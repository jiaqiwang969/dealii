include/deal.II-translator/base/time_stepping_0.txt
[0.x.0]*
 包含时间步进方法的命名空间。

* 
* [0.x.1]*
   下列Runge-Kutta方法可用。
* 

* 
* 

* 
* 

 
* 
* - 明确的方法（见[2.x.0]）。
* 

* 
* 

* 
* 

 
 

 
 

 
* 
* - FORWARD_EULER (第一顺序)
 

* 
* 

 
 

 
 

 
 

 
* 
* - RK_THIRD_ORDER (三阶 Runge-Kutta)
 

 
 

 
 

 
 

 
 

 
* 
* - SSP_THIRD_ORDER (三阶SSP Runge-Kutta)
 

 
 

 
 

 
 

 
 

 
* 
* - RK_CLASSIC_FOURTH_ORDER (经典四阶Runge-Kutta)
 

* 
 

 
 

 
* 
* - 低存储（显式）Runge-Kutta方法
 

 
* 

 
 

 
 

 
 

 
* 
* - LOW_STORAGE_RK_STAGE3_ORDER3 (三段式和三阶式)
 

* 
* 

 
 

 
 

 
 

 
* 
* - LOW_STORAGE_RK_STAGE5_ORDER4 (五级四阶)
 

* 
* 

 
 

 
 

 
 

 
* 
* - LOW_STORAGE_RK_STAGE7_ORDER4 (七级四阶)
 

* 
* 

 
 

 
 

 
 

 
* 
* - LOW_STORAGE_RK_STAGE9_ORDER5 (九级五阶)
 

* 
 

 
 

 
* 
* - 隐式方法（见[2.x.1]）。
* 

* 
* 

* 
* 

 
 

 
 

 
* 
* - BACKWARD_EULER (一阶)
 

* 
* 

 
 

 
 

 
 

 
* 
* - IMPLICIT_MIDPOINT (二阶)
 

 
 

 
 

 
 

 
 

 
* 
* - CRANK_NICOLSON (二阶)
* 

* 
* 

* 
 

 
 

 
 

 
* 
* - SDIRK_TWO_STAGES (二阶)
* 

* 
 

 
 

 
* 
* - 嵌入式显式方法（见[2.x.2]）。
* 

* 
* 

* 
* 

 
 

 
 

 
 
* - HEUN_EULER (二阶)
* 

* 
* 

 
 

 
 

 
 

 
 
* - BOGACKI_SHAMPINE (三阶)
 

 
 

 
 

 
 

 
 

 
* 
* - DOPRI (Dormand-Prince method, fifth order; this is the method used by ode45 in MATLAB)
* 

 
* 

* 
 

 
 

 
 

 
 
* - FEHLBERG (第五阶)
 

 
 

 
 

 
 

 
 

 
 
* - CASH_KARP (第五阶)  
* [0.x.2]*
     正向欧拉法，一阶。   
* [0.x.3]*
     三阶Runge-Kutta方法。   
* [0.x.4]*
     三阶强稳定（SSP）Runge-Kutta方法（SSP时间离散化在文献中也称为总变差递减（TVD）方法，见[2.x.3]）。   
* [0.x.5]*
     经典的四阶Runge-Kutta方法。   
* [0.x.6]*
     Kennedy等人的三阶方案 [2.x.4] 。它的稳定区域明显小于高阶方案，但由于只有三个阶段，它在每个阶段的工作方面非常有竞争力。   
* [0.x.7]*
     四阶的五级方案，在Kennedy等人的论文中定义 [2.x.5] 。   
* [0.x.8]*
     Tselios和Simos的论文中定义的四阶七级方案 [2.x.6] 。   
* [0.x.9]*
     肯尼迪等人的论文中定义的五阶九段式方案 [2.x.7] 。   
* [0.x.10]*
     后退欧拉法，一阶。   
* [0.x.11]*
     隐式中点法，二阶。   
* [0.x.12]*
     Crank-Nicolson方法，二阶。   
* [0.x.13]*
     两阶段SDIRK方法（"单对角隐式Runge-Kutta "的简称），二阶。   
* [0.x.14]*
     Heun方法（改进的欧拉方法），二阶。   
* [0.x.15]*
     Bogacki-Shampine方法，三阶。   
* [0.x.16]*
     Dormand-Prince方法，五阶；这是MATLAB中ODE45所使用的方法。   
* [0.x.17]*
     Fehlberg方法，五阶。   
* [0.x.18]*
     Cash-Karp方法，五阶。   
* [0.x.19]*
     无效。   
* [0.x.20]*
   使用嵌入式方法时退出evolve_one_time_step的原因。  delta_t, min_delta_t, max_delta_t.  
* [0.x.21]*
     时间步长在有效范围内。   
* [0.x.22]*
     时间步长被增加到可接受的最小时间步长。   
* [0.x.23]*
     时间步长被减少到可接受的最大时间步长。   
* [0.x.24]*
   时间步长方法的抽象类。这些方法假定方程的形式。 [2.x.8] .  
* [0.x.25]*
     虚拟解构器。   
* [0.x.26]*
     纯粹的虚拟函数。这个函数用于从时间[2.x.9]t推进到t+ [2.x.10] [2.x.11]是一个应该被整合的函数[2.x.12]的向量，输入参数是时间t和向量y，输出是此时的f值。 [2.x.13]是一个计算与隐式问题相关的雅各布式的逆函数的向量。输入参数是时间，[2.x.14] 和一个矢量。输出是函数在这一点上的值。该函数返回时间步数结束时的时间。   
* [0.x.27]*
     用来存储信息的空结构。   
* [0.x.28]*
     纯粹的虚拟函数，返回状态。   
* [0.x.29]*
   Runge-Kutta方法的基类  
* [0.x.30]*
     虚拟解构器。   
* [0.x.31]*
     用于初始化Runge-Kutta方法的纯虚拟方法。   
* [0.x.32]*
     该函数用于从时间[2.x.15]推进到t+[2.x.16] [2.x.17]是一个应被积分的函数[2.x.18]的向量，输入参数是时间t和向量y，输出是f在此点的值。 [2.x.19]是一个计算与隐式问题相关的雅各布式的逆函数的向量。输入参数是时间，[2.x.20] ，和一个向量。    输出是函数在这一点上的值。该函数返回时间步数结束时的时间。当使用Runge-Kutta方法时，[2.x.21]和@J_inverse只能包含一个元素。   
* [0.x.33]*
     纯粹的虚拟函数。这个函数用于从时间[2.x.22]t推进到t+[2.x.23] [2.x.24]是应该被积分的函数[2.x.25]，输入参数是时间t和向量y，输出是f在这一点上的值。 [2.x.26]是一个计算[2.x.27]的函数，其中[2.x.28]是身份矩阵，[2.x.29]是给定的，[2.x.30]是雅各布[2.x.31] 。输入参数是时间，[2.x.32] ，和一个矢量。输出是函数在这一点上的值。 evolve_one_time_step返回时间步数结束时的时间。   
* [0.x.34]*
     Runge-Kutta方法的阶段数。   
* [0.x.35]*
     Butcher tableau系数。   
* [0.x.36]*
     屠夫 tableau 系数。   
* [0.x.37]*
     屠夫 tableau 系数。   
* [0.x.38]*
   ExplicitRungeKutta派生自RungeKutta并实现显式方法。 
* [0.x.39]*
     默认构造函数。这个构造函数创建了一个对象，在它被使用之前，你要为它调用[2.x.33]。   
* [0.x.40]*
     构造函数。这个函数调用initialize(runge_kutta_method)。   
* [0.x.41]*
     初始化显式Runge-Kutta方法。   
* [0.x.42]*
     该函数用于从时间[2.x.34]推进到t+[2.x.35] [2.x.36]是应该被积分的函数[2.x.37]，输入参数是时间t和矢量y，输出是此时的f值。 [2.x.38]是一个计算[2.x.39]的函数，其中[2.x.40]是身份矩阵，[2.x.41]是给定的，[2.x.42]是雅各布[2.x.43] 。输入参数是时间，[2.x.44] ，和一个矢量。输出是函数在这一点上的值。 evolve_one_time_step返回时间步数结束时的时间。   
* [0.x.43]*
     这个函数用于从时间[2.x.45]推进到t+[2.x.46]这个函数类似于从RungeKutta导出的函数，但不需要id_minus_tau_J_inverse，因为它不用于显式方法。 evolve_one_time_step 返回时间步长结束时的时间。   
* [0.x.44]*
     该结构存储了所使用方法的名称。   
* [0.x.45]*
     返回当前对象的状态。   
* [0.x.46]*
     计算所需的不同阶段。   
* [0.x.47]*
     对象的状态结构。   
* [0.x.48]*
   LowStorageRungeKutta类派生于RungeKutta，实现了一类特殊的显式方法。低存储方法的主要优点是降低了内存消耗和减少了内存访问。 
* [0.x.49]*
     默认构造函数。这个构造函数创建了一个对象，在使用该对象之前，你要先调用[2.x.47]。   
* [0.x.50]*
     构造函数。这个函数调用initialize(runge_kutta_method)。   
* [0.x.51]*
     初始化显式Runge-Kutta方法。   
* [0.x.52]*
     该函数用于从时间[2.x.48]推进到t+[2.x.49] [2.x.50]是应该被积分的函数[2.x.51]，输入参数是时间t和向量y，输出是此时的f值。 [2.x.52]是一个计算[2.x.53]的函数，其中[2.x.54]是身份矩阵，[2.x.55]是给定的，[2.x.56]是雅各布[2.x.57] 。输入参数是时间，[2.x.58] ，和一个矢量。输出是函数在这一点上的值。 evolve_one_time_step返回时间步数结束时的时间。   
* [0.x.53]*
     这个函数用于从时间[2.x.59]推进到t+[2.x.60]这个函数类似于从RungeKutta导出的函数，但是不需要id_minus_tau_J_inverse，因为它不用于显式方法。 evolve_one_time_step返回时间步长结束时的时间。注意，vec_ki保存微分算子的评估，vec_ri保存微分算子应用的右手边。   
* [0.x.54]*
     获取该方案的系数。    注意这里的向量[2.x.61]不是传统意义上的布彻表的定义，而只是其中的一个子对角线。更多细节可以在[2.x.62]和其中的参考文献中找到。   
* [0.x.55]*
     该结构存储所使用的方法的名称。   
* [0.x.56]*
     返回当前对象的状态。   
* [0.x.57]*
     计算一个阶段的低存储量rk。   
* [0.x.58]*
     对象的状态结构。   
* [0.x.59]*
   该类派生于RungeKutta并实现了隐式方法。  这个类只对对角线隐式Runge-Kutta（DIRK）方法起作用。 
* [0.x.60]*
     默认构造函数。初始化(runge_kutta_method)和set_newton_solver_parameters(unsigned int,double)需要在使用该对象之前被调用。   
* [0.x.61]*
     构造函数。该函数调用initialize(runge_kutta_method)并初始化牛顿求解器的最大迭代次数和容忍度。   
* [0.x.62]*
     初始化隐式Runge-Kutta方法。   
* [0.x.63]*
     该函数用于从时间[2.x.63]推进到t+[2.x.64] [2.x.65]是应该被积分的函数[2.x.66]，输入参数是时间t和矢量y，输出是此时的f值。 [2.x.67]是一个计算[2.x.68]的函数，其中[2.x.69]是身份矩阵，[2.x.70]是给定的，[2.x.71]是雅各布[2.x.72] 。这个函数收到的输入参数是时间，[2.x.73] ，和一个向量。    输出是函数在这一点上的值。 evolve_one_time_step返回时间步数结束时的时间。   
* [0.x.64]*
     设置牛顿求解器使用的最大迭代次数和公差。   
* [0.x.65]*
     存储方法名称、牛顿迭代次数和退出牛顿求解器时的残差准则的结构。   
* [0.x.66]*
     返回当前对象的状态。   
* [0.x.67]*
     计算所需的不同阶段。   
* [0.x.68]*
     用于隐含阶段的牛顿求解器。   
* [0.x.69]*
     计算牛顿求解器所需的残差。   
* [0.x.70]*
     当使用SDIRK时，不需要计算各阶段的线性组合。因此，当这个标志为真时，线性组合被跳过。   
* [0.x.71]*
     牛顿求解器的最大迭代次数。   
* [0.x.72]*
     牛顿求解器的容忍度。   
* [0.x.73]*
     对象的状态结构。   
* [0.x.74]*
   该类派生于RungeKutta，实现了嵌入式显式方法。 
* [0.x.75]*
     默认构造函数。初始化(runge_kutta_method)和set_time_adaptation_parameters(double, double, double, double, double, double)需要在使用该对象之前被调用。   
* [0.x.76]*
     构造函数。这个函数调用initialize(runge_kutta_method)并初始化时间适应所需的参数。   
* [0.x.77]*
     解构器。   
* [0.x.78]*
     如果有必要，删除对象分配的内存。   
* [0.x.79]*
     初始化嵌入式显式Runge-Kutta方法。   
* [0.x.80]*
     该函数用于从时间[2.x.74]推进到t+[2.x.75] [2.x.76]是应该被积分的函数[2.x.77]，输入参数是时间t和矢量y，输出是此时的f值。 [2.x.78]是一个计算[2.x.79]的函数，其中[2.x.80]是身份矩阵，[2.x.81]是给定的，[2.x.82]是雅各布系数[2.x.83] 。输入参数是时间，[2.x.84] ，和一个矢量。输出是函数在这一点上的值。 evolve_one_time_step返回时间步数结束时的时间。   
* [0.x.81]*
     这个函数用于从时间[2.x.85]推进到t+[2.x.86]这个函数类似于从TimeStepping导出的函数，但不需要id_minus_tau_J_inverse，因为它不用于显式方法。 evolve_one_time_step返回时间步数结束时的时间。   
* [0.x.82]*
     设置时间适应的必要参数。   
* [0.x.83]*
     存储方法名称的结构，退出evolve_one_time_step的原因，n_iterations里面的迭代次数，对下一个时间步长的猜测，以及对误差规范的估计。   
* [0.x.84]*
     返回当前对象的状态。   
* [0.x.85]*
     计算所需的不同阶段。   
* [0.x.86]*
     这个参数是时间步长可以粗化时，时间步长所乘的系数（>1）。   
* [0.x.87]*
     该参数是当时间步长必须细化时，时间步长乘以的系数（<1）。   
* [0.x.88]*
     允许的最小的时间步长。   
* [0.x.89]*
     允许的最大的时间步长。   
* [0.x.90]*
     细化容忍度：如果误差估计值大于refine_tol，则对时间步长进行细化。   
* [0.x.91]*
     粗化公差：如果误差估计值小于coarse_tol，则对时间步长进行粗化。   
* [0.x.92]*
     如果该标志为真，最后阶段与第一阶段相同，可以保存f的一次评估。   
* [0.x.93]*
     屠夫 tableau 系数。   
* [0.x.94]*
     屠夫 tableau 系数。   
* [0.x.95]*
     如果last_same_as_first标志被设置为 "true"，最后一个阶段将被保存并作为下一个时间步骤的第一阶段重新使用。   
* [0.x.96]*
     对象的状态结构。   
* [0.x.97]

