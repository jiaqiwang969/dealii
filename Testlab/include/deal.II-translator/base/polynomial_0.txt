include/deal.II-translator/base/polynomial_0.txt
[0.x.0]*
  [2.x.0] 多项式 [2.x.1]. 

 
* [0.x.1]*
 一个命名空间，与描述1d多项式空间有关的类在其中被声明。

* 
* [0.x.2]*
   所有一维多项式的基类。一个多项式在这个类中由它的系数来表示，系数是通过构造函数或派生类来设置的。    多项式的评估有两条路径。一个是基于系数，通过Horner方案进行评估，这是一个强大的通用方案。对于根在单位区间内的高阶多项式，另一种更稳定的评估方法是通过根的乘积来提供。这种形式可用于特殊多项式，如Lagrange多项式或Legendre多项式，并与相应的构造器一起使用。为了获得这种更稳定的评估形式，必须使用拉格朗日多项式形式的根的构造器。如果做了一个改变根的操作，则表示法将被切换为系数形式。    这个类是TensorProductPolynomials类可能的模板参数的一个典型例子。 
* [0.x.3]*
     构造函数。多项式的系数作为参数传递，表示多项式[2.x.2] ，即数组的第一个元素表示常数项，第二个表示线性项，以此类推。因此这个对象所代表的多项式的度数是<tt>系数</tt>数组中的元素数减去1。   
* [0.x.4]*
     构造函数创建一个零度的多项式 [2.x.3] 。    
* [0.x.5]*
     拉格朗日多项式的构造函数和它的评估点。其思路是构造 [2.x.4] ，其中j是作为参数指定的评估点，支持点包含所有的点（包括x_j，内部将不被存储）。   
* [0.x.6]*
     默认构造函数创建一个非法对象。   
* [0.x.7]*
     返回这个多项式在给定点的值。        这个函数对所提供的多项式的形式使用最稳定的数值评估算法。如果多项式是根的乘积形式，那么评估是基于(x)形式的乘积。
* 
* - x_i), 而对于系数形式的多项式，则使用霍纳方案。   
* [0.x.8]*
     返回多项式在<tt>x</tt>点的值和导数。 <tt>values[i], i=0,...,values.size()-1</tt>包括<tt>i</tt>的导数。因此，要计算的导数的数量由传递的数组的大小决定。        这个函数使用Horner方案对系数形式的多项式或涉及根的项的乘积（如果使用该表示法）进行数值稳定评估。   
* [0.x.9]*
     返回多项式在<tt>x</tt>点的值和导数。 <tt>values[i], i=0,...,n_derivatives</tt>包括<tt>i</tt>的导数。要计算的导数数量由[2.x.5]决定，[2.x.6]必须为[2.x.7]+1个值提供足够的空间。        这个函数对于所提供的多项式的形式使用最稳定的数值评估算法。如果多项式是根的乘积形式，评估是基于形式为(x
* 
* - x_i），而Horner方案则用于系数形式的多项式。        模板类型`Number2`必须实现算术运算，如与多项式的`number`类型的加法或乘法，并且必须通过`operator=`从`number`转换过来。   
* [0.x.10]*
     多项式的程度。这是由构造函数提供的系数数所反映的程度。领先的非零系数不被单独处理。   
* [0.x.11]*
     缩放多项式的底线。 给出多项式[1.x.0]和缩放[1.x.1]，那么这个操作的结果就是多项式[1.x.2]，如[1.x.3]。        该操作是在原地进行的。   
* [0.x.12]*
     将多项式的标点移出。 给出多项式[1.x.4]和移位[1.x.5]，那么这个操作的结果就是多项式[1.x.6]，比如[1.x.7]。        模板参数允许以更高的精度计算新的系数，因为所有的计算都以<tt>number2</tt>类型进行。这可能是必要的，因为这个操作涉及大量的加法。在装有Solaris 2.8的Sun Sparc Ultra上，<tt>double</tt>和<tt>long double</tt>之间的差异并不明显，不过。        操作是就地进行的，也就是说，现在对象的系数被改变。   
* [0.x.13]*
     计算一个多项式的导数。   
* [0.x.14]*
     计算一个多项式的基数。多项式的零阶项的系数为零。   
* [0.x.15]*
     与一个标量相乘。   
* [0.x.16]*
     与另一个多项式相乘。   
* [0.x.17]*
     添加第二个多项式。   
* [0.x.18]*
     减去第二个多项式。   
* [0.x.19]*
     测试两个多项式是否相等。   
* [0.x.20]*
     打印系数。   
* [0.x.21]*
     使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据写入或读出到一个流中，以便进行序列化。   
* [0.x.22]*
     返回此对象的内存消耗估计值（以字节为单位）。   
* [0.x.23]*
     这个函数执行实际的缩放操作。   
* [0.x.24]*
     这个函数执行实际的移位    
* [0.x.25]*
     将多项式乘以一个系数。   
* [0.x.26]*
     将线性因子的乘积的多项式形式转化为标准形式， [2.x.8] 。删除所有与乘积形式有关的数据结构。   
* [0.x.27]*
     多项式的系数 [2.x.9] 。这个向量由这个类的构造函数填充，并且可以由派生类传递下去。        这个向量不能是常数，因为我们要允许复制多项式。   
* [0.x.28]*
     存储该多项式是否为拉格朗日乘积形式，即构造为乘积[2.x.10]，或者不是。   
* [0.x.29]*
     如果多项式是拉格朗日积形式，即构造为积[2.x.11]，则存储移位[2.x.12] 。   
* [0.x.30]*
     如果多项式是拉格朗日积的形式，即构造为积[2.x.13]，则存储权重c。   
* [0.x.31]*
   类产生代表n度单项式的多项式对象，即函数 [2.x.14] 。 
* [0.x.32]*
     构造函数，以单项式的度数和可选的系数作为参数。   
* [0.x.33]*
     返回一个零度到<tt>度</tt>的单项式对象的向量，然后横跨到给定度数的全部多项式空间。这个函数可以用来初始化TensorProductPolynomials和PolynomialSpace类。   
* [0.x.34]*
     构造函数所需要的。   
* [0.x.35]*
   拉格朗日多项式，其等距插值点在[0,1]。度数为<tt>n</tt>的多项式得到<tt>n+1</tt>的插值点。这些插值点按升序排列。这个顺序给每个插值点一个索引。 一个拉格朗日多项式在其 "支持点 "等于1，在所有其他插值点等于0。例如，如果度数是3，支持点是1，那么这个对象所代表的多项式是立方的，它在<tt>x=1/3</tt>点的值是1，在<tt>x=0</tt>、<tt>x=2/3</tt>和<tt>x=1</tt>点是0。所有的多项式的度数都等于<tt>度数</tt>，但它们一起跨越了度数小于或等于<tt>度数</tt>的整个多项式空间。    拉格朗日多项式的实现最高可达10度。 
* [0.x.36]*
     构造函数。取拉格朗日多项式的度数<tt>n</tt>和支持点的索引<tt>support_point</tt>。填充基类多项式的<tt>系数</tt>。   
* [0.x.37]*
     返回一个度数为<tt>degree</tt>的多项式对象的向量，然后横跨到给定度数的全部多项式空间。多项式是通过调用这个类的构造函数生成的，其度数相同，但支持点从零到<tt>度</tt>。    这个函数可以用来初始化TensorProductPolynomials和PolynomialSpace类。   
* [0.x.38]*
     计算基类Polynomial的<tt>系数</tt>。这个函数是<tt>静态的</tt>，允许在构造函数中调用。   
* [0.x.39]*
   给定一组沿实数轴的点，该函数返回用于插值这些点的所有拉格朗日多项式。多项式的数量等于点的数量，最大的度数是少一个。 
* [0.x.40]*
   任意度的Legendre多项式。构造一个学位为<tt>p</tt>的Legendre多项式, 根将由各自的点数的高斯公式和多项式的根的表示法来计算。   
*[2.x.15] 这类定义的多项式与通常所说的Legendre多项式在两个方面有所不同。(i) 该类在参考区间 [2.x.16] 上定义它们，而不是常用的区间 [2.x.17] 。(ii) 多项式的缩放方式使得它们是正交的，而不仅仅是正交的；因此，多项式的边界值不一定等于1。 
* [0.x.41]*
     度数为<tt>p</tt>的多项式的构造函数。   
* [0.x.42]*
     返回一个零度到<tt>度</tt>的Legendre多项式对象的向量，然后横跨到给定度数的全部多项式空间。这个函数可用于初始化TensorProductPolynomials和PolynomialSpace类。   
* [0.x.43]*
   <tt>[0,1]</tt>上任意程度的Lobatto多项式。    这些多项式是[0,1]上的综合Legendre多项式。前两个多项式是由 [2.x.18] 和 [2.x.19] 给出的标准线性形状函数。对于 [2.x.20] 我们使用定义 [2.x.21] ，其中 [2.x.22] 表示 [2.x.23] -次 Legendre 多项式在 [2.x.24] 。Lobatto多项式[2.x.25]构成度数[2.x.26]的多项式空间的完整基础。    以给定的索引<tt>k</tt>调用构造函数将生成索引为<tt>k</tt>的多项式。但是只有对于[2.x.27]，索引等于多项式的度数。对于<tt>k==0</tt>也会生成一个1度的多项式。    这些多项式被用于构建任意阶数的N&eacute;d&eacute;lec元素的形状函数。 
* [0.x.44]*
     度数为<tt>p</tt>的多项式的构造器。对于<tt>p==0</tt>有一个例外，见一般文档。   
* [0.x.45]*
     返回索引为<tt>0</tt>的多项式，直至<tt>度</tt>。    对于<tt>p==0</tt>有一个例外，见一般文档。   
* [0.x.46]*
     递归地计算系数。   
* [0.x.47]*
   在<tt>[0,1]</tt>上任意程度的层次多项式。    当构造一个度数为<tt>p</tt>的层次多项式时，系数将通过递归公式计算出来。 系数被存储在一个静态数据向量中，以便下次需要时可以使用。    这些分层多项式是基于Demkowicz, Oden, Rachowicz和Hardy的多项式（CMAME 77 (1989) 79-112, 第4节）。前两个多项式是由 [2.x.28] 和 [2.x.29] 给出的标准线性形状函数。对于 [2.x.30] 我们使用定义 [2.x.31] 和 [2.x.32] 。这些满足递归关系 [2.x.33] 和 [2.x.34] 。    自由度是顶点的值和中点的导数。目前，我们没有以任何方式对多项式进行缩放，尽管通过缩放可以实现对元素刚度矩阵更好的调节。    以给定的索引<tt>p</tt>调用构造函数将产生以下结果：如果<tt>p==0</tt>，那么产生的多项式是与左边顶点相关的线性函数，如果<tt>p==1</tt>是与右边顶点相关的函数。对于更高的<tt>p</tt>值，你会得到与之前所有的正交的<tt>p</tt>度的多项式。注意，对于<tt>p==0</tt>，你因此确实[1.x.8]得到一个零度的多项式，但得到一个一度的多项式。这是为了允许生成一个完整的多项式空间的基础，只需迭代给构造函数的指数。    另一方面，函数 generate_complete_basis() 创建了一个给定度数的完整基。为了与多项式程度的概念相一致，如果给定的参数是零，它不会[1.x.9]返回上述的线性多项式，而是返回一个常数多项式。 
* [0.x.48]*
     度数为<tt>p</tt>的多项式的构造函数。对于<tt>p==0</tt>有一个例外，见一般文档。   
* [0.x.49]*
     返回一个零度到<tt>degree</tt>的Hierarchical多项式对象的向量，然后横跨到给定度数的全部多项式空间。注意，如果给定的<tt>度数</tt>等于零，会有一个例外，请看这个类的一般文档。        这个函数可以用来初始化TensorProductPolynomials, AnisotropicPolynomials和PolynomialSpace类。   
* [0.x.50]*
     递归地计算系数。   
* [0.x.51]*
     为构造函数获取系数。 这样，它就可以使用Polynomial的非标准构造函数。   
* [0.x.52]*
     带有已经计算过的系数的向量。对于多项式的每一个度数，我们保留一个指向系数列表的指针；我们这样做而不是保留一个向量的向量，以便简化多线程安全编程。为了避免内存泄漏，我们使用一个唯一的指针，以便在调用全局析构器时正确释放向量的内存。   
* [0.x.53]*
   用于Hermite插值条件的多项式。    这是至少三度的多项式的集合，这样可以满足以下插值条件：多项式和它们的一阶导数在值[1.x.10]处消失。 ]=0和[1.x.11]=1，但[1.x.12]<sub>0</sub>(0)=1，[1.x.13]<sub>[1.x.14]</sub>(1)=1，[1.x.15]'<sub>2</sub>(0)=1，<1.x.16]<sub>3</sub>(1)=1。    对于三度，我们得到标准的四赫米特插值多项式，例如，见[1.x.17]。  对于更高的度数，首先通过在[1.x.18]=0和[1.x.19]=1处具有消失值和导数的四度多项式进行增强，然后通过这个四阶多项式与增阶Legendre多项式的乘积进行增强。实现方法是  
* [1.x.20]
*   
* [0.x.54]*
     多项式的构造函数，索引为<tt>p</tt>。参见类文件中关于多项式序列的定义。   
* [0.x.55]*
     返回指数<tt>0</tt>到<tt>p+1</tt>的多项式在一个度数不超过<tt>p</tt>的空间中。这里，<tt>p</tt>必须至少是3。   
* [0.x.56]*
   Hermite多项式的一个变体，在插值中的条件数比HermiteInterpolation的基础更好。    与适当的Hermite多项式相类似，这个基础在[2.x.35]处将第一个多项式[2.x.36]评估为1，在[2.x.37]处有一个零值和零导数。同样地，最后一个多项式 [2.x.38] 在 [2.x.39] 处评估为1，在 [2.x.40] 处有零值和零导数。第二个多项式[2.x.41]和倒数第二个多项式[2.x.42]分别代表[2.x.43]和[2.x.44]处的导数自由度。  它们在两个端点[2.x.45]处均为零，在另一端[2.x.46]和[2.x.47]处导数为零。与原来的Hermite多项式不同，[2.x.48]在[2.x.49]处没有零导数。额外的自由度被用来使[2.x.50]和[2.x.51]正交，对于[2.x.52]，其结果是[2.x.54]的根在[2.x.53]，[2.x.56]的根在[2.x.55]，分别。此外，这些多项式扩展到更高的度数[2.x.57]是通过在单位区间内添加额外的节点来构建的，再次确保了更好的调节。这些节点被计算为[2.x.58]的雅可比多项式的根，它与生成函数[2.x.59]的平方是正交的，具有Hermite特性。然后，这些多项式以通常的方式构建为拉格朗日多项式，其双根在 [2.x.60] 和 [2.x.61] 。例如，有了[2.x.62]，所有的[2.x.63]通过因子[2.x.65]在[2.x.64]处得到一个额外的根。综上所述，这个基础是由节点贡献主导的，但它不是一个节点的基础，因为第二个和倒数第二个多项式是非节点的，而且由于 [2.x.66] 和 [2.x.67] 中存在双节点。基函数的权重设定为：所有具有单位权重的多项式之和代表常数函数1，与Lagrange多项式类似。    基础只包含[2.x.68]的Hermite信息，但对于0到2之间的度数也可以实现。对于线性情况，实现了通常的帽子函数，而对于[2.x.69]的多项式是[2.x.70]，[2.x.71]，和[2.x.72]，根据3度的构造原理。这两个放松明显改善了质量矩阵的条件数（即内插），从下表可以看出这一点。     [2.x.73] 这个多项式继承了Hermite多项式的有利特性，在一个面上只有两个函数的值和/或导数不为零，这对不连续Galerkin方法是有利的，但却给出了更好的插值条件数，这改善了一些迭代方案的性能，如共轭梯度与点-Jacobi。这个多项式在FE_DGQHermite中使用。 
* [0.x.57]*
     在设定的度数的多项式中，索引为<tt>index</tt>的多项式的构造函数 [2.x.74] 。    
* [0.x.58]*
     返回索引为<tt>0</tt>至<tt>度+1</tt>的多项式在度数为<tt>度</tt>的空间中的情况。   
* [0.x.59] 评估由参数[2.x.76] [2.x.77] [2.x.78]指定的雅可比多项式[2.x.75]，其中[2.x.79]是雅可比多项式的程度。   
* [2.x.80] 雅可比多项式不是正交的，像通常的deal.II一样定义在单位区间[2.x.81]，而不是文献中经常使用的[2.x.82]。 [2.x.83]是评价的点。 
* [0.x.60]*
   计算单位区间[2.x.84]上给定度数的雅可比多项式的根。这些根在deal.II库中有多处使用，如Gauss-Lobatto正交公式或用于Hermite-like插值。    该算法使用牛顿算法，使用切比雪夫多项式的零点作为初始猜测。这段代码已经在α和β等于0（Legendre情况）、1（Gauss-Lobatto情况）以及2的情况下进行了测试，所以在对其他数值使用时要小心，因为牛顿迭代可能会或可能不会收敛。 
* [0.x.61]

