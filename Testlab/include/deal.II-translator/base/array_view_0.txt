include/deal.II-translator/base/array_view_0.txt
[0.x.0]*
 一个表示[2.x.0]类型的内存位置窗口的类，并将其作为一个数组来呈现。从本质上讲，这个类只不过是一个指向第一个位置的指针和一个代表数组长度的整数元素而已。内存仍然属于分配它的人，因为这个类并没有接管所有权。
* 使用这个类的好处是，你不需要传递成对的指针，而且[2.x.1]会检查你下标这个数组视图的索引是否有效。注意，只有当底层数据存储在CPU内存中时，才允许访问元素。
* 这个类可以处理对非常量和常量内存位置的视图。如果你想表示一个常数的视图，那么这个类的模板参数类型也需要是[2.x.2]。下面的代码片断给出了一个例子。

* 
* [1.x.0]
* 在任何一种情况下，访问一个视图的元素都不会改变ArrayView对象本身，因此[2.x.3]是一个[2.x.4]的const函数。这对应于这样一个概念：视图只是代表了一个，嗯，由别人拥有的内存的 "视图"。因此，访问视图中的元素会改变其他对象所管理的内存，但不会改变视图本身，这使得我们可以将[2.x.5]变成[2.x.6]成员函数。这与[2.x.7]相反，[2.x.7]管理着它所指向的内存，因此改变[2.x.8]的一个元素会改变[2.x.9]对象本身
* 
* - 因此，[2.x.10]就不是[2.x.11]。
* 

* 
* [2.x.12] 这个类与[2.x.13]类似，但后者只在C++20中开始使用。
* 

* 
* [2.x.14] 

 
* [0.x.1]*
   一个别名，表示这个容器类的 "value_type"，即它 "存储 "或指向的元素的类型。 
* [0.x.2]*
   指向数组的迭代器的一个别名。 
* [0.x.3]*
   指向数组的常数迭代器的别名。 
* [0.x.4]*
   默认的构造函数。 
* [0.x.5]*
   构造函数。     [2.x.15] starting_element 指向该对象所代表的数组的第一个元素的指针。   [2.x.16] n_elements 这个对象应该代表的内存块的长度（元素）。   
* [2.x.17] 由这些参数构建的对象不知道它所指向的对象到底有多大。因此，每当你调用[2.x.18]时，数组视图可以检查给定的索引是否在视图的范围内，但它不能检查视图是否确实是分配该范围的底层对象的有效元素范围的子集。换句话说，你需要确保这个构造函数的两个参数所指定的视图范围实际上是它所指向的数组元素的一个子集。做到这一点的适当方法是使用make_array_view()函数。 
* [0.x.6]*
   指向非[2.x.19]元素的数组视图的复制构造函数。如果当前对象将指向非[2.x.20]元素，那么这就是一个直接的复制构造函数。另一方面，如果当前类型的[2.x.21]模板参数是一个[2.x.22]限定类型，那么当前构造函数是一个转换构造函数，将非[2.x.23]视图转换为[2.x.24]视图，类似于将非[2.x.25]指针转换为[2.x.26]指针。 
* [0.x.7]*
   一个构造函数，从一个value_type对象自动创建一个视图。这样创建的视图的长度为1。 
* [0.x.8]*
   一个构造函数，从一个[2.x.27]对象中自动创建一个视图。  该视图包含了给定向量的所有元素。    当调用一个以ArrayView对象为参数的函数，并传入一个[2.x.28]时，这个隐式转换构造函数特别有用。    
* [2.x.29] 这个构造函数需要一个[2.x.30]向量的引用作为参数。    它只能用于初始化指向[2.x.31]内存位置的ArrayView对象，例如[2.x.32] 。    不能用这样的参数初始化指向非[2.x.33]内存的ArrayView对象，如[2.x.34] 。 
* [0.x.9]*
   一个构造函数，从一个[2.x.35]对象中自动创建一个视图。  该视图包含了给定向量的所有元素。    当调用一个以ArrayView对象为参数的函数，并传入一个[2.x.36]时，这个隐式转换构造函数就特别有用。    
* [2.x.37] 这个构造函数需要一个非[2.x.38]向量的引用作为参数。它可以用来初始化ArrayView对象，该对象指向[2.x.39]内存位置，例如[2.x.40]，或者指向非[2.x.41]内存，例如[2.x.42] 。 
* [0.x.10]*
   一个构造函数，为一个给定的C-style数组自动创建一个视图。  这个构造函数可以如下使用。 
* [1.x.1]
* 这样返回的对象是一个数组的视图，其大小被正确推导出来。 
* [0.x.11]*
   一个构造函数可以从一个[2.x.43]对象中自动创建一个视图。  该视图包含了给定向量的所有元素。    当调用一个以ArrayView对象为参数的函数，并传入一个[2.x.44]时，这个隐式转换构造函数特别有用。  
* [0.x.12]*
   一个构造函数，可以从一个[2.x.45]对象自动创建一个视图。  该视图包含了给定向量的所有元素。    当调用一个以ArrayView对象为参数的函数，并传入一个[2.x.46]时，这个隐式转换构造函数就特别有用。  
* [0.x.13]*
   重新初始化一个视图。     [2.x.47] starting_element 指向该对象所代表的数组的第一个元素的指针。   [2.x.48] n_elements 这个对象应该代表的内存块的长度（以元素计）。   
* [2.x.49] 由这些参数构建的对象不知道它所指向的对象到底有多大。因此，每当你调用[2.x.50]时，数组视图可以检查给定的索引是否在视图的范围内，但它不能检查视图是否确实是分配该范围的底层对象的有效元素范围的子集。换句话说，你需要确保这个构造函数的两个参数所指定的视图范围实际上是它所指向的数组元素的一个子集。做到这一点的适当方法是使用make_array_view()函数。 
* [0.x.14]*
   比较两个相同类型的ArrayView对象。如果两个对象具有相同的大小和相同的起始指针，则认为它们是相等的。  这个版本总是与const value_type进行比较。 
* [0.x.15]*
   比较两个相同类型的ArrayView对象。如果两个对象具有相同的大小和相同的起始指针，则认为它们是相等的。  这个版本总是与非const value_type进行比较。 
* [0.x.16]*
   比较两个相同类型的ArrayView对象。如果两个对象具有相同的大小和相同的起始指针，则认为它们是相等的。  这个版本总是与const value_type进行比较。 
* [0.x.17]*
   比较两个相同类型的ArrayView对象。如果两个对象具有相同的大小和相同的起始指针，则认为它们是相等的。  这个版本总是与非const value_type进行比较。 
* [0.x.18]*
   返回这个对象所代表的内存视图的大小（以元素为单位）。 
* [0.x.19]*
   返回一个指向作为元素存储的底层数组的指针。  如果该容器是空的，将返回一个nullptr。 
* [0.x.20]*
   返回一个指向数组视图开头的迭代器。 
* [0.x.21]*
   返回一个指向数组视图结束后的迭代器。 
* [0.x.22]*
   返回一个指向数组视图开始的常数迭代器。 
* [0.x.23]*
   返回一个指向数组视图结束后的常数迭代器。 
* [0.x.24]*
   返回一个指向当前对象所代表的范围内第[2.x.51]个元素的引用。    这个函数被标记为[2.x.52]，因为它不改变[2.x.53]视图对象 [2.x.54] 。但是它可能会返回一个非 [2.x.55] 内存位置的引用，这取决于类的模板类型是否是 [2.x.56] const。    只有当底层数据确实存储在CPU内存中时，才允许调用这个函数。 
* [0.x.25]*
   指向该对象所代表的内存中的位置范围的第一个元素的指针。 
* [0.x.26]*
   这个对象所代表的数组的长度。 
* [0.x.27]*
     返回在给定的迭代器范围内，通过取消迭代器得到的对象是否在内存中形成一个连续的范围。   
* [0.x.28]*
     返回在给定的迭代器范围内通过解引用迭代器得到的对象是否在内存中形成一个连续的范围。        这种对（ [2.x.57] 或非 [2.x.58] 指针的特殊化无条件地返回 [2.x.59] ，因为指针所指向的对象是连续的这一事实已经嵌入到C++的内存模型中。   
* [0.x.29]*
 创建一个ArrayView，它需要一对迭代器作为参数。ArrayView的类型是从迭代器的值类型推断出来的（例如，从两个常数迭代器创建的视图将有一个常数类型）。
* [2.x.60] 迭代器[2.x.61]和[2.x.62]必须绑定（以通常的半开放方式）一个连续的内存范围内的值。这个函数的目的是用于像 [2.x.63] 这样的容器中的迭代器，而不会在例如 [2.x.64] 中正确工作。在调试模式下，我们检查所提供的迭代器是否确实代表连续的内存。
* [2.x.65] ArrayView

* 
* [0.x.30]*
 从一对指针创建一个视图。 [2.x.66] 可以是const-qualified的。
* [2.x.67] 指针[2.x.68]和[2.x.69]必须绑定（以通常的半开放方式）一个连续的内存中的值范围。
* [2.x.70] ArrayView

* 
* [0.x.31]*
 从一个ArrayView本身创建一个视图。
* 这个函数用于[2.x.71]对ArrayView类型对象的引用。它的存在只是为了兼容的目的。
* [2.x.72] array_view 我们希望复制的ArrayView。
* [2.x.73] ArrayView

* 
* [0.x.32]*
 从ArrayView本身创建一个视图。
* 这个函数用于非 [2.x.74] ArrayView类型的对象的引用。它的存在只是为了兼容的目的。
* [2.x.75] array_view 我们希望复制的ArrayView。
* [2.x.76] ArrayView

* 
* [0.x.33]*
 为整个Tensor对象创建一个视图。这相当于用第一个元素的指针和给定参数的大小初始化一个ArrayView对象。
* 这个函数用于[2.x.77]对Tensor类型对象的引用，因为它们包含不可变的元素。因此，这个函数的返回类型是对[2.x.78]对象集合的一个视图。
* [2.x.79] 张量 我们希望有一个数组视图对象的张量。数组视图对应于[2.x.80]整个[2.x.81]对象，但条目在数组中的呈现顺序是一个实现细节，不应该被依赖。
* [2.x.82] 阵列视图

* 
* [0.x.34]*
 为整个Tensor对象创建一个视图。这相当于用一个指向第一个元素的指针和给定参数的大小初始化一个ArrayView对象。
* 这个函数用于非 [2.x.83] Tensor类型对象的引用。这种对象包含可以被写入的元素。因此，这个函数的返回类型是对一组可写对象的视图。
* [2.x.84] Tensor 我们希望有一个数组视图对象的Tensor。数组视图对应于[2.x.85]整个[2.x.86]对象，但条目在数组中的呈现顺序是一个实现细节，不应该被依赖。
* [2.x.87] ArrayView

* 
* [0.x.35]*
 为整个SymmetricTensor对象创建一个视图。这相当于用第一个元素的指针和给定参数的大小初始化一个ArrayView对象。
* 这个函数用于[2.x.88]对SymmetricTensor类型对象的引用，因为它们包含不可变的元素。因此，这个函数的返回类型是对[2.x.89]对象集合的一个视图。
* [2.x.90] tensor 我们希望有一个数组视图对象的SymmetricTensor。数组视图对应于[2.x.91]整个[2.x.92]对象，但条目在数组中的呈现顺序是一个实现细节，不应该被依赖。
* [2.x.93] 阵列视图

* 
* [0.x.36]*
 为整个SymmetricTensor对象创建一个视图。这相当于用第一个元素的指针和给定参数的大小初始化一个ArrayView对象。
* 这个函数用于对SymmetricTensor类型的对象的非[2.x.94]引用。这种对象包含可以被写入的元素。因此，这个函数的返回类型是对一组可写对象的视图。
* [2.x.95] tensor 我们希望有一个数组视图对象的SymmetricTensor。数组视图对应于[2.x.96]整个[2.x.97]对象，但条目在数组中的呈现顺序是一个实现细节，不应该被依赖。
* [2.x.98] 阵列视图

* 
* [0.x.37]*
 为整个C风格的数组创建一个视图。这相当于用一个指向第一个元素的指针和给定参数的大小初始化一个ArrayView对象。
* 产生的ArrayView是否可写，取决于ElementType是否为常量类型。
* [2.x.99] array 我们希望有一个ArrayView对象的C型数组。ArrayView对应的是[2.x.100]整个[2.x.101]向量。
* [2.x.102] ArrayView

* 
* [0.x.38]*
 为整个Vector对象创建一个视图。这相当于用一个指向第一个元素的指针和给定参数的大小初始化一个ArrayView对象。
* 这个函数用于非[2.x.103]对Vector类型对象的引用。这种对象包含可以被写入的元素。因此，这个函数的返回类型是对一组可写对象的视图。
* [2.x.104] vector 我们希望有一个数组视图对象的Vector。数组视图对应于[2.x.105] 整个[2.x.106] Vector。
* [2.x.107] 阵列视图

* 
* [0.x.39]*
 创建一个视图到整个Vector对象。这相当于用一个指向第一个元素的指针和给定参数的大小初始化一个ArrayView对象。
* 这个函数用于[2.x.108]对Vector类型对象的引用，因为它们包含不可变的元素。因此，这个函数的返回类型是对[2.x.109]对象集合的一个视图。
* [2.x.110] vector 我们希望有一个数组视图对象的Vector。该数组视图对应于[2.x.111]整个[2.x.112]向量。
* [2.x.113] 阵列视图

* 
* [0.x.40]*
 创建一个视图到整个[2.x.114]对象。这相当于用一个指向第一个元素的指针和给定参数的大小初始化一个ArrayView对象。
* 这个函数用于非 [2.x.115] 矢量类型的对象的引用。这种对象包含可以被写入的元素。因此，这个函数的返回类型是对一组可写对象的视图。
* [2.x.116] 矢量 我们希望有一个阵列视图对象的矢量。该数组视图对应于[2.x.117]整个[2.x.118]向量。
* [2.x.119] 阵列视图

* 
* [0.x.41]*
 创建一个视图到整个[2.x.120]对象。这相当于用第一个元素的指针和给定参数的大小初始化一个ArrayView对象。
* 这个函数用于[2.x.121]对矢量类型对象的引用，因为它们包含不可变的元素。因此，这个函数的返回类型是对一组[2.x.122]对象的视图。
* [2.x.123] 矢量 我们希望有一个数组视图对象的矢量。该数组视图对应于[2.x.124]整个[2.x.125]向量。
* [2.x.126] 阵列视图

* 
* [0.x.42]*
 创建一个视图到[2.x.127]对象的一部分。这相当于用一个指向[2.x.128]第三元素的指针和[2.x.129]作为视图的长度初始化ArrayView对象。
* 这个函数用于对矢量类型对象的非[2.x.130]引用。这种对象包含可以被写入的元素。因此，这个函数的返回类型是对一组可写对象的视图。
* [2.x.131] 矢量 我们希望有一个数组视图对象的矢量。 [2.x.132] starting_index 将成为该视图一部分的向量第一个元素的索引。 [2.x.133] size_of_view 新ArrayView中的元素数量。
* [2.x.134] [2.x.135] 
* [2.x.136] ArrayView

* 
* [0.x.43]*
 创建一个视图到[2.x.137]对象的一部分。这相当于用一个指向[2.x.138]第1个元素的指针和[2.x.139]作为视图的长度初始化ArrayView对象。
* 这个函数用于[2.x.140]对矢量类型对象的引用，因为它们包含不可变的元素。因此，这个函数的返回类型是对一组[2.x.141]对象的视图。
* [2.x.142] 矢量 我们希望有一个数组视图对象的矢量。 [2.x.143] starting_index 将成为该视图一部分的向量的第一个元素的索引。 [2.x.144] size_of_view 新ArrayView中的元素数量。
* [2.x.145] [2.x.146] 
* [2.x.147] ArrayView

* 
* [0.x.44]*
 为Table<2>对象的整个行创建一个视图。这相当于用一个指向给定行的第一个元素的指针初始化一个ArrayView对象，并将该行的长度作为视图的长度。
* 这个函数用于非[2.x.148]对Table类型对象的引用。这种对象包含可以被写入的元素。因此，这个函数的返回类型是对一组可写对象的视图。
* [2.x.149] table 我们希望有一个数组视图对象的表。数组视图对应于 [2.x.150] 整个 [2.x.151] 行。 [2.x.152] row 该视图所对应的表的行的索引。
* [2.x.153] 阵列视图

* 
* [0.x.45]*
 为整个Table<2>对象创建一个视图。这相当于用一个指向给定表的第一个元素的指针初始化一个ArrayView对象，并将表的条目数作为视图的长度。
* 这个函数用于非[2.x.154]的Table类型对象的引用。这种对象包含可以被写入的元素。因此，这个函数的返回类型是对一组可写对象的一个视图。
* [2.x.155] table 我们希望有一个数组视图对象的表。数组视图对应于[2.x.156]整个[2.x.157]表，但条目在数组中的呈现顺序是一个实现细节，不应该被依赖。
* [2.x.158] ArrayView

* 
* [0.x.46]*
 为整个Table<2>对象创建一个视图。这相当于用一个指向给定表的第一个元素的指针初始化一个ArrayView对象，并将表项的数量作为视图的长度。
* 这个函数用于[2.x.159]对Table类型对象的引用，因为它们包含不可变的元素。因此，这个函数的返回类型是对一组[2.x.160]对象的视图。
* [2.x.161] table 我们希望有一个数组视图对象的表。数组视图对应于[2.x.162]整个[2.x.163]表，但条目在数组中的呈现顺序是一个实现细节，不应该被依赖。
* [2.x.164] ArrayView

* 
* [0.x.47]*
 为整个LAPACKFullMatrix对象创建一个视图。这相当于用一个指向给定对象的第一个元素的指针初始化一个ArrayView对象，并将条目数作为视图的长度。
* 这个函数用于[2.x.165]对LAPACKFullMatrix类型对象的引用。这种对象包含可以被写入的元素。因此，这个函数的返回类型是对一组[2.x.166]对象的视图。
* [2.x.167] 矩阵 我们希望有一个阵列视图对象的LAPACKFullMatrix。数组视图对应于[2.x.168]整个[2.x.169]对象，但条目在数组中的呈现顺序是一个实现细节，不应该被依赖。
* [2.x.170] ArrayView

* 
* [0.x.48]*
 为整个LAPACKFullMatrix对象创建一个视图。这相当于用一个指向给定对象的第一个元素的指针初始化一个ArrayView对象，并将条目数作为视图的长度。
* 这个函数用于[2.x.171]对LAPACKFullMatrix类型对象的引用，因为它们包含不可变的元素。因此，这个函数的返回类型是对[2.x.172]对象集合的一个视图。
* [2.x.173] 矩阵 我们希望有一个阵列视图对象的LAPACKFullMatrix。阵列视图对应于[2.x.174]整个[2.x.175]对象，但条目在阵列中的呈现顺序是一个实现细节，不应依赖。
* [2.x.176] 阵列视图

* 
* [0.x.49]*
 为Table<2>对象的整个行创建一个视图。这相当于用一个指向给定行的第一个元素的指针初始化一个ArrayView对象，并将该行的长度作为视图的长度。
* 这个函数用于[2.x.177]对Table类型对象的引用，因为它们包含不可变的元素。因此，这个函数的返回类型是对一组[2.x.178]对象的视图。
* [2.x.179] table 我们希望有一个数组视图对象的表。数组视图对应于一个[2.x.180]整个[2.x.181]行。 [2.x.182] row 该视图所对应的表的行的索引。
* [2.x.183] 阵列视图

* 
* [0.x.50]*
 为Table<2>对象的一行（部分）创建一个视图。
* 这个函数用于对Table类型对象的非 [2.x.184] 引用。这种对象包含可以被写入的元素。因此，这个函数的返回类型是对一组可写对象的视图。
* [2.x.185] table 我们希望有一个数组视图对象的表。数组视图对应于 [2.x.186] 整个 [2.x.187] 行。 [2.x.188] row 该视图所对应的表的行的索引。 [2.x.189] starting_column 与该视图的第一个元素相对应的表内的列的索引。 [2.x.190] size_of_view 这个视图应该有多少个元素。这对应于该视图应该对应的当前行中的列数。
* [2.x.191] ArrayView

* 
* [0.x.51]*
 为Table<2>对象的某一行创建一个视图（一部分）。
* 这个函数用于[2.x.192]对Table类型对象的引用，因为它们包含不可变的元素。因此，这个函数的返回类型是对一组[2.x.193]对象的视图。
* [2.x.194] table 我们希望有一个数组视图对象的表。数组视图对应于一个[2.x.195]整个[2.x.196]行。 [2.x.197] row 该视图所对应的表的行的索引。 [2.x.198] starting_column 与该视图的第一个元素相对应的表内的列的索引。 [2.x.199] size_of_view 这个视图应该有多少个元素。这对应于该视图应该对应的当前行中的列数。
* [2.x.200] ArrayView

* 
* [0.x.52] 创建一个不允许修改其指向的容器的视图。如果传入的对象已经不是`const'，并且一个函数在签名中要求视图为常量内存，这就很有用。
* 这个函数返回一个`ArrayView<const T>`类型的对象，其中`T`是容器的元素类型。
* [2.x.201] ArrayView

* 
* [0.x.53]

