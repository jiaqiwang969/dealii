include/deal.II-translator/base/tensor_product_polynomials_const_0.txt
[0.x.0]*
  [2.x.0] 多项式 [2.x.1]. 

 
* [0.x.1]*
 给定的多项式和一个局部常数函数的张量乘积。这个类继承了TensorProductPolynomials的大部分功能。它的工作原理与该类类似，但为最后一个索引增加了一个常数函数。

* 
* [0.x.2]*
   访问此对象的维度，用于检查和自动设置其他类中的维度。 
* [0.x.3]*
   构造函数。<tt>pols</tt>是一个对象的向量，应该是派生的或以其他方式转换为一维多项式对象。它将被逐个元素复制到一个私有变量中。 
* [0.x.4]*
   打印<tt>tensor_polys</tt>的索引列表到<tt>out</tt>。 
* [0.x.5]*
   设置多项式的排序。需要<tt>renumber.size()==tensor_polys.n()</tt>。 存储一个<tt>renumber</tt>的副本。 
* [0.x.6]*
   给予对renumber向量的读取权限。 
* [0.x.7]*
   给予对逆向renumber向量的读取权限。 
* [0.x.8]*
   计算每个张量积多项式在<tt>unit_point</tt>的值和一、二导数。    向量的大小必须等于0或等于n()。在第一种情况下，该函数将不计算这些值。    如果你需要所有张量积多项式的值或导数，那么使用这个函数，而不是使用任何一个compute_value(), compute_grad() 或 compute_grad_grad() 函数，见下文，在所有张量积多项式上循环。 
* [0.x.9]*
   计算<tt>i</tt>第张量积多项式在<tt>unit_point</tt>的值。这里<tt>i</tt>是用张量积的编号给出的。    注意，在所有张量积多项式的循环中使用这个函数并不高效，因为这样底层（一维）多项式的每个点值都要（不必要地）计算多次。 相反，使用evaluate()函数和<tt>values.size()==</tt>n()来一次性获得所有张量多项式的点值，而且效率更高。 
* [0.x.10]*
   计算<tt>i</tt>第张量积多项式在<tt>unit_point</tt>的<tt>阶</tt>次导数。这里<tt>i</tt>是用张量积的编号给出的。    注意，在所有张量积多项式的循环中使用这个函数并不高效，因为这样一来，底层（一维）多项式的每个导数值都要（不必要地）计算多次。 相反，使用evaluate()函数，见上文，将适当的参数大小设置为n()，可以一次性得到所有张量多项式的点值，而且效率更高。     [2.x.2]顺序 导数的顺序。 
* [0.x.11]*
    [2.x.3] [2.x.4] 阶数   
* [0.x.12]*
    [2.x.5] [2.x.6]。  
* [0.x.13]*
    [2.x.7] [2.x.8]   
* [0.x.14]*
    [2.x.9] [2.x.10]   
* [0.x.15]*
   计算<tt>i</tt>第张量积多项式在<tt>unit_point</tt>的梯度。这里<tt>i</tt>是用张量积的编号给出的。    注意，在所有张量积多项式的循环中使用这个函数并不高效，因为这样一来，底层（一维）多项式的每个导数值都要（不必要地）计算多次。 相反，使用evaluate()函数，见上文，用<tt>grads.size()==</tt>n()来一次性获得所有张量多项式的点值，而且效率更高。 
* [0.x.16]*
   计算<tt>i</tt>第1个张量积多项式在<tt>unit_point</tt>的二阶导数（grad_grad）。这里<tt>i</tt>是用张量积的编号给出的。    注意，在所有张量积多项式的循环中使用这个函数并不高效，因为这样一来，底层（一维）多项式的每个导数值都要（不必要地）计算多次。 相反，使用evaluate()函数，见上文，用<tt>grad_grads.size()==</tt>n()来一次性获得所有张量多项式的点值，而且效率更高。 
* [0.x.17]*
   返回张量积多项式的数量加上常数函数。对于[1.x.0]1d多项式，这就是[1.x.1]。 
* [0.x.18]*
   返回空间的名称，即<tt>TensorProductPolynomialsConst</tt>。 
* [0.x.19]*
    [2.x.11] [2.x.12].   
* [0.x.20]*
   TensorProductPolynomials对象  
* [0.x.21]*
   用于重新排序多项式的索引图。 
* [0.x.22]*
   用于对多项式进行重新排序的索引图。 
* [0.x.23]

