include/deal.II-translator/base/aligned_vector_0.txt
[0.x.0]*
 这是一个替代[2.x.0]的类，可与VectorizedArray和派生数据类型结合使用。它分配的内存与矢量数据类型的地址对齐（以避免分段故障，当编译器假设一个矢量数组类型的变量与某些内存地址对齐时，实际上并没有遵循这些规则）。这也可以通过证明[2.x.1]与一个用户定义的分配器来实现。另一方面，编写一个自己的小向量类可以让我们用TBB实现并行的复制和移动操作，插入deal.II风格的断言，并削减一些不必要的功能。注意，由于对齐的原因，这个向量比[2.x.2]更耗费内存，所以建议只在长向量上使用这个向量。

* 
* [0.x.1]*
   声明所有容器中使用的标准类型。这些类型与<tt>C++</tt>标准库中的<tt>vector<...></tt>类中的类型平行。 
* [0.x.2]*
   空构造函数。将向量大小设置为零。 
* [0.x.3]*
   将向量大小设置为给定的大小，并用T()初始化所有元素。     [2.x.3]   
* [0.x.4]*
   解构器。 
* [0.x.5]*
   复制构造器。     [2.x.4]   
* [0.x.6]*
   移动构造器。通过窃取[2.x.5]的内容创建一个新的对齐向量。  
* [0.x.7]*
   赋值给输入向量[2.x.6] [2.x.7]。  
* [0.x.8]*
   移动赋值运算符。 
* [0.x.9]*
   改变向量的大小。如果新的大小大于先前的大小，那么新的元素将被添加到向量的末端；如果[2.x.8]是`true`，这些元素将保持未初始化（即留在未定义的状态），如果[2.x.9]是`false`，将被默认初始化。  关于[2.x.10]的定义，见[here](https://en.cppreference.com/w/cpp/types/is_trivial)。    如果新的大小小于先前的大小，那么如果[2.x.11]为`false`，最后的几个元素将被销毁，或者如果[2.x.12]为`true`，将来将被简单地忽略。    作为上述大纲的结果，这个函数的后缀"_fast "是指对于 "琐碎的 "类`T`，这个函数省略了构造函数/析构函数的调用，特别是新元素的初始化。   
* [2.x.13]这个方法只能对定义了默认构造函数的类[2.x.14]进行调用，[2.x.15]否则，编译会失败。 
* [0.x.10]*
   改变向量的大小。它保留以前可用的旧元素，并将每个新添加的元素初始化为一个默认构造的对象类型[2.x.16] 如果新的向量大小比旧的短，除非新的大小为零，否则不会立即释放内存；但是，当前对象的大小当然会被设置为要求的值。被释放元素的析构器也被调用。     [2.x.17]   
* [0.x.11]*
   改变向量的大小。它保留以前可用的旧元素，并用提供的初始化器初始化每个新添加的元素。    如果新的向量大小比旧的短，除非新的大小为零，否则不会立即释放内存；但是，当前对象的大小当然被设置为请求的值。   
* [2.x.18] 这个方法只能对定义了复制赋值操作符的类进行调用。否则，编译会失败。     [2.x.19]   
* [0.x.12]*
   为[2.x.20]元素保留内存空间。    如果参数[2.x.21]小于当前存储元素的数量（通过调用size()表示），那么这个函数根本不做任何事情。但如果参数[2.x.22]被设置为零，那么所有先前分配的内存就会被释放（这个操作就相当于直接调用clear()函数）。    为了避免过于频繁的重新分配（这涉及到数据的复制），当给定的大小大于先前分配的大小时，这个函数将占用的内存量加倍。    请注意，这个函数只改变对象可以*存储的元素数量，而不是它实际*存储的元素数量。因此，不会运行新创建的对象的构造函数或析构函数，尽管现有的元素可以被移动到一个新的位置（这涉及到在新的位置运行移动构造函数和在旧的位置运行析构函数）。 
* [0.x.13]*
   释放所有先前分配的内存，使向量处于相当于调用默认构造函数后的状态。 
* [0.x.14]*
   在向量的末端插入一个元素，使向量的大小增加一个。注意，只要之前的空间不足以容纳新的元素，分配的大小就会翻倍。 
* [0.x.15]*
   返回向量的最后一个元素（读和写访问）。 
* [0.x.16]*
   返回向量的最后一个元素（只读访问）。 
* [0.x.17]*
   在由一个元素范围给定的向量的末尾插入几个元素。 
* [0.x.18]*
   用默认构造对象的size()拷贝来填充向量。   
* [2.x.23] 与其他fill()函数不同，这个方法也可以为没有定义复制赋值操作符的类调用。     [2.x.24]   
* [0.x.19]*
   用给定输入的size()拷贝来填充向量。   
* [2.x.25] 这个方法只能对定义了复制赋值操作符的类调用。否则，编译会失败。     [2.x.26]   
* [0.x.20]*
   这个函数在MPI通信器的所有进程中复制由[2.x.27]指示的进程上发现的状态。在[2.x.28]以外的任何进程中发现的当前状态都会在这个进程中丢失。我们可以想象这个操作就像从根进程到所有其他进程对[2.x.29]的调用，尽管在实践中这个函数可能试图将数据移到每个承载MPI进程的机器上的共享内存区域，然后让这个机器上的所有MPI进程访问这个共享内存区域，而不是保留自己的副本。    这个函数的意图是将大的数组从一个进程快速交换给其他进程，而不是在所有进程上计算或创建它。这特别适用于从磁盘加载的数据
* 
*--比如说，大的数据表格
* 
* 比起让每个进程自己从磁盘上读取数据，通过读取一次，然后在MPI宇宙中的所有进程中分发，更容易处理。  具体来说，共享内存区域的使用允许在MPI宇宙中每个多核机器上只复制一次数据，而不是为每个MPI进程复制一次数据。如果今天的机器上的数据很大，每个共享内存空间可以很容易地容纳几十个MPI进程，这就可以节省大量内存。这个用例在TableBase类的文档中有所概述，因为当前的函数是从[2.x.30]中调用的。的确，这个函数的主要原理是使基于TableBase的数据表在MPI进程中共享。    这个函数并不意味着保持不同进程上的数据同步的模型，就像[2.x.31]和其他向量类所做的那样，其中存在一个由每个进程拥有的向量的某些元素的概念，可能还有从其拥有的进程镜像到其他进程的幽灵元素。相反，当前对象的元素被简单地复制到其他进程中，把这个操作看作是在所有进程中创建一组`const`AlignedVector对象，在复制操作之后不应该再被改变，这是确保向量在所有进程中保持一致的唯一方法。这尤其是因为共享内存区域的使用，在一个MPI进程上对一个向量元素的任何修改也可能导致对其他进程上可见元素的修改，假设它们位于一个共享内存节点内。   
* [2.x.32] 在MPI进程之间使用共享内存需要检测的MPI安装支持必要的操作。    这对于MPI 3.0和更高版本来说是这样的。   
* [2.x.33] 这个功能并不便宜。它需要创建所提供[2.x.34]对象的子通信器，这通常是一个昂贵的操作。同样地，共享内存空间的生成也不是一个便宜的操作。因此，当目标是在进程之间共享大的只读数据表时，这个功能主要是有意义的；例子是在启动时加载数据表，然后在程序的运行时间内使用。    在这种情况下，运行这个函数的启动成本可以随着时间的推移而摊销，而且在具有大核心数的机器上，许多MPI进程在同一台机器上运行时，不必在每个进程上存储表所带来的潜在内存节省可能是相当大的。   
* [2.x.35] 这个函数只有在数据类型`T`是 "自足 "的情况下才有意义，也就是说，如果它的所有信息都存储在其成员变量中，并且没有一个成员变量是指向内存的其他部分。这是因为如果一个类型`T`确实有指向内存其他部分的指针，那么将`T`移到一个共享内存空间不会导致其他进程访问该对象用其成员变量指针指向的数据。这些数据仍然只存在于一个进程中，并且通常在其他进程无法访问的内存区域。    因此，这个函数的通常使用情况是共享简单对象的数组，如`double's或`int's。   
* [2.x.36] 调用该函数后，不同MPI进程的对象共享一个共同的状态。这意味着某些操作变得 "集体"，即必须在所有参与的处理器上同时调用。特别是，你不能再在一个MPI进程上调用resize()、reserve()或clear()。
* 
* - 你必须在所有进程上同时这样做，因为它们必须为这些操作进行通信。如果你不这样做，你很可能会得到一个死锁，可能很难调试。推而广之，这个只集体调整大小的规则也延伸到这个函数本身。你不能连续调用它两次，因为这意味着首先除了`root_process'以外的所有进程都要扔掉他们的数据，这不是一个集体操作。一般来说，这些关于可以做什么和不可以做什么的限制，暗示了上面评论的正确性。你应该把一个当前函数被调用的AlignedVector视为`const'，在调用析构器之前，不能对其进行进一步的操作。 
* [0.x.21]*
   将给定的向量与调用的向量交换。 
* [0.x.22]*
   返回该向量是否为空，即其大小为零。 
* [0.x.23]*
   返回该向量的大小。 
* [0.x.24]*
   返回向量的容量，即这个向量在不重新分配的情况下所能容纳的大小。注意，容量（）>=大小（）。 
* [0.x.25]*
   读写访问向量中的条目[2.x.37]。 
* [0.x.26]*
   只读访问向量中的条目[2.x.38]。 
* [0.x.27]*
   返回一个指向底层数据缓冲区的指针。 
* [0.x.28]*
   返回一个指向底层数据缓冲区的常量指针。 
* [0.x.29]*
   返回一个指向数据阵列开头的读写指针。 
* [0.x.30]*
   返回一个指向数据阵列末端的读写指针。 
* [0.x.31]*
   返回一个指向数据数组开始的只读指针。 
* [0.x.32]*
   返回一个指向数据数组末端的只读指针。 
* [0.x.33]*
   返回该类中分配的内存的消耗量。如果底层类型[2.x.39]自己分配了内存，这个内存就不计算在内。 
* [0.x.34]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据写到一个流中，以便进行序列化。 
* [0.x.35]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)从流中读取此对象的数据，以便进行序列化。 
* [0.x.36]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)从流中写入和读取此对象的数据，以达到序列化的目的。 
* [0.x.37]*
   指向实际数据阵列的指针。 
* [0.x.38]*
   指向超过最后一个有效值的指针。 
* [0.x.39]*
   指向已分配内存的终点的指针。 
* [0.x.40]*
 这个命名空间定义了AlignedVector中使用的复制和设置函数。当向量中有足够的元素时，这些函数是并行操作的。

* 
* [0.x.41]*
   一个给定内存位置范围的类，在这些内存位置上调用放置-新建操作符，并在那里复制构造`T`类型的对象。    这个类是基于parallel.h中专门的for循环基类ParallelForLoop，其目的如下。当在AlignedVector上用apply_to_subranges调用一个并行for循环时，它为我们可能选择的每个不同的参数生成不同的代码（因为它是模板化的）。这就产生了大量的代码（例如，它使编译matrix_free.cc文件所需的内存增加了三倍，而且最终的对象大小也大了好几倍），这些代码是完全无用的。因此，这个类通过调用apply_to_subrange为所有可能的类型引导所有的复制命令，这使得复制操作更加简洁（感谢一个虚拟函数，其成本在这种情况下可以忽略不计）。     [2.x.40] AlignedVector  
* [0.x.42]*
     构造函数。如果有足够多的元素，就发出一个并行调用，否则就以串行方式工作。将[2.x.41]和[2.x.42]之间的半开区间的数据复制到[2.x.43]开始的数组中（通过调用带有放置new的复制构造函数）。        源数组中的元素通过放置新的复制构造函数被简单地复制出来。   
* [0.x.43]*
     这个方法在两个整数给定的子范围内将元素从源数组移动到构造函数中给定的目的地。   
* [0.x.44]*
   像AlignedVectorCopyConstruct一样，但是使用`T`的移动构造函数来创建新的对象。     [2.x.44] AlignedVector  
* [0.x.45]*
     构造器。如果有足够多的元素，发出一个并行调用，否则以串行方式工作。将数据从[2.x.45]和[2.x.46]之间的半开区间移动到从[2.x.47]开始的数组中（通过调用带有位置new的移动构造函数）。        通过调用源区间的析构器（为后续调用free做准备），数据在两个数组之间移动。   
* [0.x.46]*
     这个方法在由两个整数给定的子范围上将元素从源数移到构造函数中给定的目的地。   
* [0.x.47]*
   一个给定内存位置范围的类，调用这些内存位置的place-new操作符（如果`initialize_memory==true`）或者只是将给定的初始化器复制到这个内存位置（如果`initialize_memory==false`）。后者适合于只有琐碎构造器的类，如内置类型`double`，`int`等，以及由这类类型组成的结构。     [2.x.48] initialize_memory 决定set命令是否应该初始化内存（通过调用拷贝构造函数）或者使用拷贝赋值操作符。有必要使用模板来选择合适的操作，因为有些类可能只定义这两种操作中的一种。     [2.x.49] AlignedVector  
* [0.x.48]*
     构造函数。如果有足够多的元素，发出一个并行的调用，否则以串行方式工作。   
* [0.x.49]*
     这是在一个由两个整数给定的子范围内设置元素。   
* [0.x.50]*
   像AlignedVectorInitialize一样，但使用默认构造的对象作为初始化器。     [2.x.50] initialize_memory 设置set命令是否应该初始化内存（通过调用拷贝构造器），或者宁可使用拷贝赋值操作符。模板对于选择适当的操作是必要的，因为有些类可能只定义这两种操作中的一种。     [2.x.51] AlignedVector  
* [0.x.51]*
     构造函数。如果有足够多的元素，发出一个并行的调用，否则以串行方式工作。   
* [0.x.52]*
     这个初始化元素的子范围由两个整数给出。   
* [0.x.53]*
 关系运算符 == 用于AlignedVector
* [2.x.52] AlignedVector

* 
* [0.x.54]*
 关系运算符！= for AlignedVector
* [2.x.53] AlignedVector

* 
* [0.x.55]

