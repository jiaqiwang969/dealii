include/deal.II-translator/base/exceptions_0.txt
[0.x.0]*
 这个类是所有异常类的基类。不要直接使用它的方法和变量，因为它的接口和机制可能会被改变。而是使用<tt>DeclException</tt>宏系列创建新的异常类。
* 参见 [2.x.0] 模块以了解关于这个类的更多细节，以及从它派生的类可以做什么。
* 

* 
* [2.x.1] 

* 
* [0.x.1]*
   默认构造函数。 
* [0.x.2]*
   复制构造函数。 
* [0.x.3]*
   解构器。 
* [0.x.4]*
   拷贝操作符。这个操作符被删除，因为异常对象是不可复制的。 
* [0.x.5]*
   设置异常出现的文件名和行，以及被违反的条件和作为char指针的异常名称。这个函数还可以填充堆栈跟踪。 
* [0.x.6]*
   覆盖标准函数，返回错误的描述。 
* [0.x.7]*
   获取异常名称。 
* [0.x.8]*
   打印出错误信息的一般部分。 
* [0.x.9]*
   打印关于发生的异常的更具体的信息。  在你自己的异常类中重载这个函数。 
* [0.x.10]*
   打印一个堆栈跟踪，如果之前有记录的话，到给定的流中。 
* [0.x.11]*
   这个异常所发生的文件的名称。 
* [0.x.12]*
   该文件中的行号。 
* [0.x.13]*
   函数的名称，漂亮的打印。 
* [0.x.14]*
   被违反的条件，作为一个字符串。 
* [0.x.15]*
   异常的名称和调用序列。 
* [0.x.16]*
   回溯到问题发生的位置，如果系统支持的话。 
* [0.x.17]*
   存储在前一个变量中的堆栈跟踪帧的数量。  如果系统不支持堆栈跟踪，则为零。 
* [0.x.18]*
   包含原始堆栈跟踪的指针数组  
* [0.x.19]*
   产生c_string的内部函数。由what()调用。 
* [0.x.20]*
   一个指向将被what()打印的c_string的指针。它是由generate_message()填充的。 
* [0.x.21]*
 声明一个从ExceptionBase派生出来的没有参数的异常类。
* 

* 
* [2.x.2]这个和类似的宏名称是deal.II库中预处理程序定义的例子，它们没有用一个字符串作为前缀，这很可能使它们成为deal.II独有的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.3]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.4]为前缀，可以在所有其他deal.II的头文件中加入[2.x.5]。
* 

* 
* [2.x.6] 

* 
* [0.x.22]*
 声明一个从 ExceptionBase 派生的异常类，它可以接受一个运行时参数，但如果在你想抛出异常的地方没有给出参数，它就会简单地恢复到通过这个宏声明异常类时提供的默认文本。
* 

* 
* [2.x.7] 这个和类似的宏名称是deal.II库中预处理器定义的例子，它们没有用一个字符串作为前缀，这可能使它们在deal.II中是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.8]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.9]为前缀，可以在所有其他deal.II的头文件中加入[2.x.10]。
* 

* 
* [2.x.11] 

* 
* [0.x.23]*
 声明一个从ExceptionBase派生出来的异常类，并增加一个参数。
* 

* 
* [2.x.12] 这个和类似的宏名称是deal.II库中预处理器定义的例子，它没有用一个字符串作为前缀，这很可能使它们在deal.II中是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.13]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.14]为前缀，可以在所有其他deal.II的头文件中加入[2.x.15]。
* 

* 
* [2.x.16] 

* 
* [0.x.24]*
 声明一个从ExceptionBase派生出来的异常类，有两个额外的参数。
* 

* 
* [2.x.17]这个和类似的宏名称是deal.II库中预处理器定义的例子，它没有用一个字符串作为前缀，这很可能使它们在deal.II中是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.18]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.19]为前缀，可以在所有其他deal.II的头文件中加入[2.x.20]。
* 

* 
* [2.x.21] 

* 
* [0.x.25]*
 声明一个从ExceptionBase派生出来的异常类，有三个附加参数。
* 

* 
* [2.x.22]这个和类似的宏名称是deal.II库中预处理器定义的例子，它没有用一个字符串作为前缀，这很可能使它们在deal.II中独一无二。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.23]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.24]为前缀，可以在所有其他deal.II的头文件中加入[2.x.25]。
* 

* 
* [2.x.26] 

* 
* [0.x.26]*
 声明一个从ExceptionBase派生出来的异常类，有四个附加参数。
* 

* 
* [2.x.27]这个和类似的宏名称是deal.II库中预处理器定义的例子，它没有用一个字符串作为前缀，这很可能使它们在deal.II中是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.28]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.29]为前缀，可以在所有其他deal.II的头文件中加入[2.x.30]。
* 

* 
* [2.x.31] 

* 
* [0.x.27]*
 声明一个从ExceptionBase派生出来的异常类，有五个额外的参数。
* 

* 
* [2.x.32]这个和类似的宏名称是deal.II库中预处理器定义的例子，它没有用一个字符串作为前缀，这很可能使它们在deal.II中独一无二。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.33]这个宏，以及所有其他由deal.II定义的宏，如果没有用[2.x.34]作为前缀，可以在所有其他deal.II的头文件中加入[2.x.35]。
* 

* 
* [2.x.36] 

* 
* [0.x.28]*
 声明一个从ExceptionBase派生出来的没有参数的异常类。
* 

* 
* [2.x.37] 这个和类似的宏名称是deal.II库中预处理器定义的例子，它没有用一个字符串作为前缀，这很可能使它们在deal.II中是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.38]这个宏，以及所有其他由deal.II定义的宏，如果没有用[2.x.39]作为前缀，可以在所有其他deal.II的头文件中加入[2.x.40]。
* 

* 
* [2.x.41] 

* 
* [0.x.29]*
 声明一个从 ExceptionBase 派生的异常类，它可以接受一个运行时参数，但如果在你想抛出异常的地方没有给出参数，它就会简单地恢复到通过这个宏声明异常类时提供的默认文本。
* 

* 
* [2.x.42] 这个和类似的宏名称是deal.II库中预处理器定义的例子，它们没有用一个字符串作为前缀，这可能使它们在deal.II中是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.43]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.44]为前缀，可以在所有其他deal.II的头文件中加入[2.x.45]。
* 

* 
* [2.x.46] 

* 
* [0.x.30]*
 声明一个从ExceptionBase派生出来的异常类，并增加一个参数。
* 

* 
* [2.x.47]这个和类似的宏名称是deal.II库中预处理器定义的例子，它没有用一个字符串作为前缀，这很可能使它们在deal.II中独一无二。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.48]这个宏，以及所有其他由deal.II定义的宏，如果没有用[2.x.49]作为前缀，可以在所有其他deal.II的头文件中加入[2.x.50]。
* 

* 
* [2.x.51] 

* 
* [0.x.31]*
 声明一个从ExceptionBase派生出来的异常类，有两个额外的参数。
* 

* 
* [2.x.52]这个和类似的宏名称是deal.II库中预处理器定义的例子，它没有用一个字符串作为前缀，这很可能使它们在deal.II中是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.53]这个宏，以及所有其他由deal.II定义的宏，如果它们的前缀不是[2.x.54]，可以在所有其他deal.II的头文件中加入[2.x.55]。
* 

* 
* [2.x.56] 

* 
* [0.x.32]*
 声明一个从ExceptionBase派生出来的异常类，有三个额外的参数。
* 

* 
* [2.x.57]这个和类似的宏名称是deal.II库中预处理器定义的例子，它没有用一个字符串作为前缀，这很可能使它们在deal.II中独一无二。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.58]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.59]为前缀，可以在所有其他deal.II的头文件中加入[2.x.60]。
* 

* 
* [2.x.61] 

* 
* [0.x.33]*
 声明一个从ExceptionBase派生出来的异常类，有四个附加参数。
* 

* 
* [2.x.62]这个和类似的宏名称是deal.II库中预处理器定义的例子，它没有用一个字符串作为前缀，这很可能使它们在deal.II中是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.63]这个宏，以及所有其他由deal.II定义的宏，如果它们的前缀不是[2.x.64]，可以在所有其他deal.II的头文件中加入[2.x.65]。
* 

* 
* [2.x.66] 

* 
* [0.x.34]*
 声明一个从ExceptionBase派生出来的异常类，有五个额外的参数。
* 

* 
* [2.x.67]这个和类似的宏名称是deal.II库中预处理器定义的例子，它没有用一个字符串作为前缀，这很可能使它们在deal.II中独一无二。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.68]这个宏，以及所有其他由deal.II定义的宏，如果没有以[2.x.69]为前缀，可以在所有其他deal.II的头文件中加入[2.x.70]。
* 

* 
* [2.x.71] 

* 
* [0.x.35]*
 声明一些重复出现的异常。这样，你就可以简单地使用这些异常，而不必在你的类中本地声明它们。声明这些异常的名字空间后来被包含在全局名字空间中，由

* 
* [1.x.0]
* 
* 

* 
* [2.x.72] 

* 
* [0.x.36]*
    [2.x.73] 异常情况  
* [0.x.37]*
   表示除以0的异常情况。 
* [0.x.38]*
   如果一个数字不是有限的，就会产生异常。    这个异常应该被用来捕获不是除以零的算术运算所产生的无限数或非数的结果（使用ExcDivideByZero来处理这些结果）。    这个异常使用[2.x.74]作为它的参数，以确保我们可以对所有标量参数（实数或复数）使用它。 
* [0.x.39]*
   试图分配一个新的对象，由于缺乏可用的内存而失败。 
* [0.x.40]*
   一个内存处理程序到达一个点，所有分配的对象都应该被释放。由于这个异常被抛出，一些对象仍然被分配。 
* [0.x.41]*
   读取或写入一个文件时发生错误。 
* [0.x.42]*
   发生了一个打开命名文件的错误。    构造函数需要一个类型为[2.x.75]的单一参数来命名文件。 
* [0.x.43]*
   表示库或应用程序的一部分尚未实现的异常。在许多情况下，这只表明还没有太多需要的东西，而不是说这很难实现。因此，相当值得去看一看相应的地方，看看是否可以不费吹灰之力就能实现它。 
* [0.x.44]*
   这种异常通常表明，程序员认为在算法的某一点上必须满足的某些条件没有得到满足。这可能是由于上面的一些编程错误，由于对算法的修改没有保留这个断言，或者由于程序员所做的假设根本就不成立（也就是说，虽然这里没有错误，但却抛出了这个异常）。在库中，当我们写了某种复杂的算法，并且还不确定我们是否得到了正确的算法时，这种异常是最常用的；然后我们在算法的每个部分之后加入断言，检查一些应该成立的条件，如果不成立就抛出一个异常。    即使我们确信实现是正确的，我们通常也会留下这些断言，因为如果后来有人改变或扩展了算法，这些异常会向他们表明他们是否违反了算法中后面使用的假设。此外，有时会发生这样的情况，即算法在非常罕见的角落情况下不工作。那么这些情况迟早会被异常所困住，这样一来，算法也可以针对这些情况进行修正。 
* [0.x.45]*
   这个异常用于可能不被调用的函数（即在纯函数中），但不能被声明为纯函数，因为无论如何都要使用该类，尽管只有在使用派生类时才可能调用相应的函数。 
* [0.x.46]*
   如果发现某些对象未被初始化，就会使用这个异常。 
* [0.x.47]*
   该对象处于一个不适合该操作的状态。 
* [0.x.48]*
   如果一个功能在给定的维度上不可能实现，就会引发这个异常。主要用于抛出1D中的函数调用。    构造函数接收一个<tt>int</tt>，表示维度。 
* [0.x.49]*
   如果一个功能在给定的维度和空间维度的组合中是不可能的，就会引发这个异常。    构造函数接收两个<tt>int</tt>，表示维度和空间维度。 
* [0.x.50]*
   一个数字是零，但它不应该在这里出现。 
* [0.x.51]*
   在这个成员函数被调用之前，对象应该已经被填满了东西。 
* [0.x.52]*
   当两个对象的大小被认为是相等的，但却不相等时，就会引发这个异常。    构造函数的参数是第一个和第二个大小，都是<tt>int</tt>类型。 
* [0.x.53]*
   第一尺寸应该等于第二尺寸或第三尺寸，但它都不是。 
* [0.x.54]*
   这个异常表示一个索引不在预期范围内。  例如，可能是你试图访问一个不存在的向量的一个元素。    构造函数需要三个<tt>int</tt>参数，即 [2.x.76] [2.x.77] 违规索引 [2.x.78] 下限 [2.x.79] 上限加一 [2.x.80] 。  
* [0.x.55]*
   这个异常表示某个指数不在预期范围内。  例如，可能是你试图访问一个不存在的向量的一个元素。    构造函数需要三个参数，即 [2.x.81] [2.x.82] 违规索引 [2.x.83] 下限 [2.x.84] 上限加一 [2.x.85] 这个通用异常与ExcIndexRange不同，允许指定索引的类型。 
* [0.x.56]*
   一个数字太小。 
* [0.x.57]*
   上述ExcLowerRange的通用异常定义。 
* [0.x.58]*
   这个异常表示第一个参数应该是第二个参数的整数倍，但却不是。 
* [0.x.59]*
   如果你访问的迭代器有损坏的数据，就会抛出这个异常。  例如，可能是它所指的容器在迭代器所指的位置上没有一个入口。    通常情况下，这将是deal.II的一个内部错误，因为增量和减量运算符不应该产生一个无效的迭代器。 
* [0.x.60]*
   如果你递增或递减的迭代器已经处于最终状态，就会抛出这个异常。 
* [0.x.61]*
   这个异常是围绕<tt>DeclException0</tt>宏中的一个设计缺陷进行的：通过DeclException0声明的异常不允许指定异常发生时显示的信息，而其他异常则允许与给定参数一起显示一个文本。    当抛出这个异常时，你可以给一个消息作为[2.x.86]作为异常的参数，然后显示出来。  当然，这个参数可以在运行时构建，例如包括一个无法打开的文件的名称，或者任何其他你可能想从不同的部分组合起来的文本。 
* [0.x.62]*
   带有鬼魂元素的平行向量是只读向量。 
* [0.x.63]*
   我们的一些数值类允许使用赋值运算符<tt>=</tt>将所有条目设置为零。    在许多情况下，这个赋值运算符对参数0是有意义的[1.x.1]。在其他情况下，会抛出这种异常。 
* [0.x.64]*
   这个函数需要对LAPACK库的支持。 
* [0.x.65]*
   这个函数需要对MPI库的支持。 
* [0.x.66]*
   该函数需要对FunctionParser库的支持。 
* [0.x.67]*
   该函数需要对Assimp库的支持。 
* [0.x.68]*
   如果在CUDA内核中发生错误，会引发这个异常。    构造函数接收一个<tt>char*</tt>，即cudaGetErrorString的输出。 
* [0.x.69]*
   如果在cuSPARSE函数中发生错误，就会引发这个异常。 
* [0.x.70]*
   这个函数需要对Exodus II库的支持。 
* [0.x.71]*
   MPI错误的异常。这个异常只有在[2.x.87]编译时支持MPI时才会被定义。这个异常应该和[2.x.88]一起使用，以检查MPI函数的错误代码。比如说。 
* [1.x.2]
* 或者，使用方便的宏 [2.x.89] 。 
* [1.x.3]
* 如果断言失败，那么错误代码将被用于利用[2.x.90]函数向屏幕打印一个有用的信息。   
* [2.x.91]   
* [0.x.72]*
   用于ExodusII错误的例外。只有在[2.x.92]编译时支持SEACAS的情况下才会定义这个异常，SEACAS可以通过Trilinos获得。这个函数应该和便利宏AssertThrowExodusII一起使用。   
* [2.x.93]   
* [0.x.73]*
     构造器。         [2.x.94] error_code 由ExodusII函数返回的错误代码。   
* [0.x.74]*
     打印错误的描述到给定的流中。   
* [0.x.75]*
     存储错误代码。   
* [0.x.76]*
 在这个命名空间中，与Assert和AssertThrow机制有关的函数被声明。
* 

* 
* [2.x.95] 

* 
* [0.x.77]*
     将这个变量设置为false将禁用deal.II的异常机制来中止问题。Assert()宏将抛出异常，而AssertNothrow()宏将只打印错误信息。这个变量不应该被直接改变。使用 disable_abort_on_exception() 来代替。   
* [0.x.78]*
   设置一个字符串，在表示触发<tt>Assert</tt>语句的信息输出时打印。这个字符串在通常的输出之外被打印出来，可能会指示出一些除非我们使用调试器否则不容易得到的信息。例如，对于集群计算机上的分布式程序，所有进程的输出都被重定向到同一个控制台窗口。在这种情况下，将程序运行的主机名称作为额外的名称是很方便的，这样就可以看到异常发生在程序的哪个实例中。    参数所指向的字符串是复制的，所以在调用这个函数后不需要再存储。    以前设置的附加输出被给这个函数的参数所取代。     [2.x.96] 异常情况  
* [0.x.79]*
   当异常发生时，调用此函数可以禁止与其他输出一起打印堆栈跟踪记录。大多数时候，你会想看到这样的堆栈跟踪；然而，如果想在不同的机器和系统中比较程序的输出，抑制它是很有用的，因为堆栈跟踪显示的内存地址和库名/路径取决于机器的确切设置。     [2.x.97] 异常情况  
* [0.x.80]*
   当使用Assert()宏创建一个异常时，调用这个函数可以关闭对[2.x.98]的使用。取而代之的是，异常将使用'throw'抛出，因此如果需要的话，它可以被捕获。一般来说，当Assert()被调用时，你想中止程序的执行，但如果你想记录所有创建的异常，或者你想测试一个断言是否正常工作，则需要关闭它。例如，在回归测试中就是这样做的。请注意，一些致命的错误仍然会调用abort()，例如，在异常处理过程中捕获的异常。     [2.x.99] 异常现象  
* [0.x.81]*
   这个命名空间中的函数与Assert和AssertThrow机制有关，但仅用于内部目的，不能在异常处理和抛出机制之外使用。   
* [2.x.100]   
* [0.x.82]*
     通过打印[2.x.101]提供的错误信息并调用[2.x.102]中止程序。    
* [0.x.83]*
     一个描述如何处理issue_error_noreturn中的异常的枚举。   
* [0.x.84]*
       通过调用[2.x.103]中止程序，除非[2.x.104]已经被调用：在这种情况下，程序将抛出一个异常。     
* [0.x.85]*
       正常抛出异常。     
* [0.x.86]*
     这个例程为<tt>Assert</tt>和<tt>AssertThrow</tt>宏中使用的异常生成机制做主要工作：正如其名称所暗示的，这个函数要么以抛出一个异常结束（如果[2.x.105 ]是throw_on_exception，或者[2.x.106]是try_abort_exception且[2.x.107]是false），或者调用<tt>abort</tt>（如果[2.x.108]是try_abort_exception且[2.x.109]是true）。        实际的异常对象（最后一个参数）通常是一个在原地创建的未命名的对象；因为我们修改了它，所以我们不能通过常量引用来获取它，而且临时变量不会与非常量引用绑定。    所以要用一个模板化的类型来取它的值（=copy it），以避免切分
* 

* 
* 

* 
* 

 
 

 
 

 
* 
* - 反正对性能的影响是相当小的。         [2.x.110]     
* [0.x.87]*
     内部函数，完成issue_error_nothrow的工作。   
* [0.x.88]*
     异常生成机制，以防我们必须不抛出。         [2.x.111]         
* [2.x.112]这个函数是用一个模板定义的，原因与issue_error_noreturn()相同。   
* [0.x.89]*
     返回一个给定错误代码的字符串。这类似于cudaGetErrorString函数，但在cuSPARSE中没有相应的函数。   
* [0.x.90]*
     返回一个给定错误代码的字符串。这类似于cudaGetErrorString函数，但在cuSOLVER中没有相应的函数。   
* [0.x.91]*
 一个宏，作为调试模式错误检查的异常机制的主要程序。它断言某个条件得到满足，否则会发出错误并中止程序。
* 更详细的描述可以在[2.x.113]模块中找到。它在 [2.x.114] 和 [2.x.115] 中首次使用。更多信息也请参见<tt>ExceptionBase</tt>类。
* 

* 
* [2.x.116] 仅在DEBUG模式下活动
* 

* 
* [2.x.117] 这个和类似的宏名称是deal.II库中预处理程序定义的例子，它们没有用一个字符串作为前缀，这很可能使它们在deal.II中是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.118]这个宏，以及所有其他由deal.II定义的宏，如果没有以[2.x.119]为前缀，可以在所有其他deal.II的头文件中包括[2.x.120]。
* 

* 
* [2.x.121] 

* 
* [0.x.92]*
 上面的<tt>Assert</tt>宏的一个变种，只要不调用disable_abort_on_exception，就会表现出相同的运行时行为。
* 然而，如果disable_abort_on_exception被调用，这个宏只是打印出将被抛出的异常到deallog，并继续正常运行而不抛出异常。
* 更详细的描述可以在[2.x.122]模块中找到，在页面底部关于角落案例的讨论中。
* 

* 
* [2.x.123] 这个和类似的宏名称是deal.II库中预处理器定义的例子，这些定义的前缀不是一个可能使它们对deal.II独一无二的字符串。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.124]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.125]为前缀，可以在所有其他deal.II的头文件中加入[2.x.126]。
* 

* 
* [2.x.127] 仅在DEBUG模式下有效。

* 
* [2.x.128] 

* 
* [0.x.93]*
 一个宏，作为动态错误检查的异常机制的主要程序。它断言某个条件得到满足，否则通过C++ [2.x.129] 机制抛出一个异常。这个异常可以通过[2.x.130]子句来捕获，如[2.x.131]和以下所有教程程序所示。
* 更详细的描述可以在[2.x.132]模块中找到。它在 [2.x.133] 和 [2.x.134] 中首次使用。更多信息也请参见<tt>ExceptionBase</tt>类。
* 

* 
* [2.x.135] 这个和类似的宏名称是deal.II库中预处理器定义的例子，这些定义没有用一个可能使它们对deal.II唯一的字符串作为前缀。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.136]这个宏，以及所有其他由deal.II定义的宏，如果没有用[2.x.137]作为前缀，可以在所有其他deal.II的头文件中加入[2.x.138]。
* 

* 
* [2.x.139] 在DEBUG和RELEASE模式下都有效。

* 
* [2.x.140] 

* 
* [0.x.94]*
 尺寸不匹配的特殊断言。
* 因为这被经常使用，并且总是重复参数，所以我们为ExcDimensionMismatch引入了这个特殊的断言，以保持用户代码的简短。
* 

* 
* [2.x.141] 这个和类似的宏名称是deal.II库中预处理器定义的例子，这些定义没有用一个可能使它们对deal.II唯一的字符串作前缀。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.142]这个宏，以及所有其他由deal.II定义的宏，只要在所有其他deal.II的头文件中包含[2.x.144]，就可以不以[2.x.143]为前缀了。
* 

* 
* [2.x.145] 

 
* [0.x.95]*
 一个测试<tt>vec</tt>是否有大小<tt>dim1</tt>的断言，并且向量的每个条目本身是一个大小为<tt>dim2</tt>的数组。
* 

* 
* [2.x.146] 这个和类似的宏名称是deal.II库中预处理程序定义的例子，这些定义的前缀不是一个字符串，而这个字符串很可能使它们成为deal.II的唯一。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.147]这个宏，以及所有其他由deal.II定义的宏，如果没有前缀[2.x.148]，可以在所有其他deal.II的头文件中加入头文件[2.x.149]。
* 

* 
* [2.x.150] 

* 
* [0.x.96]*
 一个测试给定索引是否在半开范围内的断言 [2.x.151] 。如果断言失败，它会抛出一个异常对象 [2.x.152] 。
* 

* 
* [2.x.153] 这个和类似的宏名称是deal.II库中预处理器定义的例子，这些定义的前缀不是一个可能使它们在deal.II中独一无二的字符串。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.154]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.155]为前缀，可以在所有其他deal.II的头文件中加入[2.x.156]。
* 

* 
* [2.x.157] 

 
* [0.x.97]*
 一个检查一个数字是否是有限的断言。我们明确地将这个数投到[2.x.158]中，以匹配异常的签名（关于为什么使用[2.x.159]的解释，见那里），并满足[2.x.160]没有隐含转换的事实。
* 

* 
* [2.x.161] 这个和类似的宏名称是deal.II库中预处理程序定义的例子，这些定义的前缀不是一个可能使它们对deal.II唯一的字符串。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.162]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.163]为前缀，可以在所有其他deal.II的头文件中加入[2.x.164]。
* 

* 
* [2.x.165] 

* 
* [0.x.98]*
 一个断言，检查MPI函数返回的错误代码是否等于 [2.x.166] 。如果检查失败，那么就会抛出一个ExcMPI类型的异常，给定的错误代码作为参数。
* 

* 
* [2.x.167] 这个和类似的宏名称是deal.II库中预处理器定义的例子，这些定义的前缀不是一个可能使它们对deal.II独一无二的字符串。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.168]这个宏，以及所有其他由deal.II定义的宏，如果没有[2.x.169]的前缀，可以在所有其他deal.II的头文件中包括[2.x.170]。
* 

* 
* [2.x.171] 只有在deal.II被编译为MPI时才有效。

* 
* [2.x.172] 

 
* [0.x.99]*
 一个断言，检查调用CUDA例程产生的错误代码是否等于cudaSuccess。
* 

* 
* [2.x.173]这个和类似的宏名称是deal.II库中预处理程序定义的例子，这些定义没有用一个字符串作为前缀，而这个字符串很可能使它们成为deal.II的唯一。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.174]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.175]为前缀，可以在所有其他deal.II的头文件中加入[2.x.176]。
* 

* 
* [2.x.177] 

* 
* [0.x.100]*
 AssertCuda的非抛出式等价物。
* 

* 
* [2.x.178] 这个和类似的宏名称是deal.II库中预处理程序定义的例子，这些定义没有用一个字符串作为前缀，这很可能使它们在deal.II中是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.179]这个宏，以及所有其他由deal.II定义的宏，如果不以[2.x.180]为前缀，可以在所有其他deal.II的头文件中加入[2.x.181]。
* 

* 
* [2.x.182] 

 
* [0.x.101]*
 一个断言，检查内核是否被成功启动和执行。
* 

* 
* [2.x.183] 这个和类似的宏名称是deal.II库中预处理程序定义的例子，这些定义没有用一个字符串作为前缀，这很可能使它们对deal.II来说是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.184]这个宏，以及所有其他由deal.II定义的宏，如果没有[2.x.185]的前缀，可以在所有其他deal.II的头文件中加入[2.x.186]。
* 

* 
* [2.x.187] 

* 
* [0.x.102]*
 一个断言，检查调用cuSPARSE例程产生的错误代码是否等于CUSPARSE_STATUS_SUCCESS。
* 

* 
* [2.x.188]这个和类似的宏名称是deal.II库中预处理器定义的例子，这些定义的前缀不是一个可能使它们对deal.II唯一的字符串。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.189]这个宏，以及所有其他由deal.II定义的宏，如果它们的前缀不是[2.x.190]，可以在所有其他deal.II的头文件中加入[2.x.191]。
* 

* 
* [2.x.192] 

* 
* [0.x.103]*
 AssertCusparse的非抛出式等价物。
* 

* 
* [2.x.193]这个和类似的宏名称是deal.II库中预处理程序定义的例子，这些定义没有用一个字符串作为前缀，这很可能使它们在deal.II中是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.194]这个宏，以及所有其他由deal.II定义的宏，如果没有用[2.x.195]作为前缀，可以在所有其他deal.II的头文件中加入[2.x.196]。
* 

* 
* [2.x.197] 

* 
* [0.x.104]*
 一个断言，检查调用cuSOLVER例程产生的错误代码是否等于CUSOLVER_STATUS_SUCCESS。
* 

* 
* [2.x.198]这个和类似的宏名称是deal.II库中预处理器定义的例子，它没有用一个字符串作为前缀，而这个字符串可能使它们在deal.II中是独一无二的。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.199]这个宏，以及所有其他由deal.II定义的宏，如果没有[2.x.200]的前缀，可以在所有其他deal.II的头文件中加入[2.x.201]。
* 

* 
* [2.x.202] 

* 
* [0.x.105]*
 断言，检查调用ExodusII例程产生的错误代码是否等于EX_NOERR（为零）。
* 

* 
* [2.x.203]这个和类似的宏名称是deal.II库中预处理器定义的例子，这些定义没有用一个可能使它们对deal.II唯一的字符串作前缀。因此，你的代码与其他库的接口有可能定义相同的名称，其结果将是名称冲突（见https://en.wikipedia.org/wiki/Name_collision）。我们可以[2.x.204]这个宏，以及所有其他由deal.II定义的宏，如果没有[2.x.205]的前缀，可以在所有其他deal.II的头文件中加入[2.x.206]。
* 

* 
* [2.x.207] 

* 
* [0.x.106]

