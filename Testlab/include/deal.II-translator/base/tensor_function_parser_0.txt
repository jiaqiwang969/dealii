include/deal.II-translator/base/tensor_function_parser_0.txt
[0.x.0]*
 这个类实现了一个张量函数对象，它通过解析描述这个函数的字符串来获得其值。它是muparser库的一个封装类（见http://muparser.beltoforion.de/）。这个类本质上是FunctionParser类的一个扩展，用来读入一个TensorFunction。该类读入一个长度为dim<sup>rank</sup>的表达式（用分号隔开），其中张量函数的分量按照C++惯例填充（最快的索引是最右边的那个）。
* 

* 
* [2.x.0] 与FunctionParser类相比，TensorFunctionParser类不支持自动区分。
* 该类使用的一个最小的例子是。

* 
* [1.x.0]
* 
* 也请看FunctionParser类的文档。
* 这个类重载了TensorFunction基类的虚拟方法value()和value_list()，其表达式的字节编译版本被赋予initialize()方法。请注意，除非你首先调用initialize()方法，该方法接受函数的文本描述作为参数（除其他外），否则该类将无法工作。
* 描述一个函数的语法遵循通常的编程惯例，在底层muparser库的主页上有详细的解释：http://muparser.beltoforion.de/ 。
* 

* 矢量值函数可以使用字符串来声明，其中函数成分用分号隔开，或者使用字符串的矢量，每个定义一个矢量成分。
* 

* 

* 
* [2.x.1] 

 
* [0.x.1]*
   标准构造函数。只设置初始时间。这个对象在使用前需要用initialize()方法进行初始化。如果在调用initialize()方法之前试图使用这个函数，那么就会产生一个异常。 
* [0.x.2]*
   解析函数的构造器。这个对象在使用前需要用initialize()方法进行初始化。如果在调用initialize()方法之前试图使用这个函数，那么就会抛出一个异常。  接收一个分号分隔的表达式列表（张量函数的每个分量一个），一个可选的逗号分隔的常量列表。 
* [0.x.3]*
   复制构造函数。这种类型的对象不能被复制，因此这个构造函数被删除。 
* [0.x.4]*
   移动构造函数。该类型的对象不能被移动，因此该构造函数被删除。 
* [0.x.5]*
   解构器。 
* [0.x.6]*
   复制操作符。该类型的对象不能被复制，因此该操作符被删除。 
* [0.x.7]*
   移动操作符。此类型的对象不能被移动，因此该操作符被删除。 
* [0.x.8]*
   常量图的类型。由initialize()方法使用。 
* [0.x.9]*
   初始化张量函数。 这个方法接受以下参数。     [2.x.2] vars 一个包含变量的字符串，这些变量将被待评估的表达式使用。注意，变量可以有任何名字（当然与上面定义的函数名不同！），但顺序很重要。第一个变量将对应于函数被评估的点的第一个分量，第二个变量对应于第二个分量，以此类推。如果这个函数也是依赖于时间的，那么有必要通过将[2.x.3]参数设置为真来指定它。 如果这里指定的变量数量与dim（如果这个函数不依赖于时间）或与dim+1（如果它依赖于时间）不同，就会出现异常。     [2.x.4] expressions 一个字符串向量，包含将被内部解析器（TensorFunctionParser）字节编译的表达式。请注意，这个向量的大小必须与构造函数中声明的TensorFunctionParser的组件数量完全匹配。如果不是这样，就会抛出一个异常。     [2.x.5] 常量 一个常量图，用于传递我们想在表达式中指定的任何必要常量（在上面的例子中是数字pi）。当且仅当一个表达式只包含定义的变量和定义的常量（除了上面指定的函数之外）时，它才是有效的。如果给定的常量的名称是无效的（例如：[2.x.6]），就会抛出一个异常。     [2.x.7] time_dependent 如果这是一个依赖于时间的函数，那么在[1.x.1]中声明的最后一个变量被假定为时间变量，并且在评估该函数时使用this->get_time()来初始化它。当然，在这种情况下，initialize()方法解析的变量数量是dim+1。这个参数的值默认为false，也就是说，不考虑时间。 
* [0.x.10]*
   初始化函数。和上面一样，但接受一个字符串，而不是一个字符串的向量。如果这是一个向量值的函数，它的组成部分应该用分号来分隔。如果这个方法被调用，而成功解析的组件数与基函数的组件数不一致，就会产生一个异常。 
* [0.x.11]*
   一个返回变量默认名称的函数，用于initialize()函数的第一个参数：它在1d中返回 "x"，在2d中返回 "x,y"，在3d中返回 "x,y,z"。 
* [0.x.12]*
   返回张量函数在给定点的值。 
* [0.x.13]*
   返回张量函数在给定点的值。 
* [0.x.14]*
   返回一个函数表达式的数组（每个组件一个），用于初始化这个函数。 
* [0.x.15]*
    [2.x.8] 异常情况[2.x.9]。  
* [0.x.16]*
   每个线程的变量的位置  
* [0.x.17]*
   每个线程的muParser对象（每个组件也有一个）。我们存储的是unique_ptr，这样我们就不需要在这个头中包含[2.x.10]的定义。 
* [0.x.18]*
   一个数组来记录所有的常量，需要在每个线程中初始化tfp。 
* [0.x.19]*
   一个用于记录变量名称的数组，需要在每个线程中初始化tfp。 
* [0.x.20]*
   在当前线程中初始化tfp和vars。这个函数在每个线程中只能被调用一次。一个线程可以通过测试'tfp.get().size()==0'（未初始化）或>0（已初始化）来测试该函数是否已经被调用。 
* [0.x.21]*
   一个函数表达式的数组（每个组件一个），需要在每个线程中初始化tfp。 
* [0.x.22]*
   可用性的状态。这个变量在每次函数被调用评估时被检查。它在initialize()方法中被设置为true。 
* [0.x.23]*
   变量的数量。如果这也是一个时间的函数，那么变量的数量是dim+1，否则就是dim。如果这是一个依赖于时间的函数，那么时间应该是最后一个变量。如果#n_vars与initialize()方法解析的变量数量不一致，则会抛出一个异常。 
* [0.x.24]*
   组件的数量等于dim<sup>rank</sup>。 
* [0.x.25]

