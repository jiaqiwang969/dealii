include/deal.II-translator/base/discrete_time_0.txt
[0.x.0]*
 这个类提供了一种方法来跟踪随时间变化的模拟的时间。它管理着从开始时间[2.x.0]到结束时间[2.x.1]的向前迈进。它还允许在仿真过程中调整时间步长。该类提供了必要的接口，可以被纳入任何时间依赖性的仿真。这个类的用法在 [2.x.2] 和 [2.x.3] 中演示。
* 该类提供了一些保证在任何时候都是真实的不变量。
* 当前的模拟时间是在开始时间和结束时间之间的封闭区间内（ [2.x.4] ）。每当时间递增时，步长是正的（[2.x.5]）。  换句话说，时间以严格的升序前进（ [2.x.6] ）。
* 这个类所遵循的模型是，人们通过构造函数或使用set_desired_next_step_size()函数设置期望的*时间步长。这个步长将用于接下来所有对advance_time()函数的调用，但在模拟结束时可以稍作调整，以确保模拟时间与结束时间完全一致。这种调整对于以下原因是很有用的。
* 假设你通过使用`for`循环来循环所有的时间步骤

* 
* [1.x.0]
* 或者，如果你更喜欢这种方式，可以使用等效的 "while "循环。

* 
* [1.x.1]
* 
* 在上面的例子中，时间从[2.x.7]开始，直到[2.x.8] 。假设时间步数 [2.x.9] 在循环内没有被修改，时间从 [2.x.10] 推进到 [2.x.11] , [2.x.12] , [2.x.13] ，最后它在 [2.x.14] 到达结束时间。在这里，最后的步长需要从它的理想值0.3减少到[2.x.15]，以确保我们正好在指定的结束时间完成模拟。事实上，你应该假设不仅最后的时间步长可以调整，而且以前的时间步长也可以调整。
* 
* - 例如，这个类可能会擅自将时间步长的减少分散到几个时间步长中，并将时间从[2.x.16]，增加到[2.x.17]，[2.x.18]，[2.x.19]，最后到[2.x.20]，以避免时间步长从一个步骤到另一个步骤的变化太大。
* 另一种需要调整时间步长的情况（这次是调整为稍大的数值）是如果时间增量刚好低于最终时间。例如，想象一下，与上述情况类似，但结束时间不同。

* 
* [1.x.2]
* 这里，从[2.x.21]到[2.x.22]的时间步长刚好低于最终时间[2.x.23] 。而不是用一个长度为[2.x.24]的非常小的步骤来跟进，该类人将最后的时间步骤（或最后的时间步骤）稍微拉长，以达到所需的结束时间。
* 上面的例子清楚地表明，给这个类的时间步长只是一个期望的*步长。你可以使用get_next_step_size()函数查询实际的时间步长。
* 

* # ### 时间步长的细节
* 因为在我们的模拟中，时间是以离散的方式向前推进的，所以我们需要讨论如何增加时间。在时间步进过程中，我们每一步都会进入两个独立的交替状态。
**快照**阶段（*当前**阶段，*一致**阶段
   阶段）。) 在这部分算法中，我们处于[2.x.25]，所有的模拟量（位移、应变、温度等）都是[2.x.26]的最新情况。在这个阶段，当前时间*是指[2.x.27]，下一个时间*是指[2.x.28]，上一个时间*是指[2.x.29]。其他有用的符号量是下一个*时间步长 [2.x.30] 和上一个*时间步长 [2.x.31] 。在这个阶段，使用用户代码中的打印命令生成文本输出是一个完美的场合。此外，还可以在这里准备后处理输出，然后可以通过可视化程序如 "Tecplot"、"Paraview "和 "VisIt "查看。此外，在快照阶段，代码可以评估前一个步骤的质量，并决定是否要增加或减少时间步长。在这里可以通过调用set_desired_next_step_size()来修改下一个时间步骤的步骤大小。更新**阶段（*过渡**阶段，*不一致**阶段
   阶段）。) 在这部分程序中，模拟的内部状态被从[2.x.32]更新到[2.x.33] 。所有的变量都需要逐一更新，步数被增加，时间被增加[2.x.34]，时间积分算法被用来更新其他模拟量。在这个阶段的中间，一些变量已经被更新到[2.x.35]，但其他变量仍然代表它们在[2.x.36]的值。因此，我们把这个阶段称为不一致阶段，要求在这个阶段内不发生与状态变量相关的后处理输出。状态变量，即那些与时间、解场和任何内部变量有关的变量，并不是同步的，然后逐一得到更新。一般来说，更新变量的顺序是任意的，但如果它们之间存在相互依赖关系，就应该注意一些。例如，如果某个变量如[2.x.37]依赖于另一个变量如[2.x.38]的计算，那么[2.x.39]必须在[2.x.40]被更新之前被更新。
* 问题是，在更新状态量之前，时间是否应该被递增。存在多种可能性，取决于程序和配方的要求，可能还有程序员的偏好。  时间在*其余的更新之前被递增。在这种情况下，即使时间被递增到[2.x.41]，也不是所有变量都被更新。在这个更新阶段，[2.x.42]等于previous*时间步长。Previous*意味着它是指之前执行的`advance_time()`命令的[2.x.43]。在下面的示例代码中，我们假设`a`和`b`是两个需要在这个时间步长中更新的状态变量。   
* [1.x.3]
* 这里，代码开始时是一致的状态，但是一旦调用advance_time()，时间变量、`a`和`b`就不再相互一致，直到最后一条语句之后。在这一点上，这些变量又都是一致的。  在*所有变量已经更新为[2.x.46]之后，时间从[2.x.44]递增到[2.x.45] 。在更新阶段，[2.x.47]被表示为下一个*时间步长。下一个*意味着[2.x.48]的步长对应于随后发生的`advance_time()`命令。   
* [1.x.4]
*时间是在其他更新的中间递增的。在这种情况下，[2.x.49]将对应xt*或previous*，取决于它是在调用`advance_time()'之前还是之后使用。   
* [1.x.5]
* 
* 需要注意的是，在更新阶段，[2.x.50]是指*下一个**或*上一个**时间步长，这取决于是否已经调用了advance_time()。当前*时间步长的概念定义不明确。事实上，在更新阶段，每个变量的定义都取决于它是否已经被更新，因此被称为*不一致的阶段**。
* 下面的代码片段显示了在一个完整的时间依赖性仿真的背景下，快照阶段和更新阶段的代码部分。这段代码遵循了教程实例中的编码惯例。请注意，尽管这个例子是以 "for "循环的格式写的，但它也可以等同于写成 "while "或 "do while "循环（如[2.x.51]所示）。

* 
* [1.x.6]
* [2.x.52]中的`run()`函数显示了一个非常类似的例子，其中对advance_time()的调用结束了更新阶段，随后用当时的时间生成了图形输出。

* 
* [0.x.1]*
   构造函数。     [2.x.53] start_time 仿真开始时的时间。     [2.x.54] end_time 仿真结束时的时间。     [2.x.55] desired_start_step_size 用于第一步时间递增的预期步长。不保证这个值会被实际用作第一步的大小，这一点在介绍中已经讨论过。     [2.x.56] [2.x.57] 必须为非负数。   
* [2.x.58] [2.x.59] 是一个可选的参数。如果没有提供或指定为零，表明时间步长的所需尺寸将在代码中的不同位置计算。在这种情况下，创建的对象不能增加时间，直到通过调用set_desired_next_step_size()改变步长大小。 
* [0.x.2]*
   返回当前时间。 
* [0.x.3]*
   返回如果我们将时间提前一步，将达到的下一个时间。   
* [2.x.60]如果模拟到了结束时间，该方法返回结束时间。 
* [0.x.4]*
   返回我们上次调用`advance_time()`之前的时间。   
* [2.x.61]如果模拟处于开始时间，此方法返回开始时间。 
* [0.x.5]*
   返回开始时间。 
* [0.x.6]*
   返回时间区间的结束时间。  最后的时间步骤正好在这一点上结束。这个精确的浮点数是非常重要的，因为它允许我们将当前时间与结束时间进行等价比较，并决定我们是否已经到达了模拟的终点。 
* [0.x.7]*
   返回是否还没有发生任何步骤。 
* [0.x.8]*
   返回时间是否已经到达结束时间。 
* [0.x.9]*
   返回从当前时间步长到下一个时间步长的大小。正如在类的介绍中所讨论的，这是实际的*时间步长，可能与在构造函数中或通过set_desired_next_step_size()函数设置的desired*时间步长不同。   
* [2.x.62]如果仿真处于结束时间，该方法返回0。 
* [0.x.10]*
   返回上一步的步长。   
* [2.x.63] 如果仿真处于开始时间，该方法返回0。 
* [0.x.11]*
   返回仿真时间被增加的次数。  当仿真处于开始时间时，返回0。 
* [0.x.12]*
   设置下一个时间步长的期望*值。通过调用这个方法，我们表明下次调用advance_time()时，我们希望用[2.x.64]来推进仿真时间。  但是，如果步长过大，导致下一次仿真时间超过结束时间，步长就会被截断。  此外，如果步长使下一次模拟时间接近结束时间（但略微低于结束时间），步长将被调整，使下一次模拟时间与结束时间完全一致。 
* [0.x.13]*
   设置下一个时间步长的实际*值。通过调用这个方法，我们表明下次调用advance_time()时，将使用[2.x.65]来推进仿真时间。   
* [2.x.66] set_next_step_size()和set_desired_next_step_size()的区别在于，前者完全使用提供的[2.x.67]而不做任何调整，但如果[2.x.68]不在可接受的范围内，就会产生一个错误（在调试模式）。  一般来说，set_desired_next_step_size()是首选方法，因为它可以根据[2.x.70] 智能地调整[2.x.69] 。   [2.x.71] [2.x.72] 。 
* [0.x.14]*
   根据当前步骤的数值推进当前时间。  如果你想调整下一个时间步长，请在调用此方法之前调用set_desired_next_step_size()方法。  如果你重复调用这个函数，时间会以相同的步长增加，直到达到结束时间。参见set_desired_next_step_size()的文档，了解自动调整步长的规则。     [2.x.73] 当前时间必须小于结束时间。如果对象已经到了结束时间，就不能推进时间。创建这条规则是为了避免在循环内调用 advance_time() 时产生无限循环。     [2.x.74] 时间步长必须为非零。如果当前的步长为零，请在调用advance_time()之前通过调用set_desired_next_step_size()来改变它。 
* [0.x.15]*
   设置当前时间等于开始时间，并将步长设置为初始步长。 
* [0.x.16]*
   时间间隔的起始时间。 
* [0.x.17]*
  时间间隔的结束。 
* [0.x.18]*
   当前的时间。 
* [0.x.19]*
   下一个步骤的时间。   
* [2.x.75]在内部，下一个模拟时间被存储，而不是当前的步长。例如，当方法set_desired_next_step_size()被调用时，它计算出适当的下一个模拟时间并存储起来。当advance_time()被调用时，current_time被next_time所取代。这种对内部状态的选择使得代码更加简单，并确保当我们在最后一步调用advance_time()时，时间的浮点值与结束时间完全一致。 
* [0.x.20]*
   之前的时间。 
* [0.x.21]*
   第一个步骤的大小。 
* [0.x.22]*
   步数，即模拟时间被递增的次数。 
* [0.x.23]

