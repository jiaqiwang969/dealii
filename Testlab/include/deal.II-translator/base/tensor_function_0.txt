include/deal.II-translator/base/tensor_function_0.txt
[0.x.0]*
 这个类是一个张量值函数的模型。该类的接口与函数类的接口基本相同，只是不支持有多个分量的向量值函数，但返回类型总是张量值的。对这种类型的对象进行评估的返回值总是整个张量，而对于<tt>Function</tt>类，可以只要求一个特定的分量，或者使用<tt>vector_value</tt>函数，但它不返回值，而是将其写入其第二个参数提供的地址中。类的不同行为的原因是，在张量值函数的情况下，编译器预先知道参数的大小，这样就可以在堆栈中为返回值分配正确的内存量；另一方面，对于矢量值函数，编译器不知道其大小，所以内存必须在堆中分配，导致相对昂贵的复制操作。因此，我们可以认为这个类是<tt>Function</tt>类的特化，对于这个类，大小是已知的。另一个好处是可以返回任意等级的张量，而不仅仅是向量，因为它们的大小也可以简单地确定。
* 

* 
* [2.x.0] 

* 
* [0.x.1]*
   <tt>value</tt>函数的返回类型的别名。 
* [0.x.2]*
   <tt>gradient</tt>函数的返回类型的别名。 
* [0.x.3]*
   用于表示时间的标量值实数类型。 
* [0.x.4]*
   构造函数。可以为时间变量取一个初始值，默认为零。 
* [0.x.5]*
   虚拟析构器；在这种情况下是绝对必要的，因为类通常不是通过它们的真实类型来使用，而是通过指向这个基类的指针。 
* [0.x.6]*
   返回函数在给定点的值。 
* [0.x.7]*
   将<tt>values</tt>设为函数在<tt>点</tt>的点值。 假设<tt>values</tt>已经有合适的大小，即与<tt>points</tt>数组的大小相同。 
* [0.x.8]*
   返回函数在给定点的梯度。 
* [0.x.9]*
   设置<tt>gradients</tt>为函数在<tt>points</tt>的梯度。 假设<tt>values</tt>已经有合适的大小，即与<tt>points</tt>数组的大小相同。 
* [0.x.10]*
 提供一个张量值的函数，它总是返回一个恒定的张量值。很明显，这个函数的所有导数都是零。
* 

* 
* [2.x.1] 

* 
* [0.x.11]*
   用于表示时间的标量值实数类型。 
* [0.x.12]*
   构造函数；将常数张量值作为参数。参考值在内部被复制。    可以指定时间变量的初始值，否则默认为零。 
* [0.x.13]*
 提供一个张量值的函数，它总是返回0。很明显，这个函数的所有派生都是零。
* 

* 
* [2.x.2] 

* 
* [0.x.14]*
   用于表示时间的标量值实数类型。 
* [0.x.15]*
   构造函数。    可以指定时间变量的初始值，否则默认为零。 
* [0.x.16]

