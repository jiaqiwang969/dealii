include/deal.II-translator/base/point_0.txt
[0.x.0]*
 一个代表笛卡尔空间中一个点的类，其维度为 [2.x.0] 。
* 这个类的对象用于表示配备有[1.x.0]的向量空间的点（即锚定在原点的向量）。在其他用途中，它们被传递给在先验固定维度空间中对点进行操作的函数：与其使用<code>double f(const double x)</code>和<code>double f(const double x, const double y)</code>这样的函数，不如使用[2.x.1]，因为它允许编写独立维度的代码。
* deal.II特别使用Point对象来表示由笛卡尔坐标表示的点，也就是说，在[2.x.2]二维空间维度中，一个点的特征是沿着由[2.x.3]相互正交的单位向量（称为 "坐标轴"）跨越的坐标系的轴的带符号距离。这种表示矢量的选择使得矢量的加法和缩放特别简单：人们只需要对每个坐标值进行加法或乘法。另一方面，当一个向量用其他类型的坐标系表示时（如[1.x.1]），添加或缩放向量就没有那么简单了。
* 

* [1.x.2]
* 点类派生于张量[2.x.4]，因此共享后者的成员函数和其他属性。事实上，它本身的附加函数相对较少（最明显的例外是计算空间中两点之间欧几里得距离的distance()函数），因此这两个类通常可以互换使用。
*尽管如此，还是有语义上的差异，使得我们在不同的、定义明确的语境中使用这些类。在deal.II中，我们用<tt>Point</tt>类来表示空间中的点，即表示[2.x.5]锚定在原点[2.x.6]的向量（秩-1张量）。另一方面，锚定在其他地方的向量（因此在这个词的通常用法中不代表[2.x.7]点[2.x.8]）由张量[2.x.9]类型的对象表示。 ] 特别是方向向量、法向量、梯度和两点之间的差值（即当你从一个点减去另一个点时得到的东西）：所有这些都由Tensor[2.x.10]对象而不是Point[2.x.11]表示。
* 此外，点类只用于对象的坐标可以被认为拥有长度维度的地方。一个表示物体的重量、高度和成本的对象既不是点也不是张量（因为它缺乏坐标系旋转下的变换属性），因此不应该用这些类来表示。在这种情况下，使用一个大小为3的数组，或者使用[2.x.12]类。另外，就像在矢量值函数的情况下，你可以使用矢量类型的对象或[2.x.13] 。
* 

* [2.x.14] dim 一个整数，表示一个点所在的空间的维度。当然，这等于确定一个点的坐标数。 [2.x.15] Number 用于存储坐标值的数据类型。几乎在所有情况下，这都是默认的[2.x.16]，但在某些情况下，人们可能希望以不同的（而且总是标量的）类型来存储坐标。一个例子是一个区间类型，它可以存储一个坐标的值以及它的不确定性。另一个例子是一个允许自动微分的类型（例如，见[2.x.17]中使用的Sacado类型），从而可以在传递一个坐标被存储在这种类型中的点对象时产生函数的解析（空间）导数。
* 

* 

* 
* [2.x.18] 

 
* [0.x.1]*
   标准构造函数。创建一个对应于原点的对象，即所有的坐标都设置为零。   
* [2.x.19] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.2]*
   将一个张量转换为一个点。 
* [0.x.3]*
   一维点的构造函数。这个函数只对<tt>dim==1</tt>实现，因为对<tt>dim!=1</tt>的点的使用被认为是不安全的，因为它将使点坐标的一些分量未被初始化。   
* [2.x.20] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.4]*
   二维点的构造函数。这个函数只对<tt>dim==2</tt>实现，因为对于<tt>dim!=2</tt>的点来说，这个用法被认为是不安全的，因为它将使点坐标的某些分量未被初始化（如果dim>2）或不使用某些参数（如果dim<2）。   
* [2.x.21]这个函数也可以在CUDA设备代码中使用。 
* [0.x.5]*
   三维点的构造函数。这个函数只对<tt>dim==3</tt>实现，因为对于<tt>dim!=3</tt>的点来说，这个用法被认为是不安全的，因为它将使点坐标的一些分量未被初始化（如果dim>3）或者不使用一些参数（如果dim<3）。   
* [2.x.22] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.6]*
   将一个[2.x.23]转换为一个[2.x.24]。  
* [0.x.7]*
   返回一个坐标方向<tt>i</tt>的单位向量，即除了<tt>i</tt>第1个坐标中的一个1之外，所有坐标中的向量都是0。   
* [2.x.25] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.8]*
   对<tt>index</tt>th坐标的读取访问。   
* [2.x.26] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.9]*
   对<tt>index</tt>th坐标的读和写访问。   
* [2.x.27] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.10]*
   来自Tensor<1, dim, Number>的赋值操作，其底层标量类型不同。这显然要求[2.x.28]类型可以转换为[2.x.29]。  
* [0.x.11]*
    [2.x.30] 点的加法和减法。   [2.x.31]   
* [0.x.12]*
   将一个以张量<1,dim,Number>给出的偏移量添加到一个点上。   
* [2.x.32] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.13]*
   减去两个点，即获得连接这两个点的向量。正如在这个类的文档中所讨论的，减去两个点的结果是一个锚定在两个点之一的向量（而不是原点），因此，结果是作为一个张量[2.x.33]而不是作为一个点[2.x.34]返回。    
* [2.x.35] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.14]*
   从当前点减去一个差分向量（用张量[2.x.36]表示）。这将产生另一个点，正如在这个类的文档中所讨论的，然后结果自然是作为一个点[2.x.37]对象而不是作为一个张量[2.x.38]返回。    
* [2.x.39] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.15]*
   相反的向量。   
* [2.x.40] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.16]*
    [2.x.41]   
* [0.x.17]*
    [2.x.42] 点的乘法和缩放。点积。规范。   [2.x.43]   
* [0.x.18]*
   将当前点乘以一个系数。   
* [2.x.44] 这个函数也可以在CUDA设备代码中使用。     [2.x.45] EnableIfScalar  
* [0.x.19]*
   将当前点除以一个系数。   
* [2.x.46] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.20]*
   返回代表两点的向量的标量积。   
* [2.x.47] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.21]*
   返回该点向量与自身的标量乘积，即平方，或规范的平方。如果是复数类型，则相当于此点向量与自身的复共轭的收缩。   
* [2.x.48] 这个函数等同于[2.x.49]，它返回弗罗本纽斯法线的平方。   
* [2.x.50] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.22]*
   返回<tt>this</tt>点到<tt>p</tt>点的欧氏距离，即代表两点的向量之差的[2.x.51]规范。   
* [2.x.52] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.23]*
   返回<tt>this</tt>点到<tt>p</tt>点的平方欧氏距离。   
* [2.x.53] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.24]*
    [2.x.54]   
* [0.x.25]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据读入或写入一个流中，以便进行序列化。 
* [0.x.26]*
 用标量缩放点向量的全局运算符。
* 

* 
* [2.x.55] 这个函数也可以在CUDA设备代码中使用。
* [2.x.56] 点 [2.x.57] EnableIfScalar

* 
* [0.x.27]*
 点的输出运算符。连续地打印元素，中间有一个空格。 [2.x.58] 点

* 
* [0.x.28]*
 点的输入运算符。连续地输入元素。 [2.x.59] 点

* 
* [0.x.29]*
 维度为1的点的输出运算符。这是从一般模板中专门实现的，以避免编译器警告该循环是空的。

* 
* [0.x.30]

