include/deal.II-translator/base/subscriptor_0.txt
[0.x.0]*
 对订阅的处理。
* 这个类，作为一个基类，允许使用一个特定的对象来跟踪其他对象。它被用来避免指向从Subscriptor派生的类的对象的指针在该对象被无效后被引用。在这里，无效化被认为是在对象被移出或销毁时发生的。该机制的工作方式如下。成员函数subscribe()接受一个指向布尔值的指针，该指针在失效时被修改。拥有这个指针的对象（通常是SmartPointer类型的对象）然后被期望在试图访问这个类之前检查布尔值的状态。
* 通过为函数subscribe()和unsubscribe()提供识别字符串，这个类的效用甚至得到了加强。这些字符串被表示为[2.x.0]指针，因为底层的缓冲区来自（并由）运行时类型信息系统管理：更确切地说，这些指针是函数调用[2.x.1]的结果，其中[2.x.2]是一些对象。因此，提供给 subscribe() 和 unsubscribe() 的指针必须相同。内容相同的字符串将不会被识别为相同。SmartPointer中的处理方法将照顾到这一点。该类的当前订阅者可以通过调用list_subscribers()获得。
* 

* 
* [2.x.3] 

* 
* [0.x.1]*
   构造函数将计数器设置为零。 
* [0.x.2]*
   复制构造器。    复制的计数器是零，因为引用指向原始对象。 
* [0.x.3]*
   移动构造函数。    继承自Subscriptor的对象只有在没有其他对象订阅它的情况下才能被移动。 
* [0.x.4]*
   解构器，断言计数器为零。 
* [0.x.5]*
   赋值操作符。    这也要小心处理，因为计数器必须保持不变。因此，它只是返回<tt>*this</tt>而已。 
* [0.x.6]*
   移动赋值运算符。只会使所移动的对象无效。 
* [0.x.7]*
    [2.x.4]Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。 
* [0.x.8]*
   通过存储指针来订阅该对象的用户 [2.x.5] 订阅者可以通过提供的文本来识别 [2.x.6] 。  
* [0.x.9]*
   从对象中取消用户的订阅。   
* [2.x.7] [2.x.8]和[2.x.9]的指针必须与提供给subscribe()的指针相同。 
* [0.x.10]*
   返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 
* [0.x.11]*
   列出输入的订阅者 [2.x.10] 。  
* [0.x.12]*
   列出输入[2.x.11]的订阅者。  
* [0.x.13]*
    [2.x.12] 异常情况 [2.x.13].   
* [0.x.14]*
   异常情况。对象不能被删除，因为它被使用了。 
* [0.x.15]*
   具有[2.x.14]给出的识别字符串的订阅者没有订阅该对象。 
* [0.x.16]*
   为了使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)进行序列化，将此对象的数据读入或写入一个流中。    这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 
* [0.x.17]*
   存储订阅此对象的对象的数量。最初，这个数字是零，在销毁时，它应再次为零（即所有订阅过的对象应再次取消订阅）。    如果一个对象的创建者（和所有者）能够提供身份证明，那么他将被计算在下面的地图中。    我们使用<tt>mutable</tt>关键字，以便也允许订阅常量对象。    这个计数器可以在多线程代码中被同时读出和写入：因此我们使用了[2.x.15]类模板。 
* [0.x.18]*
   在这个地图中，我们为提供给subscribe()的每个不同的标识字符串计算订阅数。 
* [0.x.19]*
   在#counter_map中使用的数据类型。 
* [0.x.20]*
   在#counter_map中使用的迭代器类型。 
* [0.x.21]*
   在这个向量中，我们在订阅这个类的SmartPointer对象中存储指向有效性bool的指针。 
* [0.x.22]*
   指向这个对象的typeinfo对象的指针，以后我们可以从中推导出类的名称。因为这个派生类的信息既不能在析构器中获得，也不能在构造器中获得，所以我们在两者之间获得它，并把它存储在这里。 
* [0.x.23]*
   检查是否有任何对象订阅了这个对象。如果这个检查通过，那么销毁当前对象是安全的。如果这个检查失败，那么这个函数将中止或向deallog打印错误信息（通过使用AssertNothrow机制），但不会抛出一个异常。   
* [2.x.16] 因为这个函数只是一个一致性检查，所以它在释放模式下没有任何作用。   
* [2.x.17] 如果这个函数在有一个未捕获的异常时被调用，那么，这个函数不是中止，而是向标准错误流打印一个错误信息并返回。 
* [0.x.24]*
   一个突变器，用于在打印出订阅者列表时确保数据的一致性。 
* [0.x.25]

