include/deal.II-translator/base/polynomial_space_0.txt
[0.x.0]*
 度数最多为n的多项式的空间在高维中的表示。
* 给定一个[1.x.0]一维多项式[1.x.1]到[1.x.2]的向量，其中[1.x.3]的度数为[1.x.4]，这个类产生所有形式为[1.x.5]的二维多项式，其中[1.x.6]、[1.x.7]和[1.x.8]之和小于或等于[1.x.9]。
* output_indices()函数打印了多项式的排序，即对于多项式空间中的每个dim-dimensional多项式，它给出了x、y和z方向的一维多项式的指数i,j,k。dim-dimensional多项式的排序可以通过set_numbering()函数来改变。
* 多项式的标准排序是，第一个空间维度的指数变化最快，最后一个空间维度的指数变化最慢。特别是，如果我们为简单起见，取单项式的矢量[1.x.10]，我们得到
* [2.x.0] <dt> 1D [2.x.1] [1.x.11] <dt> 2D: [2.x.2] [1.x.12] <dt> 3D: [2.x.3] [1.x.13] [2.x.4] 
* 

* 
* [2.x.5] 

* 
* [0.x.1]*
   访问此对象的尺寸，用于检查和自动设置其他类中的尺寸。 
* [0.x.2]*
   构造函数。<tt>pols</tt>是一个指向一维多项式的向量，将被复制到一个私有成员变量中。模板参数<tt>pols</tt>的静态类型需要可以转换为[2.x.6]，即通常应该是[2.x.7]的一个派生类。  
* [0.x.3]*
   打印索引列表到<tt>out</tt>。 
* [0.x.4]*
   设置多项式的排序。要求<tt>renumber.size()==n()</tt>。存储一个<tt>renumber</tt>的副本。 
* [0.x.5]*
   计算每个多项式在<tt>unit_point</tt>的值和一、二次导数。    向量的大小必须等于0或等于n()。在第一种情况下，函数不会计算这些值，也就是说，你要通过调整那些你想要填充的向量的大小来表明你想要计算什么。    如果你需要所有多项式的值或导数，那么使用这个函数，而不是使用任何一个compute_value(), compute_grad()或compute_grad_grad()函数，见下文，在所有多项式上循环。 
* [0.x.6]*
   计算<tt>i</tt>第1个多项式在单位点<tt>p</tt>的值。    可以考虑用evaluate()代替。 
* [0.x.7]*
   计算<tt>i</tt>次多项式在单位点<tt>p</tt>的<tt>阶</tt>次导数。    可以考虑用evaluate()代替。     [2.x.8] order 导数的阶数。 
* [0.x.8]*
    [2.x.9] [2.x.10] 阶数   
* [0.x.9]*
    [2.x.11] [2.x.12] [2.x.12]。  
* [0.x.10]*
    [2.x.13] [2.x.14] [2.x.14].   
* [0.x.11]*
    [2.x.15] [2.x.16] [2.x.16].   
* [0.x.12]*
   计算<tt>i</tt>第1个多项式在单位点<tt>p</tt>的梯度。    可以考虑用evaluate()代替。 
* [0.x.13]*
   计算<tt>i</tt>次多项式在单位点<tt>p</tt>的二阶导数（grad_grad）。    可以考虑用evaluate()代替。 
* [0.x.14]*
   返回跨越这个类所代表的空间的多项式的数量。这里，如果<tt>N</tt>是给出的一维多项式的数量，那么这个函数的结果是1d中的[1.x.14]，2d中的[1.x.15]，以及3d中的[1.x.16]。 
* [0.x.15]*
   返回空间的名称，即<tt>PolynomialSpace</tt>。 
* [0.x.16]*
    [2.x.17] [2.x.18].   
* [0.x.17]*
   计算x、y和z方向的数字。给出d维多项式空间中的一个索引<tt>n</tt>，返回索引i,j,k，以便[1.x.17]。    在1d和2d中，显然只有i和i,j被返回。 
* [0.x.18]*
   复制给构造函数的多项式的向量<tt>pols</tt>。 
* [0.x.19]*
   用于重新排序多项式的索引图。 
* [0.x.20]*
   用于重新排序多项式的索引图。 
* [0.x.21]

