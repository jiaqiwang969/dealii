include/deal.II-translator/base/vectorization_0.txt
[0.x.0]*
 VectorizedArray的一个迭代器。

* 
* [0.x.1]*
   构造函数。     [2.x.0] data 实际的VectorizedArray。   [2.x.1] lane 一个指向当前车道的指针。 
* [0.x.2]*
   比较是否相等。 
* [0.x.3]*
   比较不等式。 
* [0.x.4]*
   复制赋值。 
* [0.x.5]*
   解除引用操作符（const版本）：返回当前车道的值。 
* [0.x.6]*
   去引用操作符（非[2.x.2]版本）：返回当前车道的值。 
* [0.x.7]*
   前缀<tt>++</tt>运算符。<tt>++iterator</tt>。这个操作符将迭代器推进到下一个车道，并返回对<tt>*this</tt>的引用。 
* [0.x.8]*
   这个操作符使迭代器前进了[2.x.3]个通道，并返回对<tt>*this</tt>的引用。 
* [0.x.9]*
   前缀<tt>--</tt>操作符。<tt>--iterator</tt>。这个操作符使迭代器前进到前一个通道，并返回一个对<tt>*this</tt>的引用。 
* [0.x.10]*
   创建新的迭代器，该迭代器被移位[2.x.4]。  
* [0.x.11]*
   计算这个迭代器和迭代器之间的距离 [2.x.5] 。  
* [0.x.12]*
   指向实际的VectorizedArray的指针。 
* [0.x.13]*
   指向当前车道的指针。 
* [0.x.14]*
 各种VectorizedArray模板特化的基类，包含共同的功能。
* [2.x.6] T 实际矢量数组的类型。我们在这个类中使用Couriously Recurring Template Pattern（见https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern），以避免求助于`虚拟`成员函数。

* 
* [0.x.15]*
   返回数组中元素的数量。 
* [0.x.16]*
    [2.x.7] 指向底层数据开始的一个迭代器。 
* [0.x.17]*
    [2.x.8] 一个指向基础数据开始的迭代器（`const`版本）。 
* [0.x.18]*
    [2.x.9] 指向基础数据结束的迭代器。 
* [0.x.19]*
    [2.x.10] 一个指向基础数据末端的迭代器（`const`版本）。 
* [0.x.20]*
 这个通用类定义了一个矢量数据类型的统一接口。对于一般的模板参数，这个类简单地对应于模板参数。例如，VectorizedArray<long double>只不过是<tt>long double</tt>的一个封装器，它的数据字段正好是<tt>long double</tt>类型，并且有重载的算术操作。这意味着<tt>VectorizedArray<ComplicatedType></tt>具有与ComplicatedType类似的布局，只要ComplicatedType定义了基本的算术操作。对于浮点数和双数来说，数组被打包在一起，目的是为了以单指令/多数据（SIMD）的方式进行处理。在SIMD背景下，这种短矢量的元素通常被称为通道。包装在一起的元素的数量，即车道的数量，取决于计算机系统和用于编译deal.II的编译器标志。这些打包数据类型的基本思想是使用一条CPU指令，利用处理器的向量（SIMD）单元对整个阵列进行算术运算。按照2010年的标准，大多数计算机系统在64位操作系统上编译deal.II时，将分别使用两个双数或四个浮点数的数组（这对应于SSE/SSE2数据集）。在英特尔Sandy Bridge处理器和更新的处理器或AMD Bulldozer处理器和更新的处理器上，当deal.II使用gcc配置为 \--with-cpu=native 或 \--with-cpu=corei7-avx时，会使用四个双数或八个浮点。在支持AVX-512的编译器上（例如2017年开始的英特尔Skylake服务器），会使用8个双数或16个浮点。
* 这个类的行为被做成与基本数据类型double和float类似。向量数组的定义并不初始化数据字段，而是让它未被定义，就像double和float的情况一样。然而，当调用诸如`矢量化数组<double> a =矢量化数组<double>()`或`矢量化数组<double> a = 0.`时，它将这个字段中的所有数字设置为零。根据C++11标准，该类属于标准布局类型，这意味着有一个等效的C表示法，例如，该类可以用[2.x.11]安全地复制（也见https://en.cppreference.com/w/cpp/named_req/StandardLayoutType）。标准布局对于确保在向量中收集的数据与地址边界正确对齐也是必要的（即，当向量中的第一个元素正确对齐时，所有后续元素也将正确对齐）。
* 请注意，为了使这个类的正常运行，必须遵守某些数据对齐规则。这是因为计算机期望VectorizedArray<double>字段的起始地址在内存中的特定地址（通常，矢量数组的地址应该是以字节为单位的数组长度的倍数）。否则，可能会出现分段故障或严重的性能损失。当在堆栈上创建一个单一的数据字段时，如 "VectorizedArray<double> a = 5. ;"，编译器会自动处理数据对齐。然而，当分配一个VectorizedArray<double>数据的长向量时，需要尊重这些规则。为此要使用AlignedVector类或基于AlignedVector的数据容器（如Table）。这是一个与[2.x.12]非常相似的类，否则，它总是能确保数据正确对齐。
* 用户可以通过该封装类的第二个模板参数指定通道数，明确控制特定指令集架构（ISA）扩展的宽度。例如，在英特尔Skylake服务器上，你对数据类型double有以下选择。
* 

* 
* 

* 
* 
* - VectorizedArray<double, 1> // 无矢量化（自动优化）。
* 

* 
* 

* 
* 
* - VectorizedArray<double, 2> // SSE2
* 

* 
* 

* 
* 
* - VectorizedArray<double, 4> // AVX
 

* 
* 

* 
* 
* - VectorizedArray<double, 8> // AVX-512 (默认)
* 并用于英特尔Sandy Bridge、Haswell、Broadwell、AMD Bulldozer和Zen/Ryzen。
* 

* 
* 

* 
* 
* - VectorizedArray<double, 1> // 无矢量化（自动优化）。
* 

* 
* 

* 
* 
* - VectorizedArray<double, 2> // SSE2
* 

* 
* 

* 
* 
* - VectorizedArray<double, 4> // AVX (默认)
* 以及对于支持AltiVec的处理器。
* 

* 
* 

* 
* 
* - 矢量Array<double, 1> * - 矢量Array<double, 1>
 

* 
 

 
* 

* 适用于旧的x86处理器或在没有添加特定处理器编译标志的情况下（即没有`-D CMAKE_CXX_FLAGS=-march=native`或类似标志）。
* 

* 
* 

* 
* 
* - VectorizedArray<double, 1> // 无矢量化（自动优化）。
* 

* 
* 

* 
* 
* - VectorizedArray<double, 2> // SSE2
* 类似的考虑也适用于数据类型`float`。
* 错误地选择宽度，例如，在不支持AVX-512的处理器上选择width=3或width=8，会导致静态断言。
* [2.x.13] 数字基础数据类型 [2.x.14] 宽度向量长度（可选；如果不设置，则使用架构的最大宽度）。

* 
* [0.x.21]*
   这给出了数组元素的类型。 
* [0.x.22]*
   默认的空构造函数，使数据处于未初始化的状态，类似于float/double。 
* [0.x.23]*
   用给定的标量构建一个数组广播到所有的通道。 
* [0.x.24]*
   这个函数将一个标量分配给这个类。 
* [0.x.25]*
   访问操作符（只对基类中的0号组件有效，没有特殊化）。 
* [0.x.26]*
   常数访问操作符（只对基类中的0号组件有效，没有特殊化）。 
* [0.x.27]*
   加法  
* [0.x.28]*
   减法  
* [0.x.29]*
   乘法  
* [0.x.30]*
   除法  
* [0.x.31]*
   从内存中加载size()数据项到调用类中，从给定的地址开始。指针`ptr`不需要按矢量数组中的字节数对齐，与之相反的是，将双倍地址投给VectorizedArray<double>*。 
* [0.x.32]*
   将调用类的内容以size()数据项的形式写入内存中，到给定的地址。指针`ptr`不需要按矢量数组中的字节数对齐，与之相反的是，将一个双倍地址投给VectorizedArray<double>*。 
* [0.x.33]*
   在支持的CPU上使用[2.x.15]存储本征，将调用类的内容以size()数据项的形式写入内存，并使用绕过处理器缓存的非时间性存储来给定地址。存储[2.x.16]的目标必须按矢量数组中的字节数对齐。    在存储是流式的情况下，这种存储操作可以比通常的存储操作更快，因为它避免了通常在标准存储中调用的读取所有权转移。这个大约的工作原理如下（详见计算机结构方面的文献）。当一个算法将一些结果存储到一个内存地址时，一个处理器通常希望将它移到它的一些缓存中，因为它期望这些数据在某个时候会被再次使用。由于缓存是以64字节或128字节的行来组织的，但写入的数据通常较小，所以处理器在写入时必须首先加载目标缓存行，因为最初只有部分缓存行被覆盖。如果一系列的存储写入的数据比任何一个缓冲区都要大，那么这些数据最后就必须从缓冲区转移到主内存。但是，由于所有的地址都是先被读取的，这就使主内存的负载增加了一倍，这就会产生性能上的损失。此外，在多核环境下的缓存组织也需要在将某一地址写入缓存之前读取该地址，详情请参见[1.x.0]。这个函数调用的基础指令向处理器发出信号，在存储上的这两个先决条件被放宽了：首先，人们期望整个高速缓存行被覆盖（意味着内存子系统确保一起跨越高速缓存行的连续存储被合并，并适当处理只有部分高速缓存行被写入的情况），所以没有必要首先读取高速缓存行的 "剩余部分"。其次，该特定内存后面的数据将不受缓存一致性协议的约束，因为当同一处理器想要再次访问它时，以及在多核芯片中的任何其他处理器，它都将在主内存中。由于这种特殊的设置，随后对该函数写入的数据的任何访问都需要查询主存，这在延迟和吞吐量上都比从高速缓存中访问要慢。因此，这个命令应该只用于存储大的数组，这些数组总体上不适合放在缓存中，否则性能就会下降。关于一个典型的用例，请参见[1.x.1]。    注意，流式存储只在类型为[2.x.17]或[2.x.18]的VectorizedArray的专业SSE/AVX类中可用，而不是在通用基类中。 
* [0.x.34]*
   从内存中加载size()数据项到调用的类中，从给定的地址和给定的偏移量开始，从偏移量开始的每个条目提供一个矢量化数组的元素。    这个操作对应于以下代码（但在硬件允许的情况下，使用了更有效的实现）。 
* [1.x.2]
*   
* [0.x.35]*
   将调用类的内容以size()数据项的形式写入内存，到给定的地址和给定的偏移量，将矢量数组的元素填入每个偏移量。    这个操作对应于下面的代码（但在硬件允许的情况下，使用更有效的实现）。 
* [1.x.3]
   
* [0.x.36]*
   实际的数据字段。为了与标准布局类型保持一致，并且能够与外部SIMD功能进行交互，这个成员被声明为公共的。 
* [0.x.37]*
   返回这个字段的平方根。不适合在用户代码中使用。使用sqrt(x)代替。 
* [0.x.38]*
   返回这个字段的绝对值。不适合在用户代码中使用。请使用abs(x)代替。 
* [0.x.39]*
   返回这个字段和另一个字段的分量上的最大值。不适合在用户代码中使用。使用max(x,y)代替。 
* [0.x.40]*
   返回这个字段和另一个字段的最小分量。不适合在用户代码中使用。使用min(x,y)代替。 
* [0.x.41]*
  [2.x.19] 矢量数组的打包和拆包

* 
* [0.x.42]*
 创建一个矢量数组，将数组中的所有条目设置为给定的标量，也就是说，将标量广播到所有数组元素。
* [2.x.20] 矢量Array

* 
* [0.x.43]*
 创建一个给定类型的矢量数组，并将标量值广播给所有数组元素。
* [2.x.21] VectorizedArray

* 
* [0.x.44]*
 从内存中加载size()数据项到VectorizedArray [2.x.22]，从给定的地址和给定的偏移量开始，从偏移量开始的每个条目提供一个矢量化数组的元素。
* 这个操作对应于以下代码。

* 
* [1.x.4]
* 

* 
* [0.x.45]*
 这个方法从给定的数组[2.x.24]中加载[2.x.23]数据流，输入数组的偏移量由数组[2.x.25]偏移量给出。从每个数据流中读取n_entries。然后数据被转置并存储到一个VectorizedArray类型的数组中。输出数组[2.x.26] out预计是一个大小为[2.x.27]的数组。这个方法在普通数组上操作，所以没有检查有效的数据访问。用户有责任确保给定的数组根据下面的访问布局是有效的。
* 该操作对应于根据以下公式将一个结构数组（输入）转换为一个数组结构（输出）。
* 

* 
* [1.x.5]
* 
* 该代码的一个更优化的版本将用于支持的类型。
* 这是对vectorized_transpose_and_store()的逆向操作。
* [2.x.28] VectorizedArray

* 
* [0.x.46]*
 与上面的函数相同，不同的是将一个指针数组作为输入参数传入 [2.x.29] 。
* 与上面的函数类比，可以认为 "in+offset[v]"是预先计算并作为输入参数传递的。
* 然而，如果某些函数返回一个指针数组，并且不能假设它们属于同一个数组，也就是说，它们可以在不同的内存分配中获得原点，那么也可以使用这个函数。

* 
* [0.x.47]*
 该方法以转置的形式将矢量数组存储到给定的输出数组[2.x.30]中，并给定偏移量[2.x.31]，该操作相当于将一个数组结构（输入）转换为一个数组结构（输出）。该方法对纯数组进行操作，所以没有对有效的数据访问进行检查。用户有责任确保给定的数组根据下面的访问布局是有效的。
* 该方法假设指定的偏移量不重叠。否则，在矢量化的情况下，该行为是未定义的。用户有责任确保访问不重叠，避免未定义的行为。
* 参数[2.x.32]选择哪里的条目应该只被写入输出数组，或者结果应该被添加到输出的现有条目中。对于 [2.x.33] ，假设以下代码。
* 

* 
* [1.x.6]
* 
* 对于 [2.x.34] ，代码实现了以下动作。

 
* [1.x.7]
* 
* 对于支持的类型，将使用该代码的一个更优化的版本。
* 这是对vectorized_load_and_transpose()的逆向操作。
* [2.x.35] VectorizedArray

* 
* [0.x.48]*
 和上面一样，不同的是，一个指针数组被作为输入参数传入 [2.x.36] 。
* 与上面的函数相类似，可以认为`out+offset[v]`是预先计算好的，并作为输入参数传入。
* 然而，如果某些函数返回一个指针数组，并且不能假设它们属于同一个数组，也就是说，它们可以在不同的内存分配中拥有自己的原点，那么也可以使用这个函数。

* 
* [0.x.49]*
 针对double和AVX-512的VectorizedArray类的专业化。

* 
* [0.x.50]*
   这给出了数组元素的类型。 
* [0.x.51]*
   默认的空构造函数，让数据处于未初始化的状态，类似于float/double。 
* [0.x.52]*
   用给定的标量构建一个数组，广播给所有通道。 
* [0.x.53]*
   这个函数可以用来将所有的数据字段设置为一个给定的标量。 
* [0.x.54]*
   访问操作符。 
* [0.x.55]*
   常数访问运算符。 
* [0.x.56]*
   加法。 
* [0.x.57]*
   减法。 
* [0.x.58]*
   乘法。 
* [0.x.59]*
   除法。 
* [0.x.60]*
   从内存中加载size()数据项到调用类中，从给定的地址开始。内存不需要按64字节对齐，相对于将双倍地址投给VectorizedArray<double>*来说。 
* [0.x.61]*
   将调用类的内容以[2.x.37]size()的形式写入内存到给定地址。内存不需要按64字节对齐，相对于将双倍地址投给VectorizedArray<double>*来说。 
* [0.x.62]* [2.x.38] [2.x.39]。  
* [2.x.40] 内存必须以64字节对齐。 
* [0.x.63]*
   将[2.x.41]从内存中加载到调用类中，从给定的地址开始，并有给定的偏移量，从偏移量开始的每个条目提供一个矢量数组的元素。    这个操作对应于以下代码（但在硬件允许的情况下，使用了更有效的实现）。 
* [1.x.8]
*   
* [0.x.64]*
   将调用类的内容以[2.x.42]size()的形式写入内存，到给定的地址和给定的偏移量，将矢量数组的元素填入每个偏移量。    这个操作对应于下面的代码（但在硬件允许的情况下使用了更有效的实现）。 
* [1.x.9]
   
* [0.x.65]*
   实际的数据字段。为了与标准布局类型保持一致，并且能够与外部SIMD功能进行交互，这个成员被声明为公共的。 
* [0.x.66]*
   返回这个字段的平方根。不适合在用户代码中使用。使用sqrt(x)代替。 
* [0.x.67]*
   返回该字段的绝对值。不适合在用户代码中使用。请使用abs(x)代替。 
* [0.x.68]*
   返回这个字段和另一个字段的分量上的最大值。不适合在用户代码中使用。使用max(x,y)代替。 
* [0.x.69]*
   返回这个字段和另一个字段的最小分量。不适合在用户代码中使用。使用min(x,y)代替。 
* [0.x.70]*
 对double和AVX-512的特殊化。

* 
* [0.x.71]*
 对double和AVX-512的特殊化。

* 
* [0.x.72]*
 用于双倍和AVX-512的特殊化。

* 
* [0.x.73]*
 用于双倍和AVX-512的特殊化。

* 
* [0.x.74]*
 浮动和AVX512的特殊化。

* 
* [0.x.75]*
   这给出了数组元素的类型。 
* [0.x.76]*
   默认的空构造函数，让数据处于未初始化的状态，类似于float/double。 
* [0.x.77]*
   用给定的标量构建一个数组广播到所有的通道。 
* [0.x.78]*
   这个函数可以用来将所有的数据字段设置为一个给定的标量。 
* [0.x.79]*
   访问操作符。 
* [0.x.80]*
   常数访问运算符。 
* [0.x.81]*
   加法。 
* [0.x.82]*
   减法。 
* [0.x.83]*
   乘法。 
* [0.x.84]*
   除法。 
* [0.x.85]*
   从内存中加载[2.x.43]到调用类中，从给定的地址开始。内存不需要对齐64字节，相对于将浮点地址投给VectorizedArray<float>*。 
* [0.x.86]*
   将调用类的内容以[2.x.44]size()的形式写到内存中的给定地址。内存不需要按64字节对齐，相对于将浮点地址投给VectorizedArray<float>*来说。 
* [0.x.87]* [2.x.45] [2.x.46]。  
* [2.x.47] 内存必须以64字节对齐。 
* [0.x.88]*
   将[2.x.48]从内存中加载到调用类中，从给定的地址开始，并有给定的偏移量，从偏移量开始的每个条目提供一个矢量数组的元素。    这个操作对应于以下代码（但在硬件允许的情况下，使用了更有效的实现）。 
* [1.x.10]
*   
* [0.x.89]*
   将调用类的内容以[2.x.49]size()的形式写入内存，到给定的地址和给定的偏移量，将矢量数组的元素填入每个偏移量。    这个操作对应于下面的代码（但在硬件允许的情况下使用了更有效的实现）。 
* [1.x.11]
*   
* [0.x.90]*
   实际的数据字段。为了与标准布局类型保持一致，并且能够与外部SIMD功能进行交互，这个成员被声明为公共的。 
* [0.x.91]*
   返回这个字段的平方根。不适合在用户代码中使用。使用sqrt(x)代替。 
* [0.x.92]*
   返回该字段的绝对值。不适合在用户代码中使用。使用abs(x)代替。 
* [0.x.93]*
   返回这个字段和另一个字段的分量上的最大值。不适合在用户代码中使用。使用max(x,y)代替。 
* [0.x.94]*
   返回这个字段和另一个字段的最小分量。不适合在用户代码中使用。使用min(x,y)代替。 
* [0.x.95]*
 浮点数和AVX-512的特殊化。

* 
* [0.x.96]*
 浮点数和AVX-512的特殊化。

* 
* [0.x.97]*
 浮动和AVX-512的特殊化。

* 
* [0.x.98]*
 浮动和AVX-512的特殊化。

* 
* [0.x.99]*
 适用于双数和AVX的VectorizedArray类的特化。

* 
* [0.x.100]*
   这给出了数组元素的类型。 
* [0.x.101]*
   默认的空构造函数，让数据处于未初始化的状态，类似于float/double。 
* [0.x.102]*
   用给定的标量构建一个数组，广播给所有通道。 
* [0.x.103]*
   这个函数可以用来将所有的数据字段设置为一个给定的标量。 
* [0.x.104]*
   访问操作符。 
* [0.x.105]*
   常数访问运算符。 
* [0.x.106]*
   加法。 
* [0.x.107]*
   减法。 
* [0.x.108]*
   乘法。 
* [0.x.109]*
   除法。 
* [0.x.110]*
   从内存中加载[2.x.50]到调用类中，从给定的地址开始。内存不需要按32字节对齐，与之相对应的是将一个双倍地址投给VectorizedArray<double>*。 
* [0.x.111]*
   将调用类的内容以[2.x.51]size()的形式写入内存到给定地址。内存不需要按32字节对齐，相对于将双倍地址投给VectorizedArray<double>*来说。 
* [0.x.112]* [2.x.52] [2.x.53]。  
* [2.x.54] 内存必须以32字节对齐。 
* [0.x.113]*
   将[2.x.55]从内存中加载到调用的类中，从给定的地址和给定的偏移量开始，从偏移量开始的每个条目提供一个矢量数组的元素。    这个操作对应于以下代码（但在硬件允许的情况下，使用了更有效的实现）。 
* [1.x.12]
   
* [0.x.114]*
   将调用类的内容以[2.x.56]size()的形式写入内存，到给定的地址和给定的偏移量，将矢量数组的元素填入每个偏移量。    这个操作对应于下面的代码（但在硬件允许的情况下使用了更有效的实现）。 
* [1.x.13]
*   
* [0.x.115]*
   实际的数据字段。为了与标准布局类型保持一致，并且能够与外部SIMD功能进行交互，这个成员被声明为公共的。 
* [0.x.116]*
   返回这个字段的平方根。不适合在用户代码中使用。使用sqrt(x)代替。 
* [0.x.117]*
   返回这个字段的绝对值。不适合在用户代码中使用。请使用abs(x)代替。 
* [0.x.118]*
   返回这个字段和另一个字段的分量上的最大值。不适合在用户代码中使用。使用max(x,y)代替。 
* [0.x.119]*
   返回这个字段和另一个字段的最小分量。不适合在用户代码中使用。使用min(x,y)代替。 
* [0.x.120]*
 double和AVX的特殊化。

* 
* [0.x.121]*
 双重和AVX的特殊化。

* 
* [0.x.122]*
 为双数和AVX的特殊化。

* 
* [0.x.123]*
 双重和AVX的特殊化。

* 
* [0.x.124]*
 浮动和AVX的特殊化。

* 
* [0.x.125]*
   这给出了数组元素的类型。 
* [0.x.126]*
   默认的空构造函数，使数据处于未初始化的状态，类似于float/double。 
* [0.x.127]*
   用给定的标量构建一个数组广播到所有的通道。 
* [0.x.128]*
   这个函数可以用来将所有的数据字段设置为一个给定的标量。 
* [0.x.129]*
   访问操作符。 
* [0.x.130]*
   常数访问运算符。 
* [0.x.131]*
   加法。 
* [0.x.132]*
   减法。 
* [0.x.133]*
   乘法。 
* [0.x.134]*
   除法。 
* [0.x.135]*
   从内存中加载[2.x.57]到调用类中，从给定的地址开始。内存不需要按32字节对齐，与之相对应的是将一个浮点地址投给VectorizedArray<float>*。 
* [0.x.136]*
   将调用类的内容以[2.x.58]size()的形式写入内存到给定地址。内存不需要按32字节对齐，与之相对应的是将浮点地址投给VectorizedArray<float>*。 
* [0.x.137]* [2.x.59] [2.x.60]。  
* [2.x.61] 内存必须以32字节对齐。 
* [0.x.138]*
   将[2.x.62]从内存中加载到调用的类中，从给定的地址和给定的偏移量开始，从偏移量开始的每个条目提供一个矢量数组的元素。    这个操作对应于以下代码（但在硬件允许的情况下，使用了更有效的实现）。 
* [1.x.14]
   
* [0.x.139]*
   将调用类的内容以[2.x.63]size()的形式写入内存，到给定的地址和给定的偏移量，将矢量数组的元素填入每个偏移量。    这个操作对应于下面的代码（但在硬件允许的情况下使用了更有效的实现）。 
* [1.x.15]
*   
* [0.x.140]*
   实际的数据字段。为了与标准布局类型保持一致，并能与外部SIMD功能进行交互，这个成员被声明为公共的。 
* [0.x.141]*
   返回这个字段的平方根。不适合在用户代码中使用。使用sqrt(x)代替。 
* [0.x.142]*
   返回这个字段的绝对值。不适合在用户代码中使用。请使用abs(x)代替。 
* [0.x.143]*
   返回这个字段和另一个字段的分量上的最大值。不适合在用户代码中使用。使用max(x,y)代替。 
* [0.x.144]*
   返回这个字段和另一个字段的最小分量。不适合在用户代码中使用。使用min(x,y)代替。 
* [0.x.145]*
 浮点数和AVX的特殊化。

* 
* [0.x.146]*
 浮点和AVX的特殊化。

* 
* [0.x.147]*
 浮动和AVX的特殊化。

* 
* [0.x.148]*
 浮动和AVX的特殊化。

* 
* [0.x.149]*
 对双倍数和SSE2的特殊化。

* 
* [0.x.150]*
   这给出了数组元素的类型。 
* [0.x.151]*
   默认的空构造函数，让数据处于未初始化的状态，类似于float/double。 
* [0.x.152]*
   用给定的标量构建一个数组广播到所有的通道。 
* [0.x.153]*
   这个函数可以用来将所有的数据字段设置为一个给定的标量。 
* [0.x.154]*
   访问操作符。 
* [0.x.155]*
   常数访问运算符。 
* [0.x.156]*
   加法。 
* [0.x.157]*
   减法。 
* [0.x.158]*
   乘法。 
* [0.x.159]*
   除法。 
* [0.x.160]*
   从内存中加载[2.x.64]到调用类中，从给定的地址开始。内存不需要对齐16个字节，相对于将双倍地址投给VectorizedArray<double>*来说。 
* [0.x.161]*
   将调用类的内容以[2.x.65]size()的形式写到内存中的给定地址。内存不需要对齐16个字节，相对于将双倍地址投给VectorizedArray<double>*来说。 
* [0.x.162]* [2.x.66] [2.x.67]。  
* [2.x.68] 内存必须以16字节对齐。 
* [0.x.163]*
   将[2.x.69]从内存中加载到调用的类中，从给定的地址和给定的偏移量开始，从偏移量开始的每个条目提供一个矢量数组的元素。    这个操作对应于以下代码（但在硬件允许的情况下，使用了更有效的实现）。 
* [1.x.16]
   
* [0.x.164]*
   将调用类的内容以[2.x.70]size()的形式写入内存，到给定的地址和给定的偏移量，将矢量数组的元素填入每个偏移量。    这个操作对应于下面的代码（但在硬件允许的情况下使用了更有效的实现）。 
* [1.x.17]
   
* [0.x.165]*
   实际的数据字段。为了与标准布局类型保持一致，并且能够与外部SIMD功能进行交互，这个成员被声明为公共的。 
* [0.x.166]*
   返回这个字段的平方根。不适合在用户代码中使用。使用sqrt(x)代替。 
* [0.x.167]*
   返回这个字段的绝对值。不适合在用户代码中使用。请使用abs(x)代替。 
* [0.x.168]*
   返回这个字段和另一个字段的分量上的最大值。不适合在用户代码中使用。使用max(x,y)代替。 
* [0.x.169]*
   返回这个字段和另一个字段的最小分量。不适合在用户代码中使用。使用min(x,y)代替。 
* [0.x.170]*
 double和SSE2的特殊化。

* 
* [0.x.171]*
 对double和SSE2的特殊化。

* 
* [0.x.172]*
 双重和SSE2的特殊化。

* 
* [0.x.173]*
 双重和SSE2的特殊化。

* 
* [0.x.174]*
 浮动和SSE2的特殊化。

* 
* [0.x.175]*
   这给出了数组元素的类型。 
* [0.x.176]*
   这个函数可以用来将所有的数据字段设置为一个给定的标量。 
* [0.x.177]*
   默认的空构造函数，让数据处于未初始化的状态，类似于float/double。 
* [0.x.178]*
   构造一个数组，将给定的标量广播给所有通道。 
* [0.x.179]*
   访问操作符。 
* [0.x.180]*
   常数访问操作符。 
* [0.x.181]*
   加法。 
* [0.x.182]*
   减法。 
* [0.x.183]*
   乘法。 
* [0.x.184]*
   除法。 
* [0.x.185]*
   从内存中加载[2.x.71]到调用类中，从给定的地址开始。内存不需要对齐16个字节，相对于将浮点地址投给VectorizedArray<float>*来说。 
* [0.x.186]*
   将调用类的内容以[2.x.72]size()的形式写入内存到给定地址。内存不需要对齐16个字节，与之相对应的是将浮点地址投给VectorizedArray<float>*。 
* [0.x.187]* [2.x.73] [2.x.74]。  
* [2.x.75] 内存必须以16字节对齐。 
* [0.x.188]*
   将[2.x.76]从内存中加载到调用的类中，从给定的地址和给定的偏移量开始，从偏移量开始的每个条目提供一个矢量数组的元素。    这个操作对应于以下代码（但在硬件允许的情况下，使用了更有效的实现）。 
* [1.x.18]
   
* [0.x.189]*
   将调用类的内容以[2.x.77]size()的形式写入内存，到给定的地址和给定的偏移量，将矢量数组的元素填入每个偏移量。    这个操作对应于下面的代码（但在硬件允许的情况下使用了更有效的实现）。 
* [1.x.19]
*   
* [0.x.190]*
   实际的数据字段。为了与标准布局类型保持一致，并且能够与外部SIMD功能进行交互，这个成员被声明为公共的。 
* [0.x.191]*
   返回这个字段的平方根。不适合在用户代码中使用。使用sqrt(x)代替。 
* [0.x.192]*
   返回该字段的绝对值。不适合在用户代码中使用。请使用abs(x)代替。 
* [0.x.193]*
   返回这个字段和另一个字段的分量上的最大值。不适合在用户代码中使用。使用max(x,y)代替。 
* [0.x.194]*
   返回这个字段和另一个字段的最小分量。不适合在用户代码中使用。使用min(x,y)代替。 
* [0.x.195]*
 对float和SSE2的特殊化。

* 
* [0.x.196]*
 对浮点和SSE2的特殊化。

* 
* [0.x.197]*
 浮动和SSE2的特殊化。

* 
* [0.x.198]*
 浮动和SSE2的特殊化。

* 
* [0.x.199]*
   这给出了数组元素的类型。 
* [0.x.200]*
   默认的空构造函数，让数据处于未初始化的状态，类似于float/double。 
* [0.x.201]*
   用给定的标量构建一个数组广播到所有的通道。 
* [0.x.202]*
   这个函数将一个标量分配给这个类。 
* [0.x.203]*
   访问操作符。该组件必须是0或1。 
* [0.x.204]*
   常数访问运算符。 
* [0.x.205]*
   加法。 
* [0.x.206]*
   减法。 
* [0.x.207]*
   乘法。 
* [0.x.208]*
   除法。 
* [0.x.209]*
   从内存中加载[2.x.78]到调用类中，从给定的地址开始。 
* [0.x.210]*
   将调用类的内容以[2.x.79]size()的形式写进内存，到给定的地址。 
* [0.x.211]*
   实际的数据字段。为了与标准布局类型保持一致，并且能够与外部SIMD功能进行交互，这个成员被声明为公共的。 
* [0.x.212]*
   返回这个字段的平方根。不适合在用户代码中使用。使用sqrt(x)代替。 
* [0.x.213]*
   返回该字段的绝对值。不适合在用户代码中使用。请使用abs(x)代替。 
* [0.x.214]*
   返回这个字段和另一个字段的分量上的最大值。不适合在用户代码中使用。使用max(x,y)代替。 
* [0.x.215]*
   返回这个字段和另一个字段的最小分量。不适合在用户代码中使用。使用min(x,y)代替。 
* [0.x.216]*
   这给出了数组元素的类型。 
* [0.x.217]*
   默认的空构造函数，让数据处于未初始化的状态，类似于float/double。 
* [0.x.218]*
   用给定的标量构建一个数组，广播给所有通道。 
* [0.x.219]*
   这个函数将一个标量分配给这个类。 
* [0.x.220]*
   访问操作符。该分量必须在0和3之间。 
* [0.x.221]*
   常数访问运算符。 
* [0.x.222]*
   加法。 
* [0.x.223]*
   减法。 
* [0.x.224]*
   乘法。 
* [0.x.225]*
   除法。 
* [0.x.226]*
   从内存中加载[2.x.80]到调用类中，从给定的地址开始。 
* [0.x.227]*
   将调用类的内容以[2.x.81]size()的形式写进内存，到给定的地址。 
* [0.x.228]*
   实际的数据字段。为了与标准布局类型保持一致，并且能够与外部SIMD功能进行交互，这个成员被声明为公共的。 
* [0.x.229]*
   返回这个字段的平方根。不适合在用户代码中使用。使用sqrt(x)代替。 
* [0.x.230]*
   返回这个字段的绝对值。不适合在用户代码中使用。使用abs(x)代替。 
* [0.x.231]*
   返回这个字段和另一个字段的分量上的最大值。不适合在用户代码中使用。使用max(x,y)代替。 
* [0.x.232]*
   返回这个字段和另一个字段的最小分量。不适合在用户代码中使用。使用min(x,y)代替。 
* [0.x.233]*
  [2.x.82] 用VectorizedArray进行算术运算

* 
* [0.x.234]*
 对VectorizedArray的关系运算符==。
* [2.x.83] VectorizedArray的运算

* 
* [0.x.235]*
 用操作符+对两个矢量数组进行加法。
* [2.x.84] VectorizedArray

* 
* [0.x.236]*
 两个矢量数组的减法，用操作符
* 
* - 
* [2.x.85] 矢量Array

* 
* [0.x.237]*
 用运算符对两个矢量数组进行乘法。
* [2.x.86] 矢量Array

* 
* [0.x.238]*
 用运算符/对两个矢量数组进行除法。
* [2.x.87] VectorizedArray

* 
* [0.x.239]*
 一个标量（用[2.x.88] size()相等的条目扩展为一个向量数组）和一个向量数组的加法。
* [2.x.89] VectorizedArray

* 
* [0.x.240]*
 在标量是双数的情况下，标量的加法（扩展为矢量数组，[2.x.90] size()相等的条目）和矢量数组的加法（为了能够用通常是双数的常量编写简单的代码而需要）。
* [2.x.91] 矢量Array

* 
* [0.x.241]*
 矢量数组和标量的相加（扩展为一个具有[2.x.92]等量项的矢量数组）。
* [2.x.93] VectorizedArray

* 
* [0.x.242]*
 在标量为双数的情况下，将一个矢量数组和一个标量相加（扩展为一个具有[2.x.94]相等条目的矢量数组）（为了能够用通常为双数的常量编写简单的代码而需要）。
* [2.x.95] 矢量化数组

* 
* [0.x.243]*
 从标量中减去一个矢量数组（扩展为一个具有[2.x.96]相等条目的矢量数组）。
* [2.x.97] VectorizedArray

* 
* [0.x.244]*
 在标量为双数的情况下，从标量中减去一个矢量数组（扩展为一个具有[2.x.98]相等条目的矢量数组）（为了能够用通常为双数的常数编写简单的代码而需要）。
* [2.x.99] 矢量化数组

* 
* [0.x.245]*
 从一个矢量数组中减去一个标量（扩展为一个矢量数组，[2.x.100] size()等于条目）。
* [2.x.101] VectorizedArray

* 
* [0.x.246]*
 从一个矢量数组中减去一个标量（扩展为一个矢量数组，[2.x.102] size()相等的条目），如果该标量是一个双数（为了能够用通常是双数的常量编写简单的代码而需要）。
* [2.x.103] 矢量Array

* 
* [0.x.247]*
 一个标量（扩展为一个具有[2.x.104] size()等分项的向量数组）和一个向量数组的乘法。
* [2.x.105] 矢量Array

* 
* [0.x.248]*
 在标量是双数的情况下，标量（扩展为一个矢量数组，[2.x.106] size()相等的条目）和矢量数组的乘法（为了能够用通常是双数的常量编写简单的代码而需要）。
* [2.x.107] 矢量Array

* 
* [0.x.249]*
 矢量数组和标量的乘法（扩展为具有[2.x.108]相等条目的矢量数组）。
* [2.x.109] VectorizedArray

* 
* [0.x.250]*
 在标量为双数的情况下，矢量数组和标量的乘法（扩展为具有[2.x.110]相等条目的矢量数组）（为了能够用通常为双数的常量编写简单的代码而需要）。
* [2.x.111] 矢量化数组

* 
* [0.x.251]*
 标量（扩展为矢量数组，[2.x.112] size()等于条目）与矢量数组之间的商。
* [2.x.113] 矢量Array

* 
* [0.x.252]*
 在标量是双数的情况下，标量（扩展为具有[2.x.114]size()相等条目的向量数组）和向量数组之间的商（为了能够用通常为双数的常量编写简单的代码，需要）。
* [2.x.115] 矢量Array

* 
* [0.x.253]*
 矢量数组和标量之间的商（扩展为具有[2.x.116]相等条目的矢量数组）。
* [2.x.117] 矢量Array

* 
* [0.x.254]*
 在标量为双数的情况下，矢量数组和标量之间的商（扩展为具有[2.x.118]相等条目的矢量数组）（为了能够用通常为双数的常量编写简单的代码而需要）。
* [2.x.119] 矢量化数组

* 
* [0.x.255]*
 矢量化数组上的单项运算符+。
* [2.x.120] 矢量Array

* 
* [0.x.256]*
 单元运算符
* 
* - 在一个矢量化数组上。
* [2.x.121] 矢量Array

* 
* [0.x.257]*
 矢量化数组的输出运算符。
* [2.x.122] 矢量Array

* 
* [0.x.258]*
  [2.x.123] 对VectorizedArray的三元操作

* 
* [0.x.259]*
 编码二进制操作的枚举类，用于对VectorizedArray数据类型进行组件式比较。
* 

* 
* [2.x.124] 在SIMD矢量化（sse, avx, av512）的情况下，我们选择相应的有序、非信号（ [2.x.125] ）变体。

* 
* [0.x.260]*
 计算以下三元操作的矢量等价物。

* 
* [1.x.20]
* 其中[2.x.126] , [2.x.127] , 和 [2.x.128] )。
* 当控制流本身取决于（计算的）数据时，这样的计算成语作为分支的替代是很有用的。例如，在标量数据类型的情况下，语句[2.x.129]也可以使用[2.x.130]语句来实现。

* 
* [1.x.21]
* 然而，这在向量化的情况下是根本不可能的，因为不同的向量条目（通道）需要不同的决定，所以必须使用第一个变体（基于三元运算符）来代替。

* 
* [1.x.22]
* 一些更具说明性的例子（比专用的[2.x.131]重载效率低）。

* 
* [1.x.23]
* 
* 更确切地说，这个函数首先计算一个（布尔）掩码，它是二进制运算符[2.x.132]应用于VectorizedArray参数[2.x.133]和[2.x.134]的所有元素的结果，然后掩码被用来选择[2.x.135]的相应组件（如果二进制运算相当于真），或者[2.x.136]二进制运算符通过SIMDComparison模板参数[2.x.137]编码。
* 为了方便通用编程方法，该函数为所有VectorizedArray<Number>变体以及通用POD类型（如double和float）提供重载。
* 

* 
* [2.x.138] 为了使这个函数工作，二进制操作必须通过SIMDComparison模板参数进行编码。这也解释了为什么[2.x.140]是一个编译时常量模板参数，而不是一个常量函数参数。为了能够发出正确的低级指令，编译器必须在编译时知道比较的情况。

* 
* [0.x.261]*
 上述函数对非矢量化的VectorizedArray<Number, 1>变体的特殊化。

* 
* [0.x.262]*
 在VectorizedArray上实现来自cmath的函数。这些函数不在dealii命名空间中，以确保与cmath中的相关函数有类似的接口。相反，使用[2.x.141]调用它们。

* 
* [0.x.263]*
   计算一个矢量数据域的正弦。结果将以<tt>{sin(x[0]), sin(x[1]), ..., [2.x.142] [2.x.143] VectorizedArray的形式返回。 
* [0.x.264]*
   计算一个矢量数据域的余弦。结果以矢量数组的形式返回<tt>{cos(x[0]), cos(x[1]), ..., cos(x[size()-1]) }</tt>。     [2.x.144] 矢量Array  
* [0.x.265]*
   计算一个矢量数据域的正切。结果以矢量数组的形式返回<tt>{tan(x[0]), tan(x[1]), ..., tan(x[size()-1]) }</tt>。     [2.x.145] 矢量Array  
* [0.x.266]*
   计算一个矢量数据域的指数。结果以矢量数组的形式返回<tt>{exp(x[0]), exp(x[1]), ..., exp(x[size()-1]) }</tt>。     [2.x.146] VectorizedArray  
* [0.x.267]*
   计算一个矢量数据域的自然对数。结果以矢量数组的形式返回<tt>{log(x[0]), log(x[1]), ..., log(x[size()-1])}</tt>。     [2.x.147] VectorizedArray  
* [0.x.268]*
   计算一个矢量数据域的平方根。结果以矢量数组的形式返回<tt>{sqrt(x[0]), sqrt(x[1]), ..., sqrt(x[size()-1]) }</tt>。     [2.x.148] 矢量Array  
* [0.x.269]*
   将给定的数字[2.x.149]提高到幂数[2.x.150]，用于一个矢量数据域。结果以矢量数组的形式返回<tt>{pow(x[0],p), pow(x[1],p), ..., pow(x[size()-1], p)}</tt>。     [2.x.151]矢量Array  
* [0.x.270]*
   将给定的数字[2.x.152]提高到幂数[2.x.153]，用于一个矢量数据域。结果以矢量数组的形式返回<tt>{pow(x[0],p[0]), pow(x[1],p[1]), ..., pow(x[size()-1],p[size()-1]) }</tt>。     [2.x.154] 矢量Array  
* [0.x.271]*
   计算一个矢量数据字段的绝对值（模数）。结果以矢量数组的形式返回<tt>{abs(x[0]), abs(x[1]), ..., abs(x[size()-1]) }</tt>。     [2.x.155] VectorizedArray  
* [0.x.272]*
   计算两个矢量数据域的分量最大。结果以矢量数组的形式返回<tt>{max(x[0],y[0]), max(x[1],y[1), ...}</tt>。     [2.x.156] VectorizedArray  
* [0.x.273]*
   计算两个矢量数据域的分量最小值。结果以矢量数组的形式返回<tt>{min(x[0],y[0]), min(x[1],y[1), ...}</tt>。     [2.x.157] 矢量Array  
* [0.x.274]*
   VectorizedArrayIterator的迭代器特质。 
* [0.x.275]

