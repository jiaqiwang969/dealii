include/deal.II-translator/base/geometry_info_0.txt
[0.x.0]*
 一个可以表示三角形所组成的各种对象的类：顶点、线、四边形和六边形。
* 这个类是相当原始的：它只存储一个整数，代表所代表对象的维度。换句话说，这个类主要是作为一种传递对象的方式，它的数据类型解释了它的作用（不像只是传递一个整数），并为这些对象提供符号名称，如[2.x.0]而不是一个整数0。
* 由于能够用所代表的对象的积分维度来识别这些对象，这个类提供了与无符号整数的转换操作符。

* 
* [0.x.1]*
   一个枚举，为可由该类表示的对象提供符号名称。这些符号名称的数值等于代表对象的几何维度，以使整数变量的转换更加简单。 
* [0.x.2]*
     一个顶点。   
* [0.x.3]*
     一条线。   
* [0.x.4]*
     一个四边形。   
* [0.x.5]*
     一个六面体。   
* [0.x.6]*
   构造函数。用给定的参数初始化对象，代表一个顶点、线等。 
* [0.x.7]*
   构造函数。用一个整数初始化对象，该整数应代表有关几何对象的尺寸。这通常是一个介于零（顶点）和三（六面体）之间的数字。 
* [0.x.8]*
   返回当前表示的对象的积分维度，即0代表顶点，1代表线，等等。 
* [0.x.9]*
   当前代表的对象。 
* [0.x.10]*
 一个提供当前空间维度下各向同性和各向异性细化标志的可能选择的类。
* 除了在一些奇怪的模板结构中，这个一般的模板是不用的。然而，实际使用的是专业化的 [2.x.1], [2.x.2] , 和 [2.x.3] 。
* 

* 
* [2.x.4] 

* 
* [0.x.11]*
   在当前维度的细化情况下，可能的数值。    注意数值的构造：最低位描述的是X轴的切面，第二至最低位对应的是Y轴的切面，第三至最低位对应的是Z轴的切面。因此，以下关系成立（除其他外）。   
* [1.x.0]
* 当然，只提供那些在特定空间维度上合理的切割。    此外，标签[2.x.5]表示在这个类的模板参数所选择的空间维度上的各向同性细化。    如果你选择了各向异性的细化，例如通过传递[2.x.6]的参数[2.x.7][2.x.8][2.x.9]中的一个标志或这些标志的组合，那么请记住，X、Y或Z方向的细化是针对单元的[2.x.10]局部[2.x.11]坐标系进行的。换句话说，这些标志决定了单元格的哪些边和面将被切割成新的边和面。另一方面，这个过程与细胞在[2.x.12]全局[2.x.13]坐标系中的方向无关，你不应该假定细胞的局部坐标系在它所在空间的全局坐标系中的任何特定方向。 
* [0.x.12]*
     不要进行细化。   
* [0.x.13]*
     执行各向同性的细化。这意味着在所有坐标方向进行细化。对于当前的一般模板类
* 
* - 因为有针对1d、2d和3d情况的特殊性，所以从未使用过
* 
* - ，我们简单地将这个数字设置为一个有所有比特设置的值。RefinementPossibilities<1>、RefinementPossibilities<2>和RefinementPossibilities<3>中的特殊化将相应的`enum`元素设置为更合理的值。   
* [0.x.14]*
 一个提供当前空间维度下各向同性和各向异性细化标志的可能选择的类。
* 这个特化用于[2.x.14]，它提供X方向的细化。
* 

* 
* [2.x.15] 

* 
* [0.x.15]*
   在当前维度的细化情况下，可能的数值。    注意数值的构造：最低位描述的是x轴的切面，第二至最低位对应的是y轴的切面，第三至最低位对应的是z轴的切面。因此，以下关系成立（除其他外）。   
* [1.x.1]
* 当然，只提供那些在特定空间维度上合理的切割。    此外，标签[2.x.16]表示在这个类的模板参数所选择的空间维度上的各向同性细化。    如果你选择各向异性的细化，例如通过传递[2.x.17]的一个参数作为标志[2.x.18] [2.x.19] [2.x.20]或这些标志的组合，那么请记住，X、Y或Z方向的细化是在单元的[2.x.21]局部[2.x.22]坐标系中进行。换句话说，这些标志决定了单元格的哪些边和面将被切割成新的边和面。另一方面，这个过程与细胞在[2.x.23]全局[2.x.24]坐标系中的方向无关，你不应该假定细胞的局部坐标系在它所处空间的全局坐标系中的任何特定方向。 
* [0.x.16]*
     不要细化。   
* [0.x.17]*
     在X方向上进行切割。   
* [0.x.18]*
     进行各向同性的精细化处理。   
* [0.x.19]*
 一个提供在当前空间维度上各向同性和各向异性细化标志的可能选择的类。
* 这个特殊化用于[2.x.25]，它提供了在X方向和Y方向分别进行细化，以及同时在两个方向进行各向同性的细化。
* 

* 
* [2.x.26] 

* 
* [0.x.20]*
   在当前维度的细化情况下，可能的数值。    注意数值的构造：最低位描述的是x轴的切面，第二至最低位对应的是y轴的切面，第三至最低位对应的是z轴的切面。因此，以下关系成立（除其他外）。   
* [1.x.2]
* 当然，只提供那些在特定空间维度上合理的切割。    此外，标签[2.x.27]表示在这个类的模板参数所选择的空间维度上的各向同性细化。    如果你选择了各向异性的细化，例如通过传递[2.x.28]的参数[2.x.29][2.x.30][2.x.31]中的一个标志或这些标志的组合，那么请记住，X、Y或Z方向的细化是针对单元的[2.x.32]局部[2.x.33]坐标系进行的。换句话说，这些标志决定了单元格的哪些边和面将被切割成新的边和面。另一方面，这个过程与细胞在[2.x.34]全局[2.x.35]坐标系中的方向无关，你不应该假定细胞的局部坐标系在它所处空间的全局坐标系中的任何特定方向。 
* [0.x.21]*
     不要细化。   
* [0.x.22]*
     在X方向上进行切割。   
* [0.x.23]*
     在Y方向上进行切割。   
* [0.x.24]*
     在x方向和y方向上进行切割。   
* [0.x.25]*
     执行各向同性的细化。   
* [0.x.26]*
 一个提供在当前空间维度上各向同性和各向异性细化标志的可能选择的类。
* 这个特殊化用于[2.x.36]，它提供了在x、y和z方向上分别进行细化，以及这些细化的组合和同时在所有方向上进行各向同性的细化。
* 

* 
* [2.x.37] 

* 
* [0.x.27]*
   在当前维度的细化情况下，可能的数值。    注意数值的构造：最低位描述的是x轴的切面，第二至最低位对应的是y轴的切面，第三至最低位对应的是z轴的切面。因此，以下关系成立（除其他外）。   
* [1.x.3]
* 当然，只提供那些在特定空间维度上合理的切割。    此外，标签[2.x.38]表示在这个类的模板参数所选择的空间维度上的各向同性细化。    如果你选择了各向异性的细化，例如通过传递[2.x.39]的参数[2.x.40][2.x.41][2.x.42]中的一个标志或这些标志的组合，那么请记住，X、Y或Z方向的细化是在单元的[2.x.43]局部[2.x.44]坐标系下进行的。换句话说，这些标志决定了单元格的哪些边和面将被切割成新的边和面。另一方面，这个过程与细胞在[2.x.45]全局[2.x.46]坐标系中的方向无关，你不应该假定细胞的局部坐标系在它所处空间的全局坐标系中的任何特定方向。 
* [0.x.28]*
     不要细化。   
* [0.x.29]*
     在X方向上进行切割。   
* [0.x.30]*
     在Y方向上进行切割。   
* [0.x.31]*
     在x和y方向上进行切割。   
* [0.x.32]*
     在Z方向上进行切割。   
* [0.x.33]*
     在x方向和y方向上进行切割。   
* [0.x.34]*
     在X和Y方向上进行切割。   
* [0.x.35]*
     在X、Y和Z方向上进行切割。   
* [0.x.36]*
     进行各向同性的精细化处理。   
* [0.x.37]*
 一个存储具有[2.x.47]维度的对象的可能的各向异性和各向同性的细化情况的类（例如，对于一条直线[2.x.48]在任何空间维度，对于一个四边形[2.x.49]，等等）。这个类的可能值是在基类中声明的枚举中列出的；更多信息请看那里。
* 

* 
* [2.x.50] 

* 
* [0.x.38]*
   默认构造函数。用no_refinement初始化细化情况。 
* [0.x.39]*
   构造函数。从基类中指定的可能的细化列表中获取并存储一个表示特定细化的值。 
* [0.x.40]*
   构造函数。取并存储一个表示特定细化的值，作为一个位域。为了避免隐式转换到积分值或从积分值转换，这个构造函数被标记为显式。 
* [0.x.41]*
   返回这个类所存储的数字值。虽然这个操作符的存在看起来很危险，但在人们希望有类似<tt>switch (refinement_flag)... case [2.x.51] ... 的代码的情况下，它是很有用的。</tt>，它可以写成 [2.x.52] 。  另一个应用是使用当前类型的对象作为数组的索引；然而，这种用法已被废弃，因为它假定了从RefinementPossibilities基类中定义的符号标志到实际数值（数组索引）的某种映射。 
* [0.x.42]*
   返回当前对象所代表的细化标志和作为参数给出的细化标志的联合。 
* [0.x.43]*
   返回当前对象所代表的细化标志和作为参数给出的细化标志的交集。 
* [0.x.44]*
   返回当前对象所代表的细化标志的否定值。例如，在2d中，如果当前对象持有标志[2.x.53]；如果当前值是[2.x.54]，那么结果将是[2.x.55]；等等。 
* [0.x.45]*
   返回与沿参数给出的轴线切割单元格相对应的标志。例如，如果[2.x.56]，则返回值为[2.x.57]。  
* [0.x.46]*
   返回该类型的对象所占用的内存量。 
* [0.x.47]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据读入或写入一个流中，以便进行序列化。 
* [0.x.48]*
   异常情况。 
* [0.x.49]*
   将细化情况存储为一个比特字段，在任何给定的维度上都有必要的比特。 
* [0.x.50]*
   一个提供一个面的所有可能情况的类（在当前空间维度[2.x.58]可能被细分为子面。对于[2.x.59]，它们对应于[2.x.60]中给出的情况。然而，[2.x.61]包括[2.x.62]的细化情况，但另外还有一些子面的可能性，一个面可能被细分为，这是在两个相邻单元中的一个上重复进行的各向异性细化步骤。    除了一些奇怪的模板结构，这个一般的模板是不用的。  然而，实际情况是，对[2.x.63]、[2.x.64]和[2.x.65]进行了专门化。   
* [2.x.66]   
* [0.x.51]*
     面被细分为子面的可能情况。   
* [0.x.52]*
       不要细化。     
* [0.x.53]*
       各向同性地进行细化。     
* [0.x.54]*
   一个提供所有可能情况的面（在当前空间维度[2.x.67]中可能被细分为子面的类。    对于[2.x.68]我们只提供一个假的实现。   
* [2.x.69]   
* [0.x.55]*
     面被细分为子面的可能情况。        假的实现。   
* [0.x.56]*
       不要细化。     
* [0.x.57]*
       各向同性地进行细化。     
* [0.x.58]*
   一个提供所有可能情况的面（在当前空间维度[2.x.70]可能被细分为子面的类。    对于[2.x.71]，没有面。因此，没有子面的可能性。   
* [2.x.72]   
* [0.x.59]*
     面被细分为子面的可能情况。        在1d中没有面，因此没有子面的可能性。   
* [0.x.60]*
       不要细化。     
* [0.x.61]*
       各向同性地进行细化。     
* [0.x.62]*
   一个提供一个面（在当前空间维度[2.x.73]中）可能被细分为子面的所有可能情况的类。    这个特殊化用于[2.x.74]，它提供了以下可能性：一个面（线）被细化（[2.x.75]）。   
* [2.x.76]   
* [0.x.63]*
     面被细分为子面的可能情况。        在2D中，有以下可能性：一个面（线）被细化（ [2.x.77] ）。   
* [0.x.64]*
       不进行细化。     
* [0.x.65]*
       在X方向上切割。     
* [0.x.66]*
       各向同性地细化。     
* [0.x.67]*
   一个提供一个面（在当前空间维度[2.x.78]中）可能被细分为子面的所有可能情况的类。    这个特殊化用于dim=3，它提供了以下可能性：一个面（四边形）在x方向或y方向（在面-内坐标系中）分别被细化，（ [2.x.79] 或（ [2.x.80] 相当于（ [2.x.81] ）。此外，它还提供了一个面通过在两个相邻单元中的一个单元上执行的重复各向异性细化步骤所能得到的可能性。 例如，有可能一个面（四边形）用[2.x.82]进行细化，之后左边的孩子又用[2.x.83]进行细化，这样就有了三个活跃的子面。然而，请注意，只允许在细化的情况下，两个六边形之间的面的每条线不超过一个悬挂节点。此外，不允许两个相邻的六面体被细化，使得其中一个六面体用[2.x.84]细化共同的面，而另一个六面体用[2.x.85]细化该面。事实上，[2.x.86]照顾到了这种情况，并确保精炼单元的每个面都完全包含在相邻单元的一个面中。    下图解释了SubfacePossibilities并给出了相应的子面编号。 
* [1.x.4]
*     
* [2.x.87]   
* [0.x.68]*
     面被细分为子面的可能情况。        关于子面可能性的更多细节，请参见SubfacePossibilities<3>的文档。   
* [0.x.69]*
   一个提供一个面（在当前空间维度[2.x.88]）可能被细分为子面的所有可能情况的类。   
* [2.x.89]   
* [0.x.70]*
     构造函数。在基类指定的可能情况列表中，取并存储一个表示特定子面可能性的值。   
* [0.x.71]*
     返回该类所存储的数值。虽然这个操作符的存在看起来很危险，但在人们希望有<code>switch (subface_case)... case [2.x.90] ... 这样的代码的情况下，它是很有用的。</code>，可以写成<code>switch [2.x.91] 另一个应用是使用当前类型的对象作为数组的索引；然而，这种用法已被废弃，因为它假定了从SubfacePossibilities基类中定义的符号标志到实际数值（数组索引）的某种映射。   
* [0.x.72]*
     返回该类型的对象所占用的内存量。   
* [0.x.73]*
     异常情况。   
* [0.x.74]*
     将细化情况存储为一个比特字段，在任何给定的维度上都有必要的比特。   
* [0.x.75]*
 这个类提供了一个零维单元的描述。它已经被ReferenceCell类所取代。
* 
* - 更多信息见那里。
* 零维单元的拓扑描述，即点。这个类可能看起来不是很有用，但是如果在某个维度上，我们想查询比现在低一个维度的对象的信息，例如关于面的信息，往往是有用的。
* 这个类包含了[2.x.92]网格单元的顶点和面的信息作为静态成员。该接口对所有维度都是一样的。如果一个值在低维单元中没有用处，它将被（正确地）设置为零，例如1d中的#max_children_per_face。
* 这个信息应该总是取代顶点、邻居等的硬编码数字，因为它可以独立使用维度。
* 

* 
* [2.x.93] 

* 
* [0.x.76]*
   一个单元格的最大子女数，即一个各向同性细化的单元格的子女数。    如果一个单元格是各向异性精炼的，实际的子代数可能少于这里给出的值。 
* [0.x.77]*
   一个单元有多少个面。 
* [0.x.78]*
   返回一个对象，它可以被认为是一个包含从零到`面孔_per_cell`所有索引的数组。这允许使用基于范围的for循环来编写以下类型的代码。 
* [1.x.5]
* 这里，我们在所有单元格的所有面进行循环，`face_index`使用所有有效的索引。    当然，由于这个类是针对`dim==0`的情况，返回的对象实际上是一个空数组。 
* [0.x.79]*
   一个精炼面的最大子女数，即一个各向同性的精炼面的子女数。    如果一个单元被各向异性地细化，实际的子代数可能少于这里给出的值。 
* [0.x.80]*
   返回用<tt>ref_case</tt>精炼的单元格（或面）的子数。因为我们在这里关注的是点，所以子节点的数量等于1。 
* [0.x.81]*
   一个单元格的顶点数。 
* [0.x.82]*
   返回一个对象，它可以被认为是一个包含从零到`顶点_per_cell'所有索引的数组。这允许使用基于范围的for循环来编写以下类型的代码。 
* [1.x.6]
* 这里，我们在所有单元格的所有顶点上循环，`vertex_index`使用所有有效的索引。    当然，由于这个类是针对`dim==0`的情况，返回的对象是一个只有一个条目的数组：0。这是因为维度为0的对象实际上只是一个单点，对应于一个顶点本身。 
* [0.x.83]*
   将面的顶点编号映射到单元的顶点编号，即给出面的<tt>顶点</tt>第1个顶点的单元顶点编号，例如[2.x.94]见本类文档2d部分N4点下的图片。    通过<tt>face_orientation</tt>, <tt>face_flip</tt> 和 <tt>face_rotation</tt> 参数，这个函数可以处理以标准和非标准方向的面。<tt>face_orientation</tt>默认为<tt>true</tt>，<tt>face_flip</tt>和<tt>face_rotation</tt>默认为<tt>false</tt>（标准方向）。在2d中，只有<tt>face_flip</tt>被考虑。更多信息请参见[2.x.95]的 "词汇表 "文章。    由于单元格的子节点是根据单元格的顶点排序的，这个调用被传递给child_cell_on_face()函数。  因此，这个函数只是child_cell_on_face()的一个包装器，给它起了一个暗示性的名字。    当然，由于这个类是针对`dim==0'的情况，这个函数没有被实现。 
* [0.x.84]*
   将面的行数映射到单元格行数，即给出面的<tt>行</tt>第1行的单元格行数，例如：[2.x.96] 通过<tt>面的方向</tt>，<tt>面的翻转</tt>和<tt>面的旋转</tt>参数，这个函数处理以标准和非标准方向为方向的面。<tt>face_orientation</tt>默认为<tt>true</tt>，<tt>face_flip</tt>和<tt>face_rotation</tt>默认为<tt>false</tt>（标准方向），在2d中没有影响。    当然，由于这个类是针对`dim==0'的情况，这个函数没有实现。 
* [0.x.85]*
   每个面所拥有的顶点数量。由于这在一维中没有用，我们提供了一个无用的数字（希望编译器在看到类似<tt>for (i=0; i<vertices_per_face; ++i)</tt>的结构时可以发出警告，至少在[2.x.97]是一个<tt>无符号int</tt>的情况下。 
* [0.x.86]*
   每个面有多少条线。 
* [0.x.87]*
   每个面的四边形的数量。 
* [0.x.88]*
   一个单元格的线数。 
* [0.x.89]*
   一个单元格的四边形的数量。 
* [0.x.90]*
   一个单元格的六面体的数量。 
* [0.x.91]*
   为UCD输出重新排列顶点。 对于以UCD格式写入的单元格，该字段的每个条目包含<tt>deal.II</tt>中与该位置的UCD编号相对应的一个顶点的编号。    典型的例子：写一个单元并安排顶点，这样UCD就能理解它们。   
* [1.x.7]
* 由于deal.II版本<=5.1中的顶点编号恰好与UCD的编号一致，这个字段也可以像old_to_lexicographic映射一样使用。 
* [0.x.92]*
   为OpenDX输出重新排列顶点。 对于一个被写成OpenDX格式的单元格，这个字段的每个条目都包含<tt>deal.II</tt>中的一个顶点的编号，它与这个位置的DX编号相对应。    典型的例子：写一个单元并安排顶点，这样OpenDX就能理解它们。   
* [1.x.8]
*   
* [0.x.93]*
 该类为构成单元的所有拓扑结构提供独立的维度信息，或[2.x.98]"参考单元"。这个类已经被ReferenceCell类所取代。
* 
* - 更多信息见那里。
* 

* 它是库中的一个中心点，关于参考单元的顶点、线或面的编号的信息被收集起来。因此，这个类的信息被广泛用于Triangulation对象的几何描述，以及代码的其他各个部分。特别是，它也是以独立于维度的方式编写代码的重点；例如，在2D中不写顶点0<=v<4的循环，而是写成[2.x.99]，从而使代码在3D中也能工作，而无需改变。
* 该类中最常用的部分是它的静态成员，如vertices_per_cell、faces_per_cell等。然而，该类也提供了关于更抽象的问题的信息，如面的方向等。下面的文档给出了许多这些概念的文字描述。
* 

* [1.x.9]
* 从5.2版本开始，deal.II基于一个编号方案，尽可能使用lexicographic排序（x跑得最快），因此试图采用一种'经典'排序。
* 2d中顶点和面（线）的排序定义为
 

* 
* 
* - 顶点的编号是按词法排序的
 

 
* 
* - 面（2d中的线）：首先是在x方向和y方向上有法线的两个面。对于每两个面：首先是法线为负坐标方向的面，然后是法线为正坐标方向的面，也就是说，面的排序是根据它们的法线指向
* 
* - , x,
* 
* - , y方向的法线排序。
* 

* 
* 
* - 线条的方向由点0对点1的方向表示，并且总是在其中一个坐标方向上
* 

* 
* 
* - 3d中的面线是有序的，这样诱导的2D局部坐标系（x,y）意味着（右手规则）面线法线方向的法线，见N2/。
* 由此产生的2d中顶点和面（线）的编号，以及线的方向，如下所示。

* 
* [1.x.10]
* 
* 请注意，在构建网格时，线的方向必须是正确的；但是，在细化时，它将自动被保留。
* 此外，我们定义子线的方向与父线相同，即<tt>line->child(0)->vertex(0)==line->vertex(0)</tt>，<tt>line->child(1)->vertex(1)==line->vertex(1)</tt>。这也意味着，第一条子线（<tt>line->child(0)</tt>）是位于旧线的顶点(0)的那条。
* 同样地，我们定义，一个四边形的四个子线与旧四边形的顶点相邻，并具有相同的编号。
* 请注意，关于这些约定的几个信息可以在运行或编译时从本类的成员函数和变量中提取出来。
* 

* [1.x.11]
* 当单元格中的点需要明确的坐标时（例如用于正交公式或试用函数的定义点），我们为单元格定义以下坐标系统。

* 
* [1.x.12]
* 
* 这里，顶点0是坐标系的原点，顶点1的坐标是<tt>(1,0)</tt>，顶点2在<tt>(0,1)</tt>，顶点3在<tt>(1,1)</tt>。[2.x.100]函数可以用来在运行时查询这些信息。
* 

* [1.x.13]
* 按照惯例，我们将对三空间维度的六面体的顶点、线和面使用以下编号惯例。在给出这些约定之前，我们声明以下草图是绘制六面体的三维图片的标准方式。

* 
* [1.x.14]
* 图片的左边部分显示的是立方体的左面、底部和背面，而右边的应是顶部、右侧和正面。你可以通过将这两部分移到一起恢复整个立方体。
* 请再次注意，以下几个约定的信息可以在运行或编译时从本类的成员函数和变量中提取。
* [1.x.15]
* 3d中顶点的排序是由与2D情况相同的规则定义的。特别是，以下情况仍然是真实的。
* 

* 
* 
* - 顶点的编号是按词法排序的。
* 因此，顶点的编号方式如下

* 
* [1.x.16]
* 
* 我们注意到，首先，底面的顶点（z=0）的编号方式与四边形的顶点完全相同。然后将底面的顶点(z=1)移到顶面，进行类似的编号。同样，[2.x.101]函数可以用来在运行时查询这些信息。
* 

* [1.x.17]
* 这里，与顶点的情况相同。
* 

* 
* 
* - 3d中的线序。 [2.x.102] [2.x.103] 首先是面(z=0)的线，按2D线排序，[2.x.104] 然后是面(z=1)的线，按2D线排序，[2.x.105] 最后是Z方向的线，按lexicographic排序[2.x.106] 。

 
* [1.x.18]
* 如同在2d中，线是以坐标方向指向的。

* 
* [1.x.19]
* 
* 边缘（就像顶点和面）是以其自身的权利存储的实体，而不是在每次需要时从单元格中构造出来，这一事实意味着相邻的单元格实际上有指向边缘的指针，因此它们之间是共享的。这意味着平行边的集合具有平行方向的约定不仅仅是一个局部条件。在单元格列表被传递给Triangulation类的对象以创建三角形之前，你必须确保单元格的方向是兼容的，这样边的方向才是全局的，符合上述惯例。然而，GridReordering类可以为你做到这一点，它可以对输入单元的任意列表中的单元和边进行重新定向，这些单元不需要已经被排序。
* [1.x.20]
* 3D中面的编号是由一个类似2D的规则来定义的。
* 

* 
* 
* - 面（3d中的四边形）：首先是在x-方向有法线的两个面，然后是y-和z-方向。对于每两个面：首先是法线在负坐标方向的面，然后是法线在正方向的面，也就是说，面的顺序是根据它们的法线指向
* 
* - , x,
* 
* - , y,
* 

* 
* 
* - ，Z方向。
* 因此，面的编号顺序为：左、右、前、后、底、顶面。

 
* [1.x.21]
* 
* 面的[2.x.107]标准[2.x.108]方向是这样的，即诱导的2d局部坐标系（x,y）意味着（右手规则）面法线方向的法线，见N2a）。 在下文中，我们展示了局部坐标系和面线的编号。 [2.x.109] [2.x.110] 面的0和1。
* [1.x.22]
 
* [2.x.111] 脸部2和3。
* [1.x.23]
* 
* [2.x.112] 脸部4和5。
* [1.x.24]
* [2.x.113] 
* 面的行号（0,1,2,3）对应于以下细胞行号。 [2.x.114] [2.x.115] 面0：第8、10、0、4行； [2.x.116] 面1：第9、11、1、5行； [2.x.117] 面2：第2、6、8、9行； [2.x.118 ] 面部3：第3、7、10、11行； [2.x.119] 面部4：第0、1、2、3行； [2.x.120] 面部5：第4、5、6、7行； [2.x.121] 你可以用[2.x.122]函数得到这些数字。
*脸部法线可以通过应用右手规则（x,y
* 
-> 法线）。)  我们注意到，在2D的标准方向上，面0和面2的法线指向单元格内，面1和面3的法线指向外。在3D中，面0、2和4的法线指向单元格内，而面1、3和5的法线指向外面。这些信息同样可以从[2.x.123]中查询到。
* 然而，事实证明，大量的三维网格不能满足这个约定。这是由于一个单元的面的约定已经暗示了相邻单元的东西，因为它们共享一个共同的面，对第一个单元的固定也固定了两个单元的相对面的法向量。很容易构建单元格循环的案例，对于这些案例，我们无法为所有面找到与该约定一致的方向。
* 由于这个原因，上述惯例只是我们所说的[2.x.124]标准方向[2.x.125] ......II实际上允许3d中的面要么有标准方向，要么有其相反的方向，在这种情况下，构成单元格的线会有还原的顺序，上述线的等价关系就不再成立了。你可以通过调用<tt>cell->face_orientation(face_no)</tt>来询问一个单元格的某个面是否有标准方向：如果结果是[2.x.126]，那么这个面就有标准方向，否则它的法向量就指向另一个方向。在应用程序中，你需要这些信息的地方其实并不多，但库中有几个地方用到了这个信息。注意，在2d中，结果总是[2.x.127]关于这个主题的更多信息可以在这个[2.x.128]"词汇表 "文章中找到。
* 为了允许3D中的各种网格，包括[2.x.129] Moebius[2.x.130] -loops，一个面甚至可能从一个单元看是旋转的，而从共享该特定面的邻近单元看则是按照标准。为了解决这个问题，有两个标志<tt>face_flip</tt>和<tt>face_rotation</tt>，分别代表180度和90度的旋转。设置这两个标志相当于270度的旋转（都是逆时针）。你可以像询问<tt>面的方向</tt>一样询问单元格的这些标志。为了启用旋转的面，甚至线条也可以偏离它们在3D中的标准方向。这个信息可以作为<tt>line_orientation</tt>标志提供给三维中的单元和面。同样，这应该是库内部的东西，应用程序可能永远都不需要去管它。更多的信息请参见 [2.x.131] "这个词汇表条目"。
* 

* [1.x.25]
* 一个各向同性的细化单元的八个子单元是根据它们相邻的顶点来编号的。

* 
* [1.x.26]
 
* 考虑到面的方向，下列子节点与各自的面相邻。 [2.x.132] [2.x.133] 面0：子0、2、4、6； [2.x.134] 面1：子1、3、5、7； [2.x.135] 面2：子0、4、1、5； [2.x.136] 面3：子2、6、3、7； [2.x.137] 面4：子0、1、2、3； [2.x.138] 面5：子4、5、6、7。 [2.x.139] 你可以用[2.x.140]函数得到这些数字。由于每个孩子都与具有相同数字的顶点相邻，这些数字也可以通过[2.x.141]函数得到。
* 请注意，上述列表只适用于标准方向的面。如果一个面不在标准方向上，那么在位置1和2（从0到3算起）的孩子会被交换。事实上，这就是GeometryInfo<3>的child_cell_on_face和face_to_cell_vertices函数在调用<tt>face_orientation=false</tt>参数时的作用。
* 哪个子单元在哪个面的哪个位置的信息，在计算有悬挂节点的面之间的跳跃项时，最常使用的是FESubfaceValues类型的对象。坐在一个单元格上，你会看一个面，然后算出邻居的哪个子单元是坐在现在和邻居单元之间的一个给定的子表面上。为了避免在这种情况下每次都要查询两个单元格面的标准方向，你应该使用类似<tt>cell->neighbor_child_on_subface(face_no,subface_no)</tt>的函数调用，它在2D（面的方向不重要）和3D（需要使用面的方向作为[2.x.142]的附加参数）中都能返回正确的结果。
* 对于各向异性的细化，子单元不能根据相邻的顶点进行编号，因此使用了以下惯例。

* 
* [1.x.27]
* 
* 

* 
* [1.x.28]
 
* 

 
* [1.x.29]
 
 

 
* [1.x.30]
 
* 

 
* [1.x.31]
 
 

 
* [1.x.32]
* 
* 这一信息也可以通过[2.x.143]函数获得。
* [1.x.33]
* 我们为单元格顶点的显性坐标定义了以下坐标系。

* 
* [1.x.34]
* 
* 根据上面的惯例，顶点的坐标如下（排位法，x跑得最快）。 [2.x.144] [2.x.145] 顶点0：<tt>(0,0,0)</tt>; [2.x.146] 顶点1：<tt>(1,0,0)</tt>; [2.x.147] 顶点2：<tt>（0,1,0）</tt>; [2.x.148] 顶点3：<tt>（1,1,0）</tt>; [2.x.149] 顶点4。<tt>(0,0,1)</tt>; [2.x.150] 顶点5：<tt>(1,0,1)</tt>; [2.x.151] 顶点6。<tt>(0,1,1)</tt>; [2.x.152] 顶点7：<tt>(1,1,1)</tt>。 [2.x.153] 
 

* 
* 

* 
* [2.x.154] 这个模板的实例是为维度1,2,3,4提供的，还有一个针对dim=0的特殊化（见手册中的[2.x.155]部分）。
* 

* 
* [2.x.156] 

 
* [0.x.94]*
   精炼单元的最大子女数，即各向同性精炼单元的子女数。    如果一个单元被各向异性地精炼，实际的子女数可能少于这里给出的值。 
* [0.x.95]*
   一个单元的面的数量。 
* [0.x.96]*
   返回一个对象，它可以被认为是一个包含从零到`面孔_per_cell`所有索引的数组。这允许使用基于范围的for循环来编写以下类型的代码。 
* [1.x.35]
* 这里，我们正在循环所有单元格的所有面，`face_index`接收所有有效的面的索引（1d中的0和1，2D中的0到3，以及3D中的0到5）。     [2.x.157] CPP11  
* [0.x.97]*
   一个精炼面的最大子女数，即一个各向同性的精炼面的子女数。    如果一个单元被各向异性地细化，实际的子女数可能少于这里给出的值。 
* [0.x.98]*
   一个单元格的顶点数。 
* [0.x.99]*
   返回一个对象，它可以被认为是一个包含从零到`顶点_per_cell'所有索引的数组。这样就可以使用基于范围的for循环来编写以下类型的代码。 
* [1.x.36]
* 这里，我们在所有单元格的所有顶点上循环，`vertex_index`使用所有有效的索引。     [2.x.158] CPP11  
* [0.x.100]*
   每个面上的顶点数量。 
* [0.x.101]*
   每个面的线数。 
* [0.x.102]*
   每个面上的四边形数目。 
* [0.x.103]*
   一个单元格的行数。    计算公式利用了这样一个事实：当从一个维度到下一个维度时，低维度的对象被复制一次（因此是旧的线数的两倍），然后在旧对象的每个顶点和副本中的相应顶点之间插入一条新线。 
* [0.x.104]*
   一个单元格的四边形的数量。    这个数字与前一个数字一样是递归计算的，不同的是，新的四边形是由连接原始线和它的副本产生的。 
* [0.x.105]*
   一个单元格的六面体的数量。 
* [0.x.106]*
   为UCD输出重新排列顶点。 对于正在以UCD格式写入的单元格，该字段的每个条目包含<tt>deal.II</tt>中与该位置的UCD编号相对应的一个顶点的编号。    典型的例子：写一个单元并安排顶点，这样UCD就能理解它们。   
* [1.x.37]
* 由于deal.II版本<=5.1中的顶点编号恰好与UCD的编号一致，这个字段也可以像old_to_lexicographic映射一样使用。 
* [0.x.107]*
   为OpenDX输出重新排列顶点。 对于一个被写成OpenDX格式的单元格，这个字段的每个条目都包含<tt>deal.II</tt>中的一个顶点的编号，它与这个位置的DX编号相对应。    典型的例子：写一个单元并安排顶点，这样OpenDX就能理解它们。   
* [1.x.38]
*   
* [0.x.108]*
   这个字段为每个顶点存储它所属的面。在任何给定的维度中，面的数量都等于维度。这个二维数组的第一个索引是所有顶点的，第二个索引是顶点所属的[2.x.159]面。    每个顶点的面的顺序是这样的：第一个列出的面在[1.x.39]方向上包围参考单元，第二个在[1.x.40]方向上，以此类推。 
* [0.x.109]*
   返回用<tt>ref_case</tt>提炼的单元格（或面）的子节点数量。 
* [0.x.110]*
   返回根据[2.x.160][2.x.161]精炼的一个面的子面的数量。  
* [0.x.111]*
   给定参考元素上的一个具有[2.x.162][2.x.163]的面，该函数返回[2.x.164]第1个子面的面积与该面的面积（=1）之间的比率。    例如，对于[2.x.165]，每个子面的比例是1/4。 
* [0.x.112]*
   给定一个用[2.x.166] [2.x.167] cell_refinement_case精炼的单元格，返回[2.x.169] face_no th面的[2.x.168]。 
* [0.x.113]*
   给出第[2.x.171]个面的SubfaceCase[2.x.170]，返回最小的单元格的RefinementCase，它对应于该面的细化。 
* [0.x.114]*
   给定一个用RefinementCase[2.x.172]精炼的单元格，返回第[2.x.173]个面的RefinementCase。 
* [0.x.115]*
   返回单元格的最小/最小的RefinementCase，确保细化线[2.x.174]。  
* [0.x.116]*
   这个字段存储了哪些子单元与母单元的某个面相邻。    例如，在2D中，一个单元格的布局如下。 
* [1.x.41]
* 顶点和面用它们的数字表示，面也用它们的方向表示。    现在，在细化时，布局是这样的。 
* [1.x.42]
* 因此，面0上的子单元是（按面的方向排序）0和2，面3上是2和3，等等。    对于三个空间维度，子单元的确切顺序在这个类的一般文件中规定了。    通过<tt>face_orientation</tt>, <tt>face_flip</tt> 和 <tt>face_rotation</tt> 参数，这个函数可以处理以标准和非标准方向的面。<tt>face_orientation</tt>默认为<tt>true</tt>，<tt>face_flip</tt>和<tt>face_rotation</tt>默认为<tt>false</tt>（标准方向），在2d中没有影响。  面部方向的概念在这个[2.x.175]"词汇表 "条目中得到了解释。    在各向异性细化单元和面的情况下，面的[2.x.176] RefinementCase，<tt>face_ref_case</tt>，可能对哪个子面在哪个给定子面后面有影响，因此这是一个附加参数，默认为面的各向同性细化。 
* [0.x.117]*
   将线的顶点编号映射到单元格顶点编号，即给出<tt>线</tt>的第1个顶点的单元格顶点编号，例如：[2.x.177] 线的顺序，以及它们的方向（这又决定了哪一个是线上的第一个顶点，哪一个是第二个顶点）是deal.II中的典范，如该类的一般文档中所述。    对于<tt>dim=2</tt>，这个调用被简单地传递给face_to_cell_vertices()函数。 
* [0.x.118]*
   将面的顶点编号映射到单元格的顶点编号，即给出面的<tt>顶点</tt>第1个顶点的单元格顶点编号，例如，[2.x.178]见本类文档2d部分N4点下的图片。    通过<tt>face_orientation</tt>, <tt>face_flip</tt>和<tt>face_rotation</tt>参数，这个函数可以处理以标准和非标准方向的面。<tt>face_orientation</tt>默认为<tt>true</tt>，<tt>face_flip</tt>和<tt>face_rotation</tt>默认为<tt>false</tt>（标准方向）。在2d中，只有<tt>face_flip</tt>被考虑。更多信息请参见这篇[2.x.179]"词汇表 "文章。    由于单元格的子节点是根据单元格的顶点排序的，这个调用被传递给child_cell_on_face()函数。  因此，这个函数只是child_cell_on_face()的一个包装器，给它起了一个暗示性的名字。 
* [0.x.119]*
   将面的行数映射到单元格行数，即给出面的<tt>行</tt>第1行的单元格行数，例如：[2.x.180] 通过<tt>face_orientation</tt>, <tt>face_flip</tt>和<tt>face_rotation</tt>参数，这个函数处理以标准和非标准方向为导向的面。<tt>face_orientation</tt>默认为<tt>true</tt>，<tt>face_flip</tt>和<tt>face_rotation</tt>默认为<tt>false</tt>（标准方向），在2d中没有影响。 
* [0.x.120]*
   将标准方向的面的顶点索引[2.x.181]映射到具有任意[2.x.182][2.x.183]和[2.x.184]面旋转的面。这三个标志的值分别默认为<tt>true</tt>, <tt>false</tt>和<tt>false</tt>。这个组合描述了一个标准方向的面。    这个函数只在三维中实现。 
* [0.x.121]*
   将具有任意[2.x.186] face_orientation、[2.x.187]和[2.x.188]的面的顶点索引[2.x.185]映射到一个标准方向的面。这三个标志的值分别默认为<tt>true</tt>, <tt>false</tt>和<tt>false</tt>。这个组合描述了一个标准方向的面。    这个函数只在三维中实现。 
* [0.x.122]*
   将一个标准方向的面的线条索引[2.x.189]映射到一个具有任意[2.x.190][2.x.191]和[2.x.192]face_rotation的面。这三个标志的值默认分别为<tt>true</tt>, <tt>false</tt>和<tt>false</tt>。这个组合描述了一个标准方向的面。    这个函数只在三维中实现。 
* [0.x.123]*
   将标准方向的线的顶点索引[2.x.193]映射到一个任意[2.x.194]的面的顶点索引，这个标志的值默认为<tt>true</tt>。 
* [0.x.124]*
   将四边形中的顶点索引分解为一对线的索引和该线中的顶点索引。   
* [2.x.195]哪条线被选中并不重要（也不是故意暴露）。 
* [0.x.125]*
   将一个六边形中的顶点索引分解为一对四边形索引和这个四边形中的顶点索引。   
* [2.x.196]选择哪个象限并不重要（也不是故意暴露的）。 
* [0.x.126]*
   将六边形中的线索引分解成一对四边形索引和该四边形中的线索引。   
* [2.x.197]选择哪个象限并不重要（也不是故意暴露的）。 
* [0.x.127]*
   将具有任意[2.x.199][2.x.200]和[2.x.201]的面的线指数[2.x.198]映射到一个标准方向的面。这三个标志的值默认分别为<tt>true</tt>, <tt>false</tt>和<tt>false</tt>。这个组合描述了一个标准方向的面。    这个函数只在三维中实现。 
* [0.x.128]*
   返回单元格上[2.x.202]顶点的位置。顶点的顺序是deal.II中的典范顺序，如该类的一般文档中所述。 
* [0.x.129]*
   给出一个单位坐标的点[2.x.203]，返回它所在的子单元的编号。如果该点位于两个子单元的界面上，则返回它们中的任何一个指数。结果总是小于[2.x.204]，子单元的顺序在该类的一般文档中描述。 
* [0.x.130]*
   给出单元格上的坐标[2.x.205]，返回该点在给定子单元格的坐标系中的坐标值。  原始坐标和返回的坐标实际上都不需要在单元格内，我们只是简单地进行了一个缩放和移位操作，移位的程度取决于子单元的数量。 
* [0.x.131]*
   与上面的函数相反：在子单元的坐标系中取一个点，并将其转换为母单元的坐标系。 
* [0.x.132]*
   如果给定的点在当前空间维度的单元格内，则返回真。 
* [0.x.133]*
   如果给定的点在当前空间维度的单元格内，则返回真。这个函数接受一个额外的参数，指定点的位置实际上可能在真正的单元格之外的程度。这是很有用的，因为在实践中，我们往往不能准确地计算出参考坐标中的点的坐标，而只能是数字上的舍入。    容差参数可以小于零，表示该点应该安全地在单元格内。 
* [0.x.134]*
   将一个给定的点投射到单元格上，也就是说，[0...1]以外的每个坐标被修改为位于该区间内。 
* [0.x.135]*
   返回单元格外的给定点[2.x.206]到最近的单元格边界之间的向量的无穷大规范。对于单元格内的点，这被定义为零。 
* [0.x.136]*
   计算[2.x.207]-第[2.x.208]-线性（即（双，三）线性）形状函数在位置[2.x.209]的值。 
* [0.x.137]*
   计算[2.x.210]-第[2.x.211]-线性（即（双，三）线性）形状函数在位置[2.x.212]的梯度。 
* [0.x.138]*
   对于从参考单元、面或边到由给定顶点指定的物体的（双、三）线性映射，计算转换后的单位向量顶点的交替形式。对于维数为[2.x.213]的物体，有[2.x.214]个矢量，每个矢量有[2.x.215]个分量，交替形式是等级为spacedim-dim的张量，对应于[2.x.216]个单位矢量的楔形积，它对应于从参考元素到顶点描述的元素映射的体积和法向量。    例如，如果dim==spacedim==2，那么交替形式是一个标量（因为spacedim-dim=0），其值等于[2.x.217] ，其中[2.x.218]是一个从[2.x.219]向右旋转90度的矢量。如果dim==spacedim==3，那么结果又是一个标量，其值为[2.x.220]，其中[2.x.221]是单位dim维单元的一个顶点的单位向量在转化为spacedim维空间的dim维单元时的图像。在这两种情况下，即对于dim==2或3，其结果恰好等于实空间中从参考单元到单元的映射的Jacobian的行列式。请注意，这是实际的行列式，而不是它的绝对值，因为它经常用于将积分从一个坐标系转换到另一个坐标系。特别是，如果顶点指定的对象是一个平行四边形（即参考单元的线性变换），那么计算值在所有顶点都是相同的，并且等于该单元的（有符号的）面积；同样，对于平行四边形，它是该单元的体积。    同样，如果我们有dim==spacedim-1（例如，我们有一个三维空间的四边形，或者一条二维空间的线），那么交替乘积表示每个顶点的物体的法向量（即一个秩-1张量，因为spacedim-dim=1），其中法向量的大小表示从参考物体到顶点所给物体的转换的面积元素。特别是，如果从参考物体到这里考虑的物体的映射是线性的（不是双线或三线），那么返回的向量都是%平行的，垂直于顶点描述的映射物体，并且其大小等于映射物体的面积/体积。如果dim=1，spacedim=2，那么返回值为[2.x.222] ，其中[2.x.223]是映射到顶点给出的2D中的直线的唯一单位向量的图像；如果dim=2，spacedim=3，那么返回值为[2.x.224]，其中[2.x.225]是与映射到三维空间的四边形相切的两个三维向量。    这个函数用于确定一个单元的扭曲程度（见术语表中[2.x.226]"扭曲的单元 "条目）。 
* [0.x.139]*
   对于参考单元的每个面，这个字段存储其法向量指向的坐标方向。在<tt>dim</tt>维度中，这些是<tt>2*dim</tt>的第一个条目<tt>{0,0,1,1,2,2,3,3}</tt>。    请注意，这只是坐标数。法向量的实际方向是通过将这个方向的单位向量与#unit_normal_orientation相乘而得到的。 
* [0.x.140]*
   参考单元的一个面的单位法向量的方向。在<tt>dim</tt>维度中，这些是<tt>2*dim</tt><tt>{-1,1,-1,1,-1,-1,1}</tt>的第一个条目。    每个值都是<tt>1</tt>或<tt>-1</tt>，分别对应于指向正坐标或负坐标方向的法向量。    注意，这只是面的[2.x.227]标准方向[2.x.228]。至少在3D中，三角形中单元格的实际面也可以有相反的方向，这取决于人们可以从它所属的单元格中查询到的一个标志。欲了解更多信息，请参见[2.x.229]"词汇表 "中关于面的方向的条目。 
* [0.x.141]*
   参考单元的一个面的单位法向量（Point<dim>）。    注意，这只是面的[2.x.230]标准方向[2.x.231]。至少在3D中，三角形中单元格的实际面也可以有相反的方向，这取决于一个可以从它所属的单元格中查询的标志。欲了解更多信息，请参见[2.x.232]"词汇表 "中关于面的方向的条目。 
* [0.x.142]*
   参考单元面的单位切向矢量（Point<dim>的`dim-1`元素数组），排列在右手坐标系中，使两个矢量之间的交积返回单位法向量。    注意，这只是面的[2.x.233]标准方向[2.x.234]。至少在3D中，三角形中单元格的实际面也可以有相反的方向，这取决于一个可以从它所属的单元格中查询的标志。欲了解更多信息，请参见[2.x.235]"词汇表 "中关于面的方向的条目。 
* [0.x.143]*
   数字列表，表示哪个面与给定的面相对。它的条目是<tt>{ 1, 0, 3, 2, 5, 4, 7, 6}</tt>的第一个<tt>2*dim</tt>条目。 
* [0.x.144]*
   异常情况  
* [0.x.145]*
   异常情况  
* [0.x.146]

