include/deal.II-translator/base/function_lib_0.txt
[0.x.0]*
 实现一些从Function类派生的具体类的命名空间，这些类描述实际的函数。这是我们自己的程序曾经需要的类的集合，并且认为在某些时候可能对其他人也是有用的。
* 

* 
* [2.x.0] 

* 
* [0.x.1]*
   到原点的距离的平方。    这个函数返回一个点的半径向量的平方准则。    连同该函数，它的导数和拉普拉斯也被定义。   
* [2.x.1]   
* [0.x.2]*
   2d和3d中的函数<tt>xy</tt>，在1d中没有实现。这个函数可以作为一个消失的拉普拉斯的例子。   
* [2.x.2]   
* [0.x.3]*
     该函数在一个点上的拉普拉斯系数。   
* [0.x.4]*
     多点上的拉普拉斯函数。   
* [0.x.5]*
   单位超立方体上的d-quadratic枕头。    这是一个用于测试实现的函数。它在域[2.x.3]上具有零迪里切特边界值。在内部，它是[2.x.4]在所有空间维度上的积。    向构造函数提供一个非零参数，整个函数可以被一个常数抵消。    与该函数一起，它的导数和拉普拉斯也被定义。   
* [2.x.5]   
* [0.x.6]*
     构造函数。提供一个常数，它将被添加到每个函数值中。   
* [0.x.7]*
     在一个点上的值。   
* [0.x.8]*
     在多个点上的值。   
* [0.x.9]*
     单点上的梯度。   
* [0.x.10]*
     多点上的梯度。   
* [0.x.11]*
     单点的拉普拉斯系数。   
* [0.x.12]*
     多点上的拉普拉斯。   
* [0.x.13]*
   余弦形的枕头函数。这是另一个在[2.x.6]上具有零边界值的函数。在内部，它是[2.x.7]的积。   
* [2.x.8]   
* [0.x.14]*
     构造函数允许选择性地生成一个矢量值的余弦函数，每个分量的值都相同。   
* [0.x.15]*
     单点的二阶导数。   
* [0.x.16]*
     多点上的二阶导数。   
* [0.x.17]*
   余弦形枕头函数的梯度。    这是一个具有[2.x.9]分量的向量值函数，是余弦函数的梯度。在正方形[-1,1]上，它的切向边界条件为零。因此，它可以用来测试麦克斯韦算子的实现，而不必理会边界项。   
* [2.x.10]   
* [0.x.18]*
     构造函数，创建一个具有[2.x.11]成分的函数。   
* [0.x.19]*
   每个坐标方向上的指数函数的乘积。   
* [2.x.12]   
* [0.x.20]*
     在一个点上的值。   
* [0.x.21]*
     在多点的数值。   
* [0.x.22]*
     单点上的梯度。   
* [0.x.23]*
     多点上的梯度。   
* [0.x.24]*
     单点的拉普拉斯系数。   
* [0.x.25]*
     多点上的拉普拉契亚。   
* [0.x.26]*
   一个能解决拉普拉斯方程的函数（有特定的边界值，但右手边为零），该函数在二维的L形域的中心有一个奇点（即在这个非凸域的重心角的位置）。    该函数在极坐标中由[2.x.13]给出，其奇点在原点，应与[2.x.14]一起使用。这里，[2.x.15]被定义为对正[2.x.16]轴的顺时针*角。    这个函数经常被用来说明拉普拉斯方程[1.x.0]的解可以是奇异的，即使边界值是平滑的。（这里，如果域是L形域[2.x.17]，[2.x.18]的边界值在邻近原点的两条线段上是零，而在边界的其余部分等于[2.x.19]）。该函数本身在域上仍然是有界的，但它的梯度在原点附近是[2.x.20]的形式，因此在接近原点时发散了。   
* [2.x.21]   
* [0.x.27]*
   二维L型域上的谐波奇点的梯度。    LSingularityFunction的梯度，它是一个卷曲和发散都消失的矢量值函数。   
* [2.x.22]   
* [0.x.28]*
     默认构造函数将维度设置为2。   
* [0.x.29]*
   二维和三维狭缝域上的奇异性。   
* [2.x.23]   
* [0.x.30]*
   二维中具有一个诺伊曼边界的狭缝域上的奇异性。   
* [2.x.24]   
* [0.x.31]*
   在x方向上的跳跃被输送到某个方向。    如果平移平行于y轴，函数为<tt>-atan(sx)</tt>，其中<tt>s</tt>是构造函数中提供的陡度参数。    对于不同的平流方向，这个函数将在参数空间中转动。    与该函数一起，其导数和拉普拉斯也被定义。   
* [2.x.25]   
* [0.x.32]*
     构造函数。在这里提供平流方向和斜率的陡度。   
* [0.x.33]*
     在一个点上的函数值。   
* [0.x.34]*
     多点上的函数值。   
* [0.x.35]*
     在一个点上的梯度。   
* [0.x.36]*
     多点上的梯度。   
* [0.x.37]*
     一个点上的函数的拉普拉斯系数。   
* [0.x.38]*
     多点上的拉普拉斯函数。   
* [0.x.39]*
     返回这个对象的内存消耗估计值，以字节为单位。这不是精确的（但通常会很接近），因为计算树的内存使用量（例如，[2.x.26]是很困难的。   
* [0.x.40]*
     对流矢量。   
* [0.x.41]*
     斜坡的陡度（最大导数）。   
* [0.x.42]*
     平流角。   
* [0.x.43]*
     <tt>角的正弦</tt>。   
* [0.x.44]*
     <tt>角的余弦</tt>。   
* [0.x.45]*
   给出一个文数向量，生成一个余弦函数。文数系数以傅里叶空间中的[2.x.27] -维点[2.x.28]的形式给出，然后函数被恢复为[2.x.29] 。    该类的名称来自于它类似于傅里叶余弦分解的一个组成部分。   
* [2.x.30]   
* [0.x.46]*
     构造函数。以每个空间方向上的傅里叶系数作为参数。   
* [0.x.47]*
     返回该函数在给定点的值。除非只有一个分量（即函数是标量的），否则你应该说明你想要评估的分量；它默认为零，即第一个分量。   
* [0.x.48]*
     返回函数的指定分量在给定点的梯度。   
* [0.x.49]*
     计算给定分量在<tt>p</tt>点的拉普拉斯。   
* [0.x.50]*
     存储的傅里叶系数。   
* [0.x.51]*
   给定一个文数向量生成一个正弦函数。文数系数以傅里叶空间中的[2.x.31] -维点[2.x.32]的形式给出，然后函数被恢复为[2.x.33] 。    该类的名称来自于它类似于傅里叶正弦分解的一个组成部分。   
* [2.x.34]   
* [0.x.52]*
     构造函数。以每个空间方向上的傅里叶系数作为参数。   
* [0.x.53]*
     返回该函数在给定点的值。除非只有一个分量（即函数是标量的），否则你应该说明你想要评估的分量；它默认为零，即第一个分量。   
* [0.x.54]*
     返回函数的指定分量在给定点的梯度。   
* [0.x.55]*
     计算给定分量在<tt>p</tt>点的拉普拉斯。   
* [0.x.56]*
     存储的傅里叶系数。   
* [0.x.57]*
   给出一串文数向量和权重，生成正弦函数之和。每个文数系数在傅里叶空间中作为[2.x.35]-维点[2.x.36]给出，然后整个函数被恢复为[2.x.37] 。   
* [2.x.38]   
* [0.x.58]*
     构造器。以每个空间方向上的傅里叶系数为参数。   
* [0.x.59]*
     返回该函数在给定点的值。除非只有一个分量（即函数是标量的），否则你应该说明你想要评估的分量；它默认为零，即第一个分量。   
* [0.x.60]*
     返回函数的指定分量在给定点的梯度。   
* [0.x.61]*
     计算给定分量在<tt>p</tt>点的拉普拉斯。   
* [0.x.62]*
     存储的傅里叶系数和权重。   
* [0.x.63]*
   给出一串文数向量和权重，生成余弦函数之和。每个文数系数在傅里叶空间中以[2.x.39] -维点[2.x.40]的形式给出，然后整个函数恢复为[2.x.41] 。   
* [2.x.42]   
* [0.x.64]*
     构造器。以每个空间方向上的傅里叶系数为参数。   
* [0.x.65]*
     返回该函数在给定点的值。除非只有一个分量（即函数是标量的），否则你应该说明你想要评估的分量；它默认为零，即第一个分量。   
* [0.x.66]*
     返回函数的指定分量在给定点的梯度。   
* [0.x.67]*
     计算给定分量在<tt>p</tt>点的拉普拉斯。   
* [0.x.68]*
     存储的傅里叶系数和权重。   
* [0.x.69]*
   切断函数的基础函数。该类存储了一个截断函数的中心和支持球的半径。如果该函数是矢量值的，它还存储了非零分量的数量。    这个类也可以用于近似的狄拉克三角函数。这些是特殊的截断函数，其积分总是等于1，与支持球的半径无关。   
* [2.x.43]   
* [0.x.70]*
     在这个和派生类的构造函数中使用的值，表示没有选择任何组件。   
* [0.x.71]*
     构造函数。         [2.x.44] radius 球的半径 [2.x.45] center 球的中心 [2.x.46] n_components 这个函数对象的组件数量 [2.x.47] select 如果这与[2.x.48]不同，那么函数将只对这个组件非零 [2.x.49 ] integrate_to_one 每当设置一个新的半径时，都要重新调整函数的值，以保证积分等于1 [2.x.50] unitary_integral_value 当半径等于1.0时的积分值。派生类将需要提供这个值，以保证正确地执行重新缩放。   
* [0.x.72]*
     虚拟解构器。   
* [0.x.73]*
     将球的中心设置为[2.x.51]点。    
* [0.x.74]*
     设置球的半径为[2.x.52]。    
* [0.x.75]*
     返回存储在这个对象中的中心。   
* [0.x.76]*
     返回存储在此对象中的半径。   
* [0.x.77]*
     返回一个布尔值，表示此函数是否积分到一。   
* [0.x.78]*
     积分球的中心。   
* [0.x.79]*
     该球的半径。   
* [0.x.80]*
     选择的组件。如果<tt>no_component</tt>，函数在所有组件中是相同的。   
* [0.x.81]*
     控制半径变化时我们是否重新调整数值的标志。   
* [0.x.82]*
     参考积分值。当[2.x.53]=1.0时，派生类应指定其积分是什么。   
* [0.x.83]*
     当前的重定比例，以应用截止函数。   
* [0.x.84]*
   CutOffFunctionBase对象的张量积。    该类不是使用距离来计算截断函数，而是在每个坐标方向上对同一CutOffFunctionBase对象进行张量乘积。   
* [2.x.54]   
* [0.x.85]*
     构建一个空的CutOffFunctionTensorProduct对象。        在你使用这个类之前，你必须用一个从CutOffFunctionBase对象派生的类来调用set_base()方法。        如果你在调用set_base()方法之前试图使用这个类，将会触发异常。   
* [0.x.86]*
     用一个类型为[2.x.55] CutOffFunctionBaseType<1>的对象初始化这个类。   
* [0.x.87]*
     设置新的中心。   
* [0.x.88]*
     设置新的半径。   
* [0.x.89]*
     在一个点上的函数值。   
* [0.x.90]*
     在一个点上的函数梯度。   
* [0.x.91]*
   任意球的L-无穷大中的截止函数。 这个函数是围绕<tt>中心</tt>的球的特征函数，具有指定的<tt>半径</tt>，也就是说，[1.x.1] 如果是矢量值，它可以被限制为一个分量。   
* [2.x.56]   
* [0.x.92]*
     构造函数。参数是球的中心和它的半径。        如果一个参数<tt>select</tt>被给定，并且不是
* 
* - ，则截断函数将只对这个分量非零。   
* [0.x.93]*
     在一个点上的函数值。   
* [0.x.94]*
     多点上的函数值。   
* [0.x.95]*
     多点上的函数值。   
* [0.x.96]*
   任意球的截断函数。这个函数是一个圆锥体，支持在一个围绕<tt>中心</tt>的特定</tt>球中。最大值是1。如果是矢量值，它可以被限制为一个分量。   
* [2.x.57]   
* [0.x.97]*
     构造函数。参数是球的中心和它的半径。        如果给了一个参数<tt>select</tt>，截断函数将只对这个分量非零。   
* [0.x.98]*
     在一个点上的函数值。   
* [0.x.99]*
     多点上的函数值。   
* [0.x.100]*
     多点上的函数值。   
* [0.x.101]*
   一个任意大小的球的截断函数，它在空间[2.x.58]（即连续可微）。这是一个在沉浸边界法的文献中经常使用的截止函数。    该函数在径向坐标中的表达式为[2.x.59]，其中[2.x.60]是到中心的距离，[2.x.61]是球体的半径。如果是矢量值，它可以被限制为一个单一分量。   
* [2.x.62]   
* [0.x.102]*
     构造函数。   
* [0.x.103]*
     在一个点上的函数值。   
* [0.x.104]*
     多点上的函数值。   
* [0.x.105]*
     多点上的函数值。   
* [0.x.106]*
     在一个点上的函数梯度。   
* [0.x.107]*
   任意球的截断函数。这是传统的C-无穷大的截止函数，用于围绕<tt>中心</tt>的一定半径的球，[2.x.63] ，其中[2.x.64]是到中心的距离，[2.x.65]是球体的半径。如果是矢量值，它可以被限制为一个单一成分。   
* [2.x.66]   
* [0.x.108]*
     构造函数。参数是球的中心和它的半径。        如果给了一个参数<tt>select</tt>，截断函数将只对这个分量非零。   
* [0.x.109]*
     在一个点上的函数值。   
* [0.x.110]*
     多点上的函数值。   
* [0.x.111]*
     多点上的函数值。   
* [0.x.112]*
     在一个点上的函数梯度。   
* [0.x.113]*
   一个代表单项式的函数对象的类。单项式是只有一个单项的多项式，即在1-d中它们的形式为[2.x.67]，在2-d中的形式为[2.x.68]，而在3-d中的形式为[2.x.69]。因此，单项式是由指数的[2.x.70]元组来描述的。因此，该类的构造函数需要一个Tensor<1,dim>来描述指数的集合。大多数时候，这些指数当然是整数，但实数指数当然也同样有效。当基数是负数时，指数不可能是实数。   
* [2.x.71]   
* [0.x.114]*
     构造函数。第一个参数在该类的一般描述中解释。第二个参数表示这个对象应代表的向量分量的数量。所有的向量分量将有相同的值。   
* [0.x.115]*
     在一个点上的函数值。   
* [0.x.116]*
     返回一个矢量值函数在某一点的所有分量。        <tt>值</tt>应事先有正确的大小，即#n_components。   
* [0.x.117]*
     在多个点上的函数值。   
* [0.x.118]*
     在一个点上的函数梯度。   
* [0.x.119]*
     指数的集合。   
* [0.x.120]*
   一个标量函数，通过（双，三）线性插值从一组点数据中计算其值，这些数据排列在一个可能是不均匀的张量积网中。换句话说，考虑到三维的情况，假设有点[2.x.72]，[2.x.73]，[2.x.74]，以及定义在点[2.x.76]的数据[2.x.75]，那么在点[2.x.77]上评估函数将找到盒子，以便[2.x.78]，并对该单元的数据做三线性内插。类似的操作在更低的维度上也会进行。    这一类最常被用于评估在域内一些点上通过实验提供的系数或右手边，或者用于比较有限元网格上的解的输出与先前在网格上定义的数据。   
* [2.x.79] 如果点[2.x.80]实际上是在一个区间[2.x.81]上等距分布的，并且在更高的维度上其他数据点也是如此，你应该使用InterpolatedUniformGridData类来代替。    如果一个点被要求在坐标阵列的端点所定义的框外，那么该函数被假定为在每个坐标方向的最后一个数据点之外简单地扩展常量值。  (如果一个点位于框外，该类不会抛出一个错误，因为经常发生的情况是，一个点正好位于框外，其数量与数字四舍五入的数量相同。)    
* [2.x.82] 相关类InterpolatedUniformGridData的使用在 [2.x.83] 中讨论。      [1.x.2] 这个类经常被用来插值由相当大的数据表提供的数据，这些数据表从磁盘上读取的成本很高，而且在并行（MPI）程序的每个进程上复制时都会占用大量的内存。    表类可以通过使用共享内存只在必要时存储数据来帮助摊薄这一成本
* 
* - 参见TableBase类的文档。一旦我们获得了这样一个表对象，它使用共享内存来存储数据，并且只在必要的时候使用，我们就必须避免当前的类复制*。
   表到它自己的成员变量中。相反，有必要使用这个类的move*构造函数来接管表和其共享内存空间的所有权。这可以通过TableBase类的文档中显示的代码片段的以下扩展来实现。 
* [1.x.3]
       
* [2.x.84]   
* [0.x.121]*
     构造函数，用[2.x.85] data_values中给出的数据初始化这个类实例。         [2.x.86] coordinate_values 一个由dim数组组成的数组。每个内部数组包含坐标值[2.x.87]，类似地，其他坐标方向也是如此。这些数组不需要有相同的大小。很明显，对于一个dim-维的函数对象，我们需要dim这样的数组。这个数组内的坐标值被假定为严格的升序，以便于有效的查找。         [2.x.88] data_values 一个由上述坐标数组定义的每个网格点的二维数据表格。传入的数据会被复制到内部数据结构中。请注意，Table类有一些转换构造函数，可以将其他数据类型转换为你指定这个参数的表格。   
* [0.x.122]*
     像前面的构造函数一样，但是把参数作为r值引用，并移动*，而不是复制*数据。在这些表中存储的数据很大，并且不再需要单独初始化当前对象的信息的情况下，这通常是有用的。换句话说，没有必要保留原始对象，这个对象可以从中复制其信息，但它不妨接管（"移动"）数据。   
* [0.x.123]*
     通过对给定的数据集进行双线性插值，计算出函数集的值。         [2.x.89] p 要对函数进行评估的点。     [2.x.90] component 矢量分量。因为这个函数是标量的，所以只有0是这里的有效参数。     [2.x.91] 该点的内插值。如果该点位于坐标集之外，则该函数将以一个常数扩展。   
* [0.x.124]*
     计算由给定数据集的双线性内插定义的函数的梯度。         [2.x.92] p 要对函数梯度进行评估的点。     [2.x.93] component 矢量分量。因为这个函数是标量的，所以只有0是这里的有效参数。     [2.x.94] 内插函数的梯度值，在此点。如果该点位于坐标集之外，则该函数被扩展为常数，因此其梯度被扩展为0。   
* [0.x.125]*
     返回这个对象的内存消耗估计值，单位是字节。   
* [0.x.126]*
     返回一个对内部存储数据的引用。   
* [0.x.127]*
     查找包含输入点的矩形表格中的索引    
* [0.x.128]*
     每个坐标方向上的坐标值集合。   
* [0.x.129]*
     要内插的数据。   
* [0.x.130]*
   一个标量函数，通过（双、三）线性内插计算其数值，这些数据是在一个均匀间隔的张量积网格上排列的一组点数据。换句话说，考虑到三维的情况，让点[2.x.95]从区间[2.x.96]统一细分为大小为[2.x.98]的子区间，以及类似的[2.x.99]，[2.x.100]。同样考虑数据 [2.x.101] 定义在点 [2.x.102] 上，然后在点 [2.x.103] 上评估函数将找到盒子，从而 [2.x.104] ，并对该单元的数据做三线插值。类似的操作在更低的维度上也能完成。    该类最常被用于评估在域内一些点上通过实验提供的系数或右手边，或者用于比较有限元网格上的解的输出与先前在网格上定义的数据。   
* [2.x.105] 如果你有一个问题，其中的点[2.x.106]不是等距的（例如，它们是在一个分级网格上计算的结果，该网格更接近一个边界的密度），那么使用InterpolatedTensorProductGridData类来代替。    如果一个点被要求在坐标阵列的端点所定义的范围之外，那么该函数被假定为简单地通过常量值扩展到每个坐标方向的最后一个数据点之外。  (如果一个点位于框外，该类不会抛出一个错误，因为经常发生的情况是，一个点正好位于框外，其数量与数字四舍五入的数量相同。)    
* [2.x.107] 这个类的使用在 [2.x.108] 中讨论。      [1.x.4] 该类支持与InterpolatedTensorProductGridData类一样的处理大型数据集的设施。更多信息和示例代码见那里。     
* [2.x.109]   
* [0.x.131]*
     构造函数 [2.x.110] interval_endpoints 每个坐标方向上的（均匀细分的）区间的左右端点。     [2.x.111] n_subintervals 每个坐标方向上的子间隔的数量。一个坐标的值为1，意味着该区间被认为是由整个范围组成的一个子区间。值为2意味着有两个子区间，每个子区间有一半的范围，等等。     [2.x.112] data_values 一个由上述坐标阵列定义的每个网格点的数据的二维表。请注意，Table类有一些转换构造函数，可以将其他数据类型转换为你指定这个参数的表格。   
* [0.x.132]*
     像前面的构造函数一样，但是把参数作为r值引用，并移动*，而不是复制*数据。在这些表中存储的数据很大，并且不再需要单独初始化当前对象的信息的情况下，这通常是有用的。换句话说，没有必要保留原始对象，这个对象可以从中复制其信息，但它不妨接管（"移动"）数据。   
* [0.x.133]*
     通过对给定的数据集进行双线性插值，计算出函数集的值。         [2.x.113] p 要对函数进行评估的点。     [2.x.114] component 矢量分量。因为这个函数是标量的，所以只有零是这里的有效参数。     [2.x.115] 该点的内插值。如果该点位于坐标集之外，则该函数将以一个常数扩展。   
* [0.x.134]*
     通过对给定的数据集进行双线性内插，计算函数集的梯度。         [2.x.116] p 要对函数进行评估的点。     [2.x.117] component 矢量分量。因为这个函数是标量的，所以只有0是这里的有效参数。     [2.x.118] 内插函数在该点的梯度。如果该点位于坐标集之外，则该函数被扩展为一个常数，其梯度当然为零。   
* [0.x.135]*
     返回这个对象的内存消耗估计值，单位是字节。   
* [0.x.136]*
     返回一个对内部存储数据的引用。   
* [0.x.137]*
     每个坐标方向上的区间端点的集合。   
* [0.x.138]*
     每个坐标方向上的子区间数量。   
* [0.x.139]*
     要进行内插的数据。   
* [0.x.140]*
   一个代表多项式的函数对象的类。多项式是由多个单项式的相加组成的。如果多项式有n个单项式并且维度等于dim，那么多项式可以写成[2.x.119]，其中[2.x.120]是单项式的系数，[2.x.121]是其指数。该类的构造函数需要一个Table<2,double>来描述指数集，一个Vector<double>来描述系数集。   
* [2.x.122]   
* [0.x.141]*
     构造函数。多项式的系数和指数被作为参数传递。表<2, double>的指数的行数等于多项式的单项式的数目，列数等于dim。指数表的第i行包含第i个单项式的[2.x.123]指数[2.x.124] 。系数向量的第i个元素包含第i个单项式的系数[2.x.125]。   
* [0.x.142]*
     在一个点上的函数值。   
* [0.x.143]*
     多点的函数值。   
* [0.x.144]*
     在一个点上的函数梯度。   
* [0.x.145]*
     返回这个对象的内存消耗估计值，以字节为单位。   
* [0.x.146]*
     指数的集合。   
* [0.x.147]*
     系数的集合。   
* [0.x.148]

