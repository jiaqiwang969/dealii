include/deal.II-translator/base/signaling_nan_0.txt
[0.x.0]*
     一个命名空间，用于实现创建信令NaN对象的函数。这就是[2.x.0]函数调用的地方。   
* [0.x.1]*
       一个通用模板，用于知道如何用信号NaN来初始化[2.x.1]类型的对象，以表示无效的值。            这个类的真正实现发生在对模板参数[2.x.2]的特定值的（部分）专门化中。      
* [0.x.2]*
       一般NaNInitializer类的特殊化，提供了一个函数，返回一个等于无效信号NaN的[2.x.3]值。     
* [0.x.3]*
       一般NaNInitializer类的特殊化，它提供了一个函数，返回一个等于无效信号NaN的[2.x.4]值。     
* [0.x.4]*
       一般NaNInitializer类的特殊化，它提供了一个函数，返回一个Tensor<1,dim>值，其组成部分是无效的信号NaN值。     
* [0.x.5]*
       一般NaNInitializer类的特殊化，它提供了一个函数来返回一个Tensor<rank,dim>值，其组件是无效的信号NaN值。     
* [0.x.6]*
       一般NaNInitializer类的特殊化，它提供了一个函数来返回一个Tensor<rank,dim>值，其组件是无效的信号NaN值。     
* [0.x.7]*
       一般NaNInitializer类的特殊化，它提供了一个函数，返回一个SymmetricTensor<rank,dim>值，其组件是无效的信号NaN值。     
* [0.x.8]*
       一般NaNInitializer类的特殊化，它提供了一个函数，返回一个DerivativeForm<order,dim,spacedim>值，其组件是无效的信号NaN值。     
* [0.x.9]*
   提供一个类型为[2.x.5]的对象，里面充满了信号NaN，在计算中使用时会引起异常。这些对象的内容是一个 "信号NaN"（"NaN "代表 "不是一个数字"，而 "信号 "意味着至少在支持这个的平台上，任何使用它们的算术运算都会终止程序）。这类对象的目的是把它们作为无效对象和数组的标记，这些对象和数组需要在某个时候被初始化为有效值，当这种后来的初始化没有在第一次使用之前发生时，就会触发错误。一个例子是像这样的代码。 
* [1.x.0]
* 错误在于`else`分支忘记向`x`变量写入一个值。如果你的平台支持信号NaN，那么这个错误在上面的最后一行会变得很明显，因为程序会被一个浮点异常终止。处理器意识到代码正试图对仍然存储在`x`中的信令NaN进行操作，并终止了程序，从而便于找到问题所在。如果在第一行将`x`初始化为零（或者完全不初始化），这就不是一个容易发现的错误。在这种情况下，最后一行对[2.x.6]的调用将简单地计算 "某某 "的正弦，如果`某某条件==假`，但这种无效的结果对调用者来说可能并不明显，需要大量的调试才能发现，因为下游的计算将是错误的，没有任何指示*它们为什么是错误的。     [2.x.7] T 返回无效对象的类型。这个类型可以是标量，也可以是Tensor、SymmetricTensor或DerivativeForm类型。如果[2.x.8]类对该类型有相应的专门化，可以支持其他类型。   
* [2.x.9] 因为[2.x.10]类型不作为函数参数使用，编译器不能从参数的类型中推断出它。因此，你必须明确地提供它。例如，这一行    
* [1.x.1]
* 用无效的值初始化一个张量。 
* [0.x.10]

