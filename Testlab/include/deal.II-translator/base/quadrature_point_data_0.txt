include/deal.II-translator/base/quadrature_point_data_0.txt
[0.x.0]*
 一个用于在每个由类型为 [2.x.0] 的迭代器代表的单元格存储数据向量的类 [2.x.1] 。这个类的底层结构和初始化()方法是这样设计的：人们可以使用从基础DataType类派生出来的不同子类来存储给定单元的数据。这意味着指针的使用，在我们的例子中
* 
* - [2.x.2] 
* 类型[2.x.3]是任意的，但是当使用从TransferableQuadraturePointData派生的类时，可以使用[2.x.4]的设施。
* 

* 
* [2.x.5] 每个单元上存储的数据类型可以是不同的。然而，在单元格内，该类存储的是单一数据类型的对象向量。由于这个原因，当例如采用水平集方法来描述材料行为时，这个类可能不够灵活。

* 
* [0.x.1]*
   默认构造函数。 
* [0.x.2]*
   默认的解构器。 
* [0.x.3]*
   在 [2.x.6] 上初始化数据，以存储 [2.x.7] 类型为 [2.x.8] 的对象。  类型名 [2.x.9] 可能是另一个类，它是由基 [2.x.10] 类派生的。为了初始化对象的向量，我们必须假设[2.x.11]类有一个默认的构造函数。  这个函数必须在每个要存储数据的单元格中调用。    数据被初始化后，可以使用get_data()函数对其进行修改。   
* [2.x.12] 此函数的后续调用与[2.x.13]相同，不会改变与之相关的对象。为了删除存储的数据，请使用erase()函数。   
* [2.x.14] 可以为不同的单元使用不同的类型[2.x.15]，这可能反映出，例如，在领域的不同部分，连续体力学的不同构成模型。   
* [2.x.16] 该方法第一次被调用时，会存储一个SmartPointer到拥有该单元的Triangulation对象。以后调用此方法时，希望该单元来自于同一存储的三角剖面。     [2.x.17] 类型[2.x.18]需要等于[2.x.19]或是从[2.x.20]派生的类 [2.x.21]需要是可默认构造的。 
* [0.x.4]*
   同上，但对于所有本地拥有的单元格，即`cell->is_locally_owned()==true`的迭代器范围，从[2.x.22]开始，直到但不包括[2.x.23] 。 
* [0.x.5]*
   移除存储在[2.x.24]的数据 如果数据被移除，则返回true。  如果没有数据附在[2.x.25]上，这个函数将不做任何事情，并返回false。   
* [2.x.26] 此函数还将检查是否有对存储在此单元格上的数据的未决引用。也就是说，对存储的数据的唯一引用是由这个类作出的。 
* [0.x.6]*
   清除存储在此对象中的所有数据。 
* [0.x.7]*
   获取位于 [2.x.27] 的数据的向量。  一个可能的附加类型名[2.x.28]是基类DataType可以被投到的类。由于[2.x.29]是以共享指针的形式存储的，所以通过值而不是引用返回向量的开销最小。  如果[2.x.30]类与[2.x.31]在逐个单元的基础上不相同，这允许灵活性。     [2.x.32] 类型[2.x.33]需要与提供给initialize()的类匹配。     [2.x.34] [2.x.35] 必须来自用于初始化()单元数据的同一个三角结构。 
* [0.x.8]*
   获取位于 [2.x.36] 的数据的常数指针的向量。  一个可能的附加类型名[2.x.37]是基类DataType可以被投向的类。由于[2.x.38]是以共享指针的形式存储的，所以通过值而不是引用来返回一个向量的开销最小。  如果[2.x.39]类与[2.x.40]在逐个单元的基础上不相同，这允许灵活性。     [2.x.41] 类型[2.x.42]需要与提供给initialize()的类匹配。     [2.x.43] [2.x.44] 必须来自用于初始化()单元数据的同一个三角结构。 
* [0.x.9]*
   返回一个[2.x.45]，表明[2.x.46]是否包含相关数据。如果数据是可用的，解除引用[2.x.47]会显示一个指向正交点的基础数据的指针向量。  一个可能的附加类型名[2.x.48]是基类DataType可以被投射到的类。由于[2.x.49]是以共享指针的形式存储的，所以通过值而不是引用来返回矢量的开销最小。  如果[2.x.50]类与[2.x.51]在逐个单元的基础上不相同，这允许灵活性。     [2.x.52] 类型[2.x.53]需要与提供给initialize()的类匹配。   [2.x.54] [2.x.55] 必须来自用于初始化()单元数据的同一个三角结构。 
* [0.x.10]*
   返回一个[2.x.56]，表明[2.x.57]是否包含相关数据。如果数据可用，解除引用[2.x.58]会显示一个指向正交点的基础数据的常数指针向量。  一个可能的附加类型名[2.x.59]是基类DataType可以被投射到的类。由于[2.x.60]是以共享指针的形式存储的，所以通过值而不是引用来返回矢量的开销最小。  如果[2.x.61]类与[2.x.62]在逐个单元的基础上不相同，这允许灵活性。     [2.x.63] 类型[2.x.64]需要与提供给initialize()的类匹配。   [2.x.65] [2.x.66] 必须来自用于初始化()单元数据的同一个三角结构。 
* [0.x.11]*
   尺寸的数量  
* [0.x.12]*
   空间维度的数量  
* [0.x.13]*
   为了确保CellDataStorage中的所有单元都来自同一个三角形，我们需要在该类中存储一个对该三角形的引用。 
* [0.x.14]*
   一个用于存储每个单元格的数据向量的地图。  我们需要使用CellId作为键，因为它在自适应细化过程中保持唯一。 
* [0.x.15]*
    [2.x.67] 异常情况  
* [0.x.16]*
    [2.x.68] 异常情况  
* [0.x.17]*
 一个抽象的类，它规定了在细化或重新划分过程中，单个正交点的数据可以转移的要求。
* 这个类提供了一个框架，代表正交点数据的派生类可以声明他们存储了多少标量值，然后实现将这些标量打包和解压到数组的函数。这些数组用于将数据从一个单元的正交点转移到另一个单元的正交点，以及在网格细化和重新划分时在处理器之间转移。父单元和子单元之间的正交点数据传输需要某种投影和/或内插。一个可能的实现是通过[2.x.69]类中实现的二级投影和延长矩阵。
* 要存储和访问从该类派生的类的实例，请参阅CellDataStorage类。

* 
* [0.x.18]*
   默认构造函数。 
* [0.x.19]*
   默认的虚拟解构器。 
* [0.x.20]*
   返回将从用户的DataType类中打包/解包的数值总数。因此，它也是pack_values()和unpack_values()中向量的大小。 
* [0.x.21]*
   一个必须在派生类中实现的虚拟函数，用于将派生类中存储的所有数据打包成一个向量 [2.x.70] 。  这个向量将包含每个正交点的所有标量和/或量纲数据。   
* [2.x.71] 该函数将以大小为number_of_values()的[2.x.72]被调用。  实现时可能仍有一个断言来检查是否确实如此。 
* [0.x.22]*
   与上面的情况相反，即把一个向量[2.x.73]解压为存储在这个类中的数据。   
* [2.x.74]该函数将以大小为number_of_values()的[2.x.75]被调用。  实现可能仍然有一个断言来检查是否确实如此。 
* [0.x.23]*
     在执行 [2.x.76] 的h-adaptive refinement时，用于传输存储在正交点的连续数据的类。        [1.x.0] 该类实现了在使用L2投影进行自适应细化的情况下，单元格之间正交点数据的传输。这也包括不同处理器之间的信息自动运输。        为此，该类的构造函数提供了三个主要对象：标量FiniteElement [2.x.77] [2.x.78] 和 [2.x.79] 正交规则。    首先，位于每个单元的[2.x.80]的数据被L2投影到由单个FiniteElement [2.x.81]定义的连续空间。    这是用 [2.x.82] 实现的。在这样做时，需要这个元素的质量矩阵，这将用 [2.x.83] 规则计算。如果该单元现在属于另一个处理器，那么数据就会被发送到这个处理器。该类利用了p4est（和[2.x.84]的一个特性，允许人们在网格细化和再平衡过程中给单元附加信息。在接收到目标单元的信息后，使用 [2.x.85] 计算的矩阵将数据投射回正交点。    在进行局部细化的情况下，该类首先将父元素的局部DoF值投影到每个子元素。            这个类是由[2.x.86]类型模板化的，然而用户的[2.x.87]类必须派生自TransferableQuadraturePointData类。在实践中，这相当于为一个有2个标量的正交点数据实现以下三个函数。   
* [1.x.1]
* 注意，打包和解包的顺序必须相同。        然后，这个类可以通过以下方式与CellDataStorage一起使用。   
* [1.x.2]
* 这种方法可以扩展到具有任意顺序的张量对象的正交点数据，尽管在MyQData类中对数据的打包和解包要多做一点工作。       
* [2.x.88] 目前不支持粗化。       
* [2.x.89] 这个类所提供的功能也可以用[2.x.90]来实现，但是，这需要以下步骤。(i) 创建一个具有（非连续Galerkin）FiniteElement的辅助DoFHandler，该FiniteElement有足够的分量来表示存储在正交点的所有数据；(ii) 将数据投影到FiniteElement空间，从而将结果存储在全局向量中；(iii) 使用[2.x.91]将FE向量投影到新网格上；(iv) 最后通过FEValues类将数据投影回新网格的正交点。ContinuousQuadratureDataTransfer类的目的是简化整个过程，只要求正交点数据类派生自TransferableQuadraturePointData。其他一切都将自动完成。       
* [2.x.92] 这个类不太适合存储在正交点的值代表不连续场的样本的情况。这种情况的一个例子是，存储在正交点的数据代表了材料的弹性或塑性状态，即在固体中不连续变化的属性。在这种情况下，试图将数据从正交点转移到连续的有限元场（至少在一个单元内）可能会产生过冲和下冲，一旦在不同的正交点集（在子单元或父单元上）进行评估，就会产生没有多大意义的数值。   
* [0.x.24]*
       一个单元格的别名。     
* [0.x.25]*
       构造函数，它接收有限元素[2.x.93]，用于积分其局部质量矩阵的正交规则[2.x.94]，最后用于存储[2.x.96] [2.x.97] [2.x.98]的正交规则必须是标度值。           
* [2.x.99]由于该类在单元格基础上进行投影，[2.x.100]只需要在单元格内是连续的。     
* [0.x.26]*
       为粗化和细化三角形做准备 [2.x.101] 。       [2.x.102]代表应该转移的单元数据，它应该对每个本地拥有的活动单元进行初始化。           
* [2.x.103] 尽管CellDataStorage类允许在不同的单元上存储来自基类的不同对象，这里我们假设[2.x.104]包含相同类型的对象，更确切地说，它们打包/解包相同的数据。     
* [0.x.27]*
       在网格被细化或粗化之前，将先前存储在该对象中的数据插值到当前活动单元组的正交点上。           
* [2.x.105]在调用此函数之前，用户应使用[2.x.107]在新的单元格中填充存储在提供给prepare_for_coarsening_and_refinement()的[2.x.106]对象中的数据，如果不是这样，在调试模式下将会抛出一个异常。     
* [0.x.28]*
       一个回调函数，用于将当前网格上的数据打包成对象，以后可以在细化、粗化和重新划分后进行检索。     
* [0.x.29]*
       一个回调函数，用来解开当前网格上的数据，这些数据在细化、粗化和重新划分之前，已经被打包在网格上了。     
* [0.x.30]*
       用于投影正交点的数据的FiniteElement。     
* [0.x.31]*
       将被发送的数据的大小，这取决于数据类型类。     
* [0.x.32]*
       存储DataType的正交点的数量。     
* [0.x.33]*
       从正交点到单个标量的本地DoF的投影矩阵。     
* [0.x.34]*
       单个标量从局部DoF到正交点的投影矩阵。     
* [0.x.35]*
       辅助矩阵，表示存储在正交点（第二个索引）的每个内部值对[2.x.108]（第一个索引）的本地DoF的投影。     
* [0.x.36]*
       在自适应细化的情况下，[2.x.109]对每个子单元的投影。     
* [0.x.37]*
       辅助矩阵，代表存储在每个正交点（第一索引）的数据（第二索引）。     
* [0.x.38]*
       [2.x.110]在注册pack_callback函数时分配给这个对象的句柄。     
* [0.x.39]*
       一个指向CellDataStorage类的指针，其数据将被转移。     
* [0.x.40]*
       一个指向分布式三角图的指针，单元格数据被附加到该三角图上。     
* [0.x.41]将使用[2.x.112]存储在[2.x.113]中的每个正交点的[2.x.114]类型的单元数据打包到[2.x.115]这里[2.x.115]是一个矩阵，其第一个索引对应于单元上的不同正交点，而第二个索引代表存储在DataType类中每个正交点的不同值。

* 
* [0.x.42] 与上面的打包函数相反。

* 
* [0.x.43]

