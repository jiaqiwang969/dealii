include/deal.II-translator/base/symmetric_tensor_0.txt
[0.x.0]*
   一个命名空间，用于SymmetricTensor类（及其相关函数）工作方式的内部函数和类。 
* [0.x.1]*
     计算通用[2.x.0][2.x.1]和[2.x.2]类型的对称张量的逆运算。   
* [0.x.2]*
   一个命名空间，用于SymmetricTensor类工作方式的内部类。 
* [0.x.3]*
     创建一个TableIndices<2>对象，其中到<tt>position-1</tt>的第一个条目来自previous_indices，而new_index被放在<tt>position</tt>的位置。其余的指数仍处于无效状态。   
* [0.x.4]*
     创建一个TableIndices<4>对象，其中到<tt>position-1</tt>的第一个条目取自previous_indices，new_index被放在<tt>position</tt>的位置。其余的指数仍处于无效状态。   
* [0.x.5]*
     Typedef模板魔法，表示两个张量或等级rank1和rank2之间的双倍收缩结果。一般来说，这是一个等级<tt>rank1+rank2-4</tt>的张量，但如果这是零的话，就是一个单一的标量Number。对于这种情况，我们有一个特殊化。   
* [0.x.6]*
     Typedef模板魔法表示两个张量或等级rank1和rank2之间的双重收缩的结果。一般来说，这是一个等级<tt>rank1+rank2-4</tt>的张量，但如果这是零的话，就是一个单一的标量数。对于这种情况，我们有一个特殊化。   
* [0.x.7]*
     声明用于存储对称张量的数据结构类型的别名。例如，对于等级2的对称张量，我们使用一个平面向量来存储所有的元素。另一方面，对称秩-4张量是从对称秩-2张量映射到对称秩-2张量，所以它们可以被表示为矩阵等。        除了需要这些信息的访问器类之外，其他人可能对这些信息不感兴趣。特别是，你不应该在你的应用程序中对存储格式做任何假设。   
* [0.x.8]*
     用于秩2张量的StorageType的特殊化。   
* [0.x.9]*
       等级2的对称张量的独立成分的数量。我们只存储它的右上半部分。     
* [0.x.10]*
       声明我们实际存储数据的类型。     
* [0.x.11]*
     用于等级4张量的StorageType的特殊化。   
* [0.x.12]*
       等级2的对称张量的独立分量的数量。      由于秩-4张量是这类对象之间的映射，我们需要这些信息。     
* [0.x.13]*
       等级4的对称张量的独立分量的数量。     
* [0.x.14]*
       声明我们实际存储数据的类型。对称秩4张量是对称秩2张量之间的映射，所以如果我们将秩2张量表示为向量，我们可以将数据表示为矩阵。     
* [0.x.15]*
     切换类型，选择一个秩2和维度<tt>dim</tt>的张量，切换张量是否应该是常数。   
* [0.x.16]*
     切换类型选择一个等级为2，维度为<tt>dim</tt>的张量，切换张量是否应该是常数。        对常数张量的特殊化。   
* [0.x.17]*
     切换类型选择等级2和维度<tt>dim</tt>的张量，切换张量是否应该是常数。        对非常数张量的特殊化。   
* [0.x.18]*
      [2.x.3] 作为SymmetricTensor类型元素的访问器的类。模板参数<tt>constness</tt>可以是true或false，表示所处理的对象是否是常数（即只有在值为false时才允许写访问）。        因为在<tt>N</tt>索引中，应用<tt>operator[]</tt>的效果是获得对<tt>N-1</tt>索引的访问，我们必须递归地实现这些访问器类，当我们只剩下一个索引时就停止。对于后一种情况，下面声明了这个类的特殊化，调用<tt>operator[]</tt>可以访问张量实际存储的对象；张量类还确保只访问我们实际存储的那些元素，也就是说，必要时它会重新排列索引。模板参数<tt>P</tt>表示有多少个剩余的索引。对于一个等级为2的张量，<tt>P</tt>可能是两个，而当使用<tt>operator[]</tt>时，会出现一个<tt>P=1</tt>的对象。        正如对整个命名空间所说的，你通常不会直接与这些类打交道，也不应该试图直接使用它们的接口，因为它可能会在没有通知的情况下改变。事实上，由于构造函数是私有的，你甚至不能生成这个类的对象，因为它们只被认为是访问表类元素的暂时性的，而不是作为函数的参数来传递它们，等等。        这个类是一个用于表类的类似类的改编。   
* [0.x.19]*
       从上面的switch类中导入两个别名。     
* [0.x.20]*
       构造函数。取一个我们要访问的张量对象的引用。            第二个参数表示进入张量的前几个索引的值。例如，对于一个等级为4的张量，如果P=2，那么我们将已经有两个连续的元素选择（例如通过<tt>tensor[1][2]</tt>），这两个索引值必须被储存在某个地方。因此，这个类只利用这个数组的第一个等级-P元素，但用P-1将其传递给下一级，由其填充下一个条目，以此类推。            构造函数是私有的，以防止你身边有这样的对象。创建这种对象的唯一方法是通过<tt>Table</tt>类，它只作为临时对象生成它们。      这保证了访问器对象比母对象更早退出范围，避免了数据一致性的问题。     
* [0.x.21]*
       复制构造函数。     
* [0.x.22]*
       索引操作符。     
* [0.x.23]*
       索引操作符。     
* [0.x.24]*
       存储给构造函数的数据。     
* [0.x.25]*
      [2.x.4] SymmetricTensor的访问器类。这是最后一个索引的特殊化，它实际上允许访问表中的元素，而不是递归地返回进一步子集的访问对象。这种特殊化与一般模板的情况相同；更多信息请看那里。   
* [0.x.26]*
       从上面的开关类中导入两个别名。     
* [0.x.27]*
       构造函数。取一个我们要访问的张量对象的引用。            第二个参数表示进入张量的前几个索引的值。例如，对于一个等级为4的张量，如果P=2，那么我们将已经有两个连续的元素选择（例如通过<tt>tensor[1][2]</tt>），这两个索引值必须被储存在某个地方。因此，这个类只利用这个数组的第一个等级-P元素，但用P-1将其传递给下一级，而P-1则填充了下一个条目，以此类推。            对于这个特殊的特殊化，即对于P==1，除了最后一个索引，其他的都已经被填充了。            构造函数是私有的，以防止你身边有这样的对象。创建这种对象的唯一方法是通过<tt>Table</tt>类，它只生成临时对象。      这保证了访问器对象比母对象更早退出范围，避免了数据一致性的问题。     
* [0.x.28]*
       复制构造函数。     
* [0.x.29]*
       索引操作符。     
* [0.x.30]*
       索引运算器。     
* [0.x.31]*
       存储给构造函数的数据。     
* [0.x.32]*
 提供一个能有效地存储等级为2,4,...的对称张量的类，即只存储全张量中那些不多余的对角线元素。例如，对于对称[2.x.5]张量，这将是元素11、22和12，而元素21等于12的元素。在本文档中，二阶对称张量用粗体大写拉丁字母表示，如 [2.x.6] 或粗体希腊字母，如 [2.x.7] , [2.x.8] 。二阶张量如[2.x.9]的直角坐标表示为[2.x.10]，其中[2.x.11]是0到<tt>dim-1</tt>的指数。
* 在许多情况下，对秩为2的对称张量使用这个类比矩阵有优势，因为编译器知道维度以及数据的位置。因此有可能产生比运行时间相关的维度的矩阵更有效的代码。它也比使用更通用的<tt>Tensor</tt>类更有效，因为存储的元素更少，而且该类会自动确保张量代表一个对称对象。
* 对于更高等级的张量，存储方面的节省甚至更高。例如，对于等级为4的[2.x.12]张量，只需要存储36个而不是全部81个条目。这些等级4的张量用黑板风格的大写拉丁字母表示，如[2.x.13]，其组成部分[2.x.14] 。
* 虽然对称秩-2张量的定义很明显，但如果秩4张量是将对称秩-2张量映射到对称秩-2张量上的算子，则被视为对称的。这种所谓的秩4张量的次要对称性要求对于每一组四个指数[2.x.15]，身份[2.x.16]成立。然而，它并不意味着关系 [2.x.17] 。因此，这里所理解的等级4的对称张子只是将对称张子映射到对称张子上的张子，但它们不一定能引起对称标量积[2.x.18]，甚至是正（半）定式[2.x.19]，其中[2.x.20]是对称等级2张子，冒号表示常见的双指数收缩，作为对称张子的标量积作用。
* 对称张量最常用于结构和流体力学，其中应变和应力通常是对称张量，应力-应变关系由对称秩4张量给出。
* 

* 
* [2.x.21] 对称张量只存在于偶数的指数。换句话说，你可以使用的对象只有<tt>SymmetricTensor<2,dim></tt>, <tt>SymmetricTensor<4,dim></tt>等，但是<tt>SymmetricTensor<1,dim></tt>和<tt>SymmetricTensor<3,dim></tt>并不存在，使用它们很可能导致编译器错误。
* 

* [1.x.0]
* 张量[2.x.22]的元素可以使用括号运算符来访问，即对于等级为4的张量，<tt>C[0][1][0][1]</tt>可以访问元素[2.x.23] 。这种访问可以用于读和写（如果张量至少是非常数）。你也可以对它进行其他操作，尽管这可能会导致混乱的情况，因为张量的几个元素被存储在同一个位置。例如，对于一个假定开始时为零的秩-2张量，写<tt>A[0][1]+=1; A[1][0]+=1;</tt>将导致同一个元素被增加1[2.x.24]两次[2.x.25] ，因为即使访问使用不同的索引，被访问的元素是对称的，因此存储在同一位置。因此，在应用程序中，将对单个元素的操作限制为简单的读或写可能是有用的。
* 

* 
* [2.x.26] 

* 
* [0.x.33]*
   提供一种方法来获取一个对象的尺寸，而不需要明确知道它的数据类型。实现这种方式而不是提供一个函数<tt>dimension()</tt>，因为现在有可能在编译时获得尺寸，而不需要内联函数的扩展和预评估；因此编译器可能产生更有效的代码，你可以使用这个值来声明其他数据类型。 
* [0.x.34]*
   向外界公布这个张量的等级。 
* [0.x.35]*
   一个整数，表示完全描述一个对称张量的独立成分的数量。在[2.x.27]空间维度中，这个数字等于[2.x.28]的对称张量的等级2。 
* [0.x.36]*
   默认构造函数。创建一个所有条目都等于零的张量。 
* [0.x.37]*
   构造函数。从一个一般的张量生成一个对称的张量。假设[2.x.29]已经是对称的，在调试模式下，这实际上是检查的。  注意，没有规定保证张量只在四舍五入的情况下是对称的：如果传入的张量不是完全对称的，那么会抛出一个异常。如果你知道传入的张量只到四舍五入为止是对称的，那么你可能想先调用<tt>symmetrize()</tt>函数。如果你不确定，在调用<tt>symmetrize()</tt>之前进行检查是很好的做法。    因为我们通过非constexpr函数调用来检查对称性，所以你必须在constexpr上下文中使用symmetrize()函数来代替。 
* [0.x.38]*
   一个构造函数，用于从持有独立元素的数组中创建一个对称的张量。使用这个构造函数假定调用者知道元素在对称张量中的存储顺序；因此不鼓励使用它，但是如果你认为你想使用它，你可以使用unrolled_index()函数查询元素的顺序。    这个构造函数目前只针对等级为2的对称张量实现。    传递的数组的大小等于[2.x.30]使用内部命名空间的对象的原因是为了解决一些旧编译器的错误。 
* [0.x.39]*
   从具有不同底层标量类型的张量复制构造函数。这显然要求[2.x.31]类型可以转换为[2.x.32]数。 
* [0.x.40]*
   返回一个指向底层存储的第一个元素的指针。 
* [0.x.41]*
   返回一个指向底层存储的第一个元素的常量指针。 
* [0.x.42]*
   返回一个指向底层存储结束后的元素的指针。 
* [0.x.43]*
   返回一个超过底层存储结束的元素的常量指针。 
* [0.x.44]*
   来自具有不同底层标量类型的对称张量的赋值运算符。  这显然要求[2.x.33]类型可以转换为[2.x.34]。  
* [0.x.45]*
   这个操作符将一个标量分配给一个张量。为了避免混淆将标量值分配给张量的确切含义，零是<tt>d</tt>唯一允许的值，允许用直观的符号[2.x.35]将张量的所有元素重置为零。 
* [0.x.46]*
   将目前的对称张量转换成具有相同元素的全张量，但使用全张量的不同存储方案。 
* [0.x.47]*
   测试两个张量的相等性。 
* [0.x.48]*
   测试两个张量的不等式。 
* [0.x.49]*
   添加另一个张量。 
* [0.x.50]*
   减去另一个张量。 
* [0.x.51]*
   用<tt>因子</tt>缩放张量，即用<tt>因子</tt>乘以所有组件。 
* [0.x.52]*
   用<tt>1/factor</tt>缩放张量。 
* [0.x.53]*
   单元减法运算符。负掉张量的所有条目。 
* [0.x.54]*
   本对称张量与一个等级为2的张量之间的双重收缩积。例如，如果当前对象是对称秩2张量[2.x.36]，它与另一个对称秩2张量[2.x.37]相乘，那么结果是标量积双收缩 [2.x.38] 。  在这种情况下，返回值被评估为一个单一的标量。虽然有可能定义其他标量积（以及相关的诱导规范），但这个似乎是最合适的一个。    如果当前对象是一个秩-4张量，比如[2.x.39]，那么结果是一个秩-2张量[2.x.40]，也就是说，该操作在当前对象的最后两个索引和参数的索引上收缩，结果是一个秩2的张量（[2.x.41]）。    请注意，对称张量的乘法算子被定义为对两个索引的双重收缩，而对于普通<tt>张量</tt>对象，它被定义为对一个索引的单一收缩。因此，对于对称张量，它的作用方式在数学文献中通常用 "冒号乘法 "来表示。    有一些全局函数<tt>double_contract</tt>做了与这个操作符相同的工作，但它们不是将结果作为返回值，而是将其写入函数的第一个参数中。 
* [0.x.55]*
   在本对象的两个索引上收缩，并将等级4的对称张量作为参数给出。 
* [0.x.56]*
   返回一个对指定元素的读写引用。 
* [0.x.57]*
   返回一个[2.x.42]对参数所指的值的引用。 
* [0.x.58]*
   访问这个对称张量的某一行的元素。这个函数是为常数张量调用的。 
* [0.x.59]*
   访问这个对称张量的一行元素。对于非常数张量，这个函数被调用。 
* [0.x.60]*
   返回一个[2.x.43]对参数所指数值的引用。    与operator()完全相同。 
* [0.x.61]*
   返回一个对指定元素的读写引用。    与operator()完全相同。 
* [0.x.62]*
   根据unrolled index访问一个元素。函数<tt>s.access_raw_entry(unrolled_index)</tt>与<tt>s[s.unrolled_to_component_indices(unrolled_index)]</tt>的作用相同，但更有效。 
* [0.x.63]*
   根据unrolled index来访问一个元素。函数<tt>s.access_raw_entry(unrolled_index)</tt>与<tt>s[s.unrolled_to_component_indices(unrolled_index)]</tt>的作用相同，但效率更高。 
* [0.x.64]*
   返回张量的Frobenius-norm，即所有条目平方之和的平方根。这个准则是由上面为两个对称张量定义的标量乘引起的。请注意，它包括张量的[1.x.1]个条目，计算对称性，而不仅仅是唯一的条目（例如，对于等级2的张量，这个准则包括将右上和左下条目的平方相加，而不仅仅是其中之一，尽管它们对于对称张量是相等的）。 
* [0.x.65]*
   张量对象可以通过简单地将所有元素粘贴到一个长矢量中来展开，但为此必须定义一个元素的顺序。对于对称张量，该函数返回对称张量中给定条目在[2.x.44]范围内的哪个索引。 
* [0.x.66]*
   与前一个函数相反：给定张量的解卷形式中的一个索引[2.x.45]，返回与之相对应的索引集[2.x.46]（对于秩-2张量）或[2.x.47]（对于秩-4张量）。 
* [0.x.67]*
   将所有数值重置为零。    请注意，这与标准库容器的[2.x.48]clear()成员函数和deal.II中的其他几个类的语义部分不一致，它们不仅将存储元素的值重置为零，而且释放所有内存并将对象返回到处女状态。然而，由于本类型的对象的大小是由其模板参数决定的，所以调整大小是不可能的，事实上，所有元素的值都为零的状态就是这样一个对象构造后的状态。 
* [0.x.68]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.69]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据读入或写入一个流中，以便进行序列化。 
* [0.x.70]*
   一个描述基数张量的属性的结构。 
* [0.x.71]*
   对称张量的数据存储类型。 
* [0.x.72]*
   我们存储张量数据的地方。 
* [0.x.73]*
 两个等级相同的对称张量相加。结果是另一个SymmetricTensor，它的数字类型与该操作兼容。
* 如果可能的话（例如，当[2.x.49]和[2.x.50]是同一类型时，或者如果[2.x.51]的结果是另一个[2.x.52]，你应该使用<tt>操作符+=</tt>来代替，因为这不需要创建一个临时变量。
* [2.x.53] SymmetricTensor

* 
* [0.x.74]*
 减去两个等级相同的对称张量。其结果是另一个SymmetricTensor，它的数字类型与该操作兼容。
* 如果可能的话（例如，当[2.x.54]和[2.x.55]是相同的类型，或者如果<code>Number()的结果
* 
* - OtherNumber()</code>是另一个[2.x.56]，你应该使用<tt>operator-=</tt>代替，因为这不需要创建一个临时变量。
* [2.x.57] SymmetricTensor

* 
* [0.x.75]*
 将一个对称张量和一个相同等级的一般张量相加。其结果是一个一般的张量，其数字类型与该操作兼容。
* [2.x.58] SymmetricTensor

* 
* [0.x.76]*
 一个普通张量与一个相同等级的对称张量相加。其结果是一个一般的张量，其数字类型与该操作兼容。
* [2.x.59] SymmetricTensor

* 
* [0.x.77]*
 从一个相同等级的对称张量中减去一个一般张量。其结果是一个一般的张量，其数字类型与该操作兼容。
* [2.x.60] SymmetricTensor

* 
* [0.x.78]*
 从一个相同等级的一般张量中减去一个对称张量。其结果是一个一般的张量，其数字类型与该操作兼容。
* [2.x.61] SymmetricTensor

* 
* [0.x.79]*
 计算一个等级2的对称张量的行列式。行列式通常也被称为等级2张量的第三不变量。
* 对于一个一维张量，行列式等于唯一的元素，因此等同于轨迹。
* 为了简化符号学，还有一个<tt>third_invariant()</tt>函数可以返回一个张量的行列式。
* [2.x.62] SymmetricTensor

* 
* [0.x.80]*
 计算一个等级2的对称张量的行列式。因此，这个函数计算的值与<tt>determinant()</tt>函数相同，提供这个函数只是为了在符号上更加简单（因为还有first_invariant()和second_invariant()函数）。[1.x.2]
* [2.x.63] SymmetricTensor

* 
* [0.x.81]*
 计算并返回等级为2的张量的轨迹，即其对角线项的总和。跟踪是秩2张量的第一个不变量。[1.x.3]
* [2.x.64] SymmetricTensor

* 
* [0.x.82]*
 计算一个秩2对称张量的迹。因此，这个函数计算的值与<tt>trace()</tt>函数相同，提供这个函数只是为了在符号上更加简单（因为还有second_invariant()和third_invariant()函数）。[1.x.4]
* [2.x.65] SymmetricTensor

* 
* [0.x.83]*
 计算一个等级为2的张量的第二个不变式。张量[2.x.66]的第二不变量定义为[2.x.67] 。
* 对于这个函数的参数种类，即大小为1的秩2张量，其结果只是零。
* [2.x.68] SymmetricTensor

* 
* [0.x.84]*
 计算一个等级为2的张量的第二不变量。张量[2.x.69]的第二不变量定义为[2.x.70] 。
* 对于这个函数的参数种类，即大小为2的对称秩-2张量，其结果是（从1开始计算指数） [2.x.71] 。正如预期的那样，对于这个函数处理的[2.x.72]对称张量，这等于张量的行列式。这是因为对于[2.x.73]对称张量，实际上只有两个不变式，所以第二个和第三个不变式是一样的；行列式是第三个不变式）。
* [2.x.74] 对称张量

* 
* [0.x.85]*
 计算一个等级为2的张量的第二个不变式。张量[2.x.75]的第二不变量定义为[2.x.76] 。
* [2.x.77] 对称张量

 
* [0.x.86]*
 返回一个对称的[2.x.78]张量的特征值。当然，张量的（单一）条目等于（单一）特征值。
* [2.x.79] SymmetricTensor

* 
* [0.x.87]*
 返回一个对称的[2.x.80]张量的特征值。特征值的数组按降序排序。
* 对于[2.x.81]张量，张量[2.x.82]的特征值是[1.x.5] [2.x.83]的根，由[2.x.84]给出。
* [2.x.85] 这里采用的算法通过计算特征多项式的根来确定特征值。在存在共根的情况下（特征值相等），计算结果为[1.x.6]阶的[2.x.86] 。作为一种替代方法，eigenvectors()函数提供了一种更稳健但昂贵的方法来计算对称张量的特征值。
* [2.x.87] SymmetricTensor

* 
* [0.x.88]*
 返回一个对称[2.x.88]张量的特征值。特征值的数组按降序排序。
* 对于[2.x.89]张量，张量[2.x.90]的特征值是[1.x.7] [2.x.91] 的根。
* [2.x.92] 这里采用的算法通过计算特征多项式的根来确定特征值。在存在共根的情况下（特征值相等），计算是[1.x.8]的顺序[2.x.93] 。作为一种替代方法，eigenvectors()函数提供了一种更稳健但昂贵的方法来计算一个对称张量的特征值。
* [2.x.94] SymmetricTensor

* 
* [0.x.89]*
     使用Householder方法对一个等级2的对称张量进行三对角化。    这里实现的专门算法是在    
* [1.x.9]
* 中给出的，并且是基于11.3.2节中提出的通用算法。   
* [1.x.10]
* [2.x.95] A 要被三对角化的张量 [2.x.96] Q 实现转换的正交矩阵 [2.x.97] d 三对角矩阵的对角线元素 [2.x.98] e 三对角矩阵的非对角线元素    
* [0.x.90]*
     使用QL算法计算实值等级为2的对称张量的特征值和特征向量，并采用隐式移位的方法。    这里实现的专门算法是在    
* [1.x.11]
* 的第11.4.3节中提出的通用算法的基础上。   
* [1.x.12]
* [2.x.99] A 要计算特征向量和特征值的张量。         [2.x.100] 一个包含特征向量和相关特征值的数组。    该数组不按任何特定顺序排序。   
* [0.x.91]*
     使用雅可比算法计算实值秩2对称张量的特征值和特征向量。    这里实现的专门算法是在    
* [1.x.13]
* 的第11.4.3节中提出的通用算法的基础上。   
* [1.x.14]
* [2.x.101] A 要计算的特征向量和特征值的张量。         [2.x.102] 一个包含特征向量和相关特征值的数组。    该数组不按任何特定顺序排序。   
* [0.x.92]*
     计算实值等级为2的对称2x2张量的特征值和特征向量，使用特征方程计算特征值，并使用基于交叉积的分析方法计算特征向量。如果计算结果被认为太不准确，那么该方法就会退回到ql_implicit_shifts。         [2.x.103] A 将要计算特征向量和特征值的张量。         [2.x.104] 一个包含特征向量和相关特征值的数组。    该数组不按任何特定顺序排序。   
* [0.x.93]*
     计算实值等级为2的对称3x3张量的特征值和特征向量，使用特征方程计算特征值，并使用基于交叉积的分析方法计算特征向量。如果计算结果被认为太不准确，那么该方法就会退回到ql_implicit_shifts。这里实现的专门算法是在    
* [1.x.15]
* [2.x.105] A 要计算特征向量和特征值的张量。         [2.x.106] 一个包含特征向量和相关特征值的数组。    该数组不按任何特定顺序排序。   
* [0.x.94]*
     一个结构，用于对eign=envalues和特征向量的数组进行排序。排序是按照特征值的降序进行的。   
* [0.x.95]*
 枚举算法，用于在对SymmetricTensor对象使用eigenvalues()和eigenvectors()方法进行归一化特征向量及其相应特征值的计算时使用。
* 在计算特征向量时使用的专门算法在下文中介绍。

* 
* [1.x.16]
* 

* 
* [0.x.96]*
   一种混合方法，优先使用特征方程来计算特征值，并使用基于交叉积的分析方法来计算特征向量。如果计算结果被认为太不准确，那么该方法就会退回到ql_implicit_shifts。    如果没有遇到病态的情况，这种方法可能会提供最快速的计算。 
* [0.x.97]*
   迭代QL算法，在使用Householder方法对张量进行三对角化后应用隐式移位。    这种方法在计算速度和它的稳健性之间提供了一个折中。当[2.x.107]的元素有很大的变化幅度时，这种方法特别有用，这通常会导致在计算较小的特征值时失去准确性。 
* [0.x.98]*
   迭代雅可比算法。    这种方法提供的是现有选项中最稳健的，即使是最病态的情况也能得到可靠的结果。然而，它是所有实施的算法中最慢的算法。 
* [0.x.99]*
 返回实值等级2的对称张量的特征值和特征向量 [2.x.108] 。匹配的特征值和特征向量对阵列按降序排序（由特征值决定）。
* 在计算特征向量时利用的专门算法见于

* 
* [1.x.17]
* 
* [2.x.109] SymmetricTensor

* 
* [0.x.100]*
 返回给定的对称张量的转置。由于我们正在处理对称对象，转置当然与原始张量相同。这个函数的存在主要是为了与张量类兼容。
* [2.x.110] SymmetricTensor

* 
* [0.x.101]*
 计算对称张量的偏差，其定义为 [2.x.111] ，其中 [2.x.112] 是身份算子。这个量等于原始张量减去其收缩或扩张成分，指的是弹性等方面的剪切力。
* [2.x.113] 对称张量

* 
* [0.x.102]*
 返回一个等级为2的单位对称张量，即[2.x.114]身份矩阵[2.x.115] 。
* [2.x.116] SymmetricTensor

* 
* [0.x.103]*
 unit_symmetric_tensor<dim>()是unit_symmetric_tensor<dim,Number>()函数的特殊化，它使用 [2.x.117] 作为元素的数据类型。
* [2.x.118] SymmetricTensor

* 
* [0.x.104]*
 返回等级4的张量，当与对称等级2的张量[2.x.119]相乘时，返回偏差[2.x.120] 。它是线性偏差算子[2.x.121]的算子表示，也被称为体积投影张量，计算公式为：。[1.x.18]
* 对于每一个张量<tt>T</tt>，都有一个特征<tt>deviator<dim,Number>(T) == deviator_tensor<dim,Number>() T</tt>，直到数字上的舍入。[1.x.19]
* 

* 
* [2.x.122] 提供这种运算符表示的原因是为了简化对张量的偏离部分的求导。[1.x.20]
* [2.x.123] SymmetricTensor

* 
* [0.x.105]*
 这个版本的deviator_tensor<dim>()函数是deviator_tensor<dim,Number>()的特殊化，使用<tt>double</tt>作为张量元素的数据类型。
* [2.x.124] SymmetricTensor

* 
* [0.x.106]*
 返回四阶对称身份张量[2.x.125]，它将对称的二阶张量，如[2.x.126]，映射到它们自己。[1.x.21]
* 请注意，这个张量，尽管它是同一性的，但它的形式有些滑稽，特别是不只由零和一组成。例如，对于<tt>dim=2</tt>，身份张量除了[1.x.22] [1.x.23] 以指数符号表示，我们可以写出一般的形式[1.x.24] 为了了解为什么[2.x.127]的这个因子是必要的，考虑计算[2.x.128] 。对于元素 [2.x.129] 我们有 [2.x.130] 。另一方面，我们需要有[2.x.131]，对称性意味着[2.x.132]，导致[2.x.133]，或者，同样通过对称性，[2.x.134] 。类似的考虑也适用于三维的情况。
* 这个问题在[2.x.135]的介绍中也有解释。
* [2.x.136] SymmetricTensor

* 
* [0.x.107]*
 这个版本的identity_tensor<dim>()函数是identity_tensor<dim,Number>()的特殊化，它使用<tt>double</tt>作为张量的元素的数据类型。
* [2.x.137] SymmetricTensor

* 
* [0.x.108]*
 反转一个对称的秩2张量。
* 

* 
* [2.x.138]如果一个张量不是可反转的，那么其结果是不明确的，但很可能包含除以0的结果或至少是一个非常小的数字。
* [2.x.139] SymmetricTensor

* 
* [0.x.109]*
 反转一个对称的秩-4张量。由于对称秩-4张量是对称秩-2张量的映射，它们可以有一个反转。
* 如果一个张量不是可逆的，那么其结果是不明确的，但可能包含除以0的结果或至少是一个非常小的数字。
* [2.x.140] SymmetricTensor

* 
* [0.x.110]*
 返回等级为4的张量，它是作为参数给出的两个张量的外积，即结果[2.x.141]满足[2.x.142]的所有对称张量[2.x.143] 。在索引符号中[1.x.25] 。
* 例如，偏差张量[2.x.144]可以被计算为<tt>identity_tensor<dim>()
* 
* - 1/d outer_product (unit_symmetric_tensor<dim>(), unit_symmetric_tensor<dim>())</tt>，因为与单位张量的（双）收缩会产生对称张量的迹线（[2.x.145] ）。
* [2.x.146] SymmetricTensor

* 
* [0.x.111]*
 返回全秩2张量的对称版本，即[2.x.147] ，作为对称秩2张量。这是对一般维度的版本。
* [2.x.148] SymmetricTensor

* 
* [0.x.112]*
 一般等级的对称张量与一个来自右边的标量相乘。如果标量的数据类型与用于存储对称张量元素的数据类型相同，则使用该运算符的这个版本。
* [2.x.149] SymmetricTensor

* 
* [0.x.113]*
 一般等级的对称张量与来自左边的标量相乘。如果标量的数据类型与用于存储对称张量元素的数据类型相同，则使用该运算符的这个版本。
* [2.x.150] SymmetricTensor

* 
* [0.x.114]*
 对称张量与来自右边的标量数字的乘法。
* 这个运算符的目的是只实现张量与标量数（即浮点数、复数浮点数等）的乘法。该函数的写法是，只有在第二个参数确实是标量数的情况下，编译器才会考虑这个函数
* 
* - 换句话说，[2.x.151]将不匹配，例如[2.x.152]，因为张量和矢量的乘积显然没有意义。在EnableIfScalar类的文档中解释了编译器禁止考虑这个操作符与非标量类型的乘法的机制。
* 函数的返回类型被选择为与张量和标量参数的类型一致。例如，如果你用 [2.x.153] 乘以 [2.x.154] ，那么结果将是 [2.x.155] 。换句话说，返回的张量存储其组件的类型等于你用标量因子乘以输入张量的单个组件后得到的类型。
* [2.x.156] SymmetricTensor [2.x.157] EnableIfScalar

* 
* [0.x.115]*
 对称张量与左边的标量数字相乘。关于模板参数和返回类型的更多信息，请参见与带交换参数的运算符的讨论。
* [2.x.158] SymmetricTensor [2.x.159] EnableIfScalar

* 
* [0.x.116]*
 一般等级的对称张量除以一个标量。
* [2.x.160] SymmetricTensor

* 
* [0.x.117]*
 一般等级的对称张量与一个标量从右边相乘。
* [2.x.161] SymmetricTensor

* 
* [0.x.118]*
 一般等级的对称张量与来自左边的标量相乘。
* [2.x.162] SymmetricTensor

* 
* [0.x.119]*
 一般等级的对称张量除以一个标量。
* [2.x.163] SymmetricTensor

* 
* [0.x.120]*
 计算两个秩为2的张量[2.x.165]之间的标量乘积[2.x.164]。在当前两个参数都是对称张量的情况下，这相当于调用表达式[2.x.166]，它使用[2.x.167] 。
* [2.x.168] SymmetricTensor

* 
* [0.x.121]*
 计算两个等级为2的张量[2.x.170]之间的标量乘积[2.x.169]。我们不使用[2.x.171]进行这个操作，因为两个张量之间的乘积通常被认为是对第一个张量的最后一个索引和第二个张量的第一个索引的收缩。例如，如果<tt>B</tt>是一个张量，调用<tt>A*B</tt>（而不是<tt>scalar_product(A,B)</tt>）提供 [2.x.172] 。
* [2.x.173] Tensor [2.x.174] SymmetricTensor

* 
* [0.x.122]*
 计算两个等级为2的张量[2.x.176]之间的标量乘积[2.x.175]。我们不使用[2.x.177]进行这个操作，因为两个张量之间的乘积通常被认为是对第一个张量的最后一个索引和第二个张量的第一个索引的收缩。例如，如果<tt>A</tt>是一个张量，调用<tt>A*B</tt>（而不是<tt>scalar_product(A,B)</tt>）提供 [2.x.178] 。
* [2.x.179] Tensor [2.x.180] SymmetricTensor

* 
* [0.x.123]*
 在等级4和等级2的对称张量之间进行双重收缩，产生等级2的对称张量，作为该函数的第一个参数给出。这个操作是矩阵-向量乘法的对称张量类似物。
* 这个函数的作用与[2.x.181]相同，但是不应该使用它，因为成员运算器知道实际的数据存储格式，并且至少快两个数量级。这个函数的存在主要是为了与一般的张量类兼容。
* [2.x.182] SymmetricTensor

* 
* [0.x.124]*
 在等级4和等级2的对称张量之间进行双重收缩，产生等级2的对称张量，作为该函数的第一个参数给出。这个操作是矩阵-向量乘法的对称张量类似物。
* 这个函数的作用与[2.x.183]相同，但是不应该使用它，因为成员运算器知道实际的数据存储格式，并且至少快两个数量级。这个函数的存在主要是为了与一般的张量类兼容。
* [2.x.184] SymmetricTensor

* 
* [0.x.125]*
 在等级4和等级2的对称张量之间进行双重收缩，产生等级2的对称张量，作为这个函数的第一个参数给出。这个操作是矩阵-向量乘法的对称张量类似物。
* 这个函数的作用与[2.x.185]相同，但是不应该使用它，因为成员运算器知道实际的数据存储格式，并且至少快两个数量级。这个函数的存在主要是为了与一般的张量类兼容。
* [2.x.186] SymmetricTensor

* 
* [0.x.126]*
 在等级4和等级2的对称张量之间进行双重收缩，产生等级2的对称张量，作为这个函数的第一个参数给出。这个操作是矩阵-向量乘法的对称张量类似物。
* 这个函数的作用与[2.x.187]相同，但是不应该使用它，因为成员运算器知道实际的数据存储格式，并且至少快两个数量级。这个函数的存在主要是为了与一般的张量类兼容。
* [2.x.188] SymmetricTensor

* 
* [0.x.127]*
 在等级4和等级2的对称张量之间进行双重收缩，产生等级2的对称张量，作为这个函数的第一个参数给出。这个操作是矩阵-向量乘法的对称张量类似物。
* 这个函数的作用与[2.x.189]相同，但是不应该使用它，因为成员运算器知道实际的数据存储格式，并且至少要快两个数量级。这个函数的存在主要是为了与一般的张量类兼容。
* [2.x.190] SymmetricTensor

* 
* [0.x.128]*
 在等级4和等级2的对称张量之间进行双重收缩，产生等级2的对称张量，作为这个函数的第一个参数给出。这个操作是矩阵-向量乘法的对称张量类似物。
* 这个函数的作用与[2.x.191]相同，但是不应该使用它，因为成员运算器知道实际的数据存储格式，并且至少要快两个数量级。这个函数的存在主要是为了与一般的张量类兼容。
* [2.x.192] SymmetricTensor

* 
* [0.x.129]*
 将一个对称的秩2张量（即一个矩阵）乘以一个秩1张量（即一个向量）。其结果是一个秩-1张量（即一个矢量）。
* [2.x.193] SymmetricTensor

* 
* [0.x.130]*
 将一个秩-1张量（即一个向量）与一个对称的秩-2张量（即一个矩阵）相乘。其结果是一个秩-1张量（即一个向量）。
* [2.x.194] SymmetricTensor

* 
* [0.x.131]*
 张量的点乘（单一收缩）。返回一个等级为[2.x.195]的张量，它是等级为[2.x.196]的张量的最后一个索引与等级为[2.x.199]的张量的第一个索引的收缩[1.x.26] 。
 

* 
* [2.x.200] 由于一个操作数是张量，乘法运算符只对一对索引执行收缩。这与SymmetricTensor的乘法运算符不同，后者做的是双倍收缩。
* [2.x.201] SymmetricTensor

* 
* [0.x.132]*
 张量的点积（单收缩）。返回一个等级为[2.x.202]的张量，它是等级为[2.x.204]的张量[2.x.203]的最后一个索引与等级为[2.x.206]的张量[1.x.27]的第一个索引的收缩。
 

* 
* [2.x.207] 由于一个操作数是张量，乘法运算符只对一对索引执行收缩。这与SymmetricTensor的乘法运算符不同，后者做的是双倍收缩。
* [2.x.208] SymmetricTensor

* 
* [0.x.133]*
 秩为2的对称张量的输出运算符。连续打印元素，中间有一个空格，等级1的子张量之间有两个空格，等级2之间有三个空格，以此类推。在输出中不做特殊的修改来表示对称性，例如只输出唯一的条目。
* [2.x.209] SymmetricTensor

* 
* [0.x.134]*
 秩为4的对称张量的输出运算符。连续打印元素，中间有一个空格，等级1的子张量之间有两个空格，等级2之间有三个空格，以此类推。在输出中不做特殊的修改以表示对称性，例如只输出唯一的条目。
* [2.x.210] SymmetricTensor

* 
* [0.x.135]

