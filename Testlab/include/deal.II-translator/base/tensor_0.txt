include/deal.II-translator/base/tensor_0.txt
[0.x.0]*
 这个类是<tt>Tensor<rank,dim,Number></tt>类的一个专门版本。它处理等级为零的张量，即标量。第二个模板参数[2.x.0]被忽略了。
* 这个类的存在是因为在某些情况下，我们想构造张量[2.x.1]类型的对象，它应该扩展为标量、向量、矩阵等，这取决于模板参数[2.x.2]和[2.x.3]的值，因此我们需要一个充当标量的类（即[2.x.4]用于所有目的，但属于Tensor模板家族。
* [2.x.5] dim 一个整数，表示该张量所处空间的维度。当然，这等于识别一个点和秩-1张量的坐标数。由于当前对象是一个秩0张量（标量），这个模板参数对这个类没有意义。
* [2.x.6] Number 要存储张量元素的数据类型。几乎在所有情况下，这只是默认的[2.x.7]，但在某些情况下，人们可能希望以不同的（而且总是标量）类型来存储元素。它可以用来将张量建立在[2.x.8]或[2.x.9]数字或任何其他实现基本算术运算的数据类型上。另一个例子是允许自动微分的类型（例如，见[2.x.10]中使用的Sacado类型），从而可以生成一个以张量为参数的函数的分析（空间）导数。
* 

* 
* [2.x.11] 

 
* [0.x.1]*
   提供一种方法来获取一个对象的尺寸，而不需要明确知道它的数据类型。实现这种方式而不是提供一个函数<tt>dimension()</tt>，因为现在有可能在编译时获得尺寸，而不需要内联函数的扩展和预评估；因此编译器可能产生更有效的代码，你可以使用这个值来声明其他数据类型。 
* [0.x.2]*
   向外界公布这个张量的等级。 
* [0.x.3]*
   秩为0的张量的独立成分的数量。 
* [0.x.4]*
   声明一个类型，该类型持有与该类的模板参数相同精度的实值数。对于[2.x.12]，这对应于类型number，对于所有其他情况，它等于Number。也请参见Vector<Number>中的相应字段。    这个别名是用来表示规范的返回类型的。 
* [0.x.5]*
   由这个容器封装并由operator[]()返回的对象的类型。这是一个等级为0的张量的标量数字类型。 
* [0.x.6]*
   声明一个数组类型，可以用来静态地初始化这个类型的对象。如果是一个等级为0的张量，这只是标量数字类型Number。 
* [0.x.7]*
   构造函数。设置为零。   
* [2.x.13] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.8]*
   来自不同底层标量类型的张量的构造器。这显然要求[2.x.14]类型可转换为[2.x.15]数字。   
* [2.x.16] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.9]*
   构造函数，数据从一个C风格的数组中复制出来。   
* [2.x.17] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.10]*
   拷贝构造函数  
* [0.x.11]*
   拷贝赋值操作符  
* [0.x.12]*
   移动构造函数  
* [0.x.13]*
   移动赋值运算符  
* [0.x.14]*
   返回一个指向底层存储的第一个元素的指针。 
* [0.x.15]*
   返回一个指向底层存储的第一个元素的常量指针。 
* [0.x.16]*
   返回一个指向底层存储结束后的元素的指针。 
* [0.x.17]*
   返回一个超过底层存储结束的元素的常量指针。 
* [0.x.18]*
   返回一个对封装的Number对象的引用。由于秩0张量是标量，这是一个自然的操作。    这是返回一个可写引用的非const转换操作。   
* [2.x.18] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.19]*
   返回一个对封装的Number对象的引用。由于秩0张量是标量，这是一个自然的操作。    这是一个const转换操作，返回一个只读的引用。   
* [2.x.19] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.20]*
   从具有不同底层标量类型的张量进行赋值。这显然要求[2.x.20]类型可以转换为[2.x.21]数。   
* [2.x.22]这个函数也可以在CUDA设备代码中使用。 
* [0.x.21]*
   这个操作符将一个标量分配给一个张量。这显然要求[2.x.23]类型可以转换为[2.x.24]。    
* [2.x.25] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.22]*
   测试两个张量的相等。 
* [0.x.23]*
   测试两个张量的不等式。 
* [0.x.24]*
   添加另一个标量。   
* [2.x.26]这个函数也可以在CUDA设备代码中使用。 
* [0.x.25]*
   减去另一个标量。   
* [2.x.27] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.26]*
   将标量乘以一个<tt>因子</tt>。   
* [2.x.28] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.27]*
   将标量除以<tt>因子</tt>。   
* [2.x.29] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.28]*
   带有反转项的张量。   
* [2.x.30] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.29]*
   将所有数值重置为零。    请注意，这与标准库容器的[2.x.31]clear()成员函数和deal.II内的其他几个类的语义部分不一致，它们不仅将存储元素的值重置为零，而且释放所有内存并将对象返回到处女状态。然而，由于本类型的对象的大小是由其模板参数决定的，所以调整大小是不可能的，事实上，所有元素的值都为零的状态就是这样一个对象构造后的状态。 
* [0.x.30]*
   返回张量的Frobenius-norm，即所有条目的绝对平方之和的平方根。对于目前秩-1张量的情况，这等于通常的<tt>l<sub>2</sub></tt>向量的规范。 
* [0.x.31]*
   返回张量的Frobenius-norm的平方，即所有条目的绝对平方之和。   
* [2.x.32]这个函数也可以在CUDA设备代码中使用。 
* [0.x.32]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据读入或写入一个流中，以便进行序列化。 
* [0.x.33]*
   内部类型声明，用于对Tensor<1,dim,Number>的operator[]()的返回类型进行专业化。 
* [0.x.34]*
   这个标量对象的值。 
* [0.x.35]*
   用于unroll的内部辅助函数。 
* [0.x.36]*
 一个具有任意等级的一般张量类，即具有任意数量的索引。张量类提供了一个索引操作符和一些基础结构，但大多数功能是递归到等级为1的张量中，或者放到外部模板函数中，例如<tt>contract</tt>族。
* 张量的等级规定了它可以代表哪些类型的物理量。 [2.x.33] [2.x.34] 一个等级为0的张量是一个标量，可以存储诸如温度或压力等量。这些标量在本文档中显示为简单的小写拉丁字母，例如： [2.x.35] 。   [2.x.36] [2.x.37] 等级1张量是一个有[2.x.38]分量的矢量，它可以表示矢量，如速度、位移、电场等。它们也可以描述一个标量场的梯度。    秩-1张量使用的符号是粗体小写拉丁字母，例如 [2.x.39] 。    一个秩-1张量的成分，如[2.x.40]，表示为[2.x.41]，其中[2.x.42]是0和<tt>dim-1</tt>之间的一个索引。   [2.x.43] [2.x.44] 等级2张量是一种线性算子，可以将一个向量转化为另一个向量。这些张量类似于具有[2.x.45]成分的矩阵。有一个相关的类SymmetricTensor<2,dim>，用于等级2的张量，其元素是对称的。等级2张量通常用粗体的大写拉丁字母表示，如[2.x.46]或粗体的希腊字母，如[2.x.47] 。    等级2张量的组成部分如[2.x.48]用两个指数[2.x.49]表示为[2.x.50] 。这些张量通常描述矢量场的梯度（变形梯度、速度梯度等）或标量场的Hessians。此外，机械应力张量是秩-2张量，将内部表面的单位法向量映射为局部牵引力（单位面积的力）向量。   [2.x.51] [2.x.52] 等级大于2的张量也是以一致的方式定义的。它们有[2.x.53]个分量，识别一个分量所需的指数数等于<tt>秩</tt>。对于等级为4的张量，存在一个称为SymmetricTensor<4,dim>的对称变体。   [2.x.54] [2.x.55]。
* 对秩为2的对象使用这个张量类，在许多情况下比矩阵更有优势，因为编译器知道维度以及数据的位置。因此有可能产生比具有与运行时间相关的维度的矩阵更有效的代码。这也使得代码更容易阅读，因为张量（一个与坐标系相关的对象，并且在坐标旋转和变换方面具有变换属性）和矩阵（我们认为它是与线性代数事物相关的任意向量空间上的运算符）之间存在语义上的差异。
* [2.x.56] rank_ 一个整数，表示这个张量的等级。对于秩0张量，该类存在一个特殊化。
* [2.x.57] dim 一个整数，表示该张量所处空间的维度。当然，这等于识别一个点和秩-1张量的坐标数。
* [2.x.58] Number 用来存储张量元素的数据类型。在几乎所有的情况下，这只是默认的[2.x.59]，但在有些情况下，人们可能希望以不同的（而且总是标量的）类型存储元素。它可以用来将张量建立在[2.x.60]或[2.x.61]数字或任何其他实现基本算术操作的数据类型上。另一个例子是允许自动微分的类型（例如，见[2.x.62]中使用的Sacado类型），从而可以生成一个以张量为参数的函数的分析（空间）导数。
* 

* 
* [2.x.63] 

 
* [0.x.37]*
   提供一种方法来获取一个对象的尺寸，而不需要明确知道它的数据类型。实现这种方式而不是提供一个函数<tt>dimension()</tt>，因为现在有可能在编译时获得尺寸，而不需要内联函数的扩展和预评估；因此编译器可能产生更有效的代码，你可以使用这个值来声明其他数据类型。 
* [0.x.38]*
   向外界公布这个张量的等级。 
* [0.x.39]*
   当前等级的张量的独立成分的数量。这是dim乘以每个子张量的独立分量的数量。 
* [0.x.40]*
   由这个容器封装的、由operator[]()返回的对象的类型。对于一般的张量来说，这是一个低等级的张量，对于Tensor<1,dim,Number>来说，这是一个标量数字类型。 
* [0.x.41]*
   声明一个数组类型，可以用来静态地初始化这个类型的对象。对于`dim == 0`，它的大小是1，否则，它是`dim`。 
* [0.x.42]*
   构造函数。将所有条目初始化为零。   
* [2.x.64]这个函数也可以在CUDA设备代码中使用。 
* [0.x.43]*
   一个构造函数，数据从一个C风格的数组中复制出来。   
* [2.x.65] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.44]*
   一个构造函数，数据从一个ArrayView对象中复制。  显然，ArrayView对象必须代表一个大小为`dim`<sup>`rank`</sup>的数据延伸。参数`initializer`的顺序排列的元素被解释为unrolled_to_component_index()所描述的那样。    这个构造函数显然要求[2.x.66]类型等于[2.x.67]或可转换为[2.x.68]数。   
* [2.x.69] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.45]*
   来自不同底层标量类型的张量的构造函数。这显然要求[2.x.70]类型可转换为[2.x.71]数字。   
* [2.x.72]这个函数也可以在CUDA设备代码中使用。 
* [0.x.46]*
   可以从 "张量的张量 "转换的构造函数。 
* [0.x.47]*
   到张量的张量的转换操作符。 
* [0.x.48]*
   复制构造函数  
* [0.x.49]*
   拷贝赋值运算符  
* [0.x.50]*
   移动构造函数  
* [0.x.51]*
   移动赋值运算符  
* [0.x.52]*
   读写访问操作符。   
* [2.x.73] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.53]*
   只读访问操作符。   
* [2.x.74] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.54]*
   使用TableIndices <tt>indices</tt>进行读取访问  
* [0.x.55]*
   使用TableIndices<tt>indices</tt>进行读写访问  
* [0.x.56]*
   返回一个指向底层存储的第一个元素的指针。 
* [0.x.57]*
   返回一个指向底层存储的第一个元素的常量指针。 
* [0.x.58]*
   返回一个指向底层存储结束后的元素的指针。 
* [0.x.59]*
   返回一个指向超过底层存储结束的元素的指针。 
* [0.x.60]*
   来自具有不同底层标量类型的张量的赋值运算符。  这显然要求[2.x.75]类型可以转换为[2.x.76]数。   
* [2.x.77]这个函数也可以在CUDA设备代码中使用。 
* [0.x.61]*
   这个操作符将一个标量分配给一个张量。为了避免混淆向张量分配标量值的确切含义，零是<tt>d</tt>唯一允许的值，允许用直观的符号<tt>t=0</tt>将张量的所有元素重置为零。 
* [0.x.62]*
   测试两个张量的相等。 
* [0.x.63]*
   测试两个张量的不平等。 
* [0.x.64]*
   添加另一个张量。   
* [2.x.78]这个函数也可以在CUDA设备代码中使用。 
* [0.x.65]*
   减去另一个张量。   
* [2.x.79] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.66]*
   用<tt>因子</tt>缩放张量，即用<tt>因子</tt>乘以所有组件。   
* [2.x.80]这个函数也可以在CUDA设备代码中使用。 
* [0.x.67]*
   用<tt>1/factor</tt>缩放向量。   
* [2.x.81] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.68]*
   单元减法运算符。负掉张量的所有条目。   
* [2.x.82] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.69]*
   将所有值重置为零。    请注意，这与标准库容器的[2.x.83]clear()成员函数以及deal.II中的其他几个类的语义部分不一致，它们不仅将存储元素的值重置为零，而且释放所有内存并将对象返回到处女状态。然而，由于本类型的对象的大小是由其模板参数决定的，所以调整大小是不可能的，事实上，所有元素的值都为零的状态就是这样一个对象构建后的状态。 
* [0.x.70]*
   返回张量的Frobenius-norm，即所有条目的绝对平方之和的平方根。对于目前秩-1张量的情况，这等于通常的<tt>l<sub>2</sub></tt>向量的规范。   
* [2.x.84] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.71]*
   返回张量的Frobenius-norm的平方，即所有条目的绝对平方之和。   
* [2.x.85] 这个函数也可以在CUDA设备代码中使用。 
* [0.x.72]*
   用所有张量元素填充一个向量。    这个函数将所有的张量条目展开为一个单一的、线性编号的向量。正如C++中的惯例，张量的最右边的索引行进得最快。 
* [0.x.73]*
   为函数的参数所索引的张量元素返回一个范围为[2.x.86]的未滚动索引。 
* [0.x.74]*
   与 component_to_unrolled_index 相反。对于[2.x.87]范围内的一个索引，返回它所对应的索引集。 
* [0.x.75]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.76]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据读入或写入一个流中，以便进行序列化。 
* [0.x.77]*
   内部类型声明，用于对Tensor<1,dim,Number>的operator[]()的返回类型进行专业化。 
* [0.x.78]*
   持有子元素的张量数组。 
* [0.x.79]*
   用于unroll的内部辅助函数。 
* [0.x.80]*
   这个构造函数是供内部使用的。它提供了一种方法来创建Tensor<rank, dim, Number>的constexpr构造函数。   
* [2.x.88]这个函数也可以在CUDA设备代码中使用。 
* [0.x.81]*
   下面的结构需要用来初始化嵌套的Tensor对象。  另外请看numbers.h中的另一个特殊化。 
* [0.x.82]*
  [2.x.89] Tensor对象的输出函数

* 
* [0.x.83]*
 张量的输出运算符。连续打印元素，中间有一个空格，等级1的子张量之间有两个空格，等级2之间有三个空格，以此类推。
* [2.x.90] 张量

* 
* [0.x.84]*
 秩为0的张量的输出算子。由于这种张量是标量，我们只需打印这一个值。
* [2.x.91] 张量

* 
* [0.x.85]*
  [2.x.92] 张量对象的矢量空间操作。

* 
* [0.x.86]*
 秩为0的张量与左边的对象进行标量乘法。
* 这个函数将存储在张量中的底层[2.x.93]解开，并与之相乘[2.x.94]。
* 

* 
* [2.x.95] 这个函数也可以在CUDA设备代码中使用。
* [2.x.96] 张量

* 
* [0.x.87]*
 秩为0的张量与来自右边的对象进行标量乘法。
* 这个函数将存储在张量中的底层[2.x.97]解开，并与之相乘[2.x.98]。
* 

* 
* [2.x.99] 这个函数也可以在CUDA设备代码中使用。
* [2.x.100] 张量

* 
* [0.x.88]*
 两个等级为0的张量的标量乘法。
* 这个函数将存储在张量中的[2.x.101]和[2.x.102]OtherNumber类型的底层对象解包，并将它们相乘。它返回一个解包的乘积类型的数字。
* 

* 
* [2.x.103] 这个函数也可以在CUDA设备代码中使用。
* [2.x.104] Tensor

* 
* [0.x.89]*
 等级为0的张量除以一个标量数字。
* 

* 
* [2.x.105] 这个函数也可以在CUDA设备代码中使用。
* [2.x.106] 张量

* 
* [0.x.90]*
 添加两个等级为0的张量。
* 

* 
* [2.x.107] 这个函数也可以在CUDA设备代码中使用。
* [2.x.108] 张量

* 
* [0.x.91]*
 减去两个等级为0的张量。
* 

* 
* [2.x.109] 这个函数也可以在CUDA设备代码中使用。
* [2.x.110] 张量

* 
* [0.x.92]*
 一般等级的张量与来自右边的标量的乘法。
* 只允许与标量数类型（即浮点数、复数浮点数等）的乘法，详情请参见EnableIfScalar的文档。
* 

* 
* [2.x.111] 这个函数也可以在CUDA设备代码中使用。
* [2.x.112] 张量

* 
* [0.x.93]*
 一般等级的张量与左边的标量数字的乘法。
* 只允许与标量数类型（即浮点数、复数浮点数等）的乘法，详情请参见EnableIfScalar的文档。
* 

* 
* [2.x.113] 这个函数也可以在CUDA设备代码中使用。
* [2.x.114] 张量

* 
* [0.x.94]*
 一般等级的张量与标量数字的除法。关于模板参数和返回类型的更多信息，请参见上面关于operator*()的讨论。
* 

* 
* [2.x.115] 这个函数也可以在CUDA设备代码中使用。
* [2.x.116] 张量

* 
* [0.x.95]*
 两个一般等级的张量的相加。
* [2.x.117] rank 两个张量的等级。
* 

* 
* [2.x.118] 这个函数也可以在CUDA设备代码中使用。
* [2.x.119] 张量

* 
* [0.x.96]*
 两个一般等级的张量的减法。
* [2.x.120] rank 两个张量的等级。
* 

* 
* [2.x.121] 这个函数也可以在CUDA设备代码中使用。
* [2.x.122] 张量

* 
* [0.x.97]*
 两个等级为0的张量对象的进位乘法（即两个标量值的乘法）。
* [2.x.123]张量

* 
* [0.x.98]*
 两个一般等级的张量对象的入境乘法。
* 这种乘法也被称为 "Hadamard-product"（参看https://en.wikipedia.org/wiki/Hadamard_product_(matrices)），并产生一个大小为<rank, dim>的新张量。[1.x.0]
* [2.x.124] rank 两个张量的等级。
* [2.x.125] 张量

* 
* [0.x.99]*
  [2.x.126] 张量对象的收缩操作和外积

 
* [0.x.100]*
 张量的点积（单一收缩）。返回一个等级为[2.x.127]的张量，它是等级为[2.x.129]的张量[2.x.128]的最后一个索引与等级为[2.x.131]的张量[1.x.1]的第一个索引的收缩。
* 

* 
* [2.x.132] 对于张量类，乘法运算符只对一对指数进行收缩。这与SymmetricTensor的乘法运算符相反，后者做的是双重收缩。
* 

* 
* [2.x.133] 如果收缩产生一个等级为0的张量，那么标量数将作为一个未包装的数字类型返回。
* [2.x.134] 张量

* 
* [0.x.101]*
 对任意等级的两个张量的一对索引进行通用收缩。返回一个等级为[2.x.135]的张量，它是等级为[2.x.138]的张量[2.x.137]的索引[2.x.139]与等级为[2.x.141]的张量[1.x.2]之间的收缩。
* 例如，如果张量[2.x.142]的第一个索引（[2.x.142]）应与第三个索引（[2.x.144]）收缩，该函数应被调用为

* 
* [1.x.3]
* 
* 

* 
* [2.x.145] 索引的位置是从0开始计算的，即[2.x.146] 。
* 

* 
* [2.x.147] 如果收缩产生一个等级为0的张量，那么标量数将作为一个未包装的数字类型返回。
* [2.x.148] 张量

* 
* [0.x.102]*
 对任意等级的两个张量的两对索引进行通用收缩。返回一个等级为[2.x.149]的张量，它是索引[2.x.150]与索引[2.x.151]和索引[2.x.152]index_3与索引[2.x.153]的等级为[2.x.155]的张量[2.x.156]的收缩[1.x.4]
* 例如，如果第一个索引（[2.x.158]）应与第三个索引（[2.x.159]）收缩，第二个索引（[2.x.160]）与第一个索引（[2.x.161]）收缩，这个函数应被调用为

* 
* [1.x.5]
* 
* 

 
* [2.x.162] 索引的位置是从0开始计算的，即[2.x.163] 。
* 

* 
* [2.x.164] 如果收缩产生一个等级为0的张量，那么标量数将作为一个未包装的数字类型返回。
* [2.x.165] 张量

* 
* [0.x.103]*
 标量积，或者两个等阶的张量的（广义）Frobenius内积。返回一个标量，它是张量[2.x.166]和[2.x.167] [1.x.6]完全收缩的结果。
* [2.x.168] 张量

* 
* [0.x.104]*
 对三个张量进行完全收缩。返回一个标量，它是等级为[2.x.170]的张量[2.x.169]、等级为[2.x.172]的张量[2.x.171]和等级为[2.x.174]的张量[2.x.173]完全缩减的结果 [1.x.7]
 

* 
* [2.x.175] 三个输入张量中的每一个都可以是Tensor或SymmetricTensor。
* [2.x.176] 张量

* 
* [0.x.105]*
 [2.x.177]和[2.x.178]两个张量的外积 返回一个等级为[2.x.179]的张量：[1.x.8]
* [2.x.180] 张量

 
* [0.x.106]*
  [2.x.181] 对等级为1的张量的特殊操作

 
* [0.x.107]*
 返回2d中的交叉积。这只是顺时针旋转90度来计算切向矢量的外法线。这个函数是为所有空间维度定义的，以允许独立于维度的编程（例如在空间维度的开关内），但只有当参数的实际维度为2时才可以调用（例如来自开关中的<tt>dim==2</tt>情况）。
* [2.x.182] 张量

* 
* [0.x.108]*
 返回2个向量在3D中的交叉积。这个函数是为所有空间维度定义的，以允许独立于维度的编程（例如在空间维度的开关内），但只有当参数的实际维度是3时才可以调用（例如来自开关中的<tt>dim==3</tt>情况）。
* [2.x.183] 张量

* 
* [0.x.109]*
  [2.x.184] 对等级2的张量的特殊操作

* 
* [0.x.110]*
 计算一个张量或等级2的行列式。
* [2.x.185] 张量

* 
* [0.x.111]*
 dim==1的特殊化。
* [2.x.186] 张量

 
* [0.x.112]*
 对dim==2的特化。
* [2.x.187] 张量

 
* [0.x.113]*
 对dim的特殊化==3。
* [2.x.188] 张量

 
* [0.x.114]*
 计算并返回等级为2的张量的轨迹，即其对角线项的总和。
* [2.x.189] 张量

* 
* [0.x.115]*
 计算并返回给定张量的逆值。由于编译器可以进行返回值的优化，并且由于返回对象的大小是已知的，所以可以接受通过值来返回结果，而不是通过引用作为一个参数。
* [2.x.190] 张量

* 
* [0.x.116]*
 返回给定张量的转置。
* [2.x.191] 张量

* 
* [0.x.117]*
 返回等级为2的给定张量的邻接值。张量的邻接[2.x.192]被定义为[1.x.9]。
 

* 
* [2.x.193] 这要求张量是可逆的。
* [2.x.194] 张量

* 
* [0.x.118]*
 返回给定等级为2的张量的协因子。张量的协因子[2.x.195]定义为[1.x.10] 。
 

* 
* [2.x.196] 这要求该张量是可逆的。
* [2.x.197] 张量

* 
* [0.x.119]*
 通过结合给定输入[2.x.200]的奇异值分解（SVD）[2.x.199]的产物，返回最近的正交矩阵[2.x.198]，有效地用身份矩阵代替[2.x.201]。
* 这是一个（非线性）[投影操作](https://en.wikipedia.org/wiki/Projection_(mathematics))，因为当应用两次时，我们有[2.x.202]，这很容易看到。(这是因为[2.x.203]的SVD仅仅是[2.x.204]。) 此外，[2.x.205]实际上是一个正交矩阵，因为正交矩阵必须满足[2.x.206]，这里意味着

* 
* [1.x.11]
* 由于从SVD出来的[2.x.207]和[2.x.208]因子本身就是正交矩阵。
* [2.x.209] A 要为其寻找最接近的正交张量。 [2.x.210] Number 用来存储张量的条目的类型。  必须是`float`或`double`。 [2.x.211] 为了使用这个函数，这个程序必须与LAPACK库相连。 [2.x.212] [2.x.213] 不得为单数。这是因为，从概念上讲，这里要解决的问题是试图找到一个矩阵[2.x.214]，使其与[2.x.215]的某种距离最小，同时满足二次约束[2.x.216] 。这与想要找到一个矢量[2.x.217]的问题没有什么不同，该矢量对于给定的[2.x.219]来说，在约束条件[2.x.220]下最小化二次目标函数[2.x.218] 。
* 
*--换句话说，我们正在寻找单位球面上最接近[2.x.222]的点[2.x.221]。这个问题对所有的[2.x.223]都有解，除了[2.x.224] 。我们在这里考虑的问题的相应条件是，[2.x.225]不能有零特征值。
* [2.x.226] 张量

* 
* [0.x.120]*
 返回给定等级2张量的[2.x.227]规范，其中[2.x.228]（列上之和的最大值）。
* [2.x.229]张量

* 
* [0.x.121]*
 返回给定的2级张量的[2.x.230]规范，其中[2.x.231]（行上和的最大值）。
* [2.x.232] 张量

* 
* [0.x.122]

