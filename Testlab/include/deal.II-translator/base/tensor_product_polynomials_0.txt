include/deal.II-translator/base/tensor_product_polynomials_0.txt
[0.x.0]*
  [2.x.0] 多项式 [2.x.1]. 

 
* [0.x.1]*
 给定多项式的张量乘积。
* 给定一个[1.x.0]一维多项式[1.x.1]到[1.x.2]的向量，这个类产生[1.x.3]形式的多项式[1.x.4]。如果基数多项式在区间[-1,1]或[0,1]上是相互正交的，那么张量积多项式在[-1,1]<sup>dim</sup>或[0,1]<sup>dim</sup>上分别是正交的。
* 索引如下：dim-dimensional多项式的顺序是x-坐标跑得最快，然后是y-坐标，等等。因此，前几个多项式是[1.x.5]，同样，在三维中也是如此。
* output_indices()函数打印出dim-dimensional多项式的排序，即对于多项式空间中的每个多项式，它给出了x、y和z方向的一维多项式的指数i,j,k。通过使用set_numbering()函数，可以改变二维多项式的排序。
* [2.x.2] PolynomialType 一个满足计算张量积所需接口的类。这个模板参数的典型选择是 [2.x.3] 和 [2.x.4] 。

 
* [0.x.2]*
   访问此对象的维度，用于检查和自动设置其他类中的维度。 
* [0.x.3]*
   构造函数。<tt>pols</tt>是一个对象的向量，应该是派生或以其他方式转换为`PolynomialType`类型（类的模板参数）的一维多项式对象。它将被逐个元素复制到一个受保护的成员变量中。 
* [0.x.4]*
   打印索引的列表到<tt>out</tt>。 
* [0.x.5]*
   设置多项式的排序。要求<tt>renumber.size()==n()</tt>。 存储一个<tt>renumber</tt>的副本。 
* [0.x.6]*
   给予对renumber向量的读取权限。 
* [0.x.7]*
   给予对逆向renumber向量的读取权限。 
* [0.x.8]*
   计算每个张量积多项式在<tt>unit_point</tt>的值和一、二导数。    向量的大小必须等于0或等于n()。在第一种情况下，该函数将不计算这些值。    如果你需要所有张量积多项式的值或导数，那么使用这个函数，而不是使用任何一个compute_value(), compute_grad() 或 compute_grad_grad() 函数，见下文，在所有张量积多项式上循环。 
* [0.x.9]*
   计算<tt>i</tt>第张量积多项式在<tt>unit_point</tt>的值。这里<tt>i</tt>是用张量积的编号给出的。    注意，在所有张量积多项式的循环中使用这个函数并不高效，因为这样底层（一维）多项式的每个点值都要（不必要地）计算多次。 相反，使用evaluate()函数和<tt>values.size()==</tt>n()来一次性获得所有张量多项式的点值，而且效率更高。 
* [0.x.10]*
   计算<tt>i</tt>第张量积多项式在<tt>unit_point</tt>的<tt>阶</tt>次导数。这里<tt>i</tt>是用张量积的编号给出的。    注意，在所有张量积多项式的循环中使用这个函数并不高效，因为这样一来，底层（一维）多项式的每个导数值都要（不必要地）计算多次。 相反，使用evaluate()函数，见上文，将适当的参数大小设置为n()，可以一次性得到所有张量多项式的点值，而且效率更高。     [2.x.5]顺序 导数的顺序。 
* [0.x.11]*
    [2.x.6] [2.x.7] 阶数   
* [0.x.12]*
    [2.x.8] [2.x.9]。  
* [0.x.13]*
    [2.x.10] [2.x.11]   
* [0.x.14]*
    [2.x.12] [2.x.13]   
* [0.x.15]*
   计算<tt>i</tt>第张量积多项式在<tt>unit_point</tt>的梯度。这里<tt>i</tt>是用张量积的编号给出的。    注意，在所有张量积多项式的循环中使用这个函数并不高效，因为这样一来，底层（一维）多项式的每个导数值都要（不必要地）计算多次。 相反，使用evaluate()函数，见上文，用<tt>grads.size()==</tt>n()来一次性获得所有张量多项式的点值，而且效率更高。 
* [0.x.16]*
   计算<tt>i</tt>第1个张量积多项式在<tt>unit_point</tt>的二阶导数（grad_grad）。这里<tt>i</tt>是用张量积的编号给出的。    注意，在所有张量积多项式的循环中使用这个函数并不高效，因为这样一来，底层（一维）多项式的每个导数值都要（不必要地）计算多次。 相反，使用evaluate()函数，见上文，用<tt>grad_grads.size()==</tt>n()来一次性获得所有张量多项式的点值，而且效率更高。 
* [0.x.17]*
   返回空间的名称，即<tt>TensorProductPolynomials</tt>。 
* [0.x.18]*
    [2.x.14] [2.x.15].   
* [0.x.19]*
   返回这个对象的内存消耗估计值（以字节为单位）。 
* [0.x.20]*
   返回给这个类的构造函数的底层一维多项式的副本。 
* [0.x.21]*
   给予构造函数的多义词向量<tt>pols</tt>的拷贝。 
* [0.x.22]*
   用于重新排序多项式的索引图。 
* [0.x.23]*
   用于重新排序多项式的索引图。 
* [0.x.24]*
   每个张量积多项式[1.x.6]是每个空间方向上的一维多项式的乘积。给出指数[1.x.7]，计算每个空间方向的这些一维多项式的指数。 
* [0.x.25]*
   TensorProductPolynomialsBubbles有一个TensorProductPolynomials类，所以我们声明它是一个朋友类。 
* [0.x.26]*
   TensorProductPolynomialsConst有一个TensorProductPolynomials类，所以我们声明它是一个朋友类。 
* [0.x.27]*
 给定多项式的各向异性张量乘积。
* 给定一维多项式 [2.x.16] 在 [2.x.17] -方向， [2.x.18] 在 [2.x.19] -方向，以此类推，该类生成形式为 [2.x.20] 的多项式。（如果 [2.x.21] 实际上只有2，则有明显的概括性。如果 [2.x.22] 实际上只有1，则结果只是传递给构造函数的同一组一维多项式）。
* 如果每组基数多项式的元素在区间[2.x.23]或[2.x.24]上相互正交，那么张量积多项式分别在[2.x.25]或[2.x.26]上正交。
* 得到的[2.x.27]张量乘积多项式的排序如下。我们在[2.x.28]坐标上迭代运行最快，然后是[2.x.29]坐标，等等。例如，对于[2.x.30]，前几个多项式是这样的 [2.x.31] , [2.x.32] , [2.x.33] , ..., [2.x.34] , [2.x.35] , [2.x.36] , 等等。

 
* [0.x.28]*
   构建器。 [2.x.37]是一个一维多项式的表格。该表的行数（索引到[2.x.38]时的第一个索引需要等于空间维度，每一行的元素（即第二个索引）给出应在这个特定坐标方向使用的多项式。    由于我们要建立[1.x.8]多项式，作为参数传入的[2.x.39]项的多项式集合当然可能不同，而且数量也可能不同。    张量积多项式的数量是<tt>Nx*Ny*Nz</tt>，如果空间维数小于3，则去掉条款。 
* [0.x.29]*
   计算每个张量积多项式在<tt>unit_point</tt>的值和一、二次导数。    向量的大小必须等于<tt>0</tt>或者等于<tt>this->n()</tt>。 在第一种情况下，该函数将不计算这些值。    如果你需要所有张量积多项式的值或导数，那么使用这个函数，而不是使用任何<tt>compute_value</tt>, <tt>compute_grad</tt>或<tt>compute_grad_grad</tt>函数，见下文，在所有张量积多项式上循环。 
* [0.x.30]*
   计算<tt>i</tt>第1个张量积多项式在<tt>unit_point</tt>的值。这里<tt>i</tt>是用张量积的编号给出的。    注意，在所有张量积多项式的循环中使用这个函数并不高效，因为这样一来，底层（一维）多项式的每个点值都要（不必要地）计算多次。 相反，使用<tt>compute</tt>函数，见上文，用<tt>values.size()==this->n()</tt>来一次性获得所有张量多项式的点值，而且效率更高。 
* [0.x.31]*
   计算<tt>i</tt>第张量积多项式在<tt>unit_point</tt>的<tt>阶</tt>次导数。这里<tt>i</tt>是用张量积的编号给出的。    注意，在所有张量积多项式的循环中使用这个函数并不高效，因为这样一来，底层（一维）多项式的每个导数值都要（不必要地）计算多次。 相反，使用evaluate()函数，见上文，将适当的参数大小设置为n()，可以一次性得到所有张量多项式的点值，而且效率更高。     [2.x.40]顺序 导数的顺序。 
* [0.x.32]*
    [2.x.41] [2.x.42] 阶数   
* [0.x.33]*
    [2.x.43] [2.x.44]。  
* [0.x.34]*
    [2.x.45] [2.x.46]   
* [0.x.35]*
    [2.x.47] [2.x.48]   
* [0.x.36]*
   计算<tt>i</tt>第张量积多项式在<tt>unit_point</tt>的梯度。这里<tt>i</tt>是用张量积的编号给出的。    注意，在所有张量积多项式的循环中使用这个函数并不高效，因为这样一来，底层（一维）多项式的每个导数值都要（不必要地）计算多次。 相反，使用<tt>compute</tt>函数，见上文，用<tt>grads.size()==this->n()</tt>来一次性获得所有张量多项式的点值，而且效率更高。 
* [0.x.37]*
   计算<tt>i</tt>第1个张量积多项式在<tt>unit_point</tt>的二阶导数（grad_grad）。这里<tt>i</tt>是用张量积的编号给出的。    注意，在所有张量积多项式的循环中使用这个函数并不高效，因为这样一来，底层（一维）多项式的每个导数值都要（不必要地）计算多次。 相反，使用<tt>compute</tt>函数，见上文，用<tt>grad_grads.size()==this->n()</tt>来一次性获得所有张量多项式的点值，而且效率更高。 
* [0.x.38]*
   返回空间的名称，即<tt>AnisotropicPolynomials</tt>。 
* [0.x.39]*
    [2.x.49] [2.x.50].   
* [0.x.40]*
   给予构造函数的多义词向量<tt>pols</tt>的副本。 
* [0.x.41]*
   每个张量积多项式[2.x.51]是每个空间方向上的一维多项式的乘积。在给定指数<tt>i</tt>的情况下，计算每个空间方向的这些一维多项式的指数。 
* [0.x.42]*
   给出构造函数的输入，计算<tt>n_pols</tt>。 
* [0.x.43]

