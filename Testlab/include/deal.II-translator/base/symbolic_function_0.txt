include/deal.II-translator/base/symbolic_function_0.txt
[0.x.0]*
   一个函数类，利用符号微分来计算梯度、拉普拉斯、Hessians和时间导数。    这个类可用于使用[2.x.0]命名空间提供的方法来定义函数。特别是，可以定义一个符号化的评价点（函数的参数），以及一个符号化的表达式。    符号梯度和符号Hessians在构造时计算，当用户使用update_user_substitution_map()方法要求在符号函数中进行替换时，也会计算。    每当一个评估方法被调用时，就会尝试进行替换，用评估点替换坐标符号参数，用get_time()方法返回的当前时间替换符号时间。用户必须确保在求值时，参数替换提供了一个完全求值的表达式（即除了数值之外，函数表达式中不包含其他符号），否则将抛出一个异常。额外的符号可以通过存储在用户提供的替换图中进行部分评估或替换，该替换图可以通过调用update_user_substitution_map（）或set_additional_function_arguments（）方法进行更新。    这个类的最简单的使用情况在下面的例子中给出。 
* [1.x.0]
* 在这个例子中，一个有两个组件的Function是用一个字符串定义的，这个字符串包含了用分号分隔的表达式。    一个更复杂的例子，明确地使用了[2.x.1]对象，由以下例子给出  
* [1.x.1]
* 部分替换是可能的（也就是说，你可以使用额外的符号来定义函数）。然而，一旦你评估该函数，你必须确保所有无关的符号（即那些没有提到空间[2.x.2]或[2.x.3]变量的符号）已经被数值，或空间或时间参数的表达式所替代，方法是调用update_user_substitution_map()或set_additional_function_arguments()方法。    如果你的函数需要评估额外的参数，你可以通过调用set_additional_function_arguments()方法指定它们。    如果你用相同的参数调用update_user_substitution_map()和set_additional_function_arguments()，对函数评估的影响将是相同的，然而，内部行为和函数导数将不同。update_user_substitution_map()方法执行一次替换（第一次需要替换），然后在内部存储一个结果表达式的副本，以及它的导数（如果需要）。然后在随后的所有评估中使用这些内容。调用set_additional_function_arguments()将在评估时间内，在*所有导数被计算之后，对传递的替换图进行实时评估。   
* [2.x.4] 这个类和FunctionParser类的区别在于，这个类允许计算一阶和二阶导数（以符号的方式），而FunctionParser类只计算一阶导数，使用有限差分。对于复杂的表达式，这个类可能比FunctionParser类要慢。   
* [2.x.5]   
* [0.x.1]*
     构造函数。        产生的Function对象将有与符号表达式向量[2.x.6]中的条目一样多的组件。向量[2.x.7]应包含一个涉及坐标符号参数[2.x.8]和可能的符号时间参数[2.x.9]的符号表达式的列表，可以用其他符号定义它，只要可选参数[2.x.10 ] 替换除 [2.x.11] 和 [2.x.12] 以外的所有符号，这在以下情况下很有用：例如，你想用你想用符号命名的材料参数来表达公式，而不是在定义公式时通过它们的数值，或者你想用极坐标而不是笛卡尔坐标来表达你的公式，并且你希望符号引擎能为你计算导数。    你以后可以通过调用update_user_substitution_map()来更新[2.x.13]中包含的符号图。         [2.x.14] 函数 类型为[2.x.15]的符号表达式的向量，代表此Function的组成部分。         [2.x.16] coordinate_symbols 代表坐标的符号张量，作为[2.x.17]矢量中包含的符号表达式的输入参数。默认的[2.x.18]是一个[2.x.19]，包含符号 "x "代表`dim`等于1，"x"、"y "代表`dim`等于2，而 "x"、"y"、"z "代表`dim`等于3。         [2.x.20] time_symbol 一个代表时间的符号变量。它默认为一个名为 "t "的符号变量。         [2.x.21] user_substitution_map 任何可能包含在符号函数中的其他符号都需要在这个映射中指定。该地图可以是空的，函数仍然可以包含未评估的符号，只要你调用update_user_substitution_map()，并在任何评估发生之前提供除[2.x.22]和[2.x.23]外的所有符号的替换。   
* [0.x.2]*
     构造函数，接收一个描述函数表达式的单一字符串，作为一个分号分隔的表达式列表。        符号表达式可以使用默认的参数和默认的符号时间变量，再加上你可能需要的任何额外的符号，只要你在尝试评估函数或其导数之前，通过调用update_user_substitution_map()更新替换所有符号的用户替换图，并且使用set_additional_function_arguments()方法提供你函数的所有额外函数参数。   
* [0.x.3]*
     存储并应用替换映射[2.x.24]到这个Function对象的每个符号组件。        注意，这个方法将触发对每个分量的梯度、Hessians和Laplacians的重新计算。   
* [0.x.4]*
     设置额外的[2.x.25]，在下一个评估步骤中被替换。        注意，[2.x.26]是在*评估[2.x.27]和计算完所有导数之后被替换的。如果你传递的额外参数仍然依赖于坐标或时间符号，那么导数的评估将导致部分导数评估。        这种方法提供了一种方法来评估依赖于更多参数而不仅仅是坐标和时间的函数。如果你想对复杂的符号表达式计算总导数，你应该调用update_user_substitution_map()代替。   
* [0.x.5]*
     返回一个坐标符号的张量，可以用来定义这个符号函数对象的表达式。        默认参数是一个[2.x.28]，包含符号 "x "代表`dim`等于1，"x"，"y "代表`dim`等于2，"x"，"y"，"z "代表`dim`等于3。   
* [0.x.6]*
     获取符号函数中用于坐标的实际参数。这个对象不包括任何用户定义的参数。   
* [0.x.7]*
     获取该符号函数中实际使用的符号时间。   
* [0.x.8]*
     获取该符号化函数中实际使用的符号化表达式。   
* [0.x.9]*
     获取当前存储的[2.x.29]。    
* [0.x.10]*
     返回一个SymbolicFunction对象，表示这个函数的时间导数。空间参数、符号时间和当前存储的用户替换图被转发给新函数。   
* [0.x.11]*
     打印存储的参数和函数表达式，因为它将在调用方法value()时被评估。   
* [0.x.12]*
     返回一个替换图，用[2.x.30]的值替换参数，用this->get_time()的值替换符号时间，用[2.x.31]给出的替换图替换任何其他参数。    
* [0.x.13]*
     重新计算函数的符号值，应用用户的置换图。这可能是一个昂贵的计算，只有在必要时才会调用。   
* [0.x.14]*
     重新计算函数的符号梯度，应用用户置换图。这可能是一个昂贵的计算，只有在必要时才会调用。   
* [0.x.15]*
     重新计算函数的符号Hessian和符号Lapalacian。这可能是一个昂贵的计算，只有在必要时才会调用。   
* [0.x.16]*
     这个符号函数的组件，在发生任何子结构之前。这是不可改变的，并且在构造时生成。        在任何评估发生之前，[2.x.32]被应用于这个对象，其结果被存储在内部变量函数中。        在评估过程中，[2.x.33]、[2.x.34]和任何剩余的符号被替换为输入评估点、当前时间和[2.x.35]的内容。    
* [0.x.17]*
     存储用于表达式置换的用户置换图。这可以通过调用update_user_substitution_map()来更新。请注意，该函数仍然可以有未解决的符号，只要通过调用set_additional_function_arguments()来解决这些符号。   
* [0.x.18]*
     存储一个用于额外参数替换的用户替换图。这将通过调用set_additional_function_arguments()来更新。   
* [0.x.19]*
     这个符号函数的实际成分。这是从应用[2.x.37]后的[2.x.36]中得到的。    
* [0.x.20]*
     这个符号函数的每个分量的梯度。这是通过计算对象[2.x.38]的符号梯度得到的，即应用[2.x.39]到[2.x.40]之后的梯度。    
* [0.x.21]*
     这个符号函数的每个分量的Hessians。这是通过计算对象[2.x.41]的符号Hessian得到的，也就是说，在应用[2.x.42]到[2.x.43]之后     
* [0.x.22]*
     这个符号函数的每个分量的拉普拉斯系数。这是通过计算对象[2.x.44]的符号拉普拉斯，即应用[2.x.45]到[2.x.46]之后得到的。    
* [0.x.23]*
     函数的坐标符号参数。   
* [0.x.24]*
     该函数的符号时间参数。   
* [0.x.25]*
   允许使用位数左移运算符输出。 
* [0.x.26]

