include/deal.II-translator/base/thread_local_storage_0.txt
[0.x.0] 解决方法。当涉及到STL容器和包含不可复制的对象T时，标准不幸地在[2.x.0]的类型特征中存在一个不幸的设计 "缺陷"。通过解压一些常用的容器来解决这个问题。   
* [0.x.1]*
  
* [2.x.1]，访问该对象。    这个类提供的方式是，每个访问它的线程都有自己的T类型对象的副本。从本质上讲，在多线程程序中，访问这个对象永远不会导致竞赛条件，因为除了当前的线程，没有其他线程可以访问它。    [1.x.0] 这个类的对象可以是默认构建的，也可以通过提供一个 "典范"，即一个T类型的对象，这样，每次我们需要在一个还没有这样一个对象的线程上创建一个T，它就会从典范中复制出来。    在销毁这个类的对象时，所有对应于访问过这个对象的线程的T对象都会被销毁。请注意，这可能是在线程终止的时间之前。    [1.x.1] 这个对象所存储的T对象可以使用get()函数来访问。当从不同的线程访问时，它提供了一个对唯一对象的引用。T类型的对象是懒惰地创建的，也就是说，只有当线程实际调用get()时才会创建它们。 
* [0.x.2]*
     默认构造函数。使用默认构造函数初始化每个线程局部对象。   
* [0.x.3]*
     复制构造函数。   
* [0.x.4]*
     移动构造函数。构造函数从参数中移动所有的内部数据结构。   
* [0.x.5]*
     一种复制构造函数。通过给定的对象初始化一个内部典范。该范例反过来被用来初始化每个线程的本地对象，而不是调用默认的构造函数。   
* [0.x.6]*
     一种移动构造函数。将给定的对象移动到一个内部样板中。该范例反过来被用来初始化每个线程的本地对象，而不是调用默认的构造函数。   
* [0.x.7]*
     复制赋值运算符。   
* [0.x.8]*
     移动赋值运算符。   
* [0.x.9]*
     返回这个对象在当前线程中存储的数据的引用，这个函数被调用。        请注意，没有一个成员函数get()是常数，并且像人们期望的那样返回一个常数引用。原因是，如果在一个还没有创建线程本地对象的线程上调用这样一个成员函数，那么就必须先创建这样一个对象，这当然是一个非常量操作。如果你需要从一个常量成员函数中调用一个类的成员变量的get()函数，那么你需要声明成员变量[2.x.2]以允许这种访问。   
* [0.x.10]*
     与上述相同，除了[2.x.3]在当前线程已经存在一个元素的情况下被设置为真，否则为假。   
* [0.x.11]*
     转换操作符，简单地将线程-本地对象转换为它所存储的数据类型。这个函数等同于调用get()成员函数；它的目的是使TLS对象看起来更像它所存储的对象。   
* [0.x.12]*
     将给定的参数复制到用于表示当前线程的存储空间中。以[2.x.4]的形式调用这个函数，相当于调用[2.x.5] 。这个操作符的意图是使ThreadLocalStorage对象看起来更像它在当前线程上代表的对象。         [2.x.6] t 要复制到当前线程使用的存储空间的对象。         [2.x.7] 当前的对象，在做出改变之后    
* [0.x.13]*
     将给定的参数移入用于表示当前线程的存储空间。以<code>tls_data = object</code>的方式调用此函数，相当于调用<code>tls_data.get() = object</code>。这个操作符的意图是使ThreadLocalStorage对象看起来更像它在当前线程中代表的对象。移动赋值运算符。         [2.x.8] t 要复制到当前线程所用存储空间的对象。         [2.x.9] 当前的对象，在做出改变之后    
* [0.x.14]*
     移除为所有用此对象创建过的线程所存储的线程本地对象（即，在此线程上至少调用过一次get()。这包括当前的线程。如果你随后在这个线程或任何其他线程上调用get()，新的对象将再次被创建。        如果deal.II被配置为不使用多线程，那么这个函数根本就不做任何事情。请注意，这当然有不同的语义，因为在多线程背景下，对象被删除并再次创建（如果调用了该类的适当构造函数，可以通过从样本对象中复制），而在多线程背景下，对象根本就没有被触及。同时，这个函数的目的是释放其他线程可能已经为他们自己的线程局部对象分配的内存，在这之后，每次使用这个对象都需要某种初始化。在多线程和非多线程的情况下，这都是必要的。   
* [0.x.15]*
     我们存储的数据元素。   
* [0.x.16]*
     一个突变器，用于保护插入数据对象。        我们在这里使用一个[2.x.10]（或[2.x.11]，如果有的话），以便能够使用[2.x.12]和[2.x.13]来实现读者-作者锁（https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock）。   
* [0.x.17]*
     创建一个新的（针对线程的）副本的范例。   
* [0.x.18]*
  [2.x.14] 

 
* [0.x.19] 我们必须确保，如果相应的元素不能被复制构建，就不要调用 "data.emplace(id,exemplar)"。我们使用一些SFINAE魔法来解决C++14没有 "if constexpr "的问题。   
* [0.x.20]

