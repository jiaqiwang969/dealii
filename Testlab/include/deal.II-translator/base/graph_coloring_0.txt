include/deal.II-translator/base/graph_coloring_0.txt
[0.x.0]*
 一个包含可以给图形着色的函数的命名空间。

* 
* [0.x.1]*
     给定两组假设为排序的索引，确定它们是否会有一个非空的交集。实际的交集是不计算的。     [2.x.0] indices1 一组指数，假定已排序。     [2.x.1] indices2 一组指数，假定已排序。     [2.x.2] 两组指数是否有一个非空的交集。   
* [0.x.2]*
     使用Cuthill-McKee算法（广度优先搜索算法）的简化版本创建给定范围的迭代器分区。该函数创建的分区包含迭代器的 "区域"，其中第一个分区包含第一个迭代器，第二个区域包含所有与第一个区域的单一元素有冲突的迭代器，第三个区域包含那些与第二个区域的迭代器有冲突并且之前没有被分配到一个区域的迭代器，等等。如果迭代器代表单元，那么这就会产生像洋葱壳一样的分区，围绕着最开始的单元。请注意，每个区的元素可能与同一区的其他元素冲突。        两个迭代器是否冲突的问题由一个用户提供的函数决定。这个函数的含义在[2.x.3]函数的文档中讨论。         [2.x.4] begin 寻求分区的迭代器范围的第一个元素。     [2.x.5] end 迭代器范围结束后的元素。     [2.x.6] get_conflict_indices 一个用户定义的函数对象，返回一组描述代表冲突的指标。更深入的讨论见上文。     [2.x.7] 一组迭代器的集合（为了提高效率，集合由[2.x.8]表示）。最外层集合的每个元素都对应于指向处于同一分区（即同一区域）的对象的迭代器。   
* [0.x.3]*
     这个函数使用DSATUR（Degree SATURation）来给一个集合的元素着色。DSATUR的工作原理如下。
* 

* 
* 

* 
* 

 
 

 
 

 
 
* - 按度数递减的顺序排列顶点。
* 

* 
 

 
 

 
 

 
 

 
 
* - 用颜色1给最大程度的顶点上色。
 

* 
* 

 
 

 
 

 
 

 
* 
* - 选择一个具有最大饱和度的顶点。如果存在平等，则选择无色子图中的任何最大程度的顶点。
* 

* 
* 

 
* 

 
 

 
 

 
* 
* - 用最少的可能（最低编号）的颜色给所选的顶点上色。
* 

* 
* 

* 
* 

 
 

 
 

 
 
* - 如果所有的顶点都被着色，则停止。否则，返回到3。 [2.x.9] partition 应该被着色的迭代器的集合。     [2.x.10] get_conflict_indices 一个用户定义的函数对象，返回一组描述代表冲突的指标。更深入的讨论见上文。     [2.x.11] partition_coloring 一组迭代器的集合（其中集合由[2.x.12]表示，以提高效率）。最外层集合的每个元素都对应于指向处于同一分区（具有相同颜色）的对象的迭代器，因此不会冲突。不同集合中的元素可能会发生冲突。   
* [0.x.4]*
     给定一个分区着色图，即一组分区（partition），每个分区都有颜色，为整个迭代器集产生一个组合着色。这是可能的，因为一个偶数（或奇数）区的任何颜色都不会与任何其他偶数（或奇数）区的任何颜色冲突。因此，我们可以将所有偶数区和奇数区的颜色结合起来。这个函数试图创建元素数量相似的颜色。   
* [0.x.5]*
   对给定范围的迭代器创建一个分区，这样指向冲突对象的迭代器将被放入不同的分区，其中两个对象是否冲突的问题由用户提供的函数决定。    这个函数也可以看作是一个图的着色：迭代器所指向的每个对象被认为是一个节点，每两个冲突的节点之间有一条边。然后，图形着色算法为每个节点分配一个颜色，使由一条边连接的两个节点不具有相同的颜色。    这个函数的一个典型的用例是在并行组装一个矩阵。在这里，人们希望同时在不同的单元上集合局部贡献（这种操作是纯粹的局部操作，因此不需要同步），但随后我们需要将这些局部贡献添加到全局矩阵中。一般来说，如果单元共享自由度，来自不同单元的贡献可能是对同一矩阵项的贡献，因此，除非我们想冒竞赛条件的风险，否则不能在同一时间发生（见http://en.wikipedia.org/wiki/Race_condition）。因此，我们称这两个单元为冲突单元，我们只能允许来自不冲突的单元的并行操作。换句话说，如果矩阵条目集（例如以行为特征的）有一个非空的交集，那么两个单元就处于冲突之中。    在这种情况下，计算冲突图需要调用一个确定两个迭代器（或它们代表的两个对象）是否冲突的函数，并为每一对迭代器调用，即[2.x.13]次。这在一般情况下是太昂贵了。一个更好的方法是要求一个用户定义的函数，为每个被调用的迭代器返回一个表征冲突的某种指标集；如果两个迭代器的冲突指标集有一个非空的交集，那么它们就是冲突的。在组装矩阵的例子中，冲突指标集将包含指向的单元上所有自由度的指数（在连续Galerkin方法的情况下），或者当前单元和与当前单元面相邻的所有单元上自由度指数的联合（在非连续Galerkin方法的情况下，因为在那里计算面积分，耦合由共同面连接的自由度
* 
* - 见[2.x.14]）。)    
* [2.x.15] 由作为第三个参数传递的用户定义函数返回的冲突集需要准确地描述[1.x.0]自由度，对于这些自由度，有什么东西被写进矩阵或右手边。换句话说，如果写入是通过[2.x.16]这样的函数发生的，那么冲突指标集实际上不仅要包含当前单元格上的自由度，还要包含它们通过约束条件（如悬挂节点）连接的自由度。    在其他情况下，冲突指标集可能代表完全不同的东西
* 
* - 由这个函数的调用者来描述两个迭代器冲突的含义。鉴于此，计算冲突图边可以比用[2.x.17]操作大大便宜。    在任何情况下，该函数的结果将是，其冲突指标集有重叠的迭代器不会被分配到相同的颜色。   
* [2.x.18] 这个函数中使用的算法在Turcksin、Kronbichler和Bangerth的论文中有所描述，见[2.x.19] 。     [2.x.20] 开始 寻求着色的迭代器范围的第一个元素。   [2.x.21] 结束 迭代器范围结束后的元素。   [2.x.22] get_conflict_indices 一个用户定义的函数对象，返回一组代表冲突的描述性指标。  更深入的讨论见上文。   [2.x.23] 一组迭代器的集合（为了提高效率，集合由[2.x.24]表示）。最外层集合的每个元素都对应于指向处于同一分区（具有相同颜色）的对象的迭代器，因此不会冲突。不同集合中的元素可能会发生冲突。 
* [0.x.6]*
    [2.x.25]是[2.x.26]的一个包装函数，是使用SparsityPattern表示的图连接进行着色的另一种方法。  进一步的细节，请参考[2.x.27]。  
* [0.x.7]

