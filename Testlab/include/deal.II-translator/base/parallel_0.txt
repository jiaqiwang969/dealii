include/deal.II-translator/base/parallel_0.txt
[0.x.0]*
     帮助结构，告诉我们是否可以对给定的[2.x.0]类型使用SIMD指令。   
* [0.x.1]*
     将F类型的函数对象转换成可以应用于同步迭代器范围的所有元素的对象。   
* [0.x.2]*
       构造器。取出并打包给定的函数对象。     
* [0.x.3]*
       存储的函数对象。     
* [0.x.4]*
       将F应用于一个有两个元素的迭代器集合。     
* [0.x.5]*
       将F应用于一个有三个元素的迭代器集合。     
* [0.x.6]*
       将F应用于一个有三个元素的迭代器集合。     
* [0.x.7]*
     取一个函数对象并从中创建一个Body对象。我们在这个辅助函数中这样做，因为我们必须指定F的实际数据类型。
* 
* - 对于函数对象来说，这往往是非常复杂的。   
* [0.x.8]*
     封装 [2.x.1] 。    
* [0.x.9]*
     当提供一个affinite_partitioner时，封装[2.x.2]。   
* [0.x.10]*
   一个执行<code>*out++ = predicate(*in++)</code>动作的算法，其中[2.x.3]迭代器在给定的输入范围内。    这个算法的作用与[2.x.4]的作用差不多。不同的是，当deal.II被配置为使用多线程时，该函数可以并行运行。    如果是并行运行，迭代器范围会被分割成若干块，每块都被打包成一个任务，并交给线程积木调度器，在计算资源可用的情况下进行处理。一旦所有的块都被处理完毕，该函数就会返回。最后一个参数表示每个任务的迭代器范围的最小元素数；这个数字必须大到足以摊销新任务的启动成本，小到足以确保任务可以合理地负载平衡。    关于这个函数适用于哪类问题的讨论，见[2.x.5]"多处理器的并行计算 "模块。 
* [0.x.11]*
   一个执行<code>*out++ = predicate(*in1++, in2++)</code>动作的算法，其中[2.x.6]迭代器在给定的输入范围内，使用tbb的并行for操作符。    这个算法几乎做了[2.x.7]的工作。不同的是，当deal.II被配置为使用多线程时，该函数可以并行运行。    如果是并行运行，迭代器范围会被分割成若干块，每块都被打包成一个任务，并交给线程构件调度器，在计算资源可用的情况下进行处理。一旦所有的块都被处理完毕，该函数就会返回。最后一个参数表示每个任务的迭代器范围的最小元素数；这个数字必须大到足以摊销新任务的启动成本，小到足以确保任务可以合理地负载平衡。    关于这个函数适用于哪类问题的讨论，见[2.x.8]"多处理器的并行计算 "模块。 
* [0.x.12]*
   一个执行<code>*out++ = predicate(*in1++, in2++,in3++)</code>动作的算法，其中[2.x.9]迭代器在给定的输入范围内。    这种算法的作用与[2.x.10]的作用差不多。不同的是，当deal.II被配置为使用多线程时，该函数可以并行运行。    如果是并行运行，迭代器范围会被分割成若干块，每块都被打包成一个任务，并交给线程积木调度器，在计算资源可用时进行处理。一旦所有的块都被处理完毕，该函数就会返回。最后一个参数表示每个任务的迭代器范围的最小元素数；这个数字必须大到足以摊销新任务的启动成本，小到足以确保任务可以合理地负载平衡。    关于这个函数适用于哪类问题的讨论，见[2.x.11]"多处理器的并行计算 "模块。 
* [0.x.13]*
     接受一个范围参数，并以其开始和结束来调用给定的函数。   
* [0.x.14]*
   这个函数将给定的函数参数[2.x.12]应用于范围[2.x.13]中的所有元素，并可能以并行方式进行。[2.x.14]中给出了它的一个使用实例。    然而，在许多情况下，在每个元素上调用一个函数并不高效，所以这个函数在子范围上调用给定的函数对象。  换句话说：如果给定的范围 [2.x.15] 小于grainsize，或者多线程没有启用，那么我们就调用 [2.x.16] ；否则，我们可能会执行，可能是%并行的，一连串的调用 [2.x.17] ，其中 [2.x.18] 和我们对 [2.x.19] 的调用集合将发生在不相交的子区间，共同覆盖原始区间 [2.x.20] 。    很多时候，被调用的函数当然要获得额外的信息，例如，对于迭代器参数的给定值，要对哪个对象进行处理。这可以通过 [1.x.0] 某些参数来实现。例如，这里有一个对全矩阵[2.x.22]和向量[2.x.23]的矩阵-向量乘法[2.x.21]的实现。 
* [1.x.1]
* 注意我们是如何使用lambda函数将[2.x.24]从一个需要5个参数的函数转换为一个需要2个参数的函数，并将其余参数绑定。由此产生的函数对象只需要两个参数，`begin_row'和`end_row'，而其他参数都是固定的。    如果在单线程模式下，该代码将在整个范围[2.x.26]上调用[2.x.25]一次。然而，在多线程模式下，它可能会在这个区间的子范围内被多次调用，可能允许一个以上的CPU核心来处理部分工作。    [2.x.27]参数（在上面的例子中为50）确保子区间不会变得太小，以避免在调度子区间的CPU资源上花费更多的时间，而不是在做实际工作。    关于这个函数适用于哪类问题的讨论，也可以参见[2.x.28]"多处理器的并行计算 "模块。 
* [0.x.15]*
   这是一个专门用于for循环的类，其固定范围由无符号整数给出。这是一个抽象的基类，一个实际的工作者函数是从它派生出来的。有一个公共函数apply可以并行地发出for循环，只要有足够的工作要做（即元素的数量大于grain_size），就把工作细分到可用的处理器核心上。在这个函数中，一个虚拟函数apply_to_subrange被调用，它指定了两个整数的范围<tt>[lower, upper)</tt>，这需要在一个派生类中定义。    这个类所涵盖的并行化情况是函数apply_to_subranges所能实现的一个子集（它也涵盖了可能不是由整数范围描述的更一般的迭代器的情况）。然而，对于简单的整数范围，人们可能更喜欢这个类，比如当有许多结构相似的循环时，例如对一个指针数组进行一些简单的复制或算术操作。在这种情况下，apply_to_subranges将产生大量的代码（或者说，大量的符号），因为它将由[2.x.29]产生的长名称传递给TBB中函数的模板化并行。这可以大大增加编译时间和目标代码的大小。同样地，不正确地使用[2.x.30]往往会导致非常隐晦的错误信息，这一点可以通过这个类来避免（只有一个虚拟函数需要在派生类中定义）。最后，在并行函数的背景下，虚拟函数的额外成本是可以忽略不计的。将工作实际发布到线程上的成本要高得多，而这又应该比for循环中的实际工作要少得多。 
* [0.x.16]*
     解构器。变成了虚拟的，以确保派生类也有虚拟的析构器。   
* [0.x.17]*
     这个函数在给定的范围内运行for循环<tt>[lower,upper)</tt>，当end-begin大于最小并行粒度时，可能是并行的。这个函数被标记为const，因为当几个线程同时处理相同的数据时，它的任何改变派生类数据的操作本质上都不是线程安全的。   
* [0.x.18]*
     在派生类中定义的用于处理子范围的虚拟函数。 这个函数被标记为const，因为当几个线程同时处理相同的数据时，任何改变派生类的数据的操作本质上都不是线程安全的。   
* [0.x.19]*
     一个符合TBB parallel_reduce函数正文要求的类。第一个模板参数表示要进行还原的类型。第二个模板参数表示对每个子范围应调用的函数对象的类型。   
* [0.x.20]*
       一个变量，它将保存还原的结果。     
* [0.x.21]*
       构造器。取出对每个子范围要调用的函数对象，以及相对于还原操作的中性元素。            第二个参数表示一个函数对象，它将被用来把两个计算的结果还原成一个数字。如果我们想简单地累积整数结果，一个例子是 [2.x.31] 。      
* [0.x.22]*
       分割构造函数。关于这一点，请看TBB书中的更多细节。     
* [0.x.23]*
       连接操作：合并不同子区间上的计算结果。     
* [0.x.24]*
       在指定的范围内执行给定的函数。     
* [0.x.25]*
       在每个子区间上调用的函数对象。     
* [0.x.26]*
       相对于还原操作的中性元素。在调用分割构造函数时需要这个，因为在这种情况下我们必须重新设置结果变量。     
* [0.x.27]*
       用来将两次调用的结果减少为一个数字的函数对象。     
* [0.x.28]*
   这个函数的工作原理很像apply_to_subranges()，但是它允许将在每个子范围内计算的数字结果累积为一个数字。  这个数字的类型是由需要明确指定的ResultType模板参数给出的。    使用这个函数的一个例子是计算一个正方形矩阵 [2.x.33] 和一个向量 [2.x.34] 的表达式 [2.x.32] 的值。对行的求和可以被并行化，整个代码可能看起来像这样。 
* [1.x.2]
* 这里，如果[2.x.35]的范围小于最小粒度（上面选择的是50），或者如果deal.II被配置为不使用多线程，则在整个[2.x.36]上调用。否则，它可以在给定范围的子集上调用，并在内部累积各个子集的结果。     [2.x.37] 如果ResultType是一个浮点类型，那么累加就不是一个关联操作。换句话说，如果给定的函数对象在三个子范围上被调用三次，返回值 [2.x.38] ，那么这个函数的返回结果是 [2.x.39] 。然而，根据这三个子任务在可用CPU资源上的分布情况，结果也可能是[2.x.40]或其他任何排列组合；因为浮点加法不是关联性的（当然，与实数%数的加法相反），多次调用这个函数的结果可能在舍入的顺序上有所不同。    关于这个函数适用于哪类问题的讨论，请参见[2.x.41]"多处理器的并行计算 "模块。 
* [0.x.29]*
   一个以线程安全的方式包装TBB亲和分区器的类。在Vector中，我们使用一个共享指针，在相同大小的不同向量之间共享一个亲和分区器，以提高数据（和NUMA）的定位性。然而，当一个外部任务进行多个向量操作时，共享指针可能导致竞赛条件。这个类只允许一个实例获得一个分区器。其他对象不能使用该对象，需要创建自己的副本。 
* [0.x.30]*
       构造函数。     
* [0.x.31]*
       销毁器。检查该对象是否不再被使用，即所有的循环都已完成。     
* [0.x.32]*
       返回一个亲和分区器。如果类所拥有的分区器是自由的，它将在此返回。如果另一个线程还没有释放它，就会创建一个新的对象。要再次释放该分区器，请通过release_one_partitioner()调用返回它。     
* [0.x.33]*
       在通过acquisition_one_partitioner()在tbb循环中使用分区器后，这个调用使分区器再次可用。     
* [0.x.34]*
       存储的分区器，可以在多次运行[2.x.42]中积累知识。      
* [0.x.35]*
       一个标志，表示该分区器是否已经获得但尚未释放，即它在其他地方使用。     
* [0.x.36]*
       一个突变器，用于保护对in_use标志的访问。     
* [0.x.37]*
     如果我们对向量进行并行计算（例如，我们将两个向量相加得到第三个向量，并对所有元素进行并行循环），那么这个变量决定了最小的元素数，对于这个最小的元素数，将一个范围的元素再分割开来分配给不同的线程是有利的。        这个变量可以作为一个全局可写变量，以便让测试组也能测试并行情况。默认情况下，它被设置为几千个元素，这是一个测试工具通常不会遇到的情况。因此，在testuite中，我们将其设置为一个
* 
* - 一个巨大的无益的值，但肯定会测试并行操作。   
* [0.x.38]*
     就像[2.x.43]一样，但现在表示一个矩阵的行数，应该作为最低限度的工作。   
* [0.x.39]*
     这是TBB为ParallelForInteger类实际调用的函数。   
* [0.x.40]

