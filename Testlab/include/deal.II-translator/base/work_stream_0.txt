include/deal.II-translator/base/work_stream_0.txt
[0.x.0]*
 一个命名空间，其主要的模板函数支持运行多个线程，每个线程在给定的对象范围内的一个子集上操作。该类使用英特尔线程构件（TBB）来平衡各个子范围在可用线程上的负载。关于这个类的原理的长篇讨论，见[2.x.0]"多处理器的并行计算 "模块。它在教程中首先用于[2.x.1]，然后在[2.x.2]、[2.x.3]、[2.x.4]和其他地方再次使用。
* 该类建立在以下前提之上：人们经常有一些工作需要在一连串的对象上完成；一个典型的例子是将单元格的贡献集合到一个系统矩阵或右手边。在许多这样的例子中，部分工作可以完全独立和并行地完成，可能使用一台具有共享内存的机器上的几个处理器核心。然而，这项工作的其他部分可能需要同步进行，并按顺序完成。在组装矩阵的例子中，局部贡献的计算可以完全并行完成，但将局部贡献复制到全局矩阵中需要一些注意。首先，几个线程不能同时写入，而是需要使用mutex来同步写入；其次，我们希望本地贡献加入全局矩阵的顺序总是相同的，因为浮点加法不是换元的，以不同的顺序将本地贡献加入全局矩阵会导致微妙的不同结果，这可能会影响迭代求解器的迭代次数，以及随机的解的舍弃误差。因此，我们要确保每次只有一个线程写入全局矩阵，而且结果是以稳定和可重复的顺序复制的。
* 这个类实现了这种工作模式的框架。它处理一个由迭代器范围给定的对象流，在所有这些对象上并行地运行一个工作函数，然后将每个对象传递给一个后处理函数，该函数按顺序运行，并完全按照对象在输入迭代器范围中出现的顺序获得对象。所有的同步工作都不会暴露给这个类的用户。
* 在内部，给这个类的run()函数的范围被分割成一连串的 "项目"，然后根据一些%的内部算法分配到可用线程的数量上。一个项目是我们要操作的迭代器范围中的一个元素；例如，为了组装矩阵或评估错误指标，一个项目可以是一个单元。TBB库决定了创建多少个线程（通常与处理器核心一样多），但在任何特定时间可能处于活动状态的项的数量由构造函数的参数指定。它应该大于或等于处理器内核的数量
* 
* - 默认是当前系统中核心数量的四倍。
* 每当一个工作线程处于空闲状态或预计将成为空闲状态时，TBB就会根据请求创建项目。然后，它被移交给一个工作者函数，通常是一个主类的成员函数。这些工作函数在一些线程上并行运行，而且不能保证它们被要求以任何特定的顺序处理项目，特别是不一定以项目从迭代器范围生成的顺序。
* 通常情况下，工作者函数需要额外的数据，例如FEValues对象、输入数据向量等，其中有些数据不能在线程之间共享。为此，run()函数需要另一个模板参数ScratchData，它指定了一种类型的对象，这些对象与每个项目一起存储，线程可以将其作为私有数据使用而不必与其他线程共享。run()函数需要一个额外的参数，其中有一个ScratchData类型的对象，该对象将被复制为传递给每个工作者函数的参数。
*此外，工作者函数将其结果存储在模板类型CopyData的对象中。然后，这些被移交给一个单独的函数，称为copier，它可能使用存储的结果，将它们转移到永久存储中。例如，它可以将工作函数计算的矩阵的局部贡献的结果复制到全局矩阵中。然而，与工作函数不同的是，在任何给定的时间内，只有一个复制器的实例在运行；因此，它可以安全地将本地贡献复制到全局矩阵中，而不需要使用突变器或类似手段锁定全局对象。此外，它保证复制器与CopyData对象的运行顺序与相关项目的创建顺序相同；因此，即使工作线程可能以非指定的顺序计算结果，复制器也总是以项目创建时的相同顺序接收结果。
* 一旦一个项目被复制器处理，它就会被删除，在其计算中使用的ScratchData和CopyData对象被认为是未使用的，并且可以在这个线程或另一个线程上的工作者函数的下一次调用中重新使用。然而，WorkStream函数没有试图将这些对象重置为任何一种原始状态
* 
* - 工作者应该假定它得到的CopyData对象有先前的内容，并以任何看起来合适的方式首先清除它，然后再把内容放进它，以后可以由复制者再次处理。
* ScratchData和CopyData中的成员变量可以独立于这些数据结构副本的其他并发使用而被访问。因此，将与ScratchData和CopyData相关的辅助数据结构的大小调整到每个单元上的不同长度是完全可以的。例如，与[2.x.5]一起用于组装局部矩阵的持有每个正交点密度的向量可以被调整为具有hp-capabilities的DoFHandlers中当前单元的相应正交点的数量。同样，CopyData中的局部刚度矩阵也可以根据当前单元上的局部DoF的数量来调整大小。
* 

* 
* [2.x.6] 对于单元格和面的积分，使用比当前函数更具体的方法往往是有用的（它不在乎迭代器是在单元格、向量元素还是其他类型的范围上）。[2.x.7]函数是一个特别适合于积分的接口的实现。
* 

* 
* [2.x.8] 这个命名空间中的函数只有在deal.II配置时选择了多线程模式时才会真正并行工作。否则，它们只是按顺序对每个项目工作。
* 

* 
* [2.x.9] 

 
* [0.x.1]*
   嵌套命名空间包含工作流算法的各种实现。 
* [0.x.2]*
     一个命名空间，用于实现WorkStream模式和函数的细节。这个命名空间持有处理Turcksin、Kronbichler和Bangerth的论文中描述的第二个实现的类（见[2.x.10] ）。    在这里，没有提供着色，所以复制是使用TBB过滤器顺序进行的。        尽管这个实现比那篇论文中讨论的第三个实现要慢，我们还是需要保留它，原因有二。(i)用户可能不会给我们一个图形着色，(ii)我们想用这个实现来处理那些太小的颜色。   
* [0.x.3]*
       一个可以从一系列迭代器中创建一个项目序列的类。     
* [0.x.4]*
         一个数据类型，我们用它来识别要处理的项目。这是一个结构，在WorkStream实现的不同部分之间传递，以确定流水线的各个阶段需要做什么。       
* [0.x.5]*
           一个结构，它包含一个指向抓取数据对象的指针，以及一个指示该对象当前是否正在使用的标志。         
* [0.x.6]*
             默认构造函数。           
* [0.x.7]*
           类型化为一个从头数据对象的列表。这个列表的原理是在使用这些列表的变量中提供的。         
* [0.x.8]*
           一个需要被处理的迭代器的列表。只有前面的n_个项目是相关的。         
* [0.x.9]*
           管道的Worker部分为每个工作项目填充的CopyData对象。同样，只有前n_items元素是我们所关心的。         
* [0.x.10]*
           Work_items数组所标识的、Worker和Copier管道阶段需要工作的项目数量。这个变量的最大值将是chunk_size。         
* [0.x.11]*
           指向线程局部变量的指针，识别该线程将使用的抓取数据对象。这个类的最初实现是使用线程局部变量，每个线程只提供一个从头开始的对象。这并不奏效，因为工作者函数可能会自己启动任务，然后调用[2.x.11]或类似的函数，TBB调度器可能会用它来在当前线程上运行其他东西
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
 

 
* 
* - 例如工作者函数的另一个实例。          因此，如果我们只为每个线程提供一个抓取对象，就会有两个工作者函数的实例使用同一个抓取对象。解决方案是为每个线程提供一个从头开始的对象列表，同时提供一个标志，表明这个从头开始的对象目前是否被使用。如果一个线程需要一个抓取对象，它就会浏览这个列表，直到找到一个未使用的对象，或者，如果没有，就自己创建一个。请注意，我们不需要为这个过程使用同步原语，因为这些列表是线程本地的，只要我们在访问列表之间没有屈服点，就能保证只有一个线程访问它们。                    存放在这些列表中的指向scratch对象的指针必须是这样的：当线程本地对象被销毁时，它们会在所有线程上被删除。这可以通过使用unique_ptr来实现。                    请注意，当一个工作者需要创建一个从头开始的对象时，它会使用sample_scratch_data来分配它，以便从中复制。这样做的好处是第一次接触初始化，也就是说，从头数据对象的内存是由后来使用它的同一个线程分配和初始化的。         
* [0.x.12]*
           指针指向一个样本的抓取数据对象，用于初始化为每个单独线程创建的抓取数据对象。         
* [0.x.13]*
           如果缓冲区被使用，则标志为真；如果缓冲区可以使用，则标志为假。         
* [0.x.14]*
           默认构造函数。初始化所有本身没有默认构造函数的东西。         
* [0.x.15]*
         构造函数。取一个迭代器范围，可以容纳项目的缓冲区的大小，以及将传递给每个工作者和复制者函数调用的附加数据对象样本。       
* [0.x.16]*
         创建一个项目并返回它的指针。       
* [0.x.17]*
         仍待处理的迭代器的区间。这个范围会随着时间的推移而缩小。       
* [0.x.18]*
         一个缓冲区，它将存储项目。       
* [0.x.19]*
         指向线程局部变量的指针，用于识别该线程将使用的抓取数据对象。这个类的最初实现是使用线程局部变量，每个线程只提供一个抓取对象。这并不奏效，因为工作者函数可能会自己启动任务，然后调用[2.x.12]或类似的函数，TBB调度器可能会用它来在当前线程上运行其他东西
* 
*--例如，工作函数的另一个实例。因此，如果我们只为每个线程提供一个划痕对象，就会有两个工作函数的实例使用同一个划痕对象。解决办法是为每个线程提供一个从头开始的对象列表，同时提供一个标志，表明这个从头开始的对象目前是否被使用。如果一个线程需要一个抓取对象，它就会浏览这个列表，直到找到一个未使用的对象，或者，如果没有，就自己创建一个。请注意，我们不需要为这个过程使用同步原语，因为这些列表是线程本地的，只要我们在访问列表之间没有屈服点，就能保证只有一个线程访问它们。                存放在这些列表中的指向scratch对象的指针必须是这样的：当线程本地对象被销毁时，它们会在所有线程上被删除。这可以通过使用unique_ptr来实现。                请注意，当一个工作者需要创建一个从头开始的对象时，它会使用sample_scratch_data来分配它，以便从中复制。这样做的好处是第一次接触初始化，也就是说，划痕数据对象的内存是由后来使用它的同一个线程分配和初始化的。       
* [0.x.20]*
         对抓取数据样本的引用，该样本将被用于初始化每个工作任务所使用的抓取数据对象的线程本地指针。       
* [0.x.21]*
         每个线程应按顺序工作的迭代器范围的元素数；一个大的数字可以确保每个线程在下一个任务切换发生之前得到大量的工作，而一个小的数字则更有利于负载平衡。       
* [0.x.22]*
       一个管理在若干并行线程上调用工作者函数的类。请注意，用TBB的说法，它是一个可以并行运行的过滤器。     
* [0.x.23]*
         构造函数。取一个对我们要操作的对象的引用，以及一个指向将进行装配的函数的指针。       
* [0.x.24]*
         对一个项目进行操作。       
* [0.x.25]*
         指向对单元格序列进行装配的函数的指针。       
* [0.x.26]*
         如果复制器阶段存在，该标志为真。如果它不存在，工作者必须释放缓冲区。否则，复制者将会做这件事。       
* [0.x.27]*
       一个管理调用复制器函数的类。请注意，在TBB符号中，它是一个按顺序运行的过滤器，确保所有项目按照它们被创建的相同顺序被复制。     
* [0.x.28]*
         构造函数。接受一个对我们要操作的对象的引用，以及一个指向函数的指针，该函数将完成从附加数据对象到全局矩阵的复制或类似的复制。       
* [0.x.29]*
         在一个单项上工作。       
* [0.x.30]*
         指向进行数据复制的函数的指针。       
* [0.x.31]*
     一个不使用多线程的参考实现，如果我们没有多线程支持，或者用户要求按顺序运行的话，就可以使用。如果我们只有一个单线程，这比使用TBB或taskflow更有效率。   
* [0.x.32]*
       没有颜色的顺序版本。     
* [0.x.33]*
       有颜色的顺序版本      
* [0.x.34]*
     一个用于实现WorkStream模式和功能细节的命名空间。这个命名空间拥有处理Turcksin、Kronbichler和Bangerth的论文中描述的第三个实现的类（见[2.x.13] ）。   
* [0.x.35]*
       一个结构，包含一个指向从头开始和复制数据对象的指针，以及一个指示该对象当前是否正在使用的标志。     
* [0.x.36]*
         默认构造函数。       
* [0.x.37]*
       一个管理调用worker和copyer函数的类。与其他实现不同的是，使用parallel_for而不是流水线。     
* [0.x.38]*
         构造函数。       
* [0.x.39]*
         在由两个参数表示的项目范围内调用工作器和复制器函数的函数。       
* [0.x.40]*
         对抓取数据对象的列表的类型化定义。这个列表的原理是在使用这些列表的变量中提供的。       
* [0.x.41]*
         指向在单元格序列上进行组装的函数的指针。       
* [0.x.42]*
         指向从本地贡献复制到全局对象的函数的指针。       
* [0.x.43]*
         当我们需要的时候，对样本刮擦和复制数据的引用。       
* [0.x.44]*
       使用TBB的彩色运行函数。     
* [0.x.45]*
   这是WorkStream概念的两个主要功能之一，做本命名空间介绍中描述的工作。它对应于Turcksin、Kronbichler和Bangerth的论文中的实现3，见 [2.x.14] 。  因此，它采取的不是由开始和结束迭代器描述的迭代器范围，而是迭代器的 "彩色 "图，其中每种颜色代表将单元格贡献写入全局对象中不冲突的单元格（换句话说，这些单元格不是邻接的）。每个 "颜色 "由[2.x.15]个单元格表示。这个函数的第一个参数是一组单元格（为了提高效率，用向量的向量表示），通常是通过调用[2.x.16]来构建的，更多信息见那里。    这个函数可以用于Worker和Copyer对象，这些对象要么是指向非成员函数的指针，要么是允许用operator()调用的对象，例如由lambda函数或[2.x.17]创建的对象。 两个数据类型<tt>ScratchData</tt>和<tt>CopyData</tt>需要有一个工作拷贝构造函数。<tt>ScratchData</tt>只在<tt>worker</tt>函数中使用，而<tt>CopyData</tt>是由<tt>worker</tt>传递给<tt>copier</tt>的对象。    [2.x.18]参数表示在任何给定时间内可以活用的项目数量。每个项目由输入流的[2.x.19]元素组成，将由worker和copier函数在同一线程上一个接一个地处理。   
* [2.x.20] 如果你的数据对象很大，或者它们的构造函数很昂贵，记住<tt>queue_length</tt>拷贝的<tt>ScratchData</tt>对象和<tt>queue_length*chunk_size</tt>拷贝的<tt>CopyData</tt>对象是有帮助的。   
* [2.x.21] 在复制器不做任何事情的情况下，传递[2.x.22] CopyData &)>()`作为[2.x.23]以确保内部使用更有效的算法。然而，重要的是要认识到，上面创建的空函数对象并不*
   与具有空主体的lambda函数不同，`[](const CopyData &) {}`。
* 
* - 从这个函数的角度来看，没有办法识别作为复制者提供的λ函数在其主体中是否做了什么，所以需要复制。另一方面，一个默认构造的[2.x.24]对象可以*被识别，然后被用来选择一个更有效的算法。 
* [0.x.46]*
   这是WorkStream概念的两个主要功能之一，做本命名空间介绍中描述的工作。它对应于Turcksin、Kronbichler和Bangerth的论文中的实现2（见[2.x.25]）。    这个函数可以用于worker和copyer对象，这些对象要么是指向非成员函数的指针，要么是允许用operator()调用的对象，例如lambda函数或由[2.x.26]创建的对象。 如果copyer是一个空函数，它在管道中会被忽略。然而，一个具有空主体的lambda函数并不*等同于一个空的[2.x.27]对象，因此，不会被忽略。    作为[2.x.28]传递的参数必须可以转换为与[2.x.29]开始时相同的类型，但本身不一定是相同的类型。这允许编写类似<code>WorkStream().run(dof_handler.begin_active(), dof_handler.end(), ...</code>的代码，其中第一个是[2.x.30]类型，而第二个是[2.x.31]类型。 两个数据类型<tt>ScratchData</tt>和<tt>CopyData</tt>需要有一个工作拷贝构造器。<tt>ScratchData</tt>只在<tt>worker</tt>函数中使用，而<tt>CopyData</tt>是由<tt>worker</tt>传递给<tt>copier</tt>的对象。    [2.x.32]参数表示在任何给定时间内可以活用的项目数量。每个项目由输入流的[2.x.33]个元素组成，这些元素将被worker和copier函数在同一个线程上一个接一个地处理。   
* [2.x.34] 如果你的数据对象很大，或者它们的构造函数很昂贵，记住<tt>queue_length</tt>拷贝的<tt>ScratchData</tt>对象和<tt>queue_length*chunk_size</tt>拷贝的<tt>CopyData</tt>对象是有帮助的。   
* [2.x.35] 在拷贝器不做任何事情的情况下，传递[2.x.36] CopyData &)>()`作为[2.x.37]以确保内部使用更高效的算法。然而，重要的是要认识到，上面创建的空函数对象并不*
   与具有空主体的lambda函数不同，`[](const CopyData &) {}`。
* 
* - 从这个函数的角度来看，没有办法识别作为复制者提供的λ函数在其主体中是否做了什么，所以需要复制。另一方面，一个默认构造的[2.x.38]对象可以*被识别，然后被用来选择一个更有效的算法。 
* [0.x.47]*
   与上面的函数相同，但用于迭代器范围和C风格的数组。  一个满足迭代器范围要求的类定义了[2.x.39]和[2.x.40]两个函数，这两个函数都返回到构成范围边界的元素的迭代器。 
* [0.x.48]*
   与上面的函数相同，但针对deal.II的IteratorRange。 
* [0.x.49]*
   这是WorkStream概念的两个主要函数之一的变体，做本命名空间介绍中描述的工作。  它对应于Turcksin、Kronbichler和Bangerth的论文中的实现2（见[2.x.41] ）。    这是可以用于作为类的成员函数的工作者和复制者函数的函数。如果复制器是一个空函数，那么它在管道中会被忽略。    作为[2.x.42]传递的参数必须可以转换为与[2.x.43]开始相同的类型，但本身不一定是同一类型。这允许编写类似<code>WorkStream().run(dof_handler.begin_active(), dof_handler.end(), ...</code>的代码，其中第一个是[2.x.44]类型，而第二个是[2.x.45]类型。 [2.x.46]参数表示在任何特定时间可以直播的项目数量。每个项目由输入流的[2.x.47]个元素组成，这些元素将由工作者和复制者函数在同一线程上一个接一个地处理。   
* [2.x.48] 如果你的数据对象很大，或者它们的构造函数很昂贵，记住<tt>queue_length</tt>拷贝的<tt>ScratchData</tt>对象和<tt>queue_length*chunk_size</tt>拷贝的<tt>CopyData</tt>对象是有帮助的。   
* [2.x.49] 在拷贝器不做任何事情的情况下，传递[2.x.50] CopyData &)>()`作为[2.x.51]以确保内部使用更有效的算法。然而，重要的是要认识到，上面创建的空函数对象并不*
   与具有空主体的lambda函数不同，`[](const CopyData &) {}`。
* 
* - 从这个函数的角度来看，没有办法识别作为复制者提供的λ函数在其主体中是否做了什么，所以需要复制。另一方面，一个默认构造的[2.x.52]对象可以*被识别，然后被用来选择一个更有效的算法。 
* [0.x.50]*
   与上面的函数相同，但用于迭代器范围和C风格的数组。  一个满足迭代器范围要求的类定义了[2.x.53]和[2.x.54]两个函数，这两个函数都返回到构成范围边界的元素的迭代器。 
* [0.x.51]*
   与上面的函数相同，但针对deal.II的IteratorRange。 
* [0.x.52]

