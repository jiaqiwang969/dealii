include/deal.II-translator/base/table_0.txt
[0.x.0]*
    [2.x.0] 有一个命名空间，我们在其中声明一些类，用于使用<tt>operator[]<tt>访问表的元素。这些是相当有技术含量的，因为它们必须以递归的方式进行工作（由于索引的数量不知道，如果我们访问一个对象，我们必须返回一个迭代器到下一个较低维度的对象，直到我们在最低层，实际上可以返回一个对存储数据类型本身的引用）。 这是非常技术性的，你通常根本不会想看这些类，除了可能出于教育的原因。 这里的任何一个类都没有你应该在你的程序中明确使用的接口（当然，除了通过用<tt>operator[]</tt>访问表的元素，生成这个命名空间的类型的临时对象）。 
* [0.x.1]*
      [2.x.1] 有一个类，根据其模板参数，声明一些嵌套的别名。一般的模板什么都不声明，但有更多有用的特殊化，关于最后一个参数表示表的常数，访问器对象将在这个命名空间中生成。   
* [0.x.2]*
      [2.x.2] 拥有一个声明一些嵌套别名的类，这取决于它的模板参数。对常量对象的访问器进行专业化处理。   
* [0.x.3]*
      [2.x.3] 拥有一个宣布一些嵌套别名的类，这取决于它的模板参数。对非常量对象的访问器的特殊化。   
* [0.x.4]*
      [2.x.4] 作为<tt>Table<N,T></tt>类型表的子对象访问器的类。模板参数<tt>C</tt>可以是true或false，并表示所处理的对象是否是常量（即只有当值为false时才允许写访问）。        因为对于<tt>N</tt>索引，应用<tt>operator[]</tt>的效果是获得对<tt>N-1</tt>索引的访问，我们必须递归地实现这些访问器类，当我们只剩下一个索引时就停止。对于后一种情况，下面声明了这个类的特殊化，在这里调用<tt>operator[]</tt>可以访问表实际存储的对象。在给索引运算符的值中，需要检查它是否在其范围内，为此我们需要知道我们目前实际访问的是表的哪个索引。这是通过模板参数<tt>P</tt>来实现的：它表明还有多少个索引。对于一个向量，<tt>P</tt>可能只有一个（然后使用下面的特殊化）。对于一个表来说，这个值可能是两个，当使用<tt>operator[]</tt>时，会出现一个<tt>P=1</tt>的对象。        <tt>P</tt>的值也被用来确定stride：这个对象存储了一个指针，表示它可能访问的对象范围的开始。当我们在这个对象上应用<tt>operator[]</tt>时，产生的新访问器只能访问这些元素的一个子集，为了知道哪个子集，我们需要知道表的尺寸和现在的索引，这个索引由<tt>P</tt>表示。        正如对整个命名空间所说的那样，你通常不需要直接处理这些类，也不应该试图直接使用它们的接口，因为它可能在没有通知的情况下发生变化。事实上，由于构造函数是私有的，你甚至不能生成这个类的对象，因为它们只被认为是访问表类元素的临时性的，而不是作为函数的参数来传递的，等等。   
* [0.x.5]*
       构造函数。取一个指向表对象的指针来了解各个维度的大小，以及一个指向我们可能访问的数据子集的指针。     
* [0.x.6]*
       复制构造函数。这个构造函数是公开的，这样就可以把子表作为参数传递给函数，就像 [2.x.5] 中的那样。            如果访问器的存储时间比它所指向的表长，使用这个构造函数是有风险的。不要这样做。     
* [0.x.7]*
       索引操作符。执行一个范围检查。     
* [0.x.8]*
       范围检查的异常。不要使用全局异常，因为这样我们可以输出哪个索引是错误的。     
* [0.x.9]*
       存储给构造函数的数据。这个类没有非常量的成员函数，所以没有理由不把这些元素变成常量。     
* [0.x.10]*
      [2.x.6] 表格的访问器类。这是最后一个索引的特殊化，它实际上允许对表的元素进行访问，而不是递归地返回进一步子集的访问对象。    这个特殊化与一般模板的情况相同；更多信息请看那里。   
* [0.x.11]*
       对这一行的元素进行常量和非常量迭代器类型的类型化，以及标准库算法通常需要的所有其他类型。     
* [0.x.12]*
       从上面的switch类中导入一个别名。     
* [0.x.13]*
       构造函数。取一个迭代器到表对象，以了解各个维度的大小，以及一个迭代器到我们可能访问的数据子集（在这个特殊的例子中，只有一行）。            构造函数是私有的，以防止你身边有这样的对象。创建这种对象的唯一方法是通过<tt>Table</tt>类，它只生成临时对象。      这保证了访问器对象比母对象更早退出范围，避免了数据一致性的问题。     
* [0.x.14]*
       复制构造函数。这个构造函数是公开的，这样就可以像 [2.x.7] 中那样，将子表作为参数传递给函数。            如果访问器的存储时间比它所指向的表长，使用这个构造函数是有风险的。不要这样做。     
* [0.x.15]*
       索引操作符。执行一个范围检查。     
* [0.x.16]*
       返回一行的长度，即表对象的最后一个索引所对应的元素数。     
* [0.x.17]*
       返回该行的第一个元素的迭代器。     
* [0.x.18]*
       返回一个迭代器到超过此行终点的元素。     
* [0.x.19]*
       存储给构造函数的数据。这个类没有非常量的成员函数，所以没有理由不使这些元素成为常量。     
* [0.x.20]*
 一个持有多维数组的模板类型的对象的类。如果表示维数的模板参数是一个，那么这个类或多或少代表了一个向量；如果是两个，那么它就是一个矩阵；以此类推。
* 这个类特别取代了对高维数组的尝试，如[2.x.8]或甚至更高的嵌套结构。这些结构体的缺点是很难初始化，最重要的是，如果一个矩阵或高维表的所有行都有相同的大小（这是通常的情况），那么它们的效率就非常低，因为此时每一行的内存都是独立分配的，既浪费时间又浪费内存。这可以通过为整个对象只分配一大块内存而变得更有效率，这就是当前类的做法。
* 

* [1.x.0]
* 在某种程度上，这个类类似于张量类，因为它对维数进行模板化。然而，有两个主要区别。第一是Tensor类只存储数值（如<tt>double</tt>s），而Table类存储任意的对象。第二是张量类在每个维度都有固定的尺寸，也是作为模板参数给出的，而这个类可以在每个维度处理任意的、不同的尺寸。
* 这有两个后果。首先，由于在编译时不知道大小，它必须进行显式内存分配。其次，各个元素的布局在编译时并不知道，所以访问速度比张量类慢，在张量类中，元素的数量和它们的位置在编译时就已经知道了，而且编译器可以利用这些知识进行优化（例如在展开循环的时候）。另一方面，这个类当然更灵活，例如，当你想要一个二维表，其行数等于单元格的自由度数，列数等于正交点的数量。这两个数字可能只有在运行时才知道，所以这里需要一个灵活的表格。此外，你可能想存储，例如，形状函数的梯度，所以数据类型不是单一的标量值，而是张量本身。
* 

* [1.x.1]
* 表类（派生自该类）经常被用来存储大型数据表。在[2.x.9]中给出了一个适度的例子，我们存储了一个[2.x.10]非洲地区的地理海拔数据的表，这个数据需要大约670 kB，如果内存；然而，存储三维或更多维度数据的表（例如，关于地球内部的密度、压力和温度的信息，在`（纬度、经度、深度）`点的规则网格上）可以轻松达到数百兆字节或更多。这些表格通常被提供给诸如InterpolatedTensorProductGridData或InterpolatedUniformGridData等类。
* 如果你需要在单处理器（或多线程）作业中加载这样的表，那么你对这些表的大小无能为力。该表只需适合内存即可。但是，如果你的程序是通过MPI并行化的，那么典型的第一种实现方式是在每个进程上创建一个表对象，并通过从文件中读取数据在每个MPI进程上填充它。这从两个方面来说是低效的。
* 

* 
* 
* - 你会有很多进程同时试图从同一个文件中读取数据。
* 

 
* 
* - 在大多数情况下，每个进程上存储的数据都是一样的，虽然每个进程都需要能够从表中读取数据，但没有必要每个进程都存储自己的表。碰巧位于同一台机器上的所有MPI进程不妨只存储一个副本，并通过[共享内存](https://en.wikipedia.org/wiki/Shared_memory)使其彼此可用；在这种模式下，每台机器只有一个MPI进程需要存储数据，然后所有其他进程可以访问它。
* 这两种用例都是由内部基于[2.x.12]的[2.x.11]函数实现的，该函数允许像下面这样的工作流程，我们让那个等级为0的MPI进程负责读取数据（但它也可以是任何其他 "根等级"）。

* 
* [1.x.2]
* 
* 这段代码中的最后一个调用确保数据在所有非根进程中可用，方法是在其他进程的内存空间中重新创建一个表的副本，或者，如果可能的话，在共享内存中为位于MPI作业使用的每台机器上的所有进程创建一次副本。
* 

* 
* [2.x.13] 

 
* [0.x.21]*
   用来计算这个容器中的元素数量的整数类型。 
* [0.x.22]*
   默认构造函数。将所有尺寸设置为零。 
* [0.x.23]*
   构造函数。用每个索引组件中的给定尺寸初始化数组。 
* [0.x.24]*
   构造函数。在每个索引组件中用给定的尺寸初始化数组，然后通过调用fill( entries,C_style_indexing)，用第二个和第三个参数初始化表格中的元素。 
* [0.x.25]*
   拷贝构造函数。执行一个深度拷贝。 
* [0.x.26]*
   拷贝构造函数。从存储其他数据类型的表对象中执行深度拷贝。 
* [0.x.27]*
   移动构造函数。转移另一个表的内容。 
* [0.x.28]*
   解除构造函数。释放分配的内存。 
* [0.x.29]*
   赋值运算符。将<tt>src</tt>的所有元素复制到矩阵中。  如果需要，大小会被调整。    我们不能使用其他的、模板化的版本，因为如果我们不声明这个版本，编译器会很高兴地生成一个预定义的复制操作符，这不是我们想要的。 
* [0.x.30]*
   拷贝操作符。将<tt>src</tt>的所有元素复制到数组中。如果需要的话，大小会被调整。    这个函数要求<tt>T2</tt>的类型可以转换为<tt>T</tt>。 
* [0.x.31]*
   移动赋值运算符。将<tt>src</tt>的所有元素转移到表中。 
* [0.x.32]*
   测试两个表的相等。 
* [0.x.33]*
   将所有条目设置为默认值（即用默认构造的对象将它们复制过来）。但不要改变表的大小。 
* [0.x.34]*
   将此对象的尺寸设置为第一个参数中给出的尺寸，并为表项分配所需的内存以适应这些尺寸。如果[2.x.14]被设置为[2.x.15]，表的所有元素都被设置为元素类型的默认构造对象。否则，内存将处于未初始化或其他未定义的状态。 
* [0.x.35]*
   表的大小在<tt>i</tt>方向。 
* [0.x.36]*
   返回这个对象在每个方向上的大小。 
* [0.x.37]*
   返回存储在此对象中的元素数量，它是每个维度上的扩展量的乘积。 
* [0.x.38]*
   返回该对象是否为空，即其中一个方向为零。  这等同于<tt>n_elements()==0</tt>。 
* [0.x.39]*
   通过解引用给定的前向迭代器（例如，可以是一个指向数组第一个元素的指针，或者一个插入 [2.x.16] 第二个参数表示所指向的元素的排列方式是对应于最后一个索引运行最快还是最慢。默认情况下，使用C风格的索引，即最后一个索引运行最快（与Fortran风格相反，当遍历多维数组时，第一个索引运行最快。例如，如果你试图填充一个Table<2,T>类型的对象，那么用第二个参数的默认值来调用这个函数将导致等同于做  
* [1.x.3]
* 另一方面，如果这个函数的第二个参数是假的，那么这将导致以下形式的代码。 
* [1.x.4]
* 注意我们通过遍历给定的迭代器集合来填充表元素的转换顺序。     [2.x.17] entries 一个迭代器，用于初始化这个表的元素集。假设迭代器可以被递增和取消引用足够多的次数来填充这个表。   [2.x.18] C_style_indexing 如果是true，当我们解指输入范围的后续元素时，以最后一个索引最快的速度运行该表的元素。如果为假，则最快改变第一个索引。 
* [0.x.40]*
   用相同的值填充所有的表项。 
* [0.x.41]*
   返回一个对指定元素的读写引用。 
* [0.x.42]*
   返回指定元素的值作为只读引用。    我们将请求的值作为一个常量引用而不是按值返回，因为这个对象可能持有的数据类型可能很大，而且我们在这里不知道复制是否昂贵。 
* [0.x.43]*
   这个函数在MPI通信器的所有进程中复制由[2.x.19]指示的进程上发现的状态。在[2.x.20]以外的任何进程中发现的当前状态都会在这个进程中丢失。我们可以想象这个操作就像从根进程到所有其他进程对[2.x.21]的调用，尽管在实践中这个函数可能试图将数据移动到每个承载MPI进程的机器上的共享内存区域，然后让这个机器上的所有MPI进程访问这个共享内存区域，而不是保留自己的副本。请看这个类的一般文档中的代码例子。    这个函数的意图是将大的数组从一个进程快速交换给其他进程，而不是在所有进程上计算或创建它。这特别适用于从磁盘加载的数据
* 
* - 说，大的数据表
* 
* 比起让每个进程自己从磁盘上读取数据，通过读取一次，然后在MPI宇宙中的所有进程中分发，更容易处理。  具体来说，共享内存区域的使用允许在MPI宇宙中每个多核机器上只复制一次数据，而不是为每个MPI进程复制一次数据。如果今天的机器上的数据很大，每个共享内存空间可以很容易地容纳几十个MPI进程，这就可以节省大量内存。    这个功能并不意味着保持不同进程的数据同步，就像[2.x.22]和其他矢量类所做的那样，存在一个由每个进程拥有的矢量的某些元素的概念，可能还有从其拥有的进程镜像到其他进程的幽灵元素。相反，当前对象的元素被简单地复制到其他进程中，把这个操作看作是在所有进程中创建一组`const`AlignedVector对象，在复制操作之后不应该再被改变，这是确保向量在所有进程中保持一致的唯一方法。这尤其是因为共享内存区域的使用，在一个MPI进程上对一个向量元素的任何修改也可能导致对其他进程上可见元素的修改，假设它们位于一个共享内存节点内。   
* [2.x.23] 在MPI进程之间使用共享内存需要检测的MPI安装支持必要的操作。    这对于MPI 3.0和更高版本来说是这样的。   
* [2.x.24] 这个功能并不便宜。它需要创建所提供[2.x.25]对象的子通信器，这通常是一个昂贵的操作。同样地，共享内存空间的生成也不是一个便宜的操作。因此，当目标是在进程之间共享大的只读数据表时，这个功能主要是有意义的；例子是在启动时加载数据表，然后在程序的运行时间内使用。    在这种情况下，运行这个函数的启动成本可以随着时间的推移而摊销，而且在具有大核心数的机器上，许多MPI进程在同一台机器上运行时，不必在每个进程上存储表所带来的潜在内存节省可能是相当大的。   
* [2.x.26] 这个函数只有在数据类型`T`是 "自足 "的情况下才有意义，也就是说，它的所有信息都存储在其成员变量中，并且没有一个成员变量是指向内存的其他部分的指针。这是因为如果一个类型`T`确实有指向内存其他部分的指针，那么将`T`移到共享内存空间不会导致其他进程访问该对象用其成员变量指针指向的数据。这些数据仍然只存在于一个进程中，并且通常在其他进程无法访问的内存区域。    因此，这个函数的通常使用情况是共享简单对象的数组，如`double's或`int's。   
* [2.x.27] 调用该函数后，不同MPI进程的对象共享一个共同的状态。这意味着某些操作变得 "集体"，即必须在所有参与的处理器上同时调用。特别是，你不能再在一个MPI进程上调用resize()、reserve()或clear()。
* 
* - 你必须在所有进程上同时这样做，因为它们必须为这些操作进行通信。如果你不这样做，你很可能会得到一个死锁，可能很难调试。推而广之，这个只集体调整大小的规则也延伸到这个函数本身。你不能连续调用它两次，因为这意味着首先除了`root_process'以外的所有进程都要扔掉他们的数据，这不是一个集体操作。一般来说，这些关于可以做什么和不可以做什么的限制，暗示了上面评论的正确性。你应该把一个当前函数被调用的AlignedVector视为`const'，在调用析构器之前，不能对其进行进一步的操作。 
* [0.x.44]*
   交换这个表和另一个表的内容 [2.x.28] 人们可以用一个临时变量和复制过来的数据元素来完成这个操作，但是这个函数明显更有效率，因为它只交换了两个向量的数据指针，因此不需要分配临时存储和移动数据。    这个函数类似于所有C++标准容器的[2.x.29]函数。此外，还有一个全局函数<tt>swap(u,v)</tt>，它简单地调用<tt>u.swap(v)</tt>，同样与标准函数相类似。 
* [0.x.45]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.46]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据写入或读出到一个流中，以便进行序列化。 
* [0.x.47]*
   返回指定元素在一个接一个存储的元素阵列中的位置。这个函数不做索引检查。 
* [0.x.48]*
   返回一个对指定元素的读写引用。    这个函数不做边界检查，只在内部和已经检查过的函数中使用。 
* [0.x.49]*
   返回指定元素的值，作为一个只读引用。    这个函数不做边界检查，只在内部和已经检查过的函数中使用。    我们将请求的值作为一个常数引用而不是按值返回，因为这个对象可能持有的数据类型可能很大，而且我们在这里不知道复制是否昂贵。 
* [0.x.50]*
   组件-数组。 
* [0.x.51]*
   表的每个方向上的大小。 
* [0.x.52]*
 一个代表具有任意但固定索引数的表的类。这个一般的模板在TableBase类提供的功能之外，还实现了一些额外的功能，例如索引函数采取正确的参数数量，等等。
* 与其说是这个通用模板，不如说是在这个类的部分特殊化中实现了这些功能，有固定数量的维数。更多信息请见那里，以及基类的文档中。
* 

* 
* [2.x.30] 

* 
* [0.x.53]*
 一个代表一维表的类，也就是一个类似矢量的类。这个类的大部分接口是在TableBase基类中实现的。关于这个类的原理和接口的概要，见那里。
* 

* 
* [2.x.31] 

* 
* [0.x.54]*
   用来计算这个容器中的元素数量的整数类型。 
* [0.x.55]*
   默认构造函数。将所有尺寸设置为零。 
* [0.x.56]*
   构造函数。将给定的维度传给基类。 
* [0.x.57]*
   构造函数。创建一个具有给定尺寸的表，并从一组迭代器中初始化它。    这个函数完全等同于创建一个给定尺寸的表[2.x.32]，然后调用  
* [1.x.5]
*上，使用[2.x.33]函数，其中的参数会有更详细的解释。但问题是，这只有在运行构造函数后可以改变表的情况下才有可能，而调用当前的构造函数可以立即确定对象的大小和初始化，这样就可以将其标记为常量。    使用这个构造函数，你可以做这样的事情。 
* [1.x.6]
* 你也可以使用输入迭代器，从文件中直接初始化一个表。 
* [1.x.7]
* [2.x.34] size 这个一维表的大小。   [2.x.35] entries 一组元素的迭代器，用于初始化这个表。假设迭代器可以被递增和取消引用足够多的次数来填充这个表。   [2.x.36] C_style_indexing 如果是true，当我们解指输入范围的后续元素时，以最后一个索引变化最快的方式运行该表的元素。如果为假，则最快改变第一个索引。 
* [0.x.58]*
   访问操作符。由于这是一个一维对象，这只是访问所请求的数据元素。返回一个只读的引用。 
* [0.x.59]*
   访问操作符。由于这是一个一维的对象，这只是访问所请求的数据元素。返回一个读-写引用。 
* [0.x.60]*
   访问操作符。由于这是一个一维的对象，这只是访问所请求的数据元素。返回一个只读的引用。 
* [0.x.61]*
   访问操作符。由于这是一个一维的对象，这只是访问所请求的数据元素。返回一个读-写引用。 
* [0.x.62]*
   使基类中的`operator()`的变化可用。 
* [0.x.63]*
 一个用于Table<2, T>和TransposeTable的迭代器和访问器的命名空间。这些类有特殊的访问器（也就是说，与Table<3, T>相比），因为它们有一个类似矩阵的结构；也就是说，访问器也提供行和列的信息，并被设计为与SparseMatrix和SparsityPattern迭代器类兼容。

* 
* [0.x.64]*
  
* [2.x.37] 表类的布局）。 
* [0.x.65]*
     数据以行为主（即C风格）的顺序组织。   
* [0.x.66]*
     数据以列为主（即Fortran风格）的顺序组织。   
* [0.x.67]*
  
* [2.x.38] [2.x.39]的两个值。 
* [0.x.68]*
  
* [2.x.40] 该类与LinearIndexIterator中描述的对%Accessor的要求兼容。关于迭代器和访问器之间的分割描述，请参见该类的文档。     [2.x.41] TableType %Table的类型，例如，Table<2, T>或TransposeTable。     [2.x.42] Constness 这个对象是否存储一个常量指针，并可以修改所提供的表对象。     [2.x.43] storage_order 底层表的存储方案，例如，[2.x.44] 为Table<2, T>。 
* [0.x.69]*
     存储指向表的指针的类型。   
* [0.x.70]*
     底层容器的值类型。   
* [0.x.71]*
     表的行和列索引的数字类型。   
* [0.x.72]*
     默认构造函数。   
* [0.x.73]*
     设置终端迭代器的构造函数。   
* [0.x.74]*
     从非const Accessor复制构造函数。   
* [0.x.75]*
     接受数组索引的构造函数。   
* [0.x.76]*
     比较运算符。   
* [0.x.77]*
     获取该访问器所代表的元素的值的常数引用。   
* [0.x.78]*
     转换操作符，返回元素的常数引用。   
* [0.x.79]*
     返回当前条目的行。   
* [0.x.80]*
     返回当前条目的列。   
* [0.x.81]*
     指向表格的指针。   
* [0.x.82]*
     当前的索引。   
* [0.x.83]*
     检查[2.x.45]是否对应于表实际存储的条目（即断言[2.x.46]为非负数且小于[2.x.47]）。   
* [0.x.84]*
  
* [2.x.48]表。这与基类相同。 
* [0.x.85]*
     使用基类的价值类型。   
* [0.x.86]*
     使用基类的大小类型。   
* [0.x.87]*
     继承基类的构造函数。   
* [0.x.88]*
  
* [2.x.49]一个表格。 
* [0.x.89]*
     使用基类的值类型。   
* [0.x.90]*
     使用基类大小类型。   
* [0.x.91]*
     继承基类的构造函数。   
* [0.x.92]*
     赋值运算符。这将给当前行和列坐标的表项分配一个新值。   
* [0.x.93]*
     移动赋值运算符。在当前的行和列坐标上为表项分配一个新的值。   
* [0.x.94]*
     由于我们重载了value()，我们必须明确地使用基类的版本。   
* [0.x.95]*
     获取该访问器所代表的元素的值的引用。   
* [0.x.96]*
     返回该元素的引用的转换操作符。   
* [0.x.97]*
  
* [2.x.50] TransposeTable.      [2.x.51] TableType %Table的类型，例如，Table<2, T>或TransposeTable。     [2.x.52] Constness 这是否是一个常量迭代器。     [2.x.53] storage_order 底层表的存储方案，例如，[2.x.54] 为Table<2, T>。 
* [0.x.98]*
     底层表使用的大小类型。   
* [0.x.99]*
     存储到表的指针的类型。   
* [0.x.100]*
     来自访问器的构造函数。   
* [0.x.101]*
     构造函数。创建一个表的终端迭代器。   
* [0.x.102]*
     为一个特定的表项的构造函数。   
* [0.x.103]*
     从一个非const迭代器复制构造器。   
* [0.x.104]*
     具有特定线性索引的条目的构造函数。   
* [0.x.105]*
 一个代表二维表的类，即一个对象的矩阵（不一定只有数字）。这个类的大部分接口是在TableBase基类中实现的。关于这个类的原理和接口的概要，请看那里。
* 这个类也是FullMatrix类的基类，因此它有一些专门针对矩阵及其需求的功能。
* 

* 
* [2.x.55] 

* 
* [0.x.106]*
   用来计算这个容器中的元素数量的整数类型。 
* [0.x.107]*
   用于表内数值的类型定义。 
* [0.x.108]*
   表中引用的类型定义。 
* [0.x.109]*
   为表中的常数引用提供类型定义。 
* [0.x.110]*
   为一个常数迭代器提供类型定义，该迭代器以列为主的顺序遍历表。 
* [0.x.111]*
   一个迭代器的类型定义，该迭代器以列的主次顺序遍历表。 
* [0.x.112]*
   默认构造函数。将所有的尺寸设置为零。 
* [0.x.113]*
   构造函数。将给定的尺寸传递给基类。 
* [0.x.114]*
   构造函数。创建一个具有给定尺寸的表，并从一组迭代器中初始化它。    这个函数完全等同于创建一个给定尺寸的表[2.x.56]，然后调用  
* [1.x.8]
*上，使用[2.x.57]函数，其中的参数会有更详细的解释。但问题是，这只有在运行构造函数后可以改变表的情况下才有可能，而调用当前的构造函数可以立即确定对象的大小和初始化，这样就可以将其标记为常量。    使用这个构造函数，你可以做这样的事情。 
* [1.x.9]
* 你也可以使用输入迭代器，从文件中直接初始化一个表。 
* [1.x.10]
* [2.x.58] size1 这个表的第一维的大小。   [2.x.59] size2 这个表在第二维中的大小。   [2.x.60] entries 一个迭代器，用于初始化该表的元素集。假设迭代器可以被递增和取消引用足够多的次数来填充这个表。   [2.x.61] C_style_indexing 如果是true，当我们解指输入范围的后续元素时，以最后一个索引变化最快的方式运行该表的元素。如果为假，则最快改变第一个索引。 
* [0.x.115]*
   重新初始化该对象。这个函数在这里主要是为了与早期的<tt>vector2d</tt>类兼容。通过将参数转换为基类所要求的数据类型而向下传递给基类。 
* [0.x.116]*
   访问操作符。生成一个对象，访问这个二维表的请求行。会进行范围检查。    这个版本的函数只允许读取访问。 
* [0.x.117]*
   访问操作符。生成一个对象，访问这个二维表的请求行。会进行范围检查。    这个版本的函数允许读-写访问。 
* [0.x.118]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数只允许读访问。 
* [0.x.119]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数允许读-写访问。 
* [0.x.120]*
   使基类中的`operator()`的变化可用。 
* [0.x.121]*
   行的数量。由于我们这里有一个二维的对象，所以这个函数真的只有意义。 
* [0.x.122]*
   列的数量。这个函数真的很有意义，因为我们在这里有一个二维的对象。 
* [0.x.123]*
   返回一个指向第一个条目的迭代器。 
* [0.x.124]*
   返回一个指向第一个条目的常数迭代器。 
* [0.x.125]*
   返回一个指向超过最后一个条目的迭代器。 
* [0.x.126]*
   返回一个常数迭代器，指向最后一个条目之后的一个条目。 
* [0.x.127]*
   返回一个对元素<tt>(i,j)</tt>的读写引用。    这个函数不做边界检查，只在内部和已经检查过的函数中使用。    这些函数在这里主要是为了与这些表类以前对2D数组的实现兼容，当时称为<tt>vector2d</tt>。 
* [0.x.128]*
   返回元素<tt>(i,j)</tt>的值，作为一个只读的引用。    这个函数不做边界检查，只在内部和已经检查过的函数中使用。    我们将请求的值作为常量引用而不是按值返回，因为这个对象可能持有的数据类型可能很大，而我们在这里不知道复制是否昂贵。    这些函数在这里主要是为了与这些表类以前对2D数组的实现兼容，当时称为<tt>vector2d</tt>。 
* [0.x.129]*
 一个代表对象（不一定只有数字）的三维表的类。这个类的大部分接口是在TableBase基类中实现的。关于这个类的原理和接口的概要，见那里。
* 

* 
* [2.x.62] 

* 
* [0.x.130]*
   用来计算这个容器中的元素数量的整数类型。 
* [0.x.131]*
   默认构造函数。将所有尺寸设置为零。 
* [0.x.132]*
   构造函数。将给定的尺寸传递给基类。 
* [0.x.133]*
   构造函数。创建一个具有给定尺寸的表，并从一组迭代器中初始化它。    这个函数完全等同于创建一个给定尺寸的表[2.x.63]，然后调用  
* [1.x.11]
*上，使用[2.x.64]函数，其中的参数会有更详细的解释。但问题是，这只有在运行构造函数后可以改变表的情况下才有可能，而调用当前的构造函数可以立即确定对象的大小和初始化，这样就可以将其标记为常量。    使用这个构造函数，你可以做这样的事情（这里显示的是一个二维表，但同样适用于当前类）。 
* [1.x.12]
* 你也可以使用输入迭代器，从文件中直接初始化一个表。 
* [1.x.13]
* [2.x.65] size1 这个表在第一维的大小。   [2.x.66] size2 该表在第二维中的大小。   [2.x.67] size3 此表在第三维中的大小。   [2.x.68] entries 一个迭代器，用于初始化这个表的元素集。假设迭代器可以被递增和取消引用足够多的次数来填充这个表。   [2.x.69] C_style_indexing 如果是true，当我们解指输入范围的后续元素时，以最后一个索引变化最快的方式运行该表的元素。如果为假，则最快改变第一个索引。 
* [0.x.134]*
   访问操作符。生成一个对象，访问这个三维表的请求的二维子对象。会进行范围检查。    这个版本的函数只允许读取访问。 
* [0.x.135]*
   访问操作符。生成一个对象，访问这个三维表的请求的二维子对象。会进行范围检查。    这个版本的函数允许读写访问。 
* [0.x.136]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数只允许读访问。 
* [0.x.137]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数允许读-写访问。 
* [0.x.138]*
   使基类中的`operator()`的变化可用。 
* [0.x.139]*
 一个代表对象的四维表（不一定只有数字）的类。这个类的大部分接口是在TableBase基类中实现的。关于这个类的原理和接口的概要，见那里。
* 

* 
* [2.x.70] 

* 
* [0.x.140]*
   用来计算这个容器中的元素数量的整数类型。 
* [0.x.141]*
   默认构造函数。将所有尺寸设置为零。 
* [0.x.142]*
   构造函数。将给定的尺寸传递给基类。 
* [0.x.143]*
   访问操作符。生成一个对象，访问这个四维表的请求的三维子对象。会进行范围检查。    这个版本的函数只允许读取访问。 
* [0.x.144]*
   访问操作符。生成一个对象，访问这个四维表的所要求的三维子对象。会进行范围检查。    这个版本的函数允许读-写访问。 
* [0.x.145]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数只允许读访问。 
* [0.x.146]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数允许读-写访问。 
* [0.x.147]*
   使基类中的`operator()`的变化可用。 
* [0.x.148]*
 一个代表对象的五维表（不一定只有数字）的类。这个类的大部分接口是在TableBase基类中实现的。关于这个类的原理和接口的概要，见那里。
* 

* 
* [2.x.71] 

* 
* [0.x.149]*
   用来计算这个容器中的元素数量的整数类型。 
* [0.x.150]*
   默认构造函数。将所有尺寸设置为零。 
* [0.x.151]*
   构造函数。将给定的尺寸传递给基类。 
* [0.x.152]*
   访问操作符。生成一个对象，访问这个五维表的请求的四维子对象。会进行范围检查。    这个版本的函数只允许读取访问。 
* [0.x.153]*
   访问操作符。生成一个对象，访问这个五维表的四维子对象。会进行范围检查。    这个版本的函数允许读写访问。 
* [0.x.154]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数只允许读访问。 
* [0.x.155]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数允许读-写访问。 
* [0.x.156]*
   使基类中的`operator()`的变化可用。 
* [0.x.157]*
 一个代表对象的六维表（不一定只有数字）的类。这个类的大部分接口是在TableBase基类中实现的。关于这个类的原理和接口的概要，见那里。
* 

* 
* [2.x.72] 

* 
* [0.x.158]*
   用来计算这个容器中的元素数量的整数类型。 
* [0.x.159]*
   默认构造函数。将所有尺寸设置为零。 
* [0.x.160]*
   构造函数。将给定的尺寸传递给基类。 
* [0.x.161]*
   访问操作符。生成一个对象，访问这个六维表的五维子对象的请求。会进行范围检查。    这个版本的函数只允许读取访问。 
* [0.x.162]*
   访问操作符。生成一个对象，访问这个六维表的五维子对象的请求。会进行范围检查。    这个版本的函数允许读写访问。 
* [0.x.163]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数只允许读访问。 
* [0.x.164]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数允许读-写访问。 
* [0.x.165]*
   使基类中的`operator()`的变化可用。 
* [0.x.166]*
 一个代表对象的七维表（不一定只有数字）的类。这个类的大部分接口是在TableBase基类中实现的。关于这个类的原理和接口的概要，见那里。
* 

* 
* [2.x.73] 

* 
* [0.x.167]*
   用来计算这个容器中的元素数量的整数类型。 
* [0.x.168]*
   默认构造函数。将所有尺寸设置为零。 
* [0.x.169]*
   构造函数。将给定的尺寸传递给基类。 
* [0.x.170]*
   访问操作符。生成一个对象，访问这个七维表的六维子对象的请求。会进行范围检查。    这个版本的函数只允许读取访问。 
* [0.x.171]*
   访问操作符。生成一个对象，访问这个七维表的六维子对象的请求。会进行范围检查。    这个版本的函数允许读写访问。 
* [0.x.172]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数只允许读访问。 
* [0.x.173]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数允许读-写访问。 
* [0.x.174]*
   使基类中的`operator()`的变化可用。 
* [0.x.175]*
 一个代表转置二维表的类，即一个对象（不一定只有数字）的矩阵，采用列首编号（FORTRAN惯例）。因此，唯一真正的区别其实是在存储格式上。
* 这个类复制了Table<2,T>的功能，但是元素访问和尺寸将用于TableBase中的数据字段的转置排序。
* 

* 
* [2.x.74] 

 
* [0.x.176]*
   用来计算这个容器中的元素数量的整数类型。 
* [0.x.177]*
   用于表内数值的类型化定义。 
* [0.x.178]*
   表中引用的类型定义。 
* [0.x.179]*
   为表中的常数引用提供类型定义。 
* [0.x.180]*
   为一个常数迭代器提供类型定义，该迭代器以列为主的顺序遍历表。 
* [0.x.181]*
   一个迭代器的类型定义，该迭代器以列的主次顺序遍历表。 
* [0.x.182]*
   默认构造函数。将所有的尺寸设置为零。 
* [0.x.183]*
   构造函数。将给定的尺寸传递给基类。 
* [0.x.184]*
   重新初始化该对象。这个函数在这里主要是为了与早期的<tt>vector2d</tt>类兼容。通过将参数转换为基类所要求的数据类型而向下传递给基类。 
* [0.x.185]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数只允许读取访问。 
* [0.x.186]*
   通过同时指定所有索引，直接访问表中的一个元素。会进行范围检查。    这个版本的函数允许读-写访问。 
* [0.x.187]*
   行的数量。由于我们这里有一个二维对象，所以这个函数真的只有意义。 
* [0.x.188]*
   列的数量。这个函数真的很有意义，因为我们在这里有一个二维的对象。 
* [0.x.189]*
   返回一个指向第一个条目的迭代器。 
* [0.x.190]*
   返回一个指向第一个条目的常数迭代器。 
* [0.x.191]*
   返回一个指向超过最后一个条目的迭代器。 
* [0.x.192]*
   返回一个常数迭代器，指向最后一个条目之后的一个条目。 
* [0.x.193]*
   返回一个对元素<tt>(i,j)</tt>的读写引用。    这个函数不做边界检查，只在内部和已经检查过的函数中使用。    这些函数在这里主要是为了与这些表类以前对2D数组的实现兼容，当时称为<tt>vector2d</tt>。 
* [0.x.194]*
   返回元素<tt>(i,j)</tt>的值，作为一个只读的引用。    这个函数不做边界检查，只在内部和已经检查过的函数中使用。    我们将请求的值作为常量引用而不是按值返回，因为这个对象可能持有的数据类型可能很大，而我们在这里不知道复制是否昂贵。    这些函数在这里主要是为了与这些表类以前对2D数组的实现兼容，当时称为<tt>vector2d</tt>。 
* [0.x.195]*
 全局函数[2.x.75]，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个表的数据。

* 
* [0.x.196]

