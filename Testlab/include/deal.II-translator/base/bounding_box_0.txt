include/deal.II-translator/base/bounding_box_0.txt
[0.x.0]*
 枚举器NeighborType描述了两个界线盒之间的相邻关系。

* 
* [0.x.1]*
   不相邻：相交处为空。 
* [0.x.2]*
   简单相邻：盒子与一个维度最多为`spacedim的交点相交。
* 
* - 2`. 例如，在2d中，这意味着两个盒子在每个盒子的一个角上相接触。 
* [0.x.3]*
   附着的邻居：与`维度>spacedim的相交的邻居
* 
* - 2`. 例如，在2d中，这意味着两个盒子沿着一条边接触。 
* [0.x.4]*
   可合并的邻居：可以用一个BoundingBox来表示的邻居，比如说   
* [1.x.0]
* 或者一个在另一个里面  
* [0.x.5]*
 一个表示任意尺寸<tt>spacedim</tt>且边与坐标轴平行的盒子的类，也就是一个区域
* [1.x.1]
* 其中[2.x.0] (x_0^U , ..., x_{spacedim-1}^U)表示两个顶点（左下和右上），用于表示盒子。
* 从几何学上看，一个边界盒就是这样。
* 

* 
* 
* - 1D：一个线段（由其顶点按适当顺序表示
* 

* 
* 
* - 二维：一个长方形（由左下角和右上角的顶点V代表）。

* 
* [1.x.2]
* 
* 

* 
* 
* - 三维：长方体（在这种情况下，两个顶点V遵循惯例，不属于同一个面）。

* 
* [1.x.3]
* 
* 例如，边界盒在平行分布的网格中很有用，可以对网格的每一部分的所有者进行一般描述。
* 将BoundingBox<spacedim>的横截面与给定的方向正交，可以得到一个低一维的盒子：BoundingBox<spacedim
* 
* - 1>. 在三维中，BoundingBox<3>横截面的两个坐标可以用两种不同的方式排序。也就是说，如果我们将横截面与y方向正交，我们可以将3D坐标排序为[2.x.1]或[2.x.2] 的2D坐标。本类使用第二种约定，对应于坐标的循环排序[2.x.3] 准确地说，如果我们取一个横截面。
* 正交于 * 横截面坐标排序为 | |:-------------:|:------------------------------------:| | x | (y, z) | y | (z, x) | z | (x, y)
* 这是根据函数[2.x.4]所设定的惯例。

* 
* [0.x.6]*
   标准构造函数。创建一个对应于空盒子的对象，即一个两点都是原点的退化盒子。 
* [0.x.7]*
   非空盒子的标准构造函数：它使用一对描述盒子的点：一个是底角，一个是顶角。 
* [0.x.8]*
   构建包围给定容器中所有点的包围盒。    该构造函数支持任何为Point<spacedim, Number>元素提供begin()和end()遍历器的容器。 
* [0.x.9]*
   返回一个对边界点的引用  
* [0.x.10]*
   返回一个对边界点的常量引用  
* [0.x.11]*
   测试是否相等。 
* [0.x.12]*
   测试不等式。 
* [0.x.13]*
   检查当前对象和[2.x.5]是否为邻居，也就是说，如果盒子的尺寸为spacedim，检查它们的交集是否为非空。    返回一个NeighborType类型的枚举器。 
* [0.x.14]*
   扩大当前对象，使其包含 [2.x.6] 。  如果当前对象已经包含[2.x.7]，那么它不会被这个函数所改变。 
* [0.x.15]*
   如果点在包围盒内，返回真，否则返回假。参数[2.x.8]是一个系数，相对于包围盒的尺寸来说，包围盒被放大了，以便以一种数字上稳健的方式确定该点是否在里面。 
* [0.x.16]*
   按给定的数量增加（或减少）边界框的大小。  调用此方法后，边界框的左下角的每个坐标将减少[2.x.9]，边界框的右上角的每个坐标将增加[2.x.10] 如果你用一个负数调用此方法，并且原始边界框的一个轴小于 amount/2，此方法将触发一个断言。 
* [0.x.17]*
   计算BoundingBox的体积（即二维度量）。 
* [0.x.18]*
   返回盒子中心的点。 
* [0.x.19]*
   返回盒子的边长，单位是[2.x.11]。  
* [0.x.20]*
   返回盒子的下限，单位为[2.x.12]。  
* [0.x.21]*
   返回[2.x.13]中的盒子的上界   
* [0.x.22]*
   返回[2.x.14]中的盒子的边界，作为一个一维的盒子。 
* [0.x.23]*
   返回盒子的第索引顶点。顶点的含义与单元格的含义相同，因此，[2.x.15] [2.x.16] .  
* [0.x.24]*
   返回盒子的第1个子节点。子项的含义与单元格的含义相同。 
* [0.x.25]*
   返回正交于[2.x.17]的盒子的横截面，这是一个低一维的盒子。   
* [2.x.18]在一维中调用此方法将导致一个异常，因为[2.x.19]没有实现。 
* [0.x.26]*
   应用仿射变换，将此BoundingBox转换为一个单元BoundingBox对象。    如果[2.x.20]是这个边界盒，而[2.x.21]是单位边界盒，计算满足[2.x.22]的仿生映射并将其应用于[2.x.23]。  
* [0.x.27]*
   应用将单位BoundingBox对象转换为该对象的仿射变换。    如果[2.x.24]是这个边界盒，而[2.x.25]是单位边界盒，计算满足[2.x.26]的仿生映射并将其应用于[2.x.27]。  
* [0.x.28]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据写入或读出到一个流中，以便进行序列化。 
* [0.x.29]*
 这个类的存在是为了实现与尺寸无关的编程，但在其构造函数中无条件地抛出一个异常。

* 
* [0.x.30]*
   默认构造函数。抛出一个异常。 
* [0.x.31]*
   等价的两点式构造函数。抛出一个异常。 
* [0.x.32]*
   等效的容器构造函数。抛出一个异常。 
* [0.x.33]*
 返回单位盒子 [2.x.28] 。
* [2.x.29] BoundingBox

* 
* [0.x.34]*
   这个函数定义了一个惯例，当dim+1维中的一个坐标被锁定为一个给定值时，dim维中的坐标应该如何转换为dim+1维中的坐标。    这个约定是这样的。从锁定的坐标开始，我们连续存储低维的坐标，并在越过维度时进行环绕。这种关系是，在二维中，|锁定在二维中|一维坐标|二维坐标||:------------:|:-------------:|:-------------:||x0|(a)|(x0, a)||x1|(a)|(a , x1)|，在三维中，|锁定在三维|二维坐标|三维坐标||:-------------|。 --------------:|:--------------:| | x0 | (a, b) | (x0, a, b) | | x1 | (a, b) | ( b, x1, a) | | x2 | (a, b) | ( a, b, x2) | 给定一个锁定坐标，这个函数将dim维度的坐标索引映射到dim+1维度的坐标索引。     [2.x.30] locked_coordinate应该在[0, dim+1]范围内。   [2.x.31] coordinate_in_dim应该在[0, dim]范围内。   [2.x.32] 在[0, dim+1]范围内的一个坐标索引 [2.x.33] BoundingBox  
* [0.x.35]

