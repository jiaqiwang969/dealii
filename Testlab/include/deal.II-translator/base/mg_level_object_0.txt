include/deal.II-translator/base/mg_level_object_0.txt
[0.x.0]*
 这个类代表了一个数组，在多级层次结构中，每个使用的层次都有一个对象，例如用于多栅格算法。与一般的[2.x.0]相比，这个类只允许存储一些最小和最大索引（=level）之间的对象，因为人们经常希望只在网格的一个子集上运行多层次算法（例如，因为第二或第三层最粗的层次已经足够小，在那里运行直接求解器比递归到更粗的层次要便宜）。尽管只为这些 "有趣的 "层次存储对象，该类允许简单地按层次进行索引。在内部，这当然是通过简单地将给定的索引移到我们所存储的最小级别来实现的。
* 在这个类的一个典型的使用案例中，每个层次上存储的对象都是矩阵或向量。
* 

* 
* [2.x.1] 

* 
* [2.x.2] 

 
* [0.x.1]*
   构造函数。创建一个具有给定最小和最大级别的多级对象，并为[2.x.3]级别的对象分配存储空间。   
* [2.x.4] 与库中的许多其他地方不同，这里的两个参数并不表示第一级和最后加一级的级别，而是实际上是一个[1.x.0]的级别范围，为级别对象分配存储器。因此，这两个参数的默认值将创建一个有一个级别对象的数组，而不是一个空数组。     [2.x.5] minlevel 为级别对象提供内存的最低级别。   [2.x.6] maxlevel 为级别对象提供内存的最高级别。   [2.x.7] args 传递给底层对象构造器的可选参数。     [2.x.8] minlevel <= maxlevel  
* [0.x.2]*
   构造函数。与上述相同，但没有转给底层对象构造器的参数。 
* [0.x.3]*
   访问级别为[2.x.9]的对象。  
* [0.x.4]*
   访问[2.x.10]级别的对象 这个函数可以在[2.x.11]对象上调用，并因此返回一个[2.x.12]引用。 
* [0.x.5]*
   删除此对象以前的所有内容，并根据[2.x.13]和[2.x.14]的值重置其大小 [2.x.15] new_minlevel 为级别对象提供内存的最低级别。   [2.x.16] new_maxlevel 为级别对象提供内存的最高级别。   [2.x.17] args 传递给底层对象构造器的可选参数。     [2.x.18] minlevel <= maxlevel  
* [0.x.6]*
   对这个对象存储的所有对象调用<tt>operator = (s)</tt>。  这显然要求存储在每个级别上的对象允许这个操作。特别是对于向量和矩阵来说，如果[2.x.19]为零，从而将所有向量或矩阵条目清零，这一点是正确的。 
* [0.x.7]*
   对这个对象存储的所有对象调用[2.x.20]。这个函数只对一些[2.x.21]类实现，例如，矩阵类型或PreconditionBlockSOR和类似的类。如果这个类的[2.x.22]模板类型没有提供[2.x.23]的成员函数，使用这个函数会出现编译器错误。 
* [0.x.8]*
   该类存储水平对象的最粗略的水平。 
* [0.x.9]*
   该类存储水平对象的最高水平。 
* [0.x.10]*
   对存储在这里的每个对象应用[2.x.24]的动作。参数[2.x.25]应该是一个接受<code> action(const unsigned int level, Object &object); </code> 语法的函数对象，这意味着这个函数可以接受一个lambda，一个[2.x.26]或一个普通函数指针。 
* [0.x.11]*
   这个对象所使用的内存。 
* [0.x.12]*
   第一个组件的级别。 
* [0.x.13]*
   要保存的对象的数组。 
* [0.x.14]

