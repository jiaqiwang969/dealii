include/deal.II-translator/base/mpi_noncontiguous_partitioner_0.txt
[0.x.0]*
     一个灵活的Partitioner类，它不对基础索引集的顺序进行限制。   
* [0.x.1]*
       默认构造函数。需要调用reinit()函数之一来创建一个有效的对象。     
* [0.x.2]*
       构造函数。根据MPI通信器[2.x.0]和[2.x.1]的IndexSets参数设置点对点通信模式。      
* [0.x.3]*
       构造函数。与上述相同，但对于索引为[2.x.3]和[2.x.4]的向量，这允许索引不被排序，并且在update_values()、update_values_start()和update_values_finish()期间自动在向量的正确位置读写值。允许包括值为[2.x.5]的条目，这些条目不占索引交换的一部分，但作为填充存在于数据向量中。     
* [0.x.4]*
       根据预先计算的通信模式，用来自[2.x.7][2.x.8]的值填充向量[2.x.6]，向量只需提供一个方法begin()，允许访问其原始数据。             [2.x.9] 两个向量的大小必须至少与传递给构造函数或reinit()函数的索引集的条目数一样大。           
* [2.x.10] 这个函数依次调用了 update_values_start() 和 update_values_finish() 方法。用户可以单独调用这两个函数，从而使通信和计算重叠。     
* [0.x.5]*
       同上，但接口与[2.x.11]和[2.x.12]类似 在这个函数中，用户可以提供要使用的临时数据结构。             [2.x.13] [2.x.14] 向量的大小必须至少是temporary_storage_size。其原因是这个向量被用作发送和接收数据的缓冲区。           
* [2.x.15]任何小于10的值都是[2.x.16]的有效值。      
* [0.x.6]*
       开始更新：数据被打包，非阻塞的发送和接收开始。           
* [2.x.17] 与函数[2.x.18]相比，用户不传递对目标向量的引用，因为数据被接收到缓冲区的指定部分 [2.x.19] 这允许对接收的数据进行填充和其他后处理。             [2.x.20] 向量的要求大小与上面的函数相同。           
* [2.x.21] 任何小于10的值都是[2.x.22]的有效值。      
* [0.x.7]*
       完成更新。该方法一直等待，直到所有数据都被发送和接收。一旦收到来自任何进程的数据，它将被处理并放置在向量[2.x.23]的正确位置。            
* [2.x.24] 与函数[2.x.25]相比，用户还必须传递对缓冲区[2.x.26]的引用，因为数据已经被接收到缓冲区而不是目标向量中。             [2.x.27] 向量的要求大小与上面的函数相同。     
* [0.x.8]*
       返回本进程发送数据的进程数和本进程接收数据的进程数。     
* [0.x.9]*
       返回export_to_ghosted_array()函数所需的临时存储的大小，如果临时存储是由用户代码处理的。     
* [0.x.10]*
       以Byte为单位返回内存消耗。     
* [0.x.11]*
       返回底层通信器。     
* [0.x.12]*
       初始化内部数据结构。     
* [0.x.13]*
       初始化内部数据结构。     
* [0.x.14]*
       MPI通信器。     
* [0.x.15]*
       这个进程发送数据的行列。     
* [0.x.16]*
       send_buffer内每个进程的偏移量。           
* [2.x.28]与`send_indices`一起构成一个CRS数据结构。     
* [0.x.17]*
       send_buffer中每个条目在目标向量中的本地索引。           
* [2.x.29] 与`send_ptr`一起构成一个CRS数据结构。     
* [0.x.18]*
       这个进程接收数据的行列。     
* [0.x.19]*
       recv_buffer中每个进程的偏移量。           
* [2.x.30]与`recv_indices`一起构成一个CRS数据结构。     
* [0.x.20]*
       recv_buffer中每个条目在目标向量中的本地索引。           
* [2.x.31]与`recv_ptr`一起构成一个CRS数据结构。     
* [0.x.21]*
       包含按等级排序的数值的缓冲区，用于发送和接收。           
* [2.x.32] 只有在用户不提供外部的情况下才会分配。           
* [2.x.33] 在这个地方我们不知道要发送的数据的类型。所以我们使用一个大小为1字节的任意类型。在相关的函数中，该类型被转换为要求的类型。     
* [0.x.22]*
       发送和接收的MPI请求。           
* [2.x.34]只有在用户不从外部提供的情况下才分配。     
* [0.x.23]

