include/deal.II-translator/base/index_set_0.txt
[0.x.0]*
 一个代表较大集合中的一个索引子集的类。例如，它可以用来表示在[2.x.0]范围内属于某个特定子域的自由度集合，或者在分布式并行计算中存储在某个特定处理器上的所有自由度中的自由度。
* 这个类可以表示半开范围的指数集合，也可以表示单个元素。为实用起见，它还存储了这些指数可以承担的总体范围。换句话说，你需要指定索引空间的大小[2.x.1]，这个类的对象是其中的一个子集。
* 有两种方法可以在IndexSets上进行迭代。首先，begin()和end()允许对集合中的单个索引进行迭代。第二，begin_interval()和end_interval()允许对上述的半开范围进行迭代。
* 这个类中使用的数据结构以及原理可以在[2.x.2]"分布式计算论文 "中找到。

* 
* [0.x.1]*
    [2.x.3]是用于存储索引集的大小和单个条目的类型。 
* [0.x.2]*
   我们可以把 IndexSet 看作是 size() 的容器，其中容器的元素是 bool 值，这些元素要么是假的，要么是真的，取决于某个特定的索引是否是 IndexSet 的一个元素。换句话说，IndexSet 有点像一个矢量，其中我们存储的元素是布尔值。另一方面，[2.x.5]的缺点是它不是一个数字类型，例如，它不允许与[2.x.6]相乘。换句话说，在一个允许使用其他向量的地方，我们不能轻易使用一个布尔的向量。因此，我们声明这样一个向量的元素的类型是有符号的整数。这是因为在C++语言中，booleans可以隐含地转换为整数。换句话说，将向量元素的类型声明为有符号整数只是一个小谎言，但它是一个有用的谎言。 
* [0.x.3]*
   默认构造函数。 
* [0.x.4]*
   构造函数，也设置了索引范围的整体大小。 
* [0.x.5]*
   复制构造函数。 
* [0.x.6]*
   拷贝赋值操作符。 
* [0.x.7]*
   移动构造函数。通过转移输入集的内部数据来创建一个新的IndexSet。 
* [0.x.8]*
   移动赋值运算符。将输入集的内部数据转移到当前集中。 
* [0.x.9]*
   来自Trilinos Epetra_BlockMap的构造函数。 
* [0.x.10]*
   从这个索引集中删除所有的索引。然而，索引集仍保留其大小。 
* [0.x.11]*
   设置这个对象所操作的索引的最大尺寸。    这个函数只有在索引集还不包含任何元素时才能被调用。 这可以通过调用clear()来实现，比如说。 
* [0.x.12]*
   返回这个索引集是其子集的索引空间的大小。    注意，这个结果不等于这个索引集内的索引数。后者的信息是由n_elements()返回的。 
* [0.x.13]*
   将半开范围[2.x.7]添加到该类所代表的索引集合中。   [2.x.8] 开始 要添加的范围的第一个元素。   [2.x.9] 结束 要添加的范围的过末元素。 
* [0.x.14]*
   将一个单独的索引添加到索引集合中。 
* [0.x.15]*
   添加一整组索引，通过取消引用迭代器范围的每个元素来描述 [2.x.10] 。     [2.x.11] 开始 迭代器到要添加的索引范围的第一个元素 [2.x.12] 结束 要添加的元素范围的过去-结束迭代器。 [2.x.13] 需要满足条件[2.x.14]。 
* [0.x.16]*
   将给定的索引集[2.x.15]添加到当前的索引集，构建this和[2.x.16]的联合体 如果[2.x.17]参数为非零，那么[2.x.18]中的每个索引在被添加到当前索引集之前都会被[2.x.19]移位。例如，这允许从其他几个应该代表不同范围的索引集中构建一个索引集（例如，当从一个向量的各个块的非零元素集中构建一个块向量的非零条目集时）。    如果[2.x.20]索引集的任何索引（可能是移位的）位于当前对象所代表的[2.x.21]范围之外，这个函数将产生一个异常。 
* [0.x.17]*
   返回指定索引是否是索引集的一个元素。 
* [0.x.18]*
   返回这个对象所存储的索引集是否定义了一个连续的范围。如果根本没有存储任何索引，这也是真的。 
* [0.x.19]*
   返回这个对象所存储的索引集是否不包含任何元素。  这类似于，但比检查 [2.x.22] 要快。 
* [0.x.20]*
   返回IndexSets是否相对于MPI进程号是升序的，并且是1:1，也就是说，每个索引正好包含在一个IndexSet中（在不同进程上存储的索引中），每个进程存储连续的索引子集，并且进程 [2.x.23] 上的索引集开始于比进程 [2.x.24] 上存储的最后一个索引大的索引。  在只有一个MPI进程的情况下，这仅仅意味着索引集已经完成。 
* [0.x.21]*
   返回存储在这个索引集中的元素的数量。 
* [0.x.22]*
   返回存储在这个索引集中的编号为[2.x.25]的局部索引的全局索引。 [2.x.26] 显然需要小于n_elements()。 
* [0.x.23]*
   返回这个集合的第多少个元素（按升序计数） [2.x.27] global_index是。 [2.x.28]需要小于size()。如果索引[2.x.30]实际上不是这个索引集的成员，即如果is_element(global_index)是假的，这个函数返回[2.x.29]。 
* [0.x.24]*
   每个索引集可以表示为若干个连续的索引区间的联合，如果有必要，区间可以只由单个元素组成，以表示索引集的孤立成员。    这个函数返回代表所考虑的索引集所需的最小数量的这种区间。 
* [0.x.25]*
   该函数返回最大区间开始的局部索引。    换句话说，返回值是nth_index_in_set(x)，其中x是IndexSet中最大连续范围的第一个索引。因此，返回值等于集合中在最大范围之前的元素的数量。    这个调用假定IndexSet是不空的。 
* [0.x.26]*
   通过合并具有连续范围的单个元素来压缩内部表示，等等。这个函数没有任何外部影响。 
* [0.x.27]*
   对索引集的平等进行比较。这个操作只允许在两个集合的大小相同的情况下进行（当然它们不一定要有相同数量的索引）。 
* [0.x.28]*
   索引集不平等的比较。这个操作只允许在两个集合的大小相同的情况下进行（当然它们不一定要有相同的索引数）。 
* [0.x.29]*
   返回当前索引集和所给参数的交集，即一组索引是两个索引集的元素。这两个索引集必须具有相同的大小（当然，它们不一定具有相同的索引数）。 
* [0.x.30]*
   这个命令接收一个区间<tt>[begin, end)</tt>，并返回当前索引集与该区间的交集，移到<tt>[0, end-begin)</tt>范围。    换句话说，这个操作的结果是当前对象所代表的集合与区间<tt>[begin, end)</tt>的交集，如[1.x.0]所见，将交集操作的结果向左移动<tt>begin</tt>。这对应于一个[1.x.1]的概念。区间<tt>[begin, end)</tt>是一个[1.x.2]，通过它我们可以看到当前对象所代表的集合。 
* [0.x.31]*
   将此对象所代表的集合指数分割成由[2.x.31]结构给出的块。其条目之和必须与当前对象的全局大小一致。 
* [0.x.32]*
   从这个集合中移除[2.x.32]中包含的所有元素。换句话说，如果[2.x.33]是当前对象，[2.x.34]是参数，那么我们计算[2.x.35] 。 
* [0.x.33]*
   返回一个新的IndexSet，全局大小等于`this->size()*other.size()`，对于这个IndexSet的每个元素`n`，包含[2.x.36]IndexSet的半开放范围`[n*other.size(), (n+1)*other.size()]中的条目。    这个名字来自于这样的观点：我们从一个IndexSet开始，与另一个有`other.size()`元素的IndexSet进行张量乘积；这将产生一个大小为`this->size()`乘以`other.size()`的矩阵，在这个IndexSet包含一个索引的行和[2.x.37] IndexSet包含一个索引的列中有1。然后，这个矩阵被再次 "解卷"，逐一浏览每一行，并以连续的顺序对矩阵的条目重新进行索引。矩阵中的 "1 "对应于重新索引的IndexSet中的一个条目，这个函数将返回该条目。 
* [0.x.34]*
   删除并返回最后一个范围的最后一个元素。  如果IndexSet是空的，这个函数会抛出一个异常。 
* [0.x.35]*
   删除并返回第一个区域的第一个元素。  如果IndexSet是空的，这个函数会抛出一个异常。 
* [0.x.36]*
   用这个IndexSet中包含的所有索引填充给定的向量。 
* [0.x.37]*
   用零或一的元素填充给定的向量，提供这个索引集的二进制表示。假设给定的向量已经有了正确的大小。    给定的参数用整数值0和1填充，使用[2.x.38] 。因此，只要允许将零和一的整数转换为向量的元素，任何具有这种操作符的对象都可以被使用。具体来说，对于类Vector、BlockVector，以及[2.x.39] [2.x.40]和[2.x.41]都是这样的情况。  
* [0.x.38]*
   将此IndexSet的文本表示法输出到给定的流中。用于测试。 
* [0.x.39]*
   将IndexSet写成基于文本的文件格式，可以用read()函数再次读入。 
* [0.x.40]*
   从由write()函数写入的流[2.x.42]给出的基于文本的表示法中构建IndexSet。 
* [0.x.41]*
   将 IndexSet 写入一个二进制的、紧凑的表示法，可以使用 block_read() 函数再次读入。 
* [0.x.42]*
   从由write_block()函数写入的流[2.x.43]给出的二进制表示法中构造IndexSet。 
* [0.x.43]*
   给定一个MPI通信器，创建一个Trilinos map对象，该对象表示向量元素或矩阵行的分布，我们将在其中本地存储那些我们在当前索引集中存储索引的元素或行，而所有其他元素/行则在其他MPI进程之一上的其他地方。    最后一个参数只有在通信器是一个并行的通信器，将计算分布在多个处理器上时才起作用。在这种情况下，如果最后一个参数是假的，那么就假定在所有处理器上调用这个函数的索引集是互斥的，但一起列举每个索引时正好是一次。换句话说，如果你在两个处理器上调用这个函数，那么这个函数被调用的索引集必须一起拥有从0到size()-1的所有可能的索引，并且没有索引必须出现在两个索引集中。例如，这相当于我们要把向量的元素分成独特的子集，存储在不同的处理器上的情况
* 
* - 任何元素都不应被一个以上的处理器所拥有，但每个元素必须被一个处理器所拥有。    另一方面，如果第二个参数为真，那么索引集可以是重叠的，它们也不需要横跨整个索引集。如果我们想创建的向量不仅包含本地拥有的索引，而且还包含对应于位于幽灵单元上的自由度的元素，那么这是一个有用的操作。这个方法的另一个应用是选择一个向量的元素子集，例如，只提取某些解的成分。 
* [0.x.44]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.45]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据写入或读出到一个流中，以便进行序列化。 
* [0.x.46]*
    [2.x.44] 迭代器 [2.x.45].   
* [0.x.47]*
   解除对IntervalIterator的引用将返回对该类型对象的引用。它允许访问被迭代的IndexSet的一个连续的区间[2.x.46]（也称为范围）。 
* [0.x.48]*
     给出一个IndexSet和要指向的范围的索引[2.x.47]，构造一个有效的访问器。   
* [0.x.49]*
     为IndexSet构造一个无效的访问器。   
* [0.x.50]*
     这个区间内的元素数量。   
* [0.x.51]*
     如果为真，我们就指向IndexSet中的一个有效区间。   
* [0.x.52]*
     返回一个迭代器，指向这个区间的第一个索引。   
* [0.x.53]*
     返回一个直接指向该区间最后一个索引之后的迭代器。   
* [0.x.54]*
     返回这个区间的最后一个索引的索引。   
* [0.x.55]*
     私有的复制构造函数。   
* [0.x.56]*
     私有的复制操作符。   
* [0.x.57]*
     平等测试，由IntervalIterator使用。   
* [0.x.58]*
     小于运算符，由IntervalIterator使用。   
* [0.x.59]*
     推进这个访问器，指向[2.x.48]index_set中的下一个区间。   
* [0.x.60]*
     对IndexSet的引用。   
* [0.x.61]*
     进入index_set. ranges[]的索引。如果无效，则设置为[2.x.49]，或者结束迭代器。   
* [0.x.62]*
   表示指向由[2.x.51]返回的连续区间[2.x.50]的迭代器的类。  
* [0.x.63]*
     构建一个有效的迭代器，指向索引为[2.x.52] range_idx的区间。   
* [0.x.64]*
     构建一个无效的迭代器（作为end()使用）。   
* [0.x.65]*
     构建一个空的迭代器。   
* [0.x.66]*
     从[2.x.53]迭代器复制构造函数。   
* [0.x.67]*
     对另一个迭代器进行赋值。   
* [0.x.68]*
     前缀增量。   
* [0.x.69]*
     后缀增量。   
* [0.x.70]*
     撤消运算符，返回一个IntervalAccessor。   
* [0.x.71]*
     去引用操作符，返回一个指向IntervalAccessor的指针。   
* [0.x.72]*
     比较。   
* [0.x.73]*
     <tt>==</tt>的倒数。   
* [0.x.74]*
     比较运算符。   
* [0.x.75]*
     返回当前迭代器与参数之间的距离。这个距离是通过对当前迭代器应用operator++多少次才能得到参数（对于一个正的返回值），或operator--（对于一个负的返回值）。   
* [0.x.76]*
     将该类标记为前向迭代器，并声明一些别名，这些别名是迭代器的标准，被算法用来查询它们所工作的迭代器的具体内容。   
* [0.x.77]*
     访问器，包含了我们所指向的IndexSet和间隔的内容。   
* [0.x.78]*
   表示指向IndexSet中单个元素的迭代器的类，如[2.x.54]返回的那样。  
* [0.x.79]*
     在区间[2.x.56]内构造一个指向全局索引[2.x.55]的迭代器。    
* [0.x.80]*
     构建一个指向IndexSet末端的迭代器。   
* [0.x.81]*
     去引用操作符。返回值是IndexSet中元素的索引。   
* [0.x.82]*
     这个迭代器是否指向一个现有的元素？   
* [0.x.83]*
     前缀增量。   
* [0.x.84]*
     后缀增量。   
* [0.x.85]*
     比较。   
* [0.x.86]*
     <tt>==</tt>的倒数。   
* [0.x.87]*
     比较运算符。   
* [0.x.88]*
     返回当前迭代器与参数之间的距离。在表达式[2.x.57]中，距离是由对右操作数[2.x.58] it_right应用operator++多少次才能得到左操作数[2.x.59]（对于正返回值），或者对[2.x.60]应用多少次才能得到[2.x.61]（对于负返回值）而给出。   
* [0.x.89]*
     将该类标记为前向迭代器，并声明一些别名，这些别名是迭代器的标准，被算法用来查询它们所工作的迭代器的具体信息。   
* [0.x.90]*
     将迭代器提前一个。   
* [0.x.91]*
     父索引集。   
* [0.x.92]*
     索引到index_set. ranges。   
* [0.x.93]*
     这个迭代器所指向的全局索引。   
* [0.x.94]*
   返回一个迭代器，指向这个IndexSet中包含的第一个索引。 
* [0.x.95]*
   返回一个指向全局索引[2.x.62]的元素的迭代器，如果该索引不在集合中，则指向下一个更大的元素。这等同于  
* [1.x.3]
* 如果在这个IndexSet中没有位于[2.x.63]或后面的元素，这个方法将返回end()。 
* [0.x.96]*
   返回一个迭代器，该迭代器指向这个IndexSet中包含的最后一个索引之后。 
* [0.x.97]*
   返回一个迭代器，该迭代器指向此IndexSet的第一个区间。 
* [0.x.98]*
   返回一个指向此IndexSet的最后一个区间后的迭代器。 
* [0.x.99]*
    [2.x.64]   
* [0.x.100]*
   一个表示半开索引范围的类型 [2.x.65] 。    nth_index_in_set表示当前范围的第一个元素在这个IndexSet中的第几个索引。只有当[2.x.66]在最后一次插入后被调用，这个信息才是准确的。 
* [0.x.101]*
     默认构造函数。由于默认构造的区间没有有用的选择，这个构造函数简单地创建了类似于一个无效区间的东西。我们需要这个构造函数来进行序列化，但是无效区间在使用之前应该用从存档中读取的东西来填充，所以我们应该希望永远不会在野外看到一个无效区间。   
* [0.x.102]*
     构造函数。用给定的指数创建一个半开放的区间。         [2.x.67] i1 区间的左端点。     [2.x.68] i2 大于指定范围最后一个索引的第一个索引。   
* [0.x.103]*
     为了使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)进行序列化，将此对象的数据写入或读出到一个流中。   
* [0.x.104]*
   一组连续的索引范围，构成了这个索引集的（一部分）。这个变量总是保持排序。    这个变量被标记为 "可变"，因此它可以被compress()改变，当然这并不改变这个索引集的外部表示。 
* [0.x.105]*
   如果compress()在索引集的最后一次改变后被调用，则为真。    该变量被标记为 "可变"，因此它可以被compress()改变，当然这并不改变这个索引集的外部表示。 
* [0.x.106]*
   索引范围的总体大小。这个索引集的元素必须有一个比这个值小的数字。 
* [0.x.107]*
   这个整数缓存了[2.x.69]中最大范围的索引，这给了<tt>O(1)</tt>对具有最多元素的范围的访问，而一般的访问成本<tt>O(log(n_ranges))</tt>。最大的范围需要用于[2.x.70] [2.x.71] [2.x.72]的方法。在许多应用中，最大的范围包含大多数元素（本地拥有的范围），而只有少数其他元素（幽灵）。 
* [0.x.108]*
   一个mutex，用于同步do_compress()函数的操作，该函数通过compress()从许多'const'函数调用。 
* [0.x.109]*
   实际执行compress()操作。 
* [0.x.110]*
 创建并返回一个大小为[2.x.73]的索引集，其中包含这个范围内的每一个索引。从本质上讲，这个函数返回一个由以下方式创建的索引集

* 
* [1.x.4]
* 这个函数的存在是为了让人们能够在一个步骤中创建和初始化完整的索引集，或者说是为了让人们能够写出这样的代码

* 
* [1.x.5]
 
* [2.x.74] IndexSet

* 
* [0.x.111]

