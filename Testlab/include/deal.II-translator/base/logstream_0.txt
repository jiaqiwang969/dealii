include/deal.II-translator/base/logstream_0.txt
[0.x.0]*
 一个简化了执行日志过程的类。它通过提供 [2.x.0] [2.x.1] 前缀的推送和弹出机制，以及 [2.x.2] 将信息分发到文件和控制台的可能性来实现。 [2.x.3] 
* 这个类的通常用法是通过预生成的对象<tt>deallog</tt>。典型的设置步骤是。 [2.x.4] [2.x.5] <tt>deallog.depth_console(n)</tt>: 将屏幕上的输出限制在外循环。 [2.x.6] [2.x.7] 将日志信息写进文件。 [2.x.8] <tt>deallog.depth_file(n)</tt>: 限制输出到文件的外循环。 [2.x.9] 
* 在进入程序的新阶段之前，例如一个新的循环，可以通过[2.x.10] p("loopname");</tt>设置一个新的前缀。前缀的析构器将从堆栈中弹出前缀文本。
* 通过<tt>&lt;&lt;</tt>操作符写入，<tt> deallog << "This is a log notice";</tt>将被本地缓冲线程，直到遇到[2.x.11]或[2.x.12]，这将触发写出到控制台，如果设置了日志文件。
* [1.x.0]
* 在并发线程的附近，LogStream的行为方式如下。 [2.x.13] [2.x.14] 每一次对Logstream的写操作<tt>&lt;&lt;</tt>（或使用其中一个特殊的成员函数）都会在线程本地存储中进行缓冲。 [2.x.15] 一个[2.x.16]或[2.x.17]将触发一个写出到控制台和（如果附加）到文件流。这个写出是有顺序的，所以并发的线程的输出不会交错。 [2.x.18] 在一个新的线程上，调用写出，以及调用#push或#pop将把创建LogStream实例的 "祝福 "线程的当前前缀复制到线程本地存储。此后，前缀是线程本地的。 [2.x.19] 
* 

* 
* [2.x.20] 

 
* [0.x.1]*
   一个允许安全生成和移除前缀的子类。    在一个区块的某个地方，创建一个这样的对象，它将作为前缀出现在LogStream输出中，就像 [2.x.21] 在区块结束时，前缀将自动被删除，当这个对象被销毁时。    换句话说，这样创建的对象的范围决定了前缀的寿命。使用这样一个对象的好处是，无论你以何种方式退出这个范围，前缀都会被删除
* 
*--通过[2.x.22]、[2.x.23]，或者仅仅通过到达关闭括号。在所有这些情况下，没有必要记得使用[2.x.24]来手动弹出前缀 在这一点上，它的工作方式就像更著名的[2.x.25]和[2.x.26]类。 
* [0.x.2]*
     为[2.x.27]设置一个新的前缀，这个前缀将在变量被销毁时被删除。   
* [0.x.3]*
     为给定的流设置一个新的前缀，这个前缀将在变量被销毁时被删除。   
* [0.x.4]*
     删除与此变量相关的前缀。   
* [0.x.5]*
     一个指向应用前缀的LogStream对象的指针。   
* [0.x.6]*
   标准构造函数。构造函数将输出流设置为[2.x.28]，深度设置为零。(使用attach()和depth_console()来改变这个。)  
* [0.x.7]*
   解构器。 
* [0.x.8]*
   启用输出到第二个流<tt>o</tt>。     [2.x.29] o 附加这个输出流。     [2.x.30] print_job_id 当前进程的JobIdentifier是否应该被打印到流中。     [2.x.31] flags 要在输出流上设置的格式标志 [2.x.32]   
* [0.x.9]*
   禁用对第二个流的输出。你可能想在以前连接到这个对象的流上调用<tt>close</tt>。 
* [0.x.10]*
   返回默认流（<tt>std_out</tt>）。 
* [0.x.11]*
   返回文件流。 
* [0.x.12]*
   如果文件流已经被连接，返回[2.x.33]，否则返回[2.x.34]。 
* [0.x.13]*
   返回前缀字符串。 
* [0.x.14]*
   在堆栈中推送另一个前缀。前缀自动用冒号隔开，最后一个前缀后面有一个双冒号。    一个更简单的添加前缀的方法（无需手动添加相应的pop()）是使用[2.x.35]类。使用该类的好处是，只要Prefix对象超出了范围，就会发出相应的pop()调用
* 
* - 无论是在代码块的末尾，还是在最近的[2.x.36]语句，或者是因为中间函数调用导致的异常没有被立即捕获。 
* [0.x.15]*
   删除用push()添加的最后一个前缀。 
* [0.x.16]*
   在控制台打印的最大级别数。默认为0，不会产生任何输出。这个函数允许人们将控制台输出限制在最高级别的迭代。只有小于<tt>n</tt>前缀的输出被打印。在<tt>n=0</tt>的情况下调用这个函数，将不会写出控制台输出。参见[2.x.37]中关于此方法的使用实例。    该参数的前一个值将被返回。 
* [0.x.17]*
   写入日志文件的最大层数。其功能与<tt>depth_console</tt>相同，尽管如此，这个函数应该谨慎使用，因为它可能破坏日志文件的价值。    该参数的前一个值将被返回。 
* [0.x.18]*
   记录线程的ID。 
* [0.x.19]*
   为底层流设置精度，并返回之前的流精度。这个函数模仿http://www.cplusplus.com/reference/ios/ios_base/precision/  
* [0.x.20]*
   设置底层流的宽度，并返回上一个流的宽度。此函数模仿http://www.cplusplus.com/reference/ios/ios_base/width/  
* [0.x.21]*
   设置底层流的标志，并返回之前的流标志。此函数模仿http://www.cplusplus.com/reference/ios/ios_base/flags/  
* [0.x.22]*
   处理ostream操作器。这将整个事情传递给模板函数，但[2.x.38]操纵器除外，对其进行特殊操作：将临时流缓冲区包括头写入文件和[2.x.39]并清空缓冲区。    反正这个函数的重载是需要的，因为编译器不能像以前的通用模板那样，将[2.x.40]这样的操纵器直接与模板参数[2.x.41]绑定。这是由于[2.x.42][2.x.43]实际上是[2.x.44][2.x.45]以及潜在的更多此类函数的重载集。因此，这个函数有必要从这个重载集合中挑选一个元素。 
* [0.x.23]*
   返回这个对象的内存消耗估计值，单位是字节。  这不是精确的（但通常会很接近），因为计算树（例如，[2.x.46]）的内存用量是很困难的。 
* [0.x.24]*
   围绕线程本地前缀的内部包装器。这个私有函数将返回正确的内部前缀栈。更重要的是，一个新的线程本地堆栈将从创建这个LogStream实例的 "受祝福 "线程（通常，在deallog的情况下，是 "主 "线程）的当前堆栈中复制出来。 
* [0.x.25]*
   堆栈中的字符串，这些字符串被打印在每一行的开头，以便于识别输出是在哪里产生的。 
* [0.x.26]*
   我们记录创建此对象的线程ID。我们需要这个信息，以便在一个新的线程上第一次使用deallog时，从这个 "父 "线程 "偷 "出当前的前缀。 
* [0.x.27]*
   默认的流，即输出要去的地方。这个流默认为[2.x.47]，但可以通过构造函数设置为其他流。 
* [0.x.28]*
   指向一个流的指针，输出的副本将被送到那里。通常，这将是一个文件流。    你可以通过<tt>attach</tt>函数设置和重置这个流。 
* [0.x.29]*
   表示要打印到标准输出的前缀数量的值。如果超过这个数量的前缀被推到堆栈，那么将不会产生输出，直到前缀的数量缩减到这个数字以下。 
* [0.x.30]*
   输出到文件的最大前缀深度也一样。 
* [0.x.31]*
   打印线程ID的标志。 
* [0.x.32]*
   指示输出当前是否在新行的标志  
* [0.x.33]*
   打印行的头部。 
* [0.x.34]*
   围绕 "线程本地 "输出流的内部包装器。这个私有函数将为operator<<返回正确的内部ostringstream缓冲区。 
* [0.x.35]*
   我们使用我们的线程本地存储设施，为每个发送日志信息的线程生成一个字符串流。 
* [0.x.36]*
 通过LogStream输出一个不变的东西。
* 

* 
* [2.x.48]我们将这个操作符声明为一个非成员函数，这样就有可能在C++11重载解析规则下用更专业的模板化版本来重载它

* 
* [0.x.37]*
 deal.II的标准日志对象。

* 
* [0.x.38]

