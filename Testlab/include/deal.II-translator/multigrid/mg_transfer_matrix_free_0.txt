include/deal.II-translator/multigrid/mg_transfer_matrix_free_0.txt
[0.x.0]*
 MGTransferBase接口的实现，其转移操作是基于底层有限元的插值矩阵，以无矩阵的方式实现。这比MGTransferPrebuilt需要的内存少得多，也比该变体快得多。
* 该类目前仅适用于基于FE_Q和FE_DGQ元素的张量积有限元，包括涉及这些元素之一的多个组件的系统。带有不同元素或其他元素的系统目前还没有实现。

* 
* [0.x.1]*
   没有约束矩阵的构造函数。只在不连续的有限元或没有局部细化的情况下使用这个构造函数。 
* [0.x.2]*
   带约束的构造器。相当于默认的构造函数，后面加上initialize_constraints()。 
* [0.x.3]*
   解构器。 
* [0.x.4]*
   初始化将在build()中使用的约束。 
* [0.x.5]*
   将对象重置为默认构造函数之后的状态。 
* [0.x.6]*
   实际构建每一层的延长线的信息。    外部分区器的可选第二个参数允许用户建议对各层进行矢量分区。如果发现分区器包含所有通过转移访问的幽灵未知数，则选择给定的分区器。这就保证了在延长和限制过程中矢量与用户给出的外部分区器的兼容性，这反过来又节省了一些复制操作。然而，在有未知数丢失的情况下
* 
* 在h-coarsening过程中通常会出现这种情况，因为处理器需要退出，因此某个处理器上的子单元的未知数需要作为另一个处理器上的父单元的幽灵。
* 
* - 提供的外部分区器被忽略，而使用内部的变体。 
* [0.x.7]*
   使用底层有限元的嵌入矩阵将一个向量从<tt>to_level-1</tt>延长到<tt>to_level</tt>。<tt>dst</tt>的先前内容被覆盖。     [2.x.0] to_level 要延长到的层次的索引，即[2.x.1] [2.x.2] src是一个向量，其元素数与涉及的较粗层次上的自由度相同。     [2.x.3] dst有多少个元素，就有多少个更细层次上的自由度。 
* [0.x.8]*
   使用prolongate()方法的转置操作，将一个向量从<tt>from_level</tt>级限制到<tt>from_level-1</tt>级。如果<tt>from_level</tt>层的单元所覆盖的区域小于<tt>from_level-1</tt>层的区域（局部细化），那么<tt>dst</tt>中的一些自由度是有效的，将不会被改变。对于其他自由度，限制的结果被添加。     [2.x.4] from_level 要限制的层次的索引，即[2.x.5] [2.x.6] src是一个向量，其元素数量与所涉及的更细层次上的自由度相同。     [2.x.7] dst有多少个元素，就有多少个在较粗层次上的自由度。 
* [0.x.9]*
   将精细网格场[2.x.8]插值到[2.x.9]中的每个多网格层次，并将结果存储在[2.x.10]中。这个函数与限制不同，限制是将加权残差转移到较粗的层次（延长矩阵的转置）。    参数[2.x.11]必须根据三角结构的层数以正确的大小进行初始化。    如果[2.x.12]的内向量是空的或者有不正确的局部拥有的大小，它将被调整为每个层次上的局部相关自由度。    这个函数的使用在[2.x.13]中得到了证明。 
* [0.x.10]*
   有限元不提供延长矩阵。 
* [0.x.11]*
   这个对象使用的内存。 
* [0.x.12]*
   一个变量，存储传递给build()的DoFHandler中包含的有限元的程度。计算内核的选择是基于这个数字的。 
* [0.x.13]*
   一个变量，存储该元素是否是连续的，并且在一维线的中心有一个联合自由度。 
* [0.x.14]*
   一个变量，用于存储传递给build()的DoFHandler中包含的有限元的分量数量。 
* [0.x.15]*
   一个存储所有子单元的自由度数量的变量。对于DG元素来说，它是<tt>2<sup>dim</sup>*fe.n_dofs_per_cell()</tt>，对于连续元素来说，它的数量要少一些。 
* [0.x.16]*
   这个变量保存了给定层次上的单元格的索引，从DoFHandler中提取出来以便快速访问。一个给定层次上的所有DoF指数被存储为一个普通数组（因为这个类假设每个单元的DoF是恒定的）。要索引到这个数组，使用单元格编号乘以dofs_per_cell。    这个数组首先被安排成所有本地拥有的级别的单元首先出现（在变量n_owned_level_cells中找到），然后是转移到下一级别所需的其他单元。 
* [0.x.17]*
   一个变量存储了每个级别的父级到子级单元格编号的连接。 
* [0.x.18]*
   一个存储每一级在给定进程上拥有的单元格数量的变量（为工作者循环设定界限）。 
* [0.x.19]*
   这个变量持有从母元素到所有子元素的一维嵌入（延长）矩阵。 
* [0.x.20]*
   这个变量保存了张量评估的临时值。 
* [0.x.21]*
   对于连续元素，限制不是加法的，我们需要在延长结束时（和限制开始时）根据自由度的价位对结果进行加权，也就是说，根据它们出现的元素数量进行加权。我们以矢量的形式存储数据，以允许廉价的访问。此外，我们利用了我们只需要存储<tt>3<sup>dim</sup></tt>指数的事实。    数据以每一层（外向量）和每一层的单元格（内向量）为单位组织。 
* [0.x.22]*
   一个存储所有层次（外指数）、层次内的单元（第二指数）和单元上的指数（内指数）的Dirichlet边界条件的局部指数的变量。 
* [0.x.23]*
   一个向量，持有转移的分区器的共享指针。这些分区器可能与通过build()从外部传入的东西共享，或者与从MGLevelGlobalTransfer继承的级别向量共享。 
* [0.x.24]*
   执行延长操作。 
* [0.x.25]*
   执行限制性操作。 
* [0.x.26]*
 MGTransferBase接口的实现，其转移操作是基于底层有限元的插值矩阵，以无矩阵的方式实现。这比MGTransferPrebuilt需要的内存少得多，也比该变体快得多。
* 该类与[2.x.14]一起工作，对每个区块执行与MGTransferMatrixFree完全相同的转移操作。支持所有块使用相同的DoFHandler和每个块使用自己的DoFHandler两种情况。

* 
* [0.x.27]*
   没有约束矩阵的构造函数。只在不连续的有限元或没有局部细化的情况下使用这个构造函数。 
* [0.x.28]*
   带约束的构造器。相当于默认的构造函数，后面加上initialize_constraints()。 
* [0.x.29]*
   与上面的情况相同，每个块都有自己的DoFHandler。 
* [0.x.30]*
   解构器。 
* [0.x.31]*
   初始化将在build()中使用的约束。 
* [0.x.32]*
   对于每个块都有自己的DoFHandler的情况，与上述相同。 
* [0.x.33]*
   将对象重置为默认构造函数后的状态。 
* [0.x.34]*
   实际建立每一层的延长线的信息。 
* [0.x.35]*
   在每个区块都有自己的DoFHandler的情况下，与上面一样。 
* [0.x.36]*
   使用底层有限元的嵌入矩阵，将一个向量从<tt>to_level-1</tt>延长到<tt>to_level</tt>。<tt>dst</tt>的先前内容被覆盖。     [2.x.15] to_level 要延长到的层次的索引，也就是[2.x.16] [2.x.17] src是一个向量，其元素数量与所涉及的较粗层次上的自由度相同。     [2.x.18] dst有多少个元素，就有多少个更细层次上的自由度。 
* [0.x.37]*
   使用prolongate()方法的转置操作，将一个向量从<tt>from_level</tt>级限制到<tt>from_level-1</tt>级。如果<tt>from_level</tt>层的单元所覆盖的区域小于<tt>from_level-1</tt>层的区域（局部细化），那么<tt>dst</tt>中的一些自由度是有效的，将不会被改变。对于其他自由度，限制的结果被添加。     [2.x.19] from_level 要限制的层次的索引，即[2.x.20] [2.x.21] src是一个向量，其元素数量与所涉及的更细层次上的自由度相同。     [2.x.22] dst有多少个元素，就有多少个在较粗层次上的自由度。 
* [0.x.38]*
   从全局网格上的块向量转移到每个层次上的块向量，分别定义为活动自由度。  特别是，对于一个全局细化的网格，只有[2.x.23]中最细的层次被填充为[2.x.24]的普通拷贝，其他的层次对象都没有被触动。    如果需要的话，这个函数会根据Multigrid类的要求，相应地初始化[2.x.25]。 
* [0.x.39]*
   对于每个块都有自己的DoFHandler的情况，与上述相同。 
* [0.x.40]*
   从多级块-向量转移到法向量。 
* [0.x.41]*
   与上述每个块都有自己的DoFHandler的情况相同。 
* [0.x.42]*
   这个对象使用的内存。 
* [0.x.43]*
   这个类既可以用一个DoFHandler，也可以为每个区块用一个单独的DoFHandler。 
* [0.x.44]*
   非块的无矩阵版本的转移操作。 
* [0.x.45]*
   一个标志，表示所有组件使用同一个DoFHandler，还是每个块都有自己的DoFHandler。 
* [0.x.46]

