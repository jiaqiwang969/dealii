include/deal.II-translator/multigrid/mg_transfer_global_coarsening_0.txt
[0.x.0]*
 全局粗化的实用函数。

* 
* [0.x.1]*
   常见的多项式粗化序列。   
* [2.x.0]这些高达9度的多项式粗化序列在MGTwoLevelTransfer中被预先编译了。也请参见。     [2.x.1]   
* [0.x.2]*
     通过整数除法得到半数多项式的度数。例如，对于度数=7，将得到以下序列：。7
* 
-> 3
* 
-> 1    
* [0.x.3]*
     将多项式的度数减少一个。例如，对于度数=7的情况，将产生以下序列：7
* 
-> 6
* 
-> 5
* 
-> 4
* 
-> 3
* 
-> 2
* 
-> 1    
* [0.x.4]*
     将多项式的度数减少到1。例如，对于度数=7的情况，将产生以下序列：7
* 
-> 1    
* [0.x.5]*
   对于给定的[2.x.2]和多项式粗化序列[2.x.3]，确定下一个粗化程度。 
* [0.x.6]*
   对于给定的[2.x.4]和多项式粗化序列[2.x.5]，确定多项式度数的完整序列，按升序排序。 
* [0.x.7]*
   对于一个给定的三角形[2.x.6]通过对所提供的三角形重复进行全局粗化来确定几何粗化序列。   
* [2.x.7] 为方便起见，在返回向量的最后一项中存储了对输入三角形的引用。 
* [2.x.8] 目前，没有为[2.x.9]实现。  
* [2.x.10] 返回三角形的类型与输入三角形的类型相同。 
* [0.x.8]*
   类似于上面的函数，但也取一个[2.x.11]，用于在更粗的层次上重新划分三角形。如果[2.x.12]被设置，输入的三角形不被改变，否则三角形被粗化。如果[2.x.13]被设置，最细层的三角形也会被重新划分。如果标志被设置为true/false，则输入的三角图被简单地用作最细的三角图。   
* [2.x.14] 为方便起见，在返回向量的最后一项中存储了对输入三角形的引用。 
* [2.x.15] 返回三角形的类型是[2.x.16] 。  
* [2.x.17] 目前，只对[2.x.18]实现。  
* [0.x.9]*
   类似于上面的函数，但吸收了[2.x.19]的恒定版本，因此不允许直接用于粗化，需要在内部创建一个时间性的副本。 
* [0.x.10]*
 用于在两个多网格层次之间进行p-或全局粗化的转移的类。

* 
* [0.x.11]*
   进行延长。 
* [0.x.12]*
   执行限制。 
* [0.x.13]*
   对解向量进行从细级到粗级的插值。这个功能与限制不同，在限制中，加权残差被转移到一个更粗的层次（延长矩阵的转置）。 
* [0.x.14]*
 用于在两个多网格层次之间转移p-或全局粗化的类。对[2.x.20]的专门化。

 
* [0.x.15]*
   在给定的DoFHandler对象之间设置全局粗化（ [2.x.21] 和 [2.x.22] 转移只能在活动层上进行。 
* [0.x.16]*
   在给定的DoFHandler对象之间设置多项式粗化 ( [2.x.23] 和 [2.x.24] 多项式转移只能在活动层 [2.x.25] 或粗格层上执行。   
* [2.x.26] 函数polynomial_transfer_supported()可以用来检查是否支持给定的多项式粗化策略。 
* [0.x.17]*
   检查是否有[2.x.27]和[2.x.28]之间的快速模板化版本的多项式转移。   
* [2.x.29]目前，多项式的粗化策略。1) go-to-one, 2) bisect, and 3) decrease-by-one 是预先编译好的9度以下的模板。 
* [0.x.18]*
   进行延长。 
* [0.x.19]*
   执行限制。 
* [0.x.20]*
   执行从细级到粗级的解向量的插值。这个功能与限制不同，在限制中，加权残差被转移到一个更粗的层次（延长矩阵的转置）。 
* [0.x.21]*
   一个多栅格转移方案。一个multrigrid转移类可以有不同的转移方案，以实现p-adaptivity（每个多项式度数对有一个转移方案）和实现全局粗化（子单元和父单元之间的转移有一个转移方案，以及，未被细化的单元有一个转移方案）。 
* [0.x.22]*
     粗化单元的数量。   
* [0.x.23]*
     一个粗单元的自由度数。   
* [0.x.24]*
     精细单元的自由度数。   
* [0.x.25]*
     粗单元的有限元的多项式程度。   
* [0.x.26]*
     精细单元的有限元的多项式程度。   
* [0.x.27]*
     连续元素的权重。   
* [0.x.28]*
     非张量积元素的延长矩阵。   
* [0.x.29]*
     张量-乘积元素的一维延长矩阵。   
* [0.x.30]*
     非张量产品元素的限制矩阵。   
* [0.x.31]*
     张量-产品元素的一维限制矩阵。   
* [0.x.32]*
     粗大单元的DoF指数，以MPI等级的本地指数表示。   
* [0.x.33]*
     精细单元的DoF指数，以MPI等级的本地指数表示。   
* [0.x.34]*
   传输方案。 
* [0.x.35]*
   标志着精细单元上的有限元是否是连续的。如果是，共享一个顶点/线的DoF的倍数以及约束必须通过权重来考虑。 
* [0.x.36]*
   中间向量所需的分区器。 
* [0.x.37]*
   中间向量需要的分区器。 
* [0.x.38]*
   收集精细单元的所有自由度所需的内部向量。它只有在精细级自由度指数触及局部活动自由度以外的自由度时才被初始化（我们总是假设可以通过延长/限制函数中的给定向量来访问这些自由度），否则它的大小将被保留为零。 
* [0.x.39]*
   内部向量，实际延长/限制是在其上进行的。 
* [0.x.40]*
   用于执行手动约束_coarse.distribution()的内部向量，这对于可接受的性能是必需的。 
* [0.x.41]*
   用于在MPI本地索引中手动执行constraint_coarse.distribution()的约束条目索引（出于性能原因）。 
* [0.x.42]*
   用于在MPI-本地索引中手动执行constraint_coarse.distribution()的约束条目值（出于性能原因）。 
* [0.x.43]*
   指向用于手动执行constraint_coarse.distribution()的约束条目的指针。 
* [0.x.44]*
   用于执行手动 constraint_coarse.distribut_local_to_global() 的约束条目索引。 
* [0.x.45]*
   用于执行手动 constraint_coarse.distribut_local_to_global() 的约束条目值。 
* [0.x.46]*
   用于执行手动 constraint_coarse.distribut_local_to_global()的约束条目的指针。 
* [0.x.47]*
   组件的数量。 
* [0.x.48]*
 MGTransferBase的实现。与其他多网格传输运算符相比，用户可以在每一层之间提供单独的MGTwoLevelTransfer类型的传输运算符。
* 该类目前只适用于基于FE_Q和FE_DGQ元素的张量-产品有限元。涉及这些元素之一的多个组件的系统，以及具有不同元素或其他元素的系统，目前没有实现。

* 
* [0.x.49]*
   值类型。 
* [0.x.50]*
   构造函数取一个转移运算符的集合（在[2.x.30]中，最粗大的层次保持为空，如果在PreconditionMG的背景下使用，则有一个可选的函数在函数调用copy_to_mg()内初始化内部层次向量。 
* [0.x.51]*
   进行延长。 
* [0.x.52]*
   执行限制。 
* [0.x.53]*
   初始化内部向量，并将[2.x.31]向量复制到最细的多网格层。   
* [2.x.32]DoFHandler在这里不需要，但被接口要求。 
* [0.x.54]*
   初始化内部向量，并将最细多网格层上的值复制到[2.x.33]向量。   
* [2.x.34]DoFHandler在这里不需要，但被接口所需要。 
* [0.x.55]*
   将精细网格场[2.x.35]插值到[2.x.36]中的每个多网格层次，并将结果存储在[2.x.37]中。这个函数与限制不同，在限制中，加权残差被转移到更粗糙的层次（延长矩阵的转置）。    参数[2.x.38]必须根据三角化的层数以正确的大小进行初始化。    如果[2.x.39]的内向量是空的或者有不正确的局部拥有的大小，它将被调整为每一层的局部相关自由度。   
* [2.x.40]DoFHandler在这里不需要，但被接口所需要。 
* [0.x.56]*
   两级转移运算符的集合。 
* [0.x.57]*
   用于初始化内部级别向量的%函数。 
* [0.x.58]

