include/deal.II-translator/multigrid/mg_base_0.txt
[0.x.0] 该文件包含Multigrid使用的一些抽象基类。

* 
* [0.x.1]*
 多级矩阵基类。这个类设置了多级算法所需的接口。它与实际的矩阵类型没有关系，只接受向量类作为模板参数。
* 通常，派生类[2.x.0]对矩阵的MGLevelObject进行操作，对于应用来说已经足够。

* 
* [0.x.2]虚拟解构器。 
* [0.x.3]*
   矩阵-向量-乘法在一定水平上。 
* [0.x.4]*
   在某一层次上增加矩阵-向量-乘法。 
* [0.x.5]*
   在某一层次上进行矩阵-向量-乘法的转置。 
* [0.x.6]*
   在某一层次上增加转置的矩阵-向量-乘法。 
* [0.x.7]*
   返回存储矩阵的最小级别。 
* [0.x.8]*
   返回存储矩阵的最小级别。 
* [0.x.9]*
 粗略网格求解器的基类。 它定义了虚拟括号运算符，是多网格方法使用的接口。任何实现都将由派生类来完成。

* 
* [0.x.10]*
   虚拟解构器。 
* [0.x.11]*
   解算器。 
* [0.x.12]*
 基类用于声明在多网格背景下实现向量延长和限制的具体类所需的操作。这个类是抽象的，没有这些操作的实现。
* 有几个派生类，反映了细格离散化和多层次实现的向量类型和编号是独立的。
* 如果你对一个单一的PDE或对你的完整方程组使用多网格，你将和多网格一起使用MGTransferPrebuilt。在精细网格上使用的矢量类型以及用于多级操作的矢量类型可以是Vector或BlockVector。在这两种情况下，MGTransferPrebuilt将对解决方案的所有组成部分进行操作。
* 

* 
* [2.x.1] 对于以下内容，重要的是要意识到解决方案[2.x.2]"组件 "和解决方案[2.x.3]"块 "之间的区别。这种区别只适用于使用矢量值元素的情况，但在那时是相当重要的。这反映在现在不可能将基于MGTransferComponentBase的转移类用于真正的矢量值元素，而是必须应用MGTransferBlockBase的后代。在下面的文字中，我们将使用术语[2.x.4]块[2.x.5]，但注意它也可能指的是组件。
* [2.x.6] 更新以下文档，因为它没有反映结构的最新变化。
* 对于混合系统，可能需要只对单个组件或某些组件做多网格。类MGTransferSelect和MGTransferBlock处理这些情况。
* MGTransferSelect用于对单一组件使用多重网格（在矢量对象上），可能使用<tt>mg_target_component</tt>进行分组。
* MGTransferBlock类处理你的多栅格方法对BlockVector对象进行操作的情况。这些对象可以包含完整系统的全部或连续的块集。由于大多数平滑器不能对块结构进行操作，因此不清楚这种情况是否真的有用。因此，需要时将提供这种情况的测试实现。

* 
* [0.x.13]*
   解构器。在这里不做任何事情，但无论如何需要声明为虚拟。 
* [0.x.14]*
   将一个向量从<tt>to_level-1</tt>级延长到<tt>to_level</tt>级。之前<tt>dst</tt>的内容被覆盖。     [2.x.7] src是一个向量，其元素数与所涉及的较粗层次上的自由度相同。     [2.x.8] dst有多少个元素，就有多少个更细层次的自由度。 
* [0.x.15]*
   将一个向量从<tt>to_level-1</tt>级延长到<tt>to_level</tt>级，加到<tt>dst</tt>的前一个内容。     [2.x.9] src是一个向量，其元素数与所涉及的较粗层次上的自由度相同。     [2.x.10] dst有多少个元素，就有多少个更细层次的自由度。 
* [0.x.16]*
   限制一个从<tt>from_level</tt>层到<tt>from_level-1</tt>层的向量，并将这个限制添加到<tt>dst</tt>。如果<tt>from_level</tt>层的单元所覆盖的区域小于<tt>from_level-1</tt>层的区域（局部细化），那么<tt>dst</tt>中的一些自由度是有效的，将不会被改变。对于其他自由度，限制的结果将被添加。     [2.x.11]src是一个向量，其元素数量与较细层次上的自由度相同 [2.x.12]dst的元素数量与较粗层次上的自由度相同。 
* [0.x.17]*
 多网格平滑器的基类。除了定义多网格方法所使用的接口外，什么都不做。
* 平滑器接口提供了两个方法，一个smooth()方法和一个apply()方法。出于效率的考虑，多网格预处理程序接口对这两种方法进行了区分。在进入预处理程序操作时，向量[2.x.13]需要被设置为零，平滑的开始是在[2.x.14]向量上简单应用平滑器。这个方法是由这个类的apply()方法提供的。这与首先将[2.x.15]设置为零，然后调用smooth()是一样的，但是对于许多类来说，单独的apply()接口更有效率，因为它可以跳过一个矩阵-向量乘积。
* 在多网格预处理接口中，apply()方法被用于预平滑操作，因为解向量中以前的内容需要为新进来的残差所覆盖。另一方面，所有后续的操作都需要平滑向量中已经存在的内容[2.x.16]给定的右手边，这是由smooth()完成的。

* 
* [0.x.18]*
   虚拟解构器。 
* [0.x.19]*
   释放矩阵。 
* [0.x.20]*
   平滑函数，给定右手边的向量[2.x.18]，对[2.x.17]中的内容进行平滑处理，这是多网格方法中使用的函数。 
* [0.x.21]*
   与smooth()函数相反，这个函数应用了平滑的动作，覆盖了向量u中以前的内容，这个函数必须等同于以下代码  
* [1.x.0]
* 但通常可以比前者更有效地实现。如果一个特定的平滑器没有覆盖apply()方法，就会使用这里描述的默认实现。    在多网格预处理接口中，apply()方法被用于预平滑操作，因为解向量中以前的内容需要被覆盖以获得新的传入残差。另一方面，所有后续的操作都需要平滑已经存在于向量[2.x.19]中的内容，给定的右手边，这是由smooth()完成的。 
* [0.x.22]

