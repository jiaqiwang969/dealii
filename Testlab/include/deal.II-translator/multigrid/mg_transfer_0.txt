include/deal.II-translator/multigrid/mg_transfer_0.txt
[0.x.0] MGTransferBase在mg_base.h中定义。

* 
* [0.x.1]*
 实现全局向量和多网格层次之间的转移，用于派生类MGTransferPrebuilt和其他类。

* 
* [0.x.2]*
   将对象重置为默认构造函数后的状态。 
* [0.x.3]*
   从全局网格上的矢量转移到为活动自由度分别定义在各层的矢量。特别是，对于一个全局细化的网格，只有[2.x.0]中最细的层次被填充为[2.x.1]的普通拷贝，所有其他的层次对象都没有被触动。 
* [0.x.4]*
   从多级向量转移到普通向量。    将MGVector的活动部分的数据复制到<tt>Vector<number></tt>的相应位置。为了保持结果的一致性，受限自由度被设置为零。 
* [0.x.5]*
   将一个多级向量添加到一个法向量。    与前面的函数一样工作，但可能不适合连续元素。 
* [0.x.6]*
   如果这个对象对BlockVector对象进行操作，我们需要描述各个矢量分量如何被映射到矢量的块上。  例如，对于斯托克斯系统，我们有dim+1的速度和压力的矢量分量，但我们可能想使用只有两个块的块状矢量，将所有的速度放在一个块中，压力变量放在另一个块中。    默认情况下，如果不调用这个函数，块向量的块数与有限元的向量分量一样多。然而，这可以通过调用这个函数来改变，该函数用一个数组来描述如何将矢量分量分组为块。该参数的含义与给[2.x.2]函数的参数相同。 
* [0.x.7]*
   这个对象使用的内存。 
* [0.x.8]*
   为调试目的打印拷贝索引字段。 
* [0.x.9]*
   [2.x.3] copy_indices*的内部函数。由派生类调用。 
* [0.x.10]*
   多级向量的大小。 
* [0.x.11]*
   copy_to_mg()和copy_from_mg()函数的映射。这里只有本地拥有的索引对 数据的组织方式如下：每层一个向量。这些向量的每个元素首先包含全局索引，然后是级别索引。 
* [0.x.12]*
   用于copy_to_mg()函数的额外自由度。这些是全局自由度为本地所有，而层次自由度则不是。    数据的组织与[2.x.4]相同。  
* [0.x.13]*
   用于copy_from_mg()函数的额外自由度。这些是水平自由度是本地拥有的，而全局自由度不是。    数据的组织与[2.x.5]的情况一样。  
* [0.x.14]*
   这个变量存储了从全局到层次向量的复制操作是否实际上是对最细层次的普通复制。这意味着网格没有自适应细化，最细的多网格层次上的编号与全局的情况相同。 
* [0.x.15]*
   存储给set_component_to_block_map()函数的向量。 
* [0.x.16]*
   水平系统的mg_constrained_dofs。 
* [0.x.17]*
   调用这个函数是为了确保build()已经被调用。 
* [0.x.18]*
 实现全局向量和多网格层次之间的转移，用于派生类MGTransferPrebuilt和其他类。这个类是针对[2.x.6]的情况的特殊化，与PETScWrappers和TrilinosWrappers命名空间中的%并行向量相比，需要一些不同的调用例程。

* 
* [0.x.19]*
   将对象重置为默认构造函数后的状态。 
* [0.x.20]*
   从全局网格上的矢量转移到为活动自由度分别定义在每一层的矢量。特别是，对于一个全局细化的网格，只有[2.x.7]中最细的层次被填充为[2.x.8]的普通拷贝，所有其他的层次对象都没有被触动。 
* [0.x.21]*
   从多级向量转移到普通向量。    将MGVector的活动部分的数据复制到<tt>Vector<number></tt>的相应位置。为了保持结果的一致性，受限自由度被设置为零。 
* [0.x.22]*
   将一个多级向量添加到一个法向量。    与前面的函数一样工作，但可能不适合连续元素。 
* [0.x.23]*
   如果这个对象对BlockVector对象进行操作，我们需要描述各个矢量分量如何被映射到矢量的块上。  例如，对于斯托克斯系统，我们有dim+1的速度和压力的矢量分量，但我们可能想使用只有两个块的块状矢量，将所有速度放在一个块中，压力变量放在另一个块中。    默认情况下，如果不调用这个函数，块向量的块数与有限元的向量分量一样多。然而，这可以通过调用这个函数来改变，该函数用一个数组来描述如何将矢量分量分组为块。该参数的含义与给[2.x.9]函数的参数相同。 
* [0.x.24]*
   这个对象使用的内存。 
* [0.x.25]*
   为调试目的打印拷贝索引字段。 
* [0.x.26]*
   内部函数，根据标志[2.x.10]执行残差或解决方案的转移。  
* [0.x.27]*
   [2.x.11] copy_indices*的内部函数。由派生类调用。 
* [0.x.28]*
   多级向量的大小。 
* [0.x.29]*
   copy_to_mg()和copy_from_mg()函数的映射。这里只存储本地拥有的索引对。    数据的组织方式如下：每层有一个表。这个表有两行。第一行包含全局索引，第二行是级别索引。 
* [0.x.30]*
   与上述相同，但用于传输解决方案向量。 
* [0.x.31]*
   用于copy_to_mg()函数的额外自由度。这些是全局自由度是本地拥有的，而水平自由度则不是。    数据的组织与[2.x.12]相同。  
* [0.x.32]*
   与上述相同，但用于转移解向量。 
* [0.x.33]*
   用于copy_from_mg()函数的额外自由度。这些是水平自由度是本地拥有的，而全局自由度不是。    数据的组织与[2.x.13]一样。  
* [0.x.34]*
   与上述相同，但用于转移解向量。 
* [0.x.35]*
   这个变量存储了从全局到水平向量的复制操作是否实际上是对最细水平的普通复制。这意味着网格没有自适应细化，最细的多网格层次上的编号与全局情况下的编号相同。 
* [0.x.36]*
   这个变量存储了从全局到层次向量的复制操作，除了在最细层次内对自由度进行重新编号外，实际上是对最细层次的普通复制。这意味着该网格没有自适应细化。 
* [0.x.37]*
   存储给set_component_to_block_map()函数的向量。 
* [0.x.38]*
   水平系统的mg_constrained_dofs。 
* [0.x.39]*
   在函数copy_to_mg中，我们需要访问全局向量的重影项，以便插入到关卡向量中。这个向量是由这些条目填充的。 
* [0.x.40]*
   和上面一样，但在处理解向量时使用。 
* [0.x.41]*
   在函数copy_from_mg中，我们访问所有带有某些鬼魂条目的水平向量，以便将结果插入全局向量中。 
* [0.x.42]*
   与上述相同，但在处理解向量时使用。 
* [0.x.43]*
   调用这个函数是为了确保build()已经被调用。 
* [0.x.44]*
 MGTransferBase接口的实现，该接口的转移操作是在构建该类的对象为矩阵时预先构建的。这是快速的方法，因为它只需要通过循环所有单元格并将结果存储在每一层的矩阵中来构建一次操作，但需要额外的内存。
* 参见MGTransferBase，了解哪一个转移类最适合你的需要。

* 
* [0.x.45]*
   没有约束矩阵的构造函数。只在不连续的有限元或没有局部细化的情况下使用这个构造函数。 
* [0.x.46]*
   带约束的构造器。相当于默认的构造函数，后面加上initialize_constraints()。 
* [0.x.47]*
   解构器。 
* [0.x.48]*
   初始化将在build()中使用的约束。 
* [0.x.49]*
   将对象重置为默认构造函数之后的状态。 
* [0.x.50]*
   实际构建转移操作所需的信息。在使用prolongate()或restrict_and_add()之前需要调用。 
* [0.x.51]*
   使用底层有限元的嵌入矩阵，将一个向量从<tt>to_level-1</tt>延长到<tt>to_level</tt>。之前<tt>dst</tt>的内容被覆盖。     [2.x.14] src是一个向量，其元素数与所涉及的较粗层次上的自由度相同。     [2.x.15] dst有多少个元素，就有多少个更细层次的自由度。 
* [0.x.52]*
   使用[2.x.16]方法的转置操作，将一个矢量从<tt>from_level</tt>级限制到<tt>from_level-1</tt>级。如果<tt>from_level</tt>层的单元所覆盖的区域小于<tt>from_level-1</tt>层的区域（局部细化），那么<tt>dst</tt>中的一些自由度是有效的，将不会被改变。对于其他自由度，限制的结果将被添加。     [2.x.17] src是一个向量，其元素数量与所涉及的更细层次上的自由度相同。     [2.x.18] dst的元素数与较粗层次上的自由度相同。 
* [0.x.53]*
   有限元不提供延长矩阵。 
* [0.x.54]*
   在使用这个对象之前，你必须调用build()。 
* [0.x.55]*
   这个对象使用的内存。 
* [0.x.56]*
   为调试目的打印所有的矩阵。 
* [0.x.57]*
   转移矩阵的稀疏性模式。 
* [0.x.58]*
   实际的延长矩阵。列指数属于母单元的道夫指数，即粗级别。而行指数属于子单元，即细级别。 
* [0.x.59]*
   细化边上的自由度，不包括边界上的自由度。 
* [0.x.60]

