include/deal.II-translator/multigrid/mg_smoother_0.txt
[0.x.0] MGSmootherBase在mg_base.h中定义。

* 
* [0.x.1]*
 一个用于平滑器处理平滑信息的基类。虽然没有添加到MGSmootherBase中的抽象接口，但这个类存储了平滑步骤的数量和类型的信息，反过来可以被派生类使用。

* 
* [0.x.2]*
   构造函数。 
* [0.x.3]*
   在最好的级别上修改平滑步骤的数量。 
* [0.x.4]*
   开启/关闭变量平滑。 
* [0.x.5]*
   开启/关闭对称平滑。 
* [0.x.6]*
   开启/关闭换位平滑。该效果被set_symmetric()所覆盖。 
* [0.x.7]*
   将[2.x.0]设置为非零值以获得记录在[2.x.1]deallog的调试信息。增加以获得更多信息  
* [0.x.8]*
   一个用于临时向量的内存对象。    该对象被标记为可变的，因为我们将需要用它来分配临时向量，也是在常量的函数中。 
* [0.x.9]*
   最细级别上的平滑步骤数。如果没有选择#variable smoothing，这就是所有级别的步数。 
* [0.x.10]*
   可变平滑：每当进入下一个更粗的级别时，平滑步骤的数量将增加一倍。 
* [0.x.11]*
   对称平滑：在平滑迭代中，在松弛方法和其转置之间交替进行。 
* [0.x.12]*
   使用松弛方法的转置而不是该方法本身。  如果选择了#symmetric smoothing，这就没有影响。 
* [0.x.13]*
   如果这不是零，则将调试信息输出到[2.x.2]。 
* [0.x.14]*
 平滑化不做任何事情。这个类对于很多应用来说是没有用的，除了测试一些多网格程序。另外，有些应用可能在没有平滑的情况下得到收敛，然后这个类会给你带来最便宜的多网格。

* 
* [0.x.15]*
   [2.x.3]接口的实现 这个函数什么都不做，通过与这个函数的定义比较，这意味着平滑算子等于空算子。 
* [0.x.16]*
   使用松弛类进行平滑处理。    一个松弛类是一个满足[2.x.4]"松弛概念 "的对象。    这个类在每个层次上执行平滑操作。该操作可以由几个参数控制。首先，松弛参数[2.x.5] omega用于底层松弛方法。 [2.x.6]是在最细级别上的松弛步骤的数量（如果[2.x.7]关闭，则在所有级别上）。如果[2.x.8]是[2.x.9]，则每一个较粗的层次上的平滑步数是双倍的。这导致了一种具有W-循环复杂性的方法，但节省了网格转移。这是Bramble等人提出的方法。选项[2.x.10]按照Bramble的建议，在每个步骤中交替使用平滑器和其转置。     [2.x.11] 使用<tt>Tstep</tt>的转置平滑操作，而不是放松方案的常规<tt>step</tt>。    如果你使用块矩阵，第二个[2.x.12]函数提供了提取单个块进行平滑的可能性。在这种情况下，多棱镜方法必须只用于与该单一块相关的矢量。 
* [0.x.17]*
     构造函数。设置平滑参数。   
* [0.x.18]*
     对矩阵进行初始化。这个函数用每个级别的相同的平滑器来初始化平滑运算器。         [2.x.13]是一个[2.x.14][2.x.15]类型的对象，被交给松弛方法的初始化函数。   
* [0.x.19]*
     初始化每个层次的矩阵和附加数据。        如果两个对象的最小或最大级别不同，则利用最大的共同范围。这样，即使矩阵是为所有级别生成的，平滑也可以限制在某些级别上。   
* [0.x.20]*
     清空所有的向量。   
* [0.x.21]*
     实际的平滑方法。   
* [0.x.22]*
     平滑化的应用变体，在调用平滑函数之前将向量u设置为零。这个函数等同于以下代码    
* [1.x.0]
* 在多网格预处理接口中，apply()方法用于预平滑操作，因为解向量中以前的内容需要为新进来的残差所覆盖。另一方面，所有后续的操作都需要平滑已经存在于向量[2.x.16]中的内容，给定的右手边，这是由smooth()完成的。   
* [0.x.23]*
     这个对象使用的内存。   
* [0.x.24]*
 使用满足[2.x.17]"放松概念 "的求解器进行平滑处理。
* 该类在每个层次上执行平滑操作。该操作可以由几个参数控制。首先，松弛参数[2.x.18]被用于底层松弛方法中。 [2.x.19]是最细层次上的松弛步数（如果[2.x.20]关闭，则在所有层次上）。如果[2.x.21]是[2.x.22]，则每一个较粗的层次上的平滑步数是双倍的。这导致了一种具有W-循环复杂性的方法，但节省了网格转移。这是Bramble at al.提出的方法。
* 选项[2.x.23]按照Bramble的建议，在每个步骤中交替使用平滑器和其转置。
* [2.x.24] 使用<tt>Tstep</tt>的转置平滑操作，而不是放松方案的常规<tt>step</tt>。
* 如果你使用块矩阵，第二个[2.x.25]函数提供了提取单个块进行平滑的可能性。在这种情况下，多棱镜方法必须只用于与该单块相关的向量。
* 该库包含<tt>SparseMatrix<.></tt>和<tt>Vector<.></tt>的实例化，其中模板参数是[2.x.26] float和[2.x.27] 的所有组合，其他实例化可以通过包括文件mg_smoother.templates.h来创建。

* 
* [0.x.25]*
   构造函数。设置平滑参数。 
* [0.x.26]*
   对矩阵进行初始化。这个函数存储指向水平矩阵的指针，并且用每个水平的相同的平滑器来初始化平滑运算器。     [2.x.28]是一个[2.x.29]类型的对象，被交给放松方法的初始化函数。 
* [0.x.27]*
   为矩阵进行初始化。这个函数存储指向水平矩阵的指针，并且用每个水平的相应平滑器初始化平滑运算器。     [2.x.30]是一个[2.x.31]类型的对象，被交给放松方法的初始化函数。 
* [0.x.28]*
   对单块矩阵进行初始化。在这个块状矩阵中，每一级都会选择[2.x.32]和[2.x.33]所指示的块。  这个函数存储了指向水平矩阵的指针，并以每个水平的相同平滑器初始化平滑运算器。     [2.x.34]是一个[2.x.35]类型的对象，被交给放松方法的初始化函数。 
* [0.x.29]*
   对单块矩阵进行初始化。在这个块状矩阵中，每一级都会选择[2.x.36]和[2.x.37]所指示的块。  这个函数存储指向水平矩阵的指针，并为每个水平用相应的平滑器初始化平滑运算器。     [2.x.38]是一个[2.x.39]类型的对象，被交给放松方法的初始化函数。 
* [0.x.30]*
   清空所有的向量。 
* [0.x.31]*
   实际的平滑方法。 
* [0.x.32]*
   平滑化的应用变体，在调用平滑函数之前将向量u设置为零。这个函数等同于以下代码  
* [1.x.1]
* 在多网格预处理接口中，apply()方法用于预平滑操作，因为解向量中以前的内容需要为新进来的残差所覆盖。另一方面，所有后续的操作都需要平滑已经存在于向量[2.x.40]中的内容，给定的右手边，这是由smooth()完成。 
* [0.x.33]*
   包含放松方法的对象。 
* [0.x.34]*
   这个对象所使用的内存。 
* [0.x.35]*
   指向矩阵的指针。 
* [0.x.36]*
 使用预处理器类的平滑器。
* 该类在每一级上执行平滑操作。该操作可以由几个参数控制。首先，放松参数[2.x.41]用于底层放松方法。 [2.x.42]是在最细级别上的松弛步骤的数量（如果[2.x.43]关闭，则在所有级别上）。如果[2.x.44]是[2.x.45]，则每一个较粗的层次上的平滑步数是双倍的。这导致了一种具有W-循环复杂性的方法，但节省了网格转移。这是Bramble at al.提出的方法。
* 选项[2.x.46]按照Bramble的建议，在每个步骤中交替使用平滑器和其转置。
* [2.x.47] 使用<tt>Tvmult</tt>的转置平滑操作，而不是放松方案的常规<tt>vmult</tt>。
* 如果你使用块矩阵，第二个[2.x.48]函数提供了提取单个块进行平滑的可能性。在这种情况下，多棱镜方法必须只用于与该单块相关的向量。
* 该库包含<tt>SparseMatrix<.></tt>和<tt>Vector<.></tt>的实例化，其中模板参数是[2.x.49] float和[2.x.50] 的所有组合，其他实例化可以通过包括文件mg_smoother.templates.h来创建。

* 
* [0.x.37]*
   构造函数。设置平滑参数。 
* [0.x.38]*
   对矩阵进行初始化。这个函数存储指向水平矩阵的指针，并且用每个水平的相同的平滑器来初始化平滑运算器。     [2.x.51]是一个[2.x.52][2.x.53]类型的对象，被交给放松方法的初始化函数。 
* [0.x.39]*
   为矩阵进行初始化。这个函数存储指向水平矩阵的指针，并且用每个水平的相应平滑器初始化平滑运算器。     [2.x.54]是一个[2.x.55][2.x.56]类型的对象，被交给放松方法的初始化函数。 
* [0.x.40]*
   对单块矩阵进行初始化。在这个块状矩阵中，[2.x.57]和[2.x.58]所指示的块在每一级都被选择。  这个函数存储了指向水平矩阵的指针，并以每个水平的相同平滑器初始化平滑运算器。     [2.x.59]是一个[2.x.60][2.x.61]类型的对象，被交给放松方法的初始化函数。 
* [0.x.41]*
   对单块矩阵进行初始化。在这个块状矩阵中，[2.x.62]和[2.x.63]所指示的块在每一级都被选择。  这个函数存储指向水平矩阵的指针，并为每个水平用相应的平滑器初始化平滑运算器。     [2.x.64]是一个[2.x.65][2.x.66]类型的对象，被交给放松方法的初始化函数。 
* [0.x.42]*
   清空所有的向量。 
* [0.x.43]*
   实际的平滑方法。 
* [0.x.44]*
   平滑化的应用变体，在调用平滑函数之前将向量u设置为零。这个函数等同于以下代码  
* [1.x.2]
* 在多网格预处理接口中，apply()方法用于预平滑操作，因为解向量中以前的内容需要为新进来的残差所覆盖。另一方面，所有后续的操作都需要平滑已经存在于向量[2.x.67]中的内容，给定的右手边，这是由smooth()完成。 
* [0.x.45]*
   包含放松方法的对象。 
* [0.x.46]*
   这个对象所使用的内存。 
* [0.x.47]*
   指向矩阵的指针。 
* [0.x.48]

