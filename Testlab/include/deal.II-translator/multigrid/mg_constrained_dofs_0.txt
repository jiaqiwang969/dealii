include/deal.II-translator/multigrid/mg_constrained_dofs_0.txt
[0.x.0]*
 水平向量的边界约束和细化边缘约束的集合。
* 

* 
* [2.x.0] 

* 
* [0.x.1]*
   用从dof handler对象中提取的悬挂节点约束来填充内部数据结构。只在自然边界条件下工作。  也存在一个设置边界约束的姐妹函数。    这个函数确保在每个层次上，细化层次的内部边缘的自由度被正确处理，但假设不存在迪里希特边界条件，则不触及域的边界自由度。    此外，这个调用在每个层次上设置了一个AffineConstraints对象，该对象包含可能的周期性约束，以防这些约束被添加到底层三角形中。该AffineConstraints对象可以通过get_level_constraints(level)查询。请注意，目前这个类中周期性约束的实现不支持周期性定义中的旋转矩阵，也就是说，[2.x.1]中的相应参数可能与身份矩阵不同。  如果没有传递level_relevant_dofs作为第二个参数，该函数将使用由[2.x.2]提取的本地相关级别DoFs。否则，用户提供的IndexSets（应定义本地相关DoFs的超集）将在每个级别上使用，以允许用户向受限DoFs集添加额外的指数。 
* [0.x.2]*
   用有关Dirichlet边界DoF的信息填充内部数据结构。    在设置悬挂节点约束之前，必须调用initialize()函数。    这个函数可以被多次调用，以允许考虑不同组件的不同边界_ID集。 
* [0.x.3]*
   添加用户定义的约束条件，用于水平[2.x.3] 用户可以多次调用这个函数，任何新的、冲突的约束条件将覆盖该DoF的先前约束。    在转移之前，用户定义的约束将被分配到源矢量，然后任何使用make_zero_boundary_constraints()设置的DoF索引将被覆盖为零值。   
* [2.x.4]目前这只在MGTransferMatrixFree中实现。 
* [0.x.4]*
   用无法线通量边界道夫的信息填充内部数据结构。    这个函数只限于那些无法线通量边界的面与x轴、y轴或z轴为法线的网格。同时，对于一个特定的边界ID，所有的面必须朝向同一个方向，也就是说，对X轴法线的边界必须与对Y轴或Z轴法线的边界具有不同的边界ID，以此类推。如果网格是用[2.x.5]函数生成的，在网格生成时设置<tt>colorize=true</tt>，并为每个无法线通量边界调用make_no_normal_flux_constraints()就可以了。 
* [0.x.5]*
   重置数据结构。 
* [0.x.6]*
   判断一个道夫指数是否受到边界约束。 
* [0.x.7]*
   判断一个道夫指数是否处于细化边缘。 
* [0.x.8]*
   确定是否应该设置给定层次上的界面矩阵的（i,j）项。这是就dof i而言的，也就是说，如果i在细化边缘，j不在细化边缘，并且两者都不在外部边界上，则返回true。 
* [0.x.9]*
   返回给定层次上受Dirichlet边界条件约束的层次道夫的索引（如initialize()中的[2.x.6]参数所设定）。 指数被限制在本地相关的层面道夫的集合中。 
* [0.x.10]*
   返回位于细化边上的给定层次上的道夫的指数（道夫在面与邻居的关系更粗）。 
* [0.x.11]*
   返回是否在initialize()中设置了Dirichlet边界指数。 
* [0.x.12]*
   返回给定层次的AffineConstraints对象，包含周期性约束（如果在三角剖面上启用）。 
* [0.x.13]*
   返回给定水平的用户定义的约束矩阵。这些约束是用函数add_user_constraints()设置的，不应该包含在make_zero_boundary_constraints()中设置的DoF指数的约束，因为它们将在传输过程中被覆盖。 
* [0.x.14]*
   每一层的边界DoF的指数。 
* [0.x.15]*
   某一层次上的自由度，它们生活在该层次和更粗层次上的单元之间的细化边缘上。 
* [0.x.16]*
   包含每个层的潜在周期性边界条件信息的约束矩阵。 
* [0.x.17]*
   由用户定义的约束矩阵。 
* [0.x.18]

