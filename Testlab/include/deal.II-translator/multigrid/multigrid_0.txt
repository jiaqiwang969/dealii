include/deal.II-translator/multigrid/multigrid_0.txt
[0.x.0]*
   一个包含[2.x.0]对象的结构，用于多网格求解器的可选处理。    每个信号都被调用两次，一次是在执行动作之前，一次是在执行动作之后。这两个函数调用的不同之处在于布尔参数[2.x.1]，第一次为真，第二次为假。 
* [0.x.1]*
     这个信号在调用[2.x.2]之前（[2.x.2]为真）和之后（[2.x.3]为假）被触发，[2.x.4]将给定的向量转移到一个多级向量。   
* [0.x.2]*
     这个信号在调用[2.x.5]为真之前和[2.x.6]为假之后被触发，[2.x.7]将给定的多级向量转为正常向量。   
* [0.x.3]*
     这个信号在调用[2.x.8]之前（[2.x.9]为真）和之后（[2.x.10]为假）被触发，粗解将用`defect[leve]`完成，并以`solution[level]`返回，用户可以使用这个信号检查。   
* [0.x.4]*
     这个信号在调用[2.x.11]之前（[2.x.12]为真）和之后（[2.x.12]为假）被触发，该信号将一个矢量从[2.x.14]限制到下一个更粗的矢量（[2.x.15] ）。
* 
* - 1).         向量``defect[level-1]`将在这两个触发器之间被更新，用户可以使用这个信号来检查。   
* [0.x.5]*
     这个信号在调用[2.x.16]之前（[2.x.17]为真）和之后（[2.x.17]为假）被触发，[2.x.18]将一个向量从下一个较粗的向量延长到[2.x.19]（[2.x.20] ）。
* 
* - 1).    
* [0.x.6]*
     这个信号在（[2.x.21]为真）和（[2.x.22]为假）通过[2.x.23]对[2.x.24]的预平滑步骤的调用之前和之后被触发。平滑的结果将被存储在`solution[level]`中，用户可以通过这个信号来检查。   
* [0.x.7]*
     这个信号在[2.x.25]为真之前和[2.x.26]为假之后被触发，通过[2.x.27]对[2.x.28]的平滑后步骤进行调用。    
* [0.x.8]*
 多网格方法的实现。该实现支持连续和非连续元素，并遵循[2.x.29]"Janssen和Kanschat的多栅格论文 "中描述的程序。
* cycle()是在最细级别上启动多网格循环的函数。根据构造函数选择的循环类型（见枚举Cycle），该函数会触发level_v_step()或level_step()中的一个循环，其中后者可以做不同类型的循环。
* 使用这个类，预计右手边已经从一个生活在本地最好水平上的向量转换为一个多级向量。这是一个不简单的操作，通常由PreconditionMG类自动启动，由MGTransferBase派生的类执行。
* 

* 
* [2.x.30] 这个类的接口仍然非常笨拙。特别是，在使用它之前，你必须要设置相当多的辅助性对象。不幸的是，似乎只有以一种不可接受的方式来限制这个类的灵活性，才能避免这种情况。

* 
* [0.x.9]*
   实现的循环类型列表。 
* [0.x.10]*
   构造函数。<tt>transfer</tt>是一个执行延长和限制的对象。对于[minlevel, maxlevel]中的级别，矩阵必须包含有效的矩阵。默认情况下，maxlevel被设置为最大的有效级别。    这个函数已经初始化了向量，这些向量将在以后的计算过程中使用。因此，你应该尽可能晚地创建这种类型的对象。 
* [0.x.11]*
   根据#minlevel和#maxlevel来重新启动这个类。 
* [0.x.12]*
   执行一个多栅格循环。循环的类型由构造函数参数cycle来选择。可用的类型见枚举循环。 
* [0.x.13]*
   执行V-cycle算法的一个步骤。 这个函数假定，多级向量#defect是由外部缺陷修正方案的残余物填充的。这通常是由PreconditionMG)处理的。在vcycle()之后，结果是在多级向量#solution中。如果你想自己使用这些向量，请参见MGTools命名空间的<tt>copy_*_mg</tt>。    这个函数的实际工作是在level_v_step()中完成的。 
* [0.x.14]*
   设置额外的矩阵来修正细化边缘的残差计算。由于我们只对网格细化部分的内部进行平滑处理，所以缺少对细化边缘的耦合。这种耦合是由这两个矩阵提供的。   
* [2.x.31] 虽然使用了<tt>edge_out.vmult</tt>，对于第二个参数，我们使用<tt>edge_in.Tvmult</tt>。因此，<tt>edge_in</tt>应该以转置的形式进行组合。这为<tt>edge_in</tt>节省了第二个稀疏模式。特别是，对于对称运算符来说，两个参数都可以指向同一个矩阵，这样可以节省其中一个的装配。 
* [0.x.15]*
   设置额外的矩阵来纠正细化边缘的残差计算。这些矩阵源于不连续的Galerkin方法（见FE_DGQ等），它们对应于两层之间细化边缘的边缘通量。   
* [2.x.32] 虽然使用了<tt>edge_down.vmult</tt>，对于第二个参数，我们使用<tt>edge_up.Tvmult</tt>。因此，<tt>edge_up</tt>应该以转置的形式进行组合。这为<tt>edge_up</tt>节省了第二个稀疏模式。特别是，对于对称运算符来说，两个参数都可以指向同一个矩阵，这样可以节省其中一个的装配。 
* [0.x.16]*
   返回多网格的最佳水平。 
* [0.x.17]*
   返回多网格的最粗层次。 
* [0.x.18]*
   设置执行多层次方法的最高层次。默认情况下，这是三角法的最细层次。接受的值不小于当前的#minlevel。 
* [0.x.19]*
   设置执行多层次方法的最粗层次。默认情况下，该值为零。接受的是不大于当前#maxlevel的非负值。    如果<tt>relative</tt>是<tt>true</tt>，那么这个函数决定了使用的级别数，也就是说，它将#minlevel设置为#maxlevel-<tt>level</tt>。   
* [2.x.33] 最粗层次上的网格必须覆盖整个领域。在#minlevel上不能有悬空的节点。   
* [2.x.34] 如果#minlevel被设置为非零值，不要忘记调整你的粗略网格解算器  
* [0.x.20]*
   机会#cycle_type在cycle()中使用。 
* [0.x.21]*
   连接一个函数到[2.x.35]。  
* [0.x.22]*
   将一个函数连接到[2.x.36]。  
* [0.x.23]*
   将一个函数连接到[2.x.37]。  
* [0.x.24]*
   将一个函数连接到[2.x.38]。  
* [0.x.25]*
   将一个函数连接到[2.x.39]。  
* [0.x.26]*
   多重网格算法使用的各种动作的信号。 
* [0.x.27]*
   V型循环多网格方法。<tt>level</tt>是函数开始的层次。它通常会从外部调用最高层，但随后会递归调用自己的<tt>level-1</tt>，除非我们在#minlevel上，粗网格求解器完全解决了这个问题。 
* [0.x.28]*
   实际的W-循环或F-循环多网格方法。<tt>level</tt>是函数开始的级别。它通常会从外部调用最高层，但随后会递归调用自己的<tt>level-1</tt>，除非我们在#minlevel上，粗网格求解器完全解决了问题。 
* [0.x.29]*
   由cycle()方法执行的循环类型。 
* [0.x.30]*
   用于粗略网格求解的水平。 
* [0.x.31]*
   最高级别的单元格。 
* [0.x.32]*
   循环的输入向量。包含外方法投射到多层次向量的缺陷。 
* [0.x.33]*
   多网格步骤后的解决方案更新。 
* [0.x.34]*
   辅助向量。 
* [0.x.35]*
   用于W-和F-循环的辅助向量。在V-循环中未被初始化。 
* [0.x.36]*
   每个层次的矩阵。 
* [0.x.37]*
   每一级的矩阵。 
* [0.x.38]*
   用于网格转移的对象。 
* [0.x.39]*
   预平滑对象。 
* [0.x.40]*
   后平滑对象。 
* [0.x.41]*
   从细化部分的内部到细化边缘的边缘矩阵。   
* [2.x.40]只有<tt>vmult</tt>被用于这些矩阵。 
* [0.x.42]*
   从细化边缘到细化部分内部的转置边缘矩阵。   
* [2.x.41]只有<tt>Tvmult</tt>被用于这些矩阵。 
* [0.x.43]*
   从细到粗的边缘矩阵。   
* [2.x.42] 只有<tt>vmult</tt>用于这些矩阵。 
* [0.x.44]*
   从粗到细的转置边缘矩阵。   
* [2.x.43] 只有<tt>Tvmult</tt>用于这些矩阵。 
* [0.x.45]*
 多级预处理器。在这里，我们收集了多级预处理所需的所有信息，并为LAC迭代方法提供标准接口。
* 此外，它需要函数<tt>void copy_to_mg(const VectorType&)</tt>来存储多级方法右侧的[2.x.44]，<tt>void copy_from_mg(VectorType&)</tt>来存储[2.x.45]中的v循环结果。
* 如果VectorType实际上是一个块向量，并且TRANSFER对象支持为每个块使用单独的DoFHandler，这个类也允许被初始化为每个块的单独DoFHandler。

* 
* [0.x.46]*
   构造函数。参数是多网格对象、前平滑器、后平滑器和粗网格求解器。 
* [0.x.47]*
   在块向量的每个分量都使用其自己的DoFHandler的情况下，与上述相同。 
* [0.x.48]*
   其他类所需的假函数。 
* [0.x.49]*
   预设条件运算符。调用传递给构造器的[2.x.47]对象的[2.x.46]函数。    这是LAC迭代求解器使用的运算器。 
* [0.x.50]*
   预处理运算符。调用传递给构造函数的[2.x.49]对象的[2.x.48]函数。 
* [0.x.51]*
   转置的预设条件运算符。    未实现，但可能需要定义。 
* [0.x.52]*
   转置的预设条件运算符。    未实现，但可能需要定义。 
* [0.x.53]*
   返回这个预处理程序的范围空间的划分，即从矩阵-向量乘积得到的向量的划分。默认情况下，会返回第一个DoFHandler对象的相应信息。 
* [0.x.54]*
   返回该预处理程序的域空间的划分，即该矩阵必须与之相乘的向量的划分。  默认情况下，会返回第一个DoFHandler对象的相应信息。 
* [0.x.55]*
   返回与该预处理程序一起使用的MPI通信器对象。 
* [0.x.56]*
   连接一个函数到[2.x.50]。  
* [0.x.57]*
   将一个函数连接到[2.x.51]。  
* [0.x.58]*
   关联[2.x.52]。  
* [0.x.59]*
   为没有SmartPointer包装的DoFHandler对象的指针进行存储。 
* [0.x.60]*
   多网格对象。 
* [0.x.61]*
   用于网格传输的对象。 
* [0.x.62]*
   指示该对象是用一个DoFHandler初始化还是每个区块用一个的标志。 
* [0.x.63]*
   该对象使用的信号  
* [0.x.64]

