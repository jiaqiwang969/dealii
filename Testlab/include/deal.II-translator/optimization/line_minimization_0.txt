include/deal.II-translator/optimization/line_minimization_0.txt
[0.x.0]*
 一个命名空间，用于与线上最小化有关的各种算法。

* 
* [0.x.1]*
   给出 [2.x.0] 和 [2.x.1] 连同函数值 [2.x.2] 和 [2.x.3] 以及梯度 [2.x.4] ，返回二次插值函数的局部最小化器。    返回类型是可选的，以便与可能没有给定参数的解的类似函数相适应。 
* [0.x.2]*
   给出 [2.x.5] 和 [2.x.6] 以及这些点的函数值 [2.x.7] 和 [2.x.8] 及其梯度 ( [2.x.9] ) ，返回三次插值函数的局部最小值（即三次插值函数达到其最小值的位置）。    返回类型是可选的，因为实值解可能不存在。 
* [0.x.3]*
   找出经过 [2.x.10] , [2.x.11] 和 [2.x.12] 等点，并在 [2.x.14] 处有导数 [2.x.13] 的三次方多项式的最小化。    返回类型是可选的，因为实值的解决方案可能不存在。 
* [0.x.4]*
   返回使用函数值 [2.x.15] , [2.x.16] , 和 [2.x.17] 在三个点 [2.x.18] , [2.x.19] , 和 [2.x.20] 上的多项式的最小化，以及在两个点 [2.x.21] 和 [2.x.22] 上的导数。    这个函数将首先尝试执行cubic_fit()。如果它不成功，或者如果最小值不在提供的 [2.x.24] 范围内，将执行二次拟合（）。如果quadratic_fit()失败，该函数将退回到一个二分法。 
* [0.x.5]*
   与poly_fit()相同，但是进行三点的三次拟合（见cubic_fit_three_points() ）。 
* [0.x.6]*
   在[2.x.25]中进行具有强沃尔夫条件[1.x.0]的线搜索，使用一维函数[2.x.26]与函数[2.x.27]结合，根据其两端的函数值和导数从区间中选择一个新点。  参数[2.x.28]是对第一步的试估计。  插值可以使用poly_fit()或poly_fit_three_points()，或任何其他具有类似签名的函数来完成。    该函数实现了第34-35页中的算法2.6.2和2.6.4。 
* [1.x.1]
这些都是*[1.x.1]中第60-61页的算法3.5和3.6的微小变化。 
* [1.x.2]
* 它包括一个包围阶段和一个缩放阶段，其中使用了[2.x.29]。    两个使用的例子可能如下。  在第一个例子中，我们希望找到函数 [2.x.30] 的最小值。为了找到近似的解决方案，我们可以使用直线搜索和多项式拟合曲线的方法来执行以下步骤。   
* [1.x.3]
* 在第二个例子中，我们希望在一个非线性有限元问题的背景下进行直线搜索。下面是一个非优化的反向跟踪算法的实现，当负载步长过大时，它可能是有用的。下面说明了在全局非线性求解器范围内利用该方案的必要基本步骤。   
* [1.x.4]
* [2.x.31] func 一个一维函数，返回给定点的值和导数。   [2.x.32] f0 原点的函数值。   [2.x.33] g0 在原点的函数导数。   [2.x.34] interpolate 一个决定在缩放阶段如何进行内插的函数。它接受当前区间/括号（ [2.x.35] , [2.x.36] ）的值和导数，以及最多五个先前步骤的值和导数。返回的值应在给定的范围内提供。   [2.x.37] a1 包围阶段的初始试验步骤。   [2.x.38] eta 第二个沃尔夫条件（曲率条件）的一个参数。   [2.x.39] mu 第一个沃尔夫条件中的一个参数（充分减少）。   [2.x.40] a_max 允许的最大步长。   [2.x.41] max_evaluations 允许的最大函数求值数。   [2.x.42] debug_output 将额外的调试信息输出到[2.x.43]静态对象的标志。   [2.x.44] 该函数返回步长和函数[2.x.45]被调用的次数。 
* [0.x.7] Assert((f_lo < f_hi) && w1(a_lo, f_lo), ExcInternalError()) ; Assert((a_hi
* 
* - a_lo) g_lo < 0) && !w2(g_lo), ExcInternalError()); Assert((w1(a_hi, f_hi) || f_hi >= f_lo), ExcInternalError()。  
* [0.x.8]

