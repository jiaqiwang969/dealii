include/deal.II-translator/optimization/solver_bfgs_0.txt
[0.x.0]*
 实现有限内存BFGS最小化方法。
* 该类实现了一种方法，用于最小化一个给定的函数，对于该函数来说，只有该函数及其导数的值，但没有其二阶导数可用。BFGS方法是牛顿方法的一个变种，用于函数最小化，其中Hessian矩阵仅被近似。特别是，Hessian是用Broyden, Fletcher, Goldfarb和Shanno（BFGS）的公式更新的。

* 
* [1.x.0]
*为对称正定[2.x.0] 。有限内存变体通过双环递归实现。

* 
* [0.x.1]*
   数字类型。 
* [0.x.2]*
   标准化的数据结构，用于向求解器输送额外的数据。 
* [0.x.3]*
     构造函数。   
* [0.x.4]*
     最大历史尺寸。   
* [0.x.5]*
     打印额外的调试输出到deallog。   
* [0.x.6]*
   构造函数。 
* [0.x.7]*
   从初始状态[2.x.1]开始解决无约束的最小化问题[1.x.1] 函数[2.x.2]需要两个参数，表示[2.x.3]和梯度[2.x.4]的值。当被调用时，它需要更新给定位置 [2.x.6] 的梯度 [2.x.5] 并返回被最小化的函数值，即 [2.x.7] 。 
* [0.x.8]*
   连接一个槽，进行自定义行搜索。    给出函数值 [2.x.8] 未知值 [2.x.9] 梯度 [2.x.10] 和搜索方向 [2.x.11] 返回步骤 [2.x.13] 的大小 [2.x.12] ，并相应更新 [2.x.14] [2.x.15] 和 [2.x.16] 。 
* [0.x.9]*
   连接一个槽来执行一个自定义的预处理。    先决条件在两个循环递归中应用于向量`g`，使用位置增量`s`和梯度增量`y`的历史。    一种可能性是使用最古老的`s,y`对。 
* [1.x.2]
* 如果使用该类的代码没有给信号附加任何东西，则不进行预处理。 
* [0.x.10]*
   解算器的附加数据。 
* [0.x.11]*
   用于执行行搜索的信号。 
* [0.x.12]*
   用于执行预处理的信号。 
* [0.x.13]

