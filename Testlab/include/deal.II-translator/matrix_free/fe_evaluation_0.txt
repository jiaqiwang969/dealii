include/deal.II-translator/matrix_free/fe_evaluation_0.txt
[0.x.0]*
 这个FEEvaluation和FEFaceEvaluation类的基类处理与映射相关的信息，与使用中的自由度和有限元无关。该类为用户代码提供了访问功能，但除此之外没有任何公共构造函数，是不可见的。使用方法是通过FEEvaluation类来代替。
* 这个类有四个模板参数。
* [2.x.0] 该类要使用的dim尺寸
* [2.x.1] Number 数字格式，通常是[2.x.2]或[2.x.3] 。
* [2.x.4] is_face 该类是用于单元积分器（正交尺寸与空间尺寸相同）还是用于面积分器（正交尺寸少一个）。
* [2.x.5] VectorizedArrayType 以矢量方式处理的数组类型，默认为 VectorizedArray<Number>。
* 

* 
* [2.x.6] 目前只有VectorizedArray<Number, width>被支持作为VectorizedArrayType。
* 

* 

* 
* [2.x.7] 

 
* [0.x.1]*
   解构器。 
* [0.x.2]*
   返回[2.x.8]reinit()函数所调用的单元格在几何字段中的索引偏移。这个索引可以用来访问一个字段的索引，这个字段的压缩行为与几何体的Jacobian相同，例如，存储一个有效的系数tensors，将系数与几何体结合起来，以降低内存传输，作为可用的数据字段。 
* [0.x.3]*
   返回[2.x.9]函数被调用的单元格的类型。  有效值是[2.x.10]用于笛卡尔单元（允许相当大的数据压缩），[2.x.11]用于具有仿射映射的单元，[2.x.12]用于没有应用任何压缩存储的一般单元。 
* [0.x.4]*
   返回当前正在使用的ShapeInfo对象的引用。 
* [0.x.5]*
   返回当前正在使用的DoFInfo对象的引用。 
* [0.x.6]*
   返回从单位到实数单元的雅各布系数乘以正交权重的行列式。 
* [0.x.7]*
   返回定义为 [2.x.14] 的单位到实数单元之间映射的雅各布系数的反转和转置版本 [2.x.13] 。返回张量的[2.x.15]项包含[2.x.16]，即列是指参考空间坐标，行是指实单元坐标。因此，返回的张量代表一个协变变换，在[2.x.17]函数中用于通过乘法[2.x.18]将单元格梯度转换为实单元格上的梯度。 
* [0.x.8]*
   返回一个面的单位法向量。注意，一个面的两边都使用相同方向的法向量。对于在FaceToCellTopology中被列举为 "内部 "并在构造函数中被选择为 "is_interior_face=true "的面，这对应于外部法向量，而对于在FaceToCellTopology中被列举为 "外部 "并在构造函数中被选择为 "is_interior_face=false "的面，作为单一法向量的结果，法向量指向该元素中。   
* [2.x.19]只在`is_face == true`的情况下实现。 
* [0.x.9]*
   提供一个统一的接口来访问长度为[2.x.20]+[2.x.21]的向量Array字段中的数据，用于单元（普通读取）和面（间接寻址）。 
* [0.x.10]*
   为单元格（明读）和面（间接寻址）提供一个统一的接口来设置长度为[2.x.22] + [2.x.23]的矢量Array字段中的数据。 
* [0.x.11]*
   与上述相同，只是对于任意数据类型的VectorizedArrayType的长度[2.x.24]。 
* [0.x.12]*
   和上面一样，只是对于任意数据类型的VectorizedArrayType的长度为[2.x.25]。 
* [0.x.13]*
   返回这个FEEvaluation或FEFaceEvaluation所关联的单元格的id。 
* [0.x.14]*
   返回与此FEEvaluation/FEFaceEvaluation相关的单元格/面的id。 
* [0.x.15]*
   返回FEEvaluation的评估程序中局部自由度的编号，以有限元的标准编号为准。 
* [0.x.16]*
   返回一个ArrayView到内部内存，供临时使用。注意，在evaluation()和integration()调用过程中，这部分内存会被覆盖，所以不要认为它在这些调用中是稳定的。你可以写入的最大容量是3*dofs_per_cell+2*n_q_points。 
* [0.x.17]*
   返回当前单元格的正交公式的编号。 
* [0.x.18]*
   返回当前单元格或面的索引。 
* [0.x.19]*
   返回该类的活动FE索引，以便在hp-情况下有效地进行索引。 
* [0.x.20]*
   返回该类的活动正交索引，以便在hp情况下有效地进行索引。 
* [0.x.21]*
   返回底层的MatrixFree对象。 
* [0.x.22]*
   构造函数。为了防止用户直接使用这个类，做了保护。采取所有存储在MatrixFree中的数据。如果应用于在构造`matrix_free`时选择了多个正交公式的问题，`quad_no`允许选择适当的公式。 
* [0.x.23]*
   构造函数，功能减少，工作方式与FEValues类似。 
* [0.x.24]*
   复制构造函数。如果FEEvaluationBase是由映射、fe、正交和更新标志构建的，基于FEValues的底层几何评估将被深度复制，以便于与线程并行使用。 
* [0.x.25]*
   复制赋值运算符。如果FEEvaluationBase是由映射、fe、正交和更新标志构建的，基于FEValues的底层几何评估将被深度复制，以允许与线程并行使用。 
* [0.x.26]*
   这是所有数据字段的一般阵列。 
* [0.x.27]*
   这是 scratch_data_array 中用户可见的部分，只显示 scratch_data_array 的最后一部分。第一部分被 values_dofs, values_quad 等消耗了。 
* [0.x.28]*
   本单元格的正交公式的编号。 
* [0.x.29]*
   一个指向基础数据的指针。 
* [0.x.30]*
   一个指向底层DoF指数和约束描述的指针，用于构造时指定的组件。也包含在matrix_info中，但是如果我们存储一个对它的引用，可以简化代码。 
* [0.x.31]*
   指向结构中指定的正交公式从单位到实数单元的基础转换数据的指针。也包含在matrix_info中，但如果我们存储对它的引用，可以简化代码。 
* [0.x.32]*
   该类的活动FE索引，用于在hp情况下的有效索引。 
* [0.x.33]*
   该类的活动正交索引，用于在hp情况下的有效索引。 
* [0.x.34]*
   一个指向构造时指定的底层正交公式的指针。  也包含在matrix_info中，但是如果我们存储一个对它的引用，可以简化代码。 
* [0.x.35]*
   当前评估环境中正交点的数量。 
* [0.x.36]*
   一个指向单元格形状数据的指针，即构成张量积的正交点的值、梯度和一维的Hessians。也包含在matrix_info中，但是如果我们存储一个对它的引用，可以简化代码。 
* [0.x.37]*
   一个指向当前单元格的雅各布信息的指针。只有在非卡尔蒂斯单元上才设置为有用的值。 
* [0.x.38]*
   指向当前单元格的雅各布行列式的指针。如果在笛卡尔单元或具有恒定雅各布系数的单元上，这只是雅各布行列式，否则就是雅各布行列式乘以正交权。 
* [0.x.39]*
   一个指向面的法向量的指针。 
* [0.x.40]*
   一个指向面的法向量乘以雅各布式的指针。 
* [0.x.41]*
   一个指向基础正交公式的正交权重的指针。 
* [0.x.42]*
   在调用reinit()后，存储我们当前正在处理的单元格的编号。 
* [0.x.43]*
   根据定义的法线方向，保存一个面是内部还是外部面的信息的标志。 不用于单元格。 
* [0.x.44]*
   存储FEFaceEvaluation对象当前所指向的索引（内部面、外部面、与单元格相关的数据）。 
* [0.x.45]*
   在`is_face==true'的情况下，存储给定单元格内一个面的当前编号，使用`0'到`2*dim'之间的值。 
* [0.x.46]*
   存储给定的面相对于标准方向的方向，如果在标准方向，则为0。 
* [0.x.47]*
   存储给定面的子面索引。通常情况下，这个变量的值为[2.x.26]，以表示对整个面的整合，但如果当前的物理面有一个更精细的邻居，它就是一个子面，必须适当地缩放ShapeInfo中的条目。 
* [0.x.48]*
   在调用reinit()后，存储我们当前正在处理的单元格的类型。有效值是[2.x.27][2.x.28]和[2.x.29]，它们对MappingInfo中的雅各布变换的内部存储方式有不同的影响。 
* [0.x.49]*
   可以用各自的构造函数在空中生成FEValues的几何数据。 
* [0.x.50]*
 这是FEEvaluation类的基类。 该类通常不需要在用户代码中调用，也没有任何公共构造函数。使用方法是通过FEEvaluation类来代替。它实现了一个reinit方法，用于设置指针，以便快速执行对正交点的操作，访问[2.x.30][2.x.31]和[2.x.32]函数的向量函数，以及访问有限元函数的值和梯度的方法。它还继承了FEEvaluationBaseData类所提供的几何体访问功能。
* 这个类有五个模板参数。
* [2.x.33] 该类所使用的dim尺寸
* [2.x.34] n_components 解决PDEs系统时的矢量分量的数量。如果同一个操作被应用于一个PDE的几个分量（例如，一个矢量拉普拉斯方程），它们可以通过一个调用同时应用（而且通常更有效）。
* [2.x.35] 数字 Number 格式，通常为 [2.x.36] 或 [2.x.37] 。
* [2.x.38] is_face 该类是用于单元积分器（正交维度与空间维度相同）还是用于面积分器（正交维度少一个）？
* [2.x.39] VectorizedArrayType 以矢量方式处理的数组类型，默认为 VectorizedArray<Number>。
* 

* 
* [2.x.40] 目前只有VectorizedArray<Number, width>被支持作为VectorizedArrayType。
* 

* 

* 
* [2.x.41] 

 
* [0.x.51]*
    [2.x.42] 1：从向量中读取和写入向量  
* [0.x.52]*
   对于向量[2.x.43]读出当前单元格自由度上的数值，并在内部存储。与没有约束条件时的功能[2.x.44]类似，但它也包括来自悬挂节点的约束条件，所以可以把它也看作是与[2.x.45]类似的功能。注意，如果启用了矢量化，几个单元的DoF值会被设置。    如果向量上的某些约束条件是不均匀的，则使用函数read_dof_values_plain代替，并通过调用[2.x.46]为向量提供有用的数据，也是在受约束的位置，在线性系统的求解过程中访问向量条目时，临时解应该总是有均匀的约束，这种方法是正确的。    如果给定的向量模板类是块向量（通过模板函数[2.x.47]确定，该函数检查从[2.x.48]或[2.x.49]或[2.x.50]派生的向量，该函数从块向量的索引[2.x.52]开始读取[2.x.51]块 对于非块向量，[2.x.53]被忽略了。   
* [2.x.54] 如果这个类是在没有MatrixFree对象的情况下构建的，并且信息是通过[2.x.55]来获取的，那么这个类只使用一个单元，这个函数会提取给定单元上的基础分量的值。这个调用比通过MatrixFree对象完成的调用要慢，并且导致一个结构在基于这些值的评估例程中不能有效地使用矢量化（相反，[2.x.56]相同的副本被工作）。 
* [0.x.53]*
   对于矢量[2.x.57]读出当前单元格自由度上的值，并在内部存储。与函数[2.x.58]的功能相似 相对于read_dof_values函数，这个函数从向量中读出普通条目，而不考虑存储的约束。当约束条件已经通过先前调用[2.x.59]分布在向量上时，这种访问方式是合适的。当要使用不均匀的约束时，这个函数也是必要的，因为MatrixFree只能处理均匀的约束。注意，如果启用了矢量化，几个单元的DoF值会被设置。    如果给定的向量模板类是块向量（通过模板函数[2.x.60]确定，该函数检查从[2.x.61]或[2.x.62]或[2.x.63]派生的向量，该函数从块向量的索引[2.x.65]开始读取[2.x.64]块 对于非块向量，[2.x.66]被忽略了。   
* [2.x.67] 如果这个类是在没有MatrixFree对象的情况下构建的，并且信息是通过[2.x.68]来获取的，那么这个类只使用一个单元，这个函数提取给定单元上的基础分量的值。这个调用比通过MatrixFree对象完成的调用要慢，并且导致一个结构在基于这些值的评估例程中不能有效地使用矢量化（相反，[2.x.69]相同的副本被工作）。 
* [0.x.54]*
   获取内部存储在当前单元格的dof值的值，并将它们加到向量中[2.x.70]该函数在写操作过程中也应用约束。因此，其功能与函数[2.x.71]相似。如果启用了矢量化，则会使用几个单元的DoF值。    如果给定的向量模板类是块向量（通过模板函数[2.x.72]确定，该函数检查从[2.x.73]或[2.x.74]或[2.x.75]派生的向量，该函数写入块向量的[2.x.76]块，从索引[2.x.77]开始 对于非块向量，[2.x.78] 被忽略了。    [2.x.79]可以用来抑制对当前单元向量批中包含的一些单元的写入访问，例如，在本地时间步进的情况下，一些单元被排除在调用之外。比特集中的 "true "值意味着将处理相应的车道索引，而 "false "值则跳过该索引。默认设置是一个包含所有1的比特集，这将把累积的积分写到批次中的所有单元。   
* [2.x.80] 如果这个类是在没有MatrixFree对象的情况下构建的，并且信息是通过[2.x.81]来获取的，那么这个类只使用一个单元格，这个函数会提取给定单元格上的底层组件的值。这个调用比通过MatrixFree对象完成的调用要慢，并且导致一个结构在基于这些值的评估例程中不能有效地使用矢量化（相反，[2.x.82]相同的副本被工作）。 
* [0.x.55]*
   获取内部存储在当前单元格的自由度值，并将其写入向量[2.x.83]，该函数跳过了被约束的自由度。与distribution_local_to_global方法相反，当前单元格给出的位置上的旧值被覆盖。因此，如果一个自由度与一个以上的单元相关联（在连续有限元中很常见），这些值将被覆盖，只有最后写入的值被保留。请注意，在并行环境下，这个函数也可能触及其他MPI进程所拥有的自由度，因此，随后的更新或积累幽灵值（如[2.x.84]所做的）可能会使这个函数设置的自由度失效。    如果给定的向量模板类是块向量（通过模板函数[2.x.85]确定，该函数检查从[2.x.86]或[2.x.87]或[2.x.88]派生的向量，该函数从索引[2.x.90]开始向块向量的[2.x.89]块写入。 对于非块向量，[2.x.91]被忽略了。    [2.x.92]可以用来抑制对当前单元向量批中包含的一些单元的写入访问，例如，在本地时间步进的情况下，一些单元被排除在调用之外。  比特集中的 "true "值意味着将处理相应的车道索引，而 "false "值则跳过该索引。默认设置是一个包含所有1的bitset，它将把累积的积分写到批次中的所有单元。   
* [2.x.93] 如果这个类是在没有MatrixFree对象的情况下构建的，并且信息是通过[2.x.94]来获取的，那么这个类只使用一个单一的单元格，这个函数会提取给定单元格上的底层组件的值。这个调用比通过MatrixFree对象完成的调用要慢，并且导致一个结构在基于这些值的评估例程中不能有效地使用矢量化（相反，[2.x.95]相同的副本被工作）。 
* [0.x.56]*
   与set_dof_values()相同，但不解决约束。 
* [0.x.57]*
    [2.x.96] 2：访问正交点的数据或聚集矢量数据  
* [0.x.58]*
   返回索引为[2.x.97]dof的局部自由度的存储值。如果对象是矢量值的，就会给出一个矢量值的返回参数。因此，参数[2.x.98]最多可以运行到[2.x.99] dofs_per_component，而不是[2.x.100]，因为矢量值FE的不同成分会一起返回。请注意，当矢量化被启用时，来自几个单元的值被分组在一起。如果[2.x.101]是最后被调用的，那么该值就对应于那里设置的值。如果[2.x.102]是最后被调用的，那么它就对应于具有给定索引的测试函数的综合函数的值。    请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量情况（n_components == dim）重载了这个操作。 
* [0.x.59]*
   向包含自由度分量的字段写入一个值 [2.x.103] 向通过[2.x.104] get_dof_value访问的同一字段写入一个值。因此，一旦提交了一个值，从向量中读取的原始数据就会被覆盖。    请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量值情况（n_components == dim）重载了这个操作。 
* [0.x.60]*
   在调用[2.x.106]并设置了[2.x.107]后，返回正交点号[2.x.105]处的有限元函数值，或者调用[2.x.108]时已经存储在那里的值。 如果对象是矢量值的，将给出一个矢量值的返回参数。注意，当矢量化被启用时，来自几个单元的值被分组在一起。    请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量值情况（n_components == dim）重载了这一操作的特殊性。 
* [0.x.61]*
   向包含正交点上的值的字段写一个值，其成分为 [2.x.109] 通过get_value()访问同一个字段。如果在调用设置了[2.x.111]的函数[2.x.110]之前应用，这将指定由当前单元上的所有基函数测试并整合的值。    请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量情况（n_components == dim）重载了这个操作。 
* [0.x.62]*
   在用[2.x.114]调用[2.x.113]后，返回正交点[2.x.112]的有限元函数梯度，或用[2.x.115]调用后，返回存储在那里的值 注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和矢量情况（n_components == dim）重载了该操作，具有特殊性。 
* [0.x.63]*
   在调用[2.x.117]面的法线方向后，返回正交点号[2.x.116]的有限元函数的导数。 [2.x.118] 这个调用等同于调用get_gradient() get_normal_vector()，但将使用更有效的内部数据表示。    请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量情况（n_components == dim）重载了这个操作。 
* [0.x.64]*
   写一个贡献，这个贡献被梯度测试到包含分量为[2.x.119]的正交点上的值的字段，通过get_gradient()访问同一个字段。如果在函数[2.x.120]被调用之前应用，这指定了当前单元上所有基函数梯度测试的内容，并对其进行积分。    请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量情况（n_components == dim）重载了这个操作，并进行了特殊化处理。 
* [0.x.65]*
   编写一个贡献，该贡献由梯度测试到包含分量为[2.x.121]q_point的正交点上的值的域。与通过get_gradient()或get_normal_derivative()访问相同的字段。如果在函数[2.x.122]被调用之前应用，这指定了当前单元上所有基函数梯度的测试内容，并在此基础上进行积分。   
* [2.x.123] 这个操作将数据写到与submit_gradient()相同的字段。因此，只能使用这两者中的一个。通常情况下，对这个函数的潜在调用的贡献必须加到submit_gradient()的贡献中。   
* [2.x.124]派生类FEEvaluationAccess为标量情况（n_components == 1）和矢量情况（n_components == dim）重载了这个操作。 
* [0.x.66]*
   在调用[2.x.126]后，返回正交点号[2.x.125]处的有限元函数的Hessian。如果只需要Hessian的对角线甚至跟踪，即拉普拉斯，请使用以下其他函数。    请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量情况（n_components == dim）重载了这个操作。 
* [0.x.67]*
   在调用[2.x.128]后，返回正交点编号为[2.x.127]的有限元函数的对角线。注意，派生类FEEvaluationAccess对该操作进行了重载，并对标量情况（n_components == 1）和矢量情况（n_components == dim）进行了专业化处理。 
* [0.x.68]*
   在调用[2.x.130]后，返回正交点号[2.x.129]处的有限元函数的拉普拉斯（即Hessian的踪迹）。 与计算全部Hessian的情况相比，当只要求拉普拉斯时，可以节省一些操作。    请注意，派生类FEEvaluationAccess为标量情况（n_components == 1）和向量情况（n_components == dim）重载了这个操作。 
* [0.x.69]*
   在调用[2.x.132]后，返回正交点号[2.x.131]处的矢量值有限元的发散。    
* [2.x.133]仅对n_components_==dim有效。 
* [0.x.70]*
   在调用[2.x.135]evaluation(...,true,...)后，返回正交点号[2.x.134]处的矢量值有限元的对称梯度。它对应于<tt>0.5 (grad+grad<sup>T</sup>)</tt>。   
* [2.x.136]只对n_components_==dim有效。 
* [0.x.71]*
   在调用[2.x.138]evaluate(...,true,...)后，返回矢量场的卷积，[2.x.137]。   
* [2.x.139] 只对n_components_==dim有效。 
* [0.x.72]*
   写入一个贡献，这个贡献被发散测试到包含组件[2.x.140]的正交点上的值的字段，访问与通过[2.x.141]相同的字段，如果在调用函数[2.x.142]之前应用，这指定了由当前单元上的所有基函数梯度测试并整合的内容。   
* [2.x.143] 只对n_components_==dim有效。   
* [2.x.144] 该操作将数据写到与submit_gradient()相同的字段。因此，只能使用这两者中的一个。通常情况下，对这个函数的潜在调用的贡献必须加到submit_gradient()的贡献的对角线中。 
* [0.x.73]*
   写入一个贡献，该贡献被对称梯度测试到包含正交点上的值的字段，其分量为 [2.x.145] 通过[2.x.146]访问同一字段 如果在函数[2.x.147]被调用之前应用，这指定了对称梯度，它被当前单元上的所有基函数对称梯度测试并整合到。   
* [2.x.148] 只对n_components_==dim有效。   
* [2.x.149] 该操作将数据写到与submit_gradient()相同的字段。因此，只能使用这两者中的一个。通常情况下，对这个函数的潜在调用的贡献必须加到submit_gradient()的rank-2张量的相应条目中。 
* [0.x.74]*
   写下包含正交点上的值的curl的分量 [2.x.150] 通过[2.x.151]访问同一数据域     
* [2.x.152] 只对n_components_==dim有效。   
* [2.x.153] 该操作将数据写到与submit_gradient()相同的字段。因此，只能使用这两者中的一个。通常情况下，对这个函数的潜在调用的贡献必须加到submit_gradient()的rank-2张量的相应条目中。 
* [0.x.75]*
   取正交点的值，乘以雅各布行列式和正交权重（JxW），并对单元上所有正交点的值进行求和。其结果是一个标量，代表函数在单元上的积分。如果使用了一个矢量元素，结果的分量仍然是分开的。此外，如果启用了矢量化，几个单元的积分值将包含在返回的VectorizedArray字段的槽中。   
* [2.x.154] 如果FEEvaluation对象被初始化为一批单元，在SIMD向量VectorizedArray中并非所有的通道都代表实际数据，这个方法在虚拟数据（从最后一个有效通道复制的）上执行计算，将没有意义。因此，用户需要确保在任何计算中不明确地使用它，比如在对几个单元格的结果求和时。 
* [0.x.76]*
    [2.x.155] 3：对内部数据的访问  
* [0.x.77]*
   返回一个指向dof值的第一个字段的只读指针。这是read_dof_values()函数写进的数据字段。首先是第一个组件的dof值，然后是第二个组件的所有值，以此类推。这与这个类中使用的内部数据结构有关。一般来说，使用get_dof_value()函数来代替比较安全。 
* [0.x.78]*
   返回一个指向dof值的第一个字段的读写指针。  这是read_dof_values()函数写进的数据字段。首先是第一个组件的dof值，然后是第二个组件的所有值，以此类推。这与这个类中使用的内部数据结构有关。一般来说，使用get_dof_value()函数来代替比较安全。 
* [0.x.79]*
   返回一个指向正交点上函数值第一域的只读指针。首先是第一个分量的所有正交点上的函数值，然后是第二个分量的所有数值，以此类推。这与本类中使用的内部数据结构有关。调用[2.x.156]后的原始数据只包含单元格操作，所以可能的变换、正交权重等必须手动应用。一般来说，使用get_value()函数反而更安全，它在内部完成所有的转换。 
* [0.x.80]*
   返回一个指向正交点上的函数值的第一个字段的读和写指针。首先是第一个分量的所有正交点上的函数值，然后是第二个分量的所有数值，以此类推。这与本类中使用的内部数据结构有关。调用[2.x.157]后的原始数据只包含单元格操作，所以可能的变换、正交权重等必须手动应用。一般来说，使用get_value()函数反而更安全，它在内部完成所有的转换。 
* [0.x.81]*
   返回一个指向正交点上的函数梯度的第一个字段的只读指针。首先是所有正交点上第一个分量的梯度的x分量，然后是y分量，以此类推。接下来是第二个分量的x分量，以此类推。这与本类中使用的内部数据结构有关。调用[2.x.158]后的原始数据只包含单元格操作，所以可能的变换、正交权重等必须手动应用。一般来说，使用get_gradient()函数反而更安全，它在内部完成所有的变换。 
* [0.x.82]*
   返回一个指向正交点上函数梯度第一域的读写指针。首先是所有正交点上第一个分量的梯度的x分量，然后是y分量，以此类推。接下来是第二个分量的x分量，以此类推。这与本类中使用的内部数据结构有关。调用[2.x.159]后的原始数据只包含单元格操作，所以可能的变换、正交权重等必须手动应用。一般来说，使用get_gradient()函数反而更安全，它在内部完成所有的变换。 
* [0.x.83]*
   返回一个只读指针，指向正交点上的函数 hessians 的第一个字段。首先是所有正交点上第一个分量的 hessians 的 xx-分量，然后是 yy-分量，zz-分量（3D），然后是 xy-分量，以此类推。接下来是第二个分量的xx-分量，以此类推。这与本类中使用的内部数据结构有关。调用[2.x.160]后的原始数据只包含单元格操作，所以可能的变换、正交权重等必须手动应用。一般来说，使用get_laplacian()或get_hessian()函数来代替比较安全，它在内部完成所有的变换。 
* [0.x.84]*
   返回一个读写指针，指向正交点上的函数hesians的第一个字段。首先是所有正交点上第一个分量的 hessians 的 xx-分量，然后是 yy-分量，zz-分量（3D），然后是 xy-分量，以此类推。接下来是第二个分量的xx-分量，以此类推。这与本类中使用的内部数据结构有关。调用[2.x.161]后的原始数据只包含单元格操作，所以可能的变换、正交权重等必须手动应用。一般来说，使用get_laplacian()或get_hessian()函数来代替比较安全，它在内部完成所有的变换。 
* [0.x.85]*
   返回第一个选定的分量。 
* [0.x.86]*
   构造函数。为了防止用户直接使用这个类，做了保护。采取所有存储在MatrixFree中的数据。如果应用于有多个有限元或多个正交公式的问题，在构造[2.x.162] [2.x.163] [2.x.164] first_selected_component和[2.x.165]时，允许选择适当的组件。 
* [0.x.87]*
   构造函数，带有减少的功能，工作方式与FEValues类似。参数与传递给FEValues构造函数的参数类似，但明显的区别是，FEEvaluation期望一个一维的正交公式，Quadrature<1>，而不是[2.x.166]维的。有限元既可以是标量值，也可以是矢量值，但是这个方法每次总是只选择一个标量基元（按照类模板参数指定的[2.x.167]副本）。对于矢量值元素，可选的参数[2.x.168]允许指定用于评估的基元素的索引。注意，内部数据结构总是假定基元是原始的，目前不支持非原始的。    正如从FEValues中得知的那样，调用带有[2.x.169]的reinit方法是必要的，以使当前类的几何和自由度为人所知。如果迭代器包括DoFHandler信息（即它是[2.x.170]或类似的），初始化也允许以[2.x.171]类型的标准方式一次从向量中读取或写入一个单元。然而，这种方法比使用MPI的MatrixFree的路径要慢得多，因为必须进行索引转换。由于每次只使用一个单元，这种方法不会在几个元素上进行矢量化（这对矢量操作来说是最有效的），而只可能在元素内进行，如果评估/整合例程在用户代码内被结合起来（例如计算单元矩阵）。    可选的FEEvaluationBaseData对象允许几个FEEvaluation对象共享几何评估，也就是说，底层映射和正交点只需要评估一次。这只有在正交公式相同的情况下才有效。否则，将创建一个新的评估对象。当你打算将FEEvaluation对象与另一个对象并行使用时，请确保不要传递一个可选的对象，因为否则打算共享的对象可能会产生竞赛条件。 
* [0.x.88]*
   复制构造函数。如果FEEvaluationBase是由映射、fe、正交和更新标志构建的，基于FEValues的底层几何评估将被深度复制，以允许与线程并行使用。 
* [0.x.89]*
   复制赋值运算符。如果FEEvaluationBase是由映射、fe、正交和更新标志构建的，基于FEValues的底层几何评估将被深度复制，以便允许与线程并行使用。 
* [0.x.90]*
   一个统一的函数，根据给定的模板操作从向量中读出和写入向量。它可以对[2.x.172][2.x.173]和[2.x.174]进行操作，一次对几个向量进行操作。 
* [0.x.91]*
   一个统一的函数，基于给定的模板操作从向量中读出和写入向量，用于DG型方案，其中单元格上的所有自由度是连续的。它可以一次对多个向量进行read_dof_values()、distribut_local_to_global()和set_dof_values()的操作，具体取决于n_components。 
* [0.x.92]*
   一个统一的函数，在我们没有底层MatrixFree对象的情况下，根据给定的模板操作从向量中读取和写入向量。它可以对[2.x.175][2.x.176]和[2.x.177]进行操作。 它一次对几个向量进行操作，取决于n_components。 
* [0.x.93]*
   这个字段存储了局部自由度的值（例如，从矢量中读出后，但在应用单元格变换前或在将它们分配到结果矢量中之前）。get_dof_value()和submit_dof_value()方法从这个字段读取或写入。    这个数组的值存储在[2.x.178]的起始部分。由于其作为线程本地内存的访问，该内存可以在不同的调用之间得到重复使用。相对于在堆栈上请求内存，这种方法允许非常大的多项式程度。 
* [0.x.94]*
   这个字段存储了应用单元格变换后或积分前正交点上的有限元函数的值。  get_value()和submit_value()方法访问这个字段。    这个数组的值存储在[2.x.179]的起始部分。由于其作为线程本地内存的访问，内存可以在不同的调用之间得到重复使用。相对于在堆栈上请求内存，这种方法允许非常大的多项式程度。 
* [0.x.95]*
   这个字段存储了应用单元格变换后或积分前正交点上的有限元函数的梯度。get_gradient()和submit_gradient()方法（以及一些特殊的方法如get_symmetric_gradient()或get_divergence()）访问这个字段。    这个数组的值存储在[2.x.180]的起始部分。由于它作为线程本地内存的访问，内存可以在不同的调用之间得到重复使用。相对于在堆栈上请求内存，这种方法允许非常大的多项式程度。 
* [0.x.96]*
   这个字段存储了应用单元格变换后正交点上的有限元函数的Hessians。get_hessian(), get_laplacian(), get_hessian_diagonal()方法访问这个字段。    这个数组的值存储在[2.x.181]的起始部分。由于其作为线程本地内存的访问，该内存可以在不同的调用之间得到重复使用。相对于在堆栈上请求内存，这种方法允许非常大的多项式程度。 
* [0.x.97]*
   存储在MatrixFree存储类中检测到的有限元中的组件数量，以便与模板参数进行比较。 
* [0.x.98]*
   调试信息，跟踪dof值在访问前是否已被初始化。当使用未初始化的数据时，用于控制异常。 
* [0.x.99]*
   调试信息，跟踪正交点的值在访问前是否已经被初始化。用于控制使用未初始化数据时的异常情况。 
* [0.x.100]*
   调试信息，跟踪正交点上的梯度是否在访问前被初始化。用于控制使用未初始化数据时的异常情况。 
* [0.x.101]*
   调试信息，跟踪正交点上的Hessians在访问前是否已经被初始化。用于控制使用未初始化数据时的异常情况。 
* [0.x.102]*
   调试信息跟踪正交点上的值是否在实际盯住积分之前被提交给了积分。用于控制使用未初始化数据时的异常情况。 
* [0.x.103]*
   调试信息，跟踪正交点的梯度在积分实际被盯住之前是否已被提交用于积分。  用于控制使用未初始化数据时的异常情况。 
* [0.x.104]*
   对于一个有多个基元的FiniteElement，选择这个数据结构应该从哪个分量开始。 
* [0.x.105]*
   当初始化时没有给出MatrixFree对象时，需要一个临时数据结构来读取自由度。 
* [0.x.106]*
   将数值、梯度、赫西恩的指针设置为基类的中央scratch_data_array。 
* [0.x.107]*
 这个类提供对FEEvaluation类的数据字段的访问。通用访问是通过基类实现的，标量和矢量值元素的特殊化是单独定义的。
* 

* 
* [2.x.182] 

* 
* [0.x.108]*
   构造函数。为了防止在用户代码中进行初始化，该构造函数被保护起来。接受存储在MatrixFree中的所有数据。如果应用于有多个有限元的问题，或者在构造[2.x.183][2.x.184]和[2.x.185]quad_no时选择了多个正交公式，允许选择适当的组件。 
* [0.x.109]*
   构造函数的功能减少，用于类似于FEValues的FEEvaluation的用法，包括矩阵组装。 
* [0.x.110]*
   复制构造函数  
* [0.x.111]*
   拷贝赋值操作符  
* [0.x.112]*
 该类提供对FEEvaluation类的数据字段的访问。标量字段的部分特殊化，定义了对简单数据字段的访问，即标量的值和Tensor<1,dim>的梯度。
* 

* 
* [2.x.186] 

 
* [0.x.113]*
    [2.x.187] [2.x.188]   
* [0.x.114]*
    [2.x.189] [2.x.190] [2.x.190].   
* [0.x.115]*
    [2.x.191] [2.x.192] [2.x.192]。  
* [0.x.116]*
    [2.x.193] [2.x.194] [2.x.194]。  
* [0.x.117]*
    [2.x.195] [2.x.196] [2.x.196]。  
* [0.x.118]*
    [2.x.197] [2.x.198] [2.x.198].   
* [0.x.119]*
    [2.x.199] [2.x.200] [2.x.200]。  
* [0.x.120]*
    [2.x.201] [2.x.202]   
* [0.x.121]*
    [2.x.203] [2.x.204] [2.x.204]。  
* [0.x.122]*
    [2.x.205] [2.x.206] [2.x.206].   
* [0.x.123]*
    [2.x.207] [2.x.208]   
* [0.x.124]*
    [2.x.209] [2.x.210] [2.x.210].   
* [0.x.125]*
    [2.x.211] [2.x.212].   
* [0.x.126]*
   构造函数。为了避免在用户代码中进行初始化，做了保护。接受所有存储在MatrixFree中的数据。如果应用于有多个有限元的问题，或在构造[2.x.213] [2.x.214] 和 [2.x.215] quad_no时选择了多个正交公式，则允许选择适当的组件。 
* [0.x.127]*
   构造函数的功能减少，用于类似于FEValues的FEEvaluation的用法，包括矩阵组装。 
* [0.x.128]*
   复制构造函数  
* [0.x.129]*
   拷贝赋值操作符  
* [0.x.130]*
 该类提供对FEEvaluation类的数据字段的访问。对具有与基础空间维度一样多的分量的字段进行了部分专业化处理，即值是Tensor<1,dim>类型，梯度是Tensor<2,dim>类型。提供一些额外的访问函数，如对称梯度和发散。
* 

* 
* [2.x.216] 

* 
* [0.x.131]*
    [2.x.217] [2.x.218].   
* [0.x.132]*
   在调用[2.x.220]后，返回正交点号[2.x.219]的矢量值有限元的发散。  
* [0.x.133]*
   在调用[2.x.222]evaluation(...,true,...)后，返回在正交点号[2.x.221]处的矢量值有限元的对称梯度。它对应于<tt>0.5 (grad+grad<sup>T</sup>)</tt>。 
* [0.x.134]*
   在调用[2.x.224]evaluate(...,true,...)之后，返回矢量场的卷积，[2.x.223]。 
* [0.x.135]*
    [2.x.225] [2.x.226]。  
* [0.x.136]*
    [2.x.227] [2.x.228] [2.x.228].   
* [0.x.137]*
    [2.x.229] [2.x.230].   
* [0.x.138]*
   编写一个贡献，通过梯度对包含分量为[2.x.231]的正交点上的值的域进行测试，这个函数是其他submit_gradient函数的替代方案，当使用固定数量的方程组时，恰好与某些维度的维度重合，但不是全部。为了实现与维度无关的编程，可以使用这个函数来代替。 
* [0.x.139]*
   编写一个贡献，通过发散测试到包含正交点上的值的字段，组件 [2.x.232] 通过[2.x.233]访问相同的字段，如果在调用函数[2.x.234]之前应用，这指定了由当前单元上的所有基函数梯度测试并整合的内容。 
* [0.x.140]*
   写入一个贡献，这个贡献被对称梯度测试到包含正交点上的值的字段，其分量为 [2.x.235] 通过 [2.x.236] 访问同一个字段 如果在调用函数 [2.x.237] 之前应用，这指定了对称梯度，它被当前单元上的所有基函数对称梯度测试并整合在一起。 
* [0.x.141]*
   写下包含正交点[2.x.238]上的值的curl的分量 通过[2.x.239]访问相同的数据域。  
* [0.x.142]*
   构造函数。为了避免在用户代码中进行初始化，做了保护。取用存储在MatrixFree中的所有数据。如果应用于有多个有限元的问题，或在构建[2.x.240][2.x.241]和[2.x.242]quad_no时选择了多个正交公式，允许选择适当的组件。 
* [0.x.143]*
   构造函数的功能减少，用于类似于FEValues的FEEvaluation的用法，包括矩阵组装。 
* [0.x.144]*
   复制构造函数  
* [0.x.145]*
   拷贝赋值操作符  
* [0.x.146]*
 该类提供对FEEvaluation类的数据字段的访问。1d中标量字段的部分特殊化，定义了对简单数据字段的访问，即标量为值，Tensor<1,1>为梯度。
* 

* 
* [2.x.243] 

* 
* [0.x.147]*
    [2.x.244] [2.x.245] [2.x.245]。  
* [0.x.148]*
    [2.x.246] [2.x.247] [2.x.247].   
* [0.x.149]*
    [2.x.248] [2.x.249].   
* [0.x.150]*
    [2.x.250] [2.x.251].   
* [0.x.151]*
    [2.x.252] [2.x.253].   
* [0.x.152]*
    [2.x.254] [2.x.255].   
* [0.x.153]*
    [2.x.256] [2.x.257].   
* [0.x.154]*
    [2.x.258] [2.x.259].   
* [0.x.155]*
    [2.x.260] [2.x.261] [2.x.261]。  
* [0.x.156]*
    [2.x.262] [2.x.263].   
* [0.x.157]*
    [2.x.264] [2.x.265]   
* [0.x.158]*
    [2.x.266] [2.x.267] [2.x.267]。  
* [0.x.159]*
    [2.x.268] [2.x.269] [2.x.269].   
* [0.x.160]*
    [2.x.270] [2.x.271] [2.x.271]。  
* [0.x.161]*
    [2.x.272] [2.x.273] [2.x.273]。  
* [0.x.162]*
    [2.x.274] [2.x.275] [2.x.275].   
* [0.x.163]*
    [2.x.276] [2.x.277] [2.x.277]。  
* [0.x.164]*
   构造函数。为了避免在用户代码中进行初始化，做了保护。接受所有存储在MatrixFree中的数据。如果应用于有多个有限元的问题，或在构造[2.x.278][2.x.279]和[2.x.280]quad_no时选择了多个正交公式，允许选择适当的组件。 
* [0.x.165]*
   构造器的功能减少，用于类似FEValues的FEEvaluation的使用，包括矩阵组装。 
* [0.x.166]*
   复制构造函数  
* [0.x.167]*
   拷贝赋值操作符  
* [0.x.168]*
 该类提供了在正交点和单元格积分上评估函数所需的所有功能。在功能上，这个类与FEValues类似，但是，它包括很多专门的函数，使其速度更快（5到500之间，取决于多项式的程度）。对于DG中人脸项的评估，请参见类FEFaceEvaluation。
* [1.x.0]
* [1.x.1]
* 首要的使用方法是通过MatrixFree对象初始化这个类，该对象缓存了所有与自由度和映射信息相关的内容。这样，就有可能使用矢量化的方式，一次为几个单元应用微分算子。
* FEEvaluation的能力涵盖了大量的弱形式的积分任务。一般来说，有两类任务是可以完成的。一个是[2.x.281]路径，从解向量插值到正交点。
* 

* 
* [1.x.2]
* 
* 同样，由[2.x.282]矢量代表的有限元解的梯度可以通过[2.x.283] phi.get_gradient(q)插值到正交点。read_dof_values()、evaluate()和get_value()的组合与[2.x.284]或[2.x.285]所做的类似，但一般来说要快得多，因为它利用了张量积，见下面对评估例程的描述，并且可以通过矢量化一次为几个单元做这个操作。
* FEEvaluation完成的第二类任务是右手边的积分任务。在有限元计算中，这些任务通常包括将正交点上的一个量（一个函数值，或者一个由有限元空间本身插值的场）与一组测试函数相乘，通过对每个正交点的值进行求和，再乘以正交权重和变换的雅各布行列式，对单元进行积分。如果给定一个通用的Function对象，我们想计算[2.x.286]，这可以通过以下单元的积分来完成。
* 

* 
* [1.x.3]
* 
* 在这段代码中，对[2.x.287]的调用在实际积分之前为测试函数的乘法做了准备（在提交调用中，要测试的值也被乘以雅各布的行列式和正交的权重）。在[2.x.288]调用中，由FEEvaluation对象的每个基础函数（例如二维的FE_Q[2.x.289]的四个线性形状函数）测试的积分贡献被计算出来，这就给出了要加到[2.x.290]向量中的向量条目。需要注意的是，上面的代码需要明确地在向量数组中循环计算函数的分量，这对于与具有双参数的通用Function对象对接是必要的。简单的函数也可以直接用VectorizedArray形式实现，因为VectorizedArray提供了基本的数学运算。
* 对于评估一个双线性形式，在源向量上的评估与涉及测试函数的积分相结合，被写入结果向量中。这种设置是无矩阵算子求值的背景，在[2.x.291]和[2.x.292]的教程程序中解释过。
* 请注意，通过[2.x.293]和[2.x.294]的两个向量访问，基于[2.x.295]调用时指定的AffineConstraints对象，在飞行中解决约束。如果对自由度的值感兴趣（通常只需要正交点的值），可以通过[2.x.296]访问这些值，其中i是基函数的索引。请注意，FEEvaluation中连续元素自由度的编号与FE_Q（或FEValues）中的排序不同，因为FEEvaluation需要以lexicographic顺序访问它们，例如FE_DGQ中使用的就是这种排序。重新索引的成本太高，因为evaluate()和integration()里面的访问是在张量评估部分的关键路径上。在evaluate()调用之前，通过read_dof_values()填充DoF值的一个替代方法是通过set_dof_value()调用手动赋值。同样，如果积分的局部结果应该被进一步处理，而不是通过distribut_local_to_global()分散到一个向量中，我们可以在调用 integrate()后通过get_dof_value()来访问它。在不同背景下使用积分值的一个例子是快速装配矩阵，如下一小节所示。
* 对于大多数反复穿过网格的算子评估任务，MatrixFree的实现方式是将预先计算的映射数据（几何描述的雅各布变换）与基函数的即时评估相结合，是最有效的方式。换句话说，该框架在内存使用和对象的初始化之间选择了一种权衡，适合用无矩阵的方式替代矩阵-向量乘积或显式时间积分。
* [1.x.4]
* 第二种使用形式是通过FEValues生成的几何信息来初始化FEEvaluation。这允许在不事先初始化MatrixFree对象的情况下，即时应用积分循环。当MatrixFree的内存和初始化成本不可接受时，这可能很有用，例如，在误差计算中，不同数量的正交点应该被用于一次评估。另外，当使用这个类的例程来组装矩阵时，MatrixFree类所暗示的权衡可能是不可取的。在这种情况下，即时初始化必要的几何数据的成本是相当低的，因此避免全局对象MatrixFree是有用的。当以这种方式使用时，会使用让人想起带有单元格迭代器的FEValues的reinit方法。然而，请注意，这种模式的结果是一次只处理一个单元，几何数据在矢量化数组的所有组件中都是重复的。因此，只有在可以对不同的数据进行相同的操作时，矢量化才是有用的，例如在进行矩阵装配时。
* 作为一个例子，考虑下面的代码来组装对拉普拉斯矩阵的贡献。
* 

* 
* [1.x.5]
* 
* 这段代码用上面[2.x.297]的循环生成了单元格矩阵的列。这样做的方式如下。FEEvaluation的例程专注于有限元算子的评估，所以对于计算单元矩阵的算子评估，它被应用于单元上的所有单位向量。在单位向量上应用算子可能看起来效率不高，但这里使用的评估例程非常快，以至于它们的工作速度仍然比FEValues可能的要快得多。特别是，复杂度是 [2.x.298] 而不是 [2.x.299] 。
* 由于矢量化，我们可以一次生成几个单位向量的矩阵列（例如4）。变量[2.x.300]确保我们正确地做最后一次迭代，其中单元格的数量不被矢量化长度所除。还要注意的是，我们需要得到fe_eval应用的内部自由度编号，因为FEEvaluation内部使用的是自由度的词法编号，如上所述。
* [1.x.6]
* 用于保存局部自由度的求解值以及正交点的内插值、梯度和Hessians的临时数据是由[2.x.301]提供的Scratch数组，在对FEEvaluation的不同调用之间被重复使用。因此，构造一个FEEvaluation对象通常很便宜，不涉及任何昂贵的操作。在构建过程中，只有几十个指向实际数据字段的指针被设置。因此，在每个循环中多次创建一个FEEvaluation时，不会产生负面的性能影响，例如在一个`local_cell_operation`操作的顶部，该操作被分割成小块用于并行for循环，避免了在[2.x.302]的循环中需要单独的抓取数据字段。
* 当在多线程模式下使用FEEvaluation类时，MatrixFree中抓取数据的线程本地存储会自动确保每个线程得到它的私有数据阵列。然而，请注意，当所有的线程并行化是由外部提供的，而不是通过deal.II的例程完成的，如OpenMP，deal.II也必须被编译为支持线程。这是因为deal.II需要知道线程本地存储的符号。FEEvaluation内核已经被验证可以在OpenMP循环中工作。
* [1.x.7]
* 该类旨在通过显式矢量化来执行现代CPU上存在的单指令多数据（SIMD）指令的所有算术，这些指令在deal.II中通过类VectorizedArray提供，使用配置/编译时可用的最宽矢量宽度。为了保持程序的灵活性，FEEvaluation总是在几个元素上应用矢量化。这通常是最好的妥协，因为在有限元方法中，不同元素上的计算通常是独立的（当然，除了向全局残差向量添加积分贡献的过程），在更复杂的情况下也是如此。例如，稳定参数可以定义为一个单元的所有正交点上的某些量的最大值除以该单元的体积，但不需要将结果与邻接点进行局部混合。使用计算机结构的术语，FEEvaluation的设计依赖于在典型的集成场景下对单元进行操作时不做任何跨线数据交换。
* 当问题中的单元数不是SIMD向量中数组元素的倍数时，FEEvaluation的实现会在未使用的SIMD通道中填入一些假条目，并将它们带入周围，由于VectorizedArray的长度在编译时是固定的，所以这一选择是必要的。然而，与自动矢量化设置相比，这种方法通常会产生更好的代码，因为在自动矢量化设置中，除了在完全填充的通道上使用的矢量化版本外，还需要另一个未矢量化的代码路径，同时还有一个调度机制。在[2.x.303]中，对不完整的一批单元的reinit()调用所产生的空道被设置为零，而[2.x.304]或[2.x.305]则简单地忽略了空道中的内容。实际填充的SIMD通道的数量可以通过[2.x.306]来查询。
* 很明显，在人工通道上进行的计算（没有真实的数据）不应该与有效的结果混合。使用这个类的契约是，用户要确保通道在用户代码中不被交叉，特别是由于事先不清楚哪些单元会在矢量化中被放在一起。例如，除了通过全局向量访问方法或通过被屏蔽的访问[2.x.307]，一个元素上的结果不应该被添加到其他元素上的结果中。 不能保证人工车道上的结果永远是可以安全地添加到其他结果中的零。JxW或Jacobian上的数据是从最后一个有效车道复制的，以避免除以零，这可能引发浮点异常或其他情况下的麻烦。
* [1.x.8]
* 这个类包含了基于张量积正交公式和类似张量积的形状函数的元素的专门评估例程，包括标准的FE_Q或FE_DGQ元素和围绕0.5对称的正交点（像高斯正交），基于截断张量积的FE_DGP元素以及高斯-洛巴托正交元素的更快情况，它给出对角线质量矩阵和内部更快评估。该类的主要优点是在所有正交中评估所有形状函数，或者在[2.x.308]操作中对所有形状函数进行积分，而不是在FEValues的评估例程中的较慢的[2.x.309]复杂性。这是由一种叫做和因子化的算法完成的，该算法在沿坐标方向的评估过程中剔除了常数因子。这个算法是许多谱元算法的基础。
* 请注意，通过这个类可以进行的许多操作都是从基类FEEvaluationBase继承的，特别是对向量的读写。另外，该类继承了FEEvaluationAccess，实现了对正交点上有限元函数的值、梯度和Hessians的访问。
* 该类假定所考虑的有限元的形状函数[2.x.310]不[2.x.311]依赖于实空间中单元的几何形状。目前，其他有限元不能用无矩阵概念处理。
* [1.x.9]
* 该类FEEvaluation为两个使用模式。第一个使用模式是将多项式程度作为模板参数来指定。这保证了最大的效率。用和因数法进行评估时，会执行一些嵌套的短1D循环，其长度等于多项式度数加1。如果在编译时知道循环的边界，编译器可以根据其启发式方法认为最有效的方式展开循环。至少最里面的循环几乎总是被完全解开，避免了循环的开销。
* 然而，将多项式度数（以及正交点的数量）作为模板参数携带，在需要考虑不同的多项式度数的代码中，例如在通过输入文件给出多项式度数的应用代码中，事情就变得更加复杂。第二种使用模式是依靠预编译的代码来处理多项式度数。虽然用户代码可以为单元格使用不同的函数（这些函数会被一些动态调度机制调用，用于不同的度数模板），但deal.II也支持基于传递给初始化的元素中的信息来使用这个类。对于这种使用模式，将多项式程度的模板参数设置为
* 
* - 并为正交点的数量选择一个任意的数字。该代码部分包含预编译的模板代码，用于1到6之间的多项式度数和常见的正交公式，其运行速度几乎与模板版本相同。如果所选的度数没有被预编译，一个具有模板专业性的评估器对象将用于
* 
* -被调用，根据运行时间的界限运行。
* 下图给出了FEEvaluation的性能概览。它考虑了使用类似于[2.x.312]单精度算术教程程序的代码，用连续有限元评估拉普拉斯的每个自由度所花费的时间。该时间是基于英特尔至强E5-2687W v4单核的实验，运行频率为3.4GHz，在问题大小为1000万左右时测量的。该图列出了计算时间（约0.1秒）除以自由度数。
* [2.x.313] 
* 该图显示，模板化的计算核比非模板化的计算核快2.5到3倍。在这个设置上，最快的周转是对多项式5度的计算，每自由度7.4e-9秒，或每秒1.34亿自由度。
* 
* - 在一个单核上。非模板化版本在多项式5度时也是最快的，每个自由度2.1e-9秒，或每秒4800万自由度。注意，使用模板`degree=-1`的FEEvaluation会选择1到6度之间的快速路径，而其他度数则选择慢速路径。
* [1.x.10]
* 也可以为不同的最大多项式度数预先编译FEEvaluation中的代码。这由类[2.x.314]和`nclude/deal.II/matrix_free/evaluation_template_factory.templates.h`中的实现控制。通过设置宏`FE_EVAL_FACTORY_DEGREE_MAX`为所需的整数，并实例化类FEEvaluationFactory和FEFaceEvaluationFactory（后者用于FEFaceEvaluation），为可能更大的度数集创建模板函数的路径。你可以通过调用[2.x.315]或[2.x.316]来检查是否对一个给定的度数/n_正交点进行了快速评估/积分。
* [1.x.11]
* FEEvaluation还允许通过一个关于分量数量的模板参数来处理矢量值问题。
* 

* 
* [1.x.12]
* 
* 如果这样使用，可以通过调用从一个[2.x.317]的几个组件中收集组件
* 

* 
* [1.x.13]
* 
* 其中的0表示应该使用从[2.x.318]中的第2个向量开始的向量，<code>src[0], src[1], ..., src[n_components-1]</code>。
* 如果MatrixFree数据底层的DoFHandler是基于[2.x.319]n_components项的FESystem，那么读取多成分系统的另一种方式是可能的。在这种情况下，为read_dof_values()和distribut_local_to_global()调用提供一个单一的向量。
* FEEvaluation在多组件系统中的一个重要属性是在get_value()、get_gradient()或get_dof_value()调用中的多组件布局。在这种情况下，返回的不是标量字段 VectorizedArray [2.x.320] 而是张量。
* 

* 
* [1.x.14]
* 
* 与此类似，submit_value()和submit_gradient()调用的是张量的值。请注意，存在对[2.x.321]n_components=1和[2.x.322]的特殊化，它们是通过基类FEEvaluationAccess提供的。在标量情况下，这些提供了上述的标量返回类型。在矢量值的情况下，梯度从<code>Tensor [2.x.323] [2.x.324] [2.x.325]转换为<code>Tensor [2.x.326] [2.x.327]此外，额外的操作，如diveregence或curl也是可用的。
* 如果不同的形状函数被结合起来，例如Stokes流中的混合有限元公式，将创建两个FEEvaluation对象，一个用于速度，一个用于压力。然后在正交点上进行组合。
* 

* 
* [1.x.15]
* 
* 这段代码假设一个由两个分量组成的BlockVector分别描述了速度和压力分量。为了识别速度和压力的不同DoFHandler对象，FEEvaluation对象的第二个参数为速度指定各自的分量0，为压力指定1。对于矢量值问题的进一步例子，deal.II测试套件也包括一些额外的例子，例如，上面描述的斯托克斯算子可以在https://github.com/dealii/dealii/blob/master/tests/matrix_free/matrix_vector_stokes_noflux.cc
* [1.x.16]
* FEEvaluation和MatrixFree的设计将几何学与基函数分开。因此，几个DoFHandler对象（或者同一个DoFHandler配备了不同的约束对象）可以共享相同的几何信息，就像上面的Stokes例子一样。所有的几何体在MatrixFree中被缓存一次，所以FEEvaluation不需要做昂贵的初始化调用，而是设置一些指针。这种实现是基于这样的想法：当几个字段被评估时，也只需要一次几何信息，这与FEValues不同，后者为每个字段设置了内部映射数据。例如，如果一个多分量的PDE涉及到一个分量的形状值和另一个分量的形状梯度，如果两者都基于同一个MatrixFree对象，并且更新标志指定[2.x.328] update_values , [2.x.329] , 和 [2.x.330] 都给出，就不会失去效率。形状值所需数量的选择是通过evaluation()或integration调用中的标志和正交点的访问。
* 

* 
* [1.x.17]
* 
* 在正交点的循环中，我们可以要求两个FEEvaluation对象中的任何一个提供正交点的位置，这并不重要，因为它们只保留正交点数据的指针。
* 这一观察结果也转化为在程序中实现不同的微分算子的情况，例如，在算法的一个阶段，质量矩阵的作用，而在另一个阶段，刚度矩阵的作用。只需要一个MatrixFree对象，通过在不同的FEEvaluation对象中使用不同的局部函数和各自的实现来保持充分的效率。换句话说，用户在为MatrixFree的初始化提供update_flags时，不需要为了效率的原因而费心保守
* 
* - 除了在[2.x.332]调用里面最多增加一两个[2.x.331]语句外，FEEvaluation内部不会产生任何开销。相反，从效率的角度来看，所有调用中必要的最大标志集是完全没有问题的。
* 对于不同字段的组合，包括来自不同时间步骤的不同解向量，强制要求所有的FEEvaluation对象共享同一个MatrixFree对象。这是因为单元格被[2.x.333]循环的方式对于不同的DoFHandler或AffineConstraints参数可能不同。更确切地说，即使在串行中布局是相同的，但在MPI情况下，对于不同的DoFHandler/AffineConstraints的排序没有任何保证。原因是该算法检测需要与MPI进行数据交换的单元，而这些单元对于不同的元素可能会发生变化，例如，具有悬挂节点约束的FE_Q比FE_DGQ元素连接到更多的邻居，而需要数据交换的单元被放在单元循环中的不同位置。当然，如果设置了完全相同的DoFHandler、AffineConstraints和选项（如线程并行的设置），那么顺序就会相同，因为算法是确定性的。
* [2.x.334] 该类所使用的dim维度
* [2.x.335] fe_degree 每个坐标方向具有fe_degree+1个自由度的张量积有限元的程度。可以设置为
* 
* - 如果在编译时不知道度数，但性能通常会差2-3倍。
* [2.x.336] n_q_points_1d 一维正交公式中的点数，默认为fe_degree+1。
* [2.x.337] n_components 在求解PDEs系统时，向量分量的数量。如果同一个操作被应用于一个PDE的几个分量（例如，一个矢量拉普拉斯方程），它们可以通过一次调用同时应用（而且通常更有效）。默认为1。
* [2.x.338] 数字 数字格式，通常为[2.x.339]或[2.x.340] 默认为[2.x.341]双数
* 

* 
* [2.x.342] 

* 
* [0.x.169]*
   基类的别名。 
* [0.x.170]*
   一个作为模板参数指定的底层数字类型。 
* [0.x.171]*
   函数值的类型，例如 "n_components=1 "的 "VectorizedArrayType "或 "n_components=dim "的 "Tensor<1,dim,VectorizedArrayType>"。 
* [0.x.172]*
   梯度的类型，例如，`Tensor<1,dim,VectorizedArrayType>`代表`n_components=1`或者`Tensor<2,dim,VectorizedArrayType >`代表`n_components=dim`。 
* [0.x.173]*
   作为模板参数给出的尺寸。 
* [0.x.174]*
   作为模板参数给定的评估器的解决方案组件的数量。 
* [0.x.175]*
   从给定的模板参数`n_q_points_1d`确定的正交点的静态数量。请注意，如果给定了`fe_degree=-1`，并且使用了运行时的循环长度而不是编译时的循环长度，那么实际的正交点数量`n_q_points`可能不同。 
* [0.x.176]*
   根据给定的模板参数`fe_degree`确定的标量分量的静态自由度数。请注意，如果给定了`fe_degree=-1`，或者如果底层的类型比通常的FE_Q或FE_DGQ更复杂，如FE_DGP，那么实际的自由度`dofs_per_component`可能会不同。 
* [0.x.177]*
   根据给定的模板参数`fe_degree`确定的所有组件的静态自由度数。请注意，如果给定了`fe_degree=-1`，或者如果底层的类型比通常的FE_Q或FE_DGQ更复杂，比如FE_DGP，那么实际的自由度`dofs_per_cell`可能会不同。 
* [0.x.178]*
   根据给定的模板参数`fe_degree`确定的所有组件的静态自由度数。请注意，如果给定了`fe_degree=-1`，或者如果底层的类型比通常的FE_Q或FE_DGQ更复杂，比如FE_DGP，那么实际的自由度`dofs_per_cell`可能会不同。 
* [0.x.179]*
   构造函数。接受存储在MatrixFree中的所有数据。如果应用于在构建[2.x.343]过程中选择了一个以上的有限元或一个以上的正交公式的问题，可以通过可选的参数选择合适的组件。     [2.x.344] matrix_free 包含所有数据的数据对象 [2.x.345] dof_no 如果matrix_free是用多个DoFHandler对象设置的，这个参数可以选择给定的评估器应该连接到哪个DoFHandler/AffineConstraints对。     [2.x.346] quad_no 如果matrix_free被设置为多个正交对象，该参数将选择适当的正交公式编号。     [2.x.347] first_selected_component 如果由dof_no选择的dof_handler使用一个由多个组件组成的FESystem，这个参数允许选择当前评估程序开始的组件。注意，一个评估器不支持在不同的组件中结合不同的形状函数。换句话说，FESystem的同一个基本元素需要为[2.x.348]和[2.x.349]之间的组件设置。     [2.x.350] active_fe_index 如果matrix_free是用[2.x.351]的DoFHandler对象设置的，这个参数可以选择给定的评估器应该连接到哪个DoFHandler/AffineConstraints对。     [2.x.352] active_quad_index 如果matrix_free是用[2.x.353]对象设置的，该参数选择正交公式的适当编号。 
* [0.x.180]*
   构造函数。接受存储在MatrixFree中的所有数据，用于给定的单元格范围，这可以在p-adaptive策略的情况下自动识别active_fe_index和active_quad_index。    其余的参数与上面的构造函数相同。 
* [0.x.181]*
   构造函数，功能减少，工作方式与FEValues类似。参数与传递给FEValues的构造函数的参数类似，值得注意的是，FEEvaluation期望一个一维的正交公式Quadrature<1>，而不是一个[2.x.354]维的公式。有限元既可以是标量也可以是矢量值，但是这个方法每次总是只选择一个标量基元（按照类模板指定的[2.x.355]副本）。对于向量值元素，可选的参数[2.x.356]允许指定用于评估的基础元素的索引。注意，内部数据结构总是假定基元是原始的，目前不支持非原始的。    正如从FEValues中得知的那样，调用带有[2.x.357]的reinit方法是必要的，以使当前类的几何和自由度为人所知。如果迭代器包括DoFHandler信息（即它是一个[2.x.358]或类似的），初始化也允许以[2.x.359]类型的标准方式一次从向量中读取或写入一个单元。然而，这种方法比使用MPI的MatrixFree的路径要慢得多，因为必须进行索引转换。由于每次只使用一个单元，这种方法不会在几个元素上进行矢量化（这对矢量操作来说是最有效的），而只可能在元素内进行矢量化，如果评估/整合例程在用户代码内组合的话（例如，计算单元矩阵）。 
* [0.x.182]*
   缩小功能的构造函数。这个构造函数等同于另一个构造函数，除了它使对象隐含地使用[2.x.360]映射（即，MappingQGeneric(1)类型的对象）。 
* [0.x.183]*
   缩小功能的构造函数。类似于其他带有FiniteElement参数的构造函数，但使用另一个FEEvaluationBase对象来提供关于几何的信息。这允许几个FEEvaluation对象共享几何评估，即底层映射和正交点只需要评估一次。当你打算使用与给定对象平行的FEEvaluation对象时，请确保不要传递一个可选的对象，因为否则打算共享的对象可能会产生竞赛条件。 
* [0.x.184]*
   复制构造函数。如果FEEvaluationBase是由映射、fe、正交和更新标志构建的，基于FEValues的底层几何评估将被深度复制，以便允许与线程并行使用。 
* [0.x.185]*
   复制赋值运算符。如果FEEvaluationBase是由映射、fe、正交和更新标志构建的，基于FEValues的底层几何评估将被深度复制，以允许与线程并行使用。 
* [0.x.186]*
   将操作指针初始化为当前的单元格批索引。与下面以单元格迭代器为参数的reinit函数和[2.x.361]方法不同，与特定单元格相关的信息是在reinit调用中生成的，这个函数非常便宜，因为所有数据都是在[2.x.362]中预先计算的，只有少数指数需要适当设置。 
* [0.x.187]*
   如同FEValues中的惯例，使用TriaIterator对象将数据初始化到当前单元。参数类型为[2.x.363]或[2.x.364]只有在创建FEEvaluation对象时带有有限元、正交公式和正确的更新标志以及[1.x.18]MatrixFree对象时，该选项才能使用。这种初始化方法失去了使用矢量化的能力，另见FEEvaluation类的描述。当使用这种重启方法时，FEEvaluation也可以从向量中读取数据（但效率比来自MatrixFree的数据低）。 
* [0.x.188]*
   像在FEValues中一样使用TriaIterator对象将数据初始化到当前单元。这个选项只有在FEEvaluation对象是用有限元、正交公式和正确的更新标志以及[1.x.19]MatrixFree对象创建的情况下才可用。这种初始化方法失去了使用矢量化的能力，另见FEEvaluation类的描述。当使用这种重启方法时，FEEvaluation可以[1.x.20]从矢量中读取，因为没有DoFHandler信息可用。 
* [0.x.189]*
   检查是否支持面部评估/整合。 
* [0.x.190]*
   评估函数值、梯度和从输入矢量中的DoF值到单元格上的正交点的多项式内插的Hessians。 函数参数指定哪些部分应被实际计算。这个函数必须首先被调用，以便访问函数[2.x.365] [2.x.366] 或 [2.x.367] get_laplacian提供有用的信息（除非这些值已经被手动设置）。 
* [0.x.191]*
   和上面一样，但有单独的bool标志。   [2.x.368] 使用evaluate()与EvaluationFlags参数。 
* [0.x.192]*
   评估从输入数组[2.x.369] values_array中的DoF值到单元格上的正交点的函数值、梯度和多项式内插的Hessians。如果当前的FEEvaluation对象涉及多个部件，[2.x.370]中的排序是第一个部件的所有自由度排在前面，然后是第二个部件的所有自由度，以此类推。函数参数指定哪些部分应被实际计算。这个函数必须先被调用，这样访问函数[2.x.371][2.x.372]或[2.x.373]才能提供有用的信息（除非这些值是手动设置的）。 
* [0.x.193]*
   像上面一样，但使用单独的bool标志。   [2.x.374]使用evaluate()与EvaluationFlags参数。 
* [0.x.194]*
   从输入向量中读取并评估函数值、梯度以及从与当前单元格相关的[2.x.375]向量条目到单元格上的正交点的多项式内插的Hessians。函数参数指定哪些部分应被实际计算。这个函数必须首先被调用，以便访问函数[2.x.376] [2.x.377]或[2.x.378] get_laplacian提供有用的信息（除非这些值已经被手动设置）。    这个调用等同于调用read_dof_values()，然后再调用evaluate()，但内部可能会使用一些额外的优化。 
* [0.x.195]*
    [2.x.379] 请使用带有EvaluationFlags参数的 gather_evaluate()函数。 
* [0.x.196]*
   这个函数获取存储在正交点上的值和/或梯度，通过单元上的所有基函数/梯度进行测试，并执行单元积分。两个函数参数[2.x.380]和[2.x.381]分别用于启用/禁用提交给数值或梯度槽的贡献求和。结果被写入内部数据域[2.x.382]（通常由distribut_local_to_global()或set_dof_values()方法写入结果向量中）。 
* [0.x.197]*
    [2.x.383] 请使用带EvaluationFlags参数的 integrate() 函数。 
* [0.x.198]*
   该函数获取存储在正交点上的值和/或梯度，通过单元上的所有基函数/梯度进行测试，并执行单元积分。两个函数参数 [2.x.384] integrate_values 和 [2.x.385] 分别用于启用/禁用提交给数值或梯度槽的贡献的求和。与其他integration()方法相反，这个调用将测试结果存储在给定的数组[2.x.386]中，其先前的结果被覆盖，而不是写在begin_dof_values()后面的内部数据结构中。 
* [0.x.199]*
    [2.x.387] 请使用带EvaluationFlags参数的 integrate() 函数。 
* [0.x.200]*
   该函数获取存储在正交点上的值和/或梯度，通过单元上的所有基函数/梯度进行测试，执行单元积分，并将结果加入与当前单元索引相关的自由度上的全局向量[2.x.388]。两个函数参数[2.x.389]和[2.x.390]分别用于启用/禁用提交给数值或梯度槽的贡献求和。    这个调用等同于调用 integrate() 后面的 distribute_local_to_global() ，但可能在内部使用一些额外的优化。 
* [0.x.201]*
    [2.x.391] 请使用带有EvaluationFlags参数的 integrate_scatter() 函数。 
* [0.x.202]*
   返回存储在MappingInfo中的实坐标的第q个正交点。 
* [0.x.203]*
   底层评价对象的单元上的单个组件的自由度数。通常接近static_dofs_per_component，但这个数字取决于实际选择的元素，因此不是静态的。 
* [0.x.204]*
   单元上的自由度数量在当前评估对象的所有元件上累积。通常接近static_dofs_per_cell = static_dofs_per_component*n_components，但这个数字取决于所选择的实际元素，因此不是静态的。 
* [0.x.205]*
   使用中的正交点的数量。如果1d中的正交点数量是作为模板给出的，这个数字只是该值的<tt>dim</tt>-次幂。如果元素度数被设置为
* 
* -（元素度的动态选择），正交点的静态值就不准确了，必须用这个值来代替。 
* [0.x.206]*
   检查关于元素度的模板参数是否与初始化时使用的实际元素相一致。 
* [0.x.207]*
 该类提供了在正交点评估函数和面积分所需的所有函数。该类的设计与FEEvaluation相似，大部分接口与该类共享，特别是大部分访问函数来自共同的基类FEEvaluationAccess和FEEvaluationBase。此外，该类与FEEvaluation的关系类似于FEValues与FEFaceValues的关系。
* [2.x.392] 该类将被用于的dim尺寸
* [2.x.393] fe_degree 每个坐标方向具有fe_degree+1个自由度的张量积有限元的程度。如果设置为
* 
* - ，将使用底层元素的度数，它作为一个运行时常数，而不是减缓执行速度的编译时常数。
* [2.x.394] n_q_points_1d 一维正交公式中的点数，通常选择为fe_degree+1
* [2.x.395] n_components 在求解PDEs系统时，向量分量的数量。如果相同的操作应用于一个PDE的几个分量（例如一个矢量拉普拉斯方程），它们可以通过一次调用同时应用（而且通常更有效）。
* [2.x.396] 数字 Number 格式，通常为 [2.x.397] 或 [2.x.398] 。
* [2.x.399] VectorizedArrayType 以矢量方式处理的数组类型，默认为 VectorizedArray<Number>。
* 

* 
* [2.x.400] 目前只有VectorizedArray<Number, width>被支持作为VectorizedArrayType。

* 
* [0.x.208]*
   基类的别名。 
* [0.x.209]*
   一个作为模板参数指定的底层数字类型。 
* [0.x.210]*
   函数值的类型，例如 "n_components=1 "的 "VectorizedArrayType "或 "n_components=dim "的 "Tensor<1,dim,VectorizedArrayType>"。 
* [0.x.211]*
   梯度的类型，例如，`Tensor<1,dim,VectorizedArrayType>`代表`n_components=1`或`Tensor<2,dim,VectorizedArrayType >`代表`n_components=dim`。 
* [0.x.212]*
   作为模板参数给出的尺寸。 
* [0.x.213]*
   作为模板参数给定的评估器的解决方案组件的数量。 
* [0.x.214]*
   根据给定的模板参数`n_q_points_1d`确定的正交点的静态数量，取为dim-1的幂。请注意，如果给定了`fe_degree=-1`，并且使用了运行时的循环长度而不是编译时的长度，那么实际的正交点数量`n_q_points`可能不同。 
* [0.x.215]*
   一个单元格上具有相同正交公式的正交点的静态数量。请注意，这个值只是为了与单元格正交进行更简单的比较，因为实际的点数是由`static_n_q_points`变量赋予一个面的。 
* [0.x.216]*
   从给定的模板参数`fe_degree'确定的标量分量的静态自由度数。注意，如果给定`fe_degree=-1`，实际的自由度`dofs_per_component`可能不同。 
* [0.x.217]*
   根据给定的模板参数`fe_degree`确定的所有组件的静态自由度数。注意，如果给定了`fe_degree=-1`，实际的自由度`dofs_per_cell`可能不同。 
* [0.x.218]*
   根据给定的模板参数`fe_degree`确定的所有组件的静态自由度数。注意，如果给定了`fe_degree=-1`，实际的自由度`dofs_per_cell`可能不同。 
* [0.x.219]*
   构造函数。接受存储在MatrixFree中的所有数据。如果应用于在构造[2.x.401]过程中选择了一个以上的有限元或一个以上的正交公式的问题，可以通过可选的参数选择适当的组件。     [2.x.402] matrix_free 包含所有数据的数据对象 [2.x.403] is_interior_face 这选择了当前评估器将基于内部面的两个单元中的哪个。内部面是主要的面，法线向量是沿着它的方向的。来自另一侧的外部面提供了与内部面相同的法向量，所以如果想要该面的外部法向量，必须乘以
* 
* - .      [2.x.404] dof_no 如果matrix_free是用多个DoFHandler对象设置的，这个参数可以选择给定的评估器应该连接到哪个DoFHandler/AffineConstraints对。     [2.x.405] quad_no 如果matrix_free被设置为多个正交对象，该参数将选择适当的正交公式编号。     [2.x.406] first_selected_component 如果由dof_no选择的dof_handler使用一个由多个基本元素组成的FESystem，这个参数选择FESystem中的基本元素的编号。请注意，由于元素中可能存在多重性，这与各元素的分量没有直接关系。     [2.x.407] active_fe_index 如果matrix_free是用[2.x.408]的DoFHandler对象设置的，这个参数可以选择给定的评估器应该连接到哪个DoFHandler/AffineConstraints对。     [2.x.409] face_type 在面的情况下，指示其参考单元的类型（0代表线或四边形，1代表三角形）。     [2.x.410] active_quad_index 如果matrix_free是用[2.x.411]对象设置的，这个参数会选择正交公式的适当编号。 
* [0.x.220]*
   构造函数。接受存储在MatrixFree中的所有数据，用于给定的面的范围，这可以在p自适应策略的情况下自动识别active_fe_index和active_quad_index。    其余的参数与上面的构造函数相同。 
* [0.x.221]*
   将操作指针初始化为当前的面。这个方法是面集成的默认选择，因为MappingInfo中存储的数据是按照这个编号存储的。与下面以单元格迭代器为参数的reinit函数和[2.x.412]方法不同，与特定单元格相关的信息是在reinit调用中生成的，这个函数非常便宜，因为所有数据都是在[2.x.413]中预先计算的，只有少数索引和指针需要适当设置。 
* [0.x.222]*
   相对于基类中的reinit()方法，这个reinit()方法是针对给定的单元数和面数进行初始化。这个方法的效率低于其他采取面数的reinit()方法，因为它需要在这个调用中把与面数相关的数据复制到单元中。 
* [0.x.223]*
   检查是否支持面的评估/整合。 
* [0.x.224]*
   评估FE函数的函数值、梯度和Laplacians，这些都是存储在内部数据域`dof_values`中的DoF值（通常由read_dof_values()方法填充），在单元格上的正交点。 函数参数指定哪些部分应被实际计算。需要在函数get_value()、get_gradient()或get_normal_derivative()提供有用信息之前调用（除非这些值是通过访问内部数据指针手动设置的）。 
* [0.x.225]*
    [2.x.414] 请使用带EvaluationFlags参数的evaluation()函数。 
* [0.x.226]*
   评估FE函数的函数值、梯度以及在输入数组`values_array`中的DoF值在单元格上的正交点处给出的拉普拉斯。如果当前的FEEvaluation对象涉及多个组件，values_array中的排序是：第一个组件的所有自由度排在前面，然后是第二个组件的所有自由度，以此类推。函数参数指定哪些部分应被实际计算。需要在函数get_value()、get_gradient()或get_normal_derivative()提供有用信息之前调用（除非这些值已经被手动设置）。 
* [0.x.227]*
    [2.x.415] 请使用带EvaluationFlags参数的evaluation()函数。 
* [0.x.228]*
   从输入向量中读取并评估FE函数在单元格上的正交点的函数值、梯度和拉普拉斯。函数参数指定哪些部分应被实际计算。需要在函数get_value(), get_gradient(), 或get_normal_derivative()提供有用信息之前调用。    这个调用等同于调用read_dof_values()，然后再调用evaluate()，但内部可能会使用一些额外的优化措施。 
* [0.x.229]*
    [2.x.416] 请使用带有EvaluationFlags参数的gather_evaluate（）函数。 
* [0.x.230]*
   这个函数获取存储在正交点上的值和/或梯度，通过单元上的所有基函数/梯度来测试它们，并执行单元积分。两个函数参数`integrate_val`和`integrate_grad`用于启用/禁用某些值或梯度。结果被写入内部数据域`dof_values`（通常由distribut_local_to_global()或set_dof_values()方法写入结果向量中）。 
* [0.x.231]*
    [2.x.417] 请使用带EvaluationFlags参数的 integrate() 函数。 
* [0.x.232]*
   这个函数获取存储在正交点上的值和/或梯度，通过单元上的所有基函数/梯度进行测试，并执行单元积分。两个函数参数`integrate_val`和`integrate_grad`用于启用/禁用某些值或梯度。与其他 integrate()方法相反，这个调用将测试结果存储在给定的数组`values_array`中。 
* [0.x.233]*
    [2.x.418] 请使用带EvaluationFlags参数的 integrate() 函数。 
* [0.x.234]*
   这个函数获取存储在正交点上的值和/或梯度，通过单元上的所有基函数/梯度进行测试，并执行单元积分。两个函数参数`integrate_val`和`integrate_grad`用于启用/禁用某些值或梯度。    这个调用等同于调用 integrate() 后面的 distribute_local_to_global() ，但内部可能使用一些额外的优化。 
* [0.x.235]*
    [2.x.419] 请使用带有EvaluationFlags参数的 integrate_scatter() 函数。 
* [0.x.236]*
   返回存储在MappingInfo中的实坐标的面的第q个正交点。 
* [0.x.237]*
   底层评估对象的单元格上单个组件的自由度数。通常接近于static_dofs_per_component，但是这个数字取决于实际选择的元素，因此不是静态的。 
* [0.x.238]*
   单元上的自由度数量在当前评估对象的所有元件上累积。通常接近static_dofs_per_cell = static_dofs_per_component*n_components，但这个数字取决于所选择的实际元素，因此不是静态的。 
* [0.x.239]*
   使用中的正交点的数量。如果1d中的正交点的数量是作为模板给出的，这个数字只是该值的<tt>dim-1</tt>-次幂。如果元素度数被设置为
* 
* -（元素度的动态选择），正交点的静态值就不准确了，必须用这个值代替。 
* [0.x.240]*
   返回当前面批中每个面的面号。 
* [0.x.241]*
   确定当前面批中每个面的方向。 
* [0.x.242]*
   对标准向量（有begin()方法的）的实现。 
* [0.x.243]*
   对块状向量的实现。 
* [0.x.244]*
   对有begin()方法的向量的实现。 
* [0.x.245]*
   对所有其他向量（如块向量）的实现。 
* [0.x.246]

