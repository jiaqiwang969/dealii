include/deal.II-translator/matrix_free/task_info_0.txt
[0.x.0]*
   工作者对象的接口，该对象在无矩阵循环中运行我们要执行的各种操作。 
* [0.x.1]*
     一个收集与线程并行化有关的所有信息的结构。工作被细分为可以独立完成的任务。   
* [0.x.2]*
       构造函数。     
* [0.x.3]*
       清除所有的数据字段并将其重置为零。     
* [0.x.4]*
       运行无矩阵循环。     
* [0.x.5]*
       使只能在通信重叠中处理的单元格的数量被矢量化长度所除。     
* [0.x.6]*
       根据输入参数控制的选项，设置运行单元格循环的块。             [2.x.0] cells_with_comm 一个需要在执行计算前交换数据的单元的列表。这些将在分区中被赋予一定的id，以确保与通信重叠的单元格循环有准备好的幽灵数据。             [2.x.1] dofs_per_cell 给出一个单元上自由度数量的预期值，用于确定交错单元和面积分的块大小。             [2.x.2] categories_are_hp 定义`cell_vectorization_categories`是源于具有可变多项式程度的hp自适应计算还是用户定义的变体。             [2.x.3] cell_vectorization_categories 这组类别定义了在向量数组的通道内应该被分组的单元。这可以是hp-元素中的多项式程度，也可以是用户提供的分组。             [2.x.4] cell_vectorization_categories_strict 定义前面的变量所定义的类别是否应该被严格分开，或者是否允许将较低的类别插入到下一个较高的类别。             [2.x.5] parent_relation 这个数据字段用于指定哪些单元格有相同的父单元格。具有相同祖先的单元格被分组到同一批次（es），并在单元格之间进行矢量处理。             [2.x.6] 重新编号 当离开这个函数时，向量包含一个新的单元格编号，与存储在这个类中的分组一致。             [2.x.7] incompletely_filled_vectorization 鉴于本类的矢量布局，一些单元格批次可能在矢量数组（SIMD通道）中有未被使用的组件，并且不承载有效数据。这个数组根据这个函数返回的重新编号，指出发生这种情况的单元批处理。     
* [0.x.7]*
       任务并行分块设置的分块创建的第一步。             [2.x.8] boundary_cells 一个需要在执行计算前交换数据的单元格的列表。这些单元在分区中会被赋予一定的ID。             [2.x.9] 重新编号 当离开这个函数时，向量包含一个新的单元格编号，与存储在这个类中的分组一致（在实际创建任务之前）。             [2.x.10] incompletely_filled_vectorization 考虑到这个类的矢量布局，一些单元格批次可能在矢量数组（SIMD通道）中有未被使用的组件，并不承载有效数据。这个数组根据这个函数返回的重新编号，指出发生这种情况的单元批处理。     
* [0.x.8]*
       如果用户决定不通过[2.x.11]强制确定一个块的大小，这个辅助函数确定一个块的大小，这是根据系统的硬件线程数和我们应该工作的宏单元数计算出来的。     
* [0.x.9]*
       这个方法通过所有已经填入[2.x.12]dof_indices的单元，找出哪些单元可以独立工作，哪些单元是相邻的，在并行使用时需要在不同时间进行。            该策略是基于两层的方法。外层被细分为类似于Cuthill-McKee中邻居类型的分区，内层则通过颜色进行细分（对于同一颜色内的块，可以独立工作）。一个任务由一个单元块来代表。单元块在细分为分区和颜色之前就已经形成。             [2.x.13] 连通性（in/out） 判断单元格`i`和`j`是否冲突，用位置（i,j）的条目表示。             [2.x.14] 重新编号（in/out） 在输出时，该变量的元素j给出了单元格的原始编号，由于线程图的排序而被重新排序到j的位置。             [2.x.15] irregular_cells (in/out) 通知当前函数，对于给定的单元格批次索引，VectorizedArray中的一些SIMD通道是否不会被填充。             [2.x.16] hp_bool 定义我们是否在hp模式下。     
* [0.x.10]*
       这个函数会浏览所有已经填入[2.x.17] dof_indices的单元格，找出哪些单元格可以独立工作，哪些单元格是相邻的，在并行使用时需要在不同时间进行。            该策略是基于两层的方法。外层被细分为类似于Cuthill-McKee中邻居类型的分区，内层又被细分为类似Cuthill-McKee的分区（级别相差2以上的分区可以独立工作）。一个任务由一个单元块来代表。细胞块是在细分为两级分区后形成的。             [2.x.18] cell_active_fe_index 与所有单元格索引列表中的单个索引相对应的活动FE索引，以便能够不将具有不同索引的单元格放置在具有矢量化的同一单元格批次中。             [2.x.19] connectivity (in/out) 确定单元格`i`和`j`是否冲突，由位置（i,j）的条目表示。             [2.x.20] 重新编号（in/out） 在输出时，该变量的元素j给出了单元格的原始编号，由于线程图的排序而被重新排序到j的位置。             [2.x.21] irregular_cells (in/out) 通知当前函数，对于给定的单元格批次索引，VectorizedArray中的一些SIMD通道是否不会被填充。             [2.x.22] hp_bool 定义我们是否在hp模式下。     
* [0.x.11]*
       要么调用make_thread_graph_partition_color()，要么调用外部可访问的make_thread_graph_partition_partition()，这取决于数据结构中的设置。             [2.x.23] cell_active_fe_index 与所有单元格索引列表中的单个索引相对应的活动FE索引，以便能够不将具有不同索引的单元格放入同一个具有矢量的单元格批次中。             [2.x.24] connectivity (in/out) 确定单元格`i`和`j`是否冲突，用位置（i,j）的条目表示。             [2.x.25] 重新编号（in/out） 在输出时，该变量的元素j给出了单元格的原始编号，由于线程图的排序而被重新排序到j的位置。             [2.x.26] irregular_cells (in/out) 通知当前函数，对于给定的单元格批次索引，VectorizedArray中的一些SIMD通道是否不会被填充。             [2.x.27] hp_bool 定义我们是否在hp模式下。     
* [0.x.12]*
       这个函数从单个细胞之间的连接性计算出细胞块之间的连接性。     
* [0.x.13]*
       在每个分区内的第二层上创建着色的%函数。     
* [0.x.14]*
       在每个分区的第二层上创建分区的函数。     
* [0.x.15]*
       这个函数根据提供的连接图创建分区。             [2.x.28] connectivity （细胞块）之间的连通性 [2.x.29] cluster_size 每个分区的细胞数应该是cluster_size的倍数（用于以后的阻塞） [2.x.30] cell_partition 保存每个（细胞块）的分区，该块属于哪个分区 [2.x.31 ] partition_list partition_list[j] 给出了由于分区而应该重新编号为j的块的旧编号 [2.x.32] partition_size 指向每个分区的开始的矢量（在输出时） [2.x.33] partition 创建的分区数      
* [0.x.16]*
       为make_thread_graph中设置的任务图更新任务信息的字段。     
* [0.x.17]*
       从连接结构中创建一个任务图。     
* [0.x.18]*
       返回该类的内存消耗。     
* [0.x.19]*
       打印MPI进程的最小、平均和最大的内存消耗。     
* [0.x.20]*
       网格中的物理单元的数量，而不是矢量化后的单元批次      
* [0.x.21]*
       网格中的物理幽灵单元的数量，这些单元要进行特殊处理，不应包括在循环中。     
* [0.x.22]*
       SIMD阵列中用于矢量化的通道数量      
* [0.x.23]*
       用于多线程的块大小信息      
* [0.x.24]*
       用于多线程的块的数量      
* [0.x.25]*
       多线程应用的并行方案      
* [0.x.26]*
       块是由矢量的概念组织的，这个数据字段[2.x.34]在所有数据的线性存储中存储了一个 "矢量 "到下一个的距离，以两级划分。     
* [0.x.27]*
       这是所有分区的线性存储，在MatrixFree中所有单元的整数列表中建立一个形式为cell_partition_data[idx]到cell_partition_data[idx+1]的索引范围，通过[2.x.35]细分为大块。      
* [0.x.28]*
       像cell_partition_data一样，但对每个活动的fe索引有预先计算的子范围。分区的起点和终点由cell_partition_data_hp_ptr给出。     
* [0.x.29]*
       cell_partition_data_hp内的指针，表示一个分区的开始和结束。     
* [0.x.30]*
       这是对所有内面的分区的线性存储，在MatrixFree中所有内面的整数列表中建立一个形式为face_partition_data[idx]到face_partition_data[idx+1]的索引范围，按[2.x.36]partition_row_index细分为大块。     
* [0.x.31]*
       像face_partition_data一样，但对每个活动fe索引对都有预先计算的子范围。分区的起点和终点由face_partition_data_hp_ptr给出。     
* [0.x.32]*
       face_partition_data_hp内的指针，表示一个分区的开始和结束。     
* [0.x.33]*
       这是对边界面所有分区的线性存储，在MatrixFree中所有边界面的整数列表中建立一个形式为boundary_partition_data[idx]到boundary_partition_data[idx+1]的索引范围，按[2.x.37]partition_row_index细分为大块。     
* [0.x.34]*
       像boundary_partition_data一样，但对每个活动的fe索引有预先计算的子范围。分区的起点和终点是由boundary_partition_data_hp_ptr给出的。     
* [0.x.35]*
       boundary_partition_data_hp内的指针，表示一个分区的开始和结束。     
* [0.x.36]*
       这是对边界上所有内部面的分区的线性存储，以其他处理器不在本地使用的方式，在MatrixFree中所有此类面的整数列表中建立一个形式为ghost_face_partition_data[idx]到ghost_face_partition_data[idx+1]的索引范围，按[2.x.38] partition_row_index细分为大块。     
* [0.x.37]*
       这是一个线性存储多网格级别的所有面的分区，这些面有一个更粗的邻居，只包括在某些剩余计算中，但不包括在平滑中，在MatrixFree中所有这些面的整数列表中建立一个形式为refinement_edge_face_partition_data[idx]到refinement_edge_face_partition_data[idx+1]的索引范围，按[2.x.39] partition_row_index细分为几块。     
* [0.x.38]*
       将交给动态任务调度器的线程信息（从哪个块开始 "偶数 "分区）。     
* [0.x.39]*
       将线程信息（从哪个区块启动 "奇数 "分区）交给动态任务调度器      
* [0.x.40]*
       关于移交给动态任务调度器的分区的依赖性的线程信息      
* [0.x.41]*
       关于移交给动态任务调度器的分区的依赖关系的线程信息      
* [0.x.42]*
       在字段[2.x.40]中积累的偶数分区的数量partitions_even      
* [0.x.43]*
       场上累计的奇数分区数量 [2.x.41] partitions_odd      
* [0.x.44]*
       在该领域积累的被封锁工人的数量 [2.x.42] partition_n_blocked_workers      
* [0.x.45]*
       在该领域积累的工人数量 [2.x.43] 。      
* [0.x.46]*
       存储一个特定的任务是否处于MPI边界并需要数据交换      
* [0.x.47]*
       MPI通信器      
* [0.x.48]*
       共享内存的MPI通信器      
* [0.x.49]*
       MPI进程的等级      
* [0.x.50]*
       当前通信器的MPI等级的数量      
* [0.x.51]

