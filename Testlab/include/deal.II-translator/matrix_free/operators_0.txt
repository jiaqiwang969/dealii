include/deal.II-translator/matrix_free/operators_0.txt
[0.x.0]*
   无矩阵运算符的抽象基类，可以用于最细的网格或几何多网格中的某个层次。    派生类必须实现apply_add()方法以及compute_diagonal()来初始化受保护成员inverse_diagonal_entries和/或diagonal_entries。在非对称运算符的情况下，应该额外实现Tapply_add()。    目前，唯一支持的向量是[2.x.0]和[2.x.1] [1.x.0] MatrixFree允许使用几个DoFHandler/AffineConstraints组合，方法是在[2.x.3]函数中传递一个带有指向各自对象的指针的[2.x.2] 。该类支持在底层MatrixFree对象中只选择一些块，通过可选的整数列表来指定所选的块。    只在选定的块上构造无矩阵运算符的一个应用是[2.x.4]教程程序的设置。这个问题有三个[1.x.1]，一个用于速度，一个用于压力，一个用于温度。用于时间演化的时滞方案将温度方程从速度和压力的斯托克斯系统中分割出来。然而，还有一些交叉项，如进入温度平流-扩散方程的速度或进入速度右侧的温度。为了确保MatrixFree对不同的块使用相同的整数索引，人们需要将所有三个块放入同一个MatrixFree对象。然而，当求解一个线性系统时，所涉及的运算符要么在斯托克斯求解器中针对前两个，要么在温度求解器中针对最后一个。在前一种情况下，一个有两个分量的BlockVector将被选择，在MatrixFree中选择块{0, 1}，而在后一种情况下，将使用一个选择块{2}的非块向量。    选择的第二个应用是在具有牛顿式迭代的问题或具有不均匀边界条件的问题中。在这种情况下，我们必须处理两组不同的约束。一套约束条件适用于解向量，其中可能包括悬挂节点约束或周期性约束，但没有对不均匀的Dirichlet边界的约束。在非线性迭代之前，边界值被设置为向量中的预期值，代表初始猜测。在牛顿方法的每次迭代中，一个受零Dirichlet边界条件约束的线性系统被解决，然后被加入到初始猜测中。这个设置可以通过使用一个指向同一DoFHandler对象的两个指针的向量和一个指向两个AffineConstraints对象的两个指针的向量来实现。如果第一个AffineConstraints对象是包括零Dirichlet约束的对象，我们将给initialize()函数一个[2.x.5] int>(1, 0)，也就是说，一个长度为1的向量，正好选择索引为0的第一个AffineConstraints对象。    对PDEs系统来说，MatrixFree的不同块与方程的不同物理成分相关，仅仅为了边界条件的目的而添加另一个具有不同AffineConstraints参数的块可能导致繁琐的索引处理。相反，可以用不同的AffineConstraints对象设置第二个MatrixFree实例，但对块的解释相同，并使用它来插值不均匀的边界条件（也可参见[2.x.6]教程程序中结果部分的讨论）。   
* [1.x.2]
*   
* [0.x.1]*
     数字别名。   
* [0.x.2]*
     先决条件类所需的size_type。   
* [0.x.3]*
     默认构造函数。   
* [0.x.4]*
     虚拟解构器。   
* [0.x.5]*
     释放所有内存并返回到与调用默认构造函数后相同的状态。   
* [0.x.6]*
     初始化操作者在精细的规模上。        可选的选择向量允许从底层的MatrixFree对象中只选择一些组件，例如，只选择一个。矢量中的[2.x.7]项选择了DoFHandler和AffineConstraints对象，该对象被作为[2.x.8]参数给到[2.x.9]调用。    行和列的不同参数也使得选择非对角线块或矩形块成为可能。如果行向量为空，则选择所有组件，否则其大小必须小于或等于[2.x.10]，并且所有指数需要是唯一的，并且在0和[2.x.11]的范围内 如果列选择向量为空，其取值与行选择相同，定义一个对角块。   
* [0.x.7]*
     在一个层次[2.x.12]上对单个有限元素进行初始化操作。        可选的选择向量允许从底层的MatrixFree对象中只选择一些组件，例如只选择一个。矢量中的[2.x.13]项选择DoFHandler和AffineConstraints对象，该对象被作为[2.x.14]参数给到[2.x.15]调用。    由于多网格运算符总是与反转矩阵相关，因此代表对角线块，相对于非水平初始化函数，行和列的向量是相同的。如果是空的，所有的组件都被选中。   
* [0.x.8]*
     对多个FiniteElement对象进行水平[2.x.16]初始化操作。        可选的选择向量允许只从底层的MatrixFree对象中选择一些组件，例如，只选择一个。矢量中的[2.x.17]项选择DoFHandler和AffineConstraints对象，该对象被作为[2.x.18]参数给到[2.x.19]调用。    由于多网格运算符总是与反转矩阵相关，因此代表对角线块，相对于非水平初始化函数，行和列的向量是相同的。如果是空的，所有的组件都被选中。   
* [0.x.9]*
     返回共域（或范围）空间的维度。   
* [0.x.10]*
     返回域空间的维数。   
* [0.x.11]*
     接口的vmult运算符。   
* [0.x.12]*
     用于接口的vmult运算符。   
* [0.x.13]*
     矩阵-向量乘法。   
* [0.x.14]*
     转置矩阵-向量乘法。   
* [0.x.15]*
     加法 矩阵-向量乘法。   
* [0.x.16]*
     加法转置矩阵-向量乘法。   
* [0.x.17]*
     返回矩阵条目(row,col)的值。在无矩阵情况下，当对角线被初始化时，这个函数只对row==col有效。   
* [0.x.18]*
     确定此对象的内存消耗（以字节为单位）的估计值。   
* [0.x.19]*
     MatrixFree对象的initialize_dof_vector()的一个封装器。   
* [0.x.20]*
     计算此运算符的对角线。        派生类需要实现这个函数并相应地调整和填充保护成员inverse_diagonal_entries和/或diagonal_entries的大小。   
* [0.x.21]*
     获得对用该操作符存储的MatrixFree对象的读取权限。   
* [0.x.22]*
     获得对该运算符的反对角线的读取权限。   
* [0.x.23]*
     获取对这个运算符的对角线的读取权限。   
* [0.x.24]*
     应用雅可比预处理程序，该程序将<tt>src</tt>向量的每个元素乘以各自对角线元素的逆值，并将结果乘以松弛因子<tt>omega</tt>。   
* [0.x.25]*
     在调用mult_add()内的apply_add()或Tapply_add()之前，执行与约束有关的必要操作。   
* [0.x.26]*
     在调用mult_add()内的apply_add()或Tapply_add()后，执行与约束有关的必要操作。   
* [0.x.27]*
     将[2.x.20]的约束条目（包括来自悬挂节点和边缘约束）设为1。   
* [0.x.28]*
     对[2.x.21]应用运算符，并在[2.x.22]中添加结果。    
* [0.x.29]*
     对[2.x.23]应用转置运算符，并在[2.x.24]中添加结果 默认实现是调用apply_add()。   
* [0.x.30]*
     MatrixFree对象将与该操作符一起使用。   
* [0.x.31]*
     一个指向对角线矩阵的共享指针，将对角线元素作为一个向量存储。   
* [0.x.32]*
     一个指向对角线矩阵的共享指针，该矩阵将对角线元素的倒数作为一个向量存储。   
* [0.x.33]*
     一个向量，它定义了MatrixFree的子组件对矩阵表示的行的选择。   
* [0.x.34]*
     一个向量，它定义了矩阵表示的列的MatrixFree的子组件的选择。   
* [0.x.35]*
     如果操作者在GMG背景下使用，边缘上的DoF的索引。   
* [0.x.36]*
     辅助向量。   
* [0.x.37]*
     一个标志，决定该运算符在GMG背景下是否有接口矩阵。   
* [0.x.38]*
     实现vmult_add ( [2.x.25] = false) 和Tvmult_add ( [2.x.26] = true) 的%函数。   
* [0.x.39]*
     根据底层MatrixFree类的存储要求，调整向量的ghost范围。这在mult_add()以及vmult_interface_up()和vmult_interface_down()方法中使用，以确保单元格循环能够以正确的本地索引访问ghost索引。   
* [0.x.40]*
   辅助类，提供自适应几何多网格中需要的接口vmult/Tvmult方法。 [2.x.27]类应派生于[2.x.28]类。    deal.II中的自适应多网格实现了一种叫做局部平滑的方法。这意味着最细级别的平滑只覆盖固定（最细）网格级别所定义的网格的局部部分，而忽略了计算域中终端单元比该级别更粗的部分。随着该方法向更粗的级别发展，越来越多的全局网格将被覆盖。在某个更粗的层次上，整个网格将被覆盖。由于多网格方法中的所有层次矩阵都覆盖了网格中的单一层次，所以在层次矩阵上不会出现悬空节点。在多网格层之间的界面上，在平滑的同时设置同质Dirichlet边界条件。然而，当残差被转移到下一个更粗的层次时，需要考虑到多网格界面的耦合。  这是由所谓的界面（或边缘）矩阵来完成的，它计算了被具有同质Dirichlet条件的层次矩阵所遗漏的残差部分。我们参考[2.x.29]"Janssen和Kanschat的多网格论文 "以了解更多细节。    对于这些接口矩阵的实现，大部分基础设施已经到位，由[2.x.30]通过两个乘法例程vmult_interface_down()和vmult_interface_up()提供。MGInterfaceOperator所做的唯一事情是包装这些操作，并使它们可以通过[2.x.31]和[2.x.32]接口访问，正如多网格例程（最初是为矩阵编写的，因此期待这些名称）所期望的那样。  请注意，vmult_interface_down在多网格V周期的限制阶段使用，而vmult_interface_up在延长阶段使用。 
* [0.x.41]*
     编号别名。   
* [0.x.42]*
     尺寸类型。   
* [0.x.43]*
     默认构造函数。   
* [0.x.44]*
     清除指向OperatorType对象的指针。   
* [0.x.45]*
     用一个操作符来初始化这个类 [2.x.33]     
* [0.x.46]*
     vmult运算符，更多信息见类描述。   
* [0.x.47]*
     Tvmult运算符，更多信息见类的描述。   
* [0.x.48]*
     OperatorType对象的initialize_dof_vector()的封装器。   
* [0.x.49]*
     指向操作员类的常量指针。   
* [0.x.50]*
   该类实现了质量矩阵的反作用于元素的操作，适用于评估对象的正交点与单元自由度一样多的特殊情况。它使用FEEvaluation的算法，为DGQ元素产生精确的质量矩阵。该算法使用正交点上的反一维形状矩阵的张量乘积，因此反操作与在每个单元上应用正向操作一样昂贵。当然，对于连续有限元来说，这种运算并不能产生质量运算的逆运算，因为元素之间的耦合不能被这种运算所考虑。    方程可能包含可变系数，所以用户需要提供一个数组，用于局部系数的逆运算（该类提供了一个辅助方法'fill_inverse_JxW_values'来获得常数系数运算的逆运算）。 
* [0.x.51]*
     构造函数。从FEEval类中的ShapeInfo字段初始化形状信息。   
* [0.x.52]*
     在一个输入数组上应用反质量矩阵操作。假设传递的输入和输出数组的大小正确，即[2.x.34]长。本地系数的逆值（也包含逆JxW值）必须作为第一个参数传递。允许在系数中传递一个以上的分量。   
* [0.x.53]*
     在一个输入数组上应用反质量矩阵操作，使用由传递给该类构造函数的`fe_eval`参数提供的JxW值的逆值。注意，用户代码必须在底层评估器上调用[2.x.35]，以使[2.x.36]方法返回正确单元的信息。假设输入和输出数组的指针在长度[2.x.37]上是有效的，这个长度是这个函数处理的条目数。`in_array`和`out_array`参数可以指向相同的内存位置。   
* [0.x.54]*
     这个操作执行从正交点中给出的数据到这个对象的实际基础的投影。这个投影也可以解释为从正交点的拉格朗日插值多项式到当前`fe_eval`对象的基础的变化。        在一个数组上调用这个函数为    
* [1.x.3]
* 相当于    
* [1.x.4]
* 只要[2.x.38]持有正交权重的逆值，没有额外的系数。这种设置突出了基本的投影，测试了一个右手边，并应用了一个反质量矩阵。这个函数既适用于例子中描述的标量情况，也适用于逐个组件排列的多个组件。        与更繁琐的替代方法相比，给定的程序要快得多，因为它可以绕过[2.x.39]步骤和正交点转换的前半部分，将张量积调用的数量从3*dim*n_components减少到dim*n_components。   
* [0.x.55]*
     用JxW值的逆值填充给定数组，即系数为1的质量矩阵。非单位系数必须与该数组相乘（以反形式）。   
* [0.x.56]*
     对FEEvaluation对象的引用，用于获取JxW_值。   
* [0.x.57]*
   这个类实现了质量矩阵的动作操作。    请注意，这个类只支持Base操作的非阻塞矢量变体，因为在apply函数中只使用一个FEEvaluation对象。 
* [0.x.58]*
     数字别名。   
* [0.x.59]*
     先决条件类需要的size_type。   
* [0.x.60]*
     构造函数。   
* [0.x.61]*
     对于预处理，我们在对角线条目处存储一个块状的质量矩阵。   
* [0.x.62]*
     在一个输入向量上应用质量矩阵运算。假设通过的输入和输出向量使用initialize_dof_vector()进行了正确的初始化。   
* [0.x.63]*
     对于这个运算符，只有一个单元格的贡献。   
* [0.x.64]*
   这个类实现了拉普拉斯矩阵的作用的操作，即[2.x.40]，其中[2.x.41]是标量异质性系数。    请注意，这个类只支持Base操作的非阻塞矢量变体，因为在apply函数中只使用一个FEEvaluation对象。 
* [0.x.65]*
     数字别名。   
* [0.x.66]*
     先决条件类需要的size_type。   
* [0.x.67]*
     构造函数。   
* [0.x.68]*
     对角线是通过计算每个元素的局部对角线矩阵并将其分配给全局对角线来近似计算的。这将导致在有悬空节点的元素上出现错误的结果，但仍是一个可接受的近似值，可用于预处理程序中。   
* [0.x.69]*
     设置异质标量系数[2.x.42]，在正交点使用。表的行数需要与底层MatrixFree对象中的单元格批次一样多，[2.x.43]批次的数量与无矩阵运算符不在单个单元格上工作有关，而是由于矢量化而一次对单元格的批次工作。表可以采取两种不同的列数。 一种情况是选择它等于`dim`维度上的正交点总数，这是`n_q_points_1d`模板参数的`dim`次方。这里，`(*scalar_coefficient)(cell,q)`对应于单元批`cell`和正交点指数`q`上的系数值。第二个支持的变体是一个单列的表，在这种情况下，一个单元格的所有正交点都使用相同的可变系数值。        这种表可以通过以下方式初始化    
* [1.x.5]
*其中[2.x.44]是一个MatrixFree对象，[2.x.45]是一个函数，它提供了以下方法<code>VectorizedArray<double> value(const Point<dim, VectorizedArray<double> > &p_vec)</code>。        如果这个函数没有被调用，那么系数就被认为是统一的。        这个函数的参数是一个指向这样一个表的共享指针。该类存储了这个表的共享指针，而不是一个深度拷贝，并使用它来形成拉普拉斯矩阵。因此，你可以更新该表并重新使用当前对象，以获得具有该更新系数的拉普拉斯矩阵的动作。另外，如果表的值只需要填充一次，原来的共享指针也可以在用户代码中超出范围，clear()命令或这个类的析构器将删除表。   
* [0.x.70]*
     将所有数据结构重新设置为与新构建的对象相同的状态。   
* [0.x.71]*
     读/写对拉普拉斯运算器中使用的系数的访问。        如果之前没有通过set_coefficient()函数设置系数，该函数将抛出一个错误。   
* [0.x.72]*
     在一个输入矢量上应用拉普拉斯矩阵运算。假设传递的输入和输出向量已经用initialize_dof_vector()函数正确初始化。   
* [0.x.73]*
     在一个单元格上应用拉普拉斯算子。   
* [0.x.74]*
     在一个单元格上应用拉普拉斯算子的对角线部分。   
* [0.x.75]*
     在单元格上应用拉普拉斯算子[2.x.46]。    
* [0.x.76]*
     用户提供的异质性系数。   
* [0.x.77]

