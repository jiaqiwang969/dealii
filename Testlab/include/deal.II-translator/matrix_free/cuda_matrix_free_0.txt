include/deal.II-translator/matrix_free/cuda_matrix_free_0.txt
[0.x.0]*
   这个类收集了所有为矩阵自由实现而存储的数据。这个存储方案是针对用相同数据进行的几个循环而定制的，也就是说，通常在同一个网格上做许多矩阵-向量乘积或残差计算。    该类不实现任何涉及有限元基函数的操作，也就是说，关于在单元上进行的操作。对于这些操作，FEEvaluation类被设计为使用该类中收集的数据。    这个类实现了所有单元的循环（cell_loop()）。这个循环的调度方式是，共享自由度的单元不会同时工作，这意味着可以并行地写入向量，而不必明确地同步访问这些向量和矩阵。这个类没有实现任何形状值，它所做的只是缓存相应的数据。要实现有限元操作，请使用类 [2.x.0] 这个类以不同的顺序遍历单元，而不是通常的deal.II的Triangulation类。   
* [2.x.1] 只支持float和double。   
* [2.x.2]   
* [0.x.1]*
     使用的并行化方案：parallel_in_elem（自由度层面的并行）或 parallel_over_elem（单元格层面的并行）。   
* [0.x.2]*
     标准化的数据结构，用于向MatrixFree输送额外的数据。   
* [0.x.3]*
       构造函数。     
* [0.x.4]*
       使用的并行化方案，在自由度或单元上的并行化。     
* [0.x.5]*
       这个标志是用来决定哪些数量应该被缓存。该类可以缓存梯度计算（反雅各布）、雅各布行列式（JxW）、正交点以及Hessians（雅各布导数）的数据。默认情况下，只有梯度和雅各布行列式乘以正交权重JxW的数据被缓存。如果需要二次导数的正交点，必须由这个字段指定。     
* [0.x.6]*
       如果为真，使用图形着色。否则，使用原子操作。图形着色保证了位数的可重复性，但是在Pascal和较新的架构上会比较慢。     
* [0.x.7]*
        将MPI通信与计算重叠。这需要CUDA感知的MPI和use_coloring必须是假的。     
* [0.x.8]*
     传递给内核的结构。它用于将所有必要的信息从CPU传递给GPU。   
* [0.x.9]*
       指向正交点的指针。     
* [0.x.10]*
       将本地向量中的位置映射到全局向量中的位置。     
* [0.x.11]*
       指向反雅各布的指针。     
* [0.x.12]*
       指向Jacobian乘以权重的指针。     
* [0.x.13]*
       相关MatrixFree对象的ID。     
* [0.x.14]*
       单元的数量。     
* [0.x.15]*
       填充物的长度。     
* [0.x.16]*
       行开始（包括填充物）。     
* [0.x.17]*
       决定在一个给定的单元格上设置约束的掩码。     
* [0.x.18]*
       如果为真，则使用图形着色，我们可以简单地添加到目的地向量中。否则，使用原子操作。     
* [0.x.19]*
     默认构造函数。   
* [0.x.20]*
     解构器。   
* [0.x.21]*
     返回padding的长度。   
* [0.x.22]*
     提取在单元格上进行循环所需的信息。DoFHandler和AffineConstraints对象描述了自由度的布局，DoFHandler和映射描述了从单元到实数单元的转换，DoFHandler底层的有限元与正交公式一起描述了局部操作。这个函数需要一个IteratorFilters对象（谓词）来循环处理活动单元的一个子集。当使用MPI时，该谓词应过滤掉非本地拥有的单元。   
* [0.x.23]*
     与上述相同，使用[2.x.3]作为谓词。   
* [0.x.24]*
     初始化数据结构。与上述相同，但使用Q1映射。   
* [0.x.25]*
     返回与[2.x.4]相关的数据结构。    
* [0.x.26]*
     这个方法在所有单元格上运行循环，并在每个元素上并行应用局部操作。 [2.x.5]是一个漏斗，它被应用于每个颜色。         [2.x.6]需要定义 /code __device__ void operator()( const unsigned int cell, const typename [2.x.7] [2.x.8] [2.x.9] Number> shared_data, const Number src, Number dst) const; static const unsigned int n_dofs_1d; static const unsigned int n_local_dofs; static const unsigned int n_q_points; \endcode    
* [0.x.27]*
     这个方法在所有单元格上运行循环，并在每个元素上并行应用局部操作。这个函数与cell_loop()非常相似，但它使用了一个更简单的函数。         [2.x.10] 需要定义 /code __device__ void operator()( const unsigned int cell, const typename [2.x.11] [2.x.12] static const unsigned int n_dofs_1d; static const unsigned int n_local_dofs; static const unsigned int n_q_points; \endcode    
* [0.x.28]*
     从[2.x.13]复制约束项的值到[2.x.14]这是用来施加零迪里希特边界条件。   
* [0.x.29]*
     将[2.x.15]中对应于约束值的条目设置为[2.x.16] 这个函数的主要目的是将cell_loop()中使用的源向量的约束条目设置为零。   
* [0.x.30]*
     初始化一个序列向量。其大小与DoFHandler对象中的自由度数相对应。   
* [0.x.31]*
     初始化一个分布式向量。本地元素对应于本地拥有的自由度，鬼魂元素对应于（额外的）本地相关自由度。   
* [0.x.32]*
     返回本地拥有的活动单元的彩色图。   
* [0.x.33]*
     返回代表本地拥有的数据的分区器，以及单元格循环需要访问的幽灵索引。分区器是由各自字段给出的本地拥有的道夫和幽灵道夫构建的。如果你想知道这些对象的具体信息，你可以用各自的访问函数来查询它们。如果你只是想初始化一个（平行）向量，你通常应该更喜欢这种数据结构，因为数据交换信息可以从一个向量重复使用到另一个向量。   
* [0.x.34]*
     释放所有分配的内存。   
* [0.x.35]*
     返回DoFHandler。   
* [0.x.36]*
     返回这个类的内存消耗的近似值，单位是字节。   
* [0.x.37]*
     初始化数据结构。   
* [0.x.38]*
     帮助函数。循环所有的单元格，并在每个元素上并行地应用函数。这个函数在不使用MPI时使用。   
* [0.x.39]*
     辅助函数。在所有的单元格上循环，并在每个元素上平行地应用函数。这个函数在使用MPI的时候使用。   
* [0.x.40]*
     这个函数不应该被调用。调用它将导致一个内部错误。这个函数的存在只是因为cell_loop需要distributed_cell_loop()的存在，因为 [2.x.17]     
* [0.x.41]*
     帮助函数。将[2.x.18]的约束项的值复制到[2.x.19]这个函数在不使用MPI时使用。   
* [0.x.42]*
     帮助功能。将[2.x.20]的受限项的值复制到[2.x.21]中，该函数在使用MPI时使用。   
* [0.x.43]*
     这个函数永远不应该被调用。调用它将导致一个内部错误。这个函数的存在只是因为copy_constrained_values需要distributed_copy_constrained_values()存在[2.x.22] 。    
* [0.x.44]*
     帮助功能。将[2.x.23]的约束项设置为[2.x.24]，该函数在不使用MPI时使用。   
* [0.x.45]*
     帮助功能。将[2.x.25]的受限条目设置为[2.x.26] 当使用MPI时，该函数被使用。   
* [0.x.46]*
     这个函数永远不应该被调用。调用它将导致一个内部错误。这个函数的存在只是因为set_constrained_values需要distributed_set_constrained_values()存在[2.x.27] 。    
* [0.x.47]*
     与该对象相关的唯一ID。   
* [0.x.48]*
     使用的并行化方案，在自由度或单元上的并行化。   
* [0.x.49]*
     如果为真，使用图形着色。否则，使用原子操作。图形着色可以确保位数的可重复性，但是在Pascal和新的架构上会比较慢。   
* [0.x.50]*
      将MPI通信与计算重叠。这需要CUDA感知的MPI，并且use_coloring必须为假。   
* [0.x.51]*
     总自由度数。   
* [0.x.52]*
     所用有限元的度数。   
* [0.x.53]*
     每个单元的自由度数。   
* [0.x.54]*
     受限自由度的数量。   
* [0.x.55]*
     每个单元的正交点的数量。   
* [0.x.56]*
     图形着色算法产生的颜色数量。   
* [0.x.57]*
     每种颜色的单元格数量。   
* [0.x.58]*
     与每种颜色的单元格相关的正交点的指针矢量。   
* [0.x.59]*
     将本地向量中的位置映射到全局向量中的位置。   
* [0.x.60]*
     与每种颜色的单元格相关的反雅各布系数的指针向量。   
* [0.x.61]*
     指向每个颜色的单元格相关的雅各布系数乘以权重的矢量。   
* [0.x.62]*
     指向受限自由度的指针。   
* [0.x.63]*
     决定在一个给定单元上设置约束的掩码。   
* [0.x.64]*
     与不同颜色相关的网格尺寸。网格尺寸用于启动CUDA内核。   
* [0.x.65]*
     与不同颜色相关的块尺寸。块的尺寸用于启动CUDA内核。   
* [0.x.66]*
     用于cell_loop中的分布式矢量的共享指针。当不使用MPI时，该指针为空。   
* [0.x.67]*
     每块单元格（由函数cell_per_block_shmem()决定）。   
* [0.x.68]*
     用于启动CUDA内核的网格尺寸 in_constrained_values-operations.    
* [0.x.69]*
     用于启动CUDA内核的块状尺寸_受限值-操作。   
* [0.x.70]*
     填充物的长度（大于或等于线程数的最接近2的幂）。   
* [0.x.71]*
     每个颜色的行开始。   
* [0.x.72]*
     指向与该对象相关的DoFHandler的指针。   
* [0.x.73]*
     本地拥有的活动单元的彩色图谱。   
* [0.x.74]*
   用于将共享内存传递给一般用户函数的结构。 
* [0.x.75]*
     构造函数。   
* [0.x.76]*
     用于dof和quad值的共享内存。   
* [0.x.77]*
     参考坐标系中计算的梯度的共享内存。    每个方向的梯度以数组结构的形式保存，也就是说，首先，X方向的所有梯度都会被保存。   
* [0.x.78]*
   计算给定线程的本地单元中的正交点索引。     [2.x.28] [2.x.29]。  
* [0.x.79]*
   返回一个给定线程的本地正交点索引。该索引只对一个给定的MPI进程是唯一的。     [2.x.30] [2.x.31]   
* [0.x.80]*
   返回与给定线程相关的正交点。     [2.x.32] [2.x.33] *返回与指定线程相关的正交点。  
* [0.x.81]*
   传递给内核的结构。它用于将所有必要的信息从CPU传递给GPU。 
* [0.x.82]*
     正交点的矢量。   
* [0.x.83]*
     将本地向量中的位置映射到全局向量中的位置。   
* [0.x.84]*
     反雅各布系数的矢量。   
* [0.x.85]*
     雅各布系数乘以权重的向量。   
* [0.x.86]*
     相关MatrixFree对象的ID。   
* [0.x.87]*
     单元的数量。   
* [0.x.88]*
     填充物的长度。   
* [0.x.89]*
     行开始（包括填充物）。   
* [0.x.90]*
     决定在一个给定的单元格上设置约束的掩码。   
* [0.x.91]*
     如果为真，则使用图形着色，我们可以简单地添加到目的地向量中。否则，使用原子操作。   
* [0.x.92]*
   将[2.x.34]从设备复制到设备。 [2.x.35]应该与[2.x.36][2.x.37][2.x.38]中使用的相同。  
* [0.x.93]*
   这个函数是local_q_point_id()的主机版本。     [2.x.39] [2.x.40]   
* [0.x.94]*
   该函数是主机版的get_quadrature_point()。它假定MatrixFree<dim, [2.x.41]中的数据已经用copy_mf_data_to_host()复制到主机上了。     [2.x.42] [2.x.43]。  
* [0.x.95]

