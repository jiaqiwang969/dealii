include/deal.II-translator/matrix_free/matrix_free_0.txt
[0.x.0]*
 这个类收集了所有为矩阵自由实现而存储的数据。这个存储方案是针对用相同数据进行的几个循环而定制的，也就是说，通常在同一个网格上做许多矩阵-向量乘积或残差计算。该类在 [2.x.0] 和 [2.x.1] 中使用。
* 该类不实现任何涉及有限元基函数的操作，即关于对单元的操作。对于这些操作，FEEvaluation类被设计为使用该类中收集的数据。
* 存储的数据可以细分为三个主要部分。
* 

* 
* 
* - DoFInfo：它存储了局部自由度与全局自由度的关系。它包括对约束条件的描述，这些约束条件被评估为穿过一个单元上的所有局部自由度。
* 

* 
* 
* - MappingInfo：它存储了从实数到单位单元的转换，这些转换对于建立有限元函数的导数和找到物理空间中正交权重的位置是必要的。
 

* 
* 
* - ShapeInfo：它包含有限元的形状函数，在单元格上进行评估。
* 除了初始化程序，这个类只实现了一个单一的操作，即所有单元的循环（cell_loop()）。这个循环的安排方式是，共享自由度的单元不会同时工作，这意味着可以并行地写入向量（或矩阵），而不必明确地同步访问这些向量和矩阵。这个类没有实现任何形状值，它所做的只是缓存相应的数据。要实现有限元操作，请使用FEEvaluation类（或一些相关的类）。
* 这个类以不同的顺序遍历单元，与deal.II中通常的Triangulation类不同，以便在共享内存和矢量化的并行化方面具有灵活性。
* 矢量化是通过将几个拓扑单元合并成一个所谓的宏观单元来实现的。这使得几个单元的所有相关操作都可以用一条CPU指令来实现，这也是这个框架的主要特点之一。
* 关于这个类的使用细节，见FEEvaluation的描述或[2.x.2]"无矩阵模块"。
* 

* 
* [2.x.3] 

 
* [0.x.1]*
   由模板参数指定的底层数字类型的别名。 
* [0.x.2]*
   由模板参数`dim`设定的尺寸。 
* [0.x.3]*
   收集用于MatrixFree类初始化的选项。第一个参数指定要使用的MPI通信器，第二个参数是共享内存中的并行化选项（基于任务的并行化，可以选择无并行化和避免访问相同向量项的单元同时被访问的三种方案），第三个参数是任务并行调度的块大小，第四个参数是这个类应该存储的更新标志。    第五个参数指定了三角形中的级别，索引将从该级别开始使用。如果级别设置为[2.x.4]，将遍历活动单元，否则将遍历指定级别的单元。这个选项在给出DoFHandler的情况下没有影响。    参数[2.x.5]表示DoFInfo类是否也应该允许访问向量而不解决约束。    两个参数`initialize_indices`和`initialize_mapping`允许用户停用一些初始化过程。例如，如果只需要找到避免同时触及相同向量/矩阵指数的调度，就不需要初始化映射。同样，如果映射从一个迭代到下一个迭代发生了变化，但拓扑结构没有变化（比如使用MappingQEulerian的变形网格时），只需要初始化映射就足够了。    两个参数`cell_vectorization_categories`和`cell_vectorization_categories_strict`控制在几个单元上形成向量化的批次。它在使用hp-adaptivity时被隐含使用，但在其他情况下也很有用，比如在本地时间步进中，人们想控制哪些元素一起形成一批单元。数组`cell_vectorization_categories`在`mg_level`设置为[2.x.6]的情况下，通过cell->active_cell_index()访问活动单元，对于水平单元则通过cell->index()访问。默认情况下，`cell_vectorization_category`中的不同类别可以混合使用，如果算法内部需要，允许算法将较低的类别数字与下一个较高的类别合并，以尽可能避免部分填充的SIMD通道。这样可以更好地利用矢量，但可能需要特殊处理，特别是对面积分。如果设置为[2.x.7]，算法反而会将不同的类别分开，而不是将它们混合在一个矢量化数组中。 
* [0.x.4]*
     收集任务并行的选项。参见成员变量[2.x.8]的文档以获得详尽的描述。   
* [0.x.5]*
       以串行方式执行应用。     
* [0.x.6]*
       将单元格分成两层，之后形成块状。     
* [0.x.7]*
       在全局层面进行分区，并对分区内的单元格进行着色。     
* [0.x.8]*
       使用传统的着色算法：这就像[2.x.9]，但只使用一个分区。     
* [0.x.9]*
     附加数据的构造函数。   
* [0.x.10]*
     复制构造器。   
* [0.x.11]*
     拷贝赋值。   
* [0.x.12]*
     设置任务并行的方案。有四个选项可用。    如果设置为[2.x.10]，运算器的应用是以串行方式进行的，没有共享内存并行。如果这个类和MPI一起使用，并且MPI也用于节点内的并行，那么这个标志应该设置为[2.x.11]默认值是[2.x.12]，即我们实际上用下面描述的第一个选项使用多线程。        第一个选项[2.x.13]是在洋葱皮一样的分区中对单元格进行两级分割，并在分割后形成tasks_block_size的块。分区找到独立的单元组，使其能够在不同时访问相同的向量项的情况下并行工作。        第二种选择[2.x.14]是在全局层面上使用分区，并在分区内为单元格着色（在一个颜色内的所有块是独立的）。在这里，将单元格细分为若干块是在分区之前完成的，如果自由度没有被重新编号，可能会得到更差的分区，但缓存性能更好。        第三种方案[2.x.15]是在全局层面使用传统的着色算法。这种方案是第二种方案的一个特例，即只存在一个分区。请注意，对于有悬空节点的问题，有相当多的颜色（3D中为50种或更多），这可能会降低并行性能（不良的缓存行为，许多同步点）。       
* [2.x.16] 对于进行内面积分的情况，线程支持目前是实验性的，如果可能的话，建议使用MPI并行。虽然该方案已经验证了在通常的DG元素的情况下可以使用`partition_partition`选项，但对于更一般的元素系统，如连续和不连续元素的组合，对所有项添加面积分的情况，没有进行全面的测试。   
* [0.x.13]*
     设置应该形成一个分区的所谓宏单元的数量。如果给定的尺寸为零，该类会尝试根据[2.x.17]和存在的单元数为块找到一个好的尺寸。否则，将使用给定的数字。如果给定的数字大于总单元格数的三分之一，这意味着没有并行性。请注意，在使用矢量化的情况下，一个宏单元由一个以上的物理单元组成。   
* [0.x.14]*
     这个标志决定了单元格上的映射数据被缓存起来。该类可以缓存梯度计算（反雅各布）、雅各布行列式（JxW）、正交点以及Hessians（雅各布导数）的数据。默认情况下，只有梯度和雅各布行列式乘以正交权重JxW的数据被缓存。如果需要正交点或二次导数，它们必须由这个字段指定（即使这里没有设置这个选项，二次导数仍然可以在笛卡尔单元上评估，因为那里的雅各布系数完全描述了映射）。   
* [0.x.15]*
     这个标志决定了边界面上的映射数据要被缓存。注意MatrixFree对面的积分使用单独的循环布局，以便在悬空节点（需要在两边有不同的子面设置）或者在一个VectorizedArray的批次中的一些单元与边界相邻而其他单元不相邻的情况下也能有效地进行矢量。        如果设置为不同于update_general的值（默认），面的信息将被显式建立。目前，MatrixFree支持缓存以下面的数据：逆雅各布，雅各布行列式（JxW），正交点，Hessians数据（雅各布的导数），以及法向量。       
* [2.x.18]为了能够在[2.x.19]中执行 "face_operation "或 "boundary_operation"，这个字段或[2.x.20]必须被设置为与[2.x.21]不同的值。    
* [0.x.16]*
     这个标志决定了要缓存的内部面的映射数据。请注意，MatrixFree对面的积分使用单独的循环布局，以便在悬空节点（需要在两边有不同的子面设置）或者在一个VectorizedArray的批中的一些单元与边界相邻而其他单元不相邻的情况下也能有效地进行矢量化。        如果设置为不同于update_general的值（默认），面的信息将被显式建立。目前，MatrixFree支持缓存以下面的数据：逆雅各布，雅各布行列式（JxW），正交点，Hessians数据（雅各布的导数），以及法向量。       
* [2.x.22]为了能够在[2.x.23]中执行 "face_operation "或 "boundary_operation"，这个字段或[2.x.24]必须被设置为与[2.x.25]不同的值。    
* [0.x.17]*
     这个标志决定了不同布局的面的映射数据与矢量化的关系。当`mapping_update_flags_inner_faces`和`mapping_update_flags_boundary_faces`触发以面为中心的方式建立数据并进行适当的矢量化时，当前的数据域将面的信息附加到单元格及其矢量化的方式。这只在特殊情况下需要，例如在块状Jacobi方法中，单元格的全部算子包括其面都被评估。该数据由[2.x.26] face_number)</code>访问。然而，目前用这种方法不能计算到邻居的耦合项，因为邻居不是由VectorizedArray数据布局的数组-结构-数组类型的数据结构来布置的。        注意，你应该只在真正需要的情况下计算这个数据域，因为它使面的映射数据所需的内存增加了一倍以上。        如果设置为不同于update_general的值（默认值），就会显式地建立面的信息。目前，MatrixFree支持缓存以下面的数据：反Jacobian，Jacobian行列式（JxW），正交点，Hessians（Jacobian的导数）数据，以及法向量。   
* [0.x.18]*
     这个选项可以用来定义我们是否在网格的某一层工作，而不是活动单元。如果设置为invalid_unsigned_int (这是默认值)，就会对活动单元进行处理，否则就按这个参数给定的级别处理。请注意，如果你指定在一个层次上工作，其道夫必须通过使用[2.x.27]来分配。   
* [0.x.19]*
     控制是否启用从向量读取而不解决约束，即只读取向量的局部值。默认情况下，这个选项是启用的。如果你想使用[2.x.28]，这个标志需要被设置。   
* [0.x.20]*
     选项用于控制是否应该读取存储在DoFHandler中的索引，以及是否应该在MatrixFree的初始化方法中设置任务并行的模式。默认值是true。如果映射需要重新计算（例如，当使用通过MappingEulerian描述的变形网格时），但单元格的拓扑结构保持不变，可以禁用。   
* [0.x.21]*
     控制是否应该在MatrixFree的初始化方法中计算映射信息的选项。默认值为true。当只需要设置一些索引时可以禁用（例如，当只需要计算一组独立的单元格时）。   
* [0.x.22]*
     如果传递给循环的向量支持非阻塞数据交换，可以选择控制循环是否应该尽可能地重叠通信和计算。在大多数情况下，如果要发送的数据量超过几千字节，重叠会更快。如果发送的数据较少，在大多数集群上，通信是有延迟的（按照2016年的标准，在好的集群上，点到点的延迟大约是1微秒）。根据MPI实现和结构的不同，不重叠并等待数据的到来可能会更快。默认情况下是true，即通信和计算是重叠的。   
* [0.x.23]*
     默认情况下，面的部分将只保存那些要被本地处理的面（和面后面的鬼元素）。如果MatrixFree需要访问本地拥有的单元上的所有邻域，这个选项可以在面域的末端添加相应的面。   
* [0.x.24]*
     这个数据结构允许在建立矢量化信息时将一部分单元分配给不同的类别。在使用hp-adaptivity时，它被隐含地使用，但在其他情况下也是有用的，比如在本地时间步进中，人们想控制哪些元素共同构成一批单元。        在[2.x.29]设置为[2.x.30]的活动单元上工作时，通过cell->active_cell_index()给出的数字访问这个数组，对于水平单元则通过cell->index()访问。       
* [2.x.31] 这个字段在构建AdditionalData时是空的。用户有责任在填充数据时将此字段调整为`triangulation.n_active_cells()`或`triangulation.n_cells(level)`。   
* [0.x.25]*
     默认情况下，[2.x.32]中的不同类别可以混合，如果在算法内部有必要，允许算法将较低的类别与次高的类别合并。这样可以更好地利用矢量，但可能需要特殊处理，特别是对于面积分。如果设置为[2.x.33]，算法会将不同的类别分开，而不是将它们混合在一个矢量化的数组中。   
* [0.x.26]*
     共享内存的MPI通信器。默认值。MPI_COMM_SELF。   
* [0.x.27]*
    [2.x.34] 1：构造和初始化  
* [0.x.28]*
   默认的空构造函数。什么都不做。 
* [0.x.29]*
   复制构造函数，调用copy_from  
* [0.x.30]*
   解构器。 
* [0.x.31]*
   提取在单元格上进行循环所需的信息。DoFHandler和AffineConstraints对象描述了自由度的布局，DoFHandler和映射描述了从单元到实数单元的转换，而DoFHandler底层的有限元与正交公式一起描述了局部操作。请注意，DoFHandler底层的有限元必须是标量的，或者包含同一元素的几个副本。不允许将几个不同的元素混入一个FES系统。在这种情况下，使用带有几个DoFHandler参数的初始化函数。 
* [0.x.32]*
   初始化数据结构。和上面一样，但使用[2.x.35]的映射。     [2.x.36] 使用重载来代替Mapping对象。 
* [0.x.33]*
   提取在单元格上进行循环所需的信息。DoFHandler和AffineConstraints对象描述了自由度的布局，DoFHandler和映射描述了从单元到实数单元的转换，DoFHandler的基础有限元与正交公式一起描述了局部操作。与其他初始化函数处理的标量情况不同，这个函数允许有两个或多个不同的有限元的问题。每个元素的DoFHandlers必须作为指针传递给初始化函数。另外，一个由多个构件组成的系统也可以由一个带有FESystem元素的单一DoFHandler来表示。这种情况的前提条件是FESystem的每个基本元素必须与本类兼容，如FE_Q或FE_DGQ类。    这个函数也允许使用多个正交公式，例如当描述中包含不同程度的元素的独立积分时。然而，不同正交公式的数量可以独立于DoFHandlers的数量进行设置，当几个元素总是用同一个正交公式进行积分时。 
* [0.x.34]*
   初始化数据结构。与上述相同，但使用DoFHandlerType。     [2.x.37]使用获取DoFHandler对象的重载来代替。 
* [0.x.35]*
   初始化数据结构。和上面一样，但使用[2.x.38]的映射。     [2.x.39] 使用获取Mapping对象的重载来代替。 
* [0.x.36]*
   初始化数据结构。和上面一样，但使用DoFHandlerType。     [2.x.40] 使用获取DoFHandler对象的重载来代替。 
* [0.x.37]*
   初始化数据结构。和以前一样，但现在本地拥有的自由度范围的索引集描述取自DoFHandler。此外，只使用一个正交公式，当一个矢量值问题中的几个分量基于同一个正交公式被整合在一起时，这可能是必要的。 
* [0.x.38]*
   初始化数据结构。与上述相同，但使用DoFHandlerType。     [2.x.41]使用获取DoFHandler对象的重载来代替。 
* [0.x.39]*
   初始化数据结构。和上面一样，但使用[2.x.42]的映射。     [2.x.43] 使用获取映射对象的重载来代替。 
* [0.x.40]*
   初始化数据结构。和上面一样，但使用DoFHandlerType。     [2.x.44] 使用获取DoFHandler对象的重载来代替。 
* [0.x.41]*
   复制函数。创建一个所有数据结构的深度拷贝。通常情况下，为不同的操作保留一次数据就足够了，所以不应该经常需要这个函数。 
* [0.x.42]*
   当底层几何体发生变化（例如，通过像MappingFEField这样可以通过空间配置的变化而变形的映射）而网格和未知数的拓扑结构保持不变时，重新刷新存储在MappingInfo字段中的几何体数据。与reinit()相比，这个操作只需要重新生成几何体阵列，因此可以大大降低成本（取决于评估几何体的成本）。 
* [0.x.43]*
   与上述相同，但有[2.x.45]。  
* [0.x.44]*
   清除所有的数据字段，使类进入类似于调用了默认构造函数后的状态。 
* [0.x.45]*
   这个类定义了循环（）中的面积分的数据访问类型，它被传递给并行向量的`update_ghost_values`和`compress`函数，目的是能够减少必须交换的数据量。数据交换是一个真正的瓶颈，特别是对于高等级的DG方法，因此更严格的交换方式显然是有益的。请注意，这种选择只适用于分配给访问[2.x.46]的单元格外部的FEFaceEvaluation对象；所有[1.x.0]对象在任何情况下都是可用的。 
* [0.x.46]*
     循环不涉及任何FEFaceEvaluation对邻居的访问，就像只有边界积分（但没有内部面积分）或在类似[2.x.47]的设置中做质量矩阵时的情况。   
* [0.x.47]*
     循环只涉及到FEFaceEvaluation通过函数值访问邻居，如[2.x.48]的参数[2.x.49]，但没有访问形状函数导数（通常需要访问更多数据）。对于只有部分形状函数在面上有支持的FiniteElement类型，如FE_DGQ元素，其节点在元素表面的拉格朗日多项式，数据交换从`(k+1)^dim`减少到`(k+1)^(dim-1)`。   
* [0.x.48]*
     与上述相同。如果FEFaceEvaluation通过提供单元批号和一个面的编号而被重新初始化，则必须从外部面访问数据时使用。这种配置在以单元为中心的循环中很有用。         [2.x.50] [2.x.51] 必须启用。   
* [0.x.49]*
     循环确实涉及到FEFaceEvaluation通过函数值和梯度访问到邻居，但没有二阶导数，比如[2.x.52]设置了[2.x.53]和[2.x.54]。对于只有部分形状函数在一个面上有非零值和一阶导数的FiniteElement类型，例如FE_DGQHermite元素，数据交换会减少，例如从`(k+1)^dim`到`2(k+1)^(dim-1)`。请注意，对于不具备这种特殊属性的基数，无论如何都要发送完整的邻接数据。   
* [0.x.50]*
     与上述相同。如果FEFaceEvaluation通过提供单元格批号和一个面的编号而被重新初始化的话，要用于必须从外部面访问数据。这种配置在以单元为中心的循环中很有用。         [2.x.55] [2.x.56] 必须启用。   
* [0.x.51]*
     用户不想做限制的一般设置。这通常比其他选项更昂贵，但也是最保守的一种，因为要在本地计算的面后面的元素的全部数据将被交换。   
* [0.x.52]*
    [2.x.57] 2：无矩阵循环  
* [0.x.53]*
   这种方法在所有单元格上运行循环（并行），并在源向量和目的向量上执行MPI数据交换。     [2.x.58] cell_operation [2.x.59]，签名为<tt>cell_operation (const MatrixFree<dim,Number> &, OutVector &, InVector &, [2.x.60] int,unsigned int> &)</tt>，第一个参数传递调用类的数据，最后一个参数定义应该被处理的单元的范围（通常应该处理多个单元以减少开销）。 如果一个对象有一个具有正确参数集的`operator()`，人们可以在这个地方传递一个指针，因为这样的指针可以被转换为函数对象。     [2.x.61] dst 保存结果的目标向量。如果向量是[2.x.62]类型（或其复合对象，如[2.x.63]，循环在内部调用结束时调用[2.x.64]。对于其他向量，包括平行的Trilinos或PETSc向量，不发出这样的调用。请注意，Trilinos/Epetra或PETSc向量目前不能并行工作，因为本类使用MPI本地索引寻址，而不是这些外部库所暗示的全局寻址。     [2.x.65] src 输入向量。如果向量是[2.x.66]类型（或其复合对象，如[2.x.67]，则循环在内部调用开始时调用[2.x.68]，以确保所有必要的数据在本地可用。然而，请注意，在循环结束时，向量会被重置为原始状态，即如果向量在进入循环时没有被重影，那么在完成循环时也不会被重影。     [2.x.69] zero_dst_vector 如果这个标志被设置为`true`，向量`dst`将在循环内被设置为零。在你对矩阵对象进行典型的`vmult()`操作时使用这种情况，因为它通常会比在循环之前单独调用`dst = 0;`更快。这是因为向量项只在向量的子范围内被设置为零，确保向量项尽可能地留在缓存中。 
* [0.x.54]*
   这是第二个变种，在所有单元格上运行循环，现在提供一个指向`CLASS`类成员函数的函数指针。这种方法避免了定义lambda函数或调用[2.x.70]将类绑定到给定的函数中，以防本地函数需要访问类中的数据（即，它是一个非静态成员函数）。     [2.x.71] cell_operation 指向`CLASS`的成员函数，其签名为<tt>cell_operation (const MatrixFree<dim,Number> &, OutVector &, InVector &, [2.x.72] int,unsigned int> &)</tt>，其中第一个参数传递调用类的数据，最后一个参数定义应该被处理的单元范围（通常应该处理一个以上的单元以减少开销）。     [2.x.73] owning_class 提供`cell_operation`调用的对象。为了与该接口兼容，该类必须允许调用`owning_class->cell_operation(..)`。     [2.x.74] dst 保存结果的目标向量。如果向量是[2.x.75]类型（或其复合对象，如[2.x.76]，循环在内部调用结束时调用[2.x.77]。对于其他向量，包括平行的Trilinos或PETSc向量，不发出这样的调用。请注意，Trilinos/Epetra或PETSc向量目前不能并行工作，因为本类使用MPI本地索引寻址，而不是那些外部库所暗示的全局寻址。     [2.x.78] src 输入向量。如果向量是[2.x.79]类型（或其复合对象，如[2.x.80]），循环在内部调用开始时调用[2.x.81]，以确保所有必要的数据在本地可用。然而，请注意，在循环结束时，向量会被重置为原始状态，即如果向量在进入循环时没有被重影，那么在完成循环时也不会被重影。     [2.x.82] zero_dst_vector 如果这个标志被设置为`true`，向量`dst`将在循环中被设置为零。在你对矩阵对象进行典型的`vmult()`操作时使用这种情况，因为它通常会比在循环之前单独调用`dst = 0;`更快。这是因为向量项只在向量的子范围内被设置为零，确保向量项尽可能地留在缓存中。 
* [0.x.55]*
   与上述相同，但对于非const的类成员函数。 
* [0.x.56]*
   这个函数类似于cell_loop，用一个[2.x.83]对象来指定要对单元格进行的操作，但增加了两个额外的向量，在计算单元格积分前后执行一些额外的工作。    这两个额外的向量在自由度范围内工作，以MPI本地索引中选定的DoFHandler`dof_handler_index_pre_post`的自由度编号表示。向量的参数代表自由度范围，粒度为[2.x.84]个条目（除了最后一个块被设置为本地拥有的条目数），形式为`[first, last)`。这些向量的想法是使向量上的操作更接近于它们在无矩阵循环中的访问点，目的是通过时间上的定位来增加缓存的点击。这个循环保证了`operation_before_loop`在cell_operation（包括MPI数据交换）中第一次接触到所有相关的未知数之前，就已经击中了这些未知数，允许执行一些`src`向量依赖的向量更新。循环后的操作 "是类似的
* 

* 
* 

* 
 

 
 
* - 一旦该范围内的所有自由度被`cell_operation`最后一次触及（包括MPI数据交换），它就开始在该范围的自由度上执行，允许例如计算一些取决于当前`dst`中的单元循环结果的向量操作，或者想修改`src`。缓存的效率取决于自由度的编号，因为范围的粒度不同。     [2.x.85] cell_operation 指向`CLASS`的成员函数，签名为<tt>cell_operation (const MatrixFree<dim,Number> &, OutVector &, InVector &, [2.x.86] int,unsigned int> &)</tt>，第一个参数传递调用类的数据，最后一个参数定义应该被处理的单元范围（通常应该处理多个单元，以减少开销）。     [2.x.87] owning_class 提供`cell_operation`调用的对象。为了与该接口兼容，该类必须允许调用`owning_class->cell_operation(..)`。     [2.x.88] dst 保存结果的目标向量。如果向量是[2.x.89]类型（或其复合对象，如[2.x.90]，循环在内部调用结束时调用[2.x.91]。对于其他向量，包括平行的Trilinos或PETSc向量，不发出这样的调用。请注意，Trilinos/Epetra或PETSc向量目前不能并行工作，因为本类使用MPI本地索引寻址，而不是这些外部库所暗示的全局寻址。     [2.x.92] src 输入向量。如果向量是[2.x.93]类型（或其复合对象，如[2.x.94]），循环在内部调用开始时调用[2.x.95]，以确保所有必要的数据在本地可用。然而，请注意，在循环结束时，向量被重置为其原始状态，即如果向量在进入循环时没有被重影，那么在完成循环时也不会被重影。     [2.x.96] operation_before_loop 这个函数可以用来对`src'和`dst'向量（或其他向量）的条目进行操作，在对单元的操作第一次接触到特定的DoF之前，根据上面文本中的一般描述。这个函数被传递给选定的`dof_handler_index_pre_post`（用MPI本地编号）上的本地拥有的自由度范围。     [2.x.97] operation_after_loop 这个函数可以用来对`src'和`dst'向量（或其他向量）的条目进行操作，在对单元的操作最后触及一个特定的DoF之后，根据上面文字的一般描述。这个函数被传递给选定的`dof_handler_index_pre_post`（以MPI本地编号）上的本地拥有的自由度范围。     [2.x.98] dof_handler_index_pre_post 由于MatrixFree可以用DoFHandler对象的矢量初始化，一般来说，每个对象都会有矢量大小，因此返回给`operation_before_loop`和`operation_after_loop`的范围也不同。使用这个变量来指定索引范围应该与哪一个DoFHandler对象相关。默认为`dof_handler_index` 0。   
* [2.x.99] `operation_before_loop`和`operation_after_loop`的近距离定位目前只在仅MPI的情况下实现。在启用线程的情况下，由于复杂的依赖关系，完整的`operation_before_loop`被安排在并行循环之前，而`operation_after_loop`被严格安排在之后。 
* [0.x.57]*
   与上述相同，但对于非const的类成员函数。 
* [0.x.58]*
   同上，但取一个[2.x.100]作为`cell_operation`，而不是类成员函数。 
* [0.x.59]*
   这个方法在所有单元格上运行一个循环（并行），并在源向量和目的向量上执行MPI数据交换。与其他只在单元格上运行一个函数的变体不同，这个方法还分别以内部面和边界面的函数为参数。     [2.x.101] cell_operation [2.x.102] 的签名为<tt>cell_operation (const MatrixFree<dim,Number> &, OutVector &, InVector &, [2.x.103] int,unsigned int> &)</tt>，第一个参数传递调用类的数据，最后一个参数定义应该被处理的单元的范围（通常应该处理一个以上的单元以减少开销）。如果有一个[2.x.104]具有正确的参数集，人们可以在这个地方传递一个对象的指针，因为这样的指针可以被转换为函数对象。     [2.x.105] face_operation [2.x.106] 的签名是<tt>face_operation (const MatrixFree<dim,Number> &, OutVector &, InVector &, [2.x.107] int,unsigned int> &)</tt>，类似于`cell_operation`，但现在是与内部面的工作有关的部分。请注意，MatrixFree框架将周期性面视为内部面，因此，在调用face_operation时应用周期性约束后，它们将被分配到正确的邻居。     [2.x.108] boundary_operation [2.x.109] 签名为<tt>boundary_operation (const MatrixFree<dim,Number> &, OutVector &, InVector &, [2.x.110] int,unsigned int> &)</tt>，与`cell_operation`和`face_operation`类似，但现在是与边界面的工作相关的部分。边界面是由它们的`boundary_id'分开的，可以用[2.x.111]来查询这个id。注意，内部和面都使用相同的编号，内部的面被分配的编号比边界面低。     [2.x.112] dst 保存结果的目的向量。如果向量是[2.x.113]类型（或其复合对象，如[2.x.114]，循环在内部调用结束时调用[2.x.115]。     [2.x.116] src 输入向量。如果向量是[2.x.117]类型（或其复合对象，如[2.x.118]，则循环在内部调用开始时调用[2.x.119]以确保所有必要的数据在本地可用。然而，请注意，在循环结束时，向量会被重置为其原始状态，即如果向量在进入循环时没有被重影，那么在完成循环时也不会被重影。     [2.x.120] zero_dst_vector 如果这个标志被设置为`true`，向量`dst`将在循环中被设置为零。在你对矩阵对象进行典型的`vmult()`操作时使用这种情况，因为它通常会比在循环之前单独调用`dst = 0;`更快。这是因为向量项只在向量的子范围内被设置为0，确保向量项尽可能地留在缓存中。     [2.x.121] dst_vector_face_access 设置对向量`dst`的访问类型，该访问将发生在[2.x.122]函数内部。正如在DataAccessOnFaces结构的描述中所解释的，这个选择的目的是减少必须通过MPI网络（如果在节点的共享内存区域内，则通过`memcpy`）交换的数据量以获得性能。请注意，没有办法与FEFaceEvaluation类沟通这一设置，因此除了在`face_operation`函数中实现的内容外，这一选择必须在这个地方进行。因此，也没有办法检查传递给这个调用的设置是否与后来`FEFaceEvaluation`所做的一致，确保数据的正确性是用户的责任。     [2.x.123] src_vector_face_access 设置对向量`src`的访问类型，将在[2.x.124]函数体内发生，与`dst_vector_face_access`相类似。 
* [0.x.60]*
   这是第二个变体，在所有的单元格、内部面和边界面上运行循环，现在提供了三个指向[2.x.125]类成员函数的函数指针，其签名为<code>operation (const MatrixFree<dim,Number> &, OutVector &, InVector &, [2.x.126] int,unsigned int>&) const</code>。如果本地函数需要访问类中的数据（即，它是一个非静态成员函数），该方法就不需要定义lambda函数或调用[2.x.127]将类绑定到给定函数中。     [2.x.128] cell_operation 指向`CLASS`的成员函数，其签名为<tt>cell_operation (const MatrixFree<dim,Number> &, OutVector &, InVector &, [2.x.129] int,unsigned int> &)</tt>，其中第一个参数传递调用类的数据，最后一个参数定义应该被处理的单元范围（通常应该处理一个以上的单元以减少开销）。注意，这个循环通常会将`cell_range'分割成更小的部分，并交替工作于`cell_operation'、`face_operation'和`boundary_operation'，以增加缓存中向量项的潜在重用。     [2.x.130] face_operation 指向`CLASS`的成员函数，其签名为<tt>face_operation (const MatrixFree<dim,Number> &, OutVector &, InVector &, [2.x.131] int,unsigned int> &)</tt>，与`cell_operation`相类似，但现在是与内部面的工作相关的部分。请注意，MatrixFree框架将周期性面视为内部面，因此，在调用face_operation时应用周期性约束后，它们将被分配给正确的邻居。     [2.x.132] boundary_operation 指向`CLASS`的成员函数，其签名为<tt>boundary_operation (const MatrixFree<dim,Number> &, OutVector &, InVector &, [2.x.133] int,unsigned int> &)</tt>，与`cell_operation`和`face_operation`类似，但现在是与边界面的工作相关的部分。边界面由它们的`boundary_id'分开，可以使用[2.x.134]查询该id。注意，内部和面都使用相同的编号，内部的面被分配的编号比边界面低。     [2.x.135] owning_class 提供`cell_operation`调用的对象。为了与该接口兼容，该类必须允许调用`owning_class->cell_operation(...)`, `owning_class->face_operation(...)`, 和`owning_class->boundary_operation(...)`。     [2.x.136] dst 保存结果的目标向量。如果向量是[2.x.137]类型（或其复合对象，如[2.x.138]，循环在内部调用结束时调用[2.x.139]。     [2.x.140] src 输入向量。如果向量是[2.x.141]类型（或其复合对象，如[2.x.142]，则循环在内部调用开始时调用[2.x.143]以确保所有必要的数据在本地可用。然而，请注意，在循环结束时，向量会被重置为其原始状态，即如果向量在进入循环时没有被重影，那么在完成循环时也不会被重影。     [2.x.144] zero_dst_vector 如果这个标志被设置为`true`，向量`dst`将在循环中被设置为零。在你对矩阵对象进行典型的`vmult()`操作时使用这种情况，因为它通常会比在循环之前单独调用`dst = 0;`更快。这是因为向量项只在向量的子范围内被设置为0，确保向量项尽可能地留在缓存中。     [2.x.145] dst_vector_face_access 设置对向量`dst`的访问类型，将在[2.x.146]函数内部发生。正如在DataAccessOnFaces结构的描述中所解释的，这个选择的目的是减少必须通过MPI网络（如果在节点的共享内存区域内，则通过`memcpy`）交换的数据量以获得性能。请注意，没有办法与FEFaceEvaluation类沟通这一设置，因此除了在`face_operation`函数中实现的内容外，这一选择必须在这个地方进行。因此，也没有办法检查传递给这个调用的设置是否与后来`FEFaceEvaluation`所做的一致，确保数据的正确性是用户的责任。     [2.x.147] src_vector_face_access 设置对向量`src`的访问类型，将在[2.x.148]函数体内发生，与`dst_vector_face_access`相类似。 
* [0.x.61]*
   和上面一样，但对于非const的类成员函数。 
* [0.x.62]*
   这个方法与cell_loop()的做法类似，在所有单元格上运行循环（并行）。然而，这个函数的目的是用于面和边界积分也应该被评估的情况。与loop()相反，用户只需提供一个单一的函数，该函数应包含一个单元（或向量化时的一批单元）的单元积分和所有面的面和边界积分。这在文献中被称为 "以元素为中心的循环 "或 "以单元为中心的循环"。    为了能够评估所有的面积分（用来自相邻单元的值或梯度），相邻单元的所有幽灵值都要更新。使用[2.x.149] face_no)来访问一个单元的任意面和各自的邻居的数量。     [2.x.150] cell_operation 指向`CLASS`的成员函数，其签名为<tt>cell_operation (const MatrixFree<dim,Number> &, OutVector &, InVector &, [2.x.151] int,unsigned int> &)</tt>，第一个参数传递调用类的数据，最后一个参数定义应该被处理的单元范围（通常从循环中传递多个单元以减少开销）。     [2.x.152] owning_class 提供`cell_operation`调用的对象。为了与该接口兼容，该类必须允许调用`owning_class->cell_operation(..)`。     [2.x.153] dst 保存结果的目标向量。如果向量是[2.x.154]类型（或其复合对象，如[2.x.155]，循环在内部调用结束时调用[2.x.156]。     [2.x.157] src 输入向量。如果向量是[2.x.158]类型（或其复合对象，如[2.x.159]，循环在内部调用开始时调用[2.x.160]，以确保所有必要的数据在本地可用。然而，请注意，在循环结束时，向量会被重置为原始状态，即如果向量在进入循环时没有被重影，那么在完成循环时也不会被重影。     [2.x.161] zero_dst_vector 如果这个标志被设置为`true`，向量`dst`将在循环中被设置为零。在你对矩阵对象进行典型的`vmult()`操作时使用这种情况，因为它通常会比在循环之前单独调用`dst = 0;`更快。这是因为向量项只在向量的子范围内被设置为0，确保向量项尽可能地留在缓存中。     [2.x.162] src_vector_face_access 设置对向量`src`的访问类型，这将在面积分过程中发生在[2.x.163]函数的内部。  正如在DataAccessOnFaces结构的描述中所解释的，这个选择的目的是减少必须通过MPI网络（如果在节点的共享内存区域内，则通过`memcpy`）交换的数据量以获得性能。请注意，没有办法与FEFaceEvaluation类沟通这一设置，因此除了在`face_operation`函数中实现的内容外，这一选择必须在这个地方进行。因此，也没有办法检查传递给这个调用的设置是否与后来`FEFaceEvaluation`所做的一致，确保数据的正确性是用户的责任。 
* [0.x.63]*
   同上，但对于类的成员函数，它是非const的。 
* [0.x.64]*
   与上述相同，但有[2.x.164]。  
* [0.x.65]*
   在hp-adaptive情况下，在单元格循环中计算的单元格子范围可能包含不同程度的元素。使用这个函数来计算一个单独的有限元度的子范围是什么。有限元度与函数调用中给出的矢量分量相关。 
* [0.x.66]*
   在hp-adaptive情况下，在单元循环中计算的单元子范围可能包含不同程度的元素。使用这个函数来计算给定索引的子范围的hp-finite元素，而不是其他函数中的有限元素程度。 
* [0.x.67]*
   在hp自适应情况下，返回active_fe_indices的数量。 
* [0.x.68]*
   在hp-adaptive情况下，返回单元格范围的active_fe_index。 
* [0.x.69]*
   在hp-adaptive的情况下，返回一个面域的active_fe_index。 
* [0.x.70]*
    [2.x.165] 3: 向量的初始化  
* [0.x.71]*
   一般向量的初始化函数。矢量的长度等于DoFHandler中的总度数。如果该向量属于[2.x.166]类，则相应地设置鬼魂条目。对于有几个DoFHandler底层的向量值问题，参数[2.x.167]定义了要使用哪个分量。    对于MatrixFree和FEEvaluation中使用的向量，一个向量需要容纳所有[2.x.168]"本地活动的DoF"，以及一些[2.x.169]"本地相关的DoF"。  对DoF的选择是这样的：人们可以读取所有本地相关元素（本地活跃）上的所有自由度，加上约束条件从本地拥有的单元扩展到的自由度。然而，并不是所有本地相关的自由度都被存储，因为大多数自由度在矩阵-向量乘积中永远不会被访问，这会导致过多的数据被发送，从而影响性能。 
* [0.x.72]*
   分布式向量的初始化函数。矢量的长度等于DoFHandler中的总度数。如果该向量是[2.x.170]类，则相应地设置鬼魂条目。对于有几个DoFHandler底层的向量值问题，参数[2.x.171]定义了要使用的成分。    对于MatrixFree和FEEvaluation中使用的向量，一个向量需要容纳所有[2.x.172]"本地活动的DoF "和一些[2.x.173]"本地相关的DoF"。  对DoF的选择是这样的：人们可以读取所有本地相关元素（本地活跃）上的所有自由度，加上约束条件从本地拥有的单元扩展到的自由度。然而，并不是所有本地相关的自由度都被存储，因为大多数自由度在矩阵-向量乘积中永远不会被访问，这将导致过多的数据被发送，从而影响性能。 
* [0.x.73]*
   返回代表本地拥有的数据的分区器，以及单元格循环需要访问的幽灵索引。分区器是由各自字段给出的本地拥有的道夫和幽灵道夫构建的。如果你想知道这些对象的具体信息，你可以用各自的访问函数来查询它们。如果你只是想初始化一个（平行）向量，你通常应该更喜欢这种数据结构，因为数据交换信息可以从一个向量重复使用到另一个向量。 
* [0.x.74]*
   返回由处理器拥有的单元格集合。 
* [0.x.75]*
   返回需要但不为处理器所拥有的幽灵单元的集合。 
* [0.x.76]*
   返回一个所有被约束的自由度的列表。该列表是在本地拥有的向量范围的MPI本地索引空间中返回的，而不是跨越所有MPI处理器的全局MPI索引空间。要获得全局索引空间的数字，请在向量的一个条目上调用<tt>get_vector_partitioner()->local_to_global</tt>。此外，它只返回本地拥有的自由度的指数，而不是鬼魂的指数。 
* [0.x.77]*
   根据给定的数据布局，计算自由度的重新编号，使其更符合MatrixFree中的数据布局。注意，这个函数并不重新排列存储在这个类中的信息，而是创建一个重新编号以消耗 [2.x.174] 为了产生任何效果，必须使用重新编号的DoFHandler和AffineConstraints再次设置MatrixFree对象。注意，如果DoFHandler调用[2.x.175]，MatrixFree中的所有信息都会失效。 
* [0.x.78]*
    [2.x.176] 4：一般信息  
* [0.x.79]*
   返回一个给定的FiniteElement [2.x.177] 是否被这个类所支持。 
* [0.x.80]*
   返回初始化时指定的不同DoFHandlers的数量。 
* [0.x.81]*
   对于由[2.x.178] dof_handler_index指定的DoFHandler的基础有限元，返回基础元的数量。 
* [0.x.82]*
   返回这个结构所基于的单元数。如果你使用的是一个通常的DoFHandler，它对应于（本地拥有的）活动单元的数量。请注意，这个类中的大多数数据结构并不直接作用于这个数字，而是作用于n_cell_batches()，它给出了用矢量化将几个单元拼凑在一起时看到的单元的数量。 
* [0.x.83]*
    [2.x.179] 用n_cell_batches()代替。 
* [0.x.84]*
   返回该结构所处理的单元格批次的数量。批次是通过在一般的几个单元上应用矢量化而形成的。[2.x.180]中的细胞范围从零到n_cell_batches()（独占），所以如果你想为所有要处理的细胞存储数据数组，这是一个合适的大小。这个数字大约是[2.x.181]（取决于有多少细胞批没有被完全填满）。 
* [0.x.85]*
   返回该结构为面层集成而保留的额外单元格批次的数量。请注意，并不是所有在三角形中被重影的单元格都被保留在这个数据结构中，而是只有那些对评估两边的面积分有必要的单元格。 
* [0.x.86]*
   返回这个结构所处理的内部面批的数量。  这些批次是通过在一般的几个面上应用矢量化而形成的。[2.x.182]中的面的范围从零到n_inner_face_batches()（独占），所以如果你想为所有要处理的内部面存储数据的数组，这就是合适的大小。 
* [0.x.87]*
   返回这个结构所处理的边界面批的数量。  这些批次是通过在一般的几个面上应用矢量化而形成的。[2.x.183]中的面的范围从n_inner_face_batches()到n_inner_face_batches()+n_boundary_face_batches()（独占），所以如果你需要存储所有边界面而不是内部面的数据的数组，这个数字给出适当的大小。 
* [0.x.88]*
   返回未在本地处理但属于本地拥有的面的数量。 
* [0.x.89]*
   为了对边界的不同部分应用不同的运算符，这个方法可以用来查询面孔自己在VectorizedArray中按车道排序的边界ID。只对表示边界面的索引有效。 
* [0.x.90]*
   返回一个单元格内的面的边界ID，使用单元格在VectorizedArray中按车道的排序。 
* [0.x.91]*
   返回DoFHandler，其索引与reinit()函数中各自的[2.x.184]参数一样。 
* [0.x.92]*
   返回DoFHandler，其索引与reinit()函数中相应的[2.x.185]参数一样。注意，如果你想用不同于默认的模板参数来调用这个函数，你需要在函数调用前使用`template`，也就是说，你会有类似`matrix_free.template [2.x.186] [2.x.187] 使用这个函数的非模板化等价物。 
* [0.x.93]*
   返回deal.II中的单元格迭代器讲到一个给定的单元格批次（在一个VectorizedArray中填充几个车道）和在这个结构的重新编号中跨单元格的矢量化中的车道索引。    请注意，deal.II中的单元格迭代器与本类的单元格循环的处理方式不同。这是因为几个单元被一起处理（跨单元的矢量化），而且在访问远程数据和与计算重叠的通信时，在不同的MPI处理器上有邻居的单元需要在某个时间被访问。 
* [0.x.94]*
   这将返回由get_cell_iterator()对相同参数`cell_batch_index`和`lane_index`所返回的单元的级别和索引。 
* [0.x.95]*
   在deal.II中返回单元格的迭代器，该迭代器与一个面的内部/外部单元格在一对面批和巷道索引中。这一对中的第二个元素是面的编号，这样就可以访问面的迭代器。  `pair.first()->face(pair.second());`注意deal.II中的面迭代器通过单元格的方式与本类的面/边界循环的方式不同。这是因为几个面是一起工作的（矢量化），而且在访问远程数据和与计算重叠的通信时，在不同的MPI处理器上有相邻单元的面需要在某个时间被访问。 
* [0.x.96]*
    [2.x.188] [2.x.189] [2.x.190] 使用get_cell_iterator()代替。 
* [0.x.97]*
   由于该类使用的是矢量数据类型，数据域中通常有多个值，因此可能会出现矢量类型的某些分量与网格中的实际单元不对应的情况。当只使用这个类时，通常不需要理会这个事实，因为这些值是用零填充的。然而，当这个类与访问单元格的deal.II混合时，需要注意。如果不是所有给定的`cell_batch_index`的`n_lanes`单元都对应于网格中的实际单元，有些只是为了填充的原因而出现，则该函数返回[2.x.191]。要知道有多少单元被实际使用，可以使用函数n_active_entries_per_cell_batch()。 
* [0.x.98]*
    [2.x.192] 使用n_active_entries_per_cell_batch()代替。 
* [0.x.99]*
   这个查询返回在一个单元格批中的[2.x.193]个单元格中，有多少单元格是网格中的实际单元格，而不是因为填充的原因而出现的。对于大多数给定的n_cell_batches()中的单元格批次，这个数字等于[2.x.194]，但在网格中可能有一个或几个单元格批次（数字不相加），其中只有一个批次中的一些单元格被使用，由函数at_irregular_cell()表示。 
* [0.x.100]*
   使用这个函数找出在矢量化数据类型的长度上有多少个面对应于网格中的真实面（包括内部和边界面，因为这些面使用相同的索引，但范围不同）。对于大多数在n_inner_faces_batches()和n_boundary_face_batches()中给定的索引，这只是[2.x.195]个，但可能有一个或几个网格（数字不相加），其中有更少的这种道的填充。 
* [0.x.101]*
   返回给定hp-index的每个单元的自由度数量。 
* [0.x.102]*
   返回给定hp-index的每个单元的正交点的数量。 
* [0.x.103]*
   返回给定hp-index的单元格每个面上的自由度数量。 
* [0.x.104]*
   返回给定hp-index的单元格每个面上的正交点的数量。 
* [0.x.105]*
   返回给定hp-index的正交规则。 
* [0.x.106]*
   返回给定hp-index的正交规则。 
* [0.x.107]*
   返回当前批次的电池被分配到的类别。对于非hp-DoFHandler类型，类别在字段[2.x.196]中的给定值之间运行，在hp-adaptive情况下返回活动的FE指数。 
* [0.x.108]*
   返回当前一批面的两边的单元格上的类别。 
* [0.x.109]*
   查询是否已经设置了索引。 
* [0.x.110]*
   查询单元格的几何相关信息是否已被设置。 
* [0.x.111]*
   返回要处理的网格的级别。如果在活动单元上工作，返回[2.x.197]。 
* [0.x.112]*
   返回该类的内存消耗量的近似值，单位为字节。 
* [0.x.113]*
   在给定的输出流中打印出该类不同结构的内存消耗的详细摘要。 
* [0.x.114]*
   在给定的输出流中打印这个类的摘要。它集中在索引上，并不打印所有存储的数据。 
* [0.x.115]*
    [2.x.198] 5: 访问内部数据结构 注意：专家模式，接口在不同版本之间不稳定。 
* [0.x.116]*
   返回任务图的信息。 
* [0.x.117]返回单元格上与几何有关的信息。 
* [0.x.118]*
   返回关于索引自由度的信息。 
* [0.x.119]*
   返回约束池中的权重数量。 
* [0.x.120]*
   返回一个指向约束池数据中第一个数字的指针，索引为[2.x.199]（与[2.x.200]一起使用   
* [0.x.121]*
   返回一个指向约束池数据中最后一个数字的指针，索引为[2.x.201]（与[2.x.202] constraint_pool_begin()一起使用）。 
* [0.x.122]*
   返回给定hp-index的单元格信息。 
* [0.x.123]*
   返回一个面的连接信息。 
* [0.x.124]*
   返回将宏观单元格号、单元格内的面的索引和向量的单元格批内的索引这三者转化为面数组内的索引的表格。 
* [0.x.125]*
   获取一个内部使用的抓取数据对象。请确保事后将你从这个对象获得的指针传递给release_scratch_data()函数，以释放它。这个接口被FEEvaluation对象用来存储其数据结构。    内部数据结构的组织是一个线程本地存储的向量列表。多个线程将各自获得一个单独的存储域和单独的向量，确保线程安全。获取和释放对象的机制类似于WorkStream的本地贡献机制，见[2.x.203]"WorkStream论文"。 
* [0.x.126]*
   使得抓取板的对象再次可用。 
* [0.x.127]*
   获取一个用于内部使用的划痕数据对象。确保事后将你从这个对象获得的指针传递给release_scratch_data_non_threadsafe()函数，以释放它。注意，与acquisition_scratch_data()相反，这个方法一次只能由一个线程调用，但与acquisition_scratch_data()相反，释放scratch数据的线程也有可能与获取它的线程不同。 
* [0.x.128]*
   使得从头数据的对象再次可用。 
* [0.x.129]*
   这是实际的reinit函数，为DoFHandler的情况设置索引。 
* [0.x.130]*
   初始化DoFInfo中的字段和约束池，约束池中保存了所有不同的权重（不是DoFInfo的一部分，因为几个DoFInfo类可以有相同的权重，因此只需要存储一次）。 
* [0.x.131]*
   基于DoFHandler<dim>参数初始化DoFHandlers。 
* [0.x.132]*
   指向当前问题基础的DoFHandlers的指针。 
* [0.x.133]*
   包含各个单元格上的自由度和约束信息。 
* [0.x.134]*
   包含存储在DoFInfo中的约束条件的权重。填充到一个单独的字段中，因为几个向量组件可能共享类似的权重，这样可以减少内存消耗。此外，它省去了DoFInfo上的模板参数，使之成为一个只有索引的普通字段。 
* [0.x.135]*
   包含一个指向约束池数据中第i个索引开始的指标。 
* [0.x.136]*
   保存单元格从参考单元格到实数单元格的转换信息，这是评估积分所需要的。 
* [0.x.137]*
   包含单元格的形状值信息。 
* [0.x.138]*
   描述了单元格是如何被穿过的。有了单元格级别（该字段的第一个索引）和级别内的索引，就可以重建一个deal.II单元格迭代器，并使用deal.II提供的所有传统的单元格迭代器的功能。 
* [0.x.139]*
   对于非连续Galerkin，cell_level_index包括不在本地处理器上的单元，但需要用来计算单元积分。在cell_level_index_end_local中，我们存储本地单元的数量。 
* [0.x.140]*
   存储要处理的单元和面的基本布局，包括共享内存并行化的任务布局以及与MPI的通信和计算之间可能的重叠。 
* [0.x.141]*
   持有面孔信息的向量。只在build_face_info=true时初始化。 
* [0.x.142]*
   存储索引是否已被初始化。 
* [0.x.143]*
   存储索引是否已被初始化。 
* [0.x.144]*
   用于评估的刮板内存。我们允许超过一个评估对象附加到这个字段（这个，外[2.x.204]所以我们需要跟踪某个数据字段是否已经被使用（第一部分对）并保持一个对象的列表。 
* [0.x.145]*
   用于评估和其他情况下的Scratchpad内存，非线程安全的变体。 
* [0.x.146]*
   存储了要处理的网格的级别。 
* [0.x.147]*
   用于交换向量间数据的内部类。 
* [0.x.148]*
     构造函数。接受MF数据，DG中面部访问的标志和组件的数量。   
* [0.x.149]*
     解构器。   
* [0.x.150]*
     遍历MF对象中的所有组件，选择其分区器与该组件中的分区器兼容的组件。   
* [0.x.151]*
     为给定的[2.x.205]获取分区器，同时考虑到构造函数中设置的vector_face_access。   
* [0.x.152]*
     开始为序列向量更新_ghost_value    
* [0.x.153]*
     对于不支持分割成_start()和finish()阶段的向量，开始更新_ghost_value。   
* [0.x.154]*
     对于那些支持分成_start()和finish()阶段，但不支持在DoF子集上交换的向量，开始更新_ghost_value。   
* [0.x.155]*
     最后，对于那些支持分成_start()和finish()阶段，并且支持在子集DoF上交换的向量，即[2.x.206]，开始更新_ghost_value。    
* [0.x.156]*
     对于不支持分成_start()和finish()阶段的向量和串行向量，完成update_ghost_value。   
* [0.x.157]*
     完成对支持分割成_start()和finish()阶段的向量的 update_ghost_value，但不支持在DoF的子集上进行交换。   
* [0.x.158]*
     完成update_ghost_value，用于_支持分成_start()和finish()阶段的向量，也支持在子集DoF上的交换，即[2.x.207]     
* [0.x.159]*
     对串行向量进行启动压缩    
* [0.x.160]*
     对于不支持分割成_start()和finish()阶段的向量，开始压缩    
* [0.x.161]*
     对于支持分割成_start()和finish()阶段的向量开始压缩，但不支持在DoF的一个子集上交换。   
* [0.x.162]*
     开始压缩那些_支持分割成_start()和finish()阶段的向量，并且也支持在子集DoF上的交换，即[2.x.208] 。    
* [0.x.163]*
     对不支持分成_start()和finish()阶段的向量和串行向量进行完成压缩    
* [0.x.164]*
     对于支持分割成_start()和finish()阶段的向量完成压缩，但不支持在DoF的子集上交换。   
* [0.x.165]*
     开始压缩那些_支持分割成_start()和finish()阶段的向量，并且也支持在子集DoF上的交换，即[2.x.209] 。    
* [0.x.166]*
     重置串行向量的所有幽灵值    
* [0.x.167]*
     重置不支持在子集DoF上交换的向量的所有鬼值    
* [0.x.168]*
     重置_支持在子集DoF上交换的向量的所有鬼魂值，即[2.x.210]。    
* [0.x.169]*
     对于_do_ support exchange on a subset of DoFs <==> begin() + ind == local_element(ind), i.e. [2.x.211] 的向量区域清零。    
* [0.x.170]*
     对于不支持在DoFs子集上进行交换的向量，将向量区域清零 <==> begin() + ind == local_element(ind) 但仍然是向量类型。   
* [0.x.171]*
     对于非向量类型，即没有[2.x.212]的类，将向量区域清零。    
* [0.x.172]*
   一个内部类，将三个函数指针转换为上述带有虚拟函数的方案。 
* [0.x.173]

