include/deal.II-translator/matrix_free/tensor_product_kernels_0.txt
[0.x.0]*
   在这个命名空间中，实现了评估张量产品的评估器例程。 
* [0.x.1]*
     不要使用比有限元的张量积结构更多的东西。   
* [0.x.2]*
     通过利用有限元的对称性进行评估：即通过利用形状函数和正交点的对称性跳过一些计算。   
* [0.x.3]*
     利用对称性将算子分别应用于输入矢量的偶数和奇数部分：更多信息见EvaluatorTensorProduct专业化的文档。   
* [0.x.4]*
     在Legendre和类似的多项式空间中使用对称性，其中偶数的形状函数围绕正交点的中心对称（考虑偶数多项式度数），奇数的形状函数围绕正交点的中心反对称（考虑奇数多项式度数）。这允许使用类似于偶数技术的策略，但不需要单独的系数数组。更多信息请参见EvaluatorTensorProduct专业化的文档。   
* [0.x.5]*
   决定哪个数量应该通过张量积核计算。 
* [0.x.6]*
     通过形状函数进行评估/积分。   
* [0.x.7]*
     通过形状函数的梯度进行评估/积分。   
* [0.x.8]*
     通过形状函数的Hessians进行评估/积分。   
* [0.x.9]*
   通用的评估器框架，使用张量积形式对一般维度的给定形状数据进行估值。根据矩阵条目中的特定布局，这对应于通常的矩阵-矩阵乘积或包括一些对称性的矩阵-矩阵乘积。     [2.x.0] variant 用于创建模板特化的评估变量 [2.x.1] dim 函数的尺寸 [2.x.2] n_rows 变换矩阵中的行数，相当于通常张量收缩设置中的1d形状函数的数量 [2.x.3 ] n_columns 变换矩阵中的列数，相当于通常张量收缩设置中的1d形状函数的数量 [2.x.4] Number 输入和输出数组的抽象数字类型 [2.x.5] Number2 系数数组的抽象数字类型（默认为与输入/输出数组的类型相同）；必须用Number实现operator*才能有效  
* [0.x.10]*
   使用基函数的张量积形式的任意维度的形状函数的内部评估器。     [2.x.6] dim 应用该类的空间维度 [2.x.7] n_rows 变换矩阵中的行数，对应于通常张量收缩设置中的1d形状函数的数量 [2.x.8] n_columns 变换矩阵中的列数，对应于通常张量收缩设置中的1d形状函数的数量 [2.x.9 ] Number 用于输入和输出数组的抽象数字类型 [2.x.10] Number2 用于系数数组的抽象数字类型（默认为与输入/输出数组相同的类型）；必须用Number实现操作符*，并产生Number作为输出，才能成为有效类型。 
* [0.x.11]*
     空的构造函数。什么都不做。在使用'value'和相关方法时要小心，因为它们需要用其他指针来填充。   
* [0.x.12]*
     构造函数，从ShapeInfo中获取数据    
* [0.x.13]*
     这个函数沿着输入数组中张量数据的给定[2.x.11]应用张量积核，对应于一维条纹的乘法。这个函数允许[2.x.12]和[2.x.13]数组在n_rows == n_columns的情况下别名，也就是说，在[2.x.14]和[2.x.15]指向相同地址的地方执行收缩是安全的。对于n_rows != n_columns的情况，一般来说输出是不正确的。         [2.x.16] 被评估的方向 [2.x.17] contract_over_rows 如果为真，张量收缩对给定的[2.x.18]数组中的行求和，否则对列求和 [2.x.19 ] add 如果为真，结果将被添加到输出向量中，否则计算值将覆盖输出中的内容 [2.x.20] one_line 如果为真，内核只沿着二维张量中的单一一维条纹应用，而不是像[2.x.21]情况下的全部n_rows^dim点。         [2.x.22] shape_data 具有[2.x.23]行和[2.x.24]列的变换矩阵，以行为主的格式存储 [2.x.25] in 指向输入数据向量的起点 [2.x.26] out 指向输出数据向量的起点    
* [0.x.14]*
     这个函数应用张量积操作，从单元格值中产生面值。与apply方法相反，这个方法假设与面的正交方向每个方向有n_rows自由度，而不是那些比当前应用的方向低的n_columns。换句话说，apply_face()必须在调用面内的任何插值之前被调用。         [2.x.27] face_direction 法向量的方向（0=x，1=y，等等） [2.x.28] contract_onto_face 如果为真，输入向量的大小为n_rows^dim，插值将被执行到n_rows^(dim-1)点。这是[2.x.29]调用中的一个典型场景。如果是假的，来自n_rows^(dim-1)点的数据被扩展到高维数据阵列的n_rows^dim点。在contract_onto_face==false的情况下，导数被加在一起 [2.x.30] add 如果是true，结果被加到输出向量中，否则计算出的值会覆盖输出中的内容 [2.x.31] max_derivative 设置应该被计算的导数的数量。0表示只有数值，1表示数值和第一导数，2表示第二导数。注意，所有的导数都要访问传递给类的构造函数的[2.x.32]中的数据 [2.x.33] lex_faces 设置面的评估点应该如何排序：按词典排序或按右手系统号排序（在三维中对方位1进行特殊处理）。默认情况下，右键系统号被启用，这只适用于3以内的尺寸。 [2.x.34] 输入数据向量的地址 [2.x.35] 输出数据向量的地址    
* [0.x.15]*
   形状函数的内部评估器，使用基函数的张量积形式。与其他模板类相同，但没有利用模板参数和变量循环边界来代替。     [2.x.36] dim 应用该类的空间维度 [2.x.37] Number 用于输入和输出数组的抽象数字类型 [2.x.38] Number2 用于系数数组的抽象数字类型（默认为与输入/输出数组的类型相同）；必须用Number实现操作符*，并产生Number作为输出，才能成为有效类型  
* [0.x.16]*
     空的构造函数。什么都不做。在使用'values'和相关方法时要小心，因为它们需要用其他构造函数来填充。   
* [0.x.17]*
     构造函数，从ShapeInfo中获取数据    
* [0.x.18]*
     构造函数，从ShapeInfo中获取数据    
* [0.x.19]*
   使用基函数的张量积形式的1d-3d形状函数的内部评估器。该类专门针对 "对称 "有限元的基于张量积的元素的一般应用，即当形状函数关于0.5的对称性和正交点也是如此。     [2.x.39] dim 应用该类的空间维度 [2.x.40] n_rows 变换矩阵中的行数，对应于通常张量收缩设置中的1d形状函数的数量 [2.x.41] n_columns 变换矩阵中的列数，对应于通常张量收缩设置中的1d形状函数的数量 [2.x.42 ] Number 用于输入和输出数组的抽象数字类型 [2.x.43] Number2 用于系数数组的抽象数字类型（默认为与输入/输出数组相同的类型）；必须用Number实现操作符*，并产生Number作为输出，才能成为有效类型。 
* [0.x.20]*
     构造函数，从ShapeInfo获取数据。   
* [0.x.21]*
   1d-3d形状函数的内部评估器，使用基函数的张量积形式。    这个类对对称情况下的值、梯度和Hessians也用上述函数处理，实现了一种不同的方法。有可能将每个维度的成本从N^2降低到N^2/2，其中N是一维度的数量（形状矩阵中只有N^2/2个不同的条目，所以这是很合理的）。该方法是基于对输入向量的偶数和奇数部分分别应用算子的想法，因为在正交点上评估的形状函数是对称的。例如，在David A. Kopriva的《实施偏微分方程的频谱方法》一书中介绍了这种方法，Springer, 2009，第3.5.3节（偶数-奇数分解）。尽管书中的实验说该方法在N<20的情况下效率不高，但在循环边界为编译时常量（模板）的情况下，它的效率更高。     [2.x.44] dim 应用该类的空间维度 [2.x.45] n_rows 变换矩阵中的行数，对应于通常张量收缩设置中的1d形状函数的数量 [2.x.46] n_columns 变换矩阵中的列数，对应于通常张量收缩设置中的1d形状函数的数量 [2.x.47 ] Number 用于输入和输出数组的抽象数字类型 [2.x.48] Number2 用于系数数组的抽象数字类型（默认为与输入/输出数组相同的类型）；必须用Number实现操作符*，并产生Number作为输出，才能成为有效类型。 
* [0.x.22]*
     空的构造函数。什么都不做。在使用'values'和相关的方法时要小心，因为它们需要用另一个构造函数来填充，至少传入一个数组的值。   
* [0.x.23]*
     构造函数，从ShapeInfo中获取数据（使用存储在那里的偶数变体）。   
* [0.x.24]*
     构造函数，从ShapeInfo中获取数据（使用存储在那里的偶数变体）。   
* [0.x.25]*
     这个函数沿着输入数组中张量数据的给定[2.x.49]应用张量积核，对应于一维条纹的乘法。这个函数允许[2.x.50]和[2.x.51]数组在n_rows == n_columns的情况下别名，也就是说，在[2.x.52]和[2.x.53]指向相同地址的地方执行收缩是安全的。对于n_rows != n_columns的情况，只有当[2.x.54]被设置为真时，输出才是正确的。         [2.x.55] 方向 被评估的方向 [2.x.56] contract_over_rows 如果为真，张量收缩对给定的[2.x.57]数组中的行求和，否则对列求和 [2.x.58] add 如果为真，结果被添加到输出向量中，否则计算值将覆盖输出中的内容 [2.x.59 ] type 决定是否使用形状值（type=0）、形状梯度（type=1）或二阶导数（type=2，类似于type 0，但没有两个额外的0条目）中出现的对称性 [2.x.60] one_line 如果为真，内核只沿着dim-dimensional tensor中的单个1D条纹应用，而不是像[2.x.61]情况中的全部n_rows^dim点。         [2.x.62] shape_data 具有[2.x.63]行和[2.x.64]列的变换矩阵，以行为主的格式存储 [2.x.65] in 指向输入数据向量的起点 [2.x.66] out 指向输出数据向量的起点    
* [0.x.26]*
   使用基函数的张量积形式的1d-3d形状函数的内部评估器。    这个类实现了一种类似于偶数分解的方法，但具有不同类型的对称性。在这种情况下，我们假设单个形状函数已经显示了在正交点上的对称性，而不是在偶数情况下考虑的完整基础。特别是，我们假设形状函数的排序与Legendre基一样，偶数槽（数值阵列的行）中的形状函数是对称的，奇数槽是点对称的。与偶数分解一样，操作的数量是N^2/2，而不是N^2 FMAs（融合乘加），其中N是一维度数。区别在于输入和输出量的对称方式。     [2.x.67] dim 应用该类的空间维度 [2.x.68] n_rows 变换矩阵中的行数，对应于通常张量收缩设置中的1d形状函数的数量 [2.x.69] n_columns 变换矩阵中的列数，对应于通常张量收缩设置中的1d形状函数的数量 [2.x.70 ] Number 用于输入和输出数组的抽象数字类型 [2.x.71] Number2 用于系数数组的抽象数字类型（默认为与输入/输出数组相同的类型）；必须用Number实现操作符*，并产生Number作为输出，才能成为有效类型。 
* [0.x.27]*
     空的构造函数。什么都不做。在使用'values'和相关的方法时要小心，因为它们需要用另一个构造函数来填充，至少要传入一个数组的值。   
* [0.x.28]*
     构造函数，从ShapeInfo中获取数据（使用存储在那里的偶数变体）。   
* [0.x.29]*
     构造函数，从ShapeInfo中获取数据（使用存储在那里的偶数变体）。   
* [0.x.30]*
     这个函数沿着输入数组中张量数据的给定[2.x.72]应用张量积核，对应于一维条纹的乘法。这个函数允许[2.x.73]和[2.x.74]数组在n_rows == n_columns的情况下别名，也就是说，在[2.x.75]和[2.x.76]指向相同地址的地方执行收缩是安全的。对于n_rows != n_columns的情况，只有当[2.x.77]被设置为真时，输出才是正确的。         [2.x.78] 方向 被评估的方向 [2.x.79] contract_over_rows 如果为真，张量收缩对给定的[2.x.80]数组中的行求和，否则对列求和 [2.x.81] add 如果为真，结果被添加到输出向量中，否则计算值覆盖输出的内容 [2.x.82 ] type 决定评估是在[2.x.83]的偶数行（type=0）还是奇数行（type=1）中对称，以及在奇数行（type=0）或偶数行（type=1）中偏斜对称 [2.x.84] one_line 如果为真，内核只沿着dim-dimensional张量中的单个1D条纹应用，而不是像[2.x.85]情况中的全部n_rows^dim点。         [2.x.86] shape_data 具有[2.x.87]行和[2.x.88]列的变换矩阵，以行为主的格式存储 [2.x.89] in 指向输入数据向量的起点 [2.x.90] out 指向输出数据向量的起点    
* [0.x.31]*
   在 evaluate_tensor_product_value_and_gradient 中避免使用 Tensor<1, dim, Point<dim2> 的结构，因为点不能在 Tensor 中使用。相反，这个结构的特殊化将点上传到一个Tensor<1,dim>。 
* [0.x.32]*
   计算张量积形状函数 [2.x.91] 的多项式插值，给定系数向量 [2.x.92] 的形式 [2.x.93] 。形状函数[2.x.94]代表张量积。该函数返回一对，内插值为第一分量，参考坐标中的梯度为第二分量。注意，对于复合类型（例如，`values`字段开始一个Point<spacedim>参数），梯度的分量被排序为Tensor<1, dim, Tensor<1, spacedim>，导数为第一个索引；这是函数中通用参数的结果。     [2.x.95] poly 基础的一维多项式基 [2.x.96] 以多项式的矢量形式给出。     [2.x.97] values 多项式插值中类型为`Number`的扩展系数 [2.x.98] 。这些系数可以是简单的 "双 "变量，但也可以是Point<spacedim>，如果它们定义了类型为 "Number2 "的算术运算。     [2.x.99] p 在参考坐标中应该评估插值的位置。     [2.x.100] d_linear 指定是否应该进行d-线性（一维的线性，二维的双线性，三维的三线性）插值，这允许解开循环并大大加快评估。     [2.x.101] renumber 可选参数，用于指定系数向量中的重新编号，假设`values[renumber[i]]返回系数的lexicographic（张量积）条目。如果该向量为条目，则假设数值按词典排序。 
* [0.x.33]*
   与evaluate_tensor_product_value_and_gradient()相同，但用于积分。 
* [0.x.34]

