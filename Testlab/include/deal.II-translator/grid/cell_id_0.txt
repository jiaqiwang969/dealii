include/deal.II-translator/grid/cell_id_0.txt
[0.x.0]*
 一个表示三角结构中单元格的唯一ID的类。它由`cell->id()`返回（即，[2.x.0]，其中`cell`被认为是一个单元格迭代器。
* 这个类存储了一个单元的后裔的粗略单元的索引（或者更具体地说，[2.x.1]"粗略单元ID "的条目），以及如何从该粗略单元到达该单元的信息（即，当从一个单元移动到其子单元时，在三角结构的每一层采取哪个子单元索引）。关于这个类的重要的一点是，当前类的对象在三角剖分中唯一地识别一个单元，它甚至在类型为[2.x.2]的对象的背景下也是如此，因为网格的局部部分可能不存储所有单元。例如，在一个处理器上为一个幽灵单元计算的CellId与在实际拥有该单元的处理器上为同一单元计算的CellId完全相同，尽管指向该单元[1.x.0]的迭代器的级别和索引可能（而且一般会）不同。换句话说，CellId提供了一个工具，用它可以全局地、唯一地识别平行三角形中的单元，从而使处理器之间交换与单个单元相关的数据成为可能。
* 

* 
* [2.x.3] 这些数据在内部如何表示并不重要（也没有故意暴露）。

* 
* [0.x.1]*
   一个用于以紧凑和快速的方式编码CellId数据的类型（例如，用于MPI传输到其他进程）。请注意，它限制了可以传输的子节点数量，在三维中为20个，在二维中为30个（使用2倍的32位进行存储），这个限制与p4est使用的限制相同。 
* [0.x.2]*
   用给定的[2.x.4]和子指数的向量构造一个CellId对象。 [2.x.5]的解释与同名的成员变量相同，即每个条目表示从一个细化级别到下一个细化级别挑选哪个子单元，从粗略的单元开始，直到我们到达当前对象代表的单元。因此，每个条目应该是一个介于0和当前空间维度中单元格的子代数之间的数字（即，[2.x.6]。  
* [0.x.3]*
   用给定的[2.x.7]和[2.x.8]中提供的子节点数组构造一个CellId对象[2.x.9]，其解释与同名的成员变量相同，即每个条目表示从一个细化层到下一个细化层要挑选哪个子节点，从粗大的单元开始，直到我们到达当前对象所代表的单元。因此，每个条目应该是一个介于0和当前空间维度中单元格的子数之间的数字（即[2.x.10] 数组[2.x.11]必须至少有[2.x.12]个有效条目。 
* [0.x.4]*
   用给定的二进制表示法构建一个CellId对象，该对象之前是由[2.x.13]构建的。  
* [0.x.5]*
   从一个与to_string()产生的格式相同的字符串创建一个CellId。 
* [0.x.6]*
   构建一个无效的CellId。 
* [0.x.7]*
   返回这个CellId的人可读的字符串表示。    该函数返回的字符串仅由ASCII字符组成，例如，看起来像这样。`"0_3:006"`. 它可以*被人类解释为："这个单元来自于第四个粗略网格单元，生活在细化水平3，从粗略网格单元到其子代和孙代的路径由006给出"。  但这并不意味着*可以用任何有意义的方式来解释。它只是一种表示当前对象的内部状态的方法，只使用可打印范围内的ASCII字符。 
* [0.x.8]*
   返回这个CellId的一个紧凑而快速的二进制表示。 
* [0.x.9]*
   返回一个到此CellId所代表的单元格的cell_iterator。     [2.x.14] 使用[2.x.15]代替。 
* [0.x.10]*
   比较两个CellId对象是否相等。 
* [0.x.11]*
   比较两个CellIds的不等式。 
* [0.x.12]*
   比较两个CellIds的排序。这个排序的细节是未指定的，只是该操作提供了所有单元格之间的总排序。 
* [0.x.13]*
   确定这个单元格ID是否是输入单元格ID的直接父级。 
* [0.x.14]*
   确定此单元格ID是否为输入单元格ID的祖先。 
* [0.x.15]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据读入或写入一个流中，以便进行序列化。 
* [0.x.16]*
   返回粗体单元的id。 
* [0.x.17]*
   返回一个整数的只读容器，表示从一个细化级别到下一个细化级别，从粗略单元开始，直到我们到达当前对象所代表的单元，要挑选哪个孩子。    这个容器中的元素数对应于当前单元的（第1级）。 
* [0.x.18]*
   当前对象所代表的单元格位于其树中的粗单元格的编号。 
* [0.x.19]*
   存储在child_indices数组中的子索引的数量。这相当于当前单元格的（第1级）。 
* [0.x.20]*
   一个整数数组，表示从一个细化级别到下一个细化级别，从粗略的单元开始，直到我们到达当前对象所代表的单元，要挑选哪个孩子。  只有最初的n_child_indices条目被使用，但我们使用静态分配的数组，而不是n_child_indices大小的向量，以加快该对象的创建速度。如果给定的尺寸成为一种限制，那么数组可以被扩展。 
* [0.x.21]*
 将一个CellId对象写入一个流中。

* 
* [0.x.22]*
 序列化功能

* 
* [0.x.23]*
 从一个流中读取一个CellId对象。

* 
* [0.x.24]

