include/deal.II-translator/grid/tria_levels_0.txt
[0.x.0]*
     存储属于多级层次结构中某一层次的所有信息。        在TriaLevel中，存储所有不依赖于维度的单元数据，例如，存储单元的细化标志的字段（单元的实际内容在其他地方声明），等等。对于非面向水平的数据，也请参见TriaObjects。        还有一个字段，可能适合在这里，即材料数据（对于单元）或边界指标（对于面），但由于我们需要一个线或四边形的边界信息或材料数据，我们将它们与线和四边形一起存储，而不是与普通数据一起存储。    同样地，在3D中，我们需要线和四边形的边界指标（如果相邻的两个面有不同的边界指标，我们需要知道如何细化一条线），以及单元格的材料数据。   
* [0.x.1]*
       构造函数。             [2.x.0] 三角形的dim尺寸。     
* [0.x.2]*
       默认构造函数（Boost需要）。     
* [0.x.3]*
       三角形的尺寸。     
* [0.x.4]*
        [2.x.1]单元格是否需要精化的标志 [2.x.2]单元格的含义是与维度有关的，因此这个向量的长度也取决于维度：在一维中，这个向量的长度等于[2.x.3]向量的长度，在二维中等于[2.x.4]向量的长度，等等。     
* [0.x.5]*
       与上面的含义相同，但指定了一个单元是否必须被粗化。     
* [0.x.6]*
       一个整数，对于每一个活动单元，它存储了多少个活动单元。对于非活动单元，该值未使用，并设置为无效值。     
* [0.x.7]*
       每个活动单元的全局单元索引。     
* [0.x.8]*
       给定级别上每个单元的全局单元索引。     
* [0.x.9]*
       级别和单元格邻居的指数。惯例是，索引为[2.x.5]的单元格的邻居存储在[2.x.6]之后的字段中，例如，在一个空间维度中，单元格0的邻居存储在<tt>neighbors[0]</tt>和<tt>neighbors[1]</tt>，单元格1的邻居存储在<tt>neighbors[2]</tt>和<tt>neighbors[3]</tt>，以此类推。            在邻居中，<tt>neighbors[i].first</tt>是级别，而<tt>neighbors[i].second</tt>是邻居的索引。            如果一个邻居不存在（单元格在边界），<tt>level=index=-1</tt>被设置。             [2.x.7] 公约。[2.x.8] 一个单元的[2.x.9]邻居是与该单元的[2.x.10]面（二维的[2.x.11]，三维的[2.x.12]）共享的那个。            一个单元格的邻居最多具有与该单元格相同的水平，也就是说，它可能是也可能不是精炼的。            在一个维度上，一个邻居可能具有小于或等于这个单元的水平的任何水平。如果它有相同的层次，它可以被精炼任意次数，但邻居指针仍然指向同一层次的单元，而邻居的子单元的邻居可以指向这个单元或其子单元。            在二维和更多维度上，邻居要么在同一层次上并被细化（在这种情况下，它的子代有指向本单元或其直接子代的邻居指针），要么在同一层次上未被细化，或下一层次（在这种情况下，它的邻居指针指向本单元的母单元）。     
* [0.x.10]*
       每个单元有一个整数，用来存储它属于哪个子域。这个字段最常被用于并行计算，它表示哪个处理器应该工作在/拥有给定子域编号的单元。            这个号码只在活动单元上使用。     
* [0.x.11]*
       在每一层用于并行多网格的子域ID。            与subdomain_id相反，一旦网格被划分到多网格层次的下层，这个数字也会用于非活动单元上。     
* [0.x.12]*
       每一对连续的单元都有一个整数，用于存储它们的父级单元的索引。            (我们为每对单元存储一次这一信息，因为每一次细化，无论是各向同性还是各向异性，在任何空间维度上，总是以2的倍数创建子单元，所以没有必要为每一个单元存储父单元的索引。)      
* [0.x.13]*
       每个单元有一个bool来表示法线的方向 true: 使用来自顶点的方向 false: 恢复方向。参见 [2.x.13] 。            这仅用于codim==1的网格。     
* [0.x.14]*
       包含线的数据和相关函数的对象      
* [0.x.15]*
       对于边，我们强制执行一个标准惯例，即相对的边应该是平行的。现在，这在大多数情况下是可以执行的，我们有代码确保如果一个网格允许这种情况发生，我们就有这个约定。我们也知道，总是有可能让相对的面具有平行的法向量。(关于这两点，请参见GridReordering类的文档中提到的ACM Transactions on Mathematical Software中Agelek, Anderson, Bangerth, Barth的论文)。            问题是，我们原本还有一个条件，即0、2和4号面的法线指向单元格内，而其他面的法线指向外面。事实证明，这并不总是可能的。实际上，我们必须存储每个单元格的每个面的法线向量是否遵循这一惯例。如果是这样，那么这个变量就存储一个[2.x.14]值，否则就是[2.x.15]值。            实际上，这个字段有[2.x.16]个元素，是每个单元格的六个面的倍数。           
* [2.x.17] 只有dim=3时才需要。     
* [0.x.16]*
       每个单元格的参考单元格类型。           
* [2.x.18] 仅用于dim=2和dim=3。     
* [0.x.17]*
       单元顶点索引的缓存（`structdim == dim`），以便更快速地检索这些频繁访问的数量。      为了简化寻址，这些信息以一个单元（四边形/六面体）可能的最大顶点数为索引。     
* [0.x.18]*
       确定这个对象的内存消耗（以字节为单位）的估计值。     
* [0.x.19]*
       使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据读入或写入一个流中，以便进行序列化。     
* [0.x.20]

