include/deal.II-translator/grid/tria_objects_0.txt
[0.x.0]*
     属于三角测量的几何对象的信息的一般模板，即线、四边形、六面体......。 除了对象的向量外，还包括其他信息，即表示子代、使用状态、用户标志、材料编码的向量。        这些类的对象包括在TriaLevel和TriaFaces类中。   
* [0.x.1]*
       构造函数重置了一些数据。     
* [0.x.2]*
       特定维度的构造函数。     
* [0.x.3]*
       属于这个层面的对象的向量。对象的索引等于这个容器中的索引。     
* [0.x.4]*
       返回该类存储的几何对象的数量。     
* [0.x.5]*
       返回一个关于绑定当前对象所存储的[2.x.0]第1个索引对象的对象的索引的视图。例如，如果当前对象存储的是单元格，那么这个函数返回相当于一个包含绑定[2.x.1]单元格的面的索引的数组。     
* [0.x.6]*
       对象的偶数子女的索引。因为当对象被细化时，所有的子代都是同时被创建的，它们至少是成对地被追加到列表中，彼此之间的关系。因此，我们只存储偶数子女的索引，非偶数子女紧随其后。            如果一个对象没有子女。
* 
* - 被存储在这个列表中。如果一个对象没有子嗣，那么它就被称为活动对象。函数[2.x.2]对此进行测试。     
* [0.x.7]*
       存储每个单元格被细化的情况。这个向量可能会被vector<vector<bool> > (dim, vector<bool> (n_cells))取代，这样更节省内存。     
* [0.x.8]*
       存储对象是否被用于[2.x.3]向量的向量。            由于在[2.x.4]中很难删除元素，当一个元素不再需要时（例如，在取消定义后），它不会被从列表中删除，而是将相应的[2.x.5]标志设置为[2.x.6] 。      
* [0.x.9]*
       为用户数据提供一个字段，每个对象有一个比特。这个字段通常用于当一个操作在所有单元上运行，并且需要另一个单元（例如邻居）是否已经被处理的信息。            你可以使用[2.x.7]清除所有使用的标志。      
* [0.x.10]*
       我们使用这个联盟来存储边界和材料数据。因为这里实际上只需要这两个中的一个，所以我们使用一个联合。     
* [0.x.11]*
         默认构造函数。       
* [0.x.12]*
         返回这类对象的大小。       
* [0.x.13]*
         使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据读入或写入一个流中，以便进行序列化。       
* [0.x.14]*
       存储边界和材料数据。例如，在一个维度中，这个字段存储线的材料ID，这是一个介于0和[2.x.8]之间的数字。 在一个以上的维度中，线没有材料ID，但它们可能在边界上；然后，我们在这个字段中存储边界指示器，它表示这条线属于边界的哪一部分，以及这一部分的边界条件是什么。边界指示符也是一个介于零和[2.x.9]之间的数字，id[2.x.10]是为内部的线保留的，可以用来检查一条线是否在边界上，否则，如果你不知道它属于哪个单元格，就不可能。     
* [0.x.15]*
       存储分流板ID。这个字段存储每个对象的流形ID，它是0到[2.x.11]之间的一个数字。      
* [0.x.16]*
       返回一个通往单个对象的下一个空闲槽的迭代器。这个函数只被3D中的[2.x.12]使用。             [2.x.13] 有趣的是，这个函数没有用于一维或二维三角计算，在这里，似乎细化函数的作者坚持要重新实现其内容。             [2.x.14] 这个函数没有被实例化用于codim-one的情况      
* [0.x.17]*
       返回一个通往一对对象的下一个空闲槽的迭代器。这个函数只被3D中的[2.x.15]使用。             [2.x.16] 有趣的是，这个函数并没有用于一维或二维三角计算，在这里，似乎细化函数的作者坚持重新实现其内容。             [2.x.17] 这个函数没有被实例化用于codim-one的情况      
* [0.x.18]*
       返回一个迭代器到一对六角的下一个空闲槽。只对[2.x.18]实现。     
* [0.x.19]*
       访问用户指针。     
* [0.x.20]*
       对用户指针的只读访问。     
* [0.x.21]*
       对用户索引的访问。     
* [0.x.22]*
       对用户指针的只读访问。     
* [0.x.23]*
       将用户数据重置为零。     
* [0.x.24]*
       清除所有的用户指针或索引，并重置它们的类型，这样，下一次访问可能是或者。     
* [0.x.25]*
       清除所有的用户标志。     
* [0.x.26]*
       确定这个对象的内存消耗（以字节为单位）的估计值。     
* [0.x.27]*
       为了使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)进行序列化，将此对象的数据读入或写入一个流中。     
* [0.x.28]*
       Triangulation对象可以访问用户指针或用户索引。你试图做的是在使用其中一个之后再访问另一个。           
* [2.x.19]       
* [0.x.29]*
       next_free_single_*函数的计数器      
* [0.x.30]*
       下一个免费配对函数的计数器      
* [0.x.31]*
       用于next_free_single_*函数的Bool标志      
* [0.x.32]*
       存储用户指针或用户索引的数据类型。     
* [0.x.33]*
         默认的构造函数。       
* [0.x.34]*
         使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据写入一个流中，以便进行序列化。       
* [0.x.35]*
       描述用户数据的可能类型的枚举。     
* [0.x.36]*
       指针，不被库使用，但可以被用户访问和设置，以处理一行/四行/等的本地数据。     
* [0.x.37]*
       为了避免用户指针和索引之间的混淆，这个枚举由第一个访问这两者的函数设置，随后的访问将不被允许改变所访问的数据类型。     
* [0.x.38]

