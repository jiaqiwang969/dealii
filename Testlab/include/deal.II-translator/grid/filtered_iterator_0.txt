include/deal.II-translator/grid/filtered_iterator_0.txt
[0.x.0]*
 在这个命名空间中，声明了一些可以作为FilteredIterator类中的过滤器的类。这些过滤器或者检查二进制信息（例如，[2.x.0]过滤器类检查指向的对象是否是活动的），或者通过与规定的值比较来检查有价值的信息（例如，LevelEqualTo过滤器类检查所考虑的迭代器指向的对象的级别是否等于构造时给过滤器的一个值。
* 关于这些类的使用例子以及对过滤器的要求，请参见FilteredIterator类的一般描述。
* 

* 
* [2.x.1] 

* 
* [0.x.1]*
   如果迭代器指向一个活动对象或迭代器过了终点，则评估为真的过滤器。   
* [2.x.2]   
* [0.x.2]*
     评估迭代器，如果该对象是活动的或已过终点，则返回真。   
* [0.x.3]*
   如果迭代器指向一个设置了用户标志的对象或者迭代器超过了终点，则评估为真的过滤器。参见[2.x.3]了解关于用户标志的信息。   
* [2.x.4]   
* [0.x.4]*
     评估迭代器，如果对象有设定的用户标志或过了终点，则返回true。   
* [0.x.5]*
   如果迭代器指向一个没有设置用户标志的对象或者迭代器超过了终点，则评估为真的过滤器。与前一个类别相反的过滤器。   
* [2.x.5]   
* [0.x.6]*
     评估迭代器，如果对象有一个未设置的用户标志或超过终点，则返回真。   
* [0.x.7]*
   迭代器的过滤器，如果迭代器已经过了终点，或者指向的对象的级别等于给构造函数的一个值，则评估为真。   
* [2.x.6]   
* [0.x.8]*
     构造函数。存储迭代器应被评估为真的水平。   
* [0.x.9]*
     评估操作符。如果指向的对象的级别等于存储的值，或者迭代器已过终点，则返回真。   
* [0.x.10]*
     要与级别进行比较的存储值。   
* [0.x.11]*
   迭代器的过滤器，如果迭代器已经过了终点，或者所指向的对象的子域ID等于给构造函数的一个值，假设迭代器允许查询子域ID，则评价为真。   
* [2.x.7]   
* [0.x.12]*
     构造函数。存储子域，迭代器应被评估为真。   
* [0.x.13]*
     评估操作符。如果指向的对象的子域等于存储的值或迭代器已过终点，则返回真。   
* [0.x.14]*
     用于比较子域的存储值。   
* [0.x.15]*
   迭代器的过滤器，如果一个单元格为当前处理器所拥有，即如果它是一个[2.x.8]"本地拥有的单元格"，则评估为真。    该类在 [2.x.9] 中使用，与 [2.x.10] 模块的方法相关。   
* [2.x.11]   
* [0.x.16]*
     评估运算符。如果单元格是本地拥有的，则返回true。   
* [0.x.17]*
   迭代器的过滤器，如果单元格的水平子域id等于当前处理器id，则评估为真。   
* [2.x.12]   
* [0.x.18]*
     评价运算符。如果单元格的水平子域id等于当前处理器id，则返回真。   
* [0.x.19]*
   迭代器的过滤器，如果指向的对象的迭代器等于给构造器的一个值或一组值，假设迭代器允许查询材料id，则评价为真。     
* [2.x.13]   
* [0.x.20]*
     构造器。存储迭代器应被评估为真的材料ID，并说明迭代器是否必须为本地所有。   
* [0.x.21]*
     构造函数。存储一个材料ID的集合，其迭代器应被评估为真，并说明迭代器是否必须是本地拥有的。   
* [0.x.22]*
     评价操作符。如果指向的对象的材料ID在存储的允许值集合内相等，则返回真，如果需要，如果单元格是本地拥有的。   
* [0.x.23]*
     用来比较材料ID的存储值。   
* [0.x.24]*
     标志，说明是否只有本地拥有的单元格必须返回真。   
* [0.x.25]*
   迭代器的过滤器，如果指向的对象的迭代器等于给构造器的一个值或一组值，假设迭代器允许查询活动的FE索引，则评价为真。     
* [2.x.14]   
* [0.x.26]*
     构造函数。存储活动的FE索引，哪些迭代器应被评估为真，并说明迭代器是否必须为本地所有。   
* [0.x.27]*
     构造函数。存储一个活动FE指数的集合，迭代器必须被评估为真，如果迭代器必须是本地拥有的，则说明。   
* [0.x.28]*
     评估运算符。如果所指向的对象的活动FE索引在存储的允许值集合内相等，则返回真，如果需要的话，如果单元格是本地拥有的。   
* [0.x.29]*
     用于比较材料ID的存储值。   
* [0.x.30]*
     标志，说明是否只有本地拥有的单元格必须返回真。   
* [0.x.31]*
   迭代器的过滤器，如果指向的对象的迭代器在边界上，则评估为真。     
* [2.x.15]   
* [0.x.32]*
     评估迭代器，如果对象在边界上，返回真。   
* [0.x.33]*
 这个类通过只迭代满足给定过滤器（称为[2.x.16]谓词[2.x.17]，遵循C++标准库的符号）的元素，提供了对一系列三角形或DoFHandler迭代器的某种看法。一旦用谓词和迭代器的值进行初始化，如果调用操作符++或\--，过滤的迭代器会跳到满足谓词的下一个或上一个元素。位于两者之间但不满足谓词的中间迭代器值被跳过。因此，在某一类对象上写循环是非常简单的，不需要明确写出它们在每个循环迭代中必须满足的条件。如果函数被调用时有一对迭代器，表示它们将在一个范围内行动，通过选择一个过滤的迭代器而不是通常的迭代器，这尤其有帮助。
* 该类在 [2.x.18] 中使用。
* 

* [1.x.0]
* 代表迭代器必须满足的条件的对象只需要提供一个允许调用评估操作符的接口，即 [2.x.19] 。这包括函数指针以及实现<code>bool operator ()(const BaseIterator&)</code>的类。然后，FilteredIterator将跳过所有该函数的返回值为 [2.x.20] 的对象。
* 

* 一个简单的有效谓词的例子如下：给定函数

* 
* [1.x.1]
* 那么

* 
* [1.x.2]
* 是一个有效的谓词。
* 同样地，给定以下二元函数

 
* [1.x.3]
* 那么

* 
* [1.x.4]
* 是另一个有效的谓词（这里：一个函数，如果迭代器过了终点或者水平等于第二个参数，则返回真；这个第二个参数在创建lambda函数时被视为固定的）。
* 最后，类可以是谓词。下面这个类就是一个。

* 
* [1.x.5]
* 而这种类型的对象可以作为谓词使用。同样地，这个更复杂的也可以使用。

* 
* [1.x.6]
* 像[2.x.21]这样的对象就可以作为谓词使用。
* 因为每当一个谓词被评估时，都会检查被检查的迭代器是否真的有效（即没有超过终点），所以在谓词内部不需要对这种情况进行检查。
* 很多过滤器类已经在IteratorFilters命名空间中实现了，但是按照上面的例子，编写不同的过滤器也很简单。
* 

* [1.x.7]
* 过滤的迭代器在构造时被赋予一个谓词，这个谓词不能再被改变。如果这个谓词是作为一个模板参数给类的话，这种行为是可以预期的，但由于这将使过滤迭代器的声明成为一场噩梦，我们宁愿把谓词作为一个不可改变的实体给构造器。请注意，人们可以将一个具有一个谓词的过滤迭代器分配给另一个具有另一种类型的过滤迭代器；然而，这并不[2.x.22]改变分配给迭代器的谓词，只有指示迭代器的指针被改变。
* 如果一个被过滤的迭代器没有被分配一个底层（未被过滤的）迭代器类型的值，那么将采取默认值。然而，如果给构造函数一个值，该值必须超过终点，或者必须满足谓词。例如，如果谓词只在对象的级别等于3时才评估为真，那么[2.x.24]将是一个有效的选择，而[2.x.25]则不是，因为后者也会返回非活动单元的迭代器，这些单元总是从级别0开始。
* 由于人们经常只有一些迭代器，并希望将过滤后的迭代器设置为第一个满足谓词的迭代器（例如，第一个设置了用户标志的迭代器，或者第一个具有给定子域id的迭代器），因此有一些赋值函数#set_to_next_positive和#set_to_previous_positive，它们将满足谓词的下一个或上一个迭代器赋值，即。 也就是说，它们沿着迭代器列表的任一方向追踪，直到找到一个匹配的迭代器（或过去的迭代器）。像[2.x.26]一样，它们返回过滤后的迭代器的结果值。
* 

* [1.x.8]
* 下面的调用计算了有设置用户标志的活动单元的数量。

* 
* [1.x.9]
* 请注意，通过[2.x.27]的调用，第一个有设置用户标志的单元被分配到[2.x.28]迭代器。对于结束迭代器来说，没有必要进行这样的调用，因为过去结束迭代器总是满足所有的谓词。
* 同样的情况可以通过下面的片段来实现，虽然比较难读。

* 
* [1.x.10]
* 它依赖于这样一个事实：如果我们用一个给定的谓词创建一个未命名的过滤迭代器，但没有迭代器的值，并给它分配关于这个谓词的下一个正值，它就会返回自己，然后作为[2.x.29]函数的第一个参数。这个过程对于这里的这个函数的结束元素来说是没有必要的，因为过去的结束迭代器总是满足谓词，所以我们可以在构造函数中直接将这个值分配给过滤的迭代器。
* 最后，下面的循环只在子域id等于3的单元格上组装矩阵。

* 
* [1.x.11]
* 
* 由于定义了过滤和未过滤的迭代器之间的比较，我们也可以让最后一个例子中的[2.x.30]变量为[2.x.31]类型，因为它是不变的，其值不取决于过滤器。
* 

* 
* [2.x.32] 

* 
* [2.x.33] 

 
* [0.x.34]*
   对底层迭代器的访问器类型的类型定义。 
* [0.x.35]*
   构造函数。将迭代器设置为默认状态并使用给定的谓词来过滤后续的赋值和迭代。 
* [0.x.36]*
   构造函数。使用给定的谓词进行过滤，用给定的值初始化迭代器。    如果初始值[2.x.34]不满足谓词[2.x.35]，那么它就会被推进，直到我们碰到过去结束的迭代器，或者谓词被满足。例如，这允许写这样的代码  
* [1.x.12]
* 如果单元格[2.x.36]没有等于13的subdomain_id，那么迭代器将自动推进到第一个有的单元格。 
* [0.x.37]*
   复制构造函数。复制给定参数的谓词和迭代器的值。 
* [0.x.38]*
   赋值运算符。复制参数的迭代器值，但是正如在类的文档中所讨论的，参数的谓词并没有被复制。参数的迭代器值必须满足被赋值对象的谓词，这是在其构造时给出的。 
* [0.x.39]*
   赋值运算符。复制参数的迭代器值，并保留该对象的谓词。给定的迭代器值必须满足分配到的对象的谓词，如在其构造时给出的。 
* [0.x.40]*
   从[2.x.37]开始搜索下一个满足此对象的谓词的迭代器，并将其分配给此对象。    因为过滤后的迭代器会自动转换为底层的基本迭代器类型，所以你也可以给一个过滤后的迭代器作为这个函数的参数。 
* [0.x.41]*
   如上所述，但是从[2.x.38]向后搜索满足此对象谓词的前一个迭代器，并将其分配给此对象。    由于过滤后的迭代器会自动转换为底层的基本迭代器类型，你也可以给一个过滤后的迭代器作为这个函数的参数。 
* [0.x.42]*
   比较this和给定对象的基础迭代器值是否相等。    我们不对谓词的平等性进行比较。 
* [0.x.43]*
   比较这个对象和给定对象的基本迭代器值是否相等。    此对象的谓词与此操作无关。 
* [0.x.44]*
   比较此对象和给定对象的基础迭代器值的不平等。    我们不对谓词的平等性进行比较。 
* [0.x.45]*
   比较此对象的底层迭代器值与给定对象的不平等性。    此对象的谓词与此操作无关。 
* [0.x.46]*
   比较此对象和给定对象的基础迭代器值的排序。    我们不比较谓词。 
* [0.x.47]*
   比较这个对象和给定对象的底层迭代器值的排序。    此对象的谓词与此操作无关。 
* [0.x.48]*
   前缀推进操作：移动到满足前提条件的下一个迭代器值，并返回新的迭代器值。 
* [0.x.49]*
   后缀推进运算符：移动到满足谓词的下一个迭代器值，并返回旧的迭代器值。 
* [0.x.50]*
   前缀递减运算符：移动到满足谓词的前一个迭代器值，并返回新的迭代器值。 
* [0.x.51]*
   后缀进位运算符：移动到满足谓词的前一个迭代器值，并返回旧的迭代器值。 
* [0.x.52]*
   异常情况。 
* [0.x.53]*
   用于封装谓词对象的基类。由于谓词可以有不同的类型，而且我们不想把这些类型编码到过滤迭代器类的模板参数列表中，所以我们使用一个带有抽象函数的基类和模板化的派生类，通过虚拟函数实现对实际谓词类型的使用。   
* [2.x.39]   
* [0.x.54]*
     将析构器标记为虚拟，以允许通过指向基类的指针进行破坏。   
* [0.x.55]*
     抽象函数，在派生类中表示对给定迭代器的谓词的评估。   
* [0.x.56]*
     生成这个对象的一个副本，即这个指针的实际类型。   
* [0.x.57]*
   上述抽象基类的实际实现。使用一个模板参数来表示谓词的实际类型，并存储它的副本。当虚拟函数被调用时，用存储的谓词副本评估给定的迭代器。   
* [2.x.40]   
* [0.x.58]*
     构造器。取一个谓词并存储它的一个副本。   
* [0.x.59]*
     用存储的谓词的副本来评估迭代器。   
* [0.x.60]*
     生成这个对象的一个副本，即这个指针的实际类型。   
* [0.x.61]*
     谓词的拷贝。   
* [0.x.62]*
   指向一个对象的指针，该对象封装了给与构造函数的谓词的实际数据类型。 
* [0.x.63]*
 给出基础迭代器和谓词，创建一个FilteredIterator类型的对象。 这个函数使创建临时对象（例如作为函数参数）变得简单得多，因为人们不需要明确地用手指定基迭代器的类型。
* 
* - 它是在这里自动推导出来的。
* [2.x.41] 过滤迭代器

* 
* [0.x.64]*
 使用一个Predicate对给定的迭代器范围进行过滤。这允许替换。

* 
* [1.x.13]
* 由:

* 
* [1.x.14]
* 
* [2.x.42] 过滤的迭代器

* 
* [2.x.43] 

* 
* [0.x.65]*
 通过任意数量的Predicates过滤给定范围的迭代器。这允许替换。

* 
* [1.x.15]
* 由。

* 
* [1.x.16]
* 
* [2.x.44] 过滤的迭代器

* 
* [2.x.45] 

* 
* [0.x.66]

