include/deal.II-translator/grid/intergrid_map_0.txt
[0.x.0]*
 这个类提供了两个网格之间的映射，这两个网格来自于同一个粗略的网格。对于源地图的每个单元格迭代器，它通过其<tt>operator []</tt>，提供了目标地图上相应的单元格迭代器。
* 通常情况下，两个网格的细化程度是不同的。那么，源网格上的迭代器返回的值将是：。 [2.x.0] [2.x.1] 目标网格上的同一个单元，如果它存在的话； [2.x.2] 目标网格上最精炼的单元，通过精炼可以得到源单元的垂线。该单元始终处于活动状态，其细化程度小于源单元的细化程度。 [2.x.3] 这个地图的键是源网格上的所有单元，无论是否活动。
* 例如，考虑这两个一维网格。

* 
* [1.x.0]
* （单元格编号只是作为一个例子给出，不会与真实的单元格迭代器的索引相对应）。那么从网格1到网格2的映射将如下。

* 
* [1.x.1]
* 除了这里显示的映射，网格1上的非活动单元也是有效的键。例如，第一个网格上的单元格1和2的母单元格的映射将指向第二个网格上的单元格1。
* [2.x.4] MeshType 这个类可以和任何满足[2.x.5] "MeshType概念 "的类一起使用。对其他提供迭代器函数的类的扩展和一些小的附加要求很简单。
* 请注意，这个类原则上可以基于C++ [2.x.6] 数据类型。相反，它使用了另一种数据格式，在访问的计算时间和内存消耗方面都更有效。
* 

* [1.x.2]
* 在实践中，该类的使用情况如下。

* 
* [1.x.3]
* 
* 注意这个类的模板参数必须以<tt>InterGridMap<DoFHandler<2>></tt>的形式给出，这里是DoFHandler（也同样可以是Triangulation或PersistentTriangulation）。
* 

* 
* [2.x.7] 

 
* [0.x.1]*
   对所考虑的网格类的迭代器类型的类型化定义。 
* [0.x.2]*
   构造函数设置SmartPointer成员中的类名参数。 
* [0.x.3]*
   创建两个网格之间的映射。 
* [0.x.4]*
   访问操作符：给出源网格上的一个单元，并接收另一个网格上相应的单元，如果不存在，则是源单元进一步细化后将创建的最细化单元。 
* [0.x.5]*
   删除该类的所有数据。 
* [0.x.6]*
   返回一个对源网格的引用。 
* [0.x.7]*
   返回一个对目标网格的引用。 
* [0.x.8]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.9]*
   异常情况  
* [0.x.10]*
   异常情况  
* [0.x.11]*
   实际的数据。为每一层的每个单元格保留一个迭代器。 
* [0.x.12]*
   存储一个指向源网格的指针。 
* [0.x.13]*
   同样，对于目标网格也是如此。 
* [0.x.14]*
   为给定的一对单元格设置映射。这些应该在细化程度和所有其他属性上匹配。 
* [0.x.15]*
   将键[2.x.8]的值设置为[2.x.9] 对[2.x.10]的所有子单元和它们的子单元也是如此 这个函数用于在[2.x.11]上比在[2.x.12]上更精细的单元，那么所有单元的层次及其子单元的值都指向[2.x.13] 上的一个单元   
* [0.x.16]

