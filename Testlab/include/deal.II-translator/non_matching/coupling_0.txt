include/deal.II-translator/non_matching/coupling_0.txt
[0.x.0]*
 一个函数命名空间，提供处理两个没有对齐要求的网格的工具。
* 通常这些函数允许对两个网格之间的实空间交点进行计算，例如表面积分和耦合矩阵的构造。

* 
* [0.x.1]*
   为非匹配的、重叠的网格创建一个耦合稀疏模式。    给出两个非匹配三角形，代表域[2.x.0]和[2.x.1] ，与[2.x.2]，以及两个有限元空间[2.x.3]和[2.x.4]，计算集合矩阵[1.x.0]所需的稀疏模式，其中[2.x.5 ]是与传递给该函数的`space_dh'相关的有限元空间（如果在`space_comps'中指定，则为其一部分），而[2.x.6]是与传递给该函数的`immersed_dh'相关的有限元空间（如果在`immersed_comps'中指定，则为其一部分）。    稀疏度 "是通过定位正交点（由参考正交`四边形'获得）的位置来填补的，这些正交点定义在[2.x.7]的元素上，相对于嵌入的三角形[2.x.8]。对于每个重叠的单元，对应于`space_dh`中的`space_comps`和`immersed_dh`中的`immersed_comps`的条目被添加到稀疏模式。    `space_comps'和`immersed_comps'掩码被假定为以同样的方式排序：`space_comps'的第一个分量将与`immersed_comps'的第一个分量耦合，第二个分量与第二个分量耦合，以此类推。如果两个掩码中的一个比另一个有更多的非零值，那么多余的成分将被忽略。    如果域[2.x.9]不在[2.x.10]之内，计算正交点位置的算法将抛出一个异常。特别要注意的是，这个函数只对`dim1`低于或等于`dim0`有感觉。一个静态断言可以保证实际情况是这样的。    对于这两个空间，可以指定一个自定义的Mapping，默认为StaticMappingQ1。    这个函数也可以并行工作，前提是浸入式三角形是[2.x.11]如果你使用浸入式[2.x.12]，会抛出一个异常，请看教程程序[2.x.13]中关于如何使用这个函数的例子。 
* [0.x.2]*
   与上述相同，但需要一个额外的[2.x.14]对象，而不是在内部创建一个。在这个版本的函数中，不能指定参数[2.x.15]space_mapping，因为它取自[2.x.16]参数。 
* [0.x.3]*
   为非匹配、重叠的网格创建耦合质量矩阵。    给出两个非匹配三角形，代表域[2.x.17]和[2.x.18] ，与[2.x.19]，以及两个有限元空间[2.x.20]和[2.x.21]，计算耦合矩阵[1.x.1]，其中[2.x.22 ]是与传递给该函数的`space_dh'相关的有限元空间（如果在`space_comps'中指定，则为其一部分），而[2.x.23]是与传递给该函数的`immersed_dh'相关的有限元空间（如果在`immersed_comps`中指定，则为其一部分）。    相应的稀疏性模式可以通过调用make_coupling_sparsity_pattern函数计算出来。矩阵的元素是通过定位定义在[2.x.24]元素上的正交点相对于嵌入三角形[2.x.25]的位置来计算的。    假设 "space_comps "和 "immersed_comps "掩码以同样的方式排序："space_comps "的第一个分量将与 "immersed_comps "的第一个分量耦合，第二个分量与第二个分量耦合，以此类推。如果两个掩码中的一个比另一个有更多的非零项非零值，那么多余的分量将被忽略掉。    如果域[2.x.26]不在[2.x.27]之内，计算正交点位置的算法将抛出一个异常。特别要注意的是，这个函数只对`dim1`低于或等于`dim0`有意义。静态断言可以保证实际情况是这样的。    对于这两个空间，可以指定一个自定义的Mapping，默认为StaticMappingQ1。    这个函数也可以并行工作，前提是浸入式三角形是[2.x.28]如果你使用浸入式[2.x.29]，会抛出一个异常，请看教程程序[2.x.30]中关于如何使用这个函数的例子。 
* [0.x.4]*
   与上述相同，但需要一个额外的[2.x.31]对象，而不是在内部创建一个。在这个版本的函数中，不能指定参数[2.x.32]space_mapping，因为它取自[2.x.33]参数。 
* [0.x.5]*
   为非匹配的独立网格创建一个耦合的稀疏模式，使用半径为ε的紧凑支持的卷积核。    给出两个非匹配三角形，代表域[2.x.34]和[2.x.35]，都嵌入在[2.x.36]中，以及两个有限元空间[2.x.37]和[2.x.38]，计算组装矩阵[1.x.2]所需的稀疏模式，其中[2.x.39]是与[2.x.40] 相关的有限元空间 ]传递给这个函数的有限元空间（如果在[2.x.41]中指定，则是其中一部分），而[2.x.42]是传递给这个函数的[2.x.43]相关的有限元空间（如果在[2.x.44]中指定，则是其中一部分），[2.x.45]是一个从CutOffFunctionBase导出的函数，其紧凑支持包含在半径为[2.x.46]的球中。    假设[2.x.47]和[2.x.48]掩码以同样的方式排序：[2.x.49]的第一个分量将与[2.x.50]的第一个分量耦合，第二个分量与第二个分量耦合，以此类推。如果两个掩码中的一个比另一个有更多的有效成分，那么多余的成分将被忽略。    对于这两个空间，可以指定一个自定义的Mapping，这两个空间的默认值是StaticMappingQ1。    如果至少有一个三角形是[2.x.51]类型的，这个函数也会并行工作，如果两个三角形都是[2.x.52]类型的，就会出现异常。 ] 如果epsilon被设置为零，那么我们假定内核是狄拉克三角分布，并且调用被转发到这个名字空间中的同名方法，该方法不接受epsilon作为输入（但需要正交公式[2.x.54]）。在这种情况下，对两个空间需要有更多的限制条件。参见其他create_coupling_sparsity_pattern()函数的文档。 
* [0.x.6]*
   为非匹配的独立网格创建一个耦合质量矩阵，使用具有紧凑支持的卷积核。    给出两个非匹配三角形，代表域[2.x.55]和[2.x.56]，都嵌入在[2.x.57]中，以及两个有限元空间[2.x.58]和[2.x.59]，计算矩阵[1.x.3] 其中[2.x.60]是与[2.x.61 ] 传递给这个函数的有限元空间（如果在 [2.x.62] 中指定，则为其中一部分），而 [2.x.63] 是传递给这个函数的 [2.x.64] 相关的有限元空间（如果在 [2.x.65] 中指定，则为其中一部分），而 [2.x.66] 是一个从 CutOffFunctionBase 派生的函数，紧凑支持包含在半径为 [2.x.67] 的球中。    相应的稀疏性模式可以通过调用make_coupling_sparsity_pattern()函数来计算。    假设[2.x.68]和[2.x.69]掩码以同样的方式排序：[2.x.70]的第一个分量将与[2.x.71]的第一个分量耦合，第二个分量与第二个分量耦合，以此类推。如果两个掩码中的一个比另一个有更多的有效成分，那么多余的成分将被忽略。    对于这两个空间，可以指定一个自定义的Mapping，这两个空间的默认值是StaticMappingQ1。    这个函数也可以并行工作，前提是两个三角形中的一个是[2.x.72]类型，如果两个三角形都是[2.x.73]类型，则会出现异常。 参数[2.x.74]用于设置用于计算卷积的截断函数的大小。如果epsilon被设置为0，那么我们假定内核是狄拉克德尔塔分布，并且调用被转发到这个名字空间中的同名方法，该方法不接受epsilon作为输入。 
* [0.x.7]

