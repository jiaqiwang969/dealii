include/deal.II-translator/dofs/dof_accessor_0.txt
[0.x.0]*
     这是一个开关类，它只声明一个 [2.x.0] 它是用来确定DoFAccessor类是从哪个类派生的。默认情况下，<tt>DoFAccessor [2.x.1] 派生自一般的<tt>Inheritance [2.x.2] 类中的别名，即<tt>TriaAccessor [2.x.3]，但如果<tt>structdim==dim</tt>，则使用专门化<tt>Inheritance [2.x.4 ]被使用，它声明其本地类型为<tt>CellAccessor [2.x.5] 因此，如果所考虑的对象有完整的尺寸，即构成一个单元，则自动选择继承自CellAccessor。       
* [2.x.6]     
* [2.x.7]     
* [0.x.1]*
       [2.x.8]的声明 更多信息请参见完整的文档。     
* [0.x.2]*
     这是一般模板的特殊化，用于对象有全尺寸的情况，即是一个单元。更多细节见一般模板。   
* [0.x.3]*
       [2.x.9]的声明 更多信息请参见完整的文档。     
* [0.x.4]*
 一个可以访问存储在DoFHandler对象中的自由度的类。访问器用于访问与三角形的边、面和单元有关的数据。这个概念在 [2.x.10] 中有更详细的解释。
* 该类主要遵循三角形库中声明的访问器库（TriaAccessor）所规定的路线。它使用户能够访问线、四边形或六边形的自由度。这个类的第一个模板参数决定了所考虑的对象的维度。1用于线，2用于四边形，3用于六边形。第二个参数表示我们应该在哪个类型的DoFHandler上工作。从第二个模板参数中，我们还可以推导出这个对象所指向的三角形的维度，以及它所嵌入的空间的维度。最后，模板参数[2.x.11]制约着函数get_active_or_mg_dof_indices()的行为。参见下面关于通用循环的部分。
* [1.x.0]
* 使用方法最好是通过DoFHandler类提供的各种迭代器的别名来实现，因为它们对类的命名和模板接口的变化更安全，同时也提供了更简单的输入方式（更少的复杂名称！）。
* [1.x.1]
* 许多循环看起来非常相似，无论它们是对三角结构的活动单元的活动道次进行操作，还是对单层或整个网格层次的水平道次进行操作。为了在这类循环中使用多态性，它们通过函数get_active_or_mg_dof_indices()访问自由度，该函数根据第三个模板参数改变行为。 如果该参数为false，那么将访问活动单元的活动自由度。如果它是true，则使用水平道夫。DoFHandler有一些函数，例如begin()和begin_mg()，它们返回任一类型或其他类型。此外，它们可以相互转换，如果需要的话，因为它们访问的是相同的数据。
* 建议在通用循环中使用函数get_active_or_mg_dof_indices()来代替get_dof_indices()或get_mg_dof_indices()。
* [1.x.2]
* 如果第一个模板参数给出的结构维度等于DoFHandler的维度（作为第二个模板参数给出），那么我们显然是在处理单元，而不是低维的对象。在这种情况下，继承自CellAccessor，以提供对该类所提供的所有细胞特定信息的访问。否则，也就是说，对于低维对象，继承自TriaAccessor。
* 有一个DoFCellAccessor类，提供了与CellAccessor类等价的功能。
* [2.x.12] structdim 访问器代表的对象的维度。例如，点的[2.x.13]等于0，边的[2.x.14]等于1，等等。 [2.x.15] dim 底层DoFHandler的维度。 [2.x.16] spacedim 底层DoFHandler的空间尺寸。 [2.x.17] level_dof_access 如果[2.x.18]，则访问器简单地表示DoFHandler中的单元、面或边，对于这些单元、面或边，自由度只存在于最精细的层面上。在这种情况下，有些操作是不允许的，比如询问非活动单元的自由度指数。另一方面，如果这个模板参数是[2.x.19]，那么访问器代表自由度多级层次中的一个对象。在这种情况下，访问[1.x.3]单元的DoF指数是可能的，并将返回[1.x.4]指数（对于活动单元，可能与[1.x.5]指数不同）。
* 

* 
* [2.x.20] 

* 
* [2.x.21] 

 
* [0.x.5]*
   一个静态变量，允许该类的用户发现第二个模板参数的值。 
* [0.x.6]*
   一个静态变量，允许这个类的用户发现第三个模板参数的值。 
* [0.x.7]*
   声明一个基类的别名，使访问一些异常类更加简单。 
* [0.x.8]*
   迭代器类所传递的数据类型。 
* [0.x.9]*
    [2.x.22] 构造函数  
* [0.x.10]*
    [2.x.23]   
* [0.x.11]*
   默认构造函数。提供一个不能使用的访问器。 
* [0.x.12]*
   构造函数，生成一个指向DoFHandler中特定单元或面或边的访问。     [2.x.24] tria 这个访问器所指向的三角结构。   [2.x.25] level 指向对象的网格层次结构中的级别。例如，粗略的网格单元有零级，它们的子层有一级，以此类推。对于没有等级的面和边，这个参数会被忽略。   [2.x.26] index 指向指定细化层的对象的索引。   [2.x.27] dof_handler 指向访问器应引用的DoFHandler对象的指针。当然，这个DoFHandler对象必须建立在与第一个参数中指定的相同的三角形上。 
* [0.x.13]*
   复制构造器。 
* [0.x.14]*
   移动构造函数。 
* [0.x.15]*
   解除构造器。 
* [0.x.16]*
   转换构造器。这个构造器的存在是为了使某些构造在独立于维度的代码中写得更简单。例如，它允许将一个面的迭代器分配给一个线的迭代器，这个操作在2D中很有用，但在3D中没有任何意义。这里的构造函数是为了使代码符合C++的要求而存在的，但它会无条件地中止；换句话说，将面迭代器赋值给线迭代器最好放在一个if语句中，检查维度是否为2，并在3D中赋值给一个四维迭代器（如果没有这个构造函数，如果我们碰巧为2d编译，这个操作是非法的）。 
* [0.x.17]*
   另一个对象之间的转换操作符，就像之前的那个一样，没有意义。 
* [0.x.18]*
   复制构造函数允许切换级别访问和主动访问。 
* [0.x.19]*
   拷贝操作符。这些操作符通常在类似<tt>iterator a,b;a=*b;</tt>的情况下使用。据推测，这里的意图是将[2.x.28]所指向的对象复制到[2.x.29]所指向的对象。然而，取消引用迭代器的结果不是一个对象，而是一个访问器；因此，这个操作对DoF处理程序对象的迭代器没有用。  因此，这个操作被声明为删除，不能使用。 
* [0.x.20]*
   移动赋值运算符。 
* [0.x.21]*
    [2.x.30]   
* [0.x.22]*
   返回一个我们正在使用的DoFHandler对象的句柄。 
* [0.x.23]*
   实现迭代器类所需的复制操作。 
* [0.x.24]*
   迭代器类所使用的复制运算器。保留之前设置的dof处理程序，但设置TriaAccessor的对象坐标。 
* [0.x.25]*
   告诉调用者get_active_or_mg_dof_indices()是访问活动的还是水平的道夫。 
* [0.x.26]*
    [2.x.31] 访问子对象  
* [0.x.27]*
    [2.x.32]   
* [0.x.28]*
   返回一个指向[2.x.33]子对象的迭代器。 
* [0.x.29]*
   指向与此对象相界的[2.x.34]线的指针。如果当前对象本身是一条线，那么唯一有效的索引是[2.x.35]等于零，并且该函数返回一个指向自身的迭代器。 
* [0.x.30]*
   指向与此对象相邻的[2.x.36]四边形的指针。如果当前对象本身是一个四边形，那么唯一有效的索引是[2.x.37]等于零，并且该函数返回一个指向自身的迭代器。 
* [0.x.31]*
    [2.x.38]   
* [0.x.32]*
    [2.x.39] 访问此对象的DoF索引  
* [0.x.33]*
    [2.x.40]   
* [0.x.34]*
   返回位于此对象上的自由度的[1.x.6]指数，以有限元定义的标准排序（即顶点0上的自由度，顶点1上的自由度，等等，行0上的自由度，行1上的自由度，等等，quad 0上的自由度，等等）此函数仅对[1.x.7]对象可用（见[2.x.41]"此词汇条"）。    单元需要是一个活跃的单元（而不是平行分布式计算中的人工）。    向量在传递给这个函数之前必须有合适的大小。    最后一个参数表示有限元素的索引。对于标准的::DoFHandler类，这个值必须等于其默认值，因为该类无论如何只支持所有单元上的同一有限元。    然而，当相关的DoFHandler对象启用了hp-capabilities，不同的有限元对象可以在不同的单元格上使用。因此，在两个单元之间的面以及顶点上，可能有两组自由度，相邻单元上使用的每个有限元都有一个。为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果一致。    对于单元，只有一个可能的有限元指数（即该单元的指数，由[2.x.42]返回。  因此，派生的DoFCellAccessor类有一个该函数的重载版本，它以[2.x.43]为最后参数调用本函数。 
* [0.x.35]*
   返回当前对象上的自由度的全局多级指数，相对于多网格层次结构中的给定层次而言。指数是指该行所处层次的本地编号。 
* [0.x.36]*
   设置由get_mg_dof_indices返回的层次DoF指数。 
* [0.x.37]*
   与当前单元的[2.x.44]顶点相关的[1.x.8]度的全局DoF指数。    最后一个参数表示的是有限元索引。对于标准的::DoFHandler类，这个值必须等于其默认值，因为该类反正只支持所有单元上的相同有限元。    然而，当hp-capabilities被启用时，不同的有限元对象可以被用于不同的单元。因此，在两个单元之间的面以及顶点上，可能有两组自由度，相邻单元上使用的每个有限元都有一个。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果一致。 
* [0.x.38]*
   返回与[2.x.47]层的[2.x.46]个顶点相关的[2.x.45]个自由度的全局DoF索引。 也可以参见vertex_dof_index()。 
* [0.x.39]*
   这个对象的第[1.x.9]个自由度的索引。    最后一个参数表示有限元索引。对于标准的::DoFHandler类，这个值必须等于它的默认值，因为该类反正只支持所有单元上的同一个有限元。    然而，当hp-capabilities被启用时，不同的有限元对象可以被用于不同的单元。因此，在两个单元之间的面以及顶点上，可能有两组自由度，相邻单元上使用的每个有限元都有一个。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果相匹配。   
* [2.x.48] 虽然get_dof_indices()函数返回一个数组，其中包含以某种方式存在于这个对象上的所有自由度的索引（即在这个对象的顶点、边或内部），但当前的dof_index()函数只考虑真正属于这个特定对象内部的自由度。换句话说，举个例子，如果当前对象指的是一个四边形（2D中的单元，3D中的面），并且与之相关的有限元是双线性的，那么get_dof_indices()会返回一个大小为4的数组，而dof_index()会产生一个异常，因为在面的内部没有定义度。 
* [0.x.40]*
   返回给定层面上的dof_index。也见dof_index。 
* [0.x.41]*
    [2.x.49]   
* [0.x.42]*
    [2.x.50] 访问与此对象相关的有限元  
* [0.x.43]*
    [2.x.51]   
* [0.x.44]*
   返回在给定对象上激活的有限元的数量。    当hp-capabilities被禁用时，答案当然总是1。  然而，当hp-capabilities被启用时，情况就不是这样了。如果这是一个单元，答案当然是1。如果它是一个面，答案可能是1或2，取决于相邻的两个单元是否使用相同的有限元。如果它是一个3D的边，可能的返回值可能是1或大于这个值的任何其他值。 
* [0.x.45]*
   返回此对象上的[2.x.52]活动FE索引。对于单元格和所有非hp-objects，只有一个活跃的FE索引，所以参数必须等于0。对于低维的hp-objects，有n_active_fe_indices()活动有限元，这个函数可以查询它们的指数。 
* [0.x.46]*
   返回此对象上的所有活动FE指数。    返回的集合的大小等于此对象上活动的有限元的数量。 
* [0.x.47]*
   如果具有给定索引的有限元在当前对象上处于活动状态，则返回真。当当前DoFHandler没有hp-能力时，当然只有当[2.x.53]等于0时才是这种情况。对于单元格来说，如果[2.x.54]等于该单元格的active_fe_index()，则是这种情况。对于面和其他低维物体，可能有一个以上的[2.x.55]在任何给定的物体上是活跃的（见n_active_fe_indices()）。 
* [0.x.48]*
   返回给定[2.x.56]在此对象上使用的有限元的引用[2.x.57]必须在此对象上使用，即[2.x.58]必须返回true。 
* [0.x.49]*
    [2.x.59]   
* [0.x.50]*
   子类的例外情况    
* [2.x.60]   
* [0.x.51]*
   异常情况    
* [2.x.61]   
* [0.x.52]*
   异常情况    
* [2.x.62]   
* [0.x.53]*
   异常情况    
* [2.x.63]   
* [0.x.54]*
   为一个应该是[2.x.64]"活动 "的单元格调用了一个函数，但它被细化了。   
* [2.x.65]   
* [0.x.55]*
   异常情况    
* [2.x.66]   
* [0.x.56]*
   存储要访问的DoFHandler对象的地址。 
* [0.x.57]*
   比较是否相等。如果两个访问器引用的是同一个对象，则返回<tt>true</tt>。    这个函数的模板参数允许对非常不同的对象进行比较。因此，其中一些被禁用。也就是说，如果两个对象的尺寸或dof处理程序不同，会产生一个异常。可以预见，这是一个不需要的比较。    模板参数<tt>level_dof_access2</tt>被忽略了，这样，一个有级别访问的迭代器可以等于一个有活动自由度访问的迭代器。 
* [0.x.58]*
   比较不等式。操作符==()的布尔值不是。 
* [0.x.59]*
   重置DoF处理程序指针。 
* [0.x.60]*
   将此对象的[1.x.10]个自由度的索引设置为[2.x.67]个索引。    最后一个参数表示有限元索引。对于标准的::DoFHandler类，这个值必须等于其默认值，因为该类无论如何只支持所有单元上的同一有限元。    然而，当相关的DoFHandler具有hp-capabilities时，不同的有限元对象可以在不同的单元上使用。在两个单元格之间的面上，以及顶点上，可能会有两组自由度，相邻单元格上使用的有限元各有一组。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果一致。 
* [0.x.61]*
   将当前单元的[2.x.68]顶点上的[1.x.11]度的全局索引设置为[2.x.69] 最后一个参数表示有限元索引。对于标准的::DoFHandler类，这个值必须等于其默认值，因为该类无论如何只支持所有单元上的相同有限元。    然而，当相关的DoFHandler具有hp-capabilities时，不同的有限元对象可以在不同的单元上使用。在两个单元格之间的面上，以及顶点上，可能会有两组自由度，相邻单元格上使用的有限元各有一组。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果一致。 
* [0.x.62]*
 一般DoFAccessor类模板的特化，用于零维对象（顶点）的情况，这些对象是空间维度上的一维单元的面。由于顶点的功能与一般的面不同，这个类做了一些与一般模板不同的事情，但界面看起来应该是一样的。

* 
* [0.x.63]*
   一个静态变量，允许这个类的用户发现第二个模板参数的值。 
* [0.x.64]*
   一个静态变量，允许这个类的用户发现第三个模板参数的值。 
* [0.x.65]*
   声明一个基类的别名，使访问一些异常类更加简单。 
* [0.x.66]*
   迭代器类所传递的数据类型。 
* [0.x.67]*
    [2.x.70] 构造函数  
* [0.x.68]*
    [2.x.71]   
* [0.x.69]*
   默认构造函数。提供一个不能使用的访问器。 
* [0.x.70]*
   如果这里的对象指的是一维三角形的一个顶点，即三角形的一个面，则使用构造函数。    由于没有从顶点到单元的映射，一个点的访问器对象没有办法弄清它是否在域的边界上。因此，第二个参数必须由生成这个访问器的对象来传递
* 
* 例如，一个1d单元可以计算出它的左或右顶点是否在边界上。    第三个参数是我们指向的顶点的全局索引。    第四个参数是一个指向DoFHandler对象的指针。    这个迭代器只能为一维三角计算调用。 
* [0.x.71]*
   构造函数。这个构造函数的存在是为了保持与其他访问器类的接口兼容性。然而，它在这里并没有做任何有用的事情，所以实际上可能不会被调用。 
* [0.x.72]*
   转换构造函数。这个构造函数的存在是为了使某些构造在独立于维度的代码中写得更简单。例如，它允许将一个面的迭代器分配给一个线的迭代器，这个操作在2D中很有用，但在3D中没有任何意义。这里的构造函数是为了使代码符合C++的要求而存在的，但它会无条件地中止；换句话说，将面迭代器分配给线迭代器最好放在一个if语句中，检查维度是否为2，并在3D中分配给一个四边形迭代器（如果没有这个构造函数，如果我们碰巧为2d编译，这个操作是非法的）。 
* [0.x.73]*
   另一个对象之间的转换操作符，就像之前的那个一样，没有意义。 
* [0.x.74]*
   复制构造器。 
* [0.x.75]*
   移动构造函数。 
* [0.x.76]*
   解除构造器。 
* [0.x.77]*
   复制操作符。这些操作符通常在类似<tt>iterator a,b;a=*b;</tt>的上下文中使用。据推测，这里的意图是将[2.x.72]所指向的对象复制到[2.x.73]所指向的对象。然而，取消引用迭代器的结果不是一个对象，而是一个访问器；因此，这个操作对DoF处理程序对象的迭代器没有用。  因此，这个操作被声明为删除，不能使用。 
* [0.x.78]*
   移动赋值运算符。 
* [0.x.79]*
    [2.x.74]   
* [0.x.80]*
   返回一个我们正在使用的DoFHandler对象的句柄。 
* [0.x.81]*
   实现迭代器类所需的复制操作。 
* [0.x.82]*
   迭代器类所使用的复制运算器。保留之前设置的dof处理程序，但设置TriaAccessor的对象坐标。 
* [0.x.83]*
    [2.x.75] 访问子对象  
* [0.x.84]*
    [2.x.76]   
* [0.x.85]*
   返回一个无效的迭代器，其类型代表指向当前对象的一个子对象。该对象是无效的，因为点（由当前类代表）没有子代。 
* [0.x.86]*
   指向与此对象相界的[2.x.77]线的指针。    由于维度为1的网格没有四边形，这个方法只是抛出一个异常。 
* [0.x.87]*
   指向包围此对象的[2.x.78]四边形的指针。    由于维度为1的网格没有四边形，这个方法只是抛出一个异常。 
* [0.x.88]*
    [2.x.79]   
* [0.x.89]*
    [2.x.80] 访问此对象的DoF指数  
* [0.x.90]*
    [2.x.81]   
* [0.x.91]*
   返回位于此物体上的自由度的[1.x.12]指数，其标准排序由有限元定义。这个函数只适用于[1.x.13]对象（见[2.x.82]"本词汇条"）。    目前的顶点必须属于一个活动单元（而不是在并行分布式计算中的人工）。    向量在传递给这个函数之前必须有合适的大小。    最后一个参数表示有限元素的索引。对于标准的::DoFHandler类，这个值必须等于其默认值，因为该类无论如何只支持所有单元上的同一有限元。    然而，当相关的DoFHandler具有hp-capabilities时，不同的有限元对象可以在不同的单元上使用。在两个单元格之间的面上，以及顶点上，可能会有两组自由度，相邻单元格上使用的有限元各有一组。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果一致。    对于单元，只有一个可能的有限元指数（即该单元的指数，由[2.x.83]返回。  因此，派生的DoFCellAccessor类有一个该函数的重载版本，它以[2.x.84]为最后参数调用本函数。 
* [0.x.92]*
   返回当前对象上的自由度的全局多级指数，相对于多网格层次结构中的给定层次而言。指数是指该行所处层次的本地编号。 
* [0.x.93]*
   与当前单元的[2.x.85]顶点相关的[1.x.14]度的全局DoF索引。    最后一个参数表示的是有限元索引。对于标准的::DoFHandler类，这个值必须等于其默认值，因为该类无论如何只支持所有单元上的同一有限元。    然而，当相关的DoFHandler具有hp-capabilities时，不同的有限元对象可以在不同的单元上使用。在两个单元格之间的面上，以及顶点上，可能会有两组自由度，相邻单元格上使用的有限元各有一组。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果一致。 
* [0.x.94]*
   此对象的[1.x.15]个自由度的索引。    最后一个参数表示有限元索引。对于标准的::DoFHandler类，这个值必须等于它的默认值，因为该类反正只支持所有单元上的同一个有限元。    然而，当相关的DoFHandler具有hp-capabilities时，不同的有限元对象可以在不同的单元上使用。在两个单元格之间的面上，以及顶点上，可能会有两组自由度，相邻单元格上使用的有限元各有一组。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果一致。 
* [0.x.95]*
    [2.x.86]   
* [0.x.96]*
    [2.x.87] 访问与此对象相关的有限元  
* [0.x.97]*
    [2.x.88]   
* [0.x.98]*
   返回在给定对象上激活的有限元的数量。    由于顶点没有存储计算所需的信息，这个方法只是引发一个异常，只是为了实现与尺寸无关的编程而存在。 
* [0.x.99]*
   返回此对象上的[2.x.89]活动FE索引。    由于顶点没有存储计算所需的信息，这个方法只是引发一个异常，并且只是为了实现独立于维度的编程。 
* [0.x.100]*
   如果给定索引的有限元在当前对象上是活动的，则返回真。    由于顶点没有存储计算所需的信息，这个方法只是引发一个异常，并且只存在于实现独立于维度的编程。 
* [0.x.101]*
   返回给定[2.x.90]用于此对象的有限元的引用 [2.x.91]必须用于此对象，即[2.x.92]必须返回true。 
* [0.x.102]*
    [2.x.93]   
* [0.x.103]*
   子类的例外情况    
* [2.x.94]   
* [0.x.104]*
   异常情况    
* [2.x.95]   
* [0.x.105]*
   异常情况    
* [2.x.96]   
* [0.x.106]*
   异常情况    
* [2.x.97]   
* [0.x.107]*
   为一个应该是[2.x.98]"活动 "的单元格调用了一个函数，但它被细化了。   
* [2.x.99]   
* [0.x.108]*
   异常情况    
* [2.x.100]   
* [0.x.109]*
   存储要访问的DoFHandler对象的地址。 
* [0.x.110]*
   比较是否相等。 
* [0.x.111]*
   比较不等式。 
* [0.x.112]*
   重置DoF处理程序指针。 
* [0.x.113]*
   将此对象的[1.x.16]个自由度的索引设置为[2.x.101]个索引。    最后一个参数表示有限元索引。对于标准的::DoFHandler类，这个值必须等于其默认值，因为该类无论如何只支持所有单元上的同一个有限元。    然而，当相关的DoFHandler具有hp-capabilities时，不同的有限元对象可以在不同的单元上使用。在两个单元格之间的面上，以及顶点上，可能会有两组自由度，相邻单元格上使用的有限元各有一组。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果相匹配。 
* [0.x.114]*
   将当前单元的[2.x.102]顶点上的[1.x.17]度的全局索引设置为[2.x.103] 最后一个参数表示有限元索引。对于标准的::DoFHandler类，这个值必须等于其默认值，因为该类无论如何只支持所有单元上的相同有限元。    然而，当相关的DoFHandler具有hp-capabilities时，不同的有限元对象可以在不同的单元上使用。在两个单元格之间的面上，以及顶点上，可能会有两组自由度，相邻单元格上使用的有限元各有一组。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果一致。 
* [0.x.115]*
 一个代表DoF访问器对象的类，用于表示不合理的迭代器，如1D网格上的四维迭代器。 这个类不能用来创建对象（事实上，如果试图这样做的话，它会抛出一个异常，但它有时允许以独立于维度的方式，以更简单的方式编写代码。例如，它允许编写独立于维度的四边形迭代器的代码
* 
* - 即，也可以在1d中进行编译
* 
* - 因为四元迭代器（通过当前的类）存在，并且在语法上是正确的。然而，你不能期望在1d中创建这些迭代器中的一个实际对象，这意味着你需要期望将使用四元迭代器的代码块包装成类似[2.x.104]的东西。
* 
* - 反正这也是很有意义的。
* 这个类提供了Accessor类与Iterator类交互所需的最小接口。然而，这只是为了语法上的正确性，这些函数除了产生错误之外，没有任何作用。
* 

* 
* [2.x.105] 

 
* [0.x.116]*
   从基类传播别名到这个类。 
* [0.x.117]*
   构造器。 这个类用于在给定维度中没有意义的迭代器，例如1D网格的四边形。因此，虽然这种对象的创建在语法上是有效的，但它们在语义上没有意义，当这种对象实际生成时，我们会产生一个异常。 
* [0.x.118]*
   复制构造函数。 这个类用于在给定维度中没有意义的迭代器，例如1D网格的四边形。因此，虽然这种对象的创建在语法上是有效的，但它们在语义上没有意义，当这种对象实际生成时，我们会产生一个异常。 
* [0.x.119]*
   从其他访问器转换到当前无效的访问器。这当然也会导致运行时错误。 
* [0.x.120]*
   返回这个对象的[1.x.18]个自由度的索引到[2.x.106]，因为当前对象没有指向任何有用的东西，像这个类中的所有其他函数一样，这个函数只抛出一个异常。 
* [0.x.121]*
   将此对象的[1.x.19]个自由度的索引设置为[2.x.107]个索引。由于当前对象没有指向任何有用的东西，像这个类中的所有其他函数一样，这个函数只抛出一个异常。 
* [0.x.122]*
 授予对单元格的自由度的访问权。
* 注意，因为对于我们派生的类，即<tt>DoFAccessor<dim></tt>，两个模板参数是相等的，基类实际上是派生自CellAccessor，这使得这个类的函数对DoFCellAccessor类也可用。
* 

* 
* [2.x.108] 

* 
* [2.x.109] 

 
* [0.x.123]*
   从DoFHandler中提取尺寸。 
* [0.x.124]*
   从DoFHandler中提取空间维度。 
* [0.x.125]*
   由迭代器类传递的数据类型。 
* [0.x.126]*
   声明基类的别名，使访问一些异常类更简单。 
* [0.x.127]*
   定义这个容器的类型，是它的一部分。 
* [0.x.128]*
   一个单元格的面的迭代器的类型。这就是face()函数的返回值。 
* [0.x.129]*
    [2.x.110] 构造器和初始化  
* [0.x.130]*
    [2.x.111]   
* [0.x.131]*
   构造函数  
* [0.x.132]*
   转换构造器。这个构造器的存在是为了使某些构造在独立于维度的代码中写得更简单。例如，它允许将一个面的迭代器分配给一个线的迭代器，这个操作在2D中很有用，但在3D中没有任何意义。这里的构造函数是为了使代码符合C++的要求而存在的，但它会无条件地中止；换句话说，将一个面迭代器分配给一个线迭代器，最好放在一个if语句中，检查维度是否为2，并在3D中分配给一个四边形迭代器（如果没有这个构造函数，如果我们碰巧为2d编译，这个操作是非法的）。 
* [0.x.133]*
   另一个对象之间的转换操作符，就像之前的那个一样，没有意义。 
* [0.x.134]*
   复制构造器。 
* [0.x.135]*
   移动构造函数。 
* [0.x.136]*
   解除构造函数  
* [0.x.137]*
   复制操作符。这些操作符通常在类似<tt>iterator a,b;a=*b;</tt>的情况下使用。据推测，这里的意图是将[2.x.112]所指向的对象复制到[2.x.113]所指向的对象。然而，取消引用迭代器的结果不是一个对象，而是一个访问器；因此，这个操作对于DoF处理程序对象上的迭代器是没用的。  因此，这个操作被声明为删除，不能被使用。 
* [0.x.138]*
   移动赋值运算符。 
* [0.x.139]*
    [2.x.114]   
* [0.x.140]*
   以DoF单元格迭代器的形式返回该单元格的父级。如果父对象不存在（即，如果该对象处于网格层次结构的最粗层），将产生一个异常。    这个函数是需要的，因为基类CellAccessor的父函数返回一个没有访问DoF数据的三角形单元访问器。 
* [0.x.141]*
    [2.x.115] 访问子对象和相邻对象  
* [0.x.142]*
    [2.x.116]   
* [0.x.143]*
   将[2.x.117]邻居作为DoF单元迭代器返回。这个函数是需要的，因为基类的邻居函数返回一个没有访问DoF数据的单元格访问器。 
* [0.x.144]*
   返回[2.x.118]周期性邻居作为DoF单元的迭代器。这个函数是需要的，因为基类的邻居函数返回一个没有访问DoF数据的单元访问器。 
* [0.x.145]*
   返回[2.x.119]邻居或周期性邻居作为DoF单元的迭代器。  这个函数是需要的，因为基类的邻居函数返回一个没有访问DoF数据的单元格访问器。 
* [0.x.146]*
   将[2.x.120]的子单元作为DoF单元迭代器返回。这个函数是需要的，因为基类的子函数返回一个没有访问DoF数据的单元格访问器。 
* [0.x.147]*
   返回该单元格所有子节点的迭代器数组。 
* [0.x.148]*
   返回此单元格的[2.x.121]面的一个迭代器。    这个函数返回一个一维的[2.x.122]的DoFAccessor，二维的[2.x.123]，以及三维的[2.x.124]。 
* [0.x.149]*
   返回该单元格所有面的迭代器数组。 
* [0.x.150]*
   返回基类中[2.x.125]函数的结果，但将其转换为也可以访问DoF数据（基类中的函数只返回一个访问三角形数据的迭代器）。 
* [0.x.151]*
   返回基类中[2.x.126]函数的结果，但将其转换为也可以访问DoF数据（基类中的函数只返回一个可以访问三角测量数据的迭代器）。 
* [0.x.152]*
    [2.x.127]   
* [0.x.153]*
    [2.x.128] 从全局向量中提取数值  
* [0.x.154]*
    [2.x.129]   
* [0.x.155]*
   收集限制在此单元格的道夫上的给定向量的值，其标准排序为：顶点0上的道夫，顶点1上的道夫，等等，行0上的道夫，行1上的道夫，等等，四边0上的道夫，等等。换句话说，这个函数实现了一个[聚集操作](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing))。    在传递给这个函数之前，向量必须有合适的大小。这个函数只适用于活动单元的调用。    输入的向量可以是<tt>Vector<float></tt>、Vector<double>或BlockVector<double>，或者是PETSc或Trilinos向量，如果deal.II被编译为支持这些库。调用者有责任保证存储在输入和输出向量中的数字类型是兼容的，并且具有相似的精度。 
* [0.x.156]*
   收集限制在该单元格的道夫上的给定向量的值，其标准排序为：顶点0的道夫，顶点1的道夫，等等，行0的道夫，行1的道夫，等等，四边0的道夫，等等。换句话说，这个函数实现了一个[聚集操作](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing))。    在传递给这个函数之前，向量必须有合适的大小。这个函数只适用于活动单元的调用。    输入的向量可以是<tt>Vector<float></tt>、Vector<double>或BlockVector<double>，或者是PETSc或Trilinos向量，如果deal.II被编译为支持这些库。调用者有责任保证存储在输入和输出向量中的数字类型是兼容的，并且具有相似的精度。 
* [0.x.157]*
   收集限制在该单元格的道夫上的给定向量的值，其标准排序为：顶点0的道夫，顶点1的道夫，等等，行0的道夫，行1的道夫，等等，四边0的道夫，等等。换句话说，这个函数实现了一个[聚集操作](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing))。    在传递给这个函数之前，向量必须有合适的大小。这个函数只适用于活动单元的调用。    输入的向量可以是<tt>Vector<float></tt>、Vector<double>或BlockVector<double>，或者是PETSc或Trilinos向量，如果deal.II被编译为支持这些库。调用者有责任保证存储在输入和输出向量中的数字类型是兼容的，并且具有相似的精度。作为参数传递给该函数的AffineConstraints对象可以确保在计算dof值时约束条件的分布是正确的。 
* [0.x.158]*
   这个函数是get_dof_values()的对应函数：它接收这个迭代器所指向的单元的自由度值的向量，并将这些值写入全局数据向量[2.x.130] 换句话说，这个函数实现了一个[散点操作](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing))。  这个函数只对活动单元可调用。    请注意，对于连续的有限元，调用这个函数也会影响到相邻单元的dof值。如果相邻单元的精细度低于当前单元，它还可能违反悬挂节点的连续性要求。这些要求没有被考虑到，必须由用户事后强制执行。    向量在被传递给这个函数之前必须有合适的大小。    输出的向量可以是Vector<float>, Vector<double>, 或BlockVector<double>, 或PETSc向量，如果deal.II被编译为支持这些库。调用者有责任保证存储在输入和输出向量中的数字类型是兼容的，并且具有相似的精度。 
* [0.x.159]*
   返回给定的有限元函数对当前单元的插值。在最简单的情况下，该单元是一个终端单元，即它没有子单元；那么，返回值是该单元上的节点值向量。你也可以通过[2.x.131]get_dof_values函数获得所需的值。在另一种情况下，当单元有子节点时，我们使用有限元类提供的限制矩阵来计算从子节点到本单元的内插。    如果单元是具有hp能力的DoFHandler的一部分，单元只有在活动时才有相关的有限元空间。然而，这个函数也应该提供有子单元的非活动单元的信息。因此，它带有第三个参数，可以在hp-context中使用，表示我们应该插值到的有限元空间。如果单元是活动的，这个函数就会从这个单元的[2.x.132]向量中获得有限元函数，并将其插值到[2.x.133]中的第1个元素所描述的空间，这个单元是DoFHandler中的一部分。如果该单元不是活动的，那么我们首先对其所有的终端子单元进行插值，然后将这个函数插值到所要求的单元，保持函数空间不变。    假设两个输入向量事先已经有了合适的大小。   
* [2.x.135]与get_dof_values()函数不同，这个函数只对单元格有效，而不是对线、四边形和六边形，因为插值目前只由有限元类为单元格提供。 
* [0.x.160]*
   这个函数是get_interpolated_dof_values()的对应函数：你指定单元格上的dof值，这些值被内插到当前单元格的子单元，并设置在终端单元上。    原则上，它的工作原理如下：如果这个对象指向的单元格是终端（即没有子单元），那么通过调用set_dof_values()函数在全局数据向量中设置dof值；否则，这些值被延长到每个子单元，并为每个子单元调用这个函数。    使用get_interpolated_dof_values()和这个函数，你可以计算一个有限元函数对一个更粗的网格的内插，首先在粗网格的一个单元上得到内插的解，之后用这个函数重新分配。    请注意，对于连续有限元，调用这个函数也会影响到相邻单元上的道夫值。如果相邻的单元比现在的单元细化程度低，或者它们的子单元比这个单元的子单元细化程度低，那么它也可能违反悬挂节点的连续性要求。这些要求没有得到照顾，必须由用户事后强制执行。    如果单元格是具有hp能力的DoFHandler的一部分，单元格只有在活动时才有相关的有限元空间。然而，这个函数也应该在有子代的非活动单元上工作。  因此，它带有第三个参数，可以在hp-上下文中使用，表示我们应该解释这个函数的输入矢量的有限元空间。如果单元格是活动的，这个函数就会将输入向量解释为与该单元格所属的DoFHandler相关的[2.x.136]的第三个元素所描述的空间元素，并将其插值到与该单元格相关的空间。另一方面，如果单元格不是活动的，那么我们首先使用给定的[2.x.138]从这个单元格到它的子单元格进行内插，直到我们在一个活动的单元格上结束，这时我们遵循本段开头的程序。    假设两个向量事先已经有了合适的大小。  这个函数依赖于一个单元的有限元空间对其子女的自然插值属性的存在，由有限元类的延长矩阵表示。对于某些元素，粗网格和细网格上的空间没有嵌套，在这种情况下，对子单元的插值不是相同的；关于在这种情况下延长矩阵所代表的内容，请参考各自的有限元类的文档。   
* [2.x.139]与get_dof_values()函数不同，这个函数只对单元格有效，而不是对线、四边形和六边形，因为插值目前只由有限元类对单元格提供。 
* [0.x.161]*
   通过将自由度的局部编号映射到全局编号并将局部值输入全局向量，将局部（基于单元）向量分配到全局向量。换句话说，这个函数实现了一个[散点操作](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing))。    这些元素被[2.x.140]添加到全局向量的现有元素中，而不是直接设置，因为这通常是人们想要的。如果你需要处理约束条件，你可能还想看一下[2.x.142]函数。 
* [0.x.162]*
   通过将自由度的本地编号映射到全局编号并将本地值输入全局向量，将迭代器格式的本地（基于单元）向量分配给全局向量。  换句话说，这个函数实现了一个[散点操作](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing))。    这些元素被[2.x.143]添加到全局向量中的现有元素上，而不是直接设置，因为这通常是人们想要的。如果你需要处理约束条件，你可能还想看一下[2.x.145]函数。 
* [0.x.163]*
   通过将自由度的本地编号映射到全局编号并将本地值输入全局向量，将迭代器格式的本地（基于单元）向量分布到全局向量中。  换句话说，这个函数实现了一个[散点操作](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing))。    这些元素被[2.x.146]添加到[2.x.147]全局向量中的元素，而不是仅仅设置，因为这通常是人们想要的。此外，传递给这个函数的AffineConstraints对象确保了在这个过程中也消除了约束。 
* [0.x.164]*
   这个函数与<tt>distribute_local_to_global(Vector,Vector)</tt>函数的作用基本相同，但是对矩阵而不是向量进行操作。如果矩阵类型是稀疏矩阵，那么它就应该在需要的地方有非零的入口槽。 
* [0.x.165]*
   这个函数做了两个<tt>distribute_local_to_global</tt>函数与向量和矩阵参数的作用，但都是一次性的。 
* [0.x.166]*
    [2.x.148]   
* [0.x.167]*
    [2.x.149] 访问此对象的DoF指数  
* [0.x.168]*
    [2.x.150]   
* [0.x.169]*
   获取此单元上的局部自由度的全局指数。    如果这个对象访问了一个水平单元（由第三个模板参数或#is_level_cell表示），那么返回get_mg_dof_indices()的结果，否则返回get_dof_indices()。    当调用begin_mg()时，你会得到一个level_cell_iterator，否则就是一个普通的level_cell_iterator。    这种用法的例子是在DoFRenumbering的实现中。 
* [0.x.170]*
   返回位于此对象上的自由度的[1.x.20]指数，其标准排序由有限元定义（即顶点0上的自由度，顶点1上的自由度，等等，行0上的自由度，行1上的自由度，等等，四边形0上的自由度，等等）该函数仅适用于[1.x.21]对象（见[2.x.151] "本词汇条"）。     [2.x.152] dof_indices 指数将被写入的向量。在传递给这个函数之前，它必须有合适的大小（即[2.x.153] ，或[2.x.154] ，取决于这个函数被调用的对象的种类）。    这个函数重新实现了基类中的同一个函数。与基类中的函数相比，我们在这里不需要[2.x.155]，因为单元格上总是有一个唯一的有限元索引。    这是一个要求单元格处于活动状态的函数。    也请看get_active_or_mg_dof_indices()。   
* [2.x.156] 在本教程的许多地方和库的其他地方，这个函数的参数按惯例被称为[2.x.157]。这个名字并不意味着表示自由度的[1.x.22]数量（总是在0和[2.x.158]之间），而是表示返回值是位于当前单元格上的那些自由度的[1.x.23]指数。 
* [0.x.171]*
   检索该单元上的自由度在与该单元的级别相关的级别向量中的全局指数。 
* [0.x.172]*
    [2.x.159]   
* [0.x.173]*
    [2.x.160] 访问与此对象相关的有限元  
* [0.x.174]*
    [2.x.161]   
* [0.x.175]*
   返回用于此迭代器所指向的单元格的有限元。对于没有hp-capabilities的DoFHandler对象，这当然总是同一个元素，与我们目前所在的单元无关，但是对于hp-DoFHandler对象，这可能会在不同的单元之间变化。   
* [2.x.162] 由于自由度只存在于具有hp-capabilities的DoFHandler对象的活动单元上（即目前没有实现多层次的此类对象），在非活动单元上查询有限元是没有意义的，因为它们没有任何自由度的有限元空间与它们相关联。因此，这个函数在非活动单元上调用时将产生一个异常。 
* [0.x.176]*
   返回用于该单元的有限元空间[2.x.163]内的索引。这个函数只有在与当前单元格相关的DoFHandler对象启用了hp-capabilities时才有用。   
* [2.x.164] 由于自由度只存在于具有hp-capabilities的DoFHandler对象的活动单元上（即目前没有实现多层次的此类对象），在非活动单元上查询有限元是没有意义的，因为它们没有与之相关的有限元空间，没有任何自由度。因此，当在非活动单元上调用该函数时将产生一个异常。   
* [2.x.165] 当使用平行网格时，无论是通过[2.x.166]还是[2.x.167]类，都只允许在本地拥有的或幽灵单元上调用此函数。没有关于人工单元的信息。  此外，[2.x.168]信息只在调用[2.x.169]和[2.x.170]期间从一个处理器上的本地拥有的细胞交换到其他可能是幽灵细胞的处理器。 请注意，如果你在调用这些函数之一后在一个细胞上调用set_active_fe_index()，那么这个信息将不会传播给其他可能将这个细胞作为幽灵细胞的处理器。更多信息请参见DoFHandler的文档。 
* [0.x.177]*
   设置用于此单元的FiniteElement的索引。这决定了要使用[2.x.171]中的哪个元素。这个函数只有在与当前单元相关的DoF处理程序对象启用了hp-功能时才有用。   
* [2.x.172] 由于自由度只存在于具有hp-能力的DoFHandler对象的活动单元上（即目前没有实现多层次的这种对象），在非活动单元上查询有限元是没有意义的，因为它们没有与之相关的有限元空间，没有任何自由度。因此，当在非活动单元上调用该函数时，将产生一个异常。   
* [2.x.173] 当使用平行网格时，无论是通过[2.x.174]还是[2.x.175]类，都只允许在本地拥有的或幽灵单元上调用该函数。没有关于人工单元的信息。  此外，[2.x.176]信息只在调用[2.x.177]和[2.x.178]期间，从一个处理器上的本地拥有的细胞交换到其他可能是幽灵细胞的处理器上。 请注意，如果你在调用这些函数之一后，在一个细胞上调用set_active_fe_index()，那么这个信息将不会传播给其他可能将这个细胞作为幽灵细胞的处理器。更多信息请参见DoFHandler的文档。 
* [0.x.178]*
    [2.x.179]   
* [0.x.179]*
   将此单元的DoF指数设置为给定值。如果给定的DoF处理程序类存在DoF缓存，该函数会绕过DoF缓存。 
* [0.x.180]*
   将此单元格的Level DoF指数设置为给定值。 
* [0.x.181]*
   更新缓存，我们在其中存储该单元的DoF指数。 
* [0.x.182]*
    [2.x.180]处理细化指标  
* [0.x.183]*
    [2.x.181]   
* [0.x.184]*
   返回下次三角剖分被细化和粗化时将分配给该单元的有限元。如果没有通过set_future_fe_index()函数为该单元指定未来的有限元，则活动的有限元将保持不变，在这种情况下，将返回活动的有限元。    对于没有启用hp-capabilities的DoFHandler，这当然总是同一个元素，与我们目前所在的单元无关，但是对于hp- DoFHandler对象，这可能会在不同的单元之间变化。   
* [2.x.182] 由于自由度只存在于具有hp-capabilities的DoFHandler对象的活动单元上（即目前没有实现多层次的此类对象），在非活动单元上查询有限元是没有意义的，因为它们没有与之相关的有限元空间，没有任何自由度。因此，这个函数在非活动单元上调用时将产生一个异常。 
* [0.x.185]*
   返回有限元的fe_index，该有限元将在下一次三角结构被细化和粗化时分配给该单元。如果没有通过set_future_fe_index()函数为该单元指定未来的有限元，则活动的单元将保持不变，在这种情况下，将返回活动有限元的fe_index。   
* [2.x.183] 由于自由度只存在于具有hp-capabilities的DoFHandler对象的活动单元上（即目前没有实现多层次的这种对象），在非活动单元上查询有限元是没有意义的，因为它们没有与之相关的有限元空间，没有任何自由度。因此，当在非活动单元上调用该函数时，将产生一个异常。   
* [2.x.184]当使用平行网格时，无论是通过[2.x.185]还是[2.x.186]类，只允许在本地拥有的单元上调用该函数。 
* [0.x.186]*
   设置有限元的fe_index，该有限元将在下一次三角结构被细化和粗化时被分配给该单元。之前分配的未来有限元将被覆盖。    参见future_fe_index()的注释，以了解对该功能的限制信息。 
* [0.x.187]*
   返回是否已经设置了未来有限元。    参见future_fe_index()的注释，以了解对该功能的限制信息。 
* [0.x.188]*
   撤销分配的未来有限元。因此，在下一次三角结构被细化和粗化时，活动的有限元将保持不变。    参见future_fe_index()的说明，以了解对该功能的限制。 
* [0.x.189]*
    [2.x.187]   
* [0.x.190]

