include/deal.II-translator/dofs/block_info_0.txt
[0.x.0]*


* 
* [2.x.0] 全局、多层次和局部计算。
* 一旦DoFHandler被初始化为FESystem，一个BlockInfo类型的数据对象（通过[2.x.1]访问）就被填充，它反映了自由度的块结构。
* BlockInfo由几个BlockIndices对象组成。成员global()反映了活动单元层面上的系统块结构，通常被称为全局系统。一旦[2.x.2]被调用，global()中的函数[2.x.3]将返回每个块的正确尺寸。在[2.x.4]之后，[2.x.5]将返回每个块的起始索引。
* 当使用带有级别的DoFHandler时，每个级别都会自动生成相同的结构。级别块可以通过level()访问。
* 最后，还有local() BlockIndices，它描述了单个单元上的块结构。例如，这被[2.x.6]所使用。本地索引不是自动填充的，因为它们改变了依赖BlockInfo的[2.x.7]类的行为。它们必须通过initialize_local()手工初始化。
* [1.x.0]
* 这个对象最常见的用法是初始化向量，如下面的代码。
* 

* 
* [1.x.1]
* 
* 在这个例子中，<tt>solution</tt>获得了在DoFHandler上表示一个有限元函数所需的块结构。同样地，<tt>mg_vector</tt>的所有层次都会有该层次所需的块结构。
* [2.x.8] 扩展函数local()和renumber()以允许hp-capablilites。
* 

* 
* [2.x.9] 

* 
* [0.x.1]*
  
* [2.x.10] DoFHandler。    默认情况下，这个函数将尝试初始化任何可能的东西。如果在DoFHandler参数中已经分配了活动的Dofs，它们的BlockIndices将被生成。对水平方向也是如此。    这个默认行为可以被两个参数覆盖，这两个参数可以关闭活动道夫或水平道夫。    这个函数也将清除local()指数。 
* [0.x.2]*
  
* [2.x.11]在单元格道夫和块单元格道夫之间。 
* [0.x.3]*
   访问全局系统的BlockIndices结构。 
* [0.x.4]*
   访问一个单元上的本地系统的BlockIndices。 
* [0.x.5]*
   访问多级层次结构中某一级的BlockIndices结构。 
* [0.x.6]*
   返回局部重新编号后的索引。    这个函数的输入是一个介于零和每个单元的道夫数之间的索引，按本地块的顺序编号，即首先是第一个系统块的所有索引，然后是第二个块的所有索引，依此类推。然后该函数以DoFAccessor的标准本地编号输出该索引。 
* [0.x.7]*
   基础元素的数量。 
* [0.x.8]*
   返回这个索引的基数元素。 
* [0.x.9]*
   将块结构的摘要写到流中。 
* [0.x.10]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.11]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据读入或写入流中，以便进行序列化。 
* [0.x.12]*
  
* [2.x.12]   
* [0.x.13]*
  
* [2.x.13]   
* [0.x.14]*
  
* [2.x.14]   
* [0.x.15]*
   与每个区块相关的基本元素。 
* [0.x.16]*
   一个向量，包含从单元上的标准自由度顺序到组件明智顺序的重新编号。由initialize()填充。 
* [0.x.17]

