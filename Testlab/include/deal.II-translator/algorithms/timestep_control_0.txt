include/deal.II-translator/algorithms/timestep_control_0.txt
[0.x.0]*
   时隙方案的控制类。它的主要任务是确定下一个时间步骤的大小和时间间隔中的相应点。  此外，它还控制将解决方案写入文件。    下一个时间步长的确定方法如下。   [2.x.0] [2.x.1] 根据策略，步长暂且加到当前时间上。   2.x.2] 如果得出的时间超过了区间的最终时间，则减少步长，以满足这个时间。   [2.x.3] 如果得出的时间低于最终时间，只是步长的一小部分，则增加步长，以满足这个时间。   [2.x.4] 产生的步长从当前时间开始使用。   [2.x.5] 变量[2.x.6]可以用来控制分步方案产生的输出量。   
* [2.x.7] 这个类的许多功能都可以在DiscreteTime中使用，具有更现代的接口和更好的编程保证。考虑使用DiscreteTime而不是TimestepControl。 
* [0.x.1]*
     设置默认值的构造函数    
* [0.x.2]*
     声明参数处理程序的控制参数。   
* [0.x.3]*
     从一个参数处理程序中读取控制参数。        这个函数也会调用restart()，根据刚刚读取的参数，将这个类的所有其他内部参数重置为相应的值。   
* [0.x.4]*
     返回时间间隔的左端。   
* [0.x.5]*
     返回时间间隔的右端。控制机制确保最后的时间步骤在这一点上结束。   
* [0.x.6]*
     返回控制时间步骤的公差值。   
* [0.x.7]*
     返回当前时间步长的大小。   
* [0.x.8]*
     返回当前的时间。   
* [0.x.9]*
     计算下一步的大小，如果它与当前步长不同，则返回true。用新的步长推进当前时间。   
* [0.x.10]*
     设置起始值。   
* [0.x.11]*
     设置最终时间值。   
* [0.x.12]*
     设置公差    
* [0.x.13]*
     设置第一个步骤的大小。这可能被时间步进策略所覆盖。         [2.x.8]步长 第一步的大小，这可能被时间步长策略覆盖。   
* [0.x.14]*
     设置最大步长的大小。   
* [0.x.15]*
     设置now()等于start()。将step()和print()初始化为其初始值。   
* [0.x.16]*
     如果这个时间步长应该被写入磁盘，则返回true。   
* [0.x.17]*
     时间间隔的开始。   
* [0.x.18]*
    时间间隔的结束。   
* [0.x.19]*
     控制时间步骤的公差值。   
* [0.x.20]*
     第一个步骤的大小。   
* [0.x.21]*
     最大的步长。   
* [0.x.22]*
     最小步长。   
* [0.x.23]*
     当前时间步长的大小。如果我们的目标是[2.x.10]，这可能与[2.x.9]不同。    
* [0.x.24]*
     由策略决定的当前时间步长的大小。如果我们的目标是[2.x.12]，这可能与[2.x.11]不同。    
* [0.x.25]*
     的当前时间。   
* [0.x.26]*
     决定了生成的输出之间的大致时间间隔。    如果是负数，输出将在所有时间步骤中产生。   
* [0.x.27]*
     如果当前时间超过此值，则是生成输出的时间。   
* [0.x.28]

