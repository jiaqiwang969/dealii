include/deal.II-translator/algorithms/general_data_storage_0.txt
[0.x.0]*
 这个类方便了任何一般数据的存储。它提供了一个机制来存储任何数量的数据，任何类型的数据，然后通过一个标识符字符串来访问。
* 当使用这个类时，请引用
* 

* 
* [1.x.0]
* 

* 
* [0.x.1]*
   默认构造函数。 
* [0.x.2]*
   复制构造函数。 
* [0.x.3]*
   移动构造函数。 
* [0.x.4]*
   这个类实例所存储的对象的数量。 
* [0.x.5]*
   将[2.x.0]的内容与此对象合并。 
* [0.x.6]*
   打印内部缓存的内容到[2.x.1] [2.x.2]映射中的每个键和值对都打印在单独的一行，[2.x.3]键列在前面，后面是相关映射类型的拆分<tt>type_id</tt>。 
* [0.x.7]*
   清除存储在这个类实例中的所有数据。    当你调用这个函数时，它会销毁所有你要求以副本形式存储的对象，并且忘记你要求以引用形式存储的数据的引用。因此，你现在可以在任何时候自由地销毁你所存储的引用的对象。
* 
* - 在当前的`GeneralDataStorage`对象被销毁之前或之后。    为了澄清这一点，请考虑下面这个小例子。   
* [1.x.1]
* 在上面的代码中，[2.x.4]对象的范围比<tt>some_number</tt>长。当我们从[2.x.5]中获取<tt>"value"</tt>时，对[2.x.6]的引用已不再有效。    同样地，对于复制到GeneralDataStorage对象中的数据，我们应该考虑它在哪个范围内保持有效。   
* [1.x.2]
* 与第一个例子类似，我们必须意识到这样一个事实：由[2.x.8]存储的任何[2.x.7]的副本只有在存储它的GeneralDataStorage实例活着时才有效。    此外，正如上一个例子所阐明的，当调用reset()函数时，或通过调用remove_object_with_name()删除时，被指向的类实例（由GeneralDataStorage拥有）的副本就不再是活的。   
* [1.x.3]
*   
* [0.x.8]*
    [2.x.9] 数据存储和访问  
* [0.x.9]*
   在内部存储一个给定对象的副本。被复制的对象为这个类所拥有，并且可以通过get_object_with_name()方法通过引用访问。    这个函数确保没有[2.x.10]与给定的[2.x.11]已经被这个类实例所存储。 
* [0.x.10]*
   在内部存储一个给定对象的副本。被复制的对象为这个类所拥有，并且可以通过引用get_object_with_name()方法来访问。    这个函数不进行任何检查以确保具有给定[2.x.13]的[2.x.12]已经被这个类实例存储。如果[2.x.14]确实指向现有的数据，那么这将被覆盖。 
* [0.x.11]*
   为一个已经存在的对象添加一个引用。该对象不属于这个类，用户必须保证被引用的对象比这个类实例的寿命长。存储的引用可以通过get_object_with_name()方法访问。    这个函数确保没有任何具有给定[2.x.16]的[2.x.15]已经被这个类实例所存储。 
* [0.x.12]*
   为一个已经存在的对象添加一个引用。该对象不属于这个类，而且用户必须保证被引用的对象比这个类实例的寿命长。存储的引用可以通过get_object_with_name()方法访问。    这个函数不执行任何检查以确保具有给定[2.x.18]的[2.x.17]已经被这个类实例所存储。如果[2.x.19]确实指向现有的数据，那么这将被覆盖。 
* [0.x.13]*
   返回一个给定名称的对象的引用。如果该对象不存在，那么输入的[2.x.20]将被用来构造一个给定的[2.x.21]的对象，然后返回这个新对象的引用。    一个[2.x.22]类型的对象的副本，是由这个类实例拥有的，通过调用它的构造函数和给定的参数集来生成。对于这个函数，[2.x.23]作为<tt>lvalue</tt>引用被传递。 
* [0.x.14]*
   返回一个给定名称的对象的引用。如果该对象不存在，那么输入的[2.x.24]将被用来构造一个给定的[2.x.25]的对象，然后返回这个新对象的引用。    与上述单参数的情况相同。 
* [0.x.15]*
   返回一个对给定名称的对象的引用。如果该对象不存在，那么输入的[2.x.26]将被用来构造一个给定的[2.x.27]的对象，然后返回这个新对象的引用。    一个[2.x.28]类型的对象的副本，是由这个类实例所拥有的，通过调用它的构造函数和给定的参数集来生成。与之前的同名函数不同的是，对于这个函数，[2.x.29]是作为<tt>rvalue</tt>引用传递的。 
* [0.x.16]*
   返回一个给定名称的对象的引用。如果该对象不存在，那么输入的[2.x.30]将被用来构造一个给定的[2.x.31]的对象，然后返回这个新对象的引用。    与上述单参数的情况相同。 
* [0.x.17]*
   同上面的默认构造函数。 
* [0.x.18]*
   返回一个给定名称的对象的引用。    如果具有给定名称的对象没有存储在这个类中，或者具有给定名称的对象既不是精确指定的[2.x.32]也不是指向[2.x.33]的指针，这个函数会抛出一个异常。  
* [0.x.19]*
   返回一个给定名称的对象的常数引用。    如果具有给定名称的对象没有存储在这个类中，或者如果具有给定名称的对象既不是精确指定的[2.x.34]也不是指向[2.x.35]的指针，这个函数会抛出一个异常。  
* [0.x.20]*
   找出我们是否存储了一个具有给定名称的对象。 
* [0.x.21]*
   删除具有给定名称的对象。 
* [0.x.22]*
   在内部[2.x.36]地图中不存在一个具有此名称的条目。 
* [0.x.23]*
   在内部[2.x.37]地图中不存在具有此名称的条目。 
* [0.x.24]*
   请求的类型和存储的类型不同。 
* [0.x.25]*
   任意的用户数据，由一个字符串标识。 
* [0.x.26]

