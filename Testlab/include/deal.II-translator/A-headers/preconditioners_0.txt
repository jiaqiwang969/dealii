include/deal.II-translator/A-headers/preconditioners_0.txt
[0.x.0]*



* [2.x.0]
* [1.x.0]
* 先决条件是用来加速线性系统的迭代求解的。典型的前置条件是Jacobi、Gauss-Seidel或SSOR，但该库也支持更复杂的前置条件，如Vanka或不完全LU分解（ILU）。此外，稀疏直接求解器在可用的情况下也可以作为预处理器使用。
* 广义上讲，预处理器是一种运算器，它与矩阵相乘以改善条件。其想法是，经过预处理的系统[1.x.1]比原始系统[1.x.2]更容易解决。这到底意味着什么，取决于矩阵的结构，在此不能作一般性讨论。对于对称的正定矩阵[1.x.3]和[1.x.4]，这意味着[1.x.5]的光谱条件数（最大和最小特征值的商）比[1.x.6]的要小得多。
* 在最简单的例子中，Richardson迭代，在SolverRichardson中实现，预处理迭代看起来像[1.x.7]。 因此，预处理相当于对残差应用一个线性算子，因此，预处理器[1.x.8]的动作被实现为<tt>vmult()</tt>。deal.II中需要预处理器的模板用[2.x.1]"预处理器类型概念 "来表示。在实践中，我们通常可以将任何定义了[2.x.2]的矩阵类对象作为一个预处理程序。本模块中的所有预处理类都实现了这个接口。
* 当用于Krylov空间方法时，由该方法决定是用[1.x.9]替换[1.x.10]的乘法（例如SolverBicgstab），还是做更复杂的事情。例如，SolverCG使用[1.x.11]来定义内积，这就是为什么它需要一个对称的正定算子[1.x.12]的原因。
* [1.x.13]
* 许多预处理程序依赖于加法拆分[1.x.14]为两个矩阵。在这种情况下，上述Richardson方法的迭代步骤可以简化为[1.x.15]，从而完全避免了与[1.x.16]的乘法。我们把以这种方式将前一个迭代[1.x.17]映射到下一个迭代的算子称为放松算子。它们的通用接口由[2.x.3]"松弛类型概念 "给出。本模块中名字以<tt>Relaxation</tt>开头的类实现了这个接口，还有预处理器PreconditionJacobi、PreconditionSOR、PreconditionBlockJacobi、PreconditionBlockSOR和PreconditionBlockSSOR。
* [1.x.18]
* 在这一节中，我们讨论了预设条件器通常必须提供的接口，以便在deal.II库内工作。
* [1.x.19]
* 为了能够存储在容器中，所有的预处理程序都有一个没有参数的构造函数。由于这通常会产生一个无用的对象，所有的预处理程序都有一个函数


* [1.x.20]
*
* 这个函数接收要预处理的矩阵以及其他所需的参数，并设置预处理程序的内部结构。
* [1.x.21]
* 一些预处理程序，如SOR和Jacobi，在被用作预处理程序之前，早已作为迭代求解器使用。因此，它们同时满足[2.x.4] "MatrixType "和[2.x.5] "RelaxationType "概念。
*


* [2.x.6]


* [2.x.7]


* [0.x.1]

