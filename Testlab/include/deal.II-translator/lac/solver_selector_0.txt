include/deal.II-translator/lac/solver_selector_0.txt
[0.x.0]*
 通过改变一个参数来选择一个求解器。
* 通过调用这个[2.x.1]的[2.x.0]函数，它选择在这个类的构造函数中指定的那个[2.x.3]的[2.x.2]函数。
* [1.x.0] 这个类的最简单的使用方法是如下。

* 
* [1.x.1]
* 但[2.x.4]类的全部用处要到下面的例子介绍时才清楚，该例子假设用户使用[2.x.5]类，并且已经声明了一个 "解算器 "条目，例如，用

* 
* [1.x.2]
* 假设在用户的参数文件中，存在这样一行

* 
* [1.x.3]
* 那么上面的例子中的构造器调用可以写成

* 
* [1.x.4]
 
* 

* 如果在某个时候存在一个新的求解器 "xyz"，那么用户不需要改变他们的程序。只有在[2.x.6]的实现中，才需要增加对这个求解器的调用，每个拥有上述程序行的用户只需要在他们的参数文件中'set solver = xyz'就可以获得对这个新求解器的访问。

* 
* [0.x.1]*
   底层矢量类型的别名  
* [0.x.2]*
   构造函数，填入默认值  
* [0.x.3]*
   构造函数，选择解算器[2.x.7]和解算器控制对象[2.x.8]了。 
* [0.x.4]*
   破坏器  
* [0.x.5]*
   解算器程序。调用[2.x.10]的[2.x.9]函数，其[2.x.11]SolverName是在构造函数中指定的。 
* [0.x.6]*
   选择一个新的求解器。请注意，这个类中使用的所有求解器名称都是小写的。 
* [0.x.7]*
   设置一个新的SolverControl。这需要在解算前设置。 
* [0.x.8]*
   设置附加数据。更多信息见[2.x.12]类。 
* [0.x.9]*
   设置附加数据。更多信息见[2.x.13]类。 
* [0.x.10]*
   设置附加数据。更多信息见[2.x.14]类。 
* [0.x.11]*
   设置附加数据。更多信息见[2.x.15]类。 
* [0.x.12]*
   设置附加数据。更多信息见[2.x.16]类。 
* [0.x.13]*
   设置附加数据。更多信息见[2.x.17]类。 
* [0.x.14]*
   获取所有实现的求解器的名称。可能的选项列表包括。   [2.x.18] [2.x.19] "Richardson" [2.x.20] [2.x.21] "cg" [2.x.22] [2.x.23] "bicgstab" [2.x.24] [2.x.25] "gmres" [2.x.26] [2.x.27] "fgres" [2.x.28] [2.x.29] "minres" [2.x.30] [2.x.31]   
* [0.x.15]*
   异常情况。 
* [0.x.16]*
   存储每个[2.x.33]解算器类的构造函数中需要的[2.x.32]。这可以用[2.x.34]来改变。  
* [0.x.17]*
   存储解算器的名称。 
* [0.x.18]*
   存储额外的数据。 
* [0.x.19]*
   存储额外的数据。 
* [0.x.20]*
   存储额外的数据。 
* [0.x.21]*
   存储额外的数据。 
* [0.x.22]*
   存储额外的数据。 
* [0.x.23]*
   存储额外的数据。 
* [0.x.24]

