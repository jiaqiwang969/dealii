include/deal.II-translator/lac/sparse_mic_0.txt
[0.x.0]!  [2.x.0] 先决条件 [2.x.1] 。

 
* [0.x.1]*
 实现对称矩阵的修正不完全Cholesky（MIC(0)）预处理。该类符合SparseLUDecomposition中的状态和使用规范。
* 

* [1.x.0]
* 让一个对称的、正不定的、稀疏的矩阵[2.x.2]的形式为[2.x.3]，其中[2.x.4]是[2.x.5]的对角线部分，[2.x.6]是一个严格的下三角形矩阵。矩阵[2.x.7]的MIC(0)分解由[2.x.8]定义，其中[2.x.9]是一个由条件[2.x.10]定义的对角线矩阵。

* 
* [0.x.2]*
   申报容器大小的类型。 
* [0.x.3]*
   构造函数。什么都不做，所以你必须在事后有时调用[2.x.11]。 
* [0.x.4]*
   解构器。 
* [0.x.5]*
   删除所有成员变量。将类保留在调用构造函数后的直接状态。 
* [0.x.6]*
   使基类中的[2.x.12]类型也能被这个类访问。 
* [0.x.7]*
   对给定的矩阵进行不完全的LU因子化。    这个函数需要在这个类的对象被用作预调节器之前被调用。    关于可能的参数的更多细节，请参阅SparseLUDecomposition的类文件和[2.x.13][2.x.14]类的文件。    根据[2.x.15]，该函数创建一个新的SparsityPattern，或保持以前的稀疏度，或采用用户给定的稀疏度，以[2.x.16]然后，该函数执行MIC分解。    在这个函数被调用后，预处理程序就可以使用了。 
* [0.x.8]*
   应用不完全分解，即做一个前向-后向步骤 [2.x.17] 。    在调用此函数之前，先调用[2.x.18]。 
* [0.x.9]*
   应用不完全分解的转置，即做一个向前-向后的步骤 [2.x.19] 。    在调用此函数之前调用[2.x.20]。   
* [2.x.21] 这个函数还没有被实现  
* [0.x.10]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.11]*
    [2.x.22] 异常情况 [2.x.23]   
* [0.x.12]*
   异常情况  
* [0.x.13]*
   异常情况  
* [0.x.14]*
   异常情况  
* [0.x.15]*
   计算的对角线的值。 
* [0.x.16]*
   对角线的倒数：预先计算以加快vmult。 
* [0.x.17]*
   计算的 "内部和 "的值，即位于对角线右侧的元素的每行之和。 
* [0.x.18]*
   计算每行的 "内部和"。 
* [0.x.19]

