include/deal.II-translator/lac/arpack_solver_0.txt
[0.x.0]*
 使用ARPACK的接口。ARPACK是一个Fortran77的子程序集，旨在解决大规模的特征值问题。 这里我们为ARPACK的例程[2.x.0]提供接口。如果运算符被指定为对称的，我们就使用ARPACK的对称接口[2.x.1]代替。 该软件包被设计用来计算一般n乘n矩阵A的几个特征值和相应的特征向量。它最适用于大的稀疏矩阵A。
* 在这个类中，我们利用了应用于广义特征谱问题[2.x.2]的方法，用于[2.x.3]；其中[2.x.4]是一个系统矩阵，[2.x.5]是一个质量矩阵，而[2.x.6]分别是一组特征值和特征向量。
* ArpackSolver可以通过以下方式用于带有串行对象的应用代码中。

* 
* [1.x.0]
* 对于广义的特征值问题[2.x.7] ，其中变量[2.x.8]告诉ARPACK要解决的特征向量/特征值对的数量。这里，[2.x.9]是一个包含计算的特征值的向量，[2.x.10]是一个包含计算的特征向量的向量，[2.x.11]是对矩阵[2.x.12]的逆运算。围绕零点的移位和反转变换被应用。
* 通过AdditionalData，用户可以指定一些要设置的参数。
* 关于ARPACK例程[2.x.13], [2.x.14]如何工作以及如何适当设置参数的进一步信息，请看ARPACK手册。
* 

* 
* [2.x.15] 每当你使用AffineConstraints消除自由度时，你会产生虚假的特征值和特征向量。如果你确保消除的矩阵行的对角线都等于1，你会得到一个额外的特征值。但要注意deal.II中的一些函数将这些对角线设置为相当任意的（从特征值问题的角度来看）值。参见[2.x.16] " [2.x.17] " 的例子。

* 
* [0.x.1]*
   声明容器尺寸的类型。 
* [0.x.2]*
   一个枚举，列出在solve()函数中计算哪些特征值的可能选择。 
* [0.x.3]*
     代数上最大的特征值。   
* [0.x.4]*
     代数上最小的特征值。   
* [0.x.5]*
     具有最大量级的特征值。   
* [0.x.6]*
     具有最小量级的特征值。   
* [0.x.7]*
     具有最大实部的特征值。   
* [0.x.8]*
     具有最小实部的特征值。   
* [0.x.9]*
     具有最大虚部的特征值。   
* [0.x.10]*
     具有最小虚部的特征值。   
* [0.x.11]*
     从频谱的高端计算一半的特征值，另一半从低端计算。如果要求的特征向量的数量是奇数，那么额外的特征向量来自谱的高端。   
* [0.x.12]*
   标准化的数据结构，用于向求解器输送额外的数据。 
* [0.x.13]*
     构造函数。默认情况下，将Arnoldi向量的数量（如果问题是对称的，则为Lanczos向量）设置为15。对于非对称问题，设置求解器寻找最大的特征值）。)    
* [0.x.14]*
     Arnoldi/Lanczos向量的数量。这个数字应该小于问题的大小，但要大于2倍的特征值数量（如果设置了n_eigenvalues）加1。   
* [0.x.15]*
     指定感兴趣的特征值。   
* [0.x.16]*
     指定问题是否是对称的。   
* [0.x.17]*
   访问控制收敛的对象。 
* [0.x.18]*
   构造函数。 
* [0.x.19]*
   设置初始矢量，用于构建Krylov空间。 
* [0.x.20]*
   设置移位[2.x.18]，用于移位和反转的光谱变换。    如果这个函数没有被调用，则假定移位为零。 
* [0.x.21]*
   通过调用ARPACK的[2.x.20]或[2.x.21]函数来解决广义的特征直角问题[2.x.19]。    该函数返回一个长度为[1.x.1]的特征值向量和一个长度为[1.x.2]的特征向量（在对称情况下），以及长度为[1.x.3]的非对称情况下的向量。在对称情况下，所有的特征向量都是实数。在非对称情况下，复杂的特征值总是以复数共轭对的形式出现。因此，具有非零复数部分的特征值的特征向量是通过将实数和虚数部分放在连续的实值向量中来存储的。复数共轭特征值的特征向量不需要被存储，因为它只是存储的特征向量的复数共轭。因此，如果最后n个特征值有一个非零的虚部，Arpack总共需要n+1个实值向量来存储特征向量的实部和虚部。     [2.x.22] A 我们要计算特征值的算子。实际上，这个参数完全没有使用。     [2.x.23] B 基础空间的内积，通常是质量矩阵。对于受限问题，它可以是一个部分质量矩阵，例如，像斯托克斯问题的速度质量矩阵。只有它的函数[2.x.24]被使用。     [2.x.25] inverse 这是实际使用的可能移位的逆矩阵，而不是[2.x.26]被使用。     [2.x.27] eigenvalues 是一个复数的向量，其中的特征值被返回。     [2.x.28] 特征向量是一个[1.x.4]特征向量的向量，包含所有特征向量的实部和与复数共轭特征值对对应的特征向量的虚部。  因此，其长度在对称情况下应为[1.x.5]，在非对称情况下应为[1.x.6]。在非对称情况下，存储方案会导致例如以下模式。假设前两个特征值是实数，第三和第四是一对复数共轭。询问三个特征对的结果是[1.x.7]。请注意，如果我们在这个例子中要求四个特征对，我们会得到同样的模式，因为第四个特征向量只是第三个的复共轭。     [2.x.29] n_eigenvalues 这个参数的目的并不清楚，但将其设置为[2.x.30]或更大的规模是安全的。  让它保持默认的0，它将在内部被重置为[2.x.31]的大小。 
* [0.x.22]*
   对控制迭代求解器收敛的对象的引用。 
* [0.x.23]*
   存储这个特定求解器的标志的副本。 
* [0.x.24]*
   存储一个初始向量  
* [0.x.25]*
   移位的实数部分  
* [0.x.26]*
   移位的虚数部分  
* [0.x.27]*
   例外的情况。 
* [0.x.28]

