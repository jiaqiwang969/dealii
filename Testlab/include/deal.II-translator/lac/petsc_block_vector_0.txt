include/deal.II-translator/lac/petsc_block_vector_0.txt
[0.x.0]!  [2.x.0] PETScWrappers [2.x.1]!     
* [0.x.1]*
     基于PETScWrappers中实现的平行向量类的块向量的实现。虽然基类提供了大部分的接口，但这个类处理了向量的实际分配，并提供了底层向量类型的特定函数。        数据的分配模式是这样的：每个块都分布在MPI通信器中命名的所有MPI进程中。    也就是说，我们不只是分发整个向量，而是分发每个组件。因此，在构造函数和reinit()函数中，不仅要指定各个块的大小，还要指定这些块中每个元素在本地进程中的存储数量。       
* [2.x.2] [2.x.3] "块（线性代数）"    
* [0.x.2]*
       对基类进行类型化定义，以便更简单地访问它自己的别名。     
* [0.x.3]*
       类型化底层向量的类型。     
* [0.x.4]*
       从基类中导入别名。     
* [0.x.5]*
       默认构造函数。生成一个没有任何块的空向量。     
* [0.x.6]*
       构造函数。生成一个有[2.x.4]个块的向量，每个块都是跨越[2.x.5]的平行向量，有[2.x.6]个元素，其中[2.x.7]个元素被存储在当前进程中。     
* [0.x.7]*
       复制构造函数。将平行向量的所有属性设置为给定参数的属性，并复制这些元素。     
* [0.x.8]*
       构造函数。将块的数量设置为<tt>block_sizes.size()</tt>，并以<tt>block_sizes[i]</tt>零元素初始化每个块。      各个块分布在给定的通信器上，并且每个块都在当前进程上存储<tt>local_elements[i]</tt>元素。     
* [0.x.9]*
       用parallel_partitioning.size()块创建一个BlockVector，每个块用给定的IndexSet初始化。     
* [0.x.10]*
       与上述相同，但包括幽灵元素      
* [0.x.11]*
       销毁器。清除内存      
* [0.x.12]*
       复制操作符：用给定的标量值填充本地存储的向量的所有组件。     
* [0.x.13]*
       对相同类型的参数进行复制操作。     
* [0.x.14]*
       重新初始化BlockVector，使其包含大小为[2.x.9]block_size的[2.x.8]，每个都在本地存储[2.x.10]元素。[2.x.11]参数表示这些块中的每个块应与哪个MPI通道通信。            如果<tt>omit_zeroing_entries==false</tt>，该向量将被填充为零。     
* [0.x.15]*
       重新初始化BlockVector，使其包含<tt>block_sizes.size()</tt>块。每个块都被重新初始化为<tt>block_sizes[i]</tt>尺寸。它们中的每一个都在当前进程中存储<tt>locally_owned_sizes[i]</tt>元素。            如果块的数量与调用此函数前相同，所有的向量都保持不变，并为每个向量调用 reinit()。            如果<tt>omit_zeroing_entries==false</tt>，则向量被填充为零。            注意，你必须调用这个（或其他reinit()函数）函数，而不是调用单个块的reinit()函数，以允许块向量更新其缓存的向量大小。如果你调用其中一个块的reinit()，那么对这个对象的后续操作可能会产生不可预测的结果，因为它们可能被路由到错误的块。     
* [0.x.16]*
       将尺寸改为向量<tt>V</tt>的尺寸。这与其他reinit()函数的情况相同。            <tt>V</tt>的元素不会被复制，也就是说，这个函数与调用<tt>reinit (V.size(), omit_zeroing_entries)</tt>相同。            注意，你必须调用这个（或其他reinit()函数）函数，而不是调用单个块的reinit()函数，以允许块向量更新它的向量大小缓存。如果你在其中一个块上调用reinit()，那么对这个对象的后续操作可能会产生不可预测的结果，因为它们可能会被路由到错误的块上。     
* [0.x.17]*
       使用IndexSets重新初始化BlockVector。详细情况请参见具有相同参数的构造函数。     
* [0.x.18]*
       与上述相同，但包括幽灵条目。     
* [0.x.19]*
       将块的数量改为<tt>num_blocks</tt>。各个区块将被初始化为零大小，所以假定用户自己以适当的方式调整各个区块的大小，并在之后调用<tt>collect_sizes</tt>。     
* [0.x.20]*
       如果这个向量是一个重影向量（因此是只读的），则返回。     
* [0.x.21]*
       返回一个对与此向量一起使用的MPI通信器对象的引用。     
* [0.x.22]*
       交换这个向量和另一个向量<tt>v</tt>的内容。我们可以用一个临时变量和复制数据元素来完成这个操作，但是这个函数明显更有效率，因为它只交换两个向量的数据指针，因此不需要分配临时存储和移动数据。            限制：现在这个函数只在两个向量有相同数量的块的情况下工作。如果需要，也应该交换块的数量。            这个函数类似于所有C++标准容器的swap()函数。此外，还有一个全局函数swap(u,v)，它简单地调用<tt>u.swap(v)</tt>，同样与标准函数类比。     
* [0.x.23]*
       打印到一个流。     
* [0.x.24]*
       异常情况      
* [0.x.25]*
       异常情况      
* [0.x.26]*
     全局函数，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个向量的数据。         [2.x.12] [2.x.13].     
* [0.x.27]*
     linear_operator.h中内部使用的一个辅助类。对[2.x.14]的特殊化。    
* [0.x.28]*
 将[2.x.15]声明为分布式向量。

* 
* [0.x.29]

