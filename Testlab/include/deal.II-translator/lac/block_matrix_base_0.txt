include/deal.II-translator/lac/block_matrix_base_0.txt
[0.x.0]!  [2.x.0] Matrix1 [2.x.1]! 

* 
* [0.x.1]*
 实现块状矩阵中迭代器的名称空间。

* 
* [0.x.2]*
   块状矩阵访问器的基类，实现对矩阵的步进。 
* [0.x.3]*
     声明容器大小的类型。   
* [0.x.4]*
     Typedef我们指向的矩阵的值类型。   
* [0.x.5]*
     将数据字段初始化为默认值。   
* [0.x.6]*
     该对象所代表的元素的块行。   
* [0.x.7]*
     此对象所代表的元素的块列。   
* [0.x.8]*
     我们目前所指向的块行。   
* [0.x.9]*
     我们现在所指向的块列。   
* [0.x.10]*
   块矩阵中的访问器类。 
* [0.x.11]*
   非恒定矩阵的块状矩阵访问器。 
* [0.x.12]*
     声明容器大小的类型。   
* [0.x.13]*
     在这个访问器中使用的矩阵的类型。   
* [0.x.14]*
     Typedef我们指向的矩阵的值类型。   
* [0.x.15]*
     构造器。因为我们只使用访问器进行读取访问，所以一个常量矩阵指针就足够了。        将迭代器放在矩阵给定行的开头，如果[2.x.2]等于矩阵的总行数，则创建末端指针。   
* [0.x.16]*
     这个对象所代表的元素的行数。   
* [0.x.17]*
     这个对象所代表的元素的列号。   
* [0.x.18]*
     当前位置的条目值。   
* [0.x.19]*
     设置新值。   
* [0.x.20]*
     访问的矩阵。   
* [0.x.21]*
     底层矩阵类的迭代器。   
* [0.x.22]*
     向前移动一个元素。   
* [0.x.23]*
     将这个访问器与另一个访问器进行比较，以确定是否相等。   
* [0.x.24]*
   用于常数矩阵的块状矩阵访问器，实现对矩阵的步进。 
* [0.x.25]*
     声明容器大小的类型。   
* [0.x.26]*
     该访问器中使用的矩阵的类型。   
* [0.x.27]*
     Typedef我们指向的矩阵的值类型。   
* [0.x.28]*
     构造器。因为我们只使用访问器进行读取访问，所以一个常量矩阵指针就足够了。        将迭代器放在矩阵给定行的开头，如果[2.x.3]等于矩阵的总行数，则创建末端指针。   
* [0.x.29]*
     从非常量访问器初始化常量访问器。   
* [0.x.30]*
     这个对象所代表的元素的行数。   
* [0.x.31]*
     这个对象所代表的元素的列号。   
* [0.x.32]*
     当前位置的条目值。   
* [0.x.33]*
     访问的矩阵。   
* [0.x.34]*
     底层矩阵类的迭代器。   
* [0.x.35]*
     向前移动一个元素。   
* [0.x.36]*
     将这个访问器与另一个访问器进行比较，以确定是否相等。   
* [0.x.37]*
 封锁的矩阵类。这种类型的对象的行为几乎和通常的矩阵对象一样，大部分的功能都在两个类中实现。主要的区别是，这个对象所代表的矩阵是由一个矩阵数组（例如SparseMatrix<number>类型）组成的，对这个对象的元素的所有访问都被转发到对基础矩阵的访问。这个矩阵的各个块的实际类型是模板参数的类型，例如可以是通常的SparseMatrix或[2.x.4] 。
* 除了通常的矩阵访问和线性代数函数外，还有一些函数block()，允许访问矩阵的不同块。例如，当你想实现舒尔补码方法或块状预处理时，这可能会有帮助，因为每个块都属于你目前正在离散化的方程的一个特定部分。
* 请注意，块和行的数量是由使用的稀疏模式对象隐含决定的。
* 当一个微分方程系统的解属于不同类别的变量时，这种类型的对象经常被使用。例如，斯托克斯或纳维尔-斯托克斯方程的解有[2.x.5]个速度分量和一个压力分量。在这种情况下，将线性方程组视为2x2块的系统可能是有意义的，人们可以在这个2x2块结构的基础上构建预调节器或求解器。在这种情况下，这个类可以帮助你，因为它允许把矩阵看作是一个大矩阵，或者看作是一些单独的块。
* 

* [1.x.0]
* 由于这个类只是将其调用转发给子对象（如果需要的话，在调整了表示哪个子对象的索引后），这个类完全独立于子对象的实际类型。然而，设置块状矩阵和销毁块状矩阵的函数必须在派生类中实现。这些函数也必须填充这个基类所提供的数据成员，因为它们在这个类中只是被动地使用。
* 

* 大多数函数都需要一个向量或块向量参数。一般来说，只有当这个矩阵的各个块实现了各自在有关向量类型上操作的函数时，这些函数才能被成功编译。例如，如果你有一个在deal.II SparseMatrix对象上的块状稀疏矩阵，那么你很可能无法用[2.x.6]对象上的块状向量形成矩阵-向量乘法。如果你试图这样做，你可能会得到一系列的编译器错误。
* 

* 
* [2.x.7] 这个模板的实例化提供给<tt> [2.x.8] 和 [2.x.9] 其他可以在应用程序中生成（见手册中[2.x.10] 一节）。
* [2.x.11] [2.x.12] "块（线性代数）"

* 
* [0.x.38]*
   Typedef底层矩阵的类型。 
* [0.x.39]*
   矩阵条目的类型。这些类似于标准库容器中的别名。 
* [0.x.40]*
   默认构造函数。 
* [0.x.41]*
   解构器。 
* [0.x.42]*
   将作为参数的矩阵复制到当前对象中。    复制矩阵是一个昂贵的操作，我们不希望通过编译器生成的代码意外发生[2.x.13] 。（例如，如果不小心声明了一个当前类型为[1.x.1]而不是[1.x.2]的函数参数，就会发生这种情况）。复制矩阵的功能是在这个成员函数中实现的。因此，该类型对象的所有复制操作都需要一个明确的函数调用。    源矩阵可以是一个任意类型的矩阵，只要其数据类型可以转换为该矩阵的数据类型。    该函数返回一个对<tt>this</tt>的引用。 
* [0.x.43]*
   访问具有给定坐标的块。 
* [0.x.44]*
   访问具有给定坐标的区块。常量对象的版本。 
* [0.x.45]*
   返回共域（或范围）空间的维数。注意，矩阵的维度是[2.x.14] 。 
* [0.x.46]*
   返回域空间的维度。请注意，矩阵的维度是[2.x.15] .  
* [0.x.47]*
   返回一列中的块数。如果目前没有与此矩阵相关的稀疏模式，则返回0。 
* [0.x.48]*
   返回一个行中的块数。如果目前没有与该矩阵相关的稀疏模式，则返回0。 
* [0.x.49]*
   将元素<tt>(i,j)/tt>设置为<tt>值</tt>。如果该条目不存在或者<tt>value</tt>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 
* [0.x.50]*
   将FullMatrix中给出的所有元素设置到<tt>indices</tt>给出的稀疏矩阵位置。换句话说，这个函数将<tt>full_matrix</tt>中的元素写入调用的矩阵中，对矩阵的行和列都使用<tt>indices</tt>指定的本地到全球的索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。    可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要设置零值，还是要过滤掉零值（如果存在的话，不改变相应元素中的先前内容）。默认值是<tt>false</tt>，也就是说，即使是零值也要处理。 
* [0.x.51]*
   与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 
* [0.x.52]*
   将矩阵的指定行中的几个元素与<tt>col_indices</tt>给出的列索引设置为相应的值。    可选的参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要设置零值，还是要过滤掉零值（如果存在的话，不改变相应元素中的先前内容）。默认值是<tt>false</tt>，也就是说，即使是零值也要处理。 
* [0.x.53]*
   将几个元素设置为由<tt>values</tt>给出的值，在给定的行和col_indices给出的列中设置为稀疏矩阵。    可选的参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要插入零值还是要过滤掉它们。默认值是<tt>false</tt>，也就是说，即使是零值也要插入/替换。 
* [0.x.54]*
   向元素添加<tt>value</tt>（[1.x.3]）。 如果该条目不存在或者<tt>value</tt>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 
* [0.x.55]*
   将FullMatrix<double>中给出的所有元素添加到由<tt>indices</tt>给出的稀疏矩阵位置。换句话说，这个函数将<tt>full_matrix</tt>中的元素添加到调用矩阵的相应条目中，使用<tt>indices</tt>为矩阵的行和列指定的本地到全球索引。这个函数假定一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中通常的情况。    可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。 
* [0.x.56]*
   与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 
* [0.x.57]*
   将矩阵的指定行中的几个元素与<tt>col_indices</tt>给出的列索引设置为相应的值。    可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。 
* [0.x.58]*
   在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<tt>values</tt>给出的数值阵列。    可选的参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些数据，只添加非零值。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。 
* [0.x.59]*
   将<tt>matrix</tt>按<tt>factor</tt>的比例添加到这个矩阵中，也就是说，矩阵<tt>factor*matrix</tt>被添加到<tt>this</tt>。如果调用矩阵的稀疏性模式不包含输入矩阵的稀疏性模式中的所有元素，这个函数将抛出一个异常。    然而，根据MatrixType，可能会出现额外的限制。  一些稀疏矩阵格式要求<tt>matrix</tt>是基于与调用矩阵相同的稀疏模式的。 
* [0.x.60]*
   返回条目(i,j)的值。 这可能是一个昂贵的操作，你应该始终注意在哪里调用这个函数。 为了避免滥用，如果想要的元素在矩阵中不存在，这个函数会抛出一个异常。 
* [0.x.61]*
   这个函数主要像operator()()，它返回矩阵条目<tt>(i,j)</tt>的值。唯一的区别是，如果这个条目不存在于稀疏模式中，那么就不会引发异常，而是返回0。虽然这在某些情况下可能很方便，但请注意，由于没有使用矩阵的稀疏性，写出的算法与最优解相比很简单，很慢。 
* [0.x.62]*
   返回第[1.x.4]行中的主对角线元素。如果矩阵不是二次方的，以及矩阵的对角线块不是二次方的，这个函数会抛出一个错误。    这个函数比operator()()快得多，因为对于二次矩阵来说，对角线条目可能是每行中第一个被存储的，因此访问时不需要搜索正确的列号。 
* [0.x.63]*
   在矩阵的所有子块上调用compress()函数。      参见[2.x.16]"压缩分布式对象 "以获得更多信息。 
* [0.x.64]*
   将整个矩阵乘以一个固定系数。 
* [0.x.65]*
   将整个矩阵除以一个固定系数。 
* [0.x.66]*
   加法 矩阵-向量乘法。在[2.x.18]上添加[2.x.17]，[2.x.19]为该矩阵。 
* [0.x.67]*
   添加矩阵-向量乘法。将[1.x.5]加到[1.x.6]上，[1.x.7]是这个矩阵。这个函数与vmult_add()的作用相同，但需要转置的矩阵。 
* [0.x.68]*
   返回向量[1.x.8]相对于该矩阵诱导的规范，即[1.x.9]的规范。这很有用，例如在有限元背景下，一个函数的[1.x.10]规范等于相对于代表有限元函数节点值的向量矩阵的矩阵规范。请注意，尽管函数的名称可能暗示了一些不同的东西，但由于历史原因，返回的不是法线，而是它的平方，正如上面所定义的标量积。    很明显，对于这个操作，矩阵需要是平方的。 
* [0.x.69]*
   返回矩阵的frobenius norm，即矩阵中所有条目的平方和的平方根。 
* [0.x.70]*
   计算矩阵标量乘积 [2.x.20] 。 
* [0.x.71]*
   计算残差[1.x.11]。将残差写进<tt>dst</tt>。 
* [0.x.72]*
   打印矩阵到给定的数据流中，使用格式<tt>(line,col) value</tt>，即每行有一个矩阵的非零条目。可选的标志是根据底层稀疏矩阵的类型，以不同的风格输出稀疏模式。 
* [0.x.73]*
   迭代器从第一个条目开始。 
* [0.x.74]*
   最后的迭代器。 
* [0.x.75]*
   从<tt>r</tt>行的第一个条目开始的迭代器。 
* [0.x.76]*
   行<tt>r</tt>的最终迭代器。 
* [0.x.77]*
   从第一条开始的迭代器。 
* [0.x.78]*
   最后的迭代器。 
* [0.x.79]*
   从<tt>r</tt>行的第一个条目开始的迭代器。 
* [0.x.80]*
   行<tt>r</tt>的最终迭代器。 
* [0.x.81]*
   返回对行的底层BlockIndices数据的引用。 
* [0.x.82]*
   返回对列的基本BlockIndices数据的引用。 
* [0.x.83]*
   确定此对象的内存消耗（以字节为单位）的估计值。注意，如果是在基于MPI的程序中调用，则只返回当前处理器上保留的内存。 
* [0.x.84]*
    [2.x.21] 异常 [2.x.22].   
* [0.x.85]*
   异常情况  
* [0.x.86]*
   异常情况  
* [0.x.87]*
   释放所有内存并返回到与调用默认构造函数后相同的状态。它也忘记了它之前绑定的稀疏模式。    这个函数对所有的子矩阵进行清除，然后将这个对象重置为完全没有块。    这个函数是受保护的，因为它可能需要释放额外的结构。如果足够的话，一个派生类可以再次将其公开。 
* [0.x.88]*
   行和列的索引数组。 
* [0.x.89]*
   子矩阵的数组。 
* [0.x.90]*
   这个函数收集了子对象的大小，并将其存储在内部数组中，以便能够将矩阵的全局索引转为子对象的索引。在你改变了子对象的大小之后，你必须*每次都调用这个函数。    每当子对象的大小发生变化，[2.x.23]数组需要更新时，派生类应该调用这个函数。    注意，这个函数不是公开的，因为不是所有的派生类都需要导出其接口。例如，对于通常的deal.II SparseMatrix类，每当调用reinit()时，大小都是隐式确定的，而且单个块不能被调整大小。因此，对于该类，这个函数不必是公共的。另一方面，对于PETSc类来说，没有相关的稀疏模式对象来决定块的大小，对于这些类来说，这个函数必须是公开可用的。因此，这些类导出了这个函数。 
* [0.x.91]*
   矩阵-向量乘法：让[2.x.24]与[2.x.25]是这个矩阵。    由于在vmult/Tvmult函数的块和非块版本之间衍生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个独特的名称下，模板参数可以被编译器衍生。 
* [0.x.92]*
   矩阵-向量乘法。就像之前的函数一样，但只适用于矩阵只有一个块列的情况。    由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个独特的名称下，模板参数可以被编译器派生。 
* [0.x.93]*
   矩阵-向量乘法。就像之前的函数一样，但只适用于矩阵只有一个块行的情况。    由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个独特的名字下，模板参数可以被编译器派生。 
* [0.x.94]*
   矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块的情况。    由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，其模板参数可以由编译器派生出来的唯一名称。 
* [0.x.95]*
   矩阵-向量乘法：让[2.x.26]与[2.x.27]是这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。    由于vmult/Tvmult函数的块和非块版本之间的模板参数派生问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，其模板参数可以由编译器派生出来的唯一名称。 
* [0.x.96]*
   矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块行的情况。    由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个唯一的名称下，模板参数可以被编译器派生。 
* [0.x.97]*
   矩阵-向量乘法。就像前面的函数一样，但只适用于矩阵只有一个块列的情况。    由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个独特的名称下，模板参数可以被编译器派生。 
* [0.x.98]*
   矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块的情况。    由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，其模板参数可以由编译器派生的唯一名称。 
* [0.x.99]*
   一些矩阵类型，特别是PETSc，需要同步设置和添加操作。这必须对BlockMatrix中的所有矩阵进行操作。本例程通过通知所有块来准备添加元素。在添加元素之前，所有的内部例程都会调用它。 
* [0.x.100]*
   通知所有区块，让它们为设置元素做准备，见prepare_add_operation()。 
* [0.x.101]*
   一个包含set()和add()函数使用的一些字段的结构，用于对输入字段进行预排序。由于人们可以合理地期望从多个线程同时调用set()和add()，只要所触及的矩阵索引是不相干的，这些临时数据字段需要由一个mutex来保护；因此该结构包含这样一个mutex作为成员变量。 
* [0.x.102]*
     临时向量，用于计算在做集体添加或设置时写入各个块的元素。   
* [0.x.103]*
     临时向量，用于在每个稀疏矩阵上将局部数据写入全局数据时，每个块上的列索引。   
* [0.x.104]*
     用于存储本地值的临时向量（在将本地值写入全局时需要对它们进行重新排序）。   
* [0.x.105]*
     一个突变变量，用于保护对该结构的成员变量的访问。   
* [0.x.106]*
     拷贝操作符。需要这样做是因为这个类的默认拷贝操作符被删除了（因为[2.x.28]是不可拷贝的），因此包围类的默认拷贝操作符也被删除。        这里的实现只是没有做任何事情
* 
* - TemporaryData对象只是在开始使用时被调整大小的抓取对象，所以实际上没有必要复制任何东西。   
* [0.x.107]*
   一组可以被add()和set()函数使用的从头开始的数组，这些函数在使用前采取数据的指针来预排序索引。来自多个线程的访问通过作为该结构一部分的mutex变量进行同步。 
* [0.x.108]

