include/deal.II-translator/lac/precondition_0.txt
[0.x.0]!  [2.x.0] 先决条件 [2.x.1] 。

 
* [0.x.1]*
 没有预设条件。 如果你想使用一个没有预处理的线性求解器，这个类可以帮助你。LAC中的所有求解器都需要一个预处理。因此，你必须使用这里提供的身份来避免预处理。它可以按以下方式使用。
* 

* 
* [1.x.0]
* 
* 参见[2.x.2]教程程序中的一个例子和其他解释。
* 另外，也可以用IdentityMatrix类来预设条件，方法是这样的。

* 
* [0.x.2]*
   声明容器大小的类型。 
* [0.x.3]*
   这个函数的出现只是为了提供一个预处理程序的接口，以交给平滑器。 这没有什么作用。 
* [0.x.4]*
     构造函数。   
* [0.x.5]*
   构造函数，将域和范围的大小设置为它们的默认值。 
* [0.x.6]*
   矩阵参数被忽略，这里只是为了与更复杂的预处理程序兼容。 
* [0.x.7]*
   应用预处理程序。 
* [0.x.8]*
   应用转置预处理程序。由于这是一个身份，这个函数与vmult()相同。 
* [0.x.9]*
   应用预处理程序，在前一个值上添加。 
* [0.x.10]*
   应用转置的预处理程序，添加。由于这是一个身份，这个函数与vmult_add()相同。 
* [0.x.11]*
   这个函数的出现只是为了提供一个预处理程序的接口，以交给平滑器。 这个函数什么都不做。 
* [0.x.12]*
   返回共域（或范围）空间的维数。注意，矩阵的维度是[2.x.3] 。   
* [2.x.4] 只有在预处理程序被初始化的情况下才能调用这个函数。 
* [0.x.13]*
   返回域空间的维数。请注意，矩阵的维度是[2.x.5] 。   
* [2.x.6]只有在预处理程序被初始化的情况下才可以调用这个函数。 
* [0.x.14]*
   范围空间的维度。 
* [0.x.15]*
   域空间的维度。 
* [0.x.16]*
 用Richardson方法进行预处理。这个预处理只是用AdditionalData对象提供的常数松弛因子对向量进行缩放。
* 在Krylov空间方法中，这个预处理器不应该有任何影响。使用SolverRichardson，两个松弛参数将只是相乘。不过，这个类在多网格平滑器对象（MGSmootherRelaxation）中还是很有用的。

* 
* [0.x.17]*
   声明容器尺寸的类型。 
* [0.x.18]*
   理查德森预处理程序的参数。 
* [0.x.19]*
     构造器。由于没有合理的默认参数，必须给出块的大小。   
* [0.x.20]*
     松弛参数。   
* [0.x.21]*
   构造函数，将松弛参数、域和范围大小设置为它们的默认值。 
* [0.x.22]*
   改变松弛参数。 
* [0.x.23]*
   以与其他预处理程序一致的方式改变松弛参数。矩阵参数被忽略，这里只是为了与更复杂的预处理程序兼容。 
* [0.x.24]*
   应用预处理程序。 
* [0.x.25]*
   应用转置预处理程序。由于这是一个身份，这个函数与vmult()相同。 
* [0.x.26]*
   应用预处理程序，在前一个值的基础上增加。 
* [0.x.27]*
   应用转置的预处理程序，添加。由于这是一个身份，这个函数与vmult_add()相同。 
* [0.x.28]*
   这个函数的出现只是为了提供一个预处理程序的接口，以交给平滑器。 这个函数什么都不做。 
* [0.x.29]*
   返回共域（或范围）空间的维数。注意，矩阵的维度是[2.x.7] 。   
* [2.x.8] 只有在预处理程序被初始化的情况下才能调用这个函数。 
* [0.x.30]*
   返回域空间的维数。请注意，矩阵的维度是[2.x.9] 。   
* [2.x.10]只有在预处理程序被初始化的情况下才可以调用这个函数。 
* [0.x.31]*
   松弛参数与向量相乘。 
* [0.x.32]*
   范围空间的维度。 
* [0.x.33]*
   域空间的维度。 
* [0.x.34]*
 使用矩阵构建函数的预处理程序。 该类形成了适合于LAC求解器类的预处理方法。由于许多预处理方法是基于矩阵条目的，因此这些方法必须作为底层矩阵实现的成员函数来实现。现在这个类的目的是允许从LAC求解器类中轻松访问这些成员函数。
* 似乎所有内置的预处理程序都有一个松弛参数，所以请为这些程序使用PreconditionRelaxation。
* 你通常不会想要创建这种类型的命名对象，尽管有可能。最常见的用法是这样的。

* 
* [1.x.1]
* 这将创建一个未命名的对象，作为第四个参数传递给SolverGMRES类的求解器函数。它假设SparseMatrix类有一个函数<tt>precondition_Jacobi</tt>，以两个向量（源和目的）作为参数（实际上，没有这样的函数，现有的函数需要第三个参数，表示松弛参数；因此这个例子只是为了说明一般的想法）。
* 请注意，由于默认的模板参数，上面的例子可以写得更短，如下。

* 
* [1.x.2]
* 

* 
* [0.x.35]*
   矩阵的预处理函数的类型。 
* [0.x.36]*
   构造函数。 这个构造函数存储了一个对矩阵对象的引用，供以后使用，并选择一个预处理方法，这个方法必须是该矩阵的成员函数。 
* [0.x.37]*
   执行预处理。调用传递给该对象构造函数的函数，并在此给出两个参数。 
* [0.x.38]*
   指向使用中的矩阵的指针。 
* [0.x.39]*
   指向预处理函数的指针。 
* [0.x.40]*
 其他预处理程序的基类。这里，只实现了一些常见的Jacobi、SOR和SSOR预处理函数。对于预处理，请参考派生类。

* 
* [0.x.41]*
   声明容器大小的类型。 
* [0.x.42]*
   用于参数的类。 
* [0.x.43]*
     构造函数。   
* [0.x.44]*
     放松参数。   
* [0.x.45]*
   初始化矩阵和松弛参数。矩阵只是存储在预处理程序对象中。松弛参数应大于零，并小于2，因为数值上的原因。它的默认值为1。 
* [0.x.46]*
   释放矩阵并重置其指针。 
* [0.x.47]*
   返回共域（或范围）空间的维数。注意，矩阵的维度是[2.x.11] 。 
* [0.x.48]*
   返回域空间的维度。注意，矩阵的维度是[2.x.12] .  
* [0.x.49]*
   指向矩阵对象的指针。 
* [0.x.50]*
   松弛参数。 
* [0.x.51]*
 使用矩阵内置函数的雅可比预处理。 使用的<tt>MatrixType</tt>类需要有一个<tt>precondition_Jacobi(VectorType&, const VectorType&, double</tt>)函数。这个类满足了[2.x.13]的 "松弛概念"。
* 

* 
* [1.x.3]
 

* 
* [0.x.52]*
   基类AdditionalData的一个别名。 
* [0.x.53]*
   应用预处理程序。 
* [0.x.54]*
   应用转置的预处理程序。由于这是一个对称的预处理程序，这个函数与vmult()相同。 
* [0.x.55]*
   执行预处理的Richardson迭代的一个步骤。 
* [0.x.56]*
   执行预设条件的Richardson迭代的一个步骤。 
* [0.x.57]*
 使用矩阵内置函数进行SOR预处理。
* 假设矩阵[1.x.4]被分割成对角线[1.x.5]以及严格的下三角和上三角[1.x.6]和[1.x.7]，那么具有松弛参数[1.x.8]的SOR预处理器是[1.x.9] 正是这个算子[1.x.10]，由vmult（）通过正置换实现。类似地，Tvmult()实现了[1.x.11]的操作。
* SOR迭代本身可以直接写成[1.x.12] 使用右手边的[1.x.13]和前一个迭代[1.x.14]，这是由step()实现的操作。
* 使用的MatrixType类需要有<tt>precondition_SOR(VectorType&, const VectorType&, double)</tt>和<tt>precondition_TSOR(VectorType&, const VectorType&, double)</tt>函数。这个类满足了[2.x.14]的 "放松概念"。
* 

* 
* [1.x.15]
 

* 
* [0.x.58]*
   基类AdditionalData的一个别名。 
* [0.x.59]*
   应用预处理程序。 
* [0.x.60]*
   应用转置的预处理程序。 
* [0.x.61]*
   执行预处理的Richardson迭代的一个步骤。 
* [0.x.62]*
   执行一个转置的预处理Richardson迭代步骤。 
* [0.x.63]*
 使用矩阵内置函数的SSOR预处理。 使用的<tt>MatrixType</tt>类需要有一个函数<tt>precondition_SSOR(VectorType&, const VectorType&, double)</tt>。这个类满足了[2.x.15]的 "放松概念"。
* 

* 
* [1.x.16]
 

* 
* [0.x.64]*
   基类AdditionalData的一个别名。 
* [0.x.65]*
   声明容器大小的类型。 
* [0.x.66]*
   对基类的一个别名。 
* [0.x.67]*
   初始化矩阵和放松参数。矩阵只是存储在预处理器对象中。松弛参数应该大于零，并小于2，因为数值上的原因。它的默认值为1。 
* [0.x.68]*
   应用预处理程序。 
* [0.x.69]*
   应用转置预处理程序。由于这是一个对称的预处理程序，这个函数与vmult()相同。 
* [0.x.70]*
   执行预处理的Richardson迭代的一个步骤  
* [0.x.71]*
   执行预设条件的Richardson迭代的一个步骤。 
* [0.x.72]*
   一个数组，为每个矩阵行存储对角线后第一个位置的位置。 
* [0.x.73]*
 使用矩阵内置函数的修正SOR预处理程序。 使用的<tt>MatrixType</tt>类需要有<tt>PSOR(VectorType&, const VectorType&, double)</tt>和<tt>TPSOR(VectorType&, const VectorType&, double)</tt>函数。
* 

* 
* [1.x.17]
 

 
* [0.x.74]*
   声明容器尺寸的类型。 
* [0.x.75]*
   PreconditionPSOR的参数。 
* [0.x.76]*
     构造函数。关于参数的描述，见下文。        包容向量是作为一个参考来存储的。因此，必须保证向量的寿命超过预处理程序的寿命。        松弛参数应该大于零，并且由于数值原因小于2。它的默认值是1。   
* [0.x.77]*
     包容向量的存储。   
* [0.x.78]*
     储存反互换向量。   
* [0.x.79]*
     放松参数    
* [0.x.80]*
   初始化矩阵和松弛参数。矩阵只是存储在前置条件器对象中。    扰动向量以指针形式存储。因此，必须保证该向量的寿命超过预调节器的寿命。    松弛参数应该大于零，并且由于数值原因小于2。它的默认值是1。 
* [0.x.81]*
   初始化矩阵和松弛参数。矩阵只是存储在preconditioner对象中。    关于可能的参数的更多细节，请参阅类的文档和[2.x.16]类的文档。    这个函数被调用后，预处理程序就可以使用了（使用派生类的[2.x.17]函数）。 
* [0.x.82]*
   应用预处理程序。 
* [0.x.83]*
   应用转置预处理程序。 
* [0.x.84]*
   储存互换向量。 
* [0.x.85]*
   储存反置换向量。 
* [0.x.86]*
 用Chebyshev多项式对对称正定矩阵进行预处理。这个预处理是基于[2.x.18]类型的内部预处理的迭代，其系数被调整为最佳覆盖最大特征值[2.x.19]到由可选参数[2.x.21]指定的特定较低特征值[2.x.20]之间的特征值范围。该算法是基于以下三期递归。[1.x.18] 其中参数[2.x.22]被设置为[2.x.23]的最大特征值[2.x.24]并通过[2.x.25]更新。切比雪夫多项式的构造是为了强烈阻尼[2.x.26]和[2.x.27]之间的特征值范围，例如，在[2.x.28]中可以看到。
* 预处理程序的典型用例是通过DiagonalMatrix指定的雅可比预处理程序，这也是预处理程序的默认值。请注意，如果程度变量被设置为1，切比雪夫迭代就对应于一个雅可比预处理器（或基础预处理器类型），其松弛参数根据指定的平滑范围。
* 除了默认选择的点式雅可比预处理外，该类还允许更高级的预处理类型，例如DG方法中的迭代块-雅可比预处理。
* 除了内部预处理对象，这种迭代不需要访问矩阵条目，这使得它成为无矩阵计算的理想成分。在这种情况下，这个类可以被用作多网格平滑器，它实际上是%并行的（假设矩阵-向量乘积是%并行的，内部预处理器是%并行的）。在[2.x.29]和[2.x.30]的教程程序中演示了它的使用。
* [1.x.19]
* 切比雪夫方法依赖于对矩阵特征值的估计，该估计在第一次调用vmult()时被计算出来。该算法调用共轭梯度求解器（即Lanczos迭代），因此要求（预处理）矩阵系统的对称性和正确定性。特征值算法可以通过[2.x.31]控制，指定应该进行多少次迭代。迭代从一个初始向量开始，这个初始向量取决于向量类型。对于具有快速元素访问的[2.x.32]或[2.x.33]类，它是一个条目为`(-5.5,
* 
* - .5,
* 
* - .5,
* 

* 
* 
* - .5, ..., 3.5, 4.5, 5.5)`，有适当的尾声，并进行调整，使其平均值始终为零，这对拉普拉斯的效果很好。这种设置在并行中是稳定的，因为对于不同数量的处理器，但未知数的排序相同，除了舍入误差外，将计算相同的初始向量，从而计算特征值分布。对于其他的矢量类型，初始矢量包含所有的1，按矢量的长度缩放，除了最开始的条目是0，再次触发高频内容。
* 特征值的计算发生在第一次调用vmult()、Tvmult()、step()或Tstep()函数之一时，或者直接调用improve_eigenvalues()时。在后一种情况下，有必要提供一个临时向量，其布局与应用预处理程序时使用的源向量和目的向量相同。
* 最小和最大特征值的估计值取自SolverCG（即使求解器没有在要求的迭代次数中收敛）。最后，最大特征值被乘以1.2的安全系数。
* 由于特征值估计的成本，如果反复应用，例如在几何多网格求解器的平滑器中，该类最适合，而该平滑器又可用于解决几个线性系统。
* [1.x.20]
* 在某些情况下，这一类的自动特征值计算可能会导致质量不好，或者在与不同的自由度枚举并行使用时可能不稳定，使计算强烈依赖于并行配置。可以通过设置[2.x.34]为零来绕过自动特征值计算，而提供变量[2.x.35]来代替。最小特征值是通过`max_eigenvalue/smoothing_range`隐式指定的。
* [1.x.21]
* 如果范围<tt>[max_eigenvalue/smoothing_range, max_eigenvalue]</tt>包含预处理矩阵系统的所有特征值，并且程度（即迭代次数）足够高，这个类也可以作为一个直接求解器使用。关于Chebyshev迭代的误差估计，可用于确定迭代次数，见Varga（2009）。
* 为了使用切比雪夫作为求解器，将程度设置为[2.x.36]以强制自动计算达到给定目标公差所需的迭代次数。在这种情况下，目标公差从变量[2.x.37]中读取（它需要是一个小于1的数字，以强制进行任何迭代，显然）。
* 关于该算法的细节，请参见第5.1节。

* 
* [1.x.22]
 
* [1.x.23]
* MatrixType类必须从Subscriptor派生出来，因为MatrixType的SmartPointer被保存在该类中。特别是，这意味着矩阵对象需要在PreconditionChebyshev的生命周期内持续存在。先决条件被保存在一个shared_ptr中，被复制到类的AdditionalData成员变量中，所以用于初始化的变量在调用initialize()后可以安全地被丢弃。矩阵和预处理程序都需要为矩阵-向量乘积提供[2.x.38]函数，为访问（方形）矩阵的行数提供[2.x.39]函数。此外，矩阵必须提供<tt>el(i,i)</tt>方法，以便在预处理程序类型为DiagonalMatrix时访问矩阵对角线。尽管强烈建议在一个单独的预处理对象中传递反向对角线条目，以实现Jacobi方法（这是用MPI进行%并行计算时操作该类的唯一可能方式，因为没有关于本地存储的条目范围的知识，只需要从矩阵中获取），但有一个向后兼容的函数，可以在串行计算的情况下提取对角线。

* 
* [0.x.87]*
   申报容器大小的类型。 
* [0.x.88]*
   标准化的数据结构，用于向预处理程序输送附加参数。 
* [0.x.89]*
     构造器。   
* [0.x.90]*
      复制赋值运算符。   
* [0.x.91]*
     这决定了切比雪夫多项式的程度。多项式的度数给出了应用vmult()操作所要进行的矩阵-向量乘积的数量。度数1对应的是阻尼雅可比方法。        如果度数被设置为[2.x.40]，算法将根据主类讨论中提到的通常的切比雪夫误差公式自动确定必要的迭代次数。   
* [0.x.92]*
     这设置了矩阵中最大的特征值和最小的特征值之间的处理范围。如果该参数被设置为一个小于1的数字，最大和最小的特征值的估计值将在内部计算。对于一个大于1的平滑范围，切比雪夫多项式将作用于区间[2.x.41]，其中[2.x.42]是对矩阵最大特征值的估计。选择<tt>smoothing_range</tt>在5和20之间是有用的，以防预处理程序被用作多网格的平滑器。   
* [0.x.93]*
     为寻找最大特征值而进行的最大CG迭代次数。如果设置为零，则不进行计算。相反，用户必须通过变量[2.x.43]提供一个最大特征值。    
* [0.x.94]*
     为寻找最大特征值而进行的CG迭代的容忍度。   
* [0.x.95]*
     用于工作的最大特征值。只有在[2.x.44]eig_cg_n_iterations被设置为0时才有效，否则该参数被忽略。   
* [0.x.96]*
     将用于给定的运算器的约束条件。这个变量用于在创建初始猜测时将正确的条目清零。   
* [0.x.97]*
     存储切比雪夫所包涵的预处理对象。   
* [0.x.98]*
   构造函数。 
* [0.x.99]*
   初始化函数。接受用于形成预处理程序的矩阵，如果有额外的标志，则接受额外的标志。这个函数只有在输入矩阵有一个操作符<tt>el(i,i)</tt>用于访问对角线上的所有元素时才能工作。或者，可以在AdditionalData字段的帮助下提供对角线。    这个函数在给定的迭代次数为正数的情况下，使用修改过的CG迭代法计算矩阵的特征值范围，并以其对角线为权重进行估算。 
* [0.x.100]*
   计算预处理程序对<tt>src</tt>的作用，将结果存储在<tt>dst</tt>。 
* [0.x.101]*
   计算转置的预处理程序对<tt>src</tt>的作用，将结果存入<tt>dst</tt>。 
* [0.x.102]*
   执行预处理Richardson迭代的一个步骤。 
* [0.x.103]*
   执行预设条件的Richardson迭代的一个步骤。 
* [0.x.104]*
   重置预处理程序。 
* [0.x.105]*
   返回码域（或范围）空间的维数。注意，矩阵的维度为[2.x.45] 。 
* [0.x.106]*
   返回域空间的维度。注意该矩阵的维度为[2.x.46] .  
* [0.x.107]*
   一个包含由PreconditionChebychev类执行的特征值估计信息的结构。 
* [0.x.108]*
     最小特征值的估计。   
* [0.x.109]*
     对最大特征值的估计。   
* [0.x.110]*
     执行的CG迭代次数或0。   
* [0.x.111]*
     切比雪夫多项式的度数（使用[2.x.47]设置或按该处所述估计）。   
* [0.x.112]*
     用无效值初始化的构造函数。   
* [0.x.113]*
   计算预处理程序所需的特征值估计。    如果用户没有调用该函数，则在第一次使用预处理程序时自动调用。向量[2.x.48]的布局用于创建内部临时向量，其内容并不重要。    基于特征值的计算，初始化因子theta和delta。如果用户在AdditionalData中为最大的特征值设置了值，则不进行计算，而使用用户给出的信息。 
* [0.x.114]*
   一个指向底层矩阵的指针。 
* [0.x.115]*
   用于<tt>vmult</tt>操作的内部向量。 
* [0.x.116]*
   用于<tt>vmult</tt>操作的内部向量。 
* [0.x.117]*
   用于<tt>vmult</tt>操作的内部向量。 
* [0.x.118]*
   存储传递给初始化函数的额外数据，通过复制操作获得。 
* [0.x.119]*
   所考虑的最大和最小的特征值的平均值。 
* [0.x.120]*
   所考虑的最大和最小特征值之间的一半区间长度。 
* [0.x.121]*
   存储预处理程序是否已被设置，特征值是否已被计算。 
* [0.x.122]*
   一个mutex，以避免不同线程的多个vmult()调用覆盖了临时向量。 
* [0.x.123]

