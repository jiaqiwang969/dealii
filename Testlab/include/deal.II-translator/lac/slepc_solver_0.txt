include/deal.II-translator/lac/slepc_solver_0.txt
[0.x.0]*
 使用SLEPc求解器的求解器类的基础命名空间，这些求解器是根据传递给特征值问题求解器上下文的标志来选择的。派生类设置正确的标志来设置正确的求解器。
* SLEPc求解器旨在用于解决广义的特征谱问题[2.x.0]，用于[2.x.1]；其中[2.x.2]是一个系统矩阵，[2.x.3]是一个质量矩阵，[2.x.4]分别为一组特征值和特征向量。重点是适合相关矩阵是稀疏的问题的方法和技术。SLEPc库提供的大多数方法都是投影方法或其他具有类似属性的方法；并提供了包装器来连接处理这两个问题集的SLEPc求解器。
* SLEPcWrappers可以通过以下方式在应用程序代码中实现。

* 
* [1.x.0]
* 用于广义特征值问题 [2.x.5] ，其中变量 [2.x.6] 告诉SLEPc要解决的特征向量/特征值对的数量。额外的选项和求解器参数可以在调用 [2.x.7] 之前传递给SLEPc求解器。例如，如果一般特征谱问题的矩阵不是隐性的，而且只想要低级特征值，那么在调用 [2.x.8] 之前可以实现以下代码。

* 
* [1.x.1]
* 这些选项也可以在命令行中设置。
* 也可参见[2.x.9]中的实战案例。
* 对于谱系转换与Krylov类型求解器或Davidson类型求解器结合使用的情况，可以额外指定使用哪种线性求解器和预处理器。这可以通过以下方式实现

* 
* [1.x.2]
* 
* 为了支持这种使用情况，与PETSc包装器不同，该命名空间中的类的编写方式是在构造函数中初始化基础SLEPc对象。这样做也避免了对不同设置（如目标特征值或问题类型）的缓存；相反，这些设置在调用包装器类的相应函数时直接应用。
* 上述方法的另一种实现方式是在应用程序代码中直接使用API的内部功能。这样一来，调用序列需要调用SolverBase的几个函数，而不是只有一个。这种自由是为了使用SLEPcWrappers，它需要对特征值问题求解器上下文有更多的处理。也请看API，例如。

* 
* [1.x.3]
* 以此为例说明如何做到这一点。
* 关于处理[2.x.10]"SLEPcWrappers "的进一步信息和解释，也请参见[2.x.11]"PETScWrappers"，它们依赖于此。
* 

* 
* [2.x.12] 

 
* [0.x.1]*
   使用SLEPc求解器的求解器类的基类。由于SLEPc中的求解器是根据传递给通用求解器对象的标志来选择的，所以基本上所有实际的求解器调用都发生在这个类中，而派生类只是设置正确的标志来选择一个或另一个求解器，或者为单个求解器设置某些参数。    关于如何使用这个类及其派生类的例子，包括如何为要计算特征值的矩阵提供预处理程序，请参见SolverBase类的文档，以及SLEPcWrappers命名空间的文档中的广泛讨论。 
* [0.x.2]*
     构造函数。接受MPI通信器，在该通信器上发生并行计算。   
* [0.x.3]*
     解构器。   
* [0.x.4]*
     解决特征系统的复合方法 [2.x.13] 。送入的特征向量必须至少有一个元素，我们可以在调整大小时作为模板使用，因为我们不知道使用的具体向量类的参数（即MPI向量的local_dofs）。然而，在复制特征向量时，至少要使用两倍于<tt>特征向量</tt>的内存大小（而且可能更多）。为了避免这样做，这里执行的相当标准的调用序列被使用。设置用于求解的矩阵；实际求解系统；收集求解结果。       
* [2.x.14] 注意收敛的特征向量的数量可能大于请求的特征向量的数量；这是由于特征问题求解器上下文的舍弃错误（成功）。如果发现这种情况，我们就不去管比请求的更多的特征对，而是通过忽略任何额外的东西来处理可能超过指定的数量。    默认情况下，将计算一个特征向量/特征值对。   
* [0.x.5]*
     同上，但这里是解决系统的复合方法 [2.x.15] ，用于实数矩阵、向量和值 [2.x.16] 。   
* [0.x.6]*
     同上，但这里是解决系统[2.x.17]与实数矩阵[2.x.18]和虚数特征对[2.x.19]的复合方法。   
* [0.x.7]*
     设置求解器的初始向量空间。        默认情况下，SLEPc随机地初始化起始向量或初始子空间。   
* [0.x.8]*
     设置要使用的谱系变换。   
* [0.x.9]*
     设置要计算的频谱中的目标特征值。默认情况下，不设置目标。   
* [0.x.10]*
     指明要计算的频谱的哪一部分。默认情况下，计算的是最大量级的特征值。       
* [2.x.20]关于其他允许的值，见SLEPc文档。   
* [0.x.11]*
     指定特征谱问题的类型。这可以用来利用构成标准/广义同位素问题的矩阵的已知对称性。 默认情况下，假定是一个非赫米特问题。       
* [2.x.21]关于其他允许的值，见SLEPc文档。   
* [0.x.12]*
     利用SLEPc提供的信息，与deal.II自己的SolverControl对象进行核对，看是否已经达到收敛。   
* [0.x.13]*
     异常。标准异常。   
* [0.x.14]*
     异常。带有错误号码的SLEPc错误。   
* [0.x.15]*
     异常。在特征向量的数量上收敛失败。   
* [0.x.16]*
     访问控制收敛的对象。   
* [0.x.17]*
     对控制迭代求解器收敛的对象的引用。   
* [0.x.18]*
     将用于求解器的MPI通信器对象的副本。   
* [0.x.19]*
     解决[2.x.22]特征状态的线性系统。    参数[2.x.23]包含已经收敛的特征态的实际数量；这可以少于或多于n_eigenpairs，取决于使用的SLEPc eigensolver。   
* [0.x.20]*
     访问已解决的特征向量问题的解决方案的实部，对索引解决方案， [2.x.24] 。   
* [0.x.21]*
     访问已解决的特征向量问题的解的实部和虚部，对索引解，[2.x.25] 。   
* [0.x.22]*
     初始化线性系统的求解器 [2.x.26] . (注意：在调用solve ()之前需要这样做)    
* [0.x.23]*
     同上，但在这里初始化线性系统的求解器 [2.x.27] 。   
* [0.x.24]*
     特征值问题求解器的对象。   
* [0.x.25]*
     收敛的原因。   
* [0.x.26]*
     一个可以在SLEPc中作为回调使用的函数，以检查收敛情况。       
* [2.x.28]这个函数目前没有使用。   
* [0.x.27]*
   一个使用SLEPc Krylov-Schur求解器的求解器接口的实现。使用方法。所有光谱，所有问题类型，复杂。    关于如何使用这个类和它的兄弟类的例子，包括如何为要计算特征值的矩阵提供前置条件，请参见SolverBase类的文档，以及SLEPcWrappers命名空间的文档中的广泛讨论。   
* [2.x.29]   
* [0.x.28]*
     标准化的数据结构，如果需要的话，可以将额外的数据输送到求解器中。   
* [0.x.29]*
     SLEPc求解器将希望有一个MPI通信器上下文，在这个上下文中计算被并行化。默认情况下，这与PETScWrappers的行为相同，但你可以改变它。   
* [0.x.30]*
     为这个特定的求解器存储一份标志的副本。   
* [0.x.31]*
   一个使用SLEPc Arnoldi求解器的求解器接口的实现。  使用方法。所有频谱，所有问题类型，复杂。    关于如何使用这个类和它的兄弟类的例子，包括如何为要计算特征值的矩阵提供前置条件，请参见SolverBase类的文档，以及SLEPcWrappers命名空间的文档中的广泛讨论。   
* [2.x.30]   
* [0.x.32]*
     标准化的数据结构，如果需要的话，可以将额外的数据输送到求解器中。   
* [0.x.33]*
       构造函数。默认情况下，将延迟正交化的选项设置为false，即不做。     
* [0.x.34]*
       延迟正交化的标志。     
* [0.x.35]*
     SLEPc求解器将希望有一个MPI通信器上下文，在这个上下文中计算被并行化。默认情况下，这与PETScWrappers的行为相同，但你可以改变它。   
* [0.x.36]*
     为这个特定的求解器存储一份标志的副本。   
* [0.x.37]*
   一个使用SLEPc Lanczos求解器的求解器接口的实现。  使用方法。所有光谱，所有问题类型，复杂。    关于如何使用这个类和它的兄弟类的例子，包括如何为要计算特征值的矩阵提供前置条件，请参见SolverBase类的文档，以及SLEPcWrappers命名空间的文档中的广泛讨论。   
* [2.x.31]   
* [0.x.38]*
     标准化的数据结构，如果需要的话，可以将额外的数据输送到求解器中。   
* [0.x.39]*
       在Lanczos迭代过程中使用的正交化类型。     
* [0.x.40]*
       构造函数。默认情况下，在Lanczos迭代过程中使用的正交化类型为完全。     
* [0.x.41]*
     SLEPc求解器将希望有一个MPI通信器上下文，在该上下文上计算被并行化。默认情况下，这与PETScWrappers的行为相同，但你可以改变它。   
* [0.x.42]*
     为这个特定的求解器存储一份标志的副本。   
* [0.x.43]*
   一个使用SLEPc Power求解器的求解器接口的实现。  使用方法。仅限频谱的最大值，所有问题类型，复杂。    关于如何使用这个类和它的兄弟类的例子，包括如何为要计算特征值的矩阵提供前置条件，请参见SolverBase类的文档，以及SLEPcWrappers命名空间的文档中的广泛讨论。   
* [2.x.32]   
* [0.x.44]*
     标准化的数据结构，以便在需要时将额外的数据输送到求解器中。   
* [0.x.45]*
     SLEPc求解器将希望有一个MPI通信器上下文，在这个上下文中计算被并行化。默认情况下，这与PETScWrappers的行为相同，但你可以改变它。   
* [0.x.46]*
     为这个特定的求解器存储一份标志的副本。   
* [0.x.47]*
   使用SLEPc Davidson求解器的求解器接口的一个实现。用法。所有问题类型。    关于如何使用这个类和它的兄弟类的例子，包括如何为要计算特征值的矩阵提供前置条件，请参见SolverBase类的文档，以及SLEPcWrappers命名空间的文档中的广泛讨论。   
* [2.x.33]   
* [0.x.48]*
     标准化的数据结构，如果需要的话，可以将额外的数据输送到求解器中。   
* [0.x.49]*
       在搜索子空间中使用双重扩展。     
* [0.x.50]*
       构造函数。默认将double_expansion设置为false。     
* [0.x.51]*
     SLEPc求解器将希望有一个MPI通信器上下文，在该上下文上计算被并行化。默认情况下，这与PETScWrappers的行为相同，但你可以改变它。   
* [0.x.52]*
     为这个特定的求解器存储一份标志的副本。   
* [0.x.53]*
   使用SLEPc Jacobi-Davidson求解器的求解器接口的一个实现。用法。所有问题类型。    关于如何使用这个类和它的兄弟类的例子，包括如何为要计算特征值的矩阵提供前置条件，请参见SolverBase类的文档，以及SLEPcWrappers命名空间的文档中的广泛讨论。   
* [2.x.34]   
* [0.x.54]*
     标准化的数据结构，如果需要的话，可以将额外的数据输送到求解器中。   
* [0.x.55]*
     SLEPc求解器将希望有一个MPI通信器上下文，在这个上下文中计算被并行化。默认情况下，这与PETScWrappers的行为相同，但你可以改变它。   
* [0.x.56]*
     为这个特定的求解器存储一份标志的副本。   
* [0.x.57]*
   一个使用SLEPc LAPACK直接求解器的求解器接口的实现。    关于如何使用这个类和它的兄弟类的例子，包括如何为要计算特征值的矩阵提供前置条件，请参见SolverBase类的文档以及SLEPcWrappers命名空间的文档中的广泛讨论。   
* [2.x.35]   
* [0.x.58]*
     标准化的数据结构，如果需要的话，可以将额外的数据输送到求解器中。   
* [0.x.59]*
     SLEPc求解器将希望有一个MPI通信器上下文，在这个上下文中计算被并行化。默认情况下，这与PETScWrappers的行为相同，但你可以改变它。   
* [0.x.60]*
     为这个特定的求解器存储一份标志的副本。   
* [0.x.61]*
   在此声明的目的是为了使其有可能采取[2.x.36]不同的PETScWrappers向量类型  
* [0.x.62]

