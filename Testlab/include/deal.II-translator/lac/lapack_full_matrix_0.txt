include/deal.II-translator/lac/lapack_full_matrix_0.txt
[0.x.0]*
 FullMatrix的一个变种，尽可能使用LAPACK函数。为了做到这一点，矩阵是以转置的顺序存储的。元素访问函数通过恢复转置来隐藏这一事实。
* 

* 
* [2.x.0] 为了执行LAPACK函数，该类在私有部分包含了很多辅助数据。这些数据向量的名称通常是LAPACK文档中为参数选择的名称。
* 

* 
* [2.x.1] 

* 
* [0.x.1]*
   声明容器尺寸的类型。 
* [0.x.2]*
   构造函数。将矩阵初始化为一个维度为[2.x.2]的正方形矩阵，为了避免整数和其他类型的矩阵的隐式转换，这个构造函数被声明为<tt>explicit</tt>。    默认情况下，不分配内存。 
* [0.x.3]*
   构造函数。将矩阵初始化为一个矩形矩阵 [2.x.3] 。 
* [0.x.4]*
   拷贝构造函数。这个构造函数对矩阵进行了深度复制。  因此，它带来了一个可能的效率问题，例如，如果函数参数是通过值而不是通过引用传递的。  不幸的是，我们不能将这个复制构造函数<tt>explicit</tt>，因为这样就不能在容器中使用这个类，例如 [2.x.4] 。因此，检查程序性能的责任必须由这个类的使用者来承担。 
* [0.x.5]*
   赋值运算符。 
* [0.x.6]*
   来自普通FullMatrix的赋值运算符。   
* [2.x.5]由于LAPACK希望矩阵以转置的顺序出现，所以这里包括了这种转置。 
* [0.x.7]*
   来自普通稀疏矩阵的赋值操作。   
* [2.x.6]由于LAPACK希望矩阵以转置的顺序排列，所以这里包括了这个转置。 
* [0.x.8]*
   这个操作符将一个标量分配给一个矩阵。为了避免与构造函数混淆，0（当投到[2.x.7]类型时）是[2.x.8]的唯一允许值。  
* [0.x.9]*
   这个操作符将所有条目乘以一个固定的[2.x.9]。  
* [0.x.10]*
   该运算符将所有条目除以一个固定的[2.x.10]。  
* [0.x.11]*
   将矩阵的一个特定条目设置为 [2.x.11] 因此，调用 [2.x.12] 完全等同于操作 [2.x.13] 。这个函数的存在是为了与各种稀疏矩阵对象兼容。     [2.x.14] i 要设置的元素的行索引。   [2.x.15] j 要设置的元素的列索引。   [2.x.16] value 要写进元素的值。 
* [0.x.12]*
   缩放矩阵的简单加法，即 [2.x.17] 。 
* [0.x.13]*
   对一个对称矩阵进行秩-1更新 [2.x.18] 。    这个函数也适用于Cholesky分解。  在这种情况下，更新（[2.x.19]）是通过Givens旋转进行的，而降维（[2.x.20]）是通过双曲旋转进行的。请注意，后一种情况可能会导致一个负定矩阵，在这种情况下，错误将被抛出（因为Cholesky分解只对对称和正定矩阵有效）。 
* [0.x.14]*
   将[1.x.0][2.x.21]（余弦、正弦和半径的三要素，旋转矩阵[2.x.23]的定义见[2.x.22]）在[2.x.24]和[2.x.25]单位向量所跨越的平面内应用于该矩阵。  如果[2.x.26]是[2.x.27]，则旋转从左边[2.x.28]开始，只有行[2.x.29]和[2.x.30]受到影响。  否则，旋转矩阵的转置将从右边[2.x.31]开始，只有列[2.x.32]和[2.x.33]受到影响。 
* [0.x.15]*
   从不同的矩阵类进行赋值，执行LAPACK所期望的转置格式的常规转换。这个赋值运算符使用类型名MatrixType的迭代器。因此，稀疏矩阵是可能的来源。 
* [0.x.16]*
   用一个具有相同属性的矩阵重新生成当前的矩阵，如果它是由本类的构造函数创建的，参数列表与本函数相同。 
* [0.x.17]*
   和上面一样，但在调整大小时将保留矩阵的值。  矩阵的原始值在增加大小时被保留 [1.x.1] 而如果新的大小较小，矩阵将包含原始矩阵的左上块 [1.x.2] 。 
* [0.x.18]*
   从矩阵中移除行[2.x.34]和列[2.x.35]。  [1.x.3]  
* [0.x.19]*
   用一个具有相同属性的矩阵重新生成当前的矩阵，如果它是由本类的构造函数创建的，参数列表与本函数相同。 
* [0.x.20]*
   将[2.x.36]分配给这个矩阵。 
* [0.x.21]*
   返回共域（或范围）空间的维度。   
* [2.x.37] 矩阵的维度为[2.x.38] 。 
* [0.x.22]*
   返回域空间的维数。   
* [2.x.39] 矩阵的维数是[2.x.40] .  
* [0.x.23]*
   填充矩形块。    矩阵<tt>src</tt>的一个矩形块被复制到<tt>this</tt>。被复制的块的左上角是<tt>(src_offset_i,src_offset_j)</tt>。 被复制块的左上角是<tt>(dst_offset_i,dst_offset_j)</tt>。 被复制的矩形块的尺寸是可能的最大尺寸，由<tt>this</tt>或<tt>src</tt>的尺寸决定。    最后两个参数允许输入源的倍数或其转置。 
* [0.x.24]*
   矩阵-向量-乘法。    根据#state中记录的以前的变换，这个函数的结果是[2.x.41] [2.x.42] 如果#state是[2.x.43]或[2.x.44]，这将是一个使用LAPACK gemv()的常规矩阵向量乘积。   [2.x.45] 如果#state是[2.x.46]或[2.x.47]，该函数首先与右变换矩阵相乘，然后与奇异值的对角线矩阵或其倒数值相乘，最后与左变换矩阵相乘。   [2.x.48] 可选参数[2.x.49]决定了结果是存储在向量中[2.x.50]还是添加到向量中[2.x.51] 。   
* [2.x.52] 来源和目的地不能是同一个向量。   
* [2.x.53] 带有[2.x.54]的模板只存在于与FullMatrix的编译时兼容。由于底层LAPACK接口的限制，只有[2.x.55] = [2.x.56]的情况被实现。所有其他的变体在调用时都会出现错误。 
* [0.x.25]*
   上述函数的特殊化，用于兼容[2.x.57]。  
* [0.x.26]*
   增加了矩阵-向量-乘法 [2.x.58] 。    有关实现的细节，请参见vmult()的文档。 
* [0.x.27]*
   上述函数的特殊化，用于兼容 [2.x.59] 。  
* [0.x.28]*
   转置矩阵-向量-乘法。    可选参数 [2.x.60] 决定了结果是存储在向量中 [2.x.61] 还是添加到向量中 [2.x.62] 。    关于实现的细节，请参见vmult()的文档。 
* [0.x.29]*
   上述函数的特殊化，用于兼容 [2.x.63] 。  
* [0.x.30]*
   增加转置矩阵-向量-乘法 [2.x.64] 。    有关实现的细节，请参见vmult()的文档。 
* [0.x.31]*
   上述函数的特殊化，用于兼容 [2.x.65] 。  
* [0.x.32]*
   矩阵-矩阵-乘法。    可选参数 [2.x.66] 决定了结果是存储在矩阵中 [2.x.67] 还是添加到矩阵中 [2.x.68] 。   
* [2.x.69] 假设[2.x.70]和[2.x.71]具有兼容的大小，并且[2.x.72]已经具有正确的大小。     [2.x.73]函数使用BLAS函数Xgemm。 
* [0.x.33]*
   和之前一样，但将结果存储在FullMatrix中，而不是LAPACKFullMatrix中。 
* [0.x.34]*
   使用<tt>this</tt>的转置进行矩阵-矩阵乘法。    可选的参数 [2.x.74] 决定了结果是存储在矩阵中 [2.x.75] 还是添加到矩阵中 [2.x.76] 。   
* [2.x.77] 假设[2.x.78]和[2.x.79]具有兼容的大小，并且[2.x.80]已经具有正确的大小。   
* [2.x.81] 这个函数使用BLAS函数Xgemm。 
* [0.x.35]*
   和之前一样，但将结果存储在FullMatrix中，而不是LAPACKFullMatrix中。 
* [0.x.36]*
   矩阵-矩阵-乘法，使用<tt>this</tt>的转置和对角线矢量 [2.x.82] 如果 [2.x.83] 则将结果存储在矩阵中 [2.x.84] 否则将增加 [2.x.85] 。   
* [2.x.86] 假设[2.x.87] [2.x.88]和[2.x.89]具有兼容的大小，并且[2.x.90]已经具有正确的大小。   
* [2.x.91] 这个函数不是由LAPACK提供的。该函数首先形成[2.x.92]积，然后使用Xgemm函数。 
* [0.x.37]*
   矩阵-矩阵-使用[2.x.93]的转置进行乘法 可选参数[2.x.94]决定，结果是存储在矩阵中[2.x.95]还是加到矩阵中[2.x.96] 。   
* [2.x.97] 假设[2.x.98]和[2.x.99]具有兼容的大小，并且[2.x.100]已经具有正确的大小。   
* [2.x.101] 这个函数使用BLAS函数Xgemm。 
* [0.x.38]*
   和之前一样，但将结果存储在FullMatrix中，而不是LAPACKFullMatrix中。 
* [0.x.39]*
   使用<tt>this</tt>和[2.x.102]的转置进行矩阵乘法 可选参数[2.x.103]决定了结果是存储在矩阵中[2.x.104]还是添加到矩阵中[2.x.105] 。   
* [2.x.106] 假设[2.x.107]和[2.x.108]具有兼容的尺寸，并且[2.x.109]已经具有正确的尺寸。   
* [2.x.110] 这个函数使用BLAS函数Xgemm。 
* [0.x.40]*
   和之前一样，但将结果存储在FullMatrix中，而不是LAPACKFullMatrix中。 
* [0.x.41]*
   执行外置换位。  矩阵[2.x.111]应该有适当的大小。   
* [2.x.112] 对于复数类型，将执行共轭转置。   
* [2.x.113]如果deal.II配置了Intel-MKL，将使用`mkl_?omatcopy`，否则将逐元素进行转置。 
* [0.x.42]*
   将该矩阵的行数按[2.x.114]进行缩放。这相当于与对角线矩阵进行预乘法 [2.x.115] 。 
* [0.x.43]*
   使用LAPACK函数Xgetrf计算矩阵的LU因子化。 
* [0.x.44]*
   使用LAPACK函数Xpotrf计算矩阵的Cholesky因式分解。   
* [2.x.116]因式分解被存储在矩阵的下三角部分。 
* [0.x.45]*
   使用Cholesky因式分解法估计对称正定矩阵的条件数[2.x.117]在[2.x.118]准则下的倒数（[2.x.119]）。只有在矩阵已经被分解的情况下才能调用这个函数。   
* [2.x.120] 条件数 [2.x.121] 可用于估计与矩阵反演或线性代数方程组的解有关的数值误差，如 [2.x.122] 。  或者可以得到准确数字的数量 [2.x.123] 。   
* [2.x.124] 该函数计算条件数的倒数，以避免在矩阵接近单数时可能的溢出。     [2.x.125] l1_norm 是调用Cholesky分解前矩阵的[2.x.126]规范。它可以通过调用l1_norm()获得。 
* [0.x.46]*
   估计三角矩阵的条件数[2.x.127]在[2.x.128]规范中的倒数。矩阵必须将[2.x.129]设置为[2.x.130]或[2.x.131]见set_property()。 
* [0.x.47]*
   计算一个矩阵的行列式。由于它需要对矩阵进行LU因子化，这个函数只能在调用compute_lu_factorization()之后才能被调用。 
* [0.x.48]*
   计算[2.x.132]规范。 
* [0.x.49]*
   计算[2.x.133]规范。 
* [0.x.50]*
   计算Frobenius规范  
* [0.x.51]*
   计算矩阵的轨迹，即对角线值的总和。  很明显，对于这个函数来说，矩阵需要是二次的。 
* [0.x.52]*
   首先用LAPACK函数Xgetrf/Xpotrf计算LU/Cholesky因子，然后用Xgetri/Xpotri建立实际的逆矩阵。 
* [0.x.53]*
   解出右手边[2.x.134]的线性系统，并将解放回[2.x.135]，矩阵应该是三角形的，或者之前已经计算过LU/Cholesky因式分解。    转置的标志表示是否要进行转置系统的求解。 
* [0.x.54]*
   与上述相同，但对于多个右手边（与矩阵中的列数一样多[2.x.136]）。  
* [0.x.55]*
   计算矩阵的特征值。调用此例程后，可以使用eigenvalue()函数检索特征值。在此操作后，矩阵本身将是[2.x.137]。    可选的参数也允许计算左和右的特征向量。    注意，该函数不会立即返回计算出的特征值，因为这涉及到在LAPACK函数的输出数组和任何返回数组之间复制数据。这通常是不必要的，因为人们可能不会对所有的特征值都感兴趣，而是只对极端的特征值感兴趣。在这种情况下，只让这个函数计算特征值，并有一个单独的函数来返回所要求的任何特征值，是比较便宜的做法。   
* [2.x.138]调用LAPACK函数Xgeev。 
* [0.x.56]*
   计算一个实数对称矩阵的特征值和特征向量。只计算区间[2.x.139]内的特征值，绝对公差为[2.x.140] 。当一个近似的特征值被确定位于宽度小于或等于[2.x.142]的区间[2.x.141]内，其中[2.x.143]为机器精度，则被接受为收敛。 如果[2.x.144]小于或等于零，那么[2.x.145]将被用来代替，其中[2.x.146]是通过将[2.x.147]还原为三对角形式得到的三对角矩阵的1-norm。当[2.x.148]被设置为下溢阈值的两倍而不是零时，特征值将被最准确地计算出来。  调用此例程后，[2.x.149]中的所有特征值将被存储在特征值中，相应的特征向量将被存储在特征向量的列中，其维度被相应设置。   
* [2.x.150]调用LAPACK函数Xsyevx。 
* [0.x.57]*
   计算形式为实数的广义对称特征问题的广义特征值和特征向量
* 

* 
* 

 
 

 
* 
* - itype = 1: [2.x.151] 。
* 

* 
* 

* 
* 

 
* 
* - itype = 2: [2.x.152] 。
* 

* 
* 

* 
* 

 
* 
* - itype = 3: [2.x.153] 其中[2.x.154]是这个矩阵。 [2.x.155]和[2.x.156]被假定为对称的，而[2.x.157]必须是正定的。只有在区间[2.x.158]内的特征值才以绝对公差[2.x.159]进行计算。 当一个近似的特征值被确定位于宽度小于或等于[2.x.161]的区间[2.x.160]内，其中[2.x.162]是机器精度，则被接受为收敛。如果[2.x.163]小于或等于零，那么[2.x.164]将被用来代替，其中[2.x.165]是通过将[2.x.166]还原为三对角形式得到的三对角矩阵的1-norm。当[2.x.167]被设置为下溢阈值的两倍而不是零时，特征值将被最准确地计算出来。调用此例程后，[2.x.168]中的所有特征值将被存储在特征值中，相应的特征向量将被存储在特征向量中，其维度被相应设置。   
* [2.x.169]调用LAPACK函数Xsygvx。 
* [0.x.58]*
   与其他compute_generalized_eigenvalues_symmetric函数相同，只是所有的特征值都被计算出来，并且自动设置了公差。 注意这个函数不会立即返回计算的特征值，因为这涉及到在LAPACK函数的输出数组和任何返回数组之间复制数据。这通常是不必要的，因为人们可能不会对所有的特征值都感兴趣，而是只对极端的特征值感兴趣。在这种情况下，只让这个函数计算特征值，并有一个单独的函数来返回所要求的任何特征值，是比较便宜的做法。特征值可以用eigenvalue()函数来检索。 计算出的特征向量的数量等于eigenvectors.size()    
* [2.x.170]调用LAPACK函数Xsygv。 
* [0.x.59]*
   使用LAPACK函数Xgesdd计算矩阵的奇异值分解。    要求#状态为[2.x.171] 填充数据成员#wr、#svd_u和#svd_vt，并使对象处于#状态[2.x.172] 奇异值分解将提供的矩阵（A）分解为三部分。U、sigma和V的转置（V^T），这样A=U sigma V^T。Sigma是一个MxN矩阵，包含A在对角线上的奇异值，而所有其他元素都是零。U是一个MxM的正交矩阵，包含与A的奇异值相对应的左侧奇异向量。 V是一个NxN的正交矩阵，包含与A的奇异值相对应的右侧奇异向量。注意，变量#svd_vt包含V的转置，可以通过get_svd_vt()访问，而U可以通过get_svd_u()访问。 
* [0.x.60]*
   通过奇异值分解计算矩阵的逆值。    要求#state是[2.x.173]或[2.x.174]在第一种情况下，该函数调用compute_svd()。  在此函数之后，对象将具有#state [2.x.175] 对于奇异值分解，通过将所有奇异值替换为它们的倒数来简单地计算逆值。如果矩阵没有最大等级，则不触及奇异值0，从而计算矩阵的最小规范右逆。    参数[2.x.176]决定了何时应将奇异值视为零。它是最小的非零奇异值与最大的非零奇异值的比率 [2.x.177] 。因此，所有小于[2.x.178]的奇异值的倒数将被设置为零。 
* [0.x.61]*
   与上述相同，但提供内核的大小而不是阈值，即[2.x.179]最小的特征值。 
* [0.x.62]*
   检索调用compute_eigenvalues()后的特征值。 
* [0.x.63]*
   在调用compute_svd()或compute_inverse_svd()后检索奇异值。 
* [0.x.64]*
   在调用compute_svd()或compute_inverse_svd()后检索矩阵#svd_u。 
* [0.x.65]*
   在调用compute_svd()或compute_inverse_svd()后检索矩阵#svd_vt。 
* [0.x.66]*
   打印矩阵并允许对条目进行格式化。    参数允许对输出格式进行灵活设置。     [2.x.180] out 这指定了要写入的流。     [2.x.181] precision 表示尾数的数量。     [2.x.182] scientific 用于确定数字格式，其中[2.x.183] 表示定点符号。     [2.x.184] 宽度表示每列的宽度。[2.x.185]的零条目使函数计算出一个宽度，但如果输出是粗略的，可以将其改为正值。     [2.x.186] zero_string指定了一个为零条目打印的字符串。     [2.x.187] 分母 将整个矩阵乘以这个共同分母，得到更漂亮的数字。     [2.x.188] 门槛 所有绝对值小于此值的条目都被视为零。   
* [2.x.189]只有当状态为[2.x.190]或[2.x.191]时，存储的条目才类似于一个矩阵。否则，不允许调用此函数。 
* [0.x.67]*
   计算各种规范的内部函数。 
* [0.x.68]*
   由于LAPACK的操作出了名地改变了矩阵项的含义，我们在这里记录了最后一次操作后的当前状态。 
* [0.x.69]*
   矩阵的其他属性，可能有助于选择更有效的LAPACK函数。 
* [0.x.70]*
   用于某些LAPACK函数的工作阵列。 
* [0.x.71]*
   用于某些LAPACK函数的整数工作数组。 
* [0.x.72]*
   储存用于LU-因式分解中枢轴的排列方式的向量。    也用作LAPACK函数中需要的刮擦数组WORK。 
* [0.x.73]*
   用于计算LU因子化的逆矩阵的工作区。 
* [0.x.74]*
   特征值的实部或奇异值。由 compute_eigenvalues() 或 compute_svd() 填充。 
* [0.x.75]*
   特征值的虚部，或者，在复数标量的情况下，特征值本身。由 compute_eigenvalues 填充。 
* [0.x.76]*
   可以存储左翼特征向量的空间。 
* [0.x.77]*
   可以存储右特征向量的空间。 
* [0.x.78]*
   矩阵[2.x.192]的奇异值分解[2.x.193] .  
* [0.x.79]*
   矩阵[2.x.194]在奇异值分解[2.x.195]中。 
* [0.x.80]*
   线程互斥。 
* [0.x.81]*
 一个基于LAPACKFullMatrix的LU因子化的预处理程序。
* 

* 
* [2.x.196] 

* 
* [0.x.82]

