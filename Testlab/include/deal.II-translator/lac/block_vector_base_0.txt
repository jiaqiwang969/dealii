include/deal.II-translator/lac/block_vector_base_0.txt
[0.x.0]!  [2.x.0] 矢量 [2.x.1] 。

* 
* [0.x.1]*
 一个可以用来确定某个类型是否是块向量类型的类。比如说。

* 
* [1.x.0]
* 的值是false，而

* 
* [1.x.1]
* 是真。这在模板环境中有时很有用，我们可能想根据模板类型是表示普通的还是块状向量类型来做不同的事情。

* 
* [0.x.2]*
   如果该类派生自BlockVectorBase，重载返回true，这就是块向量的作用。 
* [0.x.3]*
   对所有其他不是块状矩阵的潜在向量类型进行捕捉。 
* [0.x.4]*
   一个可静态计算的值，表示该类的模板参数是否是块向量（事实上，该类型是否来自BlockVectorBase<T>）。 
* [0.x.5]*
   实现块向量中迭代器的命名空间。 
* [0.x.6]*
     用于块向量的通用随机访问迭代器类。由于我们不希望有两个非常量迭代器和常量迭代器的类，我们采取第二个模板参数，表示我们指向的向量是否是常量对象。第一个模板参数总是使用中的块向量的数字类型。        这个类满足了C++标准中定义的随机访问迭代器的所有要求。对这些迭代器的操作在块向量中的元素数量上是常数。然而，它们有时与向量中的块数成线性关系，但由于这在应用程序中很少动态变化，所以这是一个常数，我们再次得到该迭代器满足了随机访问迭代器的要求。   
* [0.x.7]*
       声明容器大小的类型。     
* [0.x.8]*
       这个迭代器所指向的数字的类型。根据第二个模板参数的值，这要么是一个常数，要么是非常数。     
* [0.x.9]*
       声明一些别名，这些别名是迭代器的标准，被算法用来查询它们所工作的迭代器的具体内容。     
* [0.x.10]*
       Typedef块向量的类型（根据第二个模板参数的不同，其constness也不同）。     
* [0.x.11]*
       从我们指向的向量和指向的元素的全局索引构造一个迭代器。            根据这个类的<tt>Constness</tt>模板参数的值，这个构造函数的第一个参数要么是一个const，要么是非const的引用。     
* [0.x.12]*
       从不同常量的迭代器复制构造函数。           
* [2.x.2]从一个常数迭代器构造一个非常数迭代器是没有意义的。试图这样做将导致一个编译时错误（通过[2.x.3] ）。     
* [0.x.13]*
       从具有相同常量的迭代器复制构造器。     
* [0.x.14]*
       本类内部使用的构造函数。参数与各自成员变量的值完全匹配。     
* [0.x.15]*
       复制操作符。     
* [0.x.16]*
       去引用操作符。如果模板参数<tt>Constness</tt>是<tt>true</tt>，那么就不可能向结果写入，使之成为一个const_iterator。     
* [0.x.17]*
       随机访问操作符，允许访问相对于当前指向的元素的任意元素。     
* [0.x.18]*
       前缀递增操作符。这个操作符将迭代器推进到下一个元素，并返回一个对<tt>*this</tt>的引用。     
* [0.x.19]*
       后缀增量操作符。这个操作符将迭代器推进到下一个元素，并返回这个迭代器的旧值的副本。     
* [0.x.20]*
       前缀递减运算符。这个操作符将迭代器缩回到上一个元素，并返回一个对<tt>*this</tt>的引用。     
* [0.x.21]*
       后缀递减运算符。该操作符将迭代器缩回到前一个元素，并返回该迭代器的旧值的副本。     
* [0.x.22]*
       迭代器的平等比较。该操作符检查所指向的向量是否相同，如果不相同，则抛出一个异常。     
* [0.x.23]*
       比较迭代器的不平等。该操作符检查指向的向量是否相同，如果不相同，则抛出一个异常。     
* [0.x.24]*
       检查这个迭代器是否指向给定参数所指向的元素之前的一个元素。这个操作符检查所指向的向量是否相同，如果不相同，则抛出一个异常。     
* [0.x.25]*
       与上面的比较运算符相同。     
* [0.x.26]*
       与上面的比较运算符相同。     
* [0.x.27]*
       与上面的比较运算符相同。     
* [0.x.28]*
       返回两个迭代器之间的距离，单位是元素。     
* [0.x.29]*
       返回一个迭代器，该迭代器在当前迭代器的前面有一定数量的元素。     
* [0.x.30]*
       返回一个迭代器，该迭代器是在当前迭代器后面的给定数量的元素。     
* [0.x.31]*
       一次性向前移动迭代器<tt>d</tt>元素，并返回结果。     
* [0.x.32]*
       一次性向后移动迭代器<tt>d</tt>元素，并返回结果。     
* [0.x.33]*
        [2.x.4] 异常情况[2.x.5]。      
* [0.x.34]*
       当人们对属于两个不同块向量的迭代器进行算术比较时产生的异常。     
* [0.x.35]*
       指向该迭代器所指向的块向量对象的指针。      根据这个类的<tt>Constness</tt>模板参数的值，这是一个<tt>const</tt>或非<tt>const</tt>的指针。     
* [0.x.36]*
       我们目前所指向的元素的全局索引。     
* [0.x.37]*
       当前的块和当前指向的元素在该块中的索引。     
* [0.x.38]*
       全局元素地址的索引，当向前和向后移动时，我们必须转到另一个块。这些索引作为缓存保存，因为这比总是询问父对象要有效得多。     
* [0.x.39]*
       向前移动一个元素。     
* [0.x.40]*
       向后移动一个元素。     
* [0.x.41]*
 一个由几个块组成的向量，每个块代表它自己的一个向量。
* BlockVector是一个给定类型的向量的集合（例如，deal.II Vector对象，[2.x.6]对象，等等）。里面的每个向量都可以有不同的大小。
* BlockVector的功能包括一个Vector所能做的一切，加上通过<tt>block(i)</tt>访问BlockVector内部的单个Vector。它也有一个完整的随机访问迭代器，就像其他Vector类或标准C++库模板[2.x.7]一样。因此，所有在迭代器上工作的算法也能与这个类的对象工作。
* 虽然这个基类通过将对其成员函数的调用分派给每个独立块上的相应函数来实现大部分功能，但这个类实际上并没有分配一些内存或改变向量的大小。为此，派生类的构造函数、赋值运算符和 reinit() 函数负责。这个类只处理与块向量的实际向量类型无关的共同部分。
* 

* [1.x.2]
* 除了将这个对象作为一个整体使用外，你还可以使用block()函数，将每个块作为一个向量单独使用。 有一个注意事项：如果你改变了一个或几个块的大小，你必须调用块向量的函数 collect_sizes() 来更新其内部结构。
* [2.x.8] 警告。如果你在没有调用 collect_sizes() 的情况下改变单个块的大小，结果可能是不可预测的。由于性能的原因，调试版在此不检查一致性!
* [2.x.9] [2.x.10] "块（线性代数）"

* 
* [0.x.42]*
   Typedef底层向量的类型。 
* [0.x.43] 声明所有容器中使用的标准类型。这些类型与<tt>C++</tt>标准库[2.x.11]类中的类型平行。这包括迭代器类型。 
* [0.x.44]*
   声明一个类型，该类型具有持有实值数字的功能，其精度与该类的模板参数相同。如果这个类的模板参数是一个实数数据类型，那么real_type就等于模板参数。  如果模板参数是一个[2.x.12]类型，那么real_type等于复数的基础类型。    这个别名被用来表示规范的返回类型。 
* [0.x.45]*
   默认构造函数。 
* [0.x.46]*
   复制构造函数。 
* [0.x.47]*
   移动构造函数。如果底层的[2.x.13]可以移动构造，那么参数向量的每个块都被移动到当前对象中，否则它们被复制。 
* [0.x.48]*
   在调整向量大小后更新内部结构。每当你重新引用一个块状向量的一个块时，内部数据结构就会被破坏。  因此，你应该在所有块得到新的大小后再调用这个函数。 
* [0.x.49]*
   在矩阵的所有子块上调用compress()函数。    只有在使用基于MPI的向量时才需要调用这个功能，为了兼容，在其他对象中也存在。    更多信息见[2.x.14] "压缩分布式对象"。 
* [0.x.50]*
   对单个块的访问。 
* [0.x.51]*
   对单个区块的只读访问。 
* [0.x.52]*
   返回一个描述块和全局索引之间映射的对象上的引用。这个函数的使用已被高度废弃，它应该在下一个版本中消失。 
* [0.x.53]*
   块的数量。 
* [0.x.54]*
   返回向量的尺寸。这是所有组件的尺寸之和。 
* [0.x.55]*
   返回向量的局部尺寸。这是所有组件的本地尺寸（即存储在当前处理器上的值）的总和。 
* [0.x.56]*
   返回一个索引集，描述这个向量的哪些元素是由当前处理器拥有的。请注意，这个索引集不包括这个向量可能作为鬼魂元素存储在本地，但实际上是由另一个处理器拥有的元素。因此，如果这是一个分布式向量，在不同处理器上返回的索引集将形成不相交的集合，加起来就是完整的索引集。很明显，如果一个向量只在一个处理器上创建，那么结果将满足  
* [1.x.3]
* 对于块状向量，这个函数返回各个块的本地拥有的元素的并集，以它们各自的索引偏移量进行移位。 
* [0.x.57]*
   返回一个指向第一个元素的迭代器。 
* [0.x.58]*
   返回一个指向恒定块向量的第一个元素的迭代器。 
* [0.x.59]*
   返回一个指向结束后的元素的迭代器。 
* [0.x.60]*
   返回一个迭代器，指向一个恒定块向量的结束后的元素。 
* [0.x.61]*
   访问组件，返回U(i)。 
* [0.x.62]*
   访问组件，返回U(i)作为一个可写的引用。 
* [0.x.63]*
   访问组件，返回U(i)。    与operator()完全相同。 
* [0.x.64]*
   访问组件，返回U(i)作为一个可写的引用。    与operator()完全相同。 
* [0.x.65]*
   与通过operator()获取向量的单个元素不同，这个函数允许一次性获取整个元素集。要读取的元素的索引在第一个参数中说明，相应的值在第二个参数中返回。    如果当前的向量被称为[2.x.15]，那么这个函数就等同于代码  
* [1.x.4]
* [2.x.16][2.x.17]和[2.x.18]数组的大小必须是一致的。 
* [0.x.66]*
   这个函数不是通过operator()获得向量的单个元素，而是允许一次获得整个元素集。与前一个函数不同的是，这个函数通过取消引用前两个参数提供的迭代器范围内的所有元素来获得元素的索引，并将向量的值放入通过取消引用从第三个参数指向的位置开始的迭代器范围获得的内存位置。    如果当前的向量被称为[2.x.19]，那么这个函数就等同于代码  
* [1.x.5]
* [2.x.20] 必须能够写进从[2.x.21]开始的内存位置，因为在[2.x.22]和[2.x.23]之间有许多迭代器。  
* [0.x.67]*
   复制操作：用给定的标量值填充向量的所有组件。 
* [0.x.68]*
   对相同类型的参数进行复制操作。 
* [0.x.69]*
   移动赋值运算符。如果`VectorType`是可移动的，将给定参数向量的每个块移动到当前对象中，否则复制它们。 
* [0.x.70]*
   对不同类型的模板参数进行复制操作。 
* [0.x.71]*
   从非块向量到块向量的复制操作。 
* [0.x.72]*
   检查两个块向量类型是否相等。只有当两个向量已经具有相同的块结构时，才允许该操作。 
* [0.x.73]*
    [2.x.24] : 标量乘积。 
* [0.x.74]*
   返回[2.x.25]-norm的平方。 
* [0.x.75]*
   返回这个向量的元素的平均值。 
* [0.x.76]*
   返回该向量的[2.x.26]-norm，即绝对值之和。 
* [0.x.77]*
   返回向量的[2.x.27]-Norm，即元素的平方根之和。 
* [0.x.78]*
   返回该向量元素的最大绝对值，也就是向量的[2.x.28]-norm。 
* [0.x.79]*
   执行一个矢量加法和随后的内积的组合操作，返回内积的值。换句话说，这个函数的结果与用户调用的  
* [1.x.6]
*这个函数存在的原因是这个操作比在deal.II的向量类（Vector<Number>和[2.x.29]）上分别调用这两个函数涉及的内存转移要少。这个方法只需要加载三个向量，[2.x.30] [2.x.31] [2.x.32] 而调用单独的方法意味着要加载两次调用向量[2.x.33] 。由于大多数向量操作都有内存传输限制，这就使时间减少了25\%（如果[2.x.34]等于[2.x.35]，则减少50\%）对于复值向量，第二步中的标量乘法被实现为[2.x.36] 。 
* [0.x.80]*
   如果给定的全局索引在这个处理器的局部范围内，返回真。询问相应的块。 
* [0.x.81]*
   返回向量是否只包含值为0的元素。这个函数主要用于内部一致性检查，在非调试模式下应该很少使用，因为它需要花费相当多的时间。 
* [0.x.82]*
   如果向量没有负的条目，即所有条目都是零或正的，则返回 [2.x.37]。例如，这个函数用于检查细化指标是否真的都是正的（或零）。 
* [0.x.83]*
   加法运算符。 快速等同于<tt>U.add(1, V)</tt>。 
* [0.x.84]*
   减法运算符。 快速等同于<tt>U.add(-1, V)</tt>。 
* [0.x.85]*
   一个集体添加操作。这个函数将存储在[2.x.38]中的一整套数值添加到[2.x.39]指定的向量成分中。  
* [0.x.86]*
   这是第二次集体添加操作。作为区别，这个函数需要一个deal.II的数值向量。 
* [0.x.87]*
   取一个<tt>n_elements</tt>连续存储的地址，并将其添加到向量中。处理上述其他两个<tt>add()</tt>函数未涵盖的所有情况。 
* [0.x.88]*
    [2.x.40] .  在所有组件上增加<tt>s</tt>。注意，<tt>s</tt>是一个标量而不是一个矢量。 
* [0.x.89]*
   U+=a*V。缩放向量的简单相加。 
* [0.x.90]*
   U+=a*V+b*W。缩放向量的多次加法。 
* [0.x.91]*
   U=s*U+V。缩放和简单的向量相加。 
* [0.x.92]*
   U=s*U+a*V。缩放和简单的加法。 
* [0.x.93]*
   U=s*U+a*V+b*W。缩放和多重加法。 
* [0.x.94]*
   U=s*U+a*V+b*W+c*X。缩放和多重加法。 
* [0.x.95]*
   将向量的每个元素按一个常数进行缩放。 
* [0.x.96]*
   用给定值的倒数来缩放向量的每个元素。 
* [0.x.97]*
   将该向量的每个元素乘以<tt>v</tt>的相应元素。 
* [0.x.98]*
   U=a*V。赋值。 
* [0.x.99]*
   通过调用[2.x.41]更新每个区块的鬼魂值。 
* [0.x.100]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.101]*
   指向组件阵列的指针。 
* [0.x.102]*
   管理全局索引和不同块内索引之间转换的对象。 
* [0.x.103]

