include/deal.II-translator/lac/solver_minres_0.txt
[0.x.0]*
 对称矩阵的最小残差法。
* 为了使用这个类，对矩阵和向量的要求，见求解器基类的文档。
* 像所有其他求解器类一样，这个类有一个名为[2.x.0] AdditionalData的局部结构，用来向求解器传递额外的参数，如阻尼参数或临时向量的数量。我们使用这个额外的结构，而不是直接将这些值传递给构造函数，因为这使得[2.x.1]和其他类的使用更加容易，并保证即使某个求解器的额外参数的数量或类型发生变化，这些也能继续工作。
* 然而，由于MinRes方法不需要额外的数据，相应的结构是空的，不提供任何功能。构造函数有一个默认参数，所以你可以在没有附加参数的情况下调用它。
* 前提条件必须是正定和对称的。
* 该算法取自Astrid Battermann的硕士论文，并做了一些修改。全文可在http://scholar.lib.vt.edu/theses/public/etd-12164379662151/etd-title.html。
* 

* [1.x.0]
* 这个类的solve()函数使用Solver基类中描述的机制来确定收敛性。这个机制也可以用来观察迭代的进度。

* 
* [0.x.1]*
   标准化的数据结构，用于向求解器输送额外的数据。这个求解器还不需要额外的数据。 
* [0.x.2]*
   构造函数。 
* [0.x.3]*
   构造函数。使用一个GrowingVectorMemory类型的对象作为默认分配内存。 
* [0.x.4]*
   虚拟解构器。 
* [0.x.5]*
   求解x的线性系统[2.x.2]。 
* [0.x.6]*
    [2.x.3] 异常情况 [2.x.4] 。  
* [0.x.7]*
   异常情况  
* [0.x.8]*
   实现计算残差的准则。 
* [0.x.9]*
   派生类的接口。这个函数得到当前的迭代向量，残差和每一步的更新向量。它可以用于收敛历史的图形输出。 
* [0.x.10]*
   在迭代循环中，残差向量的平方被存储在这个变量中。函数[2.x.5]使用这个变量来计算收敛值，在这个类别中，它是残差向量的规范，因此是[2.x.6]值的平方根。 
* [0.x.11]

