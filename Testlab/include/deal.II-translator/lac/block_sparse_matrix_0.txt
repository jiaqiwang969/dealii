include/deal.II-translator/lac/block_sparse_matrix_0.txt
[0.x.0]!  [2.x.0] Matrix1 [2.x.1]. 

* 
* [0.x.1]*
 基于SparseMatrix类的阻塞式稀疏矩阵。这个类实现了SparseMatrix基对象的特定函数，用于阻塞式稀疏矩阵，并将实际工作中对各个块的大部分调用留给基类中实现的函数。关于这个类何时有用的描述，也请参见这里。
* [2.x.2] [2.x.3] "块（线性代数）"

* 
* [0.x.2]*
   对基类进行类型化定义，以便更简单地访问它自己的别名。 
* [0.x.3]*
   对底层矩阵的类型进行类型化定义。 
* [0.x.4]*
   从基类中导入别名。 
* [0.x.5]*
    [2.x.4] 构造函数和初始化  
* [0.x.6]*
   构造函数；将矩阵初始化为空，没有任何结构，也就是说，矩阵根本无法使用。因此，这个构造函数只对作为类的成员的矩阵有用。所有其他的矩阵都应该在数据流中的一个点上创建，在那里所有必要的信息都是可用的。    你必须在使用前用reinit(BlockSparsityPattern)初始化矩阵。然后每行和每列的块数由该函数决定。 
* [0.x.7]*
   构造函数。使用给定的矩阵稀疏度结构来表示该矩阵的稀疏度模式。你可以在以后通过调用reinit()函数来改变稀疏性模式。    这个构造函数用参数中的子疏密模式初始化所有子矩阵。    你必须确保稀疏结构的寿命至少和这个矩阵的寿命一样长，或者只要reinit()没有被调用，就会有新的稀疏结构。 
* [0.x.8]*
   解构器。 
* [0.x.9]*
   伪拷贝操作符只拷贝空对象。块矩阵的大小需要相同。 
* [0.x.10]*
   这个操作符将一个标量分配给一个矩阵。因为这通常没有什么意义（我们应该把所有的矩阵条目都设置为这个值吗？仅仅是稀疏模式的非零条目？），这个操作只允许在实际要分配的值为零的情况下进行。这个操作符的存在只是为了允许明显的符号<tt>matrix=0</tt>，它将矩阵的所有元素设置为零，但保留之前使用的稀疏模式。 
* [0.x.11]*
   释放所有内存并返回到与调用默认构造函数后相同的状态。它也忘记了之前所绑定的稀疏模式。    这在所有子矩阵上调用[2.x.5]，然后将此对象重置为完全没有块。 
* [0.x.12]*
   用给定的稀疏模式重新初始化稀疏矩阵。后者告诉矩阵需要保留多少个非零元素。    基本上，这个函数只调用[2.x.6]的子矩阵与参数的块状稀疏模式。    你必须确保稀疏结构的寿命至少和这个矩阵的寿命一样长，或者只要reinit(const SparsityPattern &)没有被调用新的稀疏结构。    矩阵的元素被这个函数设置为零。 
* [0.x.13]*
    [2.x.7] 矩阵的信息  
* [0.x.14]*
   返回该对象是否为空。如果两个维度都是零或者没有关联BlockSparsityPattern，它就是空的。 
* [0.x.15]*
   返回特定行中的条目数。 
* [0.x.16]*
   返回这个矩阵的非零元素的数量。实际上，它返回的是稀疏模式中的条目数；如果任何一个条目碰巧是零，无论如何都会被计算在内。 
* [0.x.17]*
   返回实际非零元素的数量。只是计算所有块中实际非零元素的数量（绝对值大于阈值）。 
* [0.x.18]*
   返回一个对该矩阵的底层稀疏模式的（常数）引用。    尽管返回值被声明为<tt>const</tt>，但你应该注意，如果你调用任何对其进行操作的对象的非常量函数，它可能会发生变化。 
* [0.x.19]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.20]*
    [2.x.8] 乘法运算  
* [0.x.21]*
   矩阵-向量乘法：让[2.x.9]与[2.x.10]为这个矩阵。 
* [0.x.22]*
   矩阵-向量乘法。就像前面的函数一样，但只适用于矩阵只有一个块列的情况。 
* [0.x.23]*
   矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块行的情况。 
* [0.x.24]*
   矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块的情况。 
* [0.x.25]*
   矩阵-向量乘法：让[2.x.11]与[2.x.12]为这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 
* [0.x.26]*
   矩阵-向量乘法。就像前面的函数一样，但只适用于矩阵只有一个块行的情况。 
* [0.x.27]*
   矩阵-向量乘法。就像前面的函数一样，但只适用于矩阵只有一个块列的情况。 
* [0.x.28]*
   矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块的情况。 
* [0.x.29]*
    [2.x.13] 预处理方法  
* [0.x.30]*
   应用Jacobi预处理，它将<tt>src</tt>向量的每个元素都乘以各自对角线元素的逆值，并将结果与松弛参数<tt>omega</tt>相乘。    所有的对角线块必须是方形矩阵，才能进行这个操作。 
* [0.x.31]*
   对一个简单的向量应用雅可比预处理程序。    为此，矩阵必须是单一的正方形块。 
* [0.x.32]*
    [2.x.14] 输入/输出  
* [0.x.33]*
   以通常的格式打印矩阵，即作为矩阵而不是作为非零元素的列表。为了提高可读性，不在矩阵中的元素显示为空白，而明确设置为零的矩阵元素则显示为空白。    参数允许对输出格式进行灵活设置。  <tt>precision</tt>和<tt>scientific</tt>用于确定数字格式，其中<tt>scientific = false</tt>表示固定点符号。 <tt>width</tt>的一个零条目使函数计算出一个宽度，但如果输出粗略的话，可以将其改为一个正值。    此外，还可以指定一个空值的字符。    最后，整个矩阵可以与一个共同的分母相乘，产生更可读的输出，甚至是整数。     [2.x.15] 如果应用于一个大的矩阵，这个函数可能会产生[1.x.0]量的输出!  
* [0.x.34]*
    [2.x.16] 异常情况[2.x.17]。  
* [0.x.35]*
   异常情况  
* [0.x.36]*
   指向用于该矩阵的块状稀疏模式的指针。为了保证它在使用中不被删除，我们使用SmartPointer类来订阅它。 
* [0.x.37]

