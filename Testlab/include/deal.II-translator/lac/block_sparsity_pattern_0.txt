include/deal.II-translator/lac/block_sparsity_pattern_0.txt
[0.x.0]!  [2.x.0] 稀疏性 [2.x.1] 

* 
* [0.x.1]*
 这是块版本的稀疏模式和动态稀疏模式类的基类。它的功能不多，只是管理一个疏散模式对象的数组，并将工作委托给它们。它与SparsityPattern和DynamicSparsityPattern的接口基本相同，只是将对其成员函数的调用转换为对成员疏散模式的各自成员函数的调用。
* SparsityPattern和DynamicSparsityPattern类和这个类之间最大的区别是，大多数情况下，矩阵有不同的属性，你会想在构成矩阵的块上工作，而不是整个矩阵。你可以使用<tt>block(row,col)</tt>函数访问不同的块。
* 注意：如果它的一个子对象的大小发生变化，这个对象不会被自动通知。因此，在你初始化子对象的大小后，你将不得不调用这个类的<tt>collect_sizes()</tt>函数! 注意，当然，一个（块）行中的所有子矩阵必须有相同的行数，而一个（块）列中的所有子矩阵必须有相同的列数。
* 一般来说，你不会想使用这个类，而是使用其中的一个派生类。
* [2.x.2] 正确处理底层SparsityPattern的对角线元素的优化。
* [2.x.3] [2.x.4] "块（线性代数）"

* 
* [0.x.2]*
   申报容器大小的类型。 
* [0.x.3]*
   定义一个值，用来表示[2.x.5] colnums数组中的某个值是未使用的，即不代表某个列号索引。    这个值只是SparsityPattern类中各自数值的别名。 
* [0.x.4]*
   初始化矩阵为空，也就是没有分配内存。如果你想让这样的对象在其他类中作为成员变量，这很有用。你可以通过调用reinit()函数使该结构可用。 
* [0.x.5]*
   用给定的块的行和列的数量初始化矩阵。  块本身仍然是空的，你必须在给它们分配尺寸后调用 collect_sizes()。 
* [0.x.6]*
   复制构造函数。这个构造函数只允许在要复制的稀疏模式是空的情况下被调用，也就是说，目前没有分配的块。这与SparsityPattern的原因相同，详见那里。 
* [0.x.7]*
   解构器。 
* [0.x.8]*
   通过设置块的行数和列数，调整矩阵的大小。这将删除所有的块，并用未初始化的块代替它们，也就是说，那些块的大小还没有被设置。你必须通过调用块本身的reinit()函数来做到这一点。不要忘了在这之后对这个对象调用collect_sizes()。    你必须自己设置块的大小的原因是，大小可能是变化的，每行的最大元素数可能是变化的，等等。在这里不复制SparsityPattern类的接口是比较简单的，而是让用户调用他们想要的任何函数。 
* [0.x.9]*
   复制操作符。对于这一点，与复制构造函数的情况相同：它被声明、定义并可以被调用，但后者只针对空对象。 
* [0.x.10]*
   这个函数收集子对象的大小，并将其存储在内部数组中，以便能够将矩阵的全局索引转为子对象的索引。在你改变了子对象的大小之后，你必须*每次都调用这个函数。 
* [0.x.11]*
   访问具有给定坐标的块。 
* [0.x.12]*
   访问具有给定坐标的块。对于常量对象的版本。 
* [0.x.13]*
   授权访问描述行指数分布到各个块的对象。 
* [0.x.14]*
   允许访问描述各个块的列索引分布的对象。 
* [0.x.15]*
   这个函数压缩了这个对象所代表的稀疏结构。它只是为所有子对象调用[2.x.6]。 
* [0.x.16]*
   返回一列中的块的数量。 
* [0.x.17]*
   返回一行中的块数。 
* [0.x.18]*
   返回该对象是否为空。如果没有分配内存，它就是空的，这与两个维度都是零是一样的。这个函数只是对所有子矩阵的相应调用的串联。 
* [0.x.19]*
   返回每行的最大条目数。它返回每行的最大条目数，在一行的所有块上累积，以及所有行的最大条目数。 
* [0.x.20]*
   向矩阵添加一个非零条目。这个函数只能用于非压缩的稀疏模式。    如果该条目已经存在，则不会发生任何坏事。    这个函数只是找出<tt>(i,j)</tt>属于哪个块，然后转发到该块。 
* [0.x.21]*
   向指定的矩阵行添加几个非零条目。 这个函数只可用于非压缩的稀疏模式。    如果有些条目已经存在，则不会发生什么坏事。    这个函数只是找出迭代器范围内<tt>col</tt>的块<tt>(row,col)</tt>，然后转发到这些块。 
* [0.x.22]*
   返回该矩阵的行数，等于图像空间的维度。它是子矩阵的（块-）行数之和。 
* [0.x.23]*
   返回该矩阵的列数，相当于范围空间的维度。它是子矩阵的（块）列的列数之和。 
* [0.x.24]*
   检查某个位置的值是否可能是非零。 
* [0.x.25]*
   某一行的条目数，与构成这一行的所有块相加。 
* [0.x.26]*
   返回这个矩阵的非零元素的数量。实际上，它返回的是稀疏模式中的条目数；如果任何一个条目碰巧是零，无论如何都会被计算在内。    这个函数只有在矩阵结构被压缩的情况下才能被调用。否则就没有太大意义了。    在当前情况下，它是子对象返回的数值之和。 
* [0.x.27]*
   打印矩阵的稀疏度。输出包括每行一行，格式为<tt>[i,j1,j2,j3,...]/tt>。[1.x.0]是行号，[1.x.1]是该行中分配的列。 
* [0.x.28]*
   以<tt>gnuplot</tt>理解的格式打印矩阵的稀疏度，可以用来以图形方式绘制稀疏度模式。这与通常的稀疏度模式实现的功能相同，见[2.x.7] 。  
* [0.x.29]*
   以<tt>svg</tt>格式打印矩阵的稀疏度。这与通常的稀疏度模式实现的功能相同，见[2.x.8] 。  
* [0.x.30]*
    [2.x.9] 例外 [2.x.10].   
* [0.x.31]*
   例外情况  
* [0.x.32]*
   异常情况  
* [0.x.33]*
   块的行数。 
* [0.x.34]*
   块的列数。 
* [0.x.35]*
   稀疏模式的阵列。 
* [0.x.36]*
   储存和管理行索引到子对象索引的转换的对象。 
* [0.x.37]*
   储存和管理列索引到子对象索引的转换的对象。 
* [0.x.38]*
   临时向量，用于计算在做集体添加或设置时写入各个块的元素。 
* [0.x.39]*
   临时向量，用于在每个稀疏矩阵上将局部数据写入全局数据时，每个块上的列索引。 
* [0.x.40]*
 这个类扩展了基类，实现了一个可以被块状稀疏矩阵对象使用的稀疏模式阵列。它只增加了一些额外的成员函数，但主要的接口源于基类，更多信息请看那里。
* 这个类是 [2.x.11] 的 "静态 "类型的一个例子。

* 
* [0.x.41]*
   初始化矩阵为空，也就是没有分配内存。如果你想让这样的对象作为其他类中的成员变量，这很有用。你可以通过调用reinit()函数使该结构可用。 
* [0.x.42]*
   用给定的块的行和列的数量初始化矩阵。  块本身仍然是空的，你必须在给它们分配尺寸后调用 collect_sizes()。 
* [0.x.43]*
   转发到[2.x.12]。  
* [0.x.44]*
   用两个BlockIndices初始化模式，用于矩阵行和列的块结构，以及一个行长向量。    行长向量应该是由DoFTools产生的格式。  另外，还有一个简化版本，每个内向量的长度为1。然后，相应的条目被用作最大的行长。    对于对角线块，内部SparsityPattern用优化的对角线初始化，而对于非对角线块则不这样做。 
* [0.x.45]*
   返回该结构是否被压缩，即所有子矩阵是否被压缩。 
* [0.x.46]*
   确定该对象的内存消耗（以字节为单位）的估计值。 
* [0.x.47]*
   从BlockDynamicSparsityPattern类型的对象中复制数据，即把这个对象的大小调整为给定参数的大小，并把每个子对象的内容复制过去。这个对象以前的内容会丢失。 
* [0.x.48]*
 这个类扩展了基类，实现了一个压缩稀疏模式的数组，可以用来初始化BlockSparsityPattern类型的对象。它没有增加额外的成员函数，而是作为一个[2.x.13]来介绍这个类的名称，而不要求用户指定基类的模板名称。关于这个类的接口的信息请参考基类。各个区块是基于DynamicSparsityPattern类的。
* 这个类是 [2.x.14] 的 "动态 "类型的一个例子。
* [1.x.2]
* 这个类的用法与DynamicSparsityPattern非常相似，但由于使用块索引会引起一些额外的复杂情况，我们举一个简短的例子。
* 在DoFHandler <tt>dof</tt>和AffineConstraints <tt>constraints</tt>已经设置了系统元素后，我们必须计算每个矩阵块中的自由度。
* 

* 
* [1.x.3]
* 
* 现在，我们准备设置BlockDynamicSparsityPattern。
* 

* 
* [1.x.4]
* 
* 它被填充，就像它是一个正常的模式一样
* 

* 
* [1.x.5]
* 
* 最后，它被复制到一个正常的BlockSparsityPattern中供以后使用。
* 

* 
* [1.x.6]
 

* 
* [0.x.49]*
   初始化矩阵为空，也就是没有分配内存。如果你想把这样的对象作为其他类中的成员变量，这是很有用的。你可以通过调用reinit()函数使该结构可用。 
* [0.x.50]*
   用给定的块的行和列的数量初始化矩阵。  块本身仍然是空的，你必须在给它们分配尺寸后调用 collect_sizes()。 
* [0.x.51]*
   用两个BlockIndices初始化模式，用于矩阵行和列的块结构。这个函数相当于用两个索引向量的长度调用前面的构造函数，然后输入索引值。 
* [0.x.52]*
   用对称块初始化模式。向量中IndexSets的数量决定了块的行和列的数量。每个块的大小由各自IndexSet的size()决定。  每个块只存储由IndexSet中的值给出的行，这对分布式内存并行计算很有用，通常对应于本地拥有的DoF。 
* [0.x.53]*
   用两个BlockIndices初始化模式，用于矩阵行和列的块结构。 
* [0.x.54]*
   将模式调整为由参数定义的尺寸的矩阵的张量乘积。    矩阵将有与两个参数中的条目一样多的块行和块列。在位置（[1.x.7]）的块将有<tt>row_block_sizes[i]</tt>乘以<tt>col_block_sizes[j]</tt>的尺寸。 
* [0.x.55]*
   用每个IndexSet的size()决定的对称块来调整模式的大小。详见接受一个IndexSets向量的构造函数。 
* [0.x.56]*
   将矩阵调整为由参数定义的尺寸的矩阵的张量积。两个BlockIndices对象必须被初始化，之后的稀疏模式将具有相同的块结构。 
* [0.x.57]*
   访问列号字段。返回第[2.x.15]行中第[2.x.16]个条目的列号。  
* [0.x.58]*
   也允许使用基类的 reinit 函数。 
* [0.x.59]!  [2.x.17] TrilinosWrappers [2.x.18]!   
* [0.x.60]*
   这个类扩展了基类，实现了一个Trilinos稀疏模式的数组，可以用来初始化Trilinos块状稀疏矩阵，可以分布在不同的处理器中。除了建立在[2.x.20]而不是[2.x.21]的基础上，它的使用方式与[2.x.19]相同。该类具有[2.x.22]的 "动态 "类型的属性（即如果分配的元素太少，它可以扩展内存），但其他方面更像基本的deal.II SparsityPattern（即在使用该模式之前需要调用compress()方法）。    这个类在 [2.x.23] 中使用。 
* [0.x.61]*
     初始化矩阵为空，也就是没有分配内存。如果你想让这样的对象作为其他类的成员变量，这很有用。    你可以通过调用reinit()函数使该结构可用。   
* [0.x.62]*
     用给定的块的行和列的数量初始化矩阵。    块本身仍然是空的，你必须在给它们分配尺寸后调用collect_sizes()。   
* [0.x.63]*
     用两个BlockIndices初始化模式，用于矩阵行和列的块结构。这个函数相当于用两个索引向量的长度调用前面的构造函数，然后输入索引值。   
* [0.x.64]*
     用一个索引集数组初始化模式，该数组指定了矩阵的行和列（所以最终的矩阵将是一个方形矩阵），其中IndexSets的size()指定了块的大小，每个IndexSet中的值表示每个块中要保存的行。   
* [0.x.65]*
     用两个指定矩阵的行和列的索引集数组初始化该模式，其中IndexSets的size()指定了块的大小，每个IndexSet中的值表示每个块中要保存的行。额外的索引集 writable_rows 用来设置所有我们允许本地写入的行。    这个构造函数用于创建允许多个线程同时向矩阵中写入的矩阵（当然是向不同的行写入），更多细节请参见方法[2.x.24]带有三个索引集参数的方法。   
* [0.x.66]*
     调整矩阵的大小，使其成为一个由参数定义的尺寸的矩阵的张量积。        矩阵将有与两个参数中的条目一样多的块行和块列。在位置（[1.x.8]）的块将有<tt>row_block_sizes[i]</tt>乘以<tt>col_block_sizes[j]</tt>的尺寸。   
* [0.x.67]*
     将矩阵调整为矩阵的平方张量积。详见接受一个IndexSets向量的构造函数。   
* [0.x.68]*
     将矩阵调整为一个矩形块状矩阵。这种方法允许行和列是不同的，在外部块结构和块内都是如此。   
* [0.x.69]*
     将矩阵调整为一个矩形块矩阵，进一步明确指定每个块中的可写行。这个方法用于创建允许几个线程同时向矩阵中写入的矩阵（当然是向不同的行写入），更多细节请参见方法[2.x.25]带有三个索引集参数的方法。   
* [0.x.70]*
     也允许使用基类的reinit函数。   
* [0.x.71]

