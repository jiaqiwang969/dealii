include/deal.II-translator/lac/ginkgo_solver_0.txt
[0.x.0]*
   该类构成了Ginkgo所有迭代求解器的基类。  各个派生类只接受特定于它们的额外数据，并解决给定的线性系统。Ginkgo实现的全部求解器集合可在[1.x.0]中找到。   
* [2.x.0]   
* [0.x.1]*
     构造器。        [2.x.1]定义了计算解决方案的范式。    它是一个字符串，可以选择 "OMP"、"参考 "或 "Cuda"。    各自的字符串创建各自的执行器，如下所述。        Ginkgo目前支持三种不同的执行器类型。        + OmpExecutor指定数据应被存储并在支持OpenMP的设备（如主机CPU）上执行相关操作； ``` auto omp = [2.x.2] ``` + CudaExecutor指定数据应被存储并在NVIDIA GPU加速器上执行操作； ``` [2.x.3] > 0 ) { auto cuda = [2.x.4] }     ``` + ReferenceExecutor执行一个非优化的引用实现，可用于调试库。    ``` auto ref = [2.x.5] ``` 下面的代码片段演示了使用OpenMP执行器来创建一个求解器，它将使用OpenMP范式在CPU上求解系统。        ``` auto omp = [2.x.6] using cg = [2.x.7] auto solver_gen = [2.x.8] .with_criteria( [2.x.9] [2.x.10 ].with_reduction_factor(1e-6) .on(mp)) .on(mp); auto solver = solver_gen->generate(system_matrix); solver->apply(lend(rhs), lend(solution)); `` [2.x.11] 对象与其他 deal.II迭代解算器相同。   
* [0.x.2]*
     解构器。   
* [0.x.3]*
     初始化矩阵并将其数据复制到Ginkgo的数据结构中。   
* [0.x.4]*
     解决线性系统<tt>Ax=b</tt>。根据派生类提供的信息，选择Ginkgo的一个线性求解器。   
* [0.x.5]*
     解决线性系统<tt>Ax=b</tt>。根据派生类提供的信息，选择Ginkgo的一个线性求解器。   
* [0.x.6]*
     访问控制收敛的对象。   
* [0.x.7]*
     对控制迭代求解器收敛性的对象的引用。   
* [0.x.8]*
     Ginkgo生成的求解器工厂对象。   
* [0.x.9]*
     残差准则对象，该对象根据solver_control成员中设置的容忍度来控制残差的减少。   
* [0.x.10]*
     Ginkgo收敛记录器，用于检查收敛情况和其他需要的求解器数据。   
* [0.x.11]*
     Ginkgo组合工厂对象用于创建一个组合停顿准则，以传递给求解器。   
* [0.x.12]*
     Ginkgo中的执行范式。可以在[2.x.12][2.x.13]和[2.x.14]之间选择，更多细节可以在Ginkgo的文档中找到。   
* [0.x.13]*
     用事件掩码初始化Ginkgo记录器对象。参照[1.x.1]。   
* [0.x.14]*
     Ginkgo矩阵数据结构。第一个模板参数是用于存储矩阵的非零点阵列。第二个是用于行指针和列索引。         [2.x.15] 基于矩阵类型的模板化。   
* [0.x.15]*
     执行范式为一个字符串，由用户设置。可以在`omp'、`cuda'和`reference'之间选择，更多细节可以在Ginkgo的文档中找到。   
* [0.x.16]*
   使用Ginkgo CG解算器的解算器接口的实现。   
* [2.x.16]   
* [0.x.17]*
     一个标准化的数据结构，用于向求解器输送额外的数据。   
* [0.x.18]*
     构造函数。         [2.x.17] solver_control 然后，求解器控制对象被用来设置参数，并从求解线性系统的CG工厂设置CG求解器。         [2.x.18] exec_type CG求解器的执行范式。         [2.x.19] data 解算器所需的额外数据。   
* [0.x.19]*
     构造器。         [2.x.20] solver_control 解算器控制对象然后用于设置参数，并从解算线性系统的CG工厂设置CG解算器。         [2.x.21] exec_type CG求解器的执行范式。         [2.x.22] preconditioner 解算器的预处理程序。         [2.x.23] data 解算器所需的额外数据。   
* [0.x.20]*
     存储该特定求解器的设置副本。   
* [0.x.21]*
   使用Ginkgo Bicgstab解算器的解算器接口的实现。   
* [2.x.24]   
* [0.x.22]*
     一个标准化的数据结构，用于向求解器输送额外的数据。   
* [0.x.23]*
     构造函数。         [2.x.25] solver_control 然后，求解器控制对象被用来设置参数，并从Bicgstab工厂设置Bicgstab求解器，从而求解线性系统。         [2.x.26] exec_type Bicgstab求解器的执行范式。         [2.x.27] data 解算器所需的额外数据。   
* [0.x.24]*
     构造器。         [2.x.28] solver_control 解算器控制对象然后用于设置参数，并从Bicgstab工厂设置Bicgstab解算器，该解算器解决线性系统。         [2.x.29] exec_type Bicgstab求解器的执行范式。         [2.x.30] preconditioner 解算器的预处理程序。         [2.x.31] data 解算器所需的额外数据。   
* [0.x.25]*
     存储该特定求解器的设置副本。   
* [0.x.26]*
   使用Ginkgo CGS求解器的求解器接口的实现。    CGS或共轭梯度平方法是一种迭代型Krylov子空间方法，适用于一般系统。   
* [2.x.32]   
* [0.x.27]*
     一个标准化的数据结构，用于向求解器输送额外的数据。   
* [0.x.28]*
     构造器。         [2.x.33] solver_control 然后，求解器控制对象被用来设置参数，并从CGS工厂设置CGS求解器，从而求解线性系统。         [2.x.34] exec_type CGS求解器的执行范式。         [2.x.35] data 解算器所需的额外数据。   
* [0.x.29]*
     构造器。         [2.x.36] solver_control 解算器控制对象，然后用于设置参数，并从CGS工厂设置CGS解算器，解算线性系统。         [2.x.37] exec_type CGS求解器的执行范式。         [2.x.38] preconditioner 解算器的预处理程序。         [2.x.39] data 解算器所需的额外数据。   
* [0.x.30]*
     存储该特定求解器的设置副本。   
* [0.x.31]*
   使用Ginkgo FCG求解器的求解器接口的实现。    FCG或灵活共轭梯度法是一种迭代型Krylov子空间方法，适用于对称正定法。    虽然这种方法对对称正定矩阵表现非常好，但一般来说，它不适合一般的矩阵。    与基于Polack-Ribiere公式的标准CG相比，灵活的CG使用Fletcher-Reeves公式来创建跨越Krylov子空间的正态向量。这增加了每个Krylov求解器迭代的计算成本，但允许使用非恒定的预处理程序。   
* [2.x.40]   
* [0.x.32]*
     一个标准化的数据结构，用于向求解器输送额外的数据。   
* [0.x.33]*
     构造器。         [2.x.41] solver_control 然后，求解器控制对象被用来设置参数，并从FCG工厂设置FCG求解器，该求解器解决线性系统。         [2.x.42] exec_type FCG求解器的执行范式。         [2.x.43] data 解算器所需的额外数据。   
* [0.x.34]*
     构造器。         [2.x.44] solver_control 解算器控制对象，然后用于设置参数，并从FCG工厂设置FCG解算器，解算线性系统。         [2.x.45] exec_type FCG求解器的执行范式。         [2.x.46] preconditioner 解算器的预处理程序。         [2.x.47] data 解算器所需的额外数据。   
* [0.x.35]*
     存储该特定求解器的设置副本。   
* [0.x.36]*
   使用Ginkgo GMRES求解器的求解器接口的实现。   
* [2.x.48]   
* [0.x.37]*
     一个标准化的数据结构，用于向求解器输送额外的数据。   
* [0.x.38]*
       构造函数。默认情况下，设置临时向量的数量为30，即每30次迭代做一次重启。     
* [0.x.39]*
       临时向量的最大数量。     
* [0.x.40]*
     构造函数。         [2.x.49] solver_control 然后，求解器控制对象被用来设置参数，并从GMRES工厂设置GMRES求解器，求解线性系统。         [2.x.50] exec_type GMRES求解器的执行范式。         [2.x.51] data 解算器所需的额外数据。   
* [0.x.41]*
     构造器。         [2.x.52] solver_control 解算器控制对象然后用于设置参数，并从GMRES工厂设置GMRES解算器，该解算器解决线性系统。         [2.x.53] exec_type GMRES求解器的执行范式。         [2.x.54] preconditioner 解算器的预处理程序。         [2.x.55] data 解算器所需的额外数据。   
* [0.x.42]*
     存储该特定求解器的设置副本。   
* [0.x.43]*
   使用Ginkgo IR求解器的求解器接口的实现。    迭代细化（IR）是一种迭代方法，它使用另一种粗略的方法，通过当前的残差对当前解的误差进行近似。   
* [2.x.56]   
* [0.x.44]*
     一个标准化的数据结构，用于向求解器输送额外的数据。   
* [0.x.45]*
     构造函数。         [2.x.57] solver_control 然后，求解器控制对象被用来设置参数，并从解决线性系统的IR工厂设置IR求解器。         [2.x.58] exec_type 红外求解器的执行范式。         [2.x.59] data 解算器所需的额外数据。   
* [0.x.46]*
     构造器。         [2.x.60] solver_control 然后，求解器控制对象被用来设置参数，并从求解线性系统的IR工厂设置IR求解器。         [2.x.61] exec_type 红外求解器的执行范式。         [2.x.62] inner_solver 用于IR求解器的内部求解器。         [2.x.63] data 解算器所需的额外数据。   
* [0.x.47]*
     存储该特定求解器的设置副本。   
* [0.x.48]

