include/deal.II-translator/lac/trilinos_tpetra_vector_0.txt
[0.x.0]*
   一个命名空间，用于为Trilinos的Tpetra向量提供包装器的类。    这个命名空间为Tpetra包（https://trilinos.github.io/tpetra.html）中的[2.x.0]类提供包装器，它是Trilinos的一部分。 
* [0.x.1]*
     该类实现了对Trilinos分布式向量类[2.x.1]的包装器，该类源自[2.x.2]类，需要Trilinos在编译时支持MPI。        Tpetra使用Kokkos进行线程并行，并根据Kokkos的配置自动选择执行和内存空间。优先级从高到低排列。
* 

* 
* 

* 
* 

 
 

 
 

 
* 
* - [2.x.3] 
 

* 
* 

* 
 

 
 

 
 

 
* 
* - [2.x.4] 
 

* 
* 

* 
 

 
 

 
 

 
* 
* - [2.x.5] 
 

* 
* 

* 
* 

 
 

 
 

 
* 
* - [2.x.6] 如果Kokkos被配置为支持CUDA，该类将数值存储在统一的虚拟内存空间，并在GPU上执行其动作。特别是，不需要在主机和设备之间手动同步内存。       
* [2.x.7]     
* [2.x.8]     
* [0.x.2]*
       构造函数。创建一个维度为0的向量。     
* [0.x.3]*
       复制构造函数。将维数和分区设置为给定的向量，并复制所有的元素。     
* [0.x.4]*
       这个构造函数接收一个IndexSet，它定义了如何在MPI处理器之间分配各个组件。由于它还包括关于向量大小的信息，这就是我们生成一个%并行向量所需要的全部内容。     
* [0.x.5]*
       Reinit功能。这个功能销毁了旧的向量内容，并根据输入的分区生成一个新的向量。标志<tt>omit_zeroing_entries</tt>决定了向量是否应该被填入零（false）或不被触动（true）。     
* [0.x.6]*
       将尺寸改为向量的尺寸 [2.x.9] [2.x.10]的元素不被复制。     
* [0.x.7]*
       复制函数。这个函数接收一个Vector并复制所有的元素。该向量将具有与[2.x.11] V相同的平行分布。     
* [0.x.8]*
       将向量的所有元素设置为标量[2.x.12] 这个操作只有在[2.x.13]等于零时才允许。     
* [0.x.9]*
       从输入向量[2.x.14][2.x.15][2.x.16]中导入向量的IndexSet中存在的所有元素，用于决定[2.x.17]中的元素是否应该被添加到当前向量中，或者替换当前元素。如果多次使用同一通信模式，可以使用最后一个参数。这可以用来提高性能。     
* [0.x.10]*
       将整个向量乘以一个固定系数。     
* [0.x.11]*
       将整个向量除以一个固定的因子。     
* [0.x.12]*
       将向量[2.x.18]添加到现在的向量中。     
* [0.x.13]*
       从现在的向量中减去向量[2.x.19]。     
* [0.x.14]*
       返回两个向量的标量乘积。这些向量需要有相同的布局。     
* [0.x.15]*
       将[2.x.20]添加到所有组件中。注意，[2.x.21]是一个标量而不是一个向量。     
* [0.x.16]*
       一个向量的倍数的简单加法，即<tt>*this += a*V</tt>。向量需要有相同的布局。     
* [0.x.17]*
       一个向量的多个加法，即：<tt>*this> += a*V+b*W</tt>。向量需要有相同的布局。     
* [0.x.18]*
       缩放和一个向量的倍数的简单相加，即<tt>*this=s*(*this)+a*V</tt>。     
* [0.x.19]*
       用参数中的相应元素来缩放这个向量的每个元素。这个函数主要是为了模拟对角线缩放矩阵的乘法（和立即重新分配）。这些向量需要有相同的布局。     
* [0.x.20]*
       赋值 <tt>*this = a*V</tt>.      
* [0.x.21]*
       返回向量是否只包含值为0的元素。     
* [0.x.22]*
       返回这个向量的元素的平均值。     
* [0.x.23]*
       返回该向量的l<sub>1</sub>准则（即所有处理器中所有条目的绝对值之和）。     
* [0.x.24]*
       返回向量的l<sub>2</sub>准则（即所有处理器中所有条目的平方之和的平方根）。     
* [0.x.25]*
       返回向量的最大规范（即所有条目和所有处理器之间的最大绝对值）。     
* [0.x.26]*
       执行一个向量加法和随后的内积的组合操作，返回内积的值。换句话说，这个函数的结果与用户调用的      
* [1.x.0]
* 这个函数存在的原因是这个操作比单独调用这两个函数涉及的内存转移要少。这个方法只需要加载三个向量，[2.x.22] [2.x.23] [2.x.24]，而调用单独的方法意味着要加载调用向量[2.x.25]两次。由于大多数向量操作都有内存传输限制，这就使时间减少了25\%（如果[2.x.26]等于[2.x.27]，则减少50\%）。 向量需要有相同的布局。            对于复值向量，第二步中的标量乘积被实现为[2.x.28] 。     
* [0.x.27]*
       这个函数总是返回false，它的存在只是为了向后兼容。     
* [0.x.28]*
       返回向量的全局大小，等于所有处理器中本地拥有的索引数之和。     
* [0.x.29]*
       返回向量的本地大小，即本地拥有的索引数。     
* [0.x.30]*
       返回与此对象一起使用的MPI通信器对象。     
* [0.x.31]*
       返回一个索引集，描述这个向量的哪些元素是由当前处理器拥有的。因此，如果这是一个分布式向量，在不同处理器上返回的索引集将形成不相干的集合，加起来就是完整的索引集。很明显，如果一个向量只在一个处理器上创建，那么结果将满足      
* [1.x.1]
*       
* [0.x.32]*
       返回一个对底层Trilinos [2.x.29]类的常量引用。     
* [0.x.33]*
       返回对底层Trilinos[2.x.30]类的（可修改的）引用。     
* [0.x.34]*
       将向量打印到输出流[2.x.31]。      
* [0.x.35]*
       以字节为单位返回这个类的内存消耗。     
* [0.x.36]*
       向量有不同的分区，即它们的IndexSet对象不代表相同的指数。     
* [0.x.37]*
       试图在两个不兼容的向量类型之间执行操作。           
* [2.x.32]       
* [0.x.38]*
       在Trilinos中被错误抛出的异常。           
* [2.x.33]       
* [0.x.39]*
       根据通信器[2.x.35]为IndexSet[2.x.34]和当前向量之间的通信创建通信模式。      
* [0.x.40]*
       指向实际Tpetra向量对象的指针。     
* [0.x.41]*
       最后导入的矢量元素的索引集。     
* [0.x.42]*
       Source_stored_elements IndexSet和当前向量之间的通信模式。     
* [0.x.43]*
 将[2.x.36]声明为分布式向量。

* 
* [0.x.44]

