include/deal.II-translator/lac/vector_space_vector_0.txt
[0.x.0]!  [2.x.0]矢量 [2.x.1]!   
* [0.x.1]*
   VectorSpaceVector是一个抽象类，用于定义向量类在想要实现全局操作时需要实现的接口。这个类是ReadWriteVector的补充，它允许访问单个元素，但不允许全局操作。 
* [0.x.2]*
     将维度改为向量V的维度，V的元素不会被复制。   
* [0.x.3]*
     将向量的所有元素设置为标量[2.x.2]，只有当[2.x.3]等于零时，才允许该操作。   
* [0.x.4]*
     将整个向量乘以一个固定系数。   
* [0.x.5]*
     用整个向量除以一个固定的因子。   
* [0.x.6]*
     将向量[2.x.4]添加到现在的向量中。   
* [0.x.7]*
     从现在的向量中减去向量[2.x.5]。   
* [0.x.8]*
     从输入向量[2.x.6][2.x.7][2.x.8]中导入向量的IndexSet中存在的所有元素，用于决定[2.x.9]中的元素是否应该添加到当前向量中，或者替换当前元素。如果多次使用同一通信模式，可以使用最后一个参数。这可以用来提高性能。   
* [0.x.9]*
     返回两个向量的标量乘积。   
* [0.x.10]*
     将[2.x.10]添加到所有组件中。注意[2.x.11]是一个标量而不是一个向量。   
* [0.x.11]*
     矢量的倍数的简单加法，即：<tt>*this += a*V</tt>。   
* [0.x.12]*
     缩放向量的多重加法，即<tt>*this += a*V+b*W</tt>。   
* [0.x.13]*
     缩放和简单的向量倍数加法，即<tt>*this = s*(*this)+a*V</tt>。   
* [0.x.14]*
     用参数中的相应元素来缩放这个向量的每个元素。这个函数主要是为了模拟对角线缩放矩阵的乘法（和立即重新分配）。   
* [0.x.15]*
     赋值 <tt>*this = a*V</tt>.    
* [0.x.16]*
     返回向量是否只包含值为0的元素。   
* [0.x.17]*
     返回这个向量的所有条目的平均值。   
* [0.x.18]*
     返回该向量的l<sub>1</sub>准则（即所有条目在所有处理器中的绝对值之和）。   
* [0.x.19]*
     返回向量的l<sub>2</sub>准则（即所有处理器中所有条目的平方之和的平方根）。   
* [0.x.20]*
     返回向量的最大规范（即所有条目和所有处理器之间的最大绝对值）。   
* [0.x.21]*
     执行一个向量加法和后续内积的组合操作，返回内积的值。换句话说，这个函数的结果与用户调用的    
* [1.x.0]
* 这个函数存在的原因是这个操作比单独调用这两个函数涉及的内存转移要少。这个方法只需要加载三个向量，[2.x.12] [2.x.13] [2.x.14]，而调用单独的方法意味着要加载调用向量[2.x.15]两次。由于大多数向量操作都有内存传输限制，这就使时间减少了25\%（如果[2.x.16]等于[2.x.17]，则减少50\%）。 对于复值向量，第二步的标量乘法实现为[2.x.18] 。   
* [0.x.22]*
     这个函数什么都不做，只是为了向后兼容而存在。   
* [0.x.23]*
     返回向量的全局大小，等于所有处理器中本地拥有的索引数之和。   
* [0.x.24]*
     返回一个索引集，描述这个向量的哪些元素是由当前处理器拥有的。因此，如果这是一个分布式向量，在不同处理器上返回的索引集将形成不相交的集合，加起来就是完整的索引集。很明显，如果一个向量只在一个处理器上创建，那么结果将满足    
* [1.x.1]
*     
* [0.x.25]*
     将向量打印到输出流中 [2.x.19] 。    
* [0.x.26]*
     以字节为单位返回这个类的内存消耗。   
* [0.x.27]*
     解构器。声明为虚拟，以便继承类（可能管理自己的内存）被正确销毁。   
* [0.x.28]*
   将向量的所有条目移动一个常数因子，使向量的平均值变为零。 
* [0.x.29]

