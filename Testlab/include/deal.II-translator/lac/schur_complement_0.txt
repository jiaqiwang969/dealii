include/deal.II-translator/lac/schur_complement_0.txt
[0.x.0]*
  [2.x.0] 创建一个与舒尔补码有关的LinearOperator

* 
* [0.x.1]*
  [2.x.1] LinearOperator
* 返回一个LinearOperator，执行与Schur补数相关的操作。有两个额外的辅助函数，condense_schur_rhs()和postprocess_schur_solution()，为了用这个操作符在线性代数中执行任何有用的任务，很可能需要使用这些函数。
* 我们以如下方式构建Schur补码的定义。
* 考虑一个一般的线性方程组，它可以被分解成两个主要的方程组。[1.x.0]
* 其中[2.x.2]代表矩阵[2.x.3]的一般子块，同样地，[2.x.4]的一般子向量由[2.x.5]给出。
* 这等同于以下两个声明。[1.x.1]
* 
* 假设[2.x.6]既是正方形又是可倒置的，那么我们可以进行两种可能的替换，[1.x.2] 。
* 这相当于对这个方程组进行块状高斯消除。
* 就目前的实现而言，我们选择将（3）代入（2）[1.x.3]。
* 这导致了结果[1.x.4]，其中[2.x.7]是舒尔补数，而修改后的右手边矢量[2.x.8]则来自凝结步骤。请注意，对于[2.x.9]的这种选择，子矩阵[2.x.10]不需要是可逆的，因此可能是空矩阵。理想情况下[2.x.11]应该是条件良好的。
* 所以对于任何任意矢量[2.x.12]，舒尔补码进行以下操作。[1.x.5]
* 一个典型的解决线性系统(1),(2)所需的步骤集是。1. 定义逆矩阵 [2.x.13] （使用inverse_operator()）。2. 2. 定义舒尔补码[2.x.14]（使用schur_complement()）。3. 定义迭代逆矩阵[2.x.15]，使(6)成立。有必要使用带有预处理程序的求解器来计算[2.x.16]的近似逆运算，因为我们从未直接计算[2.x.17]，而是计算其运算的结果。为了实现这一点，可以再次使用inverse_operator()与我们刚刚构建的Schur补码结合起来。请注意，[2.x.18]和它的预处理程序都是在与[2.x.19]相同的空间内运行的。4. 4. 使用 condense_schur_rhs() 对(5)的RHS进行预处理步骤。   [1.x.6] 5. 求解（5）中的[2.x.20]。   [1.x.7] 6. 使用postprocess_schur_solution()执行（3）中的后处理步骤。   [1.x.8]
* 下面给出了该算子在全耦合系统中的典型用法说明。

* 
* [1.x.9]
* 
* 在上面的例子中，[2.x.21]的预处理器被定义为[2.x.22]的预处理器，这是有效的，因为它们在同一空间内运行。然而，如果[2.x.23]和[2.x.24]太不相似，那么这可能导致大量的求解器迭代，因为[2.x.25]不是[2.x.26]的良好近似。
* 在这种情况下，更好的预处理程序是为[2.x.27]提供更具代表性的近似。一种方法显示在[2.x.28]中，其中[2.x.29]是空矩阵，[2.x.30]的预处理器是由这个空间的质量矩阵导出的。
* 从另一个角度来看，类似的结果可以通过首先构造一个代表[2.x.31]的近似对象来实现，其中昂贵的操作，即[2.x.32]，被近似。此后，我们构建近似的反算子[2.x.33]，然后将其作为计算[2.x.34]的前提条件。

* 
* [1.x.10]
* 请注意，由于构建[2.x.35] S_inv_approx和随后的[2.x.36] S_inv，有一对嵌套的迭代求解器，可能会共同消耗大量的资源。因此，在构建迭代逆运算器的过程中，应该注意选择。我们可以考虑使用IterationNumberControl（或类似的机制）来限制内部求解器的迭代次数。这可以控制近似逆运算[2.x.37]的精度，该运算仅作为[2.x.38]的预处理程序发挥作用。此外，[2.x.39]的先决条件，在本例中是[2.x.40]，理想情况下应该是计算成本低的。
* 然而，如果使用基于IterationNumberControl的迭代求解器作为预处理器，那么预处理操作就不是线性操作了。这里最好采用SolverFGMRES（灵活的GMRES）这样的灵活求解器作为外部求解器，以处理预处理器的可变行为。否则，迭代求解器可能会在预处理器的容忍度附近停滞不前，或者普遍表现得不稳定。另外，使用ReductionControl可以确保前置条件器总是以相同的容差进行求解，从而使其行为恒定。
* 这种功能的更多例子可以在测试套件中找到，如 [2.x.41] 。使用schur_complement解决一个多组件问题（即 [2.x.42] ），可以在 [2.x.43] 中找到。
* [2.x.44] [2.x.45] "块（线性代数）"
* 

* 
* [2.x.46] 

 
* [0.x.2]*
  [2.x.47] 创建与舒尔补数有关的打包操作对象

 
* [0.x.3]*
  [2.x.48] 打包操作（PackagedOperation
* 对于方程组[1.x.11]来说
* 该操作对RHS子向量[2.x.49]进行预处理（凝结）步骤，以便舒尔补码可以用来解决这个方程组。更具体地说，它产生一个对象，代表子向量[2.x.50]的浓缩形式，即[1.x.12] 。
* [2.x.51] [2.x.52] "块（线性代数）"
* 

* 
* [2.x.53] 

 
* [0.x.4]*
  [2.x.54] 打包操作
* 对于方程组[1.x.13]来说
*该操作执行舒尔补码的后处理步骤，在已知子向量[2.x.56]的情况下求解第二个子向量[2.x.55]，其结果是[1.x.14]
* [2.x.57] [2.x.58] "块（线性代数）"
* 

* 
* [2.x.59] 

 
* [0.x.5]

