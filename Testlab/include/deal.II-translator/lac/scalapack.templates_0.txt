include/deal.II-translator/lac/scalapack.templates_0.txt
[0.x.0]*
   确定有多少进程可用以及当前的进程等级。https://www.ibm.com/support/knowledgecenter/en/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_dbpnf.htm。 
* [0.x.1]*
   根据输入的[2.x.1]和[2.x.2]返回[2.x.0]中的内部BLACS值。最常见的用途是检索默认的系统上下文（[2.x.3]=0，[2.x.4]被忽略），用于BLACS_GRIDINIT或BLACS_GRIDMAP。 https://www.ibm.com/support/knowledgecenter/en/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_dbget.htm  
* [0.x.2]*
   以行为主或列为主的顺序将进程映射到进程网格中。每个进程的输入参数必须是相同的。    在返回时，[2.x.5]是BLACS上下文的整数句柄，而在进入时，它是一个系统上下文，用于创建BLACS上下文。https://www.ibm.com/support/knowledgecenter/en/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_dbint.htm  
* [0.x.3]*
   返回进程的行和列索引。https://www.ibm.com/support/knowledgecenter/en/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_dbinfo.htm  
* [0.x.4]*
   给出系统进程号，返回BLACS的进程网格中的行和列坐标。 
* [0.x.5]*
   释放一个BLACS上下文。 
* [0.x.6]*
   该例程将暂停执行指定范围内的所有进程，直到它们全部调用该例程。 
* [0.x.7]*
   释放所有BLACS上下文并释放所有分配的内存。 
* [0.x.8]*
   从进程[2.x.6][2.x.7]接收一个信息，将其转化为一般的矩形矩阵。https://software.intel.com/en-us/mkl-developer-reference-c-gerv2d。 
* [0.x.9]*
   将一般矩形矩阵A发送到进程网格中的目标进程[2.x.8] [2.x.9]。https://software.intel.com/en-us/mkl-developer-reference-c-2018-beta-gesd2d  
* [0.x.10]*
   从MPI获取BLACS上下文 [2.x.10] 。  
* [0.x.11]*
   计算每个进程拥有多少行和列（NUMber of Rows Or Columns）。https://www.ibm.com/support/knowledgecenter/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_dnumy.htm  
* [0.x.12]*
   计算N乘N实数对称正定分布矩阵sub( A )的Cholesky分解，表示A(IA:IA+N-1, JA:JA+N-1)。http://www.netlib.org/scalapack/explore-html/d5/d9e/pdpotrf_8f_source.html https://www.ibm.com/support/knowledgecenter/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_lpotrf.htm  
* [0.x.13]*
   计算一般分布式矩阵sub( A )的LU因式分解，使用部分枢轴和行互换。http://www.netlib.org/scalapack/explore-html/df/dfe/pdgetrf_8f_source.html https://www.ibm.com/support/knowledgecenter/en/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_lgetrf.htm  
* [0.x.14]*
   使用PDPOTRF计算的Cholesky因式分解sub( A ) = U**T*U或L*L**T，计算实对称正定分布矩阵sub( A ) = A(IA:IA+N-1,JA:JA+N-1)的逆。http://www.netlib.org/scalapack/explore-html/d2/d44/pdpotri_8f_source.html https://www.ibm.com/support/knowledgecenter/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_lpotri.htm https://software.intel.com/en-us/mkl-developer-reference-c-p-potri  
* [0.x.15]*
   PDGETRI使用PDGETRF计算的LU因子化来计算分布式矩阵的逆。该方法反转U，然后通过求解InvA的系统InvA*L=inv(U)，计算sub( A )=A(IA:IA+N-1,JA:JA+N-1)的反，表示InvA。 http://www.netlib.org/scalapack/explore-html/d3/df3/pdgetri_8f_source.html https://www.ibm.com/support/knowledgecenter/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_lgetri.htm  
* [0.x.16]*
   PDTRTRI计算上或下三角分布矩阵sub( A ) = A(IA:IA+N-1,JA:JA+N-1)的逆。http://www.netlib.org/scalapack/explore-html/d9/dc0/pdtrtri_8f_source.html https://www.ibm.com/support/knowledgecenter/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_lpdtri.htm https://software.intel.com/en-us/mkl-developer-reference-c-p-trtri  
* [0.x.17]*
   使用Cholesky分解法估计实数对称正定分布矩阵的条件数的倒数(l1-norm)。 https://www.ibm.com/support/knowledgecenter/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_lpocon.htm#lpocon http://www.netlib.org/scalapack/explore-html/d4/df7/pdpocon_8f.html https://software.intel.com/en-us/mkl-developer-reference-fortran-pocon  
* [0.x.18]*
   实对称矩阵的准则 http://www.netlib.org/scalapack/explore-html/dd/d12/pdlansy_8f_source.html https://www.ibm.com/support/knowledgecenter/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_pdlansy.htm#pdlansy  
* [0.x.19]*
   计算两个正整数[2.x.11]和[2.x.12]的最小公倍数（LCM） 事实上，该例程计算最大公除数（GCD），并利用M*N=GCD*LCM的事实。http://www.netlib.org/scalapack/explore-html/d0/d9b/ilcm_8f_source.html  
* [0.x.20]*
   返回两个整数的除法的上限。http://www.netlib.org/scalapack/explore-html/df/d07/iceil_8f_source.html  
* [0.x.21]*
   用8个输入参数初始化描述符向量  
* [0.x.22]*
   计算由[2.x.14]所示进程的本地索引[2.x.13]指向的分布式矩阵条目的全局索引 [2.x.15] indxloc 分布式矩阵条目的本地索引。   [2.x.16] nb 块大小，分布式矩阵被分割成的块的大小。   [2.x.17] iproc 要确定其本地数组行或列的进程的坐标 [2.x.18] isrcproc 拥有分布式矩阵第一行/列的进程的坐标 [2.x.19] nprocs 分布式矩阵的总进程数  
* [0.x.23]*
   计算一个实数线性方程组的解  
* [0.x.24]*
   执行矩阵-矩阵操作中的一个。 
* [1.x.0]
* 其中[2.x.20]表示C(IC:IC+M-1,JC:JC+N-1)，并且，[2.x.21]是[2.x.22]或[2.x.23]之一。 
* [0.x.25]*
   返回一准则的值，或弗罗本纽斯准则，或无穷大准则，或分布式矩阵的最大绝对值元素。 
* [0.x.26]*
   计算拥有由全局索引指定的分布式矩阵的条目的过程坐标  
* [0.x.27]*
   通过调用推荐的ScaLAPACK程序序列，计算实数对称矩阵A的所有特征值和可选的特征向量。在目前的形式下，该例程假定是一个同质系统，并且不检查不同进程中的特征值或特征向量的一致性。正因为如此，异质系统有可能在没有任何错误信息的情况下返回不正确的结果。http://www.netlib.org/scalapack/explore-html/d0/d1a/pdsyev_8f.html https://www.ibm.com/support/knowledgecenter/SSNR5K_4.2.0/com.ibm.cluster.pessl.v4r2.pssl100.doc/am6gr_lsyev.htm#lsyev  
* [0.x.28]*
   将一个分布式矩阵A的全部或部分复制到另一个分布式矩阵B。不进行通信，pdlacpy执行本地复制 [2.x.24] ，其中 [2.x.25] 表示 [2.x.26] ， [2.x.27] 表示 [2.x.28] 。 
* [0.x.29]*
   将一般矩形分布式矩阵[2.x.29]的内容复制到另一个分布式矩阵[2.x.30] 不要求矩阵A和B具有相同的进程网格或块大小，例如，将矩阵从一维进程网格复制到二维进程网格[2.x.31]的上下文至少是上下文A和B中所有进程的联合。 
* [0.x.30]*
   确定机器精度的辅助程序  
* [0.x.31]*
    psyevx计算一个实数对称矩阵A的选定的特征值和可选的特征向量。可以通过指定所需特征值的数值范围或指数范围来选择特征值/向量。 
* [0.x.32] PDGESVD计算M乘N矩阵A的奇异值分解（SVD），可以选择计算左和/或右奇异向量  
* [0.x.33] P_GELS使用A的QR或LQ因子化，解决涉及M乘N矩阵A或其转置的过定或欠定实数线性系统，假定A具有全秩。 
* [0.x.34] 进行矩阵求和。  [1.x.1]
* 其中[2.x.32]表示[2.x.33]或[2.x.34] 。 
* [0.x.35]*
   对一个矩阵进行转置的程序。  C = beta C + alpha A^T  
* [0.x.36]*
    psyevr使用MRR算法的并行实现，计算实数对称矩阵A的选定特征值和可选的特征向量。特征值/向量可以通过指定所需特征值的数值范围或指数范围来选择。 
* [0.x.37] 在下面的内容中，我们为ScaLAPACK例程提供了模板包装器，其他数字类型的包装器可以在将来添加。

* 
* [0.x.38] Netlib ScaLAPACK在调用pdsyevr时进行浮点测试（例如除以零），导致浮点异常被抛出（至少在调试模式下）。因此，我们把对pdsyevr的调用包装成以下代码，以抑制异常。 
* [0.x.39] Netlib ScaLAPACK在调用pssyevr时进行浮点测试（例如除以零），导致浮点异常被抛出（至少在调试模式下）。因此，我们把对pssyevr的调用包装成以下代码，以抑制异常。 
* [0.x.40]

