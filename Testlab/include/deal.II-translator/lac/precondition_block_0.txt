include/deal.II-translator/lac/precondition_block_0.txt
[0.x.0]!  [2.x.0] 先决条件 [2.x.1] 。

 
* [0.x.1]*
 实际块状预处理程序的基类。该类假设<tt>MatrixType</tt>由对角线上的[2.x.2]的可逆块组成，并提供矩阵对角线块的反转。对于这个类来说，矩阵不一定是块状对角线；相反，它适用于任意结构的矩阵，其最小属性是在对角线上有可逆块。但是，该矩阵必须能够访问单个矩阵条目。因此，BlockMatrixArray和类似的类不是一个可能的矩阵类模板参数。
* 这个类所使用的块状矩阵结构是给定的，例如，对于传输方程的DG方法。对于一个下游的编号，矩阵甚至已经得到了一个块状的左下角矩阵结构，也就是说，矩阵在对角线块的上方是空的。
* 

* 
* [2.x.3] 该类旨在用于矩阵，其结构是由来自不相交的单元的局部贡献给出的，例如用于DG方法。它不适用于块结构由不同的物理变量产生的问题，如[2.x.4]中考虑的斯托克斯方程。
* 对于所有对角线块上方和下方为空的矩阵（即所有块状对角线矩阵），[2.x.5]预调节器是一个直接求解器。对于所有只在对角线块上方为空的矩阵（例如通过下游编号的DG方法得到的矩阵），[2.x.6]是一个直接求解器。
* [2.x.7]的第一个实现是假设矩阵有相同块大小的块。如果需要的话，矩阵内不同的块大小仍然必须被实现。
* 第一个模板参数表示稀疏矩阵中的数字表示类型，第二个表示数字表示类型，在这个类中通过<tt>invert_diagblocks()</tt>存储倒置的对角块矩阵。如果你不想把块反转作为一个精确的求解器，而是作为一个预处理器，你可能想用比原始矩阵更低的精度来存储反转的块；例如，<tt>number==double, inverse_type=float</tt>可能是一个可行的选择。
* [2.x.8] [2.x.9] "块（线性代数）"

* 
* [0.x.2]*
   定义矩阵的数字类型。 
* [0.x.3]*
   逆矩阵的数值类型。 
* [0.x.4]*
   声明容器大小的类型。 
* [0.x.5]*
   块状预处理程序的参数。 
* [0.x.6]*
     构造器。由于没有合理的默认参数，必须给出块的大小。   
* [0.x.7]*
     松弛参数。   
* [0.x.8]*
     区块大小。   
* [0.x.9]*
     在初始化过程中反转对角线。   
* [0.x.10]*
     假设所有的对角线块都相等以节省内存。   
* [0.x.11]*
     选择块的反转方法。   
* [0.x.12]*
     如果#反转是SVD，那么低于这个阈值的奇异值将被视为零，从而不被反转。这个参数在调用[2.x.10]时使用。    
* [0.x.13]*
   构造函数。 
* [0.x.14]*
   解构器。 
* [0.x.15]*
   初始化矩阵和块大小。 我们将矩阵和块的大小存储在预处理对象中。在第二步中，可以计算对角线块的倒数。    此外，可以提供派生类的松弛参数。 
* [0.x.16]*
   初始化矩阵和块的大小，以便进行渗透式预处理。  除了其他initialize()函数的参数外，我们还交出两个索引向量，其中包括包络和它的逆向。关于这些向量的含义，见PreconditionBlockSOR。    在第二步中，可以计算对角线块的倒数。  请确保你使用invert_permuted_diagblocks()来产生一致的数据。    此外，还可以为派生类提供一个放松参数。 
* [0.x.17]*
   根据向量的大小，设置行的permutation或者块的permutation。    如果置换向量的大小等于线性系统的维度，则假定行是单独置换的。在这种情况下，set_permutation()必须在initialize()之前调用，因为对角线块是由矩阵的permuted条目建立的。    如果置换向量的大小不等于系统的维度，对角线块将从未置换的条目中计算出来。  相反，松弛方法step()和Tstep()会按照排列向量给出的顺序应用这些块。如果这个向量的长度不等于块的数量，它们将抛出一个异常。   
* [2.x.11] 块的排列只能应用于松弛运算符step()和Tstep()，不能应用于预处理运算符vmult()和Tvmult()。   
* [2.x.12]在initialize()之前调用set_permutation()是安全的，而其他顺序只允许用于块的permutation。 
* [0.x.18]*
   替换invert_diagblocks()用于包络预处理。 
* [0.x.19]*
   如果存在的话，删除反对角线块矩阵，将块大小设置为0，从而使该类处于调用构造函数后的直接状态。 
* [0.x.20]*
   检查对象是否为空。 
* [0.x.21]*
   对条目进行只读访问。这个功能只有在反对角线块被存储的情况下才能实现。 
* [0.x.22]*
   在[2.x.13]中存储对角线块的倒数 这需要花费一些额外的内存
* 
* - 对于DG方法来说，大约是用于矩阵的1/3（用于双倍反演）或1/6（用于浮点反演）。
* 
* 但它使预处理的速度大大加快。    在调用<tt>clear(...)</tt>之前，不允许两次调用这个函数（会产生一个错误），因为在第二次调用时，已经存在逆矩阵。    在这个函数被调用后，通过[2.x.14]函数给出的矩阵的锁被释放，也就是说，你可以覆盖或删除它。  你可能想这样做，以防你用这个矩阵作为另一个矩阵的前提条件。 
* [0.x.23]*
   在正向编号中执行一个块状松弛步骤。    根据参数[2.x.15]和[2.x.16]，这将执行一个SOR步骤（都引用同一个向量）或一个Jacobi步骤（都是不同的向量）。对于雅可比步骤，调用函数必须将[2.x.17]复制到[2.x.18]之后。   
* [2.x.19]如果设置了一个包络，它将自动被这个函数所尊重。 
* [0.x.24]*
   在后退编号中执行一个块状放松步骤。    根据参数[2.x.20]和[2.x.21]，这将执行一个SOR步骤（都引用同一个向量）的雅可比步骤（都是不同的向量）。对于雅可比步骤，调用函数必须将[2.x.22]复制到[2.x.23]之后。   
* [2.x.24]如果设置了一个包络，它将自动被这个函数所尊重。 
* [0.x.25]*
   返回块的大小。 
* [0.x.26]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.27]*
    [2.x.25] 异常情况[2.x.26]。  
* [0.x.28]*
   对于非重叠块预处理，块大小必须除以矩阵大小。如果不是，就会抛出这个异常。 
* [0.x.29]*
   异常  
* [0.x.30]*
   块的大小。每个对角线块都被假定为相同的大小。 
* [0.x.31]*
   指向矩阵的指针。确保只要这个类需要，矩阵就一直存在，即直到调用[2.x.27]或（如果不应该存储逆矩阵）直到最后一次调用派生类的pre-onditoining[2.x.28]函数。 
* [0.x.32]*
   派生类要使用的松弛参数。 
* [0.x.33]*
   包容向量  
* [0.x.34]*
   反向的包络向量  
* [0.x.35]*
 块状雅可比预处理。对矩阵的要求见PreconditionBlock。该类满足[2.x.29]的 "放松概念"。
* 

* 
* [2.x.30] 这个模板的实例化提供给<tt>[2.x.31]和[2.x.32]其他人可以在应用程序中生成（见手册中的[2.x.33]部分）。

* 
* [0.x.36]*
   定义矩阵的数字类型。 
* [0.x.37]*
   声明容器大小的类型。 
* [0.x.38]*
   符合标准的迭代器。 
* [0.x.39]*
     迭代器的访问器类    
* [0.x.40]*
       构造器。因为我们只使用访问器进行读取访问，一个常数矩阵指针就足够了。     
* [0.x.41]*
       这个对象所代表的元素的行号。     
* [0.x.42]*
       这个对象所代表的元素的列号。     
* [0.x.43]*
       这个矩阵条目的值。     
* [0.x.44]*
       访问的矩阵。     
* [0.x.45]*
       在这里保存块的大小，以便进一步参考。     
* [0.x.46]*
       当前的区块编号。     
* [0.x.47]*
       块内的迭代器。     
* [0.x.48]*
       当前块的结束。     
* [0.x.49]*
     构造函数。   
* [0.x.50]*
     前缀增量。   
* [0.x.51]*
     去引用操作符。   
* [0.x.52]*
     解除引用操作符。   
* [0.x.53]*
     比较。真，如果两个迭代器都指向同一个矩阵位置。   
* [0.x.54]*
     <tt>==</tt>的倒数。   
* [0.x.55]*
     比较运算符。如果第一行数字较小，或者行数字相等且第一个索引较小，则结果为真。   
* [0.x.56]*
     存储一个访问器类的对象。   
* [0.x.57]*
   从私有基类中导入函数  
* [0.x.58]*
   执行块状雅可比预处理。    如果存在逆矩阵，该函数将自动使用逆矩阵，如果不存在，那么BlockJacobi将需要很多时间在每个预处理步骤中反转对角线块矩阵。 
* [0.x.59]*
   与[2.x.34]相同，因为雅可比是对称的。 
* [0.x.60]*
   执行块状雅可比预处理，添加到[2.x.35]这个函数将自动使用反矩阵（如果存在），如果没有，那么BlockJacobi将需要很多时间在每个预处理步骤中反转对角块状矩阵。 
* [0.x.61]*
   与[2.x.36]相同，因为雅可比是对称的。 
* [0.x.62]*
   执行雅可比迭代的一个步骤。 
* [0.x.63]*
   执行雅可比迭代的一个步骤。 
* [0.x.64]*
   迭代器从第一条开始。 
* [0.x.65]*
   最后的迭代器。 
* [0.x.66]*
   从第[2.x.37]行的第一个条目开始的迭代器。  
* [0.x.67]*
   行[2.x.38]的最终迭代器   
* [0.x.68]*
   预处理程序的实际实现。    根据[2.x.39]，预处理的结果被添加到目标向量中。 
* [0.x.69]*
 块状SOR预处理。该类满足了[2.x.40]的 "放松概念"。
* 函数[2.x.41]和[2.x.42]根据PreconditionBlock中的块，执行一个（转置的）块-SOR步骤。对角线块之外的元素可以任意分布。
* 对矩阵的要求见PreconditionBlock。该类中使用的块必须是连续的和不重叠的。一个重叠的施瓦兹松弛方法可以在RelaxationBlockSOR中找到；不过该类不提供预处理。
* [1.x.0]
* 可选地，源向量的条目可以按照#set_permutation设置的包络向量中的索引顺序来处理（或者对于Tvmult()来说是相反顺序）。反向排列用于将元素存储回这个向量中。在调用set_permutation()的非零大小的向量后，这个功能会自动启用。
* 

* 
* [2.x.43] 对角线块，就像矩阵一样，是不被置换的! 因此，互换向量只能交换整个块。它不能改变块内部的顺序或交换块之间的单个索引。
* [1.x.1]
 

* 
* [2.x.44] 该模板的实例化提供给<tt> [2.x.45] 和 [2.x.46] 其他的可以在应用程序中生成（见手册中的[2.x.47]部分）。

* 
* [0.x.70]*
   声明容器尺寸的类型。 
* [0.x.71]*
   默认构造函数。 
* [0.x.72]*
   定义矩阵的数字类型。 
* [0.x.73]*
   从受保护的基类中导入类型和函数。 
* [0.x.74]*
   执行块SOR预处理。    如果存在逆矩阵，该函数将自动使用逆矩阵，如果不存在，那么BlockSOR将在每个预处理步骤中浪费很多时间来反转对角线块矩阵。    对于对角线块以上为空的矩阵，BlockSOR是一个直接求解器。 
* [0.x.75]*
   执行块SOR预处理。    警告：这个函数执行正常的[2.x.48]，不加。它存在的原因是BlockMatrixArray默认需要添加版本。另一方面，添加需要一个额外的辅助向量，这并不可取。     [2.x.49] vmult  
* [0.x.76]*
   向后应用vmult()。    在目前的实现中，这不是vmult()的转置。它是一个应用于整个矩阵的转置的高斯-赛德尔算法，但是被反转的对角线块没有转置。因此，如果对角线块是对称的，它就是转置的。 
* [0.x.77]*
   执行后向块SOR预处理。    警告：这个函数执行正常的[2.x.50]，不加。它存在的原因是BlockMatrixArray默认需要添加版本。另一方面，添加需要一个额外的辅助向量，这并不可取。     [2.x.51] vmult  
* [0.x.78]*
   执行SOR迭代的一个步骤。 
* [0.x.79]*
   执行一步转置的SOR迭代。 
* [0.x.80]*
   由PreconditionBlockSSOR使用的构造函数。 
* [0.x.81]*
   实现由vmult()和vmult_add()调用的正向置换循环。    如果#permutation是由set_permutation()设置的，它将自动被这个函数遵守。    参数[2.x.52]还没有任何功能。 
* [0.x.82]*
   实现由Tvmult()和Tvmult_add()调用的后向替换循环。    如果一个#permutation是由set_permutation()设置的，它将自动被这个函数兑现。    参数[2.x.53]还没有任何功能。 
* [0.x.83]*
 块状SSOR预处理。该类满足了[2.x.54]的 "放松概念"。
* 函数[2.x.55]和[2.x.56]根据PreconditionBlockSOR中的实现，执行一个块-SSOR步骤。 这个类需要存储对角线块和它们的逆向值。
* 关于矩阵的要求见PreconditionBlock。该类中使用的块必须是连续的和不重叠的。一个重叠的施瓦兹松弛方法可以在RelaxationBlockSSOR中找到；不过该类不提供预处理。
* 

* 
* [2.x.57] 这个模板的实例化提供给<tt> [2.x.58] 和 [2.x.59] 其他的可以在应用程序中生成（见手册中[2.x.60]一节）。

* 
* [0.x.84]*
   声明容器大小的类型。 
* [0.x.85]*
   定义矩阵的数字类型。 
* [0.x.86]*
   构造函数。 
* [0.x.87]*
   使初始化函数公开可用。 
* [0.x.88]*
   执行块SSOR预处理。    如果存在逆矩阵，该函数将自动使用逆矩阵，如果不存在，那么BlockSOR将在每个预处理步骤中浪费很多时间来反转对角线块矩阵。 
* [0.x.89]*
   与vmult()相同  
* [0.x.90]*
   执行SOR迭代的一个步骤。 
* [0.x.91]*
   执行一步转置的SOR迭代。 
* [0.x.92]

