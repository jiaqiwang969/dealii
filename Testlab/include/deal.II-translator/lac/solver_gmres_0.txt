include/deal.II-translator/lac/solver_gmres_0.txt
[0.x.0]*
   一个用于GMRES求解器的辅助类的命名空间。 
* [0.x.1]*
     用于保存临时向量的类。 一旦需要，这个类就会自动分配一个新的向量。        未来的版本还应该能够自动转移向量，避免重新启动。   
* [0.x.2]*
       构造函数。准备一个长度为[2.x.1] max_size的[2.x.0]数组。     
* [0.x.3]*
       销毁器。删除所有分配的向量。     
* [0.x.4]*
       获取向量编号 [2.x.2] 如果这个向量之前未被使用，会发生错误。     
* [0.x.5]*
       获取向量编号 [2.x.3] 必要时分配它。            如果必须分配一个向量，则使用[2.x.4]将其重新设定为适当的尺寸。     
* [0.x.6]*
       返回数据向量的大小。它在求解器中用于存储Arnoldi向量。     
* [0.x.7]*
       获得向量的池子。     
* [0.x.8]*
       用于存储向量的字段。     
* [0.x.9]*
 重启预设条件的直接广义最小残差法的实现。停止的标准是残差的规范。
* AdditionalData结构包含使用的临时向量的数量。阿诺尔迪基的大小是这个数字减去3。此外，它允许你选择右预处理或左预处理。默认是左预处理。最后，它包括一个标志，表明是否使用默认残差作为停止标准。
* 

* [1.x.0]
* [2.x.5] 允许你在左和右预处理之间进行选择。正如预期的那样，这将分别在对系统[1.x.1]和[1.x.2]的求解之间切换。
* 第二个结果是用来衡量收敛性的残差类型。对于左预处理，这是[1.x.3]的残差，而对于右预处理，它是未预处理系统的残差。
* 可以选择使用标志[2.x.6]来覆盖这一行为。<tt>true</tt>值是指上一段描述的行为，而<tt>false</tt>则是恢复它。但是要注意，在这种情况下必须计算额外的残差，阻碍了求解器的整体性能。
* 

* [1.x.4]
* 最大的基数大小是由[2.x.7]控制的，它是这个数字减去2。如果迭代步数超过这个数字，所有的基向量都会被丢弃，并从目前得到的近似值重新开始迭代。
* 请注意，GMRes的最小化特性只涉及到Arnoldi基所跨越的Krylov空间。因此，重新启动的GMRes不再是[1.x.5]的最小化。基长的选择是内存消耗和收敛速度之间的权衡，因为较长的基意味着在更大的空间内实现最小化。
* 关于使用该类对矩阵和向量的要求，请参见Solver基类的文档。
* 

* [1.x.6]
* 这个类的solve()函数使用Solver基类中描述的机制来确定收敛性。这个机制也可以用来观察迭代的进度。
* 

* [1.x.7]
* 该类可以在求解过程中估计特征值和条件数。这是在内部迭代过程中通过创建海森堡矩阵来实现的。特征值被估计为海森堡矩阵的特征值，条件数被估计为海森堡矩阵的最大和最小奇异值的比率。估算值可以通过使用[2.x.8] connect_condition_number_slot和[2.x.9] 连接一个函数作为槽来获得，然后这些槽将被解算器以估算值为参数调用。

* 
* [0.x.10]*
   标准化的数据结构，用于向求解器输送额外的数据。 
* [0.x.11]*
     构造函数。默认情况下，设置临时向量的数量为30，即每28次迭代做一次重启。同时从左边开始设置预设条件，停止准则的残差为默认残差，仅在必要时进行重新正交。   
* [0.x.12]*
     临时向量的最大数量。这个参数控制Arnoldi基的大小，由于历史原因，这个参数是#max_n_tmp_vectors-2。SolverGMRES假设至少有三个临时向量，所以这个值必须大于或等于3。   
* [0.x.13]*
     右侧预处理的标志。       
* [2.x.10] 在左和右预处理之间的改变也会改变残差的评估方式。参见SolverGMRES中的相应章节。   
* [0.x.14]*
     用于衡量收敛性的默认残差的标志。   
* [0.x.15]*
     在每一步中强制对正交基进行重新正交的标志。    如果设置为false，求解器每5次迭代都会自动检查正交性的损失，只有在必要时才启用重新正交化。   
* [0.x.16]*
   构造函数。 
* [0.x.17]*
   构造函数。使用一个GrowingVectorMemory类型的对象作为默认分配内存。 
* [0.x.18]*
   复制构造函数被删除。 
* [0.x.19]*
   求解x的线性系统[2.x.11]。 
* [0.x.20]*
   连接一个槽来检索估计的条件数。如果every_iteration=true，则在每次外部迭代时调用，否则在迭代结束时调用一次（即因为已经达到收敛，或者因为检测到分歧）。 
* [0.x.21]*
   连接一个槽来检索估计的特征值。如果every_iteration=true，则在每次外部迭代时调用，否则在迭代结束时调用一次（即，要么因为已经实现收敛，要么因为检测到分歧）。 
* [0.x.22]*
   连接一个槽，检索由初始矩阵在Krylov基上的投影得到的海森堡矩阵。如果every_iteration=true，则在每次外部迭代时调用，否则在迭代结束时调用一次（即因为已经达到收敛，或者因为检测到分歧）。 
* [0.x.23]*
   连接一个槽，检索由Arnoldi算法生成的Krylov空间的基向量。当迭代完成时（即，因为已经达到收敛，或者因为检测到发散），一次性调用。 
* [0.x.24]*
   连接一个槽，当向量被重新正交时，检索一个通知。 
* [0.x.25]*
   包括tmp向量的最大数量。 
* [0.x.26]*
   用来检索估计条件数的信号。在所有迭代结束时调用一次。 
* [0.x.27]*
   用来检索估计条件数的信号。在每次外部迭代时被调用。 
* [0.x.28]*
   用来检索估计的特征值的信号。在所有迭代结束时调用一次。 
* [0.x.29]*
   用来检索估计的特征值的信号。在每次外部迭代时被调用。 
* [0.x.30]*
   用于检索海森堡矩阵的信号。在所有迭代结束时调用一次。 
* [0.x.31]*
   用于检索海森堡矩阵的信号。在每次外部迭代时被调用。 
* [0.x.32]*
   用来检索Krylov空间基向量的信号。当所有迭代结束时调用一次。 
* [0.x.33]*
   当向量被重新正交化时，用于检索通知的信号。 
* [0.x.34]*
   实现对残差准则的计算。 
* [0.x.35]*
   通过最后一列的基辅旋转，将上黑森伯格矩阵转化为三对角结构。 
* [0.x.36]*
   使用修改后的Gram-Schmidt算法将向量[2.x.12]与第一个参数给出的[2.x.13]（正交）向量正交。  用于正交的因子存储在[2.x.14]中。 布尔值[2.x.15]re_orthogonalize指定是否应将修正的Gram-Schmidt算法应用两次。该算法每隔五步就会检查程序中的正交性损失，并在这种情况下将该标志设置为真。  所有随后的迭代都使用重新正交。  如果信号re_orthogonalize_signal被连接，则调用它。 
* [0.x.37]*
   从内部迭代过程中产生的海森堡矩阵H_orig中估计出特征值。使用这些估计值来计算条件数。以这些估计值为参数调用信号eigenvalues_signal和 cond_signal。 
* [0.x.38]*
   投射的系统矩阵  
* [0.x.39]*
   用于反转的辅助矩阵 [2.x.16] 。  
* [0.x.40]*
 实现具有灵活预处理的广义最小残差法（灵活的GMRES或FGMRES）。
* 这个灵活版本的GMRES方法允许在每个迭代步骤中使用不同的预处理。因此，对于预处理器的不准确评估，它也更加稳健。一个重要的应用是在预处理程序中使用Krylov空间方法。与允许在左右预处理之间进行选择的SolverGMRES相反，这个求解器总是从右边应用预处理。
* FGMRES在每个迭代步骤中需要两个向量，总共产生[2.x.17]个辅助向量。除此之外，与GMRES相比，FGMRES每次迭代所需的操作数量大致相同，只是在每次重启和solve()结束时少用一次预处理程序。
* 更多细节见 [2.x.18] 。

* 
* [0.x.41]*
   标准化的数据结构，用于向求解器输送额外的数据。 
* [0.x.42]*
     构造函数。默认情况下，将最大基础尺寸设置为30。   
* [0.x.43]*
     最大基数大小。   
* [0.x.44]*
   构造函数。 
* [0.x.45]*
   构造函数。使用一个GrowingVectorMemory类型的对象作为默认分配内存。 
* [0.x.46]*
   求解x的线性系统[2.x.19]。 
* [0.x.47]*
   额外的标志。 
* [0.x.48]*
   投射的系统矩阵  
* [0.x.49]*
   用于反转的辅助矩阵 [2.x.20] 。  
* [0.x.50]

