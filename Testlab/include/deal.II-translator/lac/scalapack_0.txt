include/deal.II-translator/lac/scalapack_0.txt
[0.x.0]*
 一个围绕ScaLAPACK并行密集线性代数的封装类。
* ScaLAPACK假设矩阵是按照块-循环分解方案来分布的。一个[2.x.0]乘以[2.x.1]的矩阵首先被分解成[2.x.2]乘以[2.x.3]的块，然后均匀地分布在具有[2.x.4]进程的二维进程网格上，其中[2.x.5]是网格尺寸，[2.x.6]是进程的总数。参数MB和NB被称为行和列块大小，决定了块-循环分布的颗粒度。
* 下面显示了[2.x.7]矩阵在[2.x.8]笛卡尔进程网格上的块-循环分布，块大小为[2.x.9]。
*\htmlonly <style>div.image img[src="scalapack_block_cycling.png"]{width:35%;}</style>\endhtmlonly [2.x.10] 
* 请注意，进程P2、P5和P8所拥有的本地矩阵的列数为奇数，这说明[2.x.11]不是[2.x.12]的整数倍。
* 块大小的选择是一个折中，既要有足够大的大小来实现高效的本地/串行BLAS，又要有足够小的大小来实现良好的并行负载平衡。
* 下面我们展示了[2.x.13]在多达5个节点上的强扩展实例，每个节点由两个英特尔至强2660v2 IvyBridge插座2.20GHz，10个核心/插座组成。计算在方形处理器网格1x1, 2x2, 3x3, 4x4, 5x5, 6x6, 7x7, 8x8, 9x9, 10x10进行。
* [2.x.14] 
 

 
* [2.x.15] 

* 
* [0.x.1]*
   声明容器尺寸的类型。 
* [0.x.2]*
   矩形矩阵的构造函数，具有[2.x.16]和[2.x.17]并使用网格[2.x.18]分布。参数[2.x.19]和[2.x.20]是用于矩阵的块循环分布的块大小。  一般来说，建议使用[2.x.21]的幂，例如[2.x.22] 。 
* [0.x.3]*
   一个大小为[2.x.23]的正方形矩阵的构造函数，使用[2.x.24]中的过程网格进行分布。  矩阵的行和列使用相同的块大小。  一般来说，建议使用[2.x.26]的幂，例如[2.x.27] 。 
* [0.x.4]*
   一般矩形矩阵的构造函数，从文件[2.x.28]中读取并使用网格[2.x.29]分布。 使用HDF5从文件[2.x.30]加载矩阵。  如果在建立deal.II时没有使用HDF5，调用这个函数将导致一个异常。    参数[2.x.31]和[2.x.32]是用于矩阵的块循环分布的块大小。  一般来说，建议使用[2.x.33]的幂，例如[2.x.34] 。 
* [0.x.5]*
   破坏器  
* [0.x.6]*
   用[2.x.35]和[2.x.36]初始化矩形矩阵，并使用网格[2.x.37]分布。参数[2.x.38]和[2.x.39]是用于矩阵的块循环分布的块大小。  一般来说，建议使用[2.x.40]的幂，例如[2.x.41] 。 
* [0.x.7]*
   初始化大小为[2.x.42]的正方形矩阵，并使用网格[2.x.43]进行分布。参数[2.x.44]用于矩阵的块循环分布。  矩阵的行和列使用相同的块大小。  一般来说，建议使用[2.x.45]的幂，例如[2.x.46] 。 
* [0.x.8]*
   将[2.x.47]分配给这个矩阵。 
* [0.x.9]*
   返回该矩阵的当前[2.x.48]。 
* [0.x.10]*
   返回此矩阵的当前[2.x.49]。 
* [0.x.11]*
   来自普通FullMatrix的赋值操作。   
* [2.x.50] 这个函数应该只用于相对较小的矩阵尺寸。它主要是为了调试的目的。 
* [0.x.12]*
   将本地拥有的[2.x.51]的内容复制到分布式矩阵中。  分布式矩阵和进程[2.x.53]上的[2.x.52]必须有匹配的尺寸。    对于所有进程来说，除了具有等级[2.x.54]的进程，序列[2.x.55]不被引用。  用户必须确保所有进程都以相同的[2.x.56]来调用。[2.x.57]是指用于创建分布式矩阵的进程网格的MPI通信器的一个进程。 
* [0.x.13]*
   将分布式矩阵的内容复制到[2.x.58]中。    
* [2.x.59] 这个函数应该只用于相对较小的矩阵尺寸。它主要是为了调试的目的。 
* [0.x.14]*
   将分布式矩阵的内容复制到本地复制的[2.x.60]上，该进程的等级为[2.x.61] 对于除[2.x.62]外的所有进程，[2.x.63]不被引用。  分布式矩阵和进程[2.x.65]上的[2.x.64]必须有匹配的尺寸。    用户必须确保所有进程都以相同的[2.x.66]来调用。[2.x.67]是指用于创建分布式矩阵的进程网格的MPI通信器的一个进程。 
* [0.x.15]*
   将分布式矩阵的内容复制到不同的分布式矩阵中 [2.x.68] 该函数也适用于具有不同进程网格或块循环分布的矩阵。 
* [0.x.16]*
   将分布式矩阵A的一个子矩阵（子集）复制到分布式矩阵的一个子矩阵[2.x.69] 。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 
* - 子矩阵A的第一个元素的全局行和列索引由[2.x.70]提供，行索引= [2.x.71] ，列索引= [2.x.72] 。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
 
* - 子矩阵B的第一个元素的全局行和列索引由[2.x.73]提供，行索引= [2.x.74] ，列索引= [2.x.75] 。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
* 
* - 要复制的子矩阵的尺寸由[2.x.76]给出，行数= [2.x.77] ，列数= [2.x.78] 。      如果需要复制具有相同块状循环分布的完整矩阵，请使用 [2.x.79] &dest），只需一个参数，以避免通信。    矩阵[2.x.80]和[2.x.81]的底层进程网格必须是用同一个MPI通信器建立的。 
* [0.x.17]*
   转置赋值。 [2.x.82] 矩阵[2.x.83]和[2.x.84]必须具有相同的进程网格。    必须满足以下对齐条件。 [2.x.85] 和 [2.x.86] .  
* [0.x.18]*
   基于输入参数[2.x.87]和对齐条件的操作在下表中进行了总结。    | transpose_B | 块大小 | 操作 | :---------: | :--------------------------: | :-------------------------------------------: | false | [2.x.88] [2.x.89] [2.x.90] | [2.x.91] | | true | [2.x.92] [2.x.93] [2.x.94] | [2.x.95] | 矩阵[2.x.96] 和[2.x.97] 必须具有相同的过程网格。 
* [0.x.19]*
   矩阵-加法。   [2.x.98] 矩阵[2.x.99]和[2.x.100]必须有相同的过程网格。    必须满足以下对齐条件。 [2.x.101] 和 [2.x.102] .  
* [0.x.20]*
   矩阵-加法。   [2.x.103] 矩阵[2.x.104]和[2.x.105]必须具有相同的过程网格。    必须满足以下对齐条件。 [2.x.106] 和 [2.x.107] 。 
* [0.x.21]*
   矩阵-矩阵-乘法。    基于输入参数和排列条件的操作总结在下表中。    | 转置_A | 转置_B | 块大小 | 操作 | :---------: | :---------: | :-------------------------------------------: | :-------------------------------------------------------------: | 虚假 | 虚假 | [2.x.108] [2.x.109] [2.x.110] [2.x.111] [2.x.112] | [2.x.113] | 虚假 | 真实 | [2.x.114 ] [2.x.115] [2.x.116] [2.x.117] [2.x.118] | [2.x.119] | | 真实 | 错误 | [2.x.120] [2.x.121] [2.x.122] [2.x.123 ] [2.x.124] | [2.x.125] | | 真 | 真 | [2.x.126] [2.x.127] [2.x.128] [2.x.129] [2.x.130] | [2.x.131] | 假设[2.x.132]和[2.x.133]的大小兼容，并且[2.x.134]已经具有正确大小。    矩阵[2.x.135]，[2.x.136]和[2.x.137]必须具有相同的过程网格。 
* [0.x.22]*
   矩阵-矩阵-乘法。    可选参数[2.x.138]决定了结果是存储在[2.x.139]中还是添加到[2.x.140]中。 如果（ [2.x.141] [2.x.142] 否则[2.x.143] 假设[2.x.144]和[2.x.145]的大小兼容，并且[2.x.146]已经有正确大小。    必须满足以下对齐条件。 [2.x.147] , [2.x.148] 和 [2.x.149] 。 
* [0.x.23]*
   使用 [2.x.150] 的转置进行矩阵-矩阵-乘法。    可选参数[2.x.151]决定了结果是存储在[2.x.152]中还是添加到[2.x.153]中。 如果（ [2.x.154] [2.x.155] 否则[2.x.156] 假设[2.x.157]和[2.x.158]的大小兼容，并且[2.x.159]已经具有正确大小。    必须满足以下对齐条件。 [2.x.160] , [2.x.161] 和 [2.x.162] .  
* [0.x.24]*
   使用 [2.x.163] 的转置进行矩阵-矩阵-乘法。    可选参数[2.x.164]决定了结果是存储在[2.x.165]中还是添加到[2.x.166]中。 如果（ [2.x.167] [2.x.168] 否则 [2.x.169] 假设[2.x.170]和[2.x.171]的大小兼容，并且[2.x.172]已经具有正确大小。    必须满足以下对齐条件。 [2.x.173] , [2.x.174] 和 [2.x.175] 。 
* [0.x.25]*
   使用 [2.x.176] 和 [2.x.177] 的转置进行矩阵-矩阵-乘法。    可选参数[2.x.178]决定了结果是存储在[2.x.179]中还是添加到[2.x.180]中。 如果（ [2.x.181] [2.x.182] 否则[2.x.183] 假设[2.x.184]和[2.x.185]的大小兼容，并且[2.x.186]已经有正确大小。    必须满足以下对齐条件。 [2.x.187] , [2.x.188] 和 [2.x.189] 。 
* [0.x.26]*
   使用HDF5将分布式矩阵存储在[2.x.190]中。    如果在建立deal.II时没有使用HDF5，调用这个函数将导致一个异常。    如果HDF5是用MPI构建的，那么将使用并行I/O来保存矩阵。  否则，只有一个进程会进行输出。这意味着在内部，分布式矩阵被复制到一个进程中，由该进程进行输出。因此，矩阵必须适合一个进程的内存。    为了调整I/O性能，特别是平行I/O，用户可以定义可选的参数[2.x.191] 所有MPI进程都需要以相同的值调用该函数。  矩阵是分块写入文件的，因此系统的属性决定了最佳的分块大小。在内部，HDF5将矩阵分割成<tt>chunk_size.first</tt> x <tt>chunk_size.second</tt>大小的块，其中<tt>chunk_size.first</tt>是一个块的行数，<tt>chunk_size.second</tt>是列的数量。 
* [0.x.27]*
   使用HDF5从文件[2.x.192]加载分布式矩阵。  如果在建立deal.II时没有使用HDF5，调用这个函数将导致一个异常。    矩阵的尺寸必须与存储在文件中的矩阵相同。    如果HDF5是用MPI构建的，那么将使用并行I/O来加载矩阵。  否则，只有一个进程会从存储中加载矩阵，并随后将内容分发给其他进程。 
* [0.x.28]*
   使用ScaLAPACK函数计算矩阵的Cholesky因子化 [2.x.193] 。因式分解的结果被存储在这个对象中。 
* [0.x.29]*
   使用ScaLAPACK函数[2.x.194]计算矩阵的LU因式分解，并通过行间交换进行部分透视。  因式分解的结果被存储在这个对象中。 
* [0.x.30]*
   通过首先计算对称矩阵的Cholesky或一般矩阵的LU因子化来反转矩阵，然后使用 [2.x.195] 或 [2.x.196] 建立实际的反转。如果矩阵是三角形的，则跳过LU因子化步骤，直接使用[2.x.197]。    如果之前已经应用了Cholesky或LU因子化，则直接调用[2.x.198]。    逆运算被存储在这个对象中。 
* [0.x.31]*
   计算选定的特征值和可选的实数对称矩阵的特征向量 [2.x.199] 。    特征值/特征向量是通过规定一个指数范围来选择的 [2.x.200] 如果成功，计算出的特征值将按升序排列。  特征向量被存储在矩阵的列中，从而覆盖了矩阵的原始内容。    如果必须计算所有的特征值/特征向量，在[2.x.202]中传递封闭区间[2.x.201]如果需要[2.x.204]最大的特征值/特征向量，则传递封闭区间[2.x.203]。 
* [0.x.32]*
   计算选定的特征值，并可选择计算特征向量。  通过规定特征值的取值范围[2.x.205]来选择特征值/特征向量。    如果成功，计算出的特征值将按升序排列。  特征向量被存储在矩阵的列中，从而覆盖了矩阵的原始内容。 
* [0.x.33]*
   使用MRRR算法计算选定的特征值和可选的实数对称矩阵[2.x.206]的特征向量。    通过规定指数范围选择特征值/特征向量 [2.x.207] 如果成功，计算出的特征值将按升序排列。  特征向量被存储在矩阵的列中，从而覆盖了矩阵的原始内容。    如果必须计算所有的特征值/特征向量，在[2.x.209]中传递封闭区间[2.x.208]如果希望得到[2.x.211]最大的特征值/特征向量，则传递封闭区间[2.x.210]。 
* [0.x.34]*
   使用MRRR算法计算选定的特征值和可选的实数对称矩阵[2.x.212]的特征向量。  特征值/特征向量是通过规定特征值的取值范围[2.x.213]来选择。    如果成功，计算出的特征值将按升序排列。  特征向量被存储在矩阵的列中，从而覆盖了矩阵的原始内容。 
* [0.x.35]*
   计算矩阵[2.x.214]的奇异值分解（SVD），可选择计算左和/或右奇异向量。SVD写成[2.x.215]，[2.x.216]为对角矩阵，[2.x.217]和[2.x.218]为正交矩阵。2.x.219]的对角线元素是[2.x.220]的奇异值，[2.x.221]和[2.x.222]的列分别是相应的左和右奇异向量。奇异值按递减顺序返回，只计算[2.x.223]的第一列和[2.x.225]的行。    返回时，矩阵的内容是不可用的。  矩阵[2.x.226]的行和列必须具有相同的块循环分布。    如果需要左奇异向量，矩阵[2.x.227]和[2.x.228]必须以相同的过程网格和块循环分布构建。如果需要右奇异向量，矩阵[2.x.229]和[2.x.230]必须以相同的过程网格和块循环分布构建。    为了避免计算左和/或右奇异向量，该函数接受[2.x.231]为[2.x.232]和/或[2.x.233]。  
* [0.x.36]*
   解决涉及矩阵[2.x.234]或其转置[2.x.235]的过定或欠定实数线性系统，使用[2.x.236]的QR或LQ因式分解，用于矩阵[2.x.237]列中的RHS向量 假设[2.x.239]具有全等级。 [2.x.240] .     支持以下选项。
* 

* 
* 

* 
* 

 
* 
* - If(!transpose) and [2.x.241] : 超定系统[2.x.242]的最小平方解 .n 退出后，[2.x.243]至[2.x.244]的行包含最小平方解向量。每一列的剩余平方和由该列中[2.x.246]至[2.x.247]元素的平方和给出。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
* 
* - If(!transpose) and [2.x.248] : 查找欠定系统的最小规范解 [2.x.249] .n 退出后，[2.x.250] 的列包含最小规范解向量。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
* 
* - 如果(转置)和[2.x.251]：找到欠定系统[2.x.252]的最小规范解 .n 退出后，[2.x.253]的列包含最小规范解向量。
* 

* 
* 

* 
* 

 
 

 
 

 
 

 
* 
* - 如果(转置)和 [2.x.254] : 超定系统的最小平方解 [2.x.255] .n 退出后，行 [2.x.256] 到 [2.x.257] 包含最小平方解向量。每一列的剩余平方和由该列中元素[2.x.258]至[2.x.259]的平方和给出。    If(!tranpose) then [2.x.260] , otherwise [2.x.261] 。  矩阵[2.x.262]和[2.x.263]的行和列必须有相同的块循环分布。 
* [0.x.37]*
   使用奇异值分解[2.x.266]计算实数矩阵[2.x.265]的假逆[2.x.264]（Moore-Penrose逆）。    与逆不同，假逆 [2.x.267] 既适用于矩形矩阵，也适用于奇异矩阵 [2.x.268] 。    对于一个矩形[2.x.269]，伪逆的计算方法是取对角线上每个非零元素的倒数，保留零的位置，然后转置[2.x.270] 。在数值计算中，只有奇异值[2.x.271]被考虑在内。成功退出后，该函数返回满足该条件的奇异值的数量。这个值可以解释为 [2.x.272] 的等级。    返回时该对象包含伪逆 [2.x.273] 。    必须满足以下排列条件。 [2.x.274] .  
* [0.x.38]*
   估计一个SPD矩阵在[2.x.275]-norm中的条件数。  该矩阵必须处于Cholesky状态（见compute_cholesky_factorization()）。条件数的倒数被返回，以避免在条件数非常大时出现溢出的可能性。     [2.x.276]在调用Cholesky因式分解之前，必须包含矩阵的[2.x.277] -norm（见l1_norm()）。   
* [2.x.278] 另一种方法是明确计算矩阵的逆值，并手动构建[2.x.279] 。 
* [0.x.39]*
   计算矩阵的[2.x.280]-norm。 
* [0.x.40]*
   计算矩阵的[2.x.281]准则。 
* [0.x.41]*
   计算矩阵的Frobenius准则。 
* [0.x.42]*
   [2.x.282]矩阵的行数。 
* [0.x.43]*
   [2.x.283]矩阵的列数。 
* [0.x.44]*
   这个MPI进程上的本地行数。 
* [0.x.45]*
   这个MPI进程上的本地列数。 
* [0.x.46]*
   返回给定本地行的全局行号 [2.x.284] 。 
* [0.x.47]*
   为给定的本地列返回全局列号 [2.x.285] 。  
* [0.x.48]*
   读取对本地元素的访问。 
* [0.x.49]*
   对本地元素的写访问。 
* [0.x.50]*
   通过数组[2.x.286]中提供的标量对分布式矩阵的列进行缩放。数组[2.x.287]必须有与矩阵列同样多的条目。    [2.x.288]的副本必须在底层MPI通信器的所有进程中可用。   
* [2.x.289] [2.x.290]的基本前提是必须能够从中创建ArrayView；[2.x.291]和Vector类满足这一要求。 
* [0.x.51]*
   通过数组[2.x.292]中提供的标量来缩放分布式矩阵的行，数组[2.x.293]的条目数必须与矩阵的行一样多。    [2.x.294]的副本必须在底层MPI通信器的所有进程中可用。   
* [2.x.295] [2.x.296]的基本前提是必须能够从中创建ArrayView；[2.x.297]和Vector类满足这一要求。 
* [0.x.52]*
   使用ScaLAPACK的内部函数计算一个分布式对称密集矩阵的规范。 
* [0.x.53]*
   使用ScaLAPACK的内部函数计算一个分布式密集矩阵的规范。 
* [0.x.54]*
   计算选定的特征值和可选的特征向量。  特征值/特征向量是通过为特征值规定一个指数范围[2.x.298]或一个值范围[2.x.299]来选择的。如果同时规定了两个范围（意味着两个范围都与默认值不同），该函数将抛出一个异常，因为这种模糊性是被禁止的。如果成功，计算出的特征值将按升序排列。特征向量被存储在矩阵的列中，从而覆盖了矩阵的原始内容。 
* [0.x.55]*
   使用MRRR算法计算选定的特征值和可选的实数对称矩阵[2.x.300]的特征向量。  特征值/特征向量是通过规定指数范围[2.x.301]或特征值的取值范围[2.x.302]来选择。如果两个范围都被规定了（意味着两个范围都与默认值不同），该函数将抛出一个异常，因为这种模糊性是被禁止的。    通过调用这个函数，矩阵的原始内容将被覆盖。如果要求，特征向量将被存储在矩阵的列中。同样，如果只需要特征值，矩阵的内容也将被覆盖。    如果成功，计算出的特征值将按升序排列。   
* [2.x.303] 由于Netlib-ScaLAPACK中的一个错误，可以计算所有的或没有特征向量。  因此，必须对输入[2.x.304]进行相应设置。使用Intel-MKL则不需要这种限制。 
* [0.x.56] 使用串行例程在[2.x.305]中存储分布矩阵。 
* [0.x.57] 使用串行例程从文件[2.x.306]加载分布式矩阵。 
* [0.x.58] 使用并行例程将分布式矩阵存储在[2.x.307]中。 
* [0.x.59] 使用并行例程从文件[2.x.308]中加载分布式矩阵。 
* [0.x.60]*
   由于ScaLAPACK操作会改变矩阵项的含义，所以我们在这里记录最后一次操作后的当前状态。 
* [0.x.61]*
   矩阵的其他属性，可能有助于选择更有效的ScaLAPACK函数。 
* [0.x.62]*
   一个指向[2.x.309]对象的共享指针，它包含一个BLACS上下文和一个MPI通信器，以及其他必要的数据结构。 
* [0.x.63]*
   矩阵中的行数。 
* [0.x.64]*
   矩阵中的列数。 
* [0.x.65]*
   行块大小。 
* [0.x.66]*
   列块大小。 
* [0.x.67]*
   当前进程拥有的矩阵中的行数。 
* [0.x.68]*
   当前进程拥有的矩阵中的列数。 
* [0.x.69]*
   ScaLAPACK描述向量。 
* [0.x.70]*
   工作区阵列。 
* [0.x.71]*
   整数工作区数组。 
* [0.x.72]*
   保存ScaLAPACK的矩阵分解程序所需的枢轴信息的整数阵列。 
* [0.x.73]*
   一个字符，用于定义元素的存储位置，以防ScaLAPACK操作支持这个。 
* [0.x.74]*
   过程网格的过程行，全局矩阵的第一行分布于此。 
* [0.x.75]*
   全局矩阵第一列所分布的过程网格的过程列。 
* [0.x.76]*
   全局行索引，决定在哪里开始一个子矩阵。  目前这等于unity，因为我们不使用子矩阵。 
* [0.x.77]*
   全局列索引，决定子矩阵的起始位置。  目前这等于unity，因为我们不使用子矩阵。 
* [0.x.78]*
   线程互斥。 
* [0.x.79]

