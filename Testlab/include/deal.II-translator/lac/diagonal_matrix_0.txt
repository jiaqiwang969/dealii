include/deal.II-translator/lac/diagonal_matrix_0.txt
[0.x.0]*
 这个类表示一个基于大小为[1.x.1]的向量的[1.x.0]对角矩阵。矩阵-向量的乘积由[2.x.0][2.x.1]实现，所以模板向量类需要提供一个[2.x.2]方法。
* 当把这个类和[2.x.3]一起使用时，底层向量需要提供对装配过程中单元格引用的所有条目的写入权限。这意味着该类也需要访问除调用进程外的其他进程所拥有的幽灵条目。在实践中，这需要对向量进行如下初始化

* 
* [1.x.2]
* 

* 
* [0.x.1]*
   默认构造函数。该对象仍然需要重新初始化才能使用。 
* [0.x.2]*
   构造函数将此对象初始化为大小为`n x n`的对角线矩阵，其中`n`是矢量的大小，其对角线条目等于[2.x.4]的元素。  
* [0.x.3]*
   通过复制向量[2.x.5]的内容，用一个给定的向量进行初始化   
* [0.x.4]*
   压缩数据结构，并允许产生的矩阵用于所有其他操作，如矩阵-向量乘积。这是一个集体操作，即在并行使用时需要在所有处理器上运行。 
* [0.x.5]*
   返回一个对底层向量的引用，以便对矩阵对角线上的条目进行操作。 
* [0.x.6]*
   清除此对象的内容并重置为默认构造函数的状态。 
* [0.x.7]*
   返回一个对底层向量的只读引用。 
* [0.x.8]*
   这个矩阵的行数。这个数字对应于底层向量的大小。 
* [0.x.9]*
   此矩阵的列数。这个数字与基础向量的大小相对应。 
* [0.x.10]*
   对一个值的只读访问。由于矩阵存储的原因，这被限制在[1.x.3]的情况下。    如果代表对角线的向量是用MPI分布的，实际上可能不是所有的指数[1.x.4]都能被访问。请参考方法[2.x.6]，了解实际可访问的条目。 
* [0.x.11]*
   对一个值的读写访问。由于矩阵存储的原因，这被限制在[1.x.5]的情况下。    如果代表对角线的向量是用MPI分布的，那么实际上可能不是所有的指数[1.x.6]都可以访问。请参考方法[2.x.7]，了解实际可访问的条目。 
* [0.x.12]*
   在给定的全局矩阵行中，在col_indices指定的列中添加一个由<tt>values</tt>给出的数值数组。由于该矩阵的存储方式，条目只被添加到矩阵的对角线上。所有其他的条目都被忽略，并且不抛出异常。    这个函数是为了与deal.II中的其他矩阵类保持一致的接口，可以在[2.x.8]中使用，得到与组装成稀疏矩阵时完全相同的对角线。 
* [0.x.13]*
   为元素(i,j)加值。    由于这个矩阵的存储方式，条目只被添加到矩阵的对角线上。所有其他的条目都被忽略，并且不抛出异常。 
* [0.x.14]*
   与给定的矩阵进行矩阵-向量乘法。 
* [0.x.15]*
   对给定的矩阵进行转置矩阵-向量乘法。因为这代表了一个对角线矩阵，与vmult()完全相同。 
* [0.x.16]*
   将矩阵-向量乘法的结果添加到目标向量dst中。需要创建一个临时向量，这使得性能比[2.x.9]的要慢。  
* [0.x.17]*
   将转置矩阵向量乘法的结果添加到目标向量dst中。需要创建一个临时向量，这使得性能比[2.x.10]慢。  
* [0.x.18]*
   初始化向量[2.x.11]，使其具有与本类的[2.x.12]成员相同的大小和分区。    这是linear_operator()所要求的接口的一部分。 
* [0.x.19]*
   返回这个对象的内存消耗。 
* [0.x.20]*
   存储的向量。 
* [0.x.21]

