include/deal.II-translator/lac/vector_0.txt
[0.x.0]!  [2.x.0] 矢量 [2.x.1] 。

 
* [0.x.1]*
 一个表示数字元素向量的类。至于其他类，在[2.x.2]组中，这个类有大量的成员函数。这些包括
* 

* 
* 
* - 用于初始化向量或改变其大小的函数。
* 

* 
* 
* - 计算向量属性的函数，如各种规范。
* 

* 
 
* - 允许从向量的单个元素中读取或写入的函数。
 

* 
* 
* - 实现向量代数运算的函数，例如向量的加法；以及
* 

* 
* 
* - 允许输入和输出向量存储的数据的函数。
* 与C++标准库类[2.x.3]相比，该类打算实现的不是简单的允许访问其元素的数组，而实际上是一个矢量，是适合数值计算的 "矢量空间 "这一数学概念的成员。
* 

* 
* [2.x.4] 这个模板的实例提供给<tt> [2.x.5] [2.x.6] [2.x.7] [2.x.8] 其他的可以在应用程序中生成（见手册中[2.x.9]部分）。

* 
* [0.x.2]*
   声明所有容器中使用的标准类型。这些类型与<tt>C++</tt>标准库中的<tt>vector<...></tt>类相似。 
* [0.x.3]*
   声明一个类型，该类型持有与该类的模板参数相同精度的实值数。如果这个类的模板参数是一个实数数据类型，那么real_type就等于模板参数。  如果模板参数是一个[2.x.10]类型，那么real_type等于复数的基础类型。    这个别名被用来表示规范的返回类型。 
* [0.x.4]*
    [2.x.11] 基本对象处理  
* [0.x.5]*
   构造函数。创建一个维数为0的向量。 
* [0.x.6]*
   复制构造函数。将维数设置为给定的向量的维数，并复制所有元素。    我们希望这个构造函数是显式的，但是标准的容器坚持隐式使用它。     [2.x.12]   
* [0.x.7]*
   移动构造函数。通过窃取向量的内部数据创建一个新的向量 [2.x.13] 。  
* [0.x.8]*
   复制构造函数获取另一种数据类型的向量。    如果没有从[2.x.14]到[2.x.15]的转换路径，这个构造函数将无法编译。 当复制到一个数据元素精度较低的向量时，你可能会失去精度。 
* [0.x.9]*
   拷贝构造函数取一个[2.x.16]类型的对象，该构造函数可用于使用大括号封闭的数字列表来初始化向量，如下面的例子。 
* [1.x.0]
* 这将创建一个大小为3的向量，其（双精度）元素的值为1.0、2.0和3.0。    如果没有从[2.x.17]到[2.x.18]的转换路径，这个构造函数将无法编译。 当复制到一个数据元素精度较低的向量时，可能会失去精度。 
* [0.x.10]*
   另一个复制构造函数：从一个PETSc向量类中复制数值。这个复制构造函数只有在配置时检测到PETSc时才可用。    请注意，由于MPI中使用的通信模型，当[2.x.19]是一个分布式向量时，只有当所有进程同时进行这一操作时才能成功。不可能只有一个进程获得一个并行向量的副本，而其他作业做其他事情。 
* [0.x.11]*
   另一个拷贝构造函数：从一个Trilinos包装向量中拷贝数值。  这个拷贝构造函数只有在配置时检测到Trilinos时才可用。   
* [2.x.20]由于MPI中使用的通信模型，这个操作只有在所有知道[2.x.21]的进程（即[2.x.22]给出的进程）同时进行时才能成功。这意味着，除非你使用一个分裂的MPI通信器，那么通常不可能只有一个或一个子集的进程获得一个并行向量的副本，而其他工作则做其他事情。换句话说，调用这个函数是一个 "集体操作"，需要由所有共同分享[2.x.23]的MPI进程来执行。  
* [0.x.12]*
   构造函数。设置维度为[2.x.24]，并将所有元素初始化为0。    构造函数是明确的，以避免像这样的意外。  <tt>v=0;</tt>。据推测，用户希望将向量的每一个元素都设置为零，但相反，发生的是这样的调用。  <tt>v=向量[2.x.25]即向量被一个长度为零的向量所取代。 
* [0.x.13]*
   用迭代器指向的给定范围的值初始化向量。这个函数是为了类似于[2.x.26]类而存在的。 
* [0.x.14]*
   销毁器，去分配内存。虚化，以使派生类的行为正确。 
* [0.x.15]*
   这个函数什么也不做，只是为了与并行向量类兼容而存在。    对于并行向量封装类来说，这个函数压缩了向量的底层表示，即刷新了向量对象的缓冲区（如果它有的话）。这个函数在逐一写入向量元素之后，在对其进行其他操作之前是必要的。    然而，对于这个类的实现，它是不重要的，因此是一个空函数。 
* [0.x.16]*
   将向量的维度改为[2.x.27] 如果可能的话，这个向量的保留内存保持不变，以使事情更快；这可能会浪费一些内存，所以要记住这一点。 然而，如果<tt>N==0</tt>所有的内存都被释放了，也就是说，如果你想调整向量的大小并释放不需要的内存，你必须先调用<tt>reinit(0)</tt>，然后再调用<tt>reinit(N)</tt>。这种引用的行为与标准库容器的行为类似。    如果[2.x.28]是假的，那么向量就会被零所填充。  否则，元素就会留下一个未指定的状态。    这个函数是虚拟的，以便允许派生类单独处理内存。 
* [0.x.17]*
   和上面一样，但在调整大小时将保留向量的值。  如果我们的新尺寸更大，我们将有[1.x.1]，而如果想要的尺寸更小，则有[1.x.2]。 
* [0.x.18]*
   将[1.x.3][2.x.29]（余弦、正弦和半径的三要素，见[2.x.30]）应用于[2.x.31]和[2.x.32]单位向量跨越的平面内的向量。 
* [0.x.19]*
   将维度改为向量[2.x.33]的维度，与其他[2.x.34]函数的情况相同。    [2.x.35]的元素不会被复制，也就是说，这个函数与调用<tt>reinit (V.size(), omit_zeroing_entries)</tt>相同。 
* [0.x.20]*
   交换这个向量和另一个向量的内容 [2.x.36] 人们可以用一个临时变量和复制数据元素来做这个操作，但是这个函数明显更有效率，因为它只交换了两个向量的数据指针，因此不需要分配临时存储和移动数据。    这个函数类似于所有C++标准容器的[2.x.37]函数。另外，还有一个全局函数<tt>swap(u,v)</tt>，它简单地调用<tt>u.swap(v)</tt>，同样与标准函数相类似。    这个函数是虚拟的，以便允许派生类单独处理内存。 
* [0.x.21]*
   将向量的所有分量设置为给定的数字 [2.x.38] 由于将标量分配给向量的语义不是很明确，这个操作符实际上只应该在你想将整个向量设置为0时使用。这允许使用直观的符号<tt>v=0</tt>。  赋值其他值是不允许的，将来可能会被禁止。     [2.x.39]   
* [0.x.22]*
   复制给定的向量。如果有必要，可以调整当前向量的大小。     [2.x.40]   
* [0.x.23]*
   移动给定的向量。该操作符用向量[2.x.41]的内部数据替换当前向量，并将[2.x.42]重置为新的默认构建后的状态。 
* [0.x.24]*
   复制给定的向量。如果有必要的话，调整当前向量的大小。     [2.x.43]   
* [0.x.25]*
   用于将块状向量分配给普通向量的复制操作。 
* [0.x.26]*
   另一个复制操作符：从PETSc包装的向量类中复制数值。这个操作符只有在配置时检测到PETSc时才可用。    请注意，由于MPI中使用的通信模型，当[2.x.44]是一个分布式向量时，只有当所有进程同时进行该操作时，该操作才能成功。不可能只有一个进程获得一个并行向量的副本，而其他作业做其他事情。 
* [0.x.27]*
   另一个拷贝操作符：从一个（顺序的或平行的，取决于底层编译器）Trilinos包装向量类中拷贝数值。这个操作符只有在配置时检测到Trilinos时才可用。   
* [2.x.45] 由于MPI中使用的通信模型，该操作只有在所有了解[2.x.46]的进程（即[2.x.47]给出的进程）同时进行时才能成功。这意味着，除非你使用一个分裂的MPI通信器，那么通常不可能只有一个或一个子集的进程获得一个并行向量的副本，而其他工作做其他事情。换句话说，调用这个函数是一个 "集体操作"，需要由所有共同分享[2.x.48]的MPI进程来执行。  
* [0.x.28]*
   检验是否相等。这个函数假设现在的向量和要比较的向量已经有相同的大小，因为比较不同大小的向量反正没有什么意义。 
* [0.x.29]*
   测试不平等。这个函数假定现在的向量和要比较的向量已经有相同的大小，因为比较不同大小的向量反正没有什么意义。 
* [0.x.30]*
    [2.x.49] 标量积、规范和相关操作  
* [0.x.31]*
   返回两个向量的标量乘积。 返回类型是[2.x.50]向量的基本类型，所以返回类型和计算结果的准确性取决于这个向量的参数顺序。    对于复数向量，标量积的实现方式为 [2.x.51] 。     [2.x.52] 该算法使用成对求和，每次运行的求和顺序相同，这使得每次运行的结果完全可重复。 
* [0.x.32]*
   返回[2.x.53]-norm的平方。     [2.x.54]该算法使用成对求和法，每次运行的求和顺序相同，这使得每次运行的结果完全可重复。 
* [0.x.33]*
   这个向量的元素的平均值。     [2.x.55]该算法使用成对求和法，每次运行的求和顺序相同，这使得每次运行的结果完全可重复。 
* [0.x.34]*
    [2.x.56] - 矢量的规范。绝对值的总和。     [2.x.57] 该算法使用成对求和，每次运行中的求和顺序相同，这使得每次运行的结果完全可以重复。 
* [0.x.35]*
    [2.x.58] - 矢量的规范。元素平方之和的平方根。     [2.x.59] 该算法使用成对求和，每次运行的求和顺序相同，这使得每次运行的结果完全可重复。 
* [0.x.36]*
    [2.x.60] - 矢量的规范。元素绝对值的p次方之和的p次根。     [2.x.61] 该算法使用成对求和，每次运行的求和顺序相同，这使得每次运行的结果完全可重复。 
* [0.x.37]*
   元素的最大绝对值。 
* [0.x.38]*
   执行一个矢量加法和随后的内积的组合操作，返回内积的值。换句话说，这个函数的结果与用户调用的  
* [1.x.4]
* 这个函数存在的原因是这个操作比单独调用这两个函数涉及的内存转移要少。这个方法只需要加载三个向量，[2.x.62] [2.x.63] [2.x.64]，而调用单独的方法意味着要加载调用向量[2.x.65]两次。由于大多数向量操作都有内存传输限制，这就使时间减少了25\%（如果[2.x.66]等于[2.x.67]，则减少50\%）对于复值向量，第二步的标量乘法被实现为[2.x.68] 。     [2.x.69] 该算法使用成对求和，每次运行的求和顺序相同，这使得每次运行的结果完全可重复。 
* [0.x.39]*
    [2.x.70] 数据访问  
* [0.x.40]*
   返回一个指向底层数据缓冲区的指针。 
* [0.x.41]*
   返回一个指向底层数据缓冲区的常量指针。 
* [0.x.42]*
   使[2.x.71]类有点像C++标准库中的<tt>vector<>/tt>类，返回该向量元素的起点和终点的迭代器。 
* [0.x.43]*
   返回到向量开始的常数迭代器。 
* [0.x.44]*
   返回一个迭代器，指向超过数组末端的元素。 
* [0.x.45]*
   返回一个恒定的迭代器，指向超过数组末端的元素。 
* [0.x.46]*
   访问[2.x.72]组件的值。 
* [0.x.47]*
   访问[2.x.73]组件作为一个可写的引用。 
* [0.x.48]*
   访问[2.x.74]组件的值。    与operator()完全相同。 
* [0.x.49]*
   访问[2.x.75]组件作为可写引用。    与operator()完全相同。 
* [0.x.50]*
   与通过operator()获取向量的单个元素不同，这个函数允许一次性获取整个元素集。要读取的元素的索引在第一个参数中说明，相应的值在第二个参数中返回。    如果当前的向量被称为[2.x.76]，那么这个函数就等同于代码  
* [1.x.5]
* [2.x.77][2.x.78]和[2.x.79]数组的大小必须是一致的。 
* [0.x.51]*
   这个函数不是通过operator()获得向量的单个元素，而是允许一次获得整个元素集。与前一个函数不同的是，这个函数通过取消引用前两个参数提供的迭代器范围内的所有元素来获得元素的索引，并将向量的值放入通过取消引用从第三个参数指向的位置开始的迭代器范围获得的内存位置。    如果当前的向量被称为[2.x.80]，那么这个函数就等同于代码  
* [1.x.6]
* [2.x.81] 必须能够写进从[2.x.82]开始的尽可能多的内存位置，因为有[2.x.83]和[2.x.84]之间的迭代器。  
* [0.x.52]*
    [2.x.85] 修改向量  
* [0.x.53]*
   将给定的向量添加到当前的向量中。     [2.x.86]   
* [0.x.54]*
   从现在的向量中减去给定的向量。     [2.x.87]   
* [0.x.55]*
   一个集体加法操作。这个函数将存储在[2.x.88]中的一整套数值添加到[2.x.89]指定的向量成分中。  
* [0.x.56]*
   这是第二次集体添加操作。作为区别，这个函数需要一个deal.II的数值向量。 
* [0.x.57]*
   取一个<tt>n_elements</tt>连续存储的地址，并将其添加到向量中。处理上述其他两个<tt>add()</tt>函数未涵盖的所有情况。 
* [0.x.58]*
   将[2.x.90]添加到所有组件中。注意，[2.x.91]是一个标量，而不是一个矢量。     [2.x.92]   
* [0.x.59]*
   缩放向量的多重加法，即<tt>*this += a*V+b*W</tt>。     [2.x.93]   
* [0.x.60]*
   矢量的倍数的简单加法，即<tt>*this += a*V</tt>。     [2.x.94]   
* [0.x.61]*
   缩放和简单的向量相加，即<tt>*this = s*(*this)+V</tt>。     [2.x.95]   
* [0.x.62]*
   缩放和简单加法，即<tt>*this = s*(*this)+a*V</tt>。     [2.x.96]   
* [0.x.63]*
   将向量的每个元素按一个常数缩放。     [2.x.97]   
* [0.x.64]*
   用给定值的倒数来缩放向量的每个元素。     [2.x.98]   
* [0.x.65]*
   用参数中的相应元素来缩放这个向量的每个元素。这个函数主要是为了模拟对角线缩放矩阵的乘法（和立即重新赋值）。     [2.x.99]   
* [0.x.66]*
   用参数中的相应元素来缩放这个向量的每个元素。这个函数主要是为了模拟用对角线缩放矩阵进行乘法（和立即重新分配）。 
* [0.x.67]*
   赋值 <tt>*this = a*u</tt>.      [2.x.100]   
* [0.x.68]*
   赋值 <tt>*this = a*u</tt>.  
* [0.x.69]*
   这个函数什么也不做，只是为了与[2.x.101]并行向量类（如[2.x.102]类）兼容而存在。 
* [0.x.70]*
    [2.x.103] 输入和输出  
* [0.x.71]*
   打印到一个流。 [2.x.104]表示打印数值所需的精度，[2.x.105]是否应使用科学符号。如果[2.x.106]是[2.x.107]，那么向量将被打印在一行中，而如果[2.x.108]则元素被打印在单独的一行中。 
* [0.x.72]*
   将整个向量写到文件中。这是以二进制模式进行的，所以输出结果既不能被人类阅读，也不能（可能）被其他使用不同操作系统或数字格式的计算机阅读。 
* [0.x.73]*
   从一个文件中读取一个矢量en块。这是用上述函数的逆运算来完成的，所以它的速度相当快，因为位流没有被解释。    如果有必要，矢量会被调整大小。    一个原始形式的错误检查被执行，它将识别最直截了当的尝试，将一些数据解释为存储在文件中的位流向量，但不会超过。 
* [0.x.74]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据写入一个流中，以便进行序列化。 
* [0.x.75]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)从一个流中读取此对象的数据，以达到序列化的目的。 
* [0.x.76]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)从流中写入和读取此对象的数据，以达到序列化的目的。 
* [0.x.77]*
    [2.x.109]   
* [0.x.78]*
    [2.x.110] 对象的信息  
* [0.x.79]*
   如果给定的全局索引在这个处理器的本地范围内，返回真。 由于这不是一个分布式矢量，该方法总是返回真。 
* [0.x.80]*
   返回一个索引集，描述这个向量的哪些元素是由当前处理器拥有的。请注意，这个索引集不包括这个向量可能作为鬼魂元素存储在本地，但实际上是由另一个处理器拥有的元素。因此，如果这是一个分布式向量，在不同处理器上返回的索引集将形成不相交的集合，加起来就是完整的索引集。很明显，如果一个向量只在一个处理器上创建，那么结果将满足  
* [1.x.7]
* 由于当前的数据类型不支持跨不同处理器的并行数据存储，所以返回的索引集是完整的索引集。 
* [0.x.81]*
   返回向量的尺寸。 
* [0.x.82]*
   返回向量的局部维度。因为这个向量不支持分布式数据，所以这个值总是与size()相同。   
* [2.x.111] 这个函数的存在是为了与[2.x.112]兼容。  
* [0.x.83]*
   返回向量是否只包含值为0的元素。这个函数主要用于内部一致性检查，在非调试模式下应该很少使用，因为它使用了相当多的时间。 
* [0.x.84]*
   如果向量没有负条目，即所有条目都是零或正，则返回[2.x.113]。例如，这个函数被用来检查细化指标是否真的都是正的（或零）。    这个函数显然只有在这个类的模板参数是一个实数类型时才有意义。如果它是一个复杂的类型，那么就会抛出一个异常。 
* [0.x.85]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.86]*
   这个函数的存在是为了与[2.x.114]并行向量类（例如，[2.x.115]类）兼容。  总是返回false，因为这个实现是串行的。 
* [0.x.87]*
   这个向量所拥有的元素的数组。 
* [0.x.88]*
   在初始化或重新初始化结束时使用的便利函数。根据循环分区器的当前状态和向量的长度，将其重置（如果需要）到正确的状态。 
* [0.x.89]*
   reinit函数的实际实现。 
* [0.x.90]*
   对于带有TBB的并行循环，该成员变量存储循环的亲和力信息。 
* [0.x.91]!  [2.x.116] 矢量 [2.x.117]! 

* 
* [0.x.92]*
 全局函数[2.x.118]，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个向量的数据。
* [2.x.119] 向量

* 
* [0.x.93]*
 输出操作符将一个向量写入流中。该操作符逐一输出向量的元素，条目之间有一个空格。每个条目都会根据输出流上设置的标志进行格式化。
* [2.x.120] 矢量

* 
* [0.x.94]*
 声明 [2.x.121] 数字 > 作为串行矢量。
* [2.x.122] 矢量

* 
* [0.x.95]

