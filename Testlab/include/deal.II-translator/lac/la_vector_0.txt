include/deal.II-translator/lac/la_vector_0.txt
[0.x.0]*
 一个用于向量类的命名空间。
* 这个命名空间包含了各种类，它们为来自不同的外部库（如Trilinos (EPetra)或PETSc）和本地实现（如[2.x.0]）的向量类提供包装。
* 不同的向量类派生自VectorSpaceVector，为向量空间操作提供一个联合接口，或派生自ReadWriteVector（或ReadWriteVector本身），或两者皆有。通过VectorSpaceVector的向量空间操作（如规范或向量添加）和通过ReadWriteVector的元素访问的分离是设计上的，可以提高性能。

* 
* [0.x.1]!  [2.x.1]矢量 [2.x.2]!   
* [0.x.2]*
   数值化的数据向量。该类同时派生自[2.x.3]和[2.x.4]与C++标准库中的数组不同，该类实现了适合数值计算的向量空间的元素。 
* [0.x.3]*
     构造函数。创建一个维数为0的向量。   
* [0.x.4]*
     复制构造函数。将维数设置为给定的向量的维数，并复制所有元素。   
* [0.x.5]*
     构造函数。将维度设置为[2.x.5]并将所有元素初始化为零。        构造函数是明确的，以避免像这样的意外。    <tt>v=0;</tt>。据推测，用户希望将向量的每一个元素都设置为零，但相反，发生的是这样的调用。    <tt>v=向量[2.x.6]即向量被一个长度为0的向量所取代。   
* [0.x.6]*
     用迭代器指向的给定范围的值初始化向量。这个函数的存在是与[2.x.7]类相类似的。   
* [0.x.7]*
     将向量的全局大小设置为[2.x.8] 存储的元素的索引在[0,size]。        如果标志[2.x.9]被设置为false，内存将被初始化为0，否则内存将不被触动（用户在使用前必须确保用合理的数据填充它）。   
* [0.x.8]*
     使用与输入向量[2.x.10]相同的IndexSet，并为该向量分配内存。        如果标志[2.x.11]被设置为false，内存将被初始化为0，否则内存将不被触动（用户在使用前必须确保用合理的数据填充它）。   
* [0.x.9]*
     初始化向量。指数由[2.x.12] locally_stored_indices指定。        如果标志[2.x.13]被设置为false，内存将被初始化为0，否则内存将不被触动（用户在使用前必须确保用合理的数据填充它）。 local_stored_indices。   
* [0.x.10]*
     将维度改为向量V的维度，V的元素不会被复制。   
* [0.x.11]*
     返回`false`，因为这是一个串行向量。        这个功能只有在使用基于MPI的向量时才需要调用，并且为了兼容而存在于其他对象中。   
* [0.x.12]*
     复制输入向量的数据 [2.x.14].     
* [0.x.13]*
     复制输入向量[2.x.15]的数据。    
* [0.x.14]*
     将向量的所有元素设置为标量 [2.x.16] 只有当[2.x.17]等于零时才允许进行此操作。   
* [0.x.15]*
     将整个向量乘以一个固定系数。   
* [0.x.16]*
     用整个向量除以一个固定的因子。   
* [0.x.17]*
     将向量[2.x.18]添加到现在的向量中。   
* [0.x.18]*
     从现在的向量中减去向量[2.x.19]。   
* [0.x.19]*
     返回两个向量的标量乘积。   
* [0.x.20]*
     这个函数没有实现，将抛出一个异常。   
* [0.x.21]*
     将[2.x.20]添加到所有分量中。注意，[2.x.21]是一个标量，而不是一个矢量。   
* [0.x.22]*
     向量的倍数的简单加法，即<tt>*this += a*V</tt>。   
* [0.x.23]*
     矢量的倍数加法，即：<tt>*this += a*V+b*W</tt>。   
* [0.x.24]*
     一个向量的倍数的缩放和简单加法，即<tt>*this = s*(*this)+a*V</tt>。   
* [0.x.25]*
     用参数中的相应元素来缩放这个向量的每个元素。这个函数主要是为了模拟对角线缩放矩阵的乘法（和立即重新分配）。   
* [0.x.26]*
     赋值 <tt>*this = a*V</tt>.    
* [0.x.27]*
     返回向量是否只包含值为0的元素。   
* [0.x.28]*
     返回这个向量的所有条目的平均值。   
* [0.x.29]*
     返回该向量的l<sub>1</sub>准则（即所有条目的绝对值之和）。   
* [0.x.30]*
     返回向量的l<sub>2</sub>准则（即所有处理器中所有条目的平方根之和）。   
* [0.x.31]*
     返回向量的最大规范（即所有条目和所有处理器之间的最大绝对值）。   
* [0.x.32]*
     执行一个向量加法和后续内积的组合操作，返回内积的值。换句话说，这个函数的结果与用户调用的    
* [1.x.0]
* 这个函数存在的原因是这个操作比单独调用这两个函数涉及的内存转移要少。这个方法只需要加载三个向量，[2.x.22] [2.x.23] [2.x.24]，而调用单独的方法意味着要加载调用向量[2.x.25]两次。由于大多数向量操作都有内存传输限制，这就使时间减少了25\%（如果[2.x.26]等于[2.x.27]，则减少50\%）对于复值向量，第二步中的标量乘法被实现为[2.x.28] 。   
* [0.x.33]*
     返回向量的全局大小，等于所有处理器中本地拥有的索引数之和。   
* [0.x.34]*
     返回一个索引集，描述这个向量的哪些元素是由当前处理器拥有的。因此，如果这是一个分布式向量，在不同处理器上返回的索引集将形成不相交的集合，加起来就是完整的索引集。很明显，如果一个向量只在一个处理器上创建，那么结果将满足    
* [1.x.1]
*     
* [0.x.35]*
     将向量打印到输出流中 [2.x.29] 。    
* [0.x.36]*
     打印向量到输出流[2.x.30]，其格式可以被[2.x.31]读取 注意，IndexSet不被打印，而只是存储在Vector中的值。要在python中加载向量，只需执行<code> vector = numpy.loadtxt('my_vector.txt') </code>。   
* [0.x.37]*
     将向量全部写入文件。这是在二进制模式下完成的，所以输出结果既不能被人类阅读，也不能（可能）被其他使用不同操作系统或数字格式的计算机阅读。   
* [0.x.38]*
     从一个文件中读取一个矢量en块。这是用上述函数的逆运算来完成的，所以它的速度相当快，因为位流没有被解释。        如果有必要，矢量会被调整大小。        一个原始形式的错误检查被执行，它将识别最直截了当的尝试，将一些数据解释为存储在文件中的位流向量，但不会更多。   
* [0.x.39]*
     返回这个类的内存消耗，单位是字节。   
* [0.x.40]*
     使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)从一个流中写入和读取此对象的数据，以便进行序列化。   
* [0.x.41]*
     试图在两个不兼容的向量类型之间执行操作。       
* [2.x.32]     
* [0.x.42]*
 将[2.x.33]声明为串行向量。

* 
* [0.x.43]

