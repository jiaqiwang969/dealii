include/deal.II-translator/lac/solver_control_0.txt
[0.x.0]*
 控制类，用于确定迭代求解器的收敛性。
* 由迭代方法使用，以确定是否应该继续迭代。为此，虚函数<tt>check()</tt>在每次迭代中被调用，并给出当前的迭代步骤和表示收敛的值（通常是残差）。
* 迭代结束后，可以用函数last_value()和last_step()来获取迭代的最终状态信息。
* check()可以在派生类中被替换，以允许进行更复杂的测试。
* 

* [1.x.0] 检查函数的返回状态是#State类型的，它是本类的一个枚举。它表示解算器所处的状态。
* State的可能值是 [2.x.0] [2.x.1] <tt>iterate = 0</tt>: 继续迭代。 [2.x.2] [2.x.3] 目标达成，迭代方法可以成功终止。 [2.x.4] [2.x.5] 迭代方法应该停止，因为在给定的最大迭代次数内无法实现或至少无法实现收敛。 [2.x.6] 

 
* [0.x.1]*
   表示求解器可以处于的不同状态的枚举。更多信息请参见该类的一般文档。 
* [0.x.2]*
   迭代求解器收敛失败时抛出的类，当迭代次数超过极限或残差没有达到期望的极限时，例如崩溃的情况。    最后一次迭代的残差，以及最后一步的迭代数都存储在这个对象中，并且可以在捕捉到这个类别的异常时恢复。 
* [0.x.3]*
     最后一步的迭代号。   
* [0.x.4]*
     最后一步的残差。   
* [0.x.5]*
   构造函数。参数[2.x.7]和[2.x.8]是失败前的最大迭代步数和确定迭代成功的公差。     [2.x.9] 指定是否应将历史记录（即要检查的值和迭代步数）打印到[2.x.10] deallog流。 默认为：不打印。同样，[2.x.11]指定最终结果是否被记录到[2.x.12]中，默认为是。 
* [0.x.6]*
   需要虚拟析构器，因为这个类中有虚拟函数。 
* [0.x.7]*
   到参数文件的接口。 
* [0.x.8]*
   从文件中读取参数。 
* [0.x.9]*
   决定一个迭代的成功或失败。 这个函数获取当前的迭代步骤，以确定是否超过了允许的步骤数，在这种情况下返回[2.x.13]。如果[2.x.14]低于规定的公差，则返回[2.x.15] 在所有其他情况下，返回[2.x.16]以建议继续进行迭代程序。    如果残差变成了一个去规范化的值，迭代也会被终止（ [2.x.17] <tt>check()</tt>另外保留了[2.x.18] 和 [2.x.19] 这些值可以通过<tt>last_value()</tt>和<tt>last_step()</tt>访问。    派生类可以重载这个函数，例如，记录收敛指标（ [2.x.20] 或做其他计算。 
* [0.x.10]*
   返回最后一次检查操作的结果。 
* [0.x.11]*
   返回初始收敛准则。 
* [0.x.12]*
   返回求解器调用[2.x.21]的最后一个迭代步骤的收敛值。 
* [0.x.13]*
   最后一个迭代步骤的数量。 
* [0.x.14]*
   最大的步骤数。 
* [0.x.15]*
   改变最大步数。 
* [0.x.16]*
   启用失败检查。如果<tt>residual>failure_residual</tt>与<tt>failure_residual := rel_failure_residual*first_residual</tt>，求解将以[2.x.22] [2.x.23]失败停止。 
* [0.x.17]*
   禁用故障检查，并将[2.x.24]和[2.x.25]failure_residual重置为零。 
* [0.x.18]*
   宽容。 
* [0.x.19]*
   改变容忍度。 
* [0.x.20]*
   使得每一步的残差写成一个向量，以便以后分析。 
* [0.x.21]*
   提供对收集的残差数据的读取权限。 
* [0.x.22]*
   所有步骤的平均误差减少。    需要 enable_history_data()  
* [0.x.23]*
   最后一步的误差减少；对于静止的迭代，这近似于迭代矩阵的规范。    需要 enable_history_data()  
* [0.x.24]*
   任何迭代步骤的误差减少。    需要 enable_history_data()  
* [0.x.25]*
   记录每个迭代步骤。使用[2.x.26]来跳过步骤。 
* [0.x.26]*
   返回[2.x.27]标志。 
* [0.x.27]*
   设置记录频率。 
* [0.x.28]*
   记录开始和结束的步骤。 
* [0.x.29]*
   返回[2.x.28]标志。 
* [0.x.30]*
   如果一个对SolverControl对象的历史数据矢量进行操作的函数被调用，但历史数据的存储没有被enable_history_data()所启用，则会产生这个异常。 
* [0.x.31]*
   最大步骤数。 
* [0.x.32]*
   要达到的规定的公差。 
* [0.x.33]*
   最后一次检查操作的结果。 
* [0.x.34]*
   初始值。 
* [0.x.35]*
   收敛标准的最后值。 
* [0.x.36]*
   最后一步。 
* [0.x.37]*
   被[2.x.30]设置为[2.x.29]并启用故障检查。 
* [0.x.38]*
   存储由[2.x.32]设置的[2.x.31]。  
* [0.x.39]*
    [2.x.33]等于第一个残差乘以[2.x.34]由[2.x.35]设置的relative_crit（见那里）。    在知道第一个残差之前，它是0。 
* [0.x.40]*
   对数收敛历史到[2.x.36]。  
* [0.x.41]*
   只记录每第n步。 
* [0.x.42]*
   记录迭代结果到[2.x.37]如果是真的，在完成迭代后，关于失败或成功的声明以及[2.x.38]和[2.x.39]被记录下来。 
* [0.x.43]*
   对历史数据存储的控制。由enable_history_data()设置。 
* [0.x.44]*
   存储每个迭代步骤后的结果的向量，用于以后的统计分析。    这个向量的使用由enable_history_data()来启用。 
* [0.x.45]*
 [2.x.40]的特殊化，如果达到了指定的容差，或者初始残差（或解算器类选择的任何标准）减少了一个给定的系数，则返回[2.x.41]。这在你不想精确求解，而是想获得两位数或达到最大迭代数的情况下很有用。比如说。最大的迭代次数是20次，减少系数是1%，公差是0.1%。最初的残差是2.5。如果完成了20次迭代，或者新的残差小于2.5*1%，或者小于0.1%，这个过程将中断。

* 
* [0.x.46]*
   构造函数。 除了与SolverControl构造函数含义相同的参数外，还提供还原系数。 
* [0.x.47]*
   用一个SolverControl对象进行初始化。其结果将通过将[2.x.42]设置为零来模拟SolverControl。 
* [0.x.48]*
   将一个SolverControl对象赋值给ReductionControl。赋值的结果将通过设置[2.x.43]为零来模拟SolverControl。 
* [0.x.49]*
   由于该类中存在虚拟函数，所以需要虚拟析构器。 
* [0.x.50]*
   到参数文件的接口。 
* [0.x.51]*
   从文件中读取参数。 
* [0.x.52]*
   决定一个迭代的成功或失败。 这个函数调用基类中的函数，但在第一次迭代时将容忍度设置为<tt>还原初始值</tt>。 
* [0.x.53]*
   缩减系数。 
* [0.x.54]*
   改变减少系数。 
* [0.x.55]*
   希望的减少系数。 
* [0.x.56]*
   减少的容忍度。如果达到这个值或者基类表示成功，则停止迭代。 
* [0.x.57]*
 [2.x.44]的特殊化，如果执行了给定的迭代次数，则返回[2.x.45]，而不考虑实际的残差。这在你不想精确求解，而是想执行固定次数的迭代的情况下很有用，例如在一个内部求解器中。给予该类的参数与SolverControl类的参数完全相同，当达到给定的容差或最大迭代次数之一时，求解器也会同样终止。与SolverControl的唯一区别是，在后一种情况下，求解器会返回成功。

* 
* [0.x.58]*
   构造函数。 提供与SolverControl类的构造函数完全相同的参数。 
* [0.x.59]*
   用一个SolverControl对象进行初始化。结果将模仿SolverControl，将还原目标设置为零。 
* [0.x.60]*
   将一个SolverControl对象分配给ReductionControl。赋值的结果将通过将还原目标设置为零来模拟SolverControl。 
* [0.x.61]*
   需要虚拟析构器，因为这个类中有虚拟函数。 
* [0.x.62]*
   决定一个迭代的成功或失败。这个函数将成功完全建立在是否达到了给定的迭代次数或者检查值正好为零的事实上。 
* [0.x.63]*
 [2.x.46]的特化，当且仅当一定数量的连续迭代满足指定的公差时，返回[2.x.47]。这在使用非精确Hessian解决非线性问题的情况下很有用。
* 比如说。要求的连续收敛迭代次数是2，公差是0.2。ConsecutiveControl将只在序列0.5, 0.0005, 1.0, 0.05, 0.01的最后一步返回[2.x.48]。

* 
* [0.x.64]*
   构建器。 [2.x.49]是连续迭代的次数，应满足收敛的规定公差。其他参数的含义与SolverControl的构造函数相同。 
* [0.x.65]*
   用一个SolverControl对象进行初始化。结果将通过设置[2.x.50]为1来模拟SolverControl。 
* [0.x.66]*
   将一个SolverControl对象分配给ConsecutiveControl。赋值的结果将通过设置[2.x.51]为1来模拟SolverControl。 
* [0.x.67]*
   由于该类中存在虚拟函数，所以需要虚拟析构器。 
* [0.x.68]*
   决定一个迭代的成功或失败，见上面的类描述。 
* [0.x.69]*
   连续迭代的次数，应满足规定的收敛容忍度。 
* [0.x.70]*
   连续收敛的迭代次数的计数器。 
* [0.x.71]

