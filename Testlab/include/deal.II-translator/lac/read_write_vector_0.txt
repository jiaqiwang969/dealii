include/deal.II-translator/lac/read_write_vector_0.txt
[0.x.0]!  [2.x.0] 矢量 [2.x.1] 。  
* [0.x.1]*
   ReadWriteVector旨在表示[2.x.2]中的向量，对于这些向量，它存储了所有或一个子集的元素。后一种情况在并行计算中很重要，因为[2.x.3]可能大到没有一个处理器能真正解决向量的所有元素，但这也不是必须的：通常我们只需要存储住在本地拥有的单元上的自由度值，加上可能住在幽灵单元上的自由度。    该类允许访问单个元素的读或写。  然而，它不允许全局性的操作，如取法线。  ReadWriteVector可以用来读写从VectorSpaceVector派生的向量中的元素，如[2.x.4]和[2.x.5][1.x.0]，大多数情况下，人们将简单地使用这些自由度的全局数字从当前类的向量中读出或写入。这是用operator()()或operator[]()来完成的，它们调用global_to_local()将[1.x.1]的索引转化为[1.x.2]的。在这种情况下，很明显，人们只能访问当前对象确实存储的向量中的元素。    然而，也可以按照当前对象所存储的元素的顺序来访问这些元素。换句话说，人们对用[1.x.3]的索引访问元素不感兴趣，而是使用一个枚举，只考虑实际存储的元素。local_element()函数为此提供了便利。为此，有必要知道[1.x.4]当前类存储的元素。所有连续范围的元素都按照每个范围的第一个索引的升序来存储。  可以用函数[2.x.6]来获取最大范围的第一个索引。 
* [0.x.2]*
     声明所有容器中使用的标准类型。这些类型与<tt>C++</tt>标准库中的<tt>vector<...></tt>类中的类型平行。   
* [0.x.3]*
      [2.x.7] 1: 基本对象处理    
* [0.x.4]*
     空的构造函数。   
* [0.x.5]*
     复制构造函数。   
* [0.x.6]*
     构建一个给定大小的向量，存储的元素的索引在[0,size]。   
* [0.x.7]*
     构建一个向量，其存储元素的索引由IndexSet[2.x.8]给出。    
* [0.x.8]*
     解构器。   
* [0.x.9]*
     将向量的全局大小设置为[2.x.9] 存储元素的索引在[0,size]。        如果标志[2.x.10]被设置为false，内存将被初始化为0，否则内存将不被触动（用户在使用它之前必须确保用合理的数据填充它）。   
* [0.x.10]*
     使用与输入向量[2.x.11]相同的IndexSet，并为该向量分配内存。        如果标志[2.x.12]被设置为false，内存将被初始化为0，否则内存将不被触动（用户在使用前必须确保用合理的数据填充它）。   
* [0.x.11]*
     初始化向量。指数由[2.x.13] locally_stored_indices指定。        如果标志[2.x.14]被设置为false，内存将被初始化为0，否则内存将不被触动（用户在使用前必须确保用合理的数据填充它）。 local_stored_indices。   
* [0.x.12]*
     通过提供对给定的ghosted或non-ghosted向量中所有本地可用条目的访问，初始化这个读写向量。       
* [2.x.15]这个函数目前将参数中的值复制到ReadWriteVector中，所以这里的修改不会修改 [2.x.16]这个函数主要是为了向后兼容而写的，以获得对库内重影[2.x.17]的元素访问。   
* [0.x.13]*
     对向量的每个元素应用漏斗[2.x.18]。这个函式应该看起来像    
* [1.x.5]
         
* [2.x.19] 这个函数要求包含头文件read_write_vector.templates.h。   
* [0.x.14]*
     交换这个向量和另一个向量的内容 [2.x.20] 人们可以用一个临时变量和复制数据元素来完成这个操作，但是这个函数明显更有效率，因为它只交换了两个向量的数据指针，因此不需要分配临时存储和移动数据。        这个函数类似于所有C++标准容器的[2.x.21]函数。此外，还有一个全局函数<tt>swap(u,v)</tt>，它简单地调用<tt>u.swap(v)</tt>，同样与标准函数相类似。   
* [0.x.15]*
     复制数据和输入向量的IndexSet [2.x.22] 。    
* [0.x.16]*
     复制数据和输入向量的IndexSet [2.x.23] 。    
* [0.x.17]*
     将向量的所有元素设置为标量 [2.x.24] 只有在[2.x.25]等于零的情况下才允许此操作。   
* [0.x.18]*
     从输入向量[2.x.26] [2.x.27] [2.x.28]中导入向量的IndexSet中存在的所有元素，用于决定[2.x.29]中的元素是否应该被添加到当前向量中，或者替换当前元素。       
* [2.x.30] 参数[2.x.31]被忽略，因为我们在这里处理的是一个串行向量。   
* [0.x.19]*
     从输入向量[2.x.32] [2.x.33] [2.x.34]中导入向量的IndexSet中存在的所有元素，用于决定[2.x.35]中的元素是否应该被添加到当前向量中，或者替换当前元素。       
* [2.x.36]参数[2.x.37]被忽略，因为我们在这里处理的是一个串行向量。   
* [0.x.20]*
     从输入向量[2.x.38][2.x.39][2.x.40]中导入向量的IndexSet中存在的所有元素，用于决定[2.x.41]中的元素是否应该被添加到当前向量中，或者替换当前元素。如果多次使用同一通信模式，可以使用最后一个参数。这可以用来提高性能。   
* [0.x.21]*
     从输入向量[2.x.42][2.x.43][2.x.44]中导入向量的IndexSet中存在的所有元素，用于决定[2.x.45]中的元素是否应该添加到当前向量中或替换当前元素。如果多次使用同一通信模式，可以使用最后一个参数。这可以用来提高性能。   
* [0.x.22]*
     从输入向量[2.x.46][2.x.47][2.x.48]中导入向量的IndexSet中存在的所有元素，用于决定[2.x.49]中的元素是否应该被添加到当前向量中，或者替换当前元素。如果多次使用同一通信模式，可以使用最后一个参数。这可以用来提高性能。       
* [2.x.50][2.x.51]不允许有幽灵条目。   
* [0.x.23]*
     从输入向量[2.x.52][2.x.53][2.x.54]中导入向量的IndexSet中存在的所有元素，用于决定[2.x.55]中的元素是否应该被添加到当前向量中，或者替换当前元素。如果多次使用同一通信模式，可以使用最后一个参数。这可以用来提高性能。   
* [0.x.24]*
     从输入向量[2.x.56][2.x.57][2.x.58]中导入向量的IndexSet中存在的所有元素，用于决定[2.x.59]中的元素是否应该被添加到当前向量中，或者替换当前元素。如果多次使用同一通信模式，可以使用最后一个参数。这可以用来提高性能。   
* [0.x.25]*
     从输入向量[2.x.60][2.x.61][2.x.62]中导入向量的IndexSet中存在的所有元素，用于决定[2.x.63]中的元素是否应该被添加到当前向量中，或者替换当前元素。最后一个参数不使用。   
* [0.x.26]*
     这个函数返回的值表示这类对象所模拟的向量空间的维度。然而，当前类的对象实际上并不存储这个空间的向量的所有元素，而实际上可能只存储一个子集。存储的元素数量由n_elements()返回，并且小于或等于当前函数返回的数量。   
* [0.x.27]*
     这个函数返回存储的元素数。它小于或等于这种对象所模拟的向量空间的维度。这个维度是由size()返回的。         [2.x.64] 使用local_owned_size()代替。   
* [0.x.28]*
     返回向量的本地大小，即本地拥有的索引数。   
* [0.x.29]*
     返回IndexSet，代表存储的元素的索引。   
* [0.x.30]*
     使[2.x.65]类有点像C++标准库的<tt>vector<>/tt>类，返回该向量的[1.x.6]元素的开始和结束的迭代器。   
* [0.x.31]*
     返回本地存储的向量元素的开始的常数迭代器。   
* [0.x.32]*
     返回一个迭代器，指向本地存储的条目数组结束后的元素。   
* [0.x.33]*
     返回一个恒定的迭代器，指向本地存储的条目数组结束后的元素。   
* [0.x.34]*
      [2.x.66] 2: 数据访问    
* [0.x.35]*
     读取对应于[2.x.67] global_index位置的数据。如果[2.x.68]不是由当前对象存储的，就会产生一个异常。   
* [0.x.36]*
     对[2.x.69] global_index对应位置的数据进行读写访问。如果[2.x.70]没有被当前对象存储，则会产生一个异常。   
* [0.x.37]*
     读取对应于[2.x.71] global_index位置的数据。如果[2.x.72]没有被当前对象存储，就会产生一个异常。        这个函数与operator()的作用相同。   
* [0.x.38]*
     读取和写入对应于[2.x.73]global_index位置的数据。如果[2.x.74]不是由当前对象存储的，就会抛出一个异常。        这个函数与operator()的作用相同。   
* [0.x.39]*
     与通过operator()获取向量中的单个元素不同，这个函数允许一次获取整个元素集。要读取的元素的索引在第一个参数中说明，相应的值在第二个参数中返回。        如果当前的向量被称为[2.x.75]，那么这个函数就等同于代码    
* [1.x.7]
* [2.x.76][2.x.77]和[2.x.78]数组的大小必须是一致的。   
* [0.x.40]*
     这个函数不是通过operator()获得向量的单个元素，而是允许一次获得整个元素集。与前一个函数不同的是，这个函数通过取消引用前两个参数提供的迭代器范围内的所有元素来获得元素的索引，并将向量的值放入通过取消引用从第三个参数指向的位置开始的迭代器范围获得的内存位置。        如果当前的向量被称为[2.x.79]，那么这个函数就等同于代码    
* [1.x.8]
* [2.x.80] 必须能够写进从[2.x.81]开始的尽可能多的内存位置，因为有[2.x.82]和[2.x.83]之间的迭代器。    
* [0.x.41]*
     读取访问[2.x.84]指定的数据字段 当你按照元素的存储顺序访问它们时，你有必要知道它们被存储在哪个位置。换句话说，你需要知道这个类所存储的元素的全局索引与这些全局元素的连续数组中的局部索引之间的映射。关于这一点，请看这个类的一般文档。        性能。直接数组访问（快速）。   
* [0.x.42]*
     对[2.x.85]指定的数据域的读写访问 当你按照元素的存储顺序访问它们时，你有必要知道它们是以何种方式存储的。换句话说，你需要知道这个类所存储的元素的全局索引与这些全局元素的连续数组中的局部索引之间的映射。关于这一点，请看这个类的一般文档。        性能。直接数组访问（快速）。   
* [0.x.43]*
      [2.x.86] 3: 修改向量    
* [0.x.44]*
     该函数将存储在[2.x.87]中的整组值添加到[2.x.88]指定的向量成分中。    
* [0.x.45]*
     这个函数与前一个函数类似，但需要一个读写向量的值。   
* [0.x.46]*
     取一个<tt>n_elements</tt>连续存储的地址，并将其加入到向量中。处理所有其他两个<tt>add()</tt>函数没有涵盖的情况。   
* [0.x.47]*
     将向量打印到输出流中 [2.x.89] 。    
* [0.x.48]*
     以字节为单位返回这个类的内存消耗。   
* [0.x.49]*
     从输入向量中导入所有存在于向量IndexSet中的元素 [2.x.90] 这是一个辅助函数，不应该直接使用它。   
* [0.x.50]*
     从输入向量导入向量的IndexSet中的所有元素 [2.x.91] 这是一个辅助函数，不应该直接使用。   
* [0.x.51]*
     返回[2.x.92]的本地位置。    
* [0.x.52]*
     一个辅助函数，用于调整val数组的大小。   
* [0.x.53]*
     返回一个[2.x.93]，并将其储存起来供将来使用。   
* [0.x.54]*
     返回一个[2.x.94]，并存储起来供将来使用。   
* [0.x.55]*
     存储的元素的索引。   
* [0.x.56]*
     最后导入的向量的元素的索引集。   
* [0.x.57]*
     Source_stored_elements IndexSet和当前向量之间的通信模式。   
* [0.x.58]*
     指向这个向量的本地元素数组的指针。   
* [0.x.59]*
     对于带有TBB的并行循环，这个成员变量存储循环的亲和力信息。   
* [0.x.60]*
     这个类提供了一个围绕Functor的包装器，它作用于向量的单个元素。这对于使用[2.x.95]是必要的，因为它需要一个TBBForFunctor。   
* [0.x.61]*
       构造器。取一个函数并存储它的副本。     
* [0.x.62]*
       用存储的functor的拷贝来评估元素。     
* [0.x.63]*
       对拥有FunctorTemplate的ReadWriteVector对象的别名。     
* [0.x.64]*
       漏斗的副本。     
* [0.x.65]*
 全局函数[2.x.96]，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个向量的数据。
* [2.x.97] 向量

* 
* [0.x.66]

