include/deal.II-translator/lac/precondition_selector_0.txt
[0.x.0]!  [2.x.0] 先决条件 [2.x.1] 。

 
* [0.x.1]*
 选择预处理程序。这个类的构造函数接收预处理的名称和预处理的阻尼参数[2.x.2]，[2.x.3]函数接收矩阵构建预处理函数所使用的矩阵。每次，<tt>operator()</tt>函数被调用时，这个预选的预处理程序、这个矩阵和这个[2.x.4]被用于预处理。该类被设计为作为[2.x.6]解算器的[2.x.5]函数的参数，它涵盖了所有矩阵构建的预处理函数的选择。其他预处理函数的选择，如BlockSOR或ILU，应该由用户在派生类中处理。
* [1.x.0] 这个类的最简单的用途是如下。

* 
* [1.x.1]
* 同样的例子，也使用了[2.x.7]类，内容如下

* 
* [1.x.2]
* 现在，[2.x.8]与[2.x.9]PreconditionSelector的结合使用允许用户在程序开始时选择求解器和预处理器，每次求解器启动时（例如在非线性迭代中多次）都会调用预选的求解器和预处理器。

* 
* [0.x.2]*
   声明容器大小的类型。 
* [0.x.3]*
   构造函数。 [2.x.10]表示预调理的阻尼参数。 
* [0.x.4]*
   解构器。 
* [0.x.5]*
   取出涉及矩阵的预处理所需的矩阵。例如，对于[2.x.11] <tt>~_sor</tt>, <tt>~_ssor</tt>。 
* [0.x.6]*
   返回共域（或范围）空间的维数。注意，矩阵的维度是[2.x.12] 。 
* [0.x.7]*
   返回域空间的维度。请注意，矩阵的维度是[2.x.13] .  
* [0.x.8]*
   预处理程序。调用构造函数中指定的预处理。 
* [0.x.9]*
   转置前提条件程序。调用构造函数中指定的预设条件。 
* [0.x.10]*
   获取所有实现的预设条件的名称。可能的选项列表包括。   [2.x.14] [2.x.15] "无" [2.x.16] [2.x.17] "jacobi" [2.x.18] [2.x.19] "sor" [2.x.20] [2.x.21] "ssor" [2.x.22] [2.x.23]   
* [0.x.11]*
    [2.x.24] 异常情况 [2.x.25]   
* [0.x.12]*
   异常情况。 
* [0.x.13]*
   存储预处理的名称。 
* [0.x.14]*
   用于矩阵构建预处理功能的矩阵。参见[2.x.26]。  
* [0.x.15]*
   存储预处理程序的阻尼参数。 
* [0.x.16]

