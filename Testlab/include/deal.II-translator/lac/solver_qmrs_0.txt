include/deal.II-translator/lac/solver_qmrs_0.txt
[0.x.0]*
 [1.x.0]
* SQMR（对称准最小残差）方法应该是用来解决具有对称的、不一定是确定的预处理的对称不定线性系统。它是原始准最小残差法（QMR）的变体，产生相同的迭代解。这个版本的SQMR是由Freund/Nachtigal各自给出的对称QMR-from-BiCG算法改编的。A new Krylov-subspace method for symmetric indefinite linear systems, NASA STI/Recon Technical Report N, 95 (1994) and Freund/Nachtigal: Software for simplified Lanczos and QMR algorithms, Appl. Num. Math. 19 (1995), pp. 319-341，并提供了右和左（但不是分裂）预处理。
* 

* [1.x.1]
* 请注意，给定算法所基于的QMR实现是由经典的BiCG导出的。可以证明（Freund/Szeto: A transpos-free quasi-minimal residual squared algorithm for non-Hermitian linear systems, Advances in Computer Methods for Partial Differential Equations VII (IMACS, New Brunswick, NJ, 1992) pp.258-264)，QMR迭代结果可以通过一个额外的向量和一些标量更新从BiCG迭代中生成。因此，BiCG可能出现的故障（准确地说是除以0）显然会转移到这个简单的无先验算法上。
* 与经典的QMR或BiCGStab相比，该算法的成本很低，每次迭代只使用一个与系统矩阵的矩阵向量乘积和一个预处理程序的应用。
* 用于衡量收敛性的残差只是通过一个上界来近似计算。如果该值低于AdditionalData结构中规定的阈值，那么当前QMR迭代的精确残差将通过与系统矩阵的另一次乘法来计算。根据经验（根据Freund和Nachtigal），这种技术对于阈值是求解容忍度的10倍是有用的，在这种情况下，只在完整迭代的最后一到两步使用。
* 为了使用这个类，对矩阵和向量的要求，见求解器基类的文档。
* 像所有其他求解器类一样，该类有一个名为[2.x.0] AdditionalData的局部结构，用于向求解器传递额外的参数，如阻尼参数或临时向量的数量。我们使用这个额外的结构，而不是直接将这些值传递给构造函数，因为这使得[2.x.1]和其他类的使用更加容易，并保证即使某个求解器的额外参数的数量或类型发生变化，这些也能继续工作。
* 

* [1.x.2]
* 这个类的solve()函数使用Solver基类中描述的机制来确定收敛性。这个机制也可以用来观察迭代的进度。

* 
* [0.x.1]*
   标准化的数据结构，用于向求解器输送额外的数据。    用户能够在右预处理和左预处理之间进行切换，也就是使用相应的参数分别求解[1.x.3]和[1.x.4]的系统。请注意，左预处理意味着采用预处理的（BiCG-）残差，否则采用未预处理的残差。默认情况是采用右侧的应用。    [2.x.2]阈值用于定义所说的边界，在该边界以下的残差被精确计算。更多信息请参见类文件。默认值是1e-9，也就是默认解算精度乘以10。    SQMR容易受到分解（除以零）的影响，所以我们需要一个参数告诉我们哪些数字被认为是零。适当的分解标准非常不清楚，所以这里可能需要进行实验。  甚至有可能在除以小数的情况下也能实现收敛。甚至在有些情况下，接受这样的除法是有利的，因为廉价的迭代成本使该算法成为所有可用的不定式迭代求解器中最快的。尽管如此，默认的分解阈值是1e-16。 
* [0.x.2]*
     构造器。        默认是右预处理，[2.x.3]选择为1e-9，[2.x.4]设置为1e-16。   
* [0.x.3]*
     标志着使用左置条件的版本。   
* [0.x.4]*
     准确计算当前残差的阈值。   
* [0.x.5]*
     击穿测试的标志。   
* [0.x.6]*
     崩溃阈值。测量到这个界限的标度被用于划分。   
* [0.x.7]*
   构造器。 
* [0.x.8]*
   构造函数。使用一个GrowingVectorMemory类型的对象作为默认分配内存。 
* [0.x.9]*
   求解x的线性系统[2.x.5]。 
* [0.x.10]*
   派生类的接口。这个函数在每一步中获得当前的迭代向量、残差和更新向量。它可以用于收敛历史的图形输出。 
* [0.x.11]*
   附加参数。 
* [0.x.12]*
   由iterate()函数返回的一个结构，代表它发现在迭代过程中发生的事情。 
* [0.x.13]*
   迭代循环本身。该函数返回一个结构，表示在这个函数中发生了什么。 
* [0.x.14]*
   当前迭代的编号（在重启过程中累积）。 
* [0.x.15]

