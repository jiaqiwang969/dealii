include/deal.II-translator/lac/solver_bicgstab_0.txt
[0.x.0]*
   包含SolverBicgstab类所使用的非参数非模板值的类。 
* [0.x.1]*
     辅助值。   
* [0.x.2]*
     辅助值。   
* [0.x.3]*
     辅助值。   
* [0.x.4]*
     辅助值。   
* [0.x.5]*
     辅助值。   
* [0.x.6]*
     当前迭代步骤。   
* [0.x.7]*
     残差。   
* [0.x.8]*
     默认构造函数。这是受保护的，所以只有SolverBicgstab可以创建实例。   
* [0.x.9]*
 van der Vorst的Bicgstab算法。
* 关于使用该类时对矩阵和向量的要求，请参见Solver基类的文档。
* 像所有其他求解器类一样，这个类有一个叫做[2.x.0] AdditionalData的局部结构，用来向求解器传递额外的参数，如阻尼参数或临时向量的数量。我们使用这个额外的结构，而不是直接将这些值传递给构造函数，因为这使得[2.x.1]和其他类的使用更加容易，并保证即使某个求解器的额外参数的数量或类型发生变化，这些也能继续工作。
* Bicgstab方法有两个额外的参数：第一个是布尔值，决定是在每一步中计算实际的残差（ [2.x.2] 还是使用计算的正交残差的长度（ [2.x.3] 注意，计算残差会在每一步中引起第三次矩阵-向量-乘法，尽管没有额外的预处理。这样做的原因是，在迭代过程中计算的正交残差的大小可能比真正的残差要大几个数量级。这是由于与条件不良的矩阵有关的数值不稳定性造成的。由于这种不稳定性导致了不好的停止标准，这个参数的默认值是[2.x.4]。每当用户知道估计的残差工作得很合理时，为了提高求解器的性能，这个标志应该设置为[2.x.5]。
* 第二个参数是分解准则的大小。很难找到一个普遍的好准则，所以如果事情对你不适用，可以尝试改变这个值。
* 

* [1.x.0]
* 这个类的solve()函数使用Solver基类中描述的机制来确定收敛性。这个机制也可以用来观察迭代的进度。

* 
* [0.x.10]*
   计算残差有两种可能：一种是使用计算值[2.x.6]进行估计 另一种是使用另一个矩阵向量乘法进行精确计算。这增加了算法的成本，所以只要问题允许，就应该将其设置为假。    Bicgstab很容易发生故障，所以我们需要一个参数来告诉我们哪些数字被认为是零。 
* [0.x.11]*
     构造函数。        默认是进行精确的残差计算，分解参数是VectorType的value_type可表示的最小有限值。   
* [0.x.12]*
     残差精确计算的标志。   
* [0.x.13]*
     破解阈值。   
* [0.x.14]*
   构造函数。 
* [0.x.15]*
   构造器。使用一个GrowingVectorMemory类型的对象作为默认分配内存。 
* [0.x.16]*
   虚拟解构器。 
* [0.x.17]*
   只解决原始问题。 
* [0.x.18]*
   传递给solve()的解决方案矢量的指针。 
* [0.x.19]*
   辅助向量。 
* [0.x.20]*
   辅助向量。 
* [0.x.21]*
   辅助向量。 
* [0.x.22]*
   辅助向量。 
* [0.x.23]*
   辅助向量。 
* [0.x.24]*
   辅助向量。 
* [0.x.25]*
   辅助向量。 
* [0.x.26]*
   指向传递给solve()的右手边向量的指针。 
* [0.x.27]*
   停止准则的计算。 
* [0.x.28]*
   派生类的接口。 这个函数在每一步中获得当前迭代向量、残差和更新向量。它可以用于收敛历史的图形输出。 
* [0.x.29]*
   附加参数。 
* [0.x.30]*
   iterate()函数返回的一个结构，代表它发现在迭代过程中发生的事情。 
* [0.x.31]*
   迭代循环本身。该函数返回一个结构，表示在这个函数中发生了什么。 
* [0.x.32]

