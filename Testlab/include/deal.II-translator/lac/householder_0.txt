include/deal.II-translator/lac/householder_0.txt
[0.x.0]!  [2.x.0] Matrix2 [2.x.1]! 

 
* [0.x.1]*
 一个完整矩阵的QR分解。
* 该类通过Householder算法计算给定矩阵的QR分解。然后，函数 least_squares() 可以用来计算给定向量 [2.x.2] 的最小化 [2.x.3] 的向量。[2.x.5]的QR分解对这一目的很有用，因为最小化器由方程[2.x.6]给出，这很容易计算，因为[2.x.7]是一个正交矩阵，因此[2.x.8] 。因此，[2.x.9] . 此外，[2.x.10]是三角形的，所以将[2.x.11]应用于一个向量只涉及到后向或前向解。
* 

* [1.x.0]
* 该类实际上没有明确地将[2.x.12]和[2.x.13]的因子存储为矩阵。它确实存储了[2.x.14]，但是[2.x.15]因子被存储为形式为[2.x.16]的Householder反射的乘积，其中向量[2.x.17]是为了使它们可以存储在底层矩阵对象的下三角部分，而[2.x.18]则存储在上三角部分。
* [2.x.19]向量和[2.x.20]矩阵现在发生了冲突，因为它们都想使用矩阵的对角线条目，但我们当然只能在这些位置存储一个。因此，[2.x.21]的条目被单独存储在`对角线`成员变量中。
* 

* 
* [2.x.22] 这个模板的实例化提供给<tt> [2.x.23] 和 [2.x.24] 其他的可以在应用程序中生成（见手册中的[2.x.25]部分）。

* 
* [0.x.2]*
   声明容器尺寸类型的类型。 
* [0.x.3]*
   创建一个空对象。 
* [0.x.4]*
   创建一个持有矩阵的QR分解的对象 [2.x.26] 。 
* [0.x.5]*
   计算给定矩阵的QR分解 [2.x.27] 。    这将覆盖任何先前计算的QR分解。 
* [0.x.6]*
   解决右手边<tt>src</tt>的最小二乘法问题。返回的标量值是近似误差的欧几里得准则。     [2.x.28] [2.x.29] dst包含返回的最小二乘问题的解。     [2.x.30] [2.x.31] src包含最小二乘法问题的右手边[1.x.1]。它将在算法过程中被改变，在返回时无法使用。 
* [0.x.7]*
   这个函数与前一个函数的作用相同，但对BlockVectors而言。 
* [0.x.8]*
   一个对least_squares()的包装器，实现了标准的MatrixType接口。 
* [0.x.9]*
   一个对least_squares()的封装器，实现了与转置矩阵的乘法。 
* [0.x.10]*
   存储正交变换的对角线元素。更多信息请参见类文件。 
* [0.x.11]*
   内部用于Householder变换的存储。 
* [0.x.12]

