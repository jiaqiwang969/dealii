include/deal.II-translator/lac/trilinos_sparsity_pattern_0.txt
[0.x.0]*
     迭代器进入稀疏性模式的访问器类。这个类也是进入稀疏矩阵的常量和非常量访问器类的基类。        请注意，这个类只允许对元素进行读取访问，提供它们的行和列号。它不允许修改稀疏模式本身。       
* [2.x.0]     
* [0.x.1]*
       声明容器大小的类型。     
* [0.x.2]*
       构造函数。     
* [0.x.3]*
       这个对象所代表的元素的行数。     
* [0.x.4]*
       这个对象所代表的元素在行中的索引。     
* [0.x.5]*
       这个对象所代表的元素的列号。     
* [0.x.6]*
       异常情况      
* [0.x.7]*
       异常情况      
* [0.x.8]*
       访问的矩阵。     
* [0.x.9]*
       当前行数。     
* [0.x.10]*
       当前行中的索引。     
* [0.x.11]*
       缓存，我们在这里存储当前行的列索引。这是必要的，因为Trilinos对其矩阵元素的访问相当困难，当我们进入某一行时，一次性复制该行的所有列项，比反复向Trilinos索取单个列项要高效得多。这也有一定的意义，因为无论如何，我们很可能会按顺序访问它们。            为了使迭代器/存取器的复制具有可接受的性能，我们为这些条目保留了一个共享指针，以便在必要时有多个存取器可以访问这些数据。     
* [0.x.12]*
       丢弃旧的行缓存（它们可能仍然被其他访问器使用），并为这个访问器目前所指向的行生成新的行缓存。     
* [0.x.13]*
     类型为[2.x.1]的稀疏模式的迭代器类，对稀疏模式的单个元素的访问由该命名空间的访问器类处理。   
* [0.x.14]*
       声明容器大小的类型。     
* [0.x.15]*
       构造器。为给定的行和其中的索引创建一个进入矩阵[2.x.2]的迭代器。     
* [0.x.16]*
       复制构造函数。     
* [0.x.17]*
       前缀增量。     
* [0.x.18]*
       后缀增量。     
* [0.x.19]*
       撤消运算符。     
* [0.x.20]*
       解除引用操作符。     
* [0.x.21]*
       比较。真，如果两个迭代器都指向同一个矩阵位置。     
* [0.x.22]*
       <tt>==</tt>的倒数。     
* [0.x.23]*
       比较运算符。如果第一行数字较小，或者行数字相等且第一个索引较小，则结果为真。     
* [0.x.24]*
       异常情况      
* [0.x.25]*
       存储一个访问器类的对象。     
* [0.x.26]*
   该类实现了一个包装类，用于使用Trilinos分布式稀疏性模式类Epetra_FECrsGraph。该类被设计用于构建%平行的Tridinos矩阵。该类的功能是以现有的稀疏模式类为模型，不同的是，该类可以根据稀疏模式行的划分，完全并行地工作。    这个类与DynamicSparsityPattern有很多相似之处，因为它可以动态地添加元素到模式中，而不需要事先为其保留任何内存。然而，它也有一个方法[2.x.3]可以最终确定该模式，并使其能够与特里诺斯稀疏矩阵一起使用。   
* [2.x.4]   
* [2.x.5]   
* [0.x.27]*
     声明容器尺寸的类型。   
* [0.x.28]*
     为迭代器类声明一个别名。   
* [0.x.29]*
      [2.x.6] 基本构造函数和初始化    
* [0.x.30]*
     默认构造函数。生成一个空的（零大小）稀疏模式。   
* [0.x.31]*
     生成一个完全本地存储的稀疏模式，有[2.x.7]行和[2.x.8]列。产生的矩阵也将完全存储在本地。        可以使用可选的[2.x.9]参数来指定每行的列条目数。然而，这个值不需要准确，甚至根本不需要给出，因为在建立稀疏模式之前，人们通常没有这种信息（通常情况下，当函数[2.x.10]被调用）。条目是以类似于deal.II DynamicSparsityPattern类的方式动态分配的。然而，一个好的估计将减少稀疏模式的设置时间。   
* [0.x.32]*
     生成一个完全存储在本地的稀疏度模式，有[2.x.11]行和[2.x.12]列。产生的矩阵也将完全存储在本地。        向量<tt>n_entries_per_row</tt>指定了每一行的条目数（不过这个信息通常是不可用的）。   
* [0.x.33]*
     移动构造函数。通过窃取内部数据创建一个新的稀疏矩阵。   
* [0.x.34]*
     复制构造函数。将调用的稀疏模式设置为与输入的稀疏模式相同。   
* [0.x.35]*
     解除构造函数。虚化，以便人们可以使用指向该类的指针。   
* [0.x.36]*
     初始化一个完全存储在本地的稀疏度模式，有[2.x.13]行和[2.x.14]列。由此产生的矩阵将被完全存储在本地。        每行的列条目数被指定为最大条目数参数。 这不需要是一个准确的数字，因为条目是以类似于deal.II DynamicSparsityPattern类的方式动态分配的，但是一个好的估计将减少稀疏模式的设置时间。   
* [0.x.37]*
     初始化一个完全存储在本地的稀疏度模式，有[2.x.15]行和[2.x.16]列。由此产生的矩阵将被完全存储在本地。        向量<tt>n_entries_per_row</tt>指定每一行的条目数。   
* [0.x.38]*
     复制功能。将调用的稀疏度模式设置为与输入的稀疏度模式相同。   
* [0.x.39]*
     拷贝函数，来自一个deal.II稀疏度模式。如果并行使用，该函数使用行和列的临时划分。   
* [0.x.40]*
     复制操作。这个操作只允许用于空对象，以避免由编译器自动合成的潜在的非常昂贵的操作。如果你知道你真的想复制一个具有非琐碎内容的稀疏模式，请使用copy_from()代替。   
* [0.x.41]*
     释放所有内存并返回到与调用默认构造函数后相同的状态。        这是一个集体操作，需要在所有处理器上调用，以避免出现死锁。   
* [0.x.42]*
     与我们自己的SparsityPattern类相类似，这个函数压缩了稀疏模式，并允许产生的模式用于实际生成一个（基于Trilinos）矩阵。这个函数还交换了在添加新元素过程中可能积累的非局部数据。因此，一旦结构被固定，就必须调用这个函数。这是一个集体操作，即在并行使用时需要在所有处理器上运行。   
* [0.x.43]*
      [2.x.17] 使用IndexSet描述的构造器和初始化    
* [0.x.44]*
     使用一个IndexSet和一个MPI通信器的方形稀疏模式的构造器，用于描述%并行分区。    此外，可以指定稀疏模式的行中非零条目的数量。请注意，这个数字不需要精确，甚至允许实际的稀疏结构有比构造函数中指定的更多非零条目。但是在这里提供好的估计值仍然是有利的，因为一个好的值可以避免重复分配内存，这大大增加了创建稀疏度模式时的性能。   
* [0.x.45]*
     与之前相同，但现在使用每m行中非零的确切数量。    由于在这种情况下我们确切地知道稀疏模式中的元素数，我们已经可以分配适当数量的内存，这使得各自的[2.x.18]调用的创建过程大大加快。然而，这是一个相当不寻常的情况，因为知道每一行的条目数通常与知道非零条目的指数有关，而稀疏模式就是为了描述这些非零条目。   
* [0.x.46]*
     这个构造函数与上面的构造函数类似，但是它现在需要两个不同的索引集来描述行和列的%平行分割。这个接口是为了用于生成矩形稀疏模式。请注意，沿着列没有真正的并行性；拥有某一行的处理器总是拥有所有的列元素，不管它们可能分散得多远。第二个Epetra_Map仅用于指定列数，以及在基于该列图与向量进行矩阵-向量乘积时的内部安排。        每行的列条目数被指定为最大条目数的参数。   
* [0.x.47]*
     这个构造函数与上面的构造函数类似，但它现在需要两个不同的行和列的索引集。这个接口是用来生成矩形矩阵的，其中一个映射指定了行的%平行分布，第二个映射指定了与矩阵列相关的自由度分布。然而，这第二个映射并不用于列本身的分布&ndash；相反，一行的所有列元素都存储在同一个处理器上。向量<tt>n_entries_per_row</tt>指定了新生成的矩阵中每一行的条目数。   
* [0.x.48]*
     这个构造函数可以构造一般的稀疏模式，可能是非方形的。通过这种方式构建稀疏模式，用户可以明确地指定我们要添加元素的行。    这个集合被要求是第一个索引集[2.x.19] row_parallel_partitioning的超集，其中也包括被另一个处理器拥有的行（ghost rows）。注意，元素只能被添加到[2.x.20]指定的行中。当处理器要写入的行可以在实际插入元素到矩阵中之前被确定时，这种方法是有益的。对于deal.II中使用的典型的[2.x.21]类，我们知道处理器只为我们所说的本地相关的道夫添加行元素（见[2.x.22]）。 其他构造函数方法使用一般的Trilinos设施，允许向任意的行添加元素（正如所有其他reinit函数所做的那样）。然而，这种灵活性是有代价的，最突出的是，只要使用MPI，从共享内存中的多个线程向同一矩阵添加元素是不安全的。对于这些设置，目前的方法是可以选择的。它将把处理器外的数据存储为一个额外的稀疏模式（然后通过reinit方法传递给Trilinos矩阵），其组织方式可以确保线程安全（当然，只要用户确保不同时写入同一矩阵行）。   
* [0.x.49]*
     重新初始化函数，用于生成一个方形稀疏模式，使用IndexSet和MPI通信器来描述%并行分区和稀疏模式的行中非零项的数量。请注意，这个数字不需要精确，甚至允许实际的稀疏结构有比构造函数中指定的更多的非零条目。然而，在这里提供良好的估计仍然是有利的，因为这将大大增加创建稀疏模式时的性能。        这个函数本身不创建任何条目，但提供了正确的数据结构，可以被相应的add()函数使用。   
* [0.x.50]*
     与之前相同，但现在使用每m行中非零的确切数量。    由于在这种情况下我们确切地知道稀疏模式中的元素数，我们已经可以分配适当数量的内存，这使得向稀疏模式添加条目的过程大大加快。然而，这是一个相当不寻常的情况，因为知道每一行的条目数通常与知道非零条目的指数有关，而稀疏模式就是为了描述这些非零条目。   
* [0.x.51]*
     这个reinit函数与上面的函数类似，但它现在需要两个不同的行和列的索引集。这个接口是用来生成矩形稀疏模式的，其中一个索引集描述了与稀疏模式行相关的%平行分割，另一个是稀疏模式列的平行分割。请注意，沿着列没有真正的并行性；拥有某一行的处理器总是拥有所有的列元素，不管它们可能分散得多远。第二个IndexSet仅用于指定列数，以及在与基于该IndexSet的EpetraMap的向量进行矩阵-向量乘积时用于内部安排。        每行的列条目数由参数<tt>n_entries_per_row</tt>指定。   
* [0.x.52]*
     这个reinit函数用于指定一般的矩阵，可能是非方形的。除了上述其他reinit方法的参数外，它允许用户明确指定我们要添加元素的行。这个集合是第一个索引集[2.x.23]的超集，也包括被另一个处理器拥有的行（ghost rows）。        当一个处理器要写入的行可以在实际插入元素到矩阵之前确定时，这种方法是有益的。对于deal.II中使用的典型[2.x.24]类，我们知道处理器只为我们所说的本地相关的道夫添加行元素（见[2.x.25]）Trilinos矩阵允许向任意的行添加元素（正如所有其他reinit函数所做的那样），这也是所有其他reinit方法所做的。    然而，这种灵活性是有代价的，最突出的是在使用MPI时，从共享内存的多个线程向同一个矩阵添加元素是不安全的。对于这些设置，当前的方法是值得选择的。它将把处理器外的数据存储为一个额外的稀疏模式（然后通过reinit方法传递给Trilinos矩阵），其组织方式可以确保线程安全（当然，只要用户确保不同时写入同一矩阵行）。   
* [0.x.53]*
     和以前一样，但现在使用一个向量<tt>n_entries_per_row</tt>来指定稀疏模式的每一行的条目数。   
* [0.x.54]*
     Reinit函数。接受一个deal.II稀疏模式和由两个索引集指定的行和列的%平行分割，以及一个用于初始化当前Trilinos稀疏模式的%平行通信器。可选参数[2.x.26]可用于用未完全构建的稀疏模式进行重新初始化。这个功能只对动态稀疏模式类型的输入稀疏模式实现。   
* [0.x.55]*
     Reinit函数。接受一个deal.II稀疏度模式和一个%平行分割的行和列，用于初始化当前Trilinos稀疏度模式。可选参数[2.x.27] exchange_data可用于重新初始化未完全构建的稀疏度模式。这个功能只对动态稀疏模式类型的输入稀疏模式实现。   
* [0.x.56]*
      [2.x.28] 稀疏度模式的信息    
* [0.x.57]*
     返回稀疏性模式的状态，即在需要数据交换的操作之后是否需要调用compress()。   
* [0.x.58]*
     返回当前处理器上每行的最大条目数。   
* [0.x.59]*
     返回该稀疏模式中的行数。   
* [0.x.60]*
     返回这个稀疏模式中的列数。   
* [0.x.61]*
     返回稀疏模式的局部维度，即存储在当前MPI进程中的行数。在顺序情况下，这个数字与n_rows()相同，但是对于并行矩阵，这个数字可能更小。        要想知道到底哪些元素被存储在本地，可以使用local_range()。   
* [0.x.62]*
     返回一对指数，表明该稀疏模式的哪些行被存储在本地。第一个数字是存储的第一行的索引，第二个数字是本地存储的最后一行之后的那一行的索引。如果这是一个顺序矩阵，那么结果将是一对（0,n_rows()），否则将是一对（i,i+n），其中<tt>n=local_size()</tt>。   
* [0.x.63]*
     返回[2.x.29]是否在本地范围内，另见local_range()。   
* [0.x.64]*
     返回这个稀疏模式的非零元素的数量。   
* [0.x.65]*
     返回给定行中的条目数。        在一个并行的环境中，有关的行当然可能不存储在当前的处理器上，在这种情况下，就不可能查询其中的条目数。在这种情况下，返回值是`static_cast<size_type>(-1)`。   
* [0.x.66]*
     计算这个结构所代表的矩阵的带宽。该带宽是[2.x.30]的最大值，其中索引对[2.x.31]代表矩阵的非零条目。因此，[2.x.32]矩阵的最大带宽是[2.x.33] 。   
* [0.x.67]*
     返回该对象是否为空。如果没有分配内存，它就是空的，这与两个维度都是0时的情况相同。   
* [0.x.68]*
     返回索引（[1.x.0]）是否存在于稀疏模式中（即它可能是非零）。   
* [0.x.69]*
     返回给定的[2.x.34]是否被存储在这个进程的当前对象中。   
* [0.x.70]*
     确定这个对象的内存消耗（以字节为单位）的估计值。目前这个类没有实现。   
* [0.x.71]*
      [2.x.35]添加条目    
* [0.x.72]*
     将元素（[1.x.1]）添加到稀疏模式中。   
* [0.x.73]*
     在一行中添加几个元素到稀疏模式中。   
* [0.x.74]*
      [2.x.36]访问底层的Trilinos数据    
* [0.x.75]*
     返回一个对存储稀疏模式的底层Trilinos Epetra_CrsGraph数据的常量引用。   
* [0.x.76]*
     返回一个对底层Trilinos Epetra_Map的常量引用，该Map设置了该稀疏模式的域空间的平行分区，即基于该稀疏模式的向量矩阵的分区与之相乘。   
* [0.x.77]*
     返回一个对底层Trilinos Epetra_Map的常量引用，该Map设置了该稀疏模式的范围空间的划分，即由矩阵-向量乘积产生的向量的划分。   
* [0.x.78]*
     返回与该矩阵一起使用的MPI通信器对象。   
* [0.x.79]*
      [2.x.37] 分割器    
* [0.x.80]*
     返回该模式的域空间的分区，即基于该稀疏模式的矩阵必须与之相乘的向量的分区。   
* [0.x.81]*
     返回该模式的范围空间划分，即基于该模式的矩阵向量乘积所产生的向量的划分。   
* [0.x.82]*
      [2.x.38] 迭代器    
* [0.x.83]*
     迭代器从第一个条目开始。   
* [0.x.84]*
     最后的迭代器。   
* [0.x.85]*
     从第[2.x.39]行的第一个条目开始的迭代器 注意，如果给定的行是空的，即不包含任何非零条目，那么这个函数返回的迭代器就等于<tt>end(r)</tt>。还要注意的是，在这种情况下，迭代器可能不能被解除引用。   
* [0.x.86]*
     行<tt>r</tt>的最终迭代器。它指向过了[2.x.40]行末尾的第一个元素，或者过了整个稀疏模式的末尾。        请注意，结束迭代器不一定是可被解除引用的。特别是如果它是一个矩阵的最后一行的结束迭代器，情况更是如此。   
* [0.x.87]*
      [2.x.41] 输入/输出    
* [0.x.88]*
     抽象的Trilinos对象，帮助在ASCII中查看其他Trilinos对象。目前这个功能还没有实现。 TODO：未实现。   
* [0.x.89]*
     使用<tt>(line,col)</tt>格式，向给定的流打印（本地拥有的部分）稀疏模式。可选的标志是以Trilinos风格输出稀疏模式，在实际写入条目之前，甚至根据处理器的编号也会打印到流中，以及一个摘要。   
* [0.x.90]*
     以<tt>gnuplot</tt>能理解的格式打印矩阵的稀疏度，该格式可用于以图形方式绘制稀疏度模式。该格式由成对的<tt>i j</tt>非零元素组成，每个元素代表该矩阵的一个条目，输出文件中每行一个。指数从零开始计算，和平常一样。由于稀疏模式的打印方式与矩阵的显示方式相同，我们打印的是列索引的负数，这意味着<tt>(0,0)</tt>元素在左上角而不是左下角。        在gnuplot中通过将数据样式设置为点或点来打印稀疏模式，并使用<tt>plot</tt>命令。   
* [0.x.91]*
      [2.x.42] 异常情况 [2.x.43]     
* [0.x.92]*
     异常情况    
* [0.x.93]*
     异常情况    
* [0.x.94]*
     异常情况    
* [0.x.95]*
     异常情况    
* [0.x.96]*
     异常情况    
* [0.x.97]*
     指向用户提供的矩阵列的Epetra Trilinos映射的指针，它将矩阵的一部分分配给各个进程。   
* [0.x.98]*
     Trilinos中的稀疏模式对象，用于基于有限元的问题，允许向模式添加非局部元素。   
* [0.x.99]*
     稀疏模式的非本地部分的稀疏模式对象，将被发送到拥有的处理器。只有在设置了特定的构造函数或带有writable_rows参数的reinit方法时才使用    
* [0.x.100]

