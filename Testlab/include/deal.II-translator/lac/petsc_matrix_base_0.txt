include/deal.II-translator/lac/petsc_matrix_base_0.txt
[0.x.0]*
     这个类作为一个迭代器，在PETSc矩阵的元素上行走。由于PETSc为所有类型的矩阵提供了一个统一的接口，这个迭代器可以用来访问稀疏和完整的矩阵。        请注意，PETSc并不保证每一行中元素的顺序。还要注意的是，访问全矩阵的元素，竟然只显示矩阵的非零元素，而不是所有元素。       
* [2.x.0]     
* [0.x.1]*
       迭代器的访问器类      
* [0.x.2]*
         声明容器大小的类型。       
* [0.x.3]*
         构造器。因为我们只使用访问器进行读取访问，所以一个常量矩阵指针就足够了。       
* [0.x.4]*
         这个对象所代表的元素的行号。       
* [0.x.5]*
         这个对象所代表的元素在行中的索引。       
* [0.x.6]*
         这个对象所代表的元素的列号。       
* [0.x.7]*
         这个矩阵条目的值。       
* [0.x.8]*
         异常情况        
* [0.x.9]*
         异常情况        
* [0.x.10]*
         访问的矩阵。       
* [0.x.11]*
         当前行数。       
* [0.x.12]*
         当前行的索引。       
* [0.x.13]*
         缓存，我们在这里存储当前行的列索引。这是必要的，因为PETSc对其矩阵元素的访问是相当困难的，当我们进入某一行时，一次性复制该行的所有列项，要比反复向PETSc索取单个列项更有效率。这也有一定道理，因为我们很可能会按顺序访问它们。                为了使迭代器/存取器的复制具有可接受的性能，我们为这些条目保留一个共享指针，以便在必要时有多个存取器可以访问这些数据。       
* [0.x.14]*
         这个行的值的类似缓存。       
* [0.x.15]*
         丢弃旧的行缓存（它们可能仍然被其他访问器使用），并为这个访问器目前所指向的行生成新的行缓存。       
* [0.x.16]*
       声明容器大小的类型。     
* [0.x.17]*
       构造函数。在矩阵[2.x.1]中为给定的行和其中的索引创建一个迭代器。     
* [0.x.18]*
       前缀增量。     
* [0.x.19]*
       后缀增量。     
* [0.x.20]*
       撤消运算符。     
* [0.x.21]*
       解除引用操作符。     
* [0.x.22]*
       比较。真，如果两个迭代器都指向同一个矩阵位置。     
* [0.x.23]*
       <tt>==</tt>的倒数。     
* [0.x.24]*
       比较运算符。如果第一行数字较小，或者行数字相等且第一个索引较小，则结果为真。     
* [0.x.25]*
       异常情况      
* [0.x.26]*
       存储一个访问器类的对象。     
* [0.x.27]*
   所有在PETSc矩阵类型之上实现的矩阵类的基类。由于在PETSc中，所有的矩阵类型（即顺序和平行，稀疏，阻塞等）都是通过填充一个抽象对象的内容来建立的，而这个抽象对象只能通过一个独立于实际矩阵类型的指针来引用，所以我们可以在这个基类中实现几乎所有的矩阵功能。然后，派生类将只需要提供创建一种或另一种矩阵的功能。    这个类的接口是以deal.II中现有的SparseMatrix类为模型的。它有几乎相同的成员函数，而且通常是可以交换的。然而，由于PETSc只支持单一的标量类型（要么是双数、浮点数，要么是复杂的数据类型），所以它没有模板化，只能与你的PETSc安装中定义的数据类型PetscScalar一起工作。    请注意，只有在矩阵装配后调用了函数[2.x.2]和[2.x.3]的情况下，PETSc才能保证操作符合你的期望。因此，你需要在实际使用矩阵之前调用 [2.x.4] 。这也会调用[2.x.5]，通过丢弃未使用的元素来压缩稀疏矩阵的存储格式。PETSc允许在调用这些函数后继续装配矩阵，但由于此后不再有可用的条目，所以最好在装配阶段结束后，在主动使用矩阵之前，只调用一次[2.x.6]。   
* [2.x.7]   
* [2.x.8]   
* [0.x.28]*
     为迭代器类声明一个别名。   
* [0.x.29]*
     声明容器大小的类型。   
* [0.x.30]*
     声明一个类似于所有其他容器类的别名。   
* [0.x.31]*
     默认的构造函数。   
* [0.x.32]*
     复制构造函数。它被删除了，因为在不知道所存储的矩阵的具体种类的情况下复制这个基类，可能会错过重要的细节，而且如果矩阵很大的话，也会很昂贵。   
* [0.x.33]*
     复制操作符。它被删除了，因为在不知道所存储的矩阵的具体种类的情况下复制这个基类可能会错过重要的细节，而且如果矩阵很大的话，费用也很高。   
* [0.x.34]*
     销毁器。虚化，以便人们可以使用指向这个类的指针。   
* [0.x.35]*
     这个操作符将一个标量分配给一个矩阵。因为这通常没有什么意义（我们应该把所有的矩阵条目都设置为这个值吗？仅仅是稀疏模式的非零条目？），这个操作只允许在实际要分配的值为零时进行。这个操作符的存在只是为了允许明显的符号<tt>matrix=0</tt>，它将矩阵的所有元素设置为零，但保留了之前使用的稀疏模式。   
* [0.x.36]*
     释放所有内存并返回到与调用默认构造函数后相同的状态。   
* [0.x.37]*
     将元素([1.x.0])设置为[2.x.9]如果现在的对象(来自这个对象的派生类)恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一个新的条目，如果该条目之前不存在的话，这与SparseMatrix类形成了很大的反差，如果该条目不存在则会抛出错误。如果<tt>value</tt>不是一个有限的数字，就会抛出一个异常。   
* [0.x.38]*
     将FullMatrix<double>中给出的所有元素设置为<tt>indices</tt>给出的稀疏矩阵位置。换句话说，这个函数将<tt>full_matrix</tt>中的元素写入调用的矩阵中，对矩阵的行和列都使用<tt>indices</tt>指定的本地到全球索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。        如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。        可选的参数<tt>elide_zero_values</tt>可以用来指定零值是否应该被插入，还是应该被过滤掉。默认值是<tt>false</tt>，也就是说，即使是零值也要插入/替换。   
* [0.x.39]*
     与之前的功能相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的局部到全局的索引。   
* [0.x.40]*
     将矩阵的指定行中的几个元素与<tt>col_indices</tt>给出的列索引设置为相应的值。        如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。        可选的参数<tt>elide_zero_values</tt>可以用来指定零值是否应该被插入，还是应该被过滤掉。默认值是<tt>false</tt>，也就是说，即使是零值也要插入/替换。   
* [0.x.41]*
     将几个元素设置为由<tt>values</tt>给定的值，在由col_indices给定的列中设置为稀疏矩阵的行。        如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。        可选的参数<tt>elide_zero_values</tt>可以用来指定零值是否应该被插入，还是应该被过滤掉。默认值是<tt>false</tt>，也就是说，即使是零值也要插入/替换。   
* [0.x.42]*
     将[2.x.10]添加到元素（[1.x.1]）。        如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一个新的条目，如果该条目之前不存在的话，这与SparseMatrix类非常不同，后者在该条目不存在的情况下会抛出一个错误。如果<tt>value</tt>不是一个有限的数字，就会抛出一个异常。   
* [0.x.43]*
     将FullMatrix<double>中给出的所有元素添加到由<tt>indices</tt>给出的稀疏矩阵位置。换句话说，这个函数将<tt>full_matrix</tt>中的元素添加到调用矩阵的相应条目中，使用<tt>indices</tt>为矩阵的行和列指定的本地到全球索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。        如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。        可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。   
* [0.x.44]*
     与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。   
* [0.x.45]*
     将矩阵的指定行中的几个元素与<tt>col_indices</tt>给出的列索引设置为相应的值。        如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。        可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。   
* [0.x.46]*
     在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<tt>values</tt>给出的数值阵列。        如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类形成鲜明对比，后者在条目不存在的时候会抛出一个错误。        可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。   
* [0.x.47]*
     将此<tt>行</tt>中的所有元素设置为零，将其删除。这个函数并不修改分配的非零条目的数量，它只是将一些条目设置为零。不过，它可能会将它们从稀疏模式中删除（但会保留分配的内存，以备以后再次添加新的条目）。        这个操作用于消除约束（例如由于挂起的节点），并确保我们可以将这个修改写入矩阵，而不需要从矩阵中读取条目（例如非零元素的位置）。
* 
* - 如果没有这个操作，消除平行矩阵的约束是一个相当复杂的过程。        第二个参数可以用来将该行的对角线条目设置为一个不同于零的值。默认是将其设置为零。   
* [0.x.48]*
     与clear_row()相同，只是它同时作用于若干行。        第二个参数可以用来将所有被清除的行的对角线条目设置为不同于0的内容。请注意，所有这些对角线项都得到相同的值
* 
* - 如果你想要不同的对角线条目的值，你必须手动设置它们。   
* [0.x.49]*
     PETSc矩阵存储了它们自己的稀疏性模式。因此，与我们自己的SparsityPattern类相类似，这个函数压缩了稀疏模式，并允许将得到的矩阵用于所有其他操作，而以前只允许使用汇编函数。因此，一旦你组装了矩阵，就必须调用这个函数。        更多信息请参见 [2.x.11] "压缩分布式对象"。   
* [0.x.50]*
     返回条目的值（[1.x.2]）。 这可能是一个昂贵的操作，你应该始终注意在哪里调用这个函数。    与[2.x.12]类中的相应函数相比，如果相应的条目不存在于该类的稀疏模式中，我们不会抛出一个异常，因为PETSc并不传输这一信息。        因此这个函数完全等同于<tt>el()</tt>函数。   
* [0.x.51]*
     返回矩阵条目的值（[1.x.3]）。如果这个条目不存在于稀疏模式中，那么就返回0。虽然这在某些情况下可能很方便，但请注意，由于没有使用矩阵的稀疏性，写出的算法与最优解相比很简单，很慢。   
* [0.x.52]*
     返回第[1.x.4]行中的主对角线元素。如果矩阵不是二次的，这个函数会抛出一个错误。        由于我们不能直接访问底层数据结构，这个函数并不比使用el()函数的元素访问快。然而，我们提供这个函数是为了与SparseMatrix类兼容。   
* [0.x.53]*
     返回这个矩阵的行数。   
* [0.x.54]*
     返回这个矩阵中的列数。   
* [0.x.55]*
     返回矩阵的本地维度，即存储在当前MPI进程中的行数。对于顺序矩阵，这个数字与m()相同，但对于并行矩阵，这个数字可能更小。        要想知道到底哪些元素被存储在本地，可以使用local_range()。   
* [0.x.56]*
     返回一对指数，表明该矩阵的哪些行是本地存储的。第一个数字是存储的第一行的索引，第二个数字是本地存储的最后一行之后的那一行的索引。如果这是一个连续的矩阵，那么结果将是一对(0,m())，否则将是一对(i,i+n)，其中<tt>n=local_size()</tt>。   
* [0.x.57]*
     返回[2.x.13]是否在本地范围内，另见local_range()。   
* [0.x.58]*
     返回对与该矩阵一起使用的MPI通信器对象的引用。这个函数必须在派生类中实现。   
* [0.x.59]*
     返回这个矩阵的非零元素的数量。实际上，它返回的是稀疏模式中的条目数；如果任何一个条目碰巧是零，无论如何都会被计算在内。   
* [0.x.60]*
     特定行中的条目数。   
* [0.x.61]*
     返回矩阵的l1准则，即[2.x.14] ，（最大列数之和）。这是一个自然的矩阵准则，与向量的l1准则兼容，即[2.x.15] 。(参看Haemmerlin-Hoffmann: Numerische Mathematik)    
* [0.x.62]*
     返回矩阵的linfty-norm，即[2.x.16] ，（最大行数之和）。这是一个自然的矩阵规范，与向量的linfty-norm兼容，即[2.x.17] 。(参看Haemmerlin-Hoffmann: Numerische Mathematik)    
* [0.x.63]*
     返回矩阵的frobenius norm，即矩阵中所有条目的平方之和的平方根。   
* [0.x.64]*
     返回向量[2.x.18]相对于该矩阵诱导的准则的平方，即[2.x.19] 。这很有用，例如在有限元背景下，一个函数的[2.x.20]规范等于相对于代表有限元函数节点值的向量的质量矩阵的矩阵规范。        很明显，对于这个操作，矩阵需要是二次的。        这个函数的实现没有deal.II中使用的[2.x.21]类（即原始的，而不是PETSc封装类）的效率高，因为PETSc不支持这个操作，需要一个临时向量。        注意，如果当前对象代表一个并行的分布式矩阵（类型为[2.x.22]，那么给出的向量也必须是一个分布式向量。反之，如果矩阵不是分布式的，那么向量也不可能是。   
* [0.x.65]*
     计算矩阵标量乘积 [2.x.23] 。        这个函数的实现不如deal.II中使用的[2.x.24]类（即原始函数，而不是PETSc封装类）的效率高，因为PETSc不支持这个操作，需要一个临时矢量。        注意，如果当前对象代表一个平行分布式矩阵（类型为[2.x.25]，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可能是。   
* [0.x.66]*
     返回矩阵的轨迹，即矩阵中所有对角线项的总和。   
* [0.x.67]*
     将整个矩阵乘以一个固定系数。   
* [0.x.68]*
     用整个矩阵除以一个固定系数。   
* [0.x.69]*
     将矩阵[2.x.26]按系数[2.x.27]的比例添加到当前矩阵中。   
* [0.x.70]*
     矩阵-向量乘法：让[1.x.5]与[1.x.6]是这个矩阵。        源和目的不能是同一个向量。        注意，如果当前对象代表一个平行分布式矩阵（类型为[2.x.28]，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。   
* [0.x.71]*
     矩阵-向量乘法：让[1.x.7]与[1.x.8]为这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。        源和目的不能是同一个向量。        注意，如果当前对象代表一个并行分布式矩阵（类型为[2.x.29]，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。   
* [0.x.72]*
     加法 矩阵-向量乘法。在[1.x.10]上添加[1.x.9]，[1.x.11]为该矩阵。        源和目的不能是同一个向量。        注意，如果当前对象代表一个平行分布式矩阵（类型为[2.x.30]，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。   
* [0.x.73]*
     加法 矩阵-向量乘法。将[1.x.12]加到[1.x.13]，[1.x.14]是这个矩阵。这个函数与vmult_add()的作用相同，但需要转置的矩阵。        来源和目的地不能是同一个向量。        注意，如果当前对象代表一个并行分布式矩阵（类型为[2.x.31]，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。   
* [0.x.74]*
     计算一个方程[1.x.15]的残差，其中残差被定义为[1.x.16]。将残差写入[2.x.32] 返回残差向量的[1.x.17]准则。        源[1.x.18]和目的[1.x.19]不能是同一个向量。        注意，如果当前对象代表一个平行分布式矩阵（类型为[2.x.33]，那么所有的向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不能是。   
* [0.x.75]*
     迭代器从第一个条目开始。这只能在拥有整个矩阵的处理器上调用。在所有其他情况下，请参考以行号为参数的begin()的版本。   
* [0.x.76]*
     最后的迭代器。这只能在拥有整个矩阵的处理器上调用。在所有其他情况下，请参考end()的版本，以一个行号作为参数。   
* [0.x.77]*
     迭代器从第[2.x.34]行的第一个条目开始 注意，如果给定的行是空的，即不包含任何非零条目，那么这个函数返回的迭代器就等于<tt>end(r)</tt>。还要注意的是，在这种情况下，迭代器可能不能被解除引用。   
* [0.x.78]*
     行<tt>r</tt>的最终迭代器。它指向超过行[2.x.35]末尾的第一个元素，或者超过整个稀疏模式的末尾。        请注意，结束迭代器不一定是可被解除引用的。特别是如果它是一个矩阵的最后一行的结束迭代器，情况更是如此。   
* [0.x.79]*
     转换操作符，以获得对底层PETSc类型的访问。如果你这样做，你就切断了这个类可能需要的一些信息，所以这个转换操作符应该只在你知道你要做什么的时候使用。特别是，它应该只用于对矩阵的只读操作。   
* [0.x.80]*
     返回一个对底层PETSc类型的引用。它可以用来修改底层数据，所以只有在你知道你在做什么的时候才使用它。   
* [0.x.81]*
     对一个矩阵进行原地转置。   
* [0.x.82]*
     测试矩阵是否是对称的。 默认公差为[2.x.36] -位机器精度。   
* [0.x.83]*
     测试一个矩阵是否是赫米特的，即它是其转置的复共轭。默认公差为[2.x.37] -位机器精度。   
* [0.x.84]*
     使用PETSc内部矩阵查看器功能<tt>MatView</tt>打印PETSc矩阵对象的值。默认格式是打印非零矩阵元素。对于其他有效的查看格式，请参考http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatView.html    
* [0.x.85]*
     打印矩阵的元素到给定的输出流。         [2.x.38] out 要写入的输出流。     [2.x.39] alternative_output 这个参数被忽略。它的存在是为了与其他矩阵类中的类似函数兼容。   
* [0.x.86]*
     返回该矩阵在该CPU上所消耗的字节数。   
* [0.x.87]*
     异常情况    
* [0.x.88]*
     异常情况。   
* [0.x.89]*
     一个PETSc中的通用矩阵对象。实际的类型是稀疏矩阵，在构造函数中设置。   
* [0.x.90]*
     存储最后一个动作是写还是加操作。   
* [0.x.91]*
     确保此调用后的动作所需的添加/设置模式与当前模式兼容。应该从所有访问矩阵元素的内部函数中调用。   
* [0.x.92]*
     内部函数，检查是否有未决的插入/添加操作。否则会抛出一个异常。在调用任何修改矩阵的PETSc内部函数之前，都是有用的。   
* [0.x.93]*
     对于某些矩阵存储格式，特别是PETSc分布式块状矩阵，单个元素的设置和添加操作不能自由混合。相反，当我们想从设置元素切换到添加元素时，我们必须同步操作。BlockMatrixBase通过为每个块调用这个辅助函数来自动同步访问。这个函数确保矩阵处于允许添加元素的状态；如果它之前已经处于这种状态，那么这个函数什么也不做。   
* [0.x.94]*
     与prepare_add()相同，但如果该类中的元素表示法需要这样的操作，则为设置元素准备矩阵。   
* [0.x.95]*
     执行矩阵-矩阵乘法[2.x.40]的基础函数，或者，如果给出一个大小与B兼容的向量[2.x.41]，则为[2.x.42]，其中[2.x.43]定义了一个带有向量项的对角矩阵。        这个函数假定调用矩阵[2.x.44]和[2.x.45]的大小兼容。[2.x.46]的大小将在本函数中设置。        矩阵[2.x.47]的内容和稀疏模式将被这个函数重置，所以要确保稀疏模式没有在你的程序中其他地方使用。这是一个昂贵的操作，所以在使用这个函数之前请三思。   
* [0.x.96]*
     基准函数，用于执行矩阵与<tt>this</tt>的转置相乘，即[2.x.48]，或者，如果给出一个可选矢量[2.x.49]，其大小与[2.x.50]兼容，则为[2.x.51]，其中[2.x.52]定义了一个带有矢量项的对角矩阵。        这个函数假设调用矩阵[2.x.53]和[2.x.54]的大小兼容。[2.x.55]的大小将在本函数中设置。        矩阵[2.x.56]的内容和稀疏模式将被这个函数改变，所以要确保稀疏模式没有在你的程序中其他地方使用。这是一个昂贵的操作，所以在使用这个函数之前请三思。   
* [0.x.97]*
     一个内部的整数数组，当向（大的）稀疏矩阵添加/插入本地数据时，用于存储列索引。        这个变量并不存储矩阵对象的任何 "状态"。相反，它只是被这个类的一些成员函数用作临时缓冲区。与所有的[2.x.57]成员变量一样，除非有突变器的保护，否则对这个变量的使用不是线程安全的。然而，由于PETSc矩阵操作无论如何都不是线程安全的，所以没有必要试图使事情变得线程安全，所以没有与这个变量相关的突变。   
* [0.x.98]*
     一个内部的双值数组，在向（大的）稀疏矩阵添加/插入本地数据时，用于存储列索引。        与上面[2.x.58]变量的注释相同。   
* [0.x.99]

