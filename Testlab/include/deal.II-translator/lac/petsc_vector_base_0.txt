include/deal.II-translator/lac/petsc_vector_base_0.txt
[0.x.0]*
 一个命名空间，PETSc对象的封装类位于其中。
* 

* 
* [2.x.0] 

* 
* [2.x.1] 

 
* [0.x.1]*
    [2.x.2]内部  
* [0.x.2]*
   一个命名空间，用于PETScWrapper成员的内部实现细节。 
* [2.x.3]   
* [0.x.3]*
     由于对PETSc向量的访问只通过函数进行，而不是通过获得一个向量元素的引用，所以我们需要一个包装器类，它的作用就像一个引用一样，基本上把所有的访问（读和写）重定向到这个类的成员函数。        这个类实现了这样一个封装器：它用一个向量和其中的一个元素进行初始化，并有一个转换操作符来提取这个元素的标量值。它也有各种赋值运算符，用于向这一个元素写入。   
* [2.x.4]     
* [0.x.4]*
       声明容器大小的类型。     
* [0.x.5]*
       构造函数。它是私有的，以便只允许实际的向量类来创建它。     
* [0.x.6]复制构造函数。     
* [0.x.7]*
       这看起来像一个复制操作符，但做的事情与平常不同。特别是，它并不复制这个引用的成员变量。相反，它处理的情况是，我们有两个向量[2.x.5]和[2.x.6]，像<tt>v(i)=w(i)</tt>中那样分配元素。这里，赋值的左手和右手都有数据类型VectorReference，但我们真正的意思是赋值这两个引用所代表的向量元素。这个操作符实现了这个操作。还要注意的是，这使得我们可以使赋值运算符成为常数。     
* [0.x.8]*
       与上面的函数相同，但用于非const引用对象。这个函数是需要的，因为编译器可能会自动为非常量对象生成一个拷贝操作符。     
* [0.x.9]*
       将向量的引用元素设置为<tt>s</tt>。     
* [0.x.10]*
       将<tt>s</tt>添加到矢量的引用元素中。     
* [0.x.11]*
       从向量的参考元素中减去<tt>s</tt>。     
* [0.x.12]*
       用<tt>s</tt>乘以矢量中的参考元素。     
* [0.x.13]*
       将向量中的参考元素除以<tt>s</tt>。     
* [0.x.14]*
       返回参考元素数值的实数部分。     
* [0.x.15]*
       返回参考元素值的虚数部分。           
* [2.x.7]这个操作对实数来说没有定义，会产生一个异常。     
* [0.x.16]*
       将引用转换为实际值，即返回向量中被引用元素的值。     
* [0.x.17]*
       异常情况      
* [0.x.18]*
       异常情况。     
* [0.x.19]*
       指向我们所参考的向量。     
* [0.x.20]*
       向量中被引用的元素的索引。     
* [0.x.21]*
    [2.x.8]   
* [0.x.22]*
   所有在PETSc向量类型之上实现的向量类的基类。由于在PETSc中，所有的向量类型（即顺序和平行的）都是通过填充一个抽象对象的内容来建立的，而这个抽象对象只能通过一个独立于实际向量类型的指针来引用，所以我们可以在这个基类中实现几乎所有的向量功能。因此，这个类也可以作为任何类型的PETSc [2.x.9]对象的deal.II兼容包装器使用。派生类将只需要提供创建一种或另一种矢量的功能。    这个类的接口是以deal.II中现有的Vector类为模型的。它有几乎相同的成员函数，并且通常是可交换的。然而，由于PETSc只支持单一的标量类型（要么是double，要么是float，要么是一个复杂的数据类型），所以它没有模板化，只能与你的PETSc安装时定义的数据类型[2.x.10]一起工作。    请注意，只有在向量装配后调用了[2.x.11]和[2.x.12]这两个函数，PETSc才能保证操作符合你的期望。因此，你需要在实际使用矢量之前调用[2.x.13]。   
* [2.x.14]   
* [0.x.23]*
     声明一些在所有容器中使用的标准类型。这些类型与<tt>C++</tt>标准库<tt>vector<...></tt>类中的类型平行。   
* [0.x.24]*
     默认构造函数。它不做任何事情，派生类将不得不初始化数据。   
* [0.x.25]*
     复制构造函数。将维度设置为给定的向量，并复制所有元素。   
* [0.x.26]*
     从一个PETSc Vec对象初始化一个向量。注意，我们没有复制向量，也没有获得所有权，所以我们没有在析构函数中销毁PETSc对象。   
* [0.x.27]*
     删除了复制赋值运算符，以避免意外的使用带来意外的行为。   
* [0.x.28]*
     解构器。   
* [0.x.29]*
     释放所有内存并返回到与调用默认构造函数后相同的状态。   
* [0.x.30]*
     压缩PETSc对象的底层表示，即刷新矢量对象的缓冲区（如果它有的话）。这个函数在逐一写入矢量元素后，在对其进行任何其他操作之前是必要的。        更多信息请参见 [2.x.15] "压缩分布式对象"。   
* [0.x.31]*
     将向量的所有分量设置为给定的数字 [2.x.16] 只需将其传递给各个块对象，但我们仍然需要声明这个函数，以使讨论中给出的关于使构造函数显式的例子发挥作用。            由于将标量分配给向量的语义并不立即明确，这个操作符实际上应该只在你想将整个向量设置为零时才使用。这样就可以使用直观的符号<tt>v=0</tt>。赋予其他的值是被弃用的，将来可能会被禁止使用。   
* [0.x.32]*
     检验是否相等。这个函数假定现在的向量和要比较的向量已经有相同的大小，因为比较不同大小的向量反正没有什么意义。   
* [0.x.33]*
     测试不平等。这个函数假定现在的向量和要比较的向量已经有相同的大小，因为比较不同大小的向量反正没有什么意义。   
* [0.x.34]*
     返回向量的全局尺寸。   
* [0.x.35]*
     返回向量的局部尺寸，即存储在当前MPI进程中的元素数量。对于顺序向量，这个数字与size()相同，但对于并行向量，它可能更小。        要想知道到底哪些元素是存储在本地的，可以使用local_range()或local_owned_elements()。         [2.x.17]用local_owned_size()代替。   
* [0.x.36]*
     返回向量的本地维度，即存储在当前MPI进程中的元素数量。对于顺序向量，这个数字与size()相同，但对于并行向量，它可能更小。        要想知道哪些元素确切地存储在本地，可以使用local_range()或local_owned_elements()。   
* [0.x.37]*
     返回一对指数，表明该向量的哪些元素被存储在本地。第一个数字是存储的第一个元素的索引，第二个数字是本地存储的最后一个元素之后的索引。如果这是一个顺序向量，那么结果将是一对（0,N），否则将是一对（i,i+n），其中<tt>n=locally_owned_size()</tt>。   
* [0.x.38]*
     返回[2.x.18]是否在本地范围内，另见local_range()。   
* [0.x.39]*
     返回一个索引集，描述这个向量的哪些元素是由当前处理器拥有的。请注意，这个索引集不包括这个向量可能在本地存储为幽灵元素，但实际上是由另一个处理器拥有的元素。因此，如果这是一个分布式向量，在不同处理器上返回的索引集将形成不相交的集合，加起来就是完整的索引集。    很明显，如果一个向量只在一个处理器上创建，那么结果将满足    
* [1.x.0]
*     
* [0.x.40]*
     如果向量包含鬼魂元素，则返回。         [2.x.19] [2.x.20] "含有鬼魂元素的向量"    
* [0.x.41]*
     这个函数的存在只是为了与[2.x.21] [2.x.22]类兼容，并不做任何事情：这个类以不同的方式实现鬼魂值的更新，与底层的PETSc向量对象更加匹配。   
* [0.x.42]*
     提供对一个给定元素的访问，包括读和写。   
* [0.x.43]*
     提供对一个元素的只读访问。   
* [0.x.44]*
     提供对一个给定元素的访问，包括读和写。        与operator()完全相同。   
* [0.x.45]*
     提供对一个元素的只读访问。        与operator()完全相同。   
* [0.x.46]*
     一个集体的设置操作：这个函数允许一次性设置整个元素集，而不是设置一个向量的单个元素。    要设置的元素的索引在第一个参数中说明，相应的值在第二个参数中说明。   
* [0.x.47]*
     与通过operator()获取向量中的单个元素不同，这个函数允许一次性获取一整组元素。要读取的元素的索引在第一个参数中说明，相应的值在第二个参数中返回。        如果当前的向量被称为[2.x.23]，那么这个函数就等同于代码    
* [1.x.1]
* [2.x.24][2.x.25]和[2.x.26]数组的大小必须是一致的。   
* [0.x.48]*
     这个函数不是通过operator()获得向量的单个元素，而是允许一次获得整个元素集。与前一个函数不同的是，这个函数通过取消引用前两个参数提供的迭代器范围内的所有元素来获得元素的索引，并将向量的值放入通过取消引用从第三个参数指向的位置开始的迭代器范围获得的内存位置。        如果当前的向量被称为[2.x.27]，那么这个函数就等同于代码    
* [1.x.2]
* [2.x.28] 必须能够写进从[2.x.29]开始的尽可能多的内存位置，因为有[2.x.30]和[2.x.31]之间的迭代器。    
* [0.x.49]*
     一个集体的添加操作。这个函数将存储在[2.x.32]中的一整组值添加到[2.x.33]指定的向量成分中。    
* [0.x.50]*
     这是第二次集体添加操作。作为区别，这个函数需要一个deal.II的数值向量。   
* [0.x.51]*
     取一个<tt>n_elements</tt>连续存储的地址，并将其添加到向量中。处理上述其他两个<tt>add()</tt>函数未涵盖的所有情况。   
* [0.x.52]*
     返回两个向量的标量乘积。这两个向量必须有相同的大小。        对于复值向量，这将得到 [2.x.34] 。   
* [0.x.53]*
     返回[2.x.35]-norm的平方。   
* [0.x.54]*
     返回这个向量的元素的平均值。   
* [0.x.55]*
      该向量的[2.x.36]-norm。绝对值的总和。       
* [2.x.37] 在3.7.0以前的复值PETSc中，这个规范被实现为复数向量元素的实部和虚部的绝对值之和。   
* [0.x.56]*
      [2.x.38] - 矢量的规范。 各元素的平方根之和。   
* [0.x.57]*
       元素绝对值的p次方之和的p次根。   
* [0.x.58]*
      [2.x.40] -向量的规范。返回具有最大绝对值的向量元素的值。   
* [0.x.59]*
     执行一个矢量加法和后续内积的组合操作，返回内积的值。换句话说，这个函数的结果与用户调用    
* [1.x.3]
* 这个函数存在的原因是为了与deal.II自己的向量类兼容，后者可以用较少的内存传输实现这个功能。然而，对于PETSc向量来说，这样的组合操作是不被原生支持的，因此其代价完全等同于单独调用这两个方法。        对于复值向量，第二步中的标量乘积被实现为[2.x.41] .    
* [0.x.60]*
     返回具有最大负值的向量元素的值。         [2.x.42] 为了提高与其他继承自VectorSpaceVector的类的兼容性，这个函数已经被废弃。如果你需要使用这个功能，那么请使用PETSc函数VecMin代替。   
* [0.x.61]*
     返回具有最大正值的向量元素的值。         [2.x.43] 这个函数已经被废弃，以提高与其他继承自VectorSpaceVector的类的兼容性。如果你需要使用这个功能，那么请使用PETSc函数VecMax代替。   
* [0.x.62]*
     返回向量是否只包含值为0的元素。这是一个集体操作。这个函数很昂贵，因为可能所有的元素都要被检查。   
* [0.x.63]*
     如果向量没有负的条目，即所有条目都是零或正，则返回[2.x.44]。例如，这个函数用于检查细化指标是否真的都是正的（或零）。         [2.x.45]这个函数已经被废弃，以改善与其他继承自VectorSpaceVector的类的兼容性。   
* [0.x.64]*
     将整个向量乘以一个固定的因子。   
* [0.x.65]*
     将整个向量除以一个固定的因子。   
* [0.x.66]*
     将给定的向量添加到当前的向量中。   
* [0.x.67]*
     从现在的向量中减去给定的向量。   
* [0.x.68]*
     将[2.x.46]加到所有组件上。注意[2.x.47]是一个标量而不是一个向量。   
* [0.x.69]*
     一个向量的倍数的简单加法，即<tt>*this += a*V</tt>。   
* [0.x.70]*
     缩放向量的多重加法，即：<tt>*this += a*V+b*W</tt>。   
* [0.x.71]*
     缩放和简单的向量相加，即<tt>*this = s*(*this)+V</tt>。   
* [0.x.72]*
     缩放和简单加法，即：<tt>*this = s*(*this)+a*V</tt>。   
* [0.x.73]*
     用参数中的相应元素来缩放这个向量的每个元素。这个函数主要是为了模拟对角线缩放矩阵的乘法（和立即重新分配）。   
* [0.x.74]*
     赋值 <tt>*this = a*V</tt>.    
* [0.x.75]*
     使用PETSc内部矢量查看器函数<tt>VecView</tt>打印PETSc矢量对象的值。默认格式是打印矢量的内容，包括矢量元素的索引。对于其他有效的视图格式，请参考http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Vec/VecView.html    
* [0.x.76]*
     打印到一个流。 [2.x.48]表示打印数值所需的精度，[2.x.49]是否应使用科学符号。如果[2.x.50]是[2.x.51]，那么向量将被打印在一行中，而如果[2.x.52]则元素被打印在单独的一行中。   
* [0.x.77]*
     交换这个向量和另一个向量的内容 [2.x.53] 人们可以用一个临时变量和复制数据元素来完成这个操作，但是这个函数明显更有效率，因为它只交换了两个向量的数据指针，因此不需要分配临时存储和移动数据。        这个函数类似于所有C++标准容器的[2.x.54]函数。此外，还有一个全局函数<tt>swap(u,v)</tt>，它简单地调用<tt>u.swap(v)</tt>，同样与标准函数相类似。   
* [0.x.78]*
     转换操作符，以获得对底层PETSc类型的访问。如果你这样做，你就切断了这个类可能需要的一些信息，所以这个转换操作符应该只在你知道你要做什么的情况下使用。特别是，它应该只用于对向量的只读操作。   
* [0.x.79]*
     对内存消耗的估计（这个类没有实现）。   
* [0.x.80]*
     返回一个对与此对象一起使用的MPI通信器对象的引用。   
* [0.x.81]*
     一个PETSc中的通用向量对象。实际的类型，一个连续的向量，在构造函数中被设置。   
* [0.x.82]*
     表示这个向量是否有与之相关的鬼魂索引。这意味着并行程序中至少有一个进程有至少一个幽灵索引。   
* [0.x.83]*
     这个向量包含鬼魂值的全局索引。这个向量中的位置表示本地编号，在PETSc中使用。   
* [0.x.84]*
     存储最后一个动作是写操作还是加操作。这个变量是[2.x.55]，这样访问器类就可以写到它，即使它们引用的向量对象是常量。   
* [0.x.85]*
     指定该向量是否是PETSc Vec的所有者。如果它是由这个类创建的，这就是真的，并决定它是否在析构器中被销毁。   
* [0.x.86]*
     集合设置或添加操作。这个函数由集体[2.x.56]和[2.x.57]调用，[2.x.58]标志设置为相应的值。   
* [0.x.87]*
   全局函数[2.x.59]，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个向量的数据。     [2.x.60] [2.x.61].   
* [0.x.88]

