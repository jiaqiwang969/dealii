include/deal.II-translator/lac/cuda_sparse_matrix_0.txt
[0.x.0]*
   这个类是cuSPARSE csr稀疏矩阵的一个包装器。与deal.II自己的SparseMatrix不同，每一行中的所有元素都是按照列索引递增的顺序存储。   
* [2.x.0] 这个模板的实例化是为<tt> [2.x.1] 和 [2.x.2] 提供的。    
* [2.x.3]   
* [0.x.1]*
     声明容器尺寸的类型。   
* [0.x.2]*
     矩阵条目的类型。   
* [0.x.3]*
     声明一个保存实值数的类型，其精度与该类的模板参数相同。   
* [0.x.4]*
      [2.x.4] 构造函数和初始化    
* [0.x.5]*
     构造函数。将矩阵初始化为空，没有任何结构，也就是说，矩阵根本无法使用。因此，这个构造函数只对属于一个类的成员的矩阵有用。        在使用之前，你必须先用reinit初始化矩阵。   
* [0.x.6]*
     构造函数。接受一个[2.x.5]和一个主机上的稀疏矩阵。主机上的稀疏矩阵被复制到设备上，并且根据cuSPARSE支持的格式对元素进行重新排序。   
* [0.x.7]*
     移动构造函数。通过窃取内部数据来创建一个新的SparseMatrix。   
* [0.x.8]*
     复制构造函数被删除。   
* [0.x.9]*
     解除构造函数。释放所有的内存。   
* [0.x.10]*
     移动赋值运算符。   
* [0.x.11]*
     复制赋值被删除。   
* [0.x.12]*
     重新初始化稀疏矩阵。主机上的稀疏矩阵被复制到设备上，并且根据cuSPARSE支持的格式对元素进行重新排序。   
* [0.x.13]*
      [2.x.6] 矩阵的信息    
* [0.x.14]*
     返回共域（或范围）空间的维数。注意，矩阵的维度是[2.x.7] 。   
* [0.x.15]*
     返回域空间的维度。注意，矩阵的维度是[2.x.8] .    
* [0.x.16]*
     返回这个矩阵的非零元素的数量。实际上，它返回的是稀疏模式中的条目数；如果任何一个条目碰巧是零，无论如何都会被计算在内。   
* [0.x.17]*
     打印矩阵到给定的流，使用格式<tt>(row,column) value</tt>，即每行打印矩阵的一个非零条目。如果<tt>across</tt>为真，则在单行上打印所有条目，使用格式row,column:value。        如果参数<tt>diagonal_first</tt>为真，二次元矩阵的对角线元素将在其行中首先打印。如果它是假的，一行中的元素将按升列顺序写入。   
* [0.x.18]*
     以通常的格式打印矩阵，即作为矩阵而不是作为非零元素的列表。为了提高可读性，不在矩阵中的元素显示为空白，而明确设置为零的矩阵元素则显示为空白。        参数允许对输出格式进行灵活设置。    <tt>precision</tt>和<tt>scientific</tt>用于确定数字格式，其中<tt>scientific = false</tt>表示固定点符号。 <tt>width</tt>的一个零条目使函数计算出一个宽度，但如果输出粗略的话，可以将其改为一个正值。        此外，还可以指定一个空值的字符。        最后，整个矩阵可以与一个共同的分母相乘，以产生更可读的输出，甚至是整数。         [2.x.9] 如果应用于一个大的矩阵，这个函数可能会产生[1.x.0]量的输出!    
* [0.x.19]*
      [2.x.10] 修改条目    
* [0.x.20]*
     将整个矩阵乘以一个固定系数。   
* [0.x.21]*
     用整个矩阵除以一个固定的因子。   
* [0.x.22]*
      [2.x.11] 乘法运算    
* [0.x.23]*
     矩阵-向量乘法：让[2.x.12]与[2.x.13]为该矩阵。   
* [0.x.24]*
     矩阵-向量乘法：让[2.x.14]与[2.x.15]为这个矩阵。这个函数与vmult()的作用相同，但需要这个转置的矩阵。   
* [0.x.25]*
     添加矩阵-向量的乘法。在[2.x.17]上添加[2.x.16]，[2.x.18]是这个矩阵。   
* [0.x.26]*
     添加矩阵-向量的乘法。将[2.x.19]加到[2.x.20]，[2.x.21]是这个矩阵。这个函数的作用与vmult_add()相同，但需要转置的矩阵。   
* [0.x.27]*
     返回向量[2.x.22]相对于该矩阵诱导的准则的平方，即[2.x.23]。这很有用，例如，在有限背景下，一个函数的[2.x.24]规范等于相对于代表有限元函数节点值的向量的质量矩阵的矩阵规范。        很明显，对于这个操作，矩阵需要是二次的。   
* [0.x.28]*
     计算矩阵标量乘积 [2.x.25] 。   
* [0.x.29]*
     计算方程[2.x.26]的残差，其中残差被定义为[2.x.27]。将残差写进 [2.x.28] 。返回残差向量的[2.x.29]准则。        源[2.x.30]和目的[2.x.31]不能是同一个向量。   
* [0.x.30]*
      [2.x.32] 矩阵规范    
* [0.x.31]*
     返回矩阵的[2.x.33]-规范，即[2.x.34] ，（最大列数之和）。这是自然的矩阵准则，与向量的[2.x.35]准则兼容，即[2.x.36] 。   
* [0.x.32]*
     返回矩阵的[2.x.37]准则，即[2.x.38] ，（行的最大和）。这是与向量的[2.x.39]规范兼容的自然规范，即[2.x.40] 。   
* [0.x.33]*
     返回矩阵的frobenius规范，即矩阵中所有条目的平方和的平方根。   
* [0.x.34]*
     [2.x.41] 访问底层CUDA数据    
* [0.x.35]*
     返回一个元组，包含矩阵值的指针，列索引的指针，行指针的指针，cuSPARSE矩阵描述，以及cuSPARSE SP矩阵描述。   
* [0.x.36]*
     用于调用cuSPARSE函数的cuSPARSE句柄。   
* [0.x.37]*
     稀疏矩阵中非零元素的数量。   
* [0.x.38]*
     稀疏矩阵的行数。   
* [0.x.39]*
     稀疏矩阵的列数。   
* [0.x.40]*
     指向稀疏矩阵的值（在设备上）的指针。   
* [0.x.41]*
     指向稀疏矩阵的列索引（在设备上）的指针。   
* [0.x.42]*
     指向稀疏矩阵的行指针的指针（在设备上）。   
* [0.x.43]*
     矩阵的cuSPARSE描述。   
* [0.x.44]*
     cuSPARSE描述的稀疏矩阵。   
* [0.x.45]

