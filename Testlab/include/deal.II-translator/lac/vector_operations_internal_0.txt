include/deal.II-translator/lac/vector_operations_internal_0.txt
[0.x.0]*
     这个结构从tbb并行for循环中获取循环范围，并将其转换为矢量中for循环的实际范围。它对粒度进行编码，但可能会选择比最小粒度更大的块值。然后，给tbb的最小粒度是简单的1。由于亲和力的原因，这个循环中的布局必须与各自的类保持同步，以便进一步削减。   
* [0.x.1]*
     将范围[first,last]划分为两个的最小块数（每个大小为32）（accumulate_recursive中if分支的第二部分）。   
* [0.x.2]*
     这个结构从tbb并行for循环中获取循环范围，并将其转换为矢量内部还原循环的实际范围。它对粒度进行编码，但可能会选择比最小粒度更大的块值。给予tbb的最小粒度是1。由于亲和力的原因，这个循环中的布局必须与各自的类保持同步，用于进一步向上的普通for循环。        由于这种结构，TBB通常只看到一个长度为4*num_threads，粒度为1的循环。矢量内部的实际范围是在TBB之外计算的，因为否则TBB会在一些不可预测的位置分割范围，这就破坏了精确的位法可重复性。其中一个重要的部分是，在[2.x.0]里面，对累积的递归调用是按顺序对一个项目进行的（尽管我们可以通过[2.x.1]乘以分块大小直接在整个范围内运行它
* 

* 
* 

* 
* 

 
 

 
 

 
* 
* - 但这将是不可预测的）。) 因此，我们不能控制的值是在数组中被填充的位置
* 
* 但在这一点上，TBB看到的算法只是一个并行的，没有什么不可预测的事情会发生。        总结一下。一旦线程数和向量大小固定下来，我们就有了调用递归函数的确切布局。在递归函数内部，我们再次只依赖于长度。最后，并发线程以线程安全的方式写入结果向量的不同位置，短数组中的加法也是串行的。   
* [0.x.3]*
       TBB使用的一个操作符，用于处理给定的[2.x.2]块[range.begin(), range.end()]。     
* [0.x.4]*
     这是并行工作的平行还原操作的一般调用者。   
* [0.x.5]

