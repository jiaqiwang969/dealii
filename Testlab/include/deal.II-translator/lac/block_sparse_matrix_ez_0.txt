include/deal.II-translator/lac/block_sparse_matrix_ez_0.txt
[0.x.0]!  [2.x.0] Matrix1 [2.x.1]. 

* 
* [0.x.1]*
 一个由SparseMatrixEZ类型的块组成的块矩阵。
* 与其他块对象一样，这个矩阵可以像SparseMatrixEZ一样使用，当涉及到对条目的访问时。然后，还有一些函数用于与BlockVector相乘，以及对单个块的访问。
* [2.x.2] [2.x.3] "块（线性代数）"

* 
* [0.x.2]*
   声明容器大小的类型。 
* [0.x.3]*
   默认构造函数。其结果是一个尺寸为零的空对象。 
* [0.x.4]*
   构造函数以给定的块的行和列的数量设置一个对象。块本身仍有零维度。 
* [0.x.5]*
   复制构造函数。这对于一些容器类来说是需要的。它创建一个具有相同数量的块行和块列的对象。因为它调用了SparseMatrixEZ的复制构造函数，所以块s必须是空的。 
* [0.x.6]*
   拷贝操作符。和复制构造函数一样，它只能被调用于空块的对象。 
* [0.x.7]*
   这个操作符将一个标量分配给一个矩阵。因为这通常没有什么意义（我们应该把所有的矩阵条目都设置为这个值吗？仅仅是稀疏模式的非零条目？），这个操作只允许在实际要分配的值为零时进行。这个操作符的存在只是为了允许明显的符号<tt>matrix=0</tt>，它将矩阵的所有元素设置为零，但保留之前使用的稀疏模式。 
* [0.x.8]*
   将矩阵设置为零维，并释放内存。 
* [0.x.9]*
   初始化为给定的块数。 在此操作之后，矩阵将具有所提供的块的尺寸。每个区块的尺寸都是零，必须随后进行初始化。在设置块的尺寸后，必须调用collect_sizes()来更新内部数据结构。 
* [0.x.10]*
   这个函数收集了子对象的尺寸，并将其存储在内部数组中，以便能够将矩阵的全局索引转为子对象的索引。在你改变了子对象的大小之后，你必须*每次都调用这个函数。 
* [0.x.11]*
   访问具有给定坐标的块。 
* [0.x.12]*
   访问具有给定坐标的块。对于常量对象的版本。 
* [0.x.13]*
   返回一列中的块的数量。 
* [0.x.14]*
   返回一行中的块数。 
* [0.x.15]*
   返回该对象是否为空。如果没有分配内存，它就是空的，这与两个维度都是零是一样的。这个函数只是对所有子矩阵的各自调用的串联。 
* [0.x.16]*
   返回该矩阵的行数，相当于共域（或范围）空间的维数。它是这个矩阵的子矩阵块上的行数之和。回顾一下，该矩阵的大小为m()乘以n()。 
* [0.x.17]*
   返回该矩阵的列数，等于域空间的维度。它是该矩阵的子矩阵块的列数之和。回顾一下，该矩阵的大小为m()乘以n()。 
* [0.x.18]*
   将元素<tt>(i,j)</tt>设为[2.x.4] 如果该条目不存在或<tt>值</tt>不是有限数，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 
* [0.x.19]*
   在元素<tt>(i,j)</tt>上添加[2.x.5]。 如果该条目不存在或者<tt>value</tt>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 
* [0.x.20]*
   矩阵-向量乘法：让[2.x.6]与[2.x.7]是这个矩阵。 
* [0.x.21]*
   矩阵-向量乘法：让[2.x.8]与[2.x.9]为这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 
* [0.x.22]*
   加法 矩阵-向量乘法。在[2.x.11]上添加[2.x.10]，[2.x.12]为该矩阵。 
* [0.x.23]*
   添加矩阵-向量乘法。将[2.x.13]加到[2.x.14]，[2.x.15]是这个矩阵。这个函数与vmult_add()的作用相同，但需要转置的矩阵。 
* [0.x.24]*
   打印统计数据。如果[2.x.16]是[2.x.17]，则打印所有现有行长和分配行长的直方图。否则，只显示已分配和已使用条目的关系。 
* [0.x.25]*
   对象存储和管理行索引到子对象索引的转换。 
* [0.x.26]*
   储存和管理列索引到子对象索引的转换的对象。 
* [0.x.27]*
   实际的矩阵  
* [0.x.28]

