include/deal.II-translator/lac/dynamic_sparsity_pattern_0.txt
[0.x.0]!  [2.x.0] 稀疏性 [2.x.1] 

* 
* [0.x.1]*
 DynamicSparsityPattern类型对象的迭代器。

* 
* [0.x.2]*
   声明容器大小的类型。 
* [0.x.3]*
   迭代器进入DynamicSparsityPattern类型的对象的访问器类。    请注意，这个类只允许对元素进行读取访问，提供它们的行和列号（或者是完整的稀疏模式中的索引）。它不允许修改稀疏度模式本身。 
* [0.x.4]*
     构造函数。   
* [0.x.5]*
     构造函数。为给定的稀疏模式构造结束访问器。   
* [0.x.6]*
     默认构造器创建一个假访问器。这个构造函数在这里只是为了能够在STL容器中存储访问器，例如 [2.x.2] 。    
* [0.x.7]*
     这个对象所代表的元素的行数。   
* [0.x.8]*
     这个对象所代表的元素在当前行中的索引。   
* [0.x.9]*
     这个对象所代表的元素的列号。   
* [0.x.10]*
     比较。如果两个迭代器都指向同一个矩阵位置，则为真。   
* [0.x.11]*
     比较运算符。如果第一行数字较小，或者行数字相等且第一个索引较小，则结果为真。        这个函数只有在两个迭代器都指向同一个稀疏模式时才有效。   
* [0.x.12]*
     我们所操作的稀疏模式被访问。   
* [0.x.13]*
     我们当前指向的行。   
* [0.x.14]*
     一个指向当前行内的元素的指针，我们当前指向的元素。   
* [0.x.15]*
     一个指向当前行结束的指针。我们存储这个指针是为了与行末迭代器进行比较，这样做比较便宜，否则它需要进行IndexSet转换，从行的索引到DynamicSparsityPattern的'lines'数组中的索引。   
* [0.x.16]*
     将访问器移动到矩阵中的下一个非零条目。   
* [0.x.17]*
   一个迭代器类，用于在稀疏性模式的元素上行走。    这些迭代器的典型用途是迭代稀疏模式的元素（或者，因为它们也是迭代相关矩阵的元素的基础，所以是迭代稀疏矩阵的元素），或者迭代单个行的元素。不能保证行的元素实际上是按照列数单调增加的顺序来遍历的。更多信息请参见SparsityPattern类的文档。   
* [2.x.3] 该类直接对DynamicSparsityPattern类的内部数据结构进行操作。因此，有些操作很便宜，有些则不然。特别是，访问指向的稀疏模式条目的列索引很便宜。另一方面，计算两个迭代器之间的距离是很昂贵的。因此，当你设计使用这些迭代器的算法时，通常的做法是不一次性循环疏散模式的[1.x.0]元素，而是在所有行上有一个外循环，并在这个循环中迭代这个行的元素。这样，你只需要解除对迭代器的引用以获得列索引，而通过使用循环索引可以避免对行索引的（昂贵）查找。 
* [0.x.18]*
     构造函数。为给定的全局索引（即从第2行开始计算的给定元素的索引）创建一个进入稀疏模式[2.x.4]的迭代器。   
* [0.x.19]*
     构造函数。创建一个无效的（结束）迭代器进入稀疏模式[2.x.5] 。    
* [0.x.20]*
     默认的构造函数，创建一个无效的迭代器。这个构造函数在这里只是为了能够在STL容器中存储迭代器，如[2.x.6]。    
* [0.x.21]*
     前缀增量。   
* [0.x.22]*
     后缀增量。   
* [0.x.23]*
     撤消运算符。   
* [0.x.24]*
     解除引用操作符。   
* [0.x.25]*
     比较。真，如果两个迭代器都指向同一个矩阵位置。   
* [0.x.26]*
     <tt>==</tt>的倒数。   
* [0.x.27]*
     比较运算符。如果第一个行号较小，或者行号相等且第一个索引较小，则结果为真。        这个函数只有在两个迭代器都指向同一个矩阵时才有效。   
* [0.x.28]*
     返回当前迭代器与参数之间的距离。这个距离是通过对当前迭代器应用operator++多少次才能得到参数（对于正的返回值），或operator--（对于负的返回值）。   
* [0.x.29]*
     存储一个访问器类的对象。   
* [0.x.30]*
 这个类作为SparsityPattern类的一个中间形式。从界面上看，它主要代表一个SparsityPattern对象，该对象在任何时候都保持压缩。然而，由于最终的稀疏度模式在构建时并不为人所知，因此在任何时候都保持压缩的模式只能以增加内存或使用时的运行时间消耗为代价。这个类的主要目的是为了避免一些内存瓶颈，所以我们选择实现它的内存保守性。不过，所选择的数据格式太不适合用于实际的矩阵。因此，在实际的矩阵中使用它之前，有必要先把这个对象的数据复制到SparsityPattern类型的对象上。
* 另一个观点是，这个类不需要预先分配一定的内存，而是根据需要增长。 在[2.x.7]模块的文档中可以找到关于稀疏性模式的广泛描述。
* 这个类是 [2.x.8] 的 "动态 "类型的一个例子。它以这样或那样的方式被用于大多数教程程序中。
* [1.x.1]
* 因为这个类是作为SparsityPattern类的中间替代物，所以它的接口大部分是相同的，在必要的地方有小的改动。特别是add()函数，以及查询稀疏模式属性的函数都是一样的。
* 

* [1.x.2]
* 这个类的用法在[2.x.9]（无约束）和[2.x.10]（有AffineConstraints）中解释，通常看起来如下。

* 
* [1.x.3]
* 

* 
* [0.x.31]*
   声明容器尺寸的类型。 
* [0.x.32]*
   Typedef一个迭代器类，允许在一个稀疏模式的所有非零元素上行走。    由于迭代器不允许修改稀疏模式，这个类型与[2.x.11]的类型相同。  
* [0.x.33]*
   迭代器类的类型定义，允许在稀疏模式的所有非零元素上行走。 
* [0.x.34]*
   初始化为一个空对象。如果你想让这样的对象作为其他类的成员变量，这很有用。你可以通过调用reinit()函数使该结构可用。 
* [0.x.35]*
   复制构造函数。这个构造函数只允许在要复制的稀疏结构为空时被调用。这样做是为了防止临时性的对象的非自愿复制，这可能会使用大量的计算时间。 然而，如果你想把一个DynamicSparsityPattern放在一个容器中，例如写这样的语句，如<tt>v.push_back(DynamicSparsityPattern());</tt>，[2.x.12]v是一个[2.x.13]对象的向量，就需要拷贝构造函数。 
* [0.x.36]*
   初始化一个具有[2.x.14]行和[2.x.15]列的矩形稀疏模式。[2.x.16]限制了对这个集合的行的元素的存储。 添加这个集合以外的元素没有影响。默认参数保留所有条目。 
* [0.x.37]*
   使用给定的索引集创建一个方形SparsityPattern。总大小由[2.x.17]的大小给出，并且只有与[2.x.18]中的索引相对应的行被存储在当前处理器上。 
* [0.x.38]*
   初始化一个尺寸为[2.x.19]的方形图案。  
* [0.x.39]*
   复制操作。对于这一点，与复制构造函数的情况相同：它被声明、定义并可以被调用，但后者只针对空对象。 
* [0.x.40]*
   为具有[2.x.20]行和[2.x.21]列的新稀疏模式重新分配内存并设置数据结构。[2.x.22]限制了对这个集合的行的元素的存储。 添加这个集合以外的元素没有影响。默认参数保留所有条目。 
* [0.x.41]*
   由于这个对象无论如何都是保持压缩的，所以这个函数什么都不做，但声明这个函数是为了使这个类的接口与SparsityPattern类的接口一样。 
* [0.x.42]*
   返回该对象是否为空。如果没有分配内存，它就是空的，这与两个维度都是零是一样的。 
* [0.x.43]*
   返回每行的最大条目数。注意，这个数字可能会随着条目的增加而改变。 
* [0.x.44]*
   添加一个非零的条目。如果该条目已经存在，这个调用不做任何事情。 
* [0.x.45]*
   在指定的行中添加几个非零的条目。已经存在的条目会被忽略。 
* [0.x.46]*
   检查某个位置的值是否可能为非零。 
* [0.x.47]*
   返回该稀疏模式的视图。  也就是说，对于[2.x.23]中的所有行，提取非空列。  得到的稀疏模式的行数将等于`rows.n_elements()`。 
* [0.x.48]*
   通过添加转置对象的稀疏度模式使稀疏度模式对称。    如果稀疏模式不代表一个正方形矩阵，这个函数会抛出一个异常。 
* [0.x.49]*
   构建并在此对象中存储对应于[2.x.24]和[2.x.25]稀疏模式的乘积的稀疏模式。 
* [0.x.50]*
   构造并在此对象中存储对应于转置[2.x.26]和非转置[2.x.27]稀疏模式乘积的稀疏模式。 
* [0.x.51]*
   打印稀疏性模式。输出包括每行一行，格式为<tt>[i,j1,j2,j3,...]/tt>。[1.x.4]是行号，[1.x.5]是这一行中分配的列。 
* [0.x.52]*
   以[2.x.28]理解的格式打印稀疏模式，该格式可用于以图形方式绘制稀疏模式。该格式由成对的<tt>i j</tt>非零元素组成，每个代表一个条目，在输出文件中每行一个。指数从零开始计算，如常。由于稀疏模式的打印方式与矩阵的显示方式相同，我们打印的是列索引的负数，这意味着<tt>(0,0)</tt>元素位于左上角而不是左下角。    在gnuplot中通过将数据样式设置为点或点来打印稀疏模式，并使用[2.x.29]命令。 
* [0.x.53]*
   返回行数，相当于图像空间的尺寸。 
* [0.x.54]*
   返回列数，相当于范围空间的尺寸。 
* [0.x.55]*
   特定行中的条目数。只有当给定的行是我们要存储的行的索引集的成员时，才能调用这个函数。 
* [0.x.56]*
   清除存储在某一特定行中的所有条目。 
* [0.x.57]*
   访问列号字段。 返回[2.x.30]中的第[2.x.31]个索引条目的列号。  
* [0.x.58]*
   返回[2.x.33]行中[2.x.32]列的索引 如果该列在此稀疏模式中不存在，返回值将是[2.x.34] 。  
* [0.x.59]*
    [2.x.35] 迭代器  
* [0.x.60]*
   迭代器从矩阵的第一个条目开始。产生的迭代器可以用来走过疏散模式的所有非零条目。    注意这个类的一般文档中关于元素被访问的顺序的讨论。   
* [2.x.36] 如果稀疏模式已经用IndexSet初始化，表示要存储哪些行，那么迭代器将简单地跳过没有存储的行。换句话说，它们看起来像空行，但是在迭代这些行的时候不会产生异常。 
* [0.x.61]*
   最终的迭代器。 
* [0.x.62]*
   迭代器从<tt>r</tt>行的第一个条目开始。    注意，如果给定的行是空的，即不包含任何非零条目，那么这个函数返回的迭代器就等于<tt>end(r)</tt>。还要注意的是，在这种情况下，迭代器可能是不能被解除引用的。    还要注意这个类的一般文档中关于元素被访问的顺序的讨论。   
* [2.x.37] 如果稀疏模式已经用IndexSet初始化，表示要存储哪些行，那么迭代器将简单地跳过没有存储的行。换句话说，它们看起来像空行，但是在迭代这些行的时候不会产生异常。 
* [0.x.63]*
   行<tt>r</tt>的最终迭代器。它指向超过[2.x.38]行末尾的第一个元素，或者超过整个稀疏模式的末尾。    请注意，结束迭代器不一定是可被解除引用的。特别是如果它是一个矩阵的最后一行的结束迭代器，情况更是如此。 
* [0.x.64]*
   计算这个结构所代表的矩阵的带宽。带宽是[2.x.39]的最大值，其中索引对[2.x.40]代表矩阵的一个非零条目。 
* [0.x.65]*
   返回通过该稀疏模式分配的非零元素的数量。 
* [0.x.66]*
   返回设定哪些行在当前处理器上是活动的IndexSet。它对应于在构造函数或reinit函数中给这个类的IndexSet。 
* [0.x.67]*
   返回包含所有列的条目的IndexSet，其中至少有一个元素存在于这个稀疏模式中。   
* [2.x.41]在并行情况下，这只考虑本地存储的行。 
* [0.x.68]*
   返回IndexSet，该索引集包含所有行的条目，其中至少有一个元素存在于该稀疏模式中。   
* [2.x.42]在并行情况下，这只考虑本地存储的行。 
* [0.x.69]*
   返回这个对象是否只存储那些显式添加的条目，或者稀疏模式是否包含在构建它时通过其他方式（隐式）添加的元素。对于当前的类，结果总是为真。    这个函数的主要作用是在几种稀疏模式可以作为模板参数传递的情况下描述当前类。 
* [0.x.70]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.71]*
   一个标志，存储到目前为止是否有任何条目被添加。 
* [0.x.72]*
   该稀疏结构应代表的行数。 
* [0.x.73]*
   这个稀疏结构所代表的列的数量。 
* [0.x.74]*
   一个包含有效行的集合。 
* [0.x.75]*
   为每一行存储一些数据，描述这一行的哪些条目是非零的。数据被分类存储在[2.x.43] [2.x.44]每行的向量在插入时是动态增长的，每次将其内存翻倍。 
* [0.x.76]*
     该行的列索引的存储。这个数组总是保持排序的。   
* [0.x.77]*
     将给定的列号添加到这一行。   
* [0.x.78]*
     将迭代器范围指定的列添加到这一行。   
* [0.x.79]*
     估计内存消耗。   
* [0.x.80]*
   实际数据：为每行存储非零条目的集合。 
* [0.x.81]

