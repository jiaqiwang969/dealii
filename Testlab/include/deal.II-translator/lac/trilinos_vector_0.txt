include/deal.II-translator/lac/trilinos_vector_0.txt
[0.x.0]*
  [2.x.0] TrilinosWrappers [2.x.1]. 

 
* [0.x.1]*
 一个命名空间，Trilinos对象的封装类位于其中。
* 

* 
* [2.x.2] 

* 
* [0.x.2]*
    [2.x.3]内部  
* [0.x.3]*
   一个命名空间，用于TrilinosWrapper成员的内部实现细节。   
* [2.x.4]   
* [0.x.4]*
     声明容器大小的类型。   
* [0.x.5]*
     这个类实现了一个用于访问Trilinos向量的包装器，就像我们访问deal.II对象一样：它被初始化为一个向量和其中的一个元素，并且有一个转换操作符来提取这个元素的标量值。它也有各种赋值运算符，用于向这一个元素写入。       
* [2.x.5]     
* [0.x.6]*
       构造函数。它是私有的，以便只允许实际的向量类来创建它。     
* [0.x.7]*
       复制构造函数。     
* [0.x.8]*
       这看起来像一个复制操作符，但做的事情与平常不同。特别是，它并不复制这个引用的成员变量。相反，它处理的情况是，我们有两个向量[2.x.6]和[2.x.7]，像<tt>v(i)=w(i)</tt>中那样分配元素。这里，赋值的左手和右手都有数据类型VectorReference，但我们真正的意思是赋值这两个引用所代表的向量元素。这个操作符实现了这个操作。还要注意的是，这使得我们可以使赋值运算符成为常数。     
* [0.x.9]*
       和上面一样，但对于非const的引用对象。     
* [0.x.10]*
       将向量的引用元素设置为<tt>s</tt>。     
* [0.x.11]*
       将<tt>s</tt>添加到矢量的引用元素中->。     
* [0.x.12]*
       从向量的参考元素中减去<tt>s</tt>->。     
* [0.x.13]*
       用<tt>s</tt>乘以矢量中的参考元素。     
* [0.x.14]*
       将向量的参考元素除以<tt>s</tt>。     
* [0.x.15]*
       将引用转换为实际值，即返回矢量中被引用元素的值。     
* [0.x.16]*
       异常情况      
* [0.x.17]*
       指向我们所引用的向量。     
* [0.x.18]*
       向量中被引用的元素的索引。     
* [0.x.19]*
    [2.x.8]   
* [0.x.20]*
   用于通过MPI并行工作的Trilinos向量类的命名空间。   
* [2.x.9]   
* [0.x.21]*
     该类实现了一个包装器，用于使用Trilinos分布式向量类Epetra_FEVector，其（并行）分区由Epetra_Map管理。    Epetra_FEVector正是我们一直在处理的那种矢量。
* 
* - 我们可能从一些装配过程中得到它，在那里，不属于本地的条目也可能需要被写入，因此需要转发给所有者。        这个类的接口是以deal.II中现有的Vector类为模型的。它有几乎相同的成员函数，并且通常是可交换的。然而，由于Trilinos只支持单一的标量类型（double），所以它不是模板化的，只对这种类型起作用。        请注意，只有在向量装配后调用了函数[2.x.10]以分配数据的情况下，Trilinos才会保证操作能达到你预期的效果。这是必要的，因为一些进程可能积累了不属于自己的元素数据，但必须被发送到拥有进程中。为了避免使用错误的数据，你需要在实际使用向量之前调用[2.x.11]。        [1.x.0] Trilinos的并行功能是建立在消息传递接口（MPI）之上的。MPI的通信模型建立在集体通信的基础上：如果一个进程想从另一个进程得到什么，另一个进程必须愿意接受这种通信。一个进程不能通过调用一个远程函数从另一个进程查询数据，而另一个进程不期望有这种交易。其结果是，这个类的基类中的大多数操作都必须被集体调用。例如，如果你想计算一个平行向量的l2准则，[2.x.12]所有共享这个向量的进程都必须调用[2.x.13]函数。如果你不这样做，而只是在一个进程上调用[2.x.14]函数，那么会发生以下情况。这一个进程将调用一个集体MPI函数，并等待所有其他进程加入到这个过程中。由于其他进程不调用这个函数，你将在第一个进程上得到一个超时，或者更糟糕的是，当下一个对Trilinos函数的调用在其他进程上产生MPI消息时，你将得到一个神秘的消息，即只有一个子集的进程试图进行通信。这些错误是很难搞清楚的，除非你对MPI的通信模型非常熟悉，并且知道哪些函数可能产生MPI消息。        下面将讨论一个特殊的情况，即可能会意外地产生MPI消息的情况。            [1.x.1] Trilinos当然允许读取矢量的单个元素，但在分布式情况下，只允许读取本地存储的元素。我们通过<tt>d=vec(i)</tt>这样的调用来实现。    然而，如果你访问本地存储范围之外的元素，就会产生一个异常。        与读访问相反，Trilinos（以及相应的deal.II包装类）允许对向量的单个元素进行写入（或添加），即使它们存储在不同的进程中。你可以通过使用语法<tt>vec(i)=d</tt>或<tt>vec(i)+=d</tt>，或类似的操作写入或添加到元素中。然而，有一个问题，可能会导致非常混乱的错误信息。    Trilinos要求应用程序在从执行一组向元素添加的操作转换到执行一组向元素写入的操作时调用compress()函数。其理由是，所有进程都可能积累对元素的加法操作，即使是多个进程写到相同的元素。当我们下次调用compress()时，所有这些加法操作都被执行了。然而，如果一个进程对一个元素进行添加，而另一个进程对其进行覆盖，如果我们不确保在这中间发生与compress()的同步，那么执行的顺序将产生非确定性的行为。        为了确保这些对compress()的调用在适当的时间发生，deal.II包装器保留了一个状态变量，用于存储当前允许的操作：添加或写入。如果它遇到了相反的操作，它就会调用compress()并翻转状态。这有时会导致非常混乱的行为，例如，代码可能看起来像这样。       
* [1.x.2]
* 这段代码可能会遇到麻烦：当我们看到第一个加法运算时，我们需要冲刷向量的覆盖缓冲区，而deal.II库会通过调用compress()来实现。然而，它只对所有实际进行加法运算的进程进行这样的操作。
* 
* 如果其中一个进程的条件永远不为真，那么这个进程就不会得到实际的compress()调用，而所有其他的进程都会。    这就给我们带来了麻烦，因为所有其他的进程都会在刷新写缓冲区的调用中挂起，而另一个进程则会推进到计算l2准则的调用。这时，你会得到一个错误，即某些操作只被一个子集的进程尝试了。这种行为似乎令人惊讶，除非你知道对单个元素的写/添加操作可能会触发这种行为。        这里描述的问题可以通过对compress()的额外调用来避免，或者确保所有进程在同一时间做相同类型的操作，例如必要时放置零加法。            [1.x.3] 并行向量有两种情况：没有和有鬼魂元素。    没有鬼魂元素的向量在处理器之间唯一地划分了向量元素：每个向量条目正好有一个处理器拥有它。对于这样的向量，你可以读取你当前所在的处理器拥有的那些元素，你可以向任何元素写入，无论你是否拥有它：如果你不拥有它，在你下次调用compress()时，写入或添加到向量元素的值将被运送到拥有这个向量元素的处理器，如上所述。        我们所说的 "重影 "向量（见[2.x.15]"具有重影元素的向量"）只是一个元素分布重叠的平行向量的视图。鬼魂 "特里诺斯向量本身不知道哪些条目是鬼魂的，哪些是本地拥有的。事实上，一个重影向量甚至可能不会存储一个非重影向量在当前处理器上存储的所有元素。 因此，对于Trilinos向量来说，不存在我们在非鬼魂情况下的观点中的向量元素的 "所有者 "概念。        这就解释了为什么我们不允许在Trilinos侧向鬼魂向量中写入内容。鉴于不存在本地拥有的索引这样的信息，谁会负责处理重复的条目呢？换句话说，由于一个处理器不知道哪些其他处理器拥有一个元素，如果有人要写到它，它将把一个值发送给谁？唯一的可能性是将这些信息发送给[1.x.4]其他处理器，但这显然不现实。因此，我们只允许从有重影的向量中读取，然而我们经常这样做。        那么，如果你不能写到一个重影向量，你如何填充它呢？这只能通过与非鬼魂向量的赋值发生。它可以有两种方式（非幽灵向量被赋值给幽灵向量，而幽灵向量被赋值给非幽灵向量；后者通常只需要取出本地拥有的部分，因为大多数时候幽灵向量存储的是非幽灵向量的元素超集）。一般来说，你用这种操作发送数据，这完全取决于两个向量的不同观点。Trilinos也允许你通过这种方式从一个大向量中得到子向量。            [1.x.5] 当从共享内存中的几个线程向Trilinos向量中写入数据时，必须记住几件事，因为这个类中没有内置锁来防止数据竞赛。在同一时间同时访问同一个向量条目会导致数据竞赛，用户必须明确避免。然而，当只有一个MPI进程存在时，或者在构建向量时为写模式下的鬼魂条目设置了额外的索引，则有可能从几个线程同时访问[1.x.6]向量的条目。       
* [2.x.16]     
* [2.x.17] 2008, 2009, 2017    
* [0.x.22]*
       声明一些在所有容器中使用的标准类型。这些类型与<tt>C</tt>标准库中的<tt>vector<...></tt>类中的类型平行。     
* [0.x.23]*
        [2.x.18] 1: 基本对象处理      
* [0.x.24]*
       默认构造函数，生成一个空的（零大小）向量。在MPI运行的情况下，函数<tt>reinit()</tt>将必须给向量以正确的大小和在进程中的分布。     
* [0.x.25]*
       使用给定向量的复制构造函数。     
* [0.x.26]*
       这个构造函数接受一个IndexSet，它定义了如何在MPI处理器之间分配各个组件。由于它还包括关于向量大小的信息，这就是我们生成一个%并行向量所需要的全部内容。            根据[2.x.19]参数是否在处理器之间唯一地细分了元素，产生的向量可能有也可能没有鬼魂元素。更多信息请参见该类的一般文档。            如果提供的IndexSet形成了一个重叠的分区，就不清楚哪些元素被哪个进程拥有，local_owned_elements()将返回一个大小为0的IndexSet。             [2.x.20] [2.x.21] "有幽灵元素的向量"      
* [0.x.27]*
       创建一个有重影的平行向量。            根据[2.x.22]参数是否在处理器之间唯一地细分元素，产生的向量可能有也可能没有鬼魂元素。更多信息请参见这个类的一般文档。             [2.x.23] [2.x.24] "有鬼魂元素的向量"      
* [0.x.28]*
       从TrilinosWrappers向量类复制构造函数。由于这个类的向量不一定需要在进程间分配，用户需要向我们提供一个IndexSet和一个设置分区细节的MPI通信器。            根据[2.x.25]参数是否在处理器之间唯一地细分元素，产生的向量可能有也可能没有鬼魂元素。更多信息请参见该类的一般文档。             [2.x.26] [2.x.27] "有鬼魂元素的向量"      
* [0.x.29]*
       从deal.II向量中复制出来的构造函数。将维数设置为给定向量的维数，并复制所有的元素。            根据[2.x.28]参数是否在处理器中唯一地划分元素，产生的向量可能有也可能没有鬼魂元素。更多信息请参见该类的一般文档。             [2.x.29] [2.x.30] "有鬼魂元素的向量"      
* [0.x.30]*
       移动构造函数。通过窃取向量的内部数据创建一个新的向量 [2.x.31] 。      
* [0.x.31]*
       解构器。     
* [0.x.32]*
       释放所有内存并返回到与调用默认构造函数后相同的状态。     
* [0.x.33]*
       重新启动功能。这个函数将调用向量设置为输入向量的维度和平行分布，但不复制<tt>v</tt>中的元素。如果<tt>omit_zeroing_entries</tt>不是<tt>true</tt>，向量中的元素将被初始化为0。如果它被设置为<tt>true</tt>，那么向量的条目就处于一个未指定的状态，用户必须设置所有元素。在目前的实现中，如果矢量的布局与之前相比没有变化，这个方法不会触及矢量的条目，否则条目会被设置为零。 请注意，这种行为在不同的版本中可能会发生变化而不被通知。            这个函数有第三个参数，<tt>allow_different_maps</tt>，它允许在两个同等大小的向量之间交换数据（但在处理器之间的分布不同）。这个函数的一个微不足道的应用是在每台机器上生成整个向量的复制，当调用的向量是由每个进程上的所有索引组成的映射建立的，并且<tt>v</tt>是一个分布式向量。在这种情况下，变量<tt>omit_zeroing_entries</tt>需要被设置为<tt>false</tt>，因为在不同的并行化向量之间交换数据而不接触元素是没有意义的。     
* [0.x.34]*
       Reinit功能。这个功能销毁了旧的向量内容，并根据输入的分区生成一个新的向量。 标志<tt>omit_zeroing_entries</tt>决定了向量是否应该被填充为零（false）。如果该标志被设置为<tt>true</tt>，则向量条目处于未指定的状态，用户必须设置所有元素。在目前的实现中，这个方法仍然将条目设置为零，但这可能会在没有通知的情况下在不同的版本中发生变化。            根据[2.x.32]参数是否在处理器中唯一地细分元素，产生的向量可能有也可能没有鬼魂元素。更多信息请参见该类的一般文档。            在[2.x.33]重叠的情况下，不清楚哪个进程应该拥有哪些元素。因此，在这种情况下，local_owned_elements()返回一个空的索引集。             [2.x.34] [2.x.35] "有幽灵元素的向量"      
* [0.x.35]*
       重新启动功能。这个功能销毁了旧的向量内容，并根据输入的分区生成一个新的向量。除了像上面所有其他方法一样只指定一个索引集外，这个方法还允许提供一个额外的鬼魂条目集。      有两个不同版本的向量可以被创建。如果标志[2.x.36]被设置为[2.x.37]，该向量只允许读取[2.x.38]和[2.x.39]的联合集合，那么reinit方法的效果相当于调用其他的reinit方法，其索引集包含本地拥有的条目和幽灵条目。            如果标志[2.x.40]被设置为true，这就为ghost元素创建了一个替代性的存储方案，允许多个线程写入向量（对于其他reinit方法，一次只允许一个线程写入ghost条目）。            根据[2.x.41]参数是否在处理器之间唯一地细分元素，产生的向量可能有也可能没有鬼魂元素。更多信息请参见该类的一般文档。             [2.x.42] [2.x.43] "有鬼魂元素的向量"      
* [0.x.36]*
       通过合并块状向量的成分来创建向量。     
* [0.x.37]*
       压缩Trilinos对象的底层表示，即刷新向量对象的缓冲区（如果它有的话）。在逐一写入矢量元素后，在对其进行其他操作之前，这个函数是必要的。            参数（缺省）可用于指定压缩模式（[2.x.44]），以防在上次调用此函数后，没有对向量进行过写入。如果在上次调用compress()后，向量被添加或写入，则该参数被忽略。            更多信息见 [2.x.45] "压缩分布式对象"。     
* [0.x.38]*
       将向量的所有分量设置为给定的数字 [2.x.46] 只需将其传递给基类，但我们仍然需要声明这个函数，以使关于使构造函数显式的讨论中给出的例子发挥作用。            由于将标量分配给向量的语义并不立即明确，所以只有当你想将整个向量设为0时，才能使用这个操作符。这样就可以使用直观的符号<tt>v=0</tt>。     
* [0.x.39]*
       复制给定的向量。如果有必要，可以调整现在的向量的大小。在这种情况下，设计平行分区的Epetra_Map也是从输入矢量中提取的。     
* [0.x.40]*
       移动给定的向量。该操作符通过有效地交换内部数据结构，用[2.x.47]替换当前的向量。     
* [0.x.41]*
       另一个复制函数。这个函数接收一个deal.II向量并将其复制到一个TrilinosWrapper向量中。请注意，由于我们没有提供任何Epetra_map来告诉MPI进程之间的向量划分，TrilinosWrapper向量的大小必须与输入向量的大小相同。     
* [0.x.42]*
       这个reinit函数是为了用于必须使用一些非本地数据的并行计算。需要这个函数的典型情况是并行调用[2.x.48]函数（或一些导数）。由于提前检索数据通常更快，这个函数可以在汇编分叉到不同处理器之前被调用。这个函数的作用如下。      它获取给定矩阵的列中的信息，并寻找不同处理器之间的数据耦合。然后从输入向量中查询这些数据。注意，你不应该再向结果向量写入数据，因为有些数据可以在不同的处理器上存储多次，导致不可预测的结果。特别是，这样的向量不能用于矩阵-向量乘积，例如在线性系统的求解过程中。     
* [0.x.43]*
       从输入向量[2.x.49][2.x.50][2.x.51]中导入向量的IndexSet中存在的所有元素，用于决定[2.x.52]中的元素是否应该添加到当前向量中或替换当前元素。     
* [0.x.44]*
       检验是否相等。这个函数假定目前的向量和要比较的向量已经具有相同的大小，因为无论如何比较不同大小的向量没有什么意义。     
* [0.x.45]*
       测试不平等。这个函数假定现在的向量和要比较的向量已经有相同的大小，因为比较不同大小的向量反正没有什么意义。     
* [0.x.46]*
       返回向量的全局尺寸。     
* [0.x.47]*
       返回向量的局部尺寸，即存储在当前MPI进程中的元素数量。对于顺序向量，这个数字与size()相同，但对于并行向量，它可能更小。            要想知道到底哪些元素是存储在本地的，可以使用local_range()。            如果向量包含鬼魂元素，它们会被包括在这个数字中。             [2.x.53] 这个函数已被废弃。     
* [0.x.48]*
       返回向量的本地大小，即本地拥有的索引数。     
* [0.x.49]*
       返回一对索引，表明这个向量的哪些元素是本地存储的。第一个数字是存储的第一个元素的索引，第二个是本地存储的超过最后一个元素的索引。如果这是一个连续的向量，那么结果将是一对[2.x.54] ，否则将是一对[2.x.55]和[2.x.56]是存储在这个处理器上的向量的第一个元素，对应于半开区间[2.x.57]             
* [2.x.58] 上面的描述在大多数时候是正确的，但并不总是。      特别是，Trilinos向量不需要存储连续的元素范围，如[2.x.59] 。相反，它可以存储元素以任意的方式分布在所有处理器上的向量，每个处理器只是存储一个特定的子集，不一定是连续的。在这种情况下，这个函数显然是没有意义的，因为它最多只能返回一个包括本地存储的所有元素的范围。因此，这个函数只有在本地存储的范围确实是连续的情况下才会成功。如果向量的本地部分不是连续的，它将触发一个断言。     
* [0.x.50]*
       返回[2.x.60]是否在本地范围内，另见local_range()。           
* [2.x.61] 这个函数的适用性限制与local_range()的文档中所列相同。     
* [0.x.51]*
       返回一个索引集，描述这个向量的哪些元素是由当前处理器拥有的。请注意，这个索引集不包括这个向量可能在本地存储为幽灵元素，但实际上由另一个处理器拥有的元素。因此，如果这是一个分布式向量，在不同处理器上返回的索引集将形成不相交的集合，加起来就是完整的索引集。      很明显，如果一个向量只在一个处理器上创建，那么结果将满足      
* [1.x.7]
*       
* [0.x.52]*
       如果向量包含鬼魂元素，则返回。如果至少有一个进程上有鬼魂元素，这个答案就是真的。             [2.x.62] [2.x.63] "含有幽灵元素的向量"      
* [0.x.53]*
       这个函数只是为了与[2.x.64] [2.x.65]类兼容而存在，并不做任何事情：这个类以不同的方式实现了鬼魂值的更新，与底层的Trilinos向量对象更加匹配。     
* [0.x.54]*
       返回两个向量的标量（内）积。这些向量必须具有相同的大小。     
* [0.x.55]*
       返回[2.x.66]-norm的平方。     
* [0.x.56]*
       这个向量的元素的平均值。     
* [0.x.57]*
       计算这个向量的元素的最小值。     
* [0.x.58]*
       计算这个向量的元素的最大值。     
* [0.x.59]*
        [2.x.67] -矢量的规范。 绝对值的总和。     
* [0.x.60]*
        [2.x.68] - 矢量的规范。 各个元素的平方根之和。     
* [0.x.61]*
        [2.x.69] - 矢量的规范。元素绝对值的[1.x.8]次幂之和的[1.x.9]根。     
* [0.x.62]*
       元素的最大绝对值。     
* [0.x.63]*
       执行矢量加法和后续内积的组合操作，返回内积的值。换句话说，这个函数的结果与用户调用的      
* [1.x.10]
* 这个函数存在的原因是为了与deal.II自己的向量类兼容，后者可以用较少的内存传输实现这个功能。然而，对于Trilinos向量来说，原生不支持这样的组合操作，因此成本完全等同于单独调用这两个方法。            对于复值向量，第二步中的标量乘积被实现为[2.x.70] .      
* [0.x.64]*
       返回该向量是否只包含数值为0的元素。这是一个集体操作。这个函数很昂贵，因为有可能所有的元素都要被检查。     
* [0.x.65]*
       如果向量没有负的条目，即所有条目都是零或正，则返回[2.x.71]。例如，这个函数用于检查细化指标是否真的都是正的（或零）。     
* [0.x.66]*
        [2.x.72] 2：数据-获取      
* [0.x.67]*
       提供对一个给定元素的访问，包括读和写。            当使用一个用MPI分布的向量时，这个操作只对调用处理器上实际存在的元素有意义。      否则，会产生一个异常。     
* [0.x.68]*
       提供对一个元素的只读访问。            当使用MPI分布的向量时，这个操作只对调用处理器上实际存在的元素有意义。      否则，会产生一个异常。     
* [0.x.69]*
       提供对一个给定元素的访问，包括读和写。            与operator()完全相同。     
* [0.x.70]*
       提供对一个元素的只读访问。            与operator()完全相同。     
* [0.x.71]*
       与通过operator()获取向量中的单个元素不同，这个函数允许一次性获取一整组元素。要读取的元素的索引在第一个参数中说明，相应的值在第二个参数中返回。            如果当前的向量被称为[2.x.73]，那么这个函数就等同于代码      
* [1.x.11]
* [2.x.74][2.x.75]和[2.x.76]数组的大小必须是一致的。     
* [0.x.72]*
       这个函数不是通过operator()获得向量的单个元素，而是允许一次获得整个元素集。与前一个函数不同的是，这个函数通过取消引用前两个参数提供的迭代器范围内的所有元素来获得元素的索引，并将向量的值放入通过取消引用从第三个参数指向的位置开始的迭代器范围获得的内存位置。            如果当前的向量被称为[2.x.77]，那么这个函数就等同于代码      
* [1.x.12]
* [2.x.78] 必须能够写进从[2.x.79]开始的尽可能多的内存位置，因为有[2.x.80]和[2.x.81]之间的迭代器。      
* [0.x.73]*
       通过返回该向量中本地拥有的元素的开始和结束的迭代器，使Vector类有点像C++标准库中的<tt>vector<>/tt>类。如果向量是由IndexSet或deal.II中的其他方法构造的，则本地元素的排序与全局索引给出的排序一致（注意，Epetra_Map可以包含任意排序的元素）。            它认为end()
* 
* - begin() == local_size()。     
* [0.x.74]*
       返回常数迭代器到向量中本地拥有的元素的起点。     
* [0.x.75]*
       返回一个迭代器，指向本地拥有的条目数组结束后的元素。     
* [0.x.76]*
       返回一个恒定的迭代器，指向本地拥有的条目数组结束后的元素。     
* [0.x.77]*
        [2.x.82] 3: 修改向量      
* [0.x.78]*
       一个集体的设置操作：这个函数允许一次性设置一整组元素，而不是设置一个向量中的单个元素。      要设置的元素的索引在第一个参数中说明，相应的值在第二个参数中说明。     
* [0.x.79]*
       这是第二个集体设置操作。作为区别，这个函数需要一个deal.II的数值向量。     
* [0.x.80]*
       这个集合操作级别较低，可以处理其他任何事情&mdash；你唯一需要提供的是一个存放所有索引的地址和要设置的元素数量。     
* [0.x.81]*
       一个集体添加操作。这个函数将存储在[2.x.83]中的整组值添加到[2.x.84]指定的向量成分中。      
* [0.x.82]*
       这是第二次集体添加操作。作为区别，这个函数需要一个deal.II的数值向量。     
* [0.x.83]*
       取一个<tt>n_elements</tt>连续存储的地址，并将其添加到向量中。处理上述其他两个<tt>add()</tt>函数未涵盖的所有情况。     
* [0.x.84]*
       将整个向量乘以一个固定系数。     
* [0.x.85]*
       将整个向量除以一个固定的因子。     
* [0.x.86]*
       将给定的向量添加到当前的向量中。     
* [0.x.87]*
       从现在的向量中减去给定的向量。     
* [0.x.88]*
       将[2.x.85]加到所有组件上。注意[2.x.86]是一个标量而不是一个向量。     
* [0.x.89]*
       简单的向量加法，等于<tt>运算符+=</tt>。            不过，如果第二个参数<tt>allow_different_maps</tt>被设置，那么就有可能从一个使用不同地图的向量中添加数据，也就是说，一个向量的元素被不同的处理器分割。例如，这可能包括有幽灵元素的向量。      然而，一般来说，添加具有不同元素对处理器映射的向量需要在处理器之间进行数据通信，因此，比使用相同映射的向量的操作要慢。     
* [0.x.90]*
       矢量的倍数的简单加法，即<tt>*this += a*V</tt>。     
* [0.x.91]*
       缩放向量的多重加法，即<tt>*this += a*V + b*W</tt>。     
* [0.x.92]*
       缩放和简单的向量相加，即<tt>*this = s*(*this) + V</tt>。     
* [0.x.93]*
       缩放和简单加法，即：<tt>*this = s*(*this) + a*V</tt>。     
* [0.x.94]*
       用参数中的相应元素来缩放这个向量的每个元素。这个函数主要是为了模拟对角线缩放矩阵的乘法（和立即重新分配）。     
* [0.x.95]*
       赋值 <tt>*this = a*V</tt>.      
* [0.x.96]*
        [2.x.87] 4：混合东西      
* [0.x.97]*
       返回一个对底层Trilinos Epetra_MultiVector类的常量引用。     
* [0.x.98]*
       返回一个（可修改的）对底层Trilinos Epetra_FEVector类的引用。     
* [0.x.99]*
       返回一个对底层Trilinos Epetra_BlockMap的常量引用，它设置了向量的平行分区。     
* [0.x.100]*
       打印到一个流。 [2.x.88]表示打印数值所需的精度，[2.x.89]是否应使用科学符号。如果[2.x.90]是[2.x.91]，那么向量将被打印在一行中，而如果[2.x.92]则元素被打印在单独的一行中。     
* [0.x.101]*
       交换这个向量和另一个向量的内容 [2.x.93] 人们可以用一个临时变量和复制数据元素来完成这个操作，但是这个函数明显更有效率，因为它只交换了两个向量的数据指针，因此不需要分配临时存储和移动数据。注意，两个向量需要有相同的大小，并以同一地图为基础。            这个函数类似于所有C++标准容器的[2.x.94]函数。此外，还有一个全局函数<tt>swap(u,v)</tt>，它简单地调用<tt>u.swap(v)</tt>，同样与标准函数相类似。     
* [0.x.102]*
       对内存消耗的估计，以字节为单位。     
* [0.x.103]*
       返回一个对与此对象一起使用的MPI通信器对象的引用。     
* [0.x.104]*
       异常情况      
* [0.x.105]*
       异常情况      
* [0.x.106]*
       异常情况      
* [0.x.107]*
       Trilinos不允许混合添加矩阵条目和覆盖它们（以使并行计算的同步更简单）。我们的方法是，对于每个访问操作，存储它是插入还是添加。如果之前的操作是不同的类型，那么我们首先要刷新Trilinos缓冲区；否则，我们可以简单地继续下去。 幸运的是，Trilinos有一个这样的对象，在这种情况下已经完成了所有的并行通信，所以我们只需使用他们的模型，存储最后一个操作是加法还是插入。     
* [0.x.108]*
       一个布尔变量，用来保存向量是否被压缩的信息。     
* [0.x.109]*
       这个向量是否有鬼魂元素。这在所有的处理器上都是真的，即使只有一个处理器有任何鬼魂元素。     
* [0.x.110]*
       指向实际Epetra向量对象的指针。这可能代表一个事实上分布在多个处理器上的向量。该对象在设置时需要一个现有的Epetra_Map来存储数据。     
* [0.x.111]*
       Trilinos中的一个向量对象，用于收集非本地元素，如果该向量是用描述鬼魂元素的额外IndexSet构造的。     
* [0.x.112]*
       一个IndexSet，存储这个向量专门拥有的索引。     
* [0.x.113]*
     全局函数[2.x.95]，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个向量的数据。         [2.x.96] [2.x.97].     
* [0.x.114]*
     linear_operator.h中内部使用的一个辅助类。对[2.x.98]的特殊化。    
* [0.x.115]*
 将[2.x.99]声明为分布式向量。

* 
* [0.x.116]

