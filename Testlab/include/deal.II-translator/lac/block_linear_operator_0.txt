include/deal.II-translator/lac/block_linear_operator_0.txt
[0.x.0]*
 一个用于存储块状线性运算符概念的类。
* 这个类在LinearOperator（封装了[2.x.0]接口）的接口上增加了三个额外的功能。

* 
* [1.x.0]
* 描述（原本不透明的）线性运算符的底层块结构。
* BlockLinearOperator类型的对象可以通过包装函数与LinearOperator类似地创建。

* 
* [1.x.1]
* 
* 另外，还有几个辅助函数可用于从可能不同类型的多个独立矩阵中创建实例。下面是一个由FullMatrix和SparseMatrixEZ创建的块状对角线矩阵的例子。
* 

* 
* [1.x.2]
* 
* 

* 一个BlockLinearOperator可以在任何时候被切成一个LinearOperator。这将删除所有关于底层块结构的信息（因为上述[2.x.1]对象不再可用）。
* 
* - 线性操作符的接口，然而，仍然是完整的。
* 

* 
* [2.x.2] 这个类大量使用了[2.x.3]对象和lambda函数。这种灵活性伴随着运行时间的惩罚。只使用这个对象来封装具有中到大的单个块大小和小块结构的对象（作为经验法则，矩阵块大于[2.x.4] ）。
* 

* 

* 
* [2.x.5] 

* 
* [0.x.1]*
   创建一个空的BlockLinearOperator对象。     [2.x.6] 这个类和它的基类LinearOperator的成员对象被初始化为默认变体，在调用时抛出一个异常。 
* [0.x.2]*
   默认的复制构造函数。 
* [0.x.3]*
   模板化的复制构造函数，从一个定义了转换函数[2.x.8]的对象[2.x.7]中创建一个BlockLinearOperator对象。 
* [0.x.4]*
   从一个二维的LinearOperator数组[2.x.9]中创建一个BlockLinearOperator。这个构造函数调用相应的block_operator()专用化。 
* [0.x.5]*
   从一维数组[2.x.10]的LinearOperator创建一个块对角线的BlockLinearOperator。这个构造函数调用相应的block_operator()专用化。 
* [0.x.6]*
   默认的复制赋值运算器。 
* [0.x.7]*
   为一个定义了转换函数[2.x.12]的对象[2.x.11]模板化的复制赋值运算符。 
* [0.x.8]*
   从一个二维数组[2.x.13]的LinearOperator中复制赋值。  这个赋值运算符调用相应的block_operator()专用化。 
* [0.x.9]*
   从一维数组[2.x.14]的LinearOperator复制赋值，创建一个块对角线的BlockLinearOperator。这个赋值运算符调用相应的block_operator()专用化。 
* [0.x.10]*
   返回一列中的块数（即 "块行 "的数量，或者数字[2.x.15] ，如果解释为[2.x.16]块系统）。 
* [0.x.11]*
   返回一行的块数（即 "块列 "的数量，或者数字[2.x.17] ，如果解释为[2.x.18]块系统）。 
* [0.x.12]*
   访问具有给定坐标的块。这个[2.x.19]对象返回一个LinearOperator，代表BlockLinearOperator的[2.x.20] -th块。 
* [0.x.13]*
     一个用于BlockLinearOperator的假类，不需要任何扩展来促进块矩阵或其子块的操作。        这是通常与deal.II的本地BlockSparseMatrix相关的Payload类。要使用[2.x.21]或[2.x.22]，必须用它们相关的BlockPayload初始化BlockLinearOperator。           
* [2.x.23]     
* [0.x.14]*
       每个子块所持有的有效载荷的类型      
* [0.x.15]*
       默认构造函数 由于这个类不做任何特别的事情，不需要特别的配置，我们只有一个通用的构造函数，可以在任何条件下调用。     
* [0.x.16]*
  [2.x.24] 创建一个BlockLinearOperator

* 
* [0.x.17]*
  [2.x.25] BlockLinearOperator
* 一个将[2.x.26]封装为BlockLinearOperator的函数。
* 在BlockLinearOperator对象创建后，对[2.x.27]block_matrix的块结构和单个块所做的所有改变都会被操作者对象所反映。
* 

* 
* [2.x.28] 

* 
* [0.x.18]*
  [2.x.29] BlockLinearOperator
* 上述函数的一个变体，它将一个给定的LinearOperator集合[2.x.30]封装成一个块结构。这里假定Range和Domain是块状向量，即从[2.x.31]中导出。[2.x.32]中的各个线性运算符必须作用于块向量的底层向量类型，即在[2.x.33]中产生一个[2.x.34]的结果。
* 列表[2.x.35]最好作为初始化器列表传递。例如，考虑一个线性运算块（作用于Vector<double>）。

* 
* [1.x.3]
* 相应的block_operator调用的形式是

* 
* [1.x.4]
* 
* 

* 
* [2.x.36] 

* 
* [0.x.19]*
  [2.x.37] BlockLinearOperator
* 这个函数提取[2.x.38]的对角线块（可以是块状矩阵类型，也可以是BlockLinearOperator），并创建一个具有对角线的BlockLinearOperator。对角线外的元素被初始化为null_operator（有正确的 reinit_range_vector 和 reinit_domain_vector 方法）。
* 在创建BlockLinearOperator对象后，在[2.x.39]的各个对角线块上所做的所有改变都会被操作者对象所反映。
* 

* 
* [2.x.40] 

* 
* [0.x.20]*
  [2.x.41] BlockLinearOperator
* 上述函数的一个变体，它从对角线元素的数组[2.x.42]中建立起一个块状对角线线性运算器（非对角线块被假定为0）。
* 列表[2.x.43]最好作为一个初始化器列表传递。例如考虑一个线性操作块（作用于Vector<double>） <code>diag(op_a0, op_a1, ..., op_am)</code>。相应的block_operator调用的形式是

* 
* [1.x.5]
 
* 

 
* [2.x.44] 

* 
* [0.x.21]*
  [2.x.45] BlockLinearOperator
* 上述函数的一个变体，它只接受一个LinearOperator参数[2.x.46]，并创建一个带有[2.x.47]副本的块对角线性算子。
* 

* 
* [2.x.48] 

* 
* [0.x.22]*
  [2.x.49] 对一个BlockLinearOperator的操纵

 
* [0.x.23]*
  [2.x.50] LinearOperator [2.x.51] BlockLinearOperator
* 这个函数实现了正向替换，以反转一个低级块状三角形矩阵。作为参数，它需要一个BlockLinearOperator [2.x.52] block_operator，代表一个块状下三角矩阵，以及一个BlockLinearOperator [2.x.53] ，代表[2.x.54] 对角线块的反转。
* 让我们假设我们有一个线性系统，其块结构如下。
* 

* 
* [1.x.6]
* 
* 首先，[2.x.55] 。然后，我们可以用x0来恢复x1。

* 
* [1.x.7]
* 并因此。

 
* [1.x.8]
 
* 

* 
* [2.x.56] 我们没有使用BlockLinearOperator参数的所有块。只是使用了[2.x.57]的下三角块矩阵以及[2.x.58]的对角线。
* 

* 
* [2.x.59] 

* 
* [0.x.24]*
  [2.x.60] LinearOperator [2.x.61] BlockLinearOperator
* 这个函数实现了反置，以反转一个上块三角矩阵。作为参数，它需要一个BlockLinearOperator [2.x.62] block_operator，代表一个上块三角矩阵，以及一个BlockLinearOperator [2.x.63] ，代表[2.x.64] 的对角块的反转。
* 让我们假设我们有一个线性系统，其块结构如下。
* 

* 
* [1.x.9]
 
* 首先，[2.x.65] 。然后，我们可以用xn来恢复x(n-1)。

* 
* [1.x.10]
* 并因此。

* 
* [1.x.11]
 
* 

* 
* [2.x.66] 我们没有使用BlockLinearOperator参数的所有块。只是使用了[2.x.67]的上三角块矩阵以及[2.x.68]的对角线。
* 

* 
* [2.x.69] 

* 
* [0.x.25]

