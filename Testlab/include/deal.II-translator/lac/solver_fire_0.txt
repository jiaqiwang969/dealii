include/deal.II-translator/lac/solver_fire_0.txt
[0.x.0]*
 FIRE（快速惯性放松引擎）用于最小化（潜在的非线性）目标函数 [2.x.0] ， [2.x.1] 是一个 [2.x.2] 变量的向量（ [2.x.3] 是目标函数的变量数）。像所有其他求解器类一样，只要满足一定的要求，它可以在任何类型的向量和矩阵上工作（关于使用该类的矩阵和向量的要求，请参见求解器基类的文档）。求解向量的类型必须作为模板参数传递，默认为[2.x.4] 。
*FIRE是Bitzek等人在[1.x.0]中描述的一种阻尼动力学方法，通常用于寻找计算材料科学中原子系统的稳定平衡配置。从给定的原子系统初始配置开始，该算法依靠惯性来获得势能最小的（最近的）配置。
* 符号。
* 

* 
* 

* 
 
* - 未知变量的全局向量。 [2.x.5] .
* 

* 
* 

 
* 
* - 目标函数。                     [2.x.6] .
* 

* 
* 

 
* 
* - 未知数的变化率。             [2.x.7] .
* 

* 
* 

* 
 
* - 目标函数的梯度与未知数的关系。                [2.x.8] .
* 

* 
* 

 
* 
* - 质量矩阵。                            [2.x.9] .
* 

* 
* 

* 
* 
* - 未知数的初始猜测。              [2.x.10] .
* 

* 
* 

* 
* 
* - 时间步骤。                              [2.x.11] .
* 给出[2.x.12]、[2.x.13]、[2.x.14]、[2.x.15]和[2.x.16]的初始值以及给定的质量矩阵[2.x.17]，FIRE算法如下：1.计算[2.x.18]并检查收敛情况（[2.x.19]）。2. 使用简单的（正向）欧拉积分步骤更新[2.x.20]和[2.x.21]，<BR> [2.x.22] ，<BR> [2.x.23] 。3. 计算[2.x.24] 。4. 设置[2.x.25] 。5. 如果[2.x.26]和自[2.x.27]最后一次为负数以来的步数大于特定值，则增加时间步数[2.x.28]并减少[2.x.29] 。6. 如果 [2.x.30] ，则减少时间步长，冻结系统，即 [2.x.31] 并重置 [2.x.32] 。7. 返回到1。
* 也见Eidel等人的[1.x.1]，2011年。

* 
* [0.x.1]*
   标准化的数据结构，用于向求解器输送额外的数据。 
* [0.x.2]*
     构造函数。默认情况下，将（正向）欧拉积分步骤的初始时间步长设置为0.1，最大时间步长设置为1，任何变量的最大允许变化（每次迭代）为1。   
* [0.x.3]*
     (正向)欧拉积分步骤的初始时间步长。   
* [0.x.4]*
     (正向)欧拉积分步骤的最大时间步长。   
* [0.x.5]*
     允许目标函数的任何变量的最大变化。   
* [0.x.6]*
   构造器。 
* [0.x.7]*
   构造函数。使用一个GrowingVectorMemory类型的对象作为默认分配内存。 
* [0.x.8]*
   获得一组变量[2.x.33]，使多态函数包装器[2.x.34]描述的目标函数最小化，并具有给定的预处理器[2.x.35]和初始[2.x.36]值。  函数[2.x.37]返回目标函数的值，并根据第二个参数--变量的状态，作为第一个参数传入时，更新目标函数的梯度（相对于变量）。 
* [0.x.9]*
   当[2.x.39]时，求解x，使[2.x.38]的<EM>特殊情况</EM>最小。 
* [0.x.10]*
   派生类的接口。这个函数在每个步骤中获得当前迭代[2.x.40]（变量），[2.x.41]（x的时间导数）和[2.x.42]（梯度）。  它可以用于收敛历史的图形输出。 
* [0.x.11]*
   解算器的附加数据。 
* [0.x.12]

