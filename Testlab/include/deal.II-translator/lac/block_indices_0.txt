include/deal.II-translator/lac/block_indices_0.txt
[0.x.0]*
 BlockIndices表示一个指数范围（如一个矢量元素的有效指数范围[2.x.0]），以及这一个范围如何被分解成更小但连续的 "块"（如一个解矢量的速度和压力部分）。特别是，它提供了在全局指数和一个块的指数[1.x.0]之间转换的能力。例如，该类用于BlockVector、BlockSparsityPattern和BlockMatrixBase类中。
* 可以从这个类中获得的信息分为两组。首先，可以查询索引空间的全局大小（通过total_size()成员函数），以及块的数量和它们的大小（通过size()和block_size()函数）。
* 其次，这个类管理全局索引到这个块内的局部索引的转换，以及反过来的转换。这是必要的，例如，当你在一个块向量中寻址一个全局元素，并想知道它在哪个块中，以及它在这个块中对应的索引。如果一个矩阵是由几个块组成的，你必须把全局的行和列索引翻译成局部的，这也很有用。
* 

* 
* [2.x.1] [2.x.2] [2.x.3] "块（线性代数）"

* 
* [0.x.1]*
   声明容器大小的类型。 
* [0.x.2]*
   默认构造函数。对零块进行初始化。 
* [0.x.3]*
   构造函数。初始化每个块[2.x.4]中的条目数为<tt>block_sizes[i]</tt>。块的数量将是[2.x.5]block_sizes的大小。 
* [0.x.4]*
   移动构造函数。通过窃取另一个BlockIndices对象的内部数据来初始化一个新对象。 
* [0.x.5]*
   复制构造函数。 
* [0.x.6]*
   用于具有相同大小块的结构的专门构造函数。 
* [0.x.7]*
   重新初始化块的数量，并给每个块分配相同数量的元素。 
* [0.x.8]*
   根据给定的参数重新初始化每个块内的索引数。块的数量将被调整为<tt>block_sizes</tt>的大小，块[2.x.6]的大小被设置为<tt>block_sizes[i]</tt>。 
* [0.x.9]*
   在块结构的末端添加另一个给定大小的块。 
* [0.x.10]*
    [2.x.7] 大小信息  
* [0.x.11]*
   索引字段中的块的数量。 
* [0.x.12]*
   返回所有块上累积的索引总数，也就是块向量空间的维度。 
* [0.x.13]*
   [2.x.8]块的大小。 
* [0.x.14]*
   块大小的字符串表示。输出的形式是`[nb->b1,b2,b3|s]`，其中`nb`是n_blocks()，`s`是total_size()，`b1`等是block_size()对每个块返回的值。 
* [0.x.15]*
    [2.x.9] 索引转换 本组函数假定一个对象，它是在按块排序后创建的，这样，每个块在对象中形成一组连续的索引。如果应用于其他对象，从这些函数得到的数字是没有意义的。 
* [0.x.16]*
   返回全局索引[2.x.10]i的块和该块中的索引。这一对的第一个元素是块，第二个是其中的索引。 
* [0.x.17]*
   返回[2.x.12]块中[2.x.11]的全局索引。  
* [0.x.18]*
   第1个区块的起始索引。 
* [0.x.19]*
   复制操作者。 
* [0.x.20]*
   移动赋值运算符。通过转移BlockIndices对象的内容，将另一个BlockIndices对象移到当前对象上。 
* [0.x.21]*
   比较两个对象是否相同，即块的数量和所有块的大小是否相等。 
* [0.x.22]*
   交换这两个对象的内容。 
* [0.x.23]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.24]*
   块的数量。虽然这个值可以通过<tt>start_indices.size()-1</tt>获得，但我们对这个值进行了缓存以加快访问速度。 
* [0.x.25]*
   每个向量的全球起始索引。最后一个也是多余的值是总条目数。 
* [0.x.26]*
 记录BlockIndices的操作员。写下块的数量，每个块的大小和索引域的总大小。
* [2.x.13] 

* 
* [0.x.27]*
 全局函数 [2.x.14]，它重载了C++标准库中使用临时对象的默认实现。该函数简单地交换了两个对象的数据。
* [2.x.15] BlockIndices

* 
* [0.x.28]

