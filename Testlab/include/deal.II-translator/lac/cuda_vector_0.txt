include/deal.II-translator/lac/cuda_vector_0.txt
[0.x.0]*
   一个用于CUDA向量的命名空间。 
* [0.x.1]*
     该类使用CUDA实现了一个在Nvidia GPU上使用的向量。这个类是由[2.x.0]类派生的。       
* [2.x.1] 只支持float和double。         [2.x.2] CUDAWrappers    
* [2.x.3]     
* [0.x.2]*
       构造函数。创建一个维度为0的向量。     
* [0.x.3]*
       复制构造函数。     
* [0.x.4]*
       移动构造函数。     
* [0.x.5]*
       构造函数。设置维度为[2.x.4]并将所有元素初始化为0。            构造函数是明确的，以避免像这样的意外。      <tt>v=0;</tt>。据推测，用户希望将向量的每一个元素都设置为零，但相反，发生的是这样的调用。      <tt>v=向量[2.x.5]即向量被一个长度为零的向量所取代。     
* [0.x.6]*
       复制赋值运算符。     
* [0.x.7]*
       移动赋值运算符。     
* [0.x.8]*
       交换这个向量和另一个向量的内容 [2.x.6] 人们可以用一个临时变量和复制数据元素来完成这个操作，但是这个函数明显更有效率，因为它只交换了两个向量的数据指针，因此不需要分配临时存储和移动数据。            这个函数类似于所有C++标准容器的[2.x.7]函数。另外，还有一个全局函数<tt>swap(u,v)</tt>，它简单地调用<tt>u.swap(v)</tt>，同样与标准函数类似。            这个函数是虚拟的，以便允许派生类单独处理内存。     
* [0.x.9]*
       重新启动功能。标志<tt>omit_zeroing_entries</tt>决定了向量是否应该被填充为零（false）或保持不动（true）。     
* [0.x.10]*
       将维度改为向量V的维度，V的元素不会被复制。     
* [0.x.11]*
       从输入向量中导入所有元素 [2.x.8] [2.x.9] [2.x.10] 用于决定int [2.x.11] 的元素是否应该添加到当前向量中，或者替换当前元素。最后一个参数不使用。它只用于分布式向量。这是一个应该用来复制一个向量到GPU的函数。     
* [0.x.12]*
       将向量的所有元素设置为标量[2.x.12] 只有在[2.x.13]等于0的情况下才允许进行这个操作。     
* [0.x.13]*
       将entive向量乘以一个固定系数。     
* [0.x.14]*
       用整个向量除以一个固定因子。     
* [0.x.15]*
       将向量[2.x.14]添加到现在的向量中。     
* [0.x.16]*
       从现在的向量中减去向量[2.x.15]。     
* [0.x.17]*
       返回两个向量的标量乘积。     
* [0.x.18]*
       将[2.x.16]的所有成分相加。注意[2.x.17]是一个标量而不是一个向量。     
* [0.x.19]*
       矢量的倍数的简单相加，即<tt>*this += a*V</tt>。     
* [0.x.20]*
       缩放向量的多次加法，即：<tt>*this += a*V+b*W</tt>。     
* [0.x.21]*
       缩放和简单的向量倍数加法，即<tt>*this = s*(*this)+a*V</tt>。     
* [0.x.22]*
       用参数中的相应元素来缩放这个向量的每个元素。这个函数主要是为了模拟对角线缩放矩阵的乘法（和立即重新分配）。     
* [0.x.23]*
       赋值 <tt>*this = a*V</tt>.      
* [0.x.24]*
       返回向量是否只包含值为0的元素。     
* [0.x.25]*
       返回这个向量的所有条目的平均值。     
* [0.x.26]*
       返回该向量的l<sub>1</sub>准则（即所有条目在所有处理器中的绝对值之和）。     
* [0.x.27]*
       返回向量的l<sub>2</sub>准则（即所有处理器中所有条目的平方之和的平方根）。     
* [0.x.28]*
       返回[2.x.18]-norm的平方。     
* [0.x.29]*
       返回向量的最大规范（即所有条目和所有处理器中的最大绝对值）。     
* [0.x.30]*
       执行一个向量加法和后续内积的组合操作，返回内积的值。换句话说，这个函数的结果与用户调用的      
* [1.x.0]
* 这个函数存在的原因是这个操作比单独调用这两个函数涉及的内存转移要少。这个方法只需要加载三个向量，[2.x.19] [2.x.20] [2.x.21]，而调用单独的方法意味着要加载调用向量[2.x.22]两次。由于大多数向量操作都有内存传输限制，这就使时间减少了25\%（如果[2.x.23]等于[2.x.24]，则减少50\%）。 对于复值向量，第二步的标量乘法被实现为[2.x.25] 。     
* [0.x.31]*
       返回指向底层数组的指针。所有权仍然在这个类中。     
* [0.x.32]*
       返回向量的大小。     
* [0.x.33]*
       返回一个索引集，描述这个向量的哪些元素为当前处理器所拥有，即[0, size]。     
* [0.x.34]*
       打印向量到输出流 [2.x.26] 。      
* [0.x.35]*
       返回这个类的内存消耗，单位是字节。     
* [0.x.36]*
       试图在两个不兼容的向量类型之间进行操作。           
* [2.x.27]       
* [0.x.37]*
       指向此向量的元素数组的指针。     
* [0.x.38]*
       矢量中的元素数量。     
* [0.x.39]*
 全局函数[2.x.28]，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个向量的数据。
* [2.x.29] 向量

* 
* [0.x.40]

