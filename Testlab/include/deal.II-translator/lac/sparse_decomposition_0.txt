include/deal.II-translator/lac/sparse_decomposition_0.txt
[0.x.0]!  [2.x.0] 先决条件[2.x.1] 

 
* [0.x.1]*
 用于将稀疏矩阵不完全分解为稀疏因子的抽象基类。这个类本身不能使用，只能作为实际实现特定分解的派生类的基类，如SparseILU或SparseMIC。
* 分解结果以稀疏矩阵的形式存储，这就是为什么这个类派生于SparseMatrix。因为它不是通常意义上的矩阵（存储的条目不是矩阵的条目，而是原始矩阵的两个因子），所以派生是<tt>保护的</tt>而不是<tt>公开的</tt>。
* 

* [1.x.0]
* 稀疏分解经常被用于额外的填充，即分解的稀疏结构比要分解的矩阵更密集。该类的initialize()函数允许通过AdditionalData对象进行填充，只要原始矩阵中的所有条目在分解中也存在，即分解的稀疏模式是原始矩阵中稀疏模式的超集。
* 这种填充可以通过各种方式完成，其中之一是SparsityPattern类的复制构造器，它允许在给定的稀疏结构中增加边对角线。
* 

* [1.x.1]
* 虽然这个类的对象不能直接使用（这个类只是其他实现实际分解的基类），但派生类如SparseILU和SparseMIC可以以通常的形式作为预处理器使用。例如，这样就可以了。

* 
* [1.x.2]
* 
* 通过AdditionalData对象，可以指定LU分解的额外参数。
* 1/ 矩阵的对角线可以通过添加[2.x.2]倍的每一行的绝对行项之和来加强各自的对角线项。默认情况下不进行强化。
*2/ 默认情况下，每个initialize()函数调用都会创建自己的稀疏度。为此，它复制了[2.x.3]的稀疏性，并增加了[2.x.4]所指定的特定数量的额外对角线条目。
* 3/ 通过设置[2.x.5]，稀疏度不会被重新创建，但之前初始化()调用的稀疏度被重新使用（回收）。当需要解决几个相同稀疏度的线性问题时，这可能是有用的，例如，在同一个三角形上的几个牛顿迭代步骤。默认值是[2.x.6] 。
* 4/ 可以给用户定义的稀疏度为[2.x.7] 。然后，不创建稀疏度，但[2.x.8]被用来存储分解后的矩阵。关于稀疏度的限制见上面的 "填充 "部分）。)
* 

* [1.x.3]
* 覆盖initialize()和vmult()方法来实现特定的LU分解就足够了，比如真正的LU，或者Cholesky分解。此外，如果该分解需要在每一行的基础上微调对角线的强度，它可以覆盖get_strengthen_diagonal()方法。

* 
* [0.x.2]*
   构造函数。什么都不做。    在使用此对象作为预处理（vmult()）之前，调用初始化()函数。 
* [0.x.3]*
   声明容器大小的类型。 
* [0.x.4]*
   销毁。将析构器标记为纯的，以确保这个类不被直接使用，而只是其派生类。 
* [0.x.5]*
   删除所有成员变量。将类留在调用构造函数后的直接状态中。 
* [0.x.6]*
   SparseDecomposition的参数。 
* [0.x.7]*
     构造函数。关于参数的描述，见下文。   
* [0.x.8]*
      [2.x.9]倍的绝对行条目之和被添加到对角线条目中。        默认情况下，该值为零，即对角线不被加强。   
* [0.x.9]*
     默认情况下，[2.x.10]函数创建自己的稀疏度。这种稀疏性具有与[2.x.11]相同的SparsityPattern，有一些额外的对角线，其数量由[2.x.12]指定。        用户可以给[2.x.13]一个SparsityPattern。    然后使用这个稀疏度，[2.x.14]参数被忽略。   
* [0.x.10]*
     如果这个标志为真，initialize()函数就会使用与之前initialize()调用时相同的稀疏度。        当需要解决几个相同稀疏度的线性问题时，这可能是有用的，例如，在同一个三角形上的几个牛顿迭代步骤。   
* [0.x.11]*
     当一个SparsityPattern被赋予这个参数时，initialize()函数会调用[2.x.15]导致这个稀疏度被使用。        注意，[2.x.16]的稀疏性结构和传递给initialize函数的矩阵不需要相等。    允许填入，也允许过滤掉矩阵中的一些元素。   
* [0.x.12]*
   这个函数需要在这个类的对象被用作预处理器之前被调用。    关于可能的参数的更多细节，请参阅类的文档和[2.x.17]类的文档。    根据 [2.x.18] ，这个函数创建一个新的SparsityPattern，或者保持以前的稀疏度，或者采用用户给定的稀疏度 [2.x.19] 。然后，这个函数进行LU分解。    这个函数被调用后，预处理程序就可以使用了（使用派生类的[2.x.20]函数）。 
* [0.x.13]*
   返回对象是否为空。它调用继承的[2.x.21]函数。 
* [0.x.14]*
   返回共域（或范围）空间的维度。它调用继承的[2.x.22]函数。注意，矩阵的维数是[2.x.23] 。 
* [0.x.15]*
   返回域空间的维度。它调用继承的[2.x.24]函数。注意，矩阵的维度是[2.x.25] .  
* [0.x.16]*
   加法 矩阵-向量乘法。在[1.x.5]上添加[1.x.4]，[1.x.6]为该矩阵。    源和目的不能是同一个向量。 
* [0.x.17]*
   添加矩阵-向量乘法。将[1.x.7]加到[1.x.8]，[1.x.9]是这个矩阵。这个函数的作用与vmult_add()相同，但取的是转置的矩阵。    来源和目的地不能是同一个向量。 
* [0.x.18]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.19]*
    [2.x.26] 异常情况 [2.x.27].   
* [0.x.20]*
   异常情况  
* [0.x.21]*
   将传递的SparseMatrix复制到这个对象上。这个对象的稀疏度模式保持不变。 
* [0.x.22]*
   执行强化循环。对于每一行计算其元素的绝对值之和，确定加强因子（通过get_strengthen_diagonal()），并将对角线条目乘以[2.x.28] 。 
* [0.x.23]*
   在分解阶段，为第[2.x.29]行的对角线条目计算一个加强系数，其元素的绝对值之和为[2.x.30] 。   
* [2.x.31] SparseLUDecomposition中的默认实现返回[2.x.32]的值。这个变量在几个派生类中被设置为非零值。 
* [0.x.24]*
   默认的强化值，由get_strengthen_diagonal()返回。 
* [0.x.25]*
   对于底层SparsityPattern中的每一行，这个数组包含一个指向该行的第一个对角线条目的指针。在调用prebuild_lower_bound()后变得可用。 
* [0.x.26]*
   填充#prebuilt_lower_bound数组。 
* [0.x.27]*
   一般来说，这个指针是零，除了没有给这个类提供SparsityPattern的情况。然后，一个SparsityPattern被创建，并被传递给SparseMatrix基类。    尽管如此，SparseLUDecomposition需要保留这个稀疏度的所有权。它保留这个指针，以便在销毁时删除这个稀疏度。 
* [0.x.28]

