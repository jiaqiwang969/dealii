include/deal.II-translator/lac/tensor_product_matrix_0.txt
[0.x.0]*
 这是一个抽象的基类，用于一个特殊的矩阵类，即TensorProductMatrixSymmetricSum。
* 首先，这个基类就像一个容器，存储一维质量矩阵和一维导数矩阵，以及每个张量方向的广义特征值和特征向量。对于这些矩阵和相应的广义特征问题的详细定义，我们可以参考TensorProductMatrixSymmetricSum的主要文档。
* 

* 
* [2.x.0] 这个基类没有计算所给质量和导数矩阵的特征值和特征向量的功能。初始化数据成员的责任完全在于派生类。
* 其次，它用张量乘积矩阵（vmult()）和它的逆（apply_inverse()）实现了矩阵-向量乘积，如TensorProductMatrixSymmetricSum的主要文档中所述。
* 

* 
* [2.x.1] 该类使用一个临时数组来存储中间结果，它是一个类成员。一个mutex被用来保护对这个数组的访问，并确保正确的结果。如果几个线程并行运行这个类的实例，建议每个线程持有自己的矩阵版本。
* [2.x.2] dim 问题的尺寸。目前，一维、二维和三维代码已经实现。
* [2.x.3] Number 底层数组元素的算术类型。
* [2.x.4] n_rows_1d 编译时一维矩阵的行数（只有在每个维度的行数和列数重合时才有效）。默认情况下，在
* 
* - ，这意味着行数是在运行时通过传递给reinit()函数的矩阵来确定。

* 
* [0.x.1]*
   矩阵条目的类型。这个别名类似于标准库容器中的<tt>value_type</tt>。 
* [0.x.2]*
   一维矩阵的静态行数。详情见模板参数<tt>n_rows_1d</tt>的描述。 
* [0.x.3]*
   返回由一维矩阵的克朗克积产生的张量积矩阵的行数，在TensorProductMatrixSymmetricSum的主文档中有所描述。 
* [0.x.4]*
   返回由一维矩阵的克朗克积产生的张量积矩阵的列数，这在TensorProductMatrixSymmetricSum的主要文档中描述。 
* [0.x.5]*
   实现与底层矩阵的矩阵-向量乘积，在TensorProductMatrixSymmetricSum的主要文档中有所描述。  这个函数在ArrayView上操作，以允许检查与[2.x.5]和[2.x.6]有关的阵列界限。  
* [0.x.6]*
   如TensorProductMatrixSymmetricSum的主文档中所述，实现了与底层矩阵的矩阵-向量乘积。  这个函数在ArrayView上操作，以允许检查与[2.x.7]和[2.x.8]有关的阵列界限。  
* [0.x.7]*
   默认构造函数。 
* [0.x.8]*
   一个包含每个张量方向的质量矩阵的数组。 
* [0.x.9]*
   一个包含每个张量方向的导数矩阵的数组。 
* [0.x.10]*
   一个存储每个张量方向的广义特征值的数组。 
* [0.x.11]*
   一个存储每个张量方向的广义特征向量的数组。 
* [0.x.12]*
   一个用于临时数据的数组。 
* [0.x.13]*
   一个保护对数组访问的突变器 [2.x.9] 。  
* [0.x.14]*
 这是一个特殊的矩阵类，定义为一维矩阵的张量积（或克朗克积），其类型为

* 
* [1.x.0]
* 在二维和

* 
* [1.x.1]
*在三维中。典型的应用设置是拉普拉斯[2.x.10]在笛卡尔（轴对齐）几何上的离散化，它可以准确地由一维质量矩阵[2.x.11]和一维拉普拉斯矩阵[2.x.12]在每个张量方向的克朗克或张量乘积来表示（由于对称性[2.x.13]和[2.x.14]在每个维度都相同）。结果类的维度是一维矩阵的乘积。
* 这个类实现了两个基本操作，即通常的向量乘法和逆向操作。对于这两种操作，可以应用快速的张量技术，在[2.x.15]的算术运算中实现运算符的评估，大大低于[2.x.16]的天真正向变换和[2.x.17]的设置逆运算。
* 有趣的是，由于1964年[1.x.2]的一篇文章，矩阵[2.x.19]的精确逆可以通过张量积找到。

* 
* [1.x.3]
* 其中[2.x.20]是给定张量方向上广义特征值问题的特征向量矩阵[2.x.21] 。

* 
* [1.x.4]
* 而[2.x.22]是代表广义特征值的对角线矩阵 [2.x.23] 。请注意，向量[2.x.24]是这样的：它们同时对角化[2.x.25]和[2.x.26]，即[2.x.27]和[2.x.28] 。这种矩阵反演的方法被称为快速对角线化法。
* 这个类需要LAPACK支持。
* 请注意，这个类允许两种使用模式。第一种是对矩阵维度使用运行时常数的使用模式，通过设置可选的模板参数<tt>n_rows_1d</tt>来实现。
* 
* - . 第二种是更快的使用模式，允许将模板参数设置为编译时常量，特别是对于小尺寸的矩阵，给出明显更快的代码。
* [2.x.29] dim 问题的尺寸。目前，已经实现了一维、二维和三维代码。
* [2.x.30] Number 基础数组元素的算术类型。请注意，底层的LAPACK实现只支持浮点数和双数，所以目前通用类只支持这两种类型。然而，存在一个针对矢量化类型VectorizedArray<float>和VectorizedArray<double>的模板特化。这对于为每个矢量化通道执行LAPACK计算是必要的，也就是说，对于支持的浮点数和双数。
* [2.x.31] n_rows_1d 编译时一维矩阵的行数（只有在每个维度的行数和列数重合时才有效）。默认情况下，在
* 
* - ，这意味着行数是在运行时通过传递给reinit()函数的矩阵来确定。

* 
* [0.x.15]*
   默认构造函数。 
* [0.x.16]*
   相当于空构造函数的构造函数，并立即调用 reinit([2.x.32] dim>&,const [2.x.33] dim>&) 。 
* [0.x.17]*
   等同于空构造函数的构造函数，并立即调用 reinit(const [2.x.34] [2.x.35])   
* [0.x.18]*
   相当于空构造函数并立即调用 reinit(const Table<2,Number>&,const Table<2,Number>&) 的构造函数。 
* [0.x.19]*
   通过将一维质量矩阵[2.x.36]和一维导数矩阵[2.x.37]的数组分别复制到它的基类对应物中，并通过在[2.x.38]和[2.x.39]中分别组装关于广义特征值和特征向量来初始化张量积矩阵。  注意，目前的实现要求每个[2.x.40]都是对称的和正定的，每个[2.x.41]都是对称的和可逆的，但不一定是正定的。 
* [0.x.20]*
   这个函数等同于之前的 reinit()，只是[2.x.42]和[2.x.43]中的一维矩阵分别以FullMatrix的形式传递。 
* [0.x.21]*
   这个函数等同于第一个reinit()，只是我们为每个张量方向考虑相同的一维质量矩阵[2.x.44]和相同的一维导数矩阵[2.x.45]。 
* [0.x.22]*
   一个基于完美转发的所有reinit()函数的通用实现，允许传递lvalue以及rvalue参数。   [2.x.46] MatrixArray 必须可以转换为[2.x.47]和[2.x.48]的基本类型。  
* [0.x.23]*
 这是VectorizedArray<Number>的模板特化，是算术模板。详细说明见通用TensorProductMatrixSymmetricSum类的主文件。

* 
* [0.x.24]*
   默认构造函数。 
* [0.x.25]*
   等同于空构造函数的构造函数，并立即调用 reinit(constitution [2.x.49] >, dim>&,const [2.x.50] >, dim>&) 。 
* [0.x.26]*
   相当于空构造函数并立即调用 reinit(Table<2,VectorizedArray<Number> >&,const Table<2,VectorizedArray<Number> >&) 的构造函数。 
* [0.x.27]*
   通过将一维质量矩阵[2.x.51]和一维导数矩阵[2.x.52]的数组分别复制到它的基类对应物中，并通过在[2.x.53]和[2.x.54]中分别组装关于广义特征值和特征向量来初始化张量积矩阵。  请注意，目前的实现要求每个[2.x.55]都是对称的和正定的，每个[2.x.56]都是对称的和可逆的，但不一定是正定的。 
* [0.x.28]*
   这个函数等同于之前的reinit()，只是我们为每个张量方向考虑相同的一维质量矩阵[2.x.57]和相同的一维导数矩阵[2.x.58]。 
* [0.x.29]*
   一个基于完美转发的所有reinit()函数的通用实现，允许传递lvalue以及rvalue参数。   [2.x.59] MatrixArray 必须可以转换为[2.x.60]和[2.x.61]的基本类型。  
* [0.x.30]*
     计算实际广义对称特征问题的广义特征值和特征向量 [2.x.62] 。由于我们是在纯指针上操作，我们需要事先知道矩阵的大小。注意，特征值和特征向量的数据数组也必须被初始化为适当的大小。(不可能检查数组的界限)    
* [0.x.31]

