include/deal.II-translator/lac/sparse_matrix_ez_0.txt
[0.x.0]*
  [2.x.0] Matrix1 [2.x.1]. 

* 
* [0.x.1]*
 无稀疏模式的稀疏矩阵。
* 这个矩阵没有使用预先组装好的稀疏模式，而是在飞行中建立了模式。填充矩阵可能比[2.x.2]消耗更多的时间，因为当新的矩阵元素被插入到矩阵中间的某个地方时，可能会涉及到大量的内存移动，而目前没有未使用的内存位置可用于插入新条目的行。为了帮助优化，可以向构造函数提供一个预期的行长度，以及一个行的增量大小。
* 该类使用一个存储结构，与通常的稀疏矩阵格式类似，只存储非零元素。这些元素被存储在整个矩阵的一个数据数组中，并按行排序，在每行中按列号排序。一个单独的数组描述了每一行在长数据数组中的起始位置以及它的长度。
* 由于这种结构，行与行之间可能出现空隙。每当必须创建一个新条目时，就会尝试使用其行中的间隙。如果没有空隙，该行必须被扩展，所有后续的行都必须向后移位。这是一个非常昂贵的操作，解释了这种数据结构的低效率，以及为什么像SparseMatrix类那样预先分配一个稀疏模式是有用的。
* 这就是提供给构造函数或 reinit()函数的优化参数的作用。 [2.x.3]是初始化时为每行分配的条目数（行的实际长度仍为0）。这意味着，[2.x.4]个条目可以被添加到这一行，而不会转移其他行。如果添加的条目较少，额外的内存当然就会被浪费掉。
* 如果一个行的空间不够，那么它将被扩大[2.x.5]个条目。这样一来，后续的行就不会经常被单项移位了。
* 最后，[2.x.6]在数据数组的末端分配了额外的空间。这个空间在任何必须扩大的行中都会被使用。这很重要，因为否则不仅下面的行必须被移动，而且在为整个数据阵列分配了足够多的空间后，实际上[1.x.0]行也必须被移动。
* 建议的设置。 [2.x.7]应该是一个典型行的长度，例如网格中常规部分的网板尺寸。然后，[2.x.8]可以是有一个挂起的节点给该行增加的预期条目量。这样一来，就应该在内存消耗和速度之间取得一个很好的折中。 [2.x.9]应该是对悬挂节点数量的估计乘以[2.x.10] default_increment。
* 让[2.x.11]为零会导致每当有行溢出时出现异常。
* 如果行被期望或多或少地从头到尾填满，使用[2.x.12]为零可能不是一个坏主意。
* 

* 
* [2.x.13] 这个类的名字用美国人的方式发音是有意义的，其中 "EZ "的发音与 "easy "的发音相同。

* 
* [0.x.2]*
   声明容器尺寸的类型。 
* [0.x.3]*
   用于存储条目的列号及其值的类。 
* [0.x.4]*
     标准构造函数。设置[2.x.14]到[2.x.15]。    
* [0.x.5]*
     构造函数。填充列和值。   
* [0.x.6]*
     列的编号。   
* [0.x.7]*
     那里的值。   
* [0.x.8]*
     不存在的列号。   
* [0.x.9]*
   用于存储矩阵行的信息的结构。每行有一个对象，将被存储在矩阵中。 
* [0.x.10]*
     构造函数。   
* [0.x.11]*
     数据域中行的第一个条目的索引。   
* [0.x.12]*
     该行的条目数。   
* [0.x.13]*
     对角线元素相对于起始索引的位置。   
* [0.x.14]*
     不存在的对角线的值。   
* [0.x.15]*
   符合标准的迭代器。 
* [0.x.16]*
     迭代器的访问器类    
* [0.x.17]*
       构造器。因为我们只使用访问器进行读取访问，一个常量矩阵指针就足够了。     
* [0.x.18]*
       这个对象所代表的元素的行号。     
* [0.x.19]*
       这个对象所代表的元素在行中的索引。     
* [0.x.20]*
       这个对象所代表的元素的列号。     
* [0.x.21]*
       这个矩阵条目的值。     
* [0.x.22]*
       访问的矩阵。     
* [0.x.23]*
       当前行数。     
* [0.x.24]*
       当前行的索引。     
* [0.x.25]*
     构造函数。   
* [0.x.26]*
     前缀增量。这总是返回一个有效的条目或<tt>end()</tt>。   
* [0.x.27]*
     去引用操作符。   
* [0.x.28]*
     解除引用操作符。   
* [0.x.29]*
     比较。真，如果两个迭代器都指向同一个矩阵位置。   
* [0.x.30]*
     <tt>==</tt>的倒数。   
* [0.x.31]*
     比较运算符。如果第一行数字较小，或者行数字相等且第一个索引较小，则结果为真。   
* [0.x.32]*
     存储一个访问器类的对象。   
* [0.x.33]*
   矩阵条目的类型。这个别名类似于标准库容器中的<tt>value_type</tt>。 
* [0.x.34]*
    [2.x.16] 构造函数和初始化  
* [0.x.35]*
   构造函数。初始化一个尺寸为0乘以0的空矩阵。 
* [0.x.36]*
   假的复制构造函数。这是在容器中使用的。它只能为空对象调用。    如果你真的想复制一个完整的矩阵，你可以使用[2.x.17] copy_from函数来实现。 
* [0.x.37]*
   构造函数。生成一个给定大小的矩阵，准备被填充。  可选参数[2.x.18]和[2.x.19]允许预先分配内存。适当地提供这些参数对于有效地组装矩阵是至关重要的。 
* [0.x.38]*
   销毁器。释放所有的内存。 
* [0.x.39]*
   只复制空对象的伪操作符。 
* [0.x.40]*
   这个操作符将一个标量分配给一个矩阵。因为这通常没有什么意义（我们应该把所有的矩阵条目都设置为这个值吗？仅仅是稀疏模式的非零条目？），这个操作只允许在实际要分配的值为零的情况下进行。这个操作符的存在只是为了允许明显的符号<tt>matrix=0</tt>，它将矩阵的所有元素设置为零，但保留之前使用的稀疏模式。 
* [0.x.41]*
   将稀疏矩阵重新初始化为所提供的尺寸。矩阵在此时将没有任何条目。可选参数[2.x.20]default_row_length，[2.x.21]和[2.x.22]允许预先分配内存。正确地提供这些参数对于有效地组装矩阵是至关重要的。 
* [0.x.42]*
   释放所有内存并返回到与调用默认构造函数后相同的状态。它也会忘记其稀疏模式。 
* [0.x.43]*
    [2.x.23] 矩阵的信息  
* [0.x.44]*
   返回该对象是否为空。如果两个维度都是零，它就是空的。 
* [0.x.45]*
   返回共域（或范围）空间的维度。注意，矩阵的维度是[2.x.24] 。 
* [0.x.46]*
   返回域空间的维度。请注意，矩阵的维度是[2.x.25] .  
* [0.x.47]*
   返回特定行中的条目数。 
* [0.x.48]*
   返回该矩阵的非零元素的数量。 
* [0.x.49]*
   确定此对象的内存消耗（以字节为单位）的估计值。 
* [0.x.50]*
   打印统计数据。如果[2.x.26]是[2.x.27]，则打印所有现有行长和分配行长的直方图。否则，只显示已分配和已使用条目的关系。 
* [0.x.51]*
   计算条目的数量。    在前三个参数中，该函数返回该矩阵使用、分配和保留的条目数。    如果最后一个参数为真，每行的条目数也会被打印出来。 
* [0.x.52]*
    [2.x.28] 修改条目  
* [0.x.53]*
   将元素<tt>(i,j)</tt>设置为 [2.x.29] 如果<tt>value</tt>不是一个有限的数字，就会产生异常。    可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。    如果这个函数设置了一个尚不存在的元素的值，那么它将为其分配一个条目。(除非如上所述，`elide_zero_values`是`true`)。   
* [2.x.30]如果你想保持矩阵的对称稀疏模式，你可能需要插入零元素。 
* [0.x.54]*
   将[2.x.31]添加到元素<tt>(i,j)</tt>。    如果这个函数添加到一个尚不存在的元素的值中，那么它将为其分配一个条目。    该函数会自动过滤掉零，也就是说，当向一个目前不存在条目的矩阵元素添加零时，它不会创建新条目。 
* [0.x.55]*
   将FullMatrix<double>中给出的所有元素添加到由<tt>indices</tt>给出的稀疏矩阵位置。换句话说，这个函数将<tt>full_matrix</tt>中的元素添加到调用矩阵的相应条目中，使用<tt>indices</tt>为矩阵的行和列指定的本地到全球索引。这个函数假定一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中通常的情况。    可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。 
* [0.x.56]*
   与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 
* [0.x.57]*
   将矩阵的指定行中的几个元素与<tt>col_indices</tt>给出的列索引设置为相应的值。    可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。 
* [0.x.58]*
   在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<tt>values</tt>给出的数值阵列。    可选的参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些数据，只添加非零值。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。 
* [0.x.59]*
   将作为参数给出的矩阵复制到当前对象中。    复制矩阵是一个昂贵的操作，我们不希望通过编译器生成的代码意外发生[2.x.32] 。（例如，如果不小心声明了一个当前类型为[1.x.1]而非[1.x.2]的函数参数，就会发生这种情况）。复制矩阵的功能是在这个成员函数中实现的。因此，该类型对象的所有复制操作都需要一个明确的函数调用。    源矩阵可以是一个任意类型的矩阵，只要其数据类型可以转换为该矩阵的数据类型。    可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。    该函数返回一个[2.x.33]的引用。  
* [0.x.60]*
   将[2.x.34]按[2.x.35]的比例添加到该矩阵中。    源矩阵可以是一个任意类型的矩阵，只要其数据类型可以转换为该矩阵的数据类型，并且具有标准的[2.x.36]。  
* [0.x.61]*
    [2.x.37]条目访问  
* [0.x.62]*
   返回条目(i,j)的值。 这可能是一个昂贵的操作，你应该始终注意在哪里调用这个函数。 为了避免滥用，如果所需元素在矩阵中不存在，该函数会抛出一个异常。    如果你想要一个返回零的函数（对于不在矩阵的稀疏模式中的条目），请使用[2.x.38]函数。 
* [0.x.63]*
   返回条目(i,j)的值。对所有不存在的条目返回零。 
* [0.x.64]*
    [2.x.39] 乘法运算  
* [0.x.65]*
   矩阵-向量乘法：让[2.x.40]与[2.x.41]为该矩阵。 
* [0.x.66]*
   矩阵-向量乘法：让[2.x.42]与[2.x.43]为这个矩阵。这个函数与[2.x.44]的作用相同，但需要转置的矩阵。 
* [0.x.67]*
   加法 矩阵-向量乘法。在[2.x.46]上添加[2.x.45]，[2.x.47]为该矩阵。 
* [0.x.68]*
   添加矩阵-向量乘法。将[2.x.48]加到[2.x.49]，[2.x.50]是这个矩阵。这个函数与[2.x.51]的作用相同，但需要转置的矩阵。 
* [0.x.69]*
    [2.x.52] 矩阵的准则  
* [0.x.70]*
   矩阵的Frobenius-norm。 
* [0.x.71]*
    [2.x.53] 预处理方法  
* [0.x.72]*
   应用雅可比预处理方法，将[2.x.54]src向量的每个元素乘以各自对角线元素的逆值，并将结果与阻尼系数[2.x.55]相乘。  
* [0.x.73]*
   对[2.x.56]应用SSOR预处理。  
* [0.x.74]*
   将SOR预处理矩阵应用于[2.x.57]，该方法的结果是[2.x.58] 。 
* [0.x.75]*
   对[2.x.59]应用转置的SOR预处理矩阵，该方法的结果是[2.x.60] 。 
* [0.x.76]*
   将由[2.x.62]共轭的矩阵[2.x.61]即[2.x.63]添加到该对象中。如果参数[2.x.64]为真，计算[2.x.65] 。    这个函数要求[2.x.66]有一个[2.x.67]遍历所有矩阵条目，并且[2.x.68]有一个函数<tt>el(i,j)</tt>用于访问特定条目。 
* [0.x.77]*
    [2.x.69] 迭代器  
* [0.x.78]*
   迭代器从第一个现有条目开始。 
* [0.x.79]*
   最后的迭代器。 
* [0.x.80]*
   迭代器从第[2.x.70]行的第一个条目开始，如果这一行是空的，结果是<tt>end(r)</tt>，它并不指向第[2.x.71]行。  
* [0.x.81]*
   行[2.x.72]的最终迭代器 结果可能与<tt>end()</tt>不同!  
* [0.x.82]*
    [2.x.73] 输入/输出  
* [0.x.83]*
   打印矩阵到给定的流，使用格式<tt>(line,col) value</tt>，即每行有一个非零的矩阵条目。 
* [0.x.84]*
   以通常的格式打印矩阵，即作为矩阵而不是作为非零元素的列表。为了提高可读性，不在矩阵中的元素显示为空白，而明确设置为零的矩阵元素则显示为空白。    参数允许对输出格式进行灵活设置。 [2.x.74]精度和[2.x.75]用于确定数字格式，其中[2.x.76]=[2.x.77]表示定点符号。 [2.x.78]的零条目使函数计算出一个宽度，但如果输出是粗略的，它可能被改变为一个正值。    此外，还可以指定一个空值的字符。    最后，整个矩阵可以与一个共同的分母相乘，产生更可读的输出，甚至是整数。    如果应用于一个大的矩阵，这个函数可能会产生[2.x.79]大量的输出!  
* [0.x.85]*
   以二进制模式将此对象的数据写到文件中。    注意，这种二进制格式与平台有关。 
* [0.x.86]*
   读取之前由[2.x.80]写入的数据，该对象在此操作中被调整大小，所有之前的内容都会丢失。    执行一种原始形式的错误检查，它将识别最直白的尝试，将一些数据解释为按位数存储到文件中的向量，但不会有更多。 
* [0.x.87]*
    [2.x.81] 异常 [2.x.82]   
* [0.x.88]*
   缺少对角线条目的异常情况。 
* [0.x.89]*
   例外情况  
* [0.x.90]*
   找到一个条目并返回一个常数指针。如果该条目不存在，则返回一个零指针。 
* [0.x.91]*
   找到一个条目并返回一个可写指针。如果该条目不存在，则返回一个零指针。 
* [0.x.92]*
   查找一个条目或生成它。 
* [0.x.93]*
   [2.x.83]的版本，只对<tt>[begin_row,end_row)</tt>定义的区域进行操作。在启用多线程的情况下，这个函数被[2.x.84]调用。 
* [0.x.94]*
   [2.x.85]的版本，只对<tt>[begin_row,end_row)</tt>定义的区域进行操作。在启用多线程的情况下，这个函数被[2.x.86]调用。 
* [0.x.95]*
   [2.x.87]的版本，只对<tt>[begin_row,end_row)</tt>定义的区域进行操作。在启用多线程的情况下，这个函数被[2.x.88]调用。 
* [0.x.96]*
   列的数量。这仅用于检查向量尺寸。 
* [0.x.97]*
   每一行的信息结构。 
* [0.x.98]*
   数据存储。 
* [0.x.99]*
   当某行增长时进行递增。 
* [0.x.100]*
   记住用户提供的默认行长度。 
* [0.x.101]*
  [2.x.89] 

* 
* [0.x.102]

