include/deal.II-translator/lac/petsc_matrix_free_0.txt
[0.x.0]*
   实现一个基于PETSc <tt>MatShell</tt> 矩阵类型的并行矩阵类。这个基类只实现了PETSc矩阵对象的接口，而所有的功能都包含在矩阵-向量乘法中，必须在派生类中重新实现。    这个接口是对[2.x.0]类的补充，以实现用户定义的矩阵类与PETSc解算器和功能。参见 [2.x.1] 类和 [2.x.2] 以及 [2.x.3] 的文档。    与命名空间PETScWrappers和[2.x.4]中的其他矩阵类类似，MatrixFree类提供了通常的矩阵-向量乘法<tt>vmult(VectorBase &dst, const VectorBase &src)</tt>，它是纯虚拟的，必须在派生类中重新实现。  除了通常的接口，这个类还有一个矩阵向量乘法<tt>vmult(Vec &dst, const Vec &src)</tt>，采取PETSc Vec对象，它将被<tt>matrix_free_mult(Mat A, Vec src, Vec dst)</tt>注册为这个PETSc矩阵对象的矩阵-向量乘法。基类中vmult函数的默认实现是用[2.x.5]类包装给定的PETSc向量，然后用常规接口调用常规vmult函数。   
* [2.x.6]   
* [2.x.7]   
* [0.x.1]*
     默认构造函数。创建一个空的矩阵对象。   
* [0.x.2]*
     创建一个尺寸为[2.x.8]乘以[2.x.9]的矩阵对象，通过提供的[2.x.10]进行通信。 关于[2.x.11]和[2.x.12]参数的含义，请参阅[2.x.13]类文档。        与其他PETSc矩阵一样，无矩阵对象也需要有一个大小，并能有效地并行执行矩阵向量乘法[2.x.14]和[2.x.15]，但与[2.x.16]类相反，PETSc无矩阵对象不需要对非零项进行任何估计，也没有<tt>is_symmetric</tt>选项。   
* [0.x.3]*
     创建一个尺寸为[2.x.17]乘以[2.x.18]的矩阵对象，并通过提供的[2.x.19]进行通信。 与其他PETSc矩阵一样，无矩阵对象也需要有一个尺寸，并能有效地并行执行矩阵向量乘法，但与[2.x.22]类相反，PETSc无矩阵对象不需要对非零项进行任何估计，也没有<tt>is_symmetric</tt>选项。   
* [0.x.4]*
     串行情况下的构造函数。与<tt>MatrixFree()</tt>函数相同，见上文，<tt>communicator = MPI_COMM_WORLD</tt>。   
* [0.x.5]*
     串行情况下的构造函数。与<tt>MatrixFree()</tt>函数相同，见上文，<tt>communicator = MPI_COMM_WORLD</tt>。   
* [0.x.6]*
     扔掉当前的矩阵，并生成一个具有相同属性的矩阵，就像它是由这个类的构造函数创建的，参数列表与当前函数相同。   
* [0.x.7]*
     扔掉当前的矩阵，并生成一个具有相同属性的矩阵，就像它是由这个类的构造函数创建的一样，参数列表与当前函数相同。   
* [0.x.8]*
     用<tt>communicator = MPI_COMM_WORLD</tt>调用上面的[2.x.23]函数。   
* [0.x.9]*
     用<tt>communicator = MPI_COMM_WORLD</tt>调用上面的[2.x.24]函数。   
* [0.x.10]*
     释放所有内存并返回到与调用默认构造函数后一样的状态。   
* [0.x.11]*
     返回一个对该矩阵使用的MPI通信器对象的引用。   
* [0.x.12]*
     矩阵-向量乘法：让[1.x.0]与[1.x.1]是这个矩阵。        源和目的不能是同一个向量。        注意，如果当前对象代表一个平行分布式矩阵（类型为[2.x.25]，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。   
* [0.x.13]*
     矩阵-向量乘法：让[1.x.2]与[1.x.3]为这个矩阵。这个函数与[2.x.26]的作用相同，但需要转置的矩阵。        源和目的不能是同一个向量。        注意，如果当前对象代表一个平行分布的矩阵，那么两个向量也必须是分布式向量。    反之，如果矩阵不是分布式的，那么两个向量都不可以是。   
* [0.x.14]*
     加法 矩阵-向量乘法。在[1.x.5]上添加[1.x.4]，[1.x.6]为该矩阵。        源和目的不能是同一个向量。        注意，如果当前对象代表一个平行分布的矩阵，那么两个向量也必须是分布式向量。    反之，如果矩阵不是分布式的，那么两个向量都不能是。   
* [0.x.15]*
     加法 矩阵-向量乘法。将[1.x.7]加到[1.x.8]，[1.x.9]是这个矩阵。这个函数与[2.x.27]的作用相同，但需要转置的矩阵。        来源和目的地不能是同一个向量。        注意，如果当前对象代表一个平行分布的矩阵，那么两个向量也必须是分布式向量。    反之，如果矩阵不是分布式的，那么两个向量都不可以是。   
* [0.x.16]*
     [2.x.28]调用的矩阵-向量乘法 这个函数可以在派生类中重新实现以提高效率。默认实现将给定的向量复制到[2.x.29]中，并调用<tt>vmult(VectorBase &dst, const VectorBase &src)</tt>，它是纯虚的，必须在派生类中重新实现。   
* [0.x.17]*
     将用于该并行矩阵-自由对象的通信器对象的副本。   
* [0.x.18]*
     注册为PETSc例程所调用的该无矩阵对象的矩阵-向量乘法的回调函数。这个函数必须是静态的，并且接受一个PETSc矩阵[2.x.30]和向量[2.x.31]和[2.x.32]，其中[1.x.10]源和目的地不能是同一个向量。        这个函数调用<tt>vmult(Vec &dst, const Vec &src)</tt>，应该在派生类中重新实现。   
* [0.x.19]*
     为各自的[2.x.33]函数和匹配的构造函数做实际工作，即创建一个矩阵对象。摆脱之前的矩阵是留给调用者的。   
* [0.x.20]

