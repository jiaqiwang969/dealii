include/deal.II-translator/lac/block_vector_0.txt
[0.x.0]!  [2.x.0] 向量[2.x.1] 

 
* [0.x.1]*
 一个基于deal.II向量的块向量的实现。虽然基类提供了大部分的接口，但这个类处理了向量的实际分配，并提供了底层向量类型的特定函数。
* 

* 
* [2.x.2] 这个模板的实例提供给<tt> [2.x.3] 和 [2.x.4] 其他人可以在应用程序中生成（见手册中的[2.x.5]部分）。
* [2.x.6] [2.x.7] "块（线性代数）"

* 
* [0.x.2]*
   对基类进行类型化定义，以便更简单地访问它自己的别名。 
* [0.x.3]*
   类型化底层向量的类型。 
* [0.x.4]*
   从基类中导入别名。 
* [0.x.5]*
   构造函数。有三种方法来使用这个构造函数。首先，没有任何参数，它生成一个没有块的对象。给定一个参数，它初始化<tt>n_blocks</tt>块，但这些块的大小为零。  第三种变体最后将所有块初始化为相同的大小<tt>block_size</tt>。    如果你打算使用不同大小的块，请参考下面的其他构造函数。 
* [0.x.6]*
   复制构造函数。尺寸设置为[2.x.8]的尺寸，所有的组件都是从[2.x.9]复制过来的。  
* [0.x.7]*
   移动构造函数。通过窃取给定参数向量的内部数据创建一个新的向量。 
* [0.x.8]*
   复制构造函数，获取另一种数据类型的BlockVector。如果没有从<tt>OtherNumber</tt>到<tt>Number</tt>的转换路径，这将失败。注意，当你复制到一个数据元素精度较低的BlockVector时，可能会失去精度。    旧版本的gcc不尊重模板构造函数上的[2.x.10]关键字。在这种情况下，很容易不小心写出效率很低的代码，因为编译器开始执行隐藏的转换。为了避免这种情况，如果我们在配置过程中检测到有损坏的编译器，这个功能就会被禁用。 
* [0.x.9]*
   一个复制构造函数，获取一个（并行的）Trilinos块向量，并将其复制成deal.II自己的格式。 
* [0.x.10]*
   构造函数。设置块的数量为<tt>block_sizes.size()</tt>，并以<tt>block_sizes[i]</tt>零元素初始化每个块。 
* [0.x.11]*
   构造函数。将向量初始化为BlockIndices参数中的结构。 
* [0.x.12]*
   构造函数。设置块的数量为<tt>block_sizes.size()</tt>。  用作为第二和第三参数的迭代器范围所指向的元素初始化向量。除了第一个参数外，这个构造函数与[2.x.11]类的相应构造函数完全类似，但需要第一个参数，以便知道如何将块向量细分为不同的块。 
* [0.x.13]*
   解除构造函数。清除内存  
* [0.x.14]*
   在所有的子块上调用compress()函数。    这个功能只有在使用基于MPI的向量时才需要调用，为了兼容，在其他对象中也存在。    参见 [2.x.12] "压缩分布式对象 "以获得更多信息。 
* [0.x.15]*
   返回`false`，因为这是一个串行块向量。    只有在使用基于MPI的向量时才需要调用这个功能，并且为了兼容而存在于其他对象中。 
* [0.x.16]*
   复制操作：用给定的标量值填充向量的所有组件。 
* [0.x.17]*
   对相同类型的参数进行复制操作。如果有必要，可以调整现在的向量的大小。 
* [0.x.18]*
   移动给定的向量。该操作符用给定参数向量的内容替换当前向量。 
* [0.x.19]*
   对不同类型的模板参数进行复制操作。如果有必要，可以调整当前向量的大小。 
* [0.x.20]*
   将一个常规向量复制到一个块向量中。 
* [0.x.21]*
   从Trilinos块向量到deal.II块向量的复制构造函数。 
* [0.x.22]*
   重新初始化BlockVector，使其包含<tt>n_blocks</tt>每个大小为<tt>block_size</tt>的块。    如果第二个参数是默认值，那么区块向量就会分配指定数量的区块，但让它们的大小为零。然后你需要重新初始化各个区块，并调用collect_sizes()来更新区块系统对其各个区块大小的认识。    如果<tt>omit_zeroing_entries==false</tt>，则向量被填充为零。 
* [0.x.23]*
   重新初始化BlockVector，使其包含<tt>block_sizes.size()</tt>块。每个块都被重新初始化为<tt>block_sizes[i]</tt>的尺寸。    如果块的数量与调用此函数前相同，所有的向量都保持不变，并且为每个向量调用 reinit()。    如果<tt>omit_zeroing_entries==false</tt>，则向量被填充为零。    注意，你必须调用这个（或其他reinit()函数）函数，而不是调用单个块的reinit()函数，以允许块向量更新其缓存的向量大小。如果你在其中一个块上调用reinit()，那么对这个对象的后续操作可能会产生不可预测的结果，因为它们可能会被路由到错误的块上。 
* [0.x.24]*
   重新初始化BlockVector以反映BlockIndices中发现的结构。    如果块的数量与调用此函数前相同，所有的向量都保持不变，并且为每个向量调用 reinit()。    如果<tt>omit_zeroing_entries==false</tt>，则向量被填充为零。 
* [0.x.25]*
   将维度改为向量<tt>V</tt>的维度。这与另一个reinit()函数同样适用。    <tt>V</tt>的元素不会被复制，也就是说，这个函数与调用<tt>reinit (V.size(), omit_zeroing_entries)</tt>相同。    注意，你必须调用这个（或其他reinit()函数）函数，而不是调用单个块的reinit()函数，以允许块向量更新它的向量大小缓存。如果你调用其中一个块的reinit()，那么这个对象的后续操作可能会产生不可预测的结果，因为它们可能被路由到错误的块。 
* [0.x.26]*
   将这个向量的每个元素乘以<tt>v</tt>的相应元素。 
* [0.x.27]*
   把这个向量的内容和另一个向量<tt>v</tt>交换。我们可以通过一个临时变量和复制数据元素来完成这个操作，但是这个函数的效率明显更高，因为它只交换了两个向量的数据指针，因此不需要分配临时存储空间和移动数据。    这个函数类似于所有C++标准容器的swap()函数。此外，还有一个全局函数swap(u,v)，它简单地调用<tt>u.swap(v)</tt>，同样与标准函数相类似。 
* [0.x.28]*
   打印到一个流。 
* [0.x.29]*
   将向量全部写到流中。这是以二进制模式进行的，所以输出结果既不能被人类阅读，也不能（可能）被其他使用不同操作系统或数字格式的计算机阅读。 
* [0.x.30]*
   从一个文件中读取一个矢量en块。这是用上述函数的逆运算来完成的，所以它的速度相当快，因为位流没有被解释过。    如果有必要，矢量会被调整大小。    一个原始形式的错误检查被执行，它将识别最直截了当的尝试，将一些数据解释为存储在文件中的位流向量，但不会超过。 
* [0.x.31]*
    [2.x.13] 异常情况 [2.x.14]   
* [0.x.32]*
   异常情况  
* [0.x.33]*
 全局函数，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个向量的数据。
* [2.x.15] BlockVector

* 
* [0.x.34]*
     linear_operator.h中内部使用的一个辅助类。对BlockVector<number>的特殊化。   
* [0.x.35]*
 将[2.x.16]声明为串行向量。

* 
* [0.x.36]

