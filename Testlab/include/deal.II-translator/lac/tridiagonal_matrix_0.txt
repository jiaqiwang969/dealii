include/deal.II-translator/lac/tridiagonal_matrix_0.txt
[0.x.0]!  [2.x.0] Matrix1 [2.x.1]! 

* 
* [0.x.1]*
 一个四次方三对角矩阵。也就是说，除了对角线和它的左右两边的条目外，所有条目都是零的矩阵。
* 矩阵有一个额外的对称模式，在这种情况下，只有矩阵的上三角被存储并镜像到下三角，用于矩阵向量操作。
* 

* 
* [2.x.2] 

* 
* [0.x.2]*
   声明容器尺寸的类型。 
* [0.x.3]*
    [2.x.3] 构造函数和初始化  
* [0.x.4]*
   构造函数生成一个维度为<tt>n</tt>的空矩阵。 
* [0.x.5]*
   重新初始化矩阵到一个新的尺寸，并将所有条目重置为零。对称性属性也可以设置。 
* [0.x.6]*
   这个矩阵的行数。注意，该矩阵是一个[1.x.0]矩阵。 
* [0.x.7]*
   该矩阵的列数。请注意，该矩阵是一个[1.x.1]矩阵。 
* [0.x.8]*
   返回该矩阵是否只包含数值为0的元素。这个函数主要用于内部一致性检查，在非调试模式下应该很少使用，因为它需要花费不少时间。 
* [0.x.9]*
   对一个值的只读访问。这只限于[1.x.2]的情况。 
* [0.x.10]*
   对一个值的读写访问。这只限于[1.x.3]的情况。   
* [2.x.4]在对称存储技术的情况下，条目[1.x.4]和[1.x.5]被识别，[1.x.6]存在。如果使用加法进行矩阵组合，必须考虑到这一点，以避免获得双倍的条目。 
* [0.x.11]*
   矩阵-向量-乘法。从右边乘以<tt>v</tt>，并将结果存入<tt>w</tt>。    如果可选的参数<tt>adding</tt>是<tt>true</tt>，结果将被添加到<tt>w</tt>中。    来源和目的地不能是同一个矢量。 
* [0.x.12]*
   添加矩阵-向量-乘法。与vmult()相同，参数<tt>adding=true</tt>，但广泛用于<tt>deal.II</tt>类。    源和目的不能是同一个向量。 
* [0.x.13]*
   转置矩阵-向量-乘法。从左边乘以<tt>v<sup>T</sup></tt>，并将结果存入<tt>w</tt>。    如果可选的参数<tt>adding</tt>是<tt>true</tt>，结果将被加到<tt>w</tt>中。    来源和目的地不能是同一个矢量。 
* [0.x.14]*
   添加转置的矩阵-向量-乘法。与Tvmult()相同，参数为<tt>adding=true</tt>，但广泛用于<tt>deal.II</tt>类。    源和目的不能是同一个向量。 
* [0.x.15]*
   建立矩阵标量乘积<tt>u^T M v</tt>。这个函数在有限元背景下建立两个函数的单元标量乘积时大多有用。 
* [0.x.16]*
   返回向量<tt>v</tt>相对于该矩阵引起的规范的平方，即[1.x.7]。这很有用，例如在有限元背景下，一个函数的[1.x.8]规范等于相对于代表有限元函数节点值的向量的质量矩阵的矩阵规范。    很明显，对于这个操作，矩阵需要是二次的。 
* [0.x.17]*
   计算对称三对角矩阵的特征值。   
* [2.x.5] 这个函数需要配置支持LAPACK的deal.II。此外，矩阵必须使用对称存储技术。 
* [0.x.18]*
   在调用compute_eigenvalues()后，你可以在这里访问每个特征值。 
* [0.x.19]*
   以用户定义的格式输出矩阵。 
* [0.x.20]*
   对角线条目。 
* [0.x.21]*
   对角线左边的条目。索引为0的条目总是0，因为第一行没有对角线左边的条目。因此，这个向量的长度与#对角线的长度相同。    对于对称存储，这个向量的长度为零。在这种情况下，#left的第二个元素与#right的第一个元素是一致的。 
* [0.x.22]*
   对角线右边的条目。最后一个条目总是零，因为最后一行在对角线右边没有条目。因此，这个向量的长度和#对角线的长度是一样的。 
* [0.x.23]*
   如果这个标志为真，则只存储对角线右边的条目，并假定矩阵是对称的。 
* [0.x.24]*
   矩阵的状态。通常情况下，该状态为[2.x.6]，表示该对象可以用于常规的矩阵操作。    详见该数据类型的解释。 
* [0.x.25]

