include/deal.II-translator/lac/matrix_block_0.txt
[0.x.0]*
 一个围绕矩阵对象的封装器，将坐标也存储在一个块状矩阵中。
* 这个类是BlockMatrixBase的一个替代品，如果你只想生成系统的一个块，而不是整个系统。使用这个类的add()函数，可以使用用于块状矩阵的标准装配函数，但只输入其中一个块，仍然可以避免涉及的索引计算。 这个类的原因是，在一个块系统中的不同块，我们可能需要不同数量的矩阵。例如，Oseen系统的预处理程序可以建立为一个块系统，其中压力块的形式为[1.x.0]<sup>-1</sup>[1.x.1]<sup>-1</sup>，[1.x.2]是压力质量矩阵，[1.x.3]是压力拉普拉斯，[1.x.4]是应用于压力空间的平流扩散算符。由于其他区块只需要一个矩阵，使用BlockSparseMatrix或类似的方法将是对内存的浪费。
* 虽然add()函数使MatrixBlock看起来像一个用于组装的块状矩阵，但vmult()、Tvmult()、vmult_add()和Tvmult_add()函数使它的行为像一个MatrixType，当它应用于一个矢量时。这种行为允许我们在向量中存储MatrixBlock对象，例如在MGLevelObject中，而不用先提取#matrix。
* MatrixBlock在使用BlockMatrixArray时很方便。一旦MatrixBlock被正确地初始化和填充，它就可以在最简单的情况下被用来作为。

* 
* [1.x.5]
* 
* 在这里，我们的收获并不大，只是我们不需要在块系统中设置空块。
* 

* 
* [2.x.0] 这个类期望，系统的行和列的BlockIndices对象是相等的。如果它们不相等，一些函数会抛出ExcNotImplemented。
* [2.x.1] 压力舒尔补码的乘积预处理的例子。
* 

* 
* [2.x.2] 

* 
* [2.x.3] 
* [2.x.4] [2.x.5] "块（线性代数）"

 
* [0.x.1]*
   申报容器尺寸的类型。 
* [0.x.2]*
   为矩阵条目声明一个类型。 
* [0.x.3]*
   构造函数渲染一个未初始化的对象。 
* [0.x.4]*
   复制构造函数。 
* [0.x.5]*
   赋值运算符。 
* [0.x.6]*
   构造函数设置块坐标，但不初始化矩阵。 
* [0.x.7]*
   为一个新的BlockSparsityPattern重新初始化矩阵。这将调整#matrix以及#row_indices和#column_indices。   
* [2.x.6] 稀疏模式的行和列块结构必须相等。 
* [0.x.8]*
   向元素添加<tt>value</tt>（[1.x.6]）。如果该条目不存在或在不同的块中，则抛出一个错误。 
* [0.x.9]*
   将FullMatrix中的所有元素添加到由<tt>indices</tt>给出的稀疏矩阵位置。这个函数假设一个二次元稀疏矩阵和一个二次元full_matrix。 全局位置被转换为该块中的位置，如果全局索引没有指向#row和#column所指的块，则抛出ExcBlockIndexMismatch。     [2.x.7] <tt>elide_zero_values</tt>目前被忽略。    可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些数据，只添加非零值。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。 
* [0.x.10]*
   将FullMatrix中的所有元素添加到分别由<tt>row_indices</tt>和<tt>col_indices</tt>给出的全局位置。全局位置被转换为该块中的位置，如果全局索引没有指向#row和#column所指的块，则抛出ExcBlockIndexMismatch。     [2.x.8] <tt>elide_zero_values</tt>目前被忽略。    可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些数据，只添加非零值。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。 
* [0.x.11]*
   将矩阵指定行中的几个元素与<tt>col_indices</tt>给出的列索引设置为相应的值。这是为添加完整矩阵的做实际工作的函数。全局位置<tt>row_index</tt>和<tt>col_indices</tt>被转换为该块中的位置，如果全局索引没有指向#row和#column所指的块，则抛出ExcBlockIndexMismatch。     [2.x.9] <tt>elide_zero_values</tt>目前被忽略。    可选参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些数据，只添加非零值。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。 
* [0.x.12]*
   在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<tt>values</tt>给出的数值阵列。    可选的参数<tt>elide_zero_values</tt>可以用来指定是无论如何都要添加零值，还是要过滤掉这些数据，只添加非零值。默认值是<tt>true</tt>，也就是说，零值不会被添加到矩阵中。 
* [0.x.13]*
   矩阵-向量-乘法，转发到MatrixType中的相同函数。没有进行索引计算，因此，向量需要有与#matrix匹配的大小。 
* [0.x.14]*
   矩阵-向量-乘法，转发到MatrixType中的相同函数。没有做索引计算，因此，向量需要有与#matrix匹配的大小。 
* [0.x.15]*
   矩阵-向量-乘法，转发到MatrixType中的相同函数。没有进行索引计算，因此，向量需要有与#matrix匹配的大小。 
* [0.x.16]*
   矩阵-向量-乘法，转发到MatrixType中的相同函数。没有做索引计算，因此，向量需要有与#matrix匹配的大小。 
* [0.x.17]*
   这个对象使用的内存。 
* [0.x.18]*
   通过使用BlockIndices从索引中计算出的块编号与存储在此对象中的块坐标不匹配。 
* [0.x.19]*
   行坐标。 这是该数据成员矩阵在全局矩阵上的位置。 
* [0.x.20]*
   列坐标。 这是该数据成员矩阵在全局矩阵上的位置。 
* [0.x.21]*
   矩阵本身  
* [0.x.22]*
   整个系统的行BlockIndices。使用row()，这可以让我们找到这个块的第一行自由度的索引。 
* [0.x.23]*
   整个系统的列BlockIndices。使用column()，我们可以找到该块的第一个列自由度的索引。 
* [0.x.24]*
 一个MatrixBlock的向量，使用共享指针来实现，以便于复制和重新排列。每个矩阵块都可以通过名称来识别。
* [2.x.10] MatrixBlock

* 
* [2.x.11] 

* 
* [0.x.25]*
   声明容器尺寸的类型。 
* [0.x.26]*
   存储对象的类型。 
* [0.x.27]*
   用于存储对象的指针类型。我们使用一个分片的指针，这样，当不再使用时，它们会被自动删除。 
* [0.x.28]*
   在块系统中的<tt>(row,column)</tt>位置添加一个新的矩阵块。 
* [0.x.29]*
   对于使用SparsityPattern的矩阵，这个函数用块系统的正确模式重新初始化向量中的每个矩阵。 
* [0.x.30]*
   清除对象。    由于通常只需要清除单个矩阵，而不需要清除块本身，所以有一个可选的参数。如果缺少这个参数或者[2.x.12]，所有的矩阵将被清空，但是这个对象的大小和块的位置将不会改变。如果[2.x.13]really_clean是[2.x.14]，那么该对象在最后将不包含任何块。 
* [0.x.31]*
   这个对象所使用的内存。 
* [0.x.32]*
   访问位置[1.x.7]的块的常数引用。 
* [0.x.33]*
   访问位置[1.x.8]的块的引用。 
* [0.x.34]*
   访问位置[1.x.9]的矩阵，进行读和写访问。 
* [0.x.35]*
   从私有基类中导入函数  
* [0.x.36]*
 一个MGLevelObject<MatrixBlock>的向量，使用共享指针来实现，以便于复制和重新排列。每个矩阵块都可以通过名称来识别。
* [2.x.15] MatrixBlock

* 
* [2.x.16] 

* 
* [0.x.37]*
   声明容器尺寸的类型。 
* [0.x.38]*
   存储对象的类型。 
* [0.x.39]*
   构造函数，决定哪些矩阵应该被存储。    如果<tt>edge_matrices</tt>为真，则分配面的自由度离散的边缘矩阵的对象。    如果<tt>edge_flux_matrices</tt>为真，则分配细化边上的危险通量对象。 
* [0.x.40]*
   块的数量。 
* [0.x.41]*
   在块系统中<tt>(行,列)</tt>的位置添加一个新的矩阵块。第三个参数允许给矩阵一个名称，以便以后识别。 
* [0.x.42]*
   对于使用SparsityPattern的矩阵，这个函数用块系统的正确模式重新初始化向量中的每个矩阵。    这个函数重新初始化了水平矩阵。 
* [0.x.43]*
   对于使用SparsityPattern的矩阵，此函数用块系统的正确模式重新初始化向量中的每个矩阵。    这个函数对细化边上的自由度的矩阵进行重新初始化。 
* [0.x.44]*
   对于使用SparsityPattern的矩阵，此函数用块系统的正确模式重新初始化向量中的每个矩阵。    这个函数在细化边上重新初始化通量矩阵。 
* [0.x.45]*
   清除对象。    因为通常只需要清除单个矩阵，而不需要清除块本身，所以有一个可选的参数。如果缺少这个参数或者[2.x.17]，所有的矩阵将被清空，但是这个对象的大小和块的位置将不会改变。如果[2.x.18]really_clean是[2.x.19]，那么该对象在最后将不包含任何块。 
* [0.x.46]*
   访问位于[1.x.10]位置的矩阵块的常量引用。 
* [0.x.47]*
   访问位置为[1.x.11]的矩阵块的引用。 
* [0.x.48]*
   访问位置[1.x.12]的边缘矩阵块的一个常量引用。 
* [0.x.49]*
   访问位置[1.x.13]的边缘矩阵块的一个引用。 
* [0.x.50]*
   访问位置[1.x.14]的边缘矩阵块的一个常量引用。 
* [0.x.51]*
   访问位置[1.x.15]的边缘矩阵块的一个引用。 
* [0.x.52]*
   访问位置[1.x.16]的边缘通量矩阵块的一个常数参考。 
* [0.x.53]*
   访问位置[1.x.17]的边缘通量矩阵块的引用。 
* [0.x.54]*
   访问位置[1.x.18]的边缘通量矩阵块的一个常数参考。 
* [0.x.55]*
   访问位置[1.x.19]的边缘通量矩阵块的引用。 
* [0.x.56]*
   这个对象所使用的内存。 
* [0.x.57]

