include/deal.II-translator/lac/trilinos_parallel_block_vector_0.txt
[0.x.0]!  [2.x.0] TrilinosWrappers [2.x.1]! 

 
* [0.x.1]*
     一个基于TrilinosWrappers中实现的向量类的块向量实现。虽然基类提供了大部分的接口，但这个类处理了向量的实际分配，并提供了底层向量类型特有的函数。        数据的分配模式是这样的，每个块都分布在MPI通信器中命名的所有MPI进程中。    也就是说，我们不只是分发整个向量，而是分发每个组件。因此，在构造函数和reinit()函数中，不仅要指定各个块的大小，还要指定这些块中每个元素在本地进程中的存储数量。       
* [2.x.2]     
* [2.x.3] [2.x.4] "块（线性代数）"    
* [0.x.2]*
       对基类进行类型化定义，以便更简单地访问它自己的别名。     
* [0.x.3]*
       类型化底层向量的类型。     
* [0.x.4]*
       从基类中导入别名。     
* [0.x.5]*
       默认构造函数。生成一个没有任何块的空向量。     
* [0.x.6]*
       构造函数。生成一个块向量，其块数与[2.x.5]中的条目一样多。每个IndexSet与MPI通信器一起包含MPI进程之间的数据分配布局。     
* [0.x.7]*
       创建一个带有幽灵元素的BlockVector。更多细节见各自的reinit()方法。 [2.x.6]可以包含[2.x.7]中的任何元素，它们将被忽略。     
* [0.x.8]*
       复制-构造器。将平行向量的所有属性设置为给定参数的属性，并复制这些元素。     
* [0.x.9]*
       移动构造函数。通过窃取向量的内部数据创建一个新的向量[2.x.8]。      
* [0.x.10]*
       创建一个由<tt>num_blocks</tt>组件组成的块状向量，但各个组件中没有内容，用户必须使用块状向量的重定位来填充适当的数据。     
* [0.x.11]*
       销毁器。清除内存      
* [0.x.12]*
       复制操作符：用给定的标量值填充本地存储的向量的所有组件。     
* [0.x.13]*
       对相同类型的参数进行复制操作。     
* [0.x.14]*
       移动给定的向量。这个操作符通过有效地交换内部数据结构，将目前的向量替换为[2.x.9]。     
* [0.x.15]*
       另一个复制函数。这个函数接收一个deal.II块向量并将其复制到一个TrilinosWrappers块向量中。注意，块的数量必须与输入向量中的相同。      使用 reinit() 命令来调整 BlockVector 的大小或改变块组件的内部结构。            由于Trilinos只在双数上工作，这个函数被限制为在deal.II向量中只接受一种可能的数字类型。     
* [0.x.16]*
       重新初始化BlockVector，使其包含与输入参数中给出的索引集一样多的块，根据地图中描述的各个组件的平行分布。            如果<tt>omit_zeroing_entries==false</tt>，该向量将被填充为零。     
* [0.x.17]*
       Reinit功能。这个函数销毁了旧的向量内容，并根据输入的分区生成一个新的向量。除了像上面所有其他方法一样只指定一个索引集外，这个方法还允许提供一个额外的幽灵条目集。      有两个不同版本的向量可以被创建。如果标志[2.x.10]被设置为[2.x.11]，该向量只允许读取[2.x.12]和[2.x.13]的联合集合，那么reinit方法的效果相当于调用其他的reinit方法，其索引集包含本地拥有的条目和幽灵条目。            如果标志[2.x.14]被设置为 "true"，这就为ghost元素创建了一个替代性的存储方案，允许多个线程向向量中写入数据（对于其他reinit方法，一次只允许一个线程向ghost条目写入数据）。     
* [0.x.18]*
       将尺寸改为向量<tt>V</tt>的尺寸。这与其他reinit()函数的情况相同。            <tt>V</tt>的元素不会被复制，也就是说，这个函数与调用<tt>reinit (V.size(), omit_zeroing_entries)</tt>相同。            注意，你必须调用这个（或其他reinit()函数）函数，而不是调用单个块的reinit()函数，以允许块向量更新它的向量大小缓存。如果你在其中一个块上调用reinit()，那么对这个对象的后续操作可能会产生不可预测的结果，因为它们可能会被路由到错误的块上。     
* [0.x.19]*
       将块的数量改为<tt>num_blocks</tt>。各个区块将被初始化为零大小，所以假定用户自己以适当的方式调整各个区块的大小，并在之后调用<tt>collect_sizes</tt>。     
* [0.x.20]*
       这个reinit函数是为了用于需要使用一些非本地数据的并行计算。需要这个函数的典型情况是并行调用[2.x.15]函数（或一些导数）。由于提前检索数据通常更快，这个函数可以在汇编分叉到不同处理器之前被调用。这个函数的作用如下。      它获取给定矩阵的列中的信息，并寻找不同处理器之间的数据耦合。然后从输入向量中查询这些数据。注意，你不应该再向结果向量写入数据，因为有些数据可以在不同的处理器上存储多次，导致不可预测的结果。特别是，这样的向量不能用于矩阵-向量乘积，例如在线性系统的求解过程中。     
* [0.x.21]*
       如果这个向量包含鬼魂元素，则返回。             [2.x.16] [2.x.17] "有鬼元素的向量"      
* [0.x.22]*
       交换这个向量和另一个向量<tt>v</tt>的内容。我们可以用一个临时变量和复制数据元素来完成这个操作，但这个函数明显更有效率，因为它只交换两个向量的数据指针，因此不需要分配临时存储空间和移动数据。            限制：现在这个函数只在两个向量有相同数量的块的情况下工作。如果需要，也应该交换块的数量。            这个函数类似于所有C++标准容器的swap()函数。此外，还有一个全局函数swap(u,v)，它简单地调用<tt>u.swap(v)</tt>，同样与标准函数类比。     
* [0.x.23]*
       打印到一个流。     
* [0.x.24]*
       异常情况      
* [0.x.25]*
       异常情况      
* [0.x.26]*
     全局函数，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个向量的数据。         [2.x.18] [2.x.19].     
* [0.x.27]*
     linear_operator.h中内部使用的一个辅助类。对[2.x.20]的特殊化。    
* [0.x.28]*
 将[2.x.21]声明为分布式向量。

* 
* [0.x.29]

