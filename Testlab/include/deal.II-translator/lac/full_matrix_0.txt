include/deal.II-translator/lac/full_matrix_0.txt
[0.x.0]!  [2.x.0] Matrix1 [2.x.1]! 

 
* [0.x.1]*
 实现一个经典的矩形数字方案。条目的数据类型由模板参数<tt>number</tt>提供。 该接口相当肥大，事实上，每次需要新的功能时，它都会增长。所以，提供了很多功能。
* 内部计算通常是以函数的向量参数的精度来完成的。如果没有数字类型的参数，则使用矩阵数字类型。
* 

* 
* [2.x.2] 本模板的实例化提供给<tt> [2.x.3] [2.x.4] [2.x.5] [2.x.6] 其他可以在应用程序中生成，详见[2.x.7] 。

* 
* [0.x.2]*
   用于对该容器进行索引的一种类型。 
* [0.x.3]*
   矩阵条目的类型。这个别名类似于标准库容器中的<tt>value_type</tt>。 
* [0.x.4]*
   使用基类的可变迭代器类型。 
* [0.x.5]*
   使用基类的常数迭代器类型。 
* [0.x.6]*
   使用基类的迭代器函数。 
* [0.x.7]*
   使用基类迭代器函数  
* [0.x.8]*
   声明一个类型，该类型持有与本类的模板参数相同精度的实值数。如果这个类的模板参数是一个实数数据类型，那么real_type就等于模板参数。  如果模板参数是一个[2.x.8]类型，那么real_type等于复数的基础类型。    这个别名被用来表示规范的返回类型。 
* [0.x.9]*
    [2.x.9] 构造函数和初始化。 也见基类Table。 
* [0.x.10]*
   构造函数。将矩阵初始化为一个维度为<tt>n</tt>的正方形矩阵。    为了避免整数和其他类型的矩阵的隐式转换，这个构造函数被声明为<tt>explicit</tt>。    默认情况下，不分配内存。 
* [0.x.11]*
   构造函数。将矩阵初始化为一个矩形矩阵。 
* [0.x.12]*
   构造函数从一个数组中初始化。该数组被逐行排列。不进行范围检查。 
* [0.x.13]*
   构建一个全矩阵，等于参数大小的身份矩阵。使用这个构造函数，我们可以很容易地创建一个大小为[2.x.10]的身份矩阵，方法是说  
* [1.x.0]
*   
* [0.x.14]*
    [2.x.11]   
* [0.x.15]*
    [2.x.12] 复制到其他矩阵中或从其他矩阵中复制出来  
* [0.x.16]*
    [2.x.13]   
* [0.x.17]*
   变量赋值运算符。 
* [0.x.18]*
   这个操作符将一个标量分配给一个矩阵。为了避免与这个函数的语义相混淆，0是<tt>d</tt>唯一允许的值，允许你以一种直观的方式清除一个矩阵。     [2.x.14]   
* [0.x.19]*
   复制操作符，创建一个完整的矩阵，等于参数大小的身份矩阵。这样一来，人们可以很容易地创建一个大小为[2.x.15]的身份矩阵，只要说  
* [1.x.1]
*   
* [0.x.20]*
   LapackFullMatrix的赋值操作。调用的矩阵必须与LAPACK矩阵的大小相同。 
* [0.x.21]*
   来自不同矩阵类的赋值。这个赋值运算符使用类型名MatrixType的迭代器。因此，稀疏矩阵是可能的来源。 
* [0.x.22]*
   来自不同矩阵类的转置赋值。这个赋值运算符使用了typename MatrixType的迭代器。因此，稀疏矩阵是可能的来源。 
* [0.x.23]*
   用从张量中提取的元素填充矩阵，取包括在<tt>r_i</tt>和<tt>r_j</tt>之间的行以及<tt>c_i</tt>和<tt>c_j</tt>之间的列。然后将得到的矩阵插入目标矩阵的<tt>(dst_r, dst_c)</tt>位置，对索引进行检查。 
* [0.x.24]*
   将一个子矩阵（也是矩形的）插入张量中，将其左上角的元素放在指定的位置<tt>(dst_r, dst_c)</tt>，其他元素也随之插入。默认值的选择是，如果张量的大小和矩阵的大小一致，则不需要指定参数。 
* [0.x.25]*
   将另一个矩阵的行和列的一个子集复制到当前对象中。     [2.x.16] 矩阵 要从中提取子集的矩阵。   [2.x.17] row_index_set 要提取的[2.x.18]的行的集合。   [2.x.19] column_index_set 要提取的[2.x.20]的列的集合。 [2.x.21] [2.x.22] 和 [2.x.23] column_index_set中的元素数量应等于当前对象的行和列的数量。换句话说，在这个操作中，当前对象的大小不会被调整。 
* [0.x.26]*
   将当前矩阵对象的元素复制到另一个矩阵的指定行和列集合中。因此，这是一个散点操作。     [2.x.24] row_index_set 要写入的[2.x.25]的行。   [2.x.26] column_index_set 要写入的[2.x.27]的列。   [2.x.28] matrix 某些元素要被替换的矩阵。 [2.x.29] [2.x.30]和[2.x.31] column_index_set中的元素数量应等于当前对象的行和列的数量。换句话说，在这个操作中，当前对象的大小不会被调整。 
* [0.x.27]*
   填充矩形块。    矩阵<tt>src</tt>的一个矩形块被复制到<tt>this</tt>。被复制的块的左上角是<tt>(src_offset_i,src_offset_j)</tt>。 被复制块的左上角是<tt>(dst_offset_i,dst_offset_j)</tt>。 被复制的矩形块的尺寸是可能的最大尺寸，由<tt>this</tt>或<tt>src</tt>的尺寸决定。 
* [0.x.28]*
   使基类的功能可用。 
* [0.x.29]*
   用另一个矩阵的permutation来填充。    矩阵<tt>src</tt>被复制到目标中。两个互换<tt>p_r</tt>和<tt>p_c</tt>的操作方式，使得<tt>result(i,j) = src(p_r[i], p_c[j]) </tt>。    如果矩阵<tt>src</tt>更大的话，向量也可能是从更大的整数集中选择出来的。也可以通过这种方法来复制行或列。 
* [0.x.30]*
   将矩阵的某一特定条目设置为一个值。因此，调用 [2.x.32] 完全等同于操作 [2.x.33] 。这个函数的存在是为了与各种稀疏矩阵对象兼容。     [2.x.34] i 要设置的元素的行索引。   [2.x.35] j 要设置的元素的列索引。   [2.x.36] value 要写进元素的值。 
* [0.x.31]*
    [2.x.37]   
* [0.x.32]*
    [2.x.38] 非修饰性操作符  
* [0.x.33]*
    [2.x.39]   
* [0.x.34]*
   比较运算符。对这个东西要小心，它可能会吞噬大量的计算时间 它最常用于程序的内部一致性检查。 
* [0.x.35]*
   这个矩阵的行数。 注意，这个矩阵的维度是[1.x.2]。 
* [0.x.36]*
   该矩阵的列数。 请注意，该矩阵的维度为[1.x.3]。 
* [0.x.37]*
   返回该矩阵是否只包含数值为0的元素。这个函数主要用于内部一致性检查，在非调试模式下应该很少使用，因为它需要花费相当多的时间。 
* [0.x.38]*
   返回由该矩阵引起的向量<tt>v</tt>的规范的平方，即[1.x.4]。这很有用，例如在有限元背景下，一个函数的[1.x.5]规范等于相对于代表有限元函数节点值的向量矩阵的矩阵规范。    显然，对于这个操作，矩阵需要是二次的，而且为了使结果真正成为一个规范，它还需要是实数对称的或复数隐式的。    该矩阵和给定向量的基础模板类型应该都是实值或复值，但不是混合的，这样这个函数才有意义。 
* [0.x.39]*
   建立矩阵标量乘积<tt>u<sup>T</sup>M v</tt>。这个函数在有限元背景下建立两个函数的单元标量积时大多有用。    这个矩阵和给定向量的基本模板类型应该都是实数或复数，但不是混合的，这样这个函数才有意义。 
* [0.x.40]*
   返回矩阵的[1.x.6]-norm，其中[2.x.40]（列上之和的最大值）。 
* [0.x.41]*
   返回矩阵的[2.x.41]-Norm，其中[2.x.42]（行上和的最大值）。 
* [0.x.42]*
   计算矩阵的Frobenius规范。 返回值是所有矩阵条目的平方和的根。   
* [2.x.43]对于我们中的胆小鬼：这个规范不是与向量空间的[1.x.7]规范兼容的规范。 
* [0.x.43]*
   计算歪斜对称部分的相对规范。返回值是矩阵的倾斜对称部分的Frobenius规范除以矩阵的规范。    这个函数的主要目的是检查，一个矩阵是否在一定的精度范围内是对称的。 
* [0.x.44]*
   计算矩阵的行列式。 这个功能只在一维、二维和三维空间实现，因为对于更高的维度，数值工作就会爆发。 很明显，对于这个函数来说，矩阵需要是二次的。 
* [0.x.45]*
   返回矩阵的轨迹，即对角线值的总和（恰好也等于矩阵的特征值的总和）。  很明显，对于这个函数来说，矩阵需要是二次的。 
* [0.x.46]*
   以用户定义的格式输出由指定的精度和宽度给出的矩阵。这个函数在为输出设置这些给定值之前保存了流的宽度和精度，并在输出后恢复之前的值。 
* [0.x.47]*
   打印矩阵并允许对条目进行格式化。    参数允许对输出格式进行灵活设置。     [2.x.44] <tt>precision</tt>表示尾数的数量。     [2.x.45] <tt>scientific</tt>用于确定数字格式，其中<tt>scientific</tt> = <tt>false</tt>表示固定点符号。     [2.x.46] <tt>width</tt>表示每列的与。<tt>width</tt>的零条目使函数计算出一个宽度，但如果输出粗略，可以将其改为正值。     [2.x.47] <tt>zero_string</tt>为零条目指定一个打印的字符串。     [2.x.48] <tt>denominator</tt> 将整个矩阵乘以这个共同的分母，得到更漂亮的数字。     [2.x.49] <tt>阈值</tt>：所有绝对值小于此值的条目都被视为零。 
* [0.x.48]*
   确定这个对象的内存消耗（以字节为单位）的估计值。 
* [0.x.49]*
   可变的迭代器，从<tt>r</tt>行的第一个条目开始。 
* [0.x.50]*
   超过行<tt>r</tt>末尾的一个可变迭代器。 
* [0.x.51]*
   从<tt>r</tt>行的第一个条目开始的恒定迭代器。 
* [0.x.52]*
   从第<tt>r</tt>行的最后一条开始的恒定迭代器。 
* [0.x.53]*
   用一个固定的因子来缩放整个矩阵。 
* [0.x.54]*
   用给定系数的逆数来缩放整个矩阵。 
* [0.x.55]*
   缩放后的矩阵的简单加法，即<tt>*this += a*A</tt>。    矩阵<tt>A</tt>可以是一个任意底层标量类型上的全矩阵，只要其数据类型可以转换为该矩阵的数据类型。 
* [0.x.56]*
   缩放矩阵的多重加法，即<tt>*this += a*A + b*B</tt>。    矩阵<tt>A</tt>和<tt>B</tt>可以是一个任意底层标量类型上的全矩阵，只要其数据类型可以转换为该矩阵的数据类型。 
* [0.x.57]*
   缩放矩阵的多重加法，即<tt>*this += a*A + b*B + c*C</tt>。    矩阵<tt>A</tt>, <tt>B</tt>和<tt>C</tt>可以是一个任意底层标量类型上的全矩阵，只要其数据类型可以转换为这个矩阵的数据类型。 
* [0.x.58]*
   添加矩形块。    矩阵<tt>src</tt>的一个矩形块被添加到<tt>this</tt>。  被复制的块的左上角是<tt>(src_offset_i,src_offset_j)/tt>。 被复制块的左上角是<tt>(dst_offset_i,dst_offset_j)</tt>。 被复制的矩形块的尺寸是可能的最大尺寸，由<tt>this</tt>或<tt>src</tt>的尺寸和给定的偏移量决定。 
* [0.x.59]*
   将<tt>B</tt>的转置加到<tt>this</tt>。    [1.x.8]  
* [0.x.60]*
   增加一个矩形块的转置。    矩阵<tt>src</tt>的一个矩形块被转置并添加到<tt>this</tt>。被复制的块的左上角是<tt>(src_offset_i,src_offset_j)</tt>在[1.x.9]转置的矩阵的坐标。 被复制块的左上角是<tt>(dst_offset_i,dst_offset_j)</tt>。 被复制的矩形块的尺寸是可能的最大尺寸，由<tt>this</tt>或<tt>src</tt>的尺寸决定。 
* [0.x.61]*
   在给定的位置添加一个单一元素。 
* [0.x.62]*
   在给定的全局矩阵行中，在全局矩阵中由col_indices指定的列上添加一个由<tt>values</tt>给出的数值数组。这个函数的出现是为了与deal.II中的各种稀疏矩阵兼容。特别是，两个布尔字段[2.x.50]和[2.x.51]并不影响这个例程的性能，与稀疏矩阵的情况不同，在实现中确实被忽略了。 
* [0.x.63]*
   [1.x.10].  简单地增加这一行的数量  
* [0.x.64]*
   [1.x.11].  多次增加这的行数。 
* [0.x.65]*
   [1.x.12].  简单添加这的列。 
* [0.x.66]*
   [1.x.13].  多次增加此列。 
* [0.x.67]*
   交换 [1.x.14].  交换这个的第i行和第j行  
* [0.x.68]*
   交换[1.x.15]。 交换这个的第i列和第j列  
* [0.x.69]*
   给这个的对角线元素添加常数，即添加身份矩阵的一个倍数。 
* [0.x.70]*
   赋值 <tt>*this = a*A</tt>.  
* [0.x.71]*
   分配 <tt>*this = a*A + b*B</tt>.  
* [0.x.72]*
   分配 <tt>*this = a*A + b*B + c*C</tt>.  
* [0.x.73]*
   通过形成现有矩阵和它的转置[1.x.16]之间的平均值，对矩阵进行对称。    很明显，矩阵必须是二次方的，才能进行这一操作。 
* [0.x.74]*
   A=Inverse(A)。A必须是一个方形矩阵。 通过高斯-乔丹算法对该矩阵进行反演，并进行部分透视。 这个过程对于正定矩阵来说表现良好，但要注意在不确定的情况下的舍入误差。    在deal.II被配置为LAPACK的情况下，函数Xgetrf和Xgetri建立了一个LU因式分解，并在该因式分解的基础上反转矩阵，提供了最好的性能，直到有几百个行和列的矩阵。    对一个<tt>n x n</tt>矩阵进行反转的数值努力是<tt>n*3</tt>。 
* [0.x.75]*
   将给定矩阵的逆运算分配给<tt>*this</tt>。这个函数是针对一到四维的二次元矩阵的硬编码。然而，由于所需的代码量增长很快，如果维数更大，则隐含地调用gauss_jordan()方法。 
* [0.x.76]*
   将给定矩阵[2.x.53]的Cholesky分解[2.x.52]分配给<tt>*this</tt>，其中[2.x.54]为下三角矩阵。给定的矩阵必须是对称正定的。    如果矩阵不是正定的，就会抛出ExcMatrixNotPositiveDefinite。 
* [0.x.77]*
   <tt>*this(i,j)</tt> = [2.x.55] 其中[2.x.56]是相同长度的向量。 
* [0.x.78]*
   将给定矩阵的左逆分配给<tt>*this</tt>。正在进行的计算是[1.x.17]。 
* [0.x.79]*
   将给定矩阵的右逆分配给<tt>*this</tt>。正在执行的计算是[1.x.18]。 
* [0.x.80]*
   矩阵-矩阵-乘法。    可选参数<tt>adding</tt>决定，结果是存储在<tt>C</tt>中，还是添加到<tt>C</tt>中。 if (adding) [1.x.19] if (!adding) [1.x.20] 假设<tt>A</tt>和<tt>B</tt>的大小兼容，并且<tt>C</tt>已经具有正确大小。    如果三个矩阵维度的乘积大于300，并且在配置过程中检测到BLAS，则该函数使用BLAS函数Xgemm。使用BLAS通常会带来相当大的性能提升。 
* [0.x.81]*
   矩阵-矩阵-乘法，使用<tt>this</tt>的转置。    可选的参数<tt>adding</tt>决定了结果是存储在<tt>C</tt>中还是添加到<tt>C</tt>中。 if (adding) [1.x.21] if (!adding) [1.x.22] 假设<tt>A</tt>和<tt>B</tt>具有兼容的大小，并且<tt>C</tt>已经具有正确大小。    如果三个矩阵维度的乘积大于300，并且在配置过程中检测到BLAS，则该函数使用BLAS函数Xgemm。使用BLAS通常会带来相当大的性能提升。 
* [0.x.82]*
   使用<tt>B</tt>的转置进行矩阵-矩阵乘法。    可选的参数<tt>adding</tt>决定了结果是存储在<tt>C</tt>中还是添加到<tt>C</tt>中。 if (adding) [1.x.23] if (!adding) [1.x.24] 假设<tt>A</tt>和<tt>B</tt>具有兼容的大小，并且<tt>C</tt>已经具有正确大小。    如果三个矩阵维度的乘积大于300，并且在配置过程中检测到BLAS，则该函数使用BLAS函数Xgemm。使用BLAS通常会带来相当大的性能提升。 
* [0.x.83]*
   使用<tt>this</tt>和<tt>B</tt>的转置进行矩阵-矩阵乘法。    可选的参数<tt>adding</tt>决定了结果是存储在<tt>C</tt>中还是添加到<tt>C</tt>中。 if (adding) [1.x.25] if (!adding) [1.x.26] 假设<tt>A</tt>和<tt>B</tt>具有兼容的大小，并且<tt>C</tt>已经具有正确大小。    如果三个矩阵维度的乘积大于300，并且在配置过程中检测到BLAS，则该函数使用BLAS函数Xgemm。使用BLAS通常会带来相当大的性能提升。 
* [0.x.84]*
   在当前矩阵中加入三乘积[1.x.27]。可以选择使用矩阵的转置[1.x.28]和[1.x.29]。缩放因子对整个乘积进行缩放，这在向矩阵添加三乘积的倍数时很有帮助。    这个乘积是在考虑到舒尔补码[1.x.30]的情况下编写的。 请注意，在这种情况下，<tt>A</tt>的参数必须是矩阵[1.x.31]的逆值。 
* [0.x.85]*
   矩阵-向量-乘法。    可选参数<tt>adding</tt>决定，结果是存储在<tt>w</tt>中，还是添加到<tt>w</tt>中。 if (adding) [1.x.32] if (!adding) [1.x.33] 源和目的必须不是同一个向量。 
* [0.x.86]*
   加法 矩阵-向量-乘法。 [1.x.34] 源和目的必须不是同一个向量。 
* [0.x.87]*
   转置矩阵-向量-乘法。    可选参数<tt>adding</tt>决定，结果是存储在<tt>w</tt>中，还是添加到<tt>w</tt>中。 if (adding) [1.x.35] if (!adding) [1.x.36] 源和目的必须不是同一个向量。 
* [0.x.88]*
   添加转置矩阵-向量-乘法。 [1.x.37] 源和目的必须不是同一个向量。 
* [0.x.89]*
   应用雅可比预处理程序，将<tt>src</tt>向量的每个元素乘以各自对角线元素的逆值，并将结果与阻尼系数<tt>omega</tt>相乘。 
* [0.x.90]*
   [1.x.38]. 残差计算，返回[1.x.39]-norm|[1.x.40]|。    源[1.x.41]和目的[1.x.42]不能是同一个向量。 
* [0.x.91]*
   正向消除下三角。 对于一个给定的右手边，反转矩形矩阵的下三角。    如果矩阵的列数多于行数，该函数只对左边的二次元子矩阵进行操作。如果行数多，则考虑矩阵的上二次方部分。   
* [2.x.57] 对[2.x.58]和[2.x.59]使用同一个对象是安全的。  
* [0.x.92]*
   向后消除上三角。    参见forward()    
* [2.x.60] 对[2.x.61]和[2.x.62]使用同一对象是安全的。  
* [0.x.93]*
    [2.x.63] 异常情况[2.x.64]。  
* [0.x.94]*
   例外情况  
* [0.x.95]*
   异常情况  
* [0.x.96]*
   异常情况  
* [0.x.97]*
   异常情况  
* [0.x.98]*
   异常情况  
* [0.x.99]

