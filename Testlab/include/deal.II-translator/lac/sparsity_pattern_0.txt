include/deal.II-translator/lac/sparsity_pattern_0.txt
[0.x.0]!  [2.x.0] 稀疏性 [2.x.1] 

* 
* [0.x.1]*
     申报容器大小的类型。   
* [0.x.2]*
     在copy_from()函数中，如果内部迭代器类型指向普通的无符号整数，则用辅助函数从一个被解读的迭代器中获取列索引。   
* [0.x.3]*
     在copy_from()函数中，如果内部迭代器类型指向无符号整数和其他值的对，则用辅助函数从一个被解除引用的迭代器中获取列索引。   
* [0.x.4]*
     同样，但有时需要用于某些类型的容器，使对中的第一个元素成为常数（如[2.x.2] ）。    
* [0.x.5]*
 SparsityPattern类型的对象上的迭代器。

* 
* [0.x.6]*
   为容器大小声明类型。 
* [0.x.7]*
   进入稀疏性模式的迭代器的访问器类。这个类也是进入稀疏矩阵的常量和非常量访问器类的基类。    请注意，这个类只允许对元素进行读取访问，提供它们的行号和列号（或者是完整的稀疏模式中的索引）。它不允许修改稀疏模式本身。 
* [0.x.8]*
     SparsityPattern的大小类型。   
* [0.x.9]*
     构造函数。   
* [0.x.10]*
     构造器。为给定的稀疏性模式构造结束访问器。   
* [0.x.11]*
     默认构造器创建一个假访问器。这个构造函数在这里只是为了能够在STL容器中存储访问器，例如 [2.x.3] 。    
* [0.x.12]*
     这个对象所代表的元素的行号。这个函数只能为is_valid_entry()为真的条目调用。   
* [0.x.13]*
     这个对象所代表的元素在当前行中的索引。    这个函数只能对is_valid_entry()为true的条目进行调用。   
* [0.x.14]*
     这个函数返回当前迭代器指向的整个稀疏模式中的第多少个条目。虽然疏散模式中的条目顺序通常并不重要，但这个函数允许使用线性索引来索引疏散模式的条目。        这个函数只能为is_valid_entry()为真的条目调用。   
* [0.x.15]*
     这个对象所代表的元素的列号。这个函数只能为is_valid_entry()为真的条目调用。   
* [0.x.16]*
     返回这个迭代器所指向的稀疏模式条目是否有效。注意，在压缩稀疏模式后，所有条目都是有效的。然而，在压缩之前，稀疏模式分配了一些内存来使用，同时仍在增加新的非零条目；如果你在稀疏模式生命周期的这个阶段创建迭代器，你将迭代那些无效的元素。    如果是这样的话，那么这个函数将返回false。   
* [0.x.17]*
     比较。真，如果两个迭代器都指向同一个矩阵位置。   
* [0.x.18]*
     比较运算符。如果第一行数字较小，或者行数字相等且第一个索引较小，则结果为真。        这个函数只有在两个迭代器都指向同一个稀疏模式时才有效。   
* [0.x.19]*
     我们所操作的稀疏模式被访问。   
* [0.x.20]*
     全局稀疏度模式中的索引。这个索引代表了迭代器/访问器在SparsityPattern类的数组中所指向的位置，该数组存储了列号。它也是稀疏矩阵的数值数组内的索引，该数组存储了该站点的相应数值。   
* [0.x.21]*
     将访问器移动到矩阵中的下一个非零条目。   
* [0.x.22]*
   一个迭代器类，用于在稀疏模式的元素上行走。    这些迭代器的典型用途是迭代稀疏模式的元素（或者，因为它们也是迭代相关矩阵的元素的基础，所以是迭代稀疏矩阵的元素），或者迭代单个行的元素。不能保证行的元素实际上是按照列数单调增加的顺序来遍历的。更多信息请参见SparsityPattern类的文档。   
* [2.x.4] 该类直接对SparsityPatternBase类的内部数据结构进行操作。因此，有些操作很便宜，有些则不然。特别是，访问指向的稀疏模式条目的列索引是很便宜的。另一方面，访问行索引是很昂贵的（对于一个有[2.x.6]行的矩阵，这需要[2.x.5]次操作）。因此，当你设计使用这些迭代器的算法时，通常的做法是不一次性循环疏散模式的[1.x.0]个元素，而是在所有行上有一个外循环，在这个循环中迭代这个行的元素。这样，你只需要解除对迭代器的引用以获得列索引，而通过使用循环索引可以避免对行索引的（昂贵）查找。 
* [0.x.23]*
     尺寸类型。   
* [0.x.24]*
     存储指针的类型。   
* [0.x.25]*
     构造函数。为给定的全局索引（即从第2行开始计算的给定元素的索引）创建一个进入稀疏模式[2.x.7]的迭代器。   
* [0.x.26]*
     构造函数。为给定的访问器创建一个进入稀疏模式[2.x.8]的迭代器。   
* [0.x.27]*
 一个可以存储矩阵中哪些元素是非零的类（或者，事实上，[1.x.1]是非零的），我们必须为其分配内存以存储其值。这个类是 "静态 "类型的稀疏格局的一个例子（见[2.x.9] ）。它使用[1.x.2]格式来存储数据，并被用作派生的SparsityPattern类和SparseMatrix类的基础。
* SparsityPatternBase的元素，对应于SparseMatrix对象可以存储非零条目的地方，被逐行存储。每行中的非零元素的排序（即增加列索引的顺序）取决于派生类。

* 
* [0.x.28]*
   声明容器大小的类型。 
* [0.x.29]*
   Typedef一个迭代器类，允许在一个稀疏模式的所有非零元素上行走。 
* [0.x.30]*
   Typedef一个迭代器类，允许在一个稀疏模式的所有非零元素上行走。    由于该迭代器不允许修改稀疏模式，该类型与[2.x.10]的类型相同。  
* [0.x.31]*
   定义一个值，用来表示#colnums数组中的某个值是未使用的，即不代表某个列号索引。    具有这种无效值的索引被用来使用add()成员函数向稀疏模式插入新条目，并在调用compress()时被删除。    你不应该认为这里声明的变量有一定的价值。这里给出的初始化只是为了让编译器进行一些优化，但变量的实际值可能会随着时间的推移而改变。 
* [0.x.32]*
    [2.x.11] 构造和初始化 构造器，析构器，初始化、复制和填充对象的函数。 
* [0.x.33]*
   初始化矩阵是空的，也就是没有分配内存。如果你想让这样的对象作为其他类中的成员变量，这是很有用的。你可以通过调用reinit()函数使该结构可用。 
* [0.x.34]*
   解构器。 
* [0.x.35]*
   为一个新的矩阵重新分配内存并设置数据结构，该矩阵有[2.x.12]行和[2.x.13]列，每行最多有[2.x.14]个非零条目。    这个函数只是将其操作映射到另一个reinit()函数。 
* [0.x.36]*
   为大小为[2.x.15]乘以[2.x.16]的矩阵重新分配内存，每行的条目数取自数组[2.x.17]，它必须给出每行的这个数字[2.x.18] 。    如果<tt>m*n==0</tt>所有的内存被释放，导致对象的完全重新初始化。如果是非零，只有当新的大小扩展到旧的大小时，才会分配新的内存。这样做是为了节省时间和避免堆的碎片化。 
* [0.x.37]*
   和上面一样，但用ArrayView参数代替。    派生类负责实现这个函数。 
* [0.x.38]*
   通过添加转置对象的稀疏模式使稀疏模式对称化。    如果稀疏度模式不代表二次矩阵，这个函数会抛出一个异常。 
* [0.x.39]*
   给矩阵添加一个非零条目。 这个函数只能用于非压缩的稀疏度模式。    如果该条目已经存在，则不会发生任何坏事。 
* [0.x.40]*
    [2.x.19] 迭代器  
* [0.x.41]*
   迭代器从矩阵的第一个条目开始。由此产生的迭代器可以用来走过稀疏模式的所有非零条目。    访问元素的顺序取决于派生类实现的存储方案。 
* [0.x.42]*
   最终迭代器。 
* [0.x.43]*
   迭代器从行<tt>r</tt>的第一个条目开始。    注意，如果给定的行是空的，即不包含任何非零条目，那么这个函数返回的迭代器就等于<tt>end(r)</tt>。还要注意的是，在这种情况下，迭代器可能不能被解除引用。    元素被访问的顺序取决于派生类实现的存储方案。 
* [0.x.44]*
   行<tt>r</tt>的最终迭代器。它指向超过行[2.x.20]末尾的第一个元素或超过整个稀疏模式的末尾。    请注意，结束迭代器不一定是可被解除引用的。特别是如果它是一个矩阵的最后一行的结束迭代器，情况更是如此。 
* [0.x.45]*
    [2.x.21] 查询信息  
* [0.x.46]*
   测试两个SparsityPatterns是否相等。 
* [0.x.47]*
   返回该对象是否为空。如果没有分配内存，它就是空的，这与两个维度都是零是一样的。 
* [0.x.48]*
   检查在某一位置的值是否可能是非零。 
* [0.x.49]*
   返回每行的最大条目数。在压缩之前，这等于给构造函数的数字，而在压缩之后，它等于用户实际分配的最大条目数。 
* [0.x.50]*
   计算这个结构所代表的矩阵的带宽。该带宽是[2.x.22]的最大值，其中索引对[2.x.23]代表矩阵的一个非零条目。因此，[2.x.24]矩阵的最大带宽为[2.x.25]，对角线矩阵的带宽为0，如果带宽为[2.x.27]，则每行最多有[2.x.26]个条目。返回的数量有时在文献中被称为 "半带宽"。 
* [0.x.51]*
   返回这个矩阵的非零元素的数量。实际上，它返回的是稀疏模式中的条目数；如果任何一个条目碰巧是零，无论如何都会被计算在内。    这个函数只有在矩阵结构被压缩的情况下才能被调用。否则就没有太大意义了。 
* [0.x.52]*
   返回该结构是否被压缩。 
* [0.x.53]*
   返回该矩阵的行数，相当于图像空间的维度。 
* [0.x.54]*
   返回该矩阵的列数，相当于范围空间的维度。 
* [0.x.55]*
   特定行中的条目数。 
* [0.x.56]*
   确定此对象的内存消耗（以字节为单位）的估计值。见MemoryConsumption。 
* [0.x.57]*
    [2.x.28] 访问条目  
* [0.x.58]*
   访问列号字段。 返回<tt>index</tt>中的第<tt>row</tt>条目的列号。注意，如果对角线元素被优化，每行的第一个元素就是对角线元素，即<tt>column_number(row,0)==row</tt>。    如果稀疏模式已经被压缩，那么（除了对角线元素），条目按列排序，即：<tt>column_number(row,i)</tt> <tt></tt> <tt>column_number(row,i+1)</tt>。 
* [0.x.59]*
   一个全局矩阵条目在其行中的索引。    这个函数类似于operator()，但它计算的索引不是关于总域的，而只是关于行的<tt>j</tt>。 
* [0.x.60]*
   这是operator()()的逆向操作：给定一个全局索引，找出它所属的矩阵条目的行和列。返回值是由行和列索引组成的一对。    这个函数只有在稀疏模式是封闭的情况下才能被调用。那么全局索引必须在0和n_nonzero_elements()之间。    如果<tt>N</tt>是这个矩阵的行数，那么这个函数的复杂性是[1.x.3]。 
* [0.x.61]*
    [2.x.29] 输入/输出  
* [0.x.62]*
   打印矩阵的稀疏度。输出包括每行一行，格式为<tt>[i,j1,j2,j3,...]/tt>。[1.x.4]是行号，[1.x.5]是这一行中分配的列。 
* [0.x.63]*
   以<tt>gnuplot</tt>能理解的格式打印矩阵的稀疏度，该格式可用于以图形方式绘制稀疏度模式。该格式由成对的<tt>i j</tt>非零元素组成，每个元素代表该矩阵的一个条目，输出文件中每行一个。指数从零开始计算，和平常一样。由于稀疏模式的打印方式与矩阵的显示方式相同，我们打印的是列索引的负数，这意味着<tt>(0,0)</tt>元素位于左上角而不是左下角。    在gnuplot中通过将数据样式设置为点或点来打印稀疏模式，并使用<tt>plot</tt>命令。 
* [0.x.64]*
   在一个.svg文件中打印出矩阵的稀疏度，可以在网络浏览器中打开。该.svg文件包含与矩阵中的条目相对应的方块。矩阵中包含非零值的条目对应的是一个红色的方块，而矩阵中零值的条目对应的是一个白色方块。 
* [0.x.65]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)将此对象的数据写入一个流中，以便进行序列化。 
* [0.x.66]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)从一个流中读取此对象的数据，以达到序列化的目的。 
* [0.x.67]*
   使用[BOOST序列化库](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)从流中写入和读取此对象的数据，以达到序列化的目的。 
* [0.x.68]*
    [2.x.30] 异常 [2.x.31].   
* [0.x.69]*
   只有在设置了SparsityPattern并且调用了compress()之后才允许进行该操作。 
* [0.x.70]*
   你试图向某一行添加一个元素，但没有剩余的空间。 
* [0.x.71]*
   这个操作改变了SparsityPattern的结构，在调用了compress()之后就不可能了。 
* [0.x.72]*
   可以存储在#rowstart数组中的最大行数。 因为只有在当前数组太小的情况下才会重新分配该数组，而不是当该矩阵结构的大小缩小时，#max_dim可能大于#rows，在这种情况下，#rowstart的元素比使用的要多。 
* [0.x.73]*
   该稀疏结构应表示的行数。 
* [0.x.74]*
   该稀疏结构应代表的列数。 
* [0.x.75]*
   实际分配的数组#colnums的大小。这里，与#rowstart数组的情况相同，即它可能大于数组的实际使用部分。 
* [0.x.76]*
   每行的最大元素数。这个值被设置为给reinit()函数（或构造函数）的值，或者在调用更灵活的构造函数或reinit版本时，设置为从向量中计算出的最大行长度。在调用compress()后，它的值或多或少没有意义。 
* [0.x.77]*
   数组，为每一行保存属于该行的#colnums中的第一个元素。请注意，数组的大小比行数大一个，因为最后一个元素是用于<tt>row</tt>=#rows，即超过最后使用的行。#rowstart[#rows]}的值等于#colnums中超过终点的元素的索引；这样，我们就能够写出类似<tt>for (i=rowstart[k]; i<rowstart[k+1]; ++i)</tt>的循环，也是为了最后一行。    请注意，分配的内存的实际大小可能比使用的区域要大。被分配的实际元素数被存储在#max_dim中。 
* [0.x.78]*
   列号的数组。在这个数组中，我们为每个非零元素存储其列号。第[1.x.6]行的元素的列号被存储在#rowstart[[1.x.7]]...#rowstart[[1.x.8]]的索引范围内。因此要找出一个给定的元素（[1.x.9]）是否存在，我们必须检查列号[1.x.10]是否存在于这个数组的上述范围内。如果它存在，比如在这个数组中的[1.x.11]位置，那么稀疏矩阵中相应元素的值也将在该类值数组的[1.x.12]位置。    在开始时，这个数组的所有元素都被设置为[2.x.32]。
* 
* - 表示无效的（未使用的）列号（不过如果要求优化存储，对角线元素会被预设）。现在，如果非零元素被添加，那么在行的各自范围内的一个列号在另一个之后被设置为添加元素的列号。当压缩被调用时，未使用的元素（由列号[2.x.33]表示 
* 
* - ）通过复制后续行的列号来消除，每行内的列号（对角线元素可能除外）被排序，这样就可以通过二进制搜索来寻找一个元素是否存在并确定其位置。 
* [0.x.79]*
   存储是否为这个对象调用了compress()函数。 
* [0.x.80]*
 这个类以[1.x.13]的格式来存储数据的稀疏性模式，并作为SparseMatrix类的基础。
* SparsityPattern的元素，对应于SparseMatrix对象可以存储非零条目的地方，被逐行存储。在每一行中，元素通常是按照列索引递增的顺序从左到右存储的；这一规则的例外情况是，如果矩阵是方形的（n_rows() == n_columns()），那么对角线条目会被存储为每一行的第一个元素，以使应用雅可比或SSOR预处理程序等操作更快。因此，如果你在迭代器的帮助下遍历SparsityPattern的一行元素（使用[2.x.34]和[2.x.35]，你会发现只要矩阵是方形的，每一行的元素就不是按列索引排序的（第一项是对角线，其次是按列索引排序的其他条目）。
* 虽然这个类构成了SparseMatrix对象的存储格式的基础，因此在建立线性系统中起着核心作用，但由于它的信息存储方式，很少被直接建立。相反，人们通常会先通过一个中间格式，例如参见 [2.x.36] 教程以及文档模块 [2.x.37] 。
* 你可以使用begin()、end()、begin(row)和end(row)对模式中的条目进行迭代。这些函数返回一个类型为[2.x.38]的迭代器，当取消引用一个迭代器[2.x.39]时，你可以访问[2.x.40]中的成员函数，如<tt>it->column()</tt>和<tt>it->row()</tt>。

* 
* [0.x.81]*
   声明容器尺寸的类型。 
* [0.x.82]*
   类型化一个迭代器类，允许在一个稀疏模式的所有非零元素上行走。 
* [0.x.83]*
   Typedef一个迭代器类，允许在一个稀疏模式的所有非零元素上行走。    由于该迭代器不允许修改稀疏模式，该类型与[2.x.41]的类型相同。  
* [0.x.84]*
   由于这个类只需要实现一个reinit()函数，我们需要将所有的基础reinit()函数带入范围，以便编译器能够找到它们。 
* [0.x.85]*
    [2.x.42] 构造和设置 构造器、析构器、初始化、复制和填充对象的函数。 
* [0.x.86]*
   初始化矩阵是空的，也就是没有分配内存。如果你想让这样的对象作为其他类中的成员变量，这是很有用的。你可以通过调用reinit()函数使该结构可用。 
* [0.x.87]*
   复制构造函数。只有当要复制的矩阵结构为空时，才允许调用该构造函数。这样做是为了防止非自愿的复制对象的临时性，这可能会使用大量的计算时间。然而，如果想把SparsityPattern放在一个容器中，例如，写诸如<tt>v.push_back(SparsityPattern());</tt>这样的语句，<tt>v</tt>一个[2.x.43]的SparsityPattern对象，则需要复制构造函数。    通常，使用显式关键字来禁止不需要的暂存器就足够了，但这对[2.x.44]不起作用，因为无论如何复制这样的结构是没有用的，因为多个矩阵可以使用相同的稀疏度结构，所以只允许对空对象进行复制，如上所述。 
* [0.x.88]*
   初始化一个大小为<tt>m x n</tt>的矩形图案。     [2.x.45] m 行的数量。   [2.x.46] n 列的数量。   [2.x.47] max_per_row 每行的最大非零条目数。 
* [0.x.89]*
   初始化一个大小为<tt>m x n</tt>的矩形图案。     [2.x.48] m 行的数量。   [2.x.49] n 列的数量。   [2.x.50] row_lengths 每行的非零条目的可能数量。  这个向量的每一行必须有一个条目。 
* [0.x.90]*
   初始化一个维度为<tt>m</tt>的二次元模式，每行最多有<tt>max_per_row</tt>非零条目。    这个构造函数自动启用对角线元素的优化存储。为了避免这种情况，请使用分别取行号和列号的构造函数。 
* [0.x.91]*
   初始化一个大小为<tt>m x m</tt>的二次方格。     [2.x.51] m 行和列的数量。   [2.x.52] row_lengths 每行的最大非零条目数。  这个向量的每一行必须有一个条目。 
* [0.x.92]*
   制作一个带有额外对角线的副本。    这样构造的对象是为了应用ILU(n)方法或其他不完全分解。 因此，在原始入口结构之外，在主对角线的两边为<tt>extra_off_diagonals</tt>侧对角线提供空间。    <tt>max_per_row</tt>是该结构每行容纳非零元素的最大数量。假设这个数字足够大，以容纳<tt>original</tt>中的元素以及由这个构造函数创建的新的非对角线元素。你通常希望给出与你给<tt>original</tt>相同的数字，再加上对角线的数量乘以2。然而，如果你希望根据其他标准而不是在边对角线上为分解增加更多的非零条目，你可以给一个更大的值。    这个函数要求<tt>original</tt>指的是一个二次方矩阵结构。 它必须被压缩。这个函数完成后，矩阵结构不会被压缩。 
* [0.x.93]*
   解构器。 
* [0.x.94]*
   复制操作符。对于这一点，与复制构造函数的情况相同：它被声明、定义并可以被调用，但后者只针对空对象。 
* [0.x.95]*
   为一个大小为[2.x.53]乘以[2.x.54]的矩阵重新分配内存，每一行的条目数取自ArrayView [2.x.55]，它必须给出每一行的这个数字[2.x.56] 。 
* [0.x.96]*
   这个函数压缩了这个对象所代表的稀疏结构。 它通过消除未使用的条目和对剩余的条目进行排序来实现，以便通过使用二进制搜索算法更快地访问。一个特殊的排序方案被用于二次矩阵的对角线条目，它总是每行的第一个条目。    不再需要的内存会被释放。    SparseMatrix对象需要对其初始化的SparsityPattern对象进行压缩，以减少内存需求。 
* [0.x.97]*
   如果你事先确切地知道将形成矩阵稀疏模式的条目，这个函数可以用来替代reinit()、对add()的后续调用和对close()的最后调用。    前两个参数决定了矩阵的大小。对于最后两个，请注意稀疏矩阵可以由一连串的行来描述，每一个行都由一连串的列索引和值来表示。在这里，begin()和end()参数指定了进入一个容器的迭代器（正向迭代器类型），一个代表一行。因此，begin()和end()之间的距离应该等于n_rows()。这些迭代器可以是[2.x.57] [2.x.58]指向C风格数组的迭代器，或者任何其他满足正向迭代器要求的迭代器。这些迭代器所指向的对象（即我们在对这些迭代器之一应用<tt>operator*</tt>或<tt>operator-></tt>后得到的东西）必须是一个容器本身，它提供了<tt>begin</tt>和<tt>end</tt>函数，指定了描述一行内容的迭代器的范围。解除这些内部迭代器必须产生一对作为列索引的无符号整数和一个任意类型的值（如果我们想用一个这样的对象来描述一个稀疏矩阵，就会使用这样的类型），或者只是一个无符号整数（如果我们只想描述一个稀疏的模式）。该函数能够通过一些模板魔法来确定我们在解读内部迭代器后得到的是无符号整数还是一对整数。    虽然外迭代器的顺序表示矩阵的不同行，但表示列的内迭代器的顺序并不重要，因为无论如何它们在这个函数的内部是被排序的。    由于这一切听起来非常复杂，请考虑下面的示例代码，它可能被用来填补一个稀疏模式。 
* [1.x.14]
* 注意这个例子是有效的，因为被解读的迭代器产生的容器有<tt>begin</tt>和<tt>end</tt>函数（即[2.x.59]，被解读的内部迭代器产生无符号整数作为列索引。请注意，我们可以用[2.x.61]替换两个[2.x.60]的出现，也可以用[2.x.62]替换内部的。    另一个例子如下，我们初始化整个矩阵，而不仅仅是一个稀疏模式。 
* [1.x.15]
* 这个例子是可行的，因为解读内部类型的迭代器会产生一对无符号整数和一个值，我们把其中的第一个作为列索引。如前所述，外部的[2.x.63]可以用[2.x.64]代替，内部的[2.x.65] int,double></tt>可以用[2.x.66] int,double></tt>代替，或者用一个列表或一组这样的对，因为它们都返回指向这种对的迭代器。 
* [0.x.98]*
   从一个DynamicSparsityPattern中复制数据。这个对象以前的内容会丢失，之后的稀疏模式会处于压缩模式。 
* [0.x.99]*
   从一个SparsityPattern复制数据。这个对象以前的内容会丢失，而之后的稀疏模式处于压缩模式。 
* [0.x.100]*
   取一个完整的矩阵并使用其非零条目为这个对象生成一个稀疏矩阵条目模式。    这个对象以前的内容会丢失，之后的稀疏模式处于压缩模式。    一旦你用这个函数建立了一个稀疏模式，你可能想给它附加一个SparseMatrix对象。然后可以使用以FullMatrix对象为参数的[2.x.67]版本，将原`matrix`对象复制到这个SparseMatrix对象中。通过这个过程，你可以将一个FullMatrix转换为一个SparseMatrix。 
* [0.x.101]*
   在指定的矩阵行中添加几个非零条目。 这个函数只能用于非压缩的稀疏模式。    如果其中一些条目已经存在，则不会发生任何坏事。 
* [0.x.102]*
    [2.x.68] 查询信息  
* [0.x.103]*
   测试两个SparsityPatterns是否相等。 
* [0.x.104]*
   返回这个对象是否只存储那些显式添加的条目，或者稀疏模式是否包含在构建它时通过其他方式（隐式）添加的元素。对于当前的类，当且仅当它是正方形时，结果是假的，因为此时它无条件地存储对角线条目，无论它们是否被显式添加。    这个函数的主要作用是在几种稀疏模式可以作为模板参数传递的情况下描述当前类。 
* [0.x.105]*
   确定此对象的内存消耗（以字节为单位）的估计值。参见MemoryConsumption。 
* [0.x.106]*
    [2.x.69] 访问条目  
* [0.x.107]*
   返回行号为<tt>i</tt>、列号为<tt>j</tt>的矩阵元素的索引。如果矩阵元素不是非零，则返回 [2.x.70] 这个函数通常由 [2.x.71] 它可能只被用于压缩稀疏模式，因为在这种情况下，搜索条目是否存在可以用二进制排序算法相当快地完成，因为列号被排序了。    如果<tt>m</tt>是<tt>row</tt>中的条目数，那么如果稀疏模式被压缩，这个函数的复杂度是[1.x.16] 。   
* [2.x.72] 这个函数并不便宜，因为它必须在给定行<tt>i</tt>的所有元素中进行搜索，以寻找索引<tt>j</tt>是否存在。因此，在你想循环查看这个稀疏模式（或与之相关的稀疏矩阵）的所有非零元素或单一行的非零元素的情况下，它比必要的要昂贵。在这种情况下，使用遍历稀疏模式或稀疏矩阵的元素的迭代器会更有效。 
* [0.x.108]*
    [2.x.73] 输入/输出  
* [0.x.109]*
   将此对象的数据全部写到文件中。这是以二进制模式进行的，所以输出的数据既不能被人类阅读，也不能（可能）被其他使用不同操作系统或数字格式的计算机阅读。    这个函数的目的是，如果你的内存不足，想在不同的程序之间进行交流，或者允许对象在程序的不同运行中持续存在，你可以把矩阵和稀疏模式换掉。 
* [0.x.110]*
   从文件中读取先前由block_write()写入的数据。  这是用上述函数的逆运算来完成的，所以它的速度相当快，因为除了前面的几个数字，比特流是不被解释的。    在这个操作中，对象被调整了大小，所有以前的内容都被丢失。    一个原始形式的错误检查被执行，它将识别最直白的尝试，将一些数据解释为按位数存储到文件的向量，但不会超过。 
* [0.x.111]*
   为了序列化的目的，将此对象的数据写入一个流中  
* [0.x.112]*
   为了序列化的目的，从一个流中读取此对象的数据  
* [0.x.113]*
   为了序列化的目的，从一个流中写和读这个对象的数据。 
* [0.x.114]*
    [2.x.74] 异常情况 [2.x.75]   
* [0.x.115]*
   异常情况  
* [0.x.116]*
   异常情况  
* [0.x.117]*
   是否启用对角线的特殊处理？ 
* [0.x.118]*
     声明容器大小的类型。   
* [0.x.119]

