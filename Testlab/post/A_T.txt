include/deal.II-translator/A-headers/automatic_and_symbolic_differentiation_0.txt
[0.x.0]*



* [2.x.0]


*
* [2.x.1]对自动和符号微分。
* 下面我们将非常简要地介绍什么是自动微分和符号微分，这些计算/数字方案有哪些变化，以及它们是如何被整合到deal.II的框架中的。所有这些方案的目的是在不想手工计算的情况下自动计算函数的导数或其近似值。常见的例子是，在有限元背景下，人们想解决一个非线性问题，要求一些残差[2.x.2]，其中[2.x.3]是一个复杂的函数，需要进行微分以应用牛顿方法；以及人们得到一个与参数有关的问题[2.x.4] 并希望对参数[2.x.5]形成导数的情况，例如，为了优化[2.x.6]的输出函数，或为了进行[2.x.7]的敏感性分析。我们应该把[2.x.8]看作是设计参数：例如，机翼的宽度或形状，选择用来建造物体的材料的硬度系数，发送到设备的功率，发送到燃烧器的气体的化学成分。在所有这些情况下，人们应该把[2.x.9]和[2.x.10]看作是[1.x.0]，并且繁琐地加以区分
*
* - 至少在手工操作时是这样。[2.x.11]中显示了一个相对简单的非线性问题的案例，它已经突出了手工计算导数的繁琐。然而，在现实中，人们可能会想到诸如化学反应流等问题，其中流体方程的系数，如密度和粘度，强烈地、非线性地依赖于流体在每一点的化学成分、温度和压力；化学物种根据反应系数相互反应，而反应系数也非线性地、复杂地依赖于化学成分、温度和压力。在许多情况下，所有这些系数的精确公式可能要花几行字才能写出来，可能包括几个非线性项的指数和（谐波或几何）平均值，和/或可能包含数据点之间的表格查询和内插。仅仅把这些项写对就已经很困难了；计算这些项的导数在大多数应用中是不切实际的，在现实中是不可能写对的。如果没有计算机的帮助，更高一级的导数就更不可能做到。自动或符号微分是解决这个问题的一个方法。我们只需要实现一次计算这些系数的输入的函数，就可以得到（正确的！）导数，而不需要进一步的编码工作（尽管在运行时、编译时或两者都有不可忽略的计算成本）。
*



*
* [2.x.12] auto_diff_1 自动微分法
* [1.x.1] （通常也被称为算法微分），是一种数字方法，可以用来 "自动 "计算函数对一个或多个输入变量的一阶，或许还有高阶导数。虽然这需要一定的计算成本，但使用这种工具的好处可能是巨大的。如果使用得当，通常复杂的函数的导数可以被计算得非常精确。尽管这些框架所能达到的确切精度在很大程度上取决于它们的基础数学公式，但一些实现方式的计算精度与机器精度相当。请注意，这与经典的数值微分（例如，通过在不同的点上对一个函数进行评估，使用有限差分近似）不同，后者的精度取决于扰动的大小以及所选择的有限差分方案；这些方法的误差要明显大于表述良好的自动微分方法。
* 那么，在有限元背景下使用自动微分的三个实际例子将是
*


*
* - 快速建立一个新的非线性公式的原型，而不需要手工计算线性化本身。
*


*
* - 在复杂的多物理学框架内自动线性化有限元残差加法形成，以及



*
* - 验证用户对基于单元的计算（如残差）和基于连续点的计算（如非线性构成法的切线）的线性化实施。
* 有相当多的自动微分数字的实现方法。它们主要分为两大类，即 [2.x.13] 源代码转换 [2.x.14] 和 [2.x.15] 操作符重载 [2.x.16] 。第一种方法是根据一些输入函数生成新的、可编译的代码，当执行时，返回输入函数的导数。第二种方法是利用<tt>C++</tt>操作符定义的能力，为自定义类的类型进行重载。因此，一个代表这样一个可自动微分的数字的类，在对它进行每一次数学运算后，原则上可以评估和跟踪它的值以及它的方向性导数。由于专门实现[2.x.17]源代码转换[2.x.18]方法的库共同描述了高度专业化的工具，作为函数预处理器使用，它们在deal.II本身没有直接支持。然而，后者代表了专门的数字类型，可以通过在适当的环境中使用模板元编程来支持。鉴于上面的例子，这意味着FEValues类（和朋友），以及Tensor和SymmetricTensor类应该支持用这些专门的数字进行计算。理论上，整个程序都可以被做成可微调的。例如，这在解决方案对输入参数的敏感性分析中可能是有用的。然而，到目前为止，这还没有被测试过）。)
* 基于[2.x.19]运算符重载[2.x.20]的专门框架的实现通常分为三类之一。在每一类中，一些定制的数据类代表了被评估函数的浮点值和它的导数，由
*


*
* - 利用[2.x.21]对偶[2.x.22]/[2.x.23]复杂步骤[2.x.24]/[2.x.25]超对偶[2.x.26]公式（有时也称为[2.x.27]无磁带[2.x.28]方法）。
*


*
* - 那些利用[2.x.29]拍打[2.x.30]的策略，以及
*


*
* - 那些通过[2.x.31]表达式模板[2.x.32]使用的编译时优化。
* 为了初步了解这些不同的实现方式在实践中可能是什么样的，我们对这些方法做了如下的一般性总结。
*


*
* - 上面列出的前两种[2.x.33]无龙头[2.x.34]方法（对偶数和复数步法）使用截断泰勒级数的某种变化，以及对扰动参数定义的特殊选择，用基于有限差分的方法来计算函数导数。双重 "数构成了在函数值被评估时同时计算的累积方向导数；在复数步法中，虚值有效地起到了这个作用。扰动参数的选择决定了方案的数值质量，例如泰勒方案截断的影响；对偶数在其一阶导数中不包含任何高阶项，而对于复数阶方法，这些存在的高阶项被忽略了。可以证明，这两种方法都不受减法取消误差的影响，而且在其有限差分方案中，它们在数值上对为数值扰动选择的内部[2.x.35]大小不敏感。因此，对偶数方法产生精确的一阶导数，而复数步骤近似法则不能。然而，对偶数的标准实现不能产生精确的二阶导数值。超对偶数对这一想法有不同的看法，数字以类似于四元数的形式表示（即带有额外的非实数成分），导数由泰勒级数所有四个成分的高阶截断来计算。其结果是，通过适当的实现，第一和第二导数都可以准确计算出来。
*



* - 使用[2.x.36]磁带[2.x.37]方法，选择一个指定的代码子区域，对该区域所有用活动（标记）输入变量执行的操作进行跟踪并记录在一个被称为磁带的数据结构中。在磁带区域结束时，可以通过用不同的输入变量集 "重放 "磁带来重新评估所记录的函数，而不是直接重新计算该函数。假设录音区域代表一个平滑的函数，那么该函数的任意高阶导数可以通过参考跟踪和存储在磁带上的代码路径来计算。    例如，这可以通过对感兴趣点周围的函数进行评估来实现）。有一些策略可以处理这样的情况：在被评估的点上，所录取的函数是不平滑的，或者它不是分析的。此外，我们可能需要考虑分支函数的情况，即磁带不再是连续的，而是在不同的评估路径上分叉，而这是由于最初记录的输入。
*


*
* - 基于[1.x.2]的方法利用了由抽象语法树（AST）构建的计算图（在这种情况下是[1.x.3]），该图从其输入值中解析出函数输出。    树上最外层的叶子代表独立变量或常数，并由单数运算符转换，由二进制运算符连接（在最简单的情况下）。因此，在编译时，对函数输入进行的操作是已知的，与此相关的导数操作也可以同时使用众所周知的计算运算导数的规则（如加减法下导数的关联性、乘积规则和连锁规则）来定义。这个运算器返回的编译输出类型不需要是通用的，而是可以根据DAG顶点上给该特定运算器的特定输入（可能携带微分历史）进行专业化。通过这种方式，可以为用于评估依赖函数的每个中间结果的非常专门的个别操作生成一套编译时优化的指令。
* 当然，这些方法中的每一种都有其优点和缺点，对于要解决的特定问题，其中一种可能比另一种更合适。由于上述实施细节（以及其他未讨论的细节）可能对用户是隐藏的，因此了解使用这些 "黑盒子 "自动差分数字中的任何一个的影响、运行时间成本和潜在的限制可能仍然很重要。
* 除了所提供的链接文章外，用于提供这里所提供的细节的资源包括。
*


* [1.x.4]

*


* [1.x.5]
*
* # ###利用链式定律
* 在最实际的意义上，上述任何一类都是利用链式规则来计算复合函数的总导数。为了执行这个动作，它们通常使用两种机制中的一种来计算导数，具体是
*


*
* - [2.x.38]正向模式[2.x.39]（或[2.x.40]正向积累[2.x.41]）自动分化，或
*


*
* - [2.x.42]反向模式[2.x.43]（或[2.x.44]反向积累[2.x.45]）自动差分。
* 值得注意的是，[2.x.46]最优雅各布积算[2.x.47]，执行一组最小的计算，位于这两种极限情况之间。它对一般复合函数的计算仍然是图论中的一个公开问题。
* 借助于下面的图表（它和一些列出的细节由这个[1.x.6]提供），让我们思考一下函数[2.x.48]及其导数的计算的代表性。
* [2.x.49] [2.x.50] </div> [2.x.51] [2.x.52] </div> </div>
* 具体来说，我们将简要介绍什么是正向和反向的自动差分。请注意，在图中，沿着文字图形的边缘是函数 [2.x.53] 相对于 [2.x.54] -个变量的定向导数，用符号 [2.x.55] 表示。在这个例子中，用于呈现函数值及其方向导数的具体计算方法在[1.x.7]中列出。对于第二个说明性例子，我们请感兴趣的读者参考[1.x.8]。
* 首先考虑任何复合函数[2.x.56]，这里表示为有两个独立变量，可以剖析为其基本函数[1.x.9]的组合。 如前所述，如果每个原始运算[2.x.57]都是平滑的和可微的，那么可以普遍采用链式规则来计算[2.x.58]的总导数，即[2.x.59]。区分 "正向 "和 "反向 "模式的是链规的评估方式，但最终都是计算总导数[1.x.10] 。
* 在正向模式下，链式规则是自然地从 "内向外 "计算的。因此自变量是固定的，每个子函数[2.x.60]被递归计算，其结果作为输入返回给父函数。使用圆括号封装和固定操作顺序，这意味着我们计算[1.x.11] 前向扫频的计算复杂性与输入函数的计算复杂性成正比。然而，对于每一个需要计算的方向性导数，都需要对计算图进行一次扫频。
* 在反向模式下，链式规则的计算有点不自然地从 "外向内 "进行。因变量的值首先被计算和固定，然后前面的微分运算被评估并与之前的结果从左到右连续相乘。同样，如果我们用括号封装和固定运算顺序，这意味着反向计算是由[1.x.12]进行的。中间值[2.x.61]被称为[2.x.62]邻接[2.x.63]，必须在计算图被遍历时计算和储存。然而，对于每个从属标量函数来说，计算图的一次扫描就能一次性呈现所有的方向性导数。
* 总的来说，每种模式的效率是由独立（输入）变量和从属（输出）变量的数量决定的。如果输出的数量大大超过输入，那么可以证明正向模式比反向模式的效率更高。反之，当输入变量的数量大大超过输出变量的数量时，也是如此。这一点可以用来帮助告知哪种数字类型最适合于使用自动微分进行的哪组操作。例如，在许多需要计算二阶导数的应用中，结合反向和正向模式是合适的。前者通常用于计算第一导数，后者用于计算第二导数。
*

*
* [2.x.64] auto_diff_1_1 支持的自动区分库
* 我们目前有以下数字类型和组合的验证实现。
*


*


*
* - 录音的ADOL-C（理论上是可微分的，但将实现多达二阶导数的内部驱动）。
*


*


*
* - 无带子的ADOL-C（一旦可区分）。
*


*


*
* - 使用表达式模板进行动态内存分配的前向模式Sacado（一旦可区分）。
*


*


*
* - 使用表达式模板的嵌套正向模式Sacado（可两次微分）。
*


*


*
* - 反向模式的萨卡多（一旦可微调）。
*


*


*
* - 嵌套的反向和动态分配的正向模式Sacado（两次可微分，但结果是内存泄漏，在[2.x.65]中描述的
* 注意，在上面，"动态内存分配 "是指在编译时不需要指定独立变量的数量。
* [1.x.13]中的
*


* [1.x.14]
*
*提供了对其有带和无带实现的原则性见解，以及如何将ADOL-C纳入用户代码中。为了解ADOL-C的实现，以及如何在数字代码中使用它的可能性，一些进一步的有用资源包括。
*


* [1.x.15]



* [1.x.16]



* [1.x.17]



* [1.x.18]
*
* 同样，为了解Sacado数字类型的实现（特别是表达式模板的使用和利用），选择了一些有用的资源，包括：*。
*


* [1.x.19]



* [1.x.20]



* [1.x.21]
*
* 正向和反向模式的Sacado数字的实现是相当复杂的。从Trilinos 12.12开始，数学运算的实现涉及大量的预处理指令和宏编程。因此，代码可能难以理解，而且这些类也不存在有意义的配套文档。因此，理解这些数字的原理实现的有用资源可以在[1.x.22]中找到，它概述了一个不使用表达式模板的正向模式自动差分数字的参考（尽管据说效率很低）实现。虽然没有明确说明，但[2.x.66]类似乎是按照双数的精神实现的）。
*

*
* [2.x.67] auto_diff_1_2 自动微分是如何集成到deal.II的？
* 由于每个自动分化库的接口都有很大的不同，所以在不久的将来会建立一个统一的内部接口来连接每个数字。目标将是让一些驱动类（提供核心功能，以后将在下一节介绍）有一个一致的机制与不同的自动区分库互动。具体来说，它们需要能够正确地初始化和最终确定将被解释为公式的因变量和自变量的数据。
* 实现支持的自动差分数字的接口的文件摘要如下。
*


*
* - ad_drivers.h:提供作为内部支持的自动区分库接口的驱动的类。这些在内部被用作我们提供的帮助类的中介。
*


*
* - ad_helpers.h:提供了一系列的类来帮助在一些不同的情况下进行自动区分。这些详见 [2.x.68] 。
*


*
* - ad_number_types.h:引入了一个枚举（称为类型代码），用于驱动类将支持的可自动区分的数字组合。   下面将讨论使用这种有点限制性的机制的理由。
*


*
* - ad_number_traits.h:声明一些为每个自动区分库和/或数字类型专用的内部类。这些随后被用来通过NumberTraits和ADNumberTraits类提供一个统一的接口，这些类在整个驱动中被广泛使用。我们还提供了一些机制来轻松查询这些数字的选择属性，即一些类型特征。
*


*
* - adolc_math.h:对ADOL-C数学运算的扩展，使这些数字在整个库中得到一致使用。
*


*
* - adolc_number_types.h:实现内部类，定义我们如何使用ADOL-C数字。
*


*
* - adolc_product_types.h:定义了一些乘积和标量类型，允许与Tensor和SymmetricTensor类一起使用ADOL-C数字。
*


*
* - sacado_math.h:对Sacado数学运算的扩展，使这些数字在整个库中被一致使用。
*


*
* - sacado_number_types.h:实现内部类，定义我们如何使用支持的Sacado数字。
*


*
* - sacado_product_types.h:定义了一些乘积和标量类型，允许与Tensor和SymmetricTensor类一起使用支持的Sacado数。
* 通过对每个支持的数字类型使用类型代码，我们人为地限制了可以在库中使用的可自动区分的数字类型。这种设计选择是由于确保每个数字类型被正确初始化，以及所有嵌套（模板化）类型的组合对库中执行的所有操作保持有效并不是一件小事。此外，库中还有一些冗长的函数，这些函数是为支持的数字类型而实例化的，并且有内部检查，只有在使用库所知道的可自动区分的数字时才会满足。这再次确保了所有计算的完整性得到维护。最后，使用一个简单的枚举作为类模板参数，最终使得在生产代码中切换使用的类型变得非常容易，几乎不需要对用户代码进行进一步的修改。
* [2.x.69] auto_diff_1_3 自动分化库的用户接口
* deal.II库为我们支持的自动区分库提供了一个统一的接口。到目前为止，已经为以下情况开发了帮助类。
*


*
* - 设计用于在正交点水平（或任何一般连续点）操作的类。



*


*


*
* - [2.x.70] %一个标量值函数的微分。       一个典型的用途是直接从应变能量函数中开发构成法。在[2.x.71]中给出了这种确切使用情况的一个例子。
*


*


*


*
* - [2.x.72] %对矢量值函数进行微分。       这可用于构成法的运动变量的线性化，或协助解决局部内部变量的进化方程。
*


*
* - 设计用于在细胞水平上操作的类。
*


*


*


*
* - [2.x.73] %标量值能量函数的微分，如可能产生于变分公式。这个类别的一个例子是在 [2.x.74] 中使用的。
*


*


*


*
* - [2.x.75] 矢量值的有限元残差的差异化，导致其一致的线性化。  [2.x.76]也提供了一个关于如何使用这个类的演示。
* 当然，用户也可以自己管理初始化和导数计算。
* 关于如何使用ADOL-C的最新例子可以在以下文献中找到
*


*
* - 他们的[1.x.23]。
*


*
* - 他们的[1.x.24]，和
*


*
* - 我们的[1.x.25]。
* 而对于萨卡多来说，说明性的例子可以在下面找到
*


*
* - 他们的[1.x.26]。
*


*
* - 一个[1.x.27]，和
*


*
* - 我们的[1.x.28]。
*



*
* [2.x.77] symb_diff_1 符号表达式和微分法
* [1.x.29]就其设计和使用而言，与自动微分完全不同。任何符号库的基础都是一个计算机代数系统（CAS），它实现了一种语言和一系列的算法来操作符号（或 "类字符串"）表达。从哲学的角度来看，这与手工进行代数运算的方式最为相似。
* 为了帮助更好地区分符号微分和自动微分等数值方法，让我们考虑一个非常简单的例子。假设函数 [2.x.78] ，其中 [2.x.79] 和 [2.x.80] 是相互独立的变量。通过应用连锁法则，这个函数的导数只是 [2.x.81] 和 [2.x.82] 。这些正是你在定义符号变量`x`和`y`，定义符号表达式`f = pow(2x+1, y)`并计算导数`diff(f, x)`和`diff(f, y)`后从CAS得到的结果。在这一点上，没有假设`x'和`y'代表什么；它们以后可能被解释为普通（标量）数、复数或其他一些幂函数和自然对数函数被定义好的东西。很明显，这意味着也没有关于哪一点来评估表达式或其导数的假设。我们可以很容易地将[2.x.83]的表达式在[2.x.84]处评估，然后再在不重新计算导数表达式本身的情况下，在[2.x.85]处评估。事实上，任何符号变量或表达式的解释，以及变量之间的相互依赖关系，都可以在它们的操作过程中的任何时候被定义或重新定义；这导致了计算的灵活性，这是自动差分所不能比拟的。例如，我们可以执行永久替换[2.x.86]，然后针对[2.x.88]的几个不同值重新计算[2.x.87]。我们也可以事后表达`x`和`y`之间的相互依赖关系，如[2.x.89] 。对于这种情况，这意味着最初计算的导数[2.x.90]和[2.x.91]真正代表了部分导数而不是总导数。当然，如果在计算导数[2.x.92]和[2.x.93]之前明确定义了这样的相互依赖关系，那么这可能对应于总导数（这也是自动差分在这个例子中唯一能够实现的结果）。
* 由于复杂的CAS构成了符号操作的基础，操作类型不一定只限于微分，而是可能跨越与离散微分计算、纯数学主题等相关的操作范围。[1.x.30]库的文档给出了大量的例子，突出了一个成熟的CAS的能力。通过[2.x.94]类和[2.x.95]命名空间中的相关函数，我们为高性能的[1.x.31]符号操作库提供了一个封装，它具有丰富的运算符重载和一致的界面，使其易于使用且 "自然"。事实上，在许多情况下，这个类可以作为算术类型的 "滴入 "替代品，将操作从数字性质转变为符号性质；当类在底层数字类型上被模板化时，这就变得特别容易。由于专注于PDEs的数值模拟，在deal.II中暴露的CAS功能主要集中在符号表达式的创建、操作和微分上。
* 对SymEngine功能的方便包装主要集中在仅涉及基于字典（即让人联想到 "基于字符串 "的东西）的操作。尽管SymEngine以一种有效的方式执行这些操作，但它们仍然是已知的计算昂贵的，特别是当这些操作是在大的表达式上执行时。因此，应该预计到在生产代码中使用时，执行微分、符号替换等[2.x.96]的代码部分的性能可能是一个限制因素。因此，deal.II提供了一个接口，通过[2.x.97]类（本身经常利用SymEngine提供的功能）加速对冗长的符号表达的评估。特别是，[2.x.98]同时使用常见的子表达式消除（CSE）等方法来优化符号表达式的集合，以及通过使用自定义生成的[2.x.99]或使用LLVM JIT编译器来生成高性能代码路径来评估这些表达式。[2.x.100]类的用法在[2.x.101]中有所例证。
* 作为最后的说明，必须认识到deal.II目前实现的支持符号库的接口还有很大的缺陷。目前实现的功能水平有效地限制了符号代数在传统使用情况下的使用（即标量和张量代数，因为可能对定义构成关系或复杂函数作为边界条件或源项的应用有用）。事实上，[2.x.102]展示了如何使用它来实现具有挑战性的构成模型。在未来，我们还将本着与[2.x.103]命名空间相同的精神，实现类来协助执行装配操作。
* 实现支持的符号可微调数的接口的文件摘要如下。
*


*
* - symengine_math.h:数学运算的实现，使实现符号表达式的类在整个库和用户代码中的使用一致。   它为标准命名空间中的许多数学函数提供对应的定义。
*


*
* - symengine_number_traits.h:提供一些机制来轻松查询符号数的选择属性，即一些类型特征。
*


*
* - symengine_number_types.h:[2.x.104]类的实现，可用于表示标量符号变量、标量符号表达式等。   这个表达式类被赋予了一整套重载的运算符，用于SymEngine库所支持的所有数学和逻辑运算，并且被认为在数值建模的背景下是有用的。
*


*
* - symengine_optimizer.h:[2.x.105]类的实现，可用于使用各种技术加速（在某些情况下，显著）符号表达式的评估。
*


*
* - symengine_product_types.h:定义了一些积和标量类型，允许与Tensor和SymmetricTensor类一起使用符号表达式。
*


*
* - symengine_scalar_operations.h:定义了许多可以对标量符号表达式或变量进行的操作。   这包括（但不限于）创建标量符号，对标量进行微分，以及在标量表达式中进行符号替换。
*


*
* - symengine_tensor_operations.h:定义了可以对符号表达式或变量的张量进行的众多操作。   这包括（但不限于）创建符号的张量，对符号的张量进行微分，对符号的张量进行微分，以及在张量表达式中进行符号替换。
*


*
* - symengine_types.h。为一些在符号计算范围内常用的类型提供别名。
*


*
* - symengine_utilities.h:提供一些在符号计算范围内有用的实用函数。


* [0.x.1]

include/deal.II-translator/A-headers/c++_0.txt
[0.x.0]*



* [2.x.0]
* 从9.0版本开始，deal.II需要一个至少支持[1.x.0]的编译器。作为其中的一部分，deal.II内部实现中的许多地方现在都在使用C++11中才引入的功能。 也就是说，deal.II也有一些函数和类，使其使用C++11的功能更容易。
* 一个例子是对C++11[1.x.1]的支持。基于deal.II的代码通常有许多类似的循环。


* [1.x.2]
* 使用C++11的基于范围的for循环，你现在可以这样写。


* [1.x.3]
* 这依赖于诸如[2.x.1]和DoF处理类中的等价函数，[2.x.2] [2.x.3] 这些函数的变体为所有单元格（不仅仅是活动单元格）和单个层次上的单元格提供迭代器范围。
* 库中还有许多其他的函数，允许习惯性的使用基于范围的for循环。例子有[2.x.4] [2.x.5] [2.x.6]等许多。
* C++11还引入了[constexpr](https://en.cppreference.com/w/cpp/language/constexpr)变量和函数的概念。定义为 "constexpr "的变量是在程序编译过程中计算出来的常量值，因此其初始化的运行时间成本为零。此外，`constexpr`常量有正确定义的生命期，完全避免了所谓的 "静态初始化顺序惨败"。%函数可以被标记为 "constexpr"，表明如果它们的输入参数是常量表达式，它们可以产生编译时常量返回值。此外，至少有一个`constexpr`构造函数的类可以被初始化为`constexpr`。
* 作为一个例子，由于构造函数[2.x.7] array_type &)是`constexpr`，我们可以在编译时用一个数组初始化一个张量，如：。


* [1.x.4]
* 在这里，A的内容没有被存储在堆栈中。相反，它们在编译时被初始化并插入到可执行程序的`.data`部分。程序可以在运行时使用这些值，而无需花费时间进行初始化。初始化张量可以用一句话来简化。


* [1.x.5]
* 一些函数如determinant()被指定为`constexpr`，但它们需要具有C++14能力的编译器。因此，这个函数在内部被声明为。


* [1.x.6]
* 如果有一个支持C++14的编译器，宏[2.x.8]简化为`constexpr`。否则，对于旧的编译器，它完全忽略了DEAL_II_CONSTEXPR。因此，在较新的编译器中，用户可以编写


* [1.x.7]
* 假设`A`是用`constexpr`指定器声明的。这个例子显示了使用`constexpr`的性能收益，因为这里我们在编译时进行了一个具有[2.x.9]复杂性的操作，避免了任何运行时的成本。


* [0.x.1]*
 deal.II目前只需要一个符合C++11的编译器，但有一些来自C++14标准的函数和类，在编译器只支持C++11的情况下也很容易提供。 这些都收集在当前的命名空间中。
* 最明显的例子是[1.x.8]函数，它可以说是一个疏忽，因为它没有被包含在C++11中（鉴于C++11中有[1.x.9]）。
* 在这个命名空间中还有其他一些小的补充，使我们在这一点上已经可以使用C++14的特性，尽管我们不需要一个符合C++14的编译器。
*

*
* [2.x.10] 如果使用的编译器确实支持C++14，那么这个命名空间的内容只是从命名空间`std`导入的类和函数。也就是说，我们回到了编译器提供的内容，而不是我们自己的实现。


* [0.x.2]*
 deal.II目前只需要一个符合C++11的编译器，但有一些来自C++17标准的函数和类，在编译器只支持C++11的情况下也很容易提供。 这些都收集在当前的命名空间。
* 最显著的例子是[1.x.10]类，它从C++17标准开始被引入到C++中。
* 在这个命名空间中还有其他一些小的补充，使我们在这一点上已经可以使用C++17的特性，尽管我们不需要一个符合C++17的编译器。
*

*
* [2.x.11] 如果使用的编译器确实支持C++17，那么这个命名空间的内容只是从命名空间`std`导入的类和函数。也就是说，我们回到了编译器提供的东西，而不是我们自己的实现。


* [0.x.3]*
 deal.II目前只需要一个符合C++11的编译器，但有一些来自C++20标准的函数和类，在编译器只支持C++11的情况下也很容易提供。 这些都收集在当前的命名空间中。
* 一个例子是[1.x.11]类，它从C++20标准开始被引入到C++中。它被用作[2.x.12][2.x.13]和[2.x.14]等函数的返回类型，以支持基于范围的for循环（参见[2.x.15]中基于范围的for循环的例子，以及上述函数的文档）。
* 在这个命名空间中还有其他一些小的补充，使我们在这一点上已经可以使用C++20的特性，尽管我们不需要一个兼容C++20的编译器。
*

*
* [2.x.16] 如果使用的编译器确实支持C++20，那么这个命名空间的内容只是从命名空间`std`导入的类和函数。也就是说，我们回到了编译器提供的内容，而不是我们自己的实现。


* [0.x.4]

include/deal.II-translator/A-headers/coding_conventions_0.txt
[0.x.0]*
  [2.x.0]
* 在整个deal.II中，我们努力保持我们的编程风格和我们提供的界面种类尽可能的一致。为此，我们采用了一套编码惯例，并尽可能地加以遵守。它们有两个部分：风格问题，以及我们称之为 "防御性编程 "的东西，后者是试图让我们的代码帮助我们发现错误。  在阅读它们的时候，重要的是要记住，风格并不是神赐予的，也不是比任何其他的惯例都要好；它们的目的只是为了使deal.II尽可能的统一。统一性减少了我们产生的错误的数量，因为我们可以，例如，总是假设输入参数在函数调用的输出参数之前。它们也简化了代码的阅读，因为有些东西通过查看代码的写法就已经很清楚了，而不需要去查找某些东西的确切定义。
* [1.x.0]
* [2.x.1] deal.II使用[2.x.2] 6.0来规范缩进。Astyle文件提供在
* [1.x.1]

* [2.x.3] 在提交之前，你应该运行
* [1.x.2]
* 在你的每一个文件上。这将确保缩进符合本页面中列出的风格指南。
* 这是很麻烦的。因此，更容易的是，你可以直接运行
* [1.x.3]
* 在你设置的编译库的任何目录中，对所有最近被修改的源文件进行缩进。如果你想确保所有提交的缩进都是正确的，你可能想设置一个提交后钩子。一种方法是将[2.x.4]复制到[2.x.5]，并确保其可执行。
* 如果你工作的系统安装了不止一个版本的[2.x.6]（或者它不在路径中），你应该将上述[2.x.7]命令改为
* [1.x.4]
*以指向正确的可执行文件。[2.x.8]
* [1.x.5]
* [2.x.9] [2.x.10] %返回某物数量（单元数、自由度等）的函数应以 [2.x.11] 开始。例如。   [2.x.12]
* [2.x.13] %设置位或标志的函数应以 [2.x.14] 开始；清除位或标志的函数应以 [2.x.15] 命名。  例子。  [2.x.16]
* [2.x.17] 应使用传统的逻辑运算符，而不是它们的英文等价物（即，使用[2.x.18]而不是[2.x.19] ）。
* [2.x.20] 在实现文件中，在每个函数之后，希望有三个空行，以使可读性更好。一个空行出现在函数中，用于对代码块进行分组，因为两个空行不足以明显地区分出代码属于两个不同的函数。[2.x.21]
* [2.x.22] 每当一个整数变量只能承担非负值，它就被标记为无符号。这同样适用于只能返回正值或零值的函数。例子。  [2.x.23]
* [2.x.24] 每当一个函数的参数不会被改变，它就应该被标记为const，即使是通过值传递。一般来说，我们将输入参数标记为const。这有助于作为一个额外的文档工具来澄清参数的意图（输入、输出或两者），并让编译器在这样的参数被改变时发出警告，这往往是不由自主的或糟糕的风格。[2.x.25]
* [2.x.26] 每当一个函数不改变嵌入类/对象的任何成员变量时，它就应该被标记为const。[2.x.27]
* [2.x.28] %函数和变量名称不能只由一个或两个字母组成，除非该变量是一个纯粹的计数索引。[2.x.29]
* [2.x.30] 类型别名（ [2.x.31] -declarations）优于 [2.x.32] -declarations。[2.x.33]
* [2.x.34] 使用GeometryInfo中的几何信息来获取每个单元的面数、每个单元的子数、与面3相邻的子单元的子指数等，而不是像 [2.x.35] 、 [2.x.36] 和 [2.x.37] 那样直接写进代码。这减少了出错的可能性，提高了代码的可读性。[2.x.38]
* [2.x.39] 类声明的布局如下：首先是公共函数块，从构造函数开始，然后是解构函数。如果有公共成员变量，这些变量必须出现在构造函数之前。只有当公有变量是常量（特别是静态和常量）或不可避免时，才应使用公有变量。   [2.x.40] 在公共成员之后，应列出受保护成员，最后是私有成员。顺序如上：先是变量，然后是函数。   [2.x.41] 异常应在公共部分的末尾声明，然后再开始非公共部分。   [2.x.42] 对于既不是[2.x.43]的成员变量，我们不使用C++11风格的类成员初始化；即，代替
* [1.x.6]
*写
* [1.x.7]
* [2.x.44]
* [2.x.45] 如果一个函数有输入和输出参数，通常输入参数应在输出参数之前，除非有充分的理由改变这个顺序。最常见的原因是带有默认值的输入参数的尾部。
* [2.x.47] 异常用于%内部参数检查和通过Assert宏进行一致性检查。像C++语言那样的异常处理（ [2.x.48] ，并使用AssertThrow宏）用于处理运行时的错误（如I/O故障），在任何情况下都必须开启，而不仅仅是在调试模式下。[2.x.49]
* [2.x.50] 有时通过使用几个非成员函数来实现一个类是有意义的，这些非成员函数不是公共接口的一部分，而且只在当前源文件中被调用。这样的自由函数应该放在一个内部命名空间中，其结构如下。
* [1.x.8]
* 其中[2.x.51]是调用类的名称。
* [2.x.52] 类、命名空间和类型一般使用大写字母来表示词的开头（例如TriaIterator）&mdash；有时也称为[1.x.9][1.x.10]&mdash；而函数和变量使用小写字母和下划线来分隔单词。  唯一的例外是Triangulation和DoFHandler中的迭代器别名（命名为cell_iterator、active_line_iterator等），以使其与标准库容器类的联系清晰。[2.x.53]
* [2.x.54] 对于有多个模板参数的类，维度通常放在数据类型指定器之前，即我们使用Point<dim,number>而不是Point<number,dim>。
* [2.x.55] 在deal.II中，有几个地方我们在头文件中使用正向声明。这样做的原因是，当我们只需要将某个类型标记为某个函数的参数时，不使用头文件，希望可以提高编译速度。在deal.II中使用的惯例是，如果我们需要的只是一个类型名称，那么这个类型可以在我们需要的头文件中向前声明；如果一个函数（或成员函数）可以返回一个值，那么这个值的类型声明应该可以得到（通过包括必要的头文件）。例如，[2.x.56]包括[2.x.57]，这样就可以写出类似[2.x.58]的东西，而不需要明确包括声明[2.x.59]所返回对象类型的头文件。
* [2.x.60] 每个类都必须有至少200页的文档；-)[2.x.61]
* [2.x.62]
*

* [1.x.11]
* [2.x.63] deal.II中的大多数类和函数是模板化的。这就带来了一个问题：如果有的话，这些对象是如何以及在哪里被实例化的。在整个deal.II中，我们采用了以下惯例。[2.x.64]
* [2.x.65]
* [2.x.66] 如果我们可以列举出所有可能的模板参数（例如，维度只能是1、2或3），那么一个函数模板就会进入[2.x.67]文件，我们明确地将所有可能性实例化。用户不会有任何需要看到这些函数模板，因为他们无论如何都不想为其他模板参数实例化这些函数。  [2.x.68]
* [2.x.69] 如果我们不能列举所有可能的模板参数（例如，vectortypes
*
* 因为用户可能想定义他们自己的向量种类），但至少知道一些常见的使用情况，那么该函数将被放入一个[2.x.70]文件中，并为所有常见的参数实例化函数。对于几乎所有的用户来说，这样做就可以了
*
* - 他们只使用我们已经实例化的（向量、矩阵......）类型，对他们来说，[2.x.71]文件不会有任何意义。这也不会减慢他们的编译速度，因为他们看到的东西都会包括[2.x.72]文件。但是定义了自己的（向量、矩阵......）类型的用户可以通过包括[2.x.73]文件，用自己的用户定义的类型实例化模板函数。
* [2.x.74] 最后，如果我们不能事先假定模板参数将采取哪些值（例如，任何从Subscriptor派生的类都可以作为参数），函数的定义将在头文件的底部提供声明。这些定义应该用<code>\#ifndefDOXYGEN ...\#以防止Doxygen发现它们。[2.x.75]
* [2.x.76]
* [2.x.77] 对于前两种情况，实例化指令被定义在[2.x.78]文件中。它们由一个叫做expand_instantiations的二进制文件处理（由[2.x.79]构建），参数根据你的配置通过cmake动态定义（见构建目录中的[2.x.80]）。正是这些[2.x.81]文件最终被包含在相应的[2.x.82]文件中。  [2.x.83]
*

* [1.x.12]
* [2.x.84] 防御性编程是我们经常使用的一个术语，当我们在谈论写代码的时候，要考虑到错误会发生。在这里，错误有两种方式：第一，我自己在写函数时可能犯错；第二，别人在调用我的函数时可能犯错。不管是哪种情况，我都希望我的代码写得(i)尽可能不出错，(ii)编译器已经可以发现一些错误，(iii)剩下的错误相对容易发现，比如说因为程序中止了。因此，防御性编程是一组使这些目标更有可能实现的策略。[2.x.85]
* [2.x.86] 随着时间的推移，我们已经学会了一些这方面的技术，其中一些我们在此列出。[2.x.87] [2.x.88] [1.x.13] 人们总是用错误或无意义的参数调用函数。作为典型的例子，考虑一个微不足道的向量加法的实现。
* [1.x.14]
* 虽然正确，但如果两个向量的大小不一样，这个函数就会陷入困境。你认为用不同大小的向量来调用这个函数是愚蠢的？是的，当然是这样的。但这种情况经常发生：人们忘记重新初始化一个向量，或者它在不同的函数中被重置，等等。这种情况时有发生。所以，如果你遇到这种不幸运的情况，可能要花很长时间才能弄清楚发生了什么，因为你很可能只是读取了未初始化的内存，或者也许你正在向[2.x.89]向量实际上并不拥有的内存写入。  这两种情况都不会导致程序的立即终止，但你可能会在以后的时间里出现随机错误。如果程序只是在这里立即停止，那就容易多了。下面的实现正是这样做的。
* [1.x.15]
* [2.x.90] 宏确保条件在运行时为真，否则会打印一个包含由第二个参数编码的信息的字符串，并中止程序。这样，当你写一个新的程序恰好调用这个函数时，你会马上知道你的错误，并有机会修复它，而不需要认真调试什么。   [2.x.91]作为一般准则，每当你实现一个新的函数时，要考虑[1.x.16]上的参数，即该函数对每一个参数或它们的组合期望是什么。  然后为所有这些先决条件写断言。在某些情况下，这可能是半打断言，但请记住，每个断言都是一个潜在的错误，已经通过琐碎的手段发现。   [2.x.92] 最后，让我们说说断言当然是昂贵的：当你把一个程序与库的调试版本链接时，它们可能会使程序慢3或5倍。但是如果你考虑到你的[1.x.17]开发时间，快速发现错误的能力可能远远超过你等待程序完成的时间。此外，在优化模式下，对Assert宏的调用被从程序中移除（你可能只在知道在调试模式下一切运行正常后才使用。优化后的库比调试后的库快3-5倍，但代价是更难发现错误。   [2.x.93]
* [2.x.94] [1.x.18] 如果一个函数计算出一些非微不足道的东西，那么代码中可能有一个错误。为了找到这些，可以使用后置条件：就像你对输入参数的有用值有一定的了解一样，你对可能的返回值也有一定的了解。例如，一个计算向量规范的函数希望规范是正的。你可以把它写成这样。
* [1.x.19]
* 这个函数太简单了，无法真正证明这个断言的正确性，但是想象一下计算的长度，你就可以看到这个断言是如何帮助你确保（或[1.x.20]）自己不犯错误的。请注意，人们可以争辩说，一旦我们运行了若干次程序，发现条件从未被触发，就应该删除这个断言。但最好还是把它留在原处：它为未来（和读者）编码了你对该函数的了解；如果有人出现，用更有效的算法取代了该函数的实现，断言可以帮助确保该函数继续做它应该做的事。   [2.x.95]
* [2.x.96] [1.x.21] 类似地，如果你有一个复杂的算法，使用断言来确保你对正在发生的事情的心理模型与确实的事实相符。例如，假设你正在编写一个函数，以确保网格尺寸不会在本地发生太大的变化。你最终可能会得到如下的代码。
* [1.x.22]
* 导致我们进入else-branch的条件可能很复杂，虽然我们认为我们到达这里的唯一可能性是邻居在边界上，这可能是真的，但在我们的实现中可能存在一个bug。也可能是我们的思维出现了错误，或者有人在同一个函数中改变了上面的代码而忘记了这里的问题，或者在库中一个完全不同的位置的改变使得这个假设站不住脚。在所有这些情况下，我们的断言的明确陈述可以确保这些问题被轻易发现。   [2.x.97]
* [2.x.98] [1.x.23] 传统的C语言要求在函数的开头声明变量，即使它们只在下面进一步使用。这就导致了我们可以想象在1d代码中出现这样的代码。
* [1.x.24]
* 问题是，如果声明和初始化之间的代码又长又复杂，你不可能在一页纸上查到一个变量的类型是什么，它的值可能是什么。事实上，甚至可能不太清楚该变量是否被用于初始化，或者它是否被意外地留在了未初始化状态。   [2.x.99] 一个更好的方法是这样做的。
* [1.x.25]
* 这使得变量的类型更加清晰，而且事实上它只在初始化时使用。此外，如果有人想阅读代码，看看这个变量实际上在做什么，在最内层的作用域中声明和初始化它，使这项任务更容易：我们不必在声明之外向上寻找它，也不必在当前作用域的末端向下寻找，因为这是变量死亡的地方。   [2.x.100] 作为最后的说明，很明显，你只能对完全生活在堆栈中的变量做这种事情，而不需要在堆上分配内存。在deal.II中，这只适用于像[2.x.101]等内置类型，以及点和张量类。其他的东西都有像[2.x.102]这样的成员变量，这需要内存分配&mdash；你不想在循环内声明这些，至少在循环被频繁遍历的情况下。   [2.x.103]
* [2.x.104] [1.x.26] 继续上面的例子，注意在大多数情况下，我们不会再改变如此初始化的变量。换句话说，如果是这种情况，我们不妨把事情写成如下。
* [1.x.27]
* 通过标记变量为常量，我们可以确保我们不会意外地改变它。例如，编译器可以捕获这样的代码。
* [1.x.28]
* 这很可能是指[2.x.105]而不是一个赋值。通过将该变量标记为常量，编译器就会告诉我们这个错误。也许同样重要的是，代码的人类读者不需要再往下看，变量的值是否真的在声明和使用之间的某个地方被改变了&mdash；如果它被标记为const，就不可能了。   [2.x.106]
* [2.x.107] [1.x.29] 对于函数参数，本质上也是如此。如果你不打算改变一个变量（这通常是输入参数的情况），那么就把它标记为常量。例如，下面这个函数应该把它的参数作为一个常数。
* [1.x.30]
* 这里，用户调用[2.x.108] ，例如。真的没有理由这个函数要改变[2.x.109]这个参数的值&mdash；所以把它标记为常量：这既可以帮助代码的读者理解这是一个函数的输入参数，我们不需要在下面搜索它是否被改变过，又可以帮助编译器在我们不小心改变了这个值时帮助我们找到bug。[2.x.110]
*


* [0.x.1]

include/deal.II-translator/A-headers/concepts_0.txt
[0.x.0]*



* [2.x.0]
* 有时对一个对象的类型施加约束而不要求它属于一个特定的继承层次是有用的。这些通常在C++社区中被称为[2.x.1]概念[2.x.2]。本模块列出了deal.II中常用的概念，并对其意图进行了简要描述。在deal.II中列出类型的约束条件的惯例是在模板中提供概念的名称作为[2.x.3]：例如，矢量的类型取决于底层字段的类型，因此它被定义为模板。


* [1.x.0]
* 这里的重点是，你正在创建一个可以存储[2.x.4]类型元素的向量，但这上面有一些基本假设。例如，deal.II Vector类并不打算仅仅作为一个集合使用（与[2.x.5]不同），而是定义了向量空间的操作，如向量的加法，或向量的规范。因此，用户可以为[2.x.6]指定的数据类型必须满足某些条件（即，它必须符合或 "模拟 "一个 "概念"）。具体来说，该类型必须表示代表数学上称为 "场 "的元素的对象（你可以认为是，嗯，"数字"：我们可以加、乘、除、取绝对值的东西，等等）。概念的意义在于描述[2.x.7]一个类型必须满足哪些条件[2.x.8]才能在特定的环境中成为有效的模板参数。
* 本页描述了在整个deal.II中使用的一些概念的这些条件。具体来说，在上面的例子中，下面讨论的[2.x.9]"数字概念 "描述了可以作为向量类的参数的类型。
*概念作为C++的语言扩展已经被提议了很久了。它们将允许我们描述一个类或函数具有某些属性，以便成为一个合格的模板参数。例如，它允许我们在C++代码中表达，例如，[2.x.10]的第一个参数必须有一个代表实际网格的类型。
*
* - 目前我们只能用文字来描述，见下文。使用C++的概念将允许我们在代码中描述这一点，并且试图用一个对象作为第一参数来调用这样一个函数，但实际上它不是一个网格，这将产生一个编译器错误，使不匹配的情况变得清晰。
* 不幸的是，这些对C++的建议从未进入任何官方的C++标准；然而，它们被建议用于C++20。一旦我们的绝大多数用户拥有支持这一标准的编译器，我们可能会开始使用它们。
* 关于这个主题的更多信息可以在[1.x.1]找到。
*

* [2.x.11]
* <dt class="concepts"> [2.x.12] ConceptDoFHandlerType [1.x.2]</dt>。
* [2.x.13] deal.II包括DoFHandler和[2.x.14]这两个管理网格上自由度的对象。虽然两者没有任何继承关系，但它们足够相似，许多函数只需要类似于DoFHandler的东西就能正常工作。  [2.x.15]
* <dt class="concepts"> [2.x.16] ConceptMatrixType [1.x.3]</dt>。
* [2.x.17] deal.II中的许多函数和类需要一个知道如何计算矩阵-向量积（成员函数 [2.x.18] ）、转置矩阵-向量积（成员函数 [2.x.19] ）以及 "乘法和加法 "等效物的对象 [2.x.20] 。有些函数只需要[2.x.21]，但如果模板需要MatrixType参数的话，一个对象应该实现所有四个成员函数。编写满足这些条件的类是很常见的，所以编写LinearOperator类是为了让事情变得更简单；更多信息请参见 [2.x.22] 。
* 对[2.x.23]的一种看法是，假装它是一个具有如下签名的基类（这几乎就是SparseMatrix提供的接口）。
*


* [1.x.4]
*
* C++中的模板函数不能是虚拟的（这是deal.II中不使用这种方法的主要原因），所以用继承的方式实现这个接口是行不通的，但这仍然是思考这个模板概念的一个好方法。人们可以使用LinearOperator类来实现[2.x.24]，而不是手动实现它们。  [2.x.25]
* <dt class="concepts"> [2.x.26] ConceptMeshType [1.x.5]</dt>。
* [2.x.27] 网格可以被认为是顶点和连接点的数组，但一个更有成效的观点是将它们视为[1.x.6]。在C++中，集合通常被称为[1.x.7]（典型的容器是[2.x.28][2.x.29]等），它们的特点是能够对集合中的元素进行迭代。<tt>MeshType</tt>概念是指任何定义了适当方法（如[2.x.30]和<tt>typedefs</tt>（如[2.x.31]）的容器，用于管理单元的集合。
* Triangulation、DoFHandler和[2.x.32]的实例都可以被视为单元格的容器。事实上，这些类的公共接口中最重要的部分仅仅由获得其元素的迭代器的能力组成。由于接口的这些部分是通用的，也就是说，这些函数在所有的类中都有相同的名字，所以可以编写一些操作，这些操作实际上并不关心它们是在三角化还是在DoF处理对象上工作。例如，在GridTools命名空间中就有大量的例子，强调了网格和DoF处理程序都可以简单地被视为单元格的集合（容器）这一抽象的力量。
* 另一方面，网格是不同于[2.x.33]或[2.x.34]的非标准容器，因为它们可以以多种方式被切分。例如，我们可以在活动单元的子集上迭代，也可以在所有单元上迭代；同样，单元被组织成层次，我们可以只为一个层次上的单元获得迭代器范围。然而，一般来说，所有实现单元格容器概念的类都使用相同的函数名称来提供相同的功能。
* 可以用任何一个类来调用的函数通过接受一个模板参数来表示，例如


* [1.x.8]
*或


* [1.x.9]
* 满足这个概念的类被统称为 [2.x.35] 网格类 [2.x.36] 。<tt>MeshType</tt>的确切定义在很大程度上依赖于库的内部结构，但它可以被概括为具有以下属性的任何类。  [2.x.37] [2.x.38] 一个名为<tt>typedef</tt>的<tt>active_cell_iterator</tt>。    [2.x.39] [2.x.40] 一个<tt>get_triangulation()</tt>方法，返回单元格集合的基础几何描述（Triangulation类之一）的引用。如果网格恰好是一个Triangulation，那么网格只是返回一个对其本身的引用。    [2.x.41] [2.x.42] 一个方法<tt>begin_active()</tt>，返回一个指向第一个活动单元的迭代器。    [2.x.43] [2.x.44] 一个静态成员值<tt>dimension</tt>，包含对象所处的维度。    [2.x.45] [2.x.46] 一个静态成员值<tt>space_dimension</tt>，包含对象的维度（例如，一个2D表面在3D环境中会有<tt>space_dimension = 2</tt>）。    [2.x.47] [2.x.48] [2.x.49]。
* <dt class="concepts"> [2.x.50] ConceptNumber [1.x.10]</dt>。
* [2.x.51] 这个概念描述了作为向量或矩阵条目有意义的标量，这通常是场元素的一些有限精度的近似。典型的例子是[2.x.52]和[2.x.53]的浮点类型[2.x.54]在很多地方也是如此。  [2.x.55]
* <dt class="concepts"> [2.x.56] ConceptPolynomialType [1.x.11]</dt>。
* [2.x.57] 更多信息见[2.x.58]中的描述。在某些情况下，任何满足类似于接口的


* [1.x.12]
*
*为了实现有限元的目的，可将其视为多项式。  [2.x.59]
* <dt class="concepts"> [2.x.60] ConceptPreconditionerType [1.x.13]</dt>。
* [2.x.61] 这基本上是[2.x.62]的同义词，但通常只要求定义[2.x.63]。大多数时候，定义[2.x.64]是不必要的。人们应该认为[2.x.65]是将线性算子的逆运算应用于向量的一些近似值，而不是线性算子对向量的作用，用于预处理器类。  [2.x.66]
* <dt class="concepts"> [2.x.67] ConceptRelaxationType [1.x.14]</dt>。
* [2.x.68] 这是一个能够对多网格方法进行放松的对象。我们可以认为满足这个约束的对象具有以下接口以及[2.x.69] "MatrixType "所要求的约束。


* [1.x.15]
* 其中这两个成员函数执行平滑方案的一个步骤（或这种步骤的转置）。换句话说，这些函数执行的操作是[2.x.70] 和 [2.x.71] 。  [2.x.72]
* <dt class="concepts"> [2.x.73] ConceptSparsityPatternType [1.x.16]</dt>。
* [2.x.74] 几乎所有的函数（除了[2.x.75]这个明显的例外）都以稀疏性模式为参数，可以采用常规的SparsityPattern或DynamicSparsityPattern，甚至是块状稀疏性模式之一。更多信息见 [2.x.76] 。  [2.x.77]
* <dt class="concepts"> [2.x.78] ConceptStreamType [1.x.17]</dt>。
* [2.x.79] 在C++中派生新的流类，众所周知是很困难的。为了解决这个问题，一些函数接受一个定义了[2.x.80]的参数，这样就可以轻松地输出到任何一种输出流。  [2.x.81]
* <dt class="concepts"> [2.x.82] ConceptVectorType [1.x.18]</dt>。
* [2.x.83] deal.II支持许多不同的向量类，包括与其他库的向量的绑定。这些与标准库中的向量类似（即它们定义了 [2.x.84] , [2.x.85] ），但也定义了像 [2.x.86] 这样的数字操作。VectorType的一些例子包括Vector, [2.x.87] 和 BlockVector。  [2.x.88]
* [2.x.89]


* [0.x.1]

include/deal.II-translator/A-headers/constraints_0.txt
[0.x.0]*



* [2.x.0]


* [2.x.1]
* 本模块处理自由度的约束问题。处理约束的中心类是AffineConstraints类。
* 约束通常来自几个方面，例如。
*


*
* - 如果你有迪里希特型边界条件，[2.x.2]，通常通过要求边界上的自由度有特定的值来执行，例如[2.x.3]，如果边界条件[2.x.4]要求自由度12位置的有限元解[2.x.5]有42值。这样的约束是由那些接受AffineConstraints参数的[2.x.6]函数版本产生的（尽管也有其他处理Dirichlet条件的方法，使用[2.x.7]见例如[2.x.8]和[2.x.9] ）。
*


*
* - 如果你有边界条件，设定了解决方案的某一部分数值，例如没有法向通量，[2.x.10]（如发生在流动问题中，由[2.x.11]函数处理）或规定的切向分量，[2.x.12]（如发生在电磁问题中，由[2.x.13]函数处理）。对于前一种情况，例如，设想我们在法线矢量具有[2.x.14]形式的顶点，在这个顶点的流场的[2.x.15]-、[2.x.16]-和[2.x.17]分量与自由度12、28和40相关。那么无正态流条件意味着我们需要有条件 [2.x.18] 。   规定的切向分量会导致类似的约束，尽管右手边经常有一些东西。
*


*
* - 如果你有悬挂节点约束，例如在这样的网格中。         [2.x.19] 我们假设右下角的两个红色自由度之一是[2.x.20]，其左右两边的黄色邻居是[2.x.21]和[2.x.22] 。那么，要求有限元函数是连续的，就相当于要求[2.x.23] 。类似的情况发生在hp自适应有限元方法的背景下。   例如，当在网格的两个标记单元上使用Q1和Q2元素（即使用FE_Q(1)和FE_Q(2)）时 [2.x.24] 有三个约束：首先 [2.x.25] ，然后 [2.x.26] ，最后是身份 [2.x.27] 。即使所有的单元格都使用相同的有限元，也会出现类似的约束条件作为悬挂节点。在所有这些情况下，你将使用[2.x.28]函数来计算这种约束。
*


*
* - 其他线性约束，例如，当你试图为一个问题施加某个平均值时，否则就没有唯一的解决方案。在[2.x.29]的教程程序中给出了这样一个例子。
* 在所有这些例子中，对自由度的约束是线性的，而且可能是不均匀的。换句话说，它们总是具有 [2.x.30] 的形式。处理存储和使用这些约束的deal.II类是AffineConstraints。
*

* [1.x.0]
* 在建立全局系统矩阵和右手边时，可以不考虑约束条件，即简单地在单元上循环，将局部贡献加入全局矩阵和右手边对象。为了进行实际计算，你必须对线性系统进行 "浓缩"：消除受约束的自由度并将适当的值分配给无约束的自由度。这改变了有限元计算中使用的稀疏矩阵的稀疏模式，因此是一个相当昂贵的操作。事情的一般方案是，你建立你的系统，使用[2.x.31]函数消除（浓缩）约束节点，然后你解决剩余的系统，最后你使用[2.x.32]函数从无约束节点的值中计算出约束节点的值。请注意，[2.x.33]函数适用于线性系统的矩阵和右手边，而[2.x.34]函数则适用于解向量。
* 这种先建立线性系统，再消除约束自由度的方案效率很低，如果约束条件多，矩阵满，即特别是对3d和/或高阶或hp-finite元素，则是一个瓶颈。此外，它不可能在一个进程可能无法接触到矩阵元素的情况下实现%的并行计算。因此，我们提供了建立线性系统的第二种方法，使用下面讨论的[2.x.35]和[2.x.36]函数。得到的线性系统与调用[2.x.37]函数后得到的线性系统是等价的。
*

*
* [2.x.38] 这两种应用约束的方式都是将矩阵对角线的值设置为与矩阵中其他项相同大小的[1.x.1]项。因此，你需要设置你的问题，使描述主要矩阵贡献的弱形式不是[1.x.2]。否则，像CG这样的迭代求解器会崩溃，或者像GMRES那样慢得多。
*

*
* [2.x.39] 虽然这两种方式是[1.x.3]，即通过任何一种方式计算的线性系统的解是相同的，但线性系统本身不一定具有相同的矩阵和右侧向量条目。具体来说，由于我们计算的方式不同，对应于受限自由度的矩阵对角线和右手边条目可能不同；但是，它们总是以这样的方式选择，即线性系统的解是相同的。
* [1.x.4]
* 如上所述，使用约束条件的第一种方式是在不考虑约束条件的情况下建立线性系统，然后将其 "浓缩 "掉。浓缩一个矩阵分四个步骤进行。
*


*
* - 首先是建立稀疏模式（例如，使用[2.x.40]）。
*



* - 那么浓缩矩阵的稀疏模式是由原始稀疏模式和约束条件组成的。
*


*
* - 第三，全局矩阵的组装。
*


*
* - 第四，矩阵最终被浓缩。
* 在浓缩过程中，我们实际上没有改变稀疏模式、矩阵和向量的行数或列数。相反，凝结函数将非零条目添加到矩阵的稀疏模式中（其中有受限节点），矩阵的凝结过程将产生额外的非零元素。在浓缩过程本身中，受约束的行和列被分配到无约束节点的行和列中。受约束的自由度保持原位。为了不干扰求解过程，这些行和列用零和主对角线上的一个适当的正值来填充（我们选择其他对角线元素大小的平均值，以确保新的对角线条目具有与其他条目相同的大小顺序；这保留了矩阵的缩放特性）。右手边的相应数值被设置为零。这样一来，受约束的节点在方程组求解时将始终得到零值，并且不会再与其他节点耦合。
* 与创建一个新的、更小的矩阵相比，保留矩阵中的条目有一个好处，即只需要一个矩阵和稀疏模式，因此需要的内存更少。此外，浓缩过程的成本较低，因为不是所有的而是只有矩阵中的受限值必须被复制。另一方面，求解过程将花费更长的时间，因为矩阵向量的乘法会在受约束的行中产生乘以零的结果。此外，矢量的大小更大，对于那些使用较大数量的辅助矢量的迭代求解方法（例如使用显式正交程序的方法）来说，会导致更多的内存消耗。尽管如此，这个过程由于其较低的内存消耗而更有效率。
* 浓缩函数存在于不同的参数类型中。SparsityPattern, SparseMatrix 和 BlockSparseMatrix。请注意，对于[2.x.41]类型的参数或其他PETSc或Trilinos矩阵封装类，没有任何版本。这是因为相对来说，要得到PETSc矩阵的稀疏结构的表示，并有效地修改它们是很困难的；这一点尤其适用于矩阵实际分布在一个计算机集群中的情况。如果你想使用PETSc/Trilinos矩阵，你可以复制一个已经浓缩的deal.II矩阵，或者以已经浓缩的形式组装PETSc/Trilinos矩阵，见下面的讨论。
*

* [1.x.5]
* 浓缩向量的工作原理与上面描述的矩阵的工作原理完全相同。请注意，缩合是一个等价的操作，也就是说，对一个向量或矩阵做一次以上的缩合操作与只做一次的结果相同：一旦一个对象被缩合，进一步的缩合操作就不会再改变它了。
* 与矩阵凝结函数相反，矢量凝结函数存在于PETSc和Trilinos矢量的变体中。然而，使用它们通常很昂贵，应该避免。你应该使用与上述相同的技术来避免使用它们。
*

* [1.x.6]
* 有时，人们希望在一个线性系统建立之后，根本就避免对它进行显式凝结。想这样做有两个主要原因。
* [2.x.42] [2.x.43] 缩合是一个昂贵的操作，特别是当有许多约束条件和/或矩阵有许多非零项时。对于三维或高多项式程度的计算，以及hp-finite element方法来说，这两种情况都很典型，例如见[2.x.44] "hp-paper"。这是hp教程程序中讨论的情况，[2.x.45] step_27 " [2.x.46] "，以及[2.x.47] 和 [2.x.48] " [2.x.49] "。
* [2.x.50] 你使用的矩阵可能没有[2.x.51]函数（例如，PETSc和Trilinos封装类就是这种情况，我们无法访问矩阵的底层表示，因此无法有效地实现[2.x.52]操作）。这种情况在 [2.x.53] 、 [2.x.54] 、 [2.x.55] 和 [2.x.56] 中讨论。  [2.x.57]
* 在这种情况下，一种可能性是在将局部条目转移到全局矩阵和向量的时刻就将其分配到最终目的地，同样在最初设置的时候就在浓缩的形式中建立一个稀疏的模式。
* AffineConstraints类也为这些操作提供了支持。例如，[2.x.58]函数将非零条目添加到一个稀疏模式对象中。它不仅添加了一个给定的条目，而且还添加了所有的条目，如果当前的条目对应于以后要消除的受限自由度，我们就必须写到这些条目。类似地，在将局部贡献复制到全局矩阵或向量时，可以使用[2.x.59]函数直接分配向量和矩阵中的条目。这些调用使得后续调用[2.x.60]变得没有必要。关于它们的使用例子，请看上面提到的教程程序。
* 注意，尽管它们的名字描述了函数的真正作用，[2.x.61]函数必须应用于矩阵和右手边的向量，而下面讨论的[2.x.62]函数则应用于求解线性系统后的向量。
*

* [1.x.7]
* 在求解浓缩方程组后，解向量必须被 "分配"：通过调用[2.x.63]对原始线性系统的修改，导致一个线性系统对所有无约束的自由度都能正确求解，但对有约束的自由度的值却没有定义。为了得到这些自由度的正确值，你需要将无约束的值也 "分配 "给它们的有约束的同事。这是由[2.x.64]函数完成的。分布的操作在某种意义上撤销了凝结过程，但应该注意的是，它不是逆向操作。基本上，分布将受约束的节点的值设置为从约束中计算出来的值，给定的是无约束的节点的值加上可能的不均匀性。
*

* [1.x.8]
* 如果一些约束线有不均匀性（如果约束来自于不均匀边界条件的实现，这就是典型的情况），情况就会比仅仅由于悬挂节点的约束更复杂一些。这是因为消除矩阵中的非对角线值会在向量中消除的行中产生贡献。这意味着，不均匀性只能用同时作用于矩阵和向量的函数来处理。这意味着，如果在没有任何矩阵的情况下调用相应的凝结函数（或者如果矩阵之前已经被凝结过），所有的不均匀性都会被忽略。
* 使用AffineConstraints类来实现Dirichlet边界条件在[2.x.65]教程程序中讨论。另一个利用AffineConstraints的例子是 [2.x.66] 。这里的情况要复杂一些，因为我们有一些不在边界上的约束。在创建AffineConstraints对象后，有两种方法来应用不均匀约束。
* 第一种方法。
*


*
* - 将[2.x.67]函数应用于系统矩阵和右侧，参数use_inhomogeneities_for_rhs = false（即默认）。
*


*
* - 使用[2.x.68]函数将不均匀约束部分的解设为零（或者从等于零的解矢量开始）。
*


*
* - 解决()线性系统
*


*
* - 将[2.x.69]应用于解决方案中
* 第二种方法。
*


*
* - 使用参数use_inhomogeneities_for_rhs = true的[2.x.70]函数，并将其应用于系统矩阵和右手方
*


*
* - 将解的有关分量设置为不均匀的约束值（例如使用[2.x.71]）。
*


*
* - 解决()线性系统
*


*
* - 根据求解器现在你必须对解应用[2.x.72]函数，因为求解器可以改变解中的约束值。对于一个基于Krylov的求解器来说，这应该不是严格意义上的需要，但是仍然有可能在不均匀值和解的值之间存在机器精度的差异，而且如果你有额外的约束，例如来自悬挂节点的约束，你可能无论如何都想调用[2.x.73]。
* 当然，这两种方法都导致了相同的最终答案，但方式不同。使用第一种方法（即在[2.x.74]中使用[2.x.75]时，我们建立的线性系统在所有那些自由度受到约束的地方，右手边的条目都是零，在这些线的矩阵对角线上有一些正值。因此，线性系统的解向量对于不均匀约束的自由度会有一个零值，我们需要调用[2.x.76]来给这些自由度以正确的非零值。
* 另一方面，在第二种方法中，对于不均匀约束自由度的矩阵对角线元素和相应的右手边条目，使线性系统的解已经具有正确的值（例如，如果约束条件是[2.x.77]，那么如果矩阵除了对角线条目外是空的，则行[2.x.78]，而[2.x.79]，这样[2.x.80]的解必须如愿满足[2.x.81]）。因此，我们不需要在求解后调用[2.x.82]来修复解的不均匀约束成分，尽管这样做也无妨。
* 还有一个问题，即采取哪种方法，以及为什么我们需要将第一种方法中的解向量的值设为零。这两个问题的答案都与迭代求解器解决线性系统的方式有关。为此，考虑到我们通常在残差下降到右手边法线的某个分数以下时停止迭代，或者说，在初始残差的某个分数以下时停止迭代。现在考虑这个问题。
*


*
* - 在第一种方法中，受限自由度的右手边条目为零，也就是说，右手边的准则实际上只包括我们关心的那些部分。另一方面，如果我们从一个解向量开始，而这个解向量在受约束的条目中不为零，那么初始残差就会非常大，因为目前解向量中的值与线性系统的解（在这些部分中为零）不匹配。   因此，如果我们一旦将初始残差减少了某一系数就停止迭代，那么我们可能在一次迭代后就达到了阈值，因为受限自由度被迭代求解器在一次迭代中就解决了。如果初始残差是由这些自由度主导的，那么我们在第一步就看到了急剧的减少，尽管在这短短的一次迭代中我们在线性系统的其余部分并没有真正取得什么进展。我们可以通过以下方式来避免这个问题：一旦残差的规范达到[1.x.9]的某个分数就停止迭代，或者我们可以将解的成分设置为零（从而减少初始残差），然后迭代直到达到[1.x.10]的某个分数。
*


*
* - 在第二种方法中，如果迭代中的起始向量为零，我们会遇到同样的问题，因为此时残差可能被受限自由度所支配，其值与我们在解中希望的值不一致。我们可以通过调用[2.x.83][1.x.11]求解线性系统（必要时在求解后再进行第二次），将解向量的相应元素设置为正确的值，从而再次规避这个问题。
* 除了这些考虑，考虑我们有[2.x.84]这种不均匀约束的情况，例如，从[2.x.85]形式的悬挂节点约束，其中[2.x.86]本身被边界值约束到[2.x.87] 。在这种情况下，AffineConstraints容器当然不能找出[2.x.88]的最终值，因此，不能正确设置解向量的第三分量。因此，第二种方法将不起作用，你应该采取第一种方法。
*

* [1.x.12]
*有些情况下，自由度受到不止一种方式的约束，有时是相互冲突的方式。例如，考虑下面的情况。      [2.x.89] 这里，蓝色标记的自由度[2.x.90]是一个悬挂节点。如果我们使用三线有限元，即FE_Q(1)，那么它将带有约束条件 [2.x.91] 。另一方面，它在边界上，如果我们施加了边界条件[2.x.92]，那么我们将有约束[2.x.93]，其中[2.x.94]是这个自由度位置上的边界函数[2.x.95]的值。
*那么，哪一个会赢？或者说：哪一个[1.x.13]赢？这个问题没有好的答案。
*


*
* - 如果悬挂的节点约束是最终执行的约束，那么对于一般的边界函数，所得到的解不再满足边界条件 [2.x.96] 。
*


*
* - 如果反其道而行之，在这一点上，解决方案将不满足悬挂节点的约束，因此将不满足所选元素的规则性属性（例如，尽管使用[2.x.97]元素，但将不连续）。
*


*
*-如果你考虑弯曲的边界，情况就会变得完全没有希望，因为那时边的中点（即悬挂的节点）一般不在母边上。因此，无论两个竞争约束的优先级如何，解决方案都不会是[2.x.98]符合要求的。如果悬空节点约束获胜，那么解决方案将既不符合要求，也没有正确的边界值。换句话说，"正确 "的解决方案是什么并不完全清楚。在大多数情况下，这并不重要：无论是哪种情况，由不符合性或不正确的边界值引入的误差最差也会与离散化的整体误差处于同一等级。
* 也就是说，如果你知道你想要的是什么，你应该怎么做。
*


*
* - 如果你想让悬挂的节点约束获胜，那么首先通过[2.x.99]函数建立这些约束。   然后用[2.x.100]将边界值插值到同一个AffineConstraints对象中。如果后一个函数遇到一个已经被约束的边界节点，它将简单地忽略这个节点的边界值，不触及约束。
*



* - 如果你想让边界值约束获胜，就像上面那样建立悬空节点约束，并使用这些约束用[2.x.101]函数来组装矩阵（或者，另一种方法是组装矩阵，然后对其使用[2.x.102]）。在第二步，使用[2.x.103]函数返回[2.x.104]，并将其作为[2.x.105]的输入，将边界节点设置为正确的值。
* 两种行为也可以通过建立两个独立的AffineConstraints对象，并以特定的第二个参数调用[2.x.106]函数来实现。
*

* [1.x.14]
* 有时候，直接压缩或消除线性方程组中的约束是不可取的，也是不可能的。特别是如果没有底层矩阵对象可以被压缩（或在装配过程中照顾到约束）。如果系统是由LinearOperator描述的，通常就是这种情况。
* 在这种情况下，我们可以用修改后的系统[1.x.15]代替[1]（M. S. Shephard.作为直接刚度装配过程的一部分，通过变换应用的线性多点约束。[1.x.16] 20(11):2107-2112, 1985).
* 这里，[2.x.107]是一个给定的（无约束的）系统矩阵，对于它，我们只假设可以应用于一个向量，但不一定可以访问单个矩阵条目。  [2.x.108]是线性方程组[2.x.109]的相应右手边。矩阵[2.x.110]描述了存储在AffineConstraints对象中的线性约束的同质部分，向量[2.x.111]是相应的不均匀性的向量。更确切地说，应用于向量[2.x.113]的[2.x.112]操作是[1.x.17]的操作。最后，[2.x.114]表示约束自由度子空间上的身份。
* 然后通过分配约束条件来恢复服从这些约束的[2.x.115]的相应解。  [2.x.116] .
* 整个系统可以通过以下代码片段来设置和解决。


* [1.x.18]



* [0.x.1]

include/deal.II-translator/A-headers/cuda_0.txt
[0.x.0]*



* [2.x.0]
* 本模块中的类涉及到使用CUDA在GPU上运行的功能描述。


* [0.x.1]

include/deal.II-translator/A-headers/distributed_0.txt
[0.x.0]*



* [2.x.0]


* [2.x.1]



* [2.x.2] 集群。
* [2.x.3]
* [1.x.0]
* deal.II除了在[2.x.4]模块中讨论的共享内存机器内的并行化之外，还可以使用通过MPI连接的多台机器来并行化计算。基本上有两种方法可以利用多部机器。
*


*
* - 每台机器都在本地保存整个网格和DoF处理程序，但每台机器上只保存全局矩阵、稀疏模式和解向量的一部分。
*


*
* - 网格和自由度处理程序也是分布式的，也就是说，每个处理器只存储一部分单元和自由度。没有一个处理器知道整个网格、矩阵或解决方案，事实上，在这种模式下解决的问题通常非常大（比如，一亿到几十亿自由度），没有一个处理器可以或应该存储哪怕一个解决方案矢量。
* 这两个选项中的第一个相对简单，因为人们在有限元程序中想做的大部分事情仍然以基本相同的方式工作，而且处理分布式矩阵、向量和线性求解器是很好的外部库，如Trilinos或PETSc，可以使事情看起来与在本地提供的一切几乎完全一样。这种并行化模式的使用在教程程序[2.x.5]和[2.x.6]中作了解释，这里不再详细讨论。
* 真正的分布式网格的使用要复杂得多，因为它改变了一些可以用deal.II三角计算、DoF处理程序等完成的事情，或者使之成为不可能。本模块以离地面50000英尺的有利位置记录了这些问题，而不涉及太多的细节。下面描述的所有算法都在命名空间[2.x.7]的类和函数中实现。
* 在使用MPI的并行计算中，一个重要的方面是，对矩阵和向量元素的写访问需要在操作结束后和使用对象前（例如从读取）调用compress（）。也请参见 [2.x.8] 。
* [1.x.1]
* 本命名空间中使用的算法的完整讨论，以及这里使用的许多术语的彻底描述，可以在[2.x.9] "分布式计算论文 "中找到。特别是，该论文表明，本模块讨论的方法可以扩展到数千个处理器和远远超过10亿个自由度。这篇论文还给出了许多术语的简明定义，这些术语在这里和图书馆的其他地方使用，与分布式计算有关。  [2.x.10]教程程序展示了该命名空间的类和方法在拉普拉斯方程上的应用，而[2.x.11]则是针对一个矢量值问题。  [2.x.12]将[2.x.13]程序扩展到大规模并行计算，从而解释了这里讨论的主题在更复杂应用中的使用。
* 关于我们认为的 "可扩展 "程序的讨论，见[2.x.14]"本词汇表条目"。
*

* [1.x.2]
* 在%并行%分布模式下，每个处理器上的[2.x.15]类型的对象只存储一个单元的子集。特别是，全局网格可以被认为是分解的，因此每个MPI进程 "拥有 "一些单元。然后，每个进程在本地存储的网格正是由它所拥有的那些单元组成，以及它在本地拥有的单元周围的一层[2.x.16]GlossGhostCell "幽灵单元"，还有一些我们称之为[2.x.17]的 "人工 "单元。后者是确保每个处理器拥有一个拥有所有粗略级别单元的网格，并且尊重相邻单元不能相差超过一个细化级别的不变性。下面的图片显示了这样一个网格，%分布在四个处理器上，以及每个处理器在本地存储的单元的集合。
* [2.x.18]
* 单元的颜色是基于[2.x.19]的 "子域ID"，它标识了哪个处理器拥有一个单元：绿松石色代表处理器0，绿色代表处理器1，黄色代表处理器2，红色代表处理器3。可以看出，每个进程在自己的单元格周围都有一层幽灵单元格，这些单元格被正确地用子域ID着色，子域ID标识了拥有这些单元格的处理器。还要注意每个处理器是如何存储一些人工单元的，用蓝色表示，它们的存在只是为了确保每个处理器知道所有的粗网格单元，并且网格具有2:1的细化属性；然而，在这些人工单元所占据的区域，处理器不知道那里的网格到底有多细，因为这些区域是由其他处理器所拥有的。因此，我们将开发的所有算法只能在本地拥有的单元上运行，如果有必要，也可以在幽灵单元上运行；试图访问任何人工单元上的数据很可能是一个错误。注意，我们可以通过测试<code>cell- [2.x.20] == triangulation.local_owned_subdomain()</code>来确定我们是否拥有一个单元。
* 这里需要考虑的 "真正的 "网格是由每个进程所拥有的单元组成的联合体，即由绿松石、绿色、黄色和红色区域的重叠所产生的网格，不考虑蓝色区域。
*

*
* [2.x.21] 这个 "真实 "的网格被分解成由每个进程存储的碎片，由[1.x.3]库提供。 p4est将完整的网格存储在一个叫做平行森林的分布式数据结构中（因此得名）。平行森林由四叉树（2D）或八叉树（3D）组成，这些树起源于每个粗略的网格单元，代表了从父单元到其四个（2D）或八个（3D）子单元的细化结构。在内部，这个平行森林由一个单元的（分布式）线性阵列表示，对应于每个树的深度优先遍历，然后每个进程存储这个单元的线性阵列的一个连续部分。这就导致了如上图所示的分区，从这个意义上说，它们不是最佳的，因为它们不能使子域之间的接口长度最小化（因此也不能使通信量最小化），但在实践中却非常好，可以用超快的算法进行操作。   因此，以这种方式存储和操作单元的效率往往超过了通信的优化损失。   这种划分方法产生的各个子域有时也可能由不相连的部分组成，如右上图所示）。然而，可以证明每个子域最多包括两个不相连的部分；见C. Burstedde, J. Holke, T. Isaac: "Bounds on the number of discontinuities of Morton-type space-filling curves", [1.x.4], 2017.)


* [1.x.5]
* DoFHandler类建立在Triangulation类的基础上，但它可以检测到每当我们实际使用[2.x.22]类型的对象作为三角形。在这种情况下，它为存在于全局网格上的所有自由度分配全局%数，但每个处理器将只知道那些定义在本地相关单元上的自由度（即本地拥有的单元或者是幽灵单元）。在内部，该算法的工作原理是：循环浏览我们本地拥有的所有单元，并为定义在这些单元上的自由度分配DoF指数，在不同处理器拥有的子域界面上的自由度，不属于邻近的处理器。然后，所有处理器交换他们本地拥有的自由度，并以这样的方式转移他们自己的指数，即所有子域上的每个自由度都由一个介于0和[2.x.23]之间的指数唯一识别（这个函数返回全局自由度的数量，在所有处理器上累积）。请注意，在这一步之后，每个进程拥有的自由度形成了一个连续的范围，例如，可以通过[2.x.24]返回的连续索引集得到。 在为所有自由度分配了唯一的索引之后，[2.x.25]函数就会在所有幽灵单元上循环，并与邻近的处理器进行通信，以确保这些幽灵单元上的自由度的全局索引与邻居分配给它们的索引一致。
*通过这个方案，我们可以确保我们本地拥有的每个单元以及所有的幽灵单元都可以被要求产生定义在它们身上的自由度的全局正确指数。然而，要求人造单元上的自由度很可能不会有什么好结果，因为这些单元没有任何信息（事实上，甚至不知道这些单元是否在全局网格上是活跃的，或被进一步细化）。
* 像往常一样，自由度在被列举后可以被重新编号，使用命名空间DoFRenumbering中的函数。
*

* [1.x.6]
* 在处理非常多的处理器时，人们很快就会了解到一件事，那就是不能在每个处理器上存储每个自由度的信息，即使这些信息是 "这个自由度不在这里"。这方面的一个例子是，我们可以为一个有[2.x.26]行的（压缩）稀疏模式创建一个对象，但我们只填充那些对应于[2.x.27]本地拥有的自由度的行。原因很简单：为了举例，我们假设我们有10亿个自由度，分布在100个处理器上；如果我们甚至在这个稀疏模式中每行只持有16个字节（无论我们是否拥有相应的自由度），即使每一行都是空的，我们也需要16GB的对象。当然，只有1000万行是不空的，为此我们需要160MB，再加上存储非零条目的实际列索引所需的东西。假设我们有一个中等复杂的问题，每行有50个条目，我们为每个条目存储价值4个字节的列索引，那么我们需要为1000万行中的每一行存储216个字节，以对应我们拥有的自由度，总共2.16GB。而我们不拥有的9.9亿行，每行需要16字节，共计15.840GB。很明显，如果我们使用更多的处理器，这个比例也不会变得更好。
* 解决这个问题的方法是只对线性系统中我们拥有的部分使用任何内存，或者出于其他原因需要。对于所有其他部分，我们必须知道它们的存在，但我们不能设置我们数据结构的任何部分。为此，存在一个叫做IndexSet的类，它表示我们所关心的一组索引，我们可能要为其分配内存。稀疏模式、约束矩阵、矩阵和向量的数据结构可以用这些IndexSet对象进行初始化，以真正只关心那些与索引集中的索引相对应的行或条目，而不关心所有其他的索引。然后这些对象会询问集合中存在多少个索引，为每个索引分配内存（例如初始化稀疏模式的一行的数据结构），当你想访问全局自由度[2.x.28]的数据时，你会被重定向到用索引[2.x.30]调用[2.x.29]的结果，而不是。访问[2.x.32]为假的元素[2.x.31]的数据将产生一个错误。
* 剩下的问题是如何确定与我们在每个处理器上需要担心的自由度相对应的指数集。为此，你可以使用[2.x.33]函数来获取一个处理器拥有的所有指数。注意，这是定义在本地拥有的单元上的自由度的一个子集（因为两个不同子域之间的界面上的一些自由度可能被邻居拥有）。这个定义在我们拥有的单元上的自由度集合可以通过函数[2.x.34]得到。 最后，有时我们需要本地拥有的子域以及相邻的幽灵单元上所有自由度的集合。这个信息由[2.x.35]函数提供。
*

* [1.x.7]
* 一个典型的并行应用要处理两种不同类型的并行向量：带有鬼魂元素的向量（也叫鬼魂向量）和没有鬼魂元素的向量。  这两种类型通常可以由同一数据类型表示，但当然也有不同的向量类型可以分别表示这两种类型：例如[2.x.36] [2.x.37]和建立在这些之上的BlockVector对象）。你可以在[2.x.38]"关于重影向量的词汇表条目 "中找到关于区分这些类型的向量的讨论。
* 从使用的角度来看，重影向量通常用于数据输出、后处理、误差估计、积分中的输入。这是因为在这些操作中，人们通常不仅需要访问[2.x.39]"本地拥有的道夫"，还需要访问[2.x.40]"本地活动的道夫"，有时还需要访问[2.x.41]"本地相关的道夫"，而它们的值可能不会存储在需要它们的处理器上的非鬼魂向量中。上面列出的操作也只需要对向量进行只读访问，因此在这些情况下，幽灵向量是可以使用的。
* 另一方面，没有鬼魂项的向量在其他所有地方都可以使用，如组装、求解或任何其他形式的操作。这些通常是只写的操作，因此不需要对可能被另一个处理器拥有的向量元素进行读取访问。
* 你可以使用operator=在有鬼魂元素和无鬼魂元素的向量之间进行复制（你可以在[2.x.42], [2.x.43] , 和 [2.x.44] 中看到）。
*

* [1.x.8]
* 在写这篇文章的时候，唯一能够处理刚才解释的情况的类是DynamicSparsityPattern。该函数的一个版本[2.x.45]存在，它接受一个IndexSet参数，指示要为疏散模式的哪些行分配内存。换句话说，创建这样一个对象是安全的，它将报告其大小为10亿，但实际上只存储了索引集有多少个元素的行。然后你可以使用通常的函数[2.x.46]来建立疏散模式，该模式是在网格的本地拥有的部分进行装配而产生的。产生的对象可以用来初始化PETSc或Trilinos矩阵，这些矩阵通过完全分布式存储支持非常大的对象尺寸。然后，该矩阵可以通过只在当前处理器所拥有的单元上进行循环来进行组装。
* 唯一需要注意的是，稀疏性需要存储哪些自由度的条目。从本质上讲，这些是我们在组装时可能在矩阵中存储的值。很明显，这些肯定是本地活动的自由度（它们生活在我们本地拥有的单元上），但是通过约束，也有可能写到位于幽灵单元上的条目。因此，你需要在初始化稀疏模式时传递来自[2.x.47]的索引集。
*

* [1.x.9]
* 在创建稀疏模式以及组装线性系统时，我们需要知道自由度的约束，例如由悬挂节点或边界条件导致的约束。像动态稀疏模式类一样，AffineConstraints容器在构造时也可以接受一个IndexSet，这个IndexSet指示在可能非常多的自由度中它应该实际存储哪些约束。与稀疏模式不同的是，这些自由度现在只是我们在组装时本地处理的自由度，即那些由[2.x.48]返回的自由度（本地拥有的自由度的超集）。
* 然而，在有些情况下，更复杂的约束会出现在有限元程序中。一个例子是在[2.x.49]的适应性计算中，自由度可以针对其他自由度进行约束，而这些自由度本身也被约束。在这样的情况下，为了完全解决这个约束链，只存储局部活动自由度的约束可能是不够的，可能还需要有局部相关自由度的约束可用。在这种情况下，AffineConstraints对象需要用由[2.x.50]产生的IndexSet进行初始化。
* 一般来说，如果你碰巧没有在每个处理器上存储所有必要的约束条件，你的程序将继续做一些事情：你将只是生成错误的矩阵条目，但程序不会中止。这与稀疏模式的情况相反：在那里，如果传递给DynamicSparsityPattern的IndexSet表明它应该存储太少的矩阵行，那么当你试图向不存在的矩阵条目写入时，程序会中止，或者矩阵类会默默地分配更多的内存来容纳它们。因此，在指明存储哪些约束条件时，谨慎行事是很有用的，使用[2.x.51]的结果而不是[2.x.52] 。这也是可以承受的，因为局部相关自由度的集合只比局部活动自由度的集合稍大一些。我们在[2.x.53]、[2.x.54]和[2.x.55]中选择了这种策略。
*

* [1.x.10]
* 和其他一切一样，你只能对本地处理器拥有的单元格进行后处理。DataOut和KellyErrorEstimator类自动做到了这一点：它们只对本地拥有的单元格进行操作，不需要做任何特别的事情。至少对于大型计算来说，也没有办法在一台机器上合并所有这些本地计算的结果，也就是说，每个处理器必须是自给的。例如，每个处理器必须生成自己的并行输出文件，而这些文件必须由一个能够处理多个输入文件的程序进行可视化处理，而不是在生成一个单一的输出文件之前将调用DataOut的结果合并到一个处理器。后者可以实现，例如，使用[2.x.56]和[2.x.57]函数。
* 这些考虑同样适用于所有其他的后处理动作：例如，虽然有可能通过在本地进行计算并将产生的单个数字处理器累积为整个通信的单个数字来计算全局能量耗散率，但如果每个处理器产生的数据量很大，一般来说是不可能做到这一点。
* 然而，对于后处理有一个特别的考虑：无论你在一个处理器拥有的每个单元上做什么，你至少需要访问在这些单元上活跃的所有那些解向量的值（即访问所有[1.x.11]的集合，用[2.x.58]《分布式计算论文》的语言），这是这个处理器实际拥有的自由度的超集（因为它可能不拥有自己的单元和其他处理器拥有的那些单元之间界面上的所有自由度）。然而，有时你需要更多的信息：例如，为了计算KellyErrorIndicator的结果，我们需要评估当前和邻近单元的界面上的梯度；后者可能为其他处理器所拥有，所以我们也需要这些自由度。因此，一般来说，人们需要获得所有自由度为[1.x.12]的解值。另一方面，我们可以用于并行线性代数的两个包（PETSc和Trilinos）以及[2.x.59]都将向量细分为每个处理器拥有的块和存储在其他处理器的块。因此，要对东西进行后处理意味着我们必须告诉PETSc或Trilinos，它也应该导入[1.x.13]，即除了我们本地拥有的向量之外，还应该导入解向量的其他向量元素。对于重影向量，这可以通过使用以分布式向量为参数的operator=来实现。


* [0.x.1]*
   一个命名空间，用于支持%分布式内存机器上的%并行计算的类和函数。参见[2.x.60]分布式模块，以了解该命名空间提供的设施的概况。    
* [2.x.61]
* [0.x.2]

include/deal.II-translator/A-headers/dofs_0.txt
[0.x.0]*



* [2.x.0]
* 本模块将与处理自由度有关的类和命名空间分组。该组的中心类是DoFHandler类：它建立在三角形和有限元类之上，并根据有限元对象所描述的有限元空间的要求在三角形的每个单元上分配自由度。DoFHandler类还有其他变体，如[2.x.1]，对更特殊的情况做类似的事情。
* DoFHandler对象与FiniteElement（或[2.x.2]中的[2.x.3]）类型的对象一起使用，以列举该特定有限元的三角结构中存在的所有自由度。因此，网格、有限元和DoF处理程序对象的组合可以被认为是提供了一个[1.x.0]的有限元空间：网格提供了定义基函数的位置；有限元描述了存在哪些种类的基函数；DoF处理程序对象提供了基的枚举，也就是说，它提供了空间的具体结构，因此我们可以通过系数向量来描述这个有限维空间的函数。
* DoFHandlers扩展了Triangulation对象（以及[2.x.4]网格模块中的其他类），因为它们也提供了迭代器，在所有单元格、面或其他构成三角形的几何对象上运行。这些迭代器是从三角形迭代器派生出来的，因此提供了同样的功能，但它们也提供了额外的功能。例如，它们允许查询与当前单元相关的自由度的索引。请注意，DoFHandler类来自Triangulation[1.x.1]，尽管它们使用Triangulation对象；原因是可以有一个以上的DoFHandler对象对同一个Triangulation对象工作。
* 除了DoF处理程序类之外，这个模块还拥有一些在应用程序中不常用的辅助类，以及三个与DoFHandler类的数据结构没有直接联系的类。其中第一个是AffineConstraints类，用于存储和处理与悬挂节点相关的约束。其次，DoFRenumbering命名空间提供了可以重新排序自由度的函数；在它的函数中，有在下游方向排序自由度的函数，例如，有以使相关矩阵的带宽最小化的方式排序自由度。最后，DoFTools命名空间提供了各种处理自由度的算法。
* 从总体上看，这个模块的各个部分与库的其他部分相互作用。


* [1.x.2]


* [0.x.1]

include/deal.II-translator/A-headers/exceptions_0.txt
[0.x.0]*



* [2.x.0]
* 该模块包含在deal.II的异常机制中使用的类。
* [1.x.0]
* 异常有两种不同的使用方式。  [2.x.1]
* [2.x.2] 静态断言。这些是只在调试模式下启用的检查，而不是在发布（或优化，生产）模式下。在deal.II中，静态断言通常用于检查函数的参数是否满足某些属性，内部数据结构是否一致，以及类似的断言。例如，静态断言用于确保两个相加的向量具有相同的组件数量
*
* - 其他的一切反正都没有任何意义。
* 这种检查是由[2.x.3]宏在库中的几千个地方进行的。另外，从[2.x.4]开始的几个教程程序显示了如何做到这一点。
* 如果一个静态断言被违反了，异常机制会产生一个异常类型，指出到底是什么出了问题，显示适当的信息，包括检测到问题的确切位置，然后中止程序
*
* - 如果你试图添加两个不同长度的向量，在程序中没有什么可以应对的情况，你必须去修正程序代码来代替。一般来说，甚至没有理由使用通常的C++异常机制来[2.x.5]一个异常对象，因为在这种情况下，更高一级的函数没有办法纠正这种情况，并以一种有用的方式处理它
*
* - 并不是程序收到了坏的数据；程序只是出现了错误，人们无法智能地解决这个问题。
* （有时将[2.x.6]宏的行为从中止程序改为抛出异常是很有用的。另一方面，异常不允许从类的析构器中传播出去。   为此，有一个叫做 [2.x.7] 的宏的变体，可以在析构器中使用。这些用例将在本页面下面进一步讨论)。
*

* [2.x.8] 动态断言。这些用于检查依赖于外部事物的条件，这些外部事物可能在一次程序运行中与下一次不同，例如，一个输出文件是否可以被写入。
* 这些是不应该被静态检查的东西，因为不能保证在调试模式下满足条件的程序，在随后的发布模式下也会满足该条件。
*
* - 换句话说，只在调试模式下检查这些情况是不够的。
* 相反，我们必须在程序的执行过程中每次都要检查这些情况。在deal.II中，这是用[2.x.10]、[2.x.11]和以下教程中介绍的[2.x.9]宏来完成的。该宏检查一个条件，如果违反了，就使用C++ [2.x.12]机制抛出一个本模块中声明的类型之一的异常。由于这些是运行时异常，这就给了程序捕捉异常的机会，例如，将输出写入一个可写文件。  [2.x.13]
*

* [1.x.1]
* <tt>deal.II</tt>中的错误处理机制通常以两种方式使用。  第一种是只在调试模式下使用错误检查，对没有经过全面测试的程序很有用。当程序不再显示错误时，可以关闭错误处理，并以此获得更好的性能，因为在库中对错误的检查是相当频繁的（典型的速度提升是4倍！）。这种异常生成模式对于内部一致性检查是最有用的，比如范围检查或函数参数的有效性检查。这种类型的错误通常是编程错误，程序终止时应该有尽可能详细的信息，包括异常产生的位置和原因。
* 第二种模式是用于错误检查，这种检查应该始终处于开启状态，比如I/O错误、内存请求失败等等。关掉这个模式没有什么意义，因为这种错误同样可能发生在经过测试和未经测试的程序中。这类异常不会终止程序，而是以<tt>C++</tt>的方式抛出异常，允许程序捕捉它们并最终做一些处理。由于在异常不能被正确处理的情况下，打印出一些信息可能是有用的，所以额外的信息会像第一种模式一样被传递。后者使得有必要提供一系列的宏，将这些额外的信息输入到异常类中；原则上，这可以由程序员自己每次手工完成，但由于这些信息可以自动获得，所以为此提供了一个宏。
* 这两种模式都使用异常类，除了<tt>C++</tt>标准的[2.x.14]类之外，它们还需要有特殊的功能。  这样的类是由以下几行代码声明的。
* [1.x.2]
*
* 这声明了一个名为<tt>ExcDomain</tt>的异常类，它有两个变量作为附加信息（默认命名为<tt>arg1</tt>和<tt>arg2</tt>），它输出给定的序列（它被附加到一个[2.x.15]变量的名称上，因此有奇怪的语法）。还有其他<tt>DeclExceptionN</tt>宏，用于有更多或没有参数的异常类。按照惯例，所有异常类的名字都是以<tt>Exc...</tt>开头的，而且大多数都是在本地声明的，以用于它要使用的类（少数非常频繁的异常也是在StandardExceptions命名空间中声明的，在任何地方都可以使用）。在全局范围内声明异常是可能的，但是会污染全局命名空间，可读性较差，而且大多数时候是不必要的。
* 由于异常类在两种错误检查模式下的声明方式相同，所以可以使用通过<tt>DeclExceptionN(...)</tt>宏系列声明的异常来进行静态和动态检查。
*

* [1.x.3]
* 要使用异常机制进行调试模式的错误检查，请在你的源代码中写下类似以下的行。
* [1.x.4]
* 通过宏扩展，它基本上做了以下工作（尽管实际的代码稍微复杂一些）。
* [1.x.5]
* 也就是说，只有当预处理器变量<tt>DEBUG</tt>被设置，并且违反了给定的条件（在这种情况下<tt>n < dim</tt>），它才会发出错误。
* 如果异常是用<tt>DeclException0 (...)</tt>宏来声明的，也就是说，没有任何附加参数，那么它的名字就必须用括号给出。  <tt>Assert (i>m, ExcSomewhat());</tt>
* [1.x.6]
* 如果设置了<tt>DEBUG</tt>预处理器指令，调用<tt>Assert (cond, exc);</tt>基本上会被预处理器转换为以下序列。
* [1.x.7]
*
* （注意，函数名称和确切的调用序列可能会随着时间的推移而改变，但一般原则是不变的）。也就是说，如果给定的条件被违反，那么发生异常的文件和行以及条件本身和异常对象的调用序列就会被传递给[2.x.16]函数。此外，一个由<tt>exc</tt>给出的对象被创建（这通常是一个未命名的对象，如<tt>ExcDomain(n, dim)</tt>类的<tt>ExcDomain</tt>）并被转移到这个函数。
* <tt>__PRETTY_FUNCTION__</tt>是一些编译器定义的宏，给出了函数的名称。如果使用的是另一个编译器，如果编译器为我们提供了这个函数，我们就尝试将其设置为合理的函数，否则就<tt>"（不可用）"</tt>。
* 在<tt>issue_error_noreturn</tt>中，通过调用set_fields()函数，将给定的数据转移到<tt>exc</tt>对象中；之后，程序要么被中止（关于异常的信息被打印到deallog），要么抛出异常。<tt>Assert</tt>宏做了第一条路径（打印和中止）；<tt>AssertThrow</tt>做了第二条（抛出）。这种行为与本文前面对静态和动态断言的描述是一致的。如果能从操作系统中获得，输出也可能包含堆栈跟踪，以显示错误发生的位置。[2.x.17]的几个程序显示了一个典型的输出。
* 如果预处理器变量<tt>DEBUG</tt>没有设置，那么<tt>Assert</tt>宏就会扩展为<tt>{}</tt>。
* 有时，除了程序流不应该到达某个点之外，没有其他有用的异常条件，例如，<tt>switch</tt>语句的<tt>default</tt>部分。在这种情况下，通过下面的结构引发异常。
* [1.x.8]
* 参见[2.x.18]和其他几个教程程序中对该结构的使用。
* 如上所述，一旦对<tt>Assert</tt>的调用失败，程序就会终止。然而，有一种情况我们不想这样做，即当一个C++异常被激活时。发生这种情况的通常情况是，有人通过<tt>AssertThrow</tt>机制抛出一个异常（见下文），在堆栈被解开的同时，导致堆栈框架上面的其他对象被破坏。如果其他对象引用了被销毁的对象，一些析构器会通过<tt>Assert</tt>引发一个异常。如果我们当时中止程序，我们只会看到一个对象被销毁的消息，而这个对象仍然被某个地方引用，但我们永远不会看到触发这个异常的原始异常。(你可以在调试器中通过在函数<tt>__throw</tt>上设置断点来看到它，但你不能从程序本身看到它。)在这种情况下，我们使用一个C++标准库函数来检测另一个活动异常的存在，并且不终止程序，以允许抛出的异常传播到某个可以显示其信息的地方。
* 由于一个失败的断言导致一连串的其他断言是很常见的，我们只打印第一个消息。如果程序被中止了，那就没有问题。如果不是这样（因为一个C++的异常是有效的），就只显示第一条，并显示一条关于被抑制的后续信息的信息。
*

* [1.x.9]
* C++有一种机制来表明发生了一些特殊情况：可以由<tt>throw</tt>语句触发的异常和由<tt>catch</tt>子句捕获的异常，例如见https://en.wikipedia.org/wiki/C%2B%2B#Exception_handling 和 http://www.cplusplus.com/doc/tutorial/exceptions/ 。
* 在一些基本的层面上，典型的C++异常是一个对象被放置在一些特殊的地方，然后函数通过一个特殊的返回路径退出当前的范围（例如，当前的函数）。  这往往足以说明是什么问题触发了异常，但更多的时候，如果能得到更多的信息就更好了：例如，问题发生在代码的哪一行，或者代码想写进稀疏矩阵的哪个不存在的条目。
* 因此，deal.II中的动态断言对这种机制进行了一些扩展。  通常情况下，人们会通过以下代码引发一个异常，例如
* [1.x.10]
* 然后用语句来捕获它
* [1.x.11]
* [2.x.19]是一个标准的<tt>C++</tt>类，为异常提供了基本的功能，比如虚拟函数<tt>what()</tt>，它返回异常本身的一些信息。如果一个异常不能被正确处理，这些信息是很有用的，在这种情况下，应该尽可能地打印出精确的描述。
* 这里的问题是，要想从<tt>what()</tt>中获得重要而有用的信息，就必须在我们的异常类中重载这个函数，并在异常类中调用带有额外参数的<tt>throw</tt>操作符。首先，重载<tt>what</tt>函数是使用<tt>DeclExceptionN</tt>宏来完成的，但是把正确的信息，也就是上面解释的<tt>Assert</tt>扩展，如果想每次都写下来，需要做一些工作。
* [1.x.12]
*
* 为此，我们发明了宏<tt>AssertThrow</tt>。它所做的工作主要与<tt>Assert</tt>宏相同，但它并不中止程序；相反，它抛出一个异常，如上所示。使用模式是
* [1.x.13]
*
* 要检查的条件被纳入宏中，以允许将被违反的条件作为一个字符串传递。<tt>AssertThrow</tt>宏的扩展不受<tt>DEBUG</tt>预处理器变量的影响。
*

* [1.x.14]
* 有一整个系列的<tt>DeclExceptionX</tt>宏，其中<tt>X</tt>将被附加参数的数量所取代（目前是0到5）。  这些宏被用来以如下方式声明异常类。
* [1.x.15]
* 第一个参数表示要创建的异常类的名称。  接下来的参数是参数的类型（这里有两种类型，与<tt>DeclExceptionX</tt>中的<tt>X</tt>相对应），最后是输出序列，你可以用它来打印附加信息。
* 输出序列的语法有点奇怪，但一旦你看到这个宏是如何定义的，就会明白了（同样是示意性的，实际的函数名称和定义可能会随着时间的推移而改变，并有所不同）。
* [1.x.16]
*
* 如果按照指定的方式声明，你以后就可以按照以下方式使用这个异常类。
* [1.x.17]
* 而如果条件失败的话，输出结果将是
* [1.x.18]
*
* 显然对于<tt>DeclException0(name)</tt>宏，不允许有任何类型，也不允许有任何输出序列。
*

* [1.x.19]
* [2.x.20]宏的默认实现，如上所述，将关于到底出了什么问题的详细信息打印到屏幕上，然后中止程序。终止程序是很有用的，因为它可以轻松地找到出错的地方
*
* - 包括我们如何到达那个地方的所有信息
*
* - 通过在调试器中运行该程序。
* 另一方面，在有些情况下，中止程序可能是不可取的，我们需要以一种更优雅的方式退出程序
*
* - 即使在这些情况下，我们真的没有什么可以做的，仍然可以产生一个有意义的结果。一个例子是，如果一个deal.II程序是在一个更大的软件框架中运行一个模块。例如，想想这样一种情况：deal.II程序计算的流场与一些优化程序提供的一组输入变量相对应：如果外部的优化器提供了一个负的密度作为输入（一个可能要通过[2.x.21]检查的条件，那么这显然是没有意义的，流解器不能产生一个有意义的答案；但它应该很好地告诉优化器，而不是直接中止整个过程（优化器和流解器）。
* 为此，我们可以调用[2.x.22]，将[2.x.23]所做的事情从中止程序转换为与[2.x.24]基本相同，即使用C++[2.x.25]机制来引发一个异常。然后这个异常可以在更高层次上被捕获
*
* 例如，在位于流解算器之上的优化例程中，然后可以决定它要对这种情况做什么。
* 这一切都很好，但是C++不允许在类的析构器中或在当前从调用栈中更高的析构器中调用的函数中抛出异常。为此，有一个单独的宏，[2.x.26]，可以在析构器中使用。它的作用就像[2.x.27]通常做的那样
*
* - 特别是，它只检查调试模式下的条件
*
* - 但它对[2.x.28]的影响是免疫的，它只会中止程序，而不会抛出异常。
*

* [2.x.29] Wolfgang Bangerth, 1998-2017年


* [0.x.1]

include/deal.II-translator/A-headers/fe_0.txt
[0.x.0]*



* [2.x.0]
* 所有与形状函数和对形状函数的访问有关的类。  这涉及到有限元的实际值。关于自由度的编号请参考 [2.x.1] 的模块。
* 本模块的类和函数分为几个子组，在上面列出的各自子模块中讨论。此外，FETools类提供了提供有限元素、元素间变换等信息的函数。
* 从总体上看，这个模块的各个部分与库中的各种其他部分相互作用。


* [1.x.0]


* [0.x.1]*



* [2.x.2]
* 这个子模块的成员描述了有限元类的实现机制，而没有实际实现一个具体的元素。例如，FiniteElement基类声明了派生类如果要描述一个有限元空间所必须实现的虚拟函数。同样地，FiniteElementData持有描述有限元特征的某些数值的变量，例如每个顶点、线或面的自由度数。
* 另一方面，像FE_Poly和FE_PolyTensor这样的类是高级抽象。它们描述了建立在单元格上的形状函数的多项式描述之上的有限元。从它们派生出来的类只需要提供一个特定的多项式的描述，而有限元就是从这个描述中建立的。例如，实现通常的拉格朗日元素的FE_Q类使用FE_Poly基类来生成有限元，为它提供一组拉格朗日插值多项式，对应于插值点的等距细分。
* 最后，FESystem类用于处理矢量值问题。在这里，人们可能想把一些标量（或者也是矢量值）基元耦合在一起，形成矢量值算子的联合有限元。例如，对于三维Navier-Stokes流动，人们可能希望用三个Q1元素来表示速度的三个分量，用一个片状常数Q0元素来表示压力。FESystem类可以用来将这四个基本元素组合成一个具有4个矢量分量的单一矢量值元素。[2.x.3]、[2.x.4]和[2.x.5]教程程序介绍了该类在矢量值弹性（Lam&eacute;）方程的使用。  [2.x.6]讨论了一个混合拉普拉斯离散化，也使用了矢量值元素。
*


* [2.x.7]


* [0.x.2]*



* [2.x.8]
* 本模块中的类在人们想要组装矩阵或矢量时使用。它们将有限元、正交对象和映射联系起来：有限元类描述单元格上的有限元空间（即单位线段、正方形或立方体<tt>[0,1]^d</tt>），正交类描述正交点的位置和它们的权重，映射类描述如何将一个点从单元格映射到实数单元并返回。由于积分发生在实单元上的正交点，需要知道它们的位置以及这些点的有限元形状函数的值和梯度。FEValues类可以协调获得这些信息。对于面的积分（例如边界上的积分，或者单元间的界面），FEFaceValues类提供了与FEValues类对单元类似的功能。最后，FESubfaceValues类提供了在面的一部分进行积分的可能性，如果相邻的单元被细化，并且目前的单元只与相邻的单元共享其面的一部分。如果使用矢量值元素，FEValues和相关的类允许访问所有的矢量组件；如果想挑选单个组件，有一些提取器类可以使这个任务更简单，如[2.x.9]模块中所述。
* 这一组的最后一个成员，UpdateFlags枚举，是作为一种优化使用的：与其让FEValues类计算与一个单元上给定的有限元有关的每一个可能的数据，你必须预先指定你真正感兴趣的信息。UpdateFlags枚举用于提供符号名称，表示您希望FEValues类计算的内容。
* 从[2.x.11]开始，所有这些类都在[2.x.10]的 "教程程序 "中使用，并且在那里有详细的描述。
* FEValues类和朋友们的实际工作很复杂，因为它必须是通用的，但又是有效的。[2.x.12]的页面试图对其工作原理做一个概述。
* 从总体上看，这个模块的各个部分与库的其他部分相互作用。


* [1.x.1]



* [2.x.13]


* [0.x.3]*



* [2.x.14]
* 这里的类描述了有限元空间，如最简单的Q1（双/三线）空间，以及高阶拉格朗日空间Qp，但也有更专业的空间，如Nedelec或Raviart-Thomas空间。具体的实现是由抽象的FiniteElement基类派生的。
* 本质上，这些类必须实现的函数提供了查询单元格上某一点的形状函数的值或导数的能力。为了在整合矩阵和右手条目中发挥作用，我们必须有能力将这些形状函数和梯度映射到实际单元中。这是由Mapping基类（见[2.x.15]）和FEValues类（见[2.x.16]）共同派生的类来完成的。
* [1.x.2]
* deal.II提供了两种不同类型的向量值元素。首先，有一组真正的矢量元素，通常通过以下事实来区分，即每个矢量分量由一组不同的各向异性多项式组成。这些元素通常与微分形式相关。目前，它们是
* [2.x.17] [2.x.18] FE_ABF [2.x.19] FE_BDM, FE_DGBDM [2.x.20] FE_Nedelec, FE_DGNedelec [2.x.21] FE_RaviartThomas, FE_DGRaviartThomas [2.x.22] 。
* 另外，deal.II提供了一种机制，可以从现有的标量或矢量元素中创建一个矢量元素。FESystem类负责这个工作：它本身并不描述形状函数，而是从其他有限元对象中组装一个矢量值的有限元。这个功能在[2.x.23], [2.x.24]和之后的其他教程程序中有所描述。
*

*
* [2.x.25] FE_PolyTensor类提供了对矢量值元素的实现支持。通常情况下，一个新的向量元素应该派生自这个类。
* [1.x.3]
* 对于每个符合任何弱可微函数空间的有限元，如[1.x.4]或[1.x.5]，我们可以通过简单地将顶点、边或面的所有自由度分配到单元的内部来定义一个类似的DG空间。这要从拓扑学的角度来理解。这种自由度的插值算子仍然会在边界上。  虽然没有这样做，但我们提供了很多这样的元素，加上那些没有符合要求的对应元素，比如FE_DGP。以下是当前DG元素的列表。  [2.x.26] [2.x.27] 标量。FE_DGP, FE_DGQ [2.x.28] 标量，不同的形状函数。FE_DGPMonomial, FE_DGPNonparametric, FE_DGQArbitraryNodes [2.x.29] 矢量值的。  FE_DGBDM, FE_DGNedelec, FE_DGRaviartThomas [2.x.30]
*

*
* [2.x.31] FE_DGVector类支持向量值DG元素的实现，其方式是只需要提供向量多项式空间。由此派生的实际类只需要实现一个构造函数和 [2.x.32] 。
*
* [2.x.33]


* [0.x.4]*



* [2.x.34]
* 本模块中的类用于从单位坐标映射到真实单元格的坐标。最常见的是，人们使用MappingQ1类，它提供了一个Q1（双线/三线）映射（即对通常的Q1元素来说是一个等价的映射）。然而，还有其他一些实现高阶映射的类，以提供曲线元素。这些在[2.x.35]和[2.x.36]的教程程序中讨论。
* MappingQ1Eulerian类是对MappingQ1类的扩展，它接受一个描述域的每个位置的位移场的向量。这在欧拉计算中使用，不需要在每个时间步长后实际移动顶点。
* 此外，MappingC1类提供了一个计算域的边界，这个边界不仅是弯曲的，而且在边界上两个单元之间的界面上有一个连续的导数。
* 最后，MappingCartesian类是对砖形且边缘与坐标轴平行的元素的优化。
* 从总体上看，这个模块的各个部分与库的其他各种部分相互作用。


* [1.x.6]



* [2.x.37]


* [0.x.5]

include/deal.II-translator/A-headers/fe_vs_mapping_vs_fevalues_0.txt
[0.x.0]*



* [2.x.0]
* [1.x.0]
* 大多数人只创建一次有限元（以及可能的映射）对象，但实际上从未调用过任何成员函数
*
* - 他们只是通过FEValues接口使用它们进行装配。大多数人唯一的其他互动是通过读取[2.x.1]变量，但这也只是在构造时设置的。换句话说，人们从来没有观察到FiniteElement或Mapping对象实际上是[1.x.1]的东西。
*
* - 而这完全是设计好的。
* 因此，本文档是为那些对编写有限元或映射类感兴趣，并想了解FEValues如何工作以及与FiniteElement和Mapping类互动的人准备的。在下文中，我们将不对FEValues（作用于单元）、FEFaceValues（作用于面）和FESubfaceValues（作用于单元的面的子女）进行区分，因为它们在概念上都是一样的。因此，在下面的文字中，"FEValues "这个术语将被普遍用于所有这三个类。
*

* [1.x.2]
* 在详细介绍数据和控制流之前，让我们定义哪个类负责提供什么样的信息。
* [1.x.3]
* FEValues是一个抽象的概念，它来自于这样的观察：人们在有限元代码中所做的几乎所有事情都只需要在正交点评估有限元的形状函数。例如，可以用正交[1.x.5]对[1.x.4]形式的积分进行逼近，但在想要生成图形输出时也同样有效：在那里我们只需要知道网格顶点的有限元场的值，这也可以写成在正交点评估一切
*
* - 这些正交点就是单元的顶点（例如由QTrapez提供）。
* FEValues的作用是为用户提供形状函数的值，以及它们的梯度，等等，在正交点。一些几何信息也是如此，例如，正交点的法向量。为此，它在FEValuesBase基类中提供了大量的成员函数，允许用户查询有关形状函数和几何信息的所有信息，但仅限于FEValues对象被初始化的正交点。
* FEValues本身并不实际计算这些信息。它实际上只是提供了一个存储信息的地方，然后协调映射和有限元类之间的互动，让它们计算所要求的信息并将结果存储在FEValues提供的位置。
* 最后，请记住，FEValues可以提供一系列令人难以置信的信息，但几乎所有的信息在任何情况下都是不必要的。例如，为了计算上述积分，不需要知道形状函数的二阶导数，也不需要知道正交点的法向量。为此，FEValues在与Mapping和FiniteElement类的交互中使用UpdateFlags来确定实际需要计算的内容。这在 [2.x.2] 中有稍微详细的讨论。
*

* [1.x.6]
* 映射（即从映射基类派生的类）负责与从参考（单位）单元 [2.x.3] 到每个实际单元 [2.x.4] 的映射有关的一切。这是由一个映射函数[2.x.5]促成的。因此，映射类实现了一些接口，允许评估 [2.x.6] 从参考单元向前映射点 [2.x.7] 到 [2.x.8] ，并使用 [2.x.9] 从实际单元向后映射到参考单元。映射提供的其他常见操作是将向量（你可以认为是连接到参考单元上的点[2.x.10]并指向某些方向的向量）映射到真实单元上的等效向量。例如，这就是我们需要对形状函数的梯度所做的工作：这些是定义在参考单元上的向量，我们需要将这些梯度映射到实数单元上 [2.x.11] 。类似的操作也可以为矩阵（等级为2的张量，而不是等级为1的向量）和高阶张量定义。
* 许多这样的映射不仅需要映射[2.x.12]本身，还需要这个映射的梯度，通常被称为雅各布[2.x.13]，以及高阶导数。
* 由于FEValues只需要在正交点评估这些东西，所以映射一般不需要提供在[1.x.7]点评估的能力。相反，正如我们将在下面看到的，它们将被初始化为使用在参考单元上定义的一组正交点，然后为一个特定的单元 "重新初始化"，然后所有进一步的操作将只需要在真实单元上的这些正交点评估[2.x.14]。
* 映射类具有双重作用：(i)计算几何信息（如法向量、雅各布定理等），并将其放入数据结构中，FEValues可以将其提供给用户；(ii)提供有限元所需的支持，将形状函数及其导数从参考单元映射到实际单元。
*

* [1.x.8]
* 有限元类（即从FiniteElement派生的类）负责在参考单元上定义其形状函数、导数和许多其他方面，但也负责在实际单元上计算映射值和导数（显然是在映射对象的帮助下）。在目前的讨论中，只有后一个角色是重要的。
* 与映射一样，这里对我们来说重要的是有限元类可以在给定的正交点上提供这些信息，并且它们可以将计算的信息放入FEValues提供的结构中，然后FEValues的成员函数可以通过FEValuesBase中的成员函数将其传递给用户。
*

* [1.x.9]
* 假设用户想要计算形状函数的梯度，比如说计算上面的积分。然后他们会通过给出update_gradients标志来初始化一个FEValues对象（从[2.x.15]开始，基本上每个教程程序都会这样做）。这表明用户希望FEValues对象能够提供真实单元上形状函数的梯度，但没有表示希望得到任何其他信息。
* 然后，FEValues将首先找出映射对象和有限元对象之间的实际需求，以实现这一目标。这在运行FEValues构造函数时已经发生了。因为映射不依赖于有限元（尽管后者依赖于前者），FEValues首先通过[2.x.16]询问有限元需要哪些[1.x.10]的信息来实现用户的请求。例如，如果有限元是FE_Q类型，那么它将确定为了计算实单元[2.x.17]上形状函数的梯度，它需要计算参考单元上形状函数的梯度（这是它自己可以做到的，不需要任何外部帮助），但是这些参考梯度必须在每个正交点上乘以映射的雅各布系数的逆值[2.x.18]。这个乘法通常被称为[1.x.11]，因此FE_Q的[2.x.19]函数的实现（在中间类FE_Poly中提供）将同时返回原始的update_gradients标志以及update_covariant_transformation。
* 在第二步中，FEValues对象将调用映射中的相应函数，[2.x.20]以确定提供update_gradients和update_covariant_transformation的要求。前者不在映射的范围内，所以被忽略了。后者通常需要先计算雅各布矩阵[2.x.21]，一个典型的映射类将通过在列表中添加 update_contravariant_transformation 来表示。
*

* [1.x.12]
* 此时，FEValues对象已经找出了一套完整的标志，表明大家要计算什么来满足用户的要求。下一步，仍然是在构建FEValues对象的过程中，源于这样的认识：许多东西可以预先计算一次，然后在我们每次移动到一个真正的单元时重复使用。一个例子是，为了计算真实单元上形状函数的梯度，我们需要知道参考单元上形状函数的梯度（在参考单元上的正交点），而且这些梯度总是相同的：每次我们访问一个新单元时，这些值都会保持不变，所以每次都重新计算它们是低效的。对于一些映射类所计算的一些信息也可以提出类似的论点。
* 因此，FEValues对象同时初始化了映射和它所指向的有限元对象，使用正交对象和上一节所述的最后一组更新标志来计算。这个初始化包括预先计算这些类在给定更新标志集后可以预先计算的内容，然后存储这些信息供以后使用。
* 然后问题来了：在哪里存储这些信息。在实践中，我们不希望将这些信息存储在映射或有限元对象本身，因为这意味着（i）一次只能有一个FEValues对象使用任何给定的映射或有限元对象，以及（ii）这些对象不能在多线程环境下使用。
* 相反，该方法是这样的。
*



* - FEValues调用[2.x.22]（以及FEFaceValues调用[2.x.23]和FESubfaceValues调用[2.x.24]，带有正交对象和最后一组更新标志。从Mapping派生出来的类中的这些函数的实现将分配一个从[2.x.25]派生出来的类型的对象，在那里他们基本上可以存储他们认为有用的任何东西，以便以后重新使用。  [2.x.26]本身实际上并没有提供任何重要的成员变量，但真正留给派生类的是他们认为在这个时候他们可以有效地预先计算和存储的东西。如果一个映射没有什么需要预先计算的（或者映射类的作者很懒，不想考虑什么可能被预先计算），那么这样的类将简单地从[2.x.27]中派生出它自己的InternalData对象，而没有实际添加任何成员变量。
* 这样产生的对象就会被返回到FEValues中的调用站点，并由FEValues对象存储。以后每当FEValues对象想要从映射中获得任何信息时，它都会被交还，从而为映射对象提供了读取其先前存储的数据的能力。
*


*
* - 其次，FEValues也调用[2.x.28]（FEFaceValues调用[2.x.29]，FESubfaceValues调用[2.x.30]，再次调用正交对象和最后一组更新标志。这些函数的作用与它们在映射中的对应函数基本相同，而且这样初始化的对象，这次是源自[2.x.31]的类型，每当FEValues对象在以后的时间里想要从有限元对象那里得到一些东西时，总是会被反馈给有限元。
* 这种方法允许我们同时从多个FEValues对象中使用有限元和映射对象，也可能同时从多个线程中使用。重点是，有限元或映射对象的每个用户都会持有他们自己的、唯一的、从[2.x.32]函数返回的对象，而且所有发生的事情都发生在这些对象上，而不是映射或有限元对象本身的成员变量上。
*

* [1.x.13]
* 之前的所有步骤都发生在创建FEValues对象的时候。到此为止，我们所做的都是设置数据结构，但从用户的角度来看，到目前为止还没有计算出任何有用的东西。这只发生在 [2.x.33] 在具体单元格上被调用时 [2.x.34] 。
* 然后FEValues所做的事情是，按照这个顺序。
*


*
* - FEValues计算出该单元是否是调用了[2.x.35]的前一个单元的平移或其他类似的简单转换。这个结果存储在[2.x.36]对象中，然后将被传递给映射和有限元，以潜在地简化一些计算。例如，如果当前单元只是前一个单元的平移，那么就不需要重新计算映射的雅各布矩阵[2.x.37]（或其逆），因为它将与前一个单元相同。
*


*
* - 接下来，[2.x.38]调用[2.x.39]（显然，FEFaceValues调用[2.x.40]，FESSubfaceValues调用[2.x.41] 这个函数的参数包括我们被要求访问的单元格（或面，或子面），以及上面的单元格相似性参数，对我们之前从[2.x.42]获得的对象的引用，以及对[2.x.43]类型的对象的引用，映射应该把它的结果写入其中。特别是，它需要计算之前由更新标志指定的所有映射相关信息，然后将它们写进输出对象。   在输出对象中，映射需要填充的字段的例子是JxW值的计算、雅各布矩阵及其反值的计算，以及单元格（如果dim小于spacedim）和面的法向量。
*


*
* - 最后，[2.x.44]调用[2.x.45]（显然，FEFaceValues调用[2.x.46]，FESSubfaceValues调用[2.x.47] 这个函数的参数包括我们被要求访问的单元格（或面，或子面），以及上面的单元格相似性参数，对我们之前从[2.x.48]获得的对象的引用，以及对[2.x.49]类型的对象的引用，映射应该将其结果写入其中。
* 除了这些，[2.x.50]函数还接收对正在使用的映射对象的引用，以及我们之前从[2.x.52]中收到的[2.x.51]对象。原因是，通常，有限元希望将形状函数的值或梯度从参考单元映射到实际单元，而这些映射由各种[2.x.53]函数提供便利
*
* - 这都需要对FEValues对象先前从映射中获得的内部对象的引用。这可能最好是通过查看实际代码来理解，在[2.x.54]中可以找到一个简单而有启发性的例子，该函数适用于一般标量、多项式有限元基。
* 与映射一样，[2.x.55]函数然后使用它们之前在构建FEValues对象时计算的任何信息（即当它调用[2.x.56]时，使用这个和映射中的函数来计算更新标志所指定的任何请求。
* 这一切完成后，我们终于可以向FEValues的所有者提供对最初通过更新标志要求的字段的访问。
*


* [2.x.57]


* [0.x.1]

include/deal.II-translator/A-headers/functions_0.txt
[0.x.0]*



* [2.x.0]
* 函数在deal.II中被用于不同的地方，例如用来描述边界条件、方程中的系数、强制项或精确解。由于方程的封闭式表达式通常很难作为函数参数传递，deal.II使用函数基类来描述这些对象。基本上，这个基类的接口要求派生类实现返回一个或一列特定位置的函数值的能力，以及可能的（如果需要）函数的梯度或二次导数。有了这个，函数对象就可以被像[2.x.1][2.x.2]这样的算法和其他函数所使用。
* 有些函数是反复需要的，因此已经在deal.II中提供。这包括一个具有常数值的函数；一个在任何地方都为零的函数，或者一个只有一个向量分量具有特定值而所有其他分量为零的向量值函数。在函数命名空间中还定义了一些更专门的函数。
*

* [1.x.0]
* 对于时间相关的计算，边界条件和/或右手边的函数也可能随时间变化。由于在一个给定的时间步长，人们通常只对函数的空间依赖性感兴趣，如果必须向所有使用函数对象的方法传递一个时间变量的值，那就很尴尬了。例如，[2.x.3]函数将不得不接受一个时间参数，当它想查询边界函数在特定时间步长的值时，它可以使用这个参数。然而，如果我们考虑的是一个静止的问题，它也必须这样做，因为在这个问题上没有类似时间变量的东西。
* 为了规避这个问题，函数对象总是只被认为是空间函数。然而，Function类是由FunctionTime基类派生出来的，如果有必要的话，它可以存储一个时间变量的值。这样，人们可以定义一个作为空间函数的函数对象，但在内部可以通过引用一个特定的时间来实现。在上面的例子中，在把函数对象交给[2.x.4]方法之前，人们会把它的时间设置为现在的时间步长。
*

* [1.x.1]
* 函数类是最常用的，但有时人们需要一个函数，其值是张量，而不是标量。TensorFunction模板可以为你做到这一点。除了返回类型外，该接口与函数类的接口基本相同。


* [0.x.1]

include/deal.II-translator/A-headers/geodynamics_0.txt
[0.x.0]*
* [2.x.0]
* deal.II的[2.x.1]"教程 "包含一组程序，它们共同构成了地球动力学示范套件。这些程序的想法是利用地球动力学的应用来演示高级有限元软件的技术，也就是对固体地球过程的研究。通过这样做，这些程序应该为解决实际地球动力学问题的更专业的专用程序提供一个基础，例如作为研究生或博士后工作的一部分。下面将对这些计划的动机进行更深入的讨论。
* 目前，地球动力学测试套件包含以下程序。

* - [2.x.2] : 弹性
*
* - [2.x.3] : 一个%平行弹性求解器
*
* - [2.x.4] : 多孔介质流
*
* - [2.x.5] : 通过多孔介质的多相流动
*
* - [2.x.6] :斯托克斯流
*
* - [2.x.7] : 热对流（Boussinesq流动

* - [2.x.8] ：用于地幔对流的%平行布西尼克解算器
* 其中一些程序是根据加州理工学院的合同开发的，得到了美国国家科学基金会EAR-0426271号奖的支持，这是资助[1.x.0]计划的第一笔拨款。接受者Wolfgang Bangerth对这一支持来源表示衷心感谢。
*

* [1.x.1]
* 自适应网格细化（AMR）长期以来一直被认为是一项关键技术，它可以帮助精确和有效地解决一些地球动力学应用的数值问题。它在地球动力学界已经讨论了好几年，并且自CIG成立以来一直是其任务清单上的一个议题。然而，到目前为止，在这个方向上发生的事情还比较少。直到最近，才有了在地球动力学中使用AMR的尝试。CIG于2007年10月在Boulder举办了一次关于AMR技术的研讨会；George Biros、Omar Ghattas、Mike Gurnis和ShijieZhong小组之间的合作目前正在开发一个%并行的自适应地幔对流处理器；deal.II的一些主要开发者最终开发了用于模拟地幔对流的[1.x.2]，现在已经是相当成熟和广泛使用的代码。
* AMR技术在地球动力学中应用缓慢的原因之一是最初的障碍比较大：代码必须提供数据结构和算法来处理自适应网格，有限元必须能够处理悬挂节点，等等。要做到这一点，在足够的通用性下，有限元程序要增加几万行代码，对于普通学生来说，在学位论文的时间范围内是无法做到的。另一方面，有一些库提供了基础代码，支持AMR的应用可以在此基础上迅速建立。当然，deal.II正是提供了这种基础。
* 地球动力学测试套件的目标是为与地球动力学相关的各种主题编写程序。继续保持现有教程程序的风格
*
* - 一个广泛的介绍，解释一个应用的背景和形式，以及在其解决方案中使用的数值方案的概念；整个代码中的详细评论，解释实施细节；以及一个显示数值结果的部分
*
* - 我们打算将所产生的程序作为解决模型问题的有据可查的应用程序来提供。特别是，它们旨在实现以下目标。[2.x.9] [2.x.10] [1.x.3] 现有的deal.II教程已被证明是一个很好的起点，可供研究生和研究人员快速开发自己的应用程序。通过提供已经接近目标应用的程序，通常可以很快获得第一个结果，既保持了开发过程中最初的热情，也允许将研究时间用于实现特定的应用行为，而不是将几个月的工作用于支持AMR的基本基础代码。
* 支持这一观点的事实是，尽管有[1.x.4]介绍了用deal.II获得的结果，但我们知道只有相对较少的应用是用deal.II从头开始建立的；所有其他的应用都是从某个教程程序的修改开始的。
* [2.x.11] [1.x.5] 我们建议编写的教程程序将为学生和研究人员提供当前数值技术的参考实现，如AMR、高阶元素、复杂的线性和非线性求解器、稳定技术等。提供这些作为其他人进一步开发的起点，也将有助于实现在现代数值算法方面培训新一代地球动力学家的目标。
* [2.x.12] [1.x.6] 在deal.II中，用另一个方程扩展一组方程是相当简单的，例如，一个额外的平流量作为右手边或在一个系数中进入现有方程。由于应用通常使用封锁的矩阵，而不是用一个大矩阵代替所有东西的方法，所以为增强方程找到合适的线性求解器也不复杂。因此，deal.II是一个很好的工具，可以尝试更复杂的问题公式，或更完整的模型及其对解的准确性的影响。
* [2.x.13] [1.x.7] deal.II提供了许多可互换的组件，允许快速建立有限元种类和顺序、稳定技术或线性求解器的原型。例如，通常只需要改变几行代码就可以用高阶元素取代低阶元素。通过这种方式，尝试高阶元素、不同的块消除求解器或不同的稳定技术变得相对简单。反过来，这可能有助于在计算求解时间和数值解的准确性方面对应用进行基准测试。
* 本模块中的应用将已经过正确性的基准测试。现有的教程程序通常采用更简单而不是更复杂的求解器方案进行阐述，但经常建议采用更复杂的方案，包括在附录中提示如何实现这些方案。
* [2.x.14] [1.x.8] deal.II的快速原型能力也可能有助于在deal.II适用的程序规模上确定最佳算法，然后在可以在更大规模的机器上运行的专用程序中实现这种特定的算法（没有能力轻易改变它）。例如，一个建立在deal.II上的小型地幔对流代码可以用来确定二阶元素是否对这个目的有用（例如，见[2.x.15]中所示的结果）。如果是这样，那么人们就可以在更大的代码中使用这种知识，比如上面提到的ASPECT代码。[2.x.16]
*


* [0.x.1]

include/deal.II-translator/A-headers/geometry_and_primitives_0.txt
[0.x.0]*



* [2.x.0]
* 本组包含一些作为几何基元或其他数学对象的基元的类。例如，Tensor [2.x.1] 类提供了等级为[2.x.2]的空间维度的张量。同样地，SymmetricTensor提供了对称的张量。
* 在几何学上，点类是deal.II库中所有几何描述的基础。它表示[2.x.3]维空间中的一个几何点。我们可以把一个点看作是一个坐标为[2.x.4]的矢量，它连接着原点和那个特定的点；因此，点类是从秩1的张量（即矢量）派生出来的，但与任意张量相比，点具有空间中点的特殊内涵，因此具有一些额外的属性。
* 在deal.II中，网格是由线段、四边形或六面体（取决于空间维度）构建的。GeometryInfo类用于描述这些基本对象在单位空间中的属性（即对于单位线、单位方和单位立方）。它提供了静态数据成员，表示每个单元的顶点数量、每个面的线，或者顶点的位置。这种抽象允许编写的应用程序大多独立于实际的空间维度：所有顶点的循环只是从0到[2.x.5]，而不是从0到4（在2D）或0到8（在3D）。这样一来，程序在2D和3D中都是正确的，人们可以通过重新编译在不同的空间维度上运行程序，而不必改变代码的很大一部分。这些与维度无关的编程技术在前几个教程程序中得到了广泛的讨论，并在整个交易中得到应用。


* [0.x.1]

include/deal.II-translator/A-headers/global_dof_index_0.txt
[0.x.0]*
  [2.x.0]
* deal.II可以被配置为使用64位的自由度指数，而不是通常的无符号整数，在目前大多数系统上默认为32位。这是必要的，因为我们希望能够解决超过40亿个未知数的问题（32位无符号整数所能表示的极限）。同时，我们不想不分青红皂白地将deal.II中的所有整数替换成64位版本，因为这将增加许多地方的内存使用，我们在这些地方表示的数量肯定不会超过40亿。
* 我们为这些指数定义的数据类型是[2.x.1]，以保持代码库的大部分不受[2.x.2]的影响。如果deal.II被正常配置，这种类型是[2.x.3]，但如果提供正确的标志，可以切换到[2.x.4]（见ReadMe文件）。本页旨在澄清何时必须使用[2.x.5]，何时可以使用普通无符号整数。
* [2.x.6]
* <dt class="glossary"> [2.x.7] GlobalDoFIndexBlockIndices [1.x.0]</dt> [2.x.8] 块的数量是一个无符号的int，因为这个数字预计会很低，即小于四亿。然而，块的大小是一个[2.x.9]，因为每个块可以是任意的大。  [2.x.10]
* <dt class=" glossary"> [2.x.11] GlobalDoFIndexCell [1.x.1]</dt> [2.x.12] 单元的ID是不唯一的。不同细化程度的单元和/或不同处理器上的单元可以有相同的ID。因此，所有与单元相关的数据都可以是无符号的int，因为在一个处理器上，一个网格级别，肯定不会有超过40亿的单元。  [2.x.13]
* <dt class=" glossary"> [2.x.14] GlobalDoFIndexDoFHandler [1.x.2]</dt> [2.x.15] 每个自由度的ID在并行计算中是唯一的。因此，自由度是 [2.x.16] [2.x.17] 。
* <dt class=" glossary"> [2.x.18] GlobalDoFIndexFullMatrix [1.x.3]</dt> [2.x.19] 行和列的数量是[2.x.20]，即使不期望有人会创建一个有这么多条目的FullMatrix。然而，AffineConstraints类的一些方法是以矩阵类型为模板的，因此，FullMatrix的大小必须与SparseMatrix的大小为同一类型。  [2.x.21]
* <dt class=" glossary"> [2.x.22] GlobalDoFIndexSparseMatrix [1.x.4]</dt> [2.x.23] SparseMatrix的大小可以是任意大的，可以想象，在单个节点上有足够的内存，可以生成一个超过40亿行或列的矩阵。因此，采用了[2.x.24]。然而，即使对于我们现在可以解决的大型复杂问题，期望稀疏矩阵中的非零条目数超过40亿是不合理的。因此，我们仍然使用无符号int，例如，[2.x.25]和类似的函数。  [2.x.26]
* [2.x.27]


* [0.x.1]

include/deal.II-translator/A-headers/glossary_0.txt
[0.x.0]*
  [2.x.0]
* 本词汇表解释了一些在deal.II的类文件中经常使用的术语。词汇表通常只给出了一个特定概念的微观观点；如果你对大局感到困惑，那么也值得参考[2.x.1]页上的类的总体概述。
* [2.x.2]
* <dt class="glossary"> [2.x.3] GlossActive [1.x.0]</dt> [2.x.4] 如果一个单元格、面或边没有被进一步细化，即没有子代，那么它被定义为[1.x.1]。一旦一个单元、面或边成为父级，它就不再活跃。除非使用多网格算法，否则活动单元是唯一携带自由度的单元。  [2.x.5]


*
* <dt class="glossary"> [2.x.6] GlossArtificialCell [1.x.2]</dt> [2.x.7] 如果一个网格使用[2.x.8]类分布在多个MPI进程中，每个处理器只存储自己拥有的单元，其他处理器拥有的一层相邻的单元（称为[2.x.9] "幽灵单元"），所有粗粒度的单元，以及所有为维持相邻单元必须最多有一个细化级别这一不变量所需的单元。存储在每个进程上的不属于该进程且不属于幽灵单元的单元被称为 "人工单元"，对于这些单元，谓词[2.x.10]返回真。人工单元被保证存在于全局分布的网格中，但它们可能在其他处理器上被进一步细化。更多信息请参见[2.x.11] "分布式计算论文"。
* 人工单元的概念对于在每个处理器上存储整个网格的三角计算没有意义，即[2.x.12] 类。  [2.x.13]
*

* <dt class=" glossary"> [2.x.14] GlossBlockLA [1.x.3]</dt>。
* [2.x.15] 将一个矩阵或向量作为单个块的集合来处理往往很方便。例如，在[2.x.16]（和其他教程程序）中，我们要考虑全局线性系统[2.x.17]的形式[1.x.4] 。
* 其中[2.x.18]分别是速度和压力自由度的值，[2.x.19]是速度空间上的质量矩阵，[2.x.20]对应于负发散算子，[2.x.21]是其转置，对应于负梯度。
* 使用这种分解为块的方法，人们可以定义基于方程组中存在的单个算子（例如，在[2.x.22]的情况下，Schur补码）的预处理程序，而不是整个矩阵。实质上，块被用来反映线性代数中PDE系统的结构，特别是允许对具有多个解决方案组件的问题进行模块化求解。另一方面，矩阵和右手边的向量也可以作为一个单元来处理，这在线性系统的装配过程中是很方便的，例如，当人们可能不想对各个组件进行区分时，或者对于不关心块结构的外Krylov空间求解器（例如，如果只有预处理程序需要块结构）。
* 将矩阵和向量分割成块是由BlockSparseMatrix、BlockVector和相关类支持的。参见[2.x.23]模块中对各种线性代数类的概述。这些对象呈现出两个接口：一个使对象看起来像一个具有全局索引操作的矩阵或向量，另一个使对象看起来像一个可以被单独处理的子块的集合。根据上下文，人们可能希望使用一个或另一个接口。
* 通常，人们通过将构成物理量组的自由度（例如所有速度）归入线性系统的各个块来定义矩阵或向量的子结构。这在下面关于[2.x.24]"块（有限元）"的词汇条中有更详细的定义。  [2.x.25]
*

* <dt class="glossary"> [2.x.26] GlossBlock [1.x.5]</dt> [2.x.27] [1.x.6] 块是[2.x.28] "组件 "的概括，它们将人们希望共同考虑的矢量值有限元的一个或多个组件组合在一起。人们经常想这样做，以定义与作用于向量值解的微分算子（部分）结构相对应的算子，如[2.x.29]中的Schur补充求解器，或[2.x.30]的块状求解器和预处理器。
* 对于离散化的目的，块是更好的概念，因为并不总是能够解决一个解决方案的各个组成部分。特别是对于非[2.x.31]GlossPrimitive的 "原始 "元素来说，就是这种情况。以使用FE_RaviartThomas元素的混合拉普拉斯系统的解为例（见[2.x.32]）。在那里，第一个<tt>dim</tt>分量是方向性速度。由于形状函数是这些的线性组合，这些<tt>dim</tt>分量只构成一个单一的块。另一方面，压力变量是标量，将构成第二个块，但在<tt>dim+1</tt>st分量中。
* 每个块的最小尺寸由底层有限元决定（对于标量元素，一个块由一个分量组成，但以FE_RaviartThomas为例，一个块由<tt>dim</tt>分量组成）。然而，几个这样的最小块可以随意组合成用户定义的块，并根据应用情况进行组合。例如，对于[1.x.7]<sub>2</sub><sup>[1.x.8]</sup>-[1.x.9]<sub>1</sub>（Taylor-Hood）Stokes元素，有[1.x.10]+1个组件，原则上每个组件可以形成自己的块。但我们通常更感兴趣的是只有两个块，其中一个由所有的速度矢量分量组成（即这个块将有[1.x.11]分量），另一个只有一个压力分量。
* [1.x.12] deal.II有许多不同的有限元类，它们都是从FiniteElement基类派生出来的（见[2.x.33] "有限元类模块"）。除了一个例外，无论它们是标量还是矢量值，它们都定义了一个单一的块：有限元通过其[2.x.34]函数定义的所有矢量分量构成一个单一的块，即[2.x.35]返回一个。
* 例外的是FESystem类，它采取多个较简单的元素，并将它们连接成较复杂的元素。因此，它可以有一个以上的块。一个FESystem有多少个块，就有多少个基础元素乘以它们的倍数（参见FESystem的构造函数来理解这个说法）。换句话说，它并不关心每个基础元素有多少个块，因此，你可以通过创建对象产生一个只有两个块的斯托克斯元素


* [1.x.13]
* 另一方面，我们可以用dim+1块产生一个类似的对象，使用


* [1.x.14]
* 除了块的数量外，这两个对象在所有实际用途上都是一样的，但是。
* [1.x.15] 虽然我们在上面用矢量值解函数的矢量分量（或者，等同于用矢量值有限元空间）来定义块，但有限元的每个形状函数都是一个或另一个块的一部分。因此，我们可以将定义在DoFHandler上的所有自由度划分为各个块。由于默认情况下DoFHandler类以一种或多或少的随机方式列举自由度，你首先要调用[2.x.36]函数以确保所有对应于单个块的自由度被连续列举。
* 如果你这样做，你自然也会将矩阵和向量划分为块（见[2.x.37]"块（线性代数）"）。  在大多数情况下，当你将矩阵或向量细分为块时，你的做法是为有限元（即在大多数实际情况下，FESystem对象）定义的每个块创建一个块。然而，不必如此：[2.x.38]函数允许将几个向量分量或有限元块归入同一个逻辑块（例如，见[2.x.39]" [2.x.40]"或[2.x.41]教程程序，而不是[2.x.42]）。因此，利用这一特性，我们可以实现同样的结果，即把矩阵细分为[2.x.43]块，把向量细分为2块，对于上述创建斯托克斯元素的第二种方式，使用一个额外的参数，就像我们使用第一种创建有两个块的斯托克斯元素的方式一样，马上就能实现。
* 关于这个主题的更多信息可以在FESystem的文档中找到，[2.x.44]模块和其中参考的教程程序。
* [1.x.16] 许多函数允许你将其操作限制在某些矢量分量或块上。例如，插值边界值的函数就是这种情况：人们可能只想插值有限元场的速度块的边界值，而不想插值压力块。这样做的方法是给这类函数传递一个BlockMask参数，见[2.x.45]"本词汇表的block mask条目"。  [2.x.46]
*

* <dt class="glossary"> [2.x.47] GlossBlockMask [1.x.17]</dt
* [2.x.48] 就像人们可以认为元素是由物理矢量分量（见[2.x.49]）或逻辑块（见[2.x.50]）组成的一样，经常需要为不打算在有限元空间的[1.x.18]块上运行的操作选择一组此类块。使用BlockMask类来选择要操作的块。
* 块掩码的工作方式与构件掩码基本相同，包括BlockMask类与ComponentMask类有类似的语义。参见[2.x.51]"关于组件掩码的词汇表条目 "以获得更多信息。
*

*
* [2.x.52] 虽然组件和块为具有多个向量分量的有限元提供了两种交替但同样有效的观点，但事实上，在整个库中，你可以传递ComponentMask参数而不是BlockMask参数的地方要多得多。幸运的是，一个可以转换为另一个，使用的语法[2.x.53]是BlockMask类型的一个变量。换句话说，如果你有一个块掩码，但需要调用一个只接受组件掩码的函数，可以用这种语法来获得必要的组件掩码。
* [1.x.19] 块掩码通常是通过要求有限元从某些选定的矢量分量中生成块掩码来创建的，使用这样的代码，我们创建的掩码只表示斯托克斯元的速度分量（见[2.x.54] ）。


* [1.x.20]
* 结果是一个区块掩码，在1d以及2d和3d中，其值为[2.x.55] 。同样地，使用


* [1.x.21]
*在任何维度上都会产生一个掩码[2.x.56]。
* 然而，请注意，如果我们以下列方式定义有限元。


* [1.x.22]
*那么代码


* [1.x.23]
*将产生一个块掩码，在2d中具有元素[2.x.57]，因为该元素具有[2.x.58]成分和同样多的块。参见[2.x.59]"本词汇表的块条目 "中关于块具体代表什么的讨论。  [2.x.60]
*

* <dt class="glossary"> [2.x.61] GlossBoundaryForm [1.x.24]</dt
* [2.x.62] 对于二维空间中的二维三角，边界形式是一个定义在面的向量。它是单元格表面上坐标向量的图像的向量乘积。它是一个对表面的法线矢量，指向外侧，具有表面元素的长度。
* 一个更普遍的定义是（至少到这个矢量的长度为止），它正是考虑分项积分时必须的那个矢量，即形式为[2.x.63]的等式。使用这个定义也解释了在嵌入空间[2.x.65]的维数[2.x.64]的域（和相应的三角形）的情况下，这个向量应该是什么：在这种情况下，边界形式仍然是一个定义在三角形面上的向量；它与边界的所有切线方向正交，并且在域的切线平面内。请注意，这与情况[2.x.66]是兼容的，因为那里的切平面是整个空间[2.x.67] 。
* 在任何一种情况下，矢量的长度都等于参考面到当前单元面的变换行列式。  [2.x.68]


* <dt class=" glossary"> [2.x.69] GlossBoundaryIndicator [1.x.25]</dt>。
* [2.x.70] 在Triangulation对象中，边界的每一部分都可以与一个唯一的数字（类型为[2.x.71]，用于确定哪种边界条件将被应用到边界的特定部分。边界是由单元格的面组成的，在三维中，是这些面的边缘。
* 默认情况下，一个网格的所有边界指标都是零，除非你从一个网格文件中读取，并特别将其设置为不同的内容，或者你使用了命名空间GridGenerator中的一个网格生成函数，该函数有一个[2.x.72]"着色 "选项。一个典型的将部分边界指示器设置为其他东西的代码会是这样的，这里将所有位于 [2.x.73] 的面的边界指示器设置为42。


* [1.x.26]
* 这调用了函数[2.x.74] 在3D中，可能也适合调用[2.x.75]来代替每个选定的面。要查询某个特定面或边的边界指标，请使用[2.x.76]。
* DoFTools和VectorTools命名空间中的许多函数都需要参数来指定边界的哪一部分，而且它们特别提到了boundary_ids。例如[2.x.77] [2.x.78] [2.x.79] 和 [2.x.80] [2.x.81] 。
*

*
* [2.x.82] 边界指标在网格细化时从母面和边继承到子面。关于边界指示器的更多信息，也在三角形类的文档中的一个部分介绍。
*

*
* [2.x.83] 对于[2.x.84]类型的平行三角形，仅在开始时设置一次边界指标是不够的。参见[2.x.85]的类文件中关于这个主题的长篇讨论。  [2.x.86]
*

* <dt class="glossary"> [2.x.87] GlossCoarseMesh [1.x.27]</dt> [2.x.88] deal.II中的 "粗网格 "是一个三角形对象，它只由未被细化的单元组成，也就是说，在这个网格中没有单元是另一个单元的孩子。这通常是deal.II中最初构建三角形的方式，例如，使用命名空间GridGenerator中的（大部分）函数，GridIn类中的函数，或者直接使用函数[2.x.89] 当然，我们可以在这样的网格上进行计算，但大多数时候（例如，参见几乎所有的教程程序），我们首先要全局地细化粗略的网格（使用[2.x.90]或自适应地细化（在这种情况下，首先计算一个细化准则，然后计算命名空间GridRefinement中的一个函数，最后调用[2.x.91]），然后网格就不再是 "粗网格"，而是 "细化网格"。
* 在某些情况下，我们也使用 "三角形的粗略网格 "这一短语，它指的是三角形开始时的单元集，即所有目前[2.x.92]三角形的 "活动单元 "都是通过网格细化得到的。当然，一些粗略的网格单元也可能是活跃的，如果它们从未被细化的话）。
* 三角形对象以[1.x.28]的方式存储单元：特别是，粗网格的所有单元都在零层。他们的子单元（如果我们在粗网格上执行[2.x.93]）将在第一层，等等。三角形的粗网格（在上一段的意义上）正好由三角形的零级单元组成。(它们是否处于活动状态(即没有子代)或已被细化，对这个定义并不重要)。
* 大多数deal.II中的三角形类都存储了整个粗网格和至少一些细化的单元。([2.x.94]和[2.x.95]类实际上都存储了整个网格的[1.x.29]个单元，而其他一些类如[2.x.96]在并行计算的每个进程中只存储了[2.x.97]个 "活动单元 "的[1.x.30]个。)在这些情况下，人们可以查询所有粗略网格单元的三角结构。其他三角剖分类（例如，[2.x.98]只存储部分粗网格。这种情况也请参见[2.x.99]"粗网格单元ID的概念"。  [2.x.100]
*

* <dt class="glossary"> [2.x.101] GlossCoarseCellId [1.x.31]</dt> [2.x.102] 大多数deal.II中的三角形类，特别是[2.x.103] [2.x.104] 和 [2.x.105] 在并行计算的每个进程中存储三角形的整个[2.x.106] "粗略网格"。另一方面，其他类别则不是这样，特别是[2.x.107]，它是为粗略网格太大而不能存储在每个进程中，需要进行分区的情况而设计。
* 在这些情况下，在算法中经常需要唯一地引用一个粗略的网格单元。因为当前进程中的三角剖分对象实际上并没有存储整个粗网格，所以我们需要为每个粗网格单元设置一个全局唯一的标识符，这个标识符与本地存储的三角剖分零级中的索引无关。这个全局唯一的ID被称为 "粗略单元ID"。它可以通过以下函数调用来访问
* [1.x.32]
* 其中`triangulation`是指向零级单元的迭代器`coarse_cell`所属的三角结构。这里，`coarse_cell->index()`返回该单元在其细化层次中的索引（见[2.x.108] 这是一个介于零和并行计算中当前进程上存储的粗网格单元数量之间的数字；它唯一地标识了该并行进程上的一个单元，但不同的并行进程可能对位于不同坐标的不同单元使用该索引。
* 对于那些在每个进程上存储所有粗略网格单元的类，[2.x.109]只是返回可能的参数值的排列组合。在最简单的情况下，例如对于一个顺序的或并行的共享三角形，该函数实际上将简单地返回参数的值。对于其他情况，如[2.x.110]，粗略单元ID的排序与粗略单元索引的排序不一样。最后，对于诸如[2.x.111]这样的类，该函数返回全局唯一的ID，它来自一个更大的可能指数集，而不是实际存储在当前进程上的粗放单元的指数。  [2.x.112]
*

* <dt class="glossary"> [2.x.113] GlossColorization [1.x.33]</dt> [2.x.114] [2.x.115] Colorization [2.x.116] 是用不同的标签标记三角图的某些部分的过程。颜色[2.x.117]一词的使用来自制图学，即通过给地图上的国家分配不同的颜色，使它们在视觉上相互区别。使用相同的术语[2.x.119]着色[2.x.120]在数学中很常见，尽管我们给不同的区域分配整数而不是色调。交易.II将两个过程称为着色。
* [2.x.121] [2.x.122] GridGenerator命名空间中的大多数函数都采取一个可选的参数 [2.x.123] 。这个参数控制边界的不同部分是否会被分配不同的 [2.x.124] "边界指标"。   一些函数也会分配不同的 [2.x.125] "材料指标"。[2.x.126] [2.x.127] 函数[2.x.128]计算一个三角形的分解（更确切地说，是一个迭代器的范围）。没有两个相邻的单元被赋予相同的颜色。[2.x.129] [2.x.130] [2.x.131]。
*

* <dt class=" glossary"> [2.x.132] GlossComponent [1.x.34]</dt>。
* [2.x.133] 当考虑方程组时，其中的解不仅仅是一个单一的标量函数，我们说我们有一个[1.x.35]与一个[1.x.36]。例如，在[2.x.134]中考虑的弹性方程的矢量解是[2.x.135]，由三个坐标方向上的位移组成。然后，该解决方案有三个元素。同样，[2.x.136]中考虑的三维斯托克斯方程有四个元素。  [2.x.137] .我们在交易二中称矢量值解的元素为[1.x.37]。为了得到良好的解决，对于解有[2.x.138]个元素，需要有[2.x.139]个偏微分方程来描述它们。这个概念在[2.x.140]模块中讨论得很详细。
* 在有限元程序中，人们经常想解决这个矢量值解决方案的单个元素（组件），或组件的集合。例如，我们在[2.x.141]中做了大量的工作，在[2.x.142]"处理矢量值问题 "模块中也提供了大量的文档。如果你只考虑偏微分方程（而不是其离散化），那么[1.x.38]的概念是自然的。
* 另一方面，当谈论有限元和自由度时，[1.x.39]并不总是正确的概念，因为组件并不总是可以单独处理。特别是，[2.x.143]"非原始有限元 "就是这种情况。同样，人们也不一定总是[1.x.40]处理单个分量，而是处理分量的集合&mdash；例如，所有速度分量在一起，并与斯托克斯系统中的压力分开，而不进一步将速度分割成其单个分量。在这两种情况下，正确的概念是[2.x.144]"块 "的概念。  由于每个分量，如果可以单独处理，也是一个块，所以用块的方式思考，往往是更好的策略。
* 对于一个给定的有限元，可以使用[2.x.145]函数查询组件的数量，可以使用[2.x.146]找出对于一个给定的有限元形状函数，哪些向量组件是非零的。 形状函数的各个组件的值和梯度（如果元素是原始的）可以使用参考单元上的[2.x.147]和[2.x.148]函数查询。[2.x.149]和[2.x.150]函数在实数单元上做同样的事情。也请参见FiniteElement和FEValues类的文档。
* [1.x.41] 许多函数允许你将其操作限制在某些向量组件或块上。例如，插值边界值的函数就是这种情况：人们可能只想插值一个有限元场的速度分量的边界值，而不想插值压力分量。这样做的方法是给这类函数传递一个ComponentMask参数，见[2.x.151]"本词汇表的组件掩码条目"。  [2.x.152]
*

* <dt class="glossary"> [2.x.153] GlossComponentMask [1.x.42]</dt>。
* [2.x.154] 当使用矢量值元素（见[2.x.155]）来解决方程组时，人们经常希望将一些操作限制在只有某些解决变量。例如，在求解斯托克斯方程时，人们可能希望只插值速度分量的边界值而不插值压力。在deal.II中，这通常是通过传递函数a[1.x.43]完成的。分量掩码总是被指定为ComponentMask对象，我们可以把它看作一个数组，其条目数与有限元的分量一样多（例如，在Stokes情况下，有[2.x.156]个分量），每个条目要么为真，要么为假。在这个例子中，我们只想插值斯托克斯系统的速度分量的边界值，那么这个分量掩码将是[2.x.157]，在3D中表示不应设置压力变量的边界值（解决方案中的最后一个[2.x.158]矢量分量。
* 有许多函数采取这样的分量掩码，例如[2.x.159] [2.x.160] [2.x.161] 等。在某些情况下，有多个具有这些名称的函数，但只有其中一些具有分量掩码参数。
* [1.x.44] 许多函数，接受一个已经默认构建的分量掩码对象，表示[1.x.45]，也就是说，就像向量有正确的长度，并且只填充了[2.x.162]值。原因是默认初始化的对象可以使用代码片断[2.x.163]来构建到位，因此可以在函数签名中作为默认参数使用。
* 换句话说，ComponentMask对象可以处于两种状态中的一种。它们可以被一个非零长度的布尔运算向量初始化；在这种情况下，它们代表一个特定长度的掩码，其中一些元素可能是真，另一些可能是假。或者，ComponentMask可能已经被默认初始化了（使用默认构造函数），在这种情况下，它代表了一个长度不确定的数组（即适合这种情况的长度），其中[1.x.46]为真。
* [1.x.47] 分量掩码通常是通过要求有限元从某些选定的分量中生成一个分量掩码来创建的，使用这样的代码，我们创建一个掩码，只表示斯托克斯元的速度分量（见[2.x.164] ）。


* [1.x.48]
* 结果是一个组件掩码，在2d中，它的值是 [2.x.165] 。同样地，使用


* [1.x.49]
* 在2d中会产生一个掩码[2.x.166]。当然，在3D中，结果将是[2.x.167] 。
*


* [2.x.168] 正如我们可以认为组成元素是由[2.x.169] "组件 "或[2.x.170] "块 "组成的，有组件掩码（由ComponentMask类代表）和[2.x.171] "块掩码"（由BlockMask类代表）。FiniteElement类有在这两种对象之间进行转换的函数。
*

*
* [2.x.172] 并非所有的组件掩码都有意义。例如，如果你有一个2D的FE_RaviartThomas对象，那么有一个[2.x.173]形式的元件掩码是没有任何意义的，因为你试图选择一个有限元的单个矢量元件，其中每个形状函数都有[2.x.174]和[2.x.175]速度。从本质上讲，虽然你当然可以创建这样的分量掩码，但你对它无能为力。  [2.x.176]
*

*
* <dt class="glossary"> [2.x.177] GlossCompress [1.x.50]</td> </td
* [2.x.178] 对于%并行计算，deal.II使用PETScWrappers和TrilinosWrappers命名空间中定义的向量和矩阵类。当使用MPI在%parallel中运行程序时，这些类只在当前处理器上存储一定数量的行或元素，而向量或矩阵的其余部分则存储在属于我们MPI宇宙的其他处理器上。当你组装线性系统时，这就出现了一定的问题：我们向矩阵和右手边的向量添加元素，这些元素可能在本地存储，也可能不在。有时，我们也可能只想[1.x.51]一个元素，而不是向其添加。
* PETSc和Trilinos都允许添加或设置没有本地存储的元素。在这种情况下，他们将我们想要存储或添加的值写入缓存，我们需要调用其中一个函数 [2.x.179] [2.x.180] [2.x.181] 或 [2.x.182] ，然后将缓存中的值运送到拥有应该被添加或写入的元素的MPI进程。由于MPI模型只允许从发送方发起通信（也就是说，它不是一个远程过程调用），这些函数是集体的，也就是说，它们需要被所有处理器调用。
* 然而，有一个障碍：PETSc和Trilinos都需要知道这些[2.x.183]函数调用的操作是适用于添加元素还是设置元素。  在某些情况下，并不是所有的处理器都在添加元素，例如，当使用一个非常[2.x.184]的 "粗略（初始）网格 "时，一个处理器并不拥有任何单元。出于这个原因，compress()需要一个VectorOperation类型的参数，它可以是::%add，或者::%insert。从7.3版本开始，这个参数对向量和矩阵是必须的。
* 简而言之，你需要在以下情况下调用compress()（而且只在这些情况下，虽然在其他情况下调用compress()只是花费一些性能）。
* 1.在你的矩阵和向量的汇编循环结束时。如果你直接写条目或者使用[2.x.185] 使用[2.x.186]，就需要这样做。
* 2.当你完成了对矩阵/向量中单个元素的设置，然后再进行其他操作（向元素添加，其他操作如缩放、求解、读取等）。使用[2.x.187]。
* 3.和2.一样，但用于向单个元素加值。使用 [2.x.188] 。
* 所有其他的操作，如缩放或添加向量，赋值，调用deal.II（VectorTools，AffineConstraints，...）或求解器都不需要调用compress()。  [2.x.189]
*

*
* [2.x.190] 压缩是一个只适用于向量的操作，其元素在一个并行的MPI宇宙中被一个且唯一的处理器拥有。它不适用于 [2.x.191] "有幽灵元素的向量"。
*

* <dt class=" glossary"> [2.x.192] GlossConcept [1.x.52]</dt>。
* [2.x.193] 在deal.II中，有几个地方我们要求模板中的类型与某个接口相匹配或以某种方式行事：这种约束在C++中被称为[2.x.194] 概念[2.x.195]。更多信息请参见[2.x.196]中的讨论和deal.II中的概念列表。  [2.x.197]
*

* <dt class="glossary"> [2.x.198] GlossDimension [1.x.53]</td> </dt
* [2.x.199] deal.II中的许多类和函数有两个模板参数，[2.x.200]和[2.x.201] 一个例子是基本的Triangulation类。


* [1.x.54]
* 在所有这些上下文中，你看到`dim`和`spacedim`被引用，这些参数有以下含义。
* [2.x.202] [2.x.203] [2.x.204] 表示网格的维度。例如，一个由线段组成的网格是一维的，因此对应于`dim==1`。由四边形组成的网格为`dim==2`，六面体的网格为`dim==3`。[2.x.205]
* [2.x.206] [2.x.207] 表示这种网格所在空间的维度。一般来说，一维网格生活在一维空间中，同样，二维和三维网格也是如此，它们将二维和三维领域细分。因此，[2.x.208] spacedim模板参数的默认值等于[2.x.209]，但情况并不一定如此。例如，我们可能想解决地球表面的沉积物迁移方程。在这种情况下，域是地球的二维表面（`dim==2`），它生活在三维坐标系中（`spacedim==3`）。[2.x.210] [2.x.211]。
* 更一般地说，deal.II可以用来解决嵌入高维空间的[1.x.55]上的偏微分方程。换句话说，这两个模板参数需要满足`dim <= spacedim'，尽管在许多应用中，我们只需满足`dim == spacedim'。
* 按照几何学的惯例，我们说 "二维 "被定义为`spacedim-dim`。换句话说，一个由四边形组成的三角形，其坐标是三维的（我们将使用`Triangulation<2,3>`对象）具有 "codimension one"。
* 这两个参数不一样的使用例子显示在 [2.x.212] , [2.x.213] , [2.x.214] 。  [2.x.215]
*

* <dt class="glossary"> [2.x.216] GlossDoF [1.x.56]</dt>。
* [2.x.217] 术语 "自由度"（通常缩写为 "DoF"）在有限元界通常用来表示两个略有不同但相关的事情。首先是我们想把有限元解表示为形状函数的线性组合，形式为 [2.x.218] 。这里，[2.x.219]是一个膨胀系数的向量。因为我们还不知道它们的值（我们将计算它们作为线性或非线性系统的解），它们被称为 "未知数 "或 "自由度"。该术语的第二个含义可以解释如下。对有限元问题的数学描述通常是说，我们正在寻找一个满足某些方程组的有限维函数[2.x.220]（例如，[2.x.221]的所有测试函数[2.x.222]）。换句话说，我们在这里说的是，解决方案需要位于某个空间 [2.x.223] 中。然而，为了在计算机上实际解决这个问题，我们需要选择这个空间的一个基；这就是我们在上面用系数[2.x.226]展开[2.x.225]时使用的形状函数[2.x.224]的集合。当然，空间[2.x.227]的基数有很多，但我们将特别选择由传统上在网格单元上局部定义的有限元函数描述的基数。在这种情况下描述 "自由度 "需要我们简单地 [1.x.57] 空间的基函数 [2.x.228] 。对于[2.x.229]元素，这意味着简单地以某种方式列举网格的顶点，但对于更高的元素，还必须列举与网格的边、面或单元内部有关的形状函数。提供这种列举[2.x.230]的基础函数的类被称为DoFHandler。  列举自由度的过程在deal.II中被称为 "分配DoF"。  [2.x.231]
* <dt class=" glossary"> [2.x.232] GlossDirectionFlag [1.x.58]</dt>。
* [2.x.233] [1.x.59]用于嵌入高维空间的三角形中，表示单元的方向，并使流形具有方向性。它使用[2.x.234]进行访问，并在创建三角化时由三角化类进行设置。你可以使用[2.x.235]函数来改变一个三角形的所有方向标志。
* 这个标志对于像这样的情况是必须的：假设我们有一个嵌入二维空间的一维网格。
* [2.x.236]
* 在一维空间的一维网格中，我们总是可以确保一个单元的左边顶点的位置比右边顶点的位置的值要小。然而，如果我们将网格嵌入到一个高维空间中，我们就不能再这样做了。例如，上面的网格中的单元格可以用下面的顶点集来描述。<code>(0,1), (1,2), (3,2), (4,3), (4,5) </code>。(作为附带说明，注意这里我们有顶点
*
* - 例如，顶点2
*
* - 是一个以上的单元的右端点）。)如果我们把每个单元的法线定义为与连接线的第一个顶点和第二个顶点的矢量垂直的单位矢量，那么我们最终会得到如下图所示。
* [2.x.237]
* 换句话说，这个一维流形是没有方向的。我们原则上可以在创建这样的网格时恢复顶点的顺序（尽管有很好的理由不这样做，例如，这个网格可能是由提取二维网格的表面网格产生的，而我们希望保留每个线段的顶点顺序，因为它们目前与二维单元的面的顶点顺序一致）。在deal.II中选择的另一种策略是简单地与每个单元关联，法线应该是该单元的左边还是右边的法线。在上面的例子中，五个单元格的标志将是<code>true, true, false, false, true</code>。根据每个单元格上的标志值，将右法线乘以正负1，就可以得到一组为流形定位的法线向量。
* 类似的问题发生在三个空间维度的二维网格上。我们注意到，如果二维流形不可定向，就不可能找到一致的方向标志；目前deal.II不支持这种流形。  [2.x.238]
*

* <dt class=" glossary"> [2.x.239] GlossDistorted [1.x.60]</dt>。
* [2.x.240] [1.x.61]是指从参考单元到实数单元的映射有一个雅各布系数，其行列式在单元的某处为非正值。通常情况下，我们只在单元格的顶点检查这个行列式的符号。函数[2.x.241]可以计算这些顶点的行列式。
* 举例来说，如果所有的行列式都是大致相等的数值，并且在[2.x.242]的顺序上，那么这个单元格就是好的形状。例如，一个正方形单元或面的行列式等于[2.x.243]，而一个强剪切的平行四边形的行列式则小得多。同样地，一个边长很不相等的单元格会有差异很大的行列式。反之，一个被夹住的单元，其中两个或多个顶点的位置被折叠成一个点，在这个位置的行列式为零。最后，一个倒置或扭曲的单元，其中两个顶点的位置是失序的，将有负的行列式。
* 下面两张图片显示了2D和3D的一个完好的单元，一个捏合的单元和一个扭曲的单元。
* [2.x.244]
* [2.x.245]
* 扭曲的细胞可以以两种不同的方式出现。原始的[2.x.246]"粗略网格 "可能已经包含了这样的单元，或者它们可能是由于移动或扭曲了一个相对较大的网格而产生的。
* 如果在创建三角网格时给出适当的标志，那么由GridGenerator和GridIn中的各种函数调用的函数[2.x.247]（但也可以由用户代码调用，见[2.x.248]和[2.x.249]末尾的例子]，将通过抛出一个类型为[2.x.250]的异常来提示创建带有变形单元的粗略网格。 如果你不打算在这些单元上装配任何东西，创建带有变形单元（尤其是塌陷/针状单元）的网格是合法的。例如，考虑这样一种情况：人们想模拟一种有液体填充的裂缝的弹性材料的行为，如一个储油罐。如果压力变得太大，裂缝就会被关闭
*
* 而离散裂缝体积的单元被折叠成零体积。只要你不在这些单元上进行积分来模拟流体的行为（如果裂缝的体积为零，就不存在任何流体），这样的网格是完全合法的。因此，[2.x.251]不是简单地中止程序，而是抛出一个异常，其中包含一个被扭曲的单元的列表；这个异常可以被捕获，如果你认为你可以忽略这个条件，你可以通过对捕获的异常不做任何反应。
* 函数[2.x.252]在某些情况下，可以通过移动具有未扭曲父单元的扭曲子单元的顶点来修复精化网格上的扭曲单元。
* 请注意，Triangulation类默认不测试是否存在扭曲的单元，因为确定一个单元是否扭曲并不是一个便宜的操作。如果你想让Triangulation对象测试单元格的变形，你需要在创建对象时通过传递适当的标志来指定这一点。  [2.x.253]
*

* <dt class="glossary"> [2.x.254] distributed_paper [1.x.62]</dt
* [2.x.255] "分布式计算论文 "是W. Bangerth, C. Burstedde, T. Heister和M. Kronbichler的一篇论文，题为 "大规模并行通用有限元代码的算法和数据结构"，描述了deal.II中%并行分布式计算的实现，即不仅像[2.x.256]中的线性系统被分割到不同机器的计算，还包括三角计算和DoFHandler对象。实质上，它是 [2.x.257] 命名空间和 [2.x.258] 中所用技术的指南。
* 该论文的完整参考资料如下。


* [1.x.63]
*
* 对于大规模的%并行计算，deal.II建立在[1.x.64]库的基础上。如果你使用这个功能，也请引用他们网站上列出的p4est论文。  [2.x.259]


* <dt class="glossary"> [2.x.260] GlossFaceOrientation [1.x.65]</dt> [2.x.261] 在三角测量中，通过应用右手边规则（x,y），可以从面的方向推导出面的法向量。
*
-> 法线）。)  我们注意到，在2D的标准方向中，面0和面2的法线指向单元格，面1和面3的法线指向外部。在3D中，面0、2和4的法线指向单元格内，而面1、3和5的法线指向外面。这些信息同样可以从[2.x.262]中查询到。
* 然而，事实证明，大量的三维网格不能满足这个约定。这是由于一个单元的面的约定已经暗示了相邻单元的东西，因为它们共享一个共同的面，对第一个单元的固定也固定了两个单元的相对面的法向量。很容易构建单元格循环的案例，对于这些案例，我们无法为所有面找到与该约定一致的方向。
* 由于这个原因，上述惯例只是我们所说的[2.x.263]标准方向[2.x.264] ...II实际上允许3d中的面具有标准方向，或者其相反的方向，在这种情况下，构成单元格的线会有还原的顺序，法向量会有相反的方向。你可以通过调用<tt>cell->face_orientation(face_no)</tt>来询问一个单元是否有标准方向：如果结果是[2.x.265]，那么这个面有标准方向，否则它的法向量就会指向另一个方向。在应用程序中，你需要这个信息的地方其实并不多，但库中有几个地方用到了这个。注意，在2D中，结果总是[2.x.266]。然而，虽然2D中的每个面总是在标准方向上，但你有时可以指定一些东西来假设不是这样的；一个例子是函数[2.x.267]。
* 还有两个描述面的方向的标志：face_flip和face_rotation。这些的一些文档存在于GeometryInfo类中。[2.x.268]函数中给出了它们在用户代码中的使用实例。  [2.x.269]
*

* <dt class="glossary"> [2.x.270] GlossGeneralizedSupport [1.x.66]</dt> [2.x.271] "Generalized support points"，顾名思义，是[2.x.272] "support points "的泛化。后者是用来描述一个有限元在个别点（"支持点"）上的简单[1.x.67]值。如果我们称这些点为[2.x.273]（其中帽子表示这些点定义在参考单元上[2.x.274]），那么人们通常以这样的方式定义形状函数[2.x.275]，即[1.x.68][2.x.276]只是在支持点评估函数，即[2.x.277]，并且选择基础以便[2.x.278] 其中[2.x.279] 是Kronecker三角函数。这就导致了常见的[2.x.280]"拉格朗日元素"。
*（在矢量值的情况下，除了支持点[2.x.281]外，唯一需要提供的其他信息是[1.x.69] [2.x.282]第1个节点函数对应的，因此[2.x.284] 。
* 另一方面，还有其他种类的元素不是这样定义的。例如，对于最低阶的Raviart-Thomas元素（见FE_RaviartThomas类），节点函数评估的不是一个具有[2.x.285]分量的矢量值有限元函数的各个分量，而是这个矢量的[1.x.70]。  [2.x.286] ，其中[2.x.287]是[2.x.288]所在的单元格面的法向量。换句话说，当在[2.x.290]处评估时，节点函数是[2.x.289]组件的[1.x.71]。类似的事情也发生在BDM、ABF和Nedelec元素上（见FE_BDM、FE_ABF、FE_Nedelec类）。
* 在这些情况下，元素没有 [1.x.72] ，因为它不是纯粹的插值；但是，在定义形状函数时，仍然涉及某种插值，因为节点函数仍然需要在特殊点上进行点评估 [2.x.291] 。在这些情况下，我们称这些点为[1.x.73]。
* 最后，还有一些元素仍然不适合这个方案。例如，一些层次化的基函数（例如，见FE_Q_Hierarchical元素）的定义是这样的：节点函数是有限元函数的[1.x.74]，2d的[2.x.292]，同样，3d的[2.x.293]是形状函数[2.x.294]描述的矩的顺序。其他一些元素使用边或面的矩。在所有这些情况下，节点函数根本不是通过插值定义的，那么这些元素既没有支持点，也没有广义支持点。  [2.x.295]
*

* <dt class="glossary"> [2.x.296] geometry_paper [1.x.75]</dt> [2.x.297] "geometry paper "是L. Heltai, W. Bangerth, M. Kronbichler, and A. Mola的一篇论文，题目是 "在有限元计算中使用精确几何信息"，描述deal.II如何描述域的几何信息。特别是，它讨论了Manifold类所基于的算法基础，以及它需要为网格细化、法向量的计算和其他许多几何学进入有限元计算的地方提供什么样的信息。
* 这篇论文目前可在arXiv网站https://arxiv.org/abs/1910.09824。这篇论文的完整参考资料如下。


* [1.x.76]
* [2.x.298]


* <dt class="glossary"> [2.x.299] GlossGhostCell [1.x.77]</dt> [2.x.300] 如果一个网格使用[2.x.301]类分布在多个MPI进程中，每个处理器只存储自己拥有的单元，其他处理器拥有的一层相邻单元，所有[2.x.302] "粗略级单元"，以及所有为维持相邻单元必须最多不同一个细化级别这一不变式所必须的单元。存储在每个进程上的不属于该进程但与该进程拥有的单元相邻的单元被称为 "幽灵单元"，对于这些单元，谓词[2.x.303]返回真。幽灵单元被保证存在于全局分布的网格中，也就是说，这些单元实际上被另一个进程所拥有，并且在那里没有被进一步细化。更多信息请参见[2.x.304] "分布式计算论文"。
* 幽灵单元层由所有与任何本地拥有的单元相邻的面、边或顶点的单元组成，这些单元本身并不是本地拥有的。换句话说，幽灵细胞完全包围了本地拥有的细胞的子域（当然，域的边界除外）。
* 幽灵单元的概念对于在每个处理器上存储整个网格的三角计算没有意义，即三角计算和[2.x.305]类。  [2.x.306]
*

* <dt class="glossary"> [2.x.307] GlossGhostedVector [1.x.78]</dt> [2.x.308] 在并行计算中，向量一般有两种情况：没有和有鬼魂元素。没有鬼魂元素的向量在处理器之间唯一地划分了向量元素：每个向量条目正好有一个处理器拥有它，而且这个处理器是唯一存储这个条目的值的。换句话说，如果零号处理器存储了一个向量的0...49号元素，一号处理器存储了50...99号元素，那么一号处理器访问这个向量的42号元素就不走运了：它没有被存储在这里，也无法评估其值。这将导致一个断言。
* 另一方面，在很多情况下，我们需要知道不属于本地的向量元素，例如在本地拥有的单元上评估解决方案（见[2.x.309]），其中一个自由度位于我们不属于本地的单元的接口处（在这种情况下，它必须是[2.x.310]"幽灵单元"），而邻近的单元可能是所有者
*
*--换句话说，自由度不是[2.x.311]"本地拥有"，而只是[2.x.312]"本地活动的自由度"。这种自由度的值通常存储在拥有该自由度的机器上，因此，在当前机器上将无法访问。
* 因为人们经常需要这些值，所以有第二种矢量，通常称为 "幽灵矢量"。幽灵向量在每个处理器上存储一些元素，而该处理器不是所有者。对于这样的向量，你可以读取你当前所在的处理器所存储的那些元素，但你不能写入这些元素，因为要做到这一点，需要将新的值传播给所有其他拥有这个值副本的处理器（这些处理器的列表可能是当前处理器不知道的，也没有办法有效地找到）。因为你不能写进重影向量，所以初始化这样一个向量的唯一方法是通过从一个非重影向量的赋值。这意味着我们必须从其他处理器中导入那些我们想在本地存储的元素。
* 幽灵向量的实际存储方式在并行向量的各种实现中是不同的。对于PETSc（以及相应的[2.x.313]类），重影向量存储的元素与非重影向量相同，另外还有一些由其他处理器拥有的额外元素。换句话说，每个元素在所有的处理器中都有一个明确的所有者，那些当前处理器存储但不拥有的元素（即 "幽灵元素"）只是其他地方的主值的镜像。
*
* - 因此，被称为 "幽灵"。[2.x.314]类也是这种情况。
* 另一方面，在Trilinos中（因此在[2.x.315]中，鬼魂向量仅仅是元素分布重叠的平行向量的一个视图。幽灵化的 "Trilinos向量本身不知道哪些条目是幽灵化的，哪些是局部拥有的。事实上，一个重影向量甚至可能不会存储所有非重影向量在当前处理器上会存储的元素。因此，对于Trilinos向量来说，不存在我们在非鬼魂情况下（或在PETSc情况下）所拥有的向量元素的 "所有者 "的概念，"鬼魂元素 "这个名字可能有误导性，因为在这个观点中，我们在本地可用的每个元素可能也会被存储在其他地方，但即使是这样，本地元素也不是一个主要位置的镜像值，因为每个元素没有所有者。
*


* [2.x.316] [2.x.317] 文档模块提供了不同种类的向量通常用于何处的简要概述。  [2.x.318]
*

* <dt class="glossary"> [2.x.319] hp_paper [1.x.79]</dt> [2.x.320] "hp-paper "是W. Bangerth和O. Kayser-Herold的一篇论文，题目是 "hp有限元软件的数据结构和要求"，它描述了在实现deal.II的hp-framework时使用的许多算法和数据结构。特别是，它总结了许多使用连续元素的%hp-有限元必须考虑的棘手问题。
* 这篇论文的完整参考资料如下。


* [1.x.80]
* 它可以从[1.x.81]中获得，也可以参见[1.x.82]了解详情。
* 那篇论文中显示的数字例子是用稍加修改的 [2.x.321] 版本生成的。与该教程程序的主要区别是，该程序中的各种操作都是为该论文计时的，以比较不同的选项，并表明[2.x.322]方法确实不是那么昂贵。  [2.x.323]
*

* <dt class="glossary"> [2.x.324] GlossInterpolation [1.x.83]</dt> [2.x.325] 用有限元插值的目的是计算一个代表有限元函数的系数向量，使得原始函数的[2.x.326]"节点值 "和有限元函数重合。因此，插值过程包括对给定函数[1.x.85]的所有[2.x.327]"节点函数"[1.x.84]进行评估，并将结果作为条目[1.x.86]存储在系数向量中。  [2.x.328]


* <dt class="glossary"> [2.x.329] GlossLagrange [1.x.87]</dt> [2.x.330] 基于拉格朗日插值的有限元在 [2.x.331] "支持点"。  [2.x.332]
*

* <dt class="glossary"> [2.x.333] GlossLocallyOwnedCell [1.x.88]</dt> [2.x.334] 当使用分布式网格时，这个概念标识了所有单元的一个子集，见[2.x.335]模块。在这样的网格中，每个单元正好被一个处理器所拥有。本地拥有的是那些由当前处理器拥有的。
* 并行计算中的每个处理器都有一个覆盖整个领域的三角形，该三角形由本地拥有的单元、[2.x.336]"幽灵单元 "和[2.x.337]"人工单元 "组成。  [2.x.338]
*

* <dt class="glossary"> [2.x.339] GlossLocallyOwnedDof [1.x.89]</dt> [2.x.340] 当使用分布式网格时，这个概念标识了所有自由度的一个子集，见[2.x.341]模块。  本地拥有的自由度生活在本地拥有的单元上。由于自由度只属于一个处理器，不同处理器所拥有的单元之间的接口上的自由度可能属于一个或另一个处理器，所以并非本地拥有的单元上的所有自由度也是本地拥有的自由度。
* 本地拥有的自由度是[2.x.342]"本地活动自由度 "的一个子集。  [2.x.343]
*

* <dt class="glossary"> [2.x.344] GlossLocallyActiveDof [1.x.90]</dt> [2.x.345] 这个概念在使用分布式网格时识别所有自由度的子集，见[2.x.346] 模块。  本地活动的自由度是那些生活在本地拥有的单元上的自由度。因此，在不同处理器拥有的单元之间的界面上的自由度属于一个以上处理器的本地活动自由度集合。
* 本地活动自由度是[2.x.347]"本地拥有的自由度 "的超集和[2.x.348]"本地相关自由度 "的子集。  [2.x.349]
*

* <dt class="glossary"> [2.x.350] GlossLocallyRelevantDof [1.x.91]</dt> [2.x.351] 当使用分布式网格时，这个概念确定了所有自由度的一个子集，见[2.x.352]模块。  本地相关的自由度是那些生活在本地拥有的或幽灵单元上的自由度。因此，它们可能被不同的处理器所拥有。
* 本地相关自由度是[2.x.353]"本地活动自由度 "的超集。  [2.x.354]
*

* <dt class="glossary"> [2.x.355] GlossManifoldIndicator [1.x.92]</td> </td
* [2.x.356] 构成三角网格的每个对象（单元格、面、边等），都与一个唯一的编号（类型为[2.x.357]，用于识别网格细化时哪个流形对象负责生成新点。
* 默认情况下，一个网格的所有流形指标都被设置为[2.x.358]。一个典型的代码将一个对象上的流形指标设置为其他内容，看起来像这样，这里将所有中心的[2.x.359]分量小于0的单元的流形指标设置为42。
*


* [1.x.93]
*
* 这里我们调用函数[2.x.360]。也可以用调用[2.x.361]来代替，以递归地设置每个面（和边，如果是3D）的流形标识。要查询某个特定对象边缘的流形指标，请使用[2.x.362]。
* 上面的代码只是设置了Triangulation的特定部分的流形指标，但它本身并没有改变Triangulation类在网格细化中对待这个对象的方式。为此，你需要调用[2.x.363]来将流形对象与特定的流形指标联系起来。这允许Triangulation对象使用不同的方法来寻找单元格、面或边上的新点进行细化；默认情况下，所有面和边都使用FlatManifold对象。
*

*
* [2.x.364] 在网格细化时，流形指标会从父类继承到子类。关于流形指示器的更多信息，也在Triangulation类的文档部分以及[2.x.365] "流形文档模块 "中介绍。歧管指标在 [2.x.366] 和 [2.x.367] 中使用。  [2.x.368]
* [2.x.369] [2.x.370] "关于歧管的模块"
*

* <dt class="glossary"> [2.x.371] GlossMaterialId [1.x.94]</dt> [2.x.372] 三角形的每个单元都有一个叫做 "材料ID "的属性。它通常用于具有异质系数的问题，以确定一个单元在域的哪一部分，因此，系数应该在这个特定的单元上具有哪个值。在实践中，一个单元的材料ID通常用于识别哪些单元属于域的特定部分，例如，当你有不同的材料（钢铁、混凝土、木材），但都属于同一个域。在组装双线性表格的过程中，我们通常会查询与某一单元相关的材料ID，并使用它来确定（例如，通过表格查询，或一连串的if-else语句）该单元的正确材料系数是多少。
* 这个材料ID可以在构建三角形时设置（通过CellData数据结构），也可以在之后通过使用单元格迭代器设置。关于这个功能的典型使用，请看[2.x.373]的教程程序。GridGenerator命名空间的函数通常将所有单元的材料ID设置为0。当通过GridIn类读取三角图时，不同的输入文件格式有不同的约定，但通常是明确指定材料ID，如果没有，则GridIn简单地将其设置为零。因为一个单元的材料是与域的特定区域相关的，所以材料ID在网格细化时由子单元从其父单元继承。
* 材料ID的设置和查询使用[2.x.374] [2.x.375] 和 [2.x.376] 函数。  [2.x.377]
*

* <dt class="glossary"> [2.x.378] GlossMPICommunicator [1.x.95]</dt> [2.x.379] 在消息传递接口（MPI）的语言中，通信器可以被认为是一个邮件系统，允许向邮件系统的其他成员发送信息。在每个通信器中，每个[2.x.380]"进程 "都有一个[2.x.381]"等级"（相当于门牌号），允许识别消息的发送方和接收方。不可能通过一个通信器向不属于这个通信器/邮件服务的接收者发送消息。
* 当通过命令行调用启动一个并行程序时，如


* [1.x.96]
*（或者在你的集群上使用的批处理提交系统中使用的等价物）MPI系统启动32份[2.x.382]的可执行文件。其中每个都可以访问[2.x.383]通信器，然后由所有32个处理器组成，每个都有自己的等级。这个MPI宇宙中的一个进程子集后来可以同意创建其他通信器，只允许在一个进程子集之间进行通信。  [2.x.384]
*

* <dt class="glossary"> [2.x.385] GlossMPIProcess [1.x.97]</dt> [2.x.386] 在分布式内存机器上运行并行作业时，人们几乎总是使用MPI。在那里，一个命令行调用，如


* [1.x.98]
*（或在你的集群上使用的批处理提交系统中使用的等价物）启动32份[2.x.387]的可执行文件。其中一些实际上可能在同一台机器上运行，但一般来说，它们将在不同的机器上运行，不能直接访问对方的内存空间。
* 在消息传递接口（MPI）的语言中，在（可能是不同的）机器上运行的同一可执行文件的每个副本被称为[1.x.99]。所有并行运行的进程的集合被称为 "MPI宇宙"，并由 [2.x.388] "MPI通信器" [2.x.389] 识别。
* 每个进程只能立即访问其自身内存空间中的对象。一个进程不能从其他进程的内存中读取或写入。因此，进程可以通信的唯一方式是互相发送消息。也就是说（正如在[2.x.390]的介绍中所解释的那样），人们通常会调用更高级别的MPI函数，而作为通信器一部分的所有进程都参与其中。一个例子是计算一组整数的总和，每个进程提供总和的一个项。  [2.x.391]
*

<dt class="glossary"> [2.x.392] GlossMPIRank [1.x.100]</dt> [2.x.393] 在消息传递接口（MPI）的语言中，[2.x.394]"MPI进程 "的[1.x.101]是该进程在当前作为一个并行作业运行的所有进程的集合[2.x.395]中的编号。更正确地说，它是[2.x.396]"MPI通信器 "中的数字，该通信器将所有进程的一个子集与一个并行作业组合在一起（其中[2.x.397]只是表示[1.x.102]的进程集）。
* 在每个通信器中，每个进程都有一个独特的等级，与所有其他进程的等级不同，可以在MPI通信调用中识别一个接收方或发送方。在一个处理器上运行的每个进程都可以通过调用[2.x.398]查询自己在通信器中的等级。 参与通信器的进程总数（即通信器的[1.x.103]）可以通过调用[2.x.399][2.x.400]获得。
*

* <dt class="glossary"> [2.x.401] mg_paper [1.x.104]</dt> [2.x.402] "multigrid paper "是B. Janssen和G. Kanschat的一篇论文，题为 "Adaptive Multilevel Methods with Local Smoothing for H1- and Hcurl-Conforming High Order Finite Element Methods"，它描述了在实现deal.II的多网格框架时所用的许多算法和数据结构。它是实现[2.x.403]中用于多网格方法的类的基础。
* 本文的完整参考资料如下。


* [1.x.105]
* 论文见[1.x.106]，更多细节见[1.x.107]。  [2.x.404]
*

* <dt class=" glossary"> [2.x.405] GlossNodes [1.x.108]</dt>。
* [2.x.406] 习惯上将有限元定义为一个三联体 [2.x.407] 其中
*


*
* - [2.x.408]是单元格，在deal.II中这总是一个线段、四边形或六面体。
*


*
* - [2.x.409]是一个有限维空间，例如，从[2.x.410]"参考单元 "映射到[2.x.411]的多项式空间。
*


*
* - [2.x.412]是 "节点函数 "的集合，即函数[2.x.413] 。[2.x.414]的维度必须等于节点函数的数量。有了这个定义，我们可以定义局部函数空间的基础，即一组 "形状函数"[2.x.415]，要求[2.x.416]，其中[2.x.417]是克朗克三角。
* 这种对有限元的定义有几个优点，涉及分析和实施。对于分析来说，它意味着与某些空间[2.x.418]的一致性，例如连续性，是由节点函数决定的。在deal.II中，它有助于大大简化像FE_RaviartThomas这样的复杂元素的实现。
* 节点函数的例子是[2.x.419]"支持点 "中的值和关于Legendre多项式的矩。例子。
* [2.x.420]
* 如上所述，有限元的构造允许编写描述有限元的代码，只需提供一个多项式空间（无需给它任何特定的基础）。
*
* - 任何方便的都是完全足够的）和节点函数。例如，在[2.x.421]函数中就用到了这一点。  [2.x.422]
*

* <dt class="glossary"> [2.x.423] GlossParallelScaling [1.x.113]</dt> [2.x.424] 当我们说一个并行程序可以 "扩展 "时，我们的意思是，如果我们让它解决的问题变大，程序不会变得过于缓慢（或占用过多的内存），如果我们保持问题大小不变但增加处理它的处理器（或内核）数量，运行时间和内存消耗将按比例减少。
* 更具体地说，想想一个问题，其大小由一个数字[2.x.425]给出（可以是单元格的数量，未知数的数量，或其他一些指示性的数量，如解决它所需的CPU周期的数量），对于这个问题，你有[2.x.426]个处理器可用于解决。在一个理想的世界里，这个程序需要的运行时间是[2.x.427]，这意味着我们可以通过提供更多的处理器将运行时间减少到任何想要的值。同样，为了使程序具有可扩展性，其总体内存消耗需要为[2.x.428]，在每个参与的进程上需要为[2.x.429]，这再次意味着我们可以通过提供足够多的处理器，将任何问题纳入计算机附加在每个处理器上的固定内存量。
* 对于可扩展性的实际评估，我们经常区分 "强 "和 "弱 "可扩展性。这些评估渐进式的声明，如[2.x.430]极限中的运行时间[2.x.431]和/或[2.x.432] 。具体来说，当我们说一个程序是 "强可扩展性 "时，我们的意思是，如果我们有一个固定大小的问题[2.x.433]，那么我们可以通过向该问题投掷更多的处理器来减少运行时间和内存消耗（在每个处理器上）与[2.x.434]成反比。特别是，强可扩展性意味着，如果我们提供两倍的处理器，那么每个进程的运行时间和内存消耗都将减少2倍。换句话说，通过提供越来越多的处理器，我们可以越来越快地解决[1.x.114]的问题。
* 相反，"弱可扩展性 "是指如果我们将问题大小[2.x.435]增加一个固定的系数，并将可用于解决问题的处理器[2.x.436]的数量增加相同的系数，那么整体运行时间（以及每个处理器的内存消耗）保持不变。换句话说，我们可以通过提供越来越多的处理器，在相同的壁时钟时间内解决[1.x.115]。
* 在这个理论意义上，没有一个程序是真正可扩展的。相反，一旦[2.x.437]或[2.x.438]的增长超过一定的限度，所有的程序就不再具有可扩展性。因此，我们经常说 "程序可以扩展到4000个核心"，或者 "程序可以扩展到100,000,000个未知数 "这样的话。程序不能无限制扩展的原因有很多；这些都可以通过查看（相对简单的）[2.x.439]教程程序来说明。
*


*
* - 序列部分。许多程序都有不能或不能并行化的代码部分，也就是说，一个处理器必须做一定的、固定的工作量，不会因为周围总共有[2.x.440]个处理器而减少。在[2.x.441]中，生成图形输出时就是这种情况：一个处理器为整个问题创建图形输出，也就是说，它需要做[2.x.442]工作。这意味着这个函数的运行时间为[2.x.443]，而不考虑[2.x.444]，因此整个程序将无法达到[2.x.445]的运行时间，而是有一个可以描述为[2.x.446]的运行时间，其中第一项来自可扩展的操作，如组装线性系统，而后者来自在进程0上生成图形输出。如果[2.x.447]足够小，那么程序可能看起来对小数量的处理器具有强扩展性，但最终强扩展性将停止。此外，程序也不能弱扩展，因为在以相同的速度增加处理器数量[2.x.449]的同时，增加问题的大小[2.x.448]并不能保持这一个函数的运行时间不变。
*


*
* - 重复的数据结构。在 [2.x.450] 中，每个处理器存储整个网格。也就是说，每个处理器都要存储一个大小为 [2.x.451] 的数据结构，而不考虑 [2.x.452] 。最终，如果我们使问题的大小足够大，即使我们增加处理器的数量，这也会溢出每个处理器的内存空间。因此，很明显，这种复制的数据结构可以防止程序弱速扩展。   但它也阻止了程序的强扩展，因为为了创建一个大小为[2.x.453]的对象，至少要写到[2.x.454]的内存位置，要花费[2.x.455]的CPU时间。因此，如果我们提供越来越多的处理器，整个算法的一个组成部分不会表现为[2.x.456]。
*


*
* - 通信。仅举一个例子，如果你想计算一个向量的[2.x.457]常数，而所有MPI进程都存储了一些条目，那么每个进程都需要计算其自身条目的平方之和（这需要[2.x.458]时间，因此可以完美扩展），但随后每个进程都需要将其部分之和发送到一个进程，将它们全部相加并取平方根。在最好的情况下，发送一个包含单个数字的信息需要恒定的时间，而不考虑进程的总体数量。因此，同样地，每一个做通信的程序都不能强势扩展，因为程序中有些部分的CPU时间要求并不随着你为固定规模分配的处理器数量而减少 [2.x.459] 。在现实中，情况实际上更糟糕：参与一个通信步骤的进程越多，一般来说需要的时间就越长，例如，因为要把所有人的贡献加起来的那个进程必须把所有的东西加起来，需要 [2.x.461] 时间。换句话说，CPU的时间[1.x.116]与进程的数量有关，因此不仅阻止了程序的强扩展，而且也阻止了弱扩展。实际上，MPI库并不通过将每个消息发送到一个进程，然后将所有的东西加起来来实现[2.x.462]规范；相反，它们在树上做成对的减少，而不是像[2.x.463]那样增长运行时间，而是像[2.x.464]那样，以发送更多消息为代价。尽管如此，根本的一点是，当你增加更多的处理器时，运行时间将以[2.x.465]的方式增长，而不管操作的实际实现方式如何，因此它不能扩展。)
* 这些以及其他阻碍程序完美扩展的原因可以在[1.x.117][1.x.118]中总结出来，即如果程序整体工作的一部分[2.x.466]可以并行化，即可以在[2.x.468]时间内运行，而程序工作的一部分[2.x.469]不能并行化（即。它包括只有一个进程可以做的工作，例如在[2.x.470]中生成图形输出；或者每个进程都必须以复制的方式执行，例如将带有本地贡献的消息发送到一个专门的进程进行积累），那么程序的总体运行时间将是


* [1.x.119]
* 因此，你得到的 "加速"，即你的程序在[2.x.471]处理器上的运行速度与在单个进程上运行程序相比的系数（假设这是可能的），将是


* [1.x.120]
* 如果[2.x.472]，对所有实际存在的程序来说都是如此，那么[2.x.473]就是[2.x.474]，这意味着有一个点，在这个点上，在问题上投入更多的处理器不会再有任何明显的回报。
* 在实践中，重要的是[1.x.121]或[1.x.122]或[1.x.123]一个程序的规模。对于deal.II，经验表明，在大多数具有合理快速网络的集群上，人们可以解决多达几十亿个未知数的问题，最多有几千个处理器，而每个进程的未知数则在40,000到100,000之间。最后一个数字是最相关的：如果你有一个问题，例如[2.x.475]未知数，那么在1000-2500个处理器上解决它是有意义的，因为每个进程处理的自由度数量保持在40000以上。因此，每个进程都有足够的工作要做，所以[2.x.476]的通信时间并不占优势。但是用1万或10万个处理器来解决这样的问题是没有意义的，因为这些处理器的每个局部问题都变得非常小，以至于它们大部分时间都在等待通信，而不是在做自己部分的工作。  [2.x.477]
* <dt class="glossary"> [2.x.478] GlossPeriodicConstraints [1.x.124]</dt> [2.x.479] 周期性边界条件经常在只有部分物理相关域被建模时使用。人们假设解决方案只是在被认为是周期性的边界上周期性地继续。在deal.II中，通过[2.x.480]和[2.x.481]支持这一点。一旦使用[2.x.482]，还必须调用[2.x.483]以确保所有进程知道周期性边界两边的三角化的相关部分。一个典型的分布式三角剖分的过程是。
*


*
* - 创建一个网格
*


*
* - 使用[2.x.484]（三角法）收集周期面
*


*
* - 使用[2.x.485]将周期性信息添加到网格中。
*


*
* - 使用 [2.x.486] (DoFHandler) 收集周期性面孔
*


*
* - 使用 [2.x.487] 添加周期性约束。
* 这方面的一个例子可以在 [2.x.488] 中找到。  [2.x.489]
*

* <dt class="glossary"> [2.x.490] GlossPrimitive [1.x.125]</dt> [2.x.491] 如果一个有限元素（由其形状函数描述）存在一个从形状函数数到矢量[2.x.492] GlossComponent "分量 "的唯一关系，那么它就是基元。这意味着，如果一个元素是原始的，那么矢量值元素的每个形状函数正好有一个非零分量。这尤其包括所有标量元素以及通过FESystem类从其他基元（例如标量）元素组装的矢量值元素，如[2.x.493]、[2.x.494]、[2.x.495]和其他一些元素所示。另一方面，[2.x.496]和[2.x.497]中使用的FE_RaviartThomas类或FE_Nedelec类提供了非原始有限元，因为在那里，每个矢量值形状函数可能有几个非零分量。  [2.x.498]


* <dt class="glossary"> [2.x.499] GlossReferenceCell [1.x.126]</dt> [2.x.500] 超立方体[0,1]<sup>dim</sup>，所有参数化的有限元形状函数都在其上定义。参考单元的许多属性由GeometryInfo类描述。  [2.x.501]


* <dt class="glossary"> [2.x.502] GlossSerialization [1.x.127]</dt>。
* [2.x.503] 术语 "序列化 "指的是将一个对象的状态写入一个流中，然后再检索它的过程。一个典型的用例是将程序的状态保存到磁盘上，以便以后可能的复活，通常是在长期运行的计算的检查点/重启策略的背景下，或者在不是很可靠的计算机上（例如，在非常大的集群上，个别节点偶尔会出现故障，然后导致整个MPI作业的中断）。在这两种情况下，人们希望偶尔保存程序的状态，以便在失败时，可以在那个点重新启动，而不是从头开始运行。
* deal.II通过实现[1.x.128]库的必要接口，实现了序列化设施。关于如何保存和恢复对象的例子见那里。  [2.x.504]
*

* <dt class="glossary"> [2.x.505] GlossShape [1.x.129]</dt> [2.x.506] 有限元基函数对单个网格单元的限制。  [2.x.507]
*

* <dt class="glossary"> [2.x.508] GlossSubdomainId [1.x.130]</dt> [2.x.509] 三角形的每个单元都有一个叫做 "subdomain id "的属性，可以通过[2.x.510]这样的调用进行查询，例如可以通过[2.x.511] 进行设置。(这些调用分别解析为[2.x.512]和[2.x.513]。)虽然原则上这个属性可以被应用程序认为有用的任何方式使用（它只是一个与每个单元相关的整数，可以表示你想要的任何东西），至少对于以%并行方式运行的程序，它通常表示 "拥有 "这个单元的处理器的[2.x.514] "MPI等级"。
* 对于基于MPI并行化的程序，但每个处理器都存储整个三角形（例如，[2.x.515]和[2.x.516]，但不是[2.x.517]），子域ID通过划分网格分配给单元，然后每个MPI进程只对它 "拥有 "的单元工作，即。属于处理器拥有的子域（传统上，这是子域id的情况，其数值与MPI通信器中MPI进程的等级一致）。分区通常使用[2.x.518]函数完成，但也可以使用任何其他方法来完成。(另外，[2.x.519]类可以用类似的方法自动划分网格)。
* 另一方面，对于使用MPI并行化的程序，但网格是使用[2.x.520]类持有分布在几个处理器上的，单元的子域id是与拥有该单元的处理器绑定的。换句话说，查询一个单元的子域id可以告诉你这个单元是否被当前的处理器所拥有（即如果<code>cell- [2.x.521] == [2.x.522] 或者被其他处理器所拥有。在%并行分布的情况下，子域ID只被分配给当前处理器拥有的单元以及紧邻的[2.x.523]"幽灵单元"。更远的单元被保留在每个处理器上，以确保每个MPI进程都能访问完整的[2.x.524]"粗网格"，并确保相邻的单元最多相差一个细化级别这一不变性。这些单元被称为 "人工"（见[2.x.525]"这里"），具有特殊的子域id值[2.x.526]。
* 除了常规的子域id，还有第二套密切相关的标志，与每个单元相关。"水平子域id"。这些标志不仅存在于活动单元，而且事实上存在于网格层次结构中的每个单元。它们的含义完全类似于常规的子域id，但它们是由[2.x.527]和[2.x.528]函数读写的。  [2.x.529]
*

* <dt class="glossary"> [2.x.530] GlossSupport [1.x.131]</dt> [2.x.531] 根据定义，支持点是那些 [2.x.532] ，使得对于形状函数 [2.x.533] 持有 [2.x.534] 。因此，有限元插值可以由支持点中的值唯一地定义。
*拉格朗日元素填充由[2.x.535]访问的矢量，这样函数[2.x.536]返回<tt>真</tt>。当然，这些支持点是在[2.x.537]的 "参考单元 "上。  然后，可以使用FEValues（与Mapping结合使用）来访问实际网格单元上的支持点。
*


* [2.x.538] [2.x.539] "支持点 "的概念仅限于基于Lagrange插值的有限元族。对于一个更普遍的概念，见[2.x.540]"广义支持点"。  [2.x.541]
*

* <dt class="glossary"> [2.x.542] GlossTargetComponent [1.x.132]</dt> [2.x.543] 当向量和矩阵被按分量分组到块中时，通常希望将几个原始分量收集到一个块中。例如，这可能是将斯托克斯系统的速度分组为一个单一的块。  [2.x.544]
*

* <dt class="glossary"> [2.x.545] GlossUnitCell [1.x.133]</dt> [2.x.546] 见[2.x.547] "参考单元"。  [2.x.548]
*

* <dt class="glossary"> [2.x.549] GlossUnitSupport [1.x.134]</dt> [2.x.550] 这些是参考单元上的[2.x.551]"支持点"，定义在FiniteElement中。例如，1d中通常的Q1元素在<tt>x=0</tt>和<tt>x=1</tt>有支持点（类似地，在更高维度的单位正方形或立方体的顶点上）。另一方面，高阶拉格朗日元素的单位支持点也在单位线、正方形或立方体的内部。  [2.x.552]


* <dt class="glossary"> [2.x.553] GlossUserFlags [1.x.135]</dt> [2.x.554] 一个三角图为用户标志提供每行、四边形等一个比特。   这个字段可以像所有其他数据一样使用迭代器进行访问，使用的语法是
* [1.x.136]
* 通常情况下，如果一个算法走过所有的单元，并且需要另一个单元，例如邻居，是否已经被处理过的信息，那么这个用户标志就会被使用。同样，它也可以用来标记边界上的面、四边形或线，对它们已经进行了一些操作。后者通常是有用的，因为一个循环，如
* [1.x.137]
*不止一次地遇到一些边界线。因此，人们会在循环的主体中设置该行的用户标志，并且只有在用户标志先前没有被设置的情况下才会进入主体。有一些额外的函数可以通过迭代器接口访问；更多信息请参见TriaAccessor类。请注意，没有用户标志可以与顶点相关联；然而，由于顶点是连续编号的，这可以很容易地在用户代码中使用一个bools矢量来模拟。
* 有两个函数，[2.x.555]和[2.x.556]可以从一个流或一个bools向量中写入和读取这些标志。与[2.x.557]和[2.x.558]不同的是，这两个函数存储和读取所有使用过的线、四边形等的标志，即不仅是活动的标志。
* 如果你想存储更多具体的用户标志，你可以使用函数[2.x.559]和[2.x.560]，对四边形等也是如此。
* 至于细化和粗化标志，这些函数有两个版本，一个是从流中读/写，一个是从<tt>向量中读/写 [2.x.561] 后者用于临时存储标志，而第一个用于将其存储在文件中。
* 在使用前用[2.x.562]函数清除用户标志是很好的做法，因为经常需要在多个函数中使用这些标志。如果在调用一个需要这些标志的函数时，这些标志可能还在使用中，那么这个函数应该按照上述方法保存和恢复这些标志。
*
* [2.x.563] 如果需要在单元格、行或面中存储更多的信息，而不仅仅是一个布尔标志，那么请参见[2.x.564] "用户数据"。  [2.x.565]
*

* <dt class="glossary"> [2.x.566] GlossUserData [1.x.138]</dt> [2.x.567] 就像[2.x.568]"用户标志 "一样，Triangulation类为每条线、四边形和六边形提供一个字段，在其中存储比单个布尔标志更具描述性的数据。这被称为 "用户数据"，可以在其中存储的数据是一个无符号整数或一个空指针。两者都是用来索引到一个更大的数组中，该数组包含了应用程序想要附加到网格实体的更详细的数据。
* 用户数据的存储和检索方式如下。
* [1.x.139]
* 同样地，有函数[2.x.569]用来设置指针，[2.x.570]和[2.x.571]用来检索索引和指针。要清除所有的用户索引或指针，请使用 [2.x.572] 与标志一样，有一些函数允许保存和恢复用户数据，可以是网格层次结构的所有实体，也可以是线、四边形或六边形的单独数据。有一些额外的函数可以通过迭代器接口访问；更多信息请参见TriaAccessor类。
*
* [2.x.573] 用户指针和用户索引被存储在同一个地方。为了避免不必要的转换，Triangulation会检查其中哪一个正在使用，并且不允许访问另一个，直到[2.x.574]被调用。
*
* [2.x.575] 关于[2.x.576]指针的类型安全缺失的常规警告显然在这里得到了体现；类型的正确性等的责任完全在于指针的使用者。  [2.x.577]
*

* <dt class="glossary"> [2.x.578] workstream_paper [1.x.140]</dt> [2.x.579] "WorkStream paper "是B. Turcksin、M. Kronbichler和W. Bangerth的一篇论文，讨论了WorkStream的设计和实现。WorkStream的核心是一种设计模式，即在有限元代码中反复使用的东西，因此，可以通用地实现。特别是，本文阐述了这种模式的动机，然后提出了实现它的不同方法。它还比较了不同实现方式的性能。
* 本文的完整参考资料如下。


* [1.x.141]
* 它可以从[1.x.142]中获得，详细情况也见[1.x.143]。  [2.x.580]
*

* <dt class="glossary"> [2.x.581] GlossZOrder [1.x.144]</dt> [2.x.582] 单元的 "Z顺序 "描述了一个单元被遍历的顺序。
* 默认情况下，如果你在deal.II中的所有单元上写一个循环，单元将按照较粗的单元（即从[2.x.583]"粗网格 "单元中以较少的细化步骤获得的单元）在较细的单元（即以较多的细化步骤获得的单元）之前的顺序进行遍历。在每个细化层中，单元的遍历顺序与它们被创建的顺序有关；然而，从本质上讲，这个顺序最好被认为是 "未指定的"：你将以某种顺序访问一个给定细化层中的每个单元一次，但你不应该对这个顺序做任何假设。
* 因为单元格的创建顺序会影响到单元格的顺序，所以对于两个相同的网格，你遍历单元格的顺序可能会发生变化。例如，想想一个有两个单元的1d（粗）网格。如果你先精炼其中的第一个单元，然后再精炼另一个单元，那么你将以不同的顺序遍历精炼层1上的四个单元，而不是先精炼第二个粗单元，再精炼第一个粗单元。
* 这种顺序对于几乎所有的应用都是完全实用的，因为在大多数情况下，以何种顺序遍历单元实际上并不重要。此外，它允许使用导致特别低的高速缓存失误频率的数据结构，因此对高性能计算应用来说是有效的。
* 另一方面，在某些情况下，人们希望以特定的、可重复的顺序遍历单元，这只取决于网格本身，而不是其创建历史或任何其他看似任意的设计决定。Z顺序 "是实现这一目标的方法之一。
* 为了解释Z顺序的概念，考虑下面的网格序列（每个单元使用 "level.index "符号进行编号，其中 "level "是指从[2.x.584]"粗略网格 "单元到特定单元所需的细化数量，"index "是该单元在特定细化级别中的索引）。
* [2.x.585] [2.x.586] [2.x.587] [2.x.588]。
* 注意第2层的单元格是如何按照它们被创建的顺序排列的。这并不总是如此：如果中间有单元格被移除，那么新创建的单元格就会填上这样产生的洞）。
* 那么deal.II遍历细胞的 "自然 "顺序将是0.0
*
-> 1.0
*
-> 1.1
*
-> 1.2
*
-> 1.3
*
-> 2.0
*
-> 2.1
*
-> 2.2
*
-> 2.3
*
-> 2.4

-> 2.5
*
-> 2.6
*
-> (如果你只想遍历[2.x.589]的 "活动单元"，那么就省略这个列表中所有有子单元的单元。)  这可以被认为是对数字 "level.index "的 "lexicographic "排序，但由于每个级别内的索引没有被很好地定义，这不是一个特别有用的概念。另外，我们也可以把它看作是对应于这个网格的树的一个可能的广度优先遍历，它代表了单元格之间的父子关系。
* [2.x.590]
* 另一方面，Z顺序对应于树的一个特定的深度优先的遍历。即：从一个单元格开始，如果它有孩子，那么就遍历这些单元格的孩子；只要一个孩子有孩子，这个规则就递归应用。
* 对于上面给定的网格，这产生了以下的顺序。0.0
*
-> 1.0
*
-> 2.4
*


*


*
-> 2.5
*
-> 2.6
*
-> 2.7
*
-> 1.1
*
-> 1.2
*
-> 1.3

-> 1.4
*
-> 2.0
*
-> 2.1
*
-> 2.2
*
-> (同样，如果你只关心活动单元，那么就把0.0、1.0和1.3从这个列表中删除。)因为单元格的子代顺序是明确定义的（相对于每一层内的单元格顺序），这种 "分层 "遍历是有意义的，尤其是独立于一个三角形的历史。
* 在实践中，它很容易使用递归函数来实现。
* [1.x.145]
* 这个函数然后被调用如下。
* [1.x.146]
*
* 最后，作为对术语 "Z "顺序的解释：如果你按照这种分层方式出现的顺序画一条穿过所有单元格的线，那么它在每个精炼的单元格上看起来就像一个左-右倒置的Z。事实上，这样定义的曲线可以被认为是一条空间填充曲线，有时也被称为 "莫顿排序"，见https://en.wikipedia.org/wiki/Z-order_curve 。  [2.x.591]



* [2.x.592]


* [0.x.1]

include/deal.II-translator/A-headers/grid_0.txt
[0.x.0]*



* [2.x.0]
* 这个模块将与网格的拓扑结构和几何形状有关的函数和类归类。一个网格可以被认为是一个单元的集合；如果网格被细化了（可能是以一种自适应的方式），那么这个集合就会被分组为一个细化等级的层次结构。除了单元之外，构成三角形的几何对象是单元的面（在三维中是单元的边）以及单元的顶点。请注意，我们有些滥用[1.x.0]这个词，因为deal.II只实现了由线性、四边形和六面体单元组成的三角形，三角形和四面体不被支持。
* 这个单元的集合由Triangulation类和派生类（如[2.x.1]和[2.x.2]）管理，它在内存中保存相关的数据，并提供接口来查询。你想在单元格上做的大多数事情都是在所有单元格上循环进行的。为此，Triangulation类提供了迭代器的概念（见[2.x.3]）：虽然实现方式不同，但它们的行为类似于单元格或面的指针，可以查询到单元格的几何属性以及相邻单元格或单元格的面等信息。
* 值得注意的是，Triangulation类只存储几何（即顶点和单元的位置）和网格的拓扑结构（即哪些单元是其他单元的邻居，等等）。它与网格上可能定义的有限元或自由度没有关系。这些功能由DoFHandler类（见[2.x.4]模块）执行，该类获得有限元空间的描述，并分配和管理顶点、面或单元的自由度，如有限元类所描述的。这种分离使得多个DoFHandler类可以同时在同一个网格上工作。
* 在整个计划中，deal.II中的三角计算与库中的各种其他部分交互。


* [1.x.1]
* [1.x.2]
* 有三种方法来创建网格。  [2.x.5] [2.x.6] 由GridGenerator类创建； [2.x.7] 从文件读取； [2.x.8] 手工创建。  [2.x.9]
* 对于第一种情况，GridGenerator类提供的函数可以自动生成最简单和最常见的几何图形。例如，矩形（或砖形）几何体以及圆形、球形或圆柱形都可以用这个类中的函数生成。大多数的教程程序都使用这种机制。
* 其次，可以使用GridIn类从输入文件中读入一些不同格式的网格。使用这个类，可以读取几万或十万个单元的网格，尽管这并不推荐：自适应有限元方法的威力只有在初始网格尽可能粗的情况下才能发挥出来，而且还有空间进行一系列的自适应细化步骤。如果初始网格已经太细了，那么在自适应网格细化能够发挥很大作用之前，就会耗尽内存或计算时间。尽管如此，GridIn类可以用于复杂的几何形状，或者用于与其他程序进行比较或交互，这些程序在网格上进行计算，然后通过这个类进行交换。 [2.x.10]教程程序展示了如何使用GridIn类。
* 第三种方式是手工创建网格，通过建立一个数据结构来描述三角形的顶点和单元。这种方法在中等复杂度的情况下非常有用，即无需借助网格生成器就可以手工建立网格，但该领域不属于GridIn类已经支持的领域。在这个方法中，所构建的数据结构被交给三角化类的create_triangulation()函数。[2.x.11]的教程程序展示了如何做到这一点。
*

* [1.x.3]
* 网格可以被写入一些不同格式的输出文件中。如果这涉及到在这个网格上获得的仿真结果，那么这将使用DataOut类（在[2.x.12]模块中有更详细的描述）来完成。另一方面，如果只需要将网格的几何结构和拓扑结构写入文件，GridOut类可以为你做到这一点。
*

* [1.x.4]
* GridTool类提供了各种作用于网格的功能。例如，这包括移动节点，拉伸或旋转整个三角形，计算域的直径，或将其细分为大致相同大小的块，以便进行并行计算。
* GridRefinement类实现了一系列的网格细化算法，基于给定的细化指标给其成员函数。
*

* [1.x.5]
* 除了上述内容外，本模块中还有相当数量的类只用于网格处理的内部数据结构中。它们一般都在内部命名空间，而不是为了在应用程序代码中使用。
*

* [2.x.13] Wolfgang Bangerth，1998-2006年


* [0.x.1]

include/deal.II-translator/A-headers/hp_0.txt
[0.x.0]*



* [2.x.0]
* 与hp-finite元素有关的类和函数。[2.x.1] 教程中概述了如何使用该命名空间中的类。[2.x.2]中给出了一个稍显奇特的应用。
* hp-命名空间实现了在deal.II中用于hp-framework的算法和数据结构。[2.x.3] "hp-paper "中给出了关于这些算法如何工作以及使用何种数据结构的细节概述。


* [0.x.1]*



* [2.x.4]
* 在hp-finite element方法的实现中，每个单元可能有不同的有限元与之关联。为了处理这个问题，[2.x.5]必须有一整套与之相关的有限元类。这个概念由[2.x.6]类代表。这种类型的对象作为容器，容纳了一整套的有限元对象。我们不在每个单元上存储指向有限元对象的指针，而只为每个单元存储一个索引，该索引标识了该单元应该使用的集合中的有限元对象。与给定单元相关的DoFHandler对象可以根据单元使用的有限元为每个单元分配自由度。
* 在单元上积分项时也会出现类似的情况：人们可能希望对不同的有限元使用不同的正交公式。例如，在我们使用Q1元素的单元上，QGauss(2)对象（即每个空间方向上有两个点的正交公式）可能就足够了，但在另一个使用Q3元素的单元上，这将导致积分不足，我们应该使用QGauss(4)公式。就像上面一样，存在一个类[2.x.7]，作为正交公式的集合。
* 最后，人们可能希望对具有不同阶数的单元的边界逼近使用不同阶数的有限元。[2.x.8]类允许这样做。
* 所有这三个类， [2.x.9] [2.x.10] 和 [2.x.11] 类，实现了与 [2.x.12] 非常相似的接口。它们有函数 [2.x.13] 来添加有限元、正交公式或映射到集合。他们有一个[2.x.14]函数，允许检索对集合中某个给定元素的引用。他们还有一个[2.x.15]函数可以返回集合中元素的数量。一些类，特别是持有有限元对象的类，也实现了其他特定的功能。
* 相似性超出了接口的范围。当向集合中添加一个元素时，所有的类都会创建一个参数的副本。这样就可以把一个临时对象传递给添加元素的函数。例如，下面的工作。


* [1.x.0]

* 这样一来，人们就可以把多项式度数为1到4的元素添加到集合中。没有必要保留所添加的对象：集合会对其进行复制，它不仅存储了一个指向给定有限元对象的指针。这个观察同样适用于其他集合类。
* 习惯上，在一个hp-finite element程序中，人们保留了具有相同数量元素的有限元和正交公式集合，一个集合中的每个元素都与另一个集合中的元素相匹配。这不是必须的，但它常常使编码变得简单得多。如果使用映射的集合，对[2.x.16]对象也是如此。
* 每当在hp-finite element程序中考虑p-adaptivity时，需要建立一个有限元的层次结构，以确定细化的后续有限元和粗化的前面的有限元。通常，这种层次结构考虑了有限元空间的嵌套方式：例如，[2.x.17]元素描述了[2.x.18]元素的一个子空间，因此进行[2.x.19]细化通常意味着使用更大（更精确）的有限元空间。换句话说，有限元的层次结构是通过考虑集合中的一些元素是其他元素的子空间还是超空间来建立的。
* 默认情况下，我们假设有限元是根据其多项式程度以升序存储的。如果元素的顺序不同，需要通过[2.x.20]成员函数向集合提供相应的层次结构。
*


* [2.x.21]


* [0.x.2]*
 一个用于实现hp-finite元素特定算法和数据结构的命名空间。
*


* [2.x.22]


* [0.x.3]

include/deal.II-translator/A-headers/instantiations_0.txt
[0.x.0]*
  [2.x.0]
* 复杂的类和函数模板的实例化在编译时间和磁盘空间方面都很昂贵。因此，我们尽可能地将模板的声明和实现分开，并确保只有在必要时才由编译器读取其实现。
* <tt>deal.II</tt>中的模板类可以分为三类，取决于可能的不同实例的数量。这三类将在下文中讨论。
*



*
* [2.x.1] Inst1 已知和固定数量的实例化
* 这些是具有模板参数的类，其值非常容易预测。典型的原型是


* [1.x.0]
*
* 在这里，我们在设计库的时候有少量的实例 ( [2.x.2] ) 已知。因此，这个类的成员函数被定义在源文件目录下的<tt>.cc</tt>文件中，我们在源文件中明确地将这些已知值实例化为模板。
* 从应用程序的角度来看，你实际看到的只是模板的声明。成员函数的实际实例化发生在库中，并且是在你编译库的时候完成的，而不是在你编译应用程序代码的时候。
* 对于这些类，为新的参数增加实例化需要改变库。然而，这很少需要，当然，除非你不满足于只在1d、2d或3d中计算。
*



*
* [2.x.3] Inst1a 可用实例
* 如果模板参数是<tt>dim</tt>，如果没有其他信息，可用的实例是为<tt>dim=1,2,3</tt>。
* 还有一些类的情况（不取决于空间维度），只支持一定的、少量的模板参数，并在库中提供显式实例。特别是，这包括所有在标量底层存储值类型上进行模板化的线性代数类：我们只支持 [2.x.4] ，以及在某些情况下支持 [2.x.5] 和 [2.x.6] 。
*



*
* [2.x.7] Inst2 一些实例化，其中大部分是已知的
* 这些是通常有少量实例的类模板，但可能需要额外的实例。因此，在库中提供了一组最可能的参数的实例化，但在一个特殊的头文件中提供了模板的实现，以便在有人想对一个未预见的参数进行实例化时，可以访问它。
* 这方面的典型例子是一些线性代数类，它们将向量类型作为模板参数。例如，它们将在库中被实例化为[2.x.8], [2.x.9], 和[2.x.10]。然而，它们也可以与其他矢量类型一起使用，如[2.x.11]和[2.x.12]，只要它们满足某些接口，包括不属于库的但可能在应用程序中定义的矢量类型。在这种情况下，应用程序可以通过手工实例化这些模板，如下一节所述。
*



*
* [2.x.13] Inst2c 创建新实例
* 从你的源文件中选择一个来提供所需的实例。假设你想让头文件<tt>XXXX</tt>中定义的类模板<tt>XX.h</tt>，用模板参数<tt>long double</tt>来实例化。那么，你的文件应该包含以下几行


* [1.x.1]

*



*
* [2.x.14] Inst2p提供的实例
* 与[2.x.15]节中的类一样，库中提供的实例通常以类似于这样的形式列在该类的文档中。


* [1.x.2]

*



*
* [2.x.16] Inst3 许多未知的实例
* 这些类，不存在合理的预先确定的实例集。因此，所有的成员定义都包含在头文件中，并在需要的地方被实例化。  一个例子是SmartPointer类模板，它几乎可以与任何模板参数一起使用。


* [0.x.1]

include/deal.II-translator/A-headers/integrators_0.txt
[0.x.0]*



* [2.x.0]
* 一个命名空间和函数的集合，简化了有限元空间上的表格和双线性表格的编码。这里收集了两个不同目的的函数：MeshWorker中对有限元网格的抽象积分，以及LocalIntegrators中对具体问题的单元和面项的积分的实际实现。
*

*
* [2.x.1] 关于编码惯例、类之间的关系以及实现细节的文档可以在本模块的命名空间文档中找到。
* [1.x.0]
* 当我们在有限元空间上积分一个函数或一个函数时，积分循环的结构总是相同的。我们有3到5个嵌套循环，从外到内。  [2.x.2] [2.x.3] 在所有单元上循环 [2.x.4] 可选择在所有面上循环以计算通量 [2.x.5] 在单元/面的所有正交点上循环 [2.x.6] 可选择在所有试验函数上循环以计算形式 [2.x.7] 可选择在所有试验函数上循环以计算双线性形式 [2.x.8]
* 这些循环自然分为两类，即计算单元和面的贡献（循环3到5），以及对网格对象的外循环，通常被称为 [2.x.9] 装配 [2.x.10] 。
* 在deal.II中对外循环的支持可以在命名空间MeshWorker中找到（见那里的文档）。为了支持单元和面的贡献（从现在开始称为局部贡献），deal.II提供了FEValuesBase和其派生类。虽然外循环是通用的（数据类型除外），但局部贡献的计算却取决于问题。因此，这里不可能有通用算法。不过，我们可以为此目的定义一个函数的通用接口，并提供一个本地积分器库供应用中使用。这些集合在命名空间LocalIntegrators中。


* [0.x.1]

include/deal.II-translator/A-headers/io_0.txt
[0.x.0]*



* [2.x.0]
* 这个模块收集了用于读写网格和数据的类。有两个子模块分别用于这些操作。


* [0.x.1]*



* [2.x.1]
* deal.II可以读取许多不同格式的网格。然而，它们都被限制在所谓的 "粗略的网格 "上，即没有细化层次，特别是没有悬挂节点的网格。GridIn类详细描述了支持哪些格式。
*此外，deal.II可以使用DataOutReader读取中间图形格式。这种格式被用作与模拟相关的数据之间的中间步骤，由DataOutBase类（或通过更多的派生类在 `ref输出模块'中描述）写入。DataOutReader类将这些数据读回来，然后它可以被转换为可视化程序支持的任何一种数据格式。
* 最后，ParameterHandler和MultipleParameterLoop类（以及相关的Patterns命名空间）被用来处理描述程序运行时参数的参数文件，这些参数不想在程序源中硬编码。
*

* [1.x.0]
* PathSearch类是输入处理中的一个辅助类。它被用来在一个目录列表中寻找一个文件，就像unix系统在[2.x.2]环境变量中列出的目录中寻找可执行文件一样。
*


* [2.x.3]


* [0.x.2]*



* [2.x.4]
* deal.II生成三种类型的输出：它可以将三角图/网格写成几种网格阅读器（包括deal.II本身的阅读器）可以理解的格式，它还可以创建用于数据可视化的输出。最后，它能以图形格式输出矩阵。
*

* [1.x.1]
* deal.II通过DataOutBase类支持大量流行的可视化格式，如OpenDX、gmv或gnuplot程序所使用的格式。支持的格式的完整列表列在DataOutBase类的文档中。
* DataOutBase类只负责在一些不同的可视化格式中实际写入一些中间格式。这个中间格式是由直接或间接从DataOutBase派生的类生成的。例如，DataOut类最常被用来从一个三角形、一个DoFHandler对象（将一个特定的有限元类与三角形联系起来）和一个或多个数据向量生成这种中间格式。DataOut类从每个单元创建中间数据，随后由DataOutBase类以某种最终格式写入。几乎所有的例子程序，从[2.x.5]开始，都使用这种方法来生成输出。
* DataOutFaces类是另一种从模拟数据创建中间格式的方法。然而，它不是从三角形的每个单元创建可视化数据，而是只为位于表面上的单元的所有面创建信息（尽管该类有一种方法可以覆盖选择哪些面应该被生成输出）。虽然这在2D中可能不是特别有趣（这些面只是线段），但在3D中，如果人们真正想知道的是域的形状或曲面上的一个变量的值，这往往是有帮助的。使用DataOutFaces类可以节省生成和存储所有内部单元的数据的工作，这对大型三维模拟来说是非常昂贵的。
* 第三个类，DataOutRotation类，允许采取一个二维模拟，并通过围绕给定的轴旋转二维领域来生成三维数据。这对于使用旋转对称性的模拟的可视化非常有用，例如，一个圆柱体。
* 最后，DataOutStack类允许在时空域中对与时间有关的模拟数据进行可视化：它收集每个时间步骤的结果，并在最后将所有这些信息一次性输出为一个时空文件。
*

* [1.x.2]
* Meshes，没有任何与之相关的数据向量，也可以用多种格式写入。这是通过GridOut类完成的，该类的文档中列出了支持的格式。
* 一些教程程序，特别是[2.x.6]、[2.x.7]、[2.x.8]、[2.x.9]、[2.x.10] b和[2.x.11]演示了GridOut类的使用。
*

* [1.x.3]
* 通过MatrixOut类，deal.II还可以以彩色或天际线图的形式给出矩阵的图形可视化。MatrixOut类使用DataOutBase进行输出。因此，矩阵可以用后一类支持的所有格式进行可视化。
*


* [2.x.12]


* [0.x.3]*



* [2.x.13]
* 除了提供图形输出格式的类（见[2.x.14]输出模块），deal.II还有一些类，以多种方式促进文本输出。它们被收集在本模块中。更多细节请参见这些类的文档。
*


* [2.x.15]


* [0.x.4]

include/deal.II-translator/A-headers/iterators_0.txt
[0.x.0]*



* [2.x.0] [2.x.1]。
* deal.II有几个类，在概念上被理解为meshes。除了明显的Triangulation之外，这些类还有，例如，DoFHandler和[2.x.2] 所有这些类都定义了一组迭代器，允许用户遍历整个网格，即构成网格的单元格、面、边等的集合，或其中的一部分。这些迭代器在某种意义上都是由TriaIteratorclass派生出来的。
* 基本上，TriaIterator的模板签名是
* [1.x.0]
*
* 从概念上讲，这个类型代表了类似于指向由[2.x.3]类所代表的对象的指针的东西。  通常情况下，你不会直接使用实际的类名，而是采用网状类所提供的一个类型定义，如<code>typename [2.x.4] 在进入这个问题之前，让我们先讨论一下迭代器的概念，然后再深入研究访问器的作用。
* 在C++中，迭代器就像指针一样，使用<tt>operator ++</tt>增加到最近的元素，使用<tt>operator减少到之前的元素。
*
* - </tt>。我们也可以用加法运算符<tt>it=it+n</tt>来跳转<tt>n</tt>元素，并相应地将一些元素向后移动。此外，按照标准模板库的传统，网格提供了成员函数<tt>begin()</tt>和<tt>end()</tt>，分别提供一个集合的第一个元素和一个超前的迭代器。由于有许多不同的迭代器可用，实际上有一整个系列的这类函数，比如<tt>begin_active()</tt>, <tt>begin_face()</tt>，等等。
* 就C++标准中定义的迭代器概念而言，deal.II网格迭代器是双向迭代器：它们可以被递增和递减，但是像<tt>it=it+n</tt>这样的操作需要的计算时间与<tt>n</tt>成正比，因为它被实现为一个<tt>n</tt>单独单位的递增序列。请注意，这与下一个更专业的迭代器概念，即随机访问迭代器形成了对比，对任意对象的访问只需要恒定时间，而不是线性时间。
*

*
* [2.x.5] IteratorsAndSets 迭代器作为指向对象集合的指针
* 如上所述，deal.II中的迭代器可以被认为是对构成网格的对象进行整体迭代。(这些对象是线、四边形和六边形，并由作为模板参数的Accessor类的类型表示给迭代器)。这表明我们可以将三角形视为单元格和其他对象的集合，这些单元格和其他对象通过某种数据结构联系在一起，就像链接列表是以线性方式连接对象的数据结构一样。
* 交易二中的三角形确实可以用这种方式来考虑。特别是，它们使用规则树之林的计算概念来存储它们的数据。这可以理解为如下几点。考虑到粗网格的单元有根；然后，如果这些粗网格的一个单元被细化，它将有2<sup>dim</sup>子，而这些子又可以，但不一定要有自己的2<sup>dim</sup>子，等等。这意味着，粗网中的每个细胞都可以被认为是二叉树（1d）、四叉树（2d）或八叉树（3d）的根。这些从粗网格单元中产生的树的集合构成了完整描述三角形的森林，包括所有的活动和非活动单元。特别是，活动单元是树中那些没有后代的终端节点，即没有进一步细化的单元。相应地，非活动单元对应于树中没有后裔的节点，即被进一步细化的单元。
* 三角形包含线（每个线可能有2个孩子）、四边形（每个四边形可能有4个孩子）和六边形（每个六边形没有或有8个孩子）的森林。根据维度的不同，这些对象也被称为单元或面。
* 迭代器在这种森林的元素上循环。通常的迭代器在森林的所有节点上循环，而活动迭代器以相同的顺序在元素上循环，但跳过所有非活动条目，因此只访问终端节点（即活动单元、面等）。遍历森林中的元素有很多方法，例如广度优先或深度优先。根据用于存储森林的数据结构的类型，有些方法比其他方法更有效。目前，在deal.II中，迭代器遍历森林的方式是广度优先。也就是说，迭代器首先访问粗网格的所有元素（单元格、面等），然后再转到直属层的所有元素，即粗网格对象的直属子节点；之后是粗网格的子节点，以此类推。然而，必须注意的是，程序不应该依赖这种特定的树形遍历顺序：这被认为是一个实现细节，可以在不同的版本之间改变，即使我们认为这在目前是一个不太可能的选择。
*

*
* [2.x.6] 迭代器的区别 不同种类的迭代器
* 迭代器有两个属性：它们指向什么（即Accessor模板参数的类型），以及它们所迭代的集合的确切定义。一般来说，迭代器总是被声明为
* [1.x.1]
*
* 这里，<tt>Kind</tt>决定了一个访问器需要有什么属性才能被这个迭代器访问（或者省略）。比如说。
* [1.x.2]
* 迭代所有构成网格的Accessor类型的对象（例如所有的单元格，无论它们是否被进一步细化并有子代），而
* [1.x.3]
* 因此，主动迭代器操作的是普通迭代器所操作的对象的一个子集，即那些拥有主动属性的对象。请注意，这与我们操作的对象的种类无关：所有有效的访问器类都必须为迭代器类提供一个方法来找出它们是否是活动的。
*（为了完整起见，让我们提到还有第三种迭代器。"rawiterators "也会遍历三角形中未使用的对象，但出于效率的考虑还是会被分配。用户代码不应该使用rawiterators，它们只为库的内部目的而存在）。)
* 一个对象是否处于活动状态可以被认为是一个 "谓词"：一个不是真就是假的属性。过滤的迭代器可以用来限制现有迭代器的范围。例如，你可以想象在那些[2.x.7]"活动单元 "的子集上进行迭代，这些单元的用户标志被设置或属于某个子域（对于一个给定的对象，这两个属性都是真或假）。
* 这是通过使用一个FilteredIterator&lt;BaseIterator&gt;类型的对象实现的，其中BaseIterator通常是上面讨论的标准迭代器之一。
* FilteredIterator在其构造函数中得到了一个额外的谓词，并将跳过所有该谓词评估为<tt>false</tt>的对象。在命名空间IteratorFilters中可以找到已经实现的谓词的集合。
*

*
* [2.x.8] 迭代器循环 迭代对象
* 所有相同类型的迭代器和迭代相同类型的几何对象都以相同的顺序遍历网格。以这个代码为例。
* [1.x.4]
*
* 这里，所有的迭代器总是指向同一个网格单元，即使<tt>DoFHandler</tt>和<tt>Triangulation</tt>是非常不同的类，即使DoFHandler处理的是不同的有限元：它们都以相同的顺序访问单元，区别只在于Accessor。如上所述，迭代器遍历对象森林的顺序实际上是明确的，但是应用程序不应该假定任何这样的顺序，而应该考虑这是库的实现细节。
* 与上面的例子相对应，在下面的片段中，迭代器遍历活动对象的顺序对所有迭代器都是一样的，与前面的例子不同的是，这里我们只考虑活动单元。
* [1.x.5]
*
*


* [2.x.9] IteratorsAccessors 访问器
* 迭代器就像指针一样：它们可以被递增和递减，但它们实际上是很笨的。它们的神奇之处在于它们指向一些有用的对象，在这里是指访问器。对于指针来说，它们指向的是一个存储了一些数据的实际对象。另一方面，deal.II迭代器，当被解除引用时，并不返回对一个实际对象的引用，而是返回一个知道如何获取代表单元格的数据的对象。一般来说，这个对象本身并不存储单元格的顶点或其邻居是什么。然而，它知道如何从Triangulation类为描述网格而设置的数组、表格和列表中获取这类信息。
* 访问表征一个单元的数据总是通过Accessor完成的，即表达式[2.x.10]允许访问这个Accessor的[1.x.6]属性。你可以从迭代器中查询的属性的例子有
* [1.x.7]
*
* 由于对迭代器的解引用产生了访问器对象，这些调用是Tomember函数 [2.x.11] , [2.x.12] 等。这些函数依次从存储这些数据的各种数据结构中找出相关的数据。这实际上是如何做到的，以及使用什么数据结构，并不是交易.II中应用的作者真正关心的。特别是，通过隐藏实际的数据结构，我们能够以一种有效的方式存储数据，而不一定是以一种使应用程序编写者容易访问或理解的方式。
*

*
* [2.x.13] IteratorsTypedefs 访问器的种类
* 根据你要访问的数据种类，有不同的访问器类。
*
* - TriaAccessor类为你提供数据，识别构成三角形的单元、面、线、四边形和六边形的几何属性，以及父子关系。
*
* - CellAccessor类是从TriaAccessor类派生出来的，用于对象具有完整维度的情况，即是一个单元，而不是例如一个单元的边界线。在这种情况下，关于一个网格的拓扑连接的额外信息可以从一个访问器中获得，比如请求指向一个单元的邻居的迭代器。
*
* - DoFAccessor类可以让你访问与单元格、面等相关的自由度信息；它对DoFHandler和[2.x.14]对象都是如此。请注意，DoFAccessor类派生于TriaAccessor或CellAccessor（取决于DoFAccessor是否指向全维度的对象），因此能够提供比其基类更高的信息集。此外，DoFAccessor类有两种风格，一种是访问细胞层面的自由度，另一种是访问活动细胞的活动度。
*
* - DoFCellAccessor类与DoFCellAccessor的目的和关系与CellAccessor与TriaAccessor的目的和关系相同。
* 除了查找成员文档，你通常不需要处理上面列出的实际类名。相反，我们使用由网格类Triangulation、DoFHandler和[2.x.15]提供的类型定义，以及生成此类对象的函数。
* <table border=1> <tr> <th>Class</th> <th>cell_iterator type</th> <th>function call</th> </tr> <tr> <th>Triangulation</th> <td>typename [2.x.16] [2.x.17] </tr> <tr> <th>DoFHandler</th> <td>typename [2.x.18] [2.x.19] </tr> <tr> [2.x.20] <td>typename [2.x.21] [2.x.22] </tr></table>
* Triangulation类支持用<tt>typename [2.x.23] 在单元格面之间进行迭代，该类型由[2.x.24] 返回。
* 活动迭代器有以下属性。
* <table border=1> <tr> <th>Class</th> <th>cell_iterator type</th> <th>function call</th> </tr> <tr> <th>Triangulation</th> <td>typename [2.x.25] [2.x.26] </tr> <tr> <th>DoFHandler</th> <td>typename [2.x.27] [2.x.28] </tr> <tr> [2.x.29] <td>typename [2.x.30] [2.x.31] </tr></table>
* Triangulation类也支持用<tt>typename [2.x.32] 遍历活动单元面，这是由[2.x.33] 返回的类型。
* 除了这些作用于单元和面的类型和调用（取决于维度的逻辑概念：一个单元在2D中是一个四边形，但在3D中是一个六面体），还有相应的类型和调用，如[2.x.34]，作用于独立于维度的几何对象line, quad, and hex。这些调用，就像上面那些调用一样，以活动和非活动的形式存在。
* 所有Mesh类中的类型定义都是在[2.x.34]中说明的。
*
* - [2.x.35] [2.x.36] 和 [2.x.37] 三角形迭代器的类。
*
* - 用于DoFHandler和[2.x.38]迭代器的[1.x.8]、[1.x.9]、[1.x.10]类。
* [2.x.39] IteratorAccessorInternals 迭代器和访问器的内部结构
* 迭代器，就像指针一样，就像它们指向一个实际的对象一样，但实际上它们所做的只是在被引用时返回一个访问器。访问器对象包含状态，也就是说，它知道它所代表的对象，例如，通过存储它属于哪个三角形，以及单元格中的级别和索引。因此，它能够访问与它所代表的单元（或面，或边）相对应的数据。
* 有一个过去-末端指针的表示，由TriaAccessor类中的成员变量[2.x.40]的特殊值表示。如果[2.x.41] [2.x.42] =0，那么该对象是有效的；如果[2.x.43] ==-1，那么该迭代器指向了终点；在所有其他情况下，该迭代器被认为是无效的。你可以通过调用[2.x.44] 函数来检查。
* 当向后运行时，过端迭代器也可用于比较迭代器与开始前的值。指向向量两端的迭代器之间是没有区别的。
* 单元的存储是基于层次结构的，因此上面提到的结构是有用的。然而，面不是按层次组织的，低维度的对象的访问器没有[2.x.45]成员变量。
*


* [2.x.46]
* [0.x.1]*



* [2.x.47]


* [2.x.48]


* [0.x.2]

include/deal.II-translator/A-headers/lac_0.txt
[0.x.0]*



* [2.x.0]
* 本模块包含涉及线性代数的类，即那些与矩阵、向量和线性系统的解有关的类。
* 各组类的描述可以在子模块中找到。
* 实现线性代数功能的文件在[2.x.1]子目录中，是[2.x.2]L[2.x.3]inear[2.x.4]A[2.x.5]lgebra[2.x.6]C[2.x.7]lasses的缩写。


* [0.x.1]

include/deal.II-translator/A-headers/laoperators_0.txt
[0.x.0]*



* [2.x.0]
* [1.x.0]
* deal.II包括支持以一种非常普遍的方式来描述线性变换。这是用LinearOperator类来完成的，就像[2.x.1]"MatrixType概念 "一样，它为[1.x.1]向量上的线性操作定义了一个最小的接口。
*


* [1.x.2]
*
* 因此，这样的对象可以作为所有[2.x.2]"迭代求解器 "类中的矩阵对象，或者作为[2.x.3]"预处理器 "使用。
* LinearOperator类的最大优势在于它为复杂的矩阵-向量操作提供了语法糖。作为一个例子，考虑操作 [2.x.4] ，其中 [2.x.5] 、 [2.x.6] 和 [2.x.7] 表示（可能不同的）稀疏矩阵对象。为了构造一个LinearOperator [2.x.8]，当应用于一个向量时执行上述计算，我们可以写道。


* [1.x.3]
* 现在，[2.x.9]可以作为一个矩阵对象用于进一步的计算。
* linear_operator()函数可以用来将一个普通的矩阵或预处理对象包装成一个LinearOperator。线性算子可以用transpose_operator()进行转置，或者通过使用inverse_operator()与迭代求解器一起进行反转。
* 对于LinearOperator类型的对象，所有的向量空间操作，即加减法、标量乘法和组合（兼容的线性算子）都被实现。


* [1.x.4]
*
* block_operator()和block_diagonal_operator()提供了对单个线性算子的进一步封装，使其成为封锁的线性算子变体。
* [2.x.10] 教程中有一个关于LinearOperator类的详细使用例子。
*

*
* [2.x.11] 如下所述，当使用LinearOperator作为[2.x.12]时，会在幕后生成PackagedOperation类实例。因此，用户程序必须包括这两个类的头文件才能编译成功。为了更容易决定在什么情况下包含哪些头文件，并防止隐藏的与模板相关的编译器错误，所有与LinearOperator相关的头文件都被归入了`<deal.II/lac/linear_operator_tools.h>`头文件。
* [1.x.5]
* 通过[2.x.13]将LinearOperator对象应用于一个向量，会产生一个PackagedOperation对象来存储这个计算。
* PackagedOperation类允许对涉及向量和线性运算符的表达式进行懒惰的评估。这是通过存储计算表达式来实现的，只有当对象被隐含地转换为向量对象，或者[2.x.14]（或[2.x.15]被手动调用时才执行计算。这就避免了不必要的中间结果的临时存储。
* 作为一个例子，考虑多个向量的相加。


* [1.x.6]
* 转换PackagedOperation <code>a + b
*
* - c + d</code>到一个向量的结果是，代码相当于以下代码


* [1.x.7]
* 这避免了任何中间存储。作为第二个例子（涉及一个LinearOperator对象），考虑计算一个残差 [2.x.16] 。
*


* [1.x.8]
* 这里，表达式<code>b
*
* - op_a x</code>的结果又是一个PackagedOperation类型的对象，它存储了应该使用两个向量和线性运算符执行的[1.x.9]。将表达式转换为矢量（就像这里发生的对矢量[2.x.17]的赋值一样），执行计算（见下面的注释）。
*

*
* [2.x.18] 计算表达式的懒惰评估必然涉及对底层向量和矩阵对象的引用。例如，创建一个[2.x.19]对象


* [1.x.10]
* 存储残差的计算表达式，引用向量 [2.x.20] 。在这一点上，它不进行任何计算。特别是，如果[2.x.21]或[2.x.22]被改变[1.x.11]，[2.x.23]的创建，每一个后续的表达式的评估都用新的值进行。


* [1.x.12]
* 因此，作为一种保障，如果你想马上计算一个表达式的结果，总是明确地在左边使用一个向量类型（而不是[2.x.24] ）。


* [1.x.13]

*


* [2.x.25] [2.x.26] 教程中有一个PackagedOperation类的详细使用例子。
*

*
* [2.x.27] LinearOperator的许多用例导致中间表达式需要一个PackagedOperation。为了一次性包含所有必要的头文件，可以考虑使用


* [1.x.14]

*




* [2.x.28]


* [2.x.29]


* [0.x.1]

include/deal.II-translator/A-headers/main_0.txt
[0.x.0]*
  [2.x.0]
* 这是deal.II类和函数文档的主要起始页。关于其他方面的文档，如构建系统，可以在其他地方找到。此外，还有[1.x.0]。
* deal.II库中的许多类可以被分组为模块（见[1.x.1]或本页面顶部菜单中的相应条目）。这些模块围绕着任何有限元程序的构建块而形成。下面的点击图给出了deal.II中主要类组的交互方式的概要，下面有更详细的描述（灰色方框表示可选的外部库的子集，灰色椭圆表示可选的外部应用程序的子集，deal.II可以与之交互）。
*


* [1.x.2]
* 这些组在教程程序中都有涉及，在[2.x.1]中首先概述了它们的组合方式。下面是这个组的分类指南，以及与每个组有关的文档链接。
* [2.x.2] [2.x.3] [1.x.3]。三角形是单元及其低维边界对象的集合。单元是参考超立方体[0,1]<sup>dim</sup>在[2.x.4]模块中的适当映射下的图像。
* 三角化存储了网格的几何和拓扑属性：单元如何连接以及它们的顶点在哪里。三角化不知道任何关于你可能想在这个网格上使用的有限元的信息，三角化甚至不知道任何关于其单元形状的信息：在2D中它只知道一个单元有4个面（线）和4个顶点（在3D中它有6个面（四边形）、12条线和8个顶点），但其他的一切都由映射类来定义。
* 三角形的属性和数据几乎都是通过所有单元的循环来查询的，可能还会查询每个单元的所有面。因此，关于网格的大部分知识都隐藏在[2.x.5]迭代器的后面，即类似指针的结构，可以从一个单元迭代到下一个单元，并且可以询问它目前指向的单元的信息。
* 描述三角形和单元格的类位于[2.x.6]模块中，并有相关文档。迭代器在[2.x.7]模块中描述。
* [2.x.8] [1.x.4]:矩阵描述了单元格的形状，更广泛地说，描述了要解决方程的领域的几何形状。它们使用微分几何的语言。更多信息可以在 [2.x.9] 中找到。
* [2.x.10] [1.x.5] 。有限元类描述了定义在单元格上的有限元空间的属性。这包括，例如，有多少自由度位于顶点，在线上，或在单元的内部。除此之外，有限元类当然还必须提供单元格上各点的单个形状函数的值和梯度。
* 有限元类在[2.x.11]模块中描述。
* [2.x.12] [1.x.6]:与有限元一样，正交对象是在单元格上定义的。它们只描述单元格上正交点的位置，以及其上正交点的权重。
* 描述特定正交公式的类的文档可以在[2.x.13]模块中找到。
* [2.x.14] [1.x.7]: %DoFHandler对象是三角形和有限元的汇合点：有限元类描述了每个顶点、线条或单元需要多少自由度，DoFHandler类分配了这个空间，使三角形的每个顶点、线条或单元有正确的数量。它也给它们一个全局的编号。
* 一个不同的观点是这样的。网格和有限元描述了我们寻求离散解的有限维空间[2.x.15]的抽象属性，而%DoFHandler类列举了这个空间的具体基础，因此我们可以通过一个有序的系数集[2.x.17]来表示离散解。
* 就像三角化对象一样，对DoFHandlers的大多数操作都是通过在所有单元上循环，并对每个单元或其中的一个子集进行操作。因此，这两个类的接口相当相似：它们允许获得第一个和最后一个单元（或面，或线等）的迭代器，并通过这些迭代器提供信息。从这些迭代器中可以得到的信息是已经可以从三角形迭代器中得到的几何和拓扑信息（它们实际上是派生类），以及诸如当前单元上的自由度的全局数字。我们也可以要求一个迭代器从一个数据向量中提取与当前单元格上的自由度相对应的值，该向量存储了与三角形相关的所有自由度的值。
* 值得注意的是，就像三角剖分一样，DoFHandler类不知道任何关于从单元格到其单个单元格的映射。它也不知道对应于它所管理的自由度的形状函数：它所知道的是，例如，每个顶点有2个自由度，每个单元格内部有4个。除了它们存在的事实之外，它们的具体细节与DoFHandler类无关。
* DoFHandler类及其关联物在[2.x.18] dofs模块中描述。此外，还有一些专门的版本可以处理多级和hp-discretizations。这些都在[2.x.19]和[2.x.20]模块中描述。有限元方法经常意味着对自由度的约束，例如对悬挂节点或适用边界条件的节点的约束；处理这种约束在[2.x.21]模块中描述。
* [2.x.22] [1.x.8]。有限元程序的下一步是，人们希望利用有限元的形状函数和正交规则定义的正交点，计算三角形的每个单元上的矩阵和右手条目或其他数量。为此，有必要将形状函数、正交点和正交权重从单元格映射到三角形的每个单元。这不是由映射和派生类直接完成的，而是由映射和派生类来促进的：它们描述了如何将点从单位空间映射到实空间并返回，以及提供这个导数的梯度和雅各布决定因素。
* 这些类都在[2.x.23]模块中描述。
* [2.x.24] [1.x.9]。下一步是实际取一个有限元，在映射到实数单元时，在正交公式定义的点上评估其形状函数及其梯度。这就是FEValues类和兄弟姐妹的领域：从某种意义上说，它们提供了一个有限元函数空间的点式视图。
* 这似乎有局限性：在数学分析中，我们总是以单元或单元面的积分来写公式，涉及到有限元形状函数。因此，人们会认为有必要将有限元空间描述为连续空间。然而，在实践中，这是没有必要的：在实际计算中，所有的积分都被使用正交公式的近似值所取代，因此真正需要的是在域内有限数量的给定位置评估形状函数的能力。FEValues类正是提供了这种信息。给定有限元、正交和映射对象，它们计算连续函数空间（相对于离散的，而不是相对于不连续的）对离散的点的限制。
* 有许多对象可以做到这一点。FEValues用于对单元格进行评估，FEFaceValues用于对单元格的面进行评估，FESubfaceValues用于对单元格的部分面进行评估。所有这些类都在[2.x.25]模块中描述。
* [2.x.26] [1.x.10]。如果知道如何使用FEValues和朋友们评估单个单元上的形状函数的值和梯度，并且知道如何使用DoFHandler迭代器获得单元上自由度的全局数，那么下一步就是使用问题的双线性形式来组合线性系统的系统矩阵（和右手边）。然后我们将从这个线性系统中确定我们问题的解决方案。
* 要做到这一点，我们需要有存储和管理矩阵和向量条目的类。deal.II为此提供了一整套的类，以及与其他提供类似功能的软件包的接口。这方面的文档可以在[2.x.27]模块中找到。
* [2.x.28] [1.x.11]:为了确定一个有限维度的线性方程组的解，人们需要线性求解器。在有限元应用中，它们经常是迭代式的，但有时也可能要使用直接或稀疏的直接求解器。deal.II有相当多的此类求解器。它们被记录在[2.x.29]模块中。
* [2.x.30] [1.x.12]。最后，一旦在给定的三角形上获得了有限元问题的解，人们往往希望用可视化程序对其进行后处理。这个库本身并不做可视化处理，而是生成各种图形格式的输出文件，这些格式可以被广泛使用的可视化工具所理解。
* 在[2.x.31]输出模块中给出了关于这样做的类的描述。  [2.x.32]
* 此外，deal.II还有一些超越这里所列举的类组。它们涉及到上面介绍的层次结构中更细化的概念，或者涉及到诸如处理输入和输出这样的切身问题，这些问题不一定专门针对有限元程序，但也出现在那里。这些类都列在类和命名空间的视图中，可以从本页顶部的菜单栏中找到，并且也被分组为自己的模块（见本页顶部的[1.x.13]）。
* 我们提供了Doxygen标签文件，供那些想把应用程序的文档直接链接到deal.II在线文档的用户使用。该标签文件在[1.x.14]。对于deal.II的每个版本，它都驻留在Doxygen参考文档的正上方的目录中。为了使用这个标签文件，你必须把它下载到一个Doxygen可以找到的地方。之后，在你的Doxygen选项文件中找到[2.x.33]这个键，然后写一些类似于<pre> TAGFILES = deal.tag=http://www.dealii.org/X.Y.Z/doxygen/deal.II </pre> 其中[2.x.34]指的是你要链接的版本。请确保你使用匹配的标签文件。理论上，你也可以针对deal.II的发展中的修订版进行链接，但你必须担心，如果deal.II的结构发生变化，你的链接可能会变得无效。


* [0.x.1]

include/deal.II-translator/A-headers/manifold_0.txt
[0.x.0]*



* [2.x.0]
* [1.x.0]
* 本模块中的类涉及到流形的描述，在流形中，一个三角形所描述的域生活在其中。这种流形描述在一些情况下是必要的。
* [2.x.1]
* [2.x.2] 网格细化。每当一个单元被细化时，有必要在三角网中引入新的顶点。在最简单的情况下，我们假设构成三角网的对象是直线段、双线性曲面或三线性体。然后，下一个顶点被简单地放到旧顶点的中间（这里的 "中间 "是指先前存在的顶点位置的一个合适的平均值）。这是Triangulation类的默认行为，并由FlatManifold类描述。
* 另一方面，如果处理弯曲的几何体，或者需要在某些方向上进行更密集细化的几何体，这并不是合适的做法。因此，从Manifold基类派生的类描述了一个域的几何形状。然后，我们可以使用[2.x.3]函数将一个从该基类派生的类对象附加到三角形对象上，并将其与manifold_id相关联（见[2.x.4]使用[2.x.5]函数将此manifold_id用于三角形的单元、面或边上，这些单元、面或边应由该manifold描述，然后三角形将询问manifold对象在网格细化时应将新顶点定位在哪里。已经有几个类支持最常见的几何形状，例如，CylindricalManifold或PolarManifold，它们分别代表以圆柱坐标或极坐标描述空间时获得的几何形状。默认情况下，所有使用GridGenerator命名空间中的函数生成的弯曲几何体都会将正确的Manifold对象附加到域的弯曲部分。
* [2.x.6] 集成。当使用高阶有限元方法时，经常需要使用边界的曲线近似，而不是直线近似来计算单元项（如单元对线性系统的矩阵和右手边的贡献）。这种曲线元素的实际实现发生在Mapping类中（见[2.x.7]模块），然而它从这里描述的类中获得关于域的边界信息。当然，在整合边界项时也是如此（例如，不均匀的诺伊曼边界条件）。
* [2.x.8] 非零维的域。在Triangulation被嵌入高维空间的情况下，即只要Triangulation类的第二个模板参数被明确指定且大于第一个模板参数（例子见[2.x.9]），流形描述对象不仅可以作为描述域的边界的几何形状的工具，而且可以作为描述域本身的工具，以防域是一个事实上是弯曲的流形。在这种情况下，人们可以使用[2.x.10]函数来指示在细化曲线时，或在使用高阶映射计算积分时，应使用何种流形描述。
* [2.x.11] 许多其他的例子，以及在deal.II中实现的许多理论基础，在[2.x.12] "几何学论文 "中提供。
* 在deal.II中，流形被看作是一个点的集合，同时还有一个点与点之间距离的概念（在流形上）。新的点通常是通过在流形上提供一个局部坐标系来获得的，识别局部坐标系中的现有点（使用局部地图将其拉回，以获得其局部坐标），通过现有点的加权和找到局部坐标系中的新点，并将该点在实空间中转换回来（使用局部地图将其向前推）。实现这一机制的主要类是ChartManifold类，这也是用户可能为复杂的几何形状而重载的类。
* 虽然这个过程在大多数感兴趣的情况下是非琐碎的，但对于大多数琐碎的几何体，如圆柱体、球体或壳体，deal.II提供了合理的实现。更复杂的例子可以用[2.x.13]和[2.x.14]中的技术来描述。
* 从总体上看，这个模块的类与库中的其他各种部分相互作用。


* [1.x.1]


* [1.x.2]
* [2.x.15]已经提供了一个处理曲面几何体的简单例子，尽管那里没有详细说明。默认情况下，GridGenerator中的函数会在需要时将流形附加到网格上。在下面的每个代码片段中，我们都会调用[2.x.16]来移除这些流形，并在例子本身中处理所有的流形附件，以使流形选择的影响清晰。
* 考虑一下那里显示的[2.x.17]函数的这个小变化，我们只是简单地将[1.x.3]单元格细化了几次。


* [1.x.4]
* 这段代码导致了一个看起来像这样的网格。
* [2.x.18]
* 我们的意图是要得到一个类似于环形的网格。然而，由于我们没有对三角形进行描述，所发生的情况是，我们从我们告诉[2.x.19]要创建的圆周方向的10个粗单元开始，然后每个单元被全局细化3次。每次细化都需要一个新的顶点，它被放在现有顶点的中间，而不考虑我们可能的意图（但在代码中忽略了描述）。
* 这很容易补救。考虑一下这段代码。


* [1.x.5]
* 这个代码更好，产生了以下的网格。
* [2.x.20]
* 这个网格看起来更好，它忠实地再现了域的圆形内边界和外边界。然而，仍然可以在切线上发现20个结点。它们是由于每次细化单元时，内部线的新顶点只是被放置在现有线的中间（边界线的处理方式不同，因为我们附加了一个流形对象）。在有10个单元的第一次细化中，我们得到了改进的点，因为根据下面关于混合不同流形的描述，两个外部边界都提供了一个弯曲的描述。换句话说，第一次细化后的新点最终出现在可能处于直线的几何中间的地方，但不在围绕中心的圆上。
* 这一点可以通过分配流形描述来弥补，不仅是沿边界的线，还有径向的线和单元（反过来，这些线会继承到网格细化后产生的新线）。这正是[2.x.21]的默认做法。为了演示，我们禁用默认的Manifold行为，然后手动复制它。


* [1.x.6]
* 这导致了以下的网状结构。
* [2.x.22]
* 那么，这有什么关系呢？毕竟，最后两个网格描述的是完全相同的领域，而且我们知道，无论选择什么样的单元，只要最大的单元的直径为零，在网格细化后，我们就能得到正确的解。
* 这个问题有两个答案。首先，求解偏微分方程到一定精度的数值努力通常取决于单元格的[1.x.7]，因为[2.x.24]形式的误差估计中的常数[2.x.23]取决于所有单元格中最小周长与最大内含圆的半径的最大比率等因素（对于三角形；或者对于其他类型的单元格的适当概括）。因此，创建具有尽可能好的单元的网格是值得的。可以说，对于上面所示的网格来说，这并不是一个问题，但有时却是一个问题。例如，考虑一下下面的代码和网格。


* [1.x.8]
*
* [2.x.25]
* 这里，我们在开始时只创建了三个圆周单元，并对它们进行细化，得到了所示的网格。很明显，尽管第一次细化将新的点放在中间，但我们有长宽比不好的单元。
* 如果我们进一步推动，从半径0.8和1.0之间的更薄的圆周的粗略网格开始，并且只有三个单元（这在这里可能是不合适的，因为我们知道这是不够的，但对于在网格生成器中生成的复杂几何形状来说，可能也是不可能避免的），我们观察到以下情况。
*


* [1.x.9]
*
* [2.x.26]
* 这个网格在细化后既没有正确的几何形状，也没有所有单元的正面积，这对于有限元方法的工作是必要的。然而，即使从这样一个不合适的网格开始，我们也可以通过使用上述相同的代码，不仅给边界，而且给内部单元和边缘附加一个合适的几何描述，使事情顺利进行。


* [1.x.10]
*
* [2.x.27]
* 在这最后一个例子中，我们终于让GridGenerator完成了它的工作，我们保留了默认的流形配置，即每个单元和面都是SphericalManifold。
* 在这里，即使从一个初始的、选择不当的网格开始，也保留了我们的能力，可以充分地将网格细化为一个对我们有利的网格。这个例子可能是在这里制造的，但它是相关的，例如在[2.x.28]产生的3D背景下（见这个函数的文档）。它也与[2.x.29]"关于扭曲细胞的词汇条目 "中讨论的案例有关。
* [2.x.30] [2.x.31] "关于流形指标的词汇条目"。
* [1.x.11]
* 在现实应用中，经常发生需要将不同的流形描述结合起来的情况。最简单的情况是，一个曲面描述只适用于边界，而不适用于计算域的内部。一个球的流形描述也属于这种情况，因为它需要将圆形部分的球形流形与域中心的直角描述结合起来，而球形流形在这里是无效的。
* 一般来说，在deal.II中混合不同的流形描述的过程是通过所谓的transfinite插值实现的。它在二维中的公式，例如，在[1.x.12]上有描述。给定图表上的一个点[2.x.32]，该点在实空间中的图像由以下公式给出


* [1.x.13]
* 其中[2.x.33]表示限定图像空间的四个顶点，[2.x.34]是描述单元格线条的四条曲线。
* 如果我们想根据流形找到单元格的中心（这也是在细化网格时使用的），图表是单元格[2.x.35]，我们想在点[2.x.36]上评估这个公式。在这种情况下，[2.x.37]是下层面的中点位置（在deal.II的排序中以2为索引），它是由自己的流形衍生出来的，[2.x.38]是上层面的中点位置（在deal.II中以3为索引），[2.x.39]是左边面的中点（以0为索引），而[2.x.40]是右边面的中点。在这个公式中，面中的四个中点的权重相当于[2.x.41]，四个顶点的权重相当于[2.x.42]。这些权重乍一看很奇怪，因为顶点的权重是负的，但这个机制是我们想要的。如果一个单元格在两个相对的面上有弯曲的描述，但在另外两个面上有直线，顶点中[2.x.43]的负权重与径向的两条直线的中心平衡，得到权重[2.x.44]。因此，在曲线方向的两个中心点上取平均值，正好把新点放在中间。
* 在三个空间维度上，面的中点的权重为[2.x.45]，线的中点的权重为[2.x.46]，顶点的权重为[2.x.47]，再次平衡了不同的实体。如果一个单元格的所有周围都是直的，那么这个公式就简化为八个顶点中每个顶点的明显权重[2.x.48]。
* 在MappingQGeneric类中，通过评估各自Gauss-Lobatto点的边界曲线[2.x.49]并将其与上述公式相结合，实现了这一概念对曲线单元的多项式表示的支持点的泛化，即Gauss-Lobatto正交的节点。这些权重已经被验证为产生最佳收敛率 [2.x.50] ，也适用于非常高的多项式度数，例如 [2.x.51] 。
* 在文献中，也使用了其他的边界描述。在9.0版本之前，deal.II使用了一种叫做拉普拉斯平滑的东西，其中应用于圆周上的节点以获得内部节点的位置的权重是通过解决单位元素上的拉普拉斯方程来确定的。然而，这导致边界层接近于曲线描述，即从单元到实心单元的映射的高导数的奇异性。
* 如果从弯曲的边界描述到内部的直线描述的过渡做错了，通常不可能达到高阶收敛率。例如，单个单元内的拉普拉斯平滑会导致从参考单元到实数单元的映射的第四导数出现奇点，将边界处单元的收敛率限制在3（如果在二维测量全局L2误差，则为3.5）。其他更粗糙的策略，比如完全忽略两个不同流形的存在，只是简单地计算直坐标系中高阶映射的附加点，会导致更差的收敛率。另一方面，目前在deal.II中的实现，在这方面已经得到了广泛的验证，应该表现得很好。
* 将曲线边界表示与平面内部表示相混合的不良策略显然也反映了网格质量。例如，在上述只有3个圆周单元的情况下，导致以下的网格是用拉普拉斯流形平滑，而不是像deal.II中实现的从边界插值。
* [2.x.52]
* 为了使用一个更实际的例子，考虑对一个球的细化，在球面上附加一个SphericalManifold。拉普拉斯类型的平滑给出了以下相当差的网格。
* [2.x.53]
* 如果我们改用从转折插值得到的权重，情况就会有很大的改善。
* [2.x.54]
* 当然，我们可以通过将TransfiniteInterpolationManifold应用于整个域（除了连接SphericalManifold的边界）来得到更好的网格，如该类中的数字所示，但原则上，在deal.II中实现的网格平滑已经和单从边界描述得到的一样好。
*


* [2.x.55] [2.x.56] Luca Heltai, 2013, Martin Kronbichler, 2017


* [0.x.1]

include/deal.II-translator/A-headers/matrices_0.txt
[0.x.0]*



* [2.x.0]
* deal.II带有许多不同的矩阵类，是为使用矩阵的各种目的而定制的。例如，有完整的矩阵、使用不同存储方案的稀疏矩阵、由单个块组成的矩阵，以及作为其他线性代数类接口实现的矩阵。在可能的情况下，所有这些实现都共享一个共同的接口，该接口至少包含编写迭代线性求解器所需的操作（见[2.x.1]），但也包含从矩阵中读取和写入的元素访问。
* 这个模块被分成了不同的部分。  [2.x.2] "基本矩阵 "包含所有实际存储条目的矩阵类。  [2.x.3] "派生矩阵"，另一方面，只使用基本矩阵，但对它们实现了某些操作。例如，TransposeMatrix提供了一个矩阵向量乘法，就像底层矩阵被转置了一样，而实际上并没有存储转置的矩阵。
* [2.x.4]也是矩阵类，因为它们对向量进行线性运算。
*


* [2.x.5]


* [0.x.1]*



* [2.x.6]
* 这些是由deal.II提供的实际矩阵类。可以在其中存储数值并检索它们。此外，它们还提供了线性求解器所需的全部接口（见[2.x.7] ）。
* 在这组矩阵中，有完整的矩阵、不同的稀疏矩阵和块状矩阵。此外，其他线性代数库（例如PETScWrappers）的接口中的一些类是矩阵。
* 大多数deal.II稀疏矩阵类与它们的稀疏度模式分开，以使存储具有相同稀疏度模式的几个矩阵更有效率。更多信息见[2.x.8]。
*


* [2.x.9]


* [0.x.2]*



* [2.x.10]
* 这些矩阵是建立在基本矩阵之上的。它们使用[2.x.11]"MatrixType概念 "所定义的接口进行特殊操作。
*


* [2.x.12]


* [0.x.3]

include/deal.II-translator/A-headers/matrixfree_0.txt
[0.x.0]*



* [2.x.0]
* 本模块描述了deal.II中的无矩阵基础设施。以下是deal.II中主要的类群与无矩阵基础设施互动的概要，可点击图表，下面有更详细的描述。
*


* [1.x.0]
* 从本质上讲，FEEvaluation类在MatrixFree的数据存储之上提供的框架是一个专门的运算符评估框架。它目前只与库中提供的具有特殊结构的元素子集兼容，即那些基础可以被描述为一维多项式的张量乘积的元素。这为向量条目和正交点的值或梯度之间的有效转换提供了机会，这种技术被称为和因子化。这种技术起源于谱元界，由Orszag在1980年的工作开始。虽然这种技术最初不过是一种装配向量（或矩阵）的特殊技术，比通用车辆FEValues更快，但它的效率使得在迭代求解器中使用这些积分设施直接评估矩阵-向量产品成为可能，而不是先装配一个矩阵，然后用这个矩阵做矩阵-向量产品。这一步最初是非直观的，与许多人在数学和计算机科学教育中所接受的教育相违背，包括大多数deal.II的开发者，因为一次又一次地重新计算积分，而不是使用预先计算的数据，似乎是一种浪费。然而，正如教程程序[2.x.1]、[2.x.2]、[2.x.3]、[2.x.4]和[2.x.5]所示，这些概念在现代计算机架构上通常比传统算法更出色。
*有利于无矩阵计算的两个主要原因如下。  [2.x.6] [2.x.7] 无矩阵方法跳过了大的全局稀疏矩阵的存储，并在飞行中计算基础的弱形式。由于内存传输，即从RAM内存中读取数据的速度，是基于矩阵的计算的瓶颈，而不是使用这些数据所做的实际算术，因此，一个读取数据较少的无矩阵评估，即使做了较多的计算，也会有优势。这个概念是建立在计算机架构的一个趋势之上的，这个趋势最好的描述就是[1.x.1]，说的是计算性能比内存性能增长得更快。因此，一定程度的算术运算基本上是免费的，而且这个份额在过去20年里变得更大。除了在显式时间积分中的经典使用外，它还使这种激进的算法转换成为迭代求解器的矩阵-向量积的无矩阵实现。当然，实现必须是高效的，而且不能有多余的计算量，以使其在总体上获胜。deal.II库使用SIMD矢量化和基于多项式程度模板的高度优化内核来实现这一目标。为了提供一个视角，二次元FE_Q的稀疏矩阵-向量乘积曾经与2005-2007年左右设计的处理器（如奔腾4或AMD Opteron Barcelona，每个芯片有2-4个内核）上的无矩阵实现速度相当。到2018年，无矩阵评估的速度大约是8倍（在英特尔Skylake服务器上测量，14个核心）。  [2.x.8] 无矩阵方法随着度数的增加，每个自由度的复杂度更好，这是由于和因子化的原因。对于无矩阵方案来说，每个自由度的工作随着[2.x.9]度的增加而增加，而对于基于矩阵的方法来说，它随着[2.x.11]度的增加而增加。这使高阶方案具有优势。在无矩阵评估中一个特别好的特点是[2.x.12]项经常占主导地位，所以看起来高阶方法在评估时间上和低阶方法一样快，当他们有相同的自由度数量时。对于deal.II中的实现，最佳吞吐量通常是在3到6的多项式度数之间实现的。  [2.x.13]
* 总而言之，无矩阵计算是高阶元素（高阶意味着除了线性形状函数之外的一切）的方法，并用于显式时间步进（[2.x.14]）或迭代求解器，其中也可以用无矩阵的方式进行预处理，正如[2.x.15]和[2.x.16]教程程序中所展示的。
* [1.x.2]
* 顶层接口由FEEvaluation类提供，其中还包含了对不同用例的广泛描述。
* [1.x.3]
* FEEvaluation类派生于FEEvaluationAccess类，后者又继承于FEEvaluationBase。FEEvaluation类本身不仅对维度、分量的数量和数字类型（如双数或浮点数）进行模板化，而且对多项式程度和每个空间方向上的正交点数量进行模板化。这些信息用于将和分解中的循环长度传递给各自的内核（见`tensor_product_kernels.h`和`evaluation_kernels.h`）并确保最佳效率。所有访问向量或提供访问单个正交点的数据字段的方法都继承自FEEvaluationAccess。
* FEEvaluationAccess类的动机是允许根据分量的多少，对内插解字段的值和梯度访问进行专业化。而基类FEEvaluationBase将梯度作为一个 "张量<1,n_components,张量<1,dim,矢量数组<Number>>"返回，外张量经过组件，内张量经过梯度的`dim'组件。对于一个标量场，即`n_components=1'，我们可以跳过外张量，简单地使用`Tensor<1,dim,VectorizedArray<Number>'作为梯度类型。同样地，对于一个`n_components=dim'的系统，梯度的适当格式是`Tensor<2,dim,VectorizedArray<Number>'。
* [1.x.4]
* 面积分，如连续有限元中的不均匀诺伊曼条件或一大类非连续Galerkin方案，除了单元积分外，还需要评估面的正交点上的量。面评价的设施大多与FEEvaluation共享，即FEFaceEvaluation也继承自FEEvaluationAccess。所有关于自由度和形状函数的数据字段都可以重复使用，后者是因为所有信息都由一维形状数据组成。然而，关于映射数据，由于数据是 "structdim=dim-1 "的，所以使用了一个特殊化。因此，FEEvaluationAccess和FEEvaluationBase被赋予一个模板参数`is_face`，以分别持有指向单元和面的映射信息的指针。除了用[2.x.17]访问函数值或用[2.x.18]访问梯度外，面评估器还可以用[2.x.19]访问法向量和一个专门的字段[2.x.20]，返回解场对面的法向导数。这个量被计算为梯度（在实空间）乘以法向量。梯度和法向量的组合是许多（简单的）二阶椭圆方程的典型特征，例如用内部惩罚法对拉普拉斯进行离散化。如果不需要单独的梯度，联合操作大大减少了数据访问，因为每个正交点只需要`dim`数据条目`normal Jacobian`，而单独访问时需要`dim^2`字段的Jacobian和`dim`字段的normal。
* 计算面积分的一个重要优化是考虑必须访问的矢量数据量，以评估面的积分。例如，想想FE_DGQ的情况，即拉格朗日多项式，其部分节点在元素边界上。对于函数值的评估，只有[2.x.21]自由度通过非零基函数做出贡献，而其余的[2.x.22]基函数在该边界上评估为零。由于矢量访问是无矩阵计算的瓶颈之一，对矢量的访问应该限制在有趣的条目上。为了实现这种设置，方法[2.x.23]（和[2.x.24]的积分等价物）将矢量访问与插值到正交点相结合。存在两种特殊情况，包括前面提到的 "非零 "值的情况，它被存储为字段[2.x.25]。对于在一个面上只有选定数量的基函数的值和第一导数评估为非零的情况，也可以有类似的属性。相关的元素类型是FE_DGQHermite，决定存储在属性[2.x.26]中，是否可以使用这样的优化内核的决定是在[2.x.27]和[2.x.28]中自动做出的。为每个积分任务做这个决定似乎效率不高，但最终这是一个单一的`if`语句（条件跳跃），对于现代CPU来说很容易预测，因为决定在一个积分循环中总是相同。(人们只需支付一定程度上增加的编译时间，因为编译器需要为所有路径生成代码，虽然)。
* [1.x.5]
*由FEEvaluation和FEFaceEvaluation执行的任务可以分成三类。[1.x.6]，[1.x.7]，和[1.x.8]。这种分割反映在MatrixFree所包含的主要数据字段上，分别用[2.x.29][2.x.30]和[2.x.31]表示这三个类别。它们的设计原则和内部布局在以下几个小节中描述。
* 所有这些数据结构坚持的主要界面是，集成任务被分解成一个单元或面的范围，人们可以通过一个整数索引来索引。单元积分、面内积分和边界积分的整数范围的信息是由类[2.x.32]使用数据字段`cell_partition_data`、`face_partition_data`和`boundary_partition_data`提供。这个类还包含了用于使用线程并行调度任务的索引子范围的信息，以及在`{cell,face,boundary}_partition_data`内对索引范围的分组，用于交错单元和面的积分，这样对单元和面的积分的向量项的访问就会重新使用已经在缓存中的数据。
* [1.x.9]
* DoFInfo类的主要目的是提供矢量访问函数[2.x.33]和[2.x.34]所消耗的索引，这些索引布置如下。  [2.x.35] [2.x.36] 指数存储在MPI本地索引空间中，以实现直接的数组访问，而不是将全局索引转换为本地索引。后者绝对不利于性能。[2.x.37] [2.x.38] 指数被存储在一个叫做[2.x.39]的字段中，这是一个长索引数组。以[1.x.10]为单位的访问粒度由辅助字段[2.x.40]控制，它类似于压缩矩阵存储中的行开始索引。该方案支持可变长度，因为我们支持hp-adaptivity和由于主索引阵列中包含的约束而产生的索引间接性。由于单元格上的矢量化，访问粒度最初会以[1.x.11]为单位。然而，我们必须能够同时访问单个单元，例如，对于面的积分，面的批次一般与单元的批次不同，因此访问不是线性的。此外，如果我们为每个单独的组件提供一个[1.x.12]，那么对多组件系统的支持就变得透明了。因此，`row_starts`字段的长度为[2.x.41] [2.x.42] [2.x.43] 在一个多基元的系统中，组件之间的转换由四个变量控制 [2.x.44] [2.x.45] int> n_components`（每个基元的组件）， [2.x.46] [2.x.47] int> start_components`（从基元到唯一组件编号的转换）， [2.x.48] [2.x.49] int> component_to_base_index`（从唯一元件编号到基数索引的翻译），以及 [2.x.50] [2.x.51] int>> component_dof_indices_offset`（特定元件的自由度范围在一个单元上的全部自由度列表中的偏移）。[2.x.52] [2.x.53] [2.x.54]。
* [2.x.55] 在hp-adaptive计算中提取FE指数的信息。[2.x.56] [2.x.57] 关于 "第一次访问 "特定向量条目的信息，该信息用于在第一次访问目标向量之前不久将其清零的[2.x.58]。这被用来避免向整个向量写零，从而破坏了数据位置性。[2.x.59] [2.x.60].
* [2.x.61]中数据结构的设置是在[2.x.62]中完成的，在这里我们首先假设了一个非常一般的有限元布局，无论是连续的还是不连续的元素，并且我们解决了由于悬挂节点而产生的约束。这个初始步骤是在单元的原始排序中完成的。在后面的阶段，这些单元一般会被重新排列，以反映我们在最终循环中通过单元的顺序，我们也会在DoF指数中寻找可以利用的模式，如单元内连续的指数范围。这种重新排序是为了实现与MPI的通信和计算的重叠（如果启用的话），并在单元格上形成更好的具有矢量化的批次组。指数的数据存储在这个最终的顺序中是线性的，安排在[2.x.63]。
* 因为存储索引的数据量是不可忽略的，所以对于携带更多结构的特殊配置，减少数据量是值得的。一个例子是FE_DGQ的情况，每个单元的一个索引就足以描述其所有的自由度，其他的则是连续的顺序。类[2.x.64]包含一个特殊的向量数组[2.x.65]，每个单元包含一个数字。由于单元和面的积分使用不同的访问模式，而且这种特殊情况下的数据很小，我们最好存储3个这样的向量，一个用于装饰为`内部'的面（索引0），一个用于装饰为`外部'的面（索引1），一个用于单元（索引2），而不是通过[2.x.66]使用定向。 DoFInfo中有一系列额外的特殊存储格式可用。关于在deal.II中实现的选项及其动机，我们参考该结构的文档[2.x.67]。
* 最后，DoFInfo类还持有一个共享指针，描述向量的并行分区。由于[2.x.68]的限制，传递给[2.x.69]函数的单个DoFHandler对象内的索引必须在每个MPI进程中是连续的，也就是说，本地范围必须最多包括一个块。除了基本的分区器，该类还提供了一组更严格的索引集，只涉及所有鬼魂索引的一个子集，被添加到向量的鬼魂范围。这些交换模式被设计为与通过[2.x.70]的减少索引访问相结合，例如。
* MatrixFree类支持多个DoFHandler对象，以传递给[2.x.71]函数。对于这些DoFHandler对象中的每一个，都会创建一个单独的[2.x.72]对象。在MatrixFree中，我们存储了一个[2.x.73]的[2.x.74]对象来说明这一事实。
* [1.x.13]
* 一维形状函数在一维正交点上的评估被存储在[2.x.75]类中 更确切地说，我们保存了所有的函数值、梯度和豫备值。此外，面的形状函数的值和导数，即单位区间的0和1点，也被存储。对于悬空节点上的面积分，相邻两个单元中较粗的单元必须对数值进行插值，而不是插值到完整的正交点，而只是插值到一个子面（评估点要么按比例调整为[0，1/2]，要么为[1/2，1]）。这种情况由数据字段`values_within_subface`、`gradients_within_subface`和`hessians_within_subface`处理。这个数据结构也会检查形状函数相对于参考单元中心的对称性（在这种情况下，会应用所谓的偶数变换，进一步减少计算量）。
* [1.x.14]
* 评估的几何信息存储在[2.x.76]类中 与[2.x.77]类类似，在一个MatrixFree实例中可以有多种变体，在这种情况下是基于多个正交公式。此外，单元格和面的单独数据被存储。由于涉及到更多的逻辑，而且字段之间有协同作用，字段的[2.x.78]被保存在[2.x.79]中。单个字段是[2.x.80]类型的，保存有反雅各布系数、JxW值、法向量、法向量乘反雅各布系数的数组（对于[2.x.81]实空间的正交点，以及参考元素上的正交点。我们使用一个辅助索引数组，指向每个单元的数据起点，即雅各布、JxW值和法向量的`data_index_offsets`字段，以及正交点的`quadrature_point_offsets`。这种偏移使HP-adaptivity的字段长度可变，类似于DoFInfo的做法，但它也使我们称之为[1.x.15]的东西得以实现。为了减少数据访问，我们检测单元格的简单几何形状，其中雅各布系数在一个单元格内是恒定的，或者也是跨单元格的，使用[2.x.82] 。
* [2.x.83] [2.x.84] 笛卡尔单元是指雅各布系数为对角线且在单元的每个正交点上相同的单元。每个单元只需要存储一个字段。由于单元内的相似性，我们还检查了当前处理器上所有单元的雅各布系数相同的其他单元批。这可以进一步减少内存访问。由于一般情况下的JxW值存储的是雅各布系数乘以正交权重，但我们只想为笛卡尔单元保留一个字段，所以我们在笛卡尔情况下误用了[1.x.16]这个名字，只存储了雅各布系数的行列式，没有正交权重。因此，在[2.x.85]和类似的情况下，我们需要注意，因为我们仍然必须乘以权重。  [2.x.86] 平行单元在整个单元内有恒定的雅各布系数，所以每个单元只需要存储一个字段。由于单元内的相似性，我们还检查了当前处理器上所有单元的雅各布系数相同的其他单元批。由于一般情况下的JxW值存储的是雅各布系数乘以正交权重，但我们只想为一个仿生单元保留一个字段，所以我们在仿生情况下滥用了[1.x.17]这个名字，就像在笛卡尔情况下一样，只存储雅各布系数的行列式，而不存储正交权重。因此，在[2.x.87]和类似的情况下，我们需要注意，因为我们仍然必须乘以权重。  [2.x.88]在面孔上，我们可以有这样的特殊情况：当JxW值不同时，法向量在所有正交点都是相同的。这种情况适用于平坦的面孔。为了减少数据访问，我们在[2.x.89]中保留了这个作为压缩索引的第三个选项。与笛卡尔和仿射的情况相反，在数组中只保留一个字段，扁平面为所有正交点保留一个单独的条目（保留一个索引字段`data_index_offsets`），但只访问第一个字。  [2.x.90] 一般类型的索引是指没有发现压缩的单元或面。在这种情况下，我们也不寻找在一个以上的单元上找到相同图案的机会，尽管这种情况可能存在，比如对于挤压的网格。这种搜索操作是基于使用自定义浮点比较器`FPArrayComparator`将数据插入到[2.x.91]中，当每个单元使用单一数据字段时，效率足够高。然而，如果对所有单元的所有正交点（有许多不同的情况）进行，它将是相当昂贵的。  [2.x.92]
* [2.x.93]的实现被分成了单元格和面的部分，所以这两个部分可以很容易地被分开持有。让代码读起来有点尴尬的是，我们需要从FEValues对象中完成的原始标量评估中把几个对象批在一起，我们需要识别重复的数据字段，而且我们需要用[2.x.94]对笛卡尔和仿射的情况在几个单元中定义压缩。
* [2.x.95]的数据计算部分除了明显的MPI并行化外，还通过任务来并行化。每个处理器在一个子范围内计算信息，然后数据最终被复制到一个单一的组合数据域中。
* [1.x.18]
* 目前MatrixFree中的面积分方案为所有的面建立了一个独立的任务列表，而不是明确地通过一个单元的`2*dim`面。这样做的好处是一个面的所有信息只需要处理一次。典型的DG方法计算的数字通量是保守的，也就是说，从面的两边看都是一样的，无论什么信息离开一个单元都必须正好再次进入邻居的单元。有了这个方案，它们必须只被计算一次。同时，这也确保了几何信息也必须只被加载一次。一个可能的缺点是，基于面的独立编号方法使得基于线程的并行变得比基于单元的方法复杂得多，因为在这种方法中，只有当前单元的信息被写入，而邻居的信息只被读取）。
* 由于面是独立于单元的，它们得到了自己的矢量布局。从一批面孔来看，不管是什么连续的一批细胞都会被交织在一起，这是面孔的本质（在这里我们只把细胞内有相同面孔索引的面孔放在一起，以此类推）。脸部循环的设置，在文件`脸部_设置_内部.h`中完成，试图提供至少部分类似于单元格补丁的脸部批次，以增加数据的定位性。沿着这些思路，在典型的[2.x.96]情况下，面的工作也与单元的工作交错进行，也就是说，函数调用中返回的`cell_range'和`face_range'参数通常很短。
* 因为所有来自两边的积分都是一次性执行的，所以出现了一个问题，即在子域边界的两个处理器中哪一个被分配到一个面。本模块的作者进行了大量的实验，发现应用于自由度存储的方案，即把所有可能重叠的项目分配给一个处理器，是相当不平衡的，面的数量最多有20%的差异。为了提高性能，在`face_setup_internal.h`中实现了一个平衡的方案，将每对处理器之间的所有接口分成两块，一块由一个处理器完成，另一块由另一个处理器完成。尽管这增加了通过MPI发送的消息的数量，但这是值得的，因为负载变得更加平衡。另外，当本地问题的规模为100,000 DoFs（三维）时，消息相当大，约为5-50kB。在这种消息大小下，延迟通常小于吞吐量。
* 脸部数据默认不被初始化，但必须由[2.x.97]中的脸部更新标志触发，即`mapping_update_flags_inner_faces`或`mapping_update_flags_boundary_faces`设置为与`update_default`不同的值。
* [1.x.19]
* MatrixFree类支持两种类型的实体的循环。第一种，从2012年开始在deal.II主分支上可用，是只执行单元积分，使用三个`cell_loop`函数中的一个，该函数需要一个指向单元操作的函数指针。第二种设置，在2018年引入，是一个循环，也可以执行面和/或边界积分，简单地称为`loop`。这需要三个函数指针，分别解决单元工作、内面工作和边界面工作。
* 除了以适当的方式安排工作外，该循环还执行两个任务。  [2.x.98] [2.x.99] 对`src`和`dst`向量进行数据交换，分别调用`update_ghost_values()`和[2.x.100]。如果各自的标志[2.x.101]被设置为 "true"（默认），那么交换可以以异步的方式进行，与不需要远程处理器数据的单元的工作重叠。  [2.x.102] 使用相应的标志将`dst`向量归零。在循环内这样做的好处是，循环知道向量中的哪些条目（首先）被单元格和面的循环中的一些子ranges触及。因此，它可以将向量逐个归零，以确保我们不需要两次访问向量条目（一次归零，一次添加贡献）。这似乎是一个微小的优化，但事实上运算符的评估可以非常快，简单地将一个向量归零就可以花费运算符评估时间的20%左右，所以这确实是值得努力的由于这个参数有一些实验性，DoFInfo类保留了一个静态变量[2.x.103]，在这里可以调整（如果有人认为其他东西会更好，例如因为未来的计算机看起来和2018年推出这个参数时不同）。  [2.x.104]
* 最后，[2.x.105]函数还需要一个参数来传递面积分的数据访问类型，由结构[2.x.106]描述，以减少处理器之间需要交换的数据量。不幸的是，目前还没有办法将这些信息传达给[2.x.107]，这些信息在FEFaceEvaluation内部通过评估类型（值和/或梯度）和底层形状函数的组合获得，以避免在第二个地方手动设置这类信息。


* [0.x.1]

include/deal.II-translator/A-headers/memory_0.txt
[0.x.0]*



* [2.x.0]
* 本组有一些用于内存处理的基本类和命名空间。Subscriptor和SmartPointer类用于计数内存处理，也就是说，每当SmartPointer被设置为指向一个对象时，它就会增加该对象中的一个计数器；当指针被设置为指向其他地方时，它又会减少。这样一来，人们总是知道一个对象还有多少用户。虽然这本身很少有用，但如果一个对象被销毁，而某个地方的指针仍然指向它，它就会被用来产生一个异常，因为在以后的时间里通过该指针的任何访问都会导致访问无效的内存区域。
* 与此相反，MemoryConsumption命名空间提供的函数可以用来确定对象的内存消耗。对于一些简单的类，比如标准库的容器，它直接确定它们需要多少内存（或者至少给出一个估计值）。对于deal.II类，它使用大多数类有的[2.x.1]成员函数。
*


* [2.x.2]


* [0.x.1]

include/deal.II-translator/A-headers/mesh_worker_0.txt
[0.x.0]*



* [2.x.0]
* 一组类和函数的集合，简化了对所有单元和面的循环编码。该模块的所有类和函数都在MeshWorker命名空间中，其中也包含了使用文档。
*


* [2.x.1]


* [0.x.1]

include/deal.II-translator/A-headers/mg_0.txt
[0.x.0]*



* [2.x.0]
* 与多栅格算法有关的类。
* 实现多网格方案的主要类是Multigrid，其功能是 [2.x.1] 它使用以下抽象类来执行多网格循环。
* [2.x.2] [2.x.3] MGMatrixBase包含水平矩阵，在[2.x.4] [2.x.5] MGCoarseGridBase是最粗层次上的求解器。  [2.x.6] MGSmootherBase在每个层次上进行平滑处理。  [2.x.7] MGTransferBase组织层次间的转移。  [2.x.8]
* 此外，还有一个PreconditionMG类，它是Multigrid的一个封装器，具有deal.II [2.x.9] Preconditioners的标准接口。PreconditionMG也使用继承自MGTransferBase的类，例如MGTransferPrebuilt，它使用[2.x.10]和[2.x.11]，在全局向量和水平向量之间进行转移。
* 最后，我们有几个辅助类，即MGLevelObject，它在每个层次上存储一个对象*。
* 关于如何使用这一功能，请参见[2.x.12] 、[2.x.13] b和[2.x.14] 示例程序。
* [1.x.0]
* 在自适应细化网格上使用多网格方法比使用常规细化方法涉及更多的基础设施。首先，为了保持最佳的复杂度，我们需要决定如何在每个层次上进行平滑处理。为此，我们必须在多级分解的意义上定义什么是级。
* 首先，我们定义多网格意义上的一个层次是由网格层次结构中某一层次的所有单元构成的。因此，某一级的平滑只限于由这一级或更细的单元组成的子域。这通常被称为局部平滑。这种定义的优点是，多网格方案的层次矩阵可以通过遍历某一层次的所有单元而轻松组装起来，而且这些层次矩阵不包含悬空节点。
* 这种分解的缺点是，我们需要额外的矩阵来处理细化边上出现的问题。此外，根据方法是连续的（因此在细化边缘有自由度）还是不连续的（在细化边缘采用通量矩阵），处理方法是不同的。虽然这些矩阵很小，但我们必须把它们集合起来，并通知多棱镜方法。


* [0.x.1]*
 这个命名空间包含了在我们知道在局部细化和块系统的背景下需要什么之后，对多层次支持的重新实现。
*


* [2.x.15]


* [0.x.2]

include/deal.II-translator/A-headers/multithreading_0.txt
[0.x.0]*



* [2.x.0]


* [2.x.1]



* [2.x.2] 机器。参见详细的文档和[2.x.3]"目录"，下面是该模块成员的冗长列表。
* [2.x.4]
* 在具有多个处理器（或多核处理器）的机器上，以%并行方式运行计算的几个部分往往是有利的。例如，我们可以有几个线程在%并行运行，每个线程组装三角形的一个子集的单元格矩阵，然后将它们写入全局矩阵。由于组装矩阵通常是一个昂贵的操作，这经常导致在多处理器机器上显著节省计算时间。
* 通过Threads命名空间中的函数和类，deal.II支持在共享内存（SMP）机器上以%并行方式运行操作。MultithreadInfo类允许查询系统的某些属性，如CPU的数量。这些用于%并行计算的设施将在下文中描述。[2.x.5]、[2.x.6]、[2.x.7]、[2.x.8]、[2.x.9]和[2.x.10]的教程程序也展示了它们在实践中的使用，其中从[2.x.11]开始的程序采用了更现代的做事风格，基本上我们描述[1.x.0]可以用%parallel完成，而旧的教程程序描述[1.x.1]事必须用%parallel完成。
* 另一方面，在分布式内存机器（即集群）上运行的程序需要一个建立在MPI和PETSc或Trilinos之上的不同编程模型。这在 [2.x.12] , [2.x.13] 和 [2.x.14] 示例程序中有所描述。
* [2.x.15] MTToC [2.x.16] 。


* [2.x.17] MTTasks [1.x.3] 。
* 在共享内存机器上并行的传统观点是将程序分解成[1.x.4]，即以%并行的方式运行程序的不同部分[1.x.5]（如果你的机器上的线程多于处理器内核，操作系统会在将执行切换到另一个线程之前短暂地轮流运行每个线程，从而模拟线程并发运行）。下面描述了deal.II的线程设施（见[2.x.18] "基于线程的并行性"），但我们首先想讨论一个通常比线程更合适的抽象。[1.x.6].
* 任务本质上是一个程序的各个部分。其中一些任务是独立的，而另一些任务则依赖于之前的任务，要先完成。举例来说，考虑一下大多数教程程序所具有的[2.x.19]函数的一部分的典型布局。


* [1.x.7]

* 这里，每个操作都需要大量的计算。但要注意的是，并不是所有的操作都相互依赖：显然我们不能在1之前运行语句2-4，4需要等待语句2和3的完成。但语句2和3是独立的：它们可以以任何顺序运行，或以%并行方式运行。实质上，我们已经确定了四个[1.x.8]，其中一些是相互依赖的，而其他是独立的。在目前的例子中，任务被识别为单独的C++语句，但往往它们更普遍地与整个代码块相吻合。
* 这里的重点是这样的。如果我们想使用线程来利用任务2和3的独立性，我们将启动两个线程，并在自己的线程上运行任务2和3；然后我们将等待这两个线程完成（一个称为 "加入线程 "的操作），并继续执行语句4。实现这一目标的代码是这样的（实际的语法在下面有更详细的解释）。


* [1.x.9]
*
* 但如果你的电脑只有一个处理器核心，或者我们有两个处理器核心，但已经有一个不同的程序部分在与上面的代码%并行运行，那该怎么办？在这种情况下，上面的代码仍然会启动新的线程，但程序不会运行得更快，因为没有额外的计算资源可用；相反，程序会运行得更慢，因为线程必须被创建和销毁，而且操作系统必须将线程安排到超额的计算资源上。
* 一个更好的方案是识别独立的任务，然后把它们交给一个调度器，把任务映射到可用的计算资源上。这样一来，例如，程序可以在每个处理器核心启动一个线程，然后让线程在任务上工作。任务将运行到完成，而不是同时进行，避免了中断线程运行不同线程的开销。在这个模型中，如果有两个处理器核，上面的任务2和3将以%的速度并行运行；如果只有一个处理器核，调度器将首先完全执行任务2，然后再做任务3，或者反过来。这个模型能够更有效地执行，特别是如果有大量的任务可供执行，例如见下面[2.x.20]节 "任务的抽象 "中的讨论。工作流"。从本质上讲，任务是对需要完成的任务的高级描述，而线程是实现这些任务如何完成的低级方式。在许多其他情况下，能够使用高层次的描述可以找到有效的低层次实现；在这种情况下，在程序中使用任务而不是线程往往是值得的。
* deal.II本身并没有实现对线程的任务调度。为此，我们使用了[1.x.10]，并为此提供了简单的封装器。TBB抽象了如何启动或停止线程、在单个线程上启动任务等细节，并提供了可以在许多不同系统中移植的接口。
*

*
* [2.x.21] MTUsing [1.x.11]。
* 理想情况下，启动任务（以及类似的线程）的语法，对于上面的例子，应该是这样的。


* [1.x.12]
* 换句话说，我们希望通过简单地在调用前加上一个关键字（比如这里的[2.x.22]，线程的关键字类似[2.x.23]）来表明函数调用应该在一个单独的任务上运行。前缀的调用将返回一个任务的句柄，我们可以用它来等待任务的完成，也可以用它来查询被调用函数的返回值（除非它是空的，就像这里一样）。
* 由于C++不支持创建新的关键字，我们必须要有一点创造性。所选择的方式是引入一个函数[2.x.24]，该函数将调用的函数以及调用的参数作为参数。[2.x.25]函数被重载，以适应没有、1个、2个和最多9个参数的函数启动任务。在deal.II中，这些函数生活在Threads命名空间中。因此，我们上面尝试做的实际代码看起来是这样的。


* [1.x.13]
*
* 同样，如果我们想在不同的任务上调用一个成员函数，我们可以通过指定调用函数的对象作为函数指针后的第一个参数来实现。


* [1.x.14]
* 在这里，首先注意我们如何传递对象[2.x.26]（即[2.x.27]会看到），好像它是函数的第一个参数。其次，注意我们如何通过调用[2.x.28]在单独的任务上获取函数返回的值，这个函数意味着等待任务的完成，也就是说，最后一行完全相当于


* [1.x.15]
*
* 还要注意，如果[2.x.29]想启动自己的任务，也是完全有效的。


* [1.x.16]
* 这里，我们让[2.x.30]计算其返回值为[2.x.31] 。如果有足够的CPU资源，那么加法的两个部分以及[2.x.32]中的其他东西都将以%的速度并行运行。如果没有，那么我们最终会在其中一个需要返回值的地方阻塞，从而释放出必要的CPU资源来运行所有这些生成的任务来完成。
*

* 在许多情况下，比如上面概述的[2.x.33]函数的介绍性例子，人们可以确定几个独立的作业，它们可以作为任务运行，但必须等待所有的作业在一个点上完成。我们可以通过存储所有[2.x.34]调用的返回对象，并对其中每一个调用[2.x.35]来做到这一点。一个更简单的方法是将所有这些任务对象放入一个[2.x.36]对象中，并一次性地等待所有的任务。然后，代码会是这样的。


* [1.x.17]

*

* [2.x.37] MTHow [1.x.18] 。
* 任务如何调度运行的确切细节是deal.II用于任务的Threading Building Blocks（TBB）库的内部%。TBB的文档对任务如何被安排到线程中给出了详细的描述，但对实际使用多少个线程却没有提及。然而，一个合理的猜测是，假设TBB创建的线程数与系统中的处理器核心数一样多。这样，它就能充分利用整个系统，而不会有太多的线程让操作系统不得不定期中断，以便其他线程能在可用的处理器核心上运行。
*那么问题来了，TBB调度器接受任务并让线程执行它们。线程完全执行任务，也就是说，TBB调度器不会中途中断一个任务，让另一个任务取得一些中途的进展。这确保了缓存总是热的，例如，避免了抢占式中断的开销。
* 缺点是，只有当线程真正在做一些事情时，CPU核心才会被充分利用，这意味着（i）必须有足够的任务可用，以及（ii）这些任务真正在做一些事情。请注意，这两个条件都必须满足；特别是，这意味着，如果我们已经确定了足够数量的任务，但如果其中一些任务踌躇不前，例如，因为一个任务正在向磁盘写入数据（这个过程中，CPU经常需要等待磁盘完成交易）或正在等待输入，那么CPU内核就没有得到充分利用。其他情况是，任务在其他外部事件上阻塞，例如通过突扰器与其他任务或线程同步。在这种情况下，调度器会让一个任务在一个线程上运行，但并没有注意到这个线程并没有完全利用CPU核心。
* 在这样的情况下，[1.x.19]创建一个新的线程（见下文[2.x.38]"基于线程的并行性"）是有意义的，操作系统可以在他们等待外部事物时将其搁置，并让不同的线程（例如运行TBB调度的任务的线程）同时使用CPU。
*

* [2.x.39] MTSimpleLoops [1.x.20]。
* 有些循环在数据上的执行体是完全独立的，因此可以以%并行方式执行。TBB库不是先验地将循环分割成固定数量的块并在任务或线程上执行，而是使用以下概念：循环迭代的范围被分割成一定数量的子范围（例如CPU核数的2或3倍），并平均分配给线程；然后线程执行子范围，如果它们完成了工作，就从其他线程那里偷取整个或部分子范围以保持忙碌。这样一来，即使不是每个循环迭代都需要同样多的工作，或者一些CPU核心因为操作系统中断了其他工作而落后，工作也是平衡的。
* TBB库的原语有点笨拙，所以deal.II为最经常使用的操作提供了包装例程。最简单的一个类似于[2.x.40]的做法：它需要一个或多个范围的输入运算符，一个输出迭代器和一个函数对象。一个典型的[2.x.41]的实现会是这样的。


* [1.x.21]
*
* 在很多情况下，[2.x.42]没有状态，因此我们可以将这个循环分成几个子范围，如上文所解释的。因此，deal.II有一组函数[2.x.43]，看起来和上面的函数一样，但它们是以%parallel的方式进行工作的（对于接受一个、两个或更多参数的函数对象，有几个版本有一个、两个和更多的输入迭代器）。调用这些函数的唯一区别是，它们需要一个额外的最后一个参数，表示[2.x.44]的子范围的最小尺寸；它应该足够大，这样我们就不会在调度子范围到处理器上花费更多的时间，但又足够小，处理器可以有效地进行负载平衡。一个经验法则似乎是，如果执行一个子程序需要少于2000条指令，那么这个子程序就太小了。
* 如何使用这些函数的一个例子是向量操作，如[2.x.45]中的加法，所有三个对象都是Vector<Number>类型。


* [1.x.22]
*
* 在这个例子中，我们用一个[1.x.23]来构建一个函数对象，它接受两个参数并返回两个参数的和。当我们想把向量[2.x.46]和[2.x.47]的各个元素相加，并把两者之和写入[2.x.48]的元素中时，这正是我们需要的东西。我们在这里得到的函数对象完全为编译器所知，当它展开[2.x.49]所产生的循环时，就像我们以其明显的形式写出的循环一样。


* [1.x.24]
*
* 还要注意的是，我们已经确保没有任何一个CPU能得到整个循环中小于1000次迭代的那块（除非整个范围更小）。
*

* [2.x.50] MTComplexLoops [1.x.25]。
* 如果在每个迭代中进行的操作不需要大量的设置成本，并且可以被编译器内联，那么上一节所示的方案是有效的。[1.x.26]正是这种类型，从而消除了调用外部函数的开销。然而，在有些情况下，在每个迭代中调用一些对象或函数是低效的。
*这种情况的一个例子是稀疏矩阵-向量乘法。如果你知道数据是如何以压缩行格式存储的，比如在SparseMatrix类中，那么一个矩阵-向量乘积函数看起来是这样的。


* [1.x.27]
* 在for循环中，我们计算矩阵的某一行与右侧向量[2.x.51]的点积，并将其写入[2.x.52]向量的相应元素中。通过利用[1.x.28]行的元素跟随当前行[1.x.29]的元素，使代码更加有效，也就是说，在循环体的开始，我们不必重新设置指向每一行的值和列数的指针。
* 使用上面的[2.x.53]函数，原则上我们可以把这段代码写成如下。


* [1.x.30]
* 注意我们如何使用[2.x.54]来[1.x.31]某些参数给[2.x.55]函数，留下一个参数，从而使[2.x.56]函数认为传递的函数参数是单值的。还要注意的是，我们需要把源向量和目的向量作为（const）引用，以防止[2.x.57]按值传递它们（意味着对[2.x.58]的拷贝和把结果写入[2.x.59]的临时拷贝，这都不是我们想要的）。最后，注意到一个矩阵的最小200行的粒度，应该由单个CPU核心来处理。
* 问题是，虽然这样做是正确的，但效率不高：我们必须在循环的每个迭代中设置[2.x.60]变量。此外，由于现在每一行要调用的函数对象不再是简单的[1.x.32]，在循环的每一次迭代中都有一个隐含的函数调用，包括参数传递。
* 一个更有效的方法是让TBB将原始范围分割成子范围，然后不是在循环的每个元素上调用目标函数，而是在整个范围上调用。这一点由[2.x.61]函数提供便利。


* [1.x.33]
* 这里，我们在每个元素至少200个的子范围上调用[2.x.62]函数，这样初始设置成本就可以摊销。
* 一个相关的操作是当元素上的循环各自产生一个结果，然后必须累积起来（除了数字的加法之外，其他的减少操作也可以）。一个例子是形成矩阵规范[2.x.63]（如果[2.x.64]是正定的，它才是真正的规范，但我们暂时假设它是）。对于稀疏矩阵来说，一个顺序的实现会是这样的。


* [1.x.34]
*
* 如果我们能把这个操作分成几个子行，每个子行都计算自己的那部分规范的平方，把各个子行的结果加在一起，然后取结果的平方根，那就更好了。这就是[2.x.65]函数所做的（注意，你必须指定结果类型作为模板参数，而且像往常一样，最后一个参数是可以在单个CPU核上调度的外循环元素的最小数量）。


* [1.x.35]

*

* [2.x.66] MTWorkStream [1.x.36]。
* 在介绍中所示的例子中，我们已经确定了一些可以作为独立任务运行的函数。理想情况下，这个任务的数量要大于CPU核心的数量（以保持它们的忙碌），但也不要过于庞大（以免数百万的任务淹没调度器，然后不得不分配给2或4个核心，例如）。然而，在有些情况下，我们有几千甚至几百万个相对独立的作业：例如，在网格的每个单元上组装对全局线性系统的局部贡献；在每个单元上评估误差估计器；或者在每个单元上对计算的数据进行后处理，这些都属于这一类。这些情况可以用我们称之为WorkStream的软件设计模式来处理。在下文中，我们将介绍这种模式的原理及其实现；更多的细节以及用它可以实现的加速的例子在[2.x.67]"WorkStream论文 "中给出。
* 像这样的代码可以这样写。


* [1.x.37]
* 在一个大的网格上，可能有一百万个单元，这会产生大量的任务；虽然它会让所有的CPU核忙上一阵子，但首先创建这么多的任务，对它们进行调度，然后等待它们，这样的开销可能不会导致高效的代码。一个更好的策略是，如果调度器能够以某种方式表明它有可用的资源，在这一点上，我们将给它提供另一个新创建的任务，我们将这样做，直到我们的任务用完，并且所创建的任务已经被工作。
* 这基本上就是[2.x.68]函数所做的。你给它一个迭代器范围，它可以从中抽取对象进行工作（在上面的例子中，它是由[2.x.69]到[2.x.70]给出的区间），以及一个对每个项目进行工作的函数（函数[2.x.71]）和一个对象，如果它是一个成员函数。
* 在下文中，让我们阐述一下为什么WorkStream命名空间中的函数会以这种方式实现的理由。关于其实现的更多信息可以在[2.x.72]"WorkStream文件 "中找到。要看到WorkStream类在类似上述任务中的实际应用，请看[2.x.73]、[2.x.74]、[2.x.75]、[2.x.76]、[2.x.77]或[2.x.78]的教程程序。
* 首先，考虑到上面的简单描述，那么[2.x.79]函数的写法可以是这样的（注意，这并不是很正确的语法，下面会介绍）。


* [1.x.38]
*
* 然而，这至少有三个问题。[2.x.80] [2.x.81] 首先，让我们看一下[2.x.82]函数可能的样子。


* [1.x.39]
*
* 这里的问题是，几个任务，每个都在运行[2.x.83]，可能会试图写入对象[2.x.84] [1.x.40]。这可以通过使用[2.x.85]的显式同步来避免，例如，看起来像这样。


* [1.x.41]
*
* 通过使mutex成为静态变量，它在全局范围内只存在一次（即对所有可能在%parallel中运行的任务都存在一次），并且只有一个任务可以进入由mutex上的acquisition/release调用保护的区域。顺便说一句，写这段代码的更好方法是这样的，确保即使在抛出异常的情况下也能释放mutex，而且不需要记住写对[2.x.86]的调用。


* [1.x.42]
* 在这里，从ScopedLock被创建到它被销毁，在代码块结束时，mutex一直被锁定。
* 请注意，尽管我们现在避免了多个线程可能向同一个对象写入的竞赛条件，但这段代码的效率并不高：在多核机器上，mutexes是很昂贵的，而且我们还在某些时候阻塞了线程，这对于任务来说是低效的，正如上文[2.x.87]"调度任务如何工作以及基于任务的编程何时不高效 "一节中所解释的。
* [2.x.88] 第二个正确性问题是，即使我们使用mutex锁定全局矩阵和右手边的对象，我们也是以一种或多或少的随机顺序这样做的：虽然任务是按照我们正常遍历单元格的顺序创建的，但不能保证当我们到了要把局部复制到全局贡献的时候，顺序仍然是我们按顺序计算的那样。换句话说，我们可能会把单元格1的贡献加在单元格0的贡献之前。这看起来无害，因为加法是交换和关联的，但事实上，如果用浮点运算，就不是这样了。  [2.x.89]
*
* - 以[2.x.90]为例（因为[2.x.91]在浮点运算中，使用双精度）。
* 结果是，最终出现在全局矩阵和右手边的确切数值会很接近，但可能会因任务完成的顺序不同而有接近四舍五入的差异。这不是一个理想的结果，因为这样的结果是不可复制的。
* 因此，WorkStream类的设计方式是使用两个函数：[2.x.92]计算本地贡献并将其存储在某个地方（我们接下来会讨论这个问题），第二个函数，例如[2.x.93]，将每个单元的计算结果复制到全局对象。在WorkStream类中实现的技巧是：(i)[2.x.94]永远不会以%并行方式运行超过一次，所以我们不需要通过互斥来同步执行，(ii)它在单元格上的运行顺序与它们在迭代器范围内出现的顺序完全相同，也就是说，我们以同样的方式将元素加入全局矩阵中[1.x.43]。
* 我们现在只需要讨论[2.x.95]如何向[2.x.96]传达它所计算的内容。这样做的方法是使用一个持有所有临时数据的对象。


* [1.x.44]
*
* 这种工作方式是，我们创建一个样本[2.x.97]对象，工作流对象将在每个以%并行方式运行的任务中复制一次。对于每个任务，这个对象将首先被传递给以%并行方式运行的[2.x.98]的几个实例中的一个，该实例将在单个单元上获得的数据填入该对象，然后再传递给顺序运行的[2.x.99]，将数据复制到全局对象中。当然，在实践中，如果我们有数以百万计的单元，我们不会产生数以百万计的[2.x.100]对象；相反，我们在这些对象被[2.x.101]使用后进行回收，并将其送回[2.x.102]的另一个实例；这意味着我们实际创建的此类对象的数量是调度器使用的线程数的一小部分，通常与系统中的CPU核数量相当。
* [2.x.103] 最后一个值得解决的问题是，按照上面[2.x.104]函数的写法，我们在每次调用该函数时都要创建和销毁一个FEValues对象，也就是说，为三角形中的每个单元创建一次。这是一个非常昂贵的操作，因为FEValues类试图在其构造函数中做大量的工作，试图减少我们对每个单元的操作数量（即增加[2.x.105]中的常数来初始化这样一个对象，以减少在三角形的[2.x.108]单元上调用[2.x.106]操作的常数）。在每个单元上创建和销毁一个FEValues对象会使这种努力失效。
* 避免这种情况的方法是将FEValues对象放入第二个结构中，该结构将保存从头开始的数据，并在构造函数中初始化它。


* [1.x.45]
* 然后在组装函数中使用这个FEValues对象。


* [1.x.46]
* 就像[2.x.109]结构一样，我们将创建一个[2.x.110]的样本对象，并将其传递给工作流对象，后者将根据需要多次复制它。为了使其发挥作用，[2.x.111]结构需要是可复制的。由于FEValues对象相当复杂，不能隐式复制，我们为[2.x.112]结构提供了我们自己的复制构造函数。
* 同样的方法，把东西放到[2.x.113]数据结构中，应该用于所有昂贵的构造。这尤其适用于所有在构造时需要分配内存的东西；例如，如果一个函数的值需要在正交点进行评估，那么这就很昂贵。


* [1.x.47]
*而这是一个更便宜的方法。


* [1.x.48]
*
* [2.x.114]
* 作为最后一点。如果由于某种原因，我的汇编器和复制器函数不符合上述分别有三个和一个参数的签名，怎么办？这也不是什么问题。WorkStream 命名空间提供了 [2.x.115] 函数的两个版本：一个是接收一个对象和两个成员函数的地址，另一个是简单地接收两个函数对象，可以分别用三个和一个参数调用。所以，换句话说，下面的两个调用是完全相同的。


* [1.x.49]
* 注意[2.x.116]是如何通过将成员函数绑定到[2.x.117]对象上产生一个需要三个参数的函数对象。  [2.x.118]是第一个、第二个和第三个参数的占位符，可以在以后指定。换句话说，例如，如果 [2.x.119] 是第一次调用 [2.x.120] 的结果，那么调用 <code>p(cell, scratch_data, per_task_data)</code> 将导致执行 [2.x.121] ，即 [2.x.122] 已经将对象绑定到函数指针上，但为以后留下了三个参数。
* 同样地，让我们假设[2.x.123]在一个非线性、时间依赖性问题的求解器中具有如下签名。


* [1.x.50]
* 因为WorkStream希望能够只用三个参数来调用worker函数，第一个参数是迭代器，第二个和第三个参数是ScratchData和PerTaskData对象，所以我们需要向它传递以下内容。


* [1.x.51]
* 这里，我们将对象、线性化点参数和当前时间参数绑定到函数中，然后再交给 [2.x.124] [2.x.125] 将简单地用单元格和scratch以及每个任务对象调用函数，这些对象将在 [2.x.126] 和 [2.x.127] 指示的位置被填入。
* 上面显示的[2.x.128]函数有一些细化。例如，人们可能会意识到，只有在复制-本地到全局的函数比本地装配函数快得多的情况下，上面的基本想法才能扩展，因为前者必须按顺序运行。这种限制只能通过安排更多的并行工作来改善。这就导致了这样一个概念：通过记录哪些写操作相互冲突，为我们工作的单元格（或更广泛的迭代器）的图形着色。因此，有一个[2.x.129]的第三个版本，它不只是取一个迭代器的范围，而是取一个由可以同时工作的元素组成的向量。这个概念在[2.x.130]的 "WorkStream论文 "中得到了非常详细的解释，同时还有常见例子的性能评估。
*

* [2.x.131] MTTaskSynchronization [1.x.52]。
* 任务是强大的，但它们确实有其局限性：为了使事情变得高效，任务调度器从不自己中断任务。除了调用[2.x.132]函数来等待另一个任务完成的情况外，任务调度器总是将一个任务运行到完成。缺点是，调度器看不到一个任务是否真的在空转，例如，如果它在等待其他事情发生（文件IO完成，来自键盘的输入等）。在这样的情况下，任务调度器原则上可以运行一个不同的任务，但由于它不知道任务在做什么，所以它不知道。因此，那些确实在等待外部事件发生的函数不适合做任务，应该使用线程（见下文）。
* 然而，在有些情况下，任务不仅是对工作的一种糟糕的抽象，而且实际上可以不使用。原则上，任务不能通过使用mutex或条件变量与其他任务同步（参见[2.x.133]和[2.x.134]类）。原因是，如果任务A需要等待任务B完成某件事情，那么只有在保证任务B最终能够运行并完成任务的情况下，这才会奏效。现在想象一下，你有2个处理器，任务A1和A2目前正在运行；我们假设他们已经排好了任务B1和B2的队列，现在正用一个突变器等待这些排队的任务完成（部分）工作。由于机器只有两个处理器，任务调度器只有在A1或A2完成后才会启动B1或B2
*
* 但这并没有发生，因为它们是使用操作系统资源（mutex）而不是任务调度器资源在等待。结果是一个死锁。
* 底线是，任务不能使用互斥或条件变量来与其他任务同步。如果任务之间的通信是必要的，你需要使用线程，因为操作系统确保所有线程最终都能运行，与线程的总数无关。然而，请注意，如果你只在每个任务上分别使用一个[2.x.135]来保护对任务可能写入的变量的访问，那么情况就不一样了：这种对mutexes的使用是可以的；任务可能只是不想等待另一个任务做什么。
*

* [2.x.136] MTThreads [1.x.53] 。
* 尽管任务是一种更高层次的描述事物的方式，但有些情况是不适合用任务的（关于其中一些情况的讨论，见上文[2.x.137]"调度任务是如何进行的以及基于任务的编程在什么情况下是无效的"）。一般来说，不能完全利用CPU的工作不适合任务，而适合线程。
* 在这样的情况下，你可以采用显式启动线程，而不是任务，使用的语法与上面基本相同。例如，如果你的应用程序中有一个生成图形输出的函数，然后估计误差，为自适应网格方案的下一次迭代细化网格，它可以是这样的。


* [1.x.54]
*
* 在这里，[2.x.138]启动了给定的函数，该函数在一个新的线程上向输出文件写入数据，该线程可以与其他一切并行运行：在与[2.x.139]函数并行的%，[2.x.140]函数将在一个单独的线程上运行。这种执行是独立于负责任务的调度器的，但这并不是一个问题，因为向文件写入大量数据并不会让CPU非常忙碌。
* 创建线程的工作方式与任务基本相同，即你可以用[2.x.141]来等待一个线程的终止，用[2.x.142]来查询一个已完成的线程的返回值，你可以将线程分组到一个[2.x.143]对象中，等待所有线程的完成。
*

* [2.x.144] MTTaskThreads [1.x.55] 如前所述，deal.II没有实现向线程调度任务，甚至没有启动线程本身。TBB库在决定使用多少个线程方面做得很好，他们不建议明确设置线程的数量。然而，在大型对称多处理（SMP）机器上，特别是那些有资源/任务管理器的机器，或者在对某些部分内存的访问是可能的，但对远处的处理器来说非常昂贵的系统上（例如，非常大的NUMA SMP机器），可能有必要明确设置线程数，以防止TBB使用过多的CPU。另一个用例是，如果你在一台机器上运行多个MPI作业，并且每个作业只应使用可用处理器内核的一个子集。
* 明确设置线程数是通过在调用其他可能创建线程的函数之前调用[2.x.145]来完成的。在实践中，它应该是你在 [2.x.146] 中首先调用的函数之一。
* 如果你用MPI运行你的程序，那么你可以使用MPI_InitFinalize类的构造函数的可选第三个参数来实现相同的目标。
*

*
* [2.x.147] deal.II内部有一小部分地方也明确使用了基于线程的并行性，例如用于运行需要等待输入或输出发生的后台任务，因此不会消耗太多的CPU时间。这种线程不在TBB任务调度器的控制下运行，因此不受上述程序的影响。在某些情况下，deal.II也会调用BLAS库，它有时也可能启动自己的线程。你将不得不查阅你的BLAS安装文档，以确定如何为这些操作设置线程数。


* [0.x.1]

include/deal.II-translator/A-headers/namespace_dealii_0.txt
[0.x.0]*
 这是deal.II中的所有内容都在其中的命名空间。为了避免在每个类和函数的调用前加上名字空间的名字，因此[2.x.0]在代码的顶部有一个[2.x.1]。
* 在整个文档中，为了简洁起见，名字空间的前缀被抑制了。


* [0.x.1]

include/deal.II-translator/A-headers/numerical_algorithms_0.txt
[0.x.0]*



* [2.x.0]
* 这个模块将一系列不同的类组合在一起，这些类通常在库中所有的基本三角形、DoFHandler和有限元类之上实现某种数值算法。它们之间一般是没有联系的。
* 一些类，如DerivativeApproximation、KellyErrorEstimator和SolutionTransfer，作用于已经得到的解，并计算前两种情况下的派生量，或者帮助将一组向量从一个网格转移到另一个网格。
* 命名空间MatrixCreator、MatrixTools和VectorTools提供了各种各样的服务，如创建拉普拉斯矩阵、将一个函数投影或内插到目前的有限元空间上，等等。  与DoFTools和FETools函数的不同之处在于，它们对向量（即给定三角上的有限元函数空间的成员）进行工作，或者帮助创建它。另一方面，DoFTools函数只作用于给定的DoFHandler对象而不参考数据向量，FETools对象一般与有限元类一起工作，但同样没有任何相关的数据向量。


* [0.x.1]

include/deal.II-translator/A-headers/parallel_0.txt
[0.x.0]*



* [2.x.0]



* [2.x.1]
* 本模块包含关于%并行计算的信息。它又分为 [2.x.2] 和 [2.x.3] 两部分。


* [0.x.1]*
 一个命名空间，我们在其中定义类和算法，处理当deal.II被配置为使用多线程时在共享内存机器上的%并行运行（见[2.x.4] ），以及在%分布式内存机器上的%并行运行（见[2.x.5] ）。
*


* [2.x.6] [2.x.7] Wolfgang Bangerth, 2008, 2009


* [0.x.2]

include/deal.II-translator/A-headers/petsc_0.txt
[0.x.0]*



* [2.x.0]
* 本模块中的类是PETSc库所提供的功能的封装器。它们提供了一个现代的面向对象的接口，与 deal.II 中其他线性代数类的接口兼容。本组中的所有类和函数都驻留在一个命名空间中 [2.x.1] 。
* 这些类只有在配置deal.II时检测到PETSc安装时才可用。请参考README文件以了解更多相关细节。
* [2.x.2] Wolfgang Bangerth, 2004
*


* [2.x.3]


* [0.x.1]

include/deal.II-translator/A-headers/physics_0.txt
[0.x.0]*



* [2.x.0]


*
* [2.x.1]与连续体物理学、物理场和材料有关的课程。


* [0.x.1]*
 命名空间和实用程序的集合，以协助定义、构建和操作与物理场和材料有关的数据。


* [0.x.2]*
   减少张量的顺序的符号，有效地将它们存储在某种一致的压缩存储模式中。一个例子是将[2.x.2]等级2的对称张量的6个独立分量存储为一个有6个分量的向量，然后将等级4的对称[2.x.3]张量的36个独立元素（当应用于一个对称等级2张量时，会产生另一个对称等级2张量）表示为一个[2.x.4]矩阵。     尽管这种表示张量的方法最常与四阶弹性张量的有效存储联系在一起，但随着它的泛化，它具有更广泛的适用性。这种表示方法在物理学、材料科学和有限元文献中也很常见。     张量符号有几种变化，每一种结构都略有不同。各种形式的张量符号之间的主要区别是对压缩张量的各种元素所规定的权重。   这个[1.x.0]对这个主题有一些进一步的一般见解。    
* [2.x.5] [2.x.6] Jean-Paul Pelteret, 2017
* [0.x.3]*
  一组操作，以协助张量从参考到空间配置的转换，反之亦然。  这些类型的转换通常用于以第二种配置重新表达在一种配置中测量或计算的数量。
* [1.x.1]
* 我们将对坐标[2.x.7]、变换[2.x.8]、微分算子[2.x.9]和变形梯度[2.x.10]使用与命名空间[2.x.11]相同的符号。
* 作为符号的另一点，我们将遵循Holzapfel（2007）的做法，将前推变换表示为[2.x.12]，后拉变换表示为[2.x.13] 。  我们还将使用注释[2.x.14]来表示张量[2.x.15]是反变量张量，[2.x.16]表示它是协变的。换句话说，这些索引实际上并不改变张量，它们只是表明某个张量的[1.x.2]对象。
*
* [2.x.17] 对于这些变换，除非另有说明，我们将严格假定变换后的张量的所有指数来自一个坐标系；也就是说，它们不是多点张量（如弹性中的皮奥拉应力）。
*
* [2.x.18]
* [2.x.19] Jean-Paul Pelteret, Andrew McBride, 2016
* [0.x.4]*
   这个命名空间提供了一个符合（非线性）弹性中使用的标准符号的定义集合。     [1.x.3] 这个符号的参考文献包括：。  
* [1.x.4]
* 为方便起见，我们将预先定义一些常用的参考张量和操作。   考虑到参考（材料）配置中的位置向量[2.x.20]，点[2.x.21]通过非线性图[1.x.5]被转换为当前（空间）配置中的点[2.x.22]，其中[2.x.23]代表位移向量。   由此我们可以计算出变形梯度张量为[1.x.6]，其中微分算子[2.x.24]被定义为[2.x.25]，[2.x.26]是身份张量。     最后，两个普通张量算子由[2.x.27]和[2.x.28]算子表示。它们分别代表对内部张量指数的单缩和双缩。   向量和二阶张量用粗体字突出，而四阶张量则用卡列字体表示。     我们可以把四阶张量看作是将二阶张量（矩阵）映射到自己身上的线性运算符，其方式与矩阵将向量映射到向量上一样。   为了给已实现的类成员和函数提供一些背景，考虑对具有特殊属性的张量进行以下基本操作。     如果我们把一般的二阶张量表示为[2.x.29]，那么一般的四阶单位张量[2.x.30]和[2.x.31]由[1.x.7]定义，或者用表记法表示为[1.x.8]，克朗克三角采用其共同定义。   请注意，[2.x.32] 。     然后我们用[1.x.9]定义对称和偏斜对称的四阶单位张量，这样[1.x.10] identity_tensor()返回的四阶对称张量是[2.x.33] 。      [2.x.34] Jean-Paul Pelteret, Andrew McBride, 2016年
* [2.x.35]
* [0.x.5]

include/deal.II-translator/A-headers/polynomials_0.txt
[0.x.0]*



* [2.x.0]
* 本模块将定义某些多项式函数家族的类归类。特别是，这包括等距支持点的拉格朗日插值多项式和它们在更高维度上的张量乘积，但也包括更奇特的如Brezzi-Douglas-Marini或Raviart-Thomas空间。


* [0.x.1]

include/deal.II-translator/A-headers/preconditioners_0.txt
[0.x.0]*



* [2.x.0]
* [1.x.0]
* 先决条件是用来加速线性系统的迭代求解的。典型的前置条件是Jacobi、Gauss-Seidel或SSOR，但该库也支持更复杂的前置条件，如Vanka或不完全LU分解（ILU）。此外，稀疏直接求解器在可用的情况下也可以作为预处理器使用。
* 广义上讲，预处理器是一种运算器，它与矩阵相乘以改善条件。其想法是，经过预处理的系统[1.x.1]比原始系统[1.x.2]更容易解决。这到底意味着什么，取决于矩阵的结构，在此不能作一般性讨论。对于对称的正定矩阵[1.x.3]和[1.x.4]，这意味着[1.x.5]的光谱条件数（最大和最小特征值的商）比[1.x.6]的要小得多。
* 在最简单的例子中，Richardson迭代，在SolverRichardson中实现，预处理迭代看起来像[1.x.7]。 因此，预处理相当于对残差应用一个线性算子，因此，预处理器[1.x.8]的动作被实现为<tt>vmult()</tt>。deal.II中需要预处理器的模板用[2.x.1]"预处理器类型概念 "来表示。在实践中，我们通常可以将任何定义了[2.x.2]的矩阵类对象作为一个预处理程序。本模块中的所有预处理类都实现了这个接口。
* 当用于Krylov空间方法时，由该方法决定是用[1.x.9]替换[1.x.10]的乘法（例如SolverBicgstab），还是做更复杂的事情。例如，SolverCG使用[1.x.11]来定义内积，这就是为什么它需要一个对称的正定算子[1.x.12]的原因。
* [1.x.13]
* 许多预处理程序依赖于加法拆分[1.x.14]为两个矩阵。在这种情况下，上述Richardson方法的迭代步骤可以简化为[1.x.15]，从而完全避免了与[1.x.16]的乘法。我们把以这种方式将前一个迭代[1.x.17]映射到下一个迭代的算子称为放松算子。它们的通用接口由[2.x.3]"松弛类型概念 "给出。本模块中名字以<tt>Relaxation</tt>开头的类实现了这个接口，还有预处理器PreconditionJacobi、PreconditionSOR、PreconditionBlockJacobi、PreconditionBlockSOR和PreconditionBlockSSOR。
* [1.x.18]
* 在这一节中，我们讨论了预设条件器通常必须提供的接口，以便在deal.II库内工作。
* [1.x.19]
* 为了能够存储在容器中，所有的预处理程序都有一个没有参数的构造函数。由于这通常会产生一个无用的对象，所有的预处理程序都有一个函数


* [1.x.20]
*
* 这个函数接收要预处理的矩阵以及其他所需的参数，并设置预处理程序的内部结构。
* [1.x.21]
* 一些预处理程序，如SOR和Jacobi，在被用作预处理程序之前，早已作为迭代求解器使用。因此，它们同时满足[2.x.4] "MatrixType "和[2.x.5] "RelaxationType "概念。
*


* [2.x.6]


* [2.x.7]


* [0.x.1]

include/deal.II-translator/A-headers/quadrature_0.txt
[0.x.0]*



* [2.x.0]
* 本模块包含基类正交以及由deal.II提供的正交公式。正交公式提供了两个基本数据：单元格[0,1]^d上的正交点的位置，以及每个正交点的权重。
* 由于deal.II使用四边形和六面体，几乎所有的正交公式都是作为定义在单位区间[0,1]上的一维正交公式的张量产物产生的，这使得它们在高维情况下的定义几乎是微不足道的。然而，通过QAnisotropic类，该库也允许各向异性的张量产品（一个坐标方向上的正交点比另一个方向上的多），以及定义不是张量产品的正交公式。
* 从总体上看，这个模块的类与库中的其他各种部分相互作用。


* [1.x.0]


* [1.x.1]
* 正交公式除其他用途外，还可用于积分矩阵条目和右手边矢量的分量。为此，定义在单元格上的正交点必须被映射到实数单元格上的相应位置，并且权重必须乘以雅各布的行列式。这一步是由派生自Mapping基类的类来完成的，尽管这通常是隐藏的，因为如果没有提供特定的映射，库的许多部分会退回到使用MappingQ1类型的对象。
* 下一步是评估形状函数和它们在这些位置的梯度。虽然从FiniteElement基类派生出来的类提供了对单元格上形状函数的描述，但在正交点上的实际评估以及将其与从映射中获得的信息结合起来的工作是由FEValues类及其关联者完成的。因此，从本质上讲，FEValues类是对有限元空间（由FiniteElement类定义）的视图，在正交点（由正交类提供）上进行评估，并映射到真实空间（而不是单元空间）的单元内的位置（由Mapping类提供映射）。
* FEValues类作为副产品，提供了映射到实数单元的正交点的位置，也可用于其他用途。例如，这可以用来在这些点上评估一个右手边的函数。
*

* [1.x.2]
* QIterated类用于从现有的正交公式中构造一个迭代的正交公式，从而在不增加阶数的情况下提高公式的精度。例如，通过对点在0和1、权重为1/2和1/2的梯形规则进行两次迭代，我们可以得到一个点在0、1/2和1、权重分别为1/4、1/2和1/4的正交公式。这个公式是通过将正交公式分别投射到子区间[0,1/2]和[1/2,1]上，然后将左边区间的右端点与右边区间的左端点合并得到的。以同样的方式，所有的一维正交公式都可以被迭代。高维迭代公式是作为一维迭代公式的张量积产生的。
*

* [1.x.3]
* 高维的通常正交公式产生的张量产品在每个方向上都是相等的，而QAnisotropic类产生的张量产品在每个方向上可能是不同的公式。
*

* [1.x.4]
* QProjector类本身实际上不是正交规则，但它提供了在高维单元表面计算正交公式的函数。
* 本模块中的所有其他类实际上实现了不同顺序和其他特征的正交规则。
*

* [1.x.5]
* 该类用于根据标识正交公式的字符串生成一个正交对象。这在希望在输入文件中指定某个正交公式，而不是在程序中硬编码的情况下很有用。


* [0.x.1]

include/deal.II-translator/A-headers/reordering_0.txt
[0.x.0]*



* [2.x.0]


*
* [2.x.1] 对象。
* [1.x.0]
* 在deal.II中的三角形有一个特殊的结构，即不仅有单元，而且有面，在三维中还有边，它们都是自己的对象。面和边都有独特的方向，而且它们相对于相邻的单元也有特定的方向。因此，在两个空间维度中分隔两个单元的线不仅有一个方向，而且相对于与第一条线相邻的两个四边形的其他线，它也必须有一个明确的方向。同样的定义也适用于三维单元和分隔它们的物体（线、四边形）。
* 例如，在二维空间中，一个四边形由四条线组成，这些线有一个方向，根据定义是这样的。


* [1.x.1]
* 现在，两个相邻的单元格必须有一个顶点编号，使公边的方向相同。例如，以下两个四边形


* [1.x.2]
*可以用顶点编号<tt>(0 1 3 4)</tt>和<tt>(1 2 4 5)</tt>来描述，因为从两个单元格看，中间线会得到方向<tt>1->4</tt>。  编号<tt>(0 1 3 4)</tt>和<tt>(5 4 2 1)</tt>将是不允许的，因为左边的四边形会给公共线以<tt>1->4</tt>的方向，而右边的会想用<tt>4->1</tt>，导致歧义的产生。
* 作为附带说明，我们注意到，如果人们采纳了拥有面的方向是有用的这一观点，那么如上所示的一个单元的四个面的方向几乎是必要的。特别是，不可能使它们的方向代表（逆）时针的意义，因为那样的话，我们就不能为下面的三块细胞找到一个有效的方向。


* [1.x.3]
*（读者需要尝试找到一个符合要求的线方向的选择；很快就会发现不可能存在这样的东西，即使我们允许可能存在同时具有顺时针和逆时针方向的线的单元。
* 有人可能会说，对面和边的唯一方向的定义，以及相对于它们所约束的单元格的方向的定义，是deal.II的一个错误特征。事实上，这使得阅读由网格生成器创建的网格变得相当困难，因为它们在生成输出时通常不会遵循这些惯例。另一方面，有很好的理由引入这些约定，因为它们在很多情况下可以使编程变得更简单，导致一些计算速度的提高，因为我们可以在很多地方避免昂贵的检查，因为面的方向是已知的，假设它是由三角法保证的。
* 本课的目的是为一组给定的单元格找到一个排序，使生成的三角形满足上述的所有要求。为此，我们将首先展示一些例子，说明为什么这是一个困难的问题，然后开发找到这种重新排序的算法。请注意，该算法是在一组CellData对象上操作的，这些对象是用来向三角剖分类描述一个网格的。例如，这些对象是由GridIn类在从输入文件读入网格时生成的。
* 作为第一节的最后一个问题：对于一个给定的领域细分为单元格，是否能保证面的这种方向总是存在？下面描述的2d的线性复杂度算法也证明了2d的答案是肯定的。对于3D，答案是否定的（这也强调了使用这种方向可能是一种
*
*--不幸的是无法治愈的
*
* - 交易二的错误特征）。)一个简单的三维反例说明了这一点：取一串三维单元并将其弯曲成一个环形。由于单元中的对立线需要有相同的方向，所以对它们有一个简单的排序，例如所有的线都是径向向外，切向顺时针，和轴向向上的。然而，如果在连接细胞串的两端之前，将细胞串扭转180度，那么就不可能再有这样的方向，这一点可以很容易地检查出来。实际上，有些网格不能用于deal.II。为了克服这个问题，引入了[2.x.2]、[2.x.3]标志。有了这些标志，就有可能处理所有的纯六面体网格。然而，为了减少可能的bug的影响，还是应该尝试对网格进行重新排序。只有当这个程序失败时，才应该使用原始的连接信息。
*

* [1.x.4]
* 如前所述，对单元格的顶点列表进行重新排序，从而得到的网格并不是一个微不足道的问题。特别是，只看一个单元格的邻域往往是不够的，它不能在不违反上述要求的情况下被添加到其他单元格的集合中。我们将展示两个例子，这一点很明显。
* 第一个这样的例子是下面的，我们将称之为 "最后的四个单元格"，因为这四个单元格靠近每一行三个垂直单元格的右端（在下面的图片中，我们只显示了左边的这样一列三个单元格，但是我们将指出如果我们延长这个列表会发生什么）。


* [1.x.5]
* 假设你在左侧边界的单元格中对顶点进行了编号，从而诱导出以下线条方向。


* [1.x.6]
* 例如，这可以通过使用索引<tt>（0 1 3 4）</tt>，<tt>（3 4 6 7）</tt>，<tt>（6 7 9 10）</tt>来完成。现在，你将找不到一种方法来给出正确的单元格的指数，而又不对某条线或其他线引入歧义，或者不违反每个单元格内必须有一个顶点，两条线都从这个顶点出发，而相邻的两条线都指向这个顶点。
* 在这种情况下，解决方案是对三个左边单元格中的一个重新编号，例如，通过对左上角单元格的编号<tt>(9 6 10 7)</tt>来恢复顶点7和10之间的线的意义。


* [1.x.7]
*
* 这里的重点是：假设我们想把网格向左延长，像这样。


* [1.x.8]
* 然后我们会遇到和上面一样的问题，如果我们把左边的单元格统一排序，从而迫使我们把一个单元格（就是上面我们可以排序为<tt>(9 6 7 10)</tt>的那个单元格）的排序还原。然而，由于相反的线必须有相同的方向，这又会迫使我们旋转它左边的单元格，然后再旋转左边的单元格，如此反复，直到我们到达网格的左端。因此，这是一个我们必须追溯到第一列的三个单元的例子，以找到一个一致的排序，如果我们最初是均匀地排序。
* 作为第二个例子，请考虑下面这个简单的网格，其中单元格的编号顺序很重要。


* [1.x.9]
* 我们在这里只指出了相关顶点的数字。假设用户通过顶点指数<tt>0 1 3 2</tt>和<tt>6 7 5 4</tt>给单元格0和1。那么，如果我们按照这个方向，为这两个单元格创建线条后的网格会是这样的。


* [1.x.10]
* 现在，由于相反的线必须指向同一方向，我们只能将单元格2到N-1添加到单元格1，使所有垂直线都指向下方。然而，我们不能向任何方向添加单元格N，因为它将有两条不指向同一方向的相反线。我们必须旋转0号或1号单元格，以便能够添加所有其他单元格，从而满足交易.II三角形的要求。
* 这两个例子说明，如果我们在某个方向上添加了一定数量的单元格，而在添加下一个单元格时又不能不引入已经在另一个方向上添加的面，那么只旋转我们未能添加的单元格附近的单元格可能是不够的。可能有必要回到很远的地方，旋转很久以前就已经输入的单元。
*

* [1.x.11]
* 从上面的例子可以看出，如果我们遇到一个不能被添加到已经输入的单元格中的单元格，我们通常不能指出哪个单元格是罪魁祸首，必须以不同的方向输入。此外，即使我们知道哪个单元格，也可能有大量的单元格不再适合于网格，我们也必须找到不同的方向（在上面的第二个例子中，如果我们旋转了单元格1，那么我们也必须旋转单元格1到N-1）。
* 解决这个问题的蛮力方法如下：如果单元格N不能被添加，那么就尝试旋转单元格N-1。如果我们不能再旋转单元格N-1，那么就尝试旋转单元格N-2，并尝试用单元格N-1的所有方向添加单元格N。以此类推。在算法上，我们可以用一个树状结构来表示，节点N有多少个子节点N+1的可能方向，就有多少个子节点（在两个空间维度上，有四个方向，每个单元可以由其四个顶点构建。例如，如果顶点指数是<tt>(0 1 3 2)</tt>，那么四个可能性是<tt>(0 1 3 2)</tt>，<tt>(1 3 2 0)</tt>，<tt>(3 2 0 1)</tt>，和<tt>(2 0 1 3)</tt>）。)当添加一个又一个单元格时，我们以深度优先（pre-order）的方式遍历这个树。当我们遇到从根（单元格0）到叶（最后一个单元格）的路径不允许时（也就是说，通过树的路径所编码的单元格的方向不能导致有效的三角形），我们必须追踪并尝试通过树的另一条路径。
* 当然，在实践中，我们并不是沿着每条路径走到最后一个节点，然后找出一条路径是否导致了有效的三角结构，而是使用一个归纳论证：如果对于所有先前添加的单元格，三角结构是有效的，那么我们可以通过检查进入当前单元格是否会引入任何具有非唯一方向的面，来找出一条穿过树的路径是否可以产生有效的三角结构；如果是这样，那么我们可以停止跟踪这一点以下的所有路径并立即追踪回去。
* 尽管如此，已经很明显的是，这棵树在两个空间维度上有[2.x.4]个叶子，因为每个[2.x.5]个单元可以在四个方向上添加。这些节点中的大部分可以被迅速丢弃，因为首先第一个单元格的方向是不相关的，其次如果我们添加的一个单元格的邻居已经被添加了，那么已经只剩下两个可能的方向了，所以我们要做的检查总数直到我们找到一个有效的方式，明显小于[2.x.6] 。然而，该算法在时间上仍然是指数级的，在内存上是线性的（我们只需要以已经添加的单元格的方向堆栈的形式来存储当前路径的信息）。
* 事实上，上面的两个例子表明，指数估计并不是悲观的：我们确实要追踪到那里的一个最开始的单元格，以找到一个以一致方式添加所有单元格的方法。
* 这种令人沮丧的情况因以下事实而大为改善：我们有一种用于2D的替代算法，在运行时间上总是线性的（由德克萨斯大学TICAM的迈克尔-安德森在2003年发现并实现），而对于3D，我们可以找到一种算法，在实践中通常只在时间和内存上是大致线性的。我们将在下文中描述这些算法。完整的描述和理论分析见 [2.x.7] 。
*

* [1.x.12]
*该算法使用了这样一个事实：一个单元格的相对面需要有相同的方向。所以你从一条任意的线开始，选择一个方向。那么对面的面的方向就已经固定了。然后去看我们已经固定的两个面对面的两个单元格：对它们来说，一个面已经固定了，所以我们也可以固定对面的面。继续这样做。最终，我们对一连串的单元格进行了这样的处理。然后从一个已经有两个固定面的单元格中抽取一个非固定面，再做一遍。
* 更详细地说，这个算法最好用一个例子来说明。我们考虑下面的网格。


* [1.x.13]
* 首先选择一个单元格（本例中为（0,1,3,4））。单元的一个侧面被任意地定向（3->4）。这个方向的选择然后在网格中传播，跨越边和元素。(0->1), (6->7)和(9->10)。这涉及到边跳和面跳，给出了一个以圆点显示的穿过网格的路径。


* [1.x.14]
* 然后对所选元素的其他面重复这一过程，对网格的更多面进行定向。


* [1.x.15]
* 一旦一个元素被完全定向，就不需要再考虑了。这些元素在图中用o来填充。然后我们转到下一个元素。


* [1.x.16]
* 重复这样做可以得到


* [1.x.17]
* 而最终的导向网是


* [1.x.18]
* 很明显，这个算法的运行时间是线性的，因为它对每个面只精确地接触一次。
* 刚才在二维情况下描述的算法在这个类中对二维和（通用形式）三维都有实现。三维情况下，使用片状而不是单元格串来工作。如果网格是可定向的，那么该算法能够在线性时间内完成其工作；如果它是不可定向的，那么它也会在线性时间内中止。
* 这两种算法在论文 "On orienting edges of unstructured two- and three-dimensional meshes "中描述，R. Agelek, M. Anderson, W. Bangerth, W. L. Barth, ACM Transactions on Mathematical Software, vol. 44, article 5, 2017。预印本可作为[1.x.19]使用。
*

* [1.x.20]
* 在实现上述算法之前（最初由Michael Anderson在2002年实现，由Wolfgang Bangerth在2016年根据[2.x.8]中的工作重新实现），我们使用了一个最初由Wolfgang Bangerth在2000年实现的分支和切割算法。虽然它不再被使用，但这里是它的工作原理，以及为什么它不总是对大网格有效，因为它的运行时间在糟糕的情况下可能是指数级的。
* 第一个观察结果是，虽然有反例，但问题通常是局部的。例如，在上面提到的第二个例子中，如果我们对单元格进行了编号，使相邻的单元格具有相似的单元格号，那么需要的回溯量就会大大减少。因此，在算法的实施过程中，第一步是以Cuthill-McKee的方式对单元格进行重新编号：从邻居数量最少的单元格开始，给它分配单元格编号为0。然后找到这个单元格的所有邻居，再给它们分配连续的数字。然后找到它们尚未被编号的邻居，给它们编号，以此类推。从图形上看，这意味着找到连续远离初始单元的单元区，并以这种前行的方式为它们编号。这已经大大改善了问题的局部性，从而减少了必要的回溯量。
* 第二点是，我们可以使用一些方法来修剪树，这通常会导致所有单元的有效方向非常快。
* 第一个方法是基于这样的观察：如果我们不能插入一个编号为N的单元格，那么这可能不是由于单元格N-1造成的，除非N-1是N的直接邻居。原因很明显：单元格M的选择方向只能影响添加单元格N的可能性，如果它是一个直接邻居，或者如果有一连串的单元格在M之后被添加并且连接单元格M和N。反过来说，如果我们不能添加单元格N，那么就没有必要追踪到单元格N-1，但我们可以追踪到单元格索引最大且已经被添加的N的邻居。
* 不幸的是，如果不谨慎应用，这种方法可能无法产生一个有效的树的路径。考虑以下情况，最初是从BAMG程序自动生成的950个单元的网格中提取的（这个程序通常生成的网格是相当不平衡的，通常有许多
*
* - 有时是10个或更多
*
* - 一个顶点的邻居，并且在最初的算法中暴露了一些问题；还要注意的是，这个例子是在2D中，我们现在有上面描述的更好的算法，但同样的观察也适用于3D）。)


* [1.x.21]
* 请注意，中间有一个洞。现在假设用户用顶点数字<tt>2 3 6 7</tt>来描述第一个单元格0，用<tt>15 14 11 10</tt>来描述单元格5，并假设单元格1、2、3、4的编号是可以在初始旋转中加入5。所有其他的单元格都以通常的方式进行编号，即从左下角开始，逆时针计数。鉴于对单元格的这种描述，算法将从零单元格开始，一个接一个地添加单元格，直到第六个。然后情况会是这样的。


* [1.x.22]
* 现在来看看第7个单元格，我们看到它的顶部和底部的两条相对的线有不同的方向；因此，我们将发现没有任何方向的第7个单元格可以在不违反三角形的一致性的情况下被添加。根据上述规则，我们回到索引最大的邻居，也就是单元格6，但由于它的底线是向右的，它的顶线也一定是向右的，所以我们无法找到单元格6的方向，从而使7符合三角形。然后，如果我们已经完成了单元格6的所有可能的方向，我们再追踪到6的最大索引的邻居，并且已经被添加了。然而，我们知道0号单元格的方向不可能是重要的，所以我们得出结论，没有任何可能的方法来确定给定单元格的所有线条的方向，使它们满足deal.II三角形的要求。我们知道这是不可能的，所以会导致抛出一个异常。
* 这个例子的底线是，当我们看了所有可能的单元格6的方向时，我们找不到一个可以添加单元格7的方向，然后决定追踪回单元格0，我们甚至没有尝试转动单元格5，之后添加单元格7就很简单了。因此，必须修改上述算法：如果我们未能在任何方向上添加一个单元格，我们只允许追踪回已经添加的那个邻居，其单元格索引最大。如果我们进一步追踪，因为我们已经用尽了所有可能的方向，但可以添加细胞（即我们追踪，因为另一个细胞，更远的地方不能添加，不管我们现在考虑的细胞的方向），那么我们不允许追踪到它的一个邻居，但必须只追踪一个细胞指数。
* 第二种修剪树的方法是，通常我们不能添加一个新的单元，因为它的一个已经被添加的邻居的方向是错误的。因此，如果我们可以尝试旋转其中一个邻居（当然要确保旋转该邻居不违反三角形的一致性），以允许现在的单元被添加。
* 第一种方法可以解释为在方向树上一次回溯不止一步，而转动一个邻居则意味着跳到树上一个完全不同的地方。对于这两种方法，人们可以找到论据，认为它们永远不会错过有效的路径，反正只跳过无效的路径。
* 这两种方法已经被证明是非常有效的。我们已经能够读取非常大的网格（几万个单元）而不需要回溯很多。特别是，我们发现找到单元格排序的时间与单元格的数量呈线性关系，而且重新排序的时间通常比从文件中读取数据所需的时间小得多（例如一个数量级），同时也比使用[2.x.9]函数从这些数据中实际生成三角图所需的时间小。
*


* [2.x.10]


* [0.x.1]

include/deal.II-translator/A-headers/simplex_0.txt
[0.x.0]*



* [2.x.0]



* [2.x.1]
* deal.II中的Simplex和混合网格仍然是实验性的，也就是正在进行的工作。该库的大部分内容已经被移植到能够操作这种网格上。然而，仍有许多函数需要被概括。通过查看 "test/simplex "文件夹中的测试，你可以对移植的功能有一个很好的概述。在下文中，我们提供了两个非常基本的例子来入门，并提供一些实现细节。
*

*
* [2.x.2] simplex_reference_example_simplex 示例：simplex网格
* 下面的代码显示了如何处理单纯x网格。
* [2.x.3]
*

*
* [2.x.4] simplex_reference_example_mixed 示例：混合网格
* 下面的代码显示了如何处理混合网格的工作。
* [2.x.5]
*

*
* [2.x.6] simplex_reference_cells 参考单元
* 在二维中，我们提供三角形和四边形，在三维中的可能方向如下。
* [2.x.7] [2.x.8] </div> [2.x.9] [2.x.10] </div> </div>
* 在三维中，四面体、金字塔、楔形和六面体都可以使用。
* [2.x.11] [2.x.12] </div> </div>
* [2.x.13] [2.x.14] </div
* [2.x.15] [2.x.16] </div
* [2.x.17] [2.x.18] </div> </div>
* 一个三维参考单元的每个表面由二维参考单元组成。枚举其顶点和线的编号的文件在右列给出。
*


* [0.x.1]

include/deal.II-translator/A-headers/slepc_0.txt
[0.x.0]*



* [2.x.0]
* 本模块中的类是对SLEPc库所提供的功能的封装。本组中的所有类和函数都驻留在一个命名空间中 [2.x.1] 。
* 只有在配置deal.II时检测到SLEPc安装和PETSc安装时，这些类才可用。请参考README文件以了解更多相关细节。
* [2.x.2] Toby D. Young, 2011



* [2.x.3]


* [0.x.1]

include/deal.II-translator/A-headers/solvers_0.txt
[0.x.0]*



* [2.x.0]
* 这个模块将迭代和直接求解器、特征值求解器和一些控制类组合在一起。所有这些类都对deal.II中定义的[2.x.1]"矩阵 "和[2.x.2]"矢量类 "的对象进行操作。
* 为了正常工作，将矩阵和向量类作为模板参数的求解器要求这些类满足某种最小的接口，可以从求解器内部使用。对于迭代求解器，这个接口被定义在求解器类中。此外，求解器使用从SolverControl类派生出来的类的对象进行控制（例如其派生类ReductionControl），以确定最大的迭代次数或所需的公差。
* 如果在配置过程中检测到（见ReadMe文件），一些稀疏的直接求解器也被支持。
*


* [2.x.3]


* [0.x.1]

include/deal.II-translator/A-headers/sparsity_0.txt
[0.x.0]*



* [2.x.0]
* 几乎所有的有限元公式都会导致矩阵的 "稀疏"，即每行的非零元素数量(i)与矩阵的整体大小相比相对较小，并且(ii)被一个固定的数字所限制，如果网格被细化，这个数字不会增长。在这种情况下，不存储矩阵的[1.x.0]元素，而只存储那些实际（或可能）为非零的元素会更有效。这需要为每一行存储非零项的列索引（我们称之为 "稀疏模式"），以及这些非零项的实际值。在实践中，有时会出现一些非零值实际上为零的情况。稀疏模式和稀疏矩阵只打算为[1.x.1]非零的条目提供空间，而且是在我们还不知道这些条目最终会有什么值的时候这样做；如果一个系数或单元格恰好有特定的值，它们可能会有一个零值）。)
* 在deal.II中，稀疏模式通常与实际的稀疏矩阵分开（除了SparseMatrixEZ类和一些来自外部库接口的类，如PETSc）。原因是人们经常有几个共享相同稀疏模式的矩阵；例子包括时间步进方案所需的刚度和质量矩阵，或者广义特征值问题的左手和右手矩阵。因此，如果它们中的每一个都必须单独存储它们的稀疏性模式，那将是一种浪费。
* 因此，deal.II具有矩阵类所建立的稀疏模式类。有两组主要的稀疏模式类，如下所述。
*

* [1.x.2]
* deal.II中的主要稀疏矩阵类，SparseMatrix，只为每个矩阵条目存储一个值，但不存储这些条目的位置。为此，它依赖于从与该矩阵相关的稀疏模式对象中获得的信息。这个稀疏性模式对象必须是SparsityPattern类型的。
* 因为矩阵是大的对象，而且改变它们的成本相对较高，所以SparsityPattern对象的构建分为两个阶段：首先，在一个 "动态 "阶段，分配期望在其上构建的矩阵有非零条目的位置；在第二个 "静态 "阶段，这些非零位置的表示被 "压缩 "成通常的压缩稀疏行（CSR）格式。在这之后，不能再添加新的非零位置。只有在压缩之后才能将稀疏模式与矩阵联系起来，因为后者需要前者的高效压缩数据格式。在动态阶段建立一个稀疏模式经常发生在[2.x.1]函数中。虽然这看起来是一个限制，但首先建立一个稀疏模式，然后只在先前分配的位置写入矩阵，这通常不是一个重要的问题，因为在有限元代码中，通常很清楚矩阵中哪些元素可能是非零的，哪些肯定是零的。
* 这种两阶段生成稀疏模式的优点是，当它实际用于矩阵时，有一个非常有效的格式。特别是，条目的位置被存储在一个线性数组中，允许快速访问，对具有深层次缓存的现代CPU类型很友好。因此，静态SparsityPattern类是deal.II的主SparseMatrix类可以工作的唯一对象。
* 静态稀疏模式的主要缺点是，它们的有效构造需要合理地猜测每一行最大可能有多少条目。在实际构建过程中，例如在[2.x.2]函数中，最多只能分配到之前所说的那么多条目。这是一个问题，因为通常很难估计每行的最大条目数。因此，一个常见的策略是首先建立和中间的稀疏模式，在构建稀疏模式的过程中使用效率较低的存储方案，然后直接复制到静态的、压缩的形式。大多数教程程序都是这样做的，从[2.x.3]开始（也可参见，例如[2.x.4]，[2.x.5]，和[2.x.6]教程程序）。
*

* [1.x.3]
* 如上所述，要获得一个稀疏模式的每一行的最大条目数的良好估计往往很复杂。因此，任何试图用不好的估计来分配一个普通的SparsityPattern的做法都需要大量的内存，几乎所有的内存都不会被使用，在压缩时被取消分配。
* 为了避免这种情况，deal.II包含一个名为DynamicSparsityPattern的 "动态 "或 "压缩 "稀疏性模式，它只分配必要的内存来容纳当前添加的条目。虽然这比上面提到的最坏情况下的行为节省了很多内存，但它需要使用效率较低的存储方案来插入元素，而且频繁分配内存往往也需要大量计算时间。然而，避免过多的内存分配的权衡是无法避免的。
*该类通常以如下方式使用


* [1.x.4]
*
* 中间的、压缩的稀疏模式被直接复制到最终静态模式的 "压缩 "形式中。
* [1.x.5]
* BlockDynamicSparsityPattern类实现了一个用于构造块矩阵的动态稀疏模式数组。更多信息见文档和[2.x.7]。
*


* [2.x.8]


* [0.x.1]

include/deal.II-translator/A-headers/trilinos_0.txt
[0.x.0]*



* [2.x.0]
* 本模块中的类是对Trilinos库所提供的功能的封装。它们提供了一个现代面向对象的接口，与deal.II中其他线性代数类的接口兼容。本组中的所有类和函数都驻留在一个命名空间中[2.x.1] 。
* 这些类只有在配置deal.II时检测到有Trilinos安装时才可用。请参考README文件以了解更多相关细节。
* [2.x.2] Martin Kronbichler, Wolfgang Bangerth, 2008
*


* [2.x.3]


* [0.x.1]

include/deal.II-translator/A-headers/update_flags_0.txt
[0.x.0]*



* [2.x.0]
* [1.x.0]
* 为了计算单个单元对全局矩阵和右手边的局部贡献，我们通常采用两种技术。
*


*
* - 首先，积分从实际单元[2.x.1]转换到单位/参考单元[2.x.2] 。例如，对于拉普拉斯方程，我们将[1.x.1]转换为[1.x.2]，其中帽子表示参考坐标，而[2.x.3]是映射[2.x.5]的雅各布[2.x.4] 。
*


*
* - 第二，这个积分然后通过正交法进行近似。这就产生了公式[1.x.3]，其中[2.x.6]表示正交点的索引，[2.x.7]其在参考单元上的位置，以及[2.x.8]其重量。
* 为了在应用程序代码中评估这样的表达式，我们必须访问三种不同的对象：描述参考单元上正交点的位置[2.x.9]和权重[2.x.10]的正交对象；描述单元上形状函数梯度[2.x.11]的有限元对象；以及提供雅各布系数和其行列式的映射对象。处理所有这些对象会很麻烦而且容易出错。
* 另一方面，这三种对象几乎总是一起出现，事实上，除了一起使用正交、有限元或映射对象，deal.II的应用代码很少对它们做任何事情。由于这个原因，deal.II使用FEValues抽象，结合了形状函数、实际网格单元的几何信息和参考单元的正交规则。在构建时，它在上述三个类别中各取一个对象。之后，它可以为一个具体的网格单元 "重新初始化"，然后提供映射的正交点和权重，映射的形状函数值和导数，以及从参考单元到实际网格单元转换的一些属性。
* 由于任何这些值的计算都是潜在的昂贵的（例如，当使用高阶元素的高阶映射时），FEValues类只计算它被明确要求的值。为此，它在构建时需要一个UpdateFlags类型的标志列表，指定每次访问一个单元时应该更新哪些数量。在上面的例子中，你想要实数单元上形状函数的梯度，这由标志 [2.x.12] 编码，以及雅各布系数的行列式乘以正交权重的乘积，这用术语 [2.x.13] 记忆性地编码了。因为这些标志是由整数中的单比特表示的，产生一个[1.x.4]相当于在一个整数中设置多个比特，这是用操作[2.x.14]来促进的（换句话说，也许有点混乱，操作[2.x.15]操作[1.x.5]，操作[2.x.16]是由表达[2.x.17][1.x.6] 单位-整数-该操作 [2.x.18] 为了使操作更便宜，FEValues和它所依赖的映射和有限元对象实际上只计算你在更新标志中指定的那些信息（加上一些计算指定内容所需的信息，见下文），而不是可能在一个单元上计算的所有信息。这种优化使得在单元格上进行迭代装配的成本大大降低，但这也意味着我们应该注意提供尽可能少的标志集。
* 此外，一旦你传递了一组你想要的标志，填充FEValues数据字段的函数就能够区分必须在每个单元上重新计算的值（例如映射梯度）和单元间不发生变化的量（例如不同单元上同一正交点的通常[2.x.19]有限元的形状函数值；但是这一特性对于Raviart-Thomas元素的形状函数不成立，它必须随本地单元旋转）。这允许进一步优化底层装配的计算。
*

* [1.x.7]
* 假设你想计算如上所示的拉普拉斯矩阵。在这种情况下，你需要指定[2.x.20]标志（用于[2.x.21]）和[2.x.22]标志（用于计算[2.x.23] ）。然而，在内部，有限元要求计算完整的雅各布矩阵的逆，[2.x.24]（而不仅仅是矩阵的行列式），为了计算雅各布矩阵的逆，还需要先计算雅各布矩阵。
* 由于这些是对用户不重要的要求，所以没有必要在用户代码中指定。相反，给定一组更新标志，FEValues对象首先询问有限元对象需要计算哪些信息，以满足用户在更新标志中提供的要求。因此，有限元对象可以向更新标志添加其他标志（例如，在上面的例子中，FE_Q对象将向列表中添加[2.x.25]，因为这是从[2.x.26]到[2.x.27]的必要转换）。有了这些更新的标志，FEValues就会通过调用[2.x.28]来询问映射是否也要在列表中添加更多的标志，以满足用户和有限元对象的需要（这种先询问有限元，再询问映射的程序不需要迭代，因为映射从来不需要有限元类计算的信息，而有限元类通常需要映射计算的信息）。使用这个最终的列表，FEValues对象然后要求有限元对象和映射对象都创建临时结构，将一些可以一次性计算的临时信息存储到其中，这些标志将在以后我们访问的每个单元上重新计算数据时使用。
*

* [1.x.8]
*如上所述，我们现在已经确定了满足用户所需信息的最后一套东西，这些信息是由他们提供的更新标志所传达的。然后，这些信息通常会在随后的整合循环中对用户代码访问的每个单元进行查询。
* 鉴于许多映射或有限元类的计算都是潜在的昂贵的，FEValues采用了一个系统，鼓励映射和有限元对象预先计算那些无需参考具体单元就能计算的信息，并在要求访问网格的特定单元时利用这些信息。一个例子是，普通FE_Q元素的形状函数的值是在参考单元上定义的，而实际单元上的值正好是参考单元上的值
*
* 因此，没有必要对每个单元格的形状函数进行评估，只需在开始时进行一次评估，将数值存储在某个地方，当访问一个具体的单元格时，只需将这些数值从临时位置复制到输出结构中即可。(但是请注意，这是FE_Q元素所特有的：如果我们使用FE_RaviartThomas元素就不是这样了，因为在那里，计算一个单元上的形状函数值需要知道映射的Jacobian，这取决于我们访问的单元的几何形状；因此，对于这个元素，简单地复制预先计算的信息并不足以评估特定单元上的形状函数值。)
* 为了适应这种结构，映射和有限元类都可以在内部将更新标志分成两组，通常被称为[2.x.29]（尽管这些名称没有出现在任何公共接口中）。前者包含所有那些在FEValues对象开始与映射或有限元交互时可以预先计算一次的信息，而后者则包含那些对应于需要在每个单元上计算的标志。例如，如果[2.x.30]，那么FE_Q类将设置[2.x.31]和[2.x.32]，而Raviart-Thomas元素将以相反的方式进行。
* 这些标志集的目的是相互排斥的。另一方面，没有任何东西可以为映射或有限元类之外的东西提供这种分解。
*
* - 它是一个纯粹的内部分解。
*

* [1.x.9]
* 如上所述，数据在两个不同的时间被计算：一次是在开始时在参考单元格上，另一次是每当我们移动到一个实际单元格时。接下来将讨论每个步骤所涉及的函数。
*

* [1.x.10]
* 在我们还没有访问第一个真实单元之前，计算参考单元的数据是一个两步的过程。首先，FEValues、FEFaceValues和FESubfaceValues的构造函数分别需要让Mapping和FiniteElement对象建立内部数据结构。这些结构在以下意义上是内部的：FEValues对象要求有限元和映射对象各创建一个[2.x.33]和[2.x.34]类型的对象；如果实际的有限元和映射类希望存储一些超出这些基类已经提供的数据，实际上可以创建衍生类型的对象。这其中涉及的函数有 [2.x.35] [2.x.36] [2.x.37] [2.x.38] [2.x.39] [2.x.40] [2.x.41] [2.x.42] 。
* 然后，FEValues对象接管了这些对象的所有权，并将在FEValues对象的生命周期结束时销毁它们。之后，FEValues对象要求FiniteElement和Mapping对象向这些InternalDataBase对象中填充与参考单元上可以和需要计算的内容有关的数据。这是在这些函数中完成的。  [2.x.43] [2.x.44] [2.x.45] [2.x.46] [2.x.47]。
*

* [1.x.11]
* 一旦初始化结束，我们调用[2.x.48][2.x.49]或[2.x.50]来移动到一个具体的单元或面，我们需要计算 "update_each "的各种数据。这是在以下函数中完成的。  [2.x.51] [2.x.52] 调用[2.x.53] 然后[2.x.54] [2.x.55] 调用[2.x.56] 然后[2.x.57] [2.x.58] 调用[2.x.59] 然后[2.x.60] [2.x.61] 。
* 这是计算存储在[2.x.62]和[2.x.63]对象中的FEValues实际数据字段的地方。这些函数首先调用Mapping中的函数，这样，有限元所需的所有映射数据都可以得到。然后，调用FiniteElement函数。
*


* [2.x.64]


* [0.x.1]

include/deal.II-translator/A-headers/utilities_0.txt
[0.x.0]*



* [2.x.0]
* 这个模块简单地收集了一些函数和类，为那些通常与有限元程序没有太大关系，但恰好也需要的任务提供了通用工具。


* [0.x.1]*



* [2.x.1]
* 这里有几个简单的类，有助于存储和查看数据。例如，Table模板不仅允许使用对象的数组（为此可能要使用[2.x.2]类），而且还允许使用任意对象的二维（矩形）表，以及高阶类似物，直到具有（目前）七个索引的表。
* 类似地，VectorSlice函数是一个基元，它接收任何具有类似于矢量的接口的东西（例如deal.II Vector或[2.x.3]类），并对其呈现一个视图，就好像它本身是一个矢量。
*


* [2.x.4]


* [0.x.2]

include/deal.II-translator/A-headers/vector_memory_0.txt
[0.x.0]*



* [2.x.0]
* 这个模块将一些类分组，用来避免在迭代过程中反复分配和解配向量。这些方法都使用基类VectorMemory的一个对象来获取它们的辅助向量。
* 关于这个话题的一些讨论可以在[2.x.1]中关于InverseMatrix类的讨论中找到。
*


* [2.x.2]


* [0.x.1]

include/deal.II-translator/A-headers/vectors_0.txt
[0.x.0]*



* [2.x.0]
* 在这里，我们列出了所有满足[2.x.1]概念的类，它们可能被用于线性求解器（见[2.x.2] ）和矩阵-向量操作。
*


* [2.x.3]


* [0.x.1]

include/deal.II-translator/A-headers/vector_valued_0.txt
[0.x.0]*



* [2.x.0]


* 矢量值问题是偏微分方程的系统。这些问题的解变量不是一个标量函数，而是一个矢量值函数或一组函数。这包括，例如。  2.x.1] [2.x.2] [2.x.3]、[2.x.4]和[2.x.5]中讨论的弹性方程，其解是每一点的向量值位移。    2.x.6] 在[2.x.7]和[2.x.8]中讨论的混合拉普拉斯方程及其扩展，其解是每一点的标量压力和矢量速度。    [2.x.9] 在[2.x.10]中讨论的斯托克斯方程及其扩展，以及[2.x.11]，其中的解也是每一点的标量压力和矢量速度。    [2.x.12] 由实部和虚部组成的复值解，例如在 [2.x.13] 中讨论。  [2.x.14]
* 本页概述了如何在deal.II中轻松实现此类矢量值问题。特别是，它解释了FESystem类的用法，它允许我们为偏微分系统编写代码，就像我们为单个方程编写代码一样。
* [2.x.15]
* [2.x.16]
*

*
* [2.x.17] VVExamples [1.x.1]。
* 系统地处理向量值问题的方式与标量问题没有根本的不同：首先，我们需要一个考虑到所有解变量的问题的弱（变）式。在我们这样做之后，生成系统矩阵和求解线性系统遵循我们已经习惯的大纲。
* [1.x.2]
* 让我们以[2.x.18]中的弹性问题为例，甚至通过选择[2.x.19]和[2.x.20]来简化它以突出重要的概念。因此，让我们考虑下面的弱表述：找到[2.x.21]，使所有[2.x.22]都持有[1.x.3] 这里，[1.x.4]表示由[2.x.23]定义的对称梯度，冒号表示两个等级为2的张量的双重收缩（Frobenius内部积）。这种双线性形式看起来确实非常像 [2.x.24] 中泊松问题的双线性形式。唯一的区别是 [2.x.25] [2.x.26] 我们用对称梯度替换了梯度算子；这实际上不是一个重大的区别，如果你用 [2.x.28] 替换 [2.x.27] ，这里说的一切都是真的。事实上，让我们这样做来简化讨论。[1.x.5]但请注意，这个系统并不十分令人兴奋，因为我们可以分别解决[1.x.6]的三个组成部分。
* [2.x.29] 现在的试验和测试函数来自空间[2.x.30]，它可以被视为标量空间[2.x.31]的三份副本。而这正是我们将在下面使用FESystem来实现这个空间的方法。  [2.x.32]
* 但现在，让我们再仔细看看这个系统。首先，让我们利用[1.x.7]=([1.x.8]<sub>1</sub>, [1.x.9]<sub>2</sub>, [1.x.10]<sub>3</sub>)<sup>T</sup>和[1.x.11]相应。然后，我们可以把坐标中的简化方程写成[1.x.12]。 我们看到，这只是拉普拉斯的双线性形式的三份拷贝，一份应用于每个分量（这是与[2.x.33]的表述更令人兴奋的地方，我们想推导出一个也适用于该表述的框架）。我们可以通过选择特殊的测试函数使这个弱形式再次成为微分方程组：首先，选择[1.x.13]=（[1.x.14]<sub>1</sub>,0,0）<sup>T</sup>，然后[1.x.15]=（0，[1.x.16]<sub>2</sub>,0)<sup>T</sup>, 最后[1.x.17]=(0,0,[1.x.18]<sub>3</sub>)<sup>T</sup>. 将这些结果写在彼此下面，我们得到系统[1.x.19]，我们使用标准内积符号 [2.x.34] 。对我们的理解很重要的是，我们要记住，后一种形式作为PDE系统完全等同于双线性形式的原始定义[1.x.20]([1.x.21],[1.x.22])，它并不立即表现出这种系统结构。最后，让我们写出具有对称梯度的弹性方程[1.x.23]的完整系统。[1.x.24] 非常正式地，如果我们相信算子值矩阵，我们可以将其改写为[1.x.25]<sup>T</sup>[1.x.26] = [1.x.27]<sup>T</sup>[1.x.28] 或 [1.x.29] 的形式。
*[1.x.30] 现在，让我们考虑一个更复杂的例子，即[2.x.35]中讨论的三维混合拉普拉斯方程：[1.x.31]
*
*这里，我们有四个解分量：标量压力[2.x.36]和有三个矢量分量的矢量值速度[2.x.37]。请注意，作为与前一个例子的重要区别，向量空间[1.x.32]并不仅仅是三个相同空间的简单复制/。
* 对于这个问题和其他矢量问题，获得弱式或变式的系统方法是，首先将其视为一个问题，其中运算符和解变量以矢量和矩阵形式书写。对于这个例子，这将读作：[1.x.33] 。
*
* 这就清楚地表明，解[1.x.34]有四个分量。
* 确实有四个成分。我们注意到，如果我们同时改变矩阵运算符的列，我们可以改变解的成分[2.x.38]和[2.x.39]在[2.x.40]里面的顺序。
* 接下来，我们需要考虑测试函数 [2.x.41] 。我们要将方程的两边都与它们相乘，然后对[2.x.42]进行积分。结果应该是一个标量的相等。我们可以通过选择[2.x.43]来实现这一点，因为[1.x.35]也是矢量值的。
*
* 将矩阵-向量方程与测试函数从左边相乘是很方便的，因为这样我们以后会自动得到正确的矩阵（在线性系统中，矩阵也是从右边与解变量相乘的，而不是从左边），而如果我们从右边相乘，那么这样汇集的矩阵就是我们真正想要的矩阵的转置。
* 考虑到这一点，让我们乘以[2.x.44]并进行积分，得到以下方程，该方程对所有测试函数[2.x.45]必须成立：[1.x.36]
* 或者等同于：[1.x.37] 。
*
*
* 我们通过对第二项的部分积分得到最终形式：[1.x.38] 。
*
* 正是这种形式，我们以后将用于将离散的弱形式组装成一个矩阵和一个右手边的向量：在这种形式中，我们有解和测试函数[2.x.46]，每个函数都由一些向量分量组成，我们可以提取。
*

* [2.x.47] VVFEs[1.x.39] 。
* 一旦我们确定了双线性形式和函数设置，我们就需要找到一种方法来描述矢量值有限元空间，并从中提取解和检验函数。这就是FESystem类的作用：它由较简单的空间组成矢量值的有限元空间。在弹性问题的例子中，我们需要同一元素的[2.x.48]份，例如


* [1.x.40]
* 这将产生一个维度为[2.x.49]的向量估值空间，其中每个分量都是FE_Q类型的连续双线性元素。它将有[2.x.50]倍于相应的FE_Q的基函数，这些基函数中的每一个都是FE_Q的基函数，被提升到矢量的一个分量中。
* 对于混合拉普拉斯，情况更为复杂。首先，我们必须确定一对离散空间 [2.x.51] 。一种选择是稳定的Raviart-Thomas对


* [1.x.41]
* 这个系统中的第一个元素已经是一个维度为[2.x.52]的矢量值元素，而第二个元素是一个普通的标量元素。
* 除了使用稳定的Raviart-Thomas对之外，我们还可以考虑混合拉普拉斯的稳定公式，例如LDG方法。在这里，我们可以选择使用相同的空间来计算速度分量和压力，即


* [1.x.42]
* 这个系统只是有[2.x.53]个相同的不连续元素的相等拷贝，这并没有真正反映系统的结构。因此，我们倾向于


* [1.x.43]
* 这里，我们有一个由两个元素组成的系统，一个是矢量值，一个是标量值，很像与[2.x.54]。事实上，在许多代码中，这两个可以互换。这个元素也允许我们很容易地切换到速度的低阶近似的LDG方法，即


* [1.x.44]
* 必须指出的是，这个元素不同于


* [1.x.45]
* 虽然构造函数的调用与[2.x.55]非常相似，但结果实际上更像[2.x.56]，因为这个元素产生[2.x.57]的独立组件。下面是对产生的FESystem对象的更详细的比较。
* [1.x.46]
* FESystem有一些内部变量，反映了构造函数所设置的内部结构。然后这些也可以被应用程序用来给矩阵组装和线性代数提供结构。我们在下表中给出了上述例子中这些变量的名称和值。<table border="1"> <tr><th>系统元素</th> [2.x.58] [2.x.59] [2.x.60] </tr> <tr><td>[2.x.61] </td><td>1</td> </tr> <tr><td>[2.x.62] </td><td>2</td> </tr> <tr><td> [2.x.63] </td><td>2</td> </tr> <tr><td> [2.x.64] </td><td>1</td> </tr> <tr><td> [2.x.65] </td><td>2</tr> </table>
*从这个表中可以看出，FES系统反映了[2.x.66]和[2.x.67]情况下微分方程组的很多结构，因为我们有一个矢量值和一个标量变量。另一方面，卷积元素没有这种结构，我们必须在组装系统时以某种方式重构它，如下所述。
* 在这一点上，需要注意的是，两个FES系统对象的嵌套可以给整个FES系统带来更丰富的结构，而不仅仅是将它们串联起来。这种结构可以被应用程序所利用，但不是自动的。
* [2.x.68] VVAssembling [1.x.47] 下一步是对线性系统进行组装。对于标量问题的简单情况，如何做到这一点已经在许多教程程序中显示出来，首先是 [2.x.69] 。在这里，我们将展示如何对矢量问题进行处理。对应于上述弱式的不同特征和创建的不同系统元素，我们有几个选择，概述如下。
* 整个概念可能最好的解释是通过展示一个例子，说明如何组装一个单元对上述混合拉普拉斯方程的弱形式的局部贡献。
* [1.x.48] 这基本上是[2.x.70]的做法。


* [1.x.49]
*
* 所以这里是发生了什么。  [2.x.71] [2.x.72] 我们做的第一件事是声明 "抽取器"（见FEValuesExtractors命名空间）。这些对象除了存储矢量值有限元的哪些分量构成单一的标量分量或秩1的张量（即我们所说的 "物理矢量"，总是由[2.x.73]分量组成）外，没有什么作用。在这里，我们声明一个对象，表示由[2.x.74]分量组成的速度，从零分量开始，以及压力的提取器，它是位置[2.x.75]的标量分量。
* [2.x.76] 然后我们对所有单元、形状函数和正交点进行常规循环。在最内部的循环中，我们计算一对形状函数对全局矩阵和右手向量的局部贡献。回顾一下，根据形状函数[2.x.77]：[1.x.50]，单元格对双线性形式的贡献（即忽略边界条款）看起来如下
*而实施起来则是这样的。       
* [1.x.51]
* 相似之处是相当明显的。
* [2.x.78] 基本上，上述代码中发生的情况是这样的：当你执行 [2.x.79] 时，会创建一个所谓的 "视图"，即一个与完整的FEValues对象不同的对象，它不代表有限元的所有组件，而只代表提取器对象 [2.x.80] 或 [2.x.81] 所代表的那（些）组件。
* [2.x.82] 然后可以向这些视图询问关于这些单独组件的信息。例如，当你写[2.x.83]时，你会得到[2.x.84]第1个形状函数[2.x.85]在[2.x.86]第1个正交点的压力分量的值。因为提取器[2.x.87]代表一个标量分量，运算器[2.x.88]的结果是一个标量数。另一方面，调用[2.x.89]将产生整组[2.x.90]分量的值，其类型为[2.x.91] 。
* [2.x.92] 其他可以用视图做的事情是要求提取器所描述的特定形状函数的分量的梯度。例如，[2.x.93]表示标量压力分量的梯度，其类型为[2.x.94]，而速度分量的梯度，[2.x.95]为[2.x.96]，即一个由条目[2.x.98]组成的矩阵[2.x.97] 。最后，标量和矢量视图都可以询问二阶导数（"Hessians"），矢量视图可以询问对称梯度，定义为 [2.x.99] 以及分歧 [2.x.100] 。  [2.x.101] 其他使用提取器和视图的例子见教程程序 [2.x.102] , [2.x.103] , [2.x.104] 和其他几个程序。
*


* [2.x.105] 在目前的背景下，当我们谈论一个矢量时（例如在提取上面的速度分量时），我们指的是物理学上使用的这个词：它有[2.x.106]分量，在坐标系变换下以特定方式表现出来。例子包括速度场或位移场。这与数学中使用 "矢量 "一词的方式相反（以及我们在库中的其他上下文中使用这个词的方式，例如在矢量类中），在那里它真正代表了一个数字的集合。后者的一个例子是火焰中化学物种浓度的集合；然而，这些实际上只是标量变量的集合，因为如果坐标系被旋转，它们不会改变，不像速度矢量的分量，因此，这个[2.x.107]类不应该被用于这种情况。
*

* [2.x.108] VVAlternative [1.x.52]。
* 在有些情况下，我们可以利用所使用的有限元的知识，对矩阵或右手边向量的装配进行一些优化。例如，考虑我们在 [2.x.109] 中首先关注的弹性方程的双线性形式。
* [1.x.53]
* 这里，[2.x.110]是一个具有[2.x.111]分量的向量函数，[2.x.112]是相应的测试函数，[2.x.113]是材料参数。鉴于我们上面的讨论，实现这种双线性形式的明显方法如下，使用一个提取器对象，将有限元的所有[2.x.114]分量解释为单一矢量，而不是不相交的标量分量。
*


* [1.x.54]

* 现在，这不是[2.x.115]中使用的代码。事实上，如果在该程序中实现的代码之上使用上述代码，它的运行速度会慢8%左右。通过仔细研究双线性形式，它可以得到改善（将惩罚降低到大约4%）。事实上，我们可以将其转换为：[1.x.55] 。
*其中[2.x.116]是对称的梯度。在第二至最后一步，我们用任意张量[2.x.117]和对称张量[2.x.118]之间的标量积等于前者的对称部分与第二张量的标量积。使用上面讨论的技术，实现这一点的明显方法是这样的。
*


* [1.x.56]
*
* 那么，如果同样，这不是我们在[2.x.119]中使用的代码，我们在那里做什么？答案取决于我们使用的有限元。在[2.x.120]中，我们使用以下元素。


* [1.x.57]
* 换句话说，我们使用的有限元由同一标量元素的[2.x.121]份组成。这就是我们所说的[2.x.122]"原始 "元素：一个可能是矢量值的元素，但每个形状函数正好有一个非零成分。换句话说：如果一个位移形状函数的[2.x.123]-分量是非零的，那么[2.x.124]-和[2.x.125]-分量必须是零，其他分量也是如此。这意味着基于形状函数的衍生量也继承了这种稀疏性。例如：矢量值形状函数[2.x.127]的发散[2.x.126]在本例中是[2.x.128]、[2.x.129]或[2.x.130]，因为[2.x.131]中正好有一个是非零。知道这一点意味着我们可以节省一些计算，如果我们要做这些计算，只会产生零的加法。
* 类似地，如果一个形状函数只有一个分量是非零的，那么它的梯度[2.x.132]就只有一行是非零。这对于像[2.x.133]这样的术语意味着什么，其中两个张量之间的标量积被定义为[2.x.134]，即只有当两个张量的非零项在同一行时，该术语才是非零的，这意味着两个形状函数必须在同一位置有其单一非零分量。
* 如果我们使用这种知识，那么我们可以在第一步避免计算梯度张量，如果我们可以预先确定它们的标量乘积将是非零的，在第二步避免建立整个张量，只得到它的非零分量，在最后一步简化标量乘积，只考虑一个非零行的索引[2.x.135]，而不是乘以和增加零。
* 这一切的载体是确定哪个向量分量将是非零的能力。这个信息是由[2.x.136]函数提供的。在 [2.x.137] 中详细解释了用它可以做什么，使用上面的例子。
*

* [2.x.138] VVBlockSolvers [1.x.58]。
* 使用如上所示的技术，对于一个矢量值问题，组装线性系统，即矩阵和右手边，并不特别复杂。然而，然后它还必须被解决。这就比较复杂了。直观地说，我们可以只把矩阵作为一个整体来考虑。对于大多数问题，这个矩阵不会是确定的（除了特殊情况，如[2.x.139]和[2.x.140]中涉及的弹性方程）。它通常也不是对称的。这类相当普遍的矩阵给迭代求解器带来了问题：由于缺乏结构特性，无法使用最有效的方法和预处理器。虽然可以做到这一点，但求解过程往往比必要的要慢。
*这个问题的答案是利用问题的结构。例如，对于上面讨论的混合拉普拉斯方程，算子的形式是[1.x.59] 。
*
* 如果这种结构也能在线性系统中恢复，那就更好了。例如，在离散化之后，我们希望有一个具有以下块状结构的矩阵：[1.x.60]
* 其中[2.x.141]代表离散化身份算子[2.x.142]产生的质量矩阵，[2.x.143]是梯度算子的等价物。
* 然而，在默认情况下，这并不是发生的情况。相反，deal.II以一种相当随机的方式给自由度分配%的数字。因此，如果你用自由度的值组成一个向量，就不会像[1.x.61]那样整齐地排列在一个向量中。
* 相反，它将是一个排列组合，与速度和压力相对应的自由度的%数混合在一起。因此，系统矩阵也不会有上面提到的漂亮结构，而是有相同的排列组合或行和列。
* 现在需要的是重新列举自由度，使速度在前，压力在后。这可以用[2.x.144]函数来完成，在[2.x.145]" [2.x.146]", [2.x.147], [2.x.148], 和[2.x.149]" [2.x.150]"中解释。在这之后，至少自由度被正确划分了。
* 但之后我们仍然要利用它，也就是说，我们必须拿出一个使用该结构的求解器。例如，在[2.x.151]中，我们对线性系统[1.x.62]做了一个块消除。
* 当然，这个系统的含义是[1.x.63] 。
*
* 因此，如果我们用第一个方程乘以[2.x.152]，再从结果中减去第二个方程，我们就得到[1.x.64] 。
*
* 这是一个现在只包含压力变量的方程。如果我们能解决这个问题，我们可以在第二步用[1.x.65]来解决速度问题。
*
* 这样做的好处是，我们要解决的矩阵[2.x.153]和[2.x.154]都是对称的和正定的，而不是我们之前的大整数矩阵。
* 像这样的求解器是如何实现的，在[2.x.155]step_20 " [2.x.156]"、[2.x.157]和其他一些教程程序中有更详细的解释。我们在这里想指出的是，我们现在需要一种方法来提取矩阵或向量的某些部分：如果我们要将，比如说，解向量的[2.x.158]部分与全局矩阵的[2.x.159]部分相乘，那么我们需要有一种方法来访问整体的这些部分。
* 这就是BlockVector、BlockSparseMatrix和类似的类的用处。为了所有的实际目的，那么可以作为常规的向量或稀疏矩阵使用，也就是说，它们提供元素访问，提供常规的向量操作，并实现例如矩阵-向量的乘法。换句话说，组装矩阵和右手边的工作方式与非块版本完全相同。也就是说，在内部，它们以 "块 "的形式存储向量和矩阵的元素；例如，BlockVector类不是使用一个大数组，而是将其存储为一组数组，每个数组我们称之为一个块。这样做的好处是，虽然整个东西可以作为一个向量使用，但人们也可以访问一个单独的块，然后，它又是一个具有所有向量操作的向量。
* 为了说明如何做到这一点，让我们考虑上面要解决的第二个方程[2.x.160]。这可以通过以下类似于我们在[2.x.161]中的序列来实现。


* [1.x.66]
*
* 这里发生的事情是，我们分配了一个临时向量，其元素数与解向量的第一块，即速度分量[2.x.162]相同。然后我们将这个临时向量设置为等于矩阵的[2.x.163]块，即[2.x.164]，乘以解决方案的分量1，即之前计算的压力[2.x.165]。结果乘以[2.x.166]，右手边的0分量[2.x.167]被添加到其中。现在的临时向量包含 [2.x.168] 。剩下的代码片段只是解决了一个线性系统，[2.x.169]为右手边，全局矩阵的[2.x.170]块，即[2.x.171] 。因此，以这种方式使用块状向量和矩阵，我们可以很容易地编写相当复杂的求解器，利用线性系统的块状结构。
*


* [2.x.172] VVExtracting [1.x.67]。
* 一旦计算出一个解决方案，往往需要在正交点上进行评估，例如为下一次牛顿迭代评估非线性残差，为误差估计器评估有限元残差，或者为时间相关问题的下一个时间步骤计算右手边。
* 这样做的方法是再次使用FEValues对象来评估正交点的形状函数，并且用这些来评估有限元函数的值。对于上面的混合拉普拉斯问题的例子，请考虑解算后的以下代码。


* [1.x.68]
*
* 在这之后，变量[2.x.173]是一个长度等于我们初始化FEValues对象的正交点数量的向量列表；每个向量都有[2.x.174]元素，包含[2.x.175]速度的值和正交点的一个压力。
* 我们可以用这些值来构建其他的东西，如残差。然而，这个构造有点尴尬。首先，我们有一个[2.x.176]s，这看起来总是很奇怪。它也是低效的，因为它意味着为外向量以及所有内向量分配动态内存。其次，也许我们只对速度感兴趣，例如，在第二阶段解决一个平流问题（例如，在[2.x.177]或[2.x.178]中）。在这种情况下，我们必须像这样手工提取这些值。


* [1.x.69]
* 注意我们如何从[2.x.179]（它只是一个矢量元素的集合）转换为[2.x.180]，因为速度是一个由[2.x.181]元素表征的量，在坐标系的旋转下具有某些变换特性。
* 这段代码可以用下面这样的代码写得更优雅、更有效。


* [1.x.70]
*
* 结果，我们在这里马上得到了速度，而且是正确的数据类型（因为我们已经用提取器描述了有限元的第一个[2.x.182]分量属于一起，形成一个张量）。这段代码也更有效率：它需要更少的动态内存分配，因为张量类将其成分作为成员变量而不是在堆上分配，而且我们节省了周期，因为我们甚至不需要费力计算正交点上的压力变量值。另一方面，如果我们只对压力而不是速度感兴趣，那么下面提取标量值的代码就可以了。


* [1.x.71]
*
* 在类似情况下，有时需要解的梯度或二阶导数，或者个别标量或矢量分量的梯度或二阶导数。为了获得解的所有分量的梯度，函数[2.x.183]和[2.x.184]相当于上面使用的函数[2.x.185]。
* 同样，要提取标量分量的梯度，[2.x.186]和[2.x.187]就可以完成这项工作。对于矢量（张量）值的量，有函数[2.x.188]和[2.x.189]，此外还有[2.x.190]和[2.x.191] 。
* 此外，在只需要解的拉普拉斯（即豫备的轨迹）的情况下，还有一个捷径，可用于标量和矢量值的问题，如[2.x.192]和[2.x.193] 。
*

* [2.x.194] VVOutput [1.x.72]。
* 如上所述，一个FESystem对象可能持有多个向量组件，但它并不清楚这些组件的实际含义。作为一个例子，以对象


* [1.x.73]
* 它有[2.x.195]个矢量分量，但它们是什么意思？它们是速度矢量的[2.x.196]分量加上一个压力吗？它们是压力加上[2.x.197]速度分量吗？还是它们是一个标量的集合？
* 关键是，FESystem类并不关心。元素的[1.x.74]含义是由后来使用该元素的人决定的，例如在组装线性表格时，或者在下一个牛顿步骤中为线性化系统提取数据解决方案组件时。几乎在所有情况下，这种解释都发生在需要它的地方。
* 然而，有一种情况是必须明确的，那就是在生成图形输出时。原因是许多用于可视化的文件格式希望表示矢量的数据（如速度、位移等）与标量（压力、密度等）分开存储，而且通常没有办法在可视化程序中把一堆标量分组为一个矢量场。
* 为了实现这一点，我们需要让DataOut类和朋友们知道FESystem的哪些成分形成了向量（有[2.x.198]成分），哪些是标量。例如，这在[2.x.199]中显示，我们产生的输出如下。


* [1.x.75]
* 换句话说，我们在这里创建了一个[2.x.200]元素的数组，在这个数组中，我们存储了有限元中哪些元素是向量，哪些是标量；这个数组被填充了[2.x.201]的副本和[2.x.203]的一个尾部元素。然后，该数组被作为一个额外的参数给到[2.x.204]，以解释如何解释给定解向量中的数据。像VisIt和Paraview这样的可视化程序将提供显示这些[2.x.205]组件的矢量场，而不是单个标量场。
*




* [2.x.206]


* [0.x.1]

include/deal.II-translator/A-tutorial/step-10_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5]
* [1.x.6][1.x.7][1.x.8] 。


*
* 这是一个相当短的例子，只显示了使用高阶映射的一些方面。我们所说的[2.x.2]映射[2.x.3]是指单元格（即单元线、正方形或立方体）与现实空间中的单元格之间的转换。在前面所有的例子中，我们都隐含地使用了线性或d-线性映射；你根本不会注意到这一点，因为如果你不做任何特别的事情，这就是发生的情况。然而，如果你的域有弯曲的边界，在有些情况下，边界的片状线性逼近(即由直线段构成)是不够的，你希望你的计算域也是使用弯曲边界的真实域的逼近。如果边界近似使用逐片二次抛物线来近似真实边界，那么我们说这是二次或[2.x.4]近似。如果我们使用立方体多项式的片断图形，那么这就是[2.x.5]的近似，以此类推。
*

*
* 对于某些微分方程，已知边界的片状线性逼近，即[2.x.6]映射，如果精确域的边界是弯曲的，则是不充分的。例如，使用[2.x.7]元素的双谐波方程，或具有弯曲反射边界的域上的气体动力学的Eulerequations。在这些情况下，有必要使用高阶映射来计算积分。如果我们不使用这样的高阶映射，边界的逼近顺序将主导整个数值方案的收敛顺序，而不考虑域内部离散化的收敛顺序。
*

*
* 我们没有用这些更复杂的例子来演示高阶映射的使用，而是只做了一个简单的计算：用两种不同的方法计算[2.x.8]的值。
*

*
* 第一种方法使用单位半径的圆的三角形近似，并在其上积分一个单位幅度的常数函数（[2.x.9]）。当然，如果领域是精确的单位圆，那么面积将是[2.x.10]，但由于我们只使用片状多项式段的近似，我们积分的面积值并不完全是[2.x.11] 。然而，众所周知，当我们细化三角形时，[2.x.12]的映射会以[2.x.13]的阶数逼近边界，其中[2.x.14]是网格大小。我们将检查圆的计算面积值以及它们在不同映射下向[2.x.15]收敛的情况。我们还将发现一个收敛行为，这个行为一开始是令人惊讶的，但有一个很好的解释。
*

*
* 第二种方法与此类似，但这次不使用三角形单位圆的面积，而是使用其周长。  [2.x.16]是周长的一半的近似值，因为我们选择半径等于1。
*

*
* [2.x.17] 本教程实质上展示了如何为积分选择一个特定的映射，方法是将一个特定的几何体附加到三角法上（例如在[2.x.18]中已经做过），然后将一个映射参数传递给FEValues类，该类在deal.II中用于所有积分。我们选择的几何体是一个圆，deal.II已经有一个可以使用的类（SphericalManifold）。如果你想定义你自己的几何体，例如，因为它很复杂，而且不能用deal.II中已有的类来描述，你将需要阅读 [2.x.19] 。
*

* [1.x.9] [1.x.10]。
* 以下第一个包含文件现在可能已经众所周知，不需要进一步解释。
*


* [1.x.11]
*
* 这个包含文件是新的。即使我们在本教程中不求解PDE，我们也要使用FE_Nothing类提供的自由度为零的假有限元。
*


* [1.x.12]
*
* 以下头文件也是新的：在其中，我们声明了MappingQ类，我们将用它来处理任意阶的多项式映射。
*


* [1.x.13]

* 而这又是C++。
*


* [1.x.14]

* 最后一步和以前的程序一样。
*


* [1.x.15]

* 现在，由于我们要计算[2.x.20]的值，我们必须与一些东西进行比较。这些是[2.x.21]的前几个数字，我们事先定义了这些数字，以便以后使用。由于我们想计算两个数字的差值，而这两个数字是相当精确的，计算出的[2.x.22]的近似值的精度在一个双变量可以容纳的位数范围内，所以我们宁可将参考值声明为[2.x.23]，并给它增加一些位数。
*


* [1.x.16]

* 然后，第一个任务将是生成一些输出。由于这个程序非常小，我们在其中没有采用面向对象的技术，也没有声明类（当然，我们使用了库的面向对象功能）。相反，我们只是将功能打包成独立的函数。我们使这些函数成为空间维数的模板，以符合使用deal.II时的通常做法，尽管我们只对两个空间维数使用这些函数，当试图对任何其他空间维数使用时，会出现异常。   
* 这些函数中的第一个只是生成一个圆（超球）的三角形，并输出[2.x.24]的不同值的单元格的映射。然后，我们细化一次网格，再做一次。
*


* [1.x.17]
*
* 所以首先生成一个圆的粗略三角剖分，并将一个合适的边界描述与之关联。默认情况下，[2.x.26]将SphericalManifold附加到边界上（内部使用FlatManifold），所以我们只需调用该函数就可以继续。
*


* [1.x.18]
*
* 然后在当前网格上交替生成[2.x.27], [2.x.28], 和[2.x.29]映射的输出，以及（在循环体的末端）对网格进行一次全局细化。
*


* [1.x.19]
*
* 为此，首先建立一个描述映射的对象。这是用MappingQ类来完成的，该类在构造函数中采用了它应使用的多项式程度作为参数。
*


* [1.x.20]
*
* 顺便提一下，对于一个片状线性映射，你可以给MappingQ的构造函数一个[2.x.30]的值，但也有一个类MappingQ1可以达到同样的效果。历史上，它以比MappingQ更简单的方式做了很多事情，但今天只是后者的一个包装。然而，如果你没有明确指定另一个映射，它仍然是库中许多地方隐含使用的类。
*


*
* 为了实际写出带有这种映射的现在的网格，我们设置了一个对象，我们将用它来输出。我们将生成Gnuplot输出，它由一组描述映射的三角图的线条组成。默认情况下，三角剖分的每个面只画一条线，但由于我们想明确地看到映射的效果，所以我们想更详细地了解这些面。这可以通过传递给输出对象一个包含一些标志的结构来实现。在目前的情况下，由于Gnuplot只能画直线，我们在面孔上输出了一些额外的点，这样每个面孔就由30条小线来画，而不是只有一条。这足以让我们看到一条弯曲的线，而不是一组直线的印象。
*


* [1.x.21]
*
* 最后，生成一个文件名和一个输出的文件。
*


* [1.x.22]
*
* 然后写出三角图到这个文件。该函数的最后一个参数是一个指向映射对象的指针。这个参数有一个默认值，如果没有给出值，就会取一个简单的MappingQ1对象，我们在上面简单介绍过。这样就会在输出中产生一个真实边界的片状线性近似。
*


* [1.x.23]
*
* 在循环结束时，对网格进行全局细化。
*


* [1.x.24]

* 现在我们进行代码的主要部分，即[2.x.31]的近似。圆的面积当然是由[2.x.32]给出的，所以有一个半径为1的圆，面积代表的只是搜索到的数字。面积的数值计算是通过在整个计算域中积分值为1的常数函数来进行的，即通过计算面积[2.x.33]，其中总和延伸到三角形中所有活动单元上的所有正交点，[2.x.34]是正交点的重量[2.x.35]。每个单元上的积分都是通过数字正交来逼近的，因此我们唯一需要的额外成分是建立一个FEValues对象，提供每个单元的相应`JxW`值。注意`JxW`是指[1.x.25]的缩写；因为在数值正交中，两个因子总是出现在相同的地方，所以我们只提供合并的数量，而不是两个单独的数量）。我们注意到，在这里我们不会在其最初的目的中使用FEValues对象，即用于计算特定正交点上的特定有限元的基函数值。相反，我们只用它来获得正交点的 "JxW"，而不考虑我们将给FEValues对象的构造者的（假）有限元。给予FEValues对象的实际有限元根本不使用，所以我们可以给任何。
*


* [1.x.26]
*
* 对于所有单元上的数字正交，我们采用足够高的正交规则。我们选择8阶的QGauss（4点），以确保数字正交引起的误差比由于边界近似的阶数，即所采用的映射的阶数所引起的阶数（最大6）更高。请注意，积分，雅各布行列式，不是一个多项式函数（相反，它是一个有理函数），所以我们不使用高斯正交来获得积分的精确值，就像在有限元计算中经常做的那样，而是可以使用任何类似阶数的正交公式来代替。
*


* [1.x.27]
*
* 现在开始在多项式映射度=1...4上循环。
*


* [1.x.28]
*
* 首先生成三角形、边界和映射对象，正如已经看到的那样。
*


* [1.x.29]

* 我们现在创建一个有限元。与其他的例子程序不同，我们实际上不需要用形状函数做任何计算；我们只需要FEValues对象的`JxW`值。因此，我们使用特殊的有限元类FE_Nothing，它的每个单元的自由度正好为零（顾名思义，每个单元的局部基础为空集）。FE_Nothing的一个比较典型的用法见[2.x.36] 。
*


* [1.x.30]

* 同样地，我们需要创建一个DoFHandler对象。我们实际上并没有使用它，但是它将为我们提供 "active_cell_iterators"，这是重新初始化三角形的每个单元上的FEValues对象所需要的。
*


* [1.x.31]
*
* 现在我们设置FEValues对象，给构造函数提供Mapping、假有限元和正交对象，以及要求只在正交点提供`JxW`值的更新标志。这告诉FEValues对象在调用[2.x.37]函数时不需要计算其他数量，从而节省计算时间。         
* 与以前的例子程序相比，FEValues对象的构造最重要的区别是，我们传递了一个映射对象作为第一个参数，它将用于计算从单元到实数单元的映射。在以前的例子中，这个参数被省略了，结果是隐含地使用了MappingQ1类型的对象。
*


* [1.x.32]
*
* 我们使用ConvergenceTable类的一个对象来存储所有重要的数据，如[2.x.38]的近似值和相对于[2.x.39]的真实值的误差。我们还将使用ConvergenceTable类提供的函数来计算[2.x.40]的近似值的收敛率。
*


* [1.x.33]
*
* 现在我们在三角形的几个细化步骤上循环。
*


* [1.x.34]
*
* 在这个循环中，我们首先将当前三角形的活动单元的数量添加到表格中。这个函数会自动创建一个上标为 "cells "的表格列，如果这个列之前没有被创建的话。
*


* [1.x.35]
*
* 然后我们为假的有限元分配自由度。严格地说，在我们的特殊情况下，我们不需要这个函数调用，但我们调用它是为了使DoFHandler高兴
*
* - 否则它将在下面的[2.x.41]函数中抛出一个断言。
*


* [1.x.36]
*
* 我们将变量面积定义为`长双`，就像我们之前对`pi`变量所做的那样。
*


* [1.x.37]
*
* 现在我们循环所有单元，重新初始化每个单元的FEValues对象，并将该单元的所有`JxW`值加到`面积'中......
*


* [1.x.38]
*
* ......并将得到的面积值和错误存储在表中。我们需要静态转换为双数，因为没有实现add_value(string, long double)函数。请注意，这也涉及到第二个调用，因为[2.x.43]命名空间中的[2.x.42]函数在其参数类型上是重载的，所以存在一个获取并返回[2.x.44]的版本，而全局命名空间中只有一个这样的函数被声明（获取并返回一个双数）。
*


* [1.x.39]
*
* 我们要计算`错误'列的收敛率。因此我们需要在调用`evaluate_all_convergence_rates`之前，将其他列从收敛率评估中省略。
*


* [1.x.40]
*
* 最后我们为一些数量的输出设置精度和科学模式...
*


* [1.x.41]
*
* ......并将整个表格写到[2.x.45]。



* [1.x.42]
*
* 下面的第二个函数也是计算[2.x.46]的近似值，但这次是通过域的周长[2.x.47]而不是面积。这个函数只是前一个函数的一个变化。因此，我们主要给出不同之处的文件。
*


* [1.x.43]
*
* 我们采取同样的正交顺序，但这次是`dim-1`维正交，因为我们将在（边界）线上而不是在单元上积分。
*


* [1.x.44]
*
* 我们在所有的度数上循环，创建三角形、边界、映射、假有限元和DoFHandler对象，如之前所见。
*


* [1.x.45]
*
* 然后我们创建一个FEFaceValues对象，而不是像前一个函数中的FEValues对象。同样，我们传递一个映射作为第一个参数。
*


* [1.x.46]
*
* 现在我们对所有单元和每个单元的所有面进行计算。只有边界面上的`JxW`值的贡献被添加到长双变量`周长`中。
*


* [1.x.47]
*
* 我们用单元格迭代器和面的编号重新启动FEFaceValues对象。
*


* [1.x.48]

* 然后将评估的数值存储在表中...
*


* [1.x.49]
*
* ......并像我们在前一个函数中那样结束这个函数。
*


* [1.x.50]

* 下面的主函数只是按照上述函数的出现顺序调用它们。除此以外，它看起来就像以前的教程程序的主函数。
*


* [1.x.51]
*[1.x.52][1.x.53]


*
* 该程序执行了两项任务，第一项是生成映射域的可视化，第二项是通过所述的两种方法计算π。让我们先看一下生成的图形。它们是以Gnuplot格式生成的，可以通过以下命令查看
* [1.x.54]
* 或者使用其他的文件名。第二行确保生成的输出的长宽比实际上是1:1，也就是说，圆在你的屏幕上被画成一个圆，而不是一个椭圆。第三行关闭了图形中的按键，因为这只会打印出现在并不重要的信息（文件名）。同样地，第四行和第五行关闭了刻度线。然后生成具有特定线宽（"lw"，这里设置为4）和线型（"lt"，这里选择线应该用RGB颜色 "黑色 "绘制）的图。
* 下表显示了[2.x.48]、[2.x.49]和[2.x.50]映射的三角计算域，原始粗网格（左）和一次均匀细化网格（右）。
* [2.x.51]
* 这些图片显示了高阶映射的明显优势：它们在相当粗的网格上也能相当好地接近真实边界。为了进一步证明这一点，这里是使用[2.x.52]和[2.x.53]映射的粗网格的右上角四分之一圆的一部分，其中红色虚线标志着实际圆。
* [2.x.54]
* 很明显，二次映射很好地逼近了边界，而对于三次映射来说，对于粗网格来说，逼近的域和真实的域之间的差别已经很难看出来了。你还可以看到，映射只在三角形的外部边界上有所改变。在内部，所有的线仍然是由线性函数表示的，这导致只在边界的单元上进行额外的计算。因此，高阶映射通常不会比低阶映射明显地慢，因为额外的计算只在所有单元格的一小部分上执行。
*


* 该程序的第二个目的是计算π的值，以达到良好的精度。这是程序的这一部分的输出。
* [1.x.55]
*
*

*
* 从输出结果中可以立即观察到，在所有情况下，数值都会迅速收敛到[2.x.55]的真实值。请注意，对于[2.x.56]的映射，我们已经进入了四舍五入误差的状态，收敛率趋于平稳，这已经是相当大的进步了。然而，也请注意，对于[2.x.57]映射，即使在最细的网格上，精度也比[2.x.58]映射的粗略网格上的精度差得多!
*

*
* 输出的最后一列显示了收敛顺序，以网格宽度[2.x.59]为幂。在介绍中，我们曾说过，[2.x.60]映射的收敛顺序应该是[2.x.61]。然而，在所示的例子中，顺序是[2.x.62] !这个最初令人惊讶的事实可以用[2.x.63]映射的特性来解释。在[1.x.56]阶，它使用的支持点是基于[1.x.57]+1点Gauss-Lobatto正交规则，以这样的方式选择支持点，使正交规则在2[1.x.58]阶收敛。尽管这些点在这里只用于插值[1.x.59]阶多项式，但我们在对积分进行数值计算时得到了一个超级收敛效应，从而得到了观察到的高收敛阶数。这一效应在以下出版物中也有详细讨论。A. Bonito, A. Demlow, and J. Owen:"对拉普拉斯-贝特拉米算子的特征值和特征函数的有限元近似的先验误差估计"，已提交，2018年）。)
*

* [1.x.60][1.x.61][2.x.64]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-1_0.txt
[0.x.0]*
 [2.x.0]
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18]
*[1.x.19][1.x.20][1.x.21] 。


*[1.x.22][1.x.23]


* 由于这是第一个教程程序，让我们首先评论一下这个教程和其他deal.II的文档是如何工作的。deal.II的文档基本上有三个不同的层次。
*
* - 教程。这是一个程序集，展示了deal.II在实践中的应用。它通常不在单个参数的层面上讨论单个函数，而是希望给出事物如何共同工作的大画面。换句话说，它讨论的是 "概念"：deal.II的构件是什么，它们如何在有限元程序中一起使用。
*
* - 手册。这是deal.II中每一个类和每一个（成员）函数的文档。例如，如果你点击本页顶部的 "主页 "或 "类 "标签，你就可以看到。在这里你可以查到[2.x.1]的第二个参数是什么意思，这只是一个略显晦涩的例子。当你知道你要做什么，但忘记了函数到底是怎么命名的，它的参数是什么，或者它的返回值是什么时，你就需要这种级别的文档。请注意，当你读完教程并点击任何一个类或函数名称时，你也会进入手册，也就是说，当你需要对某个函数或类进行更详细的描述时，教程包含了大量进入手册的链接。另一方面，手册并不是学习deal.II的好地方，因为它给你提供了一个微观的视角，而没有告诉你一个函数是如何融入大局的。
*
* - 模块。这些是一起工作或具有相关功能的类和函数组。如果你点击本页顶部的 "模块 "标签，你就会进入一个列出许多此类组的页面。每个模块都讨论了这些类的基本原理；例如，[2.x.2]模块讨论了与存储矩阵的稀疏模式有关的各种不同问题。这就是中级水平的文档：它们给你一个特定领域的概述。例如，当你想知道存在哪些有限元类时，你会看一下[2.x.3]模块。当然，这些模块也与手册（有时也与教程）有交叉链接；如果你点击一个类的名字，比如说三角形，在类名的右上方也会有这个类所属模块的链接，如果你想进一步了解它的背景。
* 让我们回到教程中来，因为你正在看它的第一个程序（或 "步骤"）。每个教程的程序都被细分为以下几个部分。[2.x.4] [2.x.5] [1.x.24] 这是关于该程序的讨论，包括数学模型，以及与以前的教程程序相比有哪些新的编程技术。   [2.x.6] [1.x.25] 广泛记录的源代码清单。在这里，我们经常记录个别行或代码块，并讨论它们做什么，如何做，以及为什么。评论中经常提到介绍，也就是说，你必须先了解[1.x.26]程序想要达到的目标（介绍中讨论的目标），然后才能了解[1.x.27]它打算达到的目标。   [2.x.7] [1.x.28] 程序的输出，包括注释和解释。这一部分也经常有一个小节，给出如何在不同方向上扩展程序的建议；在早期的程序中，这是为了给你提供小实验的方向，旨在使你熟悉deal.II，而在后来的程序中，更多的是关于如何使用更高级的数值技术。   [2.x.8] [1.x.29] 剥去所有注释的源代码。如果你想看到代码的 "全貌"，这很有用，因为程序的注释版本中间有很多文字，往往很难在屏幕上一次看到单个函数的全部代码。[2.x.9]
* 教程不仅是指静态的文档，而且你应该玩玩它们。为此，进入[2.x.10]目录（或任何你感兴趣的教程的编号），然后输入
* [1.x.30]
* 第一条命令设置了描述该教程程序所依赖的包含文件、如何编译以及如何运行的文件。这个命令应该能找到已安装的deal.II库，这些库是在编译和安装[1.x.31]文件中描述的一切时产生的。
* [1.x.32]
*代替。
* 上述命令中的第二条将源代码编译成可执行文件，而最后一条将执行它（严格地说，如果可执行文件还不存在，[2.x.11]也将编译代码，所以如果你想的话，可以跳过第二条命令）。这就是运行代码和产生输出所需的全部内容，在教程程序的 "结果 "部分讨论。这个顺序需要在你想玩的所有教程目录中重复进行。
* 在学习库的时候，你需要用它来玩，看看会发生什么。为此，用你喜欢的编辑器打开[2.x.12]的源文件，以某种方式修改它，保存它并按上述方法运行。在本程序的结果部分，我们给出了一些可能的修改建议，在那里我们还提供了一些与其他有用信息的链接。
*

*[1.x.33][1.x.34]


* 在关于deal.II和计算科学的[1.x.35]中也讨论和演示了这个和其他几个教程程序。特别是，你可以看到他运行这个和其他程序的步骤，你会对可以用来处理deal.II的工具有更好的了解。特别是，第2和第4讲概述了deal.II和任何有限元代码的构建块。
* 如果你还不熟悉使用Linux和在命令行上运行东西，你可能有兴趣看第2.9和2.91讲。 ( [2.x.14]行和关于编译程序时发生的事情，分别。
* 请注意，deal.II正在积极开发，在开发过程中，我们偶尔会对这些视频讲座中仍然引用的函数或类进行重新命名或废弃。  例如，视频讲座5中的[2.x.15]代码使用了一个HyperShellBoundary类，后来被SphericalManifold类取代。此外，从deal.II 9.0版本开始，[2.x.16]现在会自动将SphericalManifold附加到三角结构中。除此以外，其余的讲座材料都是相关的。
*[1.x.36][1.x.37]
*

* 让我们回到[2.x.17]，即当前的程序。在这第一个例子中，我们实际上并没有做很多事情，但展示了两个技术：生成三角形对象的语法是什么，以及在所有单元格上进行简单循环的一些要素。我们创建了两个网格，一个是有规律的细化的正方形（不是很令人兴奋，但对于某些问题来说是一个常见的起始网格），还有一个是几何学上的尝试：弧形域，它是向内侧边缘细化的。通过这些，你将了解到每一个有限元程序都必须有的三样东西。Triangulation类型的对象；调用GridGenerator函数来生成网格；以及涉及迭代器的所有单元的循环（迭代器是指针的泛化，在C++标准库中经常使用；在deal.II的背景下，[2.x.18]模块谈到了它们）。
* 该程序非常小，不需要大量的介绍。
* [2.x.19]
*

*[1.x.38][1.x.39]


* 如果你正在阅读这个教程程序，你很可能有兴趣继续使用deal.II来完成你自己的项目。因此，你即将开始使用一个大型科学计算库进行编程练习。除非你已经是大规模编程方法的资深用户，否则这对你来说可能是一个新的领域；伴随着所有的新规则，比如你将不得不处理别人写的代码，你可能不得不考虑记录你自己的代码，因为你可能在一年后不记得它到底在做什么（或者因为别人也会使用它），或者想出一些方法来测试你的程序是否做得正确。这些都不是我们通常训练数学家、工程师或科学家的东西，但当你开始编写超过几百行的软件时，这些都很重要。请记住。制作软件并不等同于仅仅写代码。
* 为了使你在这一旅程中生活得更轻松，让我们指出一些值得在你开始任何大规模编程之前浏览的资源。
*
* - [1.x.40]有很多关于deal.II特定方面的问题的答案，但也有一些更普遍的问题，如 "我如何调试科学计算代码？"或 "我能否训练自己写出更少的错误的代码？"。
*
* - 你将从成为一个更好的程序员中受益。为此，一个很好的资源是Steve McConnell的[Code Complete](https://en.wikipedia.org/wiki/Code_Complete) [2.x.20] 。这本书已经有几年的历史了，最后一版是在2004年出版的，但它作为良好的编程实践指南的吸引力丝毫不减，一些主要的开发者把它作为他们研究小组每一代成员的集体阅读项目。
*
* - [1.x.41]，对许多处理软件的重要主题进行了介绍，如版本控制、make文件、测试等。它是专门为科学家和工程师编写的，而不是为计算机科学家编写的，它的重点是简短、实用的课程。
*
* - [1.x.42]有很多资源（和有趣的博文），涉及编写科学软件的许多方面。
*
* - [1.x.43]也有关于软件开发的资源，特别是用于并行计算的资源。在该网站的 "活动 "部分有录制的教程和网络研讨会，涵盖了许多有趣的话题。
*
* - [1.x.44]上有一篇文章，介绍了许多方法，通过这些方法可以确保你是一个高效的程序员，写出能工作的程序。
* 作为一个一般性的建议。如果你希望在未来花几天时间来编写软件，那么请你学习能使你的生活更有效率的工具，特别是调试器和集成开发环境。( [2.x.21] 你会发现，通过提高工作效率，你很快就会把学习这些工具的时间拿回来几倍！上面提到的几个视频讲座展示了如何使用集成开发环境或调试器等工具。
*

* [1.x.45] [1.x.46]。
* [1.x.47][1.x.48] 。
*

*
* 库中最基本的类是三角形类，它在这里声明。
*


* [1.x.49]
*
* 这里有一些生成标准网格的函数。
*


* [1.x.50]
*
* 以各种图形格式输出网格。
*


* [1.x.51]
*
* 这是C++输出所需要的。
*


* [1.x.52]
*
* 而这是对[2.x.22]和[2.x.23]函数的声明。
*


* [1.x.53]

*导入deal.II的最后一步是这样的。所有deal.II的函数和类都在一个命名空间[2.x.24]中，以确保它们不会与你可能想和deal.II一起使用的其他库的符号相冲突。我们可以在使用这些函数和类时，在每个名字前加上[2.x.25]的前缀，但这很快就会变得繁琐和令人厌烦。相反，我们只是简单地导入整个deal.II命名空间，以供一般使用。
*


* [1.x.54]
*
* [1.x.55] [1.x.56]。


*
* 在下面的第一个函数中，我们简单地使用单位方格作为域，并从中产生一个全局细化网格。
*


* [1.x.57]

* 首先要做的是为一个二维领域的三角化定义一个对象。
*


* [1.x.58]
*
* 在这里和下面的许多情况下，类名后面的字符串"<2>"表示这是一个应在两个空间维度工作的对象。同样，也有一些三角形类的版本是在一个（"<1>"）和三个（"<3>"）空间维度中工作的。这种工作方式是通过一些模板魔法实现的，我们将在后面的示例程序中详细研究；在那里，我们还将看到如何以一种基本上独立于维度的方式编写程序。
*

*
* 接下来，我们要用一个正方形领域的单个单元来填充三角结构。三角形被细化了四次，总共得到[2.x.26]个单元。
*


* [1.x.59]

* 现在我们要把网格的图形表示写到一个输出文件中。deal.II的GridOut类可以用多种不同的输出格式来实现；在这里，我们选择可伸缩矢量图（SVG）格式，你可以用你选择的网络浏览器来进行可视化。
*


* [1.x.60]
*
* [1.x.61] [1.x.62]。


*
* 下面第二个函数中的网格稍微复杂一些，因为我们使用了一个环形域，并对结果进行了一次全局细化。
*


* [1.x.63]
*
* 我们再次开始定义一个二维域的三角化的对象。
*


* [1.x.64]

* 然后我们用一个环形域来填充它。环的中心应是点(1,0)，内部和外部半径应是0.5和1。圆周单元的数量可以由这个函数自动调整，但我们选择将其明确设置为10作为最后一个参数。
*


* [1.x.65]
*
* 默认情况下，三角计算假定所有边界都是直线，所有单元都是双线性四边形或三线性六边形，并且它们由粗网格（我们刚刚创建的）的单元定义。除非我们做一些特别的事情，否则当需要引入新的点时，域被假定为由粗网格的直线划定，而新的点将简单地位于周围的中间。然而，在这里，我们知道领域是弯曲的，我们想让三角法根据底层的几何结构来放置新的点。幸运的是，一些优秀的灵魂实现了一个描述球状域的对象，而环是球状域的一个部分；它只需要环的中心，并自动计算出如何指示三角计算在哪里放置新的点。这在deal.II中的工作方式是，你用一个通常被称为 "流形指标 "的数字来标记你想要弯曲的三角形部分，然后告诉三角形在所有有这个流形指标的地方使用一个特定的 "流形对象"。具体如何操作在此并不重要（你可以在[2.x.27]和[2.x.28]中阅读）。GridGenerator中的函数在大多数情况下为我们处理这个问题：它们将正确的流形附加到一个域上，这样当三角形被细化时，新的单元就会被放置在正确的位置。在目前的情况下，[2.x.29]为所有的单元格附加了一个球形流形：这使得单元格被细化为球形坐标的计算（因此新的单元格的边缘要么是径向的，要么是位于原点周围的同心圆）。   
* 默认情况下（即对于手工创建的三角图或没有调用GridGenerator函数（如[2.x.30]或[2.x.31]），三角图的所有单元格和面都将其manifold_id设置为[2.x.32]，如果你想要一个产生直线边缘的流形，这是默认的，但你可以为单个单元格和面改变这个数字。在这种情况下，因此与数字0相关的曲面流形将不适用于那些流形指标为非零的部分，但其他流形描述对象可以与这些非零指标相关联。如果没有流形描述与特定的流形指标相关联，则暗示产生直角边缘的流形。(流形指标是一个略显复杂的话题；如果你对这里到底发生了什么感到困惑，你可能想看看[2.x.33]"关于这个话题的词汇表条目")。既然[2.x.34]选择的默认值是合理的，我们就不去管它。   
* 为了演示如何在所有单元格上写一个循环，我们将分五个步骤向域的内圈细化网格。
*


* [1.x.66]
*
* 接下来，我们需要对三角形的活动单元进行循环。你可以把三角形看作是一个单元格的集合。如果它是一个数组，你只需要得到一个指针，用操作符`++`从一个元素递增到下一个元素。三角形的单元不是作为一个简单的数组来存储的，但是一个[1.x.67]的概念将指针的工作方式概括为任意的对象集合（更多信息见[1.x.68]）。通常情况下，C++中的任何容器类型都会返回一个迭代器，指向集合的开始，方法称为`begin'，并返回一个迭代器，指向集合结束后的1，方法称为`end`。我们可以用操作符`++it`来增加迭代器`it`，用`*it`来解除引用以获得底层数据，并通过比较`it != collection.end()`来检查我们是否完成。       
* 第二个重要部分是我们只需要活动单元。活跃单元是那些没有被进一步细化的单元，也是唯一可以被标记为进一步细化的单元。deal.II提供了迭代器类别，允许我们在[1.x.69]单元（包括活跃单元的父单元）或只在活跃单元上迭代。因为我们想要后者，所以我们需要调用[2.x.35]方法。
* 将所有这些放在一起，我们可以用[2.x.36]在一个三角形的所有活动单元上循环，在这个循环的初始化器中，我们使用了`auto`关键字作为迭代器`it`的类型。`auto`关键字意味着被声明的对象的类型将从上下文中推断出来。当实际的类型名称很长，甚至可能是多余的时候，这个关键字很有用。如果你不确定类型是什么，想查一下结果支持什么操作，你可以去看方法的文档 [2.x.37] 在这个例子中，`it`的类型是 [2.x.38] 。
* 虽然`auto'关键字可以让我们不用输入长长的数据类型名称，但我们仍然要输入大量冗余的声明，说明开始和结束迭代器以及如何递增。与其这样，我们不如使用[1.x.71]，它将上面显示的所有语法包成一个更短的形式。
*


* [1.x.72]

*

*
* [2.x.39] 关于deal.II中使用的迭代器类的更多信息，见[2.x.40]，关于基于范围的for循环和`auto`关键字的更多信息，见[2.x.41]。           
* 接下来，我们在单元格的所有顶点上循环。为此，我们查询一个顶点索引的迭代器（在2D中，这是一个数组，包含的元素是`{0,1,2,3}`，但是由于`cell->vertex_indices()`知道单元格所处的维度，因此返回的数组在所有维度上都是正确的，这使得无论我们在2D还是3D中运行这段代码都是正确的，也就是说，它实现了 "独立维编程"
*
* - 我们将在[2.x.42]中讨论的一个重要部分）。)
*


* [1.x.73]
*
* 如果这个单元是在内部边界，那么它的顶点中至少有一个必须位于内环上，因此与中心的径向距离正好是0.5，达到浮点精度。所以我们计算这个距离，如果我们发现一个顶点具有这个属性，我们就标记这个单元，以便以后进行细化。然后，我们也可以打破所有顶点的循环，转到下一个单元。               
* 因为离中心的距离是以浮点数计算的，所以我们必须期望我们所计算的东西只能精确到[round-off](https://en.wikipedia.org/wiki/Round-off_error)以内。因此，我们永远不能指望通过平等的方式来比较距离和内半径。诸如 "if (distance_from_center == inner_radius) "这样的语句将会失败，除非我们运气特别好。相反，我们需要以一定的容忍度来做这种比较，通常的方法是写成`if [2.x.43] 。
*
* - inner_radius) <= tolerance)`，其中`tolerance'是比四舍五入大的某个小数字。问题是如何选择它。我们可以直接选择，比如说，`1e-10'，但这只适合于我们比较的对象是大小为1的情况。如果我们创建了一个单元大小为`1e+10'的网格，那么`1e-10'将远远低于四舍五入，就像以前一样，只有在我们特别幸运的情况下，比较才会成功。相反，使公差与被比较对象的典型 "尺度 "相对应*，几乎总是有用的。在这里，"比例 "将是内半径，或者是细胞的直径。我们选择前者，并将公差设置为[2.x.44]倍环形物的内半径。
*


* [1.x.74]
*
* 现在我们已经标记了所有我们想要细化的单元格，我们让三角化实际做这个细化。这样做的函数的名字很长，因为我们也可以对单元格进行粗化标记，而且这个函数可以一次完成粗化和细化。
*


* [1.x.75]
*
* 最后，在这五次细化迭代之后，我们要再次将生成的网格写到一个文件中，同样是SVG格式。这和上面的工作一样。
*


* [1.x.76]
*
* [1.x.77] [1.x.78]。


*
* 最后是主函数。这里没有什么可做的，只是调用两个子函数，产生两个网格。
*


* [1.x.79]
* [1.x.80][1.x.81] 。


* 运行该程序会产生两个网格的图形（grid-1.svg和grid-2.svg）。你可以用大多数的网络浏览器打开这些网格。
*
* - 在最简单的情况下，只要在你的文件系统资源管理器中打开当前目录，然后点击文件即可。如果你喜欢在命令行上工作，你可以用该文件调用你的网络浏览器。`firefox grid-1.svg`，`google-chrome grid-1.svg`，或者任何你的浏览器的名字。如果你这样做，这两个网格应该看起来像这样。
* [2.x.45]
* 左边那个，嗯，不是很刺激。右边的是&mdash;至少&mdash;非常规的。这些图片对每个单元格的 "细化水平 "进行了颜色编码。一个粗略的网格单元要经过多少次的细分才能得到指定的单元。在左边的图片中，这是无聊的，因为网格在全球范围内被细化了若干次，也就是说，[1.x.82]单元被细化的次数相同。
*（虽然第二个网格完全是人为的和捏造的，而且肯定在应用中不是很实用，但令大家惊讶的是，它已经进入了文献：见[2.x.46]。显然，它至少在某些方面是好的）。)
*

*[1.x.83][1.x.84] 。


*[1.x.85][1.x.86]


* 这个程序显然没有太多的功能，但特别是[2.x.47]函数有很多地方你可以发挥它。例如，你可以修改我们决定提炼哪些单元格的标准。一个例子是把条件改成这样。
* [1.x.87]
* 这将细化所有单元格中心的[2.x.48]坐标大于零的单元格（我们通过取消引用[2.x.50]迭代器调用的[2.x.49]函数返回一个Point<2>对象；下标[2.x.51]将得到[2.x.52]坐标，下标[2.x.53]得到[2.x.54] 坐标）。通过查看TriaAccessor提供的函数，你也可以使用更复杂的细化标准。
* 一般来说，你能用`cell->something()`形式的操作做什么，在文档中有点难找，因为`cell`不是一个指针，而是一个迭代器。你在单元格上取消的函数可以在`TriaAccessor'类的文档中找到（该类的函数也可以在单元格的面上调用，或者更广泛地在三角形中出现的各种几何对象上调用），以及`CellAccessor'（该类增加了一些专门针对单元格的函数*）。
* 对整个迭代器概念的更全面的描述可以在[2.x.55]文档模块中找到。
*

*[1.x.88][1.x.89] 。


* 另一种可能性是生成完全不同几何形状的网格。虽然对于复杂的几何体来说，没有办法绕过使用从网格生成器获得的网格，但是有很多几何体，deal.II可以使用GridGenerator命名空间中的函数为其创建网格。许多这样的几何体（如本例程序中使用的几何体）包含有弯曲面的单元：换句话说，我们希望放置在边界上的新顶点位于一个圆上。deal.II通过Manifold类（以及从它继承的类）处理复杂的几何体；特别是GridGenerator中对应于非笛卡尔网格的函数（如[2.x.56]或[2.x.57]将一个Manifold对象附加到三角形中应该是曲线的部分（分别为SphericalManifold和CylindricalManifold），并在应该是平面的部分使用另一个Manifold（FlatManifold）。关于这些类的设计理念和接口的描述，请参见Manifold的文档或[2.x.58]"歧管模块"。看看它们提供了什么，看看它们如何在这样的程序中被使用。
* 我们还在[2.x.59]中讨论了其他各种创建和操作网格的方法（并描述了附加流形的过程）。
*

*[1.x.90][1.x.91]


* 最后，我们对用deal.II修改或编写程序做一个评论。当你开始使用教程中的程序或你自己的应用程序时，你会发现错误会发生：你的程序会包含一些代码，这些代码要么立即中止程序，要么就是导致错误的结果。无论哪种情况，你都会发现知道如何使用调试器是非常有帮助的：你可能会通过把调试输出放到你的程序中，编译它，然后运行它来应付一段时间，但最终用调试器来发现错误要快得多，方便得多，也可靠得多，因为你不必一直重新编译程序，而且你可以检查变量的值和它们的变化。
* 与其推迟学习如何使用调试器，直到你真的看不到任何其他方法来发现一个错误，这里是我们将在本程序中提供的一个建议：尽可能快地学习如何使用调试器。([2.x.60] Questions (FAQ) page linked to from the top-level [1.x.92] also provides a good number of hints on debugging deal.II programs.
*

*[1.x.93][1.x.94] 。


* 在你的论文或出版物中包含网格往往是有用的。为此，按细化水平对单元进行颜色编码，并在每个单元上打印单元编号可能不是很有用。但它不一定是这样的
*
* - GridOut类允许为每种可能的输出格式设置标志（见GridOutFlagsnamespace中的类），以控制网格的具体绘制方式。当然，你也可以选择其他的输出文件格式，如VTK或VTU；这对三维网格特别有用，因为二维格式如SVG并不特别有用，因为它固定了三维物体的特定视角。因此，你可能想探索GridOut类中的其他选项。
*

* [1.x.95][1.x.96] [2.x.61] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-11_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5]
* [1.x.6][1.x.7][1.x.8] 。


* 我们要考虑的问题是拉普拉斯问题的解，只需满足纽曼边界条件：[1.x.9] 。
* 众所周知，如果这个问题要有一个解决方案，那么力需要满足兼容性条件[1.x.10]我们将考虑这样的特殊情况：[2.x.2]是围绕原点的半径为1的圆，而[2.x.3]、[2.x.4]。这种选择满足了兼容性条件。
* 兼容性条件允许上述方程的解，但它仍然保留了一个模糊性：因为只有解的导数出现在方程中，解只确定到一个常数。出于这个原因，我们必须为数字解提出另一个条件，以固定这个常数。
* 对于这一点，有多种可能性。[2.x.5] [2.x.6] 将离散化的一个节点固定为零或任何其他固定值。  这相当于一个附加条件 [2.x.7] 。虽然这是常见的做法，但不一定是个好主意，因为我们知道拉普拉斯方程的解只在 [2.x.8] 中，它不允许定义点值，因为它不是连续函数的一个子集。因此，即使对离散函数允许固定一个节点，但对连续函数却不允许，在数值解的这一点上，人们常常可以看到由此产生的错误尖峰。
* [2.x.9] 将域上的均值固定为零或任何其他值。这在连续水平上是允许的，因为[2.x.10]是由Sobolev不等式决定的，因此在离散水平上也是如此，因为我们只考虑[2.x.11]的子集。
* [2.x.12] 将域的边界上的均值固定为零或任何其他值。这在连续水平上也是允许的，因为 [2.x.13] ，同样由Sobolev的不等式。[2.x.14] 我们将选择最后一种可能性，因为我们想用它来证明另一种技术。
* 虽然这描述了要解决的问题，但我们仍然要弄清楚如何实现它。基本上，除了额外的均值约束，我们已经解决了这个问题好几次，使用迪里希特的边界值，我们只需要放弃对迪里希特边界节点的处理。高阶映射的使用也是相当微不足道的，我们将在使用它的各个地方进行解释；在几乎所有可以想象的情况下，你只会把描述映射的对象视为一个黑盒子，你不需要担心，因为它们的唯一用途似乎是被传递到库中深处的地方，那里的函数知道如何处理它们（即在[2.x.15]类及其后代中）。
* 这个程序中最棘手的一点是对均值约束的使用。幸运的是，库中有一个知道如何处理这种约束的类，我们已经经常使用它了，没有提到它的通用性。请注意，如果我们假设边界节点沿边界等距分布，那么均值约束[1.x.11]可以写成[1.x.12]，其中总和应在位于计算域边界的所有自由度指数上运行。让我们用[2.x.16]表示边界上数字最小的指数（或者任何其他方便选择的指数），那么这个约束也可以用[1.x.13]来表示，幸运的是，这正是AffineConstraints类所设计的约束形式。请注意，我们在之前的几个例子中使用了这个类来表示悬空节点的约束，它也有这种形式：在这里，中间的顶点应该有相邻顶点的平均值。一般来说，AffineConstraints类被设计用来处理形式为[1.x.14]的affine约束，其中[2.x.17]表示一个矩阵，[2.x.18]表示一个向量，而[2.x.19]是节点值的向量。在这种情况下，由于[2.x.20]代表一个同质约束，[2.x.21]是零向量。
* 在这个例子中，沿边界的均值允许这样的表述，[2.x.22]是一个只有一行的矩阵（即只有一个约束）。在实现中，我们将创建一个AffineConstraints对象，添加一个指向第一个边界节点[2.x.23]的约束（即在矩阵中添加另一行），并插入所有其他节点贡献的权重，在这个例子中刚好是[2.x.24] 。
* 稍后，我们将使用这个对象来消除线性方程组中的第一个边界节点，将其还原为一个没有常数偏移值的解。实施过程中的一个问题是，明确消除这个节点会导致矩阵中出现一些额外的元素，而我们事先并不知道这些元素的位置，也不知道矩阵的每一行中会有多少额外条目。我们将展示我们如何使用一个中间对象来解决这个问题。
* 现在我们来看看解决这个问题的程序的实现......
*

* [1.x.15] [1.x.16]。
* 像往常一样，程序开始时有一个相当长的包含文件的列表，你现在可能已经习惯了。
*


* [1.x.17]
*
* 只有这一条是新的：它声明了一个动态稀疏模式（DynamicSparsityPattern）类，我们将在下面进一步使用和解释。
*


* [1.x.18]
*
* 我们将利用C++标准库的[2.x.25]算法，所以我们必须包括以下文件来声明它。
*


* [1.x.19]

* 最后一步和以前的所有程序一样。
*


* [1.x.20]

* 然后我们声明一个表示拉普拉斯问题解决方案的类。由于这个例子程序是基于[2.x.26]，这个类看起来相当相同，唯一的结构区别是函数[2.x.27]本身，因此被称为[2.x.28]，而且输出函数被删除，因为解函数非常无聊，不值得被查看。   
* 其他唯一值得注意的变化是，构造函数取一个值，代表以后要使用的映射的多项式程度，而且它还有一个成员变量，正好代表这个映射。一般来说，这个变量在实际应用中会出现在声明或使用有限元的相同地方。
*


* [1.x.21]
*
* 构建这样一个对象，通过初始化变量。在这里，我们使用线性有限元（[2.x.29]变量的参数表示多项式程度），以及给定阶数的映射。将我们要做的事情打印到屏幕上。
*


* [1.x.22]
*
* 第一个任务是为这个问题设置变量。这包括生成一个有效的[2.x.30]对象，以及矩阵的稀疏模式，和代表边界上自由度平均值为零的约束条件的对象。
*


* [1.x.23]
*
* 第一个任务是微不足道的：生成一个自由度的枚举，并将解和右手向量初始化为正确的大小。
*


* [1.x.24]
*
* 下一个任务是构建代表约束的对象，即边界上自由度的平均值应为零。为此，我们首先需要一个实际在边界上的节点的列表。[2.x.31]命名空间有一个函数可以返回一个IndexSet对象，该对象包含所有在边界上的自由度的索引。     
* 一旦我们有了这个索引集，我们想知道哪个是边界上自由度对应的第一个索引。我们需要这个，因为我们想通过边界上所有其他自由度的值来约束边界上的一个节点。使用IndexSet类很容易得到这个 "第一个 "自由度的索引。
*


* [1.x.25]

* 然后生成一个只有这一条约束的约束对象。首先清除所有以前的内容（这些内容可能来自以前在更粗的网格上的计算），然后添加这一行，将[2.x.32]约束到其他边界DoF的总和，每个DoF都有权重
*
* - .最后，关闭约束对象，也就是说，对它做一些内部记录，以便更快地处理后面的内容。
*


* [1.x.26]
*
* 下一个任务是生成一个稀疏的模式。在这里，这的确是一个棘手的任务。通常情况下，我们只需调用[2.x.33]并使用悬挂节点约束来浓缩结果。我们在这里没有悬挂节点约束（因为我们在这个例子中只进行全局细化），但是我们在边界上有这个全局约束。在这种情况下，这带来了一个严重的问题：[2.x.34]类希望我们事先说明每行的最大条目数，可以是所有行的，也可以是每行单独的。在库中有一些函数可以告诉你这个数字，如果你只有悬空的节点约束（即[2.x.35]，但这对现在的情况来说是怎样的？困难的出现是因为消除约束的自由度需要在矩阵中增加一些条目，而这些条目并不那么容易确定。因此，如果我们在这里给出每行的最大条目数，我们就会有一个问题。     
* 由于这可能非常困难，以至于无法给出合理的答案，只允许分配合理的内存量，所以有一个动态稀疏模式（DynamicSparsityPattern）类，可以帮助我们解决这个问题。它不要求我们事先知道行可以有多少个条目，而是允许任何长度。因此，在你对行的长度没有很好的估计的情况下，它明显更灵活，但是代价是建立这样一个模式也比建立一个你事先有信息的模式要昂贵得多。尽管如此，由于我们在这里没有其他选择，我们将建立这样一个对象，用矩阵的尺寸初始化它，并调用另一个函数[2.x.36]来获得由于微分算子而产生的稀疏模式，然后用约束对象浓缩它，在稀疏模式中增加那些消除约束所需的位置。
*


* [1.x.27]
*
* 最后，一旦我们有了完整的模式，我们就可以从中初始化一个[2.x.37]类型的对象，反过来用它来初始化矩阵。请注意，这实际上是必要的，因为与[2.x.38]类相比，DynamicSparsityPattern的效率非常低，因为它必须使用更灵活的数据结构，所以我们不可能将稀疏矩阵类建立在它的基础上，而是需要一个[2.x.39]类型的对象，我们通过复制中间对象产生这个对象。     
* 作为进一步的附带说明，你会注意到我们在这里没有明确地要[2.x.40]稀疏模式。当然，这是由于[2.x.41]函数从一开始就生成了一个压缩的对象，你不能再向其添加新的条目。因此，[2.x.42]的调用是隐含在[2.x.43]的调用中的。
*


* [1.x.28]
*
* 下一个函数接着集合了线性方程组，对其进行求解，并对解进行评估。这样就有了三个动作，我们将把它们放到八个真实的语句中（不包括变量的声明，以及临时向量的处理）。因此，这个函数是为非常懒惰的人准备的。尽管如此，所调用的函数是相当强大的，通过它们，这个函数使用了整个库的大量内容。但让我们来看看每一个步骤。
*


* [1.x.29]
*
* 首先，我们要把矩阵和右手边组合起来。在以前的所有例子中，我们已经研究了如何手动完成这一工作的各种方法。然而，由于拉普拉斯矩阵和简单的右手边在应用中出现的频率很高，库中提供了实际为你做这件事的函数，即它们在所有单元格上进行循环，设置局部的矩阵和向量，并将它们放在一起作为最终结果。     
* 以下是两个最常用的函数：创建拉普拉斯矩阵和创建来自体或边界力的右手向量。它们需要映射对象、代表自由度和使用中的有限元的[2.x.44]对象、要使用的正交公式以及输出对象。创建右手向量的函数也必须接受一个描述（连续）右手向量函数的函数对象。     
* 让我们看一下矩阵和体力的集成方式。
*


* [1.x.30]
*
* 这很简单，对吗？     
* 不过，有两点需要说明。首先，这些函数在很多情况下都会用到。也许你想为一个矢量值有限元创建一个拉普拉斯或质量矩阵；或者你想使用默认的Q1映射；或者你想用拉普拉斯算子的一个系数来装配矩阵。由于这个原因，在[2.x.45]和[2.x.46]命名空间中有相当多的这些函数的变体。每当你需要这些函数的一个与上面调用的略有不同的版本时，当然值得看一下文档，并检查一些东西是否适合你的需要。     
* 第二点是关于我们使用的正交公式：我们想对双线性形状函数进行积分，所以我们知道我们至少要使用二阶高斯正交公式。另一方面，我们希望正交规则至少有边界近似的阶数。因为有[2.x.47]点的高斯规则的阶数是[2.x.48] ，而使用[2.x.49]度的多项式的边界逼近的阶数是[2.x.50] ，我们知道[2.x.51] 。由于r必须是一个整数，并且（如上所述）必须至少是[2.x.52]，这就弥补了上面计算[2.x.53]的公式。     
* 由于对右侧向量的体力贡献的生成是如此简单，我们对边界力也要重新做一遍：分配一个合适大小的向量并调用合适的函数。边界函数有常量值，所以我们可以从库中快速生成一个对象，我们使用与上面相同的正交公式，但这次维度较低，因为我们现在是在面上而不是在单元上积分。
*


* [1.x.31]
*
* 然后将来自边界的贡献与来自域内部的贡献相加。
*


* [1.x.32]
*
* 对于组装右手边，我们不得不使用两个不同的向量对象，然后再把它们加在一起。我们不得不这样做的原因是，[2.x.54]和[2.x.55]函数首先清除了输出向量，而不是将它们的结果与之前的内容相加。这可以合理地称为库在起步阶段的设计缺陷，但不幸的是，事情现在已经是这样了，很难改变这种无声地破坏现有代码的事情，所以我们不得不忍受。
*

*
* 现在，线性系统已经建立起来了，所以我们可以从矩阵和右手向量中消除我们约束到边界上其他自由度的均值约束的一个自由度，并解决这个系统。之后，再次分配约束，在这种情况下，这意味着将受约束的自由度设置为适当的值
*


* [1.x.33]

* 最后，评估我们得到的解决方案。正如在介绍中所说的，我们对解决方案的H1半规范感兴趣。在这里，我们在库中也有一个函数可以做到这一点，尽管是以一种稍微不明显的方式：[2.x.56]函数整合了一个有限元函数和一个连续函数之间的差值的规范。因此，如果我们想要一个有限元场的规范，我们只需将连续函数设为零。请注意，这个函数，就像库中的许多其他函数一样，至少有两个版本，一个是以映射为参数的（我们在这里使用），另一个是我们在以前的例子中使用的隐含的[2.x.57] 。  还要注意的是，我们采用的是高一级的正交公式，以避免超融合效应，即在某些点上，解刚好特别接近精确解（我们不知道这里是否会出现这种情况，但有已知的案例，我们只是想确认一下）。
*


* [1.x.34]
*
* 然后，刚刚调用的函数将其结果作为一个值的向量返回，每个值表示一个单元格上的法线。为了得到全局法线，我们要做以下工作。
*


* [1.x.35]

* 最后的任务
*
* - 产生输出。
*


* [1.x.36]
*
* 下面这个解线性方程组的函数是从[2.x.58]中复制过来的，在那里有比较详细的解释。
*


* [1.x.37]
*
* 接下来，我们把解决方案以及材料ID写到VTU文件中。这与其他许多教程程序中的做法相似。这个教程程序中提出的新内容是，我们要确保写到文件中用于可视化的数据实际上是deal.II内部使用的数据的忠实代表。这是因为大多数的可视化数据格式只通过顶点坐标来表示单元，但没有办法表示弧形边界，而在deal.II中使用高阶映射时，弧形边界是用来表示的。
*
* 换句话说，你在可视化工具中看到的东西实际上不是你正在计算的东西。顺带一提，在使用高阶形状函数时也是如此。大多数可视化工具只呈现双线性/三线性的表示。这在[2.x.59]中有详细的讨论。
* 所以我们需要确保高阶表示被写入文件。我们需要考虑两个特别的话题。首先，我们通过[2.x.60]告诉DataOut对象，我们打算将元素的细分解释为高阶拉格朗日多项式，而不是双线性斑块的集合。最近的可视化程序，如ParaView 5.5版或更新版，然后可以呈现高阶解决方案（更多细节见[1.x.38] ）。其次，我们需要确保映射被传递给[2.x.61]方法。最后，DataOut类默认只打印[1.x.39]单元的曲面，所以我们需要确保通过映射将内部单元也打印成曲面。
*


* [1.x.40]
*
* 最后是控制要执行的不同步骤的主要功能。它的内容相当简单，生成一个圆的三角形，给它关联一个边界，然后在随后的更细的网格上做几个循环。请注意，我们将网格细化放到了循环头中；这对测试程序来说可能是件好事，但对实际应用来说，你应该考虑到这意味着网格是在循环最后一次执行后被细化的，因为增量子句（三部分循环头的最后一部分）是在比较部分（第二部分）之前执行的，如果网格已经相当细化了，这可能是相当昂贵的。在这种情况下，你应该安排代码，使网格在最后一次循环运行后不再被进一步细化（或者你应该在每次运行的开始阶段进行细化，第一次除外）。
*


* [1.x.41]
*
* 在所有数据生成后，将结果的表格写到屏幕上。
*


* [1.x.42]
*
* 最后是主函数。它的结构与前面几个例子中使用的结构相同，所以可能不需要更多解释。
*


* [1.x.43]
*
* 这是主循环，用线性到立方的映射做计算。请注意，由于我们只需要[2.x.62]类型的对象一次，我们甚至不给它命名，而是创建一个未命名的这样的对象，并调用它的[2.x.63]函数，随后它又立即被销毁。
*


* [1.x.44]
* [1.x.45][1.x.46] 。


* 这就是程序的输出结果。
* [1.x.47]
* 正如我们所期望的，每个不同的映射的收敛顺序显然是对网格大小的二次方。[2.x.64] [2.x.65] 有趣的是，双线性映射(即1度)的误差比高阶映射的误差大三倍以上；因此，在这种情况下，使用高阶映射显然是有利的，不是因为它提高了收敛顺序，只是为了减少收敛顺序之前的常数。另一方面，除了在非常粗的网格上，使用立方映射只能进一步提高结果，而且幅度不大。
* 我们还可以通过使用例如ParaView来可视化底层网格。下面的图片显示了不同映射度的初始网格。
* [2.x.66]
* 显然，当我们从线性映射到二次映射时，效果是最明显的。这也反映在上表中给出的误差值中。从二次方到三次方的效果没有那么明显，但由于对圆形边界的描述更加准确，所以还是很明显的。
* 接下来，让我们看一下三次全局细化后的网格
* [2.x.67]
* 在这里，差异就不那么明显了，特别是对于高阶映射。事实上，在这个细化水平上，表格中报告的误差值在二度和三度的映射之间基本上是相同的。
*

* [1.x.48][1.x.49] [2.x.68] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-12_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15]
* [2.x.2]
* [1.x.16]
* [1.x.17][1.x.18][1.x.19] 。


*[1.x.20][1.x.21]


* 本例专门介绍[2.x.3]不连续Galerkin方法[2.x.4]，简而言之就是DG方法。它包括以下主题。2.x.5] [2.x.6] 用DG方法对线性平流方程进行离散化。   [2.x.7] 使用FEInterfaceValues组装跳跃项和单元间界面的其他表达。   [2.x.8] 使用[2.x.9] [2.x.10] 组合系统矩阵。
* 本程序特别关注的是DG方法的循环。这些问题特别复杂，主要是因为对于面的条款，我们必须分别区分边界、规则的内部面和有悬挂节点的内部面的情况。[2.x.11]处理了单元和面的迭代的复杂性，并允许为不同的单元和面项指定 "工作者"。脸部条款本身的整合，包括对自适应细化脸部的整合，是通过FEInterfaceValuesclass完成的。
*[1.x.22][1.x.23]
*

* 本例中解决的模型问题是线性平流方程[1.x.24]，受域的边界[2.x.13]的流入部分的边界条件[1.x.25]制约。  这里，[2.x.14]表示矢量场，[2.x.15]是（标量）解函数，[2.x.16]是边界值函数，[1.x.26]是域的边界流入部分，[2.x.17]表示边界[2.x.18]的单位外向法线。这个方程是本教程[2.x.19]中已经考虑的平流方程的保守版本。
*

* 在每个单元[2.x.20]上，我们从左边乘以测试函数[2.x.21]，并通过部分积分得到：[1.x.27]当对所有单元[2.x.22]进行求和时，边界积分是在内部和外部表面整体进行的，因此，有三种情况。[2.x.23] [2.x.24] 流入的外部边界（我们用给定的[2.x.26]替换[2.x.25]）。   [2.x.27] [2.x.28] 流出的外部边界。   [2.x.29] [2.x.30]内面（两边的积分变成了跳跃，我们使用上风速度）。   [2.x.31] [2.x.32]。
* 这里，跳跃定义为[2.x.33] ，其中上标指的是面的左（'+'）和右（'-'）值。上风值[2.x.34]被定义为[2.x.35]，如果[2.x.36]，否则为[2.x.37]。
* 因此，依赖网格的弱形式为：[1.x.28]这里，[2.x.38]是三角形的所有活动单元的集合，[2.x.39]是所有活动内部面的集合。这个公式被称为上风非连续Galerkin方法。
* 为了实现这种双线性形式，我们需要用通常的方法计算单元项（第一个和）来实现单元上的积分，用FEInterfaceValues计算界面项（第二个和），以及边界项（另外两个项）。
*


*[1.x.29][1.x.30]


* 我们在[2.x.41]上求解平流方程，[2.x.42]代表一个圆形的逆时针流场，[2.x.43]代表[2.x.44]，[2.x.45]代表[2.x.46] 。
* 我们通过估计每个单元的梯度规范，自适应地细化网格，在一连串的网格上求解。在每个网格上求解后，我们以vtk格式输出解，并计算出解的[2.x.47]准则。由于精确的解是0或1，我们可以用这个方法来衡量数值解的偏移量的大小。
*

* [1.x.31] [1.x.32]。
* 前面几个文件已经在前面的例子中讲过了，因此不再进一步评论。
*


* [1.x.33]
*
* 这里定义了不连续的有限元。它们的使用方式与所有其他有限元相同，不过
*
* - 正如你在以前的教程程序中所看到的那样
*
* - 用户与有限元类的交互并不多：它们被传递给[2.x.48]和[2.x.49]对象，仅此而已。
*


* [1.x.34]
*
* FEInterfaceValues需要这个头来计算界面上的积分。
*


* [1.x.35]

* 我们将使用最简单的求解器，称为Richardson迭代，它代表了一种简单的缺陷修正。这与一个块状SSOR预处理器（定义在precondition_block.h中）相结合，该预处理器使用DG离散化产生的系统矩阵的特殊块状结构。
*


* [1.x.36]
*
* 我们将使用梯度作为细化指标。
*


* [1.x.37]
*
* 最后，新的包含文件用于使用MeshWorker框架中的Mesh_loop
*


* [1.x.38]
*
* 就像所有的程序一样，我们在完成这一部分时要包括所需的C++头文件，并声明我们要使用dealii命名空间中的对象，不加前缀。
*


* [1.x.39]
*
* [1.x.40] [1.x.41].
* 首先，我们定义一个描述不均匀边界数据的类。由于只使用它的值，我们实现value_list()，但不定义Function的所有其他函数。
*


* [1.x.42]
*
* 鉴于流动方向，单位方格[2.x.50]的流入边界是右边界和下边界。我们在x轴上规定了不连续的边界值1和0，在右侧边界上规定了值0。该函数在流出边界上的值将不会在DG方案中使用。
*


* [1.x.43]
*
* 最后，一个计算并返回风场的函数 [2.x.51] 。正如介绍中所解释的，在2D中我们将使用一个围绕原点的旋转场。在3D中，我们只需不设置[2.x.52]分量（即为零），而该函数在目前的实现中不能用于1D。
*


* [1.x.44]
*
* [1.x.45] [1.x.46]。
* 以下对象是我们在调用[2.x.53]时使用的抓取和复制对象 新的对象是FEInterfaceValues对象，它的工作原理类似于FEValues或FEFacesValues，只是它作用于两个单元格之间的接口，并允许我们将接口条款组合成我们的弱形式。
*


*


* [1.x.47]
*
* [1.x.48] [1.x.49].
* 在这个准备工作之后，我们继续进行本程序的主类，称为AdvectionProblem。   
* 这一切对你来说应该是非常熟悉的。有趣的细节只有在实现集合函数的时候才会出现。
*


* [1.x.50]

* 此外，我们要使用DG元素。
*


* [1.x.51]

* 接下来的四个成员代表要解决的线性系统。  [2.x.54]是由[2.x.55]产生的，在[2.x.56]中计算，用于确定[2.x.57]中非零元素的位置。
*


* [1.x.52]
*
* 我们从构造函数开始。[2.x.58]的构造器调用中的1是多项式的度数。
*


* [1.x.53]
*
* 在设置通常的有限元数据结构的函数中，我们首先需要分配DoF。
*


* [1.x.54]
*
* 我们从生成稀疏性模式开始。为此，我们首先用系统中出现的耦合物填充一个动态稀疏模式（DynamicSparsityPattern）类型的中间对象。在建立模式之后，这个对象被复制到[2.x.59]，可以被丢弃。
*

*
* 为了建立DG离散化的稀疏模式，我们可以调用类似于[2.x.60]的函数，它被称为[2.x.61]。
*


* [1.x.55]

* 最后，我们设置了线性系统的所有组成部分的结构。
*


* [1.x.56]
*
* [1.x.57] [1.x.58]。


*
* 在这里我们看到了与手工组装的主要区别。我们不需要在单元格和面上写循环，而是在调用[2.x.62]时包含逻辑，我们只需要指定每个单元格、每个边界面和每个内部面应该发生什么。这三个任务是由下面的函数里面的lambda函数处理的。
*


*


* [1.x.59]
*
* 这是每个单元格将被执行的函数。
*


* [1.x.60]
*
* 我们解决的是一个同质方程，因此在单元项中没有显示出右手。  剩下的就是整合矩阵条目。
*


* [1.x.61]
*
* 这是为边界面调用的函数，包括使用FEFaceValues的正常积分。新的逻辑是决定该术语是进入系统矩阵（流出）还是进入右手边（流入）。
*


* [1.x.62]
*
* 这是在内部面调用的函数。参数指定了单元格、面和子面的指数（用于自适应细化）。我们只是将它们传递给FEInterfaceValues的reinit()函数。
*


* [1.x.63]
*
* 下面的lambda函数将处理从单元格和面组件中复制数据到全局矩阵和右侧。     
* 虽然我们不需要AffineConstraints对象，因为在DG离散中没有悬挂的节点约束，但我们在这里使用一个空对象，因为这允许我们使用其`copy_local_to_global`功能。
*


* [1.x.64]

* 在这里，我们最终处理了装配问题。我们传入ScratchData和CopyData对象，以及上面的lambda函数，并指定我们要对内部面进行一次装配。
*


* [1.x.65]
*
* [1.x.66] [1.x.67]。
* 对于这个简单的问题，我们使用最简单的求解器，称为Richardson迭代，它代表了一个简单的缺陷修正。这与一个块状SSOR预调节器相结合，该预调节器使用DG离散化产生的系统矩阵的特殊块状结构。这些块的大小是每个单元的DoF数量。这里，我们使用SSOR预处理，因为我们没有根据流场对DoFs进行重新编号。如果在流的下游方向对DoFs进行重新编号，那么块状高斯-赛德尔预处理（见PreconditionBlockSOR类，放松=1）会做得更好。
*


* [1.x.68]
*
* 这里我们创建了预处理程序。
*


* [1.x.69]
*
* 然后将矩阵分配给它，并设置正确的块大小。
*


* [1.x.70]
*
* 在这些准备工作之后，我们就可以启动线性求解器了。
*


* [1.x.71]
*
* 我们根据一个非常简单的细化标准来细化网格，即对解的梯度的近似。由于这里我们考虑的是DG(1)方法（即我们使用片状双线性形状函数），我们可以简单地计算每个单元的梯度。但是我们并不希望我们的细化指标只建立在每个单元的梯度上，而是希望同时建立在相邻单元之间的不连续解函数的跳跃上。最简单的方法是通过差分商计算近似梯度，包括考虑中的单元和其相邻的单元。这是由[2.x.63]类完成的，它计算近似梯度的方式类似于本教程[2.x.65]中描述的[2.x.64]。事实上，[2.x.66]类是在[2.x.68]的[2.x.67]类之后开发的。与 [2.x.69] 中的讨论相关，这里我们考虑 [2.x.70] 。此外，我们注意到，我们不考虑近似的二次导数，因为线性平流方程的解一般不在[2.x.71]中，而只在[2.x.72]中（或者，更准确地说：在[2.x.73]中，即在方向[2.x.74]中的导数是可方整的函数空间）。
*


* [1.x.72]
*
* [2.x.75]类将梯度计算为浮点精度。这就足够了，因为它们是近似的，只作为细化的指标。
*


* [1.x.73]
*
* 现在计算出了近似梯度
*


* [1.x.74]

*并且它们被单元格按系数[2.x.76]进行缩放。
*


* [1.x.75]
*
* 最后他们作为细化指标。
*


* [1.x.76]
*
* 这个程序的输出包括一个自适应细化网格和数值解的vtk文件。最后，我们还用[2.x.77]计算了解的L-无穷大规范。
*


* [1.x.77]

* 以下[2.x.78]函数与之前的例子类似。
*


* [1.x.78]

* 下面的[2.x.79]函数与之前的例子也类似，不需要注释。
*


* [1.x.79]
* [1.x.80][1.x.81] 。


*
* 这个程序的输出包括控制台输出和vtk格式的解决方案。
* [1.x.82]
*
* 我们展示了初始网格的解决方案，以及经过两个和五个自适应细化步骤后的网格。
* [2.x.80] [2.x.81] [2.x.82].
* 最后我们展示一个三维计算的图。
* [2.x.83]
*

*[1.x.83][1.x.84][1.x.85]


* 在这个程序中，我们使用了不连续的元素。这是一个合理的问题，为什么不简单地使用正常的、连续的元素呢？当然，对于每一个有数值方法背景的人来说，答案是显而易见的：连续Galerkin（cG）方法对于传输方程来说是不稳定的，除非特别添加稳定项。然而，DG方法[1.x.86]则是稳定的。用目前的程序来说明这一点并不困难；事实上，只需要做以下一些小的修改就可以了。
*
* 将元素改为FE_Q而不是FE_DGQ。
*
* - 以与[2.x.84]完全相同的方式增加对悬挂节点约束的处理。
*
* - 我们需要一个不同的求解器；[2.x.85]中的直接求解器是一个方便的选择。一个有经验的deal.II用户将能够在10分钟内完成这个工作。
* 虽然上面显示了2d解，在界面上包含一些小尖峰，但是在网格细化下高度稳定，当使用连续元素时，结果看起来大不相同。
* [2.x.86]
* 在细化迭代5中，图像不能再以合理的方式绘制成三维图。因此，我们展示了一个范围为[2.x.87]的彩色图（当然，准确解的解值位于[2.x.88]）。在任何情况下，很明显，连续Galerkin解表现出振荡的行为，随着网格的细化越来越差。
* 如果人们出于某种原因想使用连续元素，有许多策略可以稳定cG方法。讨论这些方法超出了本教程的范围；例如，感兴趣的读者可以看一下[2.x.89]。
*


* [1.x.87][1.x.88][1.x.89] 。


* 鉴于在这种情况下精确的解是已知的，进一步扩展的一个有趣的领域是确认这个程序的收敛顺序。在目前的情况下，解是不光滑的，因此我们不能期望得到特别高的收敛顺序，即使我们使用高阶元素。但是，即使解[1.x.90]是光滑的，该方程也不是椭圆的，因此并不清楚我们应该获得与最优插值估计相等的收敛阶数（例如，我们可以通过使用二次元得到[2.x.90]准则的收敛）。
* 事实上，对于双曲方程，理论预测常常表明，最好的希望是低于插值估计值二分之一的阶。例如，对于流线扩散法（此处用于稳定传输方程解的DG法的替代方法），我们可以证明，对于度数为[2.x.92]的元素，在任意网格上的收敛顺序为[2.x.93]。虽然在均匀细化的网格上观察到的顺序经常是[2.x.94]，但我们可以构造所谓的Peterson网格，在这些网格上实际上达到了更差的理论界限。这应该是比较容易验证的，例如使用[2.x.95]函数。
* 一个不同的方向是观察运输问题的解决往往具有不连续性，因此我们[1.x.91]在每个坐标方向的每个单元的网格可能不是最佳的。相反，一个更好的策略是只在平行于不连续的方向上切割单元。这被称为[1.x.92]，是[2.x.96]的主题。
*

*[1.x.93][1.x.94] [2.x.97]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-12b_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] , [2.x.3] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12]
*[1.x.13][1.x.14][1.x.15] 。


* 这是[2.x.4]的一个变体，唯一的变化是我们使用了MeshWorker框架和预制的LocalIntegrator辅助类，而不是使用FEInterfaceValues来组装面的术语。
* 这个框架在实践中如何使用的细节将作为本教程程序的一部分加以解释。
*[1.x.16][1.x.17]
*

* 我们在这里解决的问题与 [2.x.5] 中的问题相同。
*

* [1.x.18] [1.x.19]。
* 前面几个文件已经在前面的例子中讲过了，因此不再进一步评论。
*


* [1.x.20]
*
* 这里定义了不连续的有限元。它们的使用方式与所有其他有限元相同，不过
*
* - 正如你在以前的教程程序中所看到的那样
*
* - 用户与有限元类的交互并不多：它们被传递给[2.x.6]和[2.x.7]对象，仅此而已。
*


* [1.x.21]

* 我们将使用最简单的求解器，称为Richardson迭代，它表示简单的缺陷修正。这与一个块状SSOR预处理器（定义在precondition_block.h中）相结合，该预处理器使用DG离散化产生的系统矩阵的特殊块状结构。
*


* [1.x.22]
*
* 我们将使用梯度作为细化指标。
*


* [1.x.23]
*
* 这里有新的包含文件，用于使用MeshWorker框架。第一个包含类[2.x.8]，它为局部积分器提供了局部和全局自由度之间的映射。在第二个文件中，我们发现一个类型为[2.x.10]的对象，它主要是对一组FEValues对象的封装。文件<tt>meshworker/simple.h</tt>包含了将局部集成数据组装成只包含一个矩阵的全局系统的类。最后，我们将需要在所有的网格单元和面上运行循环的文件。
*


* [1.x.24]
*
* 就像所有的程序一样，我们在完成这一部分时要包括所需的C++头文件，并声明我们要使用dealii命名空间中的对象，不加前缀。
*


* [1.x.25]
*
* [1.x.26] [1.x.27].
* 首先，我们定义一个描述不均匀边界数据的类。由于只使用它的值，我们实现value_list()，但不定义Function的所有其他函数。
*


* [1.x.28]
*
* 鉴于流动方向，单位方格[2.x.11]的流入边界是右边界和下边界。我们在x轴上规定了不连续的边界值1和0，在右侧边界上规定了值0。该函数在流出边界上的值将不会在DG方案内使用。
*


* [1.x.29]
*
* 最后，一个计算并返回风场的函数 [2.x.12] 。正如介绍中所解释的，在2D中我们将使用一个围绕原点的旋转场。在3D中，我们只需不设置[2.x.13]分量（即为零），而该函数在目前的实现中不能用于1D。
*


* [1.x.30]
*
* [1.x.31] [1.x.32].
* 在这个准备工作之后，我们继续进行本程序的主类，称为AdvectionProblem。它基本上是 [2.x.14] 的主类。我们没有AffineConstraints对象，因为在DG离散中没有悬挂节点约束。
*

*
* 主要的区别只出现在集合函数的实现上，因为在这里，我们不仅需要覆盖面上的通量积分，我们还使用MeshWorker接口来简化涉及的循环。
*


* [1.x.33]
*
* 此外，我们想使用1度的DG元素（但这只在构造函数中指定）。如果你想使用不同度数的DG方法，整个程序保持不变，只需在构造函数中用所需的多项式度数替换1。
*


* [1.x.34]

* 接下来的四个成员代表要解决的线性系统。  [2.x.15]是由[2.x.16]产生的，在[2.x.17]中计算，用于确定[2.x.18]中非零元素的位置。
*


* [1.x.35]
*
* 最后，我们必须提供集合单元格、边界和内表面条款的函数。在MeshWorker框架中，所有单元的循环和大部分操作的设置都将在这个类之外完成，所以我们所要提供的只是这三个操作。他们将在中间对象上工作，首先，我们在这里定义了交给本地整合函数的信息对象的别名，以使我们的生活更轻松。
*


* [1.x.36]
*
* 下面的三个函数是在所有单元和面的通用循环中被调用的。它们是进行实际积分的函数。     
* 在我们下面的代码中，这些函数并不访问当前类的成员变量，所以我们可以将它们标记为[2.x.19]，并简单地将这些函数的指针传递给MeshWorker框架。然而，如果这些函数想要访问成员变量（或者需要超出下面指定的参数），我们可以使用lambda函数的设施来为MeshWorker框架提供对象，这些对象就像拥有所需的参数数量和类型，但实际上已经绑定了其他参数。
*


* [1.x.37]
*
* 我们从构造函数开始。[2.x.20]的构造器调用中的1是多项式的度数。
*


* [1.x.38]
*
* 在设置通常的有限元数据结构的函数中，我们首先需要分配DoF。
*


* [1.x.39]
*
* 我们从生成稀疏性模式开始。为此，我们首先用系统中出现的耦合物填充一个动态稀疏模式（DynamicSparsityPattern）类型的中间对象。在建立模式之后，这个对象被复制到[2.x.21]，可以被丢弃。
*

*
* 为了建立DG离散化的稀疏模式，我们可以调用类似于[2.x.22]的函数，它被称为[2.x.23]。
*


* [1.x.40]

* 最后，我们设置了线性系统的所有组成部分的结构。
*


* [1.x.41]
*
* [1.x.42] [1.x.43]。


*
* 这里我们看到了与手工组装的主要区别。我们不需要在单元格和面上写循环，而是将这一切交给MeshWorker框架。为了做到这一点，我们只需要定义局部的集成函数，并使用命名空间[2.x.24]中的一个类来构建全局系统。
*


* [1.x.44]
*
* 这是一个神奇的对象，它知道关于数据结构和局部集成的一切。  这是一个在函数[2.x.25]中做工作的对象，它被下面的[2.x.26]隐含地调用。在我们提供指针的函数完成局部积分后，[2.x.27]对象将这些分布到全局稀疏矩阵和右手边的向量中。
*


* [1.x.45]
*
* 首先，我们初始化正交公式和工作者基类中的更新标志。对于正交，我们采取安全策略，使用QGauss公式，其点数比使用的多项式度数高一个。由于单元格、边界和内部面的正交率可以独立选择，所以我们必须把这个值交给三次。
*


* [1.x.46]
*
* 这些是我们在整合系统时需要的数值类型。它们被添加到用于单元格、边界和内部面以及内部邻居面的标志中，这是由四个[2.x.28]值强制的。
*


* [1.x.47]
*
* 在准备好<tt>info_box</tt>中的所有数据后，我们初始化其中的FEValues对象。
*


* [1.x.48]
*
* 到目前为止创建的对象帮助我们在每个单元和面做局部的整合。现在，我们需要一个对象来接收整合后的（本地）数据，并把它们转发给装配程序。
*


* [1.x.49]
*
* 现在，我们必须创建汇编对象，并告诉它，把本地数据放在哪里。这些将是我们的系统矩阵和右手边的数据。
*


* [1.x.50]
*
* 最后，在所有活动单元上进行积分循环（由第一个参数决定，它是一个活动迭代器）。     
* 正如在类声明中声明局部积分函数时的讨论中所指出的，集合积分器类所期望的参数实际上不是函数指针。相反，它们是可以像函数一样被调用的对象，有一定数量的参数。因此，我们也可以在这里传递具有适当的operator()实现的对象，或者如果本地集成器是，例如，非静态成员函数，则可以传递lambda函数。
*


* [1.x.51]
*
* [1.x.52] [1.x.53]。


*
* 这些是给上面所说的[2.x.29]的函数。它们计算单元格和面对系统矩阵和右手边的局部贡献。
*


* [1.x.54]
*
* 首先，让我们从[2.x.30]中检索这里使用的一些对象。注意，这些对象可以处理更复杂的结构，因此这里的访问看起来比看起来更复杂。
*


* [1.x.55]
*
* 有了这些对象，我们像往常一样继续进行局部积分。首先，我们在正交点上循环，计算当前点的平流矢量。
*


* [1.x.56]
*
* 我们解决的是一个同质方程，因此在单元项中没有显示出右手。  剩下的就是整合矩阵条目。
*


* [1.x.57]
*
* 现在对边界项也是如此。注意，现在我们使用FEValuesBase，即FEFaceValues和FESubfaceValues的基类，以便获得法向量。
*


* [1.x.58]

* 最后，内部面的条款。这里的区别是，我们收到两个信息对象，每个与面相邻的单元都有一个，我们组装了四个矩阵，每个单元一个，两个用于来回耦合。
*


* [1.x.59]
*
* 对于正交点、权重等，我们使用第一个参数的FEValuesBase对象。
*


* [1.x.60]
*
* 对于额外的形状函数，我们必须询问邻居FEValuesBase。
*


* [1.x.61]

* 然后我们得到对四个局部矩阵的引用。字母u和v分别指的是试验和测试函数。%的数字表示由info1和info2提供的单元。按照惯例，每个信息对象中的两个矩阵指的是各自单元上的试验函数。第一个矩阵包含该单元的内部耦合，而第二个矩阵包含单元之间的耦合。
*


* [1.x.62]
*
* 这里，按照前面的函数，我们会有局部的右手边向量。幸运的是，界面条款只涉及解决方案，右手边没有收到任何贡献。
*


*


* [1.x.63]
*
* 这个词我们已经看过了。
*


* [1.x.64]
*
* 我们另外组装了[2.x.31]这个术语。
*


* [1.x.65]

* 这个我们也已经看过了。
*


* [1.x.66]

* 而这是另一个新的。  [2.x.32] :
*


* [1.x.67]
*
* [1.x.68] [1.x.69]。
* 对于这个简单的问题，我们使用最简单的求解器，称为Richardson迭代，它代表了一个简单的缺陷修正。这与一个块状SSOR预调节器相结合，该预调节器使用DG离散化产生的系统矩阵的特殊块状结构。这些块的大小是每个单元的DoF数量。这里，我们使用SSOR预处理，因为我们没有根据流场对DoFs进行重新编号。如果在流的下游方向对DoFs进行重新编号，那么块状高斯-赛德尔预处理（见PreconditionBlockSOR类，放松=1）会做得更好。
*


* [1.x.70]
*
* 这里我们创建了预处理程序。
*


* [1.x.71]
*
* 然后将矩阵分配给它，并设置正确的块大小。
*


* [1.x.72]
*
* 在这些准备工作之后，我们就可以启动线性求解器了。
*


* [1.x.73]
*
* 我们根据一个非常简单的细化标准来细化网格，即对解的梯度的近似。由于这里我们考虑的是DG(1)方法（即我们使用片状双线性形状函数），我们可以简单地计算每个单元的梯度。但是我们并不希望我们的细化指标只建立在每个单元的梯度上，而是希望同时建立在相邻单元之间的不连续解函数的跳跃上。最简单的方法是通过差分商计算近似梯度，包括考虑中的单元和其相邻的单元。这是由[2.x.33]类完成的，它计算近似梯度的方式类似于本教程[2.x.35]中描述的[2.x.34]。事实上，[2.x.36]类是在[2.x.38]的[2.x.37]类之后开发的。与 [2.x.39] 中的讨论相关，这里我们考虑 [2.x.40] 。此外，我们注意到，我们不考虑近似的二次导数，因为线性平流方程的解一般不在[2.x.41]中，而只在[2.x.42]中（或者，更准确地说：在[2.x.43]中，即在方向[2.x.44]中的导数是可平方整除的函数空间）。
*


* [1.x.74]
*
* [2.x.45]类将梯度计算为浮点精度。这就足够了，因为它们是近似的，只作为细化的指标。
*


* [1.x.75]
*
* 现在计算出了近似的梯度
*


* [1.x.76]
*
*并且它们被单元格按系数[2.x.46]进行缩放。
*


* [1.x.77]
*
* 最后他们作为细化指标。
*


* [1.x.78]
*
* 该程序的输出包括自适应细化网格的eps文件和gnuplot格式的数值解。
*


* [1.x.79]

* 首先将网格写成eps格式。
*


* [1.x.80]

* 然后以gnuplot格式输出解决方案。
*


* [1.x.81]

* 下面的[2.x.47]函数与之前的例子类似。
*


* [1.x.82]

* 下面的[2.x.48]函数与之前的例子也类似，不需要注释。
*


* [1.x.83]
*[1.x.84][1.x.85]


*
* 这个程序的输出与[2.x.49]非常相似，我们在此不重复输出。
* 我们展示了在初始网格上的解决方案，经过两个和五个自适应细化步骤后的网格。
* [2.x.50] [2.x.51] [2.x.52].
*

* 然后我们再次展示最终的网格（经过5个细化步骤）和解决方案，这一次有一个更好的三维渲染（使用[2.x.53]函数和基于VTK的VisIt可视化程序获得），更好地显示了细化网格上跳跃的清晰度和解决方案沿界面的过冲和欠冲现象。
* [2.x.54] [2.x.55]
*

* 最后我们展示一个3D计算的图。
* [2.x.56]
*

*[1.x.86][1.x.87][1.x.88]


* 关于进一步扩展的想法，请参见见 [2.x.57] 。
*

* [1.x.89][1.x.90] [2.x.58] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-13_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19]
*[1.x.20][1.x.21][1.x.22] 。


*[1.x.23][1.x.24]


*
* 在这个示例程序中，我们并不关心如何使用deal.II及其设施的新方法，而是介绍编写模块化和可扩展有限元程序的方法。其主要原因是现代研究软件的规模和复杂性：实现现代误差估计概念和自适应求解方法的应用程序往往变得比较大。例如，在2002年写这个程序时，deal.II的主要作者的三个最大的应用程序，在写这个例子程序时是。[2.x.2] [2.x.3] 一个用不连续加尔金有限元法解决双曲守恒方程的程序。33,775行代码； [2.x.4] 一个参数估计程序。28,980行代码； [2.x.5] 一个波浪方程求解器：21,020行代码。[2.x.6]
*（库的适当
*
* - 不包括示例程序和测试套件
*
* 截至2002年春天，该库的代码量略多于15万行。当然，现在已经大了好几倍了）。)这些应用程序的规模处于一个人，甚至一个有经验的程序员所能管理的边缘。
*

*
* 上面的数字说明了一件事：没有被分解成较小的、大部分独立的片段的单体程序是无法生存的，因为即使是作者也会很快失去对程序不同部分之间的各种依赖关系的概述。只有数据封装，例如使用面向对象的编程方法，以及通过定义小而固定的接口来实现模块化，才能帮助构建数据流和相互依赖关系。如果一个以上的人在开发一个程序，这也是一个绝对的先决条件，因为否则会很快出现混乱，因为如果一个开发人员需要知道另一个人是否改变了不同模块的内部结构，如果它们没有被干净地分开的话。
*

*
* 在以前的例子中，你已经看到库本身是如何被分成几个复合体的，每个复合体都建立在底层复合体之上，但相对独立于其他复合体。[2.x.7] [2.x.8] 三角形类复合物，以及相关的迭代器类；[2.x.9] 有限元类；[2.x.10] DoFHandler类复合物，以及相关的迭代器，建立在三角形和有限元类之上；[2.x.11] 实现单元格和实单元格之间映射的类；[2.x.12] FEValues类复合物，建立在有限元和映射的之上。[2.x.13] 除了这些，还有大量的小类，当然还有以下 "工具 "模块。[2.x.14] [2.x.15] 以各种图形格式输出；[2.x.16] 线性代数类。[2.x.17] 这些复数也可以在deal.II手册网站的首页上以流程图的形式找到。
*

*
* 这个程序的目的是给出一个例子，说明一个相对简单的有限元程序是如何结构化的，从而使我们最终拥有一组相互独立的模块，这是可行的。这使得我们可以在一端改变程序，而不必担心另一端的程序会被破坏，只要我们不触及两端交流的界面。当然，C++中的接口是抽象基类的声明。
*

*
* 在这里，我们将（再次）实现一个拉普拉斯求解器，尽管与以前的例子程序相比有一些不同。[2.x.18] [2.x.19] 实现数值求解方程过程的类不再负责驱动 "求解-估计误差-修正-再求解 "的过程，而是将其委托给外部函数。这首先允许在更大的范围内将其作为一个构件，在这里拉普拉斯方程的解可能只是其中的一部分（例如，在非线性问题中，拉普拉斯方程可能要在每个非线性步骤中解决）。它还允许围绕该类建立一个框架，允许使用其他方程的求解器（但具有相同的外部接口），以备对不同类型的偏微分方程评估一些技术。[2.x.20] 它将评估计算出的解的过程分割成一组单独的类。原因是，人们通常对偏微分方程的解本身不感兴趣，而是对它的某些方面感兴趣。例如，人们可能希望在弹性计算中计算某一边界的牵引力，或者在某一位置的接收器上计算地震波的信号。有时，人们可能对这些方面中的几个方面感兴趣。由于解的评估是通常不影响解的过程，我们把它拆成一个单独的模块，以便独立于解算器类的开发来开发这种评估过滤器。[2.x.21] 将实现网格细化的类与计算解的类分开。[2.x.22] 将我们要介绍的测试案例的描述与程序的其他部分分开。[2.x.23] 使用WorkStream设施对线性系统的装配进行并行化。这是在[2.x.24]"多处理器访问共享内存的并行计算 "文档模块中可以找到的广泛描述。该实现基本上遵循了 [2.x.25] 中已经描述的内容。[2.x.26]
*

*
* 该程序所做的事情并不新鲜。事实上，这更像是以前程序的变种，从以前的例子中拆解出各种部分和功能。读者应该关注的是它们在这个程序中的安排方式，也就是程序中用来实现所需数学方法的目标的软设计技术。然而，我们必须强调，软件设计在某种程度上也是一个主观问题：不同的人有不同的编程背景，对 "正确 "的编程风格有不同的看法；因此，这个程序只表达了作者认为有用的做法，如果你对所选择的方式感到不舒服，也不一定要采用这种风格来编写成功的数值软件。然而，它应该作为一个案例研究，以启发读者的想法来达到预期目的。
*

*
* 一旦你完成了这个程序，你会注意到它的结构已经有些复杂了。然而，它只有大约850行代码，没有注释。在真正的应用中，当然会有注释和类文件，这将使其达到1200行左右。然而，与上面列出的应用程序相比，这仍然是很小的，因为它们是20到25倍的规模。对于这么大的程序，从一开始就进行适当的设计是不可缺少的。否则，它将不得不在其生命中的某一时刻进行设计，一旦它变得过于庞大而无法管理。
*

*
* 尽管如此，上面列出的三个程序都经历了重大的修改，甚至是重写。例如，波浪程序，在它还非常小的时候，曾经被完全撕成碎片，只是为了以更多的模块化形式重新组装起来。那时，已经不可能在不影响代码旧部分的情况下增加功能了（代码的主要问题是数据流：在依赖时间的应用程序中，主要关注的是何时将数据存储到磁盘，何时再重新加载；如果这不是以一种有组织的方式进行的，那么你最终会发现数据释放得太早，加载得太晚，或者根本没有释放）。尽管本例程序借鉴了几年来的经验，但它在设计上肯定不是没有缺陷的，特别是可能不适合于目标不同的应用。它应该成为你以模块化方式编写自己的应用程序的灵感，以避免过于紧密耦合的代码所带来的陷阱。
*


*[1.x.25][1.x.26]



* 该程序实际上做什么甚至不是这个程序的重点，程序的结构更重要。然而，用几句话来描述就是：求解给定右手边的拉普拉斯方程，使其解为函数 [2.x.27] 。计算的目的是得到[2.x.28]点的解的值，并比较我们在两个细化标准下解决这个值的准确性，即全局细化和凯利等人的误差指标细化，我们在以前的例子中已经使用过。
*

*
* 像往常一样，结果将在本文件的相关章节中讨论。在这样做的时候，我们会发现一个关于两种细化标准的相对性能的略微令人恼火的观察。在以后的例子程序中，在这个程序的基础上，我们将开发一个不同的方法，希望它能比这里讨论的技术表现得更好。
*

*
* 现在，所有的理论和传闻背景都说了这么多。了解一个程序的最好方法是看它，所以它在这里。
*

* [1.x.27] [1.x.28]。
* 和所有的程序一样，我们从库中的包含文件列表开始，和往常一样，它们的标准顺序是[2.x.29] 。
*
* - [2.x.30]
*
* - [2.x.31]
*
* - [2.x.32]
*
* - [2.x.33]
*
* - [2.x.34]（因为这些类别中的每一个都大致建立在以前的基础上），然后是C++标准头文件。
*


* [1.x.29]
*
* 现在是C++标准头文件。



* [1.x.30]

* 最后一步和以前的所有程序一样。
*


* [1.x.31]
*
* [1.x.32] [1.x.33]。


*
*至于程序本身，我们首先定义了评估拉普拉斯方程解的类。事实上，它们可以评估每一种解，只要它是由一个[2.x.35]对象和一个解向量描述的。我们在这里首先定义它们，甚至在实际生成要评估的解的类之前，因为我们需要声明一个抽象的基类，以便解算器类可以引用。   
* 从抽象的角度来看，我们声明一个纯基类，它提供了一个评估算子（），它将对解进行评估（无论派生类如何考虑[2.x.36] ）。由于这是该基类的唯一真正的功能（除了一些记账机制），我们通常把这样一个只有[2.x.37]的类称为C++术语中的[2.x.38]，因为它的使用就像一个函数对象。   
* 这种函数类型的对象随后将被传递给求解器对象，后者将其应用于刚刚计算的解决方案。然后，评估对象可以从解决方案中提取他们喜欢的任何数量。将这些评估函数放入一个单独的类的层次结构的好处是，在设计上它们不能使用求解器对象的内部结构，因此独立于求解器工作方式的变化。此外，在不修改求解器类的情况下编写另一个评估类是很容易的，这就加快了编程速度（不能使用另一个类的内部结构也意味着你不必担心它们的问题
*
* - 评估器的编程通常是一个相当快的任务），以及编译（如果求解器和评估类放在不同的文件中：求解器只需要看到抽象基类的声明，因此在增加一个新的评估类或修改一个旧的评估类时不需要重新编译）。  与此相关的是，你可以在其他项目中重复使用评估类，解决不同的方程。   
* 为了提高代码在不同模块中的分离度，我们把评估类放到了一个自己的命名空间中。这使得在同一个程序中实际解决不同的方程更容易，通过从现有的构件组装它。这样做的原因是，用于类似目的的类往往具有相同的名称，尽管它们是在不同的背景下开发的。为了能够在一个程序中一起使用它们，有必要将它们放在不同的命名空间中。我们在这里就是这样做的。
*


* [1.x.34]

* 现在是评估类的抽象基类：它的主要目的是声明一个纯虚函数[2.x.39]，取一个[2.x.40]对象和解向量。为了能够只使用指向这个基类的指针，它还必须声明一个虚拟的析构器，但这个析构器什么也不做。除此之外，它只提供了一点簿记功能：由于我们通常想在后续的细化水平上评估解决方案，我们存储了当前细化周期的编号，并提供了一个函数来改变这个编号。
*


* [1.x.35]
*
* [1.x.36] [1.x.37]。


*
* 下一件事是实现实际的评估类。正如介绍中所指出的，我们想从解决方案中提取一个点值，所以第一个类在其[2.x.41]中做了这个。实际的点是通过构造函数给这个类的，还有一个表对象，它将把它的发现放入其中。     
* 如果我们不能依靠知道实际使用的有限元，那么找出一个任意点的有限元场的值是相当困难的，因为这样我们就不能，例如，在节点之间进行插值。因此，为了简单起见，我们在这里假设我们要评估场的点实际上是一个节点。如果在评估解决方案的过程中，我们发现我们在所有顶点上循环时没有遇到这个点，那么我们就必须抛出一个异常，以便向调用的函数发出信号，说明出了问题，而不是默默地忽略这个错误。     
* 在[2.x.42]的例子程序中，我们已经看到如何使用[2.x.43]的宏来声明这样一个异常类。我们在这里再次使用这一机制。     
* 由此可见，这个类的实际声明应该是很明显的。请注意，即使我们没有明确地列出一个析构器，编译器也会生成一个隐含的析构器，而且它和基类的析构器一样是虚拟的。
*


* [1.x.38]
*
* 至于定义，构造函数是微不足道的，只是获取数据并将其存储在对象本地的。
*


* [1.x.39]
*
* 现在是本类中主要感兴趣的函数，即点值的计算。
*


* [1.x.40]

* 首先分配一个变量，用来保存点值。用一个明显是假的值来初始化它，这样，如果我们不能把它设置成一个合理的值，我们就会马上注意到。这在像这个函数这样小的函数中可能没有必要，因为我们在这里可以很容易地看到所有可能的执行路径，但事实证明，这对更复杂的情况是有帮助的，所以我们在这里也采用了这个策略。
*


* [1.x.41]
*
* 然后循环所有的单元格和它们的所有顶点，并检查一个顶点是否与评估点匹配。如果是这样，则提取该点的值，设置一个标志表明我们已经找到了感兴趣的点，然后退出循环。
*


* [1.x.42]
*
* 为了从全局解决方案矢量中提取点值，挑选属于感兴趣的顶点的那个分量，在解决方案是矢量值的情况下，取其中的第一个分量。
*


* [1.x.43]
*
* 请注意，我们在这里做了一个假设，这个假设并不总是有效的，如果这是一个真正的应用的代码，而不是一个教程程序，那么应该在类的声明中记录下来：我们假设用于我们试图评估的解决方案的有限元实际上有与顶点相关的自由度。例如，这对于不连续元素来说是不成立的，因为形状函数的支持点恰好位于顶点，但不与顶点相关，而是与单元内部相关，因为与顶点相关就意味着那里的连续性。这对面向边缘的元素也不成立，等等。                 
* 理想情况下，我们会在函数开始时检查这一点，例如通过一个类似<code>Assert (dof_handler.get_fe().dofs_per_vertex [2.x.44] 0, ExcNotImplemented())</code>的语句，这应该能在异常被触发时很清楚地说明什么地方出现了问题。在这种情况下，我们省略了它（这的确是不好的风格），但是知道这一点在这里并没有什么坏处，因为如果我们要求它给我们顶点的DoF索引，如果没有的话，语句[2.x.45]就会失败。                 
* 我们再次强调，这种对允许的有限元的限制应该在类文件中说明。
*

*
* 由于我们找到了正确的点，我们现在设置相应的标志并退出最里面的循环。由于设置了标志，外循环也将被终止。
*


* [1.x.44]
*
* 最后，我们要确定我们确实已经找到了评估点，因为如果不是这样的话，我们就不能在那里给出一个合理的解的值，反正剩下的计算也是无用的。所以通过[2.x.47]程序中已经使用的[2.x.46]宏确保我们确实已经找到了这个点。如果不是这样，这个宏就会抛出一个作为第二个参数给它的类型的异常，但与直接的[2.x.48]语句相比，它在异常对象中填充了一组额外的信息，例如，产生异常的源文件和行号，以及失败的条件。如果你在你的主函数里有一个[2.x.49]子句（就像这个程序一样），你会捕捉到所有没有在中间某个地方捕捉到的、因而已经处理过的异常，这些额外的信息会帮助你找出发生了什么以及哪里出了问题。
*


* [1.x.45]

* 请注意，我们在其他例子程序中也使用了[2.x.50]宏。它与这里使用的[2.x.51]宏的不同之处在于，它只是中止程序，而不是抛出一个异常，而且它只在调试模式下这样做。它是用来检查作为参数传递给函数的向量大小的正确宏，等等。       
* 然而，这里的情况是不同的：我们是否找到了评估点，可能会随着细化的进行而改变（例如，如果点周围的四个单元被粗化掉了，那么在细化和粗化之后，这个点可能会消失）。这是在调试模式下无法预测的事情，但应该经常检查，在生产运行中也是如此。因此，这里使用了[2.x.52]宏。
*

*
* 现在，如果我们确定已经找到了评估点，我们可以把结果加入到结果表中。
*


* [1.x.46]
*
* [1.x.47] [1.x.48]。


*
* 一种不同的，也许略显古怪的[2.x.53]的解决方案是将其以图形格式输出到一个文件中。由于在评估函数中，我们得到了一个[2.x.54]对象和解的向量，我们就有了做这件事的所有需要，所以我们可以在评估类中做这件事。实际上这样做而不是把它放到计算解决方案的类中的原因是，这样我们有更多的灵活性：如果我们选择只输出它的某些方面，或者根本不输出它。在任何情况下，我们都不需要修改求解器类，我们只需要修改其中的一个模块，就可以构建这个程序了。如上所述，这种形式的封装可以帮助我们保持程序的每一部分相当简单，因为接口保持简单，不可能访问隐藏的数据。     
* 由于这个生成输出的类是从普通的[2.x.55]基类派生出来的，它的主要接口是[2.x.56]函数。此外，它有一个构造函数，接收一个字符串，该字符串将被用作文件名的基本部分，输出将被发送到该文件中（我们将用一个数字来增加它，表示细化周期的数目
*
*-基类有这些信息在手
*
* 构造函数还需要一个值，表示要求的格式，即我们将为哪个图形程序生成输出（然后我们也将从中生成我们写入的文件名的后缀）。     
* 关于输出格式，DataOutBase命名空间提供了一个枚举字段[2.x.57]，列出了所有支持的输出格式名称。在编写本程序时，支持的图形格式由枚举值[2.x.58]、[2.x.59]、[2.x.60]、[2.x.61]等表示，但这个列表肯定会随着时间而增加。现在，在该基类的各种函数中，你可以使用这种类型的值来获得关于这些图形格式的信息（例如每种格式的文件所使用的默认后缀），你可以调用一个通用的[2.x.62]函数，然后根据给它的第二个参数的值表示所需的输出格式，将其分支到我们在以前的例子中已经使用的[2.x.63]等函数。这种机制使得编写一个可扩展的程序变得很简单，它可以在运行时决定使用哪种输出格式，同时也使得编写程序的方式变得相当简单，它可以利用新实现的输出格式，而不需要改变应用程序。     
* 在这两个字段中，基本名称和输出格式描述符，构造函数取值并存储它们，以便以后被实际评估函数使用。
*


* [1.x.49]
*
* 按照上面的描述，生成实际输出的函数现在相对简单了。与以前的例子程序相比，唯一特别有趣的特点是使用了[2.x.64]函数，为给定格式的文件返回通常的后缀（例如，".eps "用于封装的postscript文件，".gnuplot "用于Gnuplot文件），以及带有第二个参数的通用[2.x.65]函数，根据作为第二个参数传递的格式描述符的值，内部分支到不同图形格式的实际输出函数。     
* 还要注意的是，我们必须在[2.x.66]前面加上前缀，才能访问依赖模板的基类的成员变量。这里的原因，以及在程序中进一步描述的原因，与[2.x.67]示例程序中描述的相同（在那里寻找[2.x.68]）。
*


* [1.x.50]
*
* [1.x.51] [1.x.52]。


*
* 在实际应用中，人们会在这里添加一个其他可能的评价类的列表，代表人们可能感兴趣的数量。对于这个例子来说，这些就足够了，所以我们关闭这个命名空间。
*


* [1.x.53]
*
* [1.x.54] [1.x.55]。


*
* 在定义了我们想知道的解决方案之后，我们现在应该关心如何获得它。我们将把所有我们需要的东西都打包到一个自己的命名空间中，原因和上面的评价差不多。   
* 由于我们在以前的例子中已经相当详细地讨论了拉普拉斯求解器，所以下面没有太多的新东西。相反，我们在很大程度上拆解了以前的例子，并以稍微不同的形式将它们放到这个例子程序中。因此，我们将主要讨论与以前的例子的不同之处。   
* 基本上，正如在介绍中已经说过的，这个例子中缺乏新的东西是故意的，因为它更多地是为了展示软件设计的实践，而不是数学。因此，下面解释的重点将更多地放在实际的实现上。
*


* [1.x.56]
*
* [1.x.57] [1.x.58]。


*
* 在定义拉普拉斯求解器时，我们首先声明了一个抽象的基类，它本身没有任何功能，只是接受并存储了一个指向三角形的指针，以便以后使用。     
* 这个基类非常通用，也可以用于任何其他静止问题。它提供了一些函数的声明，这些函数将在派生类中分别解决一个问题，用评估对象的列表对解决方案进行后处理，并细化网格。这些函数中没有一个是在基类中实际做事情的。     
* 由于缺乏实际功能，声明非常抽象的基类的编程风格类似于Smalltalk或Java程序中使用的风格，所有的类都是从完全抽象的类派生出来的[2.x.69]，甚至是数字表示。作者承认，他并不特别喜欢在C++中使用这种风格，因为它将风格置于理性之上。此外，它提倡对一切事物使用虚拟函数（例如，在Java中，所有的函数本身就是虚拟的），然而，这在许多应用中被证明是相当低效的，在这些应用中，函数往往只是访问数据，而不是进行计算，因此很快就会返回；这样，虚拟函数的开销就会很大。笔者的意见是，凡是至少有一部分实际实现的代码可以共享的地方，都应该有抽象的基类，从而将其分离到基类中。     
* 除了所有这些理论上的问题，我们这里还有一个很好的理由，这个理由在下面会让读者更加清楚。基本上，我们希望能够有一个不同的拉普拉斯求解器家族，这些求解器差异很大，以至于无法找到更大的通用功能子集。因此，我们只是声明了这样一个抽象的基类，在构造函数中获取一个指向三角形的指针，并从此存储它。由于这个三角剖分将在所有的计算中使用，我们必须确保这个三角剖分在最后使用之前是有效的。我们通过保留一个[2.x.70]到这个三角形的指针来做到这一点，正如[2.x.71]中所解释的。     
* 请注意，虽然指针本身被声明为常数（即在这个对象的整个生命周期中，指针都指向同一个对象），但它没有被声明为指向一个常数三角的指针。事实上，通过这种方式，我们允许派生类在[2.x.72]函数中细化或粗化三角结构。     
* 最后，我们有一个函数[2.x.73]只是驱动函数的一个工具，用来决定我们是否要继续进行网格细化。它返回当前模拟的自由度数量。
*


* [1.x.59]

* 那么仅有的两个非抽象函数的实现就相当无聊了。
*


* [1.x.60]
*
* [1.x.61] [1.x.62]。


*
* 下面是主类，它实现了组装线性系统的矩阵，求解它，并在解的基础上调用后处理器对象。它实现了基类中声明的 [2.x.74] 和 [2.x.75] 函数。然而，它并没有实现[2.x.76]方法，因为网格细化将在一些派生类中实现。     
* 它还声明了一个新的抽象虚函数，[2.x.77] ，这个函数需要在子类中被重载。原因是我们将实现两个不同的类，它们将实现不同的方法来组装右手边的向量。这个函数在以下情况下可能也很有趣：右手边不仅仅取决于一个连续函数，还取决于其他东西，例如另一个离散问题的解，等等。后者经常发生在非线性问题中。     
* 正如我们之前提到的，这一类的实际内容并不是新的，而是以前的例子中已经使用过的各种技术的混合。因此，我们将不对其进行详细讨论，而是请读者参考这些程序。     
* 基本上，用几句话来说，这个类的构造函数需要指向一个三角形、一个有限元和一个代表边界值的函数对象的指针。这些都被传递给基类的构造函数，或者被存储起来并在以后用于生成一个[2.x.78]对象。由于有限元和正交公式应该匹配，所以也会传递一个正交对象。     
* [2.x.79]为实际求解设置数据结构，调用函数来组装线性系统，并求解它。     
* [2.x.80]函数最后接收一个评估对象并将其应用于计算出的解决方案。     
* [2.x.81]函数最后实现了基类的纯虚拟函数。
*


* [1.x.63]
*
* 在这个类的保护部分，我们首先有一些成员变量，其用途在前面的例子中应该很清楚。
*


* [1.x.64]

* 然后我们声明一个抽象函数，它将被用来组装右手边的内容。正如上面所解释的，在各种情况下，这个动作的必要性有很大的不同，所以我们把它推迟到派生类。
*


* [1.x.65]
*
* 接下来，在私有部分，我们有一个小类，它代表了整个线性系统，即一个矩阵、一个右手边和一个解向量，以及应用于它的约束条件，比如那些由于悬挂节点而产生的约束条件。它的构造函数初始化了各种子对象，并且有一个函数实现了共轭梯度法作为求解器。
*


* [1.x.66]

* 最后，有一组函数将被用来组装实际的系统矩阵。这一组的主要函数[2.x.82]使用以下两个辅助函数，在多核系统上并行计算矩阵。这样做的机制与 [2.x.83] 示例程序相同，并遵循 [2.x.84] 中概述的 WorkStream 概念。主函数还调用了组装右手边的虚拟函数。
*


* [1.x.67]
*
* 现在是该类的构造函数。它没有做什么，只是存储了给定对象的指针，并生成了[2.x.85]对象，初始化了给定的三角形的指针。这将导致DoF处理程序存储该指针，但并没有生成一个有限元编号（我们只在[2.x.86]函数中要求这样做）。
*


* [1.x.68]
*
* 解构器很简单，它只是清除存储在DoF处理程序对象中的信息以释放内存。
*


* [1.x.69]
*
* 下一个函数是解决这个问题的主要工作：它用给这个对象的构造函数的有限元设置DoF处理程序对象，创建一个表示线性系统的对象（即矩阵、右手向量和解向量），调用函数来组装它，最后解决它。
*


* [1.x.70]
*
* 如上所述，[2.x.87]函数接收一个评估对象，并将其应用于计算的解决方案。这个函数可以被多次调用，对用户要求的每一个解的评估都要调用一次。
*


* [1.x.71]

* [2.x.88]的功能应该是不言自明的。



* [1.x.72]
*
* 下面的函数集合了矩阵和线性系统的右手边，要在每一步中求解。我们将在几个层面上并行地做事情。首先，请注意，我们需要组装矩阵和右手边。这些都是独立的操作，我们应该并行地进行这些操作。为此，我们使用[2.x.89]文档模块中讨论的 "任务 "概念。本质上，我们想说的是 "这里有一些需要处理的事情，只要有CPU核可用就去做"，然后再做其他事情，当我们需要第一个操作的结果时，就等待它的完成。在第二层，我们想使用与我们在[2.x.90]中已经使用过的完全相同的策略来组装矩阵，即WorkStream概念。     
* 虽然我们可以考虑在做另一件事的时候在后台组装右侧或组装矩阵，但我们将选择前一种方法，只是因为对[2.x.91]的调用比对[2.x.92]的调用及其许多参数要简单得多。在任何情况下，代码看起来像这样，以组装整个线性系统。
*


* [1.x.73]
*
* 上面的语法需要一些解释。[2.x.93]有多个版本，期望有不同的参数。在[2.x.94]中，我们使用了一个版本，它需要一对迭代器，一对指向具有非常具体参数列表的成员函数的指针，一个指向这些成员函数必须工作的对象的指针或引用，以及一个抓取和复制数据对象。这有点限制性，因为这样调用的成员函数的参数列表必须与[2.x.95]所期望的完全一致：本地装配函数需要接收一个迭代器、一个从头开始的对象和一个拷贝对象；而复制-本地-全球的函数需要接收的正是一个拷贝对象。但是，如果我们想要的东西稍微更通用一些呢？例如，在目前的程序中，copy-local-to-global函数需要知道将本地贡献写入哪个线性系统对象中，也就是说，它还必须接受一个[2.x.96]参数。这在使用成员函数指针的方法中是行不通的。       
* 幸运的是，C++提供了一条出路。这些被称为函数对象。从本质上讲，[2.x.97]想要做的不是调用成员函数。它想调用一些函数，这些函数在第一种情况下需要一个迭代器、一个从属对象和一个拷贝对象，而在第二种情况下需要一个拷贝对象。不管这些是成员函数、全局函数，还是其他什么，对WorkStream来说，真的不是很关心。因此，有一个第二版本的函数，它只接受函数对象
*
* - 具有 [2.x.98] 的对象，因此可以像函数一样被调用，不管它们真正代表什么。产生这种函数对象的典型方法是使用一个[1.x.74]，它用固定的值来包装函数调用，包括各个参数。所有属于外层函数签名的参数在lambda函数中被指定为常规的函数参数。固定值使用捕获列表（`[...]`）传递到lambda函数中。可以使用捕获默认值，也可以明确列出所有要绑定到lambda的变量。为了清楚起见，我们决定在这里省略捕获默认值，但是捕获列表同样可以是`[&]`，这意味着所有使用的变量都通过引用复制到lambda中。       
* 在这一点上，我们已经组装好了矩阵，并将其浓缩。右手边可能已经完全组装好了，也可能还没有，但是我们接下来想浓缩右手边的向量。我们只有在这个向量的组装完成后才能这样做，所以我们必须等待任务的完成；在计算机科学中，等待任务通常被称为 "加入 "任务，解释了我们下面调用的函数的名称。       
* 既然这个任务可能已经完成，也可能没有完成，既然我们可能要等待它完成，那么我们不妨试着把其他需要做的事情打包到这个空隙中。因此，在等待右手边的工作之前，我们首先插值了边界值。当然，另一种可能性是在一个单独的任务中也插值边界值，因为这样做与我们到目前为止在这个函数中所做的其他事情无关。请自由地找到正确的语法，为这个插值创建一个任务，并在这个函数的顶部启动它，同时装配右手边。(你会发现这稍微有点复杂，因为[2.x.99]有多个版本，所以简单地取地址[2.x.100]会产生一组重载函数，不能马上传递给[2.x.101]。
*
* - 你必须通过将地址表达式转换为一个函数指针类型来选择你想要的这个重载集合中的哪一个元素，这个函数指针类型是你想在任务中调用的函数版本所特有的）。)
*


* [1.x.75]
*
* 现在我们有了完整的线性系统，我们也可以处理边界值，这需要从矩阵和右手边消除。
*


* [1.x.76]
*
* 这组函数的后半部分是处理每个单元上的局部装配，并将局部贡献复制到全局矩阵对象中。这与 [2.x.102] 中描述的工作方式完全相同。
*


* [1.x.77]
*
* 现在是实现线性系统类中动作的函数。首先，构造函数将所有的数据元素初始化为正确的大小，并设置了一些额外的数据结构，例如由于悬空节点而产生的约束。由于设置悬空节点和找出矩阵的非零元素是独立的，所以我们以并行方式进行（如果库被配置为使用并发，至少是这样；否则，这些动作是按顺序执行的）。注意，我们只启动一个线程，并在主线程中做第二个动作。由于只生成了一个任务，我们在这里不使用[2.x.103]类，而是直接使用创建的一个任务对象来等待这个特定任务的退出。     
* 注意，占用[2.x.104]函数的地址有点麻烦，因为它实际上有三个，每个支持的空间维度都有一个。在C++中，获取重载函数的地址有些复杂，因为在这种情况下，操作符[2.x.105]返回的更像是一组值（所有具有该名称的函数的地址），然后选择正确的函数就是下一步了。如果上下文决定采取哪一个（例如通过分配给已知类型的函数指针），那么编译器可以自己做，但如果这组指针应作为一个采取模板的函数的参数，编译器可以选择所有的，而不偏向于一个。因此，我们必须向编译器说明我们想要哪一个；为此，我们可以使用cast，但为了更清楚，我们把它分配给一个具有正确类型的临时[2.x.106]（简称<code>pointer to make_hanging_node_constraints</code>），并使用这个指针代替。
*


* [1.x.78]
*
* 启动一个辅助任务，然后在主线程上继续进行
*


* [1.x.79]
*
* 等到边上的任务完成后再进一步
*


* [1.x.80]
*
* 最后初始化矩阵和右手边的向量
*


* [1.x.81]
*
* 这一类的第二个函数只是通过预设条件的共轭梯度法来解决线性系统。这在以前已经被广泛地讨论过了，所以我们不再赘述了。
*


* [1.x.82]
*
* [1.x.83] [1.x.84]。


*
* 在上一节中，我们实现了一个拉普拉斯求解器的基类，该基类缺乏组装右手边向量的功能，但是，由于那里解释的原因。现在我们实现了一个相应的类，它可以在问题的右手边以函数对象的形式给出的情况下做到这一点。     
* 这个类的动作和你在以前的例子中已经看到的差不多，所以简单解释一下就够了：构造函数和底层类的数据一样（它把所有的信息传递给底层类），除了一个表示问题的右边的函数对象。这个对象的指针被存储起来（同样作为[2.x.107]，以确保这个函数对象只要还被这个类使用就不会被删除）。     
* 这个类的唯一功能部分是[2.x.108]方法，它的作用与它的名字一样。
*


* [1.x.85]
*
* 这个类的构造函数基本上做了上面宣布的事情...
*


* [1.x.86]
*
* ... 和[2.x.109]函数一样。由于这在前面的几个例子程序中已经解释过了，我们就不多说了。
*


* [1.x.87]
*
* [1.x.88] [1.x.89]。


*
*到现在，除了[2.x.110]函数外，抽象基类的所有函数都已经实现了。我们现在将有两个类为[2.x.111]类实现这个函数，一个做全局细化，一个做局部细化的形式。     
* 第一个做全局细化的类相当简单：它的主函数只是调用[2.x.112]，它做所有的工作。     
* 注意，由于[2.x.113]类的基类是虚拟的，我们必须声明一个构造函数来初始化直接的基类和抽象的虚拟类。     
* 除了这个技术上的复杂问题外，这个类可能很简单，可以不做进一步的评论。
*


* [1.x.90]
*
* [1.x.91] [1.x.92]。


*
* 第二个实现细化策略的类使用了之前各种示例程序中使用的Kelly细化指标。由于这个指标已经在deal.II库中的一个类中实现了，这里没有什么可做的，只是调用计算指标的函数，然后用它来选择一些单元进行细化和粗化，并对网格进行相应的细化。     
* 同样，现在这应该是足够标准的，可以省略更多的注释。
*


* [1.x.93]
*
* [1.x.94] [1.x.95]。



* 由于这又是一个学术性的例子，我们想对精确解和计算解进行相互比较。为此，我们需要声明代表精确解的函数类（用于比较和Dirichlet边界值），以及一个表示方程右侧的类（这只是应用于我们想恢复的精确解的拉普拉斯算子）。   
* 对于这个例子，让我们选择函数[2.x.115]作为精确解。在超过两个维度的情况下，只需用[2.x.116]重复正弦系数，以此类推。鉴于此，从前面的例子来看，以下两类可能是直接的。
*


* [1.x.96]
*
* [1.x.97] [1.x.98]。


*
* 现在缺少的只是实际选择各种选项的功能，并在连续的更细的网格上运行模拟，以监测网格细化后的进展。   
* 我们在下面的函数中做到了这一点：它接收一个求解器对象和一个后处理（评估）对象的列表，并在间歇性的网格细化中运行它们。
*


* [1.x.99]
*
* 我们将给出一个我们目前正在计算的步骤的指示器，以便让用户知道一些事情仍在发生，并且程序没有处于无尽的循环中。这就是这个状态行的标题。
*


* [1.x.100]
*
* 然后启动一个循环，只有当自由度数大于20,000时才会终止（当然你可以改变这个限制，如果你需要更多的话
*
* - 或更少
*
* 准确度）。)
*


* [1.x.101]

* 然后给这个迭代的[2.x.117]指示。注意，[2.x.118]是需要的，以使文本真正出现在屏幕上，而不是只出现在一些缓冲区中，而这些缓冲区只有在我们下次发出端线时才会被刷新。
*


* [1.x.102]
*
* 现在在现在的网格上解决问题，并在其上运行评估器。迭代器进入列表的长类型名称有点烦人，但如果需要的话，可以用别名来缩短。
*


* [1.x.103]
*
* 现在检查是否需要更多的迭代，或者是否应该结束循环。
*


* [1.x.104]
*
* 最后结束我们显示状态报告的那一行。
*


* [1.x.105]
*
* 最后一个函数是接受一个求解器的名字（目前允许使用 "kelly "和 "global"），用一个粗略的网格（这里是无处不在的单位方格）和一个有限元对象（这里也是无处不在的双线性对象）创建一个求解器对象，并使用该求解器来要求在一连串的细化网格上解决问题。   
* 该函数还设置了两个评估函数，一个在点（0.5,0.5）处评估解决方案，另一个将解决方案写入文件。
*


* [1.x.106]
*
* 第一个小任务：告诉用户将发生什么。因此，写一个标题行，并在下面写上与第一个标题行相同长度的所有'-'字符的行。
*


* [1.x.107]

* 然后设置三角法、有限元等。
*


* [1.x.108]
*
* 创建一个由这个函数的参数指示的解算器对象。如果该名称不被识别，则抛出一个异常!各自的求解器对象被存储在一个[2.x.119]中，以避免使用后不得不删除指针。
*


* [1.x.109]
*
* 接下来创建一个表对象，其中将存储点（0.5,0.5）的数值解的值，并创建各自的评估对象。
*


* [1.x.110]

* 还会生成一个评估器，写出解决方案。
*


* [1.x.111]

* 拿出这两个评价对象并把它们放在一个列表中...
*


* [1.x.112]
*
* ......然后我们可以将其传递给在连续的细化网格上实际运行模拟的函数。
*


* [1.x.113]
*
* 当这一切完成后，写出点评估的结果。
*


* [1.x.114]
*
* 在所有的结果之后还有一个空行。
*


* [1.x.115]

* 关于主函数没有什么可说的。它沿用了以前所有例子中的模式，试图捕捉被抛出的异常，并在我们得到一些异常时尽可能多地显示信息。其余的都是不言自明的。
*


* [1.x.116]
* [1.x.117][1.x.118] 。



*

*这个方案的结果并不那么有趣
*
*毕竟它的目的不是为了演示一些新的数学思想，也不是为了演示如何用deal.II编程，而是为了使用我们在前面的例子中所开发的材料，形成一种演示以模块化和可扩展的方式建立现代有限元软件的方法。
*


* 尽管如此，我们当然要展示程序的结果。最感兴趣的是点值的计算，为此我们实现了相应的评估类。该程序的结果（即输出）看起来如下。
* [1.x.119]
*
*

* 这里令人惊讶的是，确切的数值是1.59491554...，而且计算这个解显然出奇的复杂，甚至只有百分之一的精度，尽管这个解是平滑的（事实上是无限常可微）。这种平滑性显示在程序生成的图形输出中，这里是粗略的网格和凯利细化指标的前9个细化步骤。
*

* [2.x.120]


*当我们已经在观看图片时，这是第八个网格，从上面看。
*

* [2.x.121]


* 然而，我们还没有完成对点值计算的评估。事实上，将两个精简标准的误差[2.x.122]绘制成图，可以得出以下结果。
*

* [2.x.123]



*

* [2.x.124]和[2.x.125]这幅图令人不安的是，自适应网格细化不仅没有像人们通常期望的那样比全局细化好，甚至明显更差，因为它的收敛是不规则的，在使用后续网格的值时阻止了所有的外推技术！另一方面，全局细化提供了一个完美的[2.x.126]或[2.x.127]收敛历史。另一方面，全局细化提供了一个完美的[2.x.126]或[2.x.127]收敛历史，并提供了各种机会，甚至可以通过外推法改善点值。因此，在这个例子中，全局网格细化必须被认为是优越的。这就更令人惊讶了，因为评估点不是在左边的某个地方，那里的网格是粗糙的，而是在右边，自适应细化也应该细化评估点周围的网格。
*

*
* 因此，我们以一个问题来结束对这个例子程序的讨论。
* <p align="center"> <strong> [2.x.128] 如果适应性不比全局细化好，那么它有什么问题？[2.x.129] </strong>
*


*

* [2.x.130] 在本例的最后进行练习。[2.x.131] 有一个简单的原因可以解释适应性网格解决方案的不良和不规则行为。通过观察每个步骤中评估点周围的网格，可以很容易地发现这个问题。
*
* 这方面的数据存在于程序的输出文件中。因此，一个练习是修改网格细化程序，使问题（一旦你注意到它）得以避免。第二个练习是检查结果是否比全局细化要好，如果是的话，是否能达到更好的收敛顺序(以自由度的数量计算)，或者只是通过一个更好的常数。
*

*
* ( [2.x.132] 对于没有耐心的人来说，非常简短的答案。[2.x.133]在误差较大的步骤中，网格在评估点是不规则的，也就是说，一些相邻的单元有悬空的节点；这破坏了一些超级近似的效果，而全局精炼的网格可以从中受益。答案2：这个快速黑客
* [1.x.120]
* 在执行细化之前，在Kelly细化类的细化函数中的这个快速黑客行为将改善结果（练习：代码做了什么？不过，行为仍然是不规则的，所以不可能有关于收敛顺序的结果)。
*

* [1.x.121][1.x.122] [2.x.134] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-14_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43]
*[1.x.44][1.x.45][1.x.46] 。


*[1.x.47][1.x.48] 。


* Rolf Rannacher教授的海德堡小组，deal.II库的三位初始作者在他们的博士期间属于该小组，后来也有部分人属于该小组，自1990年代中期以来一直从事有限元离散的适应性和误差估计工作。主要成就是开发了任意函数解的误差估计，以及用于其计算的最佳网格细化。
* 我们将不详细讨论这些概念的推导，而是在本例程序中实现其主要思想。对于一般概念的彻底介绍，我们可以参考Becker和Rannacher的开创性工作[2.x.2]、[2.x.3]，以及Acta Numerica[2.x.4]中同一作者的概述文章；前者介绍了拉普拉斯方程一般函数输出的误差估计和适应性的概念，后者则给出了这些概念在大量其他更复杂方程中应用的许多例子。关于个别类型方程的应用，也可参见贝克尔[2.x.5]、[2.x.6]、坎沙特[2.x.7]、[2.x.8]、苏特梅尔[2.x.9]的出版物。] , [2.x.10] , [2.x.11] , [2.x.12] , Bangerth [2.x.13] , [2.x.14] , [2.x.15] , [2.x.16] , 和 Hartmann [2.x.17] , [2.x.18] , [2.x.19] 。所有这些工作，从Becker和Rannacher的原始介绍到对特定方程的个别贡献，后来都在Bangerth和Rannacher的书中进行了总结，其中包括所有这些主题，见[2.x.20]。
*

* 其基本思想如下：在应用中，人们通常对解本身不感兴趣，而是对它的某些方面感兴趣。例如，在模拟流动问题时，人们可能想知道浸在流体中的物体的升力或阻力；我们想知道的是这个数量的最佳精度，而描述方程的其余解是否得到很好的解决并不是主要的兴趣。同样，在弹性方面，人们可能想知道某些点的应力值，以猜测关节的最大负荷值是否安全，比如说。或者，在辐射转移问题中，平均通量强度是有意义的。
* 在刚才列举的所有情况中，我们感兴趣的是解的函数[2.x.21]的评估，而不是各地的[2.x.22]的值。由于精确的解决方案[2.x.23]是不可用的，只有它的数字近似值[2.x.24]，所以问计算值[2.x.25]是否在精确值[2.x.26]的一定范围内是明智的，也就是说，我们希望约束与这个函数有关的误差，[2.x.27]。
* 为了简化论述，我们假设感兴趣的量[2.x.28]以及方程都是线性的，我们将特别展示具有同质狄里奇边界条件的拉普拉斯方程的推导，尽管这一概念更为普遍。对于这种一般情况，我们参考上面列出的参考文献。  我们的目标是获得误差的界限，[2.x.29] 。为此，让我们用[2.x.30]表示对偶问题的解，定义如下：[1.x.49]其中[2.x.31]是与微分方程相关的双线性形式，测试函数从相应的解空间中选择。然后，作为特殊的检验函数[2.x.32]的误差，我们有[1.x.50]，通过Galerkin正交性，我们可以将其改写为[1.x.51]，其中[2.x.33]可以以我们认为方便的方式从离散检验空间选择。
* 具体来说，对于拉普拉斯方程，误差标识为[1.x.52]，因为我们不仅要用这个公式来计算误差，还要细化网格，所以我们需要将上面的表达式改写为单元的总和，然后每个单元的贡献可以作为这个单元的误差指标。因此，我们将标量积分成每个单元的条款，并对每个条款进行分项积分：[1.x.53] 。
* 接下来，我们利用[2.x.34]，对于拉普拉斯方程的解，其解足够平滑，[2.x.35]几乎到处都是连续的。
*
* 因此，在单元格上涉及[2.x.36]的条款与相邻单元格上的条款相抵消，其中法向量具有相反的符号。(不过[2.x.37]的情况并非如此。)在域的边界，没有邻接单元可以抵消这个项，权重[2.x.38]可以选择为零，整个项就消失了。
* 因此，我们有[1.x.54]。
* 在最后一步，注意当取[2.x.39]的法向导数时，我们是指从单元格的这一边取的这个量的值（对于通常的拉格朗日元素，导数在边上是不连续的）。然后我们通过将[2.x.40]单元的一半边缘积分与相邻单元[2.x.41]交换来重写上述公式，得到[1.x.55] 。
* 对于相邻单元的法向量，我们有[2.x.42]，我们通过[1.x.56]定义法向导数的跳跃，并在将离散函数[2.x.43]（现在仍然是任意的）设定为对偶解的点插值后得到最终形式，[2.x.44] ：[1.x.57] 。
*
* 这样，我们就得到了关于任意（线性）函数的有限元离散化误差的精确表示 [2.x.45] 。它的结构是一个加权形式的残差估计，因为[2.x.46]和[2.x.47]都是在精确解上消失的单元和边缘残差，而[2.x.48]是表示某个单元上的残差对给定函数的评估有多重要的权重。此外，它是一个单元的量，所以我们可以把它作为一个网格细化的标准。问题是：如何评价它？毕竟，评估需要了解对偶解[2.x.49]，它带有我们想知道的最准确的量的信息。
* 在一些非常特殊的情况下，这个对偶解是已知的。例如，如果函数[2.x.50]是点评价，[2.x.51]，那么对偶解必须满足[1.x.58]，右边是狄拉克三角函数，而对偶解是关于点[2.x.52]的格林函数。对于简单的几何形状，这个函数是分析上已知的，我们可以把它插入到误差表示公式中。
* 然而，我们不想把自己限制在这种特殊情况下。相反，我们将以数值方式计算对偶解，并以某种数值方式获得的[2.x.54]近似[2.x.53]。我们注意到，使用与初解[2.x.56]相同的方法来计算这个近似值[2.x.55]是不够的，因为这样[2.x.57]和整体误差估计将是零。相反，近似值[2.x.58]必须来自比原始有限元空间更大的空间。有多种方法可以获得这样的近似值（见所引用的文献），我们将选择用高阶有限元空间来计算它。虽然这当然不是最有效的方法，但它很简单，因为我们已经有了所有需要做的事情，而且它还允许进行简单的实验。对于更有效的方法，请再次参考给定的文献，特别是 [2.x.59] , [2.x.60] 。
* 至此，我们结束了对这个程序的数学方面的讨论，转而讨论实际的实现。
*


* [2.x.61] 如果你只关心计算误差的话，上面有两个步骤似乎没有必要：即(i)从[2.x.63]中减去[2.x.62]，以及(ii)将积分拆成单元格之和并对每个单元格进行积分。事实上，这两个步骤根本没有改变[2.x.64]，因为在用[2.x.66]代替[2.x.65]之前，我们只考虑上述的相同点。换句话说，如果你只关心[1.x.59][2.x.67]，那么这些步骤是没有必要的。另一方面，如果你想将误差估计作为网格中每个单元的细化标准，那么就有必要(i)将估计值分解为单元的总和，(ii)以这样的方式按摩公式，使每个单元的贡献都与局部误差有关。(虽然上面的公式没有改变[1.x.60][2.x.68]的值，但它们改变了我们为每个单元[2.x.69]计算的值)。为此，我们希望以 "残差乘以双重权重 "的形式来写一切，其中 "残差 "是指随着近似度变得[2.x.70]越来越好而归于零的东西。例如，[2.x.71]这个量不是残差，因为它只是收敛于精确解的梯度（法向分量）。另一方面，[2.x.72]是一个残差，因为它收敛于[2.x.73] 。我们在开发[2.x.74]的最终形式时采取的所有步骤，实际上都是为了将最终形式变成一种形式，在离散解[2.x.75]收敛到[2.x.76]时，每个项都收敛为零。这样就可以把每个单元的贡献看作是一个 "误差指标"，也会收敛为零。
*
* - 因为它应该随着网格的细化而细化。
*


*[1.x.61][1.x.62]


* [2.x.77]示例程序在很大程度上建立在[2.x.78]程序中已经使用的技术之上。它对上面解释的双重加权残差估算器的实现是通过派生出第二个类，正确地称为[2.x.79]基类，并有一个类（[2.x.80]）将两者再次连接起来，控制原始和双重问题的解决，然后使用两者来计算网格细化的误差指示器。
* 该程序延续了前面例子中的模块化概念，通过一个抽象的基类来实现对偶函数，描述兴趣量，并提供两个不同的函数来实现这个接口。因此，增加一个不同的兴趣量是很简单的。
* 一个更根本的区别是对数据的处理。一个常见的情况是，你开发了一个解决某个方程的程序，然后用不同的右手边、不同的域、不同的系数和边界值等来测试它。通常，这些必须匹配，以便知道确切的解决方案，或者它们的组合是有意义的。
* 我们展示了一种可以通过简单而又非常灵活的方式来实现的方法。我们将把属于某个设置的所有东西放到一个类中，并围绕它提供一个小小的C++砂浆，这样整个设置（域、系数、右手边等）就可以通过改变[2.x.81]中的某个[2.x.82]地方来交换。
* 再往前走一点，我们还将所有描述程序如何工作的其他参数集中在一个地方，如有限元的顺序、最大自由度数、应在计算出的解上执行的评价对象，以及很快。这使得程序的配置更加简单，我们将在后面的程序中展示如何使用一个库类来处理通过读取输入文件来设置这些参数。总的来说，我们的目的是减少程序中想要改变某个参数时需要查找的地方，因为在实践中，人们会在程序成长的过程中忘记它们的位置。此外，把所有描述程序在某次运行中所做的事情的选项放到一个文件中（可以和结果一起存储），比在程序中的某个地方设置各种标志更有助于结果的重复性，因为在下次改变这个地方后，它们的确切数值就会被遗忘。
* 不幸的是，这个程序已经变得相当长了。虽然这无疑降低了它作为一个示例程序的作用，但我们认为它是开发其他类型问题程序的一个很好的起点，涉及到比这里处理的拉普拉斯方程不同的方程。此外，它显示了我们可以向你展示的关于我们的后验误差估计方法的一切，其结构应该使你能够简单地调整这种方法，以适应其他问题、其他函数、其他几何、系数等等。
* 作者认为，本程序是他在示例程序中的杰作，涉及到数学的复杂性，以及添加扩展的简单性。如果你使用这个程序作为你自己程序的基础，我们希望你能说明这一事实，并在由此产生的出版物中注明示例程序的作者Wolfgang Bangerth的名字，你的程序有相当一部分是由示例程序组成的。
*

* [1.x.63] [1.x.64]。
*从众所周知的事情开始......



* [1.x.65]

* 最后一步和以前的所有程序一样。
*


* [1.x.66]
*
* [1.x.67] [1.x.68]。


*
* 正如介绍中提到的，该程序的重要部分只是从[2.x.83]的例子程序中拿过来的。因此，我们只对那些新的东西进行评论。   
* 首先，评估解决方案的框架没有改变，也就是说，基类是相同的，评估网格点上的解决方案的类也没有改变。
*


* [1.x.69]
*
* [1.x.70] [1.x.71]。



* [1.x.72]
*
* [1.x.73] [1.x.74]。



* [1.x.75]
*
* [1.x.76] [1.x.77]。


*
* 除了实现在一个点上求解的类，我们在这里提供了一个在网格点上求梯度的类。由于一般来说，有限元函数的梯度在一个顶点上是不连续的，所以我们在这里要更小心一点。我们所做的是在所有单元中循环，即使我们已经在一个单元中找到了点，并使用所有相邻单元的顶点梯度的平均值。     
* 鉴于[2.x.84]类的接口，这个类的声明没有提供什么惊喜，构造函数也没有。
*


* [1.x.78]
*
* 更有趣的事情发生在进行实际评估的函数中。
*


* [1.x.79]
*
* 这一次用一些有用的东西来初始化返回值，因为我们将不得不把一些贡献加起来，之后再取平均值......
*


* [1.x.80]
*
* ......然后有一些对象，其含义将在下面变得清晰......
*


* [1.x.81]
*
* ......接下来在所有单元格及其顶点上循环，并计算顶点被发现的频率。
*


* [1.x.82]
*
* 现在事情不再那么简单了，因为我们不能像以前那样得到有限元场的梯度，我们只需要在一个顶点挑选一个自由度。               
* 相反，我们必须评估这个单元上的有限元场，而且是在某一点。如你所知，在某一点上评估有限元场是通过[2.x.85]类完成的，所以我们使用这个类。问题是：[2.x.86]对象需要给定一个正交公式，然后可以计算正交点的有限元量值。在这里，我们并不想做正交，我们只是想指定一些点!               
* 尽管如此，还是选择同样的方式：使用一个特殊的正交规则，点在顶点，因为这些是我们感兴趣的。适当的规则是梯形规则，所以这就是我们上面使用那个规则的原因。               
*这样：在这个单元上初始化[2.x.87]对象。
*


* [1.x.83]
*
* 并提取顶点的解向量梯度。
*


* [1.x.84]
*
* 现在我们有所有顶点的梯度，所以挑出属于评估点的那一个（注意顶点的顺序不一定和正交点的顺序一样）。
*


* [1.x.85]
*
* 检查是否确实找到了评估点。
*


* [1.x.86]
*
* 如果是这样，就把那里的梯度的X导数作为我们感兴趣的值，并增加计数器，表明我们向该变量添加了多少次。
*


* [1.x.87]
*
* 最后跳出最内层的循环，遍历当前单元格的顶点，因为如果我们在一个顶点找到了评估点，它不可能也在后面的顶点。
*


* [1.x.88]
*
* 现在我们已经循环了所有的单元格和顶点，所以检查是否找到了这个点。
*


* [1.x.89]
*
* 我们只是简单地将所有相邻单元的贡献相加，所以我们仍然要计算出平均值。一旦完成，报告状态。
*


* [1.x.90]
*
* [1.x.91] [1.x.92]。


*
* 因为这个程序有一个更困难的结构（它除了计算一个原始解之外，还计算了一个对偶解），所以写出解不再由一个评估对象来完成，因为我们想把两个解同时写进一个文件，这需要一些比评估类可用的信息。     
* 然而，我们也想看看生成的网格。这也可以通过一个这样的类来完成。它的结构类似于前面例子程序中的[2.x.88]类，所以我们在这里不做更详细的讨论。此外，这里所使用的一切都已经在以前的例子程序中使用过了。
*


* [1.x.93]
*
* [1.x.94] [1.x.95]。


*
* 接下来是实际的求解器类。同样，我们只讨论与之前程序的不同之处。
*


* [1.x.96]
*
* [1.x.97] [1.x.98]。


*
* 这个类几乎没有变化，只是多声明了两个函数。  [2.x.89]将用于从派生类计算的实际解决方案中生成输出文件，以及[2.x.90]函数，测试框架通过该函数将细化周期的编号设置为该类中的一个局部变量；该编号随后被用于生成解决方案输出的文件名。
*


* [1.x.99]
*
* [1.x.100] [1.x.101]。


*
* 同样，[2.x.91]类也完全没有变化，因此将不进行讨论。
*


* [1.x.102]
*
* 该类的其余部分基本上也是[2.x.92]的副本，包括使用WorkStream框架并行计算线性系统所需的数据结构和函数。
*


* [1.x.103]
*
* 以下几个函数和构造函数是逐字复制自 [2.x.93] 。
*


* [1.x.104]
*
* 现在是实现线性系统类中动作的函数。首先，构造函数将所有的数据元素初始化为正确的大小，并设置了一些额外的数据结构，例如由于悬空节点而产生的约束。由于设置悬空节点和找出矩阵的非零元素是独立的，所以我们以并行方式进行（如果库被配置为使用并发，至少是这样；否则，这些动作是按顺序执行的）。注意，我们只启动一个线程，并在主线程中做第二个动作。由于只生成了一个线程，所以我们在这里不使用[2.x.94]类，而是直接使用创建的一个任务对象来等待这个特定任务的退出。这个方法与我们在上面的[2.x.95]中使用的方法大致相同。     
* 注意，获取[2.x.96]函数的地址有点麻烦，因为实际上有三个这个名字的函数，每个支持的空间维度都有一个。在C++中，获取重载函数的地址有些复杂，因为在这种情况下，操作符[2.x.97]会返回一组值（所有具有该名称的函数的地址），然后选择正确的函数是下一步的事情。如果上下文决定采取哪一个（例如通过分配给一个已知类型的函数指针），那么编译器可以自己来做，但是如果这组指针应作为一个采取模板的函数的参数，编译器可以选择所有的，而不偏向于一个。因此，我们必须向编译器说明我们想要哪一个；为此，我们可以使用cast，但为了更清楚，我们把它分配给一个具有正确类型的临时[2.x.98]（简称<code>pointer to make_hanging_node_constraints</code>），并使用这个指针代替。
*


* [1.x.105]
*
* 启动一个辅助任务，然后在主线程上继续进行
*


* [1.x.106]
*
* 等到边上的任务完成后再进一步
*


* [1.x.107]
*
* [1.x.108] [1.x.109]。


*
* 除了实现[2.x.100]函数，[2.x.99]类也基本没有变化。我们在这个程序中保留了[2.x.101]类，然后它们可以依赖这个函数的默认实现，它只是输出原始解。实现双重加权误差估计的类将自行重载这个函数，以同时输出双重解。
*


* [1.x.110]
*
* [1.x.111] [1.x.112]。


*
* 对于以下两个班级，与上述大部分班级的情况相同：班级是按原样取自前面的例子。
*


* [1.x.113]
*
* [1.x.114] [1.x.115]。


*
* 这个类是前一个类的变种，它允许用一些函数来加权我们从库的Kelly指标中得到的细化指标。我们包括这个类，因为这个例子程序的目标是展示自动细化标准，即使是复杂的输出量，如点值或应力。如果我们不解决对偶问题并计算其中的权重，我们可能会倾向于给指标一个手工制作的权重，以说明我们要评估这些数量。这个类接受这样一个加权函数作为其构造函数的参数。
*


* [1.x.116]
*
* 现在，主要的功能来了，包括加权。
*


* [1.x.117]
*
* 首先通过库中已经实现的方法为所有单元计算一些基于残差的误差指标。我们在这里计算的具体内容在该类的文档中有更详细的描述。
*


* [1.x.118]
*
* 接下来用给构造函数的值来衡量指标向量中的每个条目，在单元格中心进行评估。我们需要将结果写入对应于当前单元的向量条目中，我们可以通过使用[2.x.102]询问单元在所有活动单元中的索引来获得这个结果（实际上，对于我们在循环中处理的第一个单元，这个索引是0，第二个单元是1，等等，我们也可以使用一个整数计数器来跟踪这个索引；但是使用[2.x.103]使之更加明确）。
*


* [1.x.119]
*
* [1.x.120] [1.x.121]。
* 在这个示例程序中，我们使用的数据集与前一个相同，但由于可能有人想用不同的边界值和右手函数或在不同的网格上运行程序，我们展示了一个简单的技术来做到这一点。为了更加清晰，我们进一步将所有与方程数据有关的东西都打包到一个自己的命名空间中。   
* 基本假设是这是一个研究项目，在那里我们经常有一些测试案例，由一个域、一个右手边、边界值、可能是一个指定的系数和一些其他参数组成。当从一个例子转移到另一个例子时，它们常常同时变化。使处理这种问题描述参数集变得简单是下面的目标。   
* 基本上，这个想法是这样的：让我们为每一组数据都有一个结构，在这个结构中，我们把描述一个测试案例的所有东西都打包：这里，这些是两个子类，一个叫[2.x.104]，用于精确解的边界值，一个叫[2.x.105] ，然后是生成粗网格的方法。由于前面的例子程序的解看起来像弯曲的山脊，所以我们在这里用这个名字来表示包围的类。请注意，两个内层类的名称对于所有包围的测试案例类必须是相同的，同时我们将维度模板参数附加到包围类而不是内层类，以使进一步的处理更简单。  从语言的角度来看，用命名空间来封装这些内部类会比用结构来封装更好。然而，命名空间不能作为模板参数给出，所以我们使用一个结构来允许第二个对象从其给定的参数中选择。当然，这个封闭的结构除了它所声明的类之外，没有任何成员变量，还有一个静态函数来生成粗略的网格；一般来说，它永远不会被实例化）。)   
* 这个想法是这样的（现在是时候也简单看看下面的代码了）：我们可以为边界值和右手边生成对象，只需将外层类的名字作为模板参数给一个类，我们在这里称之为[2.x.106]，然后它就为内部类创建对象。在这种情况下，为了获得所有描述弧形山脊解决方案的特征，我们将简单地生成一个[2.x.107]的实例，而我们需要知道的关于该解决方案的一切都将是该对象的静态成员变量和函数。   
* 在这种情况下，这种方法可能看起来是多余的，但是一旦某种设定不仅有迪里希特边界值和右手函数的特征，而且还有材料属性、诺伊曼值、不同的边界描述符等，就会变得非常方便。在这种情况下，[2.x.108]类可能由十几个对象组成，而每个描述符类（如下面的[2.x.109]类）都必须提供这些对象。然后，你会很高兴，只需在一个地方改变[2.x.110]类的模板参数，而不是在许多地方改变，就能从一组数据改变到另一组。   
* 有了这个不同测试案例的框架，我们就快完成了，但还有一件事：到现在，我们可以通过改变一个模板参数，静态地选择要选择的数据集。为了能够动态地做到这一点，也就是说，在运行时，我们需要一个基类。我们以明显的方式提供这个基类，见下文，用虚拟抽象函数。这迫使我们引入第二个模板参数[2.x.111]，我们需要这个基类（这可以通过一些模板魔法来避免，但我们省略），但这就是全部。   
* 添加新的测试用例现在很简单，你不需要接触框架类，只需要一个类似于[2.x.112]的结构。
*


* [1.x.122]
*
* [1.x.123] [1.x.124]。


*
* 基于上述描述，[2.x.113]类然后看起来如下。为了允许用这个类来使用[2.x.114]类，我们从[2.x.115]类派生出来。
*


* [1.x.125]
*
* 现在是派生类，按照上面的解释接受模板参数。     
* 这里我们把数据元素打包成私有变量，并允许通过基类的方法来访问它们。
*


* [1.x.126]

* 我们必须为上述类的静态成员变量提供定义。
*


* [1.x.127]

* 还有成员函数的定义。



* [1.x.128]
*
* [1.x.129] [1.x.130]。


*
* 用于描述[2.x.116]问题的边界值和右手边的类已经在[2.x.117]示例程序中使用，然后像这样。
*


* [1.x.131]
*
* [1.x.132] [1.x.133]。


*
* 这个例子程序是在为一个关于自适应有限元方法和基于对偶性的误差估计的讲座提供实践课程时写的。对于这些课程，我们有一个练习，要求在一个中心有方孔的正方形域上求解右方恒定的拉普拉斯方程，边界值为零。由于这个问题的属性在这里的实现特别简单，所以让我们来做。由于练习的编号是2.3，所以我们冒昧地把这个名字也保留下来，作为课的名称。
*


* [1.x.134]

* 我们需要一个类来表示问题的边界值。在这种情况下，这很简单：它是零函数，所以甚至不用声明一个类，只需要一个别名。
*


* [1.x.135]

* 第二，一个表示右手的类。因为它们是常数，所以只要把库中相应的类子类化就可以了。
*


* [1.x.136]
*
* 最后是一个生成粗略网格的函数。这在这里有些复杂，请看下面的内容。
*


* [1.x.137]
*
* 如上所述，本例的网格是正方形[-1,1]^2，其中的正方形[-1/2,1/2]^2为孔。我们将粗略的网格创建为4乘以4的单元，中间的四个单元缺失。要了解网格的具体样子，最简单的方法可能是先看一下本教程程序的 "结果 "部分。一般来说，如果你想了解更多关于创建网格的信息，无论是像我们在这里所做的那样从头开始，还是使用其他技术，你都应该看一下 [2.x.118] 。     
* 当然，这个例子可以扩展到三维，但由于这个函数不能以独立于维度的方式编写，我们选择不在这里实现它，而只是对dim=2的模板进行专业化处理。如果你编译3d的程序，你会从链接器中得到一个信息：这个函数没有在3d中实现，需要提供。     
* 对于这个几何体的创建，库中没有预定义的方法。在这种情况下，几何体还是很简单的，可以用手来创建，而不是用网格发生器。
*


* [1.x.138]

* 我们首先定义空间维度，以便让函数中那些实际上与维度无关的部分使用这个变量。如果你以后以这个为起点来实现这个网格的三维版本，那就更简单了。下一步是要有一个顶点的列表。这里，它们是24个（5乘以5，中间的省略）。最好的办法是在这里画一个草图。
*


* [1.x.139]
*
* 接下来，我们要定义单元格和它们所包含的顶点。
*


* [1.x.140]
*
* 再次，我们从中生成一个C++向量类型，但这次是通过在单元格上进行循环（是的，这很无聊）。此外，我们将所有单元格的材料指标设置为零。
*


* [1.x.141]
*
* 最后将所有这些信息传递给库，以生成一个三角形图。最后一个参数可以用来将三角形的某些面的非零边界指标的信息传递给库，但是我们在这里并不希望这样，所以我们给出一个空对象。
*


* [1.x.142]
*
* 因为我们希望本例中的评估点（3/4,3/4）是一个网格点，所以我们在全局上细化一次。
*


* [1.x.143]
*
* [1.x.144] [1.x.145].
* 你现在已经读完了这个框架，你可能会想，为什么我们没有选择直接把实现某种设置的类（比如[2.x.119]类）作为派生自[2.x.120]的类来实现。事实上，我们可以很好地这样做。唯一的原因是，这样我们就必须在[2.x.121]类中为解决方案和右手边的类设置成员变量，以及重载基类的抽象函数来访问这些成员变量的成员函数。[2.x.122]类的唯一原因是让我们不必再重申这些成员变量和函数，这些在所有这类中都是必要的。在某种程度上，这里的模板机制只是提供了一种方法，为一些依赖于外部量的函数提供默认的实现，因此不能使用正常的虚拟函数来提供，至少在没有模板的帮助下不能。   
* 然而，可能有很好的理由来实际实现从[2.x.123]派生的类，例如，如果解或右手边的类需要带参数的构造函数，而[2.x.124]类无法提供。在这种情况下，子类化是一个值得考虑的策略。对于特殊情况的其他可能性是派生自[2.x.125]，其中[2.x.126]表示一个类，甚至明确地专门化[2.x.127] 。后者允许透明地使用[2.x.128]类用于其他设置的方式，但对特殊参数采取特殊行动。   
* 赞成这里采取的方法的最后一个意见是：我们无数次发现，当开始一个项目时，参数的数量（通常是边界值，右侧，粗略的网格，就像这里一样）很小，测试案例的数量也很小。然后，人们一开始就把它们手工编码成一些[2.x.129]的语句。随着时间的推移，项目的增长，测试用例的数量也在增长。[2.x.130]语句的数量也随之增长，它们的长度也是如此，人们开始想办法考虑不可能的例子，其中域、边界值和右手边不再适合在一起，并且开始失去对整个结构的概述。事实证明，把属于某个测试用例的所有东西都封装到一个自己的结构中是值得的，因为它把属于一个测试用例的所有东西都放在一个地方。此外，它允许把这些东西都放在一个或多个文件中，这些文件只用于测试用例和它们的数据，而不需要把它们的实际实现与程序的其他部分联系起来。
*



*
* [1.x.146] [1.x.147]。



* 和程序的其他部分一样，我们把所有需要描述对偶函数的东西都放到一个自己的命名空间中，并定义一个抽象基类，提供解决对偶问题的类在工作中需要的接口。   
* 然后我们将实现两个这样的类，用于评估一个点的值和该点的解的导数。对于这些函数，我们已经有了相应的评估对象，所以它们是互补的。
*


* [1.x.148]
*
* [1.x.149] [1.x.150]。


*
* 首先从对偶函数的基类开始。因为对于线性问题来说，对偶问题的特征只在右手边起作用，所以我们只需要提供一个函数来组装给定离散化的右手边。
*


* [1.x.151]
*
* [1.x.152] [1.x.153]。


*
* 作为第一个应用，我们考虑对应于在一个给定的点上对解的值进行评估的函数，我们再次假设这个点是一个顶点。除了接受和存储评估点的构造函数之外，这个类只包括实现组装右手边的函数。
*


* [1.x.154]
*
* 至于做这门课的主要目的，组装右手边，让我们先考虑一下有什么必要。对偶问题的右手边是一个值的向量J(phi_i)，其中J是误差函数，phi_i是第i个形状函数。这里，J是在点x0处的评价，即J(phi_i)=phi_i(x0)。     
*现在，我们已经假定评价点是一个顶点。因此，对于我们在这个程序中可能使用的通常的有限元，我们可以想当然地认为在这样一个点上正好有一个形状函数是不为零的，特别是有一个值为1。因此，我们将右手边的向量设置为全零，然后寻找与该点相关的形状函数，并将右手边向量的相应值设置为1。
*


* [1.x.155]

* 所以，首先把所有东西都设为零......
*


* [1.x.156]
*
* ...然后在单元格上循环，在顶点中找到评估点（或者非常接近顶点，这可能是由于浮点舍入造成的）。
*


* [1.x.157]
*
* 好的，找到了，所以设置相应的条目，然后离开函数，因为我们已经完成了。
*


* [1.x.158]
*
* 最后，一个理智的检查：如果我们以某种方式来到这里，那么我们一定是错过了评估点，所以无条件地引发一个异常。
*


* [1.x.159]
*
* [1.x.160] [1.x.161]。


*
* 作为第二个应用，我们再次考虑在一个点上对解决方案的x-derivative进行评估。同样，这个类的声明和它的构造函数的实现也不是太有趣。
*


* [1.x.162]
*
* 有趣的是这个函数的实现：这里，J(phi_i)=d/dx phi_i(x0)。     
* 我们可以像实现各自的评价对象那样，在这个评价点上取每个形状函数phi_i的梯度的平均值。然而，我们采取了一个略微不同的方法：我们简单地取该点周围所有单元格的平均值。哪些单元[2.x.131]是评估点，这个问题取决于网格宽度，包括那些单元的中点到评估点的距离小于单元的直径的单元。     
* 在这些单元的面积/体积上取梯度的平均值，可以得到一个非常接近于梯度的点评估结果的二元解。从理论上讲，这并没有明显改变方法，这一点很容易证明。
*


* [1.x.163]

* 同样，首先将所有条目设置为零。
*


* [1.x.164]
*
* 用正交公式初始化一个[2.x.132]对象，有正交点数量和形状函数的缩写......
*


* [1.x.165]
*
* ...并有两个对象用于存储单元上自由度的全局指数，以及正交点上形状函数的梯度值。
*


* [1.x.166]
*
* 最后有一个变量，我们将通过对这些单元上的单位函数进行积分，总结出这些单元的面积/体积。
*


* [1.x.167]
*
* 然后在所有单元格上开始循环，并选择那些与评估点足够接近的单元格。
*


* [1.x.168]
*
* 如果我们找到了这样的单元，那么就初始化[2.x.133]对象，并整合每个形状函数梯度的x分量，以及总面积/体积的单位函数。
*


* [1.x.169]
*
* 如果我们有本地贡献，就把它们分配到全局矢量。
*


* [1.x.170]
*
* 在我们对所有的单元格进行循环之后，检查我们是否找到了任何单元格，确保它们的体积不为零。如果不是，那么结果将是错误的，因为这时的右手边应该仍然是零，所以抛出一个异常。
*


* [1.x.171]
*
* 最后，我们现在只对形状函数的梯度进行了积分，而没有取其平均值。我们通过除以我们所整合的体积的尺度来解决这个问题。
*


* [1.x.172]
*
* [1.x.173] [1.x.174]。



* [1.x.175]
*
* [1.x.176] [1.x.177]。


*
* 与上面的[2.x.134]类相同，我们现在实现一个[2.x.135] 。它具有所有相同的特征，唯一的区别是它不接受一个表示右侧对象的函数对象，而现在接受一个[2.x.136]对象，该对象将集合对偶问题的右侧向量。该类的其余部分是相当琐碎的。     
* 由于原始解算器和对偶解算器将使用相同的三角形，但不同的离散，现在很清楚为什么我们将[2.x.137]类变成了虚拟类：因为最终类将从[2.x.138]以及[2.x.139]实例中派生，我们是不是应该将继承标记为虚拟。因为在许多应用中，基类会存储更多的信息，而不仅仅是需要在原始和对偶求解器之间共享的三角关系，所以我们通常不希望使用两个这样的基类。
*


* [1.x.178]
*
* [1.x.179] [1.x.180]。



* 这里终于出现了这个程序的主类，也就是实现对偶加权残差误差估计器的类。它连接了原始和对偶求解器类，用于计算原始和对偶解，并实现了误差表示公式，用于误差估计和网格细化。     
* 这个类的前几个函数大多是对基类各自函数的覆盖。
*


* [1.x.181]
*
* 在私有部分，我们有两个函数，用来调用原始类和双基类的[2.x.140]函数。这两个函数将被本类的[2.x.141]函数并行调用。
*


* [1.x.182]
*
* 然后声明活动单元格迭代器的缩写，以避免我们不得不重复写这个冗长的名字。
*


*


* [1.x.183]
*
* 接下来，声明一个数据类型，我们将用它来存储面孔对误差估计器的贡献。我们的想法是，我们可以计算从两个单元格中的每一个到这个面的面项，因为从两边看时它们是一样的。我们要做的是，根据下面解释的一些规则，只计算一次，由相邻的两个单元负责计算。然后，我们将每个面的贡献存储在一个映射面与它们的值的地图中，并只通过在细胞上循环第二次并从地图上抓取值来收集每个细胞的贡献。       
* 这个地图的数据类型在此声明。
*


* [1.x.184]
*
* 在计算单元和面的误差估计时，我们需要一些辅助对象，如[2.x.142]和[2.x.143]函数，但也需要一些临时对象来存储原始和对偶解的值和梯度，例如。这些字段在三个函数中都是需要的，这些函数分别在单元格、规则面和不规则面上做积分。       
* 有三种合理的方式来提供这些字段：第一，作为需要它们的函数中的局部变量；第二，作为本类的成员变量；第三，作为参数传递给该函数。       
* 这三种替代方法都有缺点：第三种是它们的数量不可忽略，会使调用这些函数成为一项冗长的事业。第二种方法的缺点是不允许并行化，因为计算误差估计值的线程必须各自拥有这些变量的副本，所以包围类的成员变量将不起作用。第一种方法虽然直接，但有一个微妙但重要的缺点：我们会反复调用这些函数，也许是成千上万次；现在证明，从堆中分配向量和其他需要内存的对象在运行时间上是昂贵的，因为当涉及几个线程时，内存分配是昂贵的。因此，只分配一次内存，并尽可能频繁地回收这些对象，是明显更好的做法。       
* 该怎么做呢？我们的答案是使用第三种策略的一个变种。事实上，这正是WorkStream概念所要做的（我们已经在上面介绍了它，但也请看[2.x.144]）。为了避免我们必须给这些函数十几个参数，我们将所有这些变量打包成两个结构，一个用于单元格的计算，另一个用于面的计算。然后，这两个结构被加入到WeightedResidualScratchData类中，该类将作为WorkStream概念的 "划痕数据 "类。
*


* [1.x.185]
*
* [2.x.145]一般都希望有一个抓取对象和一个复制对象。在这里，由于与我们在[2.x.146]中讨论计算梯度的近似值时类似的原因，我们实际上不需要一个 "拷贝数据 "结构。既然WorkStream坚持要有一个这样的结构，我们就声明一个空的结构，除了存在之外什么都不做。
*


* [1.x.186]
*
* 关于误差估计器的评估，我们有一个驱动函数，使用[2.x.147]来调用每个单元格的第二个函数。
*


* [1.x.187]
*
* 然后我们有函数对误差表示公式进行实际积分。它们将分别处理单元内部、没有悬挂节点的面和有悬挂节点的面的条款。
*


* [1.x.188]
*
* 在这个类的实现中，我们首先有[2.x.148]成员类的构造函数，以及[2.x.149]构造函数。它们只将字段初始化为正确的长度，所以我们不必过多地讨论它们。
*


* [1.x.189]
*
* 接下来的五个函数是很无聊的，因为它们只是简单地把它们的工作转交给基类。第一个函数并行地调用原始和对偶求解器，而解的后处理和检索自由度的数量则由原始类完成。
*


* [1.x.190]
*
* 现在，它变得更加有趣了：[2.x.150]函数要求误差估计器计算单元格的误差指标，然后使用它们的绝对值进行网格细化。
*


* [1.x.191]
*
*首先调用计算单元格和全局误差的函数。
*


* [1.x.192]
*
* 然后注意，只有当所有的指标都是正数时，为细化或粗化做标记的单元格才起作用，以便于它们的比较。因此，去掉所有这些指标上的符号。
*


* [1.x.193]
*
* 最后，我们可以选择不同的细化策略。这里默认的是细化那些误差指标最大、占总误差80%的单元，而我们则粗化那些指标最小、占总误差2%的单元。
*


* [1.x.194]
*
* 由于我们想同时输出原始解和对偶解，我们重载了[2.x.151]函数。这个函数唯一有趣的特点是，原始解和对偶解是在不同的有限元空间上定义的，这不是[2.x.152]类所期望的格式。因此，我们必须将它们转移到一个共同的有限元空间。由于我们只想从质量上看到这些解，所以我们要争夺将对偶解内插到（较小的）原始空间。对于插值，有一个库函数，它接收一个包括悬挂节点约束的AffineConstraints对象。其余的都是标准的。
*


* [1.x.195]
*
* 添加我们想要输出的数据向量。把它们都加进去，[2.x.153]函数可以处理你想写到输出的多少个数据向量。
*


* [1.x.196]
*
* [1.x.197] [1.x.198]。



* [1.x.199] [1.x.200]。
* 至于误差估计的实际计算，让我们从驱动这一切的函数开始，即调用那些实际工作的函数，并最终收集结果。
*


* [1.x.201]
*
* 计算误差的第一个任务是设置向量，表示原始解，以及权重(z-z_h)=(z-I_hz)，两者都在我们已经计算出对偶解的有限元空间。为此，我们必须将原始解内插到对偶有限元空间，并将计算出的对偶解内插到原始有限元空间。幸运的是，库中提供了插值到更大或更小的有限元空间的函数，所以这一点是很明显的。       
* 首先，让我们为原始解做这件事：它被单元内插到我们已经解决了对偶问题的有限元空间中：但是，还是像[2.x.154]函数中那样，我们首先需要创建一个AffineConstraints对象，包括悬挂节点约束，但这次是对偶有限元空间。
*


* [1.x.202]

* 然后用于计算数值逼近的对偶解z插值到原始解的有限元空间并从z中减去：使用[2.x.155]函数，该函数在对偶解的元素空间中给出（z-I_hz）。
*


* [1.x.203]
*
* 请注意，这可能会更有效率，因为这些约束条件已经在之前为原始问题组装矩阵和右手边以及写出对偶解时使用过了。我们把这方面的程序优化作为一个练习。
*

*
* 在计算了对偶权重之后，我们现在开始计算原始解的单元和面的残差。首先，我们在面的迭代器和面的跳跃项对误差估计器的贡献之间建立一个映射。原因是我们只计算了一次跳跃项，从面的一侧开始，并且希望在第二次循环所有单元时才收集它们。       
* 我们已经用一个值来初始化这个地图，即
*
* e20，因为如果出了问题，我们因某种原因无法计算某个面的值，这个值会在结果中脱颖而出。其次，这个初始化已经使[2.x.156]对象分配了它可能需要的所有对象。这一点很重要，因为我们将从并行线程写进这个结构，如果地图需要分配内存，从而重塑其数据结构，那么这样做就不是线程安全的。换句话说，初始化使我们不必在线程每次写入（和修改）该地图的结构时通过互斥来同步。
*


* [1.x.204]
*
* 然后把它全部交给[2.x.157]，以平行地计算所有单元的估计值。
*


* [1.x.205]
*
* 一旦计算出误差贡献，就把它们加起来。对于这一点，请注意单元项已经设置好了，只需要收集边缘项。因此，在所有的单元和它们的面中循环，确保每个面的贡献都在那里，然后把它们加起来。只需要减去一半的跳跃项，因为另一半会被邻近的单元格拿走。
*


* [1.x.206]
*
* [1.x.207] [1.x.208]。


*
* 接下来我们有一个函数，它被调用来估计单个单元的误差。如果库被配置为使用多线程，该函数可以被多次调用。下面是它的内容。
*


* [1.x.209]
*
* 由于WorkStream的原因，估计_on_one_cell需要一个CopyData对象，即使它没有被使用。下一行对这个未使用的变量的警告保持沉默。
*


* [1.x.210]
*
*每个单元的第一个任务是计算这个单元的单元残差贡献，并把它们放入[2.x.158]变量中。
*


* [1.x.211]
*
* 在计算完单元项之后，转向面项。为此，在当前单元格的所有面上进行循环，看看是否需要对其进行计算。
*


* [1.x.212]

* 首先，如果这个面是边界的一部分，那么就没什么可做的。然而，为了在汇总单元格的面的贡献时使事情变得简单，我们把这个面输入对误差贡献为零的面的列表中。
*


* [1.x.213]
*
* 接下来，请注意，由于我们想在每个面上只计算一次跳跃项，尽管我们访问它两次（如果它不在边界），我们必须定义一些规则，由谁负责在一个面上计算。
* 首先，如果相邻的单元格与这个单元格在同一层次上，也就是说，既不进一步细化，也不进一步粗化，那么这个层次中索引较低的单元格就负责计算。换句话说：如果另一个单元的指数较低，那么就跳过这个面的工作。
*


* [1.x.214]
*
* 同样，我们总是从较粗的单元开始工作，如果这个单元和它的邻居在细化程度上有所不同。因此，如果相邻的单元比现在的单元细化程度低，那么就什么都不做，因为我们在访问粗略的单元时对子表面进行整合。
*


* [1.x.215]

* 现在我们知道，我们在这里负责，所以实际上是计算面的跳跃项。如果这个面是一个规则的面，即另一边的单元格既不比这个单元格粗也不比这个单元格细，那么就调用一个函数，如果另一边的单元格进一步细化，那么就用另一个函数。请注意，另一边的单元格更粗的情况不可能发生，因为我们在上面已经决定，当我们传递到另一个单元格时，我们会处理这种情况。
*


* [1.x.216]
*
* [1.x.217] [1.x.218]。


*
*至于误差贡献的实际计算，首先转向单元项。
*


* [1.x.219]
*
* 需要完成的任务是看了误差估计公式后似乎很自然的事情：首先得到单元残差的正交点上的数值解的右手边和拉普拉斯。
*


* [1.x.220]

* ......然后得到双重权重......
*


* [1.x.221]
*
* ...最后建立所有正交点的总和，并将其与当前单元格一起存储。
*


* [1.x.222]
*
* [1.x.223] [1.x.224]。


*
* 另一方面，误差估计的边缘项的计算并不那么简单。首先，我们必须区分有悬挂节点和无悬挂节点的面。因为它是简单的情况，我们首先考虑一个面上没有悬挂节点的情况（我们称之为 "常规 "情况）。
*


* [1.x.225]
*
* 第一步是获取本单元上有限元场的正交点的梯度值。为此，初始化[2.x.159]对象，对应于面的这一面，并使用该对象提取梯度。
*


* [1.x.226]
*
* 第二步是提取面的另一边的正交点上的有限元解的梯度，即从邻近的单元中提取。       
* 为此，在之前做一个理智的检查：确保邻居确实存在（是的，如果邻居不存在，我们就不应该来这里，但是在复杂的软件中会有bug，所以最好检查一下），如果不是这样就会出现错误。
*


* [1.x.227]
*
* 如果我们有了这个，那么我们需要找出相邻单元格的哪一个面，即[2.x.160]本单元格是本面后面的单元格的邻居。为此，有一个函数，我们将结果放入一个变量，名称为[2.x.161] 。
*


* [1.x.228]
*
* 然后为邻近的单元格定义一个缩写，在该单元格上初始化[2.x.162]对象，并提取该单元格上的梯度。
*


* [1.x.229]
*
* 现在我们有了这个单元和邻近单元的梯度，通过将梯度的跳跃与法向量相乘来计算跳跃的残差。
*


* [1.x.230]
*
* 接下来得到这个面的双重权重。
*


* [1.x.231]
*
* 最后，我们要计算跳跃残差、对偶权重和正交权重的总和，以得到这个面的结果。
*


* [1.x.232]
*
* 仔细检查该元素是否已经存在，是否已经被写入...
*


* [1.x.233]
*
* ...然后将计算值存储在指定的位置。请注意，存储的值并不包含错误表示中出现的因子1/2。原因是，如果我们在三角形的所有面上进行循环，这个项实际上没有这个因子，但只有当我们把它写成所有单元和每个单元的所有面的总和时才会出现；因此我们两次访问同一个面。我们通过使用这个因子来考虑到这一点
*
* - /2以后，当我们对每个单元的贡献进行单独求和时，就会考虑到这一点。
*


* [1.x.234]
*
* [1.x.235] [1.x.236]。



* 我们仍然缺少有悬空节点的面的情况。这就是这个函数中所涉及的内容。
*


* [1.x.237]
*
* 首先还是两个缩写，以及一些一致性检查，以确定该函数是否只在它应该被调用的面上被调用。
*


* [1.x.238]

* 然后找出本单元是相邻单元的哪个邻居。注意，我们将对这个相邻单元的子女进行操作，但他们的方向与他们的母亲相同，也就是说，邻居的方向是相同的。
*


* [1.x.239]
*
* 然后简单地做我们在前面的函数中为一个面所做的一切，现在为所有的子面。
*


* [1.x.240]
*
* 再从一些检查开始：得到一个指向当前子面后面的单元格的迭代器，并检查其面是否是我们所考虑的子面。如果不是这样，那么上面调用的[2.x.163]函数就会有错误，或者是
*
* - 更糟糕
*


*
* - 库中的某些函数没有遵守关于单元格、它们的孩子和它们的面的一些基本假设。在任何情况下，尽管这个断言不应该被触发，但谨慎一点也无妨，在优化模式的计算中，这个断言还是会被删除。
*


* [1.x.241]
*
* 现在开始工作，首先在界面的这一侧再次得到解决方案的梯度。
*


* [1.x.242]
*
*然后在另一边。
*


* [1.x.243]
*
*，最后建立跳跃残差。由于这次我们从另一个单元格中取法向量，所以与另一个函数相比，还原了第一项的符号。
*


* [1.x.244]

* 然后得到双重权重。
*


* [1.x.245]

* 最后，总结这个子面的贡献，并将其设置在全局图中。
*


* [1.x.246]
*
* 一旦所有子面的贡献被计算出来，就循环收集所有子面，并将它们与母面一起存储起来，以便以后收集单元格的误差项时简单使用。再次进行安全检查，确保子面的条目已经被计算出来，并且不带有无效的值。
*


* [1.x.247]
*
* 最后将该值与父脸一起存储。
*


* [1.x.248]
*
* [1.x.249] [1.x.250]。


*
* 在前面的例子程序中，我们有两个函数，用来驱动在随后的更细的网格上求解的过程。我们在这里进行了扩展，允许向这些函数传递一些参数，并将这些参数全部放入框架类。   
* 你会注意到，这个程序是由许多小部分组成的（评估函数、实现各种细化方法的求解器类、不同的对偶函数、不同的问题和数据描述），这使得程序的扩展相对简单，但也允许通过用一个部分替换另一个部分来解决大量不同的问题。我们通过在下面的框架类中声明一个结构来反映这种灵活性，该结构持有一些参数，可以设置这些参数来测试这个程序的各个部分的组合，并且可以用简单的方法在各种问题和离散度上进行测试。
*


* [1.x.251]
*
* 首先，我们声明两个缩写，用于简单使用各自的数据类型。
*


* [1.x.252]

* 然后我们有一个结构，它声明了所有可能被设置的参数。在该结构的默认构造函数中，这些值都被设置为默认值，以供简单使用。
*


* [1.x.253]
*
* 首先，允许输入分片多项式的度数，原始问题和对偶问题将被离散化。对于原始问题，它们默认为（双，三）线性分解函数，对于对偶问题，默认为（双，三）二次函数。如果选择了一个不需要解决对偶问题的细化准则，对偶有限元度的值当然会被忽略。
*


* [1.x.254]
*
* 然后有一个描述问题类型的对象，即右手边、领域、边界值等。这里需要的指针默认为Null指针，也就是说，你必须在这个对象的实际实例中设置它，才能使它发挥作用。
*


* [1.x.255]
*
* 因为我们允许使用不同的细化标准（全局细化，通过凯利误差指标细化，可能有一个权重，以及使用对偶估计器），定义一些枚举值，并随后定义一个该类型的变量。它将默认为[2.x.164] 。
*


* [1.x.256]
*
* 接下来是一个描述双重函数的对象。只有在选择双重加权残差细化时才需要它，并且默认为一个空指针。
*


* [1.x.257]

* 然后是一个评价对象的列表。其默认值为空，即没有评价对象。
*


* [1.x.258]
*
* 接下来是一个函数，它被用作[2.x.165]类的权重。这个指针的默认值是零，但是如果你想使用[2.x.166]细化标准，你必须把它设置为其他的值。
*


* [1.x.259]

* 最后，我们有一个变量，表示我们允许（原始）离散化的最大自由度数。如果超过这个数值，我们将停止解算和间歇性的网格细化过程。其默认值为20,000。
*


* [1.x.260]
*
* 最后是这个类的默认构造函数。
*


* [1.x.261]
*
* 驱动程序框架类只有一个方法，它断断续续地调用求解器和网格细化，并在中间做一些其他的小任务。由于它不需要除了给它的参数之外的数据，我们把它变成静态的。
*


* [1.x.262]
*
* 至于实现，首先是参数对象的构造函数，将所有的值设置为默认值。
*


* [1.x.263]
*
* 然后是驱动整个过程的函数。
*


* [1.x.264]
*
*首先从给定的数据对象中创建一个三角测量。
*


* [1.x.265]

*然后是一组有限元和适当的正交公式。
*


* [1.x.266]
*
* 接下来，从实现不同细化标准的类中选择一个。
*


* [1.x.267]
*
* 现在所有的对象都到位了，运行主循环。停止的标准在循环的底部实现。     
* 在这个循环中，首先设置新的循环数，然后解决问题，输出它的解，对它应用评估对象，然后决定我们是否要进一步细化网格并在这个网格上再次求解，或者跳出循环。
*


* [1.x.268]
*
* 循环运行后清理屏幕。
*


* [1.x.269]
*
* [1.x.270] [1.x.271]。


*
* 最后是主函数。它通过指定一组用于模拟的参数（多项式度数、评估和对偶函数等）来驱动整个过程，并将它们打包成一个结构传递给上面的框架工作类。
*


* [1.x.272]
*
* 在这里描述一下我们要解决的问题，将一个描述符对象传递给做其他工作的函数。
*


* [1.x.273]
*
* 首先设置我们希望使用的细化标准。
*


* [1.x.274]
*
* 这里，我们也可以使用[2.x.167]或[2.x.168] 。请注意，所给出的关于对偶有限元、对偶函数等信息只对给定的细化准则选择很重要，否则就会被忽略。
*

*
* 然后设置原始问题和对偶问题的多项式度数。我们在这里选择双线性和双二次方的。
*


* [1.x.275]

* 然后设置测试案例的描述，即域、边界值和右手边。这些都是预先打包在类中的。我们在这里采取 [2.x.169] 的描述，但你也可以使用 [2.x.170] 。
*


* [1.x.276]
*
* 接下来首先设置一个二元函数，然后是一个评价对象的列表。我们默认选择在一个评价点上对数值进行评价，由评价和二元函数类命名空间中的[2.x.171]类代表。你也可以设置[2.x.172]类来代替评价点的值的x-derivative。       
* 请注意，双功能和评价对象应该匹配。然而，你可以给你想要的评价函数，所以你可以在每一步之后让点值和导数都得到评价。  一个这样的附加评价是在每一步中输出网格。
*


* [1.x.277]
*
* 设置最大的自由度数，之后我们希望程序停止进一步细化网格。
*


* [1.x.278]
*
* 最后将描述符对象传递给一个函数，用它来运行整个解决方案。
*


* [1.x.279]
*
* 捕获异常以提供有关失败的信息。
*


* [1.x.280]
* [1.x.281][1.x.282] 。


*[1.x.283][1.x.284] 。



* 这个程序提供了大量的可能性来玩。因此，我们只能展示所有可能的结果中的一小部分，在这个程序的帮助下可以获得。然而，我们鼓励你通过改变主程序中的设置来尝试。在这里，我们先简单地让它运行，不做任何修改。
* [1.x.285]

*

*首先让我们看看这个程序的实际计算结果。在第七个网格上，原始和双重数值解看起来是这样的（使用的颜色方案旨在唤起科罗拉多州白雪皑皑的山峰，这个程序的原作者现在称它为家）。[2.x.173]显然，左下角的区域对于右上角的点值评估是如此不重要，以至于网格在那里完全没有被细化，尽管解决方案在该单元的内角有奇异点由于右手边和领域的对称性，解决方案实际上应该像右上角的所有四个角一样，但是涉及到对偶解决方案的网格细化标准选择了不同的细化方式
*
* - 因为我们说过，我们真正关心的只是右上方某处的一个函数值。
*

*
* 下面是一些在细化周期0,2,4（顶行）和5,7,8（底行）产生的网格。
* [2.x.174]
* 注意解决角部奇异点和解决评估点周围的微妙的相互作用。手工生成这样的网格将是相当困难的，因为这将涉及到定量地判断四个角奇点中的哪一个应该被解决，并设置与评估点附近的权重。
*

*
*程序打印出这个数量的点值和估计误差。通过推断，我们可以猜测精确的数值是接近0.0334473，正负0.0000001（注意，我们从只有22000（原始）自由度中得到几乎6个有效数字。这个数字不能单独从函数的值中得到，但我使用了一个假设，即误差估计器大部分是精确的，并将计算值与估计的误差进行推算，以得到真实值的近似值。用更多自由度的计算表明，这个假设确实是有效的。
*

*
* 从计算结果中，我们可以生成两个图表：一个显示点值中误差[2.x.175]（将外推值视为正确）的收敛性，以及我们将计算值[2.x.176]和估计误差eta相加得到的值（如果误差估计器[2.x.177]是精确的，那么值[2.x.178]将等于精确的点值，这个量的误差将始终为零；但是，由于误差估计器只是一个
*
* - 好
*
* - 对真实误差的近似值，我们只能通过这个方法来减少误差的大小）。)在这张图中，我们还指出了复杂度[2.x.179]，以表明在这种情况下，网格细化器是最优的。第二张图比较了真实误差和估计误差，显示两者实际上非常接近，即使对于点值这样一个复杂的量。
*

* [2.x.180]


*[1.x.286][1.x.287]


*
* 由于我们在使用由对偶加权误差估计器驱动的网格细化时接受了相当多的努力（用于解决对偶问题，以及评估误差表示），因此值得询问这种努力是否成功。为此，我们首先比较了不同网格细化标准下的误差水平。要产生这些数据，只需改变主程序中网格细化准则变量的值。结果如下（对于Kelly指标中的权重，我们选择了函数[2.x.181]，其中[2.x.182]是到评估点的距离；可以证明，如果我们忽略边界的影响，这是最佳的权重）。
* [2.x.183]
*

*
* 检查这些数字，我们看到对于全局细化，误差与[2.x.184]成正比，而对于双重估计器[2.x.185]。一般来说，我们看到双重加权误差估计器比其他细化指标更好，至少在与那些具有类似规则行为的指标相比时是如此。凯利指标产生的误差较小，但在画面上的跳动相当不规则，误差的符号有时也会改变。因此，它的行为不允许将结果外推到更大的N值。此外，如果信任双重加权误差估计器的误差估计，可以通过将估计的误差加入计算值来改进结果。就可靠性而言，加权估计器因此比凯利指标更好，尽管后者有时会产生更小的误差。
*


*[1.x.288][1.x.289]


*
* 除了评估某一点上的解的值之外，该程序还提供了评估某一点上的X-导数的可能性，并且还可以为此定制网格细化。要让程序计算这些数量，只需将主函数中出现的两个[2.x.186]替换为[2.x.187]，然后让程序运行。
* [1.x.290]
*
*

*
* 解决方案看起来与以前大致相同（确切的解决方案当然是[2.x.188]是[2.x.189]相同，只是网格发生了一些变化），但现在的双解是不同的。评估点周围的特写显示了这一点。[2.x.190] 这一次，细化周期0、5、6、7、8和9的网格看起来像这样。
* [2.x.191]
* 注意与我们在点评估中获得的网格相比，这些网格是不对称的。这是由于域和初解可能是围绕对角线对称的，但[2.x.192]的导数不是，后者进入了细化准则。
*

*
* 然后，将感兴趣的数量的实际计算值（即解决方案在某一点上的X衍生物）与一个参考值进行比较是很有趣的。
*
* - .0528223...正负0.0000005。我们通过在更细的网格上计算得到这个参考值，大约有13万个单元。回顾一下，如果在最佳情况下，误差是[2.x.193]，采用多十倍的单元网格，我们的结果就多了一个数字。
*

*
*在下图的左边部分，你再次看到了误差向这个外推值的收敛，而在右边你看到了真实和估计误差的比较。
* [2.x.194]
* 在初始阶段，真实误差改变了它的符号，估计误差再次与它相当匹配。还请注意，当使用估计误差来修正[2.x.195]的计算值时，误差有了很大的改善。
*


*[1.x.291][1.x.292]。


*
* 如果我们不选择[2.x.196]的数据集，而是在主函数中选择[2.x.197]，并选择[2.x.198]作为评估点，那么我们就可以重新进行前面例子程序的计算，以比较在双重加权误差估计器的帮助下获得的结果是否比我们之前的结果更好。
*

*
* 首先，经过9个自适应细化周期后，分别用点评估和导数评估细化标准得到的网格，看起来像这样。
* [2.x.199]
* 在网格中仍然可以看到解的特征，但是由于解是光滑的，对偶解的奇异性完全支配了网格细化准则，并导致强烈集中的网格。第七次细化步骤后的解看起来像下面这样。
* [2.x.200]
* 显然，在某些地方的解更差，但是网格细化过程中应该注意到这些地方对计算点值并不重要。
*


*

* 下一步是将新的（基于二元性的）网格细化标准与旧的进行比较。这些是结果。
* [2.x.201]
*

*
* 结果是，嗯，有点混合。首先，Kelly指示器因其不稳定的行为而不合格，多次改变了误差的符号，并且在网格细化下的误差越来越大。双重加权误差估计器的误差呈单调下降，比加权凯利和全局精简要好，但幅度没有预期的那么大。这是因为全局细化可以利用评估点周围网格的规则结构，这导致了点误差的更好收敛顺序。然而，如果我们的网格不是局部矩形的，例如因为我们必须接近弯曲的边界，或者如果系数不是恒定的，那么全局细化网格的这种优势就会消失，而基于对偶性的估计器的良好性能就会保持。
*


*

*[1.x.293][1.x.294] 。


*
* 这里的结果并没有太清楚地表明加权误差估计方法在网格细化方面比其他网格细化标准（如Kelly指标）的优越性。这是由于所显示的应用相对简单。如果你还不相信这种方法确实有优势，请你浏览一下引言中提到的文献，其中提供了大量的例子，双加权方法可以将必要的数值工作减少几个数量级，使之成为计算某些数量的合理精度的唯一方法。
*

*
* 除了你可能提出的反对其作为网格细化标准的反对意见外，考虑到对一个人可能想要计算的量的误差的准确认识是非常有用的，因为我们可以在对精度满意时停止计算。使用更传统的方法，很难得到任意量的精确估计，也许除了能量规范的误差，我们将不能保证我们计算的结果满足对其精度的任何要求。另外，正如对点值和导数的评价所显示的那样，误差估计可以用来推断结果，从而在我们想知道的数量上产生更高的精度。
*

*
* 抛开这些数学上的考虑，我们试图以模块化的方式来编写程序，这样，实现另一个测试案例，或另一个评估和双重功能就很简单。我们鼓励你把这个程序作为你自己实验的基础，并稍加发挥。
*

* [1.x.295][1.x.296] [2.x.202] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-15_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30]
* [2.x.2]
*[1.x.31] [2.x.3] 。


*[1.x.32][1.x.33][1.x.34]


*[1.x.35][1.x.36]


* 这个程序涉及一个非线性椭圆偏微分方程的例子，即[最小表面方程](https://en.wikipedia.org/wiki/Minimal_surface)。你可以想象这个方程的解描述一个肥皂膜所跨越的表面，这个肥皂膜被一个封闭的线环所包围。我们想象一下，这根线不仅仅是一个平面的环，而且是弯曲的。肥皂膜的表面张力将使该表面变成最小表面。最小表面方程的解描述了这种形状，并以金属丝的垂直位移为边界条件。为了简单起见，我们在这里假设曲面可以写成图形[2.x.4]，尽管很明显，要构造出钢丝弯曲的情况并不难，因为在这种情况下，曲面只能局部地被构造成图形，而不能整体地被构造成图形。
* 因为这个方程是非线性的，我们不能直接解决它。相反，我们必须使用牛顿的方法来迭代计算解决方案。
* [2.x.5] ( [2.x.6] )
*


*[1.x.37][1.x.38]


*在经典的意义上，该问题以下列形式给出。
*


* [1.x.39]
*
* [2.x.7]是我们通过将导线的位置投射到[2.x.8]空间得到的域。在这个例子中，我们选择[2.x.9]作为单位盘。
* 如上所述，我们用牛顿方法解决这个方程，我们从[2.x.11]个近似解中计算出[2.x.10]个近似解，并使用阻尼参数[2.x.12]来获得更好的全局收敛行为。
* [1.x.40]
* 用[1.x.41]和[2.x.13]的F的导数在[2.x.14]的方向：[1.x.42] 。
* 通过运动找出[2.x.15]是什么，我们发现我们必须在每一个牛顿步骤中解决一个线性椭圆PDE，[2.x.16]是以下的解。
* [1.x.43]
* 为了解决最小表面方程，我们必须重复解决这个方程，每个牛顿步骤一次。要解决这个问题，我们必须看一下这个问题的边界条件。假设[2.x.17]已经有了正确的边界值，那么牛顿更新[2.x.18]应该有零边界条件，以便在添加两者之后有正确的边界条件。  在第一个牛顿步骤中，我们从解[2.x.19]开始，牛顿更新仍然需要向解[2.x.20]提供正确的边界条件。
*

* 总而言之，我们必须在第一步用边界条件[2.x.21]来解决上面的PDE，在接下来的所有步骤中用[2.x.22]来解决。
* [2.x.23] 在某种意义上，人们可能会说，如果程序已经实现了[2.x.24]，那么还必须实现[2.x.25]就是重复的。像往常一样，重复会诱发错误，我们希望能避免它。虽然我们没有在这个程序中探讨这个问题，但我们会在下面的[1.x.44]部分的末尾再来讨论这个问题，特别是在[2.x.26]中。
*

*[1.x.45][1.x.46]


* 从上面的强公式开始，我们通过将PDE的两边都乘以一个检验函数[2.x.27]并对两边进行部分积分，得到弱公式。  [1.x.47]这里的解[2.x.28]是[2.x.29]中的一个函数，受制于上面讨论的边界条件。把这个空间缩小到一个有基数[2.x.30]的有限维空间，我们可以写出这个解。
* [1.x.48]
* 使用基函数作为测试函数并定义[2.x.31]，我们可以重写弱的公式。
* [1.x.49]
* 其中解[2.x.32]是由系数[2.x.33]给出的。这个线性方程组可以改写为： * [1.x.50] 。
* [1.x.50]
* 其中矩阵[2.x.34]的条目由以下方式给出。
* [1.x.51]
* 右手边[2.x.35]由以下内容给出。
* [1.x.52]


*[1.x.53][1.x.54]


* 与上述牛顿步骤相对应的矩阵可以被重新表述，以更好地显示其结构。稍微改写一下，我们可以得到它的形式[1.x.55]，其中矩阵[2.x.36]（在[2.x.38]空间维度上大小为[2.x.37]）由以下表达式给出：[1.x.56另一方面，[2.x.41]也是正定的，这使[2.x.42]具有相同的属性。这可以通过注意到向量[2.x.43]是[2.x.44]的特征向量，其特征值为[2.x.45]，而所有与[2.x.47]垂直的向量[2.x.46]和彼此都是特征向量，其特征值为[2.x.48]。因为所有的特征值都是正的，所以[2.x.49]是正定的，[2.x.50]也是。因此，我们可以使用CG方法来解决牛顿步骤。（矩阵[2.x.51]是对称和正定的这一事实不应该让人惊讶。它来自于对一个算子的导数，而这个算子又来自于对一个能量函数的导数：最小表面方程只是最小化了一些非二次能量。因此，作为标量能量的二阶导数矩阵，牛顿矩阵必须是对称的，因为与[2.x.52]th和[2.x.53]th自由度有关的导数显然应该相减。同样，如果能量函数是凸的，那么第二导数的矩阵必须是正定的，上面的直接计算只是重申了这一点。)
* 然而，值得注意的是，在[2.x.54]变大的问题中，正定性会退化。换句话说，如果我们简单地将所有边界值乘以2，那么一阶[2.x.55]和[2.x.56]也将被乘以2，但结果是[2.x.57]的最小特征值会变小，矩阵会变得更加不稳定。更具体地说，对于[2.x.58]，我们有[2.x.59]而[2.x.60]；因此，[2.x.61]的条件数，也就是[2.x.62]的条件数的一个乘法因子，会像[2.x.63]一样增长）。用目前的程序可以很简单地验证，将目前程序中使用的边界值乘以越来越大的数值，会导致问题最终无法用我们这里使用的简单预设条件的CG方法解决。
*

*[1.x.57][1.x.58]


* 如上所述，牛顿方法是通过计算一个方向[2.x.64]，然后以步长[2.x.66]进行更新[2.x.65]。一般来说，对于强非线性模型，如果我们总是选择[2.x.67]，牛顿方法就不会收敛，除非我们从足够接近非线性问题的解[2.x.69]的初始猜测[2.x.68]开始。在实践中，我们并不总是有这样的初始猜测，因此采取完整的牛顿步骤（即使用[2.x.70]）往往是不可行的。
* 因此，一个常见的策略是，当迭代[2.x.71]离解[2.x.72]还很远时，在前几步使用较小的步长，随着我们的接近，使用较大的[2.x.73]值，直到我们最终可以开始使用全步[2.x.74]，因为我们已经足够接近解。当然，问题是如何选择[2.x.75]。基本上有两种广泛使用的方法：线条搜索法和信任区域法。
* 在这个程序中，我们简单地选择步长等于0.1。这确保了在手头的测试案例中，我们确实得到了收敛，尽管很明显，由于没有最终恢复到全步长，我们放弃了使牛顿方法如此吸引人的快速、二次收敛。显然，如果这个程序是为了解决更多的现实问题，那么这一点最终是必须解决的。我们将在[1.x.59]中进一步评论这个问题，并在[2.x.76]中使用一个更好的方法。
*

*[1.x.60][1.x.61]


* 总的来说，我们这里的程序在许多方面与[2.x.77]并无不同。主类的布局本质上是相同的。另一方面，[2.x.78]函数中的驱动算法是不同的，其工作方式如下。[2.x.79] [2.x.80] 从函数[2.x.81]开始，以这样的方式修改它，使[2.x.82]的值沿边界等于正确的边界值[2.x.83]（这发生在[2.x.84]）。设[2.x.85] .[2.x.86]
* [2.x.87] 通过在[2.x.90]上解决带有边界条件[2.x.89]的系统[2.x.88]来计算牛顿更新。[2.x.91]
* [2.x.92] 计算一个步长 [2.x.93] 。在这个程序中，我们总是设置 [2.x.94] 。为了便于以后的扩展，这发生在一个自己的函数中，即在 [2.x.95] 中。 (总是选择 [2.x.96] 的策略当然不是最优的)
*
* - 我们应该选择一个适用于给定搜索方向的步长
*
* - 但要做到这一点需要做一些工作。最后，我们把这类事情留给外部软件包。  [2.x.97]就是这样做的）。)[2.x.98]
* [2.x.99] 解决方案的新近似值由 [2.x.100] 给出。[2.x.101]
* [2.x.102] 如果[2.x.103]是5的倍数，那么细化网格，将解[2.x.104]转移到新的网格中，并设置[2.x.105]的值，以便沿边界有[2.x.106]（同样在[2.x.107]）。请注意，这并不是自动保证的，即使在网格细化之前我们就已经有了[2.x.108]，因为网格细化会在网格中增加新的节点，当我们把旧的解决方案带到新的网格时，必须把旧的解决方案插值到新的节点。我们通过插值选择的数值可能接近于精确的边界条件，但一般来说，并不是正确的数值。[2.x.109]
* [2.x.110] 设置[2.x.111]并转到第二步。[2.x.112] [2.x.113].
* 我们解决的测试案例选择如下。我们寻求在单位盘[2.x.114]上找到最小曲面的解决方案，其中该曲面沿边界达到[2.x.115]的值。
*

* [1.x.62] [1.x.63]。
* [1.x.64] [1.x.65]。


*
* 前面的几个文件已经在前面的例子中涉及到了，因此将不再进一步评论。
*


* [1.x.66]
*
* 我们将在牛顿迭代之间使用自适应网格细化。要做到这一点，我们需要能够在新的网格上使用解决方案，尽管它是在旧的网格上计算出来的。SolutionTransfer类将解决方案从旧网格转移到新网格。
*


*


* [1.x.67]
*
* 然后我们为这个程序打开一个命名空间，并将dealii命名空间的所有东西导入其中，就像以前的程序一样。
*


* [1.x.68]
*
* [1.x.69] [1.x.70]。


*
* 该类模板与 [2.x.116] 中的基本相同。  增加了三个内容。
*


*
* - 有两个解决方案向量，一个用于牛顿更新 [2.x.117] ，另一个用于当前迭代 [2.x.118] 。
*


*
* - [2.x.119]函数需要一个参数，表示这是否是第一次调用它。不同的是，第一次我们需要分配自由度并将[2.x.120]的解向量设置为正确的大小。在接下来的时间里，这个函数是在我们已经完成了这些步骤，作为细化网格的一部分之后被调用的 [2.x.121] 。
*


*
* - 然后我们还需要新的函数。  [2.x.122]负责正确设置解向量的边界值，正如在介绍的最后所讨论的。  [2.x.123]是一个计算非线性（离散）残差准则的函数。我们用这个函数来监测牛顿迭代的收敛性。该函数以步长[2.x.124]为参数来计算[2.x.125]的残差。这是人们通常需要的步长控制，尽管我们在这里不会使用这个功能。最后，[2.x.126]计算每个牛顿迭代中的步长[2.x.127]。正如介绍中所讨论的，我们在这里使用一个固定的步长，并把实现一个更好的策略作为一个练习。( [2.x.128]的做法不同。它只是在整个求解过程中使用了一个外部软件包，而一个好的线搜索策略是该软件包提供的一部分)。
*


*


* [1.x.71]
*
* [1.x.72] [1.x.73]。


*
* 边界条件的实现与 [2.x.129] 中一样。  它被选择为 [2.x.130] 。
*


*


* [1.x.74]
*
* [1.x.75] [1.x.76]。



* [1.x.77] [1.x.78]。


*
*类的构造函数和析构函数与前几个教程中的相同。
*


*


* [1.x.79]
*
* [1.x.80] [1.x.81]。


*
* 在setup-system函数中，我们总是设置有限元方法的变量。与[2.x.131]有相同的区别，因为在那里我们在每个细化周期中都要从头开始求解PDE，而在这里我们需要将前一个网格的解放到当前的网格中。因此，我们不能只是重置解向量。因此，传递给这个函数的参数表明我们是否可以分布自由度（加上计算约束）并将解向量设置为零，或者这在其他地方已经发生过了（具体来说，在[2.x.132]）。
*


*


* [1.x.82]
*
* 该函数的其余部分与 [2.x.133] 中的相同。
*


*


* [1.x.83]
*
* [1.x.84] [1.x.85]。


*
* 这个函数的作用与前面的教程相同，当然，现在的矩阵和右手边的函数取决于前面迭代的解。正如在介绍中所讨论的，我们需要对牛顿更新使用零边界值；我们在这个函数的结尾处计算它们。   
* 该函数的顶部包含通常的模板代码，设置允许我们在正交点评估形状函数的对象，以及本地矩阵和向量的临时存储位置，以及在正交点的上一个解的梯度。然后，我们开始在所有单元中进行循环。
*


* [1.x.86]
*
* 对于线性系统的组装，我们必须在正交点上获得先前解的梯度值。有一个标准的方法：[2.x.134]函数接收一个代表定义在DoFHandler上的有限元场的向量，并评估这个场在FEValues对象最后被重新初始化的单元的正交点的梯度。然后将所有正交点的梯度值写入第二个参数中。
*


* [1.x.87]
*
* 有了这个，我们就可以对所有的正交点和形状函数进行积分循环。  在刚刚计算了正交点上旧解的梯度之后，我们就可以计算这些点上的系数[2.x.135]。  然后，系统本身的组装看起来与我们一贯的做法相似，除了非线性项之外，将结果从局部对象复制到全局对象中也是如此。
*


* [1.x.88]
*
* 最后，我们从系统中移除悬挂的节点，并将零边界值应用于定义牛顿更新的线性系统 [2.x.136] 。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。


*
* 求解函数和以往一样。在求解过程结束时，我们通过设置[2.x.137]更新当前的解决方案。
*


* [1.x.92]
*
* [1.x.93] [1.x.94]。


*
* 这个函数的第一部分与[2.x.138]中的相同 ...然而，在细化网格之后，我们必须将旧的解决方案转移到新的解决方案上，这一点我们要借助于SolutionTransfer类来完成。这个过程稍微有点复杂，所以让我们详细描述一下。
*


* [1.x.95]
*
* 那么我们就需要一个额外的步骤：比如说，如果你标记了一个比它的邻居多精炼一次的单元，而这个邻居没有被标记为精炼，那么我们就会在一个单元界面上出现两个精炼级别的跳跃。  为了避免这些情况，库将默默地也要对邻居单元进行一次细化。它通过在实际进行细化和粗化之前调用[2.x.139]函数来实现。  这个函数标志着一组额外的单元格进行细化或粗化，以执行像单悬节点规则这样的规则。  调用此函数后，被标记为细化和粗化的单元格正是那些将被实际细化或粗化的单元格。通常情况下，你不需要用手去做这件事[2.x.140]为你做这件事)。然而，我们需要初始化SolutionTransfer类，它需要知道最终将被粗化或细化的单元集，以便存储旧网格的数据并转移到新网格。因此，我们用手调用这个函数。
*


* [1.x.96]
*
* 有了这些，我们用现在的DoFHandler初始化一个SolutionTransfer对象，并将解决方案向量附加到它上面，然后在新的网格上进行实际的细化和自由度的分配
*


* [1.x.97]
*
* 最后，我们找回插值到新网格的旧解。由于SolutionTransfer函数实际上并不存储旧的解决方案的值，而是索引，我们需要保留旧的解决方案向量，直到我们得到新的内插值。因此，我们将新的数值写入一个临时的向量中，之后才将其写入解决方案向量对象中。
*


* [1.x.98]
*
* 在新的网格上，有不同的悬空节点，我们必须在丢弃对象以前的内容后，重新计算约束。为了安全起见，我们还应该确保当前解决方案的向量条目满足悬挂节点的约束条件（关于为什么要这样做，请看SolutionTransfer类文档中的讨论）。我们可以通过明确地调用`hanging_node_constraints.distribution(current_solution)`来做到这一点；我们省略这一步，因为这将在下面调用`set_boundary_values()`的最后发生，而且没有必要做两次。
*


* [1.x.99]
*
* 一旦我们有了内插的解决方案和所有关于悬挂节点的信息，我们必须确保我们现在拥有的[2.x.141]实际上具有正确的边界值。正如在介绍的最后所解释的那样，即使细化前的解具有正确的边界值，也不会自动出现这种情况，因此我们必须明确地确保它现在具有。
*


* [1.x.100]
*
* 我们通过更新所有剩余的数据结构来结束这个函数，向[2.x.142]表明这不是第一次了，它需要保留解向量的内容。
*


* [1.x.101]
*
* [1.x.102] [1.x.103]。


*
* 下一个函数确保解向量的条目尊重我们问题的边界值。  在细化网格后（或者刚刚开始计算），边界上可能会出现新的节点。这些节点的数值是在`refine_mesh()`中从之前的网格中简单插值出来的，而不是正确的边界值。这种情况可以通过将当前求解向量的所有边界节点明确设置为正确的值来解决。   
* 但有一个问题我们必须注意：如果我们有一个悬挂的节点紧挨着一个新的边界节点，那么它的值也必须被调整以确保有限元场保持连续。这就是这个函数最后一行的调用所做的。
*


* [1.x.104]
*
* [1.x.105] [1.x.106]。


*
* 为了监测收敛性，我们需要一种方法来计算（离散）残差的规范，即介绍中讨论的向量[2.x.143]与[2.x.144]的规范。事实证明，（尽管我们在当前版本的程序中没有使用这个功能）在确定最佳步长时需要计算残差[2.x.145]，因此这就是我们在这里实现的：该函数将步长[2.x.146]作为一个参数。原有的功能当然是通过传递一个零作为参数来获得。   
* 在下面的函数中，我们首先为残差设置一个向量，然后为评估点设置一个向量 [2.x.147] 。接下来是我们用于所有积分操作的模板代码。
*


* [1.x.107]
*
* 实际的计算与[2.x.148]中的差不多。我们首先评估[2.x.149]在正交点的梯度，然后计算系数[2.x.150]，然后将其全部插入残差公式中。
*


* [1.x.108]
*
* 在这个函数的最后，我们还必须处理悬挂节点的约束和边界值的问题。关于后者，我们必须将所有对应于位于边界的自由度的条目的残差向量元素设置为零。原因是，由于那里的解的值是固定的，它们当然不是 "真正的 "自由度，因此，严格来说，我们不应该在残差向量中为它们集合条目。然而，正如我们一直所做的那样，我们想在每个单元上做完全相同的事情，因此我们并不想在上面的积分中处理某个自由度是否位于边界的问题。相反，我们将简单地在事后将这些条目设置为零。为此，我们需要确定哪些自由度实际上属于边界，然后在所有这些自由度上进行循环，并将剩余条目设置为零。这发生在以下几行中，我们已经在[2.x.151]中看到了使用DoFTools命名空间的适当函数。
*


* [1.x.109]
*
* 在函数的最后，我们返回残差的规范。
*


* [1.x.110]
*
* [1.x.111] [1.x.112]。


*
* 正如介绍中所讨论的，如果我们总是采取全步，即计算[2.x.152]，牛顿方法经常不收敛。相反，我们需要一个阻尼参数（步长） [2.x.153] 并设置 [2.x.154] 。这个函数就是用来计算 [2.x.155] 的。   
* 在这里，我们干脆总是返回0.1。这当然是一个次优的选择：理想情况下，人们希望的是，当我们越来越接近解决方案时，步长变为1，这样我们就可以享受牛顿方法的快速二次收敛。我们将在下面的结果部分讨论更好的策略，[2.x.156]也涉及这方面的内容。
*


* [1.x.113]
*
* [1.x.114] [1.x.115]。


*
* 从`run()`调用的最后一个函数以图形形式输出当前的解决方案（和牛顿更新），作为VTU文件。它与以前的教程中所使用的完全相同。
*


* [1.x.116]
*
* [1.x.117] [1.x.118]。


*
* 在运行函数中，我们建立第一个网格，然后有牛顿迭代的顶层逻辑。   
* 正如介绍中所描述的，领域是围绕原点的单位盘，创建方式与[2.x.157]中所示相同。网格被全局细化了两次，后来又进行了几次自适应循环。   
* 在开始牛顿循环之前，我们还需要做一些设置工作。我们需要创建基本的数据结构，并确保第一个牛顿迭代已经有了正确的边界值，这在介绍中已经讨论过了。
*


* [1.x.119]
*
* 接下来开始牛顿迭代。我们一直迭代到上一次迭代结束时计算的残差（准则）小于[2.x.158]，正如在 "do { ...} while "循环的末尾进行检查。因为我们没有一个合理的值来初始化这个变量，我们只是使用可以表示为 "双数 "的最大值。
*


* [1.x.120]
*
* 在每个网格上，我们正好做五个牛顿步骤。我们在这里打印初始残差，然后在这个网格上开始迭代。         
* 在每一个牛顿步骤中，首先要计算系统矩阵和右手边，然后我们存储右手边的准则作为残差，以便在决定是否停止迭代时进行检查。然后我们求解线性系统（该函数也会更新[2.x.159]），并在这个牛顿步骤结束时输出残差的准则。         
* 在这个循环结束后，我们还以图形的形式输出当前网格上的解，并增加网格细化循环的计数器。
*


* [1.x.121]
*
* [1.x.122] [1.x.123]。


*
* 最后是主函数。这遵循了所有其他主函数的方案。
*


* [1.x.124]
*[1.x.125][1.x.126]



* 程序的输出看起来如下。
* [1.x.127]
*
* 很明显，这个方案收敛了，即使不是非常快。我们将在下面讨论加速该方法的策略。
* 我们可以在每一组五次牛顿迭代之后，即在每一个我们对其进行近似的网格上，将解决方案可视化。这就产生了以下一组图像。
* [2.x.160]
* 可以清楚地看到，每次细化后的解决方案都能使曲面最小化。解决方案收敛到一个想象中的肥皂泡，它位于一个像边界一样弯曲的线环内。同样可以看出，每次细化后的边界是如何被平滑的。在粗略的网格上，边界看起来并不像正弦，而网格越细越像。
* 网格主要是在边界附近被细化，在那里解的增减很强烈，而在域的内部被粗化，在那里没有什么有趣的事情发生，因为解没有什么变化。这里显示的是第九种解决方案和网格。
* [2.x.161]
*


* [1.x.128][1.x.129][1.x.130] 。


* 该程序显示了一个非线性静止问题的求解器的基本结构。然而，它的收敛速度并不特别快，原因很简单。
*
* 该程序总是采取0.1的步长。这就排除了快速的二次收敛，而牛顿方法通常都是选择这种方法。
*
* - 它没有将非线性迭代与网格细化迭代联系起来。
* 显然，一个更好的程序必须解决这两点。我们将在下文中讨论它们。
*

*[1.x.131][1.x.132]


* 牛顿方法有两个众所周知的特性。
*
* - 它不可能从任意选择的起点收敛。相反，一个起始点必须足够接近解决方案，以保证收敛。然而，我们可以通过使用[1.x.133] 0< [2.x.162] 的阻尼迭代来扩大牛顿方法的收敛区域。
*
* - 如果(i)步长选择为[2.x.163]，它表现出快速的二次收敛，并且(ii)事实上它在选择步长时确实收敛了。
* 这两个观察的结果是，一个成功的策略是在初始迭代中选择[2.x.164]，直到迭代足够接近，可以用全步长收敛，在这一点上，我们希望切换到[2.x.165] 。问题是如何以自动的方式选择[2.x.166]，以满足这些标准。
* 我们不想在这里回顾关于这个主题的文献，只是简单地提到有两种基本的方法来解决这个问题：回溯线搜索和信任区域方法。前者更广泛地用于部分微分方程，基本上做了以下工作。
*
* - 计算一个搜索方向
*
* - 看看[2.x.167]与[2.x.168]产生的残差是否比[2.x.169]单独产生的残差 "大大缩小"。
*
* - 如果是，则取[2.x.170]。
*
* - 如果不是，试试用[2.x.171]的残余量是否 "大大减少"。
*
* - 如果是，那么就采取[2.x.172] .
*
* - 如果不是，试试用[2.x.173]是否 "大大缩小 "了残差。
*
* - 等等。当然，我们可以选择其他因素[2.x.174]，而不是上面选择的[2.x.175]，为[2.x.176] 。很明显，"回溯 "一词的来源是：我们尝试一个长的步骤，但如果这不起作用，我们就尝试一个更短的步骤，而且是越来越短的步骤，等等。函数[2.x.177]的编写方式正是为了支持这种使用情况。
* 我们是否接受一个特定的步长[2.x.178]，取决于我们如何定义 "相当小"。有许多方法可以做到这一点，但在不详细说明的情况下，我们只需提到最常见的方法是使用沃尔夫和阿米约-戈尔德斯坦条件。对于这些，我们可以证明以下几点。
*
* - 总有一个步长[2.x.179]可以满足条件，也就是说，只要问题是凸的，迭代就不会被卡住。
*
* - 如果我们足够接近解决方案，那么条件允许[2.x.180]，从而实现二次收敛。
* 我们在此不再赘述，而是将这种算法的实现作为一个练习。然而，我们注意到，如果实施正确，那么通常可以看到，大多数合理的非线性问题可以在5到15次牛顿迭代中解决，达到工程精度&mdash；比我们目前版本的程序所需要的要少得多。
* 关于全球化方法的更多细节，包括回溯，可以在 [2.x.181] 和 [2.x.182] 中找到。
* 然而，非常值得一提的是，在实践中，高效非线性求解器的实现与高效有限元方法的实现一样复杂。我们不应该试图通过自己实现所有的必要步骤来重新发明车轮。在[2.x.183]函数中已经有了大量的拼图，可以用来实现这个目的。但是，相反，就像在deal.II这样的库中构建有限元求解器一样，我们应该在[SUNDIALS](https://computing.llnl.gov/projects/sundials)这样的库中构建非线性求解器。事实上，deal.II有与SUNDIALS的接口，特别是通过[2.x.184]类与它的非线性求解器子包KINSOL的接口。将目前的问题建立在该接口上并不困难。
*
* - 事实上，这就是[2.x.185]的作用。
*


*[1.x.134][1.x.135]。


* 我们目前对每个网格正好做了5次迭代。但这是最优的吗？我们可以提出以下问题。
*
* - 也许在初始网格上做更多的迭代是值得的，因为那里的计算很便宜。
*
* - 另一方面，我们不希望在每个网格上做太多的迭代：是的，我们可以在每个网格上把残差赶到零，但这只意味着非线性迭代误差远远小于离散化误差。
*
* - 我们应该用更高还是更低的精度来解决每个牛顿步骤中的线性系统？
* 归根结底，这归结为我们需要将当前网格上的离散化误差与我们希望在特定网格上通过牛顿迭代实现的非线性残差，以及我们希望在每个牛顿迭代中通过CG方法实现的线性迭代联系起来。
* 如何做到这一点，也不是完全微不足道的，我们还是把它作为一个未来的练习。
*


*[1.x.136][1.x.137]


* 正如在介绍中所概述的，当解决形式为[1.x.138]的非线性问题时，我们使用牛顿迭代，要求我们反复解决线性偏微分方程。
* [1.x.139]
* 这样我们就可以计算出更新
* [1.x.140]
*与牛顿步骤的解决方案[2.x.186]。对于这里的问题，我们可以用手计算导数[2.x.187]，并得到[1.x.141]，但这已经是一个相当大的表达式，无论是操作还是实现都很麻烦。在某种意义上，它也是重复的。如果我们在代码的某个地方实现了[2.x.188]，那么[2.x.189]就不是一个独立的信息，而是，至少在原则上，计算机应该能够自己推断出来的东西了。也就是说，如果我们只需要实现[2.x.190]，而[2.x.191]是以某种方式隐含地完成的，那不是很好吗？这实际上是可能的，并以 "自动区分 "的名义运行。  [2.x.192]概括地讨论了这个概念，[2.x.193]说明了如何在实践中应用这个概念来解决我们在这里考虑的问题。
*

* [1.x.142][1.x.143] [2.x.194] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-16_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19]
* [2.x.2]
* [1.x.20]
* [1.x.21][1.x.22][1.x.23] 。


*
* 这个例子展示了deal.II中多层次函数的基本用法。它解决的问题与[2.x.3]中使用的问题几乎相同，但展示了使用多网格作为预处理程序时必须提供的东西。特别是，这要求我们定义一个层次结构，提供从一个层次到下一个层次以及返回的转移算子，并在每个层次上提供拉普拉斯算子的表示。
* 为了使微分方程系统和块状预处理程序具有足够的灵活性，在开始使用多层次方法之前，必须创建一些不同的对象，尽管大部分需要做的事情是由deal.II本身提供。这些对象是
*


*


*
* - 网格之间的对象处理转移；我们为此使用了MGTransferPrebuilt类，它几乎完成了库内所有的工作。
*


*


*
* - 最粗层次上的求解器；这里，我们使用MGCoarseGridHouseholder。
*


*


*
* - 所有其他级别的平滑器，在我们的例子中，这将是使用SOR作为基本方法的[2.x.4]类。
*


*


*
* 和[2.x.5]一个具有特殊水平乘法的类，即我们基本上为每个网格水平存储一个矩阵并允许与之相乘。
* 这些对象中的大多数只在实际解决线性系统的函数中需要。在这里，这些对象被合并到一个多网格类型的对象中，其中包含V-循环的实现，它又被预设条件器PreconditionMG使用，准备插入到LAC库的线性求解器中。
* 这里实现的自适应细化网格的多网格方法遵循[2.x.6]"多网格论文 "中的大纲，其中描述了交易二中的基本实现方式，也介绍了很多术语。首先，我们必须区分层次网格和叶子网格，前者是指与粗略网格有相同解析距离的单元，后者是由层次结构中的活动单元组成的（在较早的工作中，我们将其称为全局网格，但这个术语被过度使用）。最重要的是，叶状网格与最细层次的网格不完全相同。下面的图片显示了我们所认为的 "水平网格"。
* [2.x.7]
* 这个网格中的精细层次只包括在精炼单元上定义的自由度，而没有延伸到没有精炼的域的那一部分。虽然这保证了整体工作的增长[2.x.8]为最佳多网格复杂度所必需的，但它导致了在定义平滑的位置和对个别层次上定义的算子提出什么边界条件时的问题，如果层次边界不是外部边界。这些问题在上面引用的文章中有详细的讨论。
*[1.x.24][1.x.25]
*

* 我们在这里解决的问题与[2.x.9]相似，主要有两点不同：首先，显然是多网格预处理程序。我们还改变了系数的不连续性，使局部汇编器看起来不会比必要的更复杂。
*

* [1.x.26] [1.x.27]。
* [1.x.28] [1.x.29]。


*
* 同样，前几个include文件已经知道了，所以我们不会对它们进行评论。
*


* [1.x.30]
*
* 这些，现在，是多级方法所必需的包括。第一个声明了如何处理多网格方法每个层次上的Dirichlet边界条件。对于自由度的实际描述，我们不需要任何新的包含文件，因为DoFHandler已经实现了所有必要的方法。我们只需要将自由度分配给更低的层次。
*

*
* 其余的包括文件涉及到作为线性算子（求解器或预处理器）的多重网格的力学。
*


* [1.x.31]
*
* 我们将使用[2.x.10]来循环处理单元格，所以在这里包括它。
*


* [1.x.32]
*
* 这就是C++。
*


* [1.x.33]
*
* [1.x.34] [1.x.35]。
* 我们使用[2.x.11]来组装我们的矩阵。为此，我们需要一个ScratchData对象来存储每个单元的临时数据（这只是FEValues对象）和一个CopyData对象，它将包含每个单元装配的输出。关于scratch和copy对象的用法的更多细节，请参阅WorkStream命名空间。
*


* [1.x.36]
*
* [1.x.37] [1.x.38]。


*
* 这个主类与 [2.x.12] 中的同一类相似。就成员函数而言，唯一增加的是。
*


*
* - [2.x.13]函数，它组装了对应于中间层次的离散运算符的矩阵。
*


*
* - [2.x.14]函数，将我们的PDE组装在一个单元上。
*


* [1.x.39]
*
* 以下成员是多网格方法的基本数据结构。前四个表示稀疏模式和多级层次结构中各个层次上的矩阵，非常类似于上面的全局网格的对象。     
* 然后我们有两个新的矩阵，只需要在自适应网格上进行局部平滑的多网格方法。它们在细化区域的内部和细化边缘之间传递数据，如[2.x.15]"多网格论文 "中详细介绍的。     
* 最后一个对象存储了每个层次上的边界指数信息和位于两个不同细化层次之间的细化边缘上的指数信息。因此，它的作用与AffineConstraints类似，但在每个层次上。
*


* [1.x.40]
*
* [1.x.41] [1.x.42]。


*
* 关于三角结构的构造函数，只有一个简短的评论：按照惯例，deal.II中所有自适应细化的三角结构在单元之间的面的变化不会超过一个级别。然而，对于我们的多网格算法，我们需要一个更严格的保证，即网格在连接两个单元的顶点上的变化也不超过细化级别。换句话说，我们必须防止出现以下情况。
* [2.x.16]
* 这可以通过向三角化类的构造函数传递[2.x.17]标志来实现。
*


* [1.x.43]
*
* [1.x.44] [1.x.45]。


*
* 除了只是在DoFHandler中分配自由度之外，我们在每一层都做同样的事情。然后，我们按照之前的程序在叶网中设置系统。
*


* [1.x.46]
*
* 多网格约束必须被初始化。他们需要知道哪里有迪里希特边界条件的规定。
*


* [1.x.47]
*
* 现在是关于多网格数据结构的事情。首先，我们调整多级对象的大小，以容纳每一级的矩阵和稀疏度模式。粗略的级别是零（现在是强制性的，但在未来的修订中可能会改变）。注意，这些函数在这里采取的是一个完整的、包容的范围（而不是一个起始索引和大小），所以最细的级别是[2.x.18] 。我们首先要调整容纳SparseMatrix类的容器的大小，因为它们必须在调整大小时释放它们的SparsityPattern才能被销毁。
*


* [1.x.48]

* 现在，我们必须在每个层次上提供一个矩阵。为此，我们首先使用[2.x.19]函数在每个层次上生成一个初步的压缩稀疏模式（关于这个主题的更多信息，请参见[2.x.20]模块），然后将其复制到我们真正想要的那个层次。下一步是用拟合的稀疏模式初始化接口矩阵。     
* 值得指出的是，界面矩阵只有位于较粗和较细的网格之间的自由度条目。因此，它们甚至比我们的多网格层次结构中的各个层次的矩阵还要稀疏。因此，我们使用一个专门为此目的而建立的函数来生成它。
*


* [1.x.49]
*
* [1.x.50] [1.x.51]。


*
* cell_worker函数用于在给定的单元上组装矩阵和右手边。这个函数用于活动单元生成system_matrix，并在每个层次上建立层次矩阵。   
* 请注意，当从assemble_multigrid()调用时，我们也会组装一个右手边，尽管它没有被使用。
*


* [1.x.52]
*
* [1.x.53] [1.x.54]。



* 下面的函数将线性系统组装在网格的活动单元上。为此，我们向Mesh_loop()函数传递了两个lambda函数。cell_worker函数重定向到同名的类成员函数，而copyer是这个函数特有的，它使用约束条件将本地矩阵和向量复制到相应的全局矩阵。
*


* [1.x.55]
*
* [1.x.56] [1.x.57]。


*
* 下一个函数是建立矩阵，定义每一层网格上的多栅方法。集成的核心与上面的相同，但是下面的循环会遍历所有已存在的单元，而不仅仅是活动的单元，而且结果必须输入正确的层次矩阵。幸运的是，MeshWorker对我们隐藏了大部分的内容，因此这个函数和之前的函数的区别只在于汇编器的设置和循环中的不同迭代器。   
* 我们为每个层次生成一个AffineConstraints对象，其中包含了边界和界面道夫作为约束条目。然后，相应的对象被用来生成层次矩阵。
*


* [1.x.58]
*
* 接口条目在填充mg_matrices[cd.level]时被上面的boundary_constraints对象所忽略。相反，我们手动将这些条目复制到当前级别的界面矩阵中。
*


* [1.x.59]
*
* [1.x.60] [1.x.61]。


*
* 这是另一个在支持多网格求解器（或者说，事实上，我们使用多网格方法的前提条件）方面有明显不同的函数。   
* 让我们首先建立多层次方法的两个组成部分：层次间的转移算子和最粗层次上的求解器。在有限元方法中，转移算子来自所涉及的有限元函数空间，通常可以用独立于所考虑问题的通用方式计算。在这种情况下，我们可以使用MGTransferPrebuilt类，给定最终线性系统的约束条件和MGConstrainedDoFs对象，该对象知道各层的边界条件和不同细化层之间接口的自由度，可以从具有层自由度的DoFHandler对象建立这些转移操作的矩阵。   
* 下面几行的第二部分是关于粗略网格求解器的。由于我们的粗网格确实非常粗，我们决定采用直接求解器（最粗层次矩阵的Householder分解），即使其实现不是特别复杂。如果我们的粗网格比这里的5个单元多得多，那么这里显然需要更合适的东西。
*


* [1.x.62]
*
* 多级求解器或预处理器的下一个组成部分是，我们需要在每一级上进行平滑处理。这方面常见的选择是使用松弛方法的应用（如SOR、Jacobi或Richardson方法）或求解器方法的少量迭代（如CG或GMRES）。[2.x.21]和MGSmootherPrecondition类为这两种平滑器提供支持。这里，我们选择应用单一的SOR迭代。为此，我们定义一个适当的别名，然后设置一个平滑器对象。     
* 最后一步是用我们的水平矩阵初始化平滑器对象并设置一些平滑参数。[2.x.22]函数可以有选择地接受额外的参数，这些参数将被传递给每一级的平滑器对象。在当前SOR平滑器的情况下，这可能包括一个松弛参数。然而，我们在这里将这些参数保留为默认值。对[2.x.23]的调用表明我们将在每个级别上使用两个前平滑步骤和两个后平滑步骤；为了在不同级别上使用可变数量的平滑器步骤，可以在对[2.x.24]对象的构造函数调用中设置更多选项。     
* 最后一步的结果是我们使用SOR方法作为平滑器的事实
*
* - 这不是对称的
*
* - 但我们使用共轭梯度迭代（这需要一个对称的预处理程序）下面，我们需要让多级预处理程序确保我们得到一个对称的算子，即使是非对称的平滑器。
*


* [1.x.63]
*
* 下一个准备步骤是，我们必须将我们的水平矩阵和接口矩阵包裹在一个具有所需乘法函数的对象中。我们将为从粗到细的接口对象创建两个对象，反之亦然；多网格算法以后将使用转置运算器进行后一种操作，允许我们用已经建立的矩阵初始化该运算器的上下版本。
*


* [1.x.64]

* 现在，我们准备设置V型循环算子和多级预处理程序。
*


* [1.x.65]
*
* 有了这些，我们终于可以用通常的方法来解决这个线性系统了。
*


* [1.x.66]
*
* [1.x.67] [1.x.68]。


*
* 以下两个函数在解决方案计算完成后对其进行后处理。特别是，第一个函数在每个周期开始时细化网格，第二个函数在每个周期结束时输出结果。这些函数与[2.x.25]中的函数几乎没有变化。
*


* [1.x.69]
*
* [1.x.70] [1.x.71]。


*
* 和上面的几个函数一样，这几乎是对[2.x.26]中相应函数的复制。唯一的区别是对[2.x.27]的调用，它负责形成我们在多网格方法中需要的每一级矩阵。
*


* [1.x.72]
*
* [1.x.73] [1.x.74]。


*
* 这又是与 [2.x.28] 中的函数相同。
*


* [1.x.75]
* [1.x.76][1.x.77] 。


* 在最细的网格上，解决方案看起来像这样。
* [2.x.29]
* 更重要的是，我们想看看多网格方法是否真的提高了求解器的性能。因此，这里是文本输出。
<pre>第0周期 活动单元数：80 自由度数：89 (按级别：8, 25, 89) CG迭代数。8
* 周期1 活跃单元数：158 自由度数：183（按级别：8，25，89，138） CG迭代次数：9。9
* 周期2 活跃单元数：302 自由度数：352 (按级别：8, 25, 89, 223, 160) CG迭代次数。10
*周期3 活跃单元数：578 自由度数：649 (按级别：8, 25, 89, 231, 494, 66) CG迭代次数。10
* 第四周期 活跃单元数：1100 自由度数：1218 (按级别：8, 25, 89, 274, 764, 417, 126) CG迭代次数。10
* 周期5 活跃单元数：2096 自由度数：2317 (按级别：8, 25, 89, 304, 779, 1214, 817) CG迭代次数。11
* 第六周期 活跃单元数：3986 自由度数：4366 (按级别：8, 25, 89, 337, 836, 2270, 897, 1617) CG迭代次数。10
*周期7 活动单元数：7574 自由度数：8350 (按级别：8, 25, 89, 337, 1086, 2835, 2268, 1789, 3217) CG迭代次数。11</pre>
* 这几乎是完美的多重网格性能：线性残差在10次迭代步骤中减少了12个数量级，而且结果几乎与网格大小无关。这显然部分是由于所解决的问题的简单性质，但它显示了多网格方法的力量。
*

*[1.x.78][1.x.79] 。


*
* 我们鼓励你生成solve()调用的时间，并与 [2.x.30] 进行比较。你会看到多网格方法在粗网格上有相当大的开销，但在细网格上，由于其最佳的复杂性，它总是胜过其他方法。
* 仔细检查这个程序的性能，就会发现它主要是由矩阵-向量操作主导的。  [2.x.31]展示了一种可以通过使用无矩阵方法来避免这种情况的方法。
* 另一个途径是使用代数多网格方法。这里使用的几何多网格方法有时会有点难实现，因为它需要所有这些额外的数据结构，如果程序要在通过MPI耦合的机器上并行运行，例如，就会变得更加困难。在这种情况下，如果我们能使用一个黑盒子去修饰，那就更简单了，它使用某种多网格层次结构以获得良好的性能，但可以自己计算出水平矩阵和类似东西。代数多栅方法正是这样做的，我们将在[2.x.32]中使用它们来解决斯托克斯问题，在[2.x.33]和[2.x.34]中使用它们来解决平行变分。也就是说，这个例子程序的MPI并行版本可以在[2.x.35]中找到。
* 最后，人们可能想考虑如何将几何多网格用于其他类型的问题，特别是[2.x.36]"矢量值问题"。这是[2.x.37]的主题，我们在这里使用了斯托克斯方程的技术。
*

* [1.x.80][1.x.81] [2.x.38] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-16b_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17]
* [2.x.2]
* [1.x.18][1.x.19][1.x.20] 。


* 这是[2.x.3]的一个变体，唯一的变化是我们使用MeshWorker框架和预制的LocalIntegrator辅助类，而不是手动组装矩阵。
* 这个框架在实践中如何使用的细节将作为本教程程序的一部分来解释。
*[1.x.21][1.x.22]
*

* 我们在这里解决的问题与 [2.x.4] 中的问题相同。
*

* [1.x.23] [1.x.24]。
* [1.x.25][1.x.26] 。
*

*
* 同样，前几个include文件已经知道了，所以我们不会对它们进行评论。
*


* [1.x.27]
*
* 这些，现在，是多级方法所必需的包括。第一个声明了如何处理多网格方法中每一级的Dirichlet边界条件。对于自由度的实际描述，我们不需要任何新的包含文件，因为DoFHandler已经实现了所有必要的方法。我们只需要将自由度分配给更低的层次。
*

*
* 其余的包括文件涉及到作为线性算子（求解器或预处理器）的多重网格的力学。
*


* [1.x.28]
*
* 最后我们包括MeshWorker框架。这个框架通过其函数loop()和integration_loop()，自动在单元格上进行循环，并将数据组装成向量、矩阵等。它自动服从约束。由于我们必须建立几个矩阵，并且必须注意几组约束，这将使我们省去很多麻烦。
*


* [1.x.29]
*
* 为了节省精力，我们使用了在以下文件中找到的预先实现的拉普拉斯。
*


* [1.x.30]
*
* 这就是C++。
*


* [1.x.31]
*
* [1.x.32] [1.x.33]。


*
* [2.x.5]希望有一个类能够提供在单元格和边界及内部面的积分功能。这是由下面的类来完成的。在构造函数中，我们告诉循环应该计算单元格积分（"真"），但不应该计算边界和内部面的积分（两个 "假"）。因此，我们只需要一个单元格函数，而不需要面的函数。
*


* [1.x.34]

* 接下来是每个单元上的实际积分器。我们解决一个泊松问题，在右半平面的系数为1，在左半平面的系数为十分之一。
*

*
* [2.x.6]的基类[2.x.7]包含了可以在这个局部集成器中填充的对象。在MeshWorker框架内，有多少对象被创建是由装配器类决定的。在这里，我们测试一下，比如说需要一个矩阵[2.x.8] 矩阵是通过[2.x.9]来访问的，它的第一个参数是矩阵的编号。第二个参数只用于对面的积分，当每个测试函数使用两个矩阵时。那么，第二个具有指标 "true "的矩阵将以相同的索引存在。
*

*
* [2.x.10]提供了一个或几个FEValues对象，下面这些对象被[2.x.11]或[2.x.12]使用，因为我们只组装一个PDE，所以这些对象中也只有一个索引为0。
*

*
*此外，我们注意到这个积分器的作用是计算多级预处理的矩阵，以及全局系统的矩阵和右手边。由于系统的汇编器需要一个额外的向量，[2.x.13]是返回一个非零值。相应地，我们在这个函数的结尾处填充了一个右手边的向量。由于LocalResults可以处理多个BlockVector对象，但我们在这里又是在最简单的情况下，我们将信息输入到零号向量的零块中。
*


* [1.x.35]
*
* [1.x.36] [1.x.37]。


*
* 这个主类与 [2.x.14] 中的类基本相同。就成员函数而言，唯一增加的是[2.x.15]函数，该函数组装了对应于中间层的离散运算符的矩阵。
*


* [1.x.38]
*
* 以下成员是多网格方法的基本数据结构。前两个表示稀疏模式和多级层次结构中各个层次上的矩阵，非常类似于上面的全局网格的对象。     
* 然后我们有两个新的矩阵，只需要在自适应网格上进行局部平滑的多网格方法。它们在细化区域的内部和细化边缘之间传递数据，如[2.x.16]"多网格论文 "中详细介绍的。     
* 最后一个对象存储了每个层次上的边界指数信息和位于两个不同细化层次之间的细化边缘上的指数信息。因此，它的作用与AffineConstraints类似，但在每个层次上。
*


* [1.x.39]
*
* [1.x.40] [1.x.41]。


*
* 关于三角结构的构造函数只有一个简短的评论：按照惯例，deal.II中所有自适应细化的三角结构在单元之间的面的变化不会超过一个级别。然而，对于我们的多网格算法，我们需要一个更严格的保证，即网格在可能连接两个单元的顶点上的变化也不超过细化级别。换句话说，我们必须防止出现以下情况。
* [2.x.17]
* 这可以通过在三角化类的构造函数中传递[2.x.18]标志来实现。
*


* [1.x.42]
*
* [1.x.43] [1.x.44]。


*
* 除了只是在DoFHandler中分配自由度之外，我们在每一层都做同样的事情。然后，我们按照之前的程序在叶网中设置系统。
*


* [1.x.45]
*
* 多网格约束必须被初始化。他们也需要知道边界值，所以我们也在这里传递[2.x.19]。
*


* [1.x.46]
*
* 现在是关于多网格数据结构的事情。首先，我们调整多级对象的大小，以容纳每一级的矩阵和稀疏度模式。粗略的级别是零（现在是强制性的，但在未来的修订中可能会改变）。注意，这些函数在这里采取的是一个完整的、包容的范围（而不是一个起始索引和大小），所以最细的级别是[2.x.20] 。我们首先要调整容纳SparseMatrix类的容器的大小，因为它们必须在调整大小时释放它们的SparsityPattern才能被销毁。
*


* [1.x.47]

* 现在，我们必须在每个层次上提供一个矩阵。为此，我们首先使用[2.x.21]函数在每个层次上生成一个初步的压缩稀疏模式（关于这个主题的更多信息，见[2.x.22]模块），然后把它复制到我们真正想要的那个层次上。下一步是用这些稀疏模式初始化两种层次矩阵。     
* 值得指出的是，界面矩阵只有位于较粗和较细的网格界面上的自由度的条目。因此，它们甚至比我们的多网格层次结构中的各个层次的矩阵还要稀疏。如果我们更关心内存的使用（可能还有我们与这些矩阵相乘的速度），我们应该对这两种矩阵使用不同的稀疏性模式。
*


* [1.x.48]
*
* [1.x.49] [1.x.50]。


*
* 下面的函数将线性系统装配在网格的最细层次上。由于我们想在下面的层次装配中重用这里的代码，我们使用局部积分器类LaplaceIntegrator，而将循环留给MeshWorker框架。因此，这个函数首先设置了这个框架所需的对象，即
*


*
* - 一个[2.x.23]对象，它将提供单元格上正交点的所有所需数据。这个对象可以看作是FEValues的扩展，提供更多的有用信息。
*


*
* - 一个[2.x.24]对象，它一方面扩展了单元格迭代器的功能，同时也为其基类LocalResults中的返回值提供了空间。
*


*
* - 一个汇编程序，在此为整个系统。这里的 "简单 "是指全局系统没有一个块状结构。
*


*
* - 本地集成器，实现了实际的形式。   
* 在循环将所有这些组合成一个矩阵和一个右手边之后，还有一件事要做：集合器将矩阵的行和列的受限自由度不做处理。因此，我们在对角线上放一个一，使整个系统摆好。1这个值或任何固定的值都有一个好处，那就是它对矩阵的频谱的影响很容易理解。由于相应的特征向量形成了一个不变的子空间，所选择的值不会影响Krylov空间求解器的收敛性。
*


* [1.x.51]
*
* [1.x.52] [1.x.53]。


*
* 下一个函数是建立线性算子（矩阵）的函数，该算子定义了每一层网格上的多重网格方法。积分的核心与上面的相同，但是下面的循环会遍历所有已存在的单元，而不仅仅是活动的单元，而且结果必须输入到正确的层次矩阵中。幸运的是，MeshWorker对我们隐藏了大部分的内容，因此这个函数和之前的函数的区别只在于汇编器的设置和循环中不同的迭代器。另外，最后对矩阵的修复也是比较复杂的。
*


* [1.x.54]
*
* [1.x.55] [1.x.56]。


*
* 这是另外一个在支持多栅求解器（或者说，事实上，我们使用多栅方法的前提条件）方面有明显不同的函数。   
* 让我们首先建立多层次方法的两个组成部分：层次间的转移算子和最粗层次上的求解器。在有限元方法中，转移算子来自所涉及的有限元函数空间，通常可以用独立于所考虑问题的通用方式计算。在这种情况下，我们可以使用MGTransferPrebuilt类，给定最终线性系统的约束条件和MGConstrainedDoFs对象，该对象知道各层的边界条件和不同细化层之间接口的自由度，可以从具有层自由度的DoFHandler对象建立这些转移操作的矩阵。   
* 下面几行的第二部分是关于粗略网格求解器的。由于我们的粗网格确实非常粗，我们决定采用直接求解器（最粗层次矩阵的Householder分解），即使其实现不是特别复杂。如果我们的粗网格比这里的5个单元多得多，那么这里显然需要更合适的东西。
*


* [1.x.57]
*
* 多级求解器或预处理器的下一个组成部分是，我们需要在每一级上进行平滑处理。这方面常见的选择是使用松弛方法的应用（如SOR、Jacobi或Richardson方法）或求解器方法的少量迭代（如CG或GMRES）。[2.x.25]和MGSmootherPrecondition类提供了对这两种平滑器的支持。这里，我们选择应用单一的SOR迭代。为此，我们定义一个适当的别名，然后设置一个平滑器对象。     
* 最后一步是用我们的水平矩阵初始化平滑器对象并设置一些平滑参数。[2.x.26]函数可以有选择地接受额外的参数，这些参数将被传递给每一级的平滑器对象。在目前SOR平滑器的情况下，这可能包括一个松弛参数。然而，我们在这里将这些参数保留为默认值。对[2.x.27]的调用表明我们将在每个级别上使用两个前平滑步骤和两个后平滑步骤；为了在不同级别上使用可变数量的平滑器步骤，可以在对[2.x.28]对象的构造函数调用中设置更多选项。     
* 最后一步的结果是我们使用SOR方法作为平滑器的事实
*
* - 这不是对称的
*
* - 但我们使用共轭梯度迭代（这需要一个对称的预处理程序）下面，我们需要让多级预处理程序确保我们得到一个对称的算子，即使是非对称的平滑器。
*


* [1.x.58]
*
* 下一个准备步骤是，我们必须将我们的水平矩阵和接口矩阵包裹在一个具有所需乘法函数的对象中。我们将为从粗到细的接口对象创建两个对象，反之亦然；多网格算法以后将使用转置算子进行后一种操作，允许我们用已经建立的矩阵初始化该算子的上下两个版本。
*


* [1.x.59]

* 现在，我们已经准备好设置V-循环算子和多级预处理。
*


* [1.x.60]
*
* 有了这些，我们终于可以用通常的方法来解决线性系统了。
*


* [1.x.61]
*
* [1.x.62] [1.x.63]。


*
* 以下两个函数在解决方案计算完成后对其进行后处理。特别是，第一个函数在每个周期开始时细化网格，第二个函数在每个周期结束时输出结果。这些函数与[2.x.29]中的函数几乎没有变化，除了一个小的区别：我们以VTK格式生成输出，以使用今天更现代的可视化程序，而不是[2.x.30]编写时的那些。
*


* [1.x.64]
*
* [1.x.65] [1.x.66]。


*
* 和上面的几个函数一样，这几乎是对[2.x.31]中相应函数的复制。唯一的区别是对[2.x.32]的调用，它负责形成我们在多网格方法中需要的每一级矩阵。
*


* [1.x.67]
*
* [1.x.68] [1.x.69]。


*
* 这又是与 [2.x.33] 中的函数相同。
*


* [1.x.70]
* [1.x.71][1.x.72] 。


* 如[2.x.34]，在最细的网格上，解决方案看起来像这样。
* [2.x.35]
* 与[2.x.36]相比，输出的格式略有不同，但功能相同，显示了相同的收敛特性：<pre> [2.x.37] 0DEAL:: 活动单元数：20DEAL:: 自由度数：25（通过级别：8，25） [2.x.38]值0.510691 [2.x.39] 步骤6值4.59193e-14 [2.x.40] 1DEAL:: 活动单元数：44DEAL:: 自由度数：55（通过级别：8，25，45） [2.x.41]值0.440678 [2.x.42] 第8步值1.99419e-13 [2.x.43] 2DEAL::活动单元数：86DEAL::自由度数：105（按级别：8、25、69、49） [2.x.44] 值0.371855 [2.x.45] 第9步值1.13984e-13 [2.x.46] 3DEAL:: 活动单元数：170DEAL:: 自由度数：200（按级别：8、25、77、174） [2.x.47] 值0.318967 [2.x.48] 第9步值2.62112e-13 [2.x.49] 4DEAL:: 活动单元数：332DEAL:: 自由度数：388（按级别：8, 25, 86, 231, 204） [2.x.50] 值0.276534 [2.x.51] 第10步值1.69562e-13 [2.x.52] 5DEAL:: 活动单元数: 632DEAL:: 自由度数: 714 (按级别: 8, 25, 89, 231, 514, 141) [2.x.53] 值 0.215300 [2.x.54] 步骤10值 6.47463e-13 [2.x.55] 6DEAL:: 活动单元数: 1202DEAL:: 自由度数: 1332 (按级别: 8, 25, 89, 282, 771, 435, 257) [2.x.56] 值 0.175848 [2.x.57] 步骤 10 值 1.80664e-13 [2.x.58] 7DEAL:: 活动单元数：2288DEAL:: 自由度数：2511（按级别：8，25，89，318，779，1420，829，30） [2.x.59] 值0.136724 [2.x.60] 第11步值9.73331e-14</pre>。
*

* [1.x.73][1.x.74] [2.x.61] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-17_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21]
*[1.x.22][1.x.23][1.x.24] 。


*[1.x.25][1.x.26]


* 这个程序没有引入任何新的数学思想；事实上，它所做的只是做与[2.x.2]已经做的完全相同的计算，但它以一种不同的方式来做：我们没有使用deal.II的线性代数类，而是在deal.II提供的类之上建立一切，这些类包裹着[1.x.27]库的线性代数实现。由于PETSc允许将矩阵和向量分布在MPI网络中的几台计算机上，因此产生的代码甚至能够以%并行方式解决该问题。如果你不知道PETSc是什么，那么现在就是快速浏览其主页的好时机。
* 作为这个程序的先决条件，你需要安装PETSc，如果你想在一个集群上以%并行方式运行，你还需要[1.x.28]来划分网格。在[1.x.29]文件中描述了deal.II和这两个附加库的安装。
* 现在，关于细节：如前所述，该程序不计算任何新的东西，所以对有限元类等的使用与以前完全相同。与以前的程序不同的是，我们用近似的类[2.x.4]和[2.x.5]代替了几乎所有的类[2.x.3]的使用，它们存储数据的方式使MPI网络中的每个处理器只存储矩阵或矢量的一部分。更具体地说，每个处理器将只存储与它 "拥有 "的自由度相对应的那些矩阵行。对于向量，它们要么只存储与处理器拥有的自由度相对应的元素（这是右手边所需要的），要么也存储一些额外的元素，以确保每个处理器都能访问处理器拥有的单元（所谓的[2.x.6]"本地活动的自由度"）或邻近的单元（所谓的[2.x.7]"本地相关的自由度"）上的解组件。
* PETScWrapper命名空间的类所提供的接口与deal.II线性代数类的接口非常相似，但它们不是自己实现这一功能，而是简单地传递给其相应的PETScfunctions。因此，包装器只是用来给PETSc提供一个更现代的、面向对象的接口，并使PETSc和deal.II对象的使用尽可能地互换。使用PETSc的主要意义在于它可以以%并行方式运行。我们将利用这一点，将域划分为与MPI网络中的进程数量相同的块（"子域"）。同时，PETSc还提供了假的MPI存根，所以如果PETSc的配置中没有MPI，你可以在一台机器上运行这个程序。
*

*[1.x.30][1.x.31]


* 开发通过MPI并行运行的软件需要改变一下思维方式，因为通常需要分割所有的数据结构，使每个处理器只存储整个问题的一部分。因此，你通常不能在每个处理器上访问一个解决方案向量的所有组成部分。
*
* - 每个处理器可能根本没有足够的内存来容纳整个解决方案向量。由于数据被分割或 "分布 "在处理器之间，我们把MPI使用的编程模型称为 "分布式内存计算"（与 "共享内存计算 "相对，后者意味着多个处理器可以在一个内存空间内访问所有数据，例如，当一台机器的多个核心在一个共同任务上工作时）。分布式内存计算的一些基本原理在[2.x.8]"使用分布式内存的多处理器并行计算 "文档模块中讨论，该模块本身就是[2.x.9]"并行计算 "模块的一个子模块。
* 一般来说，为了真正能够扩展到大量的处理器，我们需要在可用的处理器之间分割[1.x.32]数据结构，其大小随着整个问题的大小而变化。关于程序 "扩展 "的定义，见[2.x.10]"本词汇表条目"）。例如，这包括三角形、矩阵和所有全局向量（解决方案，右侧）。如果不拆分所有这些对象，其中一个对象将在所有处理器上复制，如果问题大小（和可用处理器的数量）变得很大，最终会变得太大。（另一方面，在每个处理器上保留与整个问题大小无关的对象是完全可以的。例如，每个可执行文件的副本将创建它自己的有限元对象，或我们在汇编中使用的本地矩阵）。)
* 在当前的程序中（以及相关的[2.x.11]中），我们不会走得这么远，而是对使用MPI做一个比较温和的介绍。更具体地说，我们要并行化的数据结构只有矩阵和向量。然而，我们并没有拆分Triangulation和DoFHandler类：每个进程仍然拥有这些对象的完整副本，而且所有进程都拥有其他进程所拥有的确切副本。然后，我们只需在每个处理器上的三角形的每个副本中，标记哪个处理器拥有哪些单元。这个过程被称为将网格 "分割 "为[2.x.12]"子域"。
* 对于较大的问题，在每个处理器上存储[1.x.33]网格显然会产生一个瓶颈。分割网格稍微复杂一些，但并不复杂（从用户的角度来看，虽然它[1.x.34]在引擎下更复杂），我们将在[2.x.13]和其他一些程序中展示如何做到这一点。在讨论这个程序的某个功能如何工作的过程中，我们会多次评论它不能扩展到大型问题的事实，以及为什么不能。所有这些问题都将在[2.x.14]，特别是[2.x.15]中解决，它可以扩展到非常多的进程。
* 从哲学上讲，MPI的运行方式如下。你通常通过以下方式运行一个程序
* [1.x.35]
* 这意味着在（比如）32个处理器上运行它。如果你是在一个集群系统上，你通常需要[1.x.36]程序在32个处理器可用时运行；这将在你的集群的文档中描述。但是在系统内部，每当这些处理器可用时，通常会执行上述相同的调用）。)这样做的目的是，MPI系统将启动32个[1.x.37]的[2.x.16]可执行文件。(这些运行中的可执行文件的MPI术语是你有32个[2.x.17]"MPI进程"。)这可能发生在不同的机器上，甚至不能从对方的内存空间中读取，也可能发生在同一台机器上，但最终结果是一样的：这32个副本中的每一个都将在操作系统分配给它的一些内存中运行，而且它将不能直接读取其他31个副本的内存。为了在一个共同的任务中合作，这32个副本就必须[1.x.38]相互协作。MPI是[1.x.39]的缩写，通过允许程序[1.x.40]来实现这一目标。你可以把它看作是邮件服务：你可以把一封写给特定地址的信放入邮件中，它将被送达。但这就是你能控制的范围。如果你想让收信人对信的内容做些什么，例如把你想要的数据从那边返回给你，那么需要发生两件事。(i)接收方需要实际去检查他们的邮箱里是否有任何东西，(ii)如果有的话，做出适当的反应，比如说发送数据回来。如果你在等待这个返回信息，但原来的接收者却心不在焉，没有注意到，那么你就不走运了：你只能等待，直到你的请求在那里得到解决。在某些情况下，错误会导致原始接收者永远不检查你的邮件，在这种情况下，你将永远等待。
*
* - 这被称为[1.x.41]。( [2.x.18] 。
* 在实践中，人们通常不在发送和接收单个消息的层面上编程，而是使用更高层次的操作。例如，在程序中，我们将使用函数调用，从每个处理器中获取一个数字，将它们全部相加，然后将总和返回给所有处理器。在内部，这是用单个消息实现的，但对用户来说，这是透明的。我们称这种操作为[1.x.42]，因为[1.x.43]处理器参与其中。集合体允许我们编写程序，其中不是每个可执行文件的副本都在做完全不同的事情（这将是令人难以置信的编程难度），但在本质上，所有的副本都在为自己做同样的事情（尽管在不同的数据上），通过相同的代码块运行；然后他们通过集合体进行数据通信；然后再回到为自己做事情，再次通过相同的数据块运行。这是能够编写程序的关键部分，也是确保程序能够在任何数量的处理器上运行的关键部分，因为我们不需要为每个参与的处理器编写不同的代码。
* 这并不是说程序永远不会以不同的处理器在其可执行文件副本中运行不同的代码块的方式编写。程序内部也经常以其他方式而不是通过集合体进行通信。但是在实践中，%并行有限元代码几乎总是遵循这样的方案：程序的每个副本在同一时间运行相同的代码块，中间穿插着所有处理器相互交流的阶段。)
* 在现实中，即使是调用MPI集体函数的水平也是很低的。相反，下面的程序根本不包含任何对MPI的直接调用，而只包含对deal.II的用户隐藏这种通信的函数。这样做的好处是，你不需要学习MPI的细节和相当复杂的函数调用。尽管如此，你还是必须理解上文所述的MPI背后的一般哲学。
*

*[1.x.44][1.x.45]


* 本程序随后演示的技术是。
*
* - 如何使用PETSc封装类；这在本程序的主类的声明中已经可以看到， [2.x.19] 。
*
* - 如何将网格划分为子域；这发生在 [2.x.20] 函数中。
*
* - 如何对运行在MPI网络上的作业进行并行化操作；在这里，这是在很多地方都要注意的，最明显的是在 [2.x.21] 函数中。
*
* - 如何处理只存储向量项子集的向量，对于这些向量，我们必须确保它们在当前处理器上存储我们需要的东西。例如参见[2.x.22]函数。
*
* - 如何处理同时在多个处理器上运行的程序的状态输出。这是通过程序中的[2.x.23]变量完成的，在构造函数中初始化。
* 由于这一切只能用实际的代码来演示，让我们直接进入代码，不再多说。
*

* [1.x.46] [1.x.47]。
* [1.x.48][1.x.49] 。
*

*
* 首先是我们在以前的例子程序中已经使用过的常见的各种头文件。
*


* [1.x.50]
*
* 这里是我们在这个例子程序中特别需要的东西，这些东西在[2.x.24]中没有。首先，我们替换掉标准输出[2.x.25]，它用于并行计算，只在其中一个MPI进程中产生输出。
*


* [1.x.51]
*
* 我们将通过调用[2.x.26]命名空间中的相应函数来查询进程的数量和当前进程的数量。
*


* [1.x.52]
*
* 然后，我们要把所有涉及（全局）线性系统的线性代数组件替换成类，这些类围绕PETSc提供的接口与我们自己的线性代数类相似（PETSc是一个用C语言编写的库，而deal.II附带的包装类提供的PETSc功能的接口与我们自己的线性代数类已有的接口相似）。特别是，我们需要在MPI程序中分布在几个[2.x.27]"进程 "中的向量和矩阵（如果只有一个进程，也就是说，如果你只在一台机器上运行，并且没有MPI支持，则简单地映射为顺序的、本地的向量和矩阵）。
*


* [1.x.53]
*
* 然后我们还需要PETSc提供的求解器和预处理器的接口。
*


* [1.x.54]
*
* 此外，我们还需要一些算法来划分我们的网格，以便它们可以有效地分布在MPI网络上。分区算法在[2.x.28]命名空间中实现，我们需要一个额外的包含文件，用于[2.x.29]中的一个函数，该函数允许对与自由度相关的索引进行排序，以便根据它们所关联的子域进行编号。
*


* [1.x.55]

* 而这又是简单的C++。
*


* [1.x.56]

* 最后一步和以前的所有程序一样。



* [1.x.57]
*
* [1.x.58] [1.x.59]。


*
* 该程序的第一个真正的部分是主类的声明。  正如在介绍中提到的，几乎所有的内容都是从[2.x.30]中逐字复制过来的，所以我们只对这两个教程之间的少数差异进行评论。  有一个（表面上的）变化是，我们让[2.x.31]返回一个值，即收敛所需的迭代次数，这样我们就可以在适当的地方将其输出到屏幕上。
*


* [1.x.60]
*
* 第一个变化是，我们必须声明一个变量，表明我们应该通过它来分配我们的计算的[2.x.32]"MPI通信器"。
*


* [1.x.61]
*
* 然后我们有两个变量，告诉我们在并行世界中的位置。下面的第一个变量，[2.x.33] ，告诉我们总共有多少个MPI进程，而第二个变量，[2.x.34] ，表明在这个进程空间中，哪个是当前进程的编号（在MPI语言中，这相当于进程的[2.x.35] "等级"）。后者对每个进程都有一个唯一的值，介于零和（小于）[2.x.36] 之间。如果这个程序运行在没有MPI支持的单机上，那么它们的值分别是[2.x.37] ，。
*


* [1.x.62]
*
* 接下来是一个类似流的变量 [2.x.38] 。从本质上讲，它只是我们为了方便而使用的东西：在一个并行程序中，如果每个进程都输出状态信息，那么很快就会有很多杂乱的东西。相反，我们希望只让一个[2.x.39]"进程 "输出一次所有信息，例如[2.x.40]"等级 "为零的那个。同时，在我们创建输出的地方用[2.x.41]的条件给[1.x.63]加前缀似乎很傻。     
* 为了使这个问题更简单，ConditionalOStream类在引擎盖下正是这样做的：它就像一个流一样，但只有在一个标志被设置时才转发到一个真正的、底层的流。通过将这个条件设置为[2.x.42]（其中[2.x.43]对应于MPI进程的等级），我们确保输出只从第一个进程中产生，并且我们不会在每个进程中重复得到相同的输出行。因此，我们可以在每一个地方和每一个进程中使用[2.x.44]，但是除了一个进程之外，其他的进程都不会发生通过[2.x.45]输送到对象中的信息。
*


* [1.x.64]
*
* 成员变量列表的其余部分与 [2.x.46] 中的内容基本相同。然而，我们改变了矩阵和向量类型的声明，改为使用并行的PETSc对象。请注意，我们没有使用单独的稀疏模式，因为PETSc将其作为其矩阵数据结构的一部分进行内部管理。
*


* [1.x.65]
*
* [1.x.66] [1.x.67]。


*
* 以下内容取自[2.x.47]，没有改动。
*


* [1.x.68]
*
* [1.x.69] [1.x.70]。



* [1.x.71] [1.x.72]。


*
* 实际实现的第一步是主类的构造函数。除了初始化我们在[2.x.48]中已经有的相同成员变量外，我们在这里用连接所有进程的全局MPI通信器来初始化我们将使用的MPI通信器变量（在更复杂的应用中，我们可以在这里使用一个只连接所有进程的一个子集的通信器对象），并调用[2.x.49]辅助函数来确定进程的数量以及当前进程在这个画面中的地位。此外，我们确保输出只由（全局）第一个进程产生。我们通过将我们想要输出的流传给[2.x.50]和一个真/假标志作为参数，后者是通过测试当前执行构造函数调用的进程是否是MPI宇宙中的第一个来确定的。
*


* [1.x.73]
*
* [1.x.74] [1.x.75]。


*
* 接下来，需要实现我们为要解决的全局线性系统设置各种变量的函数。   
* 然而，在我们进行这项工作之前，对于一个并行程序来说，有一件事要做：我们需要确定哪个MPI进程负责每个单元。在进程之间分割单元，通常称为 "划分网格"，是通过给每个单元分配一个[2.x.51]"子域ID "来完成的。我们通过调用METIS库来做到这一点，该库以一种非常有效的方式，试图尽量减少子域之间的接口上的节点数量。我们没有尝试直接调用METIS，而是通过调用[2.x.52]函数来实现，该函数在更高的编程水平上完成这一工作。   
*


* [2.x.53] 正如在介绍中提到的，如果我们使用[2.x.54]类来代替三角形对象，我们可以避免这个手动划分的步骤（就像我们在[2.x.55]中做的那样）。该类实质上做了所有常规三角形的工作，但它也会在每次创建或细化网格操作后自动划分网格。   
* 分割之后，我们需要像往常一样列举所有的自由度。  然而，我们希望列举自由度的方式是：所有与子域0（位于过程0）的单元相关的自由度都在与子域1的单元相关的自由度之前，在过程2的单元之前，以此类推。我们需要这样做，因为我们必须将全局向量的右手边和解决方案，以及矩阵分割成连续的行块，住在每个处理器上，而且我们希望以一种需要最小通信的方式来做这件事。这种特殊的列举可以通过使用[2.x.56]对自由度指数重新排序得到。
* 这个初始设置的最后一步是，我们为自己得到一个IndexSet，表示这个过程所负责的全球未知数的子集。(注意，一个自由度不一定是由拥有一个单元的进程所拥有，只是因为这个自由度生活在这个单元上：有些自由度生活在子域之间的接口上，因此只由这个接口附近的一个进程所拥有)。   
* 在我们继续之前，让我们回顾一下介绍中已经讨论过的一个事实。我们在这里使用的三角形是在所有进程中复制的，每个进程都有整个三角形的完整副本，包括所有单元。分区只提供了一种方法来确定每个进程 "拥有 "哪些单元，但它知道所有单元的一切。同样，DoFHandler对象知道每个单元的一切，特别是每个单元上的自由度，不管它是否是当前进程拥有的。这不能扩展到大型问题，因为如果问题足够大，最终只是在每个进程中存储整个网格以及与之相关的所有内容将变得不可行。另一方面，如果我们将三角形分割成若干部分，使每个进程只存储它 "拥有 "的单元格，而不存储其他的单元格（或者，至少是其他所有单元格中足够小的一部分），那么我们就可以解决大型问题，只要我们将足够多的MPI进程扔给它们。这就是我们在[2.x.57]中要做的事情，例如，使用[2.x.58]类。  另一方面，我们在当前程序中演示的其余大部分内容实际上将继续工作，无论我们有整个三角形的可用，还是只有其中的一部分。
*


* [1.x.76]
*
* 我们需要初始化表示当前网格的悬挂节点约束的对象。与三角形和DoFHandler对象一样，我们将简单地在每个进程上存储[1.x.77]约束；同样，这不会有规模，但我们在[2.x.59]中展示了如何通过在每个MPI进程上只存储对该特定进程实际重要的自由度约束来解决这一问题。
*


* [1.x.78]
*
* 现在我们为系统矩阵创建稀疏模式。请注意，我们再次计算并存储所有的条目，而不仅仅是与这个过程有关的条目（见[2.x.60]或[2.x.61]，以获得更有效的处理方式）。
*


* [1.x.79]
*
* 现在我们确定本地拥有的DoF的集合，并使用它来初始化并行向量和矩阵。由于矩阵和向量需要并行工作，我们必须向它们传递一个MPI通信对象，以及IndexSet[2.x.62]中包含的分区信息。IndexSet包含全局大小（[1.x.80]自由度数）的信息，也包含要在本地存储哪些行的子集。  注意，系统矩阵需要该行和列的分区信息。对于正方形矩阵，就像这里的情况一样，列的划分方式应该与行的划分方式相同，但是对于矩形矩阵，我们必须以向量的划分方式来划分列，而行的划分方式必须与矩阵-向量乘法的目的向量相同。
*


* [1.x.81]
*
* [1.x.82] [1.x.83]。


*
* 我们现在组装矩阵和问题的右手边。在我们进行详细讨论之前，有一些事情值得一提。首先，我们将平行组装系统，也就是说，每个进程将负责在属于这个特定进程的单元上组装。请注意，自由度的分割方式是，单元内部和属于同一子域的单元之间的所有自由度都属于[2.x.63]该单元的过程。然而，即使如此，我们有时也需要在一个单元上与属于不同过程的邻居集合，在这些情况下，当我们将局部贡献加到全局矩阵或右手向量中时，我们必须将这些条目转移到拥有这些元素的过程中。幸运的是，我们不需要用手去做这件事。PETSc为我们做了这一切，它在本地缓存了这些元素，当我们在这个函数的末尾调用矩阵和向量的[2.x.64]函数时，根据需要将它们发送到其他进程。   
* 第二点是，一旦我们把矩阵和向量的贡献交给了PETSc，那么，a）很难，b）要把它们拿回来修改，效率非常低。这不仅是PETSc的错，也是这个程序的分布式性质的结果：如果一个条目存在于另一个处理器上，那么获取它的成本必然很高。这样做的后果是，我们不应该试图首先将矩阵和右手边组装起来，就像没有悬挂的节点约束和边界值一样，然后在第二步中消除这些约束（例如使用[2.x.65]），相反，我们应该在将这些条目移交给PETSc之前尝试消除悬挂的节点约束。这很容易：我们不是用手将元素复制到全局矩阵中（就像我们在[2.x.66]中做的那样），而是使用[2.x.67]函数同时处理悬空节点的问题。我们在 [2.x.68] 中也已经这样做了。第二步，消除边界节点，也可以这样做，把边界值放到与悬挂节点相同的AffineConstraints对象中（例如，见[2.x.69]中的方法）；但是，严格来说，在这里没有必要这样做，因为消除边界值可以只用每个进程本身存储的数据来完成，因此，我们使用之前在[2.x.70]中使用的方法，即通过[2.x.71]
* 说了这么多，下面是实际的实现，从辅助变量的一般设置开始。  (注意，我们仍然使用deal.II的全矩阵和向量类型的本地系统，因为这些类型很小，不需要在不同的进程中共享。)
*


* [1.x.84]
*
* 接下来是所有元素的循环。请注意，我们不必在每个进程上做[1.x.85]的工作：我们在这里的工作只是在实际属于这个MPI进程的单元上组装系统，所有其他的单元将由其他进程来处理。这就是紧随for-loop之后的if-clause所要处理的：它查询每个单元的子域标识符，这是一个与每个单元相关的数字，告诉我们所有者进程的情况。在更大的范围内，子域标识被用来将一个域分成几个部分（我们在上面[2.x.72]的开头就这样做了），并允许识别一个单元生活在哪个子域。在这个应用中，我们让每个进程恰好处理一个子域，所以我们确定了这些术语 [2.x.73] 。     
* 除此以外，如果你已经了解了在 [2.x.74] 中是如何完成的，那么组装本地系统就相对不难了。如上所述，将局部贡献分配到全局矩阵和右手边，也是以与[2.x.75]中相同的方式处理悬挂节点约束。
*


* [1.x.86]

* 下一步是 "压缩 "向量和系统矩阵。这意味着每个进程将对矩阵和向量中那些自己不拥有的条目所做的补充发送给拥有这些条目的进程。在收到其他进程的这些加法后，每个进程再把它们加到它已经拥有的值上。这些加法是将生活在几个单元上的形状函数的积分贡献结合起来，就像在串行计算中一样，不同的是这些单元被分配给不同的进程。
*


* [1.x.87]
*
* 全局矩阵和右手边的向量现在已经形成。我们仍然要应用边界值，方法与我们在[2.x.76]、[2.x.77]和其他一些程序中的方法相同。     
* 下面调用[2.x.78]的最后一个参数允许进行一些优化。它控制我们是否应该删除对应于边界节点的矩阵列中的条目（即设置为零），或者保留它们（通过[2.x.79]意味着：是的，消除这些列）。如果我们消除了列，那么结果矩阵将再次成为对称的，如果我们不这样做，那么它将不会。不过，结果系统的解应该是一样的。我们想让系统重新成为对称的唯一原因是我们想使用CG方法，该方法只对对称矩阵有效。我们可能[1.x.88]想让矩阵对称的原因是，这将要求我们写进实际存在于其他进程中的列项，即涉及到数据的交流。这总是很昂贵的。     
* 经验告诉我们，如果我们不删除与边界节点相关的列，CG也可以工作（而且工作得几乎一样好），这可以用这种特殊的非对称性结构来解释。为了避免通信的费用，我们因此不消除受影响列中的条目。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。


*
* 组建了线性系统后，我们接下来需要解决它。PETSc提供了各种顺序和并行求解器，我们为这些求解器编写了包装器，其界面与之前所有示例程序中使用的deal.II求解器几乎相同。因此，下面的代码看起来应该相当熟悉。   
* 在函数的顶部，我们设置了一个收敛监视器，并为它指定了我们希望解决线性系统的精度。接下来，我们使用PETSc的CG求解器创建一个实际的求解器对象，该求解器也适用于并行（分布式）矢量和矩阵。最后是一个预处理程序；我们选择使用一个块状雅可比预处理程序，它通过计算矩阵的每个对角线块的不完全LU分解来工作。  换句话说，每个MPI进程从其存储的行中计算出一个ILU，丢掉与本地未存储的行指数相对应的列；这就产生了一个方形矩阵块，我们可以从中计算出一个ILU。这意味着如果你只用一个进程来运行程序，那么你将使用一个ILU(0)作为预处理程序，而如果它在许多进程上运行，那么我们将在对角线上有许多块，预处理程序是这些块中每个块的ILU(0)。在每个处理器只有一个自由度的极端情况下，这个预处理程序只是一个雅可比预处理程序，因为对角线矩阵块只由一个条目组成。这样的预处理程序相对容易计算，因为它不需要处理器之间的任何形式的通信，但一般来说，对于大量的处理器来说，它的效率并不高。)   
* 按照这样的设置，我们就可以解决线性系统。
*


* [1.x.92]
*
* 下一步是分配悬挂的节点约束。这有点麻烦，因为要填入一个约束节点的值，你需要访问它所约束的节点的值（例如，对于2d中的Q1元素，我们需要访问悬挂节点面大边上的两个节点，以计算中间的约束节点的值）。     
* 问题是，我们已经以这样的方式建立了我们的向量（在[2.x.80]中），即每个进程只负责存储解向量中对应于该进程 "拥有 "的自由度的那些元素。然而，在有些情况下，为了计算一个进程中受限自由度的向量项的值，我们需要访问存储在其他进程中的向量项。  PETSc（以及它所基于的MPI模型）不允许简单地查询存储在其他进程上的向量条目，所以我们在这里所做的是获得一个 "分布式 "向量的副本，我们将所有元素存储在本地。这很简单，因为deal.II包装器有一个针对deal.II Vector类的转换构造函数。这种转换当然需要通信，但实质上每个进程只需要将其数据批量发送给其他每个进程一次，而不需要对单个元素的查询做出回应）。
*


* [1.x.93]
*
* 当然，和以前的讨论一样，如果你想在大量的进程上解决大问题，这样的步骤显然不能很好地扩展，因为现在每个进程都存储了[1.x.94]的解向量。(我们将在[2.x.81]中展示如何更好地做到这一点。) 另一方面，在这个本地副本上分配悬挂节点约束很简单，使用通常的函数[2.x.82] 特别是，我们可以计算[1.x.95]约束自由度的值，无论当前进程是否拥有它们。
*


* [1.x.96]
*
* 然后把所有的东西都转回全局向量中。下面的操作是复制那些我们在本地存储在分布式解决方案中的本地化解决方案的元素，而不碰其他的元素。由于我们在所有处理器上做同样的操作，我们最终得到一个分布式向量（即在每个进程上只存储对应于该进程所拥有的自由度的向量项的向量），该向量的所有约束节点是固定的。     
* 我们通过返回收敛所花的迭代次数来结束这个函数，以允许一些输出。
*


* [1.x.97]
*
* [1.x.98] [1.x.99]。


*
* 使用某种细化指标，可以对网格进行细化。问题基本上与分布悬挂节点约束相同：为了计算误差指标（即使我们只是对当前进程拥有的单元格的指标感兴趣），我们需要访问解向量的更多元素，而不仅仅是当前处理器存储的那些。为了实现这一点，我们基本上做了我们在[2.x.83]中已经做过的事情，即在每个进程中获取[1.x.100]的解向量副本，并使用它来计算。如上所述，这本身就很昂贵，而且特别没有必要，因为我们刚刚在[2.x.84]中创建并销毁了这样一个向量，但效率不是这个程序的重点，所以让我们选择一个设计，其中每个函数都是尽可能独立的。   
* 一旦我们有了这样一个包含[1.x.101]解向量元素的 "本地化 "向量，我们就可以计算属于当前过程的单元的指标。事实上，我们当然可以计算[1.x.102]细化指标，因为我们的Triangulation和DoFHandler对象存储了所有单元的信息，而且我们有一个完整的解向量副本。但是为了展示如何平行操作，让我们演示一下，如果只计算[1.x.103]错误指标，然后与其他进程交换剩余的指标，会如何操作。最终，每个进程都需要一套完整的细化指标，因为每个进程都需要细化他们的网格，并且需要以与所有其他进程完全相同的方式细化它）。   
* 因此，要做到这一切，我们需要。
*


*
* - 首先，获得一份分布式解决方案向量的本地副本。
*


*
* - 第二，创建一个矢量来存储细化指标。
*


*
* - 第三，让KellyErrorEstimator计算属于当前子域/过程的所有单元的细化指标。调用的最后一个参数表明我们对哪个子域感兴趣。在它之前的三个参数是其他各种默认参数，通常不需要（也不说明数值，而是使用默认值），但我们必须在这里明确说明，因为我们想修改下面一个参数的值（即表示子域的参数）。
*


* [1.x.104]
*
* 现在，所有进程都计算了自己单元的错误指标，并将其存储在[2.x.85]向量的各个元素中。这个向量中不属于本进程的单元的元素为零。然而，由于所有进程都有整个三角形的副本，并需要保持这些副本的同步性，他们需要三角形所有单元的细化指标值。因此，我们需要分配我们的结果。我们通过创建一个分布式向量来做到这一点，每个进程都有自己的份额，并设置它所计算的元素。因此，当你把这个向量看作是一个存在于所有进程中的向量时，那么这个向量的每个元素都被设置过一次。然后，我们可以将这个并行向量分配给每个进程上的一个本地非并行向量，使[1.x.105]错误指标在每个进程上都可用。     
* 所以在第一步，我们需要设置一个并行向量。为了简单起见，每个进程都将拥有一个元素块，其数量与该进程拥有的单元格一样多，因此第一个元素块被存储在进程0，下一个元素块被存储在进程1，以此类推。然而，需要注意的是，这些元素不一定是我们要写入的元素。这是单元格排列顺序的结果，也就是说，向量中的元素对应单元格的顺序并不是根据这些单元格所属的子域来排序的。换句话说，如果在这个过程中，我们计算某个子域的单元的指标，我们可能会把结果写到分布式向量的或多或少的随机元素中；特别是，它们不一定位于我们在这个过程中拥有的向量块中。它们随后将不得不被复制到另一个进程的内存空间中，当我们调用[2.x.86]函数时，PETSc为我们做了这项操作。这种低效率可以通过更多的代码来避免，但我们避免这样做，因为它不是程序总运行时间的主要因素。     
* 所以我们是这样做的：计算有多少个单元属于这个过程，用这么多的元素建立一个分布式向量存储在本地，将我们在本地计算的元素复制过去，最后将结果压缩。事实上，我们实际上只复制了非零的元素，所以我们可能会错过一些我们计算为零的元素，但这不会有什么影响，因为反正矢量的原始值是零。
*


* [1.x.106]
*
* 所以现在我们有了这个分布式向量，它包含了所有单元的细化指标。为了使用它，我们需要获得一个本地副本，然后用它来标记要细化或粗化的单元，并实际进行细化和粗化。重要的是要认识到，[1.x.107]进程对它自己的三角图副本做了这件事，并且以完全相同的方式进行。
*


* [1.x.108]
*
* [1.x.109] [1.x.110]。


*
* 最后一个有意义的函数是创建图形输出的函数。它的工作方式与[2.x.87]中的相同，但有两个小区别。在讨论这些之前，让我们说明这个函数的一般工作原理：我们打算让所有的数据都在一个单一的进程中产生，然后写入一个文件。正如本程序的许多其他部分已经讨论过的那样，这不是一个可以扩展的东西。之前，我们认为我们会在三角计算、DoFHandlers和解决方案向量的副本方面遇到麻烦，每个进程都必须存储所有的数据，而且会出现一个点，即每个进程根本没有足够的内存来存储这么多数据。在这里，情况是不同的：不仅是内存，而且运行时间也是一个问题。如果一个进程负责处理[1.x.111]的数据，而其他所有的进程什么都不做，那么这一个函数最终会在程序的整个运行时间中占主导地位。  特别是，这个函数花费的时间将与问题的整体大小（以单元数或自由度数计算）成正比，与我们扔给它的进程数量无关。   
* 这种情况需要避免，我们将在[2.x.88]和[2.x.89]中展示如何解决这个问题。对于目前的问题，解决方案是让每个进程只为自己的本地单元产生输出数据，并将它们写入单独的文件，每个进程一个文件。这就是[2.x.90]的操作方式。另外，我们可以简单地把所有的东西放在一组独立的文件中，让可视化软件读取所有的文件（可能也使用多个处理器），并从所有的文件中创建一个单一的可视化；这就是[2.x.91]、[2.x.92]以及后来开发的所有其他并行程序所采取的方法。   
* 更具体地说，对于当前的函数，所有的进程都调用这个函数，但不是所有的进程都需要做与生成输出有关的工作。事实上，它们不应该这样做，因为我们会试图一次多次地写到同一个文件。所以我们只让第一个进程做这件事，而其他所有的进程在这段时间内闲置（或者为下一次迭代开始工作，或者干脆把它们的CPU让给碰巧在同一时间运行的其他作业）。第二件事是，我们不仅要输出解决方案的向量，还要输出一个向量，表明每个单元属于哪个子域。这将使一些分区域的图片变得漂亮。   
* 为了实现这一点，过程零需要一个完整的本地向量中的解决方案组件。就像之前的函数一样，有效的方法是重新使用已经在[2.x.93]函数中创建的向量，但是为了使事情更加自洽，我们在这里只是从分布式解向量中重新创建一个。   
* 需要认识到的一个重要问题是，我们在所有进程中都做了这个定位操作，而不仅仅是实际需要数据的那一个。然而，这一点是无法避免的，我们在这个教程程序中对向量使用的MPI的简化通信模型。MPI没有办法查询另一个进程的数据，双方必须在同一时间启动通信。因此，即使大多数进程不需要本地化的解决方案，我们也必须把将分布式转换为本地化向量的语句放在所有进程中执行。   
*（这项工作的一部分事实上可以避免。我们所做的是将所有进程的局部部分发送给所有其他进程。我们真正需要做的是在所有进程上发起一个操作，每个进程只需将其本地的数据块发送给进程0，因为只有这个进程真正需要它，也就是说，我们需要类似于收集操作的东西。PETSc可以做到这一点，但是为了简单起见，我们在这里并不试图利用这一点。我们没有这样做，因为我们所做的事情在整个计划中并不昂贵：它是所有进程之间的一个矢量通信，这必须与我们在求解线性系统、为预处理程序设置块状ILU以及其他操作时必须进行的通信数量相比较）。)
*


* [1.x.112]
*
* 这样做了，进程0继续设置输出文件，如[2.x.94]，并将（本地化的）解决方案向量附加到输出对象上。
*


* [1.x.113]
*
* 我们在这里做的唯一其他事情是，我们也为每个单元格输出一个值，表明它属于哪个子域（即MPI进程）。这需要一些转换工作，因为库提供给我们的数据不是输出类所期望的数据，但这并不困难。首先，设置一个整数向量，每个单元格一个，然后由每个单元格的子域id填充。         
* 在第二步中，这个向量的元素被转换为浮点向量，这个向量被添加到DataOut对象中，然后去创建VTK格式的输出。
*


* [1.x.114]
*
* [1.x.115] [1.x.116]。


*
* 最后，这里是驱动函数。它与[2.x.95]几乎完全没有变化，只是我们替换了[2.x.96]流。除此以外，唯一的表面变化是我们输出了每个进程有多少个自由度，以及线性求解器花了多少次收敛。
*


* [1.x.117]
*
* [1.x.118] [1.x.119]。


*
* [2.x.97]的工作方式与其他例子程序中的大多数主函数相同，即它将工作委托给管理对象的[2.x.98]函数，只将所有的东西包装成一些代码来捕捉异常。
*


* [1.x.120]

* 这里是唯一真正的区别。MPI和PETSc都要求我们在程序开始时初始化这些库，并在结束时解除初始化。MPI_InitFinalize类处理了所有这些。后面的参数`1`意味着我们确实想用单线程运行每个MPI进程，这是PETSc并行线性代数的前提条件。
*


* [1.x.121]
* [1.x.122][1.x.123] 。


*
* 如果上述程序被编译并在单处理器机器上运行，它产生的结果应该与我们已经得到的[2.x.99]非常相似。然而，如果我们在多核机器或计算机集群上运行它，它就会变得更有趣。运行MPI程序的最基本方法是使用命令行，如
* [1.x.124]
* 在32个处理器上运行[2.x.100]的可执行程序。
* 如果你在一个集群上工作，那么中间通常有一个步骤，你需要设置一个工作脚本，并将该脚本提交给调度器。只要调度器能够为你的工作分配32个未使用的处理器，它就会执行这个脚本。如何编写这样的作业脚本在不同的集群中是不同的，你应该找到你的集群的文档来了解如何做到这一点。在我的系统上，我必须使用[2.x.101]这个命令，加上一大堆选项来并行运行一个作业）。)
* 无论是直接还是通过调度器，如果你在8个处理器上运行这个程序，你应该得到如下的输出。
* [1.x.125]
* (这次运行比examples/目录中的代码多用了一些细化周期。该运行还使用了2004年的METIS版本，产生了不同的分区；因此，你今天得到的数字略有不同）。)
* 可以看出，我们可以很容易地达到近400万个未知数。事实上，该代码在8个进程中的运行时间不到7分钟，直到（包括）第14个周期，14分钟包括倒数第二步。我失去了最后一步的时间信息，但你会明白的。所有这些都是在通过运行[2.x.102]启用发布模式之后，并且由于上述程序注释中提到的原因，关闭了图形输出的生成。 ([2.x.103]我做的最大的2D计算大约有710万个未知数，在32个进程中完成。毫不奇怪，一个人可以走多远的限制因素是他有多少内存，因为每个进程都必须持有整个网格和DoFHandler对象，尽管矩阵和向量被分割了。对于7.1M的计算，每个未知数的内存消耗约为600字节，这还算不错，但我们必须考虑到这是针对每个未知数的，无论我们是否在本地存储矩阵和向量ntries。
*

*
* 以下是在程序的第12个周期产生的一些输出，即大约有30万个未知数。
* [2.x.104]
* 正如人们所希望的那样，这里显示的X-（左）和Y-位移（右）与我们在[2.x.105]中看到的情况非常接近。正如那里和[2.x.106]中所示，我们也可以制作位移场的矢量图，而不是把它绘制成两个独立的标量场。不过，更有趣的是，在这一步看一下网格和分区的情况。
* [2.x.107]
* 同样，网格（左边）显示了与之前相同的细化模式。右边的面板显示了8个过程中的域的划分，每个过程用不同的颜色表示。图中显示，在网格单元较小的地方，子域较小，考虑到分区算法试图平衡每个子域的单元数，这一事实是需要预期的；这种平衡在上图的输出中也很容易识别，其中每个子域的度数大致相同。
*

*
* 值得注意的是，如果我们用不同数量的进程来运行同一个程序，我们可能会得到稍微不同的输出：不同的网格，不同的未知数和迭代收敛的次数。其原因是，虽然矩阵和右手边是相同的，不受所用进程数量的影响，但预处理程序不是：它对每个处理器的[2.x.108]矩阵块分别执行ILU(0)[2.x.109]。因此，随着进程数的增加，它作为预处理程序的有效性会降低，这使得迭代次数增加。由于不同的预处理程序导致计算出的解有细微的变化，这将导致细化时标记的网格单元略有不同，在随后的步骤中差异更大。不过，解决方案看起来总是非常相似的。
*

*
* 最后，这里是3D模拟的一些结果。你可以通过改变以下内容来重复这些结果
* [1.x.126]
* 改为
* [1.x.127]
* 在主函数中。然后，如果你并行运行该程序，你会得到类似这样的结果（这是针对有16个进程的工作）。
* [1.x.128]
*
*

*
* 最后一步，达到150万个未知数，在8台双处理器机器（2003年可用的那种）上使用16个进程，大约需要55分钟。这项工作产生的图形输出相当大（第5周期已经打印了大约82MB的数据），所以我们要显示第4周期的输出。
* [2.x.110]
*


* 左图显示的是将立方体划分为16个过程，右图显示的是沿两个切面通过立方体的X位移。
*


* [1.x.129][1.x.130][1.x.131] 。
*

* 该程序在每个处理器上都保留一份三角形和DoFHandler对象的完整副本。它还创建了解决方案向量的完整副本，并且只在一个处理器上创建输出。就并行化而言，所有这些显然都是瓶颈。
* 在内部，在deal.II中，分级和非结构化三角计算中使用的数据结构的并行化是一个困难的问题，我们花了几年时间才实现了这一点。[2.x.111]教程程序和[2.x.112]文档模块讲述了如何完成这些步骤，以及从应用角度来看需要做什么。当前程序的一个明显的扩展是使用这个功能将计算完全分配给比这里更多的处理器。
*

* [1.x.132][1.x.133] [2.x.113]。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-18_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37]
*[1.x.38][1.x.39][1.x.40] 。


*
* 这个教程程序是我们在[2.x.2]和[2.x.3]已经开始的弹性问题系列中的另一个。它将其扩展到两个不同的方向：首先，它用拉格朗日网格移动方法解决了大变形的准静态但随时间变化的弹性问题。其次，它展示了一些使用PETSc线性代数的%并行处理来解决此类问题的更多技术。除此之外，我们还展示了如何解决[2.x.4]中两个主要瓶颈中的一个，即我们只从一个进程中生成图形输出，而这在更多的进程和大型问题上的扩展性非常差。另一个瓶颈，即每个处理器都必须持有整个网格和DoFHandler，已在[2.x.5]中解决。最后，我们还展示了一些在以前的程序中没有展示过的各种改进和技术。
* 正如之前在[2.x.6]中所说，只要你安装了PETSc，程序在单机上的运行也是一样的。关于如何让deal.II知道你的系统上安装了PETSc的信息可以在deal.IIREADME文件中找到，该文件在你安装deal.II的[1.x.41]中被链接到，或者在[1.x.42]中被链接。
*

*[1.x.43][1.x.44]


*[1.x.45][1.x.46]


* 一般来说，随时间变化的小弹性变形由弹性波方程[1.x.47]描述，其中[2.x.7]是体的变形，[2.x.8]和[2.x.9]是密度和衰减系数，以及[2.x.10]外力。此外，为了得到唯一的解，需要指定初始条件[1.x.48]和Dirichlet（位移）或Neumann（牵引）边界条件：[1.x.49] 。
* 在上述公式中，[2.x.11]是位移的对称梯度，也称为[2.x.12] 应变[2.x.13]。  [2.x.14]是一个等级为4的张量，称为[2.x.15]应力-应变张量[2.x.16]（是[1.x.50]的逆值）。])，它包含了材料弹性强度的知识；它的对称性属性确保它将秩为2的对称张量(&ldquo;矩阵&rdquo;的维数[2.x.17]，其中[2.x.18]是空间维数)映射到相同秩的对称张量上。我们将在下面更多地评论应变和应力张量的作用。目前，我们只需说，我们将术语[2.x.19]解释为具有成分[2.x.20]的向量，其中对指数[2.x.21]的求和是隐含的。
* 这个方程的准静态极限的动机如下：身体的每个小的扰动，例如边界条件或加强函数的变化，将导致身体配置的相应变化。一般来说，这将是以波的形式从扰动的位置辐射出去。由于阻尼项的存在，这些波将在例如[2.x.22]的时间尺度上被减弱。现在，假设所有外部强制力的变化发生在比[2.x.23]大得多的时间尺度上。在这种情况下，变化的动态性质并不重要：我们可以认为身体总是处于静态平衡状态，即我们可以假定在任何时候身体都满足[1.x.51] 。
* 注意该微分方程不再包含任何时间导数。
*
* 所有的时间依赖性是通过边界条件和可能的时间变化的力函数引入的 [2.x.24] 。因此，不配置的变化可以被认为是同时静止的。另一种观点认为，[2.x.25]并不是真正的时间变量，而只是一个支配问题演变的类似时间的参数。
* 虽然这些方程足以描述小的变形，但计算大的变形要复杂一些，一般来说，会导致非线性方程，如[2.x.26]中处理的那些。在下文中，让我们考虑在模拟变形成为[1.x.52]的问题时，我们会使用一些工具。
* [2.x.27] 我们下面要考虑的模型并不是建立在任何数学上合理的基础上：我们将考虑一个模型，其中我们产生一个小的变形，通过这个变形使物体的物理坐标变形，然后再考虑下一个加载步骤作为一个线性问题。这是不一致的，因为线性的假设意味着变形是无限小的，所以在解决下一个线性问题之前，在我们的网格顶点上移动一个有限的量是一个不一致的方法。因此，我们应该注意到，下面讨论的方程在文献中找不到并不奇怪。[1.x.53] 另一方面，我们所考虑的实现技术正是人们在实现[1.x.54]模型时需要用到的，我们将在[2.x.28]中看到。
*

* 为了回到定义我们的 "人工 "模型，让我们首先引入一个张量的应力变量[2.x.29]，并以应力为条件写出微分方程：[1.x.55] 。
* 注意，这些方程是在一个随时间变化的域[2.x.30]上提出的，边界根据边界上各点的位移[2.x.31]而移动。为了完成这个系统，我们必须指定应力和应变之间的增量关系，如下所示：[1.x.56][1.x.57]其中一个点表示时间导数。应力[2.x.32]和应变[2.x.33]都是等级2的对称张量。
*

*[1.x.58][1.x.59]


* 在数值上，该系统的求解方法如下：首先，我们使用后向欧拉方案对时间部分进行离散化。这导致了时间步长[2.x.34]的力的离散平衡：[1.x.60]其中[1.x.61]和[2.x.35]是时间步长[2.x.36]的增量位移。此外，我们必须指定初始数据[2.x.37]。这样，如果我们想解决位移增量，我们必须解决以下系统。
* [1.x.62]
* 这组方程的弱形式，像往常一样是无限元公式的基础，其内容如下：找到[2.x.38]，使[1.x.63]。
* [1.x.64]
*利用[2.x.39]，这些方程可以简化为
* [1.x.65]
*
* 我们注意到，为了简单起见，在程序中我们总是假设没有边界力，即[2.x.40]，并且身体的变形仅由身体力[2.x.41]和规定的边界位移[2.x.42]驱动。还值得注意的是，当通过部分积分时，我们会得到形式为[2.x.43]的条款，但我们用涉及对称梯度的条款[2.x.44]而不是[2.x.45]取代它们。由于[2.x.46]的对称性，这两个项在数学上是等价的，但对称版本避免了可能出现的四舍五入错误，使所得矩阵略显非对称性。
* 时间步长[2.x.47]的系统将在旧域[2.x.48]上求解，其形式完全是一个静止的弹性问题，因此与我们在以前的示例程序中已经实现的类似。因此，除了说我们再次使用最低阶连续有限元之外，我们将不对空间离散化进行评论。
* 然而，也有不同之处。[2.x.49] [2.x.50] 我们必须在每个时间步骤之后移动（更新）网格，以便能够在新的领域上解决下一个时间步骤。
* [2.x.51] 我们需要知道[2.x.52]来计算下一个增量位移，也就是说，我们需要在时间步长结束时计算它，以确保它在下一个时间步长可用。从本质上讲，应力变量是我们了解体的变形历史的窗口。[2.x.53] 这两个操作在程序中的[2.x.54]和[2.x.55]函数中完成。移动网格只是一个技术问题，更新应力则要复杂一些，将在下一节讨论。
*

*[1.x.66][1.x.67]


* 如上所述，在计算时间步长[2.x.57]时，我们需要有应力变量[2.x.56]，我们可以用[1.x.68][1.x.69]来计算，尽管这个方程明显很简单，但有两个问题我们需要讨论。第一个问题是关于我们存储[2.x.58]的方式：即使我们使用最低阶无限元素计算增量更新[2.x.59]，那么它的对称梯度[2.x.60]一般仍然是一个不容易描述的函数。特别是，它不是一个片状常数函数，在一般的网格上（单元不是平行于坐标轴的矩形）或非恒定应力-应变张量[2.x.61]，它甚至不是一个双线性或三线性函数。因此，如何在计算机程序中存储[2.x.62]是一个先验的问题。
* 要决定这一点，我们必须看看它在哪里被使用。唯一需要强调的地方是在术语[2.x.63]中。在实践中，我们当然会用数字正交代替这个术语：[1.x.70]其中[2.x.64]是正交权重，[2.x.65]是单元格[2.x.66]上的正交点。这应该表明，我们真正需要的不是应力[2.x.67]本身，而只是所有单元上的正交点的应力值。然而，这是一个更简单的任务：我们只需要提供一个数据结构，能够为所有单元上的每个正交点容纳一个等级为2的对称张量（或者，因为我们是并行计算，所以是目前MPI进程拥有的所有单元的正交点）。在每个时间步骤结束时，我们只需评估[2.x.68]，将其乘以应力-应变张量[2.x.69]，并使用该结果来更新正交点[2.x.71]的应力[2.x.70]。
* 第二个复杂情况在我们上面选择的符号中是不可见的。这是由于我们在域[2.x.73]上计算了[2.x.72]，然后用这个位移增量来更新应力，并移动网格节点，以获得[2.x.74]，在此基础上计算下一个增量。在这种情况下，我们必须确定的是，移动网格不仅涉及到节点的移动，而且还涉及到应力变量的相应变化：更新的应力是一个相对于旧域中材料的坐标系而定义的变量，必须转移到新域中。其原因可以理解为：在局部，增量变形[2.x.75]可以分解为三个部分：线性平移（点附近的位移增量场的常数部分）、倾斜分量（位移场梯度中发散为零的那一部分）和旋转。材料的线性平移并不影响冻结在其上的应力。
*
* 应力值被简单地沿线平移。扩张或压缩的变化产生相应的应力更新。然而，旋转分量并不一定会引起非零的应力更新（想想，在2d中，例如[2.x.76]的情况，[2.x.77]的情况）。尽管如此，如果材料在某一方向上受到预应力，那么这一方向将随着材料的旋转而旋转。  为此，我们必须定义一个旋转矩阵[2.x.78]，描述每个点由于位移增量而产生的旋转。不难看出，[2.x.79]对[2.x.80]的实际依赖可以通过位移的卷曲，而不是位移本身或其全部梯度（如上所述，增量的常数分量描述平移，其发散描述扩张模式，而卷曲描述旋转模式）。由于[2.x.81]的确切形式很麻烦，我们只在程序代码中说明，并注意到应力变量的正确更新公式是[1.x.71][1.x.72] 。
* 应力更新和旋转都在示例程序的函数[2.x.82]中实现。
*

*[1.x.73][1.x.74]


* 在[2.x.83]中，就运行时间而言，%并行计算的主要瓶颈是只有第一个处理器产生整个领域的输出。由于产生图形输出是昂贵的，当涉及到更多的处理器时，这并不能很好地扩展。我们将在这里解决这个问题。关于程序 "扩展 "的定义，见[2.x.84]"本词汇表条目"）。
* 基本上，我们需要做的是让每个进程为其拥有的单元格子集生成图形输出，将其写入单独的文件，并有办法在同一时间显示某个时间段的所有文件。这样，代码在每个时间步骤的每个进程中产生一个[2.x.85]文件。两个常见的VTK文件查看器ParaView和Viscit都支持一次打开一个以上的[2.x.86]文件。为了简化挑选正确文件的过程，并允许在时间上移动，两者都支持记录文件，以引用给定时间步长的所有文件。不幸的是，记录文件在VisIt和Paraview之间有不同的格式，所以我们写出了两种格式。
* 代码将生成文件[2.x.87]，其中[2.x.88]是时间步数（从1开始），[2.x.89]是进程等级（从0开始）。这些文件包含本地拥有的时间段和进程的单元。文件[2.x.90]是时间段的访问记录[2.x.91]对ParaView也是如此。较新版本的VisIt实际上也可以读取[2.x.92]文件，但输出这两种记录文件也无妨）。最后，[2.x.93]文件是只有ParaView支持的特殊记录，它引用所有的时间步骤。所以在ParaView中，只需要打开solution.pvd，而在VisIt中则需要选择所有的.visit文件组来达到同样的效果。
*

*[1.x.75][1.x.76]


* 在[2.x.94]中，我们使用了一个在每个处理器上简单复制的常规三角形，以及一个相应的DoFHandler。两者都不知道它们是在%并行环境下使用的。
*
* 他们只是完整地存在于每个处理器上，我们认为这最终会成为一个主要的内存瓶颈。
* 我们在这里没有解决这个问题（我们将在[2.x.95]中解决这个问题），但使情况稍微自动化一些。在[2.x.96]中，我们创建了三角形，然后手动 "分区"，也就是说，我们为每个单元分配了[2.x.97]"子域ID"，表明哪个[2.x.98]"MPI进程 "拥有该单元。在这里，我们使用了一个[2.x.99]类，它至少自动完成了这一部分：每当你创建或改进这样一个三角形时，它都会自动在所有参与的进程之间进行划分（它知道这些进程，因为你必须告诉它在构建三角形时连接这些进程的[2.x.100]"MPI通信器"），否则，[2.x.101]看起来，就所有实际目的而言，就像一个普通的三角形对象。
* 使用这个类的便利性不仅来自于能够避免手动调用[2.x.102]，相反，DoFHandler类现在也知道你想在并行环境中使用它，并且默认情况下自动列举自由度，使进程0拥有的所有DoF先于进程1拥有的所有DoF，等等。换句话说，你也可以避免对[2.x.103]的调用。
* 还有其他好处。例如，因为三角计算知道它生活在一个%的平行宇宙中，它也知道它 "拥有 "某些单元（即那些子域ID等于其MPI等级的单元；以前，三角计算只存储这些子域ID，但没有办法使它们有意义）。因此，在汇编函数中，当你使用语法循环所有单元时，你无法测试一个单元是否为 "本地所有"（即，由当前进程拥有，见[2.x.104]）。
* [1.x.77]
* 这种知识延伸到建立在这种三角形上的DoFHandler对象，它可以通过[2.x.106]和[2.x.107]等调用来识别哪些自由度是本地拥有的（见[2.x.105]）。 最后，DataOut类也知道如何处理这种三角形，并将简单地跳过在非本地拥有的单元上生成图形输出。
* 当然，正如在[2.x.108]的讨论中多次指出的那样，在每个进程中保留整个三角计算是无法扩展的：大型问题可能根本无法容纳每个进程的内存，即使我们有足够多的进程可以在合理的时间内解决它们。在这种情况下，[2.x.109]不再是合理的计算基础，我们将在[2.x.110]中展示如何使用[2.x.111]类来解决这个问题，即让每个进程只存储三角形的一个[1.x.78]。
*

*[1.x.79][1.x.80]


* 程序的整体结构可以从[2.x.112]函数中推断出来，该函数首先在第一个时间步调用[2.x.113]，然后在所有后续时间步调用[2.x.114]。这些函数之间的区别仅仅在于，在第一个时间步中，我们在一个粗略的网格上启动，对其进行求解，自适应地细化网格，然后在新的网格上以一个干净的状态再次启动。这个过程给了我们一个更好的起始网格，尽管我们当然应该在迭代过程中不断调整网格。
*
* - 这不是在这个程序中做的，而是在下面评论的。
* 这两个处理时间步长的函数的共同部分是对当前网格进行以下操作的序列。[2.x.115] [2.x.116] [2.x.117] ] 。  这第一个函数也是最有趣的一个。它集合了对应于方程[1.x.81]离散化版本的线性系统。这导致系统矩阵[2.x.118]由每个单元[2.x.119]上的局部贡献组成，其条目为[1.x.82] 在实践中，[2.x.120]是根据公式[1.x.83]用正交点[2.x.121]和权重[2.x.122]的数值正交计算的。我们以前在[2.x.123]和[2.x.124]中建立过这些贡献，但在这两种情况下，我们都是通过使用等级4张量[2.x.125]的组成知识，并考虑应变张量[2.x.126]的单个元素，相当笨拙地完成的。这其实并不方便，特别是如果我们想考虑比各向同性的情况更复杂的弹性模型，而[2.x.127]有方便的形式 [2.x.128] 。虽然我们在本程序中实际上没有使用比这更复杂的形式，但我们还是希望以一种容易实现的方式来编写它。因此，很自然地引入代表等级为2（用于应变和应力）和4（用于应力-应变张量[2.x.129]）的对称张量的类。幸运的是，deal.II提供了这些：[2.x.130]类模板提供了等级[2.x.131]（需要是偶数）和维度[2.x.132]的这类张量的完整实现。
* 然后我们需要的是两件事：一种创建应力-应变等级4张量[2.x.133]的方法，以及从给定单元上正交点[2.x.135]的形状函数[2.x.134]的梯度创建一个等级2的对称张量（应变张量）。在这个例子程序的执行顶部，你会发现这样的函数。第一个，[2.x.136] ，接受两个参数，对应于Lam&eacute;常数[2.x.137]和[2.x.138]，并返回对应于这些常数的各向同性的应力-应变张量（在程序中，我们将选择对应于钢的常数）；用一个计算各向异性的张量的函数来代替这个函数是很简单的，或者考虑到晶体对称性，例如。第二个，[2.x.139]和指数[2.x.140]和[2.x.141]，并返回对称梯度，即应变，对应于形状函数[2.x.142]，在[2.x.143]对象最后被重新初始化的单元上评估。
* 鉴于此，[2.x.144]的最内部循环以下列优雅的方式计算对矩阵的局部贡献（变量[2.x.145]，对应于张量[2.x.146]，先前已用上述第一个函数的结果初始化）。
* [1.x.84]
* 值得注意的是这段代码的表达能力，并将其与我们在以前的例子中为弹性问题所经历的复杂情况进行比较。公平地说，在写这些以前的例子时，SymmetricTensor类模板还不存在）。为了简单起见，[2.x.147]在这里规定了偶数等级的对称张量之间的（双重求和）乘积。
* 将局部贡献[1.x.85]组装起来。
* 到[1.x.86]的右手边也同样简单（注意，我们在这里不考虑任何边界牵引[2.x.148]）。请记住，我们只需要在单元格的正交点上存储旧的应力。在程序中，我们将提供一个变量[2.x.149]，允许访问每个正交点的应力[2.x.150]。有了这个，右手边的代码看起来就像这样，同样相当优雅。
* [1.x.87]
* 请注意，在乘法[2.x.151]中，我们利用了这样一个事实：对于所选择的有限元，[2.x.153]中只有一个矢量分量（即[2.x.152]）是非零的，因此我们也只需要考虑[2.x.154]的一个分量。
* 这基本上结束了我们在这个函数中提出的新材料。它后来必须处理边界条件以及悬挂节点约束，但这与我们以前在其他程序中已经要做的事情相类似。
* [2.x.155] [2.x.156] ] 。  与前一个不同，这个函数并不真正有趣，因为它做的是以前所有教程程序中的类似函数
*
* - 使用CG方法求解线性系统，使用不完整的LU分解作为预处理程序（在%并行的情况下，它分别使用每个处理器的块的ILU）。它与 [2.x.157] 几乎没有变化。
* [2.x.158] [2.x.159] [通过[2.x.160] ] 。基于之前计算的位移场[2.x.161]，我们根据[1.x.88]和[1.x.89]更新所有正交点的应力值，包括坐标系的旋转。
* [2.x.162] [2.x.163] ：给定之前计算的解决方案，在这个函数中，我们通过移动每个顶点的位移矢量场来实现网格的变形。
* [2.x.164] [2.x.165] : 这个函数只是根据我们上面所说的输出解决方案，也就是说，每个处理器只对自己的那部分领域进行计算输出。除了解决方案之外，我们还计算每个单元上所有正交点平均的应力的规范。[2.x.166]
* 有了这个代码的一般结构，我们只需要定义我们要解决的情况。在本程序中，我们选择模拟一个垂直圆柱体的静态变形，其底部边界是固定的，顶部边界以规定的垂直速度被推倒。然而，顶层边界的水平速度却没有被指定。
*
* 我们可以把这种情况想象成一块油性良好的板从顶部推到圆柱体上，圆柱体顶部边界上的点被允许沿着板的表面水平滑动，但被板强迫向下移动。圆柱体的内部和外部边界是自由的，不受任何规定的偏转或牵引的影响。此外，重力作用在身体上。
* 程序文本将揭示更多关于如何实现这种情况，而结果部分将显示这种模拟产生的位移模式。
*

* [1.x.90] [1.x.91]。
* 首先是通常的头文件列表，这些文件已经在以前的示例程序中使用过了。
*


* [1.x.92]
*
* 这里是头文件中仅有的三个新东西：一个包含文件，其中实现了秩2和秩4的对称张量，正如介绍中所介绍的。
*


* [1.x.93]
*
* 最后是一个头，包含一些函数，这些函数将帮助我们计算域中特定点的局部坐标系的旋转矩阵。
*


* [1.x.94]
*
* 这就又是简单的C++。
*


* [1.x.95]

* 最后一步和以前的所有程序一样。



* [1.x.96]
*
* [1.x.97] [1.x.98]。


*
* 正如在介绍中提到的，我们必须在正交点中存储旧的应力，以便在下一个时间步骤中计算该点的残余力。仅仅这一点还不能保证只有一个构件的结构，但在更复杂的应用中，我们还必须在正交点存储更多的信息，如塑性的历史变量等。实质上，我们必须在这里存储所有影响材料当前状态的信息，在塑性中，这是由变形历史变量决定的。   
* 除了能够存储数据之外，我们不会给这个类任何有意义的功能，也就是说，没有构造函数、析构函数或其他成员函数。在这种 "哑巴 "类的情况下，我们通常选择将其声明为[2.x.167]，以表明它们更接近于C语言风格的结构而不是C++风格的类。
*


* [1.x.99]
*
* [1.x.100] [1.x.101]。


*
* 接下来，我们定义弹性中的应力和应变的线性关系。它由一个等级为4的张量给出，通常写成 [2.x.168] 的形式。这个张量将等级2的对称张量映射到等级2的对称张量。对于Lam&eacute;常数[2.x.169]和[2.x.170]的给定值，一个实现其创建的函数是直接的。
*


* [1.x.102]
*
* 通过这个函数，我们将在下面的主类中定义一个静态成员变量，在整个程序中作为应力-应变张量使用。请注意，在更复杂的程序中，这可能是某个类的成员变量，或者是一个根据其他输入返回应力-应变关系的函数。例如，在损伤理论模型中，Lam&eacute;常数被认为是一个点的先前应力/应变历史的函数。相反，在塑性中，如果材料在某一点达到了屈服应力，那么应力-应变张量的形式就会被修改，而且可能还取决于其先前的历史。   
* 然而，在本方案中，我们假设材料是完全弹性和线性的，恒定的应力-应变张量对我们目前的目的是足够的。
*




*


* [1.x.103] [1.x.104]。



* 在程序的其他部分之前，这里有几个我们需要的函数作为工具。这些是在内循环中调用的小函数，所以我们把它们标记为 [2.x.171] 。   
* 第一个是通过形成这个形状函数的对称梯度来计算形状函数[2.x.172]的对称应变张量。例如，当我们要形成矩阵时，我们需要这个。   
* 我们应该注意到，在以前处理矢量值问题的例子中，我们总是问有限元对象在哪个矢量分量中的形状函数实际上是不为零的，从而避免计算任何我们反正可以证明为零的项。为此，我们使用了[2.x.173]函数，该函数返回形状函数在哪个分量中为零，同时[2.x.174]和[2.x.175]函数只返回形状函数的单个非零分量的值和梯度，如果这是一个矢量值元素。   
* 这是一个优化，如果不是非常关键的时间，我们可以用一个更简单的技术来解决：只要向[2.x.176]询问给定形状函数的给定分量在给定正交点的值或梯度。这就是[2.x.177]调用的作用：返回形状函数[2.x.179]的[2.x.178]分量在正交点[2.x.180]的全部梯度。如果某个形状函数的某个分量总是为零，那么这将简单地总是返回零。   
* 如前所述，使用[2.x.181]而不是[2.x.182]和[2.x.183]的组合可能效率较低，但其实现已针对这种情况进行了优化，应该不会有很大的减慢。我们在这里演示这个技术，因为它是如此的简单和直接。
*


* [1.x.105]
*
* 声明一个将保存返回值的临时。
*


* [1.x.106]
*
* 首先，填充对角线项，这只是矢量值形状函数的方向[2.x.184]分量的导数。
*


* [1.x.107]
*
* 然后填充应变张量的其余部分。注意，由于张量是对称的，我们只需要计算一半（这里：右上角）的非对角线元素，[2.x.185]类的实现可以确保至少到外面的对称条目也被填充（实际上，该类当然只存储一份）。在这里，我们选择了张量的右上半部分，但左下半部分也一样好。
*


* [1.x.108]
*
* 第二个函数做了非常类似的事情（因此被赋予相同的名字）：从一个矢量值场的梯度计算对称应变张量。如果你已经有了一个解场，[2.x.186]函数允许你在正交点提取解场的每个分量的梯度。它返回的是一个秩-1张量的矢量：解的每个矢量分量有一个秩-1张量（梯度）。由此，我们必须通过转换数据存储格式和对称化来重建（对称的）应变张量。我们以与上面相同的方式来做，也就是说，我们通过首先填充对角线，然后只填充对称张量的一半来避免一些计算（[2.x.187]类确保只写两个对称分量中的一个即可）。   
* 不过在这之前，我们要确保输入有我们期望的那种结构：即有[2.x.188]矢量分量，即每个坐标方向有一个位移分量。我们用[2.x.189]宏来测试这一点，如果不满足条件，我们的程序就会被终止。
*


* [1.x.109]
*
* 最后，下面我们将需要一个函数来计算某一点的位移所引起的旋转矩阵。当然，事实上，单点的位移只有一个方向和一个幅度，正是方向和幅度的变化诱发了旋转。实际上，旋转矩阵可以从位移的梯度计算出来，或者更具体地说，从卷曲计算出来。   
* 确定旋转矩阵的公式有点笨拙，特别是在三维中。对于2D来说，有一个更简单的方法，所以我们实现了这个函数两次，一次用于2D，一次用于3D，这样我们就可以在两个空间维度上编译和使用这个程序，如果需要的话
*
* 毕竟，deal.II是所有关于独立维度的编程和重用算法的，在2D的廉价计算中进行了彻底的测试，在3D的更昂贵的计算中进行了测试。这里有一个例子，我们必须为2D和3D实现不同的算法，但可以用独立于空间维度的方式来编写程序的其他部分。   
* 因此，不再赘述2D的实现。
*


* [1.x.110]
*
* 首先，根据梯度计算出速度场的卷曲。注意，我们是在2d中，所以旋转是一个标量。
*


* [1.x.111]
*
*由此，计算出旋转的角度。
*


* [1.x.112]
*
* 并由此建立反对称的旋转矩阵。我们希望这个旋转矩阵能够代表本地坐标系相对于全局直角坐标系的旋转，因此我们用一个负的角度来构建它。因此，旋转矩阵代表了从局部坐标系移动到全局坐标系所需的旋转。
*


* [1.x.113]

* 3d的情况就比较复杂了。
*


* [1.x.114]
*
* 同样首先计算速度场的卷曲。这一次，它是一个实向量。
*


* [1.x.115]
*
* 从这个矢量，利用它的大小，计算旋转角度的正切，并从它计算出相对于直角坐标系的实际旋转角度。
*


* [1.x.116]
*
* 现在，这里有一个问题：如果旋转角度太小，那就意味着没有旋转发生（比如说平移运动）。在这种情况下，旋转矩阵就是身份矩阵。     
* 我们强调这一点的原因是，在这种情况下，我们有那个[2.x.190]。再往下看，我们在计算旋转轴的时候需要除以这个数字，这样做除法的时候会遇到麻烦。因此，让我们走捷径，如果旋转角度真的很小，就简单地返回同一矩阵。
*


* [1.x.117]
*
* 否则就计算出真实的旋转矩阵。为此，我们再次依靠一个预定义的函数来计算本地坐标系的旋转矩阵。
*


* [1.x.118]
*
* [1.x.119] [1.x.120]。


*
* 这是该程序的主类。由于命名空间已经表明了我们要解决的问题，让我们用它的作用来称呼它：它引导着程序的流程，也就是说，它是顶层驱动。   
* 这个类的成员变量基本上和以前一样，即它必须有一个三角形，一个DoF处理程序和相关的对象，如约束、描述线性系统的变量等。现在还有不少成员函数，我们将在下面解释。   
* 然而，该类的外部接口是不变的：它有一个公共的构造函数和析构函数，并且它有一个[2.x.191]函数来启动所有的工作。
*


* [1.x.121]
*
* 私有接口比 [2.x.192] 中的更广泛。首先，我们显然需要创建初始网格的函数，设置描述当前网格上的线性系统的变量（即矩阵和向量），然后是实际组装系统的函数，指导每个时间步长中必须解决的问题，一个解决每个时间步长中出现的线性系统的函数（并返回它的迭代次数），最后输出正确网格上的解向量。
*


* [1.x.122]
*
* 除了前两个，所有这些函数都在每个时间步中被调用。由于第一个时间步骤有点特殊，我们有单独的函数来描述在一个时间步骤中必须发生的事情：一个用于第一个时间步骤，一个用于所有后续时间步骤。
*


* [1.x.123]
*
* 然后我们需要一大堆的函数来做各种事情。第一个是细化初始网格：我们从原始状态的粗网格开始，解决这个问题，然后看一下，并相应地细化网格，然后重新开始同样的过程，再次以原始状态开始。因此，细化初始网格比在两个连续的时间步骤之间细化网格要简单一些，因为它不涉及将数据从旧的三角测量转移到新的三角测量，特别是存储在每个正交点的历史数据。
*


* [1.x.124]
*
* 在每个时间步骤结束时，我们要根据这个时间步骤计算的增量位移来移动网格顶点。这就是完成这个任务的函数。
*


* [1.x.125]
*
* 接下来是两个处理存储在每个正交点的历史变量的函数。第一个函数在第一个时间步长之前被调用，为历史变量设置一个原始状态。它只对属于当前处理器的单元上的正交点起作用。
*


* [1.x.126]
*
* 第二个是在每个时间段结束时更新历史变量。
*


* [1.x.127]

* 这是新的共享三角法。
*


* [1.x.128]

* 这个程序的一个不同之处在于，我们在类声明中声明了正交公式。原因是在所有其他程序中，如果我们在计算矩阵和右手边时使用不同的正交公式，并没有什么坏处，比如说。然而，在目前的情况下，它确实如此：我们在正交点中存储了信息，所以我们必须确保程序的所有部分都同意它们的位置以及每个单元格上有多少个。因此，让我们首先声明整个程序将使用的正交公式......
*


* [1.x.129]
*
* ......然后也有一个历史对象的向量，在我们负责的单元上的每个正交点都有一个（也就是说，我们不为其他处理器拥有的单元上的正交点存储历史数据）。请注意，我们可以使用CellDataStorage类来代替我们自己存储和管理这些数据，就像在 [2.x.193] 中那样。然而，为了演示的目的，在这种情况下，我们手动管理存储。
*


* [1.x.130]

* 这个对象的访问方式是通过每个单元格、面或边持有的[2.x.194]：它是一个[2.x.195]指针，应用程序可以用它来将任意的数据关联到单元格、面或边上。程序对这些数据的实际操作属于自己的职责范围，库只是为这些指针分配了一些空间，而应用程序可以设置和读取这些对象中的每个指针。
*



* 更进一步：我们需要要解决的线性系统的对象，即矩阵、右手边的向量和解向量。由于我们预计要解决大问题，我们使用与[2.x.196]中相同的类型，即建立在PETSc库之上的分布式%并行矩阵和向量。方便的是，它们也可以在只在一台机器上运行时使用，在这种情况下，这台机器正好是我们的%并行宇宙中唯一的机器。     
* 然而，与[2.x.197]不同的是，我们不存储解向量。
*
* - 这里是在每个时间步骤中计算的增量位移
*
* - 以分布式的方式。也就是说，在计算时它当然必须是一个分布式矢量，但紧接着我们确保每个处理器都有一个完整的副本。原因是我们已经在[2.x.198]中看到，许多函数需要一个完整的副本。虽然得到它并不难，但这需要在网络上进行通信，因此很慢。此外，这些都是重复的相同操作，这当然是不可取的，除非不必总是存储整个向量的收益超过了它。在编写这个程序时，事实证明，我们在很多地方都需要一份完整的解决方案，以至于只在必要时才获得它似乎不值得。相反，我们选择一劳永逸地获得完整的副本，而立即摆脱分散的副本。因此，请注意，[2.x.199]的声明并没有像中间命名空间[2.x.200]所表示的那样表示一个分布式向量。
*


* [1.x.131]
*
* 接下来的变量块与问题的时间依赖性有关：它们表示我们要模拟的时间间隔的长度，现在的时间和时间步数，以及现在时间步数的长度。
*


* [1.x.132]
*
* 然后是几个与%并行处理有关的变量：首先，一个变量表示我们使用的MPI通信器，然后是两个数字，告诉我们有多少个参与的处理器，以及我们在这个世界上的位置。最后，一个流对象，确保只有一个处理器实际产生输出到控制台。这与 [2.x.201] 中的所有内容相同。
*


* [1.x.133]

* 我们正在存储本地拥有的和本地相关的指数。
*


* [1.x.134]

* 最后，我们有一个静态变量，表示应力和应变之间的线性关系。由于它是一个不依赖任何输入的常量对象（至少在这个程序中不依赖），我们把它作为一个静态变量，并将在我们定义这个类的构造函数的同一个地方初始化它。
*


* [1.x.135]
*
* [1.x.136] [1.x.137]。


*
* 在我们进入这个程序的主要功能之前，我们必须定义哪些力将作用在我们想要研究的变形的体上。这些力可以是体力，也可以是边界力。体力通常是由四种基本的物理力类型之一所介导的：重力、强弱相互作用和电磁力。除非人们想考虑亚原子物体（对于这些物体，无论如何准静态变形是不相关的，也是不合适的描述），否则只需要考虑引力和电磁力。为了简单起见，让我们假设我们的身体有一定的质量密度，但要么是非磁性的，不导电的，要么周围没有明显的电磁场。在这种情况下，身体的力只是[2.x.202]是材料密度，[2.x.203]是一个负Z方向的矢量，大小为9.81米/秒^2。  密度和[2.x.204]都是在函数中定义的，我们把7700 kg/m^3作为密度，这是对钢通常假定的值。   
* 为了更普遍一点，也为了能够在2d中进行计算，我们意识到体力总是一个返回[2.x.205]维矢量的函数。我们假设重力沿着最后一个坐标的负方向作用，即[2.x.206]个坐标。考虑到以前的例子程序中的类似定义，这个函数的其余实现应该大部分是不言自明的。请注意，体力与位置无关；为了避免编译器对未使用的函数参数发出警告，我们因此注释了[2.x.207]函数的第一个参数的名称。
*


* [1.x.138]
*
* [1.x.139] [1.x.140]。



* 除了身体的力之外，运动还可以由边界力和强制边界位移引起。后一种情况相当于以这样一种方式选择力，使其诱发某些位移。   
* 对于准静态位移，典型的边界力是对身体的压力，或对另一身体的切向摩擦。我们在这里选择了一个更简单的情况：我们规定了边界（部分）的某种运动，或者至少是位移矢量的某些分量。我们用另一个矢量值函数来描述这一点，对于边界上的一个给定点，返回规定的位移。   
* 由于我们有一个随时间变化的问题，边界的位移增量等于在时间段内累积的位移。因此，这个类必须知道现在的时间和现在时间步长，然后可以将位移增量近似为现在的速度乘以现在的时间步长。   
* 在本程序中，我们选择一种简单的边界位移形式：我们以恒定的速度向下位移顶部的边界。边界的其余部分要么是固定的（然后用[2.x.208]类型的对象来描述），要么是自由的（Neumann类型，在这种情况下不需要做什么特别的事情）。  然后，利用我们通过之前所有的例子程序获得的知识，描述持续向下运动的类的实现应该是很明显的。
*


* [1.x.141]
*
* [1.x.142] [1.x.143]。


*
* 现在是主类的实现。首先，我们初始化应力-应变张量，我们将其声明为一个静态常量变量。我们选择了适合于钢铁的Lam&eacute;常数。
*


* [1.x.144]
*
* [1.x.145] [1.x.146]。


*
* 下一步是构造函数和析构函数的定义。这里没有什么惊喜：我们为解决方案的每个[2.x.209]矢量分量选择线性和连续的有限元，以及每个坐标方向上有2个点的高斯正交公式。解构器应该是很明显的。
*


* [1.x.147]
*
* 最后一个公共函数是指导所有工作的函数， [2.x.210] 。它初始化了描述我们目前所处时间位置的变量，然后运行第一个时间步长，然后在所有其他时间步长上循环。请注意，为了简单起见，我们使用一个固定的时间步长，而一个更复杂的程序当然要以某种更合理的方式自适应地选择它。
*


* [1.x.148]
*
* [1.x.149] [1.x.150]。


*
* 按照上面声明的顺序，下一个函数是创建粗略网格的函数，我们从这里开始。在这个例子中，我们想计算一个圆柱体在轴向压缩下的变形。因此第一步是生成一个长度为3，内外半径分别为0.8和1的圆柱体的网格。幸运的是，有一个库函数可以生成这样的网格。   
* 第二步，我们必须将边界条件与圆柱体的上下两个面联系起来。我们为边界面选择一个边界指标0，其特征是中点的Z坐标为0（底面），指标1为Z=3（顶面）；最后，我们对圆柱体外壳内部的所有面使用边界指标2，外部使用3。
*


* [1.x.151]
*
* 一旦所有这些都完成了，我们就可以在全球范围内细化一次网格。
*


* [1.x.152]
*
* 作为最后一步，我们需要设置一个干净的数据状态，我们将这些数据存储在目前处理器上处理的所有单元上的正交点。
*


* [1.x.153]
*
* [1.x.154] [1.x.155]。


*
* 下一个函数是为一个给定的网格设置数据结构。这与[2.x.211]中的方法基本相同：分配自由度，然后对这些自由度进行排序，使每个处理器得到一个连续的块。请注意，每个处理器的细分块是在创建或细化网格的函数中处理的，与之前的例子程序不同（发生这种情况的时间点主要是口味问题；在这里，我们选择在创建网格时进行，因为在[2.x.212]和[2.x.213]函数中，我们希望在还没有调用当前函数的时候输出每个处理器上的单元数量）。
*


* [1.x.156]
*
* 下一步是设置由于悬挂节点而产生的约束。这在以前已经处理过很多次了。
*


* [1.x.157]

* 然后我们要设置矩阵。这里我们偏离了 [2.x.214] ，在那里我们简单地使用了PETSc的能力，即只知道矩阵的大小，然后分配那些被写入的非零元素。虽然从正确性的角度来看，这样做很好，但是效率却不高：如果我们不给PETSc提供关于哪些元素被写入的线索，那么当我们第一次设置矩阵中的元素时（即在第一个时间步中），它就会慢得令人难以忍受。后来，当元素被分配后，一切都快多了。在我们所做的实验中，如果我们指示PETSc哪些元素将被使用，哪些不被使用，那么第一个时间步骤可以加快近两个数量级。     
* 要做到这一点，我们首先要生成我们要处理的矩阵的稀疏模式，并确保浓缩的悬挂节点约束在稀疏模式中增加必要的额外条目。
*


* [1.x.158]

* 请注意，我们在这里使用了[2.x.215]类，该类在[2.x.216]中已经介绍过，而不是我们在所有其他情况下使用的[2.x.217]类。其原因是，为了使后一个类发挥作用，我们必须给每一行的条目数提供一个初始的上限，这项任务传统上是由[2.x.218]完成。然而，这个函数有一个严重的问题：它必须计算每一行中非零项的数量的上限，而这是一个相当复杂的任务，特别是在3D中。实际上，虽然它在2D中相当准确，但在3D中经常得出太大的数字，在这种情况下，[2.x.219]一开始就分配了太多的内存，经常是几百MB。后来当[2.x.220]被调用时，我们意识到我们不需要那么多的内存，但这时已经太晚了：对于大问题，临时分配太多的内存会导致内存不足的情况。     
* 为了避免这种情况，我们采用了[2.x.221]类，它的速度较慢，但不需要对每行的非零条目数进行任何预先估计。因此，它在任何时候都只分配所需的内存，而且我们甚至可以为大型的三维问题建立它。     
* 值得注意的是，由于[2.x.222]的特殊性，我们构建的稀疏模式是全局性的，即包括所有的自由度，无论它们是属于我们所在的处理器还是另一个处理器（如果这个程序是通过MPI并行运行的%）。当然，这并不是最理想的
*
* 它限制了我们可以解决的问题的规模，因为在每个处理器上存储整个稀疏模式（即使只是短时间）的规模并不大。然而，在程序中还有几个地方我们是这样做的，例如，我们总是把全局三角测量和DoF处理对象保留在周围，即使我们只在其中的一部分工作。目前，deal.II没有必要的设施来完全分配这些对象（事实上，这项任务在自适应网格中很难实现，因为随着网格的自适应细化，领域的均衡分区往往会变得不均衡）。     
* 有了这个数据结构，我们就可以去找PETSc稀疏矩阵，告诉它预先分配所有我们以后要写的条目。
*


* [1.x.159]
*
* 在这一点上，不再需要对稀疏模式有任何明确的了解，我们可以让[2.x.223]这个变量超出范围，没有任何问题。
*

*
* 这个函数的最后一个任务是将右手边的向量以及解决方案向量重置为正确的大小；请记住，解决方案向量是一个本地向量，不像右手边是一个分布式的%并行向量，因此需要知道MPI通信器，它应该通过这个通信器来传输信息。
*


* [1.x.160]
*
* [1.x.161] [1.x.162]。


*
* 同样，组装系统矩阵和右手边的结构与之前许多例子程序的结构相同。特别是，它主要等同于[2.x.224]，除了不同的右手边，现在只需要考虑到内部应力。此外，通过使用[2.x.225]类，组装矩阵明显变得更加透明：请注意形成2级和4级对称张量的标量乘积的优雅性。这个实现也更加普遍，因为它与我们可能使用或不使用各向同性的弹性张量这一事实无关。   
* 汇编程序的第一部分和以往一样。
*


* [1.x.163]
*
* 如同在 [2.x.226] 中一样，我们只需要在属于当前处理器的所有单元中进行循环。
*


* [1.x.164]
*
* 然后在所有指数i,j和正交点上循环，从这个单元中组合出系统矩阵的贡献。  注意我们如何从[2.x.227]对象中提取给定正交点的形状函数的对称梯度（应变），以及我们如何优雅地形成三重收缩[2.x.228]；后者需要与[2.x.229]中需要的笨拙计算进行比较，无论是在介绍中还是在程序的相应位置。
*


* [1.x.165]
*
* 然后还要集合局部的右手边的贡献。为此，我们需要访问这个正交点的先验应力值。为了得到它，我们使用这个单元的用户指针，该指针指向全局数组中与目前单元的第一个正交点相对应的正交点数据，然后添加一个与我们目前考虑的正交点的索引相对应的偏移。
*


* [1.x.166]
*
*此外，我们需要这个单元上正交点的外体力值。
*


* [1.x.167]
*
* 然后我们可以在这个单元的所有自由度上进行循环，计算出对右手边的局部贡献。
*


* [1.x.168]
*
* 现在我们有了对线性系统的局部贡献，我们需要将其转移到全局对象中。这与[2.x.230]中的做法完全相同。
*


* [1.x.169]

* 现在压缩向量和系统矩阵。
*


* [1.x.170]
*
* 最后一步是再次修复边界值，就像我们在以前的程序中已经做的那样。一个稍微复杂的问题是，[2.x.231]函数希望有一个与矩阵和右手边兼容的求解向量（即这里是一个分布式%并行向量，而不是我们在这个程序中使用的顺序向量），以便用正确的边界值预设求解向量的条目。我们以临时向量的形式提供这样一个兼容向量，然后将其复制到顺序向量中。
*

*
* 我们通过展示边界值的灵活使用来弥补这种复杂性：按照我们创建三角形的方式，有三个不同的边界指标用来描述领域，分别对应于底面和顶面，以及内/外表面。我们希望施加以下类型的边界条件。内外圆柱体表面没有外力，这一事实对应于自然（诺伊曼型）边界条件，我们不需要做任何事情。在底部，我们希望完全没有运动，对应于圆柱体在边界的这一部分被夹住或粘住。然而，在顶部，我们希望有一个规定的垂直向下的运动来压缩圆柱体；此外，我们只想限制垂直运动，而不是水平运动。
*
*--可以把这种情况看作是一块油性良好的板子坐在圆柱体的顶部，把它向下推：圆柱体的原子被迫向下运动，但它们可以沿着板子自由地滑动。
*

*
*描述的方法如下：对于边界指标为零（底面），我们使用一个二维的零函数，代表在任何坐标方向上没有运动。对于指标为1的边界（顶面），我们使用[2.x.232]类，但我们为[2.x.233]函数指定一个额外的参数，表示它应该适用于哪些矢量分量；这是一个针对每个矢量分量的bools矢量，由于我们只想限制垂直运动，它只有其最后一个分量的设置。
*


* [1.x.171]
*
* [1.x.172] [1.x.173]。


*
* 下一个函数是控制一个时间段内必须发生的所有事情。从函数名称来看，事情的顺序应该是相对不言而喻的。
*


* [1.x.174]
*
* [1.x.175] [1.x.176]。


*
* 再次求解线性系统的工作原理与之前一样。唯一不同的是，我们只想保留一份完整的解向量的本地拷贝，而不是从PETSc的求解例程中得到的分布式拷贝。为此，我们为分布式向量声明了一个本地临时变量，并用本地变量的内容对其进行初始化（记得[2.x.234]中调用的[2.x.235]函数预设了该向量中边界节点的值），用它进行求解，并在函数结束时再次将其复制到我们声明为成员变量的完整本地向量中。然后，挂起的节点约束只分布在本地拷贝上，也就是说，在每个处理器上是相互独立的。
*


* [1.x.177]
*
* [1.x.178] [1.x.179]。


*
* 这个函数生成.vtu格式的图形输出，正如介绍中所解释的那样。每个进程将只对其拥有的单元格进行处理，然后将结果写入自己的文件中。此外，处理器0将写下引用所有.vtu文件的记录文件。   
* 这个函数的关键部分是给[2.x.236]类提供一种方法，只对当前进程拥有的单元格进行处理。
*


*


* [1.x.180]
*
* 然后，就像在[2.x.237]中一样，定义求解变量的名称（这里是位移增量）并排队输出求解向量。注意在下面的开关中，我们如何确保如果空间维度应该不被处理，我们会抛出一个异常，说我们还没有实现这种情况（另一个防御性编程的案例）。
*


* [1.x.181]
*
* 下一件事是，我们想输出类似于我们存储在每个单元中的应力的平均规范。这可能看起来很复杂，因为在目前的处理器上，我们只在那些实际属于目前进程的单元格上存储正交点的应力。换句话说，我们似乎无法计算出所有单元的平均应力。然而，请记住，我们源自[2.x.238]的类只迭代那些实际属于当前处理器的单元，也就是说，我们不需要为所有其他单元计算任何东西，因为这些信息不会被触及。下面的小循环就是这样做的。我们将整个区块包围在一对大括号中，以确保迭代器变量不会在它们被使用的区块结束后仍然意外地可见。
*


* [1.x.182]

*在所有的单元格上循环...
*


* [1.x.183]
*
*在这些单元上，把所有正交点的应力加起来...
*


* [1.x.184]
*
* ......然后把平均值的常数写到它们的目的地。
*


* [1.x.185]
*
* 在我们不感兴趣的单元格上，将向量中的相应数值设置为假值（规范必须是正值，大的负值应该能吸引你的眼球），以确保如果我们的假设有误，即这些元素不会出现在输出文件中，我们会通过查看图形输出发现。
*


* [1.x.186]
*
* 最后把这个向量也附在上面，以便进行输出处理。
*


* [1.x.187]
*
* 作为最后一个数据，如果这是一个并行作业，让我们也把域划分为与处理器相关的子域。这与[2.x.239]程序中的工作方式完全相同。
*


* [1.x.188]
*
* 最后，有了所有这些数据，我们可以指示deal.II对信息进行整合，并产生一些中间数据结构，其中包含所有这些解决方案和其他数据向量。
*


* [1.x.189]
*
* 让我们调用一个函数，打开必要的输出文件并将我们生成的数据写入其中。该函数从给定的目录名（第一个参数）和文件名基数（第二个参数）自动构建文件名。它通过由时间步数和 "片数 "产生的片断来增加所产生的字符串，"片数 "对应于整个域的一部分，可以由一个或多个子域组成。     
* 该函数还为Paraview写了一个记录文件（后缀为`.pvd`），描述了所有这些输出文件如何组合成这个单一时间步骤的数据。
*


* [1.x.190]
*
* 记录文件必须只写一次，而不是由每个处理器来写，所以我们在处理器0上做这个。
*


* [1.x.191]
*
* 最后，我们编写paraview记录，引用所有.pvtu文件和它们各自的时间。注意，变量times_and_names被声明为静态的，所以它将保留以前的时间段的条目。
*


* [1.x.192]
*
* [1.x.193] [1.x.194]。


*
* 这个和下一个函数分别处理第一个和下一个时间步骤的整体结构。第一个时间步骤的工作量稍大，因为我们要在连续细化的网格上多次计算，每次都从一个干净的状态开始。在这些计算的最后，我们每次都计算增量位移，我们使用最后得到的增量位移的结果来计算产生的应力更新并相应地移动网格。在这个新的网格上，我们再输出解决方案和任何我们认为重要的额外数据。   
* 所有这些都是通过生成输出到控制台来穿插进行的，以更新观看屏幕的人对正在发生的事情。如同在[2.x.240]中一样，使用[2.x.241]可以确保只有一个并行进程实际在向控制台写数据，而不需要在每个产生输出的地方明确地编码一个if语句。
*


* [1.x.195]
*
* [1.x.196] [1.x.197]。


*
* 后续的时间步骤比较简单，鉴于上面对前一个函数的解释，可能不需要更多的文档。
*


* [1.x.198]
*
* [1.x.199] [1.x.200]。


*
* 当在连续细化的网格上求解第一个时间步骤时，会调用下面这个函数。在每次迭代之后，它计算一个细化准则，细化网格，并将每个正交点的历史变量再次设置为干净的状态。
*


* [1.x.201]
*
* 首先，让每个进程计算它所拥有的单元的误差指标。
*


* [1.x.202]
*
* 然后建立一个全局向量，我们把每个%并行进程的局部指标合并到其中。
*


* [1.x.203]
*
* 一旦我们有了这个，就把它复制回所有处理器上的本地副本，并相应地完善网格。
*


* [1.x.204]
*
* 最后，在新的网格上再次设置正交点数据，并且只在那些我们已经确定是我们的单元上设置。
*


* [1.x.205]
*
* [1.x.206] [1.x.207]。


*
* 在每个时间步骤结束时，我们根据这个时间步骤中计算的增量位移来移动网格的节点。为了做到这一点，我们保留一个标志的向量，用于指示每个顶点是否已经被我们移动过，然后在所有单元中循环，移动那些尚未被移动的单元顶点。值得注意的是，我们从某个顶点相邻的单元中移动这个顶点并不重要：因为我们使用连续有限元计算位移，位移场也是连续的，我们可以从每个相邻的单元中计算某个顶点的位移。我们只需确保每个节点精确地移动一次，这就是为什么我们要保留标志的矢量。   
*在这个函数中，有两个值得注意的地方。首先，我们如何使用[2.x.242]函数获得给定顶点的位移场，该函数返回给定单元的[2.x.243]的索引。在本例中，k-th坐标方向的位移对应于有限元的k-th分量。使用这样的函数有一定的风险，因为它使用了我们在[2.x.244]元素中为这个程序共同采取的元素顺序的知识。如果我们决定增加一个额外的变量，例如用于稳定的压力变量，并碰巧将其作为元素的第一个变量插入，那么下面的计算将开始产生无意义的结果。此外，这种计算还依赖于其他假设：首先，我们使用的元素确实有与顶点相关的自由度。对于目前的Q1元素来说确实如此，对于所有多项式阶的Qp元素来说也是如此[2.x.245] 。然而，这对于不连续的元素或混合公式的元素来说是不成立的。其次，它还建立在这样的假设上：一个顶点的位移只由与这个顶点相关的自由度的值决定；换句话说，所有对应于其他自由度的形状函数在这个特定的顶点是零。同样，对于目前的元素来说是这样的，但对于目前在deal.II中的所有元素来说并非如此。尽管有风险，我们还是选择使用这种方式，以便提出一种查询与顶点相关的单个自由度的方法。   
* 在这种情况下，指出一种更普遍的方法是很有意义的。对于一般的有限元来说，应该采取正交公式，将正交点放在单元的顶点上。梯形规则的[2.x.246]公式正是这样做的。有了这个正交公式，我们就可以在每个单元中初始化一个[2.x.247]对象，并使用[2.x.248]函数来获得正交点，即单元顶点的解函数值。这些是我们真正需要的唯一数值，也就是说，我们对与这个特定正交公式相关的权重（或[2.x.249]值）完全不感兴趣，这可以作为[2.x.250]构造器的最后一个参数来指定。这个方案中唯一的一点小麻烦是，我们必须弄清楚哪个正交点对应于我们目前考虑的顶点，因为它们可能是以相同的顺序排列，也可能不是。   
* 如果有限元在顶点上有支持点（这里的支持点是有的；关于支持点的概念，见[2.x.251]"支持点"），那么这种不便是可以避免的。对于这种情况，可以使用[2.x.252]构建一个自定义的正交规则，然后第一个[2.x.253]正交点将对应于单元格的顶点，其顺序与[2.x.254]一致，考虑到矢量元素的支持点将被重复[2.x.255]次。   
* 关于这个简短的函数，值得解释的另一点是三角形类输出其顶点信息的方式：通过[2.x.256]函数，它公布了三角形中有多少个顶点。并非所有的顶点都是一直在使用的
*
*--有些是以前被粗化的单元的遗留物，由于deal.II从不改变顶点的编号，一旦它出现，即使编号较低的顶点消失了，它仍然存在。其次，[2.x.257]返回的位置不仅是一个类型为[2.x.258]的只读对象，而且事实上是一个可以写入的引用。这允许相对容易地移动网格的节点，但值得指出的是，使用该功能的应用程序有责任确保所得到的单元仍然有用，即没有扭曲到单元退化的程度（例如，用负的雅各布系数表示）。请注意，我们在这个函数中没有任何规定来实际确保这一点，我们只是有信心。   
* 在这个冗长的介绍之后，下面是全部20行左右的代码。
*


* [1.x.208]
*
* [1.x.209] [1.x.210]。


*
* 在计算的开始，我们需要设置历史变量的初始值，例如材料中的现有应力，我们将其存储在每个正交点中。如上所述，我们使用每个单元中都有的[2.x.259]来做这个。   
* 为了从更大的角度来看，我们注意到，如果我们的模型中有先前可用的应力（为了这个程序的目的，我们假设这些应力不存在），那么我们就需要将先前存在的应力场插值到正交点上。同样，如果我们要模拟具有硬化/软化的弹塑性材料，那么我们就必须在每个正交点存储额外的历史变量，如累积塑性应变的当前屈服应力。然后，预先存在的硬化或弱化将通过在当前函数中插值这些变量来实现。
*


* [1.x.211]
*
* 为了慎重起见，我们将所有单元格的用户指针（无论是否属于我们）都设置为空指针。这样一来，如果我们访问了一个我们不应该访问的单元格的用户指针，一个分段故障将让我们知道这不应该发生。
*


*


* [1.x.212]
*
* 接下来，分配属于这个处理器职责范围内的正交对象。当然，这等于属于这个处理器的单元格的数量乘以我们的正交公式在每个单元格上的正交点的数量。由于`resize()`函数在要求的新大小小于旧大小的情况下，实际上并没有缩小分配的内存量，所以我们采用了一个技巧，首先释放所有的内存，然后再重新分配：我们声明一个空的向量作为临时变量，然后将旧向量的内容和这个临时变量交换。这确保了`正交点历史'现在确实是空的，我们可以让现在保存着以前的向量内容的临时变量超出范围并被销毁。在下一步，我们可以根据需要重新分配尽可能多的元素，矢量默认初始化`PointHistory`对象，这包括将压力变量设置为零。
*


* [1.x.213]
*
* 最后再次循环所有单元，并将属于本处理器的单元的用户指针设置为指向此类对象的向量中与本单元对应的第一个正交点对象。
*


* [1.x.214]
*
* 最后，为了慎重起见，确保我们对元素的计数是正确的，而且我们既用完了之前分配的所有对象，又没有指向向量末端以外的任何对象。这样的防御性编程策略总是很好的检查，以避免意外的错误，并防止将来对这个函数的修改忘记同时更新一个变量的所有用途。回顾一下，使用[2.x.260]宏的构造在优化模式下被优化掉了，所以不影响优化运行的运行时间。
*


* [1.x.215]
*
* [1.x.216] [1.x.217]。


*
* 在每个时间步骤结束时，我们应该计算出一个增量的位移更新，以便材料在其新的配置中能够容纳在这个时间步骤中施加的外部体和边界力减去通过预先存在的内部应力施加的力之间的差异。为了在下一个时间步骤中获得预先存在的应力，我们必须用本时间步骤中计算的增量位移引起的应力来更新预先存在的应力。理想情况下，所产生的内应力之和将完全抵消所有的外力。事实上，一个简单的实验可以确保这一点：如果我们选择边界条件和体力与时间无关，那么强迫项（外力和内应力之和）应该正好是零。如果你做了这个实验，你会从每个时间步长的右手边的规范输出中意识到这几乎是事实：它并不完全是零，因为在第一个时间步长中，增量位移和应力更新是相对于未变形的网格计算的，然后再进行变形。在第二个时间步骤中，我们再次计算位移和应力的更新，但这次是在变形的网格中计算的
*
* - 在这里，结果的更新非常小，但不完全是零。这可以迭代，在每一次这样的迭代中，残差，即右手边向量的法线，都会减少；如果做这个小实验，就会发现这个残差的法线会随着迭代次数的增加而呈指数级下降，在最初的非常快速的下降之后，每次迭代大约会减少3.5倍（对于我看的一个测试案例，其他测试案例，以及其他未知数的数量会改变这个系数，但不会改变指数级下降的情况）。
*

*
* 在某种意义上，这就可以被认为是一个准时序方案，以解决在一个以拉格朗日方式移动的网格上解决大变形弹性的非线性问题。   
* 另一个复杂的问题是，现有的（旧的）应力是在旧的网格上定义的，我们将在更新应力后移动这个网格。如果这个网格更新涉及到单元的旋转，那么我们也需要旋转更新的应力，因为它是相对于旧单元的坐标系计算的。   
* 因此，我们需要的是：在目前处理器拥有的每个单元上，我们需要从每个正交点存储的数据中提取旧应力，计算应力更新，将两者相加，然后将结果与从目前正交点的增量位移计算的增量旋转一起旋转。下面我们将详细介绍这些步骤。
*


* [1.x.218]
*
* 首先，建立一个[2.x.261]对象，通过它我们将评估增量位移和其在正交点的梯度，以及一个保存这些信息的向量。
*


* [1.x.219]
*
* 然后在所有单元格上循环，在属于我们的子域的单元格中做工作。
*


* [1.x.220]
*
* 接下来，获得一个指向当前单元本地正交点历史数据的指针，作为一种防御措施，确保这个指针在全局数组的范围内。
*


* [1.x.221]
*
* 然后初始化当前单元上的[2.x.262]对象，并提取正交点上的位移梯度，以便以后计算应变。
*


* [1.x.222]
*
* 然后在这个单元的正交点上循环。
*


* [1.x.223]
*
* 在每个正交点上，从梯度中计算出应变增量，并将其乘以应力-应变张量，得到应力更新。然后把这个更新添加到这个点上已经存在的应变上。
*


* [1.x.224]

* 最后，我们必须对结果进行旋转。为此，我们首先要从增量位移中计算出目前正交点的旋转矩阵。事实上，它可以从梯度中计算出来，而且我们已经有一个函数用于这个目的。
*


* [1.x.225]
*
* 请注意，其结果，即旋转矩阵，一般来说是一个等级为2的反对称张量，所以我们必须将其作为一个完整的张量来存储。
*

*
* 有了这个旋转矩阵，我们可以通过从左和右的收缩来计算旋转的张量，在我们把对称张量[2.x.263]扩展为一个完整的张量之后。
*


* [1.x.226]
*
* 请注意，虽然这三个矩阵的乘法结果应该是对称的，但由于浮点舍入的原因，它并不是对称的：我们得到的结果的非对角线元素的不对称程度为1e-16。当把结果分配给一个[2.x.264]时，该类的构造函数会检查对称性，并意识到它并不完全对称；然后它会引发一个异常。为了避免这种情况，我们明确地对结果进行对称，使其完全对称。
*


* 所有这些操作的结果然后被写回到原来的地方。
*


* [1.x.227]
*
* 这结束了项目特定的命名空间 [2.x.265] 。其余的和往常一样，并且已经在 [2.x.266] 中显示：一个 [2.x.267] 函数初始化和终止PETSc，调用做实际工作的类，并确保我们捕捉所有传播到这一点的异常。
*


* [1.x.228]
* [1.x.229][1.x.230] 。


*
* 如果使用调试模式，运行该程序需要很长时间；在我的i7桌面上需要大约11分钟。幸运的是，经过优化编译的版本要快得多；在同一台机器上用<tt>make release</tt>命令重新编译后，程序只需要大约1分半钟，这是更合理的时间。
*

* 如果运行，该程序会打印出以下输出，解释它在所有这些时间内做了什么。
* [1.x.231]
* 换句话说，它在12,000个单元上进行计算，涉及大约52,000个未知数。不是很多，但对于一个耦合的三维问题来说，足以让计算机忙上一阵子。在一天结束的时候，这是我们的输出结果。
* [1.x.232]
*
*

* 如果我们用VisIt或Paraview将这些文件可视化，我们就能看到我们的强制压缩对圆柱体造成的灾难的全貌（图像中的颜色编码了材料中的应力规范）。
*

* [2.x.268]


* [2.x.269]


* 可以清楚地看到，当我们不断压缩圆柱体时，它开始在完全受限的底面附近弯曲，并在大约8个时间单位后，以方位对称的方式弯曲。
*

*虽然这个结果对于对称几何和加载来说似乎是合理的，但计算是否完全收敛还有待确定。为了看看是否如此，我们再次运行了这个程序，在开始时多了一次全局精简，时间步长减半。这在单机上会花费很长的时间，所以我们使用了一个合适的工作站，在16个处理器上并行运行。现在输出的开头看起来像这样。
* [1.x.233]
* 考虑到我们是在3D中，这是个相当好的未知数的数字。这个程序的输出是每个时间步骤的16个文件。
* [1.x.234]

*

* 这里首先是我们计算的网格，以及16个处理器的分区。
*

* [2.x.270]


* 最后，这里的输出与我们之前为更小的顺序情况所展示的相同。
* [2.x.271]
*

* [2.x.272]


* 和以前一样，我们观察到，在高轴向压缩时，圆柱体开始弯曲，但这次最终是在自己身上倒塌。与我们第一次运行不同的是，在模拟结束时，变形模式变得不对称（中央凸起向侧面偏移）。该模型显然没有考虑到这一点（我们所有的力和边界偏转都是对称的），但这种效果可能在物理上是正确的：在现实中，身体材料属性的小不均匀性会导致它向一侧弯曲以逃避强制力；在数值模拟中，小的扰动，如数值舍入或迭代求解器对线性系统的不精确求解，都会产生同样的效果。在自适应计算中，另一个典型的不对称来源是每一步只精炼一定数量的单元，这可能导致不对称的网格，即使最初的粗网格是对称的。
*

* 如果我们将这一结果与前一次运行相比较，其结果在质和量上都有所不同。因此，以前的计算肯定没有收敛，尽管我们不能肯定地说现在的计算是什么。我们需要一个更精细的计算来找出答案。然而，这一点可能是没有意义的：详细看一下最后一张图片，很明显，不仅我们选择的线性小变形模型是完全不够的，而且对于一个现实的模拟，我们还需要确保身体在变形过程中不相交（如果我们继续压缩圆柱体，我们会观察到一些自我相交）。
*

*[1.x.235][1.x.236]


* 这个程序并没有真正解决一个在实践中有很多应用的方程：基于纯弹性定律的准静态材料变形几乎是无聊的。然而，该程序可以作为更有趣的实验的起点，这确实是编写该程序的最初动机。这里有一些建议，说明该程序还缺少什么，以及它可以向什么方向扩展。
* [1.x.237][1.x.238] 。


* 最明显的扩展是使用一个现实的材料模型来处理大规模的静态变形。这方面的自然选择是塑性，其中应力和应变之间的非线性关系取代了方程[1.x.239]。塑性模型的编程通常相当复杂，因为应力与应变的关系通常是不平滑的。可以认为材料只能承受一个最大的应力（屈服应力），在这之后它就开始&ldquo;流动&rdquo;。这方面的数学描述可以用变量不等式的形式给出，或者可以将其视为在应力约束[1.x.241]下的弹性能量最小化[1.x.240]。这种扩展使得问题在每个时间步长中都是非线性的，所以我们需要在每个时间步长中再进行一次循环。
* 我们不打算进一步讨论这个模型的细节，我们可以参考Simo和Hughes关于&ldquo;计算非弹性&rdquo;的优秀书籍，以全面了解解决塑性模型的计算策略。另外，S.Commend, A.Truty和Th.Zimmermann在一篇文章中对塑性的算法做了简要的描述。Zimmermann; [2.x.273] 。
*

*[1.x.242][1.x.243]


* 我们选择的公式，即对位移矢量的所有分量使用分片（双，三）线性元素，并将应力视为依赖于位移的变量，对大多数材料是合适的。然而，对于不可压缩或接近不可压缩的材料，这种所谓的基于位移的公式变得不稳定，并表现出虚假的模式。虽然流体通常不是弹性的（在大多数情况下，应力取决于速度梯度，而不是位移梯度，但也有例外，如电流变流体），但也有一些固体是几乎不可压缩的，如橡胶。另一种情况是，许多塑性模型最终让材料变得不可压缩，尽管这不在本程序的范围之内。
* 不可压缩性的特点是泊松比[1.x.244]，其中[2.x.274]是材料的Lam&eacute;常数。物理约束表明[2.x.275]（条件也是来自数学稳定性考虑）。如果[2.x.276]接近[2.x.277]，那么材料变得不可压缩。在这种情况下，纯粹的基于位移的公式不再适合于解决这类问题，必须采用稳定化技术来获得稳定和准确的解决方案。上面引用的书和论文给出了如何做到这一点的指示，但在这个问题上也有大量的文献资料；在H.-Y. Duan和Q. Lin的论文的参考文献中，可以找到一个获得该主题概述的良好开端。Duan和Q. Lin；[2.x.278] 。
*

*[1.x.245][1.x.246]


* 在目前的形式下，程序只对初始网格进行了若干次细化，然后就不再进行细化。对于任何类型的现实模拟来说，我们都希望将其扩展为每隔几步就对网格进行细化和粗化。事实上，这并不难做到，但是如果你愿意的话，我们可以把它留给将来的教程或者作为一个练习。
* 我们需要克服的主要复杂问题是，我们必须将存储在旧网格单元正交点中的数据转移到新网格中，最好是通过某种投影方案。这方面的一般方法是这样的。
*
* - 开始时，数据只存在于各个单元的正交点中，而不是作为一个到处定义的有限元场。
*
* - 所以让我们找到一个[1.x.247]到处定义的有限元场，这样我们以后就可以把它内插到新网格的正交点上。一般来说，要找到一个与正交点中的数值完全匹配的连续有限元场是很困难的，因为这些场的自由度数与正交点的数量不匹配，而且这个全局场的节点值要么是过定的，要么是欠定的。但是找到一个与正交点数值相匹配的不连续场通常不是很困难；例如，如果你有一个QGauss(2)正交公式（即2D中每个单元4个点，3D中8个点），那么就可以使用FE_DGQ(1)类型的有限元，即双/三线性函数，因为这些函数在2D中每个单元有4个自由度，在3D中有8个自由度。
*
* - 有一些函数可以使这种从单个点到全局场的转换更简单。如果你使用QGauss(2)正交公式，下面这段伪代码应该有帮助。请注意，下面的投影矩阵的乘法需要一个标量分量的向量，也就是说，我们一次只能将一组标量从正交点转换成自由度，反之亦然。所以我们需要分别存储每个应力分量，这需要[2.x.279]个向量。我们将把这组向量存储在一个二维数组中，以便于用读出应力张量的方式来读出分量。  因此，我们将对每个单元的应力分量进行循环，并将这些值存储在全局历史域中。(前缀[2.x.280]表示我们的工作与正交点中定义的历史变量有关。)
* [1.x.248]

*
* - 现在我们有了一个全局场，我们可以像往常一样使用SolutionTransfer类来细化网格并转移history_field向量。这将把所有的东西从旧的网格内插到新的网格。
*
* - 在最后一步，我们必须将数据从现在插值的全局场返回到新网格上的正交点。下面的代码将做到这一点。
* [1.x.249]
*
* 一旦我们并行运行这个程序，情况就会变得有点复杂，因为每个进程只为它在旧网格上拥有的单元存储这些数据。也就是说，如果你在将正交点转移到全局矢量后调用[2.x.281]，使用平行矢量就可以做到。
*

*[1.x.250][1.x.251] 。


* 目前，该程序没有尝试确保一个单元在时间步数结束时移动其顶点后，仍然具有有效的几何形状（即其雅各布决定数是正的，并且在任何地方都远离零）。事实上，设置边界值和强迫项的方式并不难，可以很快得到扭曲和倒置的单元。当然，在某些大变形的情况下，这在有限网格的情况下是不可避免的，但在其他情况下，通过适当的网格细化和/或缩小时间步长，这应该是可以避免的。这个程序没有这样做，但是一个更复杂的版本肯定应该采用某种启发式方法来定义哪些单元的变形量是可以接受的，哪些是不可以的。
*

* [1.x.252][1.x.253] [2.x.283] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-19_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32]

* [2.x.2]
* [1.x.33]
* [2.x.3] 在deal.II中存在对粒子的支持，主要是由于Rene Gassmoeller的最初努力。如果你在自己的工作中使用粒子功能，请通过引用出版物[2.x.4]来确认这项工作。
* [1.x.34][1.x.35][1.x.36]
*

* 一般的有限元方法，特别是 deal.II，是为了解决偏微分方程而发明的。
*
*换句话说，是为了解决[连续体力学](https://en.wikipedia.org/wiki/Continuum_mechanics)问题。另一方面，有时人们想解决的问题是，跟踪单个物体（"粒子"）以及它们的位置如何演变是很有用的。如果这只是导致一组常微分方程，例如，如果你想长期跟踪太阳系中行星的位置，那么deal.II显然不是你合适的工具。另一方面，如果这种演变是由于与偏微分方程的解的相互作用，或者如果有一个网格来确定哪些粒子与其他粒子相互作用（比如在[平滑粒子流体力学（SPH）](https://en.wikipedia.org/wiki/Smoothed-particle_hydrodynamics)方法中），那么deal.II对你就有支持。
* 我们这里要考虑的情况是带电粒子如何在电场中运动。作为动机，我们将考虑[阴极射线](https://en.wikipedia.org/wiki/Cathode_ray)。由一块带负电的金属（"阴极"）发出的电子，在电场的作用下加速向带正电的电极（"阳极"）移动。阳极通常是环形的，这样大部分电子可以以电子束的形式飞过孔。在过去，它们可能会照亮由[阴极射线管](https://en.wikipedia.org/wiki/Cathode-ray_tube)制成的电视屏幕。而今天，电子束在[X光机](https://en.wikipedia.org/wiki/X-ray_tube)、[电子束平版印刷](https://en.wikipedia.org/wiki/Electron-beam_lithography)、[电子束焊接](https://en.wikipedia.org/wiki/Electron-beam_welding)以及其他一些领域都很有用。
* 我们接下来要考虑的方程式如下。首先，我们需要描述电场。这是最容易做到的，注意到电势[2.x.5]满足方程式[1.x.37]，其中[2.x.6]是真空的介电常数，[2.x.7]是带电强度。这是由边界条件增加的，我们将选择如下。
* [1.x.38]
* 换句话说，我们在两个电极上规定电压[2.x.8]和[2.x.9]，在其他地方规定绝缘（诺伊曼）边界条件。由于粒子的动力学纯粹是由于电场[2.x.10]，我们也可以在两个电极上规定[2.x.11]和[2.x.12]。
*
* - 所有重要的是两个电极的电压差。
* 考虑到这个电动势[2.x.13]和电场[2.x.14]，我们可以用微分方程[1.x.39]描述第[2.x.15]个粒子的轨迹，其中[2.x.16]是每个粒子的质量和电荷。在实践中，将其写成位置[2.x.17]和速度[2.x.18]的一阶微分方程系统很方便。
* [1.x.40]
* 我们将用来处理粒子的deal.II类，[2.x.19]以一种方式存储粒子，因此位置[2.x.20]是[2.x.21]数据结构的一部分。另一方面，速度[2.x.22]与[2.x.23]无关，因此我们将其作为每个粒子的 "属性 "来存储，并在每个时间步长中更新。属性也可以用来存储我们可能关心的关于每个粒子的任何其他数量：它的电荷，或者如果它们大于一个电子，它的颜色、质量、在空间的位置、化学成分等等。
* 为了完成这个模型，还有两件事需要讨论：粒子从哪里开始，电荷密度[2.x.24]是什么。
*首先，在历史上，阴极射线使用非常大的电场将电子从金属中拉出来。这只产生一个相对较小的电流。通过加热阴极可以做得更好：在这种情况下，统计学上的一部分电子有足够的热能离开金属；然后电场只要足够强，就可以把它们从宿主体的吸引中拉出来。我们将以下列方式建立这个模型。如果（i）电场指向远离电极的地方，即如果[2.x.25]，其中[2.x.26]是指向域外（进入电极）的表面的法向量，以及（ii）电场超过一个阈值[2.x.27]，我们将创建一个新粒子。这不是一个足够准确的模型，但对我们目前的教程来说已经足够了。
* 第二，原则上我们必须通过[1.x.41]来建立电荷密度模型。
* [2.x.28] 现在的问题是，在现实中，一台老式电视中的阴极射线管产生的电流大约为几毫安培。在粒子加速器的高能量光束中，电流可能只有几纳安培。但一个安培是每秒钟流动的[2.x.29]个电子。现在，正如你将在结果部分看到的那样，我们实际上只模拟了几微秒（[2.x.30]秒），但这仍然导致了非常大的电子数量
*
*--远远超过我们希望用一个像目前这样小的程序来模拟的数量。因此，让我们假设每个粒子代表[2.x.31]个电子。那么粒子的质量和电荷也是[2.x.32]和[2.x.33]，我们要解决的方程是[1.x.42]，这当然与上述情况完全相同。另一方面，这些电子 "团块 "的带电强度由[1.x.43]给出，我们将在程序中实现这一形式，其中[2.x.34]在程序中被选得相当大，以确保粒子实际影响电场。这在实践中可能并不现实。在大多数情况下，没有足够的电子来实际影响过电场。但现实主义不是我们的目标）。)
*

*
* [2.x.35] 人们可能会问，为什么电场（或者说，电势）的方程式没有时间导数，而电子位置的方程式却有。从本质上讲，这是一个建模假设。我们假设粒子移动得很慢，以至于在任何时候电场都处于平衡状态。这就是说，换句话说，电子的速度远远小于光速。换句话说，我们可以用电极电压[2.x.36]来重新表述：由于每伏电势都会使电子加速约600公里/秒（忽略相对论效应），要求[2.x.37]相当于说[2.x.38]。在这个假设（以及电子总数很小的假设）下，我们也可以忽略移动电荷产生的磁场，否则也会影响电子的运动。
*

*[1.x.44][1.x.45]


* 上面概述的方程构成了一组耦合微分方程。让我们再次把它们集中在一起，以明确这一点。
* [1.x.46]
* 由于电势对粒子位置的依赖性很强，我们不想把它作为一个耦合系统来解决，而是采用一种解耦的方法，首先解决每个时间步长的电势，然后解决粒子位置。这与我们在[2.x.39]、[2.x.40]和[2.x.41]（仅举几例）中的做法精神完全相同，而且都可以在[2.x.42]中讨论的算子拆分方法的背景下理解。
* 因此，如果我们用大指数表示[2.x.43]的时间步长，如果我们对ODE使用简单的时间离散化，那么这意味着我们必须在每个时间步长中解决以下方程组。
* [1.x.47]
* 当然，还有许多更好的方法来进行时间离散化（例如简单的[跃迁方案](https://en.wikipedia.org/wiki/Leapfrog_integration)），但这不是本教程程序的重点，因此我们将满足于我们在这里的内容。然而，我们将在本程序的[1.x.48]部分对这个难题的一个部分进行评论）。
* 还有一个问题是我们应该如何选择时间步长[2.x.44]。这里的限制是，[2.x.45]类需要跟踪每个粒子在哪个单元。这在我们并行运行计算时尤其是一个问题（例如，在[2.x.46]中），因为在这种情况下，每个进程只存储它所拥有的那些单元和一层 "幽灵单元"。这在这里并不相关，但一般来说，我们应该确保在每个时间步长中，一个粒子只从一个单元移动到它的任何近邻（面、边或顶点邻居）。如果我们能确保这一点，那么[2.x.47]就能保证能够弄清粒子最终在哪个单元。要做到这一点，一个有用的经验法则是，我们应该选择时间步长，使所有粒子的预期移动距离小于一个单元格直径：[1.x.49]或等价于[1.x.50]这里，[2.x.48]是粒子[2.x.49]所在的单元格的最短边缘的长度
*
* - 本质上，是对一个单元的大小的衡量。
* 另一方面，一个粒子可能已经在一个单元的边界上，而邻近的单元可能曾经进一步完善。因此，那么穿过那个相邻*单元的时间实际上是上述数量的一半，这表明[1.x.51] 。
* 但即使这样也是不够好的。上面的公式使用[1.x.52]更新粒子位置，也就是说，使用当前*速度[2.x.50]。但是在我们需要选择[2.x.51]的时候，我们还没有当前的速度。
*
但在我们需要选择[2.x.51]*时，我们还没有当前的速度--这是在我们更新了势[2.x.52]之后，但在我们将速度从[2.x.53]更新到[2.x.54]之前。我们有的只是[2.x.55]。所以我们需要为我们的最终选择增加一个安全系数：[1.x.53]，[2.x.56]应该有多大？这取决于与[2.x.58]相比，[2.x.57]可能被低估了多少，而这实际上是很容易评估的。如果沿途遇到的电场是大致恒定的，那么在一个时间步长中产生的速度为零的粒子在每个连续的时间步长中大致会获得相等的速度增量。因此，[2.x.59]和[2.x.60]之间的最大差异将是一个系数。因此，我们将选择[2.x.61]。
* 只有一种情况我们应该考虑。在第一个时间步骤中会发生什么？在那里，任何要移动的粒子都是刚刚产生的，但它们的速度是零。所以我们不知道我们应该为它们选择什么速度。当然，在所有其他的时间步长中，也有刚刚被创造出来的粒子，但一般来说，具有最高速度的粒子限制了时间步长，所以新创造的粒子及其零速度并不重要。但是，如果我们只有*个
有这样的粒子？
* 在这种情况下，我们可以使用下面的近似方法。如果一个粒子从[2.x.62]开始，那么更新公式告诉我们[1.x.54]，因此[1.x.55]，我们可以写成[1.x.56]不想让一个粒子移动超过[2.x.63]，那么意味着我们应该选择[1.x.57]的时间步长。
* 严格来说，我们必须在每个粒子的位置上评估电势[2.x.64]，但一个足够好的近似值是使用各自单元顶点的最大值。为什么是顶点而不是中点？因为拉普拉斯方程的解的梯度，即电场，在位于单元顶点的角落奇点上是最大的）。)这样做的好处是，我们可以很好地利用FEValues功能，只要各单元的正交点相同，就可以循环使用预计算的材料。
* 我们总是可以运行这种方案来估计[2.x.65]和[2.x.66]之间的差异，但它依赖于评估每个单元的电场[2.x.67]，这很昂贵。因此，我们将把这种方法限制在第一个时间步骤上。
*

*[1.x.59][1.x.60]


*在讨论了时间离散化之后，对空间离散化的讨论将很简短：我们使用二次有限元，即空间[2.x.68]，来近似计算电动势[2.x.69]。在最初的时间步长中，Themesh被调整了几次。如果你读过[2.x.70]，所有这些都是完全标准的，而且这个实现没有提供任何形式的惊喜。
*


*[1.x.61][1.x.62]


* 添加和移动粒子实际上在deal.II中并不困难。要添加一个粒子，本程序的`create_particles()`函数只需使用以下形式的代码片段。
* [1.x.63]
* 换句话说，这与在[2.x.71]或[2.x.72]中插入一个对象没有什么不同。 创建对象，设置其属性（这里是当前位置，其参考单元位置，以及其id），并调用`insert_particle`。唯一可能令人惊讶的是参考位置。为了评估诸如[2.x.73]这样的东西，有必要评估位置[2.x.74]的有限元场。但这需要在参考单元[2.x.75]上的点评估有限元形状函数。为了提高效率，每个粒子不仅要存储它的位置和它所在的单元，还要存储该点在单元的参考坐标系中所对应的位置。
* 更新一个粒子的位置并不困难。我们只需要调用
* [1.x.64]
* 我们在`move_particles()`函数中这样做。唯一不同的是，我们必须告诉[2.x.76]类，以找到该位置所对应的单元（以及在并行计算时，哪个进程拥有该单元）。出于效率的考虑，这在更新所有粒子的位置后最容易完成，并通过[2.x.77]函数实现。
* 当然，有些时候，粒子可能会离开问题域。在这种情况下，[2.x.78]不能找到周围的单元，而是简单地删除粒子。但是，跟踪以这种方式丢失的粒子的数量往往是有用的，为此，[2.x.79]类提供了一个可以附加的 "信号"。我们在主类的构造器中展示了如何做到这一点，以计算每个时间步长中损失了多少个粒子。具体来说，这种工作方式是，[2.x.80]类有一个 "信号"，可以附加一个函数，在信号被触发时执行。在这里，这看起来如下。
* [1.x.65]
* 这有点拗口，但实际情况是这样的。我们声明了一个 "捕获"`this`指针的lambda函数（这样我们就可以在lambda函数中访问周围对象的成员函数），并接受两个参数。
*
* - 被 "丢失 "的粒子的一个引用。
*
* - 它最后所在的单元格的引用。然后，lambda函数用这些参数简单地调用[2.x.81]函数。当我们把这个lambda函数附加到信号上时，[2.x.82]函数将为每个找不到新家的粒子触发信号。这就给了我们一个机会来记录粒子的位置，并记录它的统计数据。
*

*
* [2.x.83] 在这个教程程序中，我们通过手工插入粒子，并在我们根据包括解决静电问题的条件而特别选择的位置插入粒子。但在其他情况下，人们主要想把粒子作为被动对象，例如追踪和可视化流体流动问题的流场。在这些情况下，在[2.x.84]命名空间中有许多函数可以自动生成粒子。这个命名空间中的一个函数也被用于[2.x.85]教程程序中，例如。
*

*[1.x.66][1.x.67]


* 这里的测试案例并不意味着是对阴极射线管的真实描述，但它具有正确的一般特征，而且在任何情况下，重点只是为了演示如何实现使用粒子的deal.II代码。
* 下图显示了我们将要使用的几何图形。
* [2.x.86]
* 在这幅图中，边界上标有红色和蓝色的部分是阴极，保持在一个电势[2.x.87]。阴极的红色部分是被加热的部分，导致电子离开金属，然后被电场加速（也显示了一些电场线）。边界的绿色部分是阳极，保持在[2.x.88]。边界的其余部分满足诺伊曼边界条件。
* 这个设置模仿了真实的设备。重心角的结果是电势[2.x.89]，其导数（电场[2.x.90]）有一个奇点。
*
* 换句话说，它在拐角附近变得非常大，允许它把电子从金属上扯下来。这些电子然后被加速推向（绿色）阳极，阳极中间有一个孔，电子可以通过这个孔逃离设备并飞向屏幕，在那里它们激发了 "荧光粉"，然后发出我们从这些老式电视屏幕上看到的光。阴极的非加热部分不受电子发射的影响。
*
* 在代码中，我们将其标记为电子管的 "聚焦元件"，因为它的负电压会排斥电子，并确保它们不会从垂直于边界的阴极加热部分飞走，而实际上是将它们的路径弯曲到右侧的阳极上。
* 图中的电场线也说明了电场分别连接着负极和正极。电子所经历的加速力是沿着这些场线的。最后，图片显示了计算中使用的网格，说明在重租角的顶端以及所有边界条件发生变化的地方都有网格，这些网格是可见的，因为网格在这些地方被细化。
* 实际的利益是要弄清楚从阴极发射的电子中，有哪一部分能真正通过阳极上的孔。
*
* 除了将电转化为热之外，那些只是反弹到阳极本身的电子实际上并没有什么用处。因此，在`track_lost_particle()'函数中（该函数为每个离开域的粒子调用，见上文），我们将估计它可能离开域的位置并在输出中报告。
*

*
* [2.x.91] 值得重申的是，这里使用的几何图形，以及这个程序的任何其他方面，都不是为了表现任何东西，甚至是半点现实的。教程是我们教授deal.II如何工作的工具，我们经常使用我们有某种直觉的情况，因为这有助于我们解释程序的输出，但这就是我们打算让程序除了作为教学工具之外做任何有用的事情的程度。
*

* [1.x.68] [1.x.69]。
* [1.x.70] [1.x.71]。



* 本程序中使用的大部分include文件都是[2.x.92]和类似程序中众所周知的。
*


*


* [1.x.72]
*
* 新的只有以下三个。第一个声明了DiscreteTime类，它帮助我们在与时间相关的模拟中跟踪时间。后面两个提供了所有的粒子功能，即跟踪位于网格上的粒子的方法（[2.x.93]类）和为可视化目的输出这些粒子的位置和属性的能力（[2.x.94]类）。
*


* [1.x.73]
*
* [1.x.74] [1.x.75]。


*
* 按照惯例，我们把所有与程序细节相对应的东西都放到一个自己的命名空间中。在顶部，我们定义了一些常量，我们宁愿使用符号名称而不是硬编码的数字。
*

*
* 具体来说，我们为[2.x.95]的 "边界指标 "定义数字，用于几何学的各个部分，以及电子的物理属性和我们在这里使用的设置的其他具体内容。
*

*
* 对于边界指标，让我们从某个随机值101开始列举。这里的原则是使用不常见的数字*。如果以前有`GridGenerator'函数设置的预定义边界指标，它们很可能是从零开始的小整数，但不是在这个相当随机的范围内。使用下面这样的数字可以避免冲突的可能性，同时也减少了在程序中直接拼出这些数字的诱惑（因为你可能永远不会记得哪个是哪个，而如果它们从0开始，你可能会受到诱惑）。
*


* [1.x.76]
*
* [1.x.77] [1.x.78]。



* 下面是这个程序的主类。从根本上说，它的结构与[2.x.96]和其他许多教程程序相同。这包括大部分的成员函数（其余部分的目的可能从它们的名字中不难看出），以及超出[2.x.97]的少量成员变量，所有这些都是与处理粒子有关的。
*


* [1.x.79]
*
* [1.x.80] [1.x.81]。



* [1.x.82] [1.x.83]。


*
* 那么，让我们开始实现。构造函数所做的实际上只是对顶部的所有成员变量进行简单的初始化。唯一值得一提的两个变量是`particle_handler`，它被交给一个三角形的引用，粒子将生活在这个三角形上（目前当然还是空的，但粒子处理程序存储了这个引用，一旦粒子被添加，就会使用它
*
*--这发生在三角结构建立之后）。)它得到的另一个信息是每个粒子需要存储多少个 "属性"。在这里，我们需要每个粒子记住的是它当前的速度，也就是一个带有`dim`分量的矢量。然而，每个粒子还有其他的内在属性，[2.x.98]类会自动并始终确保这些属性是可用的；特别是，这些属性是一个粒子的当前位置、它所在的单元格、它在该单元格中的参考位置以及粒子的ID。   
* 唯一感兴趣的其他变量是 "时间"，一个DiscreteTime类型的对象。它记录了我们在一个随时间变化的模拟中的当前时间，并以开始时间（零）和结束时间（[2.x.99]）初始化。我们以后将在`update_timestep_size()`中设置时间步长。   
* 构造函数的主体由我们在介绍中已经讨论过的一段代码组成。也就是说，我们要确保每次有粒子离开领域时，`track_lost_particle()`函数都会被`particle_handler`对象调用。
*


* [1.x.84]
*
* [1.x.85] [1.x.86]。


*
* 接下来的函数负责生成我们要解决的网格。回顾一下领域的样子。  [2.x.100] 我们把这个几何体细分为一个[2.x.101]单元的网格，看起来像这样。  [2.x.102] 这样做的方法是，首先定义[2.x.103]顶点的位置
*
* - 在这里，我们说它们在整数点上，左边的中间一个向右移动了一个`delta=0.5'的值。   
* 在下文中，我们就必须说哪些顶点共同组成了8个单元。下面的代码就完全等同于我们在[2.x.104]中的做法。
*


* [1.x.88]
*
* 有了这些数组，我们就可以转向稍高的高层数据结构了。我们创建一个CellData对象的向量，为每个要创建的单元存储相关的顶点以及[2.x.105]"材料ID"（我们在这里将其简单地设置为0，因为我们在程序中不使用它）。     
* 这些信息然后被交给[2.x.106]函数，网格被两次全局细化。
*


* [1.x.89]
*
* 该函数的其余部分在所有的单元格和它们的面之间循环，如果一个面在边界上，则决定哪个边界指标应该应用于它。如果你将代码与上面的几何图形相比较，各种条件应该是有意义的。     
* 一旦完成了这一步，我们再一次全局地细化网格。
*


* [1.x.90]
*
* [1.x.91] [1.x.92]。


*
* 本程序的下一个函数是处理与解决偏微分方程有关的各种对象的设置。它本质上是对[2.x.107]中相应函数的复制，不需要进一步讨论。
*


* [1.x.93]
*
* [1.x.94] [1.x.95]。


*
* 计算矩阵条目的函数实质上还是[2.x.108]中相应函数的副本。
*


* [1.x.96]

* 这个函数唯一有趣的部分是它如何形成线性系统的右手边。回顾一下，PDE的右边是[1.x.97]，在这里我们用[2.x.109]来索引粒子，以避免与形状函数[2.x.110]混淆；[2.x.111]是第[2.x.112]个粒子的位置。         
* 当与测试函数[2.x.113]相乘并在域上积分时，会产生一个右手边的向量


* [1.x.98]
* 注意最后一行不再包含一个积分，因此也没有出现[2.x.114]，这需要在我们的代码中出现`JxW`符号。         
* 对于一个给定的单元格[2.x.115]，该单元格对右边的贡献是


* [1.x.99]
*也就是说，我们只需要担心那些实际位于当前单元格上的粒子 [2.x.116] 。         
* 在实践中，我们在这里所做的是以下工作。如果当前单元格上有任何粒子，那么我们首先获得一个迭代器范围，指向该单元格的第一个粒子，以及该单元格上最后一个粒子之后的粒子（或结束迭代器
*
*--即一个半开放的范围，这在C++函数中很常见。现在知道了粒子的列表，我们查询它们的参考位置（相对于参考单元），评估这些参考位置的形状函数，并根据上述公式计算出力（没有任何[2.x.117]）。
*

*
* [2.x.118] 值得指出的是，调用[2.x.119]和[2.x.120]函数在有大量粒子的问题上效率不高。但是它说明了写这个算法的最简单的方法，所以我们愿意为了说明问题而暂时承担这个代价。我们在下面的[1.x.100]中更详细地讨论了这个问题，并在[2.x.121]中使用了一个更好的方法，例如：。
*


* [1.x.101]
*
* 最后，我们可以把这个单元的贡献复制到全局矩阵和右手边的向量中。
*


* [1.x.102]
*
* [1.x.103] [1.x.104]。


*
* 解决线性系统的函数又与[2.x.122]中完全一样。
*


* [1.x.105]
*
* [1.x.106] [1.x.107]。


*
* 最后一个与场有关的函数是细化网格的函数。我们将在第一个时间步骤中多次调用它，以获得一个与解的结构相适应的网格，特别是解决解中由于重入角和边界条件类型变化的地方而产生的各种奇异现象。你可能想再参考一下[2.x.123]以了解更多的细节。
*


* [1.x.108]
*
* [1.x.109] [1.x.110]。


*
* 现在让我们来看看处理粒子的函数。第一个是关于粒子的创造。正如介绍中提到的，如果电场[2.x.124]超过某个阈值，即如果[2.x.125]，并且如果电场指向域内（即如果[2.x.126]），我们希望在阴极的各点创建一个粒子。正如有限元方法中常见的那样，我们在特定的评估点评估场（及其导数）；通常，这些是 "正交点"，因此我们创建了一个 "正交公式"，我们将用它来指定我们想要评估解决方案的点。在这里，我们将简单地采用QMidpoint，意味着我们将只在面的中点检查阈值条件。然后我们用它来初始化一个FEFaceValues类型的对象来评估这些点的解。   
* 然后，所有这些将被用于所有单元格、它们的面，特别是那些位于边界的面，以及边界的阴极部分的循环中。
*


* [1.x.111]
*
* 所以我们已经找到了阴极上的一个面。接下来，我们让FEFaceValues对象计算每个 "正交 "点的解的梯度，并通过[2.x.127]"矢量值问题 "文件模块中讨论的方法，以张量变量的形式从梯度中提取电场向量。
*


* [1.x.112]
*
* 只有当电场强度超过阈值时，电子才能逃离阴极，关键是，如果电场指向*域。一旦我们检查了这一点，我们就在这个位置创建一个新的[2.x.128]对象，并将其插入到[2.x.129]对象中，并设置一个唯一的ID。                 
* 唯一可能不明显的是，我们还将这个粒子与我们当前所在的单元格的参考坐标中的位置联系起来。这样做是因为我们将在下游函数中计算诸如粒子位置的电场等量（例如，在每个时间步长中更新其位置时计算作用于它的力）。在任意坐标上评估有限元场是一个相当昂贵的操作，因为形状函数实际上只定义在参考单元上，所以当要求一个任意点的电场时，我们首先要确定这个点的参考坐标是什么。为了避免反复操作，我们一次性地确定这些坐标，然后将这些参考坐标直接存储在粒子上。
*


* [1.x.113]
*
* 在所有这些插入的最后，我们让`particle_handler`更新它所存储的粒子的一些内部统计数据。
*


* [1.x.114]
*
* [1.x.115] [1.x.116]。


*
* 第二个与粒子有关的函数是在每个时间步骤中移动粒子的函数。要做到这一点，我们必须在所有的单元中进行循环，每个单元中的粒子，并评估每个粒子位置上的电场。   
* 这里使用的方法在概念上与`assemble_system()`函数中使用的相同。我们在所有单元中循环，找到位于那里的粒子（同样要注意这里用来寻找这些粒子的算法的低效率），并使用FEPointEvaluation对象来评估这些位置的梯度。
*


* [1.x.117]
*
* 然后我们可以向FEPointEvaluation对象询问这些位置上的解决方案的梯度（即电场[2.x.130]），并在各个粒子上循环。
*


* [1.x.118]
*
* 现在我们已经得到了其中一个粒子位置的电场，我们首先用它来更新速度，然后更新位置。要做到这一点，让我们首先从存储在粒子的属性中得到旧的速度，计算加速度，更新速度，并将这个新速度再次存储在粒子的属性中。回顾一下，这对应于在介绍中讨论的以下一组更新方程中的第一个。


* [1.x.119]

*


* [1.x.120]
*
* 有了新的速度，我们就可以同时更新粒子的位置，并告诉粒子有关情况。
*


* [1.x.121]
*
* 在更新了所有粒子的位置和属性（即速度）之后，我们需要确保`particle_handler'再次知道它们在哪个单元中，以及它们在参考单元的坐标系中的位置是什么。下面的函数就是这样做的。(它还确保在并行计算中，如果粒子从一个处理器拥有的子域移动到另一个处理器拥有的子域，那么粒子会从一个处理器移动到另一个处理器。)
*


* [1.x.122]
*
* [1.x.123] [1.x.124]。


*
* 最后一个与粒子有关的函数是当一个粒子从模拟中丢失时被调用的函数。这通常发生在它离开域的时候。如果发生这种情况，这个函数会同时调用单元（我们可以询问它的新位置）和它之前所在的单元。然后，该函数不断跟踪更新这个时间步骤中丢失的粒子数，丢失的粒子总数，然后估计该粒子是否通过阳极中间的孔离开。我们这样做，首先检查它最后所在的单元是否有一个[2.x.131]坐标在右边边界的左边（位于[2.x.132]），而粒子现在的位置在右边边界的右边。如果是这样的话，我们就计算出它的运动方向矢量，这个方向矢量被归一化了，所以方向矢量的[2.x.133]分量等于[2.x.134] 。有了这个方向矢量，我们可以计算出它与直线[2.x.135]相交的位置。如果这个相交点在[2.x.136]和[2.x.137]之间，那么我们声称粒子从孔中离开，并增加了一个计数器。
*


* [1.x.125]
*
* [1.x.126] [1.x.127]。


*
* 正如在介绍中详细讨论的那样，我们需要尊重一个时间步长条件，即粒子在一个时间步长中不能移动超过一个单元。为了确保这一点，我们首先计算每个单元上所有粒子的最大速度，然后用该速度除以单元大小。然后，我们使用介绍中讨论的安全系数，将下一个时间步长计算为所有单元上该数量的最小值，并使用[2.x.138]函数将其设定为所需的时间步长。
*


* [1.x.128]
*
* 正如介绍中所提到的，我们必须以不同的方式对待第一个时间步长，因为在那里，粒子还没有出现，或者还没有我们计算合理步长所需的相关信息。下面的公式是按照介绍中的讨论进行的。
*


* [1.x.129]
*
* [1.x.130] [1.x.131]。



* 实现整个算法的最后一个函数是生成图形输出的函数。在目前的情况下，我们想同时输出电势场以及粒子的位置和速度。但我们也想输出电场，即解决方案的梯度。   
* deal.II有一个一般的方法，可以从溶液中计算出派生量，并将其输出。在这里，这就是电场，但也可以是一些其他的量
*
* 比如说，电场的法线，或者事实上任何其他人们想从解[2.x.139]或其导数中计算的东西。这个一般的解决方案使用了DataPostprocessor类，在像这里的情况下，我们想输出一个代表矢量场的量，则使用DataPostprocessorVector类。   
* 与其尝试解释这个类是如何工作的，不如让我们简单地参考一下DataPostprocessorVector类的文档，这个案例基本上是一个有据可查的例子。
*


* [1.x.132]
*
* 有了这个，`output_results()`函数就变得相对简单了。我们使用DataOut类，就像我们在以前几乎所有的教程程序中使用的那样，来输出解决方案（"电动势"），我们使用上面定义的后处理程序来输出其梯度（"电场"）。这些都将被写入VTU格式的文件中，并将当前时间和时间步长与该文件相关联。
*


* [1.x.133]
*
* 输出粒子的位置和属性并不复杂。[2.x.140]类扮演了粒子的DataOut类的角色，我们所要做的就是告诉该类从哪里获取粒子，以及如何解释属性中的`dim`成分
*
*--即作为表示速度的单一矢量，而不是作为`dim`标量属性。剩下的就和上面一样了。
*


* [1.x.134]

* [1.x.135] [1.x.136]。


*
* 这个程序的主类的最后一个成员函数是驱动。在顶层，它通过在一连串越来越细的网格上求解问题（还没有创建粒子）来多次细化网格。
*


* [1.x.137]
*
*在前面做几个细化循环
*


* [1.x.138]
*
* 现在在时间上做循环。这个步骤的顺序紧紧围绕着介绍中讨论的算法的大纲。正如在DiscreteTime类的文档中详细讨论的那样，当我们将场和粒子信息向前移动一个时间步长时，存储在`time`变量中的时间与这些量的（部分）位置不一致（在DiscreteTime的字典中，这就是 "更新阶段"）。对`time.advance_time()`的调用通过将`time`变量设置为场和粒子已经处于的时间，使一切再次保持一致，一旦我们处于这个 "一致阶段"，我们就可以生成图形输出，并将模拟的当前状态的信息写入屏幕中。
*


* [1.x.139]
*
* [1.x.140] [1.x.141]。



* 程序的最后一个函数又是`main()`函数。自[2.x.141]以来，它在所有的教程程序中都没有变化，因此没有什么新的内容需要讨论。
*


* [1.x.142]
* [1.x.143][1.x.144] 。


*当这个程序运行时，它产生的输出看起来如下：``时间步骤1 场自由度：4989 仿真中的粒子总数：20 这个时间步骤损失的粒子数：0
*现在在t=2.12647e-07，dt=2.12647e-07。
* 时间步数2 场自由度：4989 仿真中的粒子总数：24 本时间步数损失的粒子数：0
* 现在在t=4.14362e-07，dt=2.01715e-07。
* 时间步数3 场自由度：4989 仿真中的粒子总数：28 这个时间步数损失的粒子数：0
* 现在在t=5.96019e-07，dt=1.81657e-07。
* 时间步数4 场自由度：4989 仿真中的粒子总数。  32 这个时间步骤损失的粒子数：0
* 现在在t=7.42634e-07，dt=1.46614e-07。
*

* ...


* 时间步数1000场自由度：4989模拟中的粒子总数。  44 这个时间步骤损失的粒子数：6 通过阳极损失的粒子数。0.0601266
* 现在在t=4.93276e-05，dt=4.87463e-08。
* 时间步数1001 场自由度：4989 仿真中的粒子总数。  44 这个时间步长损失的粒子数：0 通过阳极损失的粒子的分数。0.0601266
* 现在在t=4.93759e-05，dt=4.82873e-08。
*

* ...


* 时间步数2091场自由度：4989模拟中的粒子总数。  44 这个时间步长损失的粒子数：0 通过阳极损失的粒子的分数。0.0503338
* 现在在t=9.99237e-05，dt=4.26254e-08。
* 时间步长2092场自由度：4989模拟中的粒子总数。  44 这个时间步长损失的粒子数：0 通过阳极损失的粒子的分数。0.0503338
* 现在在t=9.99661e-05，dt=4.24442e-08。
* 时间步长2093场自由度：4989模拟中的粒子总数。  44 这个时间步长损失的粒子数：2 通过阳极损失的粒子的分数。0.050308
*现在在t=0.0001，dt=3.38577e-08.```。
* 随机选取几个时间步长，我们可以用电场的流线和电子的圆点的形式来可视化解决方案。[2.x.142]
* 也就是说，更合适的方法是通过创建一个视频，显示这些电子是如何运动的，以及电场是如何随着它们的运动而变化的，来直观地显示这个程序的结果。
* [1.x.145]
*
* 在这里你可以看到，边界的 "焦点元素 "是如何用负电压排斥电子，并确保它们不会垂直于阴极飞走（就像它们在轨迹的初始部分那样）。它还显示了电场线是如何随着时间的推移而移动的，以应对电荷的飞行。
*
* 换句话说，粒子对电场的反馈，本身就推动了电子的运动。
* 这部电影表明，电子在 "成串 "或 "爆裂 "中移动。这种表象的一个因素是电影制作过程中的一个假象。电影的每一帧都对应着一个时间步长，但时间步长是不同的。更具体地说，穿过最小单元的最快粒子决定了时间步长（见介绍中的讨论），因此，每当一个（快速）粒子穿过域的右边缘的小单元时，时间步长都很小；一旦粒子离开域，时间步长又会变长。通过绘制屏幕输出中显示的时间步长，可以很容易地看到这种减速-加速的效果。
* 然而，这其中的第二部分是真实的。仿真在开始时创造了一大群粒子，而在大约第300个时间步长之后，粒子数量减少。这可能是因为模拟中的粒子带有负电荷：它们降低了（同样带负电荷的电极）的电场强度，从而减少了阴极上电场强度超过吸引电子离开电极所需阈值的点的数量。
*

*[1.x.146][1.x.147][1.x.148]


*[1.x.149][1.x.150]


* `assemble_system()`、`move_particles()`和`update_timestep_size()`函数都调用[2.x.143]和[2.x.144]，查询位于当前单元上的粒子信息。虽然这很方便，但效率也很低。为了理解为什么会这样，我们需要知道粒子是如何存储在[2.x.145]中的，即在一个数据结构中，粒子以某种线性方式排序，并按照它们所在的单元进行排序。因此，为了找到与给定单元相关的粒子，这些函数需要搜索给定单元上的第一个（可能还有最后一个）粒子
*
*--这种努力需要花费[2.x.146]次操作，其中[2.x.147]次是粒子的数量。但这是在每个单元上重复进行的；假设对于大型计算来说，单元和粒子的数量大致成比例，那么这些函数调用的累积成本是[2.x.148]，因此大于我们应该对程序的所有部分进行的[2.x.149]成本。
* 不过，我们可以使之更便宜。首先，我们可以不调用[2.x.150]，而是先调用[2.x.151]，然后通过计算当前单元上最后一个粒子与第一个粒子的距离来计算单元上的粒子数。
* [1.x.151]
* 当然，第一个调用仍然是[2.x.152]，但至少第二个调用只需要与当前单元格上的粒子数成比例的计算时间，因此，当累积到所有单元格时，成本为[2.x.153] 。
* 但我们甚至可以通过一些适当的算法设计摆脱这些调用中的第一个。这是因为粒子是以与单元相同的方式排序的，所以我们可以在单元上移动时直接走动它们。下面的算法纲要就是这样做的。
* [1.x.152]
*
* 在这段代码中，我们对每个单元都精确地接触了一次，我们不必在大数据结构中搜索每个单元上的第一个或最后一个粒子。因此，该算法在完成所有粒子和所有单元的扫描时总共花费了[2.x.154]。
* 对这个程序中存在这个问题的所有三个函数实施这个方案并不十分困难。
*

*[1.x.153][1.x.154]


* 该程序已经计算出了通过阳极上的孔离开域的电子的比例。但人们可能还对其他的数量感兴趣。例如，这些粒子的平均速度。从每个粒子的属性中获得其速度并不是很困难，就像我们在`move_particles()`函数中做的那样，并从中计算出统计数据。
*

*[1.x.155][1.x.156]


* 如上所述，不同的视频帧之间有不同的时间差，因为我们为每一个时间步骤创建输出。一个更好的方法是在固定的时间间隔内生成一个新的输出文件，不管每个时间点之间有多少时间步长。
*

*[1.x.157][1.x.158] 。


* 我们在这个程序中考虑的问题是一个耦合的、多物理学的问题。但是我们解决这个问题的方法是首先计算（电）势场，然后更新粒子位置。这就是所谓的 "算子分割法"，我们将在[2.x.155]中详细研究这一概念。
* 虽然要想出一种不涉及将问题分割成PDE部分和粒子部分的方法是很困难的，但我们可以
*可以*（而且可能应该！）想出一个更好的方法来更新粒子位置。具体来说，我们用来更新粒子位置的方程是
* [1.x.159]
* 这对应于一个简单的正向欧拉时间离散化
*
* 我们知道我们应该避免这种方法，因为我们可以做得更好。相反，我们可能想考虑一种方案，如[跃迁方案](https://en.wikipedia.org/wiki/Leapfrog_integration)或更普遍的[折衷积分器](https://en.wikipedia.org/wiki/Symplectic_integrator)，如[Verlet方案](https://en.wikipedia.org/wiki/Verlet_integration)。
*

*[1.x.160][1.x.161] 。


* 在发布模式下，写这篇文章时，该程序在作者的一台笔记本电脑上运行约3.5分钟。这是可以接受的。但是，如果我们想让模拟变成三维的呢？如果我们不希望在任何时候使用最多100个粒子（就像这里使用的参数一样），而是使用100,000个？如果我们需要一个更细的网格？
* 在这些情况下，我们不仅要在单个处理器上运行程序，而且要在尽可能多的处理器上运行。这就需要对PDE解决方案和粒子进行并行化。在实践中，虽然要使这一方法有效并具有良好的规模，存在很大的挑战，但这些挑战都在交易二本身中得到了解决。例如，[2.x.157]展示了如何将有限元部分并行化，[2.x.158]展示了如何将粒子部分也并行化。
*

* [1.x.162][1.x.163] [2.x.159] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-20_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33]
*[1.x.34][1.x.35][1.x.36] 。


* [2.x.2]
*本程序致力于两个方面：混合有限元的使用
*
* - 特别是Raviart-Thomas元素
*
* 以及使用块矩阵来定义解算器、预处理器和使用系统矩阵子结构的嵌套版本。我们要解决的方程又是泊松方程，不过有一个矩阵值的系数：[1.x.37] 。
* [2.x.3]被假定为均匀正定，即有[2.x.4]使[2.x.6]的特征值[2.x.5]满足[2.x.7] 。使用符号[2.x.8]而不是通常的[2.x.9]作为解变量将在下一节中变得清晰。
* 在讨论了方程和我们要用来求解的公式之后，这个介绍将包括块状矩阵和向量的使用，求解器和预处理器的定义，以及最后我们要解决的实际测试案例。
* 我们将在[2.x.10]中扩展这个教程程序，不仅要解决混合拉普拉斯方程，还要增加一个描述两种流体混合物运输的方程。
* 这里涉及的方程属于矢量值问题的范畴。对这一主题的概述可以在[2.x.11]模块中找到。
*

*[1.x.38][1.x.39]


* 在上述形式中，泊松方程（即具有非零右边的拉普拉斯方程）通常被认为是多孔介质中流体流动的良好模型方程。当然，人们通常通过[1.x.40]来模拟流体流动，或者，如果流体速度很慢或粘度很大，则通过[1.x.41]（我们在[2.x.12]中介绍）。在这两个模型中的第一个，作用力是惯性和粘性摩擦，而在第二个，只有粘性摩擦。
*
* - 即一个流体粒子对附近的粒子所施加的力。另一方面，如果流体被限制在孔隙中，那么孔壁对流体施加的摩擦力变得越来越重要，而内部的粘性摩擦力变得越来越不重要。后者只是泊松方程或拉普拉斯方程的一个不同名称，其内涵是指人们想要应用它的领域：多孔介质中的缓慢流动。从本质上说，速度与驱动流体通过多孔介质的负压梯度成正比。
* 达西方程对驱动流动的压力进行建模。(由于求解变量是压力，我们在此使用[2.x.13]这个名称，而不是通常用于求解偏微分方程的[2.x.14]。)这种拉普拉斯方程观点的典型应用是模拟地下水流，或油藏中的碳氢化合物流动。在这些应用中，[2.x.15]是渗透性张量，即衡量土壤或岩石基质对流体流动的阻力大小。
* 在上述应用中，数值方案的一个理想特征是它应该是局部保守的，也就是说，无论什么东西流入一个单元，也会从该单元流出（或者如果来源为零，则差值等于每个单元的源项的积分）。然而，事实证明，拉普拉斯方程的通常离散化（如[2.x.16]、[2.x.17]或[2.x.18]中使用的那些）并不满足这一特性。但是，我们可以通过选择问题的不同表述和特定的无限元空间组合来实现这一点。
*

*[1.x.44][1.x.45]


* 为此，首先要引入第二个变量，称为速度，[2.x.19] 。根据其定义，速度是压力梯度的反方向的一个矢量，乘以渗透性张量。如果渗透性张量与单位矩阵成正比，这个方程就很容易理解和直观：渗透性越高，速度就越高；速度与压力梯度成正比，从高压区到低压区（因此是负号）。
* 有了这第二个变量，就可以找到拉普拉斯方程的另一个版本，称为[1.x.46]：[1.x.47] 。
* 这里，我们将定义速度的方程[2.x.20]乘以[2.x.21]，因为这使得方程组是对称的：其中一个方程有梯度，第二个方程有负发散，这两个方程当然是彼此相邻的，结果是不对称的双线性形式，因此，在[2.x.22]是对称张量的共同假设下，是对称的系统矩阵。
* 这个问题的弱式是通过将两个方程与测试函数相乘，并将一些项分次积分而得到的：[1.x.48] 。
* 其中[1.x.49]
* 这里，[2.x.23]是边界处的外向法向量。请注意，在这种形式中，原问题的迪里希特边界值被纳入了弱的形式中。
* 为了得到良好的解决，我们必须在空间[2.x.24]中寻找[2.x.25]、[2.x.26]和[2.x.27]中寻找[2.x.28]的解和检验函数。众所周知，几乎每一本关于有限元理论的书都提到，如果选择离散的有限元空间来逼近[2.x.29]是不恰当的，那么由此产生的离散问题是不稳定的，离散的解也不会收敛到精确的解。(这里考虑的问题的一些细节
*
* 属于 "鞍点问题 "的范畴
*
* 可以在维基百科的[1.x.50]页面上找到）。)
* 为了克服这个问题，已经为[2.x.30]开发了一些不同的有限元对，导致了稳定的离散问题。其中一个对子是用Raviart-Thomas空间[2.x.31]处理速度[2.x.32]，用非连续元素类[2.x.33]处理压力[2.x.34] 。关于这些空间的细节，我们特别参考Brezzi和Fortin的关于混合有限元方法的书，但许多其他关于有限元理论的书，例如Brenner和Scott的经典书，也说明了相关结果。在任何情况下，在适当选择函数空间的情况下，离散的表述如下。找到[2.x.35]，以便[1.x.51]。
*
*

*在继续之前，让我们简单地停顿一下，说明上述函数空间的选择为我们提供了所需的局部守恒特性。特别是，由于压力空间由不连续的片状多项式组成，我们可以选择测试函数[2.x.36]作为在任何给定单元[2.x.37]上等于1而在其他地方为0的函数。如果我们也到处选择[2.x.38]（记住，上面的弱式必须对[1.x.52]离散测试函数[2.x.39]成立），那么把这些测试函数的选择放入上面的弱式表述中，特别意味着[1.x.53]
* 我们当然可以用更明确的形式写成[1.x.54]。
* 应用发散定理的结果是，对于每个单元[2.x.41]的选择，[2.x.40]必须满足[1.x.55]的关系。
* 如果你现在记得[2.x.42]是速度，那么左边的积分正是穿过单元[2.x.43]边界的（离散）通量。然后，声明通量必须等于[2.x.44]内的源上的积分。特别是，如果没有源（即[2.x.45]在[2.x.46]中），那么声明是[1.x.56]通量为零，也就是说，无论什么东西流入一个单元都必须通过单元边界的其他部分流出。这就是我们所说的[1.x.57]，因为它对每个细胞都是成立的。
* 另一方面，通常的连续[2.x.47]元素在用于压力时不会产生这种属性（例如，我们在[2.x.48]中所做的），因为我们不能选择一个离散的测试函数[2.x.49]，它在一个单元[2.x.50]上为1，在其他地方为0：它将是连续的，因此不在有限元素空间中。严格来说，我们只能说上面的证明对连续元素不起作用。这些元素是否仍会导致局部守恒是一个不同的问题，因为我们可以认为不同的证明可能仍然有效；然而在现实中，该属性确实不成立）。)
*


*[1.x.58][1.x.59]


* deal.II库（当然）实现了任意阶的Raviart-Thomas元素[2.x.51][2.x.52]，以及不连续的元素[2.x.53]。如果我们暂时不考虑它们的特殊属性，那么我们就必须解决一个离散问题[1.x.60] *，该问题具有双线性形式，并且是一个不连续的问题。
*如上所述的双线性形式和右手边，以及[2.x.54] , [2.x.55]。[2.x.56]和[2.x.57]都来自空间[2.x.58]，其中[2.x.59]本身就是一个[2.x.60]维函数的空间，以适应流速为矢量值的事实。
* 矢量值元素已经在以前的教程程序中讨论过了，第一次是在[2.x.61]中详细讨论。其主要区别在于，矢量值空间[2.x.62]的所有分量都是统一的：位移矢量的[2.x.63]分量都是相等的，并且来自同一函数空间。因此，我们可以做的是把[2.x.64]作为[2.x.65]乘以通常的[2.x.66]有限元空间的外积，并以此确保我们所有的形状函数都只有一个非零矢量分量。因此，我们在[2.x.67]中所做的，不是处理矢量值的形状函数，而是查看（标量）唯一的非零分量，并使用[2.x.68]调用来计算出这实际上是哪一个分量。
* 这对Raviart-Thomas元素不起作用：由于它们的构造是为了满足空间[2.x.69]的某些规则性属性，[2.x.70]的形状函数通常在其所有矢量分量中都是不为零。由于这个原因，如果应用[2.x.71]来确定形状函数[2.x.72]的唯一非零分量，就会产生一个例外。我们真正需要做的是在[2.x.73]中获得一个形状函数的所有[2.x.74]向量分量。在deal.II的字典中，我们把这样的有限元称为[2.x.75]非原始[2.x.76]，而把标量的有限元或者每个向量值的形状函数只在一个向量分量中不为零的有限元称为[2.x.77]原始[2.x.78]。
* 那么对于非原始元素，我们要怎么做呢？为了弄清楚这个问题，让我们回到教程程序中去，几乎是在最开始的时候。在那里，我们了解到我们使用[2.x.79]类来确定正交点的形状函数的值和阶差。例如，我们会调用[2.x.80]来获得[2.x.81]的形状函数在编号为[2.x.82]的正交点的值。后来，在[2.x.83]和其他教程程序中，我们了解到这个函数调用也适用于矢量值的形状函数（原始有限元），它返回正交点[2.x.85]处形状函数[2.x.84]唯一非零分量的值。
* 对于非原始形状函数，这显然是行不通的：形状函数[2.x.86]没有单一的非零向量分量，因此调用[2.x.87]就没有多大意义。然而，deal.II提供了第二个函数调用，[2.x.88]，返回正交点[2.x.89]的值[2.x.90]是介于零和当前有限元的矢量分量数量之间的索引；例如，我们将用于描述速度和压力的元素将有[2.x.91]分量。值得注意的是，这个函数调用也可以用于原始形状函数：它将简单地对除一个以外的所有分量返回零；对于非原始形状函数，它一般会对不止一个分量返回非零值。
* 我们现在可以尝试用矢量分量来重写上面的双线性形式。例如，在2d中，第一项可以这样改写（注意[2.x.92]）：[1.x.61] 。
* 如果我们实现了这一点，我们会得到这样的代码。
* [1.x.62]
*
* 这充其量是繁琐的，容易出错的，而且不是独立的维度。有一些明显的方法可以使事情与维度无关，但最终，代码根本不漂亮。如果我们能够简单地提取形状函数[2.x.93]和[2.x.94]的分量，那就更好了。在程序中，我们以下列方式进行。
* [1.x.63]
*
* 事实上，这不仅是双线性形式的第一项，而且是整个事情（不包括边界贡献）。
* 这段代码的作用是，给定一个[2.x.96]对象，在正交点[2.x.99]提取形状函数[2.x.98]的第一个[2.x.97]分量的值，也就是该形状函数的速度分量。换句话说，如果我们把形状函数[2.x.100]写成元组[2.x.101]，那么该函数返回这个元组的速度部分。请注意，速度当然是一个[2.x.102]维的张量，并且该函数返回一个相应的对象。类似地，当我们用压力提取器下标时，我们提取标量压力部分。整个机制在[2.x.103]模块中有更详细的描述。
* 在实践中，如果我们在每个最外层的循环中只评估一次形状函数、它们的梯度和发散，并存储结果，我们可以做得更好一些，因为这样可以节省一些重复的计算（通过提前计算所有相关的量，然后只在实际的循环中插入结果，甚至可以节省更多的重复操作，关于这种方法的实现，见[2.x.104]），最后的结果看起来像这样，在每个空间维度上工作。
* [1.x.64]
*
* 这非常类似于我们最初写下的双线性形式和右手边的形式。
* 有一个最后的项，我们必须注意：右手边包含项[2.x.105]，构成压力边界条件的弱执行。我们已经在[2.x.106]中看到了如何处理面积分：本质上与域积分完全相同，只是我们必须使用FEFaceValues类，而不是[2.x.107]。为了计算边界项，我们只需在所有的边界面上进行循环并在那里进行积分。该机制的工作方式与上述相同，也就是说，提取器类也对FEFaceValues对象工作。
* [1.x.65]
*
* 你会在本程序的源代码中找到与上述完全相同的代码。因此，我们在下面将不作过多评论。
*

*[1.x.66][1.x.67]


* 组建了线性系统后，我们面临着解系统的任务。这里的问题是，矩阵拥有两个不理想的特性。
*
* - 它是[1.x.68]，即它有正负两个特征值。  我们不想在此证明这一特性，但请注意，所有形式为[2.x.108]的矩阵都是如此，如这里的[2.x.109]是正定的。
*
* - 矩阵的右下方有一个零块（在双线性形式中没有将压力[2.x.110]与压力测试函数[2.x.111]耦合的项）。
* 至少它是对称的，但是上面的第一个问题仍然意味着共轭梯度法是行不通的，因为它只适用于矩阵是对称和正定的问题。我们将不得不求助于其他迭代求解器，如MinRes、SymmLQ或GMRES，它们可以处理不确定的系统。然而，下一个问题立即浮现。由于零块的存在，对角线上有零，通常的 "简单 "预处理程序（Jacobi, SSOR）都不能工作，因为它们需要除以对角线元素。
* 对于我们期望用这个程序运行的矩阵大小，到目前为止最简单的方法就是使用直接求解器（特别是与deal.II捆绑的SparseDirectUMFPACK类）。  [2.x.112]走的就是这条路线，并表明解决[1.x.69]线性系统只需3、4行代码就可以完成。
* 但是，这是一个教程。我们教的是如何做事。因此，在下文中，我们将介绍一些可用于类似这些情况的技术。也就是说，我们将考虑线性系统不是由一个大的矩阵和向量组成，而是要将矩阵分解为[1.x.70]，对应于系统中出现的各个运算符。我们注意到，由此产生的求解器并不是最优的
*
*--有更好的方法来有效地计算这个系统，例如在[2.x.113]的结果部分所解释的方法，或者我们在[2.x.114]中对一个与当前问题类似的问题所用的方法。在这里，我们的目标仅仅是介绍新的求解技术，以及它们如何在本质上实现。
*

*[1.x.71][1.x.72]


* 鉴于上述使用标准求解器和预处理器的困难，让我们再看一下矩阵。如果我们对自由度进行排序，使所有的速度变量排在所有的压力变量之前，那么我们可以将线性系统[2.x.115]细分为以下几块：[1.x.73] 。
* 其中[2.x.116]分别是速度和压力自由度的值，[2.x.117]是速度空间的质量矩阵，[2.x.118]对应于负发散算子，[2.x.119]是其转置，对应于梯度。
* 通过区块消除法，我们可以按以下方式对这个系统重新排序（用系统的第一行乘以[2.x.120]，然后再减去第二行）：[1.x.74] 。
* 这里，矩阵[2.x.121]（称为[2.x.122]的[1.x.75]）显然是对称的，由于[2.x.123]的正定性和[2.x.124]具有全列等级，[2.x.125]也是正定的。
* 因此，如果我们能够计算出[2.x.126]，我们就可以对其应用共轭梯度法。然而，计算[2.x.127]是昂贵的，因为它要求我们计算（可能很大的）矩阵[2.x.128]的逆；而[2.x.129]实际上也是一个全矩阵，因为即使[2.x.130]是稀疏的，其逆[2.x.131]通常也是一个密集矩阵。我们可以利用矩阵乘积是关联的这一事实，分步进行（即，我们可以设置括号，使乘积更便于计算）：为了计算[2.x.133]，我们[2.x.134] [2.x.135]计算[2.x.136]；[2.x.137]解[2.x.138]为[2.x.139]，使用CG方法应用于正定和对称质量矩阵[2.x.140]；[2.x.141]计算[2.x.142]，得到[2.x.143] 。[2.x.144] 注意我们如何从右到左评估表达式[2.x.145]以避免矩阵-矩阵乘积；这样，我们所要做的就是评估矩阵-向量乘积。
* 在下文中，我们将不得不想出表示矩阵[2.x.146]的方法，以便在共轭梯度求解器中使用它，以及定义我们可以预设涉及[2.x.147]的线性系统解决方案的方法，并处理与矩阵[2.x.148]的线性系统求解（上述第二步骤）。
* [2.x.149] 这一考虑的关键点是要认识到，为了实现CG或GMRES这样的迭代求解器，我们实际上从来不需要矩阵的实际[1.x.76]!所需要的只是我们能够进行矩阵-向量乘积。对于预处理程序也是如此。在deal.II中，我们对这一要求进行了编码，只要求提供给求解器类的矩阵和预处理器有一个[2.x.150]的成员函数来做矩阵-向量积。一个类如何选择实现这个函数对求解器来说并不重要。因此，类可以通过实现它，例如，像上面讨论的那样，做一连串的乘积和线溶。
*

*[1.x.77][1.x.78]


* deal.II包括支持以一种非常普遍的方式来描述这种线性操作。这是由LinearOperator类完成的，就像[2.x.151]"MatrixType概念 "一样，它为[1.x.79]向量的线性操作定义了一个最小接口。
* [1.x.80]
* 然而，LinearOperator和普通矩阵的关键区别在于，LinearOperator不允许对底层对象进行任何进一步的访问。你能用LinearOperator做的就是将它的 "动作 "应用于一个向量!我们借此机会介绍一下LinearOperator的概念，因为它是一个非常有用的工具，可以让你以一种非常直观的方式构造复杂的求解器和预处理器。
* 作为第一个例子，让我们构建一个代表[2.x.152]的LinearOperator对象。这意味着每当这个运算符的[2.x.153]函数被调用时，它必须解决一个线性系统。这就要求我们指定一个解算器（和相应的）前置条件。假设[2.x.154]是对系统矩阵左上块的引用，我们可以写出。
* [1.x.81]
* 我们没有使用SolverControl类，而是使用了ReductionControl类，当达到绝对容限（我们选择[2.x.155]）或者当残差减少了一定的因素（这里是[2.x.156]）时，就停止迭代。相反，SolverControl类只检查绝对公差。在我们的案例中，我们必须使用ReductionControl来解决一个小问题。我们将送入[2.x.157]的右手边基本上是由残差形成的，随着外部迭代的进行，残差的规范自然会大大降低。这使得用绝对公差来控制非常容易出错。
* 我们现在有一个LinearOperator[2.x.158]，我们可以用它来构造更复杂的运算符，如Schur补码[2.x.159]。假设[2.x.160]是对右上角块的引用，构造一个LinearOperator[2.x.161]只需两行。
* [1.x.82]
* 这里，三个LinearOperator对象的乘法产生了一个复合对象[2.x.162]，该函数首先应用[2.x.163]，然后是[2.x.164]（即用[2.x.165]解方程），最后是[2.x.166]到任何指定的输入向量。在这个意义上，[2.x.167]类似于以下代码。
* [1.x.83]
*（[2.x.168]是两个临时向量）。这种方法背后的关键点是，我们实际上从未创建过矩阵的内积。相反，每当我们要用[2.x.169]进行矩阵向量乘法时，我们只需按上述顺序运行所有单独的[2.x.170]操作。
* [2.x.171] 我们可以通过实现一个专门的类[2.x.172]，提供一个合适的[2.x.173]函数，来实现创建一个 "类似矩阵 "的对象的相同目标。跳过一些细节，这可能看起来像下面这样。
* [1.x.84]
* 尽管这两种方法完全等同，但LinearOperator类比这种手工方法有很大的优势。它提供了所谓的[1.x.85][1.x.86]：在数学上，我们认为[2.x.174]是复合矩阵[2.x.175]，LinearOperator类允许你大致上逐字写出这一点。
* [1.x.87]
* 另一方面，手工方法掩盖了这个事实。
* 现在我们要做的就是形成定义[2.x.176]和[2.x.177]的两个方程的右边，然后分别用舒尔补强矩阵和质量矩阵来解决它们。例如，第一个方程的右手边是[2.x.178]。这可以用以下方式实现。
* [1.x.88]
* 同样，这是一个完全有效的方法，但是deal.II要求我们手动调整最终和临时向量的大小，而且每一个操作都要占用一个新的行，这就使我们难以阅读。这就是线性运算符框架中的第二个类可以帮助我们的地方。与LinearOperator的精神类似，PackagedOperation存储一个 "计算"。
* [1.x.89]
* 该类允许[1.x.90]涉及向量和线性运算符的表达式。这是通过存储计算表达式来实现的，只有当对象被转换为矢量对象，或者[2.x.179]（或[2.x.180]被手动调用时才会执行计算。假设[2.x.181]是右边的两个向量，我们可以简单地写出。
* [1.x.91]
* 这里，[2.x.182]是一个打包的操作，[1.x.92]是我们指定的计算。它不会立即创建一个带有实际结果的向量。
* 有了这些先决条件，解决[2.x.183]和[2.x.184]的问题就是创建另一个求解器和逆向。
* [1.x.93]
*
* [2.x.185] 我们在这个例子中手工开发的功能在库中已经可以使用了。看看tschur_complement(), condense_schur_rhs(), and postprocess_schur_solution()。
*

*[1.x.94][1.x.95] 。


* 有人会问，如果我们有一个Schurcomplement [2.x.186]的预处理程序，是否会有帮助。一般来说，答案是：当然。问题是，我们对这个舒尔补码矩阵一无所知。我们不知道它的条目，我们所知道的只是它的作用。另一方面，我们必须认识到，我们的求解器是昂贵的，因为在每次迭代中，我们必须与舒尔补矩阵做一次矩阵-向量乘积，这意味着我们必须在每次迭代中对质量矩阵做一次反转。
* 对这样的矩阵有不同的预处理方法。一个极端是使用一些便宜的方法，因此对每次迭代的工作没有实际影响。另一个极端是使用本身非常昂贵的预处理方法，但作为回报，真正降低了用[2.x.187]求解所需的迭代次数。
* 我们将沿着第二种方法进行尝试，既是为了提高程序的性能，也是为了展示一些技术。为此，让我们回顾一下，理想的预处理程序当然是[2.x.188]，但这是无法实现的。然而，将[1.x.96]*作为预处理程序如何？
* 作为一个预处理程序呢？这意味着每次我们必须做一个预处理步骤时，我们实际上必须用[2.x.189]来解决。起初，这看起来几乎和立即用[2.x.190]求解一样昂贵。然而，请注意，在内迭代中，我们不必计算[2.x.191]，而只是计算其对角线的逆值，这很便宜。
* 值得庆幸的是，LinearOperator框架使得这一点很容易写出来。我们之前已经对[2.x.192]矩阵使用了雅可比预处理程序（[2.x.193]）。所以剩下的就是写出近似的舒尔补码应该是什么样子。
* [1.x.97]
* 注意这个算子的不同之处在于，它只是做了一次雅可比扫频（即与对角线的逆数相乘），而不是与整个[2.x.194]相乘（这就是与[2.x.195]相乘的单一雅可比预处理步骤的定义：它是与[2.x.196]对角线的逆数相乘；换言之，对向量[2.x.198]的[2.x.197]操作正是预处理Jacobi的工作）。
* 有了这些，我们几乎完成了预处理程序：它应该是近似舒尔补码的逆。我们再次通过使用inverse_operator()函数创建一个线性算子来实现这一点。不过这次我们想为CG解算器选择一个相对较小的容忍度（即反转[2.x.199]）。理由是[2.x.200]，所以我们实际上不需要完全反转它。然而，这产生了一个微妙的问题：[2.x.201]将被用于最后的外层CG迭代，以创建一个正交的基础。但是为了使其发挥作用，每次调用都必须是精确的相同的线性操作。我们通过使用迭代次数控制（IterationNumberControl）来确保这一点，该控制允许我们将执行的CG迭代次数固定为一个固定的小数字（在我们的例子中为30）。
* [1.x.98]
*
* 这就是全部!
* 很明显，应用这个近似舒尔补码的逆运算是一个非常昂贵的预处理程序，几乎和倒置舒尔补码本身一样昂贵。我们可以期望它能大大减少Schur补码所需的后继迭代次数。事实上，它确实如此：在使用0阶元素的7次细化网格的非典型运行中，outer迭代次数从592次下降到39次。另一方面，我们现在必须应用一个非常昂贵的预处理程序25次。因此，更好的衡量标准是程序的运行时间：在目前的笔记本电脑上（截至2019年1月），这个测试案例的运行时间从3.57秒下降到2.05秒。这似乎并不令人印象深刻，但在更细的网格和更高阶的元素上，节省的时间变得更加明显了。例如，一个7倍细化的网格和使用2阶元素（相当于约40万个自由度）产生了1134次到83次的外部迭代，运行时间为168秒到40秒。虽然不是惊天动地，但意义重大。
*

*[1.x.99][1.x.100]


* 在这个教程程序中，我们将以上述的混合形式解决拉普拉斯方程。由于我们想在程序中监测解决方案的收敛性，我们选择右手边、边界条件和系数，以便恢复我们已知的解函数。特别是，我们选择压力解[1.x.101]。
*对于系数，我们选择单位矩阵[2.x.202]，以求得简单性。因此，准确的速度满足[1.x.102]。
* 选择这个解是因为它完全没有发散，使它成为不可压缩流体流动的现实的测试案例。因此，右侧等于[2.x.203]，作为边界值，我们必须选择[2.x.204]。
* 在本程序的计算中，我们选择[2.x.205]。你可以在[1.x.103]中找到结果的解决方案，在注释程序之后。
*

* [1.x.104] [1.x.105]。
* [1.x.106] [1.x.107]。
*

*
* 因为这个程序只是对[2.x.206]的改编，所以在头文件方面没有多少新东西。在deal.II中，我们通常按照base-lac-grid-dofs-fe-numerics的顺序列出包含文件，然后是C++标准包含文件。
*


* [1.x.108]
*
* 唯一值得注意的两个新头文件是LinearOperator和PackagedOperation类的文件。
*


* [1.x.109]
*
* 这是唯一重要的新标头，即声明Raviart-Thomas有限元素的标头。
*


* [1.x.110]

* 最后，作为本程序中的一项奖励，我们将使用一个张量系数。由于它可能具有空间依赖性，我们认为它是一个张量值的函数。下面的include文件提供了提供这种功能的[2.x.207]类。
*


* [1.x.111]

* 最后一步和以前所有的程序一样。我们把所有与这个程序相关的代码放到一个命名空间中。(这个想法在 [2.x.208] 中首次提出) 。
*


* [1.x.112]
*
* [1.x.113] [1.x.114]。


*
* 同样，由于这是对[2.x.209]的改编，主类与该教程程序中的主类几乎相同。就成员函数而言，主要区别在于构造函数将Raviart-Thomas元素的度数作为参数（并且有一个相应的成员变量来存储这个值），并且增加了[2.x.210]函数，在这个函数中，不出意外，我们将计算精确解和数值解之间的差异，以确定我们计算的收敛性。
*


* [1.x.115]
*
* 第二个区别是疏散模式、系统矩阵、解和右手向量现在被封锁了。这意味着什么，人们可以用这些对象做什么，在这个程序的介绍中已经解释过了，下面我们在解释这个问题的线性求解器和预处理器时也会进一步解释。
*


* [1.x.116]
*
* [1.x.117] [1.x.118]。


*
* 我们的下一个任务是定义我们问题的右手边（即原始拉普拉斯方程中压力的标量右手边），压力的边界值，以及一个描述压力和精确解的速度的函数，以便以后计算误差。请注意，这些函数分别有一个、一个和[2.x.211]分量，我们将分量的数量传递给[2.x.212]基类。对于精确解，我们只声明实际上一次性返回整个解向量（即其中的所有成分）的函数。下面是各自的声明。
*


* [1.x.119]
*
* 然后我们还得定义这些各自的函数，当然了。鉴于我们在介绍中讨论了解决方案应该是什么样子的，下面的计算应该是很简单的。
*


* [1.x.120]
*
* [1.x.121] [1.x.122]。


*
* 除了其他方程数据外，我们还想使用渗透率张量，或者更好的是
*
* - 因为这就是出现在弱形式中的所有内容
*
* - 渗透率张量的逆值，[2.x.213] 。对于验证解的精确性和确定收敛顺序的目的来说，这个张量的作用大于帮助。因此，我们将简单地把它设置为同一矩阵。     
* 然而，在现实生活中的多孔介质流动模拟中，空间变化的渗透率张量是不可缺少的，我们想利用这个机会来展示使用张量值函数的技术。     
* 可能毫不奇怪，deal.II也有一个基类，不仅适用于标量和一般矢量值的函数（[2.x.214]基类），也适用于返回固定维度和等级的张量的函数，即[2.x.215]模板。在这里，所考虑的函数返回一个dim-by-dim矩阵，即一个等级为2、维度为[2.x.216]的张量。然后我们适当地选择基类的模板参数。     
* [2.x.217]类提供的接口本质上等同于[2.x.218]类。特别是，存在一个[2.x.219]函数，它接收一个评估函数的点的列表，并在第二个参数中返回函数的值，一个张量的列表。
*


* [1.x.123]
*
* 实现起来就不那么有趣了。和以前的例子一样，我们在类的开头添加一个检查，以确保输入和输出参数的大小是一样的（关于这个技术的讨论见[2.x.220]）。然后我们在所有的评估点上循环，对于每一个评估点，将输出张量设置为身份矩阵。     
* 在函数的顶部有一个奇怪的地方（`(void)point;`语句），值得讨论。我们放到输出`values`数组中的值实际上并不取决于函数被评估的坐标`points`数组。换句话说，`points'参数实际上是不用的，如果我们想的话，可以不给它起名字。但是我们想用`points`对象来检查`values`对象是否有正确的大小。问题是在发布模式下，`AssertDimension'被定义为一个宏，扩展为空；然后编译器会抱怨`points'对象没有使用。消除这个警告的习惯方法是有一个评估（读取）变量的语句，但实际上不做任何事情：这就是`(void)points;`所做的：它从`points`中读取，然后将读取的结果转换为`void`，也就是什么都没有。换句话说，这句话是完全没有意义的，除了向编译器解释是的，这个变量事实上是被使用的，即使是在发布模式下。(在调试模式下，`AssertDimension`宏会扩展为从变量中读取的东西，所以在调试模式下，这个有趣的语句是没有必要的)。
*


* [1.x.124]
*
* [1.x.125] [1.x.126]。


*
* [1.x.127] [1.x.128]。


*
* 在这个类的构造函数中，我们首先存储传入的关于我们将使用的有限元的度数的值（例如，度数为0，意味着使用RT(0)和DG(0)），然后构造属于介绍中描述的空间[2.x.221]的向量值元素。构造函数的其余部分与早期的教程程序一样。   
* 这里唯一值得描述的是，这个变量所属的[2.x.222]类的构造函数调用有很多不同的构造函数，都是指将较简单的元素绑定在一起，成为一个较大的元素。在目前的情况下，我们想把一个RT(度)元素与一个DQ(度)元素结合起来。这样做的[2.x.223]构造函数要求我们首先指定第一个基本元素（给定程度的[2.x.224]对象），然后指定这个基本元素的副本数量，然后类似地指定[2.x.225]元素的种类和数量。注意Raviart-Thomas元素已经有[2.x.226]个矢量分量，所以耦合元素将有[2.x.227]个矢量分量，其中第一个[2.x.228]个对应于速度变量，最后一个对应于压力。   
* 还值得比较的是，我们从基本元素中构建这个元素的方式，与我们在[2.x.229]中的方式相比较：在那里，我们将其构建为[2.x.230]，即我们简单地使用[2.x.231]元素，每个坐标方向上的位移都有一份。
*


* [1.x.129]
*
* [1.x.130] [1.x.131]。


*
* 接下来的这个函数从众所周知的函数调用开始，创建和细化一个网格，然后将自由度与之相关联。
*


* [1.x.132]
*
* 然而，接下来事情就变得不同了。正如在介绍中提到的，我们想把矩阵细分为对应于速度和压力这两种不同类型的变量的块。为此，我们首先要确保与速度和压力相对应的指数不会混在一起。首先是所有速度自由度，然后是所有压力自由度。这样一来，全局矩阵就很好地分离成一个[2.x.232]系统。为了达到这个目的，我们必须根据自由度的矢量分量对其重新编号，这个操作已经很方便地实现了。
*


* [1.x.133]
*
* 接下来，我们要弄清楚这些块的大小，以便我们可以分配适当的空间。为此，我们调用了[2.x.233]函数，该函数统计了某个向量分量的多少个形状函数为非零。我们有[2.x.234]个向量分量，[2.x.235]将计算有多少个形状函数属于这些分量中的每个。     
* 这里有一个问题。正如该函数的文档所描述的，它 [1.x.134] 将 [2.x.236] -速度形状函数的数量放入 [2.x.237] 中，将 [2.x.238] -速度形状函数的数量放入 [2.x.239] 中（以及类似的3d），并将压力形状函数的数量放入 [2.x.240] 中 。但是，Raviart-Thomas元素的特殊性在于它是非[2.x.241]"原始 "的，也就是说，对于Raviart-Thomas元素，所有的速度形状函数在所有分量中都是非零。换句话说，该函数不能区分[2.x.242]和[2.x.243]的速度函数，因为[1.x.135]没有这种区别。因此，它将速度的总体数量放入[2.x.244]、[2.x.245]中的每一个。另一方面，压力变量的数量等于在dim-th分量中不为零的形状函数的数量。     
*利用这一知识，我们可以从[2.x.246]中的任何第一个[2.x.247]元素中得到速度形状函数的数量，然后用下面这个来初始化向量和矩阵块大小，以及创建输出。     
*


* [2.x.248] 如果你觉得这个概念难以理解，你可以考虑用函数[2.x.249]来代替，就像我们在[2.x.250]中的相应代码一样。你可能还想阅读一下术语表中[2.x.251]"块 "和[2.x.252]"组件 "之间的区别。
*


* [1.x.136]
*
* 下一个任务是为我们将要创建的矩阵分配一个稀疏模式。我们使用与前面步骤一样的压缩稀疏模式，但是由于[2.x.253]是一个块状矩阵，我们使用[2.x.254]类，而不仅仅是[2.x.255] 。这种块状稀疏模式在[2.x.256]模式中有四个块。块的大小取决于[2.x.257]，它持有速度和压力变量的数量。在第二步中，我们必须指示块系统更新它所管理的块的大小的知识；这发生在[2.x.258]的调用中。
*


* [1.x.137]
*
* 我们以与非区块版本相同的方式使用压缩的区块稀疏模式，以创建稀疏模式，然后创建系统矩阵。
*


* [1.x.138]
*
* 然后我们必须以与块压缩稀疏模式完全相同的方式调整解和右侧向量的大小。
*


* [1.x.139]
*
* [1.x.140] [1.x.141]。


*
* 同样，组装线性系统的函数在这个例子的介绍中已经讨论过很多了。在它的顶部，发生的是所有的常规步骤，此外我们不仅为单元项分配正交和[2.x.259]对象，而且还为面项分配。之后，我们为变量定义通常的缩写，并为本地矩阵和右手贡献分配空间，以及保存当前单元本地自由度的全局数的数组。
*


* [1.x.142]
*
* 下一步是声明代表源项、压力边界值和方程中的系数的对象。除了这些代表连续函数的对象外，我们还需要数组来保存它们在各个单元格（或面，对于边界值）的正交点的值。请注意，在系数的情况下，数组必须是矩阵的一种。
*


* [1.x.143]
*
* 最后，我们需要几个提取器，用来获取矢量值形状函数的速度和压力成分。它们的功能和使用在[2.x.260] vector_valued报告中详细描述。基本上，我们将把它们作为下面FEValues对象的下标：FEValues对象描述了形状函数的所有矢量分量，而在订阅后，它将只指速度（一组从零分量开始的[2.x.261]分量）或压力（位于[2.x.262]位置的标量分量）。
*


* [1.x.144]
*
* 有了这些，我们就可以继续在所有单元格上进行循环。这个循环的主体已经在介绍中讨论过了，这里就不再做任何评论了。
*


* [1.x.145]
*
* 在所有单元的循环中，最后一步是将局部贡献转移到全局矩阵和右手边的向量中。请注意，我们使用的接口与之前的例子完全相同，尽管我们现在使用的是块状矩阵和向量，而不是常规的。换句话说，对于外界来说，块对象具有与矩阵和向量相同的接口，但它们还允许访问单个块。
*


* [1.x.146]
*
* [1.x.147] [1.x.148]。



* 我们在这个例子中使用的线性求解器和预处理器已经在介绍中进行了详细的讨论。因此，我们在这里不再讨论我们的方法的理由，而只是对剩下的一些实现方面进行评论。
*


* [1.x.149] [1.x.150]。


*
* 正如在介绍中已经概述的那样，求解功能基本上由两个步骤组成。首先，我们必须形成涉及舒尔补数的第一个方程并求解压力（解决方案的第1部分）。然后，我们可以从第二个方程（解的第0部分）中重建速度。
*


* [1.x.151]
*
* 作为第一步，我们声明对矩阵的所有块分量、右手边和我们将需要的解向量的引用。
*


* [1.x.152]
*
* 然后，我们将创建相应的LinearOperator对象，并创建[2.x.263]运算器。
*


* [1.x.153]
*
* 这使得我们可以声明舒尔补数 [2.x.264] 和近似舒尔补数 [2.x.265] 。
*


* [1.x.154]
*
* 我们现在从[2.x.266]中创建一个预处理程序，应用固定数量的30次（便宜的）CG迭代。
*


* [1.x.155]

* 现在来看看第一个方程。它的右边是[2.x.267] ，这就是我们在前几行计算的内容。然后我们用CG求解器和我们刚刚声明的预处理器来解决第一个方程。
*


* [1.x.156]
*
* 在我们得到压力之后，我们可以计算速度。方程为[2.x.268] ，我们通过首先计算右手边，然后与代表质量矩阵逆的物体相乘来解决这个问题。
*


* [1.x.157]
*
* [1.x.158] [1.x.159]。



* [1.x.160] [1.x.161]。


*
* 在我们处理完线性求解器和预处理器之后，我们继续实现我们的主类。特别是，下一个任务是计算我们数值解的误差，包括压力和速度。   
* 为了计算解的误差，我们已经在[2.x.270]和[2.x.271]中介绍了[2.x.269]函数。然而，在那里我们只处理了标量解，而在这里我们有一个矢量值的解，其分量甚至表示不同的量，并且可能有不同的收敛阶数（由于所使用的有限元的选择，这里不是这种情况，但在混合有限元应用中经常是这种情况）。因此，我们要做的是 "掩盖 "我们感兴趣的成分。这很容易做到：[2.x.272]函数将一个指向权重函数的指针作为其参数之一（参数默认为空指针，意味着单位权重）。我们要做的是传递一个函数对象，在我们感兴趣的成分中等于1，而在其他成分中等于0。例如，为了计算压力误差，我们应该传递一个函数，代表在分量[2.x.273]中具有单位值的常数向量，而对于速度，常数向量在第一个[2.x.274]分量中应该是1，而在压力的位置是0。   
* 在deal.II中，[2.x.275]正是这样做的：它想知道它要表示的函数应该有多少个向量分量（在我们的例子中，这将是[2.x.276]，对于速度-压力联合空间），哪个个体或范围的分量应该等于1。因此，我们在函数的开头定义了两个这样的掩码，接下来是一个代表精确解的对象和一个向量，我们将在其中存储由[2.x.277]计算的单元误差。
*


* [1.x.162]
*
* 正如在[2.x.278]中已经讨论过的，我们必须认识到不可能准确地对误差进行积分。我们所能做的就是用正交法对这个积分进行近似。这实际上在这里提出了一个小小的转折：如果我们像人们可能倾向于做的那样天真地选择一个[2.x.279]类型的对象（这就是我们用于积分线性系统的对象），就会发现误差非常小，根本不遵循预期的收敛曲线。现在的情况是，对于这里使用的混合有限元，高斯点恰好是超收敛点，其中的点误差比其他地方小得多（而且收敛的阶数更高）。因此，这些点不是特别好的积分点。为了避免这个问题，我们简单地使用梯形法则，并在每个坐标方向上迭代[2.x.280]次（同样如[2.x.281]中的解释）。
*


* [1.x.163]
*
* 有了这个，我们就可以让库计算错误并将其输出到屏幕上。
*


* [1.x.164]
*
* [1.x.165] [1.x.166]。


*
* 最后一个有趣的函数是我们生成图形输出的函数。请注意，所有的速度分量都有相同的解名 "u"。再加上使用[2.x.282]，这将使[2.x.283]产生单个速度分量的矢量表示，更多信息请参见[2.x.284]或[2.x.285]模块的 "生成图形输出 "部分。最后，对于高阶元素来说，在图形输出中每个单元只显示一个双线性四边形似乎不合适。因此，我们生成大小为(度数+1)x(度数+1)的斑块来捕捉解决方案的全部信息内容。关于这方面的更多信息，请参见[2.x.287]的教程程序。
*


* [1.x.167]
*
* [1.x.168] [1.x.169]。


*
* 这是我们主类的最后一个函数。它唯一的工作是按照自然顺序调用其他函数。
*


* [1.x.170]
*
* [1.x.171] [1.x.172]。


*
* 我们从 [2.x.288] 而不是 [2.x.289] 那里偷来的主函数。它几乎等同于 [2.x.290] 中的函数（当然，除了改变了类的名称），唯一的例外是，我们将有限元空间的度数传递给混合拉普拉斯问题的构造函数（这里，我们使用零阶元素）。
*


* [1.x.173]
* [1.x.174][1.x.175] 。


*[1.x.176][1.x.177]


*
* 如果我们按原样运行程序，对于我们使用的[2.x.291]网格，我们得到这样的输出（总共1024个单元，有1024个压力自由度，因为我们使用片状常数，还有2112个速度，因为Raviart-Thomas元素定义每个面有一个自由度，有[2.x.292]个面与[2.x.293]轴平行，同样数量与[2.x.294]轴平行）。
* [1.x.178]
*
* 迭代次数如此之少的事实，当然是由于我们所开发的良好（但昂贵！）的预处理程序。为了获得对解决方案的信心，让我们看一下它。下面三幅图显示了（从左到右）X-速度、Y-速度和压力。
* [2.x.295]


*
* 让我们从压力开始：它在左边最高，在右边最低，所以流动将从左到右。此外，虽然在图中很难看出来，但我们选择了这样的压力场，即从左到右的流动首先是向中心流动，然后再向外流动。因此，X-速度必须增加以使流动通过狭窄的部分，这一点在左图中很容易看到。中间的图像代表域的左端Y方向的内流，以及域的右端Y方向的外流。
*

*
* 作为补充，请注意左图中的x-速度在x方向上是连续的，而y-速度在y方向上是连续的。其他方向的流场是不连续的。这非常明显地反映了Raviart-Thomaselements的连续性特性，事实上，它只在空间H(div)而不是在空间[2.x.296]。最后，压力场是完全不连续的，但鉴于我们选择了[2.x.297]作为该求解分量的有限元，这并不奇怪。
*


*[1.x.179][1.x.180]


*
* 该程序提供了两个明显的地方，在那里播放和观察收敛性：使用的有限元的程度（传递给[2.x.298]的构造器），和细化水平（在[2.x.299]中确定）。我们可以做的是改变这些值，并观察以后在程序运行过程中计算出的误差。
*

*
*如果这样做，就会发现压力变量中的[2.x.300]错误有如下模式。[2.x.301]
* 理论上预期的收敛顺序很好地反映在表中最后一行所显示的实验观察结果中。
*

*
* 我们可以用速度变量的[2.x.302]误差做同样的实验。[2.x.303] 这里关于收敛顺序的结果是一样的。
*


* [1.x.181][1.x.182][1.x.183] 。


*[1.x.184][1.x.185]


* 地下水或油藏模拟的现实流动计算不会使用恒定的渗透率。下面是改变这种情况的第一个相当简单的方法：我们使用一个在远离中心流线的地方迅速衰减的渗透率，直到它达到一个0.001的背景值。这是为了模拟流体在砂岩中的行为：在大部分区域中，砂岩是均匀的，虽然对流体有渗透性，但不是过度的渗透；在另一块石头上，石头沿着一条线出现了裂缝，或者说断层，流体沿着这条大裂缝流得更密了。下面是我们如何实现类似的东西。
* [1.x.186]
* 记住，该函数返回渗透率张量的逆值。
*

*
* 用明显更高的网格分辨率，我们可以将其可视化，这里用x-和y-速度。
* [2.x.304]
* 很明显，流体基本上只沿着中线流动，而不是其他地方。
*

*
* 另一种可能性是使用随机渗透率场。实现这一点的一个简单方法是在域的周围散布一些中心，然后使用一个渗透率场，它是这些中心的（负）指数之和。然后，流动将试图从一个高渗透率的中心跳到下一个中心。这是一种完全不科学的描述随机介质的尝试，但是实现这种行为的一种可能性是这样的。
* [1.x.187]
*
* 这个张量的逆的对角线元素的片状常数插值（即[2.x.305]）看起来如下。
* [2.x.306]
*

* 有了这样一个渗透率场，我们将得到如下的X-velocities和压力。
* [2.x.307]
* 我们将在 [2.x.308] 和 [2.x.309] 中再次使用这些渗透率场。
*

*[1.x.188][1.x.189]


* 正如介绍中提到的，这里使用的Schur补码求解器并不是可以想象的最好的（也不打算成为一个特别好的）。更好的解算器可以在文献中找到，并且可以使用这里介绍的相同的块矩阵技术来构建。我们在[2.x.310]中再次讨论了这个主题，在那里我们首先为斯托克斯方程建立了一个Schur补数求解器，就像我们在这里所做的那样，然后在[1.x.190]部分讨论了基于求解系统整体但基于单个块的预处理的更好方法。我们还将在[2.x.311]中再次讨论这个问题。
*

* [1.x.191][1.x.192] [2.x.312] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-2_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12]
*[1.x.13][1.x.14][1.x.15] 。


* [2.x.2]
* 在前面的例子中，我们已经创建了一个网格，现在我们要展示如何在这个网格上定义自由度。在这个例子中，我们将使用最低阶的([2.x.3])有限元，其自由度与网格的顶点相关。后面的例子将展示高阶元素，自由度不一定与顶点相关，但可以与边、面或单元相关。
* 术语 "自由度 "在有限元界通常被用来表示两个略有不同但相关的东西。首先，我们希望将有限元解表示为形状函数的线性组合，形式为[2.x.4] 。这里，[2.x.5]是一个膨胀系数的向量。因为我们还不知道它们的值（我们将计算它们作为线性或非线性系统的解），它们被称为 "未知数 "或 "自由度"。这个术语的第二层含义可以解释如下。对有限元问题的数学描述通常是说，我们正在寻找一个满足某些方程组的有限维函数[2.x.6]（例如，[2.x.7]为所有测试函数[2.x.8]）。换句话说，我们在这里说的是，解决方案需要位于某个空间 [2.x.9] 中。然而，为了在计算机上实际解决这个问题，我们需要选择这个空间的一个基；这就是我们在上面用系数[2.x.12]展开[2.x.11]时使用的形状函数[2.x.10]的集合。当然，空间[2.x.13]有许多基数，但我们将特别选择由有限元函数描述的基数，这些函数传统上是在网格单元上局部定义的。在这种情况下描述 "自由度 "需要我们简单地[1.x.16]空间的基函数[2.x.14]。对于[2.x.15]元素来说，这意味着简单地以某种方式列举网格的顶点，但对于更高阶的元素，我们还必须列举与网格的边、面或单元内部相关的形状函数。换句话说，自由度的列举是与我们用于顶点的指数完全不同的事情。提供这种列举[2.x.16]基础函数的类被称为DoFHandler。
* 在网格上定义自由度（简称 "DoF"）是一个非常简单的任务，因为这个库为你做了所有的工作。从本质上讲，你所要做的就是创建一个有限元对象（从deal.II已有的许多有限元类中选取，例如参见[2.x.17]文档），并通过[2.x.18]函数将其交给DoFHandler对象（"分配DoF "是我们用来描述[1.x.17]基础函数过程的术语，如上所述）。DoFHandler是一个知道哪个自由度在哪里的类，也就是说，它可以回答 "全球有多少个自由度 "和 "在这个单元上，给我住在这里的形状函数的全球索引 "这样的问题。这就是你在确定系统矩阵应该有多大，以及将单个单元的贡献复制到全局矩阵时需要的信息。
*[1.x.18][1.x.19]
*

* 然后，下一步将是使用这个有限元和网格计算对应于特定微分方程的矩阵和右手边。我们将为[2.x.19]程序保留这一步骤，而讨论有限元程序的一个实际问题，即有限元矩阵总是非常稀疏的：矩阵中几乎所有条目都是零。
* 更准确地说，如果一个矩阵中的非零项[1.x.20]的数量与总体自由度数无关，我们就说该矩阵是稀疏的。例如，拉普拉斯方程的有限差分逼近的简单5点模版导致了一个稀疏矩阵，因为每行的非零条目数是5，因此与矩阵的总大小无关。对于更复杂的问题
*
* 例如，[2.x.20]的斯托克斯问题
*
* 特别是在三维中，每行的条目数可能是几百个。但重要的一点是，这个数字与问题的整体大小无关：如果你细化网格，每行的未知数的最大数量保持不变。
* 稀疏性是有限元方法的显著特征之一，与之相比，使用泰勒展开和匹配系数来逼近局部微分方程的解，或使用傅里叶基。
* 在实践中，正是矩阵的稀疏性使我们能够解决具有数百万或数十亿未知数的问题。为了理解这一点，请注意，具有[2.x.21]行的矩阵，每个非零项的数量都有一个固定的上限，需要[2.x.22]个内存位置来存储，而矩阵-向量乘法也只需要[2.x.23]次操作。因此，如果我们有一个线性求解器，只需要固定数量的矩阵-向量乘法就可以得到这个矩阵的线性系统的解，那么我们就会有一个求解器，可以以最佳的复杂度找到所有[2.x.24]个未知数的值，也就是说，总共只需要[2.x.25]次运算。显然，如果矩阵不是稀疏的，这是不可能的（因为那时矩阵中的条目数必须是[2.x.26]和一些[2.x.27]，而且做固定数量的矩阵-向量乘积需要[2.x.28]次操作），但这也需要非常专业的求解器，如多重网格方法，以满足求解只需要固定数量的矩阵-向量乘法的要求。在本教程的其余程序中，我们将经常研究使用何种求解器的问题。
* 稀疏性是由以下事实产生的：有限元形状函数是在单个单元上定义的[1.x.21]，而不是在全球范围内定义的，而且双线型中的局部微分算子只对支持度重叠的形状函数进行耦合。(一个函数的 "支持 "是指它非零的区域。对于有限元方法，形状函数的支持通常是与它所定义的顶点、边或面相邻的单元。)换句话说，不在同一单元上定义的自由度[2.x.29]和[2.x.30]不会重叠，因此，矩阵条目[2.x.31]将为零。  在某些情况下，如非连续Galerkin方法，形状函数也可以通过面积分连接到邻近的单元。但是有限元方法一般不会将形状函数连接到定义了该函数的单元的近邻之外）。)
*

*[1.x.22][1.x.23]


* 默认情况下，DoFHandler类以相当随机的方式列举网格上的自由度；因此，稀疏度模式也不是为任何特定目的而优化的。为了说明这一点，下面的代码将演示一种简单的方法来输出对应于DoFHandler的 "稀疏模式"，也就是说，一个对象代表了在网格和DoFHandler上离散化偏微分方程时可能建立的所有潜在的非零元素矩阵。在sparsitypattern中这种结构的缺乏将从我们下面展示的图片中显而易见。
* 对于大多数应用和算法来说，自由度的确切编号方式并不重要。例如，我们用来解决线性系统的共轭梯度方法并不关心。另一方面，有些算法确实关心：特别是一些预处理程序，如SSOR，如果它们能以特定的顺序走过自由度，就能更好地工作，如果我们能将它们分类，使SSOR能以这种顺序从零到[2.x.32]进行迭代，那就太好了。其他的例子包括计算不完整的LU或Cholesky因式分解，或者如果我们关心矩阵的块结构（见[2.x.33]的例子）。因此，deal.II在命名空间DoFRenumbering中有可以重新列举自由度的特定方式的算法。重新编号可以被认为是选择了一个不同的、经过排列的有限元空间的基础。因此，这种重新编号所产生的稀疏模式和矩阵也是简单的行和列的排列组合，与我们没有明确的重新编号所得到的相比。
* 在下面的程序中，我们将使用Cuthill和McKee的算法来做这件事。我们将在[1.x.24]中显示原始自由度枚举和重新编号的版本的稀疏模式。
*

* [1.x.25] [1.x.26]。
* 前面几个包括的内容和前面的程序一样，所以不需要额外的注释。
*


* [1.x.27]
*
* 然而，下一个文件是新的。我们需要这个包含文件来将自由度（"DoF "s）与顶点、线和单元联系起来。
*


* [1.x.28]
*
* 以下包括对双线性有限元的描述，包括它在三角形的每个顶点上有一个自由度，但在面和单元内部没有自由度的事实。
*

*
*（事实上，该文件包含了一般的拉格朗日元素的描述，即也有二次、三次等版本，而且不仅是2d，还有1d和3d）。
*


* [1.x.29]
*
* 在以下文件中，可以找到几个操纵自由度的工具。
*


* [1.x.30]
*
* 我们将使用一个稀疏矩阵来可视化自由度在网格上的分布所导致的非零项的模式。那个类可以在这里找到。
*


* [1.x.31]
*
* 我们还需要使用一个中间的稀疏模式结构，在这个文件中可以找到。
*


* [1.x.32]

* 我们将希望使用一种特殊的算法来重新对自由度进行编号。它在这里被声明。
*


* [1.x.33]
*
* 而这又是C++输出所需要的。
*


* [1.x.34]
*
* 最后，和[2.x.34]一样，我们将deal.II命名空间导入到全局范围。
*


* [1.x.35]
*
* [1.x.36] [1.x.37]。


*
* 这是在之前的[2.x.35]示例程序中产生圆形网格的函数，其细化步骤较少。唯一的区别是它通过其参数返回它所产生的网格。
*


* [1.x.38]
*
* [1.x.39] [1.x.40]。


*
* 到目前为止，我们只有一个网格，即一些几何信息（顶点的位置）和一些拓扑信息（顶点如何与线相连，线与单元相连，以及哪些单元与其他单元相邻）。要使用数值算法，还需要一些逻辑信息：我们希望将自由度数字与每个顶点（或线，或单元，如果我们使用高阶元素的话）联系起来，以便以后生成描述三角形上有限元场的矩阵和矢量。
*

*
* 这个函数展示了如何做到这一点。要考虑的对象是[2.x.36]类模板。  然而，在我们这样做之前，我们首先需要一些东西来描述这些对象中的每一个要关联多少个自由度。由于这是有限元空间定义的一个方面，有限元基类存储了这个信息。因此，在目前情况下，我们创建了一个描述拉格朗日元素的派生类[2.x.37]的对象。它的构造函数需要一个参数，说明元素的多项式程度，这里是1（表示一个双线性元素）；这就对应于每个顶点的一个自由度，而线和四边形内部没有自由度。如果给构造函数的值是3，我们就会得到一个双立方体元素，每个顶点有一个自由度，每条线有两个自由度，单元内有四个自由度。一般来说，[2.x.38]表示具有完整多项式（即张量积多项式）的连续元素家族，直到指定的顺序。
*

*
* 我们首先需要创建一个这个类的对象，然后把它传递给[2.x.39]对象，为自由度分配存储空间（用deal.II的行话说：我们[1.x.41]）。
*


* [1.x.42]
*
* 现在我们已经将自由度与全局数字关联到每个顶点，我们想知道如何将其可视化？  没有简单的方法可以直接将与每个顶点相关的自由度数字可视化。然而，这样的信息几乎不会真正重要，因为编号本身或多或少是任意的。还有更重要的因素，我们将在下文中展示其中一个。   
* 与三角形的每个顶点相关的是一个形状函数。假设我们想解决类似拉普拉斯方程的问题，那么不同的矩阵条目将是每对这样的形状函数的梯度的积分。显然，由于形状函数只在与它们相关的顶点相邻的单元格上是非零的，所以只有当与该列和行%号相关的形状函数的支持相交时，矩阵条目才是非零的。这只是相邻形状函数的情况，因此也只是相邻顶点的情况。现在，由于顶点被上述函数[2.x.40]或多或少地随机编号，矩阵中非零项的模式将有些参差不齐，我们现在就来看看它。   
* 首先，我们必须创建一个结构，用来存储非零元素的位置。然后，这可以被一个或多个稀疏矩阵对象使用，这些对象在这个稀疏模式所存储的位置上存储条目的值。存储这些位置的类是SparsityPattern类。然而，事实证明，当我们试图立即填充这个类时，这个类有一些缺点：它的数据结构的设置方式是，我们需要对我们可能希望在每一行的最大条目数有一个估计。在两个空间维度上，通过[2.x.41]函数可以得到合理的估计值，但是在三个维度上，该函数几乎总是严重高估真实的数字，导致大量的内存浪费，有时对于所使用的机器来说太多，即使未使用的内存可以在计算稀疏模式后立即释放。为了避免这种情况，我们使用了一个中间对象DynamicSparsityPattern，该对象使用了一个不同的%内部数据结构，我们可以随后将其复制到SparsityPattern对象中，而不会有太多的开销。关于这些数据结构的一些更多信息可以在[2.x.42]模块中找到）。为了初始化这个中间数据结构，我们必须给它提供矩阵的大小，在我们的例子中，矩阵是正方形的，行和列的数量与网格上的自由度相同。
*


* [1.x.43]
*
* 然后我们用非零元素的位置来填充这个对象，鉴于目前自由度的编号，非零元素将位于这些地方。
*


* [1.x.44]
*
* 现在我们已经准备好创建实际的稀疏性模式，以后我们可以用在我们的矩阵上。它将包含已经组装在DynamicSparsityPattern中的数据。
*


* [1.x.45]
*
* 有了这个，我们现在可以把结果写到一个文件里。
*


* [1.x.46]
*
* 结果存储在一个[2.x.43]文件中，矩阵中的每个非零条目都对应于图像中的一个红色方块。输出结果将显示如下。   
* 如果你看一下，你会注意到稀疏性模式是对称的。这不应该是一个惊喜，因为我们没有给[2.x.44]任何信息，表明我们的双线性形式可能以非对称的方式耦合形状函数。你还会注意到，它有几个明显的区域，这源于编号从最粗的单元开始，然后到较细的单元；由于它们都是围绕原点对称分布的，这在稀疏模式中又显示出来。
*


* [1.x.47]
*
* [1.x.48] [1.x.49]。


*
* 在上面产生的稀疏模式中，非零项在对角线上的延伸相当远。对于一些算法来说，例如不完整的LU分解或Gauss-Seidel预处理，这是不利的，我们将展示一个简单的方法来改善这种情况。
*

*
* 请记住，要使矩阵中的一个条目[2.x.45]为非零，形状函数i和j的支持需要相交（否则在积分中，积分项将到处为零，因为在某个点上，要么是一个形状函数，要么是另一个形状函数为零）。然而，形状函数的支撑点只有在彼此相邻的情况下才会相交，因此，为了使非零条目聚集在对角线周围（其中[2.x.46]等于[2.x.47]），我们希望相邻的形状函数的索引（DoF号码）不会相差太多。
*

*
* 这可以通过一个简单的前行算法来完成，即从一个给定的顶点开始，给它的索引为0。然后，对它的邻居依次进行编号，使它们的指数接近于原始指数。然后，他们的邻居，如果还没有被编号，也被编号，以此类推。
*


* 一种沿着这些思路增加了一点复杂性的算法是Cuthill和McKee的算法。我们将在下面的函数中使用它来对自由度进行重新编号，从而使产生的稀疏模式在对角线周围更加本地化。该函数唯一有趣的部分是对[2.x.48]的第一次调用，其余部分基本上与以前一样。
*


* [1.x.50]

* 同样，输出结果显示如下。请注意，非零项在对角线周围的聚类情况要比以前好得多。这种效果对于较大的矩阵来说更加明显（目前的矩阵有1260行和列，但大的矩阵往往有几十万行）。
*

*
* 值得注意的是，[2.x.49]类也提供了一些其他的算法来重新编号自由度。例如，如果所有的耦合都在矩阵的下三角或上三角部分，那当然是最理想的，因为那样的话，解决线性系统就只相当于向前或向后的替换。当然，这对于对称稀疏模式来说是无法实现的，但在一些涉及传输方程的特殊情况下，通过列举从流入边界沿流线到流出边界的自由度，这是可能的。毫不奇怪，[2.x.50]也有这方面的算法。
*



*
* [1.x.51] [1.x.52]。



* 最后，这是主程序。它所做的唯一事情是分配和创建三角形，然后创建一个[2.x.51]对象并将其与三角形相关联，最后对其调用上述两个函数。
*


* [1.x.53]
*[1.x.54][1.x.55]


* 该程序在运行后产生了两个疏散模式。我们可以通过在网络浏览器中打开[2.x.52]文件来观察它们。
* 结果是这样的（每一个点都表示一个可能为非零的条目；当然，该条目是否为零取决于所考虑的方程，但矩阵中的指示位置告诉我们，在离散化局部方程，即微分方程时，哪些形状函数可以和哪些不可以耦合）。[2.x.53]
* 左图中的不同区域，由线条中的结点和左侧及顶部的单点表示，代表了三角法不同细化层次上的自由度。  从右图中可以看出，经过编号后，矩阵的主对角线附近的稀疏度模式更加集中。虽然这一点可能不明显，但两张图片中的非零项的数量是相同的，当然。
*


*[1.x.56][1.x.57]


* 就像[2.x.54]一样，你可能想在程序中玩一下，让自己熟悉一下deal.II。例如，在[2.x.55]函数中，我们使用线性有限元（FE_Q对象的参数 "1 "就是这样）。如果你使用高阶元素，例如立方体或五元体（使用3和5作为各自的参数），探索稀疏模式如何变化。
* 你也可以通过细化网格来探索稀疏性模式的变化。你会发现不仅矩阵的大小会发生变化，而且其带宽也会发生变化（矩阵中离对角线最远的非零元素与对角线的距离），不过带宽与大小的比例通常会缩小，也就是说，矩阵在对角线周围的聚集度会更高。
* 另一个实验想法是尝试DoFRenumbering命名空间中除Cuthill-McKee之外的其他重编号策略，看看它们如何影响稀疏度模式。
* 你也可以使用[1.x.58]（较简单的可视化程序之一；也许不是最容易使用的，因为它是命令行驱动的，但在所有Linux和其他类似Unix的系统上也普遍可用）通过改变[2.x.56]来实现输出的可视化。
* [1.x.59]
*
* 基于[1.x.60]的另一种做法是尝试打印出带有支撑点位置和编号的网格。为此，你需要包含GridOut和MappingQ1.的头文件，其代码为。
* [1.x.61]
* 在我们运行该代码后，我们得到一个名为gnuplot.gpl的文件。要查看这个文件，我们可以在命令行中运行以下代码。
* [1.x.62].有了这个，你会得到一个类似于[2.x.57]的图片，这取决于你正在看的网格。更多信息，请参见[2.x.58]。
*

*[1.x.63][1.x.64] [2.x.59]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-21_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38]
*[1.x.39][1.x.40][1.x.41] 。


* 这个项目是由德克萨斯A&amp;M大学的李艳的一个学生项目发展而来。这个项目的大部分工作是由她完成的。
* 在这个项目中，我们为多孔介质中的两个相流问题提出了一个数值模拟。这个问题包括一个椭圆方程和一个非线性的、与时间相关的传输方程。因此，这也是第一个时间相关的教程程序（除了[2.x.2]" [2.x.3]"有点奇怪的时间相关）。
* 这里涉及的方程是 [2.x.4] 中已经涉及的材料的扩展。特别是，它们属于向量值问题的范畴。关于这一主题的顶层概述可以在[2.x.5]模块中找到。
*

*[1.x.42][1.x.43] 。


* 多孔介质中的两相流建模对于环境修复以及石油和地下水储层的管理都很重要。涉及两相流动的实际情况包括含水层中非水相液体的分散，或储层中油和水等流体混合物的联合运动。仿真模型如果要提供真实的预测，就必须准确地考虑到这些影响。
* 为了推导出管理方程，考虑储层中的两相流动[2.x.6]，假设流体的运动由粘性效应主导；也就是说，我们忽略了重力、压缩性和毛细压力的影响。孔隙率将被认为是恒定的。我们将用下标[2.x.7]和[2.x.8]来表示这两个阶段的变量，即水和油的简称。然而，这些方程的解读对其他流体对也是适用的。
* 两相分子的运动速度由达西定律决定，即速度与压力梯度成正比：[1.x.44] 。
* 其中[2.x.9]是相[2.x.10]的速度，[2.x.11]是渗透性张量，[2.x.12]是相[2.x.13]的相对渗透性，[2.x.14]是压力，[2.x.15]是相[2.x.16]的黏度。最后，[2.x.17]是饱和度（体积分数），即一个数值在0和1之间的函数，表示流体混合物的组成。一般来说，系数[2.x.18]可能是空间依赖性的变量，在下文中我们总是将其视为非常数函数。
* 我们将达西定律与每一相的质量守恒声明结合起来，[1.x.45]每相都有一个源项。通过对两相求和，我们可以用所谓的压力方程来表达管理方程：[1.x.46] 。
* 这里，[2.x.19]是总源项，[1.x.47]是总流动性。
* 到目前为止，这看起来是一个普通的静止的、类似泊松的方程，我们可以用前几个教程程序的技术立即解决（例如，看一下[2.x.20]，就可以看到非常类似的东西）。然而，我们还没有提到饱和度的问题，当然，饱和度会随着流体的移动而改变。
* 方程的第二部分是对饱和度动态的描述，即两种液体的相对浓度如何随时间变化。置换流体（水）的饱和方程由以下守恒定律给出：[1.x.48] 。
*可以通过使用前一个方程中的发散算子的乘积规则来重写：[1.x.49] 。
* 这里，[2.x.21]是上面介绍的总流入量，[2.x.22]是置换流体（水）的流速。这两者与分流量[2.x.23]的关系如下：[1.x.50]其中分流量通常通过（启发式）表达式[1.x.51]进行参数化。 将所有这些放在一起，得到饱和方程式，其形式如下：[1.x.52
*其中[2.x.24]是总速度[1.x.53]注意，平流方程包含术语[2.x.25]而不是[2.x.26]，以表明饱和度不是简单地沿途传送；相反，由于两相以不同的速度移动，即使在平流坐标系中，饱和度实际上也可以改变。为了看到这一点，重写[2.x.27]，以观察具有饱和度[2.x.28]的相的[1.x.54]速度是[2.x.29]，而另一个相的速度是[2.x.30]。  因此，[2.x.31]通常被称为[1.x.55]。
* 综上所述，我们得到的是以下两个方程：[1.x.56] 。
* 这里，[2.x.32]现在是随时间变化的函数：虽然在每个时间点上，流场与压力是不平衡的（即我们忽略了动态加速），但饱和度是随着流动而传输的，因此随时间变化，反过来又通过第一个方程对[2.x.33]的依赖而影响流场。
* 这组方程有一个特殊的特点：两个方程中的一个有时间导数，另一个没有。这与压力和速度通过瞬时约束耦合的特点相对应，而饱和度在有限的时间尺度上演变。
* 这样的方程组被称为微分代数方程（DAEs），因为其中一个方程是微分方程，另一个不是（至少就时间变量而言不是），因此是一个 "代数 "方程。这个符号来自常微分方程领域，在这个领域中，所有不具有关于时间变量的导数的东西都必然是代数方程）。这类方程包含了相当知名的情况：例如，依赖时间的斯托克斯和纳维尔-斯托克斯方程（其中代数约束是流场的发散，[2.x.34]，必须为零）以及依赖时间的麦克斯韦方程（这里，代数约束是电位移场的发散等于电荷密度，[2.x.35] ，磁通密度的发散为零。  [2.x.36]）；即使是[2.x.37]的准静态模型也属于这一类别。我们将看到，这两个方程的不同特征将告知我们这两个方程的离散化策略。
*

*[1.x.57][1.x.58]


* 在储层模拟界，通常是通过回到一阶混合配方来解决上述方程。为此，我们重新引入总速度[2.x.38]，并将方程写成以下形式：[1.x.59] 。
* 这种提法还有一个好处，即我们不必把运输方程中出现的总速度[2.x.39]作为压力的函数来表示，而是可以把它作为主要变量。鉴于前两个方程的鞍点结构以及它们与我们在[2.x.40]中介绍的混合拉普拉斯公式的相似性，我们将再次使用混合离散化，这一点并不奇怪。
* 但让我们先把这个问题推迟一下。我们处理这些方程的第一件事是考虑时间离散化问题。在储层模拟中，有一个相当标准的算法，我们将在这里使用。它首先使用隐式方程解决压力问题，然后使用显式时间步进方案解决饱和问题。该算法被称为IMplicit PressureExplicit Saturation（隐式压力显式饱和），很早以前就被提出：1959年由Sheldon等人提出，1961年由Stone和Gardner提出（J. W. Sheldon, B. Zondek andW.T. Cardwell）。[1.x.60], Trans.SPE AIME, 216 (1959), pp. 290-296; H.L. Stone and A. O. Gardner Jr: [1.x.61], Trans.SPE AIME, 222 (1961), pp. 92-104)。在一个稍加修改的形式中，这个算法可以写成如下：对于每个时间步长，求解[1.x.62]
*其中[2.x.41]是一个时间步长。请注意我们是如何解决只取决于先前计算的饱和度[2.x.42]的隐式压力-速度系统的，然后对[2.x.43]做显式时间步长，只取决于先前已知的[2.x.44]和刚计算的[2.x.45]。这样一来，我们就不必像使用全隐式方法那样对系统的非线性进行迭代。(从更现代的角度来看，这应该被看作是一种 "算子拆分 "方法。  [2.x.46]对这背后的想法有一个很长的描述）。)
* 然后，我们可以以弱的形式说明问题，用测试函数[2.x.47]、[2.x.48]和[2.x.49]乘以上述方程，并通过部分积分来表示：[1.x.63] 。
* 注意，在第一项中，我们必须规定边界[2.x.51]上的压力[2.x.50]作为我们问题的边界值。  [2.x.52]表示对[2.x.53]的单位外向法向量，如常。
* 对于饱和方程，我们通过部分积分得到[1.x.64]。
* 利用[2.x.54]这一事实，我们可以重写cell项，得到一个方程如下：[1.x.65] 。
* 我们引入一个DiscreteTime类型的对象，以便在代码中跟踪当前的时间值和时间步长。这个类封装了许多关于调整时间步长和在指定的最终时间停止的复杂情况。
*


*[1.x.66][1.x.67]


* 在每个时间步长中，我们将[2.x.55]" [2.x.56]"的混合有限方法应用于速度和压力。为了得到良好的解决，我们选择Raviart-Thomas空间[2.x.57]作为[2.x.58]，选择类[2.x.59]的不连续元素作为[2.x.60]。对于饱和度，我们也将选择[2.x.61]空间。
* 由于我们有不连续的空间，我们必须考虑如何在单元格之间的界面上评估参数，因为不连续的函数在那里并没有真正的定义。特别是，我们必须给饱和度方程左边的最后一个定理赋予一个意义。为此，让我们定义，我们要在以下意义上评估它：[1.x.68] 。
* 其中[2.x.62]表示流入边界，[2.x.63]是边界的流出部分。然后数量[2.x.64]对应于当前单元上的变量值，而[2.x.65]（需要在[2.x.66]的边界流入部分）是取自邻近单元的数量。关于非连续单元技术和流速评估的更多背景，也可以在[2.x.67]和[2.x.68]中找到b。
*

*[1.x.69][1.x.70]


* 本程序中使用的线性求解器是对[2.x.69]中使用的线性求解器的直接扩展（但没有LinearOperator）。从本质上讲，我们只需将一切从两个求解组件扩展到三个。如果我们使用上面提到的离散空间，并将形状函数放到双线性形式中，就会发现在时间步长[2.x.70]中需要解决以下线性系统：[1.x.71]其中各个矩阵和向量的定义如下：使用形状函数[2.x.71]（Raviart Thomas[2.x.72]类型）用于velocities，[2.x.73]（2.x.74）类型用于压力和饱和度：[1.x.72]
*
* [2.x.75] 由于历史事故，与[2.x.78]相比，矩阵[2.x.76]和[2.x.77]的作用在本程序中被还原了。换句话说，这里[2.x.79]指的是发散，[2.x.80]指的是梯度算子，而在[2.x.81]中则正好相反。
* 上面的系统出现了一个复杂的问题。由于矩阵[2.x.82]隐含地依赖于[2.x.83]（速度需要确定细胞边界[2.x.84]的哪些部分是流入或流出的部分），我们只有在解决了速度问题之后才能组装这个矩阵。
* 然后，求解方案包括以下步骤。[2.x.85] [2.x.86] 使用[2.x.88]中介绍的Schur补数技术求解压力[2.x.87] 。
* [2.x.89] 解决速度[2.x.90]，这在[2.x.91]中也有讨论。
* [2.x.92] 计算项[2.x.93] ，使用刚刚计算的速度。
* [2.x.94] 求解饱和度 [2.x.95] 。[2.x.96]
* 在这个方案中，我们实际上从未建立矩阵[2.x.97]，而是在我们准备好之后生成第三个方程的右边。
* 在程序中，我们使用一个变量[2.x.98]来存储当前时间步骤的解决方案。在每一步结束时，我们将其内容，即其所有三个块状成分，复制到变量[2.x.99]中，以便在下一步使用。
*

*[1.x.73][1.x.74]


* 像我们要解决的饱和方程这样的双曲运输方程的一般经验法则是，如果我们使用显式时间步长方案，那么我们应该使用一个时间步长，使粒子在一个时间步长内所能走的距离不大于单个细胞的直径。换句话说，在这里，我们应该选择[1.x.75]。幸运的是，我们处于一个可以做到这一点的位置：我们只需要在我们想要组装饱和方程的右侧时，也就是在我们已经解决了[2.x.100]之后，才需要这个时间步长。因此，在求解速度之后，我们所要做的就是在域中的所有正交点上循环，确定速度的最大幅度。然后我们可以将饱和方程的时间步长设置为[1.x.76] 。
* 为什么要这样做呢？如果我们不这样做，那么我们就会出现很多地方的饱和度大于1或小于0，这一点很容易得到验证。请记住，饱和度相当于流体混合物中的水的比例，因此物理上必须介于0和1之间）。另一方面，如果我们根据上述标准选择时间步长，这种情况只会非常非常少地发生，事实上在程序的整个运行过程中只有一次。然而，为了安全起见，我们在每个时间步长结束时运行一个函数[2.x.101]，如果饱和度超出了物理范围，则简单地将其投射回间隔[2.x.102]。这很有用，因为函数[2.x.103]和[2.x.104]并不代表这个范围以外的任何物理现象，而且我们不应该期望程序在我们有负的饱和度或大于1的饱和度时做任何有用的事情。
* 请注意，在[2.x.105]和[2.x.106]中，我们对时间步长也有类似的限制，在那里我们要解决时间相关的波浪方程，也是一个双曲问题。我们还将在下面的[1.x.77]一节中回到时间步长的选择问题。
*

*[1.x.78][1.x.79] 。


* 为简单起见，本程序假定没有源头，[2.x.107]，而且异质多孔介质是各向同性的[2.x.108]。其中第一个假设在石油储层中是现实的：除了注入井和生产井，通常没有液体突然出现或消失的机制。第二个假设更难证明：在微观层面上，大多数岩石是各向同性的，因为它们是由相互连接的孔隙网络组成的。然而，这种微观尺度超出了今天计算机模拟的范围，我们不得不满足于模拟米级的东西。然而，在这个尺度上，流体运输通常是通过岩石中的裂缝网络，而不是通过孔隙。然而，裂缝往往是由岩层中的外部应力场造成的（例如由构造断层造成的），因此裂缝是大致排列的。这就导致了这样一种情况：在与裂缝平行的方向上，渗透率往往比垂直于裂缝的方向上大几个数量级。然而，在储层模拟中通常面临的一个问题是，建模者不知道裂缝的方向，因为油藏不容易被检查到。在这种情况下，唯一的解决办法是假设一个有效的、各向同性的渗透率。
* 无论怎样，这两个限制，即无源和各向同性，都可以通过程序中的几行代码轻松解除。
* 接下来，为了简单起见，我们的数值模拟将在单元格[2.x.109]上进行，用于[2.x.110] 。我们的初始条件是[2.x.111]；在油藏图中，[2.x.112]表示水的饱和度，这意味着油藏一开始就含有纯油。请注意，我们不需要任何压力或速度的初始条件，因为方程中不包含这些变量的时间衍生物。最后，我们施加以下压力边界条件：[1.x.80]由于压力和速度解决的是混合形式的泊松方程，施加的压力导致了速度的流场结果。另一方面，这个流场决定了边界的某一部分是流入还是流出，这一点很重要，因为我们必须对边界的流入部分的饱和度施加边界条件，[1.x.81]在这个流入的边界上，我们施加以下的饱和度值：[1.x.82] 。
* 换句话说，我们有纯水在左边进入储层，而边界的其他部分与储层的未受干扰部分接触，只要这些边界上发生流入，纯油就会进入。
* 在我们的模拟中，我们选择总的流动性为[1.x.83]，其中我们使用[2.x.113]的粘度。此外，水的部分流量由[1.x.84]给出。
* [2.x.114] 几年后，在[2.x.115]中再回到这个测试案例，发现这个测试案例的设置存在缺陷。为此，考虑到我们可以把饱和度的平流方程写成 [2.x.116] 。现在，在初始时间，我们有[2.x.117]，而在给定的函数[2.x.118]的选择下，我们正好有[2.x.119]。换句话说，在[2.x.120]处，方程对所有[2.x.122]都还原为[2.x.121]，所以饱和度在任何地方都是零，而且在任何地方都会保持零！这就是为什么[2.x.122]处的饱和度为零。尽管[2.x.123]不一定是零：组合流体在移动，但我们选择的部分通量[2.x.124]是这样的：有限数量的润湿流体也只以无限小的速度移动（也就是说，它们粘附在介质上的程度比它们所处的非润湿相要大）。也就是说，我们如何将这一点与润湿液从左边侵入，导致在[1.x.85]中看到的流动模式的知识相联系？这就是我们进入数学的地方。像我们在这里考虑的传输方程有无限多的解决方案，但其中只有一个是物理的：从所谓的粘性极限产生的解决方案，称为[1.x.86]。问题是，在不连续元素的情况下，我们得出了这个粘度极限，因为使用数值通量在数值方案中引入了有限量的人工粘度。另一方面，在[2.x.125]中，我们在每个单元上使用与[2.x.126]成比例的人工粘度，在初始时间为零。因此，那里的饱和度为零并保持为零；然后我们得到的解是[1.x.87]的对流方程的解，但该方法不需要进一步改变就能收敛到粘度解。因此，我们将在该程序中使用一个不同的初始条件。
*

* 最后，回到测试案例的描述，我们将展示在[2.x.127]"[2.x.128]"的结果部分末尾介绍的两个渗透率函数的计算结果：[2.x.129][2.x.130]一个函数，模拟一条蜿蜒穿过域的裂缝。与[2.x.131]相类似，但考虑到我们这里的几何形状略有不同，我们用以下函数来描述它。  [1.x.88] 取最大值是必要的，以确保最大和最小磁导率之间的比率保持有界。如果我们不这样做，渗透率将跨越许多数量级。另一方面，最大和最小渗透率之间的比率是舒尔补矩阵的条件数的一个因素，如果太大，会导致我们的线性求解器不再正常收敛的问题。
* [2.x.132] 一个模拟某种随机介质的函数。这里，我们选择[1.x.89]。
* 其中中心[2.x.133]是域内[2.x.134]随机选择的位置。这个函数模拟了一个领域，其中有[2.x.135]个渗透率较高的中心（例如，岩石已经开裂），嵌入到更原始的、未受干扰的背景岩石矩阵中。请注意，在这里，我们在上方和下方都切断了渗透率函数，以确保有一个有界的条件数。[2.x.136]
*

* [1.x.90] [1.x.91] 。
* 这个程序是对 [2.x.137] 的改编，包括了 [2.x.138] 的一些DG方法的技术。因此，该程序的很大一部分与 [2.x.139] 非常相似，我们将不再对这些部分进行评论。只有新的东西会被更详细地讨论。
*


* [1.x.92] [1.x.93]。


*
* 所有这些包含文件以前都被使用过。
*


* [1.x.94]

* 在这个程序中，我们使用一个张量值的系数。由于它可能具有空间依赖性，我们认为它是一个张量值的函数。下面的include文件提供了提供这种功能的[2.x.140]类。
*


* [1.x.95]
*
* 此外，我们使用类[2.x.141]来执行与时间递增有关的操作。
*


* [1.x.96]

* 最后一步和以前的所有程序一样。
*


* [1.x.97]
*
* [1.x.98] [1.x.99]。


*
* 这是该程序的主类。它接近于[2.x.142]的那个，但有一些额外的功能。   
* [2.x.143] [2.x.144] [2.x.145] 组装饱和方程的右侧。正如介绍中所解释的，这不能被集成到[2.x.146]中，因为它取决于在时间步长的第一部分计算的速度。   
* [2.x.147] [2.x.148]的作用正如其名称所示。这个函数被用于计算时间步长。   
* [2.x.149] [2.x.150] 将所有饱和度小于零的自由度重置为零，将所有饱和度大于一的自由度重置为一。   [2.x.151]
* 该类的其余部分应该是非常明显的。变量[2.x.152]存储粘度[2.x.153]，它进入了非线性方程中的几个公式。变量[2.x.154]记录了模拟中的时间信息。
*


* [1.x.100]
*
* [1.x.101] [1.x.102]。



* [1.x.103] [1.x.104]。


*
* 目前，压力方程的右侧仅仅是零函数。然而，如果需要的话，程序的其余部分完全可以处理其他任何事情。
*


* [1.x.105]
*
* [1.x.106] [1.x.107]。


*
*接下来是压力边界值。正如介绍中提到的，我们选择一个线性压力场。
*


* [1.x.108]
*
* [1.x.109] [1.x.110]。


*
*那么我们还需要边界的流入部分的边界值。某物是否为流入部分的问题是在组装右手边时决定的，我们只需要提供边界值的功能描述。这正如介绍中所解释的。
*


* [1.x.111]
*
* [1.x.112] [1.x.113]。


*
* 最后，我们需要初始数据。实际上，我们只需要饱和度的初始数据，但我们很懒，所以我们以后在第一个时间步骤之前，简单地从一个包含所有矢量分量的函数中插值出前一个时间步骤的整个解。   
*因此，我们简单地创建一个函数，在所有分量中返回零。我们通过简单地将每个函数转发到[2.x.155]类来做到这一点。为什么不在这个程序中我们目前使用[2.x.156]类的地方立即使用呢？因为这样的话，以后再去选择不同的函数作为初始值就更简单了。
*


* [1.x.114]
*
* [1.x.115] [1.x.116]。


*
* 正如介绍中所宣布的，我们实现了两个不同的渗透率张量场。我们把它们各自放在一个命名空间中，这样以后就可以很容易地在代码中用另一个来代替一个的使用。
*


* [1.x.117] [1.x.118]。


*
* 渗透率的第一个函数是模拟单个弯曲裂缝的函数。它在[2.x.157]的结尾已经使用过了，它的函数形式在本教程程序的介绍中给出。和以前的一些程序一样，我们必须声明KInverse类的一个（似乎是不必要的）默认构造函数，以避免某些编译器的警告。
*


* [1.x.119]
*
* [1.x.120] [1.x.121]。


*
* 这个函数的作用正如介绍中所宣布的那样，即在随机的地方创建一个指数的叠加。对于这门课，有一件事值得考虑。这个问题的中心是，这个类使用随机函数创建指数的中心。如果我们因此在每次创建本类型的对象时都创建中心，我们每次都会得到一个不同的中心列表。这不是我们对这种类型的类的期望：它们应该可靠地代表同一个函数。   
* 解决这个问题的方法是使中心列表成为这个类的一个静态成员变量，也就是说，整个程序中只存在一个这样的变量，而不是为这个类型的每个对象。这正是我们要做的。   
* 然而，接下来的问题是，我们需要一种方法来初始化这个变量。由于这个变量是在程序开始时初始化的，我们不能使用普通的成员函数，因为当时身边可能没有这个类型的对象。因此C++标准规定，只有非成员函数和静态成员函数可以用来初始化静态变量。我们通过定义一个函数[2.x.158]来使用后一种可能性，该函数在调用时计算中心点的列表。   
* 注意这个类在2D和3D中都能正常工作，唯一的区别是我们在3D中使用了更多的点：通过实验我们发现我们在3D中比2D中需要更多的指数（毕竟我们有更多的地方需要覆盖，如果我们想保持中心之间的距离大致相等），所以我们在2D中选择40，在3D中选择100。对于任何其他维度，该函数目前不知道该怎么做，所以只是简单地抛出一个异常，表明这一点。
*


* [1.x.122]
*
* [1.x.123] [1.x.124]。



* 还有两个数据我们需要描述，即反迁移函数和饱和曲线。它们的形式也在介绍中给出。
*


* [1.x.125]
*
* [1.x.126] [1.x.127]。


*
* 我们使用的线性求解器也完全类似于 [2.x.159] 中使用的线性求解器。因此，下面的类是逐字逐句地从那里复制的。请注意，这里的类不仅是从[2.x.160]中复制的，而且在deal.II中也有重复的类。在这个例子的未来版本中，它们应该被一个有效的方法所取代，虽然。有一个变化：如果线性系统的大小很小，也就是说，当网格很粗时，那么在[2.x.161]函数中的求解器收敛之前，设置最大的[2.x.162]CG迭代次数有时是不够的。(当然，这是数值取舍的结果，因为我们知道，在纸面上，CG方法最多只能在[2.x.163]步内收敛)。因此，我们设定最大迭代次数等于线性系统大小的最大值和200。
*


* [1.x.128]
*
* [1.x.129] [1.x.130]。


*
* 这里是主类的实现。它的大部分内容实际上是从[2.x.164]中复制过来的，所以我们不会对它进行过多的评论。你应该试着先熟悉一下那个程序，然后这里发生的大部分事情就应该很清楚了。
*

*
* [1.x.131] [1.x.132]。


*
* 首先是构造函数。我们使用[2.x.165]空间。对于初始化DiscreteTime对象，我们不在构造函数中设置时间步长，因为我们还没有它的值。时间步长最初被设置为零，但在需要增量时间之前，它将被计算出来，正如介绍的一个小节中所描述的。时间对象在内部阻止自己在[2.x.166]时被递增，迫使我们在推进时间之前为[2.x.167]设置一个非零的期望大小。
*


* [1.x.133]
*
* [1.x.134] [1.x.135]。


*
* 接下来的函数从众所周知的函数调用开始，创建和细化一个网格，然后将自由度与之关联。它所做的事情与[2.x.168]中的相同，只是现在是针对三个组件而不是两个。
*


* [1.x.136]
*
* [1.x.137] [1.x.138]。


*
* 这是组装线性系统的函数，或者至少是除了(1,3)块之外的所有东西，它取决于在这个时间步长中计算的仍然未知的速度（我们在[2.x.169]中处理这个问题）。它的大部分内容与[2.x.170]中一样，但这次我们必须处理一些非线性问题。  然而，函数的顶部与平常一样（注意，我们在开始时将矩阵和右手边设置为零&mdash；对于静止问题我们不必这样做，因为在那里我们只使用每个矩阵对象一次，而且在开始时它是空的）。   
* 请注意，在目前的形式下，该函数使用[2.x.171]类中实现的渗透率。切换到单曲裂缝渗透率函数就像改变命名空间名称一样简单。
*


* [1.x.139]

* 这里是第一个重要的区别。我们必须在正交点上获得前一个时间步长的饱和函数值。为此，我们可以使用[2.x.172]（之前已经在[2.x.173]、[2.x.174]和[2.x.175]中使用），这个函数接收一个解向量并返回当前单元的正交点的函数值列表。事实上，它返回每个正交点的完整矢量值解，即不仅是饱和度，还有速度和压力。
*


* [1.x.140]
*
* 然后我们还必须得到压力的右手边和反渗透性张量在正交点的数值。
*


* [1.x.141]
*
* 有了这些，我们现在可以在这个单元格上的所有正交点和形状函数上进行循环，并将我们在这个函数中处理的矩阵和右手边的那些部分组合起来。鉴于引言中所述的双线性形式的明确形式，贡献中的各个条款应该是不言自明的。
*


* [1.x.142]
*
* 接下来，我们还得处理压力边界值的问题。这一点，还是和[2.x.176]中一样。
*


* [1.x.143]
*
*在所有单元的循环中，最后一步是将局部贡献转移到全局矩阵和右手向量中。
*


* [1.x.144]
*
* 矩阵和右手边的组装就这么多了。请注意，我们不需要插值和应用边界值，因为它们都已经在弱式中得到了处理。
*



*
* [1.x.145] [1.x.146]。


*
* 正如介绍中所解释的，我们只有在计算出速度后才能评估饱和方程的右边。因此，我们有这个单独的函数来实现这个目的。
*


* [1.x.147]

* 首先是单元项。按照介绍中的公式，这些是[2.x.177] ，其中[2.x.178]是测试函数的饱和成分。
*


* [1.x.148]
*
* 其次，我们要处理面边界上的通量部分。这就有点麻烦了，因为我们首先要确定哪些是细胞边界的流入和流出部分。如果我们有一个流入的边界，我们需要评估面的另一边的饱和度（或者边界值，如果我们在域的边界上）。         
* 所有这些都有点棘手，但在 [2.x.179] 中已经有了一些详细的解释。请看一下，这应该是如何工作的!
*


* [1.x.149]
*
* [1.x.150] [1.x.151]。


*
* 在所有这些准备工作之后，我们最终以与[2.x.180]中相同的方式解决速度和压力的线性系统。在这之后，我们必须处理饱和方程（见下文）。
*


* [1.x.152]

* 首先是压力，使用前两个方程的压力舒尔补码。
*


* [1.x.153]

* 现在的速度。



* [1.x.154]
*
* 最后，我们必须处理好饱和度方程。我们在这里要做的第一件事是使用介绍中的公式来确定时间步长。知道了我们领域的形状和我们通过有规律的划分单元创建的网格，我们可以很容易地计算每个单元的直径（事实上我们使用的是单元坐标方向上的线性扩展，而不是直径）。请注意，我们将在[2.x.181]中学习一种更通用的方法，在那里我们使用[2.x.182]函数。     
* 我们使用一个辅助函数来计算下面定义的最大速度，有了这些，我们就可以评估我们新的时间步长了。我们使用方法[2.x.183]来向DiscreteTime对象建议新的时间步长计算值。在大多数情况下，时间对象使用精确提供的值来增加时间。在某些情况下，时间对象可以进一步修改步骤大小。例如，如果计算出的时间增量超过了结束时间，它将被相应地截断。
*


* [1.x.155]

* 下一步是组装右手边，然后把所有的东西都传给解。最后，我们把饱和度投射回物理上的合理范围。
*


* [1.x.156]
*
* [1.x.157] [1.x.158]。


*
* 这里没有什么令人惊讶的。由于程序会做大量的时间步骤，我们只在每第五个时间步骤创建一个输出文件，并在文件的顶部已经跳过所有其他时间步骤。   
*在为接近函数底部的输出创建文件名时，我们将时间步长的数字转换为字符串表示，用前导零填充到四位。我们这样做是因为这样所有的输出文件名都有相同的长度，因此在创建目录列表时可以很好地排序。
*


* [1.x.159]
*
* [1.x.160] [1.x.161]。


*
* 在这个函数中，我们简单地遍历所有的饱和自由度，并确保如果它们应该离开物理上的合理范围，那么它们将被重置到区间 [2.x.184] 。要做到这一点，我们只需循环查看解向量的所有饱和分量；这些分量被存储在块2中（块0是速度，块1是压力）。   
* 值得注意的是，当时间步长选择在介绍中提到的时候，这个函数几乎从不触发。然而，如果我们只选择稍大的时间步长，我们会得到大量超出适当范围的数值。严格地说，如果我们选择的时间步长足够小，这个函数就没有必要。从某种意义上说，这个函数只是一个安全装置，以避免由于个别自由度在几个时间步长之前变得不符合物理条件而导致我们的整个解决方案变得不符合物理条件的情况。
*


* [1.x.162]
*
* [1.x.163] [1.x.164]。


*
* 以下函数用于确定允许的最大时间步长。它的作用是在域中的所有正交点上循环，并找出速度的最大幅度。
*


* [1.x.165]
*
* [1.x.166] [1.x.167]。


*
* 这是我们主类的最后一个函数。它的简洁不言自明。只有两点是值得注意的。首先，该函数在开始时将初始值投射到有限元空间；[2.x.185]函数这样做需要一个表明悬挂节点约束的参数。我们在这个程序中没有（我们在一个均匀细化的网格上计算），但是这个函数当然需要这个参数。所以我们必须创建一个约束对象。在原始状态下，约束对象是没有排序的，在使用前必须进行排序（使用[2.x.186]函数）。这就是我们在这里所做的，这也是为什么我们不能简单地用一个匿名的临时对象[2.x.188]作为第二个参数来调用[2.x.187]函数。   
* 第二点值得一提的是，我们只在求解每个时间步长对应的线性系统的过程中计算当前时间步长。因此，我们只有在时间步长结束时才能输出一个时间步长的当前时间。我们通过调用循环内的方法[2.x.189]来增加时间。由于我们在增量后报告时间和dt，我们必须调用方法[2.x.190]，而不是[2.x.191]。 经过许多步，当仿真到达结束时间时，最后的dt由DiscreteTime类选择，其方式是最后一步正好在结束时间完成。
*


* [1.x.168]

* [1.x.169] [1.x.170]。


*
* 这就是了。在主函数中，我们将有限元空间的度数传递给TwoPhaseFlowProblem对象的构造函数。  这里，我们使用零度元素，即[2.x.192] 。其余部分与所有其他程序一样。
*


* [1.x.171]
* [1.x.172][1.x.173] 。


* 这里介绍的代码并没有实际计算网页上发现的结果。原因是，即使在一台普通的计算机上，它也要运行一天以上。如果你想重现这些结果，请在两相流问题的构造器中把离散时间对象的结束时间修改为`250'。
* 如果我们运行该程序，我们会得到以下的输出。
* [1.x.174]
* 我们可以看到，时间步长从一开始就非常恒定，这表明域中的速度并不强烈依赖于饱和度的变化，尽管它们肯定是通过压力方程中的因子[2.x.193]来实现的。
* 我们的第二个观察结果是，在第一个和第二个时间步骤之间，解决压力舒尔补足方程所需的CG迭代次数从22次下降到17次（事实上，在其余的计算中，它仍然是17次左右）。原因其实很简单。在我们求解一个时间步长的压力之前，我们没有将[2.x.194]变量重置为零。因此，当我们进入CG求解器时，压力（和其他变量）具有前一个时间步长的值。由于速度和压力在计算过程中变化不大，前一时间段的压力实际上是对这一时间段压力的良好初始猜测。因此，一旦我们计算了一次压力，我们需要的迭代次数就会大大减少。
* 最后的观察是关于解决饱和度问题所需的迭代次数，即一次。这不应该让我们太惊讶：我们要解决的矩阵是质量矩阵。然而，这是[2.x.195]元素的质量矩阵，其中没有元素与相邻单元的自由度相耦合。因此，该矩阵是一个对角线，很明显，我们应该能够在一次CG迭代中反转该矩阵。
*

*有了这些，这里有几段电影，显示了饱和度是如何随时间推移而发展的。首先，这是在[2.x.196]类中实现的单裂缝模型。
* [2.x.197]
* 可以看出，富水流体主要是沿着域中间的高渗透区蜿蜒前行，而域的其他部分大部分是不渗透的。这部电影和下一部电影是用[2.x.198]生成的，导致[2.x.199]的网格有大约16000个单元和大约66000个未知数。
*

* 第二部电影显示了[2.x.200]类的随机介质模型的饱和度，其中我们有随机分布的高渗透率中心，流体从这些区域中的一个跳到另一个。
* [2.x.201]
*

* 最后，这里是在三个空间维度上的相同情况，在一个带有[2.x.202]的网格上，产生一个大约32000个单元和167000个自由度的网格。
* [2.x.203]
* 要重复这些计算，你所要做的就是改变这一行
* [1.x.175]
* 将主函数中的一行改为
* [1.x.176]
* 可视化使用了云技术，每个单元的饱和度都由彩色但透明的云来表示。这样一来，人们也可以看到域的深处发生了什么。一种不同的可视化方式是显示饱和度随时间变化的等值线。有一些技术可以透明地绘制等值面，这样人们就可以像看洋葱层一样同时看到几个等值面。
* 那么，为什么我们不显示这样的等值面呢？问题在于计算等值面的方式：它们要求被可视化的场是连续的，因此等值面可以通过遵循至少跨越一个单元的轮廓线来生成。然而，我们的饱和场是片状常数和不连续的。如果我们想为一个饱和度[2.x.204]绘制一个等值面，那么在这个领域中，很可能没有一个点是真正达到饱和度的。如果我们必须在这种情况下定义等值线，我们将不得不采取细胞之间的界面，其中相邻的两个细胞的饱和度大于，另一个细胞的饱和度小于0.5。然而，大多数可视化程序似乎并不具备做这种转换的能力。
*

* [1.x.177][1.x.178][1.x.179] 。


* 这个项目有许多可以改进的地方。下面列出了其中的三个方面。事实上，所有这些都在构成当前程序的延续的教程程序中得到解决。  [2.x.205] .
*

*[1.x.180][1.x.181]


* 目前，该程序不是特别快：二维随机介质的计算在1000个左右的时间步数中花费了大约一天的时间。相应的三维计算在800个时间步数上几乎花了两天时间。它没有比这更快的原因有两个方面。首先，我们在每个时间步骤中都要重建整个矩阵，尽管有些部分如[2.x.206]、[2.x.207]和[2.x.208]块从未改变。
* 第二，我们可以在求解器和预处理器方面做得更好。目前，我们用CG方法求解舒尔补码[2.x.209]，用[2.x.210]作为预调节器。应用这个预处理程序是很昂贵的，因为它每次都要解决一个线性系统。这对于[2.x.211]"[2.x.212]"可能是合适的，在那里我们只需要解决整个问题一次。然而，在这里，我们必须求解数百次，在这种情况下，值得考虑一个预处理程序，它在第一次设置时比较昂贵，但在以后应用时比较便宜。
* 一种可能性是认识到我们用作预处理的矩阵，[2.x.213]仍然是稀疏的，而且是对称的。如果看一下流场随时间的演变，我们还可以看到，虽然[2.x.214]随时间变化很大，但压力几乎没有变化，因此[2.x.215] 。换句话说，第一个时间步骤的矩阵应该是一个很好的预设条件，也适用于所有后来的时间步骤。  通过一些反反复复的操作，实际上不难得到一个SparseMatrix对象的表示。然后我们可以把它交给SparseMIC类来进行稀疏的不完全Cholesky分解。形成这种分解的成本很高，但是我们只需要在第一个时间步骤中做一次，然后就可以在将来把它作为一个廉价的预处理程序。我们甚至可以通过使用SparseDirectUMFPACK类来做得更好，它不仅可以产生一个不完整的，而且是一个完整的矩阵分解，这应该会产生一个更好的预处理程序。
* 最后，为什么使用近似值[2.x.216]对[2.x.217]进行预处理？后者的矩阵毕竟是拉普拉斯算子在压力空间上的混合形式，对此我们使用线补充。因此，我们可以在直接与拉普拉斯的非混合形式相对应的一侧建立一个单独的矩阵[2.x.218]，例如使用双线性形式[2.x.219]。然后我们可以对这个非混合矩阵进行不完全或完整的分解，并将其作为混合形式的预处理。
* 使用这样的技术，可以合理地预期，求解过程将至少快一个数量级。
*

*[1.x.182][1.x.183] 。


* 在引言中，我们确定了时间步长限制[1.x.184]，该限制必须在全局范围内成立，即对所有[2.x.220]。离散化后，我们通过选择[1.x.185]来满足它。
* 这种对时间步长的限制有点令人讨厌：我们把网格做得越细，时间步长就越小；换句话说，我们受到了两次惩罚：每个时间步长的求解费用更高，我们必须做更多的时间步长。
* 这一点特别令人恼火，因为大部分额外的工作都花在了解决方程的隐含部分，即压力-维络系统，而正是饱和度的双曲传输方程造成了时间步长的限制。
* 为了避免这一瓶颈，人们发明了一些方法。例如，他们可以每隔几个时间步数才重新计算压力-速度场（或者，如果你愿意，对压力/速度和饱和度方程使用不同的时间步数）。这样就可以保持对廉价显式部分的时间步长限制，而使隐式部分的求解不那么频繁。这个方向的实验肯定是值得的；这种方法的一个出发点是陈章新、桓冠仁和李宝岩的论文：[1.x.186]，Transport in Porous Media，54（2004），pp.361&mdash;376。当然也有很多其他关于这个主题的论文，但这篇论文是前段时间偶然出现在我们的办公桌上的。
*


*[1.x.187][1.x.188]。


* 适应性显然也会有帮助。看一下电影，我们可以清楚地看到，大部分的行动都被限制在领域的一个相对较小的部分（这对饱和度来说特别明显，但对velocities和压力来说也是如此）。因此，适应性可望保持必要的低自由度数，或者增加准确度。
* 另一方面，对于时间相关的问题，自适应性并非易事：我们必须每隔几步改变网格，而且每次改变网格时，我们都必须将目前的解决方案传送到下一个网格（SolutionTransfer类可以帮助解决这个问题）。这些都不是不可逾越的障碍，但它们确实需要一些额外的编码，而且比我们认为值得打包到这个教程程序中的还要多。
*

* [1.x.189][1.x.190] [2.x.221] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-22_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43][1.x.44]
* [2.x.3]
* [1.x.45]



*[1.x.46][1.x.47][1.x.48]


* 本程序处理斯托克斯方程组，其非维度形式如下：[1.x.49] 。
* 其中[2.x.4]表示流体的速度，[2.x.5]是压力，[2.x.6]是外力，[2.x.7]是对称梯度的第二级张量；其分量定义为[2.x.8] 。
* 斯托克斯方程描述了缓慢移动的粘性流体的稳态运动，如蜂蜜、地幔中的岩石或其他惯性不起作用的情况。如果流体的运动速度足够快，与粘性摩擦相比，惯性力的作用非常明显，那么斯托克斯方程就不再有效了；考虑到惯性效应，就会导致非线性的纳维-斯托克斯方程。然而，在本教程中，我们将重点讨论较简单的斯托克斯系统。
* 请注意，在推导更一般的可压缩纳维-斯托克斯方程时，扩散被建模为应力张量的发散[1.x.50] 。
* 其中[2.x.9]是流体的黏度。在[2.x.10]的假设下（假设粘度恒定，并通过除以[2.x.11]使方程非立体化），并假设不可压缩性（[2.x.12]），从上面的公式来看：[1.x.51] 。
* 一个不同的公式使用拉普拉斯算子（[2.x.13]）而不是对称梯度。这里的一个很大的区别是，速度的不同分量并不耦合。如果你假设解决方案[2.x.14]具有额外的不规则性（第二偏导存在并且是连续的），那么这些公式是等价的：[1.x.52] 。
* 这是因为[2.x.15]中的[2.x.16]的第1个条目是由：[1.x.53]给出的。
* 如果你不能假设上述的规律性，或者你的粘度不是一个常数，这个等价关系就不再成立。因此，我们决定在本教程中坚持使用更准确的物理学上的对称张量公式。
*

* 为了得到很好的解决，我们将不得不在方程中加入边界条件。一旦我们讨论方程的微弱形式，什么边界条件在这里是容易实现的就会清楚。
* 这里所涉及的方程属于矢量值问题的范畴。对这一主题的概述可以在[2.x.17]模块中找到。
*

*[1.x.54][1.x.55]


* 方程的弱形式是通过将其写成矢量形式得到的[1.x.56] 。
* 从左边开始与矢量值测试函数[2.x.18]形成点积，并在域[2.x.19]上进行积分，得出以下方程组：[1.x.57] 。
*这对所有测试函数[2.x.20]都必须成立。
* 一般来说，一个好的经验法则是，如果一个人[1.x.58]减少公式中任何变量的导数，那么一个人[1.x.59]实际上是用部分积分来做。这是由[1.x.60]的理论引起的，特别是强和[1.x.61]之间的区别）。我们已经为拉普拉斯方程做了这样的工作，在那里我们通过部分积分第二导数来获得弱的表述，即在测试和试算函数上都只有一个导数。
* 在当前情况下，我们对第二项进行分项积分：[1.x.62] 。
* 同样地，我们对第一项进行分项积分，得到[1.x.63] 。
* 两个张量之间的标量乘积被定义为[1.x.64] 。
* 利用这一点，我们现在已经把对变量的要求降低到对[2.x.21]的第一次导数和对[2.x.22]完全没有导数。
* 因为像[2.x.23]这样的一般张量与[2.x.24]这样的对称张量之间的标量积等于两者的对称形式之间的标量积，我们也可以把上面的双线性形式写成：[1.x.65] 。
* 我们将在下一节中处理边界项，但它已经从域项[1.x.66]中清除了。
* 斯托克斯方程产生了一个对称的双线性形式，因此也产生了一个对称的（如果是不确定的）系统矩阵。
*

*[1.x.67][1.x.68]


* [2.x.25] ( [2.x.26] )
* 刚刚导出的弱形式立即为我们提供了施加边界条件的不同可能性。[2.x.27] [2.x.28] Dirichlet速度边界条件。在一个部分[2.x.29]，我们可以对速度施加迪里希特条件[2.x.30] 。
* [1.x.69]
* 因为测试函数[2.x.31]来自解变量的切线空间，我们有[2.x.32]在[2.x.33]上，因此有[1.x.70]
* 换句话说，像往常一样，强加的边界值不会出现在弱形式中。
* 值得注意的是，如果我们在整个边界上施加Dirichlet边界值，那么压力就只能确定到一个常数。这方面的算法实现将使用类似于在[2.x.34]中看到的工具。
* [2.x.35] 诺伊曼型或自然边界条件。在边界的其余部分[2.x.36]，让我们把边界条款重新写成如下。    [1.x.71]
* 换句话说，在边界的诺伊曼部分，我们可以规定总应力的值。    [1.x.72]
* 如果边界被细分为Dirichlet和Neumann部分[2.x.37]，这就导致了以下的弱形式。    [1.x.73]
*
*

* [2.x.38] 罗宾式边界条件。罗宾式边界条件是迪里切特和诺伊曼边界条件的混合物。它们将读作 [1.x.74] 。
*有一个等级2的张量（矩阵） [2.x.39] 。相关的弱形式是[1.x.75] 。
*
* [2.x.40] 局部边界条件。有可能通过只对速度的某些分量强制执行Dirichlet和Neumann边界条件来结合它们中的每一个。例如，施加人工边界条件的一种方法是要求流动垂直于边界，即切向分量[2.x.41]为零，从而约束速度的[2.x.42]-1分量。剩下的分量可以通过要求法向应力的法向分量为零来约束，产生以下一组边界条件。    [1.x.76]
*
* 另一种情况是希望流向[1.x.77]而不是垂直于边界（在deal.II中，[2.x.43]函数可以帮你做到这一点）。这种情况经常发生在自由边界的问题上（例如，在河流或湖泊的表面，如果流动的垂直力不足以使表面实际变形），或者如果边界对流体没有施加明显的摩擦力（例如，在地幔和地核的界面上，两种流体因密度不同而相遇，但它们的粘度都很小，不会对彼此产生很大的切向应力）。    在公式中，这意味着[1.x.78]。
*第一个条件（需要强加）固定速度的一个分量，第二个条件（将在弱的形式下强制执行）固定其余的两个分量。[2.x.44]
* 尽管有这么多的可能性，我们在本教程中只使用迪里切特和（同质）诺伊曼边界条件。
*

*[1.x.79][1.x.80]


*如上所述，在[2.x.45]和[2.x.46]上有迪里切特和诺伊曼边界条件的方程的弱形式是这样的：找到[2.x.47]以便[1.x.81]
*对于所有测试函数[2.x.48]。
*这些方程代表一个对称的[1.x.82]。众所周知，只有当我们寻找解决方案的函数空间满足某些条件时，解决方案才存在，这些条件通常被称为Babuska-Brezzi或Ladyzhenskaya-Babuska-Brezzi（LBB）条件。上面的连续函数空间满足这些条件。然而，当我们将方程离散化，用有限维空间的有限元函数取代连续变量和检验函数时[2.x.49]，我们必须确保[2.x.50]也满足LBB条件。这与我们在[2.x.51]中要做的事情相似。
* 对于斯托克斯方程，有许多可能的选择来确保有限元空间与LBB条件兼容。一个简单而准确的选择是[2.x.52]，即对速度使用比压力高一阶的元素。
* 这就导致了以下的离散问题：找到[2.x.53]，使[1.x.83]在所有测试函数中都能得到满足。
* 对于所有测试函数[2.x.54]。与这个问题相关的线性系统的组装遵循[2.x.55]"[2.x.56]"、[2.x.57]中使用的相同路线，并在[2.x.58]模块中详细解释。
*


*[1.x.84][1.x.85]


* 离散方程的弱形式自然导致了速度场和压力场的节点值的以下线性系统：[1.x.86] 。
* 与[2.x.59]和[2.x.60]一样，我们将通过形成舒尔补数来解决这个方程组，即我们将首先找到[1.x.87]的[2.x.61]解。
* 然后是[1.x.88]。
* 我们这样做的方式与我们在之前的教程中所做的差不多，也就是说，我们再次使用相同的类[2.x.62]和[2.x.63]。然而，有两个显著的区别。
* [2.x.64] [2.x.65] 首先，在混合拉普拉斯方程中，我们必须处理如何对舒尔补数[2.x.66]进行预处理的问题，它在光谱上等同于压力空间的拉普拉斯算子（因为[2.x.67]代表梯度算子，[2.x.68]代表其邻接算子[2.x.69]，而[2.x.70]代表身份（直到材料参数[2.x.71]为止），因此[2.x.72]类似于[2.x.73]）。因此，他们的矩阵对于小的网格尺寸来说条件很差，我们不得不为Schur补数提出一个精心设计的预处理方案。
* [2.x.74] 其次，每次我们与[2.x.75]相乘时，我们必须用他们的矩阵[2.x.76]来解决。然而，这并不特别困难，因为质量矩阵总是有很好的条件的，所以使用CG和一点点预处理就可以简单地反转。[2.x.77]换句话说，[2.x.78]的内部求解器的预处理很简单，而[2.x.79]的外部求解器的预处理很复杂。
* 这里，情况几乎完全相反。差异源于这样一个事实，即舒尔补码的核心矩阵不是来自身份算子，而是来自拉普拉斯算子的一个变体，[2.x.80]（其中[2.x.81]是对称梯度），作用于一个矢量场。在研究这个问题时，我们主要遵循D.Silvester和A.Wathen的论文："稳定的斯托克斯系统的快速迭代解决第二部分。使用一般块状先决条件"。(SIAM J. Numer.Anal., 31 (1994), pp.1352-1367），可在线查阅[1.x.89].主要是，Schurcomplement的核心矩阵的差异有两个后果。
* [2.x.82] [2.x.83] 首先，它使外部预处理变得简单：Schur补码对应于压力空间上的算子[2.x.84]；忘记我们处理的是对称梯度而不是常规梯度的事实，Schur补码是类似[2.x.85]的东西，即使在数学上不是完全简洁的，在光谱上也等同于身份算子（一个启发式的说法是将算子换成[2.x.86] ）。事实证明，用CG方法直接解决这个Schur补数并不容易：在没有预设条件的情况下，Schur补数矩阵的条件数取决于最大和最小单元的大小比，而且仍然需要50-100次CG迭代。然而，有一个简单的解决办法：用压力空间上的质量矩阵进行预处理，我们就可以减少到5-15次CG迭代，几乎不受网格结构的影响（看看这个程序的[1.x.90]，可以看到CG迭代的数量确实没有随着网格的细化而改变）。
* 因此，除了我们已经有的东西之外，我们需要的是压力变量的质量矩阵，我们将把它存储在一个单独的对象中。
*


* [2.x.87] 虽然与[2.x.88]中讨论的混合拉普拉斯情况相比，外部预调节器变得更简单，但内部求解器的问题却变得更复杂。在混合拉普拉斯微分法中，舒尔补码的形式为 [2.x.89] 。因此，每当我们与Schur补码相乘时，我们必须解决线性系统[2.x.90]；然而，这并不太复杂，因为压力空间上的质量矩阵[2.x.91]是有条件的。
*

* 另一方面，对于我们这里考虑的斯托克斯方程，舒尔补码是[2.x.92]，其中矩阵[2.x.93]与拉普拉斯算子有关（实际上，它是对应于双线性形式[2.x.94]的矩阵）。因此，用[2.x.95]求解要复杂得多：矩阵的条件很差，我们知道我们需要多次迭代，除非我们有一个非常好的预处理程序。更糟糕的是，我们每次与舒尔补码相乘时都要用[2.x.96]求解，使用上述的预处理程序需要5-15次。
* 因为我们必须多次用[2.x.97]求解，所以多花一点时间为这个矩阵创建一个好的预处理程序是值得的。所以我们要做的是：如果在2d中，我们使用第二个预处理程序，即对矩阵进行直接稀疏LU分解。这是用SparseDirectUMFPACK类实现的，它使用UMFPACK直接求解器来计算分解。要使用它，你必须建立支持UMFPACK的deal.II（这是默认的）；参见[1.x.91]的说明。有了它，内解器在一次迭代中就能收敛。
* 在2D中，我们可以做这样的事情，因为即使是合理的大问题，也很少有超过100,000个未知数，而且每行的非零点相对较少。此外，2D中矩阵的带宽是[2.x.98]，因此是中等的。对于这样的矩阵，稀疏因子可以在几秒钟内计算完成。作为参考，计算一个大小为[2.x.99]、带宽为[2.x.100]的矩阵的稀疏因子需要[2.x.101]次操作。在2D中，这需要[2.x.102]；尽管这比例如组装线性系统需要[2.x.103]的复杂度要高，但计算分解的常数非常小，直到我们发现大量未知数的百分比在100,000以上，它才会成为整个程序中的主导因素。)
* 情况在3D中发生了变化，因为在那里我们很快就会有更多的未知数，而且矩阵的带宽（决定了稀疏LU因子中非零项的数量）是[2.x.104]，而且每行也有更多的条目。这使得使用像UMFPACK这样的稀疏直接求解器的效率很低：只有在问题规模为10,000到100,000个未知数时，才能用合理的时间和内存资源进行稀疏分解计算。
* 在这种情况下，我们所做的是使用一个不完整的LU分解（ILU）作为条件器，而不是实际计算完整的LU因子。正如它所发生的，deal.II有一个类可以做到这一点。SparseILU。计算ILU所需要的时间只取决于稀疏矩阵中非零项的数量（或者说我们愿意填入LU因子，如果这些因子比矩阵中的要多），但与矩阵的带宽无关。因此，这也是一个可以有效地在三维中计算的操作。另一方面，根据定义，一个不完整的LU分解并不代表矩阵的精确逆[2.x.105]。因此，用ILU进行预处理仍然需要一次以上的迭代，而不像用稀疏直接求解器进行预处理。因此，内部求解器在与舒尔补码相乘时将花费更多时间：这是一个不可避免的折衷。[2.x.106]
* 在下面的程序中，我们将利用SparseILU和SparseDirectUMFPACK类具有非常相似的接口，可以互换使用的事实。我们所需要的是一个开关类，根据维度的不同，提供一个类型，即上面提到的两个类中的任何一个。这就是我们如何做到的。
* [1.x.92]
*
*从这里开始，我们可以引用类型<code>typename [2.x.107]，并自动得到正确的preconditioner类。由于这两个类的接口很相似，我们将能够在所有地方使用相同的语法来互换使用它们。
*

*[1.x.93][1.x.94] 。


* 上面的讨论显示了解决斯托克斯方程所产生的线性系统的一种*方式，而且由于教程程序是教学工具，这是有意义的。但这是解决这个方程组的方法吗？
* 答案是否定的。上面已经指出了这种方法的主要瓶颈，那就是我们必须反复求解舒尔补数内的[2.x.108]的线性系统，由于我们没有一个好的舒尔补数的预处理程序，这些求解就不得不经常发生。一个更好的方法是使用块状分解，这是基于Silvester和Wathen[2.x.109]的观察，并在[2.x.110]中做了更详细的解释。下面在本程序的结果部分的[1.x.95]一节中讨论了这种替代方法的实施。
*

*[1.x.96][1.x.97] 。


* 以上，我们声称线性系统具有[1.x.98]的形式。
* 即，特别是在矩阵的右下方有一个零块。这样我们就可以把舒尔补数写成[2.x.111]。但这并不完全正确。
* 想一想，如果对某些压力变量有约束（见[2.x.112]"自由度的约束 "文件模块），例如因为我们使用自适应细化网格和连续压力有限元，所以有悬挂的节点，会发生什么。导致这种约束的另一个原因是压力的迪里希边界条件。然后，AffineConstraints类在将矩阵的局部贡献复制到全局线性系统中时，会将对应于受限自由度的行和列清零，并在对角线上放一个正条目。你可以认为这个条目是一个简单的条目，尽管实际上它是一个与其他矩阵条目相同数量级的值）。换句话说，右下角区块其实根本不是空的：它在对角线上有几个条目，每个受限的压力自由度都有一个，对我们要解决的线性系统的正确描述是，它的形式是[1.x.99] 。
*其中[2.x.113]是零矩阵，除了受限自由度的对角线正项。那么，正确的舒尔补码实际上就是矩阵[2.x.114]，而不是上面所描述的那个。
* 思考这个问题使我们首先意识到，现在的舒尔补码是不确定的，因为[2.x.115]是对称和正定的，而[2.x.116]是正半定的，从前者中减去后者可能不再是正定的。这很烦人，因为我们不能再在这个真正的舒尔补数上使用共轭梯度法。也就是说，我们可以在[2.x.117]中解决这个问题，即简单地将负*值放在受限压力变量的对角线上
*
* 因为我们实际上只是把一些非零的东西放到了对角线上，以确保得到的矩阵不是奇异的；我们真的不在乎这个条目是正还是负。因此，如果[2.x.118]的对角线上的条目是负的，那么[2.x.119]将再次成为不对称和正定矩阵。
* 但是，其次，下面的代码实际上并没有做这些事情。我只是用错误的舒尔补码[2.x.120]来解决线性系统，完全忽略了这个问题。为什么会这样呢？为了理解为什么会这样，回顾一下，当把局部贡献写进全局矩阵时，[2.x.121]把对应于受限自由度的行和列清零。这意味着[2.x.122]有一些零行，[2.x.123]零列。[2.x.125]的非零条目将正好适合于这些零对角线位置，并确保[2.x.126]是可逆的。不这样做，严格来说，意味着[2.x.127]仍然是单数。它在非约束压力自由度子集上是对称的和正定的，而在约束压力上只是一个零矩阵。为什么共轭梯度法对这个矩阵有效？因为[2.x.128]也确保了与矩阵的这些零行相对应的右手边条目也是*的。
零，也就是说，右手边是兼容的。
* 这意味着，无论这些受限压力自由度的解向量的值是多少，这些行的残差总是为零，而且，如果考虑到CG算法的内部操作，就永远不会对解向量产生任何更新。换句话说，尽管矩阵是奇异的，但CG算法只是忽略了*这些行。这只是因为这些自由度与线性系统的其他部分完全脱钩（因为整个行和相应的列都是零）。在求解过程结束时，求解向量中的约束压力值仍然与我们开始调用求解器时一模一样；当我们在CG求解器完成后调用[2.x.129]时，它们最终被正确的值覆盖。
* 这个讨论的结果是，假设大矩阵的右下角块为零是有点简化了，但仅仅是这样做实际上并没有导致任何值得解决的实际问题。
*

*[1.x.100][1.x.101]


* 我们下面实施的领域、右手边和边界条件与地球物理学中的一个问题有关：在那里，人们想计算大洋中裂缝下地球内部的岩浆流场。裂缝是两个大陆板块非常缓慢地漂移开来的地方（每年最多几厘米），在地壳上留下一个裂缝，里面充满了来自下面的岩浆。在不试图完全现实的情况下，我们通过解决以下一组方程和边界条件来模拟这种情况[2.x.130]：[1.x.102] 。
*其他地方使用自然边界条件[2.x.131]。换句话说，在顶面的左边部分，我们规定流体以速度[2.x.132]随大陆板向左移动，在顶面的右边部分向右移动，并在其他地方施加自然流动条件。如果我们在2d中，描述基本上是相同的，例外的是我们省略了上述所有矢量的第二部分。
* 正如在[1.x.103]中所显示的那样，流场将从下面拉出物质，并将其移到域的左端和右端，这是所期望的。速度边界条件的不连续性将在顶面中心产生一个压力奇点，将材料一直吸到顶面，以填补材料在此位置向外运动所留下的缺口。
*

*[1.x.104][1.x.105]


*[1.x.106][1.x.107]


* 在以前的所有教程程序中，我们仅仅使用AffineConstraints对象来处理悬挂节点约束（除了[2.x.133]）。然而，该类也可用于实现狄氏边界条件，正如我们将在本程序中展示的那样，通过固定一些节点值[2.x.134] 。请注意，这些是不均匀的约束，我们必须特别注意这点。我们要实现这一点的方法是，首先通过使用调用将边界值读入AffineConstraints对象中。
* [1.x.108]
*
* 非常类似于我们之前制作边界节点列表的方式（注意，我们只在边界标志为1的边界上设置迪里希特条件）。边界值的实际应用是由AffineConstraints对象直接处理的，没有任何额外的干扰。
* 然后我们可以像以前一样进行，即通过填充矩阵，并在约束对象上调用一个浓缩函数，其形式为
* [1.x.109]
*
* 注意，我们在系统矩阵和系统右侧同时调用这个函数，因为解决不均匀约束需要对矩阵条目和右侧的知识。不过，出于效率的考虑，我们选择了另一种策略：所有收集在AffineConstraints对象中的约束都可以在将本地数据写入全局矩阵的过程中得到解决，方法是使用调用
* [1.x.110]
*
* 这一技术在[2.x.135]教程程序中进一步讨论。我们在这里需要知道的是，这个函数同时做了三件事：它将局部数据写入全局矩阵，并将悬挂的节点约束分配出去，另外还实现了（非均质的）迪里切特边界条件。这很好，不是吗？
* 我们可以得出结论，AffineConstraints类提供了一个替代使用[2.x.136]来实现Dirichlet边界条件的方法。
*

* [1.x.111][1.x.112][1.x.113] 。
* 通常，稀疏矩阵包含大量的元素，当我们要开始线性求解时，这些元素实际上是零。这种元素是在我们消除约束条件或实现迪里希特条件时引入的，在这种情况下，我们通常会删除受约束行和列中的所有条目，即把它们设为零。对于本教程程序中所考虑的三维应用，存在于稀疏模式中但并不真正包含任何信息的那部分元素，可以达到矩阵中元素总数的四分之一。请记住，矩阵-向量乘积或前置条件器对稀疏矩阵的所有元素（甚至那些为零的元素）进行操作，这是我们在这里要避免的低效率。
* 直接解决约束自由度的一个好处是，我们可以避免在我们的稀疏矩阵中出现大部分将为零的条目&mdash；我们在构建矩阵时不需要约束条目（与传统算法相反，传统算法是先填充矩阵，然后才解决约束）。这将在形成矩阵-向量乘积时节省内存和时间。我们要做的是将约束信息传递给生成稀疏模式的函数，然后设置一个<tt>false</tt>参数，指定我们不打算使用约束条目。
* [1.x.114]
* 顺便说一下，这个函数也避免了对稀疏模式的<tt>condense()</tt>函数的调用。
*

*[1.x.115][1.x.116]


* 下面开发的程序经过了大量的调试。我们在分析工具（主要是[1.x.117]的cachegrind和callgrindtools，以及KDE[1.x.118]的visualization程序）下反复运行它，看看瓶颈在哪里。这已经得到了回报：通过这种努力，如果考虑到细化周期0到3的运行时间，该程序的速度已经提高了四倍，将CPU指令的总执行数量从869,574,060,348减少到199,853,005,625。对于更高的细化水平，收益可能更大，因为一些不是[2.x.137]的算法已经被取消了。
* 基本上，目前程序中有两种算法不随自由度数量的增加而线性变化：自由度的重新编号（即[2.x.138]，以及线性求解器（即[2.x.139]）。对于第一个算法，虽然自由度的重新排序可能不是线性扩展，但它是整个算法不可缺少的一部分，因为它极大地提高了稀疏ILU的质量，很容易弥补计算重新编号所花费的时间；DoFRenumberingnamespace的文档中显示了图表和时间，也强调了下面选择的Cuthill-McKee reorderingalgorithm的原因。
* 至于线性求解器：如上所述，我们在这里的实现使用的是Schur补码公式。这不一定是最好的选择，但展示了交易中的各种重要技术。关于哪种求解器最好的问题在本程序的[1.x.119]中再次讨论，并附有显示备选求解器和其结果比较的代码。
* 除此以外，在本程序的创建过程中，还测试和改进了许多其他算法。例如，在建立稀疏模式时，我们最初使用了一个（现在已经不存在了）BlockCompressedSparsityPatternobject，它一次增加一个元素；然而，它的数据结构对于我们在3D中的离散化所产生的每行大量非零条目适应性很差，导致了一个二次方行为。取代deal.II中的内部算法，一次设置许多元素，并使用BlockCompressedSimpleSparsityPattern（截至2015年初，它又被BlockDynamicSparsityPattern取代）作为一个更好的适应性数据结构，消除了这个瓶颈，代价是内存消耗略高。同样，SparseILU类中分解步骤的实现也非常低效，已经被一个快10倍的步骤所取代。甚至SparseILU的vmult函数也得到了改进，节省了大约20%的时间。在这里和那里都做了小的改进。此外，AffineConstraints对象被用来消除稀疏矩阵中大量最终为零的条目，见[1.x.120]。
* 这里显示了在细化周期0到3的三维过程中，在程序的不同地方花费了多少CPU指令的概况。
* [2.x.140]
* 可以看出，在这个细化水平上，大约四分之三的指令数花在实际求解上（左边的[2.x.141]调用，中间的[2.x.142]调用用于Schurcomplement求解，还有一个方框代表[1.x.121]求解中与SparseILU和SparseMatrix的乘法）。大约五分之一的指令用于矩阵装配和稀疏ILU计算（右下角的方框），其余的用于其他方面。由于[2.x.143]中的浮点运算通常比矩阵组装中的许多逻辑运算和查表要长得多，所以矩阵组装所占用的运行时间的比例实际上明显小于指令的比例，这在我们在结果部分的比较中会很明显。
* 对于更高的细化水平，代表求解器的方框以及右上角源自重排算法的蓝色方框将以牺牲程序的其他部分为代价而增长，因为它们不是线性缩放。在这个中等的细化水平（3168个单元和93176个自由度），线性求解器已经占了大约四分之三的指令，这是一个很好的迹象，说明这个程序中使用的大多数算法都是经过良好调整的，加速程序的主要改进很可能不是来自手工优化的个别方面，而是通过改变求解器的算法。我们将在下面的结果讨论中也讨论这一点。
* 最后一点，作为参考，下面的图片也显示了在优化这个程序的早期阶段，概况是怎样的。
* [2.x.144]
* 如上所述，这个版本的运行时间大约是第一个配置文件的四倍，其中稀疏ILU分解占用了大约30%的指令数，而操作早期低效的DynamicSparsityPattern版本大约占10%。这两个瓶颈后来都被完全消除了。
*

* [1.x.122] [1.x.123]。
* [1.x.124] [1.x.125]。


*
* 像往常一样，我们首先包括一些著名的文件。
*


* [1.x.126]
*
* 然后我们需要包括稀疏直接求解器UMFPACK的头文件。
*


* [1.x.127]
*
* 这包括不完全LU因子化的库，它将被用作3D的预处理程序。
*


* [1.x.128]
*
* 这就是C++。
*


* [1.x.129]
*
* 和所有的程序一样，名字空间dealii被包括在内。
*


* [1.x.130]
*
* [1.x.131] [1.x.132]。


*
* 正如介绍中所解释的，我们将分别对两个和三个空间维度使用不同的预处理程序。我们通过使用空间维度作为模板参数来区分它们。关于模板的细节，请参见[2.x.145]。我们不打算在这里创建任何预处理对象，我们所做的只是创建一个持有确定预处理类的本地别名的类，这样我们就可以以独立于维度的方式编写我们的程序。
*


* [1.x.133]
*
* 在二维，我们将使用稀疏的直接求解器作为预处理。
*


* [1.x.134]
*
* 还有三维的ILU预处理，由SparseILU调用。
*


* [1.x.135]
*
* [1.x.136] [1.x.137]。


*
* 这是对[2.x.146]的改编，所以主类和数据类型与那里使用的几乎相同。唯一不同的是，我们有一个额外的成员 [2.x.147] ，用于预处理Schur补码，以及相应的稀疏模式 [2.x.148] 。此外，我们没有依赖LinearOperator，而是实现了我们自己的InverseMatrix类。   
* 在这个例子中，我们还使用了自适应网格细化，其处理方式与 [2.x.149] 类似。根据介绍中的讨论，我们也将使用AffineConstraints对象来实现Dirichlet边界条件。因此，我们改变了名称 [2.x.150] 。
*


* [1.x.138]
*
* 这一条是新的：我们将使用一个所谓的共享指针结构来访问预处理程序。共享指针本质上只是指针的一种方便形式。几个共享指针可以指向同一个对象（就像普通的指针一样），但是当最后一个指向前提器对象的共享指针对象被删除时（例如，如果一个共享指针对象超出了范围，如果它是一个成员的类被销毁，或者如果指针被分配到一个不同的前提器对象），那么指向的前提器对象也被销毁。这确保了我们不必手动跟踪有多少地方仍在引用一个前置条件器对象，它永远不会产生内存泄漏，也不会产生一个指向已被销毁对象的悬空指针。
*


* [1.x.139]
*
* [1.x.140] [1.x.141]。


*
* 如同在[2.x.151]和其他大多数例子程序中一样，下一个任务是定义PDE的数据：对于斯托克斯问题，我们将在边界的一部分使用自然边界值（即同质诺伊曼型），对于这些边界，我们不必做任何特殊处理（同质性意味着弱形式中的相应项只是零），而在边界的其余部分使用速度的边界条件（迪里希勒型），如介绍中所述。   
* 为了强制执行速度上的Dirichlet边界值，我们将像往常一样使用[2.x.152]函数，这要求我们写一个具有与有限元一样多分量的函数对象。换句话说，我们必须在[2.x.153]-空间上定义函数，但我们在插值边界值时要过滤掉压力分量。
*

*
* 以下函数对象是介绍中描述的边界值的表示。
*


* [1.x.142]
*
* 我们为右手边实现了类似的函数，对于目前的例子来说，右手边只是零。
*


* [1.x.143]
*
* [1.x.144] [1.x.145]。


*
* 在介绍中广泛讨论了线性求解器和预处理器。在这里，我们创建将被使用的各自对象。
*

*
* [1.x.146] [1.x.147] [2.x.154] 类表示逆矩阵的数据结构。与[2.x.155]不同，我们用一个类来实现，而不是用辅助函数inverse_linear_operator()，我们将把这个类应用于不同种类的矩阵，这些矩阵需要不同的前置条件（在[2.x.156]中，我们只对质量矩阵使用非同一性前置条件）。矩阵和预处理器的类型通过模板参数传递给这个类，当创建[2.x.157]对象时，这些类型的矩阵和预处理器对象将被传递给构造函数。成员函数[2.x.158]是通过求解一个线性系统得到的。
*


* [1.x.148]
*
* 这是对[2.x.159]函数的实现。
*

*
* 在这个类别中，我们对求解器的控制使用了一个相当大的公差。这样做的原因是，该函数的使用非常频繁，因此，任何使CG求解中的残差变小的额外努力都会使求解更加昂贵。请注意，我们不仅将该类作为Schur补数的预处理程序，而且在形成拉普拉斯矩阵的逆时也使用该类；因此，该类直接对解本身的精度负责，所以我们也不能选择太大的容差。
*


* [1.x.149]
*
* [1.x.150] [1.x.151]。


*
* 这个类实现了介绍中讨论的Schur补码。它与 [2.x.160] 相类似。  不过，我们现在用一个模板参数[2.x.161]来调用它，以便在指定逆矩阵类的各自类型时访问它。作为上述定义的结果，声明[2.x.162]现在包含了上述预处理类的第二个模板参数，这也影响到[2.x.163]。
*


* [1.x.152]
*
* [1.x.153] [1.x.154]。



* [1.x.155] [1.x.156]。


*
* 这个类的构造函数看起来与 [2.x.164] 的构造函数非常相似。该构造函数初始化了多项式程度、三角形、有限元系统和dof处理器的变量。矢量速度分量的基础多项式函数的阶数为[2.x.165]，压力的阶数为[2.x.166]。  这就得到了LBB稳定元素对[2.x.167]，通常被称为Taylor-Hood元素。   
* 注意，我们用MeshSmoothing参数初始化三角形，这可以确保单元的细化是以PDE解的近似保持良好的方式进行的（如果网格过于非结构化就会出现问题），详见[2.x.168]的文档。
*


* [1.x.157]
*
* [1.x.158] [1.x.159]。


*
* 给定一个网格，该函数将自由度与之关联，并创建相应的矩阵和向量。在开始的时候，它还释放了指向预处理对象的指针（如果此时共享的指针指向任何东西的话），因为在这之后肯定不会再需要它了，在装配矩阵之后必须重新计算，并且将稀疏矩阵从它们的稀疏模式对象中解开。   
* 然后我们进行自由度的分配和重新编号。为了使ILU预处理程序（三维）有效地工作，重要的是以这样的方式列举自由度，以减少矩阵的带宽，或者也许更重要的是：以这样的方式使ILU尽可能地接近于真正的LU分解。另一方面，我们需要保留在[2.x.169]和[2.x.170]中已经看到的速度和压力的块结构。这要分两步完成。首先，对所有的道夫进行重新编号，以提高ILU，然后我们再一次按组件重新编号。由于[2.x.171]没有触及单个块内的重新编号，所以第一步的基本重新编号仍然存在。至于如何对自由度进行重新编号以改善ILU：deal.II有许多算法试图找到排序以改善ILU，或减少矩阵的带宽，或优化其他方面。DoFRenumbering命名空间显示了我们在本教程程序中基于这里讨论的测试案例而获得的几种算法的结果比较。在这里，我们将使用传统的Cuthill-McKee算法，该算法已经在之前的一些教程程序中使用。  在[1.x.160]中我们将更详细地讨论这个问题。
*


*与以前的教程程序相比，还有一个变化。没有理由对[2.x.172]速度分量进行单独排序。事实上，与其先列举所有[2.x.173]-velocities，然后列举所有[2.x.174]-velocities，等等，我们希望将所有速度放在一起，只在速度（所有分量）和压力之间进行区分。默认情况下，[2.x.175]函数不是这样做的：它把每个矢量分量分开处理；我们要做的是把几个分量分成 "块"，并把这个块结构传递给该函数。因此，我们分配一个有多少个元素的向量[2.x.176]，并描述所有速度分量对应于块0，而压力分量将构成块1。
*


* [1.x.161]
*
* 现在来实现Dirichlet边界条件，这在介绍中的讨论后应该是很明显的。所有的变化是这个函数已经出现在设置函数中，而我们习惯于在一些装配程序中看到它。在我们设置网格的下面，我们将把施加Dirichlet边界条件的顶部边界与边界指标1联系起来。  我们必须将这个边界指标作为第二个参数传递给下面的插值函数。  不过，还有一件事。  描述Dirichlet条件的函数是为所有分量定义的，包括速度和压力。然而，Dirichlet条件只为速度而设置。  为此，我们使用一个只选择速度分量的ComponentMask。通过指定我们想要的特定分量，从有限元中获得该分量掩码。由于我们使用自适应细化网格，仿生约束对象需要首先填充由DoF处理程序生成的悬挂节点约束。注意这两个函数的顺序；我们首先计算悬挂节点约束，然后将边界值插入约束对象。这确保了我们在有悬挂节点的边界上尊重H<sup>1</sup>一致性（在三个空间维度上），悬挂节点需要支配Dirichlet边界值。
*


* [1.x.162]
*
* 与[2.x.177]相类似，我们计算各个组件中的道夫。我们可以用与那里相同的方式来做，但是我们想在我们已经用于重新编号的块状结构上进行操作。函数 [2.x.178] 的作用与 [2.x.179] 相同，但现在通过 [2.x.180] 分成了速度和压力块。
*


* [1.x.163]
*
* 下一个任务是为我们将创建的系统矩阵分配一个稀疏模式，为预处理矩阵分配一个稀疏模式。我们可以用与[2.x.181]相同的方式来做，即通过[2.x.182]直接建立一个SparsityPattern类型的对象，但是，有一个重要的原因是不能这样做。在3D中，函数[2.x.183]为各个道夫之间的耦合产生了一个保守但相当大的数字，因此，最初为创建矩阵的稀疏性模式提供的内存太多
*
*--实际上，对于中等规模的三维问题，初始的稀疏模式甚至无法放入大多数系统的物理内存中，也可参见[2.x.184]中的讨论。相反，我们首先建立临时对象，使用不同的数据结构，不需要分配更多的内存，但不适合作为SparseMatrix或BlockSparseMatrix对象的基础；在第二步，我们再将这些对象复制到BlockSparsityPattern类型的对象中。这与我们在 [2.x.185] 和 [2.x.186] 中所做的完全相似。特别是，我们利用了这样一个事实，即我们永远不会写进系统矩阵的[2.x.187]块，而这是唯一需要填充预处理矩阵的块。     
* 所有这些都是在新范围内完成的，这意味着一旦信息被复制到[2.x.189]，[2.x.188]的内存将被释放。
*


* [1.x.164]
*
* 最后，系统矩阵、前导矩阵、解决方案和右侧向量是由类似于 [2.x.190] 中的方法的块结构创建的。
*


* [1.x.165]
*
* [1.x.166] [1.x.167]。


*
* 装配过程遵循[2.x.191]和引言中的讨论。我们使用众所周知的缩写来表示持有本单元的局部矩阵、右手和自由度的全局编号的数据结构。
*


* [1.x.168]
*
* 接下来，我们需要两个对象，它们作为FEValues对象的提取器工作。它们的使用在关于 [2.x.192] vector_valued 的报告中做了详细解释。
*


* [1.x.169]
*
* 作为对[2.x.193]和[2.x.194]的扩展，我们包括了一些优化，使这个特定问题的装配速度大大加快。这些改进是基于这样的观察：当我们像[2.x.195]那样做时，我们做了几次计算：对称梯度实际上在每个正交点有[2.x.196]个不同的值，但我们从FEValues对象中提取[2.x.197]次
*
* - 对于[2.x.198]的循环和[2.x.199]的内循环都是如此。在3D中，这意味着评估它[2.x.200]次而不是[2.x.201]次，这是一个不小的差别。     
* 所以我们在这里要做的是，在开始对单元上的道夫进行循环之前，在正交点得到一个秩-2张量的向量（类似的还有压力上的发散和基函数值）来避免这种重复计算。首先，我们创建各自的对象来保存这些值。然后，我们开始在所有单元上进行循环，并在正交点上进行循环，在那里我们首先提取这些值。我们在这里还实现了一个优化：本地矩阵（以及全局矩阵）将是对称的，因为所有涉及的操作都是相对于[2.x.202]和[2.x.203]对称的。这可以通过简单地运行内循环而不是到[2.x.204]，即外循环的索引来实现。
*


* [1.x.170]
*
* 现在最后是系统矩阵和我们用于预处理程序的矩阵的双线性形式。回顾一下，这两个的公式是


* [1.x.171]
*和


* [1.x.172]
*，其中[2.x.205]和[2.x.206]分别是[2.x.207]th形状函数的速度和压力成分。然后，上述各种条款在以下实施中很容易识别。
*


* [1.x.173]
*
* 请注意，在上述（1）的实现中，`operator*`被重载用于对称张量，产生两个张量之间的标量乘积。                 
* 对于右手边，我们利用形状函数只在一个分量中不为零的事实（因为我们的元素是原始的）。  我们不是将代表形状函数i的dim+1值的张量与整个右手边的向量相乘，而是只看唯一的非零分量。函数[2.x.208]将返回这个形状函数所处的分量（0=x速度，1=y速度，2=2d中的压力），我们用它来挑选出右手边向量的正确分量来相乘。
*


* [1.x.174]
*
* 在我们将局部数据写入全局矩阵之前（同时使用AffineConstraints对象来应用Dirichlet边界条件和消除悬挂的节点约束，正如我们在介绍中讨论的那样），我们必须注意一件事，虽然。由于对称性，我们只建立了一半的局部矩阵，但我们要保存完整的矩阵，以便使用标准函数进行解算。这是通过翻转指数来实现的，以防我们指向本地矩阵的空部分。
*


* [1.x.175]
*
* 在我们要解决这个线性系统之前，我们要为速度-速度矩阵生成一个预处理程序，即系统矩阵中的[2.x.209]。如上所述，这取决于空间维度。由于[2.x.210]别名所描述的两个类具有相同的接口，因此无论我们想使用稀疏直接求解器还是ILU，都不需要做任何不同的事情。
*


* [1.x.176]
*
* [1.x.177] [1.x.178]。


*
* 经过前面介绍中的讨论和各自类的定义，[2.x.211]函数的实现是相当直接的，其方式与[2.x.212]类似。首先，我们需要一个[2.x.213]类的对象，代表矩阵A的逆。正如在介绍中所描述的那样，在[2.x.214]类的内部预处理器的帮助下，生成了逆。
*


* [1.x.179]
*
* 这就像在 [2.x.215] 中一样。我们生成 Schur 补数的右手边 [2.x.216] 和一个代表各自线性运算的对象 [2.x.217] ，现在有一个模板参数表示预处理器
*
* - 按照该类的定义。
*


* [1.x.180]
*
* 解算器调用的常规控制结构被创建...
*


* [1.x.181]

* 现在是对舒尔补码的预处理。正如介绍中所解释的，预处理是由压力变量的质量矩阵来完成的。       
* 实际上，求解器需要有[2.x.218]形式的预调节器，所以我们需要创建一个反操作。我们再次使用[2.x.219]类的对象，它实现了求解器需要的[2.x.220]操作。  在这种情况下，我们必须对压力质量矩阵进行反转。正如在早期的教程程序中已经证明的那样，质量矩阵的反转是一个相当便宜和简单的操作（与拉普拉斯矩阵等相比）。带有ILU预处理的CG方法在5-10步内收敛，与网格大小无关。  这正是我们在这里所做的。我们选择另一个ILU预处理，并通过相应的模板参数将其带入InverseMatrix对象。  然后在逆矩阵的vmult操作中调用一个CG求解器。       
* 另一种方法是选择因子为1.2的SSOR预处理器，这种方法的构建成本较低，但事后需要更多的迭代。它需要大约两倍的迭代次数，但其生成的成本几乎可以忽略不计。
*


* [1.x.182]
*
* 有了舒尔补码和一个有效的预处理程序在手，我们可以用通常的方法解决压力的相应方程（即解向量中的块0）。
*


* [1.x.183]
*
* 在这第一个求解步骤之后，为了实现一致的压力场，必须将悬挂的节点约束分布到求解中。
*


* [1.x.184]
*
* 如[2.x.221]，我们最后需要解决速度方程，在这里我们插入压力方程的解。这只涉及我们已经知道的物体
*
* 所以我们只需将[2.x.222]乘以[2.x.223]，减去右边的部分，再乘以[2.x.224]的逆数。最后，我们需要将悬空节点的约束分布在一起，以获得一个一致的流场。
*


* [1.x.185]
*
* [1.x.186] [1.x.187]。


*
* 下一个函数是生成图形输出。在这个例子中，我们将使用VTK文件格式。  我们给问题中的各个变量附上名字：[2.x.225]速度的组成部分和[2.x.226]压力。   
* 并非所有的可视化程序都有能力将单个矢量分量分组为一个矢量，以提供矢量图；特别是对于一些基于VTK的可视化程序，这一点是成立的。在这种情况下，在包含数据的文件中应该已经描述了组件的逻辑分组为矢量的情况。换句话说，我们需要做的是为我们的输出编写者提供一种方法，让他们知道有限元的哪些分量在逻辑上形成一个矢量（在[2.x.227]空间维度上有[2.x.228]分量），而不是让他们假设我们只是有一堆标量场。  这是用[2.x.229]命名空间的成员实现的：和文件名一样，我们创建一个矢量，其中第一个[2.x.230]分量指的是速度，并被赋予标签[2.x.231]我们最后推一个标签[2.x.232]来描述压力变量的分组情况。
*

*
* 接下来的函数与 [2.x.233] 中的相同。
*


* [1.x.188]
*
* [1.x.189] [1.x.190]。


*
* 这是[2.x.234]类中最后一个有趣的函数。  正如它的名字所示，它获取问题的解决方案，并在需要时细化网格。其过程与[2.x.235]中的相应步骤相同，不同的是我们只根据压力的变化进行细化，也就是说，我们用ComponentMask类型的掩码对象调用Kelly误差估计器，选择我们感兴趣的压力的单一标量分量（我们通过指定我们想要的分量从有限元类得到这样一个掩码）。此外，我们没有再次粗化网格。
*


* [1.x.191]
*
* [1.x.192] [1.x.193]。


*
* 斯托克斯类的最后一步是，像往常一样，生成初始网格的函数，并按各自的顺序调用其他函数。   
* 我们从一个大小为[2.x.236]（2D）或[2.x.237]（3D）的矩形开始，在[2.x.238]中分别放置为[2.x.239]或[2.x.240]。在每个方向上以相等的网格大小开始是很自然的，所以我们在第一个坐标方向上将初始矩形细分四次。为了将创建网格所涉及的变量的范围限制在我们实际需要的范围内，我们将整个块放在一对大括号之间。
*


* [1.x.194]
*
* 边界指标1被设置为所有受Dirichlet边界条件约束的边界，即位于最后一个坐标方向上的0的面。详见上面的例子描述。
*


* [1.x.195]

* 然后我们在第一次求解之前应用一个初始细化。在三维中，会有更多的自由度，所以我们在那里细化得更少。
*


* [1.x.196]
*
* 正如在[2.x.241]中首次看到的那样，我们在不同的细化水平上循环细化（除了第一个循环），设置自由度和矩阵，组装，求解和创建输出。
*


* [1.x.197]
*
* [1.x.198] [1.x.199]。


*
* 主函数与 [2.x.242] 中的相同。我们将元素度数作为参数传递，并在著名的模板槽中选择空间维度。
*


* [1.x.200]
* [1.x.201][1.x.202][1.x.203] 。


*[1.x.204][1.x.205]。


*[1.x.206][1.x.207]


* 在[2.x.243]函数中空间维度设置为2的情况下运行程序，会产生以下输出（在 "释放模式 "下，[2.x.244] ）。
* [1.x.208]
*
* 上述整个计算在一台相当快的（以2015年的标准）机器上需要大约2秒钟。
* 我们立即看到的是，（外部）迭代的数量并没有随着我们细化网格而增加。这证实了导言中的说法，即用质量矩阵对舒尔补码进行预处理，确实可以得到一个与身份矩阵频谱相等的矩阵（即其特征值上下受限，与网格大小或单元的相对大小无关）。换句话说，质量矩阵和Schur补码在光谱上是等价的。
* 在下面的图片中，我们展示了程序中前六个细化步骤的网格。  观察网格是如何在解决方案迅速变化的区域内被细化的。在上边界，我们有Dirichlet边界条件，即
*
在上边界，我们的迪里希特边界条件在左半部分是*-，在右半部分是1，所以在[2.x.245]处有一个突然的变化。同样，在两个上角的数据中，也有从Dirichlet到Neumann的变化，所以那里也需要细化。
* [2.x.246]
* 最后，下面是一个流场的图。它显示了流体随着上边界的移动而被来自下方的物质所取代。
* [2.x.247]
* 该图使用了基于VTK的可视化程序（在这种情况下是VisIt）的能力来显示矢量数据；这是我们将使用中的有限元的速度分量定为矢量分量的集合，而不是在本教程程序的[2.x.248]功能中的独立标量分量的结果。
*


*[1.x.209][1.x.210]


* 在3D中，程序的屏幕输出看起来像这样。
* [1.x.211]
*
* 我们再次看到，随着我们对网格的细化，外部迭代的次数并没有增加。然而，计算时间明显增加：对于上述每个迭代，分别需要0.14秒、0.63秒、4.8秒、35秒、2分33秒和13分12秒。这种运行时间的整体超线性（未知数的数量）增加是由于我们的内部求解器不是[2.x.249]：一个简单的实验表明，随着我们不断细化网格，反转速度-速度块的ILU-条件化CG迭代的平均数量[2.x.250]增加。
* 我们将解决如何改进我们的求解器[1.x.212]的问题。
* 至于图形输出，在求解过程中产生的网格看起来如下。
* [2.x.251]
* 同样，它们基本上显示了由边界条件引入的奇异点的位置。计算出的矢量场构成了一个有趣的图形。
* [2.x.252]
* 这里显示的等值线也是压力变量的等值线，显示了不连续速度边界条件点的奇异性。
*


*[1.x.213][1.x.214]


* 正如在生成稀疏模式时解释的那样，在使用不完全LU分解等预处理程序时，必须牢记自由度的数量。使用刚度矩阵中的非零元素的分布可以很好地说明这一点。
* 如果我们不对自由度重新编号（即不使用[2.x.253]，而是使用[2.x.254]来确保自由度被适当地排序到矩阵和向量的相应块中），那么在二维的第一次自适应解析之后，我们会得到以下图像。
* [2.x.255]
* 为了生成这样的图，你必须在设置步骤的末尾插入一段代码，如以下内容。
* [1.x.215]
*
* 可以清楚地看到，非零项几乎分布在整个矩阵中。  这使得用ILU进行预处理的效率很低。ILU生成的高斯消元(LU分解)没有填充元素，这意味着更多的暂定填充元素会导致对完整分解的近似度更低。
* 在这个方案中，我们因此选择了一种更先进的成分重新编号法。  用[2.x.256]进行重新编号，并将成分归入速度和压力，产生以下输出。
* [2.x.257]
* 很明显，情况有了很大的改善。大多数元素现在都集中在矩阵中（0,0）块的对角线周围。对其他区块也有类似的效果。在这种情况下，ILU分解将更接近于全LU分解，这提高了预处理程序的质量。值得注意的是，稀疏直接求解器UMFPACK在实际生成稀疏LU分解之前，会对方程进行一些内部重新编号；这个过程导致了与我们从Cuthill-McKee算法中得到的模式非常相似）。
* 最后，我们想仔细看看三维的稀疏模式。我们只展示了矩阵的(0,0)块，也是在一次适应性细化之后。除了矩阵大小增加的事实之外，还可以看到矩阵中多了很多条目。此外，即使是优化后的重新编号，也会有相当数量的暂定填充元素。这说明了为什么UMFPACK在3D中不是一个好的选择。
*
* - 一个完整的分解需要许多新的条目，而这些条目最终将无法装入物理内存（RAM）。
* [2.x.258]
*


*[1.x.216][1.x.217]


* [1.x.218][1.x.219][1.x.220] 。
* 我们在计算结果一节中看到，外迭代的数量并不取决于网格的大小，从可扩展性的角度来看，这是最佳的。然而，这并不适用于整个求解器，如上所述：在生成矩阵[2.x.259]和质量矩阵[2.x.260]的逆时，我们没有研究内部迭代的数量。当然，这在二维情况下是没有问题的，我们用直接求解器对[2.x.261]进行预处理，反矩阵结构的[2.x.262]操作将在一个单一的CG步骤中收敛，但这在三维情况下发生了变化，我们只使用ILU预处理器。  在那里，反演[2.x.263]所需的预处理CG步骤的数量随着网格的细化而增加，每个[2.x.264]操作在上述细化步骤中平均涉及大约14、23、36、59、75和101次内部CG迭代。另一方面，在二维和三维中，应用反压力质量矩阵的迭代次数总是在5次左右）。  总而言之，大部分工作都是花在反复解决具有相同矩阵[2.x.265]的线性系统上。让这看起来更糟糕的是，我们实际上是在反转一个矩阵，该矩阵的大小约为整个系统矩阵的95%，并代表了sparsitypattern中85%的非零条目。因此，自然的问题是，在计算块状系统的解时，用矩阵[2.x.266]解约15次的线性系统是否合理。
* 当然，答案是，我们可以用其他一些（大部分时间更好的）方法来做。然而，必须指出的是，像手头这样的不确定系统对线性代数的要求确实比我们在早期教程程序中看到的标准椭圆问题高得多。如果与类似规模的椭圆问题相比，其改进仍不令人满意。无论如何，我们将在下面介绍一些对线性求解器的改进，我们将在[2.x.267]程序中用附加选项重新考虑这一讨论。
* [1.x.221][1.x.222][1.x.223]改善线性求解过程速度的第一个尝试是选择一个Dof重排序，使ILU更接近于全LU分解，这在代码内的注释中已经提到。DoFRenumbering命名空间比较了斯托克斯方程的道夫重新编号的几种选择。关于计算时间的最佳结果是通过调用[2.x.268]找到的，通过该程序，内部求解器需要相当少的操作，例如，在第4周期对[2.x.269]进行反演的约62次CG内迭代，而使用标准Cuthill-McKee算法的约75次。另外，在第4周期，对[2.x.270]的调用的计算时间从17分钟减少到11分钟。然而，King的排序（以及由[2.x.271]命名空间提供的一般排序）有一个严重的缺点
*
* - 它比构建中的交易版本使用更多的内存，因为它作用于抽象图形，而不是由三角化提供的几何图形。在目前的情况下，重新编号需要大约5倍的内存，这就产生了一个在三维中具有120万个未知数的最后周期的不可行的算法。
*[1.x.224][1.x.225]
* 另一个改善情况的想法是选择一个能使(0,0)矩阵[2.x.272]的CG在与esh无关的迭代次数中收敛的再调节器，例如10到30。我们已经在[2.x.273]中看到了这样的候选方案：多网格。
* [1.x.226][1.x.227] 。
* [1.x.228]即使在[2.x.274]中有一个很好的预处理程序，我们仍然需要反复求解同一个线性系统（虽然有不同的右手边），以使舒尔补码的解法得到验证。我们这里要讨论的方法是如何将内部迭代和外部迭代结合起来。如果我们坚持计算舒尔补码，就没有其他的可能性了。
* 另一种方法是一次性攻击区块系统，并使用近似的Schur补码作为有效的预处理程序。这个想法是这样的。如果我们找到一个块状预处理程序[2.x.275]，使得矩阵[1.x.229]是简单的。
* 是简单的，那么使用该预处理的迭代求解器将在几次迭代中收敛。使用舒尔补码[2.x.276]，我们发现[1.x.230]*似乎是很好的选择。
*似乎是一个很好的选择，因为[1.x.231]。
* 这就是介绍中提到的Silvester和Wathen的论文所采取的方法（除了Silvester和Wathen的用户不考虑预设条件）。在这种情况下，基于Krylov的迭代方法只有在应用[2.x.277]和[2.x.278]的精确求逆器时才会一步到位，因为所有的特征值都是1（这种方法的迭代次数被不同的特征值数量所限制）。下面，我们将讨论如何为这个问题选择一个适当的求解器。首先，我们要仔细研究一下预处理程序的实现。
* 由于[2.x.279]的目的只是作为一个预处理程序，我们将使用舒尔补码[2.x.280]和矩阵[2.x.281]的逆的近似值。因此，舒尔补集将由压力质量矩阵[2.x.282]近似，我们使用[2.x.283]的预处理程序（周围没有反矩阵类）来近似[2.x.284]。
* 这里有一个实现块状Schurcomplement预处理的类。根据上面的推导，对块向量的[2.x.285]操作可以通过三个连续的操作来指定。
* [1.x.232]
*
* 由于我们现在对整个块系统进行操作，我们必须忍受一个缺点：我们需要对整个块系统而不是较小的压力空间进行求解器的迭代。
* 现在我们转向我们应该对块系统使用哪种求解器的问题。第一个观察结果是，产生的预处理矩阵不能用CG求解，因为它既不是正定也不是对称的。
* deal.II库实现了几个适合手头问题的求解器。一个选择是求解器[2.x.286]"BiCGStab"，它被用于解决[2.x.287]中的非对称平流问题。第二种选择，也就是我们要选择的，是[2.x.288]"GMRES"（广义最小残差）。这两种方法都有其优点和缺点
*
* - 在有些问题上，两种方法中的一种明显优于另一种，反之亦然。[1.x.233]关于GMRES方法的文章给出了一个比较性的介绍。
* 对于我们的具体问题和[2.x.289]的ILU预处理程序，我们当然需要在大问题尺寸的块系统上进行数百次迭代（我们不会打败CG！）。实际上，这不利于GMRES。在GMRES迭代过程中，Krylov向量的基础被陆续建立起来，并对这些向量进行一些运算。这个基础上的向量越多，需要的操作和内存就越多。操作的数量以[2.x.290]的形式扩展，内存以[2.x.291]的形式扩展，其中[2.x.292]是Krylov基中的向量数量，[2.x.293]是（块）矩阵的大小。为了不让这些需求过度增长，deal.II将基的大小[2.x.294]默认为30个向量。这种GMRES方法的实现被称为GMRES(k)，默认为[2.x.295]。我们通过这一限制所获得的，即对操作和内存需求的约束，将被我们使用不完整的基础这一事实所补偿。
*
* - 这将增加所需的迭代次数。
* 另一方面，当需要多次迭代时，BiCGStab不会变慢（一次迭代只使用前面一个步骤的结果，而不是像GMRES那样使用所有的步骤）。除了BiCGStab由于需要两个矩阵-向量乘积（相比之下，CG或GMRES只需要一个），所以每一步的成本更高之外，还有一个主要原因使得BiCGStab不适合这个问题：预处理程序通过使用InverseMatrix类来应用压力质点矩阵的逆向。由于对矢量的反矩阵应用只是以近似的方式进行（精确的反矩阵太昂贵），这也会影响求解器。在BiCGStab的情况下，由于这种扰动，Krylov向量将不会是正交的。虽然这对于少量的步骤（最多50步）来说并不重要，但是当这些扰动在迭代的粗大过程中增长到相当大的程度时，就会破坏求解器的性能。
* 我们用BiCGStab做了一些实验，发现它在细化周期3之前比GMRES快（在3D中），但在周期4和5时变得非常慢（甚至比原来的Schur补码还慢），所以在这种情况下，该求解器是没有用的。对逆矩阵类选择一个更严格的容忍度（[2.x.296]而不是[2.x.297]）使BiCGStab在第4周期也表现良好，但在非常大的问题上并没有改变失败。
* 当然，GMRES也会受到近似求逆的影响，但它对正交性不敏感，而且在大问题上也保持了相对较好的性能，见下面的结果。
* 说到这里，我们来看看用[2.x.298]临时向量实现GMRES的求解器调用。
* [1.x.234]
*
* 我们用BlockVector模板调用求解器，以使GMRES能够对块状向量和矩阵进行操作。还要注意的是，在我们将信息复制到另一个矩阵之后，我们需要将系统矩阵中的（1,1）块设置为零（我们将压力质量矩阵保存在那里，这不是问题的组成部分）。
* 除了两个选项的解决方案之外，我们还检查这两个变体的解决方案是否接近（即这个解决方案确实与我们之前的解决方案相同），并计算矢量差的无穷大。
* 让我们先看看二维的结果。
* [1.x.235]
*
* 我们看到，块状舒尔补码预处理求解器和舒尔补码本身在求解时间上没有很大差别。原因很简单：我们用直接求解作为[2.x.300]的前置条件。
*
* 所以我们不能指望通过避免内部迭代获得任何收益。我们看到，GMRES的迭代次数略有增加，但总的来说，两种选择是相当相似的。
* 画面当然会在三维中发生变化。
* [1.x.236]
*
* 在这里，块状预处理求解器明显优于Schurcomplement，但是当网格点越多，优势就越小。这是因为GMRES(k)与CG相比，在问题大小上的扩展性更差，正如我们前面所讨论的。  尽管如此，对于中等规模的问题，3-6倍的改进是相当令人印象深刻的。
*

* [1.x.237][1.x.238] 。
* 这个问题的终极线性求解器可以想象为[2.x.301]的最佳预处理器（例如多网格）和上面描述的块状预处理器的组合，这就是[2.x.302]和[2.x.303]教程程序（我们使用代数多网格方法）和[2.x.304]（我们使用几何多网格方法）中采取的办法。
*

*[1.x.239][1.x.240]
* 另一个可以考虑的可能性是不设置块系统，而是一次性解决速度和压力系统。可以选择用UMFPACK直接求解（二维）或用ILU预调节的GMRES（三维）。这应该是很直接的尝试。
*


*[1.x.241][1.x.242]


* 当然，该程序也可以作为计算更有趣的情况下的流动的基础。编写这个程序的最初动机是希望它能成为一些地球物理流动问题的起点，例如在大陆板块漂移的地方（例如大洋中脊）岩浆的运动。当然，在这样的地方，几何形状比上面的例子更复杂，但这并不难适应。
* 例如，通过使用以下修改的边界值函数
* [1.x.243]
*和以下方式生成网格作为域[2.x.305]。
* [1.x.244]
*然后我们得到断层线是弯曲的图像。[2.x.306]


*[1.x.245][1.x.246] [2.x.307]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-23_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22]
*[1.x.23][1.x.24][1.x.25] 。


* [2.x.2]
* 这是一系列教程程序中的第一个，它将最终涵盖 "真正的 "时间依赖问题，而不是[2.x.3]或[2.x.4]的DAE模型中发现的略显奇怪的时间依赖形式。特别是，这个程序介绍了有界域中的波浪方程。以后，[2.x.5]将考虑一个吸收边界条件的例子，[2.x.6]" [2.x.7]" 一种非线性波方程产生的解决方案称为孤子。
* 波浪方程的原型形式如下：找到满足[1.x.26]的[2.x.8]。
* 请注意，由于这是一个具有二阶时间导数的方程，我们需要提出两个初始条件，一个是溶液的值，一个是溶液的时间导数。
* 物理上，该方程描述了弹性介质的运动。在二维空间中，我们可以考虑膜在受到力的作用下如何运动。上面的Dirichlet边界条件表明，膜在边界上被夹在一个高度[2.x.9]（这个高度可能也在移动&mdash；想想人们拿着毯子上下摇晃）。第一个初始条件等于膜的初始偏转，而第二个初始条件则是其速度。例如，我们可以考虑用手指把膜往下推，然后在[2.x.10]处让它离开（非零偏转但零初始速度），或者在[2.x.11]处用锤子砸它（零偏转但非零速度）。这两种情况都会引起膜的运动。
*

*[1.x.27][1.x.28]


*[1.x.29][1.x.30]
* 数值分析界有一个长期的争论，即时间依赖方程的离散化是否应该首先离散时间变量，导致每个时间步长的静止PDE，然后用标准的有限元技术来解决（这被称为Rothe方法），或者是否应该首先离散空间变量，导致一个大的常微分方程系统，然后可以由通常的ODE求解器处理（这被称为线的方法）。
* 传统上，人们更倾向于线的方法，因为它允许使用非常发达的高阶ODE求解器来处理这种方法产生的相当僵硬的ODE，包括步长控制和时间误差的估计。
* 另一方面，当使用高阶时间步长法时，罗特的方法变得很笨拙，因为人们不得不写下一个PDE，它不仅将当前时间步长的解与前一个时间步长的解结合起来，而且还可能将早期的解结合起来，从而导致大量的条款。
* 由于这些原因，线段法一直是人们的首选方法。然而，它有一个很大的缺点：如果我们首先对空间变量进行离散化，导致一个大的ODE系统，我们必须一劳永逸地选择一个网格。如果我们愿意这样做，那么这就是一个合法的、可能是优越的方法。
* 另一方面，如果我们看的是波浪方程和许多其他与时间有关的问题，我们会发现，随着时间的推移，解决方案的特征会发生变化。例如，对于波浪方程，我们可能有一个单一的波浪穿过域，在波浪前后的解是平滑的甚至是恒定的&mdash；自适应性对于这种情况确实很有用，但关键是我们需要细化网格的区域会随着时间步长而变化
* 如果我们打算这样做，即为每个时间步长（或一组时间步长）选择不同的网格，那么线的方法就不再合适了：我们不是得到一个变量数等于有限元网格中未知数的ODE系统，而是未知数的数量一直在变化，标准的ODE求解器当然不准备处理这一事实。另一方面，对于罗特方法，我们只是在每个时间步长得到一个PDE，我们可以选择独立于前一个时间步长的网格进行离散化；这种方法不是没有缺点和困难，但至少是一个合理的、定义明确的程序。
* 由于所有这些原因，在本程序中，我们选择使用Rothe方法进行离散化，即我们首先在时间上进行离散化，然后在空间上进行。我们实际上根本不会使用自适应网格，因为这涉及到大量的额外代码，但我们将在[1.x.31]中对此进行更多评论。
*

*[1.x.32][1.x.33]


* 鉴于这些考虑，我们将这样进行：让我们首先为这个二阶问题定义一个简单的时间步进方法，然后在第二步进行空间离散化，即我们将遵循Rothe的方法。
* 对于第一步，让我们先走个小弯路：为了计算二阶时间导数，我们可以直接离散化，或者引入一个额外的变量，将系统转化为一阶系统。在很多情况下，这都是等价的，但处理一阶系统往往更简单。为此，让我们引入[1.x.34]，出于明显的原因，把这个变量称为[1.x.35]。这样我们就可以把原来的波浪方程重新表述如下：[1.x.36] 。
* 这种表述的好处是，它现在只包含两个变量的第一时间导数，为此，可以简单地写出时间步进方案。请注意，我们一开始并没有为[2.x.12]设定边界条件。然而，我们可以在边界上强制执行[2.x.13]。在数值例子中发现，这实际上是必要的：如果不这样做，解决方案看起来并不特别错误，但如果不强制执行这些边界条件，Crank-Nicolson方案就不能保存能量。
* 有了这个公式，让我们引入以下的时间分解，其中上标[2.x.14]表示一个时间步长，[2.x.15]是当前时间步长：[1.x.37]注意我们在这里引入了一个参数[2.x.16]。如果我们选择[2.x.17]，例如，第一个方程将简化为[2.x.18]，这就是众所周知的前向或显式欧拉方法。另一方面，如果我们设定[2.x.19]，那么我们将得到[2.x.20]，这对应于后向或隐式欧拉方法。这两种方法都是一阶精确的方法。它们实现起来很简单，但实际上并不十分精确。
* 第三种情况是选择[2.x.21]。然后上面的第一个方程就会变成[2.x.22]。这种方法被称为Crank-Nicolson方法，它的优点是二阶精确。此外，它还有一个很好的特性，即保留了溶液中的能量（从物理上讲，能量是膜中粒子的动能加上由于局部拉伸而存在的势能的总和；这个量在连续方程中是一个守恒量，但大多数时间步进方案在时间微分后并没有保留它）。由于[2.x.23]也出现在[2.x.24]的方程中，Crank-Nicolson方案也是隐含的。
* 在程序中，我们将把[2.x.25]作为一个参数，这样就可以很容易地玩弄它。结果部分将显示一些比较不同方案的数字证据。
* 上面的方程（称为[1.x.38]方程，因为我们只离散了时间，而没有离散空间），可以通过从第一个方程中消除[2.x.26]和重新排列项来简化一下。然后我们得到[1.x.39]在这种形式下，我们看到，如果我们得到前一个时间步长的解决方案[2.x.27]，那么我们可以分别解决变量[2.x.28]，即一次一个。这是很方便的。此外，我们认识到第一个方程中的算子是正定的，而第二个方程看起来特别简单。
*

*[1.x.40][1.x.41]


* 我们现在已经得出了将近似（半离散）解[2.x.29]及其时间导数[2.x.30]与前一个时间步骤[2.x.33]的解[2.x.32]相关的方程。下一步是使用通常的有限元方法将空间变量离散化。为此，我们将每个方程与一个测试函数相乘，在整个域上进行积分，并在必要时进行部分积分。这就导致了[1.x.42]。
* 然后习惯性地对[2.x.34]进行近似，其中[2.x.35]是用于离散化[2.x.36]第1个时间步长的形状函数，[2.x.37]是解决方案的未知结点值。同样地，[2.x.38] 。最后，我们有前一个时间步骤的解决方案，[2.x.39]和[2.x.40] 。请注意，由于前一个时间步骤的解决方案在我们到达时间步骤时已经被计算出来了[2.x.41], [2.x.42]是已知的。此外，请注意上一步的解可能是在不同的网格上计算出来的，所以我们必须使用形状函数 [2.x.43] 。
* 如果我们将这些展开式插入上述方程，并使用目前网格中的测试函数进行测试，我们将得到以下线性系统：[1.x.43]其中[1.x.44] 。
*
* 如果我们解决这两个方程，我们可以将解决方案向前推进一步，并进入下一个时间步骤。
* 值得注意的是，如果我们在每个时间步长选择相同的网格（事实上我们将在下面的程序中这样做），那么我们在时间步长[2.x.44]和[2.x.45]上有相同的形状函数，即[2.x.46] 。因此，我们得到 [2.x.47] 和 [2.x.48] 。另一方面，如果我们使用了不同的形状函数，那么我们将不得不计算包含定义在两个网格上的形状函数的积分。这是一个有点混乱的过程，我们在此省略，但在[2.x.49]中有详细的处理。
* 在这些条件下（即网格不发生变化），我们可以通过基本消除第二线性系统的解来优化求解过程。我们将在[2.x.50] " [2.x.51] " 程序的介绍中讨论这个问题。
* [1.x.45][1.x.46] 。
*

* 比较时间步进方案质量的一个方法是看数字近似是否保留了连续方程的守恒特性。对于波浪方程来说，自然要看的量是能量。通过将波浪方程乘以[2.x.52]，对[2.x.53]进行积分，并在必要时进行部分积分，我们发现[1.x.47]，因此，在没有体力和恒定边界值的情况下，我们得到[1.x.48]是一个守恒量，即一个不会随时间变化的量。我们将在每个时间步长后计算这个量。我们可以直接看到，如果我们用有限元近似代替[2.x.54]，用速度的有限元近似代替[2.x.55]，那么[1.x.49]正如我们将在结果部分看到的，Crank-Nicolson方案确实保存了能量，而前向和后向的Euler方案都没有。
*

*[1.x.50][1.x.51]


* 波浪方程的数值求解令人讨厌的原因之一是，只有在时间步长足够小的情况下，显式时间离散化才是稳定的。特别是，它与空间网格宽度相耦合 [2.x.57] 。对于我们在这里使用的最低阶离散化，其关系为[1.x.52]，其中[2.x.58]为波速，在我们的波浪方程表述中，波速已被归一。因此，除非我们使用带有[2.x.59]的隐式方案，否则如果我们违反这一限制，我们的解在数值上将不稳定。隐式方案在稳定性方面没有这个限制，但如果时间步长过大，它们就会变得不准确。
* 这个条件最早是由Courant, Friedrichs, and Lewy &mdash;在1928年认识到的，当时还没有计算机可用于数值计算!这个结果出现在德语文章R.库朗、弗里德里希斯和卢伊。[1.x.53], MathematischeAnnalen, vol. 100, no. 1, pages 32-74, 1928.）这个关于时间步长的条件最常被称为[1.x.54]条件。直观地说，CFL条件是指时间步长不能大于一个波穿过一个单元的时间。
* 在程序中，我们将对正方形[2.x.60]均匀地细化七次，得到一个[2.x.61]的网格大小，这就是我们设定的时间步长。我们在两个不同的地方分别设置时间步长和网格尺寸是很容易出错的：很容易再一次细化网格，却忘记了同时调整时间步长。  [2.x.62] " [2.x.63] " 展示了一个更好的方法来保持这些东西的同步。
*

*[1.x.55][1.x.56]


* 尽管该程序具有处理非零初始和边界条件以及体力的所有钩子，但我们采取一个简单的案例，即域是一个正方形[2.x.64]和[1.x.57]。
* 这相当于一个最初处于静止状态、四周被夹住的膜，有人在夹住的边界的一部分上下挥动，从而向域内发射一个波。
*

* [1.x.58] [1.x.59]。
* [1.x.60] [1.x.61]。
*

*
* 我们从通常的各种各样的包含文件开始，我们在以前的许多测试中都看到过。
*


* [1.x.62]

* 这里是仅有的三个有一些新兴趣的包含文件。第一个文件已经被使用了，例如，用于[2.x.65]和[2.x.66]函数。然而，我们在这里使用该类中的另一个函数，[2.x.67]来计算我们的初始值，作为连续初始值的[2.x.68]投影。此外，我们使用[2.x.69]来生成积分[2.x.70] 。这些以前总是由[2.x.71]或应用程序代码中的类似函数手工生成。然而，我们懒得在这里做这些，所以干脆使用库函数。
*


* [1.x.63]
*
* 与此非常相似，我们也懒得写代码来组装质量矩阵和拉普拉斯矩阵，虽然这只需要从以前的任何一个教程程序中复制相关代码。相反，我们想把重点放在这个程序中真正新的东西上，因此使用了[2.x.72]和[2.x.73]函数。它们被声明在这里。
*


* [1.x.64]
*
* 最后，这里有一个包含文件，它包含了人们有时需要的各种工具函数。特别是，我们需要[2.x.74]类，该类在给定一个整数参数后，返回它的字符串表示。它特别有用，因为它允许有第二个参数，表明我们希望结果用前导零填充的数字数。我们将用它来写输出文件，其形式为[2.x.75]，表示时间步数，并且总是由三位数组成，即使我们仍然处于个位或两位数的时间步数中。
*


* [1.x.65]

* 最后一步和以前的所有程序一样。
*


* [1.x.66]
*
* [1.x.67] [1.x.68]。


*
* 接下来是主类的声明。它的公共函数接口与其他大多数教程程序一样。值得一提的是，我们现在必须存储四个矩阵，而不是一个：质量矩阵 [2.x.76] ，拉普拉斯矩阵 [2.x.77] ，用于求解 [2.x.79] 的矩阵 [2.x.78] ，以及用于求解 [2.x.80] 的带有边界条件的质量矩阵副本。请注意，在周围有一个额外的质量矩阵副本是有点浪费的。我们将在可能的改进部分讨论如何避免这种情况的策略。   
* 同样，我们需要[2.x.81]的解向量，以及前一个时间步长的相应向量，[2.x.82]。[2.x.83]将用于我们在每个时间步长中解决两个线性系统之一时的任何右手向量。这些将在两个函数 [2.x.84] 和 [2.x.85] 中得到解决。   
* 最后，变量[2.x.86]用于表示参数[2.x.87]，该参数用于定义使用哪种时间步进方案，这在介绍中已经说明。剩下的就不言而喻了。
*


* [1.x.69]
*
* [1.x.70] [1.x.71]。


*
* 在我们继续填写主类的细节之前，让我们定义与问题相对应的方程数据，即解[2.x.88]和其时间导数[2.x.89]的初始值和边界值，以及一个右手类。我们使用从Function类模板派生出来的类来做这件事，这个模板以前已经用过很多次了，所以下面的内容不应该是一个惊喜。   
* 让我们从初始值开始，对数值[2.x.90]以及它的时间导数，即速度[2.x.91]都选择零。
*


* [1.x.72]

* 其次，我们有右手边的强制项。无聊的是，我们在这里也选择零。
*


* [1.x.73]

* 最后，我们有 [2.x.92] 和 [2.x.93] 的边界值。它们就像介绍中描述的那样，一个是另一个的时间导数。
*


* [1.x.74]
*
* [1.x.75] [1.x.76]。


*
* 实际逻辑的实现实际上是相当短的，因为我们把组装矩阵和右手边的向量等事情交给了库。其余的实际代码不超过130行，其中相当一部分是可以从以前的例子程序中获取的模板代码（例如，解决线性系统的函数，或生成输出的函数）。   
* 让我们从构造函数开始（关于时间步长的选择的解释，见引言中关于Courant、Friedrichs和Lewy的部分）。
*


* [1.x.77]
*
* [1.x.78] [1.x.79]。


*
* 下一个函数是在程序开始时，也就是在第一个时间步骤之前，设置网格、DoFHandler以及矩阵和向量。如果你已经阅读了至少到[2.x.94]为止的教程程序，那么前几行是相当标准的。
*


* [1.x.80]
*
* 然后是一个区块，我们必须初始化我们在程序过程中需要的3个矩阵：质量矩阵、拉普拉斯矩阵和在每个时间步骤中求解[2.x.95]时使用的矩阵[2.x.96]。     
*在设置这些矩阵时，注意它们都利用了相同的稀疏模式对象。最后，在deal.II中，矩阵和稀疏模式是独立的对象的原因（与许多其他有限元或线性代数类不同）变得很清楚：在相当一部分应用中，人们必须持有几个恰好具有相同稀疏模式的矩阵，它们没有理由不共享这一信息，而不是重新建立并多次浪费内存。     
* 在初始化所有这些矩阵之后，我们调用库函数来建立拉普拉斯和质量矩阵。它们所需要的只是一个DoFHandler对象和一个将用于数值积分的正交公式对象。请注意，在许多方面，这些函数比我们通常在应用程序中做的要好，例如，如果一台机器有多个处理器，它们会自动并行构建矩阵：更多信息请参见WorkStream的文档或[2.x.97]"多处理器的并行计算 "模块。解决线性系统的矩阵将在run()方法中被填充，因为我们需要在每个时间步长中重新应用边界条件。
*


* [1.x.81]
*
* 该函数的其余部分用于将矢量大小设置为正确的值。最后一行关闭了悬挂的节点约束对象。由于我们在一个均匀细化的网格上工作，所以不存在任何约束，也没有计算过任何约束（也就是说，没有必要像其他程序那样调用[2.x.98]），但无论如何，我们需要在下面的一个地方进一步设置一个约束对象。
*


* [1.x.82]
*
* [1.x.83] [1.x.84]。


*
* 接下来的两个函数是解决与 [2.x.99] 和 [2.x.100] 的方程相关的线性系统。这两个函数并不特别有趣，因为它们几乎都是按照以前所有的教程程序中使用的方案。   
* 我们可以对我们要反转的两个矩阵的预处理程序做一些小实验。然而，事实证明，对于这里的矩阵，使用雅可比或SSOR预处理器可以稍微减少解决线性系统所需的迭代次数，但由于应用预处理器的成本，在运行时间方面并不占优势。这也不是什么损失，但让我们保持简单，只做不做。
*


* [1.x.85]
*
* [1.x.86] [1.x.87]。


*
* 同样，下面的函数也和我们之前做的差不多。唯一值得一提的是，这里我们使用[2.x.101]函数的第二个参数，生成了一个用前导零填充的时间步长的字符串表示，长度为3个字符。
*


* [1.x.88]
*
* 与[2.x.102]一样，由于我们在每个时间步长写输出（而且我们要解决的系统相对简单），我们指示DataOut使用zlib压缩算法，该算法针对速度而不是磁盘使用进行了优化，因为否则绘制输出就会成为一个瓶颈。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。



* 以下是程序中唯一有趣的功能。它包含了所有时间步骤的循环，但在这之前我们必须设置网格、DoFHandler和矩阵。此外，我们必须以某种方式从初始值开始。为此，我们使用[2.x.103]函数，该函数接收一个描述连续函数的对象，并计算该函数在DoFHandler对象所描述的有限元空间的[2.x.104]投影。再也没有比这更简单的了。
*


* [1.x.92]
*
* 接下来是循环所有的时间步骤，直到我们到达结束时间（本例中为[2.x.105]）。在每个时间步骤中，我们首先要解决[2.x.106]，使用方程式[2.x.107] [2.x.108] [2.x.109] 。请注意，我们在所有的时间步骤中使用相同的网格，因此[2.x.110] 和 [2.x.111] 。因此，我们首先要做的是将[2.x.112]和强制项相加，并将结果放入[2.x.113]向量中。对于这些加法，我们需要在循环之前声明一个临时向量，以避免在每个时间步骤中重复分配内存）。     
* 这里要意识到的一点是我们如何将时间变量传达给描述右手边的对象：每个从函数类派生的对象都有一个时间字段，可以用[2.x.114]来设置，用[2.x.115]来读取。 实质上，使用这种机制，所有空间和时间的函数因此被认为是在特定时间评估的空间的函数。这与我们在有限元程序中的典型需求非常吻合，在有限元程序中，我们几乎总是在一个时间步长上工作，而且从来没有发生过，例如，人们想在任何给定的空间位置为所有时间评估一个时空函数。
*


* [1.x.93]
*
* 在如此构建了第一个方程的右手边向量之后，我们要做的就是应用正确的边界值。至于右手边，这是一个在特定时间评估的时空函数，我们在边界节点插值，然后像我们通常做的那样用结果来应用边界值。然后将结果交给solve_u()函数。
*


* [1.x.94]
*
* solution_u()的矩阵在每个时间步骤中都是相同的，所以人们可以认为只在模拟开始时做一次就足够了。然而，由于我们需要对线性系统应用边界值（消除了一些矩阵的行和列，并为右侧提供了贡献），因此在实际应用边界数据之前，我们必须在每个时间步骤中重新填充矩阵。实际内容非常简单：它是质量矩阵和加权拉普拉斯矩阵的总和。
*


* [1.x.95]
*
* 第二步，即求解[2.x.116]，工作原理类似，只是这次左边的矩阵是质量矩阵（我们再次复制，以便能够应用边界条件，而右边是[2.x.117]加上强制项。边界值的应用方式与之前相同，只是现在我们必须使用BoundaryValuesV类。
*


* [1.x.96]
*
* 最后，在计算完两个解的组成部分后，我们输出结果，计算解中的能量，并在将现在的解移入持有上一个时间步骤的解的向量后，继续下一个时间步骤。注意函数[2.x.118]可以在一个步骤中计算[2.x.119]和[2.x.120]，为我们节省了一个临时向量和几行代码的费用。
*


* [1.x.97]
*
* [1.x.98] [1.x.99]。



*剩下的是程序的主要功能。这里没有什么是在以前的几个程序中没有展示过的。
*


* [1.x.100]
* [1.x.101][1.x.102] 。


* 当程序运行时，它产生以下输出。
* [1.x.103]
*
* 我们立即看到，至少在[2.x.121]之后，能量是一个常数（在此之前，边界源项[2.x.122]是非零的，向系统注入能量）。
* 除了屏幕输出外，程序还将每个时间段的解写到输出文件中。如果我们充分处理它们并将其粘贴到amovie中，我们会得到以下结果。
* [2.x.123]
* 这部电影显示了生成的波很好地穿过域并返回，在夹持的边界处被反射。一些数值噪声跟在波的后面，这是由过大的网格尺寸造成的假象，可以通过减小网格宽度和时间步长来减少。
*

* [1.x.104][1.x.105][1.x.106] 。


* 如果你想探索一下，可以尝试以下一些东西。[2.x.124] [2.x.125] 变化的 [2.x.126] 。这给出了不同的时间步进方案，其中一些是稳定的，而另一些则不是。看一下能量是如何演变的。
* [2.x.127] 不同的初始和边界条件，右手边。
* [2.x.128] 更复杂的域或更精细的网格。请记住，时间步长需要以网格宽度为界，所以改变网格应该同时改变时间步长。我们将在 [2.x.129] 中再来讨论这个问题。
* [2.x.130] 可变系数。在实际介质中，波速往往是可变的。特别是，现实介质中的 "真实 "波浪方程应为[1.x.107]，其中[2.x.131]是材料的密度，[2.x.132]与刚度系数有关。那么波速就是[2.x.133] 。
* 要做这样的改变，我们就必须用可变系数来计算质量和拉普拉斯矩阵。幸运的是，这并不难：函数[2.x.134]和[2.x.135]有额外的默认参数，可以用来向它们传递非恒定系数函数。因此，所需的变化相对较小。另一方面，必须再次注意确保时间步长在允许范围内。
* [2.x.136] 在代码内的注释中，我们讨论了这样一个事实：由于边界条件的原因，用于求解[2.x.137]和[2.x.138]的矩阵需要在每个时间内被重置，尽管实际内容没有变化。可以通过不消除线性系统中的列来避免复制，这可以通过在调用中附加一个[2.x.139]参数来实现。
* [1.x.108]

* [2.x.140] deal.II是一个支持自适应网格的库，如果这个程序支持每隔几步改变网格，那当然更好。考虑到解决方案的结构&mdash; 一个穿越领域的波浪&mdash; 如果我们只在波浪目前所在的地方完善网格，而不是简单地在所有地方完善网格，这似乎是合适的。直观地看，我们应该能够通过这种方式节省大量的单元。虽然经过进一步的思考，我们意识到这只是在模拟的初始阶段。  一段时间后，对于波浪现象来说，域中充满了初始波的反射，向各个方向发展，充满了域中的每个角落。  在这一点上，一般来说，使用局部网格细化是没有什么好处的）。)
* 为了使自适应改变网格成为可能，基本上有两条途径。  正确的方法是回到我们用Rothe的方法得到的弱形式。例如，在每个时间步骤中要解决的两个方程中的第一个方程看起来是这样的。  [1.x.109] 现在，注意我们在网格[2.x.142]上求解[2.x.141]，因此，测试函数[2.x.143]也必须来自空间[2.x.144]。正如在介绍中所讨论的，像[2.x.145]这样的条款要求我们将上一步的解决方案（可能是在不同的网格[2.x.146]上计算的）与当前网格的测试函数进行整合，从而得到一个矩阵[2.x.147]。这个整合不同网格的形状函数的过程，充其量也是尴尬的。它是可以做到的，但是由于很难保证[2.x.148]和[2.x.149]最多只相差一个细化级别，我们必须递归匹配两个网格的单元。这样做是可行的，但它会导致冗长的、不完全明显的代码。
* 第二种方法是：每当我们改变网格时，我们只需使用SolutionTransfer类将旧网格上最后一个时间步长的解插到新网格上。换句话说，我们将解决[1.x.110]，[2.x.150]将一个给定的函数插值到网格[2.x.151]上，而不是上面的方程式。  这是一个更简单的方法，因为在每个时间步长中，我们不再需要担心[2.x.152]是在我们现在使用的同一个网格上计算的，还是在不同的网格上计算的。因此，代码的唯一变化是增加了一个计算误差的函数，为细化标记单元，设置SolutionTransfer对象，将解转移到新的网格上，并在新的网格上重建矩阵和右手向量。建立矩阵和右手边的函数以及求解器都不需要改变。
* 虽然严格来说，这第二种方法在Rothe框架中并不十分正确（它引入了一个额外的误差源，即插值），但它几乎是所有解决时间相关方程的人所做的。我们将在 [2.x.153] 中使用这种方法，例如。[2.x.154]
*

* [1.x.111][1.x.112] [2.x.155] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-24_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20]
*[1.x.21][1.x.22][1.x.23] 。


* 这个项目是由德克萨斯A&amp;M大学的Xing Jin的一个学生项目发展而来的。本程序的大部分工作是由她完成的。本教程的部分工作得到了美国国家科学基金会DMS-0604778的资助。
* 该计划是一个旨在模拟热声断层成像的项目的一部分。在热声断层扫描中，脉冲电磁能量被送入生物问题。组织吸收部分能量，组织中吸收能量最多的部分通过热弹性膨胀产生热声波。在成像方面，人们利用不同种类的组织，最重要的是健康和病变组织，吸收不同数量的能量，因此以不同的速度膨胀。实验设置是测量这些源在组织表面产生的压力波的振幅，并试图重建源的分布，这表明吸收器的分布，从而表明不同种类的组织。这个项目的一部分是将模拟数据与实际测量进行比较，因此必须解决 "前向问题"，即描述压力波在组织中传播的波浪方程。因此，本程序是[2.x.2]"[2.x.3]"的延续，其中首次介绍了波浪方程。
*

*[1.x.24][1.x.25]


* 某一位置的温度，忽略热扩散，可以最好地表述为
* [1.x.26]
* 这里[2.x.4]是密度；[2.x.5]是比热；[2.x.6]是传递的微波能量带来的温升；[2.x.7]是加热函数，定义为从沉积的微波能量转化为每一时间和体积的热能。
* 让我们假设组织具有异质的介电特性，但具有同质的声学特性。声学同质介质中的基本声学生成方程可以描述如下：如果[2.x.8]是矢量值的位移，那么组织肯定会对压力的变化做出加速反应：[1.x.27]此外，它由于压力过大而收缩，并根据温度的变化而膨胀：[1.x.28]这里，[2.x.9]是一个热膨胀的系数。
* 现在让我们假设，加热只发生在一个比波在组织中传播短得多的时间尺度上（即加热组织的微波脉冲的时间长度比波穿过该领域的时间短得多）。在这种情况下，加热速率[2.x.10]可以写成[2.x.11]（其中[2.x.12]是微波能量的吸收强度图，[2.x.13]是狄拉克三角函数），与上面的第一个方程一起，将产生温度[2.x.14]在时间[2.x.15]的瞬时跳跃。使用这一假设，并将所有方程放在一起，我们可以将上述内容写成并合并为：[1.x.29]其中[2.x.16] 。
* 这个有点奇怪的方程，右边是狄拉克三角函数的导数，可以改写成一个初值问题如下：[1.x.30] 。
* (这个转化为初值问题的推导在本介绍的最后作为附录给出。)
* 在逆向问题中，人们希望恢复的是初始条件[2.x.17]，因为它是一张吸收微波能量的地图，因此可能是辨别健康和病变组织的指标。
* 在实际应用中，热声源与介质相比是非常小的。  因此，热声波的传播路径可以近似为从源头到无限远。此外，检测器离源头只有有限的距离。我们只需要评估热声波通过检测器时的数值，尽管它们仍在继续延伸。因此，这是一个我们只对无限介质的一小部分感兴趣的问题，而且我们不希望某个地方产生的波在我们认为感兴趣的领域的边界上被反射。相反，我们希望只模拟包含在感兴趣的领域内的那部分波场，而碰到该领域边界的波则不受干扰地通过边界。换句话说，我们希望边界能吸收撞击它的任何波。
* 一般来说，这是一个困难的问题：好的吸波边界条件是非线性的，并且/或者在数值上非常昂贵。因此，我们选择了一个简单的一阶近似吸收边界条件，即[1.x.31]这里，[2.x.18]是边界的法向导数。应该指出的是，这不是一个特别好的边界条件，但它是为数不多的可以合理简单实现的边界条件之一。
*

*[1.x.32][1.x.33]


* 与[2.x.19]一样，首先引入第二个变量，定义为压力势的导数：[1.x.34] 。
* 有了第二个变量，我们就可以将正向问题转化为两个独立的方程：[1.x.35] 。
* 带有初始条件：[1.x.36] 。
* 注意，我们在这里引入了一个右手边[2.x.20]，以显示如何在一般情况下推导出这些公式，尽管在应用于热声问题时[2.x.21]。
* 使用[2.x.23]中介绍的一般[2.x.22]方案，这个模型的半简化、弱化版本是：[1.x.37] 。
* 其中[2.x.24]是一个任意的测试函数，我们使用吸收边界条件进行部分积分：吸收边界条件通过使用[1.x.38]被纳入弱形式。
* 由此，我们通过引入有限数量的形状函数得到离散模型，并得到[1.x.39] 。
* 这里的矩阵[2.x.25]和[2.x.26]与[2.x.27]一样，边界质量矩阵[1.x.40]是使用吸收性边界条件的结果。
* 以上两个方程可以用矩阵形式重写，压力及其导数为未知矢量：[1.x.41] 。
* 其中[1.x.42] 。
* 通过简单的转换，就可以得到压力势及其导数的两个方程，就像在前面的教程程序中一样：[1.x.43] 。
*
*

*[1.x.44][1.x.45]


* 与[2.x.28]相比，本程序增加了对简单的吸收性边界条件的处理。此外，它还处理了从实际实验测量中获得的数据。为此，我们需要在实验也评估了真实压力场的点上评估该解决方案。我们将看到如何使用[2.x.29]函数在下面进一步做到这一点。
*


*[1.x.46][1.x.47]


* 在推导波浪方程的初值问题时，我们最初发现该方程有一个狄拉克三角函数的导数作为右手边：[1.x.48]为了看看如何将这个单一方程转化为具有初始条件的PDE的通常状态，让我们假设物理上相当合理的介质最初是静止的，即[2.x.30]为[2.x.31]。接下来，让我们形成两边相对于时间的不定积分：[1.x.49]这立即导致声明[1.x.50]，其中[2.x.32]是使[2.x.33] 。接下来，我们从[2.x.34]到[2.x.35]形成时间上的（定）积分，以找到[1.x.51]如果我们使用三角洲函数的属性，即[2.x.36]，并假设[2.x.37]是时间上的连续函数，我们发现当我们让[2.x.38]归零时，[1.x.52]换言之，使用[2.x.39]，我们找回了初始条件[1.x.53]。同时，我们知道，对于每一个[2.x.40]，delta函数都是零，所以对于[2.x.41]，我们得到了方程[1.x.54]。
* 最后，由于我们这里有一个具有两个时间导数的方程，我们仍然需要第二个初始条件。为此，让我们回到方程[1.x.55]，从[2.x.42]到[2.x.43]进行时间积分。这导致了[1.x.56]使用[1.x.57]形式的积分，其中我们使用[2.x.44]并插入[2.x.45]，我们看到，事实上[1.x.58]
* 现在，让[2.x.46]。假设[2.x.47]是一个连续的时间函数，我们看到[1.x.59]，因此[1.x.60]。然而，我们假设[2.x.48].因此，我们得到作为第二个初始条件，[1.x.61]完成了方程组。
*

* [1.x.62] [1.x.63]。
* [1.x.64] [1.x.65]。


*
* 以下内容之前都已涉及。



* [1.x.66]

* 这是唯一的一个新的。我们将需要一个定义在GridTools命名空间的库函数，用来计算最小单元格直径。
*


* [1.x.67]

* 最后一步和以前的所有程序一样。
*


* [1.x.68]
*
* [1.x.69] [1.x.70]。


*
* 主类的第一部分与[2.x.49]中的完全一样（除了名字）。
*


* [1.x.71]
*
* 以下是新的内容：首先，我们需要从吸收性边界条件中得出的边界质量矩阵[2.x.50]。同样，由于这次我们考虑的是一个现实的介质，我们必须有一个衡量波速的标准[2.x.51]，它将进入所有与拉普拉斯矩阵（我们仍然定义为[2.x.52]）有关的公式。
*


* [1.x.72]

* 最后我们要注意的是，我们想在一定数量的检测器位置评估解决方案。我们需要一个数组来保存这些位置，在这里声明并在构造函数中填充。
*


* [1.x.73]
*
* [1.x.74] [1.x.75]。


*
* 像往常一样，我们必须定义我们的初始值、边界条件和右手函数。这次事情有点简单：我们考虑的是一个由初始条件驱动的问题，所以没有右手函数（尽管你可以在[2.x.53]中查找，看看如何做到这一点）。其次，没有边界条件：域的整个边界由吸收性边界条件组成。这就只剩下初始条件了，那里的事情也很简单，因为对于这个特殊的应用，只规定了压力的非零初始条件，而没有规定速度的非零初始条件（在初始时间是零）。   
* 所以这就是我们所需要的：一个指定压力初始条件的类。在本程序考虑的物理环境中，这些是小的吸收器，我们将其建模为一系列的小圆圈，我们假设压力盈余为1，而其他地方没有吸收，因此没有压力盈余。我们是这样做的（注意，如果我们想把这个程序扩展到不仅可以编译，而且可以运行，我们将不得不用三维源的位置来初始化源）。
*


* [1.x.76]
*
* [1.x.77] [1.x.78]。


*
* 让我们再从构造函数开始。设置成员变量是很直接的。我们使用矿物油的声波速度（单位为毫米/微秒，是实验性生物医学成像中的常用单位），因为我们想和输出的许多实验都是在这里进行的。再次使用Crank-Nicolson方案，即theta被设定为0.5。随后选择时间步长以满足[2.x.54]：这里我们将其初始化为一个无效的数字。
*


* [1.x.79]
*
* 构造函数中的第二个任务是初始化存放检测器位置的数组。这个程序的结果与实验进行了比较，其中探测器间距的步长为2.25度，对应于160个探测器位置。扫描圆的半径被选为中心和边界之间的一半，以避免不完善的边界条件带来的剩余反射破坏我们的数值结果。     
*然后按顺时针顺序计算探测器的位置。请注意，下面的内容当然只有在我们以2d计算时才有效，这个条件我们用一个断言来保护。如果我们以后想在三维中运行同样的程序，我们就必须在这里添加代码来初始化三维中的检测器位置。由于断言的存在，我们不可能忘记这样做。
*


* [1.x.80]
*
* [1.x.81] [1.x.82]。


*
* 下面的系统几乎是我们在[2.x.55]中已经做过的，但有两个重要的不同之处。首先，我们必须在原点周围创建一个半径为1的圆形（或球形）网格。这并不新鲜：我们之前在[2.x.56]和[2.x.57]中已经这样做了，在那里我们还解释了PolarManifold或SphericalManifold对象如何在细化单元时将新点放在同心圆上，我们在这里也会使用。   
* 我们必须确保的一点是，时间步长满足[2.x.58]的介绍中讨论的CFL条件。在那个程序中，我们通过设置一个与网格宽度相匹配的时间步长来确保这一点，但是这很容易出错，因为如果我们再细化一次网格，我们也必须确保时间步长有所改变。在这里，我们自动做到了这一点：我们向一个库函数询问任何单元的最小直径。然后我们设置[2.x.59] 。唯一的问题是：[2.x.60]到底是什么？问题是，对于波浪方程来说，在这个问题上确实没有好的理论。众所周知，对于由矩形组成的均匀细化网格，[2.x.61]是最小边长。但对于一般四边形的网格来说，确切的关系似乎是未知的，也就是说，不知道单元的什么属性与CFL条件有关。问题是，CFL条件来自于对拉普拉斯矩阵最小特征值的了解，而这只能对简单结构的网格进行分析计算。   
* 所有这些的结果是，我们并不十分确定我们应该对[2.x.62]采取什么具体措施。函数[2.x.63]计算了所有单元的最小直径。如果单元格都是正方形或立方体，那么最小边长就是最小直径除以[2.x.64] 。我们简单地将此概括为非均匀网格的情况，没有理论上的理由。   
* 唯一的其他重大变化是我们需要建立边界质量矩阵。我们将在下文中进一步评论这个问题。
*


* [1.x.83]
*
* 如前所述，与[2.x.65]的第二个区别是，我们需要建立从吸收性边界条件中生长出来的边界质量矩阵。     
* 第一个观察结果是，这个矩阵比常规质量矩阵要稀疏得多，因为没有一个具有纯内部支持的形状函数对这个矩阵作出贡献。因此，我们可以根据这种情况优化存储模式，建立第二个稀疏模式，只包含我们需要的非零条目。这里有一个权衡：首先，我们必须要有第二个稀疏模式对象，所以这需要花费内存。其次，与该稀疏性模式相连的矩阵将更小，因此需要更少的内存；用它进行矩阵-向量乘法也会更快。然而，最后一个论点是提示规模的论点：我们主要感兴趣的不是单独对边界矩阵进行矩阵-向量运算（尽管我们需要在每个时间步长对右侧向量进行一次运算），而是主要希望将其与两个方程中的第一个方程使用的其他矩阵相加，因为这是CG方法每个迭代都要与之相乘的一个方程，即明显更频繁。现在的情况是，[2.x.66]类允许将一个矩阵添加到另一个矩阵中，但前提是它们使用相同的稀疏模式（原因是我们不能在稀疏模式创建后向一个矩阵添加非零条目，所以我们只要求两个矩阵具有相同的稀疏模式）。     
* 所以我们就这样做吧。
*


* [1.x.84]

* 第二件要做的事是实际建立矩阵。在这里，我们需要对单元格的面进行积分，所以首先我们需要一个能在[2.x.67]维对象上工作的正交对象。其次，FEValues的变体FEFaceValues，正如其名字所暗示的，它可以在面上工作。最后，其他的变量是组装机器的一部分。所有这些我们都放在大括号里，以便将这些变量的范围限制在我们真正需要它们的地方。     
* 组装矩阵的实际行为是相当直接的：我们在所有的单元格上循环，在每个单元格的所有面上循环，然后只在特定的面位于域的边界时做一些事情。像这样。
*


* [1.x.85]
*
* [1.x.86] [1.x.87]。


*
* 以下两个函数，解决压力和速度变量的线性系统，几乎是逐字逐句地从[2.x.70]中提取的（除了名称从[2.x.68]改为[2.x.69]的主变量之外）。
*


* [1.x.88]
*
* [1.x.89] [1.x.90]。


*
* 这里也是如此：该函数来自 [2.x.71] 。
*


* [1.x.91]
*
* [1.x.92] [1.x.93]。


*
* 这个做大部分工作的函数又和[2.x.72]中的差不多，尽管我们通过使用介绍中提到的向量G1和G2使事情变得更清楚。与程序的整体内存消耗相比，引入几个临时向量并没有什么坏处。   
* 这个函数唯一的变化是：首先，我们不必为速度[2.x.73]预测初始值，因为我们知道它是零。其次，我们在构造函数中计算的检测器位置评估解决方案。这是用[2.x.74]函数完成的。然后，这些值被写入我们在函数开始时打开的一个文件中。
*


* [1.x.94]
*
* [1.x.95] [1.x.96]。



*剩下的是程序的主要功能。这里没有什么是在以前的几个程序中没有展示过的。
*


* [1.x.97]
*[1.x.98][1.x.99]


* 该程序将每个时间步骤的图形数据以及在每个检测器位置评估的数值都写入磁盘。我们将它们绘制成图。目前，我们的实验只在二维空间内通过圆形扫描单个检测器来完成。这里的组织样本是[2.x.75]平面上的一个薄片（[2.x.76]），我们假设其他[2.x.77]方向的信号不会对数据产生影响。因此，我们只需要将我们的实验数据与二维模拟数据进行比较。
*[1.x.100][1.x.101]。
*

* 这部电影显示了由一个小型吸收器产生的热声波在介质中传播（在我们的模拟中，我们假设介质是矿物油，其声速为1.437 [2.x.78] ）。
* [2.x.79]
* 对于单个吸收器，我们当然要相应地改变[2.x.80]类。
* 接下来，让我们比较一下实验和计算的结果。可视化使用了地震学中长期使用的一种技术，即把每个探测器的数据都画在一个图上。这样做的方法是将每个检测器的信号与前一个检测器相比偏移一点。例如，这里是前四个探测器的图（从下到上，时间从左到右为微秒），使用程序中使用的源设置，与目前只有一个源的情况相比，使事情更有趣。
* [2.x.81]
* 例如，可以看到的一点是，第二和第四个信号的到达时间在探测器数量较多的情况下（即最顶端的探测器）会转移到较早的时间，但第一和第三信号不会；这可以解释为，这些信号的起源必须更接近后一个探测器，而不是前一个探测器。
* 如果我们不仅把4个，而且把所有160个探测器都堆在一个图中，个别的线就会模糊，但在它们一起运行的地方，它们会形成一个或深或浅的灰度模式。  下面两张图显示了在以这种方式堆叠的探测器位置上获得的结果。左图是通过实验得到的，右图是模拟数据。在实验中，一个小的强吸收器被嵌入到较弱的吸收组织中。
* [2.x.82]
* 很明显，在角度[2.x.83]时，源的位置更接近探测器。实验数据中可以看到的所有其他信号都是由于组织的其他部分也有弱吸收体，这些吸收体环绕着中心的小强吸收体产生的信号。另一方面，在模拟数据中，我们只模拟了小的强吸收体。
* 在现实中，检测器的带宽有限。因此，通过探测器的热声波将被过滤掉。通过使用高通滤波器（在MATLAB中实现并针对本程序产生的数据文件运行），可以使模拟结果看起来更接近实验数据。
* [2.x.84]
* 在我们的模拟中，我们看到主波后面的假信号是由数值伪影造成的。这个问题可以通过使用细网格来缓解，从而得到以下的图。
* [2.x.85]
*


*[1.x.102][1.x.103]


* 为了进一步验证该程序，我们还将展示多个吸收器的模拟结果。这与程序中实际实现的情况相对应。下面的影片显示了由多个吸收体产生的thermoacoustic波在介质中的传播情况。
* [2.x.86]
* 实验数据和我们的模拟数据在以下两张图中进行了比较。[2.x.87]
* 请注意，在实验数据中，第一个信号（即最左边的暗线）来自组织边界的吸收，因此在来自内部的任何信号之前，首先到达探测器。这个信号在痕迹的末端也是微弱可见的，大约在30[2.x.88]，这表明信号穿过整个组织到达另一侧的探测器，在所有来自内部的信号到达它们之后。
* 如前所述，通过应用符合探测器实际行为的带宽滤波器（左）和选择更细的网格（右），数值结果与实验结果更加吻合。
* [2.x.89]
* 左图和右图之间的一个重要区别是，右图的曲线看起来没有那么多的 "棱角"。角度来自于这样一个事实：虽然连续方程中的波在各个方向上的移动速度相同，但离散化后的情况并非如此：在那里，对角线上的波与平行于网格线的波的移动速度略有不同。这种各向异性导致的波前并不是完全的圆形（在堆积图中会产生正弦信号），而是在某些方向上凸出。更糟糕的是，我们使用的圆形网格（例如见[2.x.90]的粗略网格视图）也不是各向同性的。最终的结果是，除非网格足够细，否则信号的前沿不是正弦波的。右图在这方面要好得多，尽管仍然可以看到尾部虚假波的形式的伪影。
*

* [1.x.104][1.x.105] [2.x.91] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-25_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26]
*[1.x.27][1.x.28][1.x.29] 。


* 这个程序是从德克萨斯A&amp;M大学的Ivan Christov的一个学生项目发展而来的。这个程序的大部分工作是由他完成的。
* 这个程序的目标是解决1、2或3空间维度的正弦戈登孤子方程。解决这个方程的动机是对二维和三维的解决方案的性质知之甚少，尽管一维的情况已经被广泛地研究。
* 正弦戈登方程的名称是对所谓的克莱因-戈登方程的双关语，克莱因-戈登方程是对质量为非零的粒子的薛定谔方程的相对论版本。这种相似性不仅仅是表面的，正弦-戈登方程已经被证明可以模拟一些统一的场现象，如亚原子粒子的相互作用（见，例如，Perring &amp; Skyrme in Nuclear %Physics [1.x.30此外，从数学的角度来看，由于正弦戈登方程是 "完全不可积分的"，它是使用反散射变换等通常方法进行研究的候选者。因此，多年来，人们发现了许多有趣的静止波，甚至是静止的正弦戈登方程的解。在这些解中，粒子对应于局部特征。关于正弦戈登方程、反散射变换和其他寻找分析性索利通方程的方法的更多信息，读者应参考以下关于该主题的 "经典 "参考资料。G. L. Lamb的[1.x.32]（第5章，第2节）和G. B. Whitham的[1.x.33]（第17章，10-13节）。
* [2.x.2] 我们将在[2.x.3]中介绍量子力学的一个单独的非线性方程，即非线性Schr&ouml;dinger方程。
*[1.x.34][1.x.35]
* 我们希望解决的正弦戈登初始边界值问题（IBVP）由以下方程组成：[1.x.36]这是一个类似于[2.x.4]和[2.x.5]中讨论过的波浪方程的非线性方程。然而，应该注意的是，Dirichlet边界条件并不适合这个问题。尽管正弦-戈登方程的解是局部的，但只有在[2.x.6]处指定（迪里希特）边界条件才有意义，否则，要么不存在解，要么只存在微不足道的解[2.x.7]。
* 然而，上述方程的形式对于数值离散化来说并不理想。如果我们要直接准确地离散二阶时间导数，那么我们将需要一个最大的encil（即需要在内存中保存几个时间步骤），这可能会变得很昂贵。因此，与我们在[2.x.8]和[2.x.9]中的做法完全类似，我们将二阶（时间）正弦-戈登方程分割成两个一阶（时间）方程系统，我们称之为分割或速度公式。为此，通过设置[2.x.10]，很容易看到正弦戈登方程等效于[1.x.37] 。
*[1.x.38][1.x.39] 。
* 现在，我们可以使用[2.x.11]方法对分裂公式进行时间离散，该方法的模板只有两个时间步长。通过选择[2.x.12]，后者的离散化允许我们从一系列的方案中进行选择。特别是，如果我们选择[2.x.13]或[2.x.14]，我们可以分别得到一阶精确的阐释式隐式欧拉方法。另一个重要的选择是[2.x.15]，它给出了二阶精确的Crank-Nicolson方案。因此，上标[2.x.16]表示[2.x.17]时间步长的变量值，即[2.x.18]，其中[2.x.19]是（固定）时间步长。因此，时间分解的正弦-戈登方程的分割表述为[1.x.40] 。
* 我们可以通过一点代数来简化后者。从第一个方程中排除[2.x.20]并重新排列，我们得到[1.x.41] 。
* 在这一点上，我们似乎可以直接对方程进行空间离散。虽然这对第二个方程（在[2.x.21]中是线性的）来说是正确的，但这对所有的[2.x.22]来说是不可行的，因为上面的第一个方程是非线性的。因此，必须实现一个非线性求解器，然后将方程在空间中离散化并求解。
* 为此，我们可以使用牛顿方法。给定非线性方程[2.x.23]，我们产生对[2.x.24]的连续近似值如下：[1.x.42]迭代可以用旧的时间步长初始化，即[2.x.25]，最终它将产生对分裂公式中第一个方程的解（见上文）。对于这里所考虑的sine-Gordon方程的时间离散化，我们有[1.x.43]注意，虽然[2.x.26]是一个函数，[2.x.27]是一个算子。
*[1.x.44][1.x.45]。
* 事后看来，我们选择的解决方案和测试空间都是[2.x.28]。因此，乘以测试函数[2.x.29]并进行积分，我们得到每个时间步长的分裂公式（包括第一个方程的非线性求解器）的以下变分（或弱）公式：[1.x.46]注意，我们已经使用了部分积分和涉及拉普拉斯算子的所有项的零纽曼边界条件。此外，[2.x.30]和[2.x.31]如上定义，[2.x.32]表示通常[2.x.33]对域[2.x.34]的内积，即[2.x.35]。最后，请注意，第一个方程实际上是一个迭代程序的定义，所以它在每个时间步骤中被多次解决，直到满足一个停止标准。
* [1.x.47][1.x.48] 。
* 使用有限元方法，我们在空间中离散化变分公式。为此，让[2.x.36]成为一个具有节点基础[2.x.39]的有限元空间（[2.x.38]）。现在，我们可以在弱公式中展开所有的函数（见上文）与节点基的关系。此后，我们将用大写字母表示一个函数的系数向量（在节点基中），用小写字母表示；例如，[2.x.40]，其中[2.x.41]和[2.x.42] 。因此，变量公式的有限维版本要求我们在每个时间步骤中解决以下矩阵方程：[1.x.49] 。
* 以上，矩阵[2.x.43]和向量[2.x.44]表示上面讨论的小工具的离散版本，即[1.x.50]再次注意，上面的第一个矩阵方程实际上是迭代程序的定义，所以它被多次解决，直到满足停止标准。此外，[2.x.45]是质量矩阵，即[2.x.46]，[2.x.47]是拉普拉斯矩阵，即[2.x.48]，[2.x.49]是定义我们的辅助速度变量的方程中的非线性项，即[2.x.50]，[2.x.51]是[2.x.52]的雅各布矩阵中的非线性项，即[2.x.53] 。
* 对于第一个方程，我们可以用什么解法？让我们来看看我们要反转的矩阵：[1.x.51]对于一些[2.x.54]，取决于现在和以前的解决方案。首先，请注意，该矩阵是对称的。此外，如果时间步长[2.x.55]足够小，也就是说，如果[2.x.56]，那么矩阵也将是正无限的。在下面的程序中，情况总是这样的，所以我们将使用共轭梯度法和SSOR法作为修饰器。然而，我们应该记住，如果我们碰巧使用更大的时间步长，这将失败。幸运的是，在这种情况下，求解器将只是抛出一个异常，表示收敛失败，而不是默默地产生一个错误的结果。如果发生这种情况，我们就可以简单地用能够处理不确定对称系统的方法来取代CG方法。GMRES求解器通常是处理所有 "坏 "线性系统的标准方法，但它也是一个缓慢的方法。更好的方法是利用对称性的求解器，例如，SymmLQ，它也是在deal.II中实现的。
* 这个程序对[2.x.57]和[2.x.58]"[2.x.59]"进行了巧妙的优化：如果你仔细阅读上述公式，就会发现，速度[2.x.60]只出现在与质量矩阵的乘积中。因此，在[2.x.61]和[2.x.62]中，我们有点浪费：在每个时间步骤中，我们将用质量矩阵求解一个线性系统，只是在下一个时间步骤中再次将该系统的解乘以[2.x.63]。当然，这可以避免，我们在这个程序中就是这样做的。
*

*[1.x.52][1.x.53]


* 正弦戈登方程有几个分析解，包括一维和二维的。特别是，这个程序可以计算出一个具有单一的类似激波的初始条件的问题的解。  这个解决方案是由Leibbrandt在《物理学》（Phys.）《Rev.》《Lett.》中给出的。\b 41(7)，并在[2.x.64]类中实现。
* 应该指出的是，严格来说，这个闭式解法只对无限空间的初值问题成立（而不是这里考虑的诺伊曼初值问题）。然而，鉴于我们施加了零诺依曼边界条件，我们期望我们的初始边界值问题的解将接近无限空间初始值问题的解，如果波在我们领域边界上的反射不发生的话。在实践中，当然不是这样的，但我们至少可以假设是这样的。
* 二维解决方案中的常数[2.x.65]和[2.x.66]以及三维解决方案中的[2.x.67]、[2.x.68]和[2.x.69]被称为B&auml;cklundtransformation参数。它们控制诸如扭结的方向和深度。为了测试代码与精确解的对比，我们应该选择这些参数，使扭结与网格保持一致。
* 我们在[2.x.70]类中实现的解决方案是这些。[2.x.71] [2.x.72] 在一维中：[1.x.54] 其中我们选择[2.x.73] 。
* 在一维中，更多有趣的分析解是已知的。他们中的许多人被列在http://mathworld.wolfram.com/Sine-GordonEquation.html .
* [2.x.74] 在二维：[1.x.55] 其中[2.x.75]定义为[1.x.56]，我们选择[2.x.76] 。
* [2.x.77] 在三维中：[1.x.57] 其中[2.x.78]被定义为[1.x.58]，我们选择[2.x.79] .[2.x.80]


* 因为这使得玩起来更容易，用于设置&mdash;惊喜！&mdash;我们模拟的初始值的[2.x.81]类只是查询描述初始值的精确解的类，而不是重复努力实现解函数。
*

* [1.x.59] [1.x.60]。
* [1.x.61] [1.x.62]。
*

*
* 关于include文件的解释，读者应该参考示例程序 [2.x.82] 到 [2.x.83] 。它们按标准顺序排列，即 [2.x.84] 。
*
* - [2.x.85]
*
* - [2.x.86]
*
* - [2.x.87]
*
* - [2.x.88]
*
* - [2.x.89]（因为这些类别中的每一个都大致建立在以前的基础上），然后是一些用于文件输入/输出和字符串流的C++头文件。
*


* [1.x.63]

* 最后一步和以前的所有程序一样。
*


* [1.x.64]
*
* [1.x.65] [1.x.66]。


*
* 解决问题的整个算法被封装在这个类中。和以前的例子程序一样，这个类在声明时有一个模板参数，就是空间维度，这样我们就可以在一个、两个或三个空间维度上求解正弦-戈登方程。关于问题的独立于维度的类封装的更多信息，读者应该参考 [2.x.90] 和 [2.x.91] 。   
* 与[2.x.92]和[2.x.93]相比，在程序的一般结构中没有任何有价值的东西（当然，在各种函数的内部运作中也有！）。最明显的区别是出现了两个新的函数[2.x.94]和[2.x.95]，计算系统矩阵的非线性贡献和第一个方程的右手边，正如在介绍中讨论的那样。此外，我们还必须有一个向量[2.x.96]，它包含在每个牛顿步骤中对解向量的非线性更新。   
*正如介绍中也提到的，我们在这个程序中不存储速度变量，而是质量矩阵乘以速度。这是在[2.x.97]变量中进行的（"x "是代表 "次数"）。   
* 最后，[2.x.98]变量存储了在生成图形输出之前每次所需的时间步数。这一点在使用细网格（因此也是小的时间步数）时非常重要，在这种情况下，我们会运行大量的时间步数，并创建大量的输出文件，这些文件中的解看起来几乎是一样的。这只会堵塞我们的可视化程序，我们应该避免创建比我们真正感兴趣的更多的输出。因此，如果这个变量被设置为大于1的值[2.x.99]，那么只有在每一个[2.x.100]的时间步长时才会产生输出。
*


* [1.x.67]
*
* [1.x.68] [1.x.69]。



* 在下面两课中，我们首先实现了本程序介绍中提到的一维、二维和三维的精确解。如果想通过比较数值解和分析解来测试程序的准确性，这个时空解可能会有独立的意义（不过要注意，程序使用的是有限域，而这些是无界域的分析解）。例如，这可以用[2.x.101]函数来完成。再次注意（正如在[2.x.102]中已经讨论过的），我们如何将时空函数描述为依赖于时间变量的空间函数，该变量可以使用FunctionTime基类的[2.x.103]和[2.x.104]成员函数进行设置和查询。
*


* [1.x.70]

* 在本节的第二部分，我们提供初始条件。我们很懒惰（也很谨慎），不想第二次实现与上面相同的函数。相反，如果我们被询问初始条件，我们创建一个对象[2.x.105]，将其设置为正确的时间，并让它计算当时的精确解的任何值。
*


* [1.x.71]
*
* [1.x.72] [1.x.73]。



* 让我们继续讨论主类的实现，因为它实现了介绍中概述的算法。
*


* [1.x.74] [1.x.75]。


*
* 这是[2.x.106]类的构造函数。它指定了所需的有限元的多项式程度，关联了一个[2.x.107]对象（就像在示例程序[2.x.108]和[2.x.109]中一样），初始化了当前或初始时间，最终时间，时间步长，以及用于时间步长方案的[2.x.110]值。由于我们在这里计算的解是时间周期性的，所以开始时间的实际值并不重要，我们选择它是为了让我们在一个有趣的时间开始。   
* 注意，如果我们选择显式欧拉时间步进方案（[2.x.111]），那么我们必须选择一个时间步长[2.x.112]，否则该方案不稳定，解中可能出现振荡。Crank-Nicolson方案（[2.x.113]）和隐式Euler方案（[2.x.114]）不存在这个缺陷，因为它们是无条件稳定的。然而，即使如此，时间步长也应选择在[2.x.115]的数量级上，以获得一个好的解决方案。由于我们知道我们的网格是由矩形的均匀细分而来，我们可以很容易地计算出这个时间步长；如果我们有一个不同的域，[2.x.116]中的技术使用[2.x.117]也是可以的。
*


* [1.x.76]
*
* [1.x.77] [1.x.78]。


*
* 这个函数在[2.x.118]维度上创建一个矩形网格，并对其进行多次细化。同时，一旦自由度被组装起来，[2.x.119]类的所有矩阵和向量成员都被初始化为它们适当的大小。像[2.x.120]一样，我们使用[2.x.121]函数来生成质量矩阵[2.x.122]和拉普拉斯矩阵[2.x.123]，并在程序的剩余时间里将它们存储在适当的变量中。
*


* [1.x.79]
*
* [1.x.80] [1.x.81]。


*
* 这个函数为牛顿方法的每次迭代组装系统矩阵和右手边向量。关于系统矩阵和右手边的明确公式，读者应该参考导论。   
* 注意，在每个时间步长中，我们必须把对矩阵和右手边的各种贡献加起来。与[2.x.124]和[2.x.125]相比，这需要集合更多的条款，因为它们取决于前一个时间步骤或前一个非线性步骤的解决方案。我们使用函数[2.x.126]和[2.x.127]来做到这一点，而本函数提供了顶层逻辑。
*


* [1.x.82]

* 首先我们组装雅各布矩阵[2.x.128]，为了方便，[2.x.129]被储存在向量[2.x.130]中。
*


* [1.x.83]
*
* 接下来我们计算右手边的向量。这只是介绍中对[2.x.131]的描述所暗示的矩阵-向量的组合。
*


* [1.x.84]
*
* [1.x.85] [1.x.86]。


*
* 这个函数计算向量[2.x.132]，它出现在拆分公式的两个方程的非线性项中。这个函数不仅简化了这个项的重复计算，而且也是我们在时间步长为隐式时使用的非线性迭代求解器的基本部分（即[2.x.133]）。此外，我们必须允许该函数接收一个 "旧 "和一个 "新 "的解决方案作为输入。这些可能不是存储在[2.x.134]中的问题的实际解决方案，而只是我们线性化的两个函数。为了这个函数的目的，让我们在下面这个类的文档中分别调用前两个参数 [2.x.135] 和 [2.x.136]。   
* 作为一个旁注，也许值得研究一下什么阶数的正交公式最适合这种类型的积分。由于[2.x.137]不是一个多项式，可能没有正交公式可以准确地积分这些项。通常只需确保右手边的积分达到与离散化方案相同的精度即可，但通过选择更精确的正交公式，也许可以改善渐近收敛声明中的常数。
*


* [1.x.87]
*
* 一旦我们将[2.x.138]实例化重新初始化到当前单元格，我们就利用[2.x.139]例程来获得 "旧 "数据（大概在[2.x.140]）和 "新 "数据（大概在[2.x.141]）在所选正交公式节点的值。
*


* [1.x.88]
*
* 现在，我们可以使用所需的正交公式评估[2.x.142]。
*


* [1.x.89]
*
* 我们的结论是将各单元的积分对全局积分的贡献相加。
*


* [1.x.90]
*
* [1.x.91] [1.x.92]。


*
* 这是处理非线性方案的第二个函数。它计算矩阵[2.x.143]，它出现在[2.x.144]的雅各布项的非线性项中。正如[2.x.145]一样，我们必须让这个函数接收一个 "旧 "和一个 "新 "的解决方案作为输入，我们再次将其分别称为[2.x.146]和[2.x.147]，如下。
*


* [1.x.93]
*
* 同样，首先我们将我们的[2.x.148]实例化重新初始化为当前单元格。
*


* [1.x.94]
*
* 然后，我们使用所需的正交公式评估[2.x.149]。
*


* [1.x.95]
*
* 最后，我们将各单元上的积分对全局积分的贡献相加。
*


* [1.x.96]
*
* [1.x.97] [1.x.98]。



* 正如在介绍中所讨论的，这个函数对由牛顿方法的每次迭代产生的线性方程组使用CG迭代求解器，用于分割公式的（非线性）第一方程的有限元空间离散化。该系统的解实际上是[2.x.150]，所以它被存储在[2.x.151]的[2.x.152]函数中。   
* 请注意，我们在求解前将解的更新值重新设置为零。这是没有必要的：迭代求解器可以从任何一点开始并收敛到正确的解。如果对线性系统的解有一个很好的估计，那么从这个向量开始可能是值得的，但是作为一个一般的观察，事实是起点并不重要：它必须是一个非常非常好的猜测，以减少超过几个迭代的数量。事实证明，对于这个问题，使用以前的非线性更新作为起点实际上会损害收敛性，并增加所需的迭代次数，所以我们简单地将其设置为零。   
* 该函数返回收敛到一个解决方案所需的迭代次数。这个数字以后将被用来在屏幕上生成输出，显示每次非线性迭代需要多少次迭代。
*


* [1.x.99]
*
* [1.x.100] [1.x.101]。


*
* 这个函数将结果输出到一个文件。它与 [2.x.153] 和 [2.x.154] 中的相关函数基本相同。
*


* [1.x.102]
*
* [1.x.103] [1.x.104]。


*
* 这个函数对一切都有最高级别的控制：它运行（外部）时间步长循环，（内部）非线性求解器循环，并在每个时间步长后输出解。
*


* [1.x.105]
*
* 为了确认初始条件，我们必须使用函数 [2.x.155] 来计算 [2.x.156] 。为此，下面我们将创建一个类型为[2.x.157]的对象；注意，当我们创建这个对象（源自[2.x.158]类）时，我们将其内部时间变量设置为[2.x.159]，以表明初始条件是在[2.x.160]处评估的空间和时间函数。     
* 然后我们通过使用[2.x.163]将[2.x.162]投影到网格上，产生[2.x.161]。我们必须使用与[2.x.164]中相同的使用悬挂节点约束的构造：[2.x.165]函数需要一个悬挂节点约束对象，但要使用它，我们首先需要关闭它。
*


* [1.x.106]
*
* 为了完整起见，我们像其他时间步长一样，将第2个时间步长输出到一个文件。
*


* [1.x.107]
*
* 现在我们进行时间步进：在每个时间步进中，我们解决与问题的有限元离散化相对应的矩阵方程，然后根据我们在介绍中讨论的时间步进公式推进我们的解决方案。
*


* [1.x.108]
*
*在每个时间步长的开始，我们必须通过牛顿方法求解分裂公式中的非线性方程
*
* - - 即解出[2.x.166]，然后计算[2.x.167]，以此类推。这种非线性迭代的停止标准是：[2.x.168] 。因此，我们需要记录第一次迭代中残差的准则。         
* 在每次迭代结束时，我们向控制台输出我们花了多少次线性求解器的迭代。当下面的循环完成后，我们有（一个近似的） [2.x.169] 。
*


* [1.x.109]
*
* 在得到问题的第一个方程[2.x.170]的解后，我们必须更新辅助速度变量[2.x.171]。然而，我们不计算和存储[2.x.172]，因为它不是我们在问题中直接使用的一个量。因此，为了简单起见，我们直接更新[2.x.173]。
*


* [1.x.110]
*
* 很多时候，特别是对于精细的网格，我们必须把时间步长选得相当小，才能使方案稳定下来。因此，有很多的时间步长，在求解过程中 "没有什么有趣的事情发生"。为了提高整体效率
*
* - 特别是加快程序的速度和节省磁盘空间
*
* - 我们每隔[2.x.174]个时间步骤才输出解。
*


* [1.x.111]
*
* [1.x.112] [1.x.113]。



* 这是该程序的主函数。它创建了一个顶层类的对象并调用其主函数。如果在执行[2.x.175]类的运行方法时抛出了异常，我们会在这里捕获并报告它们。关于异常的更多信息，读者应该参考 [2.x.176] 。
*


* [1.x.114]
* [1.x.115][1.x.116] 。
* 显式欧拉时间步进方案（[2.x.177]）对于我们希望解决的问题来说表现得很充分。不幸的是，由于稳定性问题，必须选择一个相当小的时间步长。
*
* - - [2.x.178]似乎对我们进行的大多数模拟都有效。另一方面，Crank-Nicolson方案（[2.x.179]）是无条件稳定的，而且（至少对于一维呼吸器的情况）我们可以选择大到[2.x.180]的时间步长，而不会对解产生任何不良影响。隐式欧拉方案（[2.x.181]）是 "指数阻尼 "的，所以它不是解决正弦戈登方程的好选择，因为它是保守的。然而，[2.x.182]-方法提供的连续体中的一些阻尼方案对于消除边界效应引起的虚假振荡很有帮助。
* 在下面的模拟中，我们在一维的区间[2.x.183]和二维的正方形[2.x.184]上解决正弦-戈登方程。在每种情况下，各自的网格被均匀地细化6次，即[2.x.185] 。
*[1.x.117][1.x.118] 。
* 我们讨论的第一个例子是所谓的正弦-戈登方程的一维（静止的）呼吸解。该呼吸器有以下封闭式表达，正如在介绍中提到的：[1.x.119]其中[2.x.186]、[2.x.187]和[2.x.188]是常数。在下面的模拟中，我们选择[2.x.189]、[2.x.190]、[2.x.191]。此外，我们知道呼吸器的振荡周期是[2.x.192]，因此我们选择了[2.x.193]和[2.x.194]，这样我们可以观察到溶液的三次振荡。然后，取[2.x.195]，[2.x.196]和[2.x.197]，程序计算出以下解。
* [2.x.198]
* 虽然程序中没有显示如何做，但另一种可视化(1+1)-d解决方案的方法是使用DataOutStack类产生的输出；它允许 "堆叠 "各个时间步骤的解决方案，因此我们从一维时间相关的解决方案中得到二维时空图。这就产生了下面的时空图，而不是上面的动画。
* [2.x.199]
* 此外，由于呼吸器是正弦戈登方程的分析解，我们可以用它来验证我们的代码，尽管我们必须假设我们选择的诺伊曼边界条件所带来的误差与数值误差相比是很小的。在这种假设下，我们可以使用[2.x.200]函数来计算数值解和本程序的[2.x.201]类描述的函数之间的差异。对于上面两幅图所示的模拟，每个时间步长的无限元解的[2.x.202]准则误差仍然在[2.x.203]的数量级。因此，我们可以得出结论，数值方法已经在程序中得到了正确的实现。
*

*[1.x.120][1.x.121]


* 文献中可以找到的正弦戈登方程在(2+1)D中的唯一分析解是所谓的克氏孤波。它有以下的闭合式表达。  [1.x.122]与[1.x.123]其中[2.x.204]、[2.x.205]和[2.x.206]是常数。在下面的模拟中，我们选择了[2.x.207]。请注意，如果[2.x.208]的扭结是静止的，因此它将成为一个很好的解决方案，我们可以根据它来验证二维的程序，因为没有发生域边界的反射。
* 下面显示的模拟是用[2.x.209]、[2.x.210]、[2.x.211]、[2.x.212]和[2.x.213]进行的。每个时间步长的有限元解的[2.x.214]误差准则保持在[2.x.215]的数量级上，表明该程序在二维和一维都能正常工作。不幸的是，这个解决方案不是很有趣，尽管如此，为了完整起见，我们还是把它的一个快照放在下面。
* [2.x.216]
* 现在我们已经验证了一维和二维的代码，我们转到一个分析解未知的问题上。
* 为此，我们将上面讨论的扭结解围绕[2.x.217]轴旋转：我们让[2.x.218] 。后者的结果是不与网格对齐的孤波，所以反射立即发生在域的边界上。在下面的模拟中，我们选择了[2.x.219]、[2.x.220]、[2.x.221]、[2.x.222]和[2.x.223] 。此外，我们不得不选择[2.x.224]，因为对于任何[2.x.225]的边界都会产生振荡，这可能是由于方案而不是方程造成的，因此选择[2.x.226]的值，在时间步进方案的 "指数阻尼 "频谱内，可以确保这些振荡不会被产生。
* [2.x.227]
* 正弦戈登方程的另一个有趣的解决方案（无法通过分析获得）可以通过使用两个一维呼吸器来构建以下可分离的二维初始条件来产生：[1.x.124]其中[2.x.228], [2.x.229]与我们上面讨论的一维情况一样。在下面的模拟中，我们选择了[2.x.230]、[2.x.231]、[2.x.232]和[2.x.233] 。解决方案是相当有趣的
*
* --它的作用就像一个呼吸器（就图片而言）；然而，它似乎是分解和重新组装，而不仅仅是振荡。
* [2.x.234]
*

* [1.x.125][1.x.126][1.x.127] 。


* 改变初始条件是很有意义的。大多数选择不会导致保持局部的解决方案（在孤子界，这样的解决方案被称为 "静止的"，尽管解决方案确实随时间变化），而是导致解决方案，其中方程的波状特征占主导地位，波从局部初始条件的位置走出去。例如，值得玩一玩[2.x.235]类，把对[2.x.236]类的调用改为类似这样的函数：[1.x.128]如果[2.x.237]，而[2.x.238]在这个区域之外。
* 第二个方面是研究该方案是否是能量保留的。对于[2.x.239]"[2.x.240]"中讨论的纯波方程，如果我们选择时间步进参数，使我们得到Crank-Nicolson方案，情况就是这样。我们可以在这里做类似的事情，注意到正弦-戈登解的能量定义为[1.x.129](我们在公式中使用[2.x.241]而不是[2.x.242]，以确保对能量的所有贡献都是正的，从而使衰减解在无界域上具有无限的能量。)
* 除此之外，还有两个明显的领域。
*
* 显然，自适应性（即时间自适应网格）会对这样的问题感兴趣。它们的复杂性导致我们再次将其排除在本计划之外，尽管[2.x.243]" [2.x.244]"介绍中的一般评论仍然是正确的。
*
* - 更快的方案来解决这个问题。虽然今天的计算机已经足够快，可以在不长的时间内解决二维甚至三维静止的问题，但与时间相关的问题则是完全不同的一类问题。我们在[2.x.245]中讨论了这个问题，在那里我们展示了如何并行地解决这个问题，而且根本不需要组装或反转任何矩阵。
*

* [1.x.130][1.x.131] [2.x.246]。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-26_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22]
*[1.x.23][1.x.24][1.x.25] 。


* [2.x.2] ( [2.x.3] )


* 这个程序实现了热力方程
* [1.x.26]
* 从某种意义上说，这个方程比我们在前面的程序[2.x.4]、[2.x.5]、[2.x.6]中讨论的方程（即波浪方程）更简单。这是由于热方程随着时间的推移平滑了解，因此在许多方面更宽容。例如，当使用隐式时间步长方法时，我们实际上可以采取大的时间步长，我们不会因为每隔几步调整网格而引入小的干扰而产生麻烦，等等。
* 我们在这里的目标是使用theta-scheme来解决上述方程，该方程在时间上使用以下方法进行解算，我们希望[2.x.7]在某个时间[2.x.9]近似于[2.x.8] 。
* [1.x.27]
* 这里，[2.x.10]是时间步长。Theta-scheme概括了显式欧拉（[2.x.11]）、隐式欧拉（[2.x.12]）和Crank-Nicolson（[2.x.13]）时间离散。由于后者具有最高的收敛顺序，我们将在下面的程序中选择[2.x.14]，但要使这个参数的玩法保持简单。如果你对玩更高阶的方法感兴趣，可以看看[2.x.15]）。
* 考虑到这种时间离散化，空间离散化会像往常一样发生，通过与测试函数相乘，通过部分积分，然后将一切限制在一个有限维的子空间。在与[2.x.16]相乘之后，产生了以下一组完全离散的方程。
* [1.x.28]
* 其中[2.x.17]是质量矩阵，[2.x.18]是对拉普拉斯进行微分后得到的刚度矩阵。把所有已知的量带到右手边，得到我们在每一步都要解决的线性系统。
* [1.x.29]
* 左手边的线性系统是对称的和正定的，所以我们用共轭梯度法来解决它应该没有问题。
* 如果我们在初始时间有一组节点系数[2.x.19]，我们可以开始上面的迭代。在这里，我们采用将初始值[2.x.20]插值到第一个时间步骤所用的网格上得到的系数。我们还需要选择一个时间步长；在这里我们只选择固定的时间步长，但显然先进的仿真器会希望自适应地选择它。我们将在[1.x.30]中简要地回过头来讨论这个问题。
*

*[1.x.31][1.x.32]


* 在前面几个程序中求解波浪方程及其变体时，我们保持了固定的网格。就像静止方程一样，我们可以很好地证明这不是最聪明的方法，通过调整网格可以节省大量的费用。然而，与静止的情况相比，还有很大的困难。让我们依次来看看这些困难。
* [2.x.21] [2.x.22] [1.x.33]:对于静止的问题，一般的方法是 "将网格做得越细越好"。对于有奇点的问题，这往往会导致我们在角落或界面上得到许多细化层次的情况。第一个使用自适应网格的教程，[2.x.23]，已经是一个案例了。
* 然而，对于时间相关问题，我们通常需要选择与网格大小相关的时间步长。对于显性时间离散，这是显而易见的，因为我们需要尊重CFL条件，将时间步长与最小的网格尺寸联系起来。对于隐式时间离散，不存在这样的硬性限制，但在实践中，如果我们使网格尺寸变小，我们仍然希望使时间步长变小，因为我们通常有[2.x.24]形式的误差估计，其中[2.x.25]分别是时间和空间离散的收敛阶。我们只有减少这两个项，才能使误差变小。理想情况下，像这样的估计会建议选择[2.x.26] 。因为，至少对于非光滑解的问题，误差通常集中在最小的网格尺寸的单元中，我们必须确实选择[2.x.27] ，使用[1.x.34]的网格尺寸。
* 其结果是，在一个地方进一步细化网格，不仅意味着稍微增加自由度的适度额外努力，而且由于时间步长较小，必须更频繁地解决[1.x.35]线性系统的问题。
* 在实践中，人们通常通过承认我们不能使时间步长任意地小，因此也不能使局部网格大小任意地小来处理这个问题。相反，我们设置了一个最大的细化水平，当我们标记单元进行细化时，我们只是不细化那些子单元会超过这个最大的细化水平。
* 还有一个类似的问题，即我们将选择一个右手边，在不同的时间在领域的不同部分开启。为了避免在我们突然需要更细的网格的地方，被太粗的网格抓个正着，我们也将在程序中强制执行[1.x.36]的网格细化水平。
* [2.x.28] [1.x.37]。让我们再次考虑我们上面写下的半离散方程。
* [1.x.38]
* 我们在这里可以把[2.x.29]视为数据，因为它可能已经被计算过了。现在，让我们来替换
* [1.x.39]
*乘以测试函数[2.x.30]，并在必要时进行部分积分。在上述的过程中，这将产生
* [1.x.40]
* 现在想象一下，我们在时间步骤[2.x.31]和[2.x.32]之间改变了网格。那么问题来了，我们在[2.x.33]和[2.x.34]中使用的基函数是不同的！这与[2.x.32]中的项有关。这与右手边的项有关，其中第一个项我们可以更清楚地写成（第二个项也是如此
* [1.x.41]
* 如果这两个时间步骤中使用的网格是相同的，那么[2.x.35]就会形成一个方形质量矩阵[2.x.36]。然而，如果网格不一样，那么一般来说，矩阵是矩形的。更糟的是，甚至很难计算这些积分，因为如果我们在时间步长[2.x.37]的网格单元上循环，那么我们需要在这些单元的正交点上评估[2.x.38]，但它们不一定对应于时间步长[2.x.39]的网格单元，[2.x.40]也不通过这些单元定义；当然，如果我们想通过对网格[2.x.41]的单元积分计算这些积分，也是如此。
* 在任何情况下，我们必须面对的情况是，我们需要整合定义在两个不同网格上的形状函数。这是可以做到的，事实上在[2.x.42]中也有演示，但这个过程最多只能用 "尴尬 "一词来形容。
* 在实践中，人们通常并不希望这样做。相反，我们在每次调整网格时，通过从旧的网格插值到新的网格来避免整个情况。换句话说，我们不是求解上面的方程，而是求解这个问题
* [1.x.42]
* 其中[2.x.43]是对时间步长[2.x.44]中使用的有限元空间的插值算子。这不是最佳的方法，因为它除了时间和空间离散化之外，还引入了一个额外的误差，但这是一个务实的方法，使得做时间适应网格是可行的。[2.x.45]



*[1.x.43][1.x.44]


* 在实现无限元素代码时，通常会有许多事情出错。特别是，对于时间相关问题，以下是常见的错误来源。
*
* 时间积分，例如把涉及当前和前一个时间步骤的条款前面的系数弄错了（例如，把[2.x.46]的系数混为[2.x.47]）。
*
* - 处理右手边，例如忘记了[2.x.48]或[2.x.49]的一个系数。
*
* - 错误地处理边界值，例如同样忘记了[2.x.50]或[2.x.51]的系数，或忘记了不仅对右手边而且对系统矩阵应用非零边界值。
* 一个不太常见的问题是把初始条件弄错了，因为一般来说，只要输出第一个时间步长就可以看出它是错的。在任何情况下，为了验证代码的正确性，有一个测试协议是很有帮助的，它允许我们单独验证这些组件中的每一个。这意味着。
*
* 在初始条件为非零但右手边和边界值为零的情况下测试代码，并验证时间演变是否正确。
*
* 然后用零初始条件和边界值但非零右手边进行测试，再次确保正确性。
*
* - 最后，用零的初始条件和右手边但非零的边界值进行测试。
* 这听起来很复杂，但幸运的是，对于像这里这样没有系数（或恒定系数）的线性偏微分方程，有一个相当标准的协议，它基于以下观察：如果你选择一个正方形[2.x.52]作为你的领域（或者，稍作修改，一个矩形），那么精确的解决方案可以写成
* [1.x.45]
*（有整数常数[2.x.53]），只要初始条件、右手边和边界值也都是[2.x.54]形式。这是由于函数[2.x.55]是拉普拉斯算子的特征函数，允许我们以分析的方式计算诸如时间因子[2.x.56]的东西，因此，与我们得到的数值进行比较。
* 作为一个例子，让我们考虑有[2.x.57]和[2.x.58]的情况。通过对[2.x.59]的上述形式的主张（ansatz），我们可以得到
* [1.x.46]
* 为了使其等于[2.x.60]，我们需要
* [1.x.47]
*并且由于初始条件，[2.x.61] 。这个微分方程可以被积分，从而得到
* [1.x.48]
* 换句话说，如果初始条件是正弦的乘积，那么解决方案的形状与正弦的乘积完全一样，它以已知的时间依赖性衰减到零。如果你有足够细的网格和足够小的时间步长，这一点是很容易测试的。
* 如果你弄错了时间积分方案（例如，在变量前面有错误的[2.x.62]或[2.x.63]的因子），通常会发生的情况是你没有得到正确的解决方案的时间行为。仔细检查各种因素，直到你得到正确的行为。你可能还想验证一下时间衰减率（例如，通过在固定点绘制解决方案的值来确定），而不是在你把时间步长或网格大小加倍或减半时，时间衰减率就加倍或减半了。你知道这不是对边界条件或右手边的处理，因为这些都是零。
* 如果你已经验证了时间积分器是正确的，那么就采取右手边不为零但初始条件为零的情况。  [2.x.64] 和 [2.x.65] 。再说一遍。
* [1.x.49]
*而要使其等于[2.x.66]，我们需要的是
* [1.x.50]
*并且由于初始条件，[2.x.67] 。对这个方程进行时间积分可以得到
* [1.x.51]
*
* 同样，如果你在右侧条款前面有错误的[2.x.68]或[2.x.69]的因素，你将不会得到正确的时间行为的解决方案，或者它将收敛到一个最大值，而不是[2.x.70]。
* 一旦我们验证了使用这个方案的时间积分和右侧处理是正确的，我们就可以继续验证我们的边界值是否正确，使用一个非常类似的方法。
*


*[1.x.52][1.x.53]


* 在一个具有简单右手边的简单域上求解热方程，几乎总是导致解非常无聊，因为它们很快就变得非常光滑，然后就不再有什么变化。相反，我们在这里解决L型域上的方程，其边界值为零，初始条件为零，但作为右手边，我们选择
* [1.x.54]
* 这里。
* [1.x.55]
* 换句话说，在每一个长度为[2.x.71]的周期中，右手边首先在域1中闪烁，然后完全关闭，然后在域2中打开，然后再次完全关闭。通过[1.x.56]中所示的解决方案的小动画，这种模式可能是最好的观察。
* 如果你把热方程解释为寻找导电固体的空间和时间可变的温度分布，那么上面的测试案例对应于一个L形体，我们保持边界为零温度，并在域的两个部分交替加热。在加热过程中，这些地方的温度会上升，之后温度会扩散并再次降低。这些初始条件的意义在于，它们为我们提供了一个在时间上（当源开关时）和时间上（在再入角以及在源作用区域的边缘和角落）都有奇点的解决方案。
*

* [1.x.57] [1.x.58]。
* 该程序以通常的包含文件开始，所有这些文件你现在应该都见过了。
*


* [1.x.59]
*
* 然后按照惯例将这个程序的所有内容放入一个命名空间，并将deal.II命名空间导入到我们将要工作的命名空间中。
*


* [1.x.60]
*
* [1.x.61] [1.x.62].
* 下一个部分是这个程序的主类的声明。它沿用了以前的例子中很好的路径。如果你看过[2.x.72]，例如，这里唯一值得注意的是，我们需要建立两个矩阵（质量和拉普拉斯矩阵），并保存当前和前一个时间步长的解。然后，我们还需要存储当前时间、时间步长和当前时间步长的编号。最后一个成员变量表示引言中讨论的theta参数，它允许我们在一个程序中处理显式和隐式欧拉方法以及Crank-Nicolson方法和其他通用方法。   
* 就成员函数而言，唯一可能的惊喜是[2.x.73]函数需要最小和最大的网格细化水平的参数。这方面的目的在介绍中已经讨论过了。
*


* [1.x.63]
*
* [1.x.64] [1.x.65]。


*
* 在下面的类和函数中，我们实现了定义这个问题的各种数据（右手边和边界值），这些数据在这个程序中使用，我们需要函数对象。右手边的选择是在介绍的最后讨论的。对于边界值，我们选择零值，但这很容易在下面改变。
*


* [1.x.66]
*
* [1.x.67] [1.x.68]
* 现在是实现主类的时候了。让我们从构造函数开始，它选择了一个线性元素，一个时间步长为1/500的常数（记得上面将右边的源的一个周期设置为0.2，所以我们用100个时间步长来解决每个周期），并通过设置[2.x.74]选择了Crank Nicolson方法.
*


* [1.x.69]
*
* [1.x.70] [1.x.71]
* 下一个函数是设置DoFHandler对象，计算约束条件，并将线性代数对象设置为正确的大小。我们还在这里通过简单地调用库中的两个函数来计算质量和拉普拉斯矩阵。   
* 请注意，在组装矩阵时，我们不考虑悬挂节点的约束（两个函数都有一个AffineConstraints参数，默认为空对象）。这是因为我们要在结合当前时间步长的矩阵后，在run()中浓缩约束。
*


* [1.x.72]
*
* [1.x.73] [1.x.74].
* 下一个函数是解决单个时间步骤的实际线性系统的函数。这里没有什么值得惊讶的。
*


* [1.x.75]
*
* [1.x.76] [1.x.77]
* 除了我们告诉DataOut对象当前的时间和时间步长是多少之外，在生成图形输出方面也没有什么新的内容，这样就可以将其写入输出文件中。
*


* [1.x.78]
*
* [1.x.79] [1.x.80]
* 这个函数是程序的有趣部分。它负责自适应网格细化的工作。这个函数执行的三个任务是：首先找出需要细化/粗化的单元，然后实际进行细化，最终在两个不同的网格之间传输解向量。第一个任务是通过使用成熟的凯利误差估计器来实现的。第二项任务是实际进行再细化。这也只涉及到基本的函数，例如[2.x.75]，它可以细化那些具有最大估计误差的单元，这些误差加起来占60%，并粗化那些具有最小误差的单元，这些单元加起来占40%的误差。请注意，对于像目前这样的问题，即有事发生的区域正在四处移动，我们希望积极地进行粗化，以便我们能够将单元格移动到有必要的地方。   
* 正如在介绍中已经讨论过的，太小的网格会导致太小的时间步长，而太大的网格会导致太小的分辨率。因此，在前两个步骤之后，我们有两个循环，将细化和粗化限制在一个允许的单元范围内。
*


* [1.x.81]
*
* 上面这两个循环略有不同，但这很容易解释。在第一个循环中，我们没有调用[2.x.76]，而是调用了[2.x.77] 。这两个调用应该产生相同的迭代器，因为迭代器是按级别排序的，不应该有任何级别高于[2.x.78]的单元格。事实上，这段代码确保了这种情况的发生。
*

*
* 作为网格细化的一部分，我们需要将旧网格中的解向量转移到新网格中。为此，我们使用了SolutionTransfer类，我们必须准备好需要转移到新网格的解向量（一旦我们完成了细化，我们将失去旧的网格，所以转移必须与细化同时发生）。在我们调用这个函数的时候，我们将刚刚计算出解决方案，所以我们不再需要old_solution变量（它将在网格被细化后被解决方案覆盖，也就是在时间步长结束时；见下文）。换句话说，我们只需要一个求解向量，并将其复制到一个临时对象中，当我们在下面进一步调用 [2.x.79] 时，它就不会被重置。     
* 因此，我们将一个SolutionTransfer对象附加到旧的DoF处理程序中，以初始化它。然后，我们准备好三角形和数据向量以进行细化（按照这个顺序）。
*


* [1.x.82]
*
* 现在一切都准备好了，所以进行细化并在新网格上重新创建DoF结构，最后在[2.x.80]函数中初始化矩阵结构和新向量。接下来，我们实际执行从旧网格到新网格的插值解。最后一步是对解向量应用悬空节点约束，即确保位于悬空节点上的自由度值，使解是连续的。这是必要的，因为SolutionTransfer只对单元格进行局部操作，不考虑邻域。
*


* [1.x.83]
*
* [1.x.84] [1.x.85]。
* 这是程序的主要驱动，我们在这里循环所有的时间步骤。在该函数的顶部，我们通过重复第一个时间步长来设置初始全局网格细化的数量和自适应网格细化的初始周期数。然后，我们创建一个网格，初始化我们要处理的各种对象，设置一个标签，说明我们在重新运行第一个时间步长时应该从哪里开始，并将初始解插值到网格上（我们在这里选择了零函数，当然，我们可以用更简单的方法，直接将解向量设置为零）。我们还输出一次初始时间步长。   
*


* [2.x.81] 如果你是一个有经验的程序员，你可能会对我们在这段代码中使用[2.x.82]语句而感到惊讶  [2.x.83] 语句现在已经不是特别受人欢迎了，因为计算机科学界的伟人之一Edsgar Dijkstra在1968年写了一封信，叫做 "去语句认为是有害的"（见[1.x.86]）。这段代码的作者全心全意地赞同这一观念。  [2.x.84]是难以理解的。事实上，deal.II几乎不包含任何出现的情况：不包括基本上是从书本上转录的代码，也不计算重复的代码片断，在写这篇笔记时，在大约60万行代码中有3个位置；我们还在4个教程程序中使用它，与这里的背景完全相同。与其在这里试图证明这种情况的出现，不如先看看代码，我们在函数的最后再来讨论这个问题。
*


* [1.x.87]
*
* 然后我们开始主循环，直到计算的时间超过我们的结束时间0.5。第一个任务是建立我们需要在每个时间步骤中解决的线性系统的右手边。回顾一下，它包含项[2.x.85] 。我们把这些项放到变量system_rhs中，借助于一个临时矢量。
*


* [1.x.88]
*
* 第二块是计算源项的贡献。这对应于项 [2.x.86] 。下面的代码调用[2.x.87]来计算向量[2.x.88]，在这里我们在评估之前设置右侧（源）函数的时间。这一切的结果最终都在forcing_terms变量中。
*


* [1.x.89]
*
* 接下来，我们将强迫项添加到来自时间步长的强迫项中，同时建立矩阵[2.x.89]，我们必须在每个时间步长中进行反转。这些操作的最后一块是消除线性系统中悬挂的节点约束自由度。
*


* [1.x.90]
*
* 在我们解决这个问题之前，还有一个操作需要做：边界值。为此，我们创建一个边界值对象，将适当的时间设置为当前时间步长的时间，并像以前多次那样对其进行评估。其结果也被用来在线性系统中设置正确的边界值。
*


* [1.x.91]
*
* 有了这些，我们要做的就是解决这个系统，生成图形数据，然后......
*


* [1.x.92]
*
* ...负责网格细化工作。在这里，我们要做的是：(i)在求解过程的最开始就细化所要求的次数，之后我们跳到顶部重新开始时间迭代，(ii)之后每隔五步细化一次时间。         
* 时间循环，事实上，程序的主要部分以开始进入下一个时间步骤为结束，将old_solution设置为我们刚刚计算的解决方案。
*


* [1.x.93]
*
* 现在你已经看到了这个函数的作用，让我们再来看看 [2.x.90] 的问题。从本质上讲，该代码所做的事情是这样的。  [2.x.91] 这里，"对结果满意 "的条件是我们是否愿意保留当前的网格，或者宁愿细化网格，然后在新的网格上重新开始。当然，我们可以用下面的方法取代 [2.x.92] 的使用。  [2.x.93] 这样做的好处是摆脱了[2.x.94]，但缺点是必须在两个不同的地方重复实现 "solve timestep "和 "postprocess "操作的代码。这可以通过将这些部分的代码（在上面的实际实现中是相当大的块）放到自己的函数中来解决，但是一个带有[2.x.96]语句的[2.x.95]循环并不是真的比一个[2.x.97]容易阅读或理解。
*

*
* 最后，人们可能只是同意[1.x.96][2.x.98]语句是个坏主意，但要务实地指出，在某些场合，它们可能有助于避免代码重复和控制流的尴尬。这可能是其中的一个地方，它与Steve McConnell在他关于良好编程实践的优秀书籍 "Code Complete" [2.x.99]中所采取的立场相吻合（见[2.x.100]的介绍中提到的这本书），该书花了惊人的10页来讨论[2.x.101]的一般问题。
*



*
* [1.x.97] [1.x.98]。


*
*走到这一步，这个程序的主函数又没有什么好讨论的了：它看起来就像自[2.x.102]以来的所有此类函数。
*


* [1.x.99]
*[1.x.100][1.x.101]


* 如同许多教程一样，程序的实际输出并不重要，重要的是我们如何到达那里。尽管如此，它还是在这里。
* [1.x.102]
*
* 也许更有意义的是解决方案的可视化和计算的网格。
* [2.x.103]
* 这部电影显示了两个信号源的开关情况以及网格的反应。很明显，现在的网格可能不是我们能想出来的最好的。我们将在下一节再讨论这个问题。
*

*[1.x.103][1.x.104][1.x.105]


* 至少有两个方面可以大大改善这个程序：自适应时间步进和更好地选择网格。
* [1.x.106][1.x.107] 。
*

* 由于选择了隐式时间步进方案，我们不受任何类似CFL的时间步进条件的约束。此外，由于在热力方程中发生变化的时间尺度不受细胞直径的约束（不像波浪方程那样，我们有一个固定的信息传输速度，将时间尺度和空间尺度结合起来），我们可以随意选择时间步长。或者，最好是按照我们认为必要的精确度来选择。
* 看一下这个解决方案，很明显，行动并不是随着时间的推移而均匀发生的：在我们打开一个源的时候，很多东西都在发生变化，一旦一个源开启了一段时间，事情就变得不那么戏剧化了，而当两个源都关闭时，我们就进入了衰退阶段。在这些时候，我们可以肯定地使用比以前更大的时间步长而不牺牲太多准确性。
* 文献中有许多关于如何适应性地选择时间步长的建议。例如，可以从ODE求解器选择其时间步长的方式中学到很多。我们还可以从后验误差估计器中得到启发，理想情况下，后验误差估计器的编写方式包括对整体误差的时间和空间贡献。如果时间上的贡献太大，我们应该选择一个较小的时间步长。例如，这个方向的想法可以在deal.II的前主要开发者Ralf Hartmann的博士论文中找到，该论文由德国海德堡大学在2002年出版。
*

*[1.x.108][1.x.109] 。


* 我们在这里使用了一种比较简单的时间步进方法，即二阶时间的Crank-Nicolson方法。然而，更精确的方法，如Runge-Kutta方法，也是可以使用的，因为它们并不代表太多的额外努力。对于目前的程序来说，实现这一点并不困难，但在[2.x.104]中也给出了一个更系统的处理。
*

*[1.x.110][1.x.111] 。


* 如果你看一下上面电影中的网格，很明显，它们并不特别适合手头的工作。事实上，它们看起来相当随机。
* 有两个因素在起作用。首先，有一些岛屿，其中的细胞已经被细化，但周围是未细化的细胞（可能还有一些偶尔被粗化的岛屿）。这些并不可怕，因为它们大多数时候并不影响网格的近似质量，但是它们也没有帮助，因为它们的许多额外的自由度实际上是受到悬挂节点约束的。也就是说，这很容易解决：Triangulation类在它的构造器中接受一个参数，表示 "网格平滑 "的程度。传递一个可能的标志，这将指示三角结构细化一些额外的单元，或者不细化一些单元，这样得到的网格就不会有这些假象了。
* 第二个问题更为严重：网格出现滞后于解的情况。根本原因是我们每隔五步才调整一次网格，而且在这些情况下只允许进行一次细化。每当资源开启时，解决方案在这一区域之前是非常平滑的，因此网格是相当粗糙的。这意味着在下一个时间步骤中，当我们对网格进行细化时，我们将在这一区域获得更多的细化级别，而在五个时间步骤之后，将获得另一个级别，等等。但这还不够：首先，我们应该在一个源打开时立即进行细化（毕竟在当前情况下，我们至少知道右手边是什么），而且我们应该允许多于一个细化级别。当然，所有这些都可以用deal.II来完成，只是需要在如何实现这一工作方面有一些算法上的思考。
*

*[1.x.112][1.x.113] 。


* 为了提高你的模拟在时间上的准确性和分辨率，通常会减少时间步长[2.x.105]。如果你在这个特定的例子中开始玩弄时间步长，你会注意到，如果[2.x.106]低于某个阈值，解决方案会变成部分负值。这不是我们所期望发生的（在自然界）。
* 为了从数学上了解这种行为，让我们考虑一个一般的、完全离散的问题。
* [1.x.114]
* 然后，[2.x.107]th方程的一般形式为。
* [1.x.115]
* 其中[2.x.108]是自由度[2.x.109]耦合的自由度集合（即矩阵[2.x.110]或矩阵[2.x.111]在[2.x.112]位置有一个非零条目）。如果所有系数都满足以下条件。
* [1.x.116]
*所有解[2.x.113]的符号与之前的解[2.x.114]保持一致，并因此与初始值[2.x.115]保持一致。关于正性保持的更多信息，请参见例如[1.x.117]。
* 根据要解决的PDE和使用的时间积分方案，我们可以推导出时间步长的条件[2.x.116]。对于采用Crank-Nicolson方案的热方程，[1.x.118]已将其翻译为以下内容。
* [1.x.119]
* 其中[2.x.117]表示质量矩阵，[2.x.118]表示刚度矩阵，[2.x.119]分别为[2.x.120]。有了[2.x.121]，我们可以对全局时间步长[2.x.122]制定如下的界限。
* [1.x.120]
* 换句话说，在Crank-Nicolson方案的情况下，时间步长受到[1.x.121]的约束。这些约束应该与CFL条件一起考虑，以确保执行模拟的重要性。
* 无法使时间步长达到我们所希望的那样小，以获得更多的精度而又不失去正数特性是令人讨厌的。这就提出了一个问题：在这个特定的教程中，我们是否至少可以[1.x.122]选择最小的时间步长来确保正性的保留。事实上，我们可以使用MatrixCreator函数创建的质量和刚度的稀疏矩阵对象。通过SparseMatrixIterators遍历每个条目，我们可以检查对角线和非对角线条目，以动态地设置一个适当的时间步长。对于二次矩阵，对角线元素被存储为一行的第一个成员（见SparseMatrix文档）。下面是一个关于如何从[2.x.123]中抓取感兴趣的条目的示例性代码片段。
* [1.x.123]
*
* 使用这样计算出来的信息，我们可以通过上面的公式来约束时间步长。
*

* [1.x.124][1.x.125] [2.x.124]。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-27_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34]
*[1.x.35][1.x.36][1.x.37] 。


* 本教程试图展示如何使用[2.x.2]-无限元方法与deal.II。它解决的是拉普拉斯方程，因此只建立在前几个教程程序的基础上，特别是建立在[2.x.3]的尺寸无关编程和[2.x.4]的自适应网格细化上。
* 20世纪80年代初，Babu&scaron;ka和Guo提出了[2.x.5]有限元方法，作为(i)网格细化（即减少有限元计算中的网格参数[2.x.6]）或(ii)增加用于形状函数的多项式程度[2.x.7]的一种替代方法。它是基于这样的观察：如果解足够光滑，增加形状函数的多项式度数可以减少近似误差。另一方面，众所周知，即使是一般表现良好的一类椭圆问题，在边界附近、角落或系数不连续的地方也不能保证较高的规则性；因此，在这些地方不能通过提高多项式度来改善近似[2.x.8]，而只能通过细化网格，即减小网格大小[2.x.9]。这些减少误差的不同手段导致了[2.x.10]-无限元的概念，其中近似无限元空间被调整为在解足够平滑的地方具有高多项式度[2.x.11]，而在解缺乏规则性的地方减少了网格宽度[2.x.12]。在关于这种方法的第一篇论文中已经意识到，[2.x.13]--无限元素可以是一个强有力的工具，它可以保证误差不仅以自由度数的某个负数减少，而且事实上是以指数方式减少。
* 为了实现这种方法，我们需要一些超出一般有限元程序需要的东西，特别是超出我们在[2.x.14]之前的教程程序中所介绍的东西。特别是，我们将不得不讨论以下几个方面。[2.x.15] [2.x.16] 我们现在不是在所有单元上使用相同的有限元，而是想要一个有限元对象的集合，并将每个单元与这个集合中的一个对象相关联。[2.x.17]
* [2.x.18] 然后，必须根据与该特定单元相关的有限元，在每个单元上分配自由度。约束条件的生成方式与悬挂节点的生成方式相同，但我们现在还必须处理两个相邻单元分配不同有限元的情况。[2.x.19]
* [2.x.20] 我们将需要能够汇集单元和面对全局矩阵和右手向量的贡献。
* [2.x.22] 在解决了所产生的线性系统后，我们将想分析该解决方案。特别是，我们要计算误差指标，告诉我们是否应该细化一个给定的单元和/或是否应该增加对其使用的形状函数的多项式程度。[2.x.23] [2.x.24] 。
* 我们将在本介绍的以下小节中讨论所有这些方面。大部分的set任务已经被deal.II提供的功能很好地支持了，我们只需要提供程序应该做什么的逻辑，而不是具体如何发生，这不会让人感到很惊讶。
* 在deal.II中，[2.x.25]的功能主要被打包到hp-namespace中。这个命名空间提供了处理[2.x.26]分解、集合矩阵和向量以及其他任务的类。我们将在下文中进一步了解它们中的许多类。此外，DoFTools和VectorTools命名空间中的大多数函数除了接受非[2.x.28]的对象外，还接受[2.x.27]的对象。许多[2.x.29]的实现也在[2.x.30]文档模块和那里的链接中讨论。
* 在这篇介绍的第一部分的结尾，也许值得给出一个稍大的观点。  [2.x.31] -功能已经在许多不同的有限元软件包中实现（例如，见[2.x.32] "hp-paper "中引用的参考文献列表）。然而，总的来说，大多数这些软件包只对(i) 2d情况和/或(ii) 不连续Galerkin方法实现。后者是一个重要的简化，因为根据定义，非连续有限元不要求单元之间的面的连续性，因此，当不同多项式程度的有限元在一个共同的面相遇时，不需要特殊处理。相比之下，deal.II实现了最普遍的情况，即它允许1d、2d和3d的连续和不连续元素，并自动处理由此产生的复杂性。特别是，它可以处理不同程度的元素在面或边上相遇时的约束（类似于悬挂节点的约束）的计算。许多必要的算法和数据结构技术在[2.x.33]"hp-paper "中为那些对这些细节感兴趣的人进行了描述。
* 我们希望，提供这样一个通用的实现方法将有助于进一步挖掘[2.x.34]方法的潜力。
*


*[1.x.38][1.x.39]


* 现在再来看看如何使用[2.x.35]-功能的细节，二。我们要处理的第一个方面是，现在我们不再只有一个用于所有单元的单一有限元，而是有许多不同的单元可以选择使用的元素。为此，deal.II引入了[1.x.40]的概念，在[2.x.36]类中实现。实质上，这样的集合就像[2.x.37]类型的对象，但多了一些功能，内存管理也更适合当前的任务。正如我们以后所看到的，我们还将使用类似的正交集合，以及&mdash; 尽管我们在这里没有使用它们&mdash; 还有映射集合的概念。所有这些类在[2.x.38]概述中都有描述。
* 在这个教程程序中，我们将使用2到7阶（2D）或2到5阶（3D）的连续Lagrange元素。然后可以按以下方式创建使用的元素集合。
* [1.x.41]
*
*


* [1.x.42][1.x.43][1.x.44] 。


* 我们要考虑的下一个任务是如何处理我们要使用的有限元对象的列表。在以前的教程中，从[2.x.39]开始，我们已经看到DoFHandler类负责在网格(由三角形对象描述)和有限元之间建立联系，为网格的每个顶点、面、边和单元分配正确的自由度数量。
* 这里的情况要复杂一些，因为我们不只是有一个单一的有限元对象，而是可能要在不同的单元上使用不同的有限元。因此，我们需要两件事。(i) 可以处理这种情况的DoFHandler类的厌恶，以及(ii) 告诉DoFHandler在哪个单元上使用哪个元素的方法。
* 这两件事中的第一件是在DoFHandler类的[1.x.45]模式下实现的：不是将其与一个三角形和一个有限元对象相关联，而是与一个三角形和一个有限元集合相关联。第二部分是通过循环该DoFHandler的所有单元来实现的，并为每个单元设置在该单元上应使用的集合中的有限元的索引。我们将集合中用于某个单元的有限元对象的索引称为该单元的[1.x.46]，以表明这是活跃于该单元的有限元，而集合中的所有其他元素都是活跃的。其大致内容如下。
* [1.x.47]
*
* 调用[2.x.40]中的圆点表示我们以后必须有某种策略来决定在哪个单元上使用哪个元素；我们以后会回到这个问题。这里主要的一点是，这个代码片段的第一行和最后一行与非[2.x.41]的情况几乎完全相同。
* 另一个复杂的情况是，这次我们不只是有来自局部网格细化的悬空节点，我们还必须处理这样的情况：如果有两个具有不同完整有限元指数的单元在一个面上相遇（例如一个Q2单元和一个Q3单元），那么我们必须计算有限元场的额外约束以确保其连续。这在概念上与我们计算悬挂节点约束的方式非常相似，事实上，代码看起来完全一样。
* [1.x.48]
* 换句话说，[2.x.42]不仅处理悬挂节点约束，而且同时处理[2.x.43]约束。
*


*[1.x.49][1.x.50]


* 在这之后，我们必须为正确大小的线性系统设置矩阵和向量，并将它们组合起来。设置它们的方法与非[2.x.44]的情况完全相同。组装需要多花点心思。
* 主要的想法当然是不变的：我们必须在所有的单元中循环，集合本地的贡献，然后将它们复制到全局对象中。正如第一次在[2.x.45]中详细讨论的那样，deal.II有一个FEValues类，它将有限元描述、映射和正交公式拉到一起，帮助评估形状函数的值和梯度，以及映射到单元的每个正交点上的其他信息。每当我们转到一个新的单元时，我们就会重新初始化这个FEValues对象，从而要求它重新计算从一个单元到另一个单元的那部分信息。然后，它可以被用来总结对双线性形式和右手边的局部贡献。
* 在[2.x.46]有限元方法的背景下，我们必须处理这样一个事实，即我们不在每个单元上使用同一个有限元对象。事实上，我们甚至不应该对所有单元使用相同的正交对象，而应该对使用高阶有限元的单元使用更高阶的正交公式。同样地，我们也可能想在这些单元格上使用高阶映射。
* 为了促进这些考虑，deal.II有一个类[2.x.47]，可以满足我们在当前背景下的需要。不同的是，它不是单一的有限元、正交公式和映射，而是这些对象的集合。它的使用非常类似于常规的FEValues类，也就是说，在所有单元中循环的有趣部分看起来像这样。
* [1.x.51]
*
* 在本教程中，我们将始终使用Q1映射，所以[2.x.48]结构的映射集合参数将被省略。在这个循环中，我们首先初始化当前单元格的[2.x.49]对象。第二个、第三个和第四个参数表示我们希望在该单元上使用的正交、映射和有限元对象在各自集合中的索引。这些参数可以省略（在下面的程序中也是如此），在这种情况下，[2.x.50]被用来作为这个索引。之所以这样选择这些参数的顺序，是因为有时我们可能想从它们各自的集合中选择不同的正交或映射对象，但几乎不可能选择与该单元上使用的不同的有限元，即索引不同于[2.x.51]的有限元。因此，有限元集合的索引是最后一个默认参数，这样就可以方便地省略它。
* 这个[2.x.52]调用的作用如下：[2.x.53]类检查它是否已经为这个有限元、正交和映射对象的组合分配了一个[2.x.54] -FEValues对象。如果没有，它将分配一个。然后为当前单元重新初始化这个对象，之后就会有一个FEValues对象用于当前单元上选定的有限元、正交和映射。然后通过调用[2.x.55]获得对该对象的引用，并以常规方式用于集合本地贡献。
*


*[1.x.52][1.x.53]


* 自适应有限元方法的核心部分之一是，我们用一个指标来检查计算出的解（后验），这个指标告诉我们哪些单元的误差最大，然后对它们进行修正。在其他许多教程程序中，我们使用KellyErrorEstimator类来获得一个单元的误差大小指示，尽管我们也在一些程序中讨论了更复杂的策略，最重要的是在[2.x.56]中。
* 在任何情况下，只要决定只是 "细化这个单元 "或 "不细化这个单元"，实际的细化步骤就不是特别有挑战性的。然而，在这里，我们有一个能够进行hp细化的代码，也就是说，每当我们检测到某个单元的误差过大，我们就会突然有两个选择：我们可以通过将其分割成几个较小的单元来细化这个单元，或者我们可以增加用于它的形状函数的多项式程度。我们如何知道哪种策略更有前途？在撰写本文时，回答这个问题是[2.x.57]有限元研究的核心问题。
* 简而言之，这个问题目前在文献中似乎还没有解决。有许多或多或少复杂的方案来解决这个问题，但是没有什么像KellyErrorEstimator那样被普遍接受为一个好的，即使不是最佳的误差指标。大多数建议采用这样的事实：只要解决方案是局部光滑的，增加多项式的度数是有益的，而只要网格是粗糙的，细化网格是更好的。然而，如何确定解的局部光滑性以及决定何时解足够光滑以允许增加[2.x.58]的问题无疑是巨大而重要的。
* 在下文中，我们提出了一个简单的解的局部光滑性的估计方法。正如我们将在结果部分看到的，这个估计器有缺陷，特别是就有局部悬空节点的单元而言。因此，我们不打算把下面的想法作为问题的完整解决方案。相反，它是作为一个值得进一步研究和调查的想法来处理的。换句话说，我们不打算在关于一般问题答案的争论中提出一个复杂的建议。然而，为了证明我们对[2.x.59]无限元素的方法，我们需要一个简单的指标，它确实产生了一些有用的信息，可以驱动本教程程序所要进行的简单计算。
*

*[1.x.54][1.x.55]


* 我们在这里的方法很简单：对于一个函数[2.x.60]来说，它在单元格[2.x.62]上的Sobolev空间[2.x.61]中，必须满足条件[1.x.56]假设单元格[2.x.63]不是退化的，也就是说。从单元格到单元格[2.x.64]的映射足够规则，上述条件当然相当于[1.x.57]，其中[2.x.65]是映射回单元格[2.x.66]的函数。从这里，我们可以做以下工作：首先，让我们定义[2.x.68]的傅里叶级数为[1.x.58]，傅里叶向量[2.x.69]在2D，[2.x.70]在3D，等等，以及[2.x.71] 。扩张的系数[2.x.72]可以利用指数基[1.x.59]的[2.x.73]正交性得到，这导致了以下表达式[1.x.60]很明显，然后我们可以把[2.x.74]的规范[2.x.75]的[1.x.61]换句话说，如果这个规范是有限的（即[2.x.76]要在[2.x.77]中），我们需要[1.x.62]换句话说：我们想要的规则性[2.x.78]越高，傅里叶系数归零的速度越快。如果你想知道额外的指数[2.x.79]从何而来：我们想利用这样一个事实：[2.x.80]如果序列[2.x.81]为任何[2.x.82]。问题是，我们在这里不仅有一个单一变量的求和，而且有[2.x.83]的所有整数倍，这些整数倍位于[2.x.84]维球内，因为我们有矢量成分[2.x.85] 。正如我们证明上面的序列[2.x.86]通过在整条线上的积分来替代总和而实现的一样，我们可以用在[2.x.88]-维空间上的积分来替代我们的[2.x.87]-维总和。现在我们必须注意，在距离[2.x.89]和[2.x.90]之间，在一个常数以内，有[2.x.91]个模式，就像我们可以把体积元素[2.x.92]转化为[2.x.93]一样。因此，必须衰减为[2.x.95]的不再是[2.x.94]，而实际上是[2.x.96]。指数的比较产生了一个结果。
* 我们可以把这个问题转过来。假设我们得到了一个未知光滑度的函数[2.x.97]。让我们计算它的傅里叶系数[2.x.98]，看看它们的衰减速度。如果它们以[1.x.63]的速度衰减，那么我们这里的函数就在[2.x.99]中。
*

*[1.x.64][1.x.65]


* 那么，我们要如何估计[2.x.100]在[2.x.101]单元上的局部平滑度呢？显然，第一步是计算我们解决方案的傅里叶系数。傅里叶级数是无限级数，我们通过只计算级数的前几项来简化我们的任务，例如，[2.x.102]有一个截止点[2.x.103]。让我们顺便说一下，我们希望选择[2.x.104]足够大，以便我们至少能捕捉到那些变化最大的形状函数的变化。另一方面，我们也不应该把[2.x.105]选得太大：显然，一个有限元函数，作为一个多项式，在任何给定的单元格上都在[2.x.106]中，所以系数必须在某一点上呈指数衰减；由于我们想估计这个多项式所逼近的函数的平稳性，而不是多项式本身，我们需要为[2.x.107]选择一个合理的截断。无论如何，计算这个数列并不特别困难：从定义[1.x.66]我们可以看到，我们可以计算系数[2.x.108]为[1.x.67]，其中[2.x.109]是这个单元格上的[2.x.110]个自由度的值。换句话说，我们可以把它写成[1.x.68]与矩阵[1.x.69]的矩阵-向量乘积，对于给定数量的形状函数[2.x.111]和傅里叶模式[2.x.112]，这个矩阵很容易计算。因此，寻找系数[2.x.113]是一个相当琐碎的工作。为了进一步简化我们的生活，我们将使用[2.x.114]类，它正是这样做的。
* 下一个任务是，我们必须估计这些系数衰减的速度 [2.x.115] 。问题是，当然，我们首先只有无限多的这些系数。换句话说，我们能做的就是将一个函数[2.x.116]与我们的数据点[2.x.117]进行拟合，例如通过最小二乘法程序确定[2.x.118]：[1.x.70]然而，这样做的问题是，它导致了一个非线性问题，这是我们想要避免的事实。另一方面，如果我们试图将系数的对数与[2.x.119]的对数相适应，我们可以将问题转化为一个更简单的问题：[1.x.71]利用关于对数的通常事实，我们看到这产生了问题[1.x.72]，其中[2.x.120] 。现在，这是一个最佳条件[2.x.121]的问题，在[2.x.122]中是线性的。我们可以把这些条件写成：[1.x.73]这个线性系统很容易被倒置，得到[1.x.74]和[1.x.75] 。
* 虽然我们对[2.x.124]的实际值不是特别感兴趣，但上面的公式给了我们一个计算指数[2.x.125]的平均值，然后我们可以用它来确定[2.x.126]在[2.x.127]和[2.x.128]之间。
* 上面概述的这些步骤适用于许多不同的情况，这促使我们在deal.II中引入了一个通用函数[2.x.129]，它将本节中描述的所有任务结合在一个简单的函数调用中。我们将在这个程序的实现中使用它。
*

*[1.x.76][1.x.77] 。


* 在上面的公式中，我们已经得出了傅里叶系数 [2.x.130] 。因为[2.x.131]是一个矢量，对于相同的绝对值[2.x.133]，我们会得到许多傅里叶系数[2.x.132]，对应于不同方向的傅里叶变换。如果我们现在考虑像[2.x.134]这样的函数，那么我们会发现在[2.x.135]方向有很多大的傅里叶系数，因为该函数在这个方向是不光滑的，但在[2.x.136]方向有快速衰减的傅里叶系数，因为该函数在那里是光滑的。由此产生的问题是：如果我们简单地将我们的多项式衰减[2.x.137]与[1.x.78]的傅里叶系数拟合，我们将把它拟合为光滑度[1.x.79]。这就是我们想要的吗？还是只考虑所有[2.x.139]的最大系数[2.x.138]，本质上是试图确定解在空间方向上的平滑度，在这个方向上解似乎是最粗糙的？
*人们也许可以为这两种情况争辩。如果deal.II有能力使用各向异性的有限元，即在不同的空间方向上使用不同的多项式度数，那么这个问题将更有意义，因为他们可以更好地利用方向性的平滑度变化。可惜的是，在编写本教程程序时，这种能力并不存在。
* 无论如何，由于我们只有同位素的有限元类，我们采取的观点是，我们应该将多项式的程度调整到最低的规则性，以保持低的数值努力。因此，在计算[2.x.140]时，我们必须对所有的和稍作修改，而不是对所有的傅里叶模式进行求和，我们只对那些傅里叶系数是所有[2.x.141]中最大的[2.x.142]进行求和，也就是说，上述所有的和必须由以下的和来代替：[1.x.81]这就是我们将在程序中实现的形式。
*

*[1.x.82][1.x.83] 。


* 有人可能会问，我们只计算解的[1.x.84]（而不是实数单元）的傅里叶变换是否是个问题。毕竟，在变换过程中，我们将解决方案拉伸了一个系数[2.x.143]，从而使傅里叶频率移动了一个系数[2.x.144]。这是一个特别值得关注的问题，因为我们可能会有网格大小[2.x.145]的相邻单元，如果其中一个单元比另一个单元更精细，那么这两个单元就会相差2倍。正如我们在下面的结果部分所看到的那样，估计的平滑度应该是一个或多或少的连续函数，但是在网格尺寸跳跃的地方却表现出跳跃性，这也是引起关注的原因。因此，我们似乎很自然地要问，我们是否需要对这种转换进行补偿。
* 简短的回答是 "不"。在上述过程中，我们试图找到系数[2.x.146]，使各条款的平方之和最小化[1.x.85]，以补偿转换意味着不试图拟合一个衰减[2.x.147]相对于傅里叶频率[2.x.148][1.x.86]的衰减，而是去拟合在参考单元[1.x.87]上计算的系数[2.x.149]，其中[2.x.150]是变换算子的规范（即类似单元的直径）。换句话说，我们必须最小化[1.x.88]项的平方之和。然而，利用对数的基本属性，这就简单地等同于最小化[1.x.89]。换句话说，这和原来的最小二乘法问题将产生相同的最佳拟合指数[2.x.151]，尽管在一种情况下偏移量是[2.x.152]，在另一种情况下是[2.x.153] 。然而，由于我们对偏移量不感兴趣，而只对指数感兴趣，所以无论我们是否为了考虑网格大小的影响而对傅里叶频率进行缩放，都没有关系，在两种情况下估计的平滑度指数都是一样的。
*


*[1.x.90][1.x.91]


*[1.x.92][1.x.93] 。


* [2.x.154]方法的一个问题是，形状函数的高多项式度和大量的受限自由度导致矩阵的某些行有大量的非零条目。同时，由于有些地方我们使用低多项式度，因此矩阵行的非零项相对较少。因此，为这些矩阵分配稀疏性模式是一个挑战：我们不能简单地从带宽的估计开始组装一个稀疏性模式，而不使用大量的额外内存。
* 我们为底层线性系统创建SparsityPattern的方式与我们用来执行约束的策略密切相关。[2.x.155] [2.x.156] 在不考虑约束条件的情况下组装矩阵，然后用[2.x.157]或[2.x.158] [2.x.159] 在我们用[2.x.160] [2.x.161]组装系统时应用约束条件，大多数基于deal.II的程序使用[2.x.162] 函数来分配一个考虑到约束的动态SparsityPattern。然后系统矩阵使用从动态稀疏模式复制过来的稀疏模式。这个方法在[2.x.163]中作了解释，并在大多数教程程序中使用。
* 早期的教程程序使用一阶或二阶有限元，移动对应于受限自由度的稀疏模式中的条目对矩阵明确存储的零的总体数量没有很大影响。然而，由于多达三分之一的自由度在hp分解中可能受到约束（而且，在更高的度数元素中，这些约束可以将一个DoF与多达10个或20个其他DoF联系起来），值得考虑这些约束，因为结果矩阵将更加稀疏（因此，矩阵-向量乘积或因子化也将大大加快）。
*

*[1.x.94][1.x.95] 。


*[2.x.164]方法的第二个问题是，我们有许多受约束的自由度：通常有三分之一的自由度（在三维中）是受约束的，因为它们要么属于有悬空节点的单元，要么位于与具有更高或更低多项式度的单元相邻的单元上。事实上，这并不比非[2.x.165]模式中受约束的自由度多多少，但不同的是，每个受约束的悬空节点不仅受制于相邻的两个自由度，而且还受制于更多的自由度。
* 事实证明，[2.x.166]中首先提出的策略，即在用[2.x.167]计算元素矩阵和向量时消除约束，对于这种情况也是最有效的方法。另一种策略是首先建立没有约束的矩阵，然后 "浓缩 "掉受约束的自由度，这种策略的成本明显更高。事实证明，通过这种低效率的算法建立稀疏模式至少需要[2.x.168]个未知数，而理想的有限元程序当然只有与未知数成线性关系的算法。对稀疏模式的创建以及矩阵的装配进行计时，表明[2.x.169]中提出的算法（在下面的代码中使用）确实更快。
* 在我们的程序中，我们还将把边界条件视为（可能是不均匀的）约束条件，并将矩阵的行和列也消除。我们所要做的就是在设置阶段调用插值Dirichlet边界条件的函数，以告诉AffineConstraints对象它们的情况，然后同时在矩阵和向量上做从局部到全局的数据转移。这正是我们在[2.x.170]中所展示的。
*


*[1.x.96][1.x.97]。


* 我们将用这个程序解决的测试案例是对我们在[2.x.171]中已经看过的案例的重考：我们在2d中解决拉普拉斯方程[1.x.98]，用[2.x.172]，以及[2.x.173]的零Dirichlet边界值。我们在域[2.x.174]上这样做，即一个中间有一个正方形孔的正方形。
* 当然，与[2.x.175]的区别在于我们使用[2.x.176]的有限元素进行求解。这个测试案例是有意义的，因为它在洞的四角有re-entrant角，在这些角上的解有singularities。因此，我们期望解在域的内部是平滑的，而在奇点附近则是粗糙的。我们希望我们的细化和光滑度指标能够看到这种行为，并在远离奇点的地方细化网格，同时增加多项式度数。正如我们将在结果部分看到的那样，情况确实如此。
*

* [1.x.99] [1.x.100]。
* [1.x.101] [1.x.102]。


*
* 前面的几个文件已经在前面的例子中涉及到了，因此将不再进一步评论。
*


* [1.x.103]
*
* 这些是我们需要的新文件。第一个和第二个提供了FECollection和[1.x.104]版本的FEValues类，如本程序介绍中所述。下一个文件提供了自动[2.x.177]适应的功能，为此我们将使用基于衰变系列扩展系数的估计算法，这是最后两个文件的一部分。
*


* [1.x.105]
*
* 最后一组包含文件是标准的C++头文件。
*


* [1.x.106]

* 最后，这和以前的程序一样。
*


* [1.x.107]
*
* [1.x.108] [1.x.109]。


*
* 这个程序的主类看起来非常像前几个教程中已经使用过的程序，例如 [2.x.178] 中的那个。主要的区别是我们将refine_grid和output_results函数合并为一个，因为我们还想输出一些用于决定如何细化网格的量(特别是估计解决方案的平滑度)。   
* 就成员变量而言，我们使用与[2.x.179]中已经使用的相同的结构，但我们需要集合，而不是单个的有限元、正交和面状正交对象。我们将在类的构造函数中填充这些集合。最后一个变量，[2.x.180]，表示所用形状函数的最大多项式程度。
*


* [1.x.110]
*
* [1.x.111] [1.x.112]。
* 接下来，让我们为这个问题定义右手边的函数。它在1d中是[2.x.181]，在2d中是[2.x.182]，以此类推。
*


* [1.x.113]
*
* [1.x.114] [1.x.115]。


*
* [1.x.116] [1.x.117]。


*
* 这个类的构造函数是相当直接的。它将DoFHandler对象与三角形相关联，然后将最大多项式度数设置为7（在1d和2d中）或5（在3d及以上）。我们这样做是因为使用高阶多项式度数会变得非常昂贵，特别是在更高的空间维度上。   
* 在这之后，我们填补了有限元的集合，以及单元和面的四分法对象。我们从二次元开始，每个正交公式都被选择，以便它适合于[2.x.183]对象中的匹配有限元。
*


* [1.x.118]
*
* [1.x.119] [1.x.120]。


*
* 解构器与我们在 [2.x.184] 中已经做过的没有变化。
*


* [1.x.121]
*
* [1.x.122] [1.x.123]。
* 这个函数又是对我们在 [2.x.185] 中已经做过的事情的逐字复制。尽管函数调用的名称和参数完全相同，但内部使用的算法在某些方面是不同的，因为这里的dof_handler变量是在 [2.x.186] -模式下。
*


* [1.x.124]
*
* [1.x.125] [1.x.126]。


*
* 这是一个从每个单元的局部贡献集合全局矩阵和右手向量的函数。它的主要工作原理与之前的许多教程程序中描述的一样。重要的差异是[1.x.127]有限元方法所需要的。特别是，我们需要使用FEValues对象的集合（通过[2.x.187]类实现），并且在将局部贡献复制到全局对象时，我们必须消除受限自由度。这两点在本程序的介绍中都有详细解释。   
* 另外一个小小的复杂情况是，由于我们在不同的单元格上使用不同的多项式度，持有局部贡献的矩阵和向量在所有单元格上的大小不一样。因此，在所有单元的循环开始时，我们每次都必须将它们的大小调整到正确的大小（由[2.x.188]给出）。因为这些类的实现方式是减少矩阵或向量的大小不会释放当前分配的内存（除非新的大小为零），所以在循环开始时调整大小的过程只需要在最初几次迭代中重新分配内存。一旦我们在一个单元中找到了最大的有限元度，就不会再发生重新分配的情况，因为所有后续的[2.x.189]调用只会将大小设置为适合当前分配的内存。这一点很重要，因为分配内存是很昂贵的，而且每次我们访问一个新的单元时都这样做会花费大量的计算时间。
*


* [1.x.128]
*
* [1.x.129] [1.x.130]。


*
* 解决线性系统的函数与以前的例子完全没有变化。我们只是试图将初始残差（相当于右手边的[2.x.190]准则）减少一定的系数。
*


* [1.x.131]
*
* [1.x.132] [1.x.133]。


*
* 解完线性系统后，我们要对解进行后处理。在这里，我们所做的就是估计误差，估计解的局部光滑度，如介绍中所述，然后写出图形输出，最后根据之前计算的指标在[2.x.191]和[2.x.192]中细化网格。我们在同一个函数中完成这一切，因为我们希望估计的误差和平滑度指标不仅用于细化，而且还包括在图形输出中。
*


* [1.x.134]
*
* 让我们开始计算估计的误差和平滑度指标，这两个指标对于我们三角测量的每个活动单元来说都是一个数字。对于误差指标，我们一如既往地使用KellyErrorEstimator类。
*


* [1.x.135]
*
* 估算平滑度是用介绍中所述的衰减膨胀系数的方法进行的。我们首先需要创建一个对象，能够将每一个单元上的有限元解转化为一串傅里叶级数系数。SmoothnessEstimator命名空间为这样一个[2.x.193]对象提供了一个工厂函数，它为估计平滑度的过程进行了优化。然后在最后一个函数中实际确定每个单独单元上的傅里叶系数的衰减情况。
*


* [1.x.136]

* 接下来我们要生成图形输出。除了上面得出的两个估计量之外，我们还想输出网格上每个元素所使用的有限元的多项式程度。     
* 要做到这一点，需要我们在所有单元上循环，用[2.x.194]轮询它们的活动有限元索引。然后我们使用这个操作的结果，在有限元集合中查询具有该索引的有限元，最后确定该元素的多项式程度。我们将结果放入一个矢量，每个单元有一个元素。DataOut类要求这是一个[2.x.195]的向量，尽管我们的值都是整数，所以我们就用这个向量。
*


* [1.x.137]
*
*现在有了所有的数据向量
*
* - 解决方案，估计误差和平滑度指标，以及有限元度
*
* - ，我们创建一个用于图形输出的DataOut对象并附加所有数据。
*


* [1.x.138]
*
* 生成输出的最后一步是确定一个文件名，打开文件，并将数据写入其中（这里，我们使用VTK格式）。
*


* [1.x.139]
*
* 在这之后，我们想实际细化网格，在[2.x.196]和[2.x.197] 。我们要做的是：首先，我们用估计的误差来标记那些误差最大的单元来进行细化。这就是我们一直以来的做法。
*


* [1.x.140]
*
* 接下来我们要弄清楚哪些被标记为细化的单元格实际上应该增加[2.x.198]而不是减少[2.x.199]。我们在这里选择的策略是，我们查看那些被标记为细化的单元格的平滑度指标，并为那些平滑度大于某个相对阈值的单元格增加[2.x.200]。换句话说，对于每一个(i)细化标志被设置，(ii)平滑度指标大于阈值，以及(iii)我们在有限元集合中仍有一个多项式程度高于当前的有限元的单元，我们将分配一个未来的FE指数，对应于一个比当前高一个程度的多项式。下面的函数正是能够做到这一点。在没有更好的策略的情况下，我们将通过在标记为细化的单元上的最小和最大平滑度指标之间进行插值来设置阈值。由于角部奇点具有很强的局部性，我们将在数量上支持[2.x.201]-而不是[2.x.202]-细化。我们通过设置0.2的小插值因子，以低阈值实现这一点。以同样的方式，我们处理要被粗化的单元，当它们的平滑度指标低于在要被粗化的单元上确定的相应阈值时，就减少它们的多项式程度。
*


* [1.x.141]
*
* 上述函数只确定多项式程度是否会通过未来的FE指数发生变化，但不会操作[2.x.203] -细化标志。因此，对于被标记为两种细化类别的单元，我们更倾向于[2.x.204] -而不是[2.x.205] -细化。下面的函数调用确保只有[2.x.206] -或[2.x.207] -细化中的一个被施加，而不是同时施加。
*


* [1.x.142]
*
* 对于网格自适应细化，我们通过调用[2.x.208]将相邻单元的细化水平差限制为1来确保2:1的网格平衡。 我们希望对相邻单元的p水平实现类似的效果：未来有限元的水平差不允许超过指定的差值。通过其默认参数，调用[2.x.209]可以确保它们的级差被限制为1。这不一定会减少域中的悬挂节点的数量，但可以确保高阶多项式不会被限制在面的低得多的多项式上，例如，五阶多项式到二阶多项式。
*


* [1.x.143]
*
* 在这个过程的最后，我们再细化网格。在这个过程中，正在进行分化的单元的子单元会继承其母单元的有限元指数。此外，未来的有限元指数将变成活动的，因此新的有限元将在下一次调用[2.x.210]后被分配给单元。
*


* [1.x.144]
*
* [1.x.145] [1.x.146]。


*
* 在创建初始网格时，会用到下面这个函数。我们想要创建的网格实际上类似于[2.x.211]中的网格，即中间有方孔的方形域。它可以由完全相同的函数生成。然而，由于它的实现只是2d情况下的一种特殊化，我们将介绍一种不同的创建这个域的方法，它是独立于维度的。   
* 我们首先创建一个有足够单元的超立方体三角形，这样它就已经包含了我们想要的域[2.x.212]，并细分为[2.x.213]单元。然后，我们通过测试每个单元上顶点的坐标值来移除域中心的那些单元。最后，我们像往常一样对如此创建的网格进行全局细化。
*


* [1.x.147]
*
* [1.x.148] [1.x.149]。


*
* 这个函数实现了程序的逻辑，就像以前大多数程序中的相应函数一样，例如，见 [2.x.214] 。   
* 基本上，它包含了自适应循环：在第一次迭代中创建一个粗略的网格，然后建立线性系统，对其进行组合，求解，并对解进行后处理，包括网格细化。然后再重新开始。同时，也为那些盯着屏幕试图弄清楚程序是干什么的人输出一些信息。
*


* [1.x.150]
*
* [1.x.151] [1.x.152]。


*
* 主函数仍然是我们之前的版本：将创建和运行一个主类的对象包装成一个[2.x.215]块，并捕捉任何抛出的异常，从而在出现问题时产生有意义的输出。
*


* [1.x.153]
* [1.x.154][1.x.155] 。


* 在本节中，我们讨论了运行当前教程程序所产生的一些结果。更多的结果，特别是扩展到三维计算和确定程序的各个部分需要多少计算时间，在[2.x.216]"hp-paper "中给出。
* 当运行时，这是该程序产生的结果。
* [1.x.156]
*
* 我们从中了解到的第一件事是，受限自由度的数量占总自由度的20-25%，至少在后来的网格中，当我们有相对高阶的元素时（在3D中，受限自由度的比例可以达到30%）。事实上，这与非[2.x.217]分解的数量级相同。例如，在[2.x.218]程序的最后一步，我们有18353个自由度，其中4432个是受限的。不同的是，在后者的程序中，每个受约束的悬挂节点只对相邻的两个自由度进行约束，而在[2.x.219]的情况下，受约束的节点对许多自由度进行约束。还要注意的是，目前的程序在约束列表中还包括受迪里切特边界条件约束的节点。在第0周期中，所有的约束实际上都是因为边界条件。
* 也许更有趣的是看一下图形输出。首先，这是该问题的解决方案。
* <img src="https://www.dealii.org/images/steps/developer/ [2.x.220] -solution.png" alt="解决方案的高程图，显示在内部（重入）角附近缺乏规则性。" width="200" height="200">。
* 其次，让我们看一下生成的网格序列。
* [2.x.221]
* 我们可以清楚地看到，在角部奇点附近的网格是如何被细化的，正如人们所期望的那样。更有趣的是，我们应该好奇地看看这些网格单元的有限元多项式度数的分布，其中最浅的颜色对应于2度，最深的对应于7度。
* [2.x.222]
* 这当然不是一个完美的安排，但它确实有一定的意义：我们在边界和角落附近使用低阶元素，因为那里的规则性很低。另一方面，在以下情况下使用高阶元素：(i) 误差在某一点上相当大，即主要是在拐角处的一般区域和右上角，那里的解很大；(ii) 解是平滑的，即远离边界的地方。
*这种多项式程度的安排当然是由我们的平滑度估计器得出的。这里是对解决方案的平滑度的估计，深色表示最不平滑，浅色表示最平滑的区域。
* [2.x.223]
* 从这里可以得出的主要结论是，内角的规则性损失是一个高度局部的现象；它似乎只影响到与角相邻的单元，所以当我们细化网格时，黑色的颜色就不再明显。除了角之外，这一连串的图示表明，平滑度估计值在某种程度上与网格细化无关，特别是当我们远离边界的时候。同样明显的是，平滑度估计值与解的实际大小无关（见上面的解的图片），因为它应该是如此。这反过来又导致这些区域的多项式度数更高，使有限元在单元中的分配出现偏差。
* 我们目前对这种影响没有很好的解释。有一种理论认为，有悬空节点的单元上的数值解当然是受限制的，因此不能完全自由地探索函数空间以获得接近精确的解。这种自由度的缺乏可能表现为在这些单元上产生具有抑制振荡的数值解，意味着更高的平滑度。估计器会捕捉到这个信号，估计的平滑度会高估实际值。然而，这个程序的作者目前还没有找到发生了什么的确切答案。
* 当然，更大的问题是，如何避免这个问题。可能的情况包括：不是在单个细胞上估计平滑度，而是在每个细胞周围的细胞组合或批次上估计。也可以根据每个细胞所拥有的受限自由度的数量，为其找到简单的修正系数。无论哪种情况，都有大量的机会来进一步研究寻找好的[2.x.224]细化标准。另一方面，目前计划的主要内容是展示使用交易二中的[2.x.225]技术，该技术不受我们使用可能的次优精炼标准的影响。
*


* [1.x.157][1.x.158][1.x.159] 。


*[1.x.160][1.x.161] 。


* 本教程只演示了决定[2.x.226]-和[2.x.227]-适应的一个特定策略。事实上，还有许多自动决定适应类型的方法，其中一些已经在deal.II中实现： [2.x.228] [2.x.229] [1.x.162] 这是本教程中目前实现的策略。关于这一策略的更多信息，请参见[2.x.230]命名空间的一般文档。[2.x.231]
* [2.x.232] [1.x.163] 这个策略与目前的策略很相似，但使用了Legendre级数展开，而不是傅里叶级数：这个策略使用Legendre多项式而不是正弦波作为基础函数。当然，由于我们在每个单元上使用有限维度的多项式来近似解，因此解在Legendre多项式中的扩展也是有限的，因此，当我们谈论这个扩展的 "衰减 "时，我们只能考虑这个扩展的有限多个非零系数，而不是用渐进的方式来思考。  但是，如果我们有足够多的这些系数，我们当然可以把这些系数的衰减看作是精确解的系数衰减的特征（一般来说，精确解不是多项式的，所以会有一个无限的Legendre扩展），考虑我们拥有的系数应该可以揭示一些关于精确解的特性。
* 从傅里叶策略到Legendre策略的转换非常简单。  你只需要改变序列扩展类和相应的平滑度估计函数，使其成为适当命名空间的一部分 [2.x.233] 和 [2.x.234] 这种策略在 [2.x.235] 中使用。关于这个策略的理论背景，请参考 [2.x.236] 命名空间的一般文档，以及 [2.x.237] 、 [2.x.238] 和 [2.x.239] 。[2.x.240]
* [2.x.241] [1.x.164] 最后一个策略与其他两个截然不同。在理论上，我们知道在改变函数空间离散化后，误差会如何收敛。通过[2.x.242]-细化，解决方案以代数方式收敛，正如在[2.x.243]中已经指出的。不过，如果解足够平滑，我们预计解将随着有限元的多项式程度的增加而指数级收敛。我们可以在下面的步骤中把对误差的适当预测与实际误差进行比较，看看我们对适应类型的选择是否合理。
*过渡到这个策略就比较复杂了。为此，我们需要一个纯[2.x.244]-或[2.x.245]-细化的初始化步骤，我们需要将预测的误差转移到适应的网格上。[2.x.246]函数的大量文档不仅描述了这种方法的理论细节，而且还介绍了如何在你的代码中实现这种策略的蓝图。欲了解更多信息，请参见 [2.x.247] 。
* 请注意，在时间依赖性问题上，用这个特殊的函数你无法预测下一个时间步骤的误差。因此，这种策略不能不加思索地应用于这种类型的问题。另外，也可以使用下面的方法，它也适用于所有其他的策略：从每一个时间步骤的粗网格开始，不断细化，直到对结果满意为止，然后才进入下一个时间步骤。[2.x.248] [2.x.249] [2.x.249].
* 试着在本教程中实施这些策略之一，并观察结果的细微变化。你会注意到，所有的策略都能识别出重心角附近的奇点，并会在这些区域进行[2.x.250]-精简，而更倾向于[2.x.251]-精简大体域。这些策略的详细比较见[2.x.252]。
*

*[1.x.165][1.x.166]


* 本教程中介绍的所有功能都已经适用于连续和并行的应用。可以不费吹灰之力就改成[2.x.253]或[2.x.254]类。如果你急于尝试，我们建议先阅读[2.x.255]（前者）和[2.x.256]（后者），以了解有关该主题的进一步背景信息，然后再回到本教程，尝试你新获得的技能。
* 我们在[2.x.257]中更进一步：在这里，我们将hp-adapative和MatrixFree方法与[2.x.258]对象结合起来。
*

* [1.x.167][1.x.168] [2.x.259] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-28_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39]
* [2.x.2]
* [1.x.40][1.x.41][1.x.42] 。
* [2.x.3]
*

* [1.x.43][1.x.44] [1.x.45] 。
* 在这个例子中，我们打算解决中子传输方程的多组扩散近似。从本质上讲，看待这个问题的方式如下。在核反应堆中，中子以不同的能量飞驰，被吸收或散射，或开始一个新的裂变事件。如果从足够长的长度尺度来看，中子的运动可以被视为一个扩散过程。
* 对这一过程的数学描述将把中子分成几个能级，并考虑每个能级或能量组中的中子通量的平衡方程。散射、吸收和裂变事件将成为描述中子通量的扩散方程中的算子。假设我们有能量组[2.x.4]，按照惯例，我们假设能量最高的中子在1组，能量最低的中子在[2.x.5]组。然后每组的中子通量满足以下方程：[1.x.46] 。
*由适当的边界条件增强。这里，[2.x.6]是组内中子的速度 [2.x.7] 。换句话说，[2.x.8]组中的中子通量的时间变化是由以下过程所支配的。[2.x.9] [2.x.10] 扩散 [2.x.11] 。这里，[2.x.12]是（空间上可变的）扩散系数。[2.x.13] 吸收 [2.x.14] （注意是负号）。系数[2.x.15]被称为[1.x.47]。[2.x.16] 核裂变 [2.x.17] 。  能量的中子[2.x.18]的产生与能量的中子通量[2.x.19]乘以能量的中子[2.x.21]引起裂变事件的概率[2.x.22]乘以每个裂变事件中产生的中子数量乘以该事件中产生的中子具有能量的概率[2.x.23] 。  [2.x.24]被称为[1.x.48]，[2.x.25]被称为[1.x.49]。我们将在程序中把[2.x.26]这个词表示为[1.x.50]。[2.x.27] 能量为[2.x.28]的中子的散射[2.x.29]产生能量为[2.x.30]的中子 。  [2.x.31]被称为[1.x.51]。弹性、群内散射[2.x.32]的情况也存在，但我们将其归入清除截面。[2.x.33]的情况被称为向下散射，因为中子在这样的事件中失去了能量。另一方面，[2.x.34]对应于上散射：中子在散射事件中从其周围原子的热运动中获得能量；因此，上散射仅对动能已经与热动能相同的中子（即在[2.x.35]以下范围）是一个重要过程。[2.x.36] 一个外源 [2.x.37] 。[2.x.38]
* 然而，如果对某些类型的反应堆（例如压水反应堆，PWR）的中子能谱有足够的了解，那么只用两个能组就可以获得满意的结果。
* 在本教程中显示的程序中，我们提供了一个结构，可以根据需要计算任意多的能量组。然而，为了保持适度的计算时间，并避免将数百个系数列入表格，我们只提供上述两组模拟方程的系数，即[2.x.39] 。然而，我们确实考虑了一个现实的情况，即假设系数不是恒定的，而是取决于以相当复杂的方式组装成反应堆燃料组件的材料（见下文）。
*

*[1.x.52][1.x.53]


* 如果我们同时考虑所有的能量组，我们可以把上述方程写成以下的算子形式：[1.x.54] 。
* 其中[2.x.40]分别是沉降、裂变和散射算子。  这里的[2.x.41]包括扩散和清除项。注意，[2.x.42]是对称的，而[2.x.43]和[2.x.44]不是。
* 众所周知，如果算子[2.x.45]的等值为负，该方程就会有稳定的解。这可以通过将方程乘以[2.x.46]并在域上进行积分而很容易看出，从而得出[1.x.55] 。
* 稳定性意味着解决方案不会增长，也就是说，我们希望左手边的值小于零，如果右边运算器的特征值都是负的，就会出现这种情况。由于显而易见的原因，如果核反应堆产生的中子通量呈指数增长，那就不是很理想了，所以特征值分析是核工程师的面包和主食。因此，本程序的重点是考虑特征值问题[1.x.56] 。
* 其中我们要确保所有的特征值都是正的。请注意，[2.x.47]，即扩散算子加上吸收（去除），是正无限的；因此，所有特征值为正的条件意味着我们要确保裂变和组间散射足够弱，不会将光谱转移到负值。
* 在核工程中，人们通常关注的是特征值问题的一个略微不同的形式。为此，我们不只是与[2.x.48]相乘并积分，而是与[2.x.49]相乘。我们得到以下进化方程：[1.x.57] 。
* 如果以下问题的特征值都是负的，那么稳定性就得到了保证：[1.x.58] 。
* 这等同于特征值问题[1.x.59] 。
* 核工程中的典型表述是将其写为[1.x.60] 。
* 直观地说，[2.x.51]类似于每个典型时间尺度的中子的乘法系数，对于反应堆的稳定运行来说，它应该小于或等于1：如果它小于1，链式反应就会停止，而核弹等的特征值[2.x.52]大于1。一个稳定的反应堆应该有[2.x.53] 。
* 对于那些想知道如何在实践中实现这一点，而不在不经意间变得比一稍大而引发核弹的人来说：首先，裂变过程发生在不同的时间尺度上。虽然大多数中子在裂变事件后很快就被释放出来，但少量的中子只有在裂变开始后的10-60秒内，经过几次进一步的衰变才由子核释放出来。因此，如果稍稍超过[2.x.54]，就会有许多秒的时间进行反应，直到裂变中产生的所有中子重新进入裂变循环。然而，核反应堆中吸收中子的控制棒
*
* - 因此减少[2.x.55]。
*
* - 被设计成这样的方式，它们在最多2秒内全部进入反应堆。
* 因此，如果[2.x.56]在一段时间内大于1，正如不断增长的中子通量所表明的那样，人们有10-60秒的时间来调节核反应。调节可以通过持续监测中子通量来实现，必要时通过将吸收中子的控制棒移入或移出反应堆几毫米来增加或减少中子通量。在更大的范围内，冷却反应堆的水含有硼，这是一种良好的中子吸收剂。每隔几个小时，通过添加硼或稀释冷却剂来调整硼的浓度。
* 最后，一些吸收和散射反应具有一定的稳定性；例如，较高的中子通量导致局部温度升高，这降低了水的密度，因此减少了散射体的数量，而这些散射体是在中子开始裂变事件之前将中子从高能量变为低能量所必需的。
* 在这个教程程序中，我们解决上述[2.x.57]-两个能量组的特征值问题，我们正在寻找最大的乘法系数[2.x.58]，它与最小特征值的逆值加1成正比。为了解决特征值问题，我们通常使用[1.x.61]的修改版。该算法看起来像这样。
* [2.x.59] [2.x.60] 用[2.x.63]和[2.x.64]初始化[2.x.61]和[2.x.62]，让[2.x.65] 。
* [2.x.66] 通过[1.x.63]定义所谓的[1.x.62]。

* [2.x.67] 用[1.x.64]求解所有群通量[2.x.68] 。
*
* [2.x.69] 更新[1.x.65]。

* [2.x.70] 比较 [2.x.71] 和 [2.x.72] 。  如果变化大于规定的公差，则设置 [2.x.73] 从步骤2开始重复迭代，否则结束迭代。[2.x.74]
* 请注意，在这个方案中，我们在每次迭代中不完全解决群通量，而是考虑以前只计算 [2.x.75] 下散射事件 [2.x.76] 。上散射仅通过使用旧迭代器[2.x.77]来处理，实质上是假设散射操作器是三角形的。这是物理上的原因，因为向上散射在中子散射中并不扮演太重要的角色。此外，实践表明，即使使用这种简化方法，反功率迭代也是稳定的。
* 还需要注意的是，人们可以使用很多外推技术来加速上述的功率迭代。然而，这些都没有在本例中实现。
*

*[1.x.66][1.x.67]


* 人们可能会问，在同一网格上求解各个能量组方程的解是否合适。这个问题可以归结为：[2.x.78]和[2.x.79]是否具有类似的光滑性？如果是这样的话，那么对两者使用相同的网格是合适的；一个非典型的应用可能是化学燃烧，通常所有或大多数化学物种的浓度在火焰前沿快速变化。事实证明，正如在本教程程序的结果部分所显示的图表所显示的那样，这里的情况并非如此：由于不同能量组的扩散系数是不同的，快中子（在小组数[2.x.80]的组别中）有一个非常平滑的网格。] 有一个非常平滑的通量函数，而慢速中子（在有大组数的仓中）受当地材料特性的影响更大，如果系数是粗糙的，就像我们这里计算的情况一样，有一个相应的粗糙的解决方案。因此，我们希望使用不同的网格来计算每个能量组。
* 这有两个影响，我们必须加以考虑。首先，我们需要找到一种方法来单独细化这些网格。第二，为反功率迭代组装源码，我们必须将定义在网格[2.x.82]上的解[2.x.81]与定义在网格[2.x.83]上的形状函数进行整合，这将成为一项更为复杂的任务。
*

*[1.x.68][1.x.69] 。


* 我们使用通常的范式：在一个给定的网格上求解，然后对每个网格的每个单元评估一个误差指标。因为它非常方便，我们再次使用Kelly, Gago, Zienkiewicz和Babuska的后验误差估计器，该估计器通过整合每个单元面的解的梯度跳跃来接近每个单元的误差。使用这个方法，我们可以得到指标[1.x.70] 。
*其中[2.x.84]是用于解决[2.x.85]的三角结构。问题是该如何处理这个问题。首先，很明显，只提炼那些误差指标最高的单元可能会导致不好的结果。为了理解这一点，必须认识到[2.x.86]与[2.x.87]的二阶导数成比例。换句话说，如果我们有两个能量组[2.x.88]，它们的解同样平滑，但其中一个大了一万倍，例如，那么只有该网格的单元会被细化，而小幅度的解的网格会保持粗糙的。这可能不是我们想要的，因为我们可以认为解决方案的两个部分同样重要。
* 从本质上讲，我们必须用一个重要系数[2.x.90]来衡量[2.x.89]，即在任何特定精度下解决[2.x.91]的重要性。这样的重要系数可以用对偶性技术来计算（例如，见[2.x.92]教程程序，以及那里引用的Bangerth和Rannacher的书的参考资料）。然而，我们不会走到这一步，而是简单地假设所有的能量组都同样重要，因此将用解[2.x.95]的最大值对组[2.x.93]的误差指标进行归一化。然后我们细化那些误差满足[1.x.71]的单元。
* 并粗化满足[1.x.72]的单元格。
* 我们在代码中选择[2.x.96]和[2.x.97]。注意，这当然会导致不同能量组的不同网格。
* 上面的策略基本上意味着以下几点。如果对于能量组[2.x.98]来说，有许多单元[2.x.99]的误差很大，例如因为全局的解非常粗糙，那么许多单元将在阈值之上。另一方面，如果有几个单元的误差较大，而许多单元的误差较小，例如，因为除少数地方外，解决方案总体上是比较光滑的，那么，只有少数有较大误差的单元将被细化。因此，该策略可以使网格很好地跟踪相应解的整体光滑性属性。
*

*[1.x.73][1.x.74]


* 如上所述，多组细化策略对不同的解[2.x.100]产生不同的网格。那么问题出在哪里呢？实质上是这样的：在特征值迭代的第三步，我们必须像往常一样通过与定义在网格前能群[2.x.103]上的测试函数[2.x.102]相乘，形成方程的弱形式来计算[2.x.101]；在这个过程中，我们必须计算包含以下形式的条款的右手边向量：[1.x.75]
*其中[2.x.104]是用于特征值方程右侧的系数函数[2.x.105]或[2.x.106]中的一个。现在的困难是[2.x.107]是定义在能量组[2.x.108]的网格上，即它可以扩展为[2.x.109]，基函数[2.x.110]定义在网格[2.x.111]。因此，对右手边的贡献可以写成[1.x.76] 。
* 另一方面，测试函数[2.x.112]被定义在网格[2.x.113]上。这意味着我们不能将积分[2.x.114]分割成网格[2.x.115]或[2.x.116]上的积分，因为其他的基函数可能不在这些单元上定义。
* 这个问题的解决方法在于[2.x.117]和[2.x.118]的网格都是通过自适应细化从一个共同的粗大网格中得到的。因此，我们总是能找到一组满足以下条件的单元，我们用[2.x.119]表示。[2.x.120] [2.x.121] 这些单元的联合覆盖了整个领域，并且[2.x.122] 一个单元[2.x.123] 在两个网格中至少有一个是活动的。[2.x.124]构造这个集合的方法是，取粗网格的每个单元，做以下步骤。(i) 如果该单元在[2.x.125]或[2.x.126]上处于活动状态，则将该单元加入该集合；(ii) 否则，即如果该单元在两个网格上都有子代，则对该单元的每个子代进行步骤(i)。事实上，deal.II有一个函数[2.x.127]可以准确地计算出在两个网格中至少有一个处于活动状态的单元的集合。
* 有了它，我们可以将上述积分写成：[1.x.77] 。
* 在代码中，我们在函数[2.x.128]中计算右手边，其中（除其他外）我们在共同的最精炼的单元集上循环，在每一对这些单元上调用函数[2.x.129]。
* 根据结构，现在有三种情况需要考虑。[2.x.130] [2.x.131] 单元[2.x.132]在两个网格上都是有效的，也就是说，基函数[2.x.133]和[2.x.134]都是在[2.x.135]上定义。[2.x.136] 单元[2.x.137]在网格[2.x.138]上有效，但在[2.x.139]上无效，即[2.x.140]定义在[2.x.141]上，而[2.x.142]定义在[2.x.143]的子网格上。[2.x.144] 单元[2.x.145]在网格[2.x.146]上是有效的，但在[2.x.147]上不是，结论与(ii)中相反。[2.x.148]
* 为了计算上面的右手边，我们需要对这三种情况有不同的代码，如下所示。[2.x.149] [2.x.150] 如果单元[2.x.151]在两个网格上都是活动的，那么我们可以直接评估积分。事实上，我们甚至不必理会基函数[2.x.152]，因为我们所需要的只是[2.x.153]在正交点的值。我们可以使用[2.x.154]函数来完成这个任务。这可以直接在[2.x.155]函数中完成。
* [2.x.156] 如果单元[2.x.157]在网格[2.x.158]上被激活，而不是[2.x.159]，那么基函数[2.x.160]只定义在子单元[2.x.161]上，或者如果单元[2.x.162]在网格[2.x.163]上被精化了一次以上，则定义在这些子单元的子节点上。
* 让我们假设[2.x.164]在网格[2.x.165]上只比在网格[2.x.166]上多精炼一次。利用我们使用嵌入式有限元空间的事实，即一个网格上的每个基函数可以写成下一个细化网格上的基函数的线性组合，我们可以将[2.x.167]对子单元[2.x.168]的限制扩展为定义在该子单元上的基函数（即定义了基函数[2.x.169]的单元上）。  [1.x.78]
* 在这里，以及在下文中，暗示了对出现两次的指数进行求和。矩阵[2.x.170]是将数据从一个单元内插到其[2.x.171]-个子的矩阵。
* 那么我们可以把单元格[2.x.172]对右侧分量[2.x.173]的贡献写成[1.x.79] 。
* 在矩阵符号中，这可以写成[1.x.80] 。
*其中[2.x.174]是单元格[2.x.176]的子[2.x.175]上的加权质量矩阵。
* 接下来的问题是，如果[2.x.178]的子单元[2.x.177]不活跃会怎样。然后，我们必须递归地应用这个过程，即我们必须将基函数[2.x.179]插值到[2.x.181]的子单元[2.x.180]上，然后插值到该单元的子单元[2.x.182]上，插值到该单元的子单元[2.x.183]上，等等，直到我们找到一个活动单元。然后，我们必须将单元格[2.x.184]的所有子代、孙代等的贡献相加，其贡献形式为[1.x.81] 。
*或[1.x.82]。
*等等。我们递归地做这个过程，即如果我们坐在单元格[2.x.185]上，看到它在网格[2.x.186]上有子代，那么我们用一个身份矩阵调用一个函数[2.x.187]；该函数将从左边的参数乘以延长矩阵；如果该单元格还有子代，它将用这个新矩阵调用自己，否则它将执行积分。
* [2.x.188] 最后一种情况是，[2.x.189]在网格[2.x.190]上是有效的，但在网格[2.x.191]上不是。在这种情况下，我们必须用定义在单元格 [2.x.193] 上的基函数来表达基函数 [2.x.192] ，而不是像之前那样用 [2.x.194] 来表达。这当然是以完全相同的方式进行的。如果[2.x.195]的子单元在网格[2.x.196]上是活动的，那么就会导致表达式[1.x.83] 。
* 在矩阵符号中，这个表达式现在读作[1.x.84] 。
* 对于单元格[2.x.197]在网格[2.x.198]上被精炼一次以上的情况，相应地：[1.x.85] 。
*或[1.x.86] 。
*等等。换句话说，这个过程与之前的工作方式完全相同，只是我们必须采取延长矩阵的转置，并需要从另一侧乘以质量矩阵。[2.x.199]
*

*情况(ii)和(iii)的表达式可以理解为将标量积[2.x.200]中的左或右基函数反复内插到子单元上，然后在最后的单元上形成内积（质量矩阵）。为了使这些情况的对称性更加明显，我们可以这样写：对于情况（二），我们有[1.x.87] 。
*而对于情况(iii)，我们得到[1.x.88]。
*
*


*[1.x.89][1.x.90]


* 核反应堆堆芯是由不同类型的组件组成的。一个组件基本上是最小的单元，可以在反应堆中移动，通常是矩形或方形。然而，组件并不是固定的单位，因为它们是由不同的燃料棒、控制棒和仪器元件组成的复杂晶格，通过永久连接在棒上的间隔物来保持彼此之间的位置。
* 显然，组件的排列以及组件内棒的排列会影响反应堆内中子通量的分布（通过查看本程序结果部分中显示的解决方案，这一事实就会很明显）。例如，燃料棒在铀235或钚239的富集度方面彼此不同。另一方面，控制棒具有零裂变，但散射和吸收截面不为零。
* 这整个安排将使描述或空间依赖的材料参数变得非常复杂。它不会变得更简单，但我们将做一个近似：我们将每个圆柱杆和周围的水所居住的体积合并成二次截面的体积，在所谓的 "pin cell "中，用核数据库和中子光谱的知识获得同质化的材料数据。同质化使所有材料数据在具有新鲜燃料的反应堆的求解域上成为片状常数。然后为一个点所在的二次元组合查询空间相关的材料参数，然后为该组合中的二次元钳子查询。
* 在这个教程程序中，我们模拟了一个由[2.x.201]组件组成的反应堆的四分之一。我们使用对称性（诺伊曼）边界条件将问题减少到四分之一的领域，因此只模拟[2.x.202]组的装配。其中两个将是UO[2.x.203]燃料，另外两个是MOX燃料。这些组件中的每一个都由不同成分的[2.x.204]棒组成。因此，我们总共创造了一个[2.x.205]棒的网格。为了使以后的事情更简单，我们通过创建一个[2.x.206]单元的粗大网格来反映这一事实（尽管领域是方形的，我们通常会使用一个单元）。在deal.II中，每个单元都有一个[2.x.207]，可以用来将每个单元与识别该单元体积的材料的特定数字联系起来；我们将使用这个材料ID来识别在这个测试案例中使用的8种不同类型的棒材中的哪一种构成了一个特定的单元。请注意，在网格细化后，单元格的子代会继承材料ID，这样即使在网格细化后也能简单地跟踪材料。
* 在结果部分的图片中可以清楚地看到杆件的排列。材料和两个能量组的截面取自OECD/NEA的基准问题。详细的配置和材料数据在代码中给出。
*

*[1.x.91][1.x.92] 。


* 作为对程序具体工作的粗略概述，这里是基本的布局：从一个对每个能量组都相同的粗略网格开始，我们计算反特征值迭代来计算特定网格集上的[2.x.208]特征值。当特征值的变化低于一定的容忍度时，我们停止这些迭代，然后写出每个能量组的网格和解，供图形程序检查。由于解决方案的网格是不同的，我们必须为每个能量组生成一个单独的输出文件，而不是将所有能量组的解决方案加入同一个文件。
* 在这之后，我们对每个网格的误差指标进行评估，并对每个网格的单元进行独立的细化和粗化。由于特征值迭代是相当昂贵的，我们并不想在新的网格上重新开始；相反，我们使用SolutionTransferclass在网格细化时将前一个网格的解插到下一个网格。一个简单的实验会让你相信，这比我们省略这一步要便宜很多。这样做之后，我们在下一组网格上继续进行特征值迭代。
* 该程序由一个参数文件控制，使用ParameterHandler类。我们将在本教程的结果部分展示一个参数文件。目前，我们只需要说它控制了所使用的有限元的多项式程度，能量组的数量（尽管目前实现的都是2组问题的系数），停止反特征值迭代的容忍度，以及我们要做的细化循环的数量。
*

* [1.x.93] [1.x.94]。
* [1.x.95][1.x.96] [1.x.96]。



* 我们从一堆包含文件开始，这些文件在以前的教程程序中已经解释过了。一个新的是[2.x.209] ：这是第一个使用Timer类的例子程序。Timer同时记录了经过的挂钟时间（即安装在墙上的时钟所测量的时间）和CPU时钟时间（当前进程在CPU上使用的时间）。我们将在下面使用一个Timer来测量每个网格细化周期所需的CPU时间。
*


* [1.x.97]
*
* 我们使用下一个include文件来访问块向量，它为我们提供了一种方便的方式来管理所有能量组的解和右手向量。
*


* [1.x.98]
*
* 这个包含文件是用来将一个网格的解转移到另一个不同的网格。我们在每次网格迭代后初始化解法时使用它。
*


* [1.x.99]
*
* 当在一个网格上定义的函数与在另一个网格上定义的形状函数进行积分时，我们需要一个函数[2.x.210]（在介绍中讨论过），该函数定义在以下头文件中。
*


* [1.x.100]
*
* 我们使用boost中的一个小工具类来保存输出流的状态（见下面的[2.x.211]函数）。
*


* [1.x.101]
*
* 下面是另外两个C++标准头文件，我们用它来定义列表数据类型，以及微调我们生成的输出。
*


* [1.x.102]

* 最后一步和以前的所有程序一样。



* [1.x.103]
*
* [1.x.104] [1.x.105]。


*
* 首先，我们需要定义一个类，为主类提供材料数据（包括扩散系数、清除截面、散射截面、裂变截面和裂变光谱）。   
*构造函数的参数决定了我们为多少个能量组设置了相关的表格。目前，这个程序只包括2个能量组的数据，但更复杂的程序可能也能初始化更多能量组的数据结构，这取决于在参数文件中选择了多少个能量组。   
* 对于每个不同的系数类型，都有一个函数来返回该系数在特定能量组（或能量组的组合，如分布截面[2.x.212]或散射截面[2.x.213]）的值。除了能量组之外，这些系数还取决于燃料或控制棒的类型，正如介绍中所解释的那样。因此，这些函数需要一个额外的参数，[2.x.214] material_id，以确定特定种类的棒。在这个程序中，我们使用[2.x.215]不同种类的棒。   
* 除了散射截面，每个系数都可以表示为一个二维浮点数组中的条目，该数组由能量组编号以及材料ID索引。表类模板是存储此类数据的理想方式。最后，散射系数取决于两个能量组的索引，因此需要存储在一个三维数组中，为此我们再次使用表类，这时第一个模板参数（表示数组的维度）当然需要是三。
*


* [1.x.106]
*
* 该类的构造函数用于初始化所有的材料数据数组。它把能量组的数量作为一个参数（如果这个值不等于2，就会抛出一个错误，因为目前只实现了两个能量组的数据；但是，使用这个参数，这个函数仍然是灵活的，可以扩展到未来）。在开始的成员初始化部分，它也将数组的大小调整为正确的大小。   
* 目前，材料数据被存储为8种不同类型的材料。这一点在将来也可以很容易地被扩展。
*


* [1.x.107]
*
* 接下来是返回给定材料和能量组的系数值的函数。它们所做的就是确保给定的参数在允许的范围内，然后在相应的表格中查找各自的值。
*


* [1.x.108]
*
* 计算裂变分布截面的函数略有不同，因为它将其值计算为另外两个系数的乘积。我们不需要在这里检查参数，因为这在我们调用其他两个相关函数时已经发生了，尽管这可能也无妨。
*


* [1.x.109]
*
* [1.x.110] [1.x.111]。


*
* 第一个有趣的类是包含所有特定于单个能量组的东西。为了将那些属于单个对象的东西组合在一起，我们声明了一个结构，它包含了用于单个能量组的网格的Triangulation和DoFHandler对象，以及一些其他对象和成员函数，我们将在下面的章节中讨论。   
* 这个类的主要原因如下：对于正向问题（有指定的右手边）和特征值问题，人们通常解决一连串的问题，而不是完全耦合的问题。一旦意识到单一能量组的系统矩阵是对称和正定的（它只是一个扩散算子），而完全耦合问题的矩阵通常是非对称和非定值的，这就可以理解了。如果涉及几个以上的能量组，它也是非常大和相当完整的。   
* 让我们首先看看在外部右手边的情况下要解决的方程（对于时间无关的情况）。[1.x.112]
*
* 我们通常会通过将右手边的所有项与[2.x.216]移到左手边来解决这个方程，并求出[2.x.217] 。当然，我们还不知道[2.x.218]，因为这些变量的方程包括涉及[2.x.219]的右侧项。在这种情况下，通常的做法是进行迭代：计算[1.x.113] 。
*
*换句话说，我们逐一解决方程，如果[2.x.222]，则使用前一次迭代中[2.x.221]的值，如果[2.x.224]，则使用本次迭代中已经计算的[2.x.223]的值。   
* 在计算特征值时，我们做了一个非常类似的迭代，只是我们没有外部的右手边，而且每次迭代后的解都是按比例计算的，正如在介绍中所解释的。   
* 在任何一种情况下，如果我们所做的只是让下面这一类人具备这些能力，那么这两种情况就可以共同处理。(i) 形成左手边的矩阵，(ii) 形成组内右手边的贡献，即涉及到不相干的来源，以及(iii) 形成源于组[2.x.225]的对右手边的那份贡献。这个类正是做这些工作（以及一些簿记工作，如网格细化、设置矩阵和向量等）。另一方面，这个类本身不知道有多少个能量组，特别是它们如何相互作用，也就是说，决定外部迭代的方式（以及因此我们是解决一个特征值还是一个直接问题）是留给本程序下面的NeutronDiffusionProblem类的。   
* 所以让我们来看看这个类和它的接口。
*


* [1.x.114]
*
* [1.x.115] [1.x.116]
* 该类有相当数量的公共成员函数，因为其操作方式是由外部控制的，因此所有做重要事情的函数都需要从另一个类中调用。让我们从记账开始：该类显然需要知道它代表哪个能源组，使用哪种材料数据，以及从哪个粗略的网格开始。构造函数需要这些信息，并且用这些信息初始化相关的成员变量（见下文）。     
* 然后，我们还需要一些函数来设置线性系统，即正确地确定矩阵的大小和它的稀疏模式，等等，给定一个有限元对象来使用。[2.x.226]函数就是这样做的。最后，对于这个初始块，有两个函数可以返回这个对象中使用的活动单元和自由度的数量
*
* - 利用这一点，我们可以使三角化和DoF处理程序成员变量私有化，不必授予外部使用它，增强了封装性。
*


* [1.x.117]
*
* 然后有一些函数为每个迭代和目前的能量组组装线性系统。请注意，该矩阵与迭代次数无关，因此在每个细化周期只需计算一次。对于必须在每次逆功率迭代中更新的右手边来说，情况就有点复杂了，而且由于计算它可能涉及到几个不同的网格，正如介绍中所解释的那样，这就更复杂了。为了使事情在解决正向或特征值问题方面更加灵活，我们将右手边的计算分成一个函数，将无关的源和组内贡献（我们将其称为零函数，作为特征值问题的源项）和一个计算来自另一个能量组的右手边的贡献。
*


* [1.x.118]
*
* 接下来我们需要一组函数来实际计算线性系统的解，并对其进行处理（比如计算介绍中提到的裂变源贡献，将图形信息写入输出文件，计算误差指标，或者根据这些标准和阈值实际细化和粗化网格）。所有这些函数以后都可以从驱动类[2.x.227]中调用，或者你想实现的任何其他类来解决涉及中子通量方程的问题。
*


* [1.x.119]
*
* [1.x.120] [1.x.121].
* 作为面向对象编程的良好实践，我们通过将大多数数据成员变成私有的来隐藏它们。然而，我们必须授予驱动进程的类对解向量以及上一次迭代的解的访问权，因为在幂迭代中，解向量在每次迭代中都被我们正在寻找的特征值的当前猜测所缩放。
*


* [1.x.122]
*
* [1.x.123] [1.x.124]。
* 其余的数据成员是私有的。与之前所有的教程程序相比，唯一的新数据成员是一个存储该对象所代表的能量组的整数，以及该对象的构造函数从驱动类得到的材料数据对象的引用。同样，构造函数也得到了一个对我们要使用的有限元对象的引用。     
* 最后，我们必须在每次迭代中对线性系统应用边界值，即相当频繁。我们不是每次都插值，而是在每个新网格上插值一次，然后和这个类的所有其他数据一起存储。
*


* [1.x.125]
*
* [1.x.126] [1.x.127]。
* 这个类中有一个私有成员函数。它递归地走过两个网格的单元，以计算跨组的右手边项。这方面的算法在本程序的介绍中有所解释。这个函数的参数是对一个对象的引用，该对象代表了我们想要整合的右手项的能量组，一个指向用于当前能量组的网格单元的迭代器，一个指向另一个网格上相应单元的迭代器，以及将自由度从两个单元中较粗的单元插补到较细的单元的矩阵。
*


* [1.x.128]
*
* [1.x.129] [1.x.130]。


*
* 这个类的前几个函数大多是不言自明的。构造函数只设置了几个数据成员，并创建了一个给定三角图的副本，作为这个能量组所用的三角图的基础。接下来的两个函数只是从私有数据成员中返回数据，从而使我们能够使这些数据成员私有化。
*


* [1.x.131]
*
* [1.x.132] [1.x.133]
* 第一个 "实 "函数是在新的网格上或在网格细化后设置网格、矩阵等的函数。我们用这个函数来初始化稀疏系统矩阵，以及右手边的向量。如果求解向量之前从未被设置过（如用零大小表示），我们也会初始化它并将其设置为默认值。如果它已经有一个非零的大小（即这个函数是在网格细化之后调用的），我们就不这么做了，因为在这种情况下，我们希望在网格细化中保留解决方案（这一点我们在[2.x.228]函数中做过）。
*


* [1.x.134]
*
* 在这个函数的最后，我们更新边界节点的列表和它们的数值，首先清除这个列表和重新插值的边界数值（记住，这个函数是在第一次设置网格后调用的，每次在网格细化后调用）。     
* 为了理解这段代码，有必要认识到我们使用[2.x.229]函数来创建网格（在[2.x.230]），其中我们将最后一个参数设置为[2.x.231] 。这意味着域的边界是 "彩色 "的，也就是说，域的四个（或六个，在3D中）边被赋予不同的边界指标。结果是，底部边界得到指标0，顶部的一个边界得到指标1，而左右边界分别得到指标2和3。     
* 在这个程序中，我们只模拟一个，即右上角的反应器的四分之一。也就是说，我们只想在顶部和右侧边界插值边界条件，而在底部和左侧边界不做任何事情（即施加自然的、无流量的诺伊曼边界条件）。这很容易被推广到任意维度，即我们想在指标为1、3、......的边界上插值，我们在下面的循环中这样做（注意，对[2.x.232]的调用是加法的，即它们不会首先清除边界值图）。
*


* [1.x.135]
*
* [1.x.136] [1.x.137].
* 接下来我们需要函数来组装系统矩阵和右手边。考虑到介绍中列出的方程以及我们在以前的例子程序中看到的内容，组装矩阵是很简单的。注意使用[2.x.233]来获取一个单元的材料种类。还要注意我们如何设置正交公式的顺序，以便它总是适合使用的有限元。   
* 最后，请注意，由于我们在这里只组装了系统矩阵，所以我们还不能消除边界值（我们需要右边的向量来实现）。我们将此推迟到[2.x.234]函数中，此时所有的信息都可以得到。
*


* [1.x.138]
*
* [1.x.139] [1.x.140]。
* 正如[2.x.235]类的文档中所解释的，我们把组装右手边分成两部分：组内耦合和跨组耦合。首先，我们需要一个函数来组装这里的一个特定组的右手边，即包括一个无关的源（我们将在特征值问题上设置为零）以及组内裂变贡献。  组内散射已经在清除截面的定义中得到了考虑）。该函数的工作原理就组装右手边而言是非常标准的，因此不需要更多的评论，只是我们要提到在函数的开始部分将右手边的向量设置为零
*
* 这一点我们不打算为跨组项做，因为它们只是简单地加到右手边的向量上。
*


* [1.x.141]
*
* [1.x.142] [1.x.143]。
* 对于组装单一能量组方程的右手向量来说，更有趣的函数是将能量组[2.x.236]和[2.x.237]耦合起来。正如介绍中所解释的，我们首先要找到两个能量组的网格所共有的单元格集合。首先我们调用[2.x.238]来获得这一对来自两个网格的共同单元的列表。一对单元格中的两个单元格可能都不活跃，但至少有一个是活跃的。然后，我们将这些单元格对中的每一个交给一个函数，以递归地计算右手边的项。   
* 注意，组内耦合在之前已经处理过了，所以如果[2.x.239]，我们提前退出函数。
*


* [1.x.144]
*
* [1.x.145][1.x.146] 。
* 这是最后一个处理在潜在的不同网格上递归地组装右手边项的函数，使用介绍中描述的算法。该函数需要一个对代表能量组[2.x.240]的对象的引用，以及对能量组[2.x.241]和[2.x.242]的网格中相应单元的迭代器。起初，即从上面的函数中调用这个函数时，这两个单元将是两个网格上的匹配单元；然而，这两个单元中的一个可能被进一步细化，我们将递归地调用这个函数，两个迭代器中的一个被原始单元的一个子单元所替代。   
* 最后一个参数是介绍中的矩阵乘积矩阵[2.x.243]，它从两个单元中较粗的单元插值到较细的单元。如果这两个单元格匹配，那么这就是身份矩阵。
*
* - 正是我们最初传递给这个函数的东西。   
* 该函数必须考虑两种情况：两个单元格都没有进一步细化，即没有子代，在这种情况下，我们可以最终组装这对单元格的右侧贡献；两个单元格中的一个被进一步细化，在这种情况下，我们必须通过循环未激活的单元格的子代来继续递归。下面将讨论这两种情况。
*


* [1.x.147]

* 第一种情况是，两个单元都没有进一步细化。在这种情况下，我们可以组装相关条款（见介绍）。这涉及到在两个单元中较细的单元上组装质量矩阵（事实上，有两个具有不同系数的质量矩阵，一个用于裂变分布截面[2.x.244]，一个用于散射截面[2.x.245]）。这是直截了当的，但请注意我们如何通过查看两个单元的细化水平来确定哪个是更细的单元。
*


* [1.x.148]
*
* 现在我们有了所有的插值（延长）矩阵以及局部质量矩阵，所以我们只需要根据两个单元中哪一个更细，形成乘积 [1.x.149] 或 [1.x.150] 。我们使用 [2.x.246] 函数提供的矩阵-向量乘积，或者使用 [2.x.247] 与转置矩阵进行乘积。这样做之后，我们将结果转移到能量组的全局右侧向量中 [2.x.248] 。
*


* [1.x.151]
*
* 另一种情况是，两个单元中的一个被进一步细化。在这种情况下，我们必须在所有的子单元上循环，将现有的矩阵的插值（延长）乘以从现在的单元到其子单元的插值（使用矩阵-矩阵乘法函数[2.x.249]），然后将结果再次交给这个非常相同的函数，但有子单元被其子单元之一取代。
*


* [1.x.152]
*
* [1.x.153] [1.x.154]。
* 在（反）功率迭代中，我们使用综合裂变源来更新[2.x.250] -特征值。鉴于其定义，以下函数基本上是不言自明的。
*


* [1.x.155]
*
* [1.x.156] [1.x.157].
* 接下来是一个解决之前组装的线性系统的函数。事情基本是标准的，只是我们把应用边界值的时间推迟到了这里，因为在之前的所有函数中，我们还是在为右边的向量做加法。
*


* [1.x.158]
*
* [1.x.159] [1.x.160].
* 网格细化被分成两个函数。第一个函数估计每个单元的误差，通过解的大小将其归一化，并将其返回到作为参数的矢量中。调用函数收集所有能量组的所有误差指标，并计算出细化和粗化单元的阈值。
*


* [1.x.161]
*
* [1.x.162] [1.x.163]。
* 第二部分是给定前一个函数中计算的误差指标和误差阈值来细化网格，超过这个阈值的单元应被细化，低于这个阈值的单元应被粗化。注意，我们在这里没有使用[2.x.251]中的任何函数，而是自己设置细化标志。   
* 在设置完这些标志后，我们使用SolutionTransfer类将求解向量从旧网格转移到新网格。这里使用的程序在该类的文档中已有详细描述。
*


* [1.x.164]
*
* 强制执行约束条件，使插值后的解在新的网格上符合要求。
*


* [1.x.165]
*
* [1.x.166] [1.x.167].
* 本类的最后一个函数在每次网格迭代后输出网格和解。这在以前已经显示过很多次了。唯一值得指出的是使用[2.x.252]函数将一个整数转换成其字符串表示。该函数的第二个参数表示我们应使用多少个数字
*
* - 如果这个值大于1，那么这个数字将被填充前导零。
*


* [1.x.168]

* [1.x.169] [1.x.170]。


*
* 这是程序的主类，并不是因为它实现了所有的功能（事实上，大部分的功能都在[2.x.253]类中实现了），而是因为它包含了决定什么时候计算的驱动算法。它主要是像其他许多教程程序中显示的那样，它有一个公共的[2.x.254]函数和私有函数来做其他的事情。在一些地方，我们必须为所有能源组做一些事情，在这种情况下，如果deal.II被配置为多线程，我们将为每个组启动任务，让这些事情并行运行。  关于并行化的策略，请看一下[2.x.255]模块。   
* 与以前的例子程序最大的不同是，我们还声明了一个嵌套类，该类有成员变量，用于所有可在输入文件中传递给程序的运行时参数。现在，这些参数是能量组的数量、细化周期的数量、要使用的有限元的多项式程度，以及用于确定反幂迭代何时收敛的公差。此外，我们有一个该类的构造函数，将所有这些值设置为默认值，还有一个函数[2.x.256]向ParameterHandler类描述输入文件中接受哪些参数，还有一个函数[2.x.257]可以从ParameterHandler对象中提取这些参数的值。另一个使用ParameterHandler的例子见[2.x.258]。
*


* [1.x.171]
*
* [1.x.172] [1.x.173]。



* 这个类中没有那么多的成员函数，因为大部分的功能已经被移到了[2.x.259]类中，只是从这个类的[2.x.260]成员函数中调用。保留下来的成员函数有不言自明的名字。
*


* [1.x.174]
*
* [1.x.175] [1.x.176]。


*
* 接下来，我们有几个成员变量。特别是，这些是（i）对参数对象的引用（由本程序的主函数拥有，并传递给本类的构造函数），（ii）描述输入文件中要求的能量组数量的材料参数的对象，以及（iii）所有能量组要使用的有限元。
*


* [1.x.177]
*
* 此外，我们还有(iv)目前迭代时计算出的特征值的值。事实上，这也是所有能量组之间唯一共享的解的部分
*
* - 解决方案的所有其他部分，如中子通量都是特定于一个或另一个能量组的，因此被存储在描述单一能量组的对象中。
*


* [1.x.178]
*
* 最后一个计算对象（v）是一个指向能量组对象的指针数组。当然，这个数组的长度等于参数文件中指定的能量组的数量。
*


* [1.x.179]
*
* 最后（vi）我们有一个文件流，我们将把总结的输出保存到这个文件中。
*


* [1.x.180]
*
* [1.x.181] [1.x.182]。


*
* 在继续实现外层类之前，我们必须先实现参数结构的功能。这是非常直接的，事实上，对于所有使用ParameterHandler功能的这类参数类来说，看起来都是一样的。因此，我们将不再对此进行评论。
*


* [1.x.183]
*
* [1.x.184] [1.x.185]。


*
* 现在是[2.x.261]类。构造函数和析构函数没有什么值得注意的地方。
*


* [1.x.186]
*
* [1.x.187] [1.x.188]。
* 第一个感兴趣的函数是设置反应堆核心的几何形状的函数。这在介绍中会有更详细的描述。   
* 该函数的第一部分定义了几何数据，然后创建了一个粗略的网格，其单元数与我们模拟的那部分反应堆堆芯中的燃料棒（或针状单元）的数量相同。正如上面插值边界值时提到的，[2.x.262]函数的最后一个参数指定域的两侧应具有唯一的边界指标，这将使我们以后能够以简单的方式确定哪些边界具有诺伊曼条件，哪些具有迪里希特条件附加在上面。
*


* [1.x.189]
*
* 该函数的第二部分涉及到每种类型组件的销钉单元的材料数量。在这里，我们定义了四种不同类型的组件，对于这些组件，我们在以下表格中描述了燃料棒的安排。     
* 这里描述的装配体取自介绍中提到的基准，它们是（按顺序）。  [2.x.263] [2.x.264] 'UX'组件。二氧化铀燃料组件，带有24个导向管和一个中央可移动裂变室 [2.x.265] 'UA' 组件。带有24个AIC的二氧化铀燃料组件和一个中央可移动裂变室 [2.x.266] 'PX'组件。MOX燃料组件，带有24个导气管和一个中央可移动裂变室 [2.x.267] 'R'组件：一个反射器。   [2.x.268]
* 请注意，这里列出的数字和从基准描述中提取的数字，以良好的老Fortran方式，是基于一的。我们以后在给各个单元分配材料时将从每个数字中减去1，以便将事情转换为C语言风格的基于零的索引。
*


* [1.x.190]
*
* 在描述了组成装配体的材料之后，我们必须指定装配体在核心中的排列方式。我们使用一个对称的模式，实际上只使用 "UX "和 "PX "组件。
*


* [1.x.191]

* 我们现在可以为每个单元实际设置材料ID。为此，我们对所有单元进行循环，查看单元中心的位置，并确定这将在哪个组件和燃料棒中。我们增加了一些检查，以确保我们计算的位置在我们必须查找材料的数组的范围内）。在循环结束时，我们相应地设置材料标识符。
*


* [1.x.192]
*
* 在粗略网格被初始化后，我们创建适当数量的能量组对象，并让它们用上面生成的粗略网格初始化各自的网格。
*


* [1.x.193]
*
* [1.x.194] [1.x.195]。
* 在特征值计算中，我们需要在每次功率迭代后计算裂变中子源总量。然后用总功率来更新K效。   
* 因为总裂变源是所有能量组的总和，而且每个总和都可以独立计算，所以我们实际上是并行进行的。其中一个问题是，[2.x.269]类中计算裂变源的函数会返回一个值。我们想在循环本身中把这些值加在一起：理想的情况是，每个任务计算它的值，然后立即把它加到总数中。以这种方式同时加值需要两个功能。  [2.x.270] [2.x.271] 我们需要一种存储数值的方式，使多个线程能够以防止数据竞赛的方式并发地读入和写入（即线程安全的读写）。[2.x.272] [2.x.273] 我们需要一种方法来增加这样一个值，而且是线程安全的。[2.x.274] [2.x.275]
* 第一个特性可以通过模板类实现 [2.x.276] 。然而，由[2.x.277]实现的第二个特性只在C++20及以后的版本中可用：由于deal.II支持旧版本的C++语言标准，我们还不能使用这一特性。因此，取而代之的是，我们简单地将每个组的值写成一个向量的条目，并在函数的最后将这些值相加。
*


* [1.x.196]
*
* [1.x.197] [1.x.198]。
* 下一个函数让各个能量组对象细化其网格。这其中的大部分，也是可以独立并行完成的任务：首先，让所有的能量组对象并行计算它们的误差指标，然后计算所有能量组的最大误差指标，并确定细化和粗化单元的阈值，然后要求所有的能量组相应地细化它们的网格，也是并行的。
*


* [1.x.199]
*
* [2.x.278]的析构器加入了所有线程，所以我们知道在我们退出范围时，计算已经完成。
*


*


* [1.x.200]
*
* [1.x.201] [1.x.202].
* 最后，这就是肉的函数：在一连串的网格上迭代，并对每一个网格进行幂级迭代来计算特征值。   
* 鉴于介绍中对算法的描述，实际上没有什么可评论的。
*


* [1.x.203]
*
* 我们希望只为这个函数改变输出精度，并在这个函数返回时恢复[2.x.279]的状态。因此，我们需要一种方法来撤销输出格式的改变。Boost提供了一种方便的方法来保存输出流的状态，并在当前块结束时（当调用[2.x.280]的析构器时）用[2.x.281]类来恢复它，我们在这里使用这个方法。
*


* [1.x.204]
*
* 我们通过k_eff的变化来计算下面的误差（即k_eff_old的差异。
*


* [1.x.205]
*
* 我们将在下面测量每个周期所花费的CPU时间。计时器的构造函数调用了[2.x.282]，所以一旦我们创建了一个计时器，就可以查询它的信息。由于这个循环的许多部分是用任务并行化的，所以我们测量的CPU时间（如果我们用一个以上的线程运行）将大于墙的时间。
*


* [1.x.206]
*
* 打印出关于模拟的信息以及耗费的CPU时间。我们可以不先调用[2.x.283]来获得调用该函数时的已用CPU时间。
*


* [1.x.207]
*
* [1.x.208] [1.x.209]。



* 程序中的最后一件事是[2.x.285]函数。其结构与其他大多数教程程序一样，唯一的例外是我们在这里处理一个参数文件。  为此，我们首先看一下传递给这个函数的命令行参数：如果在命令行上没有指定输入文件，那么就使用 "project.prm"，否则就取命令行上作为第一个参数给出的文件名。
*

*
* 有了这个，我们创建一个ParameterHandler对象，让[2.x.286]类声明它想在输入文件中看到的所有参数（或者，采取默认值，如果参数文件中没有列出任何参数），然后读取输入文件，要求参数对象提取数值，最后把所有东西交给[2.x.287]类型的对象，以便计算特征值。
*


* [1.x.210]
*[1.x.211][1.x.212]


* 我们可以用以下输入文件来运行程序。
* [1.x.213]
* 该程序的输出包括控制台输出，一个名为 "convergence_table "的文件记录了网格迭代的主要结果，以及vtu格式的图形输出。
* 控制台的输出看起来像这样。
* [1.x.214]
*
* 我们看到在第0周期后，动力迭代确实收敛得比较快，这是因为用上一次网格迭代的解进行了初始化。`convergence_table'的内容是。
* [1.x.215]
* 列的含义是：网格迭代次数，快速能量组的自由度数，热能组的自由度数，收敛效果和快速通量的最大值与热能组的最大值之比。
* 网格迭代#9时，快速和热能组的网格看起来如下。
* [2.x.288] &nbsp; [2.x.289] 。
* 我们看到热能组的网格要比快速组的网格细得多。在这些网格上的解是，（注意：通量被归一化，总裂变源等于1）。
* [2.x.290] &nbsp; [2.x.291] 。
* 然后我们绘制多项式阶数等于1、2和3的收敛数据。
* [2.x.292]
* 估计的 "精确 "k-effective=0.906834721253，这只是从多项式阶数为3减去2e-10的lastmesh迭代得出的。我们看到，h-adaptive计算提供了一个代数收敛。多项式阶数越高，网格迭代收敛的速度越快。在我们的问题中，我们需要较少的DoFs数量来实现较高的多项式阶数下的相同精度。
*

* [1.x.216][1.x.217] [2.x.293] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-29_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22]
* [2.x.2]
* [1.x.23]
* [1.x.24] 为了运行这个程序，deal.II必须被配置为使用UMFPACK稀疏直接求解器。请参考[1.x.25]中的说明如何做到这一点。
*

*[1.x.26][1.x.27][1.x.28]



* 一个经常出现的问题是如何用交易解决涉及复值函数的问题。对于许多问题，与其直接使用复值有限元，不如将复值函数分成实部和虚部，并使用单独的标量有限元场来离散其中的每一个。基本上，这相当于把一个单一的复值方程看成是两个实值方程的系统。这个简短的例子演示了如何在deal.II中通过使用[2.x.3]对象来堆叠两个代表实部和虚部的有限元场来实现。(相反的方法，保持所有的复值，在另一个教程程序中演示：见[2.x.4]。)当分成实部和虚部时，这里涉及的方程属于矢量值问题的范畴。关于这一主题的顶层概述可以在[2.x.5]模块中找到。
* 除了这个讨论之外，我们还讨论了ParameterHandler类，它提供了一种方便的方法，可以在运行时从配置文件中读取参数，而不需要重新编译程序代码。
*

*[1.x.29][1.x.30]


* 本程序的最初目的是模拟由一个具有可变几何形状的换能器透镜产生的超声波的聚焦特性。最近在医学成像方面的应用不仅使用超声波进行成像，而且还激发材料中的某些局部效应，如光学特性的变化，然后可以用其他成像技术进行测量。这些方法的一个重要因素是能够将超声波的强度集中在材料的一个特定部分，最好是一个点，以便能够检查材料在该特定位置的特性。
* 为了得出这个问题的模型，我们认为超声波是由波浪方程支配的压力波：[1.x.31]其中[2.x.6]是波速（为简单起见，我们假设它是常数），[2.x.7] 。边界[2.x.8]分为两部分[2.x.9]和[2.x.10]，其中[2.x.11]代表换能器透镜，[2.x.12]是吸收边界（也就是说，我们要在[2.x.13]上选择边界条件，使其模仿大域的方式）。在[2.x.14]上，换能器产生一个恒定频率[2.x.15]和恒定振幅（我们在这里选择为1）的波：[1.x.32] 。
* 如果没有其他（内部或边界）源，并且由于唯一的源具有频率[2.x.16]，那么该解决方案允许一个形式为[2.x.17]的变量分离。复值函数[2.x.18]描述了频率外波的振幅和相位（相对于源）的空间依赖性[2.x.19]，其中振幅是我们感兴趣的量。通过将这种形式的解决方案插入波浪方程，我们看到，对于[2.x.20]，我们有[1.x.33]
*
* 为了在[2.x.21]上找到合适的条件来模拟一个吸收边界，考虑一个频率为[2.x.23]的波在[2.x.24]方向上行驶。为了使[2.x.25]能够解决波浪方程，[2.x.26]必须成立。假设这个波在[2.x.27]中以直角撞击边界，即[2.x.28]，[2.x.29]表示[2.x.30]在[2.x.31]的外单位法线。然后在[2.x.32]，这个波满足方程[1.x.34]。因此，通过强制执行边界条件[1.x.35]，以直角撞击边界[2.x.33]的波将被完全吸收。另一方面，那些没有以直角撞击边界的波场部分并不满足这个条件，将其作为边界条件来执行将产生部分反射，也就是说，只有部分波会通过边界，就像它不在这里一样，而剩下的那部分波将被反射回域中。
* 如果我们愿意接受这一点作为吸收边界的充分近似，我们最终得出以下问题[2.x.34]：[1.x.36] 。
* 这是一个亥姆霍兹方程（类似于[2.x.35]中的方程，但这次有''坏符号''），[2.x.36]上有迪里希特数据，[2.x.37]上有混合边界条件。由于[2.x.38]上的条件，我们不能只是单独处理[2.x.39]的实部和虚部方程。然而，我们可以把[2.x.40]的PDE看作是[2.x.41]的实部和虚部的两个PDE系统，[2.x.42]的边界条件代表系统中两个部分之间的耦合项。这是按以下思路进行的。让[2.x.43]，然后在[2.x.44]和[2.x.45]方面，我们有以下系统：[1.x.37]
*
* 对于测试函数[2.x.46]与[2.x.47]，经过通常的乘法，在[2.x.48]上的积分和应用分项积分，我们得到弱表述[1.x.38] 。
*
* 我们选择有限元空间[2.x.49]和[2.x.50]，基数为[2.x.51]，并寻找近似解[1.x.39]插入变分形式，得到方程组[1.x.40]，用矩阵符号表示：[1.x.41](不要被这里的右手边为零所迷惑，那是因为我们还没有包括Dirichlet边界数据。)由于非对角线块的交替符号，我们已经可以看到这个系统是非对称的，事实上它甚至是不确定的。当然，没有必要选择空间[2.x.52]和[2.x.53]是相同的。然而，我们希望解的实部和虚部具有类似的性质，因此在实施过程中确实会采取[2.x.54]，并且对这两个空间使用相同的基函数[2.x.55]。之所以使用不同的符号，只是为了让我们区分[2.x.56]和[2.x.57]的形状函数，因为这种区分在实施中起着重要作用。
*

*[1.x.42][1.x.43] 。


* 在计算中，我们将考虑波在单位方阵中的传播，超声由换能器透镜产生，透镜的形状像圆的一个部分，中心在[2.x.58]，半径略大于[2.x.59]；这种形状应该导致声波在圆中心的聚焦。改变[2.x.60]会改变透镜的 "焦点"，影响[2.x.61]强度的空间分布，我们主要关心的是[2.x.62]的聚焦程度。
* 在下面的程序中，我们将使用实部和虚部分离的公式来实现复值亥姆霍兹方程。我们还将讨论如何生成一个看起来像正方形的域，并带有模拟换能器的轻微隆起（在[2.x.63]函数中），以及如何生成图形输出，不仅包含解分量[2.x.64]和[2.x.65]，还包括直接在输出文件中的量级[2.x.66]（在[2.x.67]中）。最后，我们使用ParameterHandler类来轻松读取参数，如焦距[2.x.68]、波速[2.x.69]、频率[2.x.70]，以及在运行时从输入文件中读取其他一些参数，而不是在源代码中固定这些参数，每次我们想改变参数时，都必须重新编译。
*

* [1.x.44] [1.x.45]。
* [1.x.46] [1.x.47]。
*

*
* 以下头文件之前都已经讨论过了。
*


*


* [1.x.48]
*
* 这个头文件包含ParameterHandler类的必要声明，我们将用它来从配置文件中读取我们的参数。
*


* [1.x.49]
*
* 对于线性系统的求解，我们将使用UMFPACK提供的稀疏LU分解（参见SparseDirectUMFPACK类），为此需要以下头文件。  请注意，为了编译这个教程程序，deal.II-library需要建立UMFPACK支持，这个支持在默认情况下是启用的。
*


* [1.x.50]
*
* FESystem类允许我们将几个FE-对象堆叠成一个复合的、矢量值的有限元场。该类的必要声明在这个头文件中提供。
*


* [1.x.51]
*
* 最后，包括声明Timer类的头文件，我们将用它来确定我们程序的每个操作需要多少时间。
*


* [1.x.52]
*
* 作为这个程序开始的最后一步，我们把这个程序中的所有东西都放到它的命名空间中，在它的命名空间中，让所有在deal.II命名空间中的东西都是全局可用的，不需要在所有东西前加上[2.x.71]。
*


* [1.x.53]
*
* [1.x.54] [1.x.55]。


*
* 首先我们为代表Dirichlet边界值的函数定义一个类。这在以前已经做过很多次了，因此不需要过多解释。   
* 因为有两个值[2.x.72]和[2.x.73]需要在边界规定，我们必须告诉基类，这是一个有两个分量的向量值函数，[2.x.74]函数和它的表弟[2.x.75]必须返回有两个条目的向量。在我们的例子中，这个函数非常简单，它只是对实部[2.x.76]返回1，对虚部[2.x.77]返回0，而不管它在哪个点被评估。
*


* [1.x.56]
*
* [1.x.57] [1.x.58]。


*
* 下一个类负责准备ParameterHandler对象并从输入文件中读取参数。  它包括一个声明所有必要参数的函数[2.x.78]和一个从外部调用的[2.x.79]函数，以启动参数读取过程。
*


* [1.x.59]
*
* 构造函数存储了一个传递给它的ParameterHandler对象的引用。
*


* [1.x.60]
*
* [1.x.61] [1.x.62]。


*
* [2.x.80]函数声明了我们的ParameterHandler对象能够从输入文件中读取的所有参数，以及它们的类型、范围条件和它们出现在哪个小节。我们将用一对大括号包住所有进入一个部分的条目，以迫使编辑器将它们缩进一级，从而使阅读哪些条目共同构成一个部分变得更简单。
*


* [1.x.63]
*
* 网格和几何的参数包括应用于初始粗网格的全局细化步数和换能器镜头的焦距[2.x.81]。对于细化步数，我们允许在[2.x.82]范围内取整数，其中[2.x.83]对象的第二个参数被省略，表示半开区间。  对于焦距，任何大于零的数字都可以接受。
*


* [1.x.64]
*
* 下一小节专门讨论方程中出现的物理参数，即频率 [2.x.84] 和波速 [2.x.85] 。同样，两者都需要位于半开区间[2.x.86]内，通过调用[2.x.87]类，仅以左端点为参数来表示。
*


* [1.x.65]
*
* 最后但并非最不重要的是，我们希望能够通过配置文件中的条目来改变输出的一些属性，如文件名和格式，这就是最后一小节的目的。
*


* [1.x.66]
*
* 因为不同的输出格式可能需要不同的参数来生成输出（例如，postscript输出需要视角角度、线宽、颜色等），如果我们必须为库中支持的每一种可能的输出格式手工声明所有这些参数，那将是非常麻烦的。相反，每种输出格式都有一个[2.x.88]函数，它在自己的小节中声明了该格式的所有特定参数。下面调用[2.x.89]为所有可用的输出格式执行[2.x.90]，这样就为每种格式创建了一个自己的小节，并为该特定输出格式声明了参数。(上面[2.x.91]的调用中，模板参数的实际值在这里并不重要：该函数做了同样的工作，与维度无关，但碰巧是在一个依赖模板参数的类中。)  要想知道哪种输出格式有哪些参数，你可以查阅DataOutBase类的文档，或者干脆在没有参数文件的情况下运行这个程序。然后，它将创建一个文件，将所有声明的参数设置为默认值，这可以方便地作为一个起点，将参数设置为你想要的值。
*


* [1.x.67]
*
* [1.x.68] [1.x.69]。


*
* 这是在ParameterReader类中的主函数。  它从外部被调用，首先声明所有的参数，然后从输入文件中读取参数，文件名由调用者提供。在对这个函数的调用完成后，可以使用[2.x.92]对象来检索从文件中读入的参数值。
*


* [1.x.70]
*
* [1.x.71] [1.x.72]。


*
* 正如介绍中提到的，我们真正追求的数量是超声波强度的空间分布，它对应于 [2.x.93] 。现在我们可以只满足于在输出中拥有[2.x.94]和[2.x.95]，并使用合适的可视化或后处理工具从我们计算的解决方案中得出[2.x.96]。然而，也有一种方法可以输出从deal.II的解决方案中得出的数据，我们在这里要利用这个机制。
*

*
* 到目前为止，我们一直使用[2.x.97]函数将包含输出数据的向量添加到一个DataOut对象中。  这个函数有一个特殊的版本，除了数据向量之外，还有一个额外的参数类型为DataPostprocessor。当这个函数用于输出时，在每个要生成输出数据的点上，指定的DataPostprocessor对象的[2.x.98]或[2.x.99]函数被调用，从数据向量代表的有限元函数的值、梯度和二阶导数计算输出量（在面相关数据的情况下，法向量也可用）。因此，这使我们可以输出任何可以从解的值及其导数中局部得出的数量。  当然，超声强度[2.x.100]就是这样一个量，其计算甚至不涉及[2.x.101]或[2.x.102]的任何导数。
*

*
* 在实践中，DataPostprocessor类只提供了一个接口，我们需要从它派生出我们自己的类，以便实现接口所指定的功能。在最一般的情况下，我们必须实现几个成员函数，但如果输出量是一个单一的标量，那么其中一些模板代码可以由一个更专业的类，即DataPostprocessorScalar来处理，我们可以从该类中派生出来。这就是[2.x.103]类的作用。
*


* [1.x.73]
*
* 在构造函数中，我们需要用两个参数调用基类的构造函数。第一个参数表示这个类计算的单一标量在输出文件中应该用什么名字来表示。在我们的例子中，后处理程序有[2.x.104]作为输出，所以我们使用 "Intensity"。   
* 第二个参数是一组标志，表明后处理程序需要哪些数据来计算输出量。  这可以是update_values、update_gradients和update_hessians（如果是脸部数据，也可以是update_normal_vector）的任何一个子集，这些都在UpdateFlags中记录。  当然，导数的计算需要额外的资源，所以这里只应该给出真正需要的数据的标志，就像我们使用FEValues对象时一样。在我们的例子中，只有[2.x.105]和[2.x.106]的函数值需要用来计算[2.x.107]，所以我们用update_values标志就可以了。
*


* [1.x.74]
*
* 实际的后处理发生在下面这个函数中。它的输入是一个存储函数值的对象（这里是向量值），代表给[2.x.108]的数据向量在我们产生输出的所有评估点的评估值，以及一些代表导数的张量对象（这里我们不使用，因为[2.x.109]只是从[2.x.110]和[2.x.111]计算出来的）。派生量在[2.x.112]向量中返回。请记住，这个函数只能使用由 [2.x.113] 指定的各自更新标志的数据。例如，我们可能不会在这里使用导数，因为我们对 [2.x.114] 的实现要求只提供函数值。
*


* [1.x.75]

* 计算本身是很简单的。我们遍历输出向量中的每个条目，并从[2.x.116]和[2.x.117]的相应值中计算出[2.x.115] 。我们通过创建一个复数[2.x.118]，然后对结果调用[2.x.119]来实现。(我们可能会想调用[2.x.120]，但是在一个历史的怪圈中，C++委员会决定[2.x.121]应该返回绝对值的[1.x.76]。
*
* - 因此不符合数学家对称为 "规范 "的东西的属性要求）。)
*


* [1.x.77]
*
* [1.x.78] [1.x.79]。


*
* 最后这里是这个程序的主类。  它的成员函数与之前的例子非常相似，特别是[2.x.122]，成员变量的列表也没有任何重大的惊喜。传递给构造函数的ParameterHandler对象被存储为一个引用，以便于从该类的所有函数中访问参数。  由于我们正在使用矢量值的有限元，我们使用的FE对象是FESystem类型的。
*


* [1.x.80]
*
* 构造函数接收ParameterHandler对象并将其存储在一个引用中。它还初始化了DoF-Handler和有限元系统，该系统由两份标量Q1场组成，一份用于[2.x.123]，一份用于[2.x.124] 。
*


* [1.x.81]
*
* [1.x.82] [1.x.83]。


*
* 这里我们为我们的领域设置网格。  正如论述中所提到的，这个几何体只是一个单位正方形（2D），其边界部分代表换能器透镜，由一个圆的扇形代替。
*


* [1.x.84]
*
* 首先我们产生一些日志输出，并启动一个计时器，这样我们就可以计算出这个函数完成后的执行时间。
*


* [1.x.85]
*
* 然后我们从ParameterHandler对象中查询换能器镜头的焦距和网格细化步数的值。
*


* [1.x.86]
*
* 接下来，为换能器镜头的位置和焦点定义了两个点，即圆的中心，其线段将形成边界的换能器部分。注意，这是程序中唯一一个在二维和三维中略有不同的地方。尽管本教程只涉及二维情况，但要使这个程序在三维中发挥作用，必要的补充是非常少的，因此我们选择包括它们。
*


* [1.x.87]
*
* 作为初始粗网格，我们采用一个简单的单位方格，每个方向上有5个细分。分区的数量是这样选择的：我们想指定为换能器边界的线段[2.x.125]是由一个面来跨越的。然后，我们通过所有的单元格来找到换能器所在的面，事实上，这只是X轴上从0.4到0.6的一条边。这是我们希望根据圆环形边界进行细化的地方，所以我们用不同的流形指标来标记这个边缘。由于我们将在换能器上设置迪里希特边界条件，我们也要改变其边界指标。
*


* [1.x.88]
*
* 对于换能器镜头的圆形部分，使用了一个SphericalManifold对象（当然，在2D中只是代表一个圆），中心的计算方法如上。
*


* [1.x.89]
*
* 现在，全局细化被执行。换能器位置附近的单元格将根据换能器透镜的圆弧形边界自动细化。
*


* [1.x.90]
*
* 最后，我们再生成一些日志输出。我们停止定时器，并查询从函数开始到现在所经过的CPU秒数。
*


* [1.x.91]
*
* [1.x.92] [1.x.93].
* 系统矩阵、稀疏模式和向量的初始化与前面的例子相同，因此不需要进一步注释。和前面的函数一样，我们也输出我们在这里所做的运行时间。
*


* [1.x.94]
*
* [1.x.95] [1.x.96]。


*
* 和以前一样，这个函数负责组装系统矩阵和右手边的向量。
*


* [1.x.97]
*
* 首先，我们从ParameterHandler对象中查询波速和频率，并将它们存储在本地变量中，因为它们将在本函数中频繁使用。
*


*


* [1.x.98]
*
* 像往常一样，计算积分时使用普通的高斯正交规则。由于我们的双线性形式涉及到[2.x.126]上的边界积分，我们还需要一个正交法则来计算面的积分，这些面是[2.x.127]维的。
*


* [1.x.99]
*
* FEValues对象将为我们评估形状函数。  对于涉及到[2.x.128]上的积分的双线性形式的部分，我们需要形状函数的值和梯度，当然还有正交加权。  对于涉及边界积分的条款，只需要形状函数值和正交权重。
*


* [1.x.100]
*
* 像往常一样，系统矩阵是逐个单元组装的，我们需要一个矩阵来存储本地单元的贡献，以及一个索引向量来将单元的贡献转移到全局系统矩阵中的适当位置，然后。
*


* [1.x.101]
*
* 在每个单元，我们首先需要重置本地贡献矩阵，并请求FEValues对象计算当前单元的形状函数。
*


* [1.x.102]
*
* 在这一点上，重要的是要记住，我们所处理的是一个有两个分量的有限元系统。由于我们构造这个FESystem的方式，即作为两个标量有限元场的笛卡尔乘积，每个形状函数只有一个非零分量（用deal.II的行话来说，它们是[2.x.129] GlossPrimitive "原始"）。  因此，每个形状函数可以被看作是介绍中的[2.x.130] 's或[2.x.131] 's之一，同样，相应的自由度也可以归属于[2.x.132] 或[2.x.133] 。然而，当我们遍历当前单元上的所有自由度时，它们并不以任何特定的顺序出现，因此我们无法立即决定索引为[2.x.134]和[2.x.135]的自由度是属于我们解决方案的实部还是虚部。  另一方面，如果你看一下介绍中的系统矩阵的形式，这个区别是至关重要的，因为它将决定当前一对DoF的贡献将归入系统矩阵的哪个块，因此我们需要从给定的两个形状函数中计算哪个量。  幸运的是，FESystem对象可以为我们提供这些信息，即它有一个函数[2.x.136]，为每个局部的DoF索引返回一对整数，其中第一个整数表示该DoF属于系统的哪个组成部分。这对整数中的第二个整数表示该DoF在标量基有限元域中的索引，但这一信息在这里并不相关。如果你想知道更多关于这个函数和原始向量值元素背后的基本方案，可以看看[2.x.137]或[2.x.138]模块，那里对这些主题有深入的解释。
*


* [1.x.103]

* 如果DoF[2.x.139]和[2.x.140]都属于同一个组件，即它们的形状函数都是[2.x.141]'s或都是[2.x.142]'s，贡献将最终出现在我们系统矩阵的一个对角线块中，由于相应的条目是由同一个公式计算的，我们不必理会它们是否真的是[2.x.143]或[2.x.144]形状函数。我们可以简单地通过遍历所有正交点并将其贡献相加来计算条目，其中形状函数的值和梯度由我们的FEValues对象提供。
*


*


* [1.x.104]
*
* 你可能认为我们在向FEValues对象请求形状函数值或梯度时，必须指定我们想评估的形状函数的哪个分量。然而，由于形状函数是原始的，它们只有一个非零分量，而FEValues类足够聪明，它知道我们肯定对这一个非零分量感兴趣。
*


* [1.x.105]
*
* 我们还必须增加由于边界项的贡献。为此，我们对当前单元格的所有面进行循环，首先看它是否在边界上，其次看它是否有与[2.x.145]相关的正确边界指标，即我们有吸收边界条件的那部分边界。
*


* [1.x.106]
*
* 这些面肯定会对系统矩阵的非对角线块作出贡献，所以我们要求FEFaceValues对象为我们提供这个面上的形状函数值。
*


* [1.x.107]
*
* 接下来，我们循环浏览当前单元的所有DoF，找到属于不同组件且都支持当前face_no的一对。
*


* [1.x.108]
*
* 检查形状函数是否在一个面上有支持并不是严格必要的：如果我们不检查它，我们会简单地把本地单元矩阵的项加起来，这些项碰巧是零，因为至少有一个形状函数碰巧是零。然而，我们可以通过添加上面的检查来节省这项工作。
*

*
* 在任何一种情况下，这些DoF都会对系统矩阵的非对角线块的边界积分做出贡献。为了计算积分，我们在面的所有正交点上进行循环，并将贡献量与面正交规则所提供的正交权重相加。  与对角线块上的条目不同，这里的形状函数哪一个是[2.x.146]，哪一个是[2.x.147]，确实很重要，因为这将决定该条目的符号。  我们通过一个简单的条件语句来说明这一点，以确定正确的符号。由于我们已经检查了DoF[2.x.148]和[2.x.149]属于不同的组件，这里只需测试其中一个属于哪个组件即可。
*


* [1.x.109]
*
* 现在我们已经完成了这个单元，必须把它的贡献从局部系统矩阵转移到全局系统矩阵。为此，我们首先得到这个单元斗室的全局指数列表......
*


* [1.x.110]
*
* ......然后把这些条目一个一个地加到系统矩阵中。
*


* [1.x.111]
*
* 唯一剩下的是[2.x.150]上的迪里希特边界值，其特征是边界指标1。迪里希特值是由我们上面定义的[2.x.151]类提供的。
*


* [1.x.112]
*
* [1.x.113] [1.x.114]。


*
* 正如介绍中已经提到的，系统矩阵既不是对称的，也不是确定的，因此，如何提出一个迭代求解器和预处理器来很好地处理这个矩阵并不是很明显。  我们选择了另一种方式，用UMFPACK提供的稀疏LU分解来解决线性系统。这通常是二维问题的一个很好的首选，即使对于大量的DoF也能很好地工作。  SparseDirectUMFPACK类提供了UMFPACK的deal.II接口，它非常容易使用，使我们只需3行代码就能解决我们的线性系统。
*

*
* 再次注意，为了编译这个例子程序，你需要有支持UMFPACK的deal.II库。
*


* [1.x.115]
*
* 解决线性系统的代码很短：首先，我们分配一个正确类型的对象。下面的[2.x.152]调用提供了我们想要反转的矩阵给SparseDirectUMFPACK对象，并同时启动了LU分解。因此，这也是这个程序中大部分计算工作发生的地方。
*


* [1.x.116]
*
* 分解之后，我们可以把[2.x.153]当作代表我们系统矩阵的逆矩阵来使用，所以要计算出解决方案，我们只需要与右边的向量相乘。
*


* [1.x.117]
*
* [1.x.118] [1.x.119]。


*
* 在这里，我们以参数文件中指定的格式输出我们的解[2.x.154]和[2.x.155]以及派生量[2.x.156]。从[2.x.158]和[2.x.159]导出[2.x.157]的大部分工作已经在[2.x.160]类的实现中完成，因此输出程序相当简单，与前面教程中的内容非常相似。
*


* [1.x.120]
*
* 定义我们[2.x.161]类的对象和一个DataOut对象。
*


* [1.x.121]
*
* 接下来我们从ParameterHandler查询输出相关的参数。[2.x.162] 调用充当了 [2.x.164] 中 [2.x.163] 调用的对应部分。它从ParameterHandler收集所有与输出格式相关的参数，并相应地设置DataOut对象的相应属性。
*


* [1.x.122]
*
* 现在我们从ParameterHandler提供的基本名称和DataOut类提供的后缀组合成文件名（默认后缀被设置为正确的类型，与.prm文件中通过parse_parameters()设置的类型相匹配）。
*


* [1.x.123]
*
*解向量[2.x.165]和[2.x.166]以常规方式添加到DataOut对象中。
*


* [1.x.124]
*
* 对于强度，我们只是再次调用[2.x.167]，但这次用我们的[2.x.168]对象作为第二个参数，这实际上是将[2.x.169]加入到输出数据中。
*


* [1.x.125]

* 最后的步骤和以前一样。请注意，现在实际的输出格式是由输入文件中的内容决定的，也就是说，人们可以改变输出格式而不必重新编译这个程序。
*


* [1.x.126]
*
* [1.x.127] [1.x.128]。


*
* 这里我们只是一个接一个地执行我们的函数。
*


* [1.x.129]
*
* [1.x.130] [1.x.131]。


*
* 最后是该程序的[2.x.170]功能。它的结构与其他几乎所有的教程程序相同。唯一的例外是，我们定义了ParameterHandler和[2.x.171]对象，并让后者从一个叫做[2.x.172]的文本文件中读入参数值。读取的值将被交给UltrasoundProblem类的一个实例。
*


* [1.x.132]
* [1.x.133][1.x.134][1.x.135] 。


* 当前程序从一个名为[2.x.173]的输入文件中读取其运行时参数，该文件看起来像这样。
* [1.x.136]
*
* 可以看出，我们设置了[2.x.174]，这相当于换能器镜头的焦点在[2.x.175]，[2.x.176]。粗略的网格被细化了5次，结果是160x160个单元，输出结果以vtu格式书写。参数读取器可以理解更多与输出生成有关的参数，但是我们在这里不需要这些参数，因此坚持使用它们的默认值。
* 下面是在调试模式下程序的控制台输出。
* [1.x.137]
*
* (当然，如果你在本地运行该程序，执行时间会有所不同。) 事实上，大部分时间都花在组装系统矩阵和生成输出上，这是因为在调试模式下有许多断言需要检查。在发布模式下，程序的这些部分运行得更快，而求解线性系统的速度却很难加快。
* [1.x.138]
*
* 该程序的图形输出看起来如下。
*

* [2.x.177]
* 前两张图片显示了[2.x.178]的实部和虚部，而最后一张显示了强度[2.x.179]。我们可以清楚地看到，强度集中在透镜的焦点周围（0.5，0.3），焦点在[2.x.180]方向相当尖锐，但在[2.x.181]方向却比较模糊，这是聚焦透镜的几何形状、有限光圈和问题的波浪性质所造成的。
* 因为丰富多彩的图形总是很有趣，而且为了进一步强调聚焦效果，这里还有一组图像，强调强度在[2.x.182]-方向上的实际聚焦效果。
* [2.x.183]
*

* 最后，程序的结构使我们很容易确定程序的哪些部分可以随着网格的细化而很好地扩展，哪些部分不可以。下面是5、6、7次全局细化的运行时间。
* [1.x.139]
*
* 每次我们对网格进行一次细化，所以每一步的单元和自由度的数量大约是四倍。可以看出，生成网格、设置自由度、组装线性系统和生成输出的比例相当接近于线性，而求解线性系统的操作，自由度的数量每增加4倍，就需要增加8倍的时间，也就是说，是[2.x.184] 。这可以解释为（使用最优排序）有限元矩阵的带宽是[2.x.185]，而使用LU分解解决带状线性系统的努力是[2.x.186]。这也解释了为什么程序在三维中也能运行（在改变了[2.x.187]对象的维度后），但扩展性很差，在完成对具有可观分辨率的网格上的线性系统的求解前需要极大的耐心，尽管程序的其他部分扩展性很好。
*


* [1.x.140][1.x.141][1.x.142] 。


* 这个程序的一个明显的可能的扩展是在3D&mdash中运行；毕竟，我们周围的世界是三维的，超声束在三维介质中传播。你可以通过简单地改变[2.x.188]中主类的模板参数并运行它来尝试。但这不会让你走得很远：如果你按照参数文件中的设置做5个全局细化步骤，当然不会。你的内存会耗尽，因为网格（包括[2.x.189]单元），特别是稀疏直接求解器会占用太多的内存。然而，如果你有一点时间，你可以用3个全局细化步骤进行求解：在2011年初，直接求解大约需要半个小时。然而，你会注意到，这个解法是完全错误的：网格大小根本不足以准确地解决解法的波浪，你可以从解法的图中看到这一点。因此，在这种情况下，如果你不想在这个问题上扔一个更大的（可能是%并行的）机器，那么自适应性是必不可少的。
*

* [1.x.143][1.x.144] [2.x.190]。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-30_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19]
*[1.x.20][1.x.21][1.x.22] 。



*[1.x.23][1.x.24]


* 这个例子专门讨论[2.x.2]各向异性细化[2.x.3]，它扩展了局部细化的可能性。在大多数情况下，这是对[2.x.4]教程程序的修改，我们使用相同的DG方法来处理线性转场方程。这个程序将涵盖以下主题。[2.x.5] [2.x.6] [2.x.7] 各向异性的细化 [2.x.8] ：各向异性的细化是什么意思？   [2.x.9] [2.x.10] 实现 [2.x.11] ：对代码进行必要的修改，以便与各向异性的细化网格一起工作。   [2.x.12] [2.x.13] 跳跃指标 [2.x.14] : 在DG方法的背景下，各向异性细化的简单指标。[2.x.15] 将不讨论离散化本身，也不讨论此处使用的非各向异性细化的实现技术。请参考[2.x.16]的内容。
* 请注意，在编写这个教程程序的时候，各向异性细化只在不连续的Galerkin有限元中完全实现。这一点以后可能会改变（或者已经改变）。
*


* [2.x.17] 虽然这个程序是对[2.x.18]的修改，但它是对[2.x.19]版本的改编，是在deal.II历史上早期写的，当时MeshWorker框架还没有出现。因此，它与现在的[2.x.20]没有什么相似之处，除了它用同样的离散化方法解决了同样的方程。
*


*[1.x.25][1.x.26]


* 在前面的教程程序中，所有的适应过程都是基于[2.x.21]各向同性[2.x.22]细化单元，它将所有的边切成两半，并在这些分割的边上形成新的单元（当然，还包括一些额外的边、面和顶点）。在交易二中，[2.x.23]各向异性细化[2.x.24]指的是只拆分部分边而不改变其他边的过程。以简单的方形单元为例，考虑一下。
* [1.x.27]
* 经过通常的细化，它将由四个子单元组成，看起来像这样。
* [1.x.28]
* 新的各向异性细化可以采取两种形式：要么我们可以将平行于水平X轴的边缘分割开来，形成这两个子单元。
* [1.x.29]
* 或者我们可以分割沿Y轴运行的两条边，再次产生两个子单元，不过看起来是这样的。
* [1.x.30]
* 所有单元格的细化情况都由一个枚举[2.x.25]来描述，上述各向异性情况被称为[2.x.26]和[2.x.27]，原因很明显。各向异性的细化情况在二维中被称为[2.x.28]，可以通过[2.x.29]从RefinementCase类中请求。
* 在三维中，有第三个轴可以被分割，即Z轴，因此我们在这里有一个额外的细化案例[2.x.30]。各向同性的细化现在将沿x轴、y轴和z轴细化一个单元，因此被称为[2.x.31] cut_xyz。另外还有[2.x.32][2.x.33]和[2.x.34]的情况，它们沿两个轴精炼单元，但不沿第三个轴精炼。给出一个x轴向右、y轴 "进入页面"、z轴在顶部的六面体单元。
* [1.x.31]
*我们有各向同性的细化情况。
* [1.x.32]
*三种各向异性的情况，只对一个轴进行细化。
* [1.x.33]
*还有三个细化三个轴中的两个轴的情况。
* [1.x.34]
* 对于一维问题，各向异性的细化不会产生任何影响，因为一个单元只有一个坐标方向，所以除了各向同性外，不可能以任何其他方式分割。
*[1.x.35][1.x.36]
* 自适应局部细化被用来获得精细的网格，这些网格能够很好地适应有效解决手头的问题。简而言之，产生较大误差的单元的尺寸被缩小，以获得对手头问题的更好的近似解。然而，很多问题都含有各向异性的特征。突出的例子是可压缩粘性流动中的冲击或边界层。一个有效的网格可以用较高长宽比的单元来逼近这些特征，而这些单元是根据上述特征来确定方向的。只使用各向同性的细化，原始网格单元的长宽比会被保留，因为它们会被单元的子代所继承。因此，从各向同性的网格开始，边界层将被细化，以捕捉壁面法线方向上流场的快速变化，从而导致在法线和切线方向上都具有非常小的边长的单元。通常情况下，切线方向的边长要大得多，因此可以使用更少的单元，而不会在近似精度上有明显的损失。各向异性的细化过程可以通过每个细化步骤将母细胞和子细胞的长宽比修改为2的系数。在多次细化的过程中，精细单元的长宽比可以被优化，节省了相当数量的单元和相应的自由度，从而节省了计算资源、内存和CPU时间。
*[1.x.37][1.x.38]
*

* 大多数时候，当我们进行有限元计算时，我们一次只考虑一个单元，例如计算单元对全局矩阵的贡献，或插值边界值。然而，有时我们不得不关注单元在我们的算法中是如何关联的。单元之间的关系有两种形式：邻居关系和母子关系。对于各向异性细化的情况，deal.II对始终保持的单元格关系使用了某些约定（不变量）。例如，一个细化的单元总是正好有[2.x.35]个孩子。而且（除了1d情况），两个相邻的单元格最多可以相差一个细化级别：它们同样经常被细化，或者其中一个正好再细化一次，在共同面上正好留下一个悬空的节点。几乎所有的时候，这些不变量只在库的内部实现中才会被关注。然而，在有些情况下，对它们的了解也与应用程序有关。
* 在目前的情况下，值得注意的是，网格细化的种类影响到一些最基本的假设。因此，在应用程序中发现的一些常规代码将需要修改，以利用使用各向异性细化创建的网格的特征。对于那些对deal.II如何演变感兴趣的人来说，可能有兴趣的是，这种不变性的松动需要一些不兼容的变化。例如，库中曾经有一个成员[2.x.36]，指定单元格一旦被细化后有多少个孩子。对于各向同性的细化，这个数字等于[2.x.37]，如上所述。然而，对于各向异性的细化，这个数字并不存在，因为在二维中可以是2或4，在三维中可以是2、4或8，因此成员[2.x.38]已被删除。它现在被[2.x.39]所取代，后者规定了一个单元格可以拥有的[1.x.39]个子女。以前，被细化的单元有多少个孩子是作为静态信息提供的，但现在它取决于单元的实际细化状态，可以使用[2.x.40]来获取，这个调用对各向同性和各向异性的细化都同样有效。对于面和它们的子面也有非常类似的情况：相关的信息可以使用[2.x.41]或[2.x.42]进行查询，这取决于上下文。
* 另一个重要的方面，也是本教程中最重要的方面，是在组装单元格之间的表面上的跳跃项时对相邻关系的处理。查看[2.x.43]中assemble_system函数的文档，我们注意到，我们需要决定一个相邻的单元是否更粗、更细或者与我们当前的单元处于同一（细化）水平。这些决定对于各向异性的细化并不适用，因为单元的[2.x.44]级[2.x.45]所提供的信息并不足以完全描述各向异性的单元；例如，一个二维单元的终端子女是在[2.x.46方向切割的二维单元，其子女在[2.x.47]方向上被切割，是在第2层，还是在第1层，因为如果该单元被各向同性地细化一次，就会产生同一组最好的单元？
* 在各向异性细化之后，一个更粗的邻居不一定完全是比我们低一级的，而是几乎可以有相对于当前级别的任何级别；事实上，它甚至可以在一个更高的级别上，尽管它更粗。因此，决定必须在不同的基础上做出，而决定的意图却保持不变。
* 在下文中，我们将讨论当我们想要计算形式为[1.x.40]或类似的矩阵（或右手边）的贡献时可能发生的情况；记住，我们使用FEFaceValues和FESubfaceValues类来整合这样的条款。我们还将展示如何编写适用于各向同性和各向异性细化的代码。
* [2.x.48]
* [2.x.49] [2.x.50] 细化邻居 [2.x.51] ：如果我们在一个活动单元上，想在一个面[2.x.52]上进行整合，第一种可能性是这个面后面的邻居更细化，即有孩子只占据了公共面的一部分。在这种情况下，所考虑的面必须是一个精致的面，这可以通过询问 [2.x.53] 来确定。如果这是真的，我们需要循环所有的子面，并得到这个子面后面的邻居的子，这样我们就可以用邻居重新输入一个FEFaceValues对象，用我们的单元格和相应的子面重新输入一个FESubfaceValues对象。
* 对于各向同性的细化，这种情况相当简单，因为我们知道在deal.II中各向同性细化的自适应网格的一个不变因素是，邻居只能正好相差一个细化等级。然而，对于各向异性细化的网格来说，这并不完全正确，特别是在三维中；在那里，我们感兴趣的[2.x.54]另一边的活动单元实际上可能不是我们邻居的孩子，而可能是孙子或甚至更远的后代。幸运的是，这种复杂性被隐藏在库的内部。我们所要做的就是调用[2.x.55]函数。尽管如此，在3D中，有两种情况需要特别考虑。   [2.x.56] [2.x.57] 如果邻居被各向异性地细化了一次以上，可能这里需要考虑的不是两个或四个而是三个子面。想象一下我们正在考虑的（三维）邻接单元的（二维）面的以下细化过程：首先该面沿x方向细化，后来只沿y方向细化左侧子面。
* [1.x.41]
* 这里子面的数量是三个。需要注意的是，对于一个面，[2.x.58]和[2.x.59]之间的细微差别。第一个函数返回直系子代的数量，对于上面的例子是两个，而第二个函数返回活动子代的数量（即包括子代、孙代和进一步的子代），在上面的例子中是正确的三个。使用[2.x.60]对各向同性和各向异性以及二维和三维情况都有效，所以应该始终使用它。应该注意的是，如果最右边图像左侧的两个小子面后面的任何一个单元被进一步细化，那么当前的单元（即我们正在查看这个共同面的一侧）也要被细化：之所以这样，是因为否则就会违反每条边只有一个悬挂节点的不变性。
* [2.x.61] 可能的情况是，邻居比较粗糙，但仍有比我们当前单元格更精细的子节点。如果两个同样粗糙的单元被细化，其中一个单元在所考虑的面有两个孩子，另一个有四个孩子，这种情况就会发生。下图中的单元格只是相互分离，以显示各个细化的情况。
* [1.x.42]
*
* 这里，左边的两个单元是在[2.x.62]方向对母单元进行各向异性分割的结果，而右边的四个单元是在[2.x.63]-和[2.x.64]方向同时进行各向异性细化的结果。  标有#的左边单元有两个标有+的更细的邻居，但左边单元的实际邻居是完整的右边母单元，因为标有+的两个单元更细，它们的直接母体是一个大单元。   [2.x.65]
* 然而，幸运的是，[2.x.66]可以自己处理这些情况，如果你在正确的子面数量上循环，在上面的例子中，这是两个。[2.x.67]函数也会照顾到这一点，所以结果的状态总是正确的。然而，有一个小的注意事项。为了重新调用邻居的FEFaceValues对象，你需要知道指向当前单元格的面的索引。通常你假设直接得到的邻居和你一样粗或一样细，如果它有孩子的话，因此这个信息可以通过[2.x.68]得到。为了方便你，有一个[2.x.70]可以为你做正确的事情，并返回所需的结果。
* [2.x.71] [2.x.72] 邻居和我们的单元格一样细 [2.x.73] ：在我们排除了所有存在更细的子单元的情况后，我们只需要决定，这里的邻居是否更粗。为此，有一个[2.x.74]函数，返回一个布尔值。为了得到相同粗度的邻居的相关情况，我们将使用 [2.x.75] 。这个块里面的代码可以不动。然而，这里有一件事要提到。如果我们想使用一个规则，哪一个单元应该在一个给定的面上组合某些条款，我们可以考虑[2.x.76]中提出的规则。我们知道，我们必须舍弃将我们的单元格的水平与邻居的水平进行比较的部分，而代之以上面提出的对更粗的邻居的测试。然而，我们也必须考虑到具有相同粗度的相邻单元具有相同指数（在不同水平上）的可能性。因此，我们必须包括单元格具有相同指数的情况，并给出一个额外的条件，即哪一个单元格应该集合条款，例如，我们可以选择较低层次的单元格。这个概念的细节可以在下面的实现中看到。
* [2.x.77] [2.x.78] 较粗的邻居 [2.x.79] : 剩下的情况很明显：如果没有精炼的邻居，而且邻居没有当前单元格那么细，那么它一定是较粗的。因此，我们可以留下旧的条件短语，简单地使用 [2.x.80] 。[2.x.81]函数照顾到各向异性细化的所有复杂性，结合一般三维网格上可能出现的非标准面方向、翻转和旋转。
* [2.x.82]
* [1.x.43][1.x.44] 。
* 当一个三角形被细化时，没有被标记为细化的单元仍然可以被细化。这是由于额外的平滑算法，这些算法是必要的或明确要求的。特别是，在每条边上最多有一个悬空节点的限制，经常迫使细化那些已经很细的、被标记为要进一步细化的单元的邻近单元。
* 然而，deal.II也实现了一些算法，以确保产生的网格比最低限度的平滑，例如确保没有孤立的细化单元被非细化单元包围，因为这些土地上的额外自由度几乎都受到悬挂节点的约束。(参见Triangulation类的文档和它的[2.x.83]成员以获得更多关于网格平滑的信息)。
* 大多数最初为各向同性开发的平滑算法已经被调整为以非常相似的方式用于各向异性和各向同性的细化。然而，有两种算法值得一提。[2.x.84] [2.x.85] [2.x.86] ：在各向同性的环境中，该算法试图通过减少在共同顶点相遇的单元的细化水平差异来确保良好的近似质量。然而，对于各向异性的细化没有明确的对应概念，因此该算法不能与各向异性的细化结合使用。这个限制是由一个断言强制执行的，一旦在一个已经被各向异性细化的三角形上调用该算法，就会抛出一个错误。
* [2.x.87] [2.x.88] ：如果引入细化来限制悬空节点的数量，往往不需要额外的单元来提高近似质量。这对DG方法来说尤其如此。如果你设置了标志[2.x.89]，平滑算法试图通过使用各向异性的细化来尽量减少可能不需要的额外单元的数量。如果你设置了这个平滑标志，你可能会得到各向异性的细化单元，即使你从未将一个细化标志设置为各向异性的细化。请注意，如果你的代码尊重各向异性网格的可能性，你只应该使用这个标志。结合一个合适的各向异性指标，这个标志可以帮助节省额外的单元，从而节省精力。[2.x.90]
*

*[1.x.45][1.x.46]


* 利用各向异性细化的好处，需要一个指标来捕捉溶液的各向异性特征，并利用它们来进行细化过程。一般来说，各向异性的细化过程将包括几个步骤。[2.x.91] [2.x.92] 计算一个误差指标。   [2.x.93] 使用误差指标标记单元进行细化，例如，使用固定数量或分数的单元。这些单元将被自动标记为各向同性的细化。   [2.x.94] 仅在被标记的单元上评估一个明显的各向异性指标。   [2.x.95] 使用各向异性指标为合适的单元设置一个新的各向异性细化标志，否则保持标志不变。   [2.x.96] 调用[2.x.97]来执行要求的细化，使用要求的各向同性和各向异性标志。[2.x.98] 这种方法类似于我们在[2.x.99]中用于hp-细化的方法，具有很大的灵活性优势。任何误差指标都可以在各向异性过程中使用，也就是说，如果你有相当多的面向后方的误差指标可用，你可以像使用一个简单的Kelly误差估计器一样容易地使用它们。细化过程的各向异性部分不受这种选择的影响。此外，在deal.II或你的应用程序中没有任何各向异性变化之前，只需省去第三步和第四步，就可以得到相同的各向异性细化结果。作为最后一个优点，只在标记为细化的单元上工作，可以更快地评估各向异性指标，如果指标涉及很多单元，在更细的网格上会变得很明显。
* 在这里，我们使用一个非常简单的方法，它只适用于DG方法。一般的想法是非常简单的。DG方法允许离散解在单元面上跳跃，而在每个单元内是平滑的。当然，在极限情况下，我们希望随着我们对网格的细化和对真实解的逼近，跳跃会趋于零。因此，在某个面上的大跳跃表明该单元应该被细化（至少是）正交于该面，而小跳跃则不会导致这一结论的产生。当然，确切的解不可能是光滑的，它也有跳跃的特征。然而，在这种情况下，一个面的大跳跃表明，这个面或多或少地与跳跃平行，并与之相邻，因此，我们再次期望与所考虑的面正交的细化能够有效。
* 建议的指标计算平均跳跃[2.x.100]，即离散解[2.x.102]在两个面[2.x.103]、[2.x.104]、[2.x.105]上正交于坐标方向[2.x.106]的绝对跳跃的平均值[1.x.47] 。如果一个方向的平均跳动比其他方向的平均跳动大一定的系数[2.x.107]，即如果[2.x.108]，则单元格只沿该特定方向细化[2.x.109]，否则单元格是各向同性细化的。
* 这样的标准很容易被推广到方程组中：跳跃的绝对值将被矢量值跳跃的适当规范所取代。
*


*[1.x.48][1.x.49]


* 我们解决[2.x.110]中提出的线性传输方程。域被扩展到覆盖二维的[2.x.111]，其中流场[2.x.112]在域的右半部分描述了围绕原点的逆时针四分之一圆，在域的左半部分平行于X轴。流入边界同样位于[2.x.113]处，并沿x轴的正向部分，边界条件选择如[2.x.114]。
*

* [1.x.50] [1.x.51]。
* deal.II的包含文件在以前的例子中已经介绍过了，因此不再做进一步评论。
*


* [1.x.52]

* 而这又是C++。
*


* [1.x.53]

* 最后一步和以前的所有程序一样。



* [1.x.54]
*
* [1.x.55] [1.x.56].
* 描述方程数据的类和单个项的实际装配几乎完全照搬自 [2.x.115] 。我们将对差异进行评论。
*


* [1.x.57]
*
*流场选择为四分之一圆，流向为逆时针，原点为域的右半部分的中点，数值为正[2.x.116]，而在域的左边部分，流速只是向左走，与从右边进来的流速一致。在圆形部分，流速的大小与离原点的距离成正比。这与[2.x.117]不同，在该定义中，到处都是1。新定义导致[2.x.118]沿单元的每个给定面的线性变化。另一方面，[2.x.119]的解决方案与之前完全相同。
*


* [1.x.58]
*
* [1.x.59] [1.x.60]。
* 这个类的声明完全不受我们目前的变化影响。
*


* [1.x.61]
*
* 同样地，该类的构造函数以及组装对应于单元格内部和边界面的术语的函数与之前没有变化。装配单元间面术语的函数也没有改变，因为它所做的只是对两个FEFaceValuesBase类型的对象（它是FEFaceValues和FESubfaceValues的基类）进行操作。这些对象从何而来，即它们是如何被初始化的，对这个函数来说并不重要：它只是假设这两个对象所代表的面或子面上的正交点对应于物理空间中的相同点。
*


* [1.x.62]
*
* [1.x.63] [1.x.64]。
* 这个声明很像 [2.x.120] 的声明。然而，我们引入了一个新的例程（set_anisotropic_flags）并修改了另一个例程（refine_grid）。
*


* [1.x.65]
*
* 我们再次希望使用1度的DG元素（但这只在构造函数中指定）。如果你想使用不同程度的DG方法，请在构造函数中用新的程度替换1。
*


* [1.x.66]
*
* 这是新的，在介绍中解释的各向异性跳跃指标的评估中使用的阈值。它的值在构造函数中被设置为3.0，但是它可以很容易地被改变为一个大于1的不同值。
*


* [1.x.67]
*
* 这是一个指示是否使用各向异性细化的bool标志。它由构造函数设置，构造函数需要一个同名的参数。
*


* [1.x.68]

* 在这里为不同程度的DG方法进行改变。
*


* [1.x.69]
*
* 由于β是一个线性函数，我们可以选择所得积分正确的正交度数。因此，我们选择使用[2.x.121]高斯点，这使我们能够准确地积分度数为[2.x.122]的多项式，足以满足我们在本程序中要进行的所有积分。
*


* [1.x.70]
*
* [1.x.71] [1.x.72]。
* 我们继续使用[2.x.123]函数来实现DG离散化。这个函数与[2.x.125]中的[2.x.124]函数的作用相同（但没有MeshWorker）。  一个单元的邻居关系所考虑的四种情况与各向同性的情况相同，即a)单元在边界上，b)有更细的邻居单元，c)邻居既不粗也不细，d)邻居更粗。  然而，我们决定哪种情况的方式是按照介绍中描述的方式修改的。
*


* [1.x.73]
*
* 情况（a）。该面在边界上。
*


* [1.x.74]
*
* 情况（b）。这是一个内部面，邻居是精炼的（我们可以通过询问当前单元格的面是否有孩子来测试）。在这种情况下，我们需要对 "子面 "进行整合，即当前单元格的面的子女。                 
*（有一个稍微令人困惑的角落案例。如果我们是在1d
*
*--诚然，当前的程序及其各向异性细化的演示并不特别相关
*
* - 那么单元格之间的面总是相同的：它们只是顶点。换句话说，在1d中，我们不想区别对待不同层次的单元之间的面。我们在这里检查的条件`face->has_children()`确保了这一点：在1d中，这个函数总是返回`false'，因此在1d中我们永远不会进入这个`if'分支。但我们将不得不在下面的情况（c）中回到这个角落。
*


* [1.x.75]
*
* 我们需要知道，哪个邻居的面孔指向我们的单元格的方向。使用[2.x.126] neighbor_face_no函数，我们可以得到较粗和非较粗邻居的这些信息。
*


* [1.x.76]
*
* 现在我们在所有的子面中循环，也就是当前面的子代和可能的孙代。
*


* [1.x.77]
*
* 要获得当前子面后面的单元，我们可以使用[2.x.127]函数。它照顾到各向异性细化和非标准面的所有复杂情况。
*


* [1.x.78]
*
* 本案例的其余部分没有变化。
*


* [1.x.79]
*
* 情况（c）。如果这是一个内部面，并且邻居没有进一步细化，我们就得到这里（或者，如上所述，我们是在1d中，在这种情况下，我们对每个内部面都得到这里）。然后，我们需要决定是否要对当前面进行整合。如果邻居实际上更粗，那么我们就忽略这个面，而是在访问相邻的单元并查看当前面时进行处理（除了在1d中，如上所述，这是不可能的）。
*


* [1.x.80]
*
* 另一方面，如果邻居更加精细，那么我们已经处理了上面(b)情况下的面（1d除外）。所以对于2d和3d，我们只需要决定是要处理来自当前一侧的同一层次的单元格之间的面还是来自相邻一侧的面。  我们通过引入一个平局来做到这一点。我们只取索引较小的单元格（在当前细化级别内）。在1d中，我们取较粗的单元，或者如果它们在同一层次，则取该层次中指数较小的单元。这就导致了一个复杂的条件，希望在上面的描述中可以理解。
*


* [1.x.81]
*
* 这里我们知道，邻居不是更粗的，所以我们可以使用通常的[2.x.128]函数。然而，我们也可以使用更通用的[2.x.129]函数。
*


* [1.x.82]
*
* 我们不需要考虑情况(d)，因为那些面孔是'从情况(b)内的另一边处理的。
*


* [1.x.83]
*
* [1.x.84] [1.x.85]。
* 对于这个简单的问题，我们再次使用简单的Richardson迭代。该求解器完全不受我们各向异性变化的影响。
*


* [1.x.86]
*
* [1.x.87] [1.x.88].
* 我们根据[2.x.130]中使用的相同的简单细化标准来细化网格，即对解的梯度的近似。
*


* [1.x.89]
*
* 我们对梯度进行近似计算。
*


* [1.x.90]

* 并对其进行缩放，以获得一个误差指标。
*


* [1.x.91]
*
* 然后我们用这个指标来标记误差指标最高的30%的单元格来进行精炼。
*


* [1.x.92]
*
* 现在，细化标志被设置为那些具有大误差指标的单元。如果不做任何改变，这些单元将被各向同性地细化。如果给这个函数的[2.x.131]标志被设置，我们现在调用set_anisotropic_flags()函数，该函数使用跳转指标将一些细化标志重置为各向异性细化。
*


* [1.x.93]
*
* 现在执行细化，考虑各向异性以及各向同性的细化标志。
*


* [1.x.94]
*
* 一旦错误指标被评估，误差最大的单元被标记为细化，我们要再次循环这些被标记的单元，以决定它们是否需要各向同性的细化，或者各向异性的细化更合适。这就是在介绍中解释的各向异性跳跃指标。
*


* [1.x.95]
*
* 我们想在有标记的单元格的面上评估跳跃，所以我们需要一些对象来评估面上的解决方案的值。
*


* [1.x.96]
*
* 现在我们需要在所有的活动单元中进行循环。
*


* [1.x.97]
*
* 我们只需要考虑那些被标记为细化的单元。
*


* [1.x.98]
*
* 在汇编例程中看到的四种不同的相邻关系的情况，在这里基本以相同的方式重复。
*


* [1.x.99]
*
* 邻居被细化。  首先，我们存储信息，即邻居的哪个面指向我们当前单元的方向。这个属性会继承给子代。
*


* [1.x.100]
*
* 现在我们在所有的子界面上循环。
*


* [1.x.101]
*
*得到一个迭代器，指向当前子面后面的单元格...
*


* [1.x.102]
*
* ... 并重新启动各自的FEFaceValues和FESSubFaceValues对象。
*


* [1.x.103]
*
* 我们获得了函数值
*


* [1.x.104]
*
*以及正交权重，乘以雅各布行列式。
*


* [1.x.105]
*
* 现在我们在所有的正交点上循环。
*


* [1.x.106]
*
*并整合解决方案的跳跃的绝对值，即分别从当前单元格和相邻单元格看到的函数值的绝对值。我们知道，前两个面与单元格上的第一个坐标方向正交，后两个面与第二个坐标方向正交，以此类推，所以我们把这些值累积成有[2.x.132]分量的向量。
*


* [1.x.107]
*
* 我们还将按比例的权重相加，得到脸部的量度。
*


* [1.x.108]
*
* 我们当前的单元和邻近的单元沿着所考虑的面有相同的细化。除此之外，我们的做法与上述案例中的一个子单元基本相同。
*


* [1.x.109]
*
* 现在的邻居实际上更粗了。这种情况是新的，因为它没有在汇编程序中出现。在这里，我们必须考虑它，但这并不太复杂。我们只需使用[2.x.133] neighbor_of_coarser_neighbor函数，它再次自行处理各向异性的细化和非标准面的方向。
*


* [1.x.110]
*
* 现在我们分析一下平均跳跃的大小，我们用跳跃除以各自面的度量得到。
*


* [1.x.111]
*
* 现在我们在单元格的[2.x.134]坐标方向上进行循环，比较与该方向正交的面的平均跳跃和与其余方向正交的面的平均跳跃。如果前者比后者大一个给定的系数，我们只沿帽轴进行细化。否则，我们不改变细化标志，导致各向同性的细化。
*


* [1.x.112]
*
* [1.x.113] [1.x.114]。
* 程序的其余部分非常遵循以前教程程序的方案。我们以VTU格式输出网格（就像我们在[2.x.135]中所做的那样，例如），并以VTU格式输出可视化，我们几乎总是这样做。
*


* [1.x.115]
*
* 创建矩形域。
*


* [1.x.116]
*
* 调整不同方向的单元数，以获得原始网格的完全各向同性的单元。
*


* [1.x.117]
*
* 如果你想以3D方式运行程序，只需将下面一行改为[2.x.136] 。
*


* [1.x.118]
*
* 首先，我们进行一次各向同性的细化运行。
*


* [1.x.119]
*
* 现在我们做第二次运行，这次是用各向异性的细化方法。
*


* [1.x.120]
*[1.x.121][1.x.122]


*
* 这个程序的输出包括控制台输出，包含网格的SVG文件，以及以VTU格式给出的解决方案。
* [1.x.123]
*
* 这个文本输出显示了各向异性细化的连续应用所带来的单元数量的减少。在最后一步细化之后，节省的数量已经积累到几乎是各向同性情况下所需单元和自由度的四倍。装配所需的时间也以类似的因素增加。
* 第一个有趣的部分当然是看网格的样子。左边是各向同性的细化网格，右边是各向异性的网格（颜色表示单元的细化程度）。
* [2.x.137]
*

* 另一个有趣的事情是，当然，要看到两个网格序列上的解决方案。在这里，它们是在细化周期1和4上，清楚地显示出解决方案确实是由[1.x.124]片断多项式组成的。
* [2.x.138]
* 我们看到，各向异性细化网格上的解与各向同性细化网格上的解非常相似。因此，各向异性指标似乎可以有效地选择适当的单元进行各向异性的细化。
* 图片也解释了为什么网格被细化成这样。在整个域的左边部分，细化只沿着单元的[2.x.139]轴进行。在域的右边部分，细化是以各向异性细化为主，因为解决方案的各向异性特征
*
*-从一到零的跳跃
*
* - 与平流方向转弯的网格不太一致。然而，在四分之一圆的底部和最接近观察者的部分，这个跳跃又变得越来越与网格对齐，细化算法的反应是创建各向异性的单元，也就是增加长宽比。
* 似乎各向异性特征和粗大网格的必要对齐会大大降低现实世界问题的性能。这在一般情况下是不会错的。例如，如果将各向异性细化应用于出现冲击的问题（例如，在[2.x.140]中求解的方程），那么在许多情况下，各向异性细化的性能会大大降低。)，那么在很多情况下，冲击并不与网格对齐，各向异性的细化对其帮助不大，除非同时引入技术将网格与冲击对齐。在这些情况下，网格已经与各向异性的特征对齐，因为它当然是与边界本身对齐的，各向异性的细化几乎总是能提高这些情况下适应网格的计算效率。
*

* [1.x.125][1.x.126] [2.x.141]。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-3_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25]
*[1.x.26][1.x.27][1.x.28] 。


* [2.x.2]
*[1.x.29][1.x.30]


* 这是我们实际使用有限元计算的第一个例子。我们将求解一个简单版本的泊松方程，其边界值为零，但其右手边非零。
* [1.x.31]
* 我们将在正方形[2.x.3]上求解这个方程，你已经在[2.x.4]和[2.x.5]中学过如何生成网格。在这个程序中，我们也将只考虑特殊情况[2.x.6]，在下一个教程程序[2.x.7]中再来讨论如何实现更普遍的情况。
* 如果你已经了解了有限元方法的基础知识，你会记得我们需要采取的步骤，即用有限元近似法来近似解[2.x.8]。具体来说，我们首先需要推导出上述方程的弱式，通过将方程乘以测试函数[2.x.9][1.x.32]（下面我们将回到从左而非从右相乘的原因）并在域[2.x.10]上积分来获得。
* [1.x.33]
* 这可以通过部分整合。
* [1.x.34]
* 测试函数[2.x.11]必须满足同样的边界条件（用数学术语来说：它需要来自我们寻求解决方案的集合的切线空间），因此在边界上[2.x.12]，因此我们要寻找的弱形式为
* [1.x.35]
*其中我们使用了常用的符号[2.x.13]。然后，问题要求找到一个函数[2.x.14]，对于这个函数，这个声明对于适当空间（这里是空间[2.x.16]）中的所有测试函数[2.x.15]都是真的。
* 当然，在一般情况下，我们无法在计算机上找到这样的函数，因此我们寻求一个近似值[2.x.17]，其中[2.x.18]是我们需要确定的未知膨胀系数（这个问题的 "自由度"），而[2.x.19]是我们将使用的无限元形状函数。为了定义这些形状函数，我们需要以下条件。
*
* - 一个用于定义形状函数的网格。你已经在[2.x.20]和[2.x.21]中看到如何生成和操作描述网格的对象。
*
* - 一个描述我们要在参考单元上使用的形状函数的有限元（在deal.II中，它总是单位间隔[2.x.22]、单位正方形[2.x.23]或单位立方体[2.x.24]，取决于你在哪个空间维度工作）。在[2.x.25]中，我们已经使用了一个FE_Q<2>类型的对象，它表示通常的拉格朗日元素，通过对支持点的插值来定义形状函数。最简单的是FE_Q<2>(1)，它使用1度的多项式。在2d中，这些通常被称为[1.x.36]，因为它们在参考单元的两个坐标中都是线性的。(在1d中，它们是[1.x.37]，在3d中是[1.x.38]；然而，在deal.II文档中，我们经常不做这种区分，而只是简单地总是称这些函数为 "线性"。)
*
* - 一个DoFHandler对象，它列举了网格上的所有自由度，以有限元对象提供的参考单元描述为基础。你也已经在 [2.x.26] 中看到了如何做到这一点。
*
* - 一个映射，它告诉我们如何从参考单元上的有限元类定义的形状函数中获得真实单元上的形状函数。默认情况下，除非你明确说明，否则deal.II将使用（双，三）线性映射，所以在大多数情况下，你不必担心这个步骤。
* 通过这些步骤，我们现在有了一组函数[2.x.27]，我们可以定义离散问题的弱形式：找到一个函数[2.x.28]，即找到上面提到的扩展系数[2.x.29]，以便
* [1.x.39]
* 注意，我们在这里遵循惯例，即一切从零开始计算，这在C和C++中很常见。如果你插入表示法[2.x.30]，然后观察到，这个方程可以被改写为一个线性系统。
* [1.x.40]
*有了这个，问题就变成了。找到一个向量[2.x.31]，以便
* [1.x.41]
*其中矩阵[2.x.32]和右边的[2.x.33]定义为
* [1.x.42]
*
*

*[1.x.43][1.x.44]


* 在我们继续描述如何计算这些数量之前，请注意，如果我们将[1.x.45]中的原始方程乘以est函数，而不是从左边开始，那么我们将得到一个形式为的线性系统
* [1.x.46]
*有一个行向量[2.x.34]。通过转置这个系统，这当然等同于求解
* [1.x.47]
* 在这里，由于[2.x.35]，它与上述相同。但一般来说不是，为了避免任何形式的混淆，经验表明，只要养成从左边而不是从右边乘方程的习惯（就像数学文献中经常做的那样），就能避免一类常见的错误，因为矩阵会自动正确，在比较理论和实现时不需要转置。本教程中的第一个例子见[2.x.36]，我们有一个非对称的双线性形式，对于这个形式，我们从右边乘以还是从左边乘以是有区别的。
*

*[1.x.48][1.x.49]


* 现在我们知道我们需要什么（即：持有矩阵和向量的对象，以及计算[2.x.37]的方法），我们可以看看要实现这些需要什么。
*
* - [2.x.38]的对象是稀疏矩阵类型，而[2.x.39]和[2.x.40]的对象是矢量类型。我们将在下面的程序中看到哪些类是用来解决线性系统的。
*
* - 我们需要一种方法来形成积分。在有限元方法中，最常见的是使用正交法，即积分被每个单元上的一组点的加权和所取代。也就是说，我们首先将[2.x.41]的积分分成所有单元的积分。
* [1.x.50]
* 然后用正交法近似计算每个单元的贡献。
* [1.x.51]
* 其中[2.x.42]是[2.x.43]单元上的第1个正交点[2.x.44]，而[2.x.45]是第1个正交权重。这样做需要有不同的部分，接下来我们将依次讨论它们。
*
* - 首先，我们需要一种方法来描述正交点的位置 [2.x.47] 和它们的权重 [2.x.48] 。它们通常以与形状函数相同的方式从参考单元映射出来，即隐含地使用MappingQ1类，或者，如果你明确地说，通过从Mapping派生的其他类之一。参考单元上的位置和权重由派生自正交基类的对象来描述。通常，人们选择一个正交公式（即一组点和权重），使正交正好等于矩阵中的积分；这可以实现，因为积分中的所有因子都是多项式，由高斯正交公式完成，在QGauss类中实现。
*
* - 然后我们需要一些东西来帮助我们评估[2.x.49]单元格[2.x.50]。这就是FEValues类的作用：它需要一个有限元对象来描述参考单元上的[2.x.51]，一个正交对象来描述正交点和权重，以及一个映射对象（或隐含地采用MappingQ1类），并在位于[2.x.53]的正交点上提供形状函数的值和导数，以及积分所需的各种其他信息。
* FEValues确实是装配过程中的核心类。你可以用以下方式来看待它。FiniteElement和派生类描述了形状[1.x.52]，即无限维度的对象：函数在每个点上都有值。由于理论上的原因，我们需要这样做，因为我们要用函数的积分来进行分析。然而，对于计算机来说，这是一个非常困难的概念，因为它们一般只能处理有限的信息量，所以我们用正交点上的和来代替积分，我们通过使用定义在参考单元（正交对象）上的点映射（映射对象）到实数单元上的点来获得。因此，我们将问题简化为我们只需要有限的信息量，即形状函数值和导数、正交权重、法线向量等，只需要在有限的点集合上。FEValues类是将这三个部分结合在一起的，它提供了一个特定单元上的有限信息集 [2.x.54] 。当我们组装下面的线性系统时，你会看到它在发挥作用。
* 值得注意的是，如果你只是在一个应用程序中自己创建这三个对象，并自己处理这些信息，所有这些也都可以实现。然而，这样做既不简单（FEValues类提供的正是你实际需要的信息），也不快：FEValues类经过高度优化，只在每个单元中计算你需要的特定信息；如果有任何东西可以从前一个单元中重复使用，那么它就会这样做，而且该类中有很多代码可以确保在任何有利的地方进行缓存。
* 这段介绍的最后一点是要提到，在得到一个线性系统后，要用一个迭代求解器进行求解，然后进行后处理：我们用DataOut类创建一个输出文件，然后可以用一个常见的可视化程序进行可视化。
* [2.x.55] 前面对任何有限元实现的所有重要步骤的概述在deal.II中都有对应的内容：该库可以自然地归纳为若干 "模块"，涵盖了刚才概述的基本概念。你可以通过本页面顶部的标签访问这些模块。在[1.x.53]中也有最基本的概念组的概述。
*

*[1.x.54][1.x.55]


* 尽管这是你能用有限元方法解决的最简单的方程，但这个程序显示了大多数有限元程序的基本结构，也是几乎所有后续程序都要遵循的模板。具体来说，这个程序的主类是这样的。
* [1.x.56]
*
* 这遵循了[1.x.57]的面向对象编程口号，也就是说，我们尽力将这个类的几乎所有内部细节隐藏在外部无法访问的私有成员中。
* 让我们从成员变量开始。这些变量遵循我们在上面的要点中所概述的构件，即我们需要一个三角形（Triangulation）和一个DoFHandler对象，以及一个描述我们要使用的各种形状函数的有限元对象。第二组对象与线性代数有关：系统矩阵和右手边以及解向量，还有一个描述矩阵稀疏模式的对象。这是这个类所需要的全部内容（也是任何静止PDE的求解器所需要的基本内容），并且需要在整个程序中存在。与此相反，我们需要的FEValues对象只在整个装配过程中需要，因此我们在进行装配的函数中把它创建为一个局部对象，并在结束时再次销毁它。
* 其次，让我们看看成员函数。这些也已经形成了通用的结构，几乎所有下面的教程程序都会使用。[2.x.56] [2.x.57] [2.x.58] ：这就是人们所说的[1.x.58]。顾名思义，它设置了存储三角图的对象。在以后的例子中，它还可以处理边界条件、几何形状等。   [2.x.59] [2.x.60] ：这是一个函数，其中设置了解决问题所需的所有其他数据结构。特别是，它将初始化DoFHandler对象，并正确确定与线性代数有关的各种对象的大小。这个函数通常与上面的预处理函数分开，因为在一个与时间相关的程序中，每当网格被自适应细化时，它可能至少每隔几个时间步就被调用一次（我们将在[2.x.61]中看到如何做到这一点）。另一方面，在上面的预处理函数中，设置网格本身只在程序开始时进行一次，因此，它被分离成自己的函数。   [2.x.62] [2.x.63] : 这就是计算矩阵和右手边内容的地方，在上面的介绍中已经详细讨论过。由于对这个线性系统进行处理在概念上与计算其条目有很大不同，我们将其与以下函数分开。   [2.x.64] [2.x.65] ：这就是我们计算线性系统[2.x.67]的解[2.x.66]的函数。在当前的程序中，这是一个简单的任务，因为矩阵是如此简单，但只要问题不再那么微不足道，它就会成为程序大小的一个重要部分（例如，在你对库有了更多的了解之后，可以参考 [2.x.68] ， [2.x.69] ，或 [2.x.70] ）。   [2.x.71] [2.x.72] : 最后，当你计算出一个解决方案后，你可能想用它做一些事情。例如，你可能想以可视化的格式输出它，或者你可能想计算你感兴趣的量：例如，热交换器中的热通量、机翼的空气摩擦系数、最大桥梁载荷，或者仅仅是某一点上的数值解的值。因此，这个函数是对你的解进行后处理的地方。[2.x.73]所有这些都是由唯一的公共函数（除constructor外），即[2.x.74]函数来支撑的。它是在创建这种类型的对象的地方被调用的函数，也是按适当顺序调用所有其他函数的函数。将这个操作封装到 [2.x.75] 函数中，而不是从 [2.x.76] 中调用所有其他函数，可以确保你可以改变这个类中关注点分离的实现方式。例如，如果其中一个函数变得太大，你可以把它拆成两个，而你唯一需要关注的地方就是这个类中的变化，而不是其他地方。
* 如上所述，你会看到这种一般的结构&mdash；有时在函数名称的拼写上会有差异，但基本上是按照这种功能分离的顺序&mdash；在下面的许多教程程序中也是如此。
*

*[1.x.59][1.x.60]


* deal.II通过命名空间[2.x.77]中的别名定义了一些积分%类型（在前一句中，"积分 "一词被用作[1.x.61]，对应于名词 "整数"。它不应该与表示曲线或曲面下的面积或体积的[1.x.62]"积分 "相混淆。形容词 "积分 "在C++世界中被广泛使用，如 "积分类型"、"积分常数 "等。特别是，在这个程序中，你会在几个地方看到[2.x.78]：一个整数类型，用来表示自由度的[1.x.63]索引，即定义在三角形之上的DoFHandler对象中的特定自由度的索引（而不是特定单元中的特定自由度的索引）。对于当前的程序（以及几乎所有的教程程序），你将有几千个到几百万个全局未知数（对于[2.x.79]元素，你将有4个[1.x.64]的2D和8个3D）。因此，允许为全局DoF指数存储足够大的数字的数据类型是[2.x.80]，因为它允许存储0到略高于40亿的数字（在大多数系统中，其中整数是32位）。事实上，这就是[2.x.81]的内容。
* 那么，为什么不直接使用[2.x.82]呢？ deal.II在7.3版之前一直是这样做的。然而，deal.II支持非常大的计算（如[2.x.83]中讨论的框架），当分布在几千个处理器上时，可能有超过40亿的未知数。因此，在有些情况下，[2.x.84]不够大，我们需要一个64位无符号积分类型。为了实现这一点，我们引入了[2.x.85]，默认情况下，它被定义为<code>unsignedint</code>，而如果需要的话，可以通过在配置过程中传递一个特定的标志，将其定义为<code>unsigned long longint</code>（见ReadMe文件）。
* 这包括技术方面。但是还有一个文档的目的：在库和建立在它上面的代码中，如果你看到一个地方使用了数据类型[2.x.86]，你就会立即知道被引用的数量实际上是一个全局的道夫指数。如果我们只是使用[2.x.87]（它也可能是一个局部索引、一个边界指示器、一个材料ID等等），就不会有这样的含义。立即知道一个变量指的是什么也有助于避免错误：如果你看到一个[2.x.88]类型的对象被分配给[2.x.89]类型的变量，这很明显是一个错误，尽管它们都是用无符号整数表示，因此编译器不会抱怨。
* 在更实际的情况下，这种类型的存在意味着在汇编过程中，我们创建了一个[2.x.90]矩阵（在2d中，使用[2.x.91]元素），即我们目前所在的单元的贡献，然后我们需要将这个矩阵的元素添加到全局（系统）矩阵的适当元素中。为此，我们需要获得当前单元的局部自由度的全局指数，为此我们将始终使用下面这段代码。
* [1.x.65]
*其中[2.x.92]被声明为
* [1.x.66]
* 这个变量的名字可能有点名不副实
*
* - 它代表 "当前单元格上局部定义的自由度的全局指数"
*
* - 但持有这些信息的变量在整个库中都是这样命名的。
* [2.x.93] [2.x.94]不是这个命名空间中定义的唯一类型，而是有一整个系列，包括[2.x.95] [2.x.96]和[2.x.97] 所有这些都是整数数据类型的别名，但正如上面所解释的，它们被用于整个库，以便(i)变量的意图变得更容易辨别，以及(ii)如果有必要，有可能将实际类型改为更大的类型，而不必翻阅整个库，找出[2.x.98]的特定用法是否对应于，例如，一个材料指标。
*

* [1.x.67] [1.x.68]。
* [1.x.69] [1.x.70]。



* 这些包含文件已经为你所知。它们声明了处理三角形和自由度枚举的类。
*


* [1.x.71]
*
* 这就是声明创建网格的函数的文件。
*


* [1.x.72]
*
*该文件包含拉格朗日插值有限元的描述。
*


* [1.x.73]
*
* 而这个文件是创建稀疏矩阵的稀疏模式所需要的，如前面的例子中所示。
*


* [1.x.74]
*
* 接下来的两个文件是在每个单元上使用正交法组装矩阵所需要的。下面将对其中声明的类进行解释。
*


* [1.x.75]
*
* 以下是我们在处理边界值时需要的三个包含文件。
*


* [1.x.76]

* 我们现在几乎到了终点。第二组到最后一组include文件是用于线性代数的，我们用它来解决拉普拉斯方程的有限元离散化所产生的方程组。我们将使用向量和全矩阵在每个单元中组装方程组，并将结果转移到稀疏矩阵中。然后我们将使用共轭梯度求解器来解决这个问题，为此我们需要一个预处理程序（在这个程序中，我们使用身份预处理程序，它没有任何作用，但我们还是需要包括这个文件）。
*


* [1.x.77]
*
* 最后，这是用来输出到文件和控制台的。
*


* [1.x.78]
*
* ...这是为了将deal.II命名空间导入到全局范围。
*


* [1.x.79]
*
* [1.x.80] [1.x.81]。


*
* 在这个程序中，我们没有采用以前例子中的程序化编程，而是将所有东西都封装在一个类中。这个类由函数组成，每个函数都执行有限元程序的某些方面，一个`main`函数控制先做什么和后做什么，以及一个成员变量列表。
*

*
* 该类的公共部分相当短：它有一个构造函数和一个从外部调用的函数`run`，其作用类似于`main`函数：它协调该类的哪些操作应以何种顺序运行。该类中的其他一切，即所有真正做事情的函数，都在该类的私有部分。
*


* [1.x.82]
*
* 然后，还有一些成员函数，它们主要是做它们名字所暗示的事情，在介绍中已经讨论过了。因为它们不需要从外部调用，所以它们是这个类的私有函数。
*


*


* [1.x.83]

* 最后我们还有一些成员变量。有一些变量描述了三角形和自由度的全局编号（我们将在这个类的构造函数中指定有限元的确切多项式程度）...
*


* [1.x.84]
*
* ...拉普拉斯方程离散化产生的系统矩阵的稀疏模式和数值的变量...
*


* [1.x.85]
*
* ......和变量，这些变量将持有右手边和解决方案的向量。
*


* [1.x.86]
*
* [1.x.87] [1.x.88]。


*
* 这里是构造函数。它除了首先指定我们需要双线性元素（由有限元对象的参数表示，它表示多项式的程度），并将dof_handler变量与我们使用的三角形相关联之外，没有做更多的工作。(注意，目前三角结构并没有设置网格，但是DoFHandler并不关心：它只想知道它将与哪个三角结构相关联，只有当你使用distribution_dofs()函数试图在网格上分布自由度时，它才开始关心实际的网格。)Step3类的所有其他成员变量都有一个默认的构造函数，它可以完成我们想要的一切。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。


*
* 现在，我们要做的第一件事是生成我们想在其上进行计算的三角形，并对每个顶点进行自由度编号。我们之前在[2.x.99]和[2.x.100]中分别看到过这两个步骤。
*

*
* 这个函数完成了第一部分，创建网格。  我们创建网格并对所有的单元格进行五次细化。由于初始网格（即正方形[2.x.101]）只由一个单元组成，所以最终的网格有32乘以32个单元，总共1024个。
*


*不确定1024是正确的数字？我们可以通过使用三角图上的[2.x.102]函数输出单元格的数量来检查。
*


* [1.x.92]

*

*
* [2.x.103]我们称之为[2.x.104]函数，而不是[2.x.105]这里，[1.x.93]指的是没有被进一步细化的单元。我们强调 "活跃 "这个形容词，因为还有更多的单元，即最细的单元的父单元，它们的父单元等等，直到构成初始网格的一个单元为止。当然，在下一个更粗的层次上，单元格的数量是最细层次上的单元格的四分之一，即256，然后是64、16、4和1。如果你在上面的代码中调用[2.x.106]，你会因此得到一个1365的值。另一方面，单元格的数量（相对于活动单元格的数量）通常没有什么意义，所以没有很好的理由去打印它。
*



*
* [1.x.94] [1.x.95]。


*
* 接下来我们列举所有的自由度，并建立矩阵和向量对象来保存系统数据。枚举是通过使用[2.x.107]来完成的，我们在[2.x.108]的例子中已经看到了。由于我们使用了FE_Q类，并且在构造函数中设置了多项式的度数为1，即双线性元素，这就将一个自由度与每个顶点联系起来。当我们在生成输出时，让我们也看看有多少自由度被生成。
*


* [1.x.96]
*
* 每个顶点应该有一个DoF。因为我们有一个32乘以32的网格，所以DoFs的数量应该是33乘以33，或者1089。
*

*
* 正如我们在前面的例子中所看到的，我们通过首先创建一个临时结构，标记那些可能为非零的条目，然后将数据复制到SparsityPattern对象中，然后可以被系统矩阵使用，来设置一个稀疏模式。
*


* [1.x.97]
*
* 请注意，SparsityPattern对象并不持有矩阵的值，它只存储条目所在的位置。条目本身被存储在SparseMatrix类型的对象中，我们的变量system_matrix就是其中之一。   
* 区分稀疏模式和矩阵是为了让几个矩阵使用相同的稀疏模式。这在这里似乎并不重要，但是当你考虑到矩阵的大小，以及可能需要一些时间来建立稀疏模式时，如果你必须在程序中存储几个矩阵，这在大规模的问题中就变得很重要。
*


* [1.x.98]
*
* 在这个函数中，最后要做的是将右侧向量和解向量的大小设置为正确的值。
*


* [1.x.99]
*
* [1.x.100] [1.x.101]。



*
* 下一步是计算形成线性系统的矩阵和右手边的条目，我们从中计算出解决方案。这是每一个有限元程序的核心功能，我们在介绍中已经讨论了主要步骤。
*

*
*集合矩阵和向量的一般方法是在所有单元上循环，并在每个单元上通过正交计算该单元对全局矩阵和右手边的贡献。现在要认识到的一点是，我们需要实心单元上正交点位置的形状函数值。然而，有限元形状函数和正交点都只定义在参考单元上。因此，它们对我们帮助不大，事实上，我们几乎不会直接从这些对象中查询有关有限元形状函数或正交点的信息。
*

*
* 相反，我们需要的是一种将这些数据从参考单元映射到真实单元的方法。能够做到这一点的类都是从Mapping类派生出来的，尽管人们常常不必直接与它们打交道：库中的许多函数可以将映射对象作为参数，但当它被省略时，它们只是简单地诉诸于标准的双线性Q1映射。我们将走这条路，暂时不去管它（我们将在[2.x.109]、[2.x.110]和[2.x.111]中再讨论这个问题）。
*

*
* 所以我们现在有三个类的集合来处理：有限元、正交和映射对象。这就太多了，所以有一种类型的类可以协调这三者之间的信息交换：FEValues类。如果给这三个对象各一个实例（或两个，以及一个隐式线性映射），它就能为你提供实心单元上正交点的形状函数值和梯度的信息。
*

*
*利用所有这些，我们将把这个问题的线性系统组装在以下函数中。
*


* [1.x.102]
*
* 好的，让我们开始吧：我们需要一个正交公式来评估每个单元格上的积分。让我们采用一个高斯公式，每个方向有两个正交点，即总共有四个点，因为我们是在二维空间。这个正交公式可以精确地积分三度以下的多项式（在一维）。很容易检查出，这对目前的问题来说是足够的。
*


* [1.x.103]
*
* 然后我们初始化我们在上面简单谈过的对象。它需要被告知我们要使用哪个有限元，以及正交点和它们的权重（由一个正交对象共同描述）。如前所述，我们使用隐含的Q1映射，而不是自己明确指定一个。最后，我们必须告诉它我们希望它在每个单元上计算什么：我们需要正交点的形状函数值（对于右手[2.x.112]），它们的梯度（对于矩阵条目[2.x.113]），以及正交点的权重和从参考单元到实际单元的雅各布变换的行列式。   
* 我们实际需要的信息清单是以标志集合的形式给出的，作为FEValues构造函数的第三个参数。由于这些值必须重新计算，或更新，每次我们去一个新的单元，所有这些标志都以前缀[2.x.114]开始，然后指出我们想要更新的实际内容。如果我们想要计算形状函数的值，那么给出的标志是#update_values；对于梯度，则是#update_gradients。雅各布的行列式和正交权重总是一起使用的，所以只计算乘积（雅各布乘以权重，或者简称[2.x.115]）；因为我们需要它们，所以我们也必须列出#update_JxW_values。
*


* [1.x.104]
*
* 这种方法的优点是，我们可以指定在每个单元上实际需要什么样的信息。很容易理解的是，这种方法可以大大加快有限元计算的速度，相比之下，所有的东西，包括二阶导数、单元的法向量等都在每个单元上计算，不管它们是否需要。   
*

*
* [2.x.116] 语法<code>update_values | update_gradients | update_JxW_values</code>对于那些不习惯于用C语言编程位操作多年的人来说并不明显。首先，[2.x.117]是[1.x.105]，也就是说，它接受两个整数参数，这些参数被解释为比特模式，并返回一个整数，其中每个比特都被设置，因为在两个参数中至少有一个对应的比特被设置。例如，考虑操作[2.x.118]（其中前缀[2.x.119]表示该数字将被解释为二进制数字）和[2.x.120] 。通过每个比特，看它是否在其中一个参数中被设置，我们得出[2.x.121]，或者用十进制符号表示，[2.x.122] 。你需要知道的第二个信息是，各种[2.x.123]标志都是有[1.x.106]的整数。例如，假设 [2.x.124] , [2.x.125] , [2.x.126] 。那么<code>update_values | update_gradients | update_JxW_values = 0b10011 = 19</code>。换句话说，我们得到一个数字，即[1.x.107]，其中每个操作正好对应于整数中的一个位，如果等于1，意味着每个单元格上应该更新某一块，如果是0，意味着我们不需要计算它。换句话说，即使[2.x.127]是[1.x.108]，它真正代表的是[1.x.109]。这样的二进制掩码在C语言编程中很常见，但在C++这样的高级语言中也许不是这样，但对当前的目的有很好的作用。
*

*
* 为了在下文中进一步使用，我们为一个将被频繁使用的数值定义了一个快捷方式。也就是每个单元的自由度数的缩写（因为我们是在二维，自由度只与顶点相关，所以这个数字是四，但我们更希望在写这个变量的定义时，不妨碍我们以后选择不同的有限元，每个单元有不同的自由度数，或者在不同的空间维度工作）。   
* 一般来说，使用符号名称而不是硬编码这些数字是个好主意，即使你知道它们，因为例如，你可能想在某个时候改变有限元。改变元素就必须在不同的函数中进行，而且很容易忘记在程序的另一部分做相应的改变。最好不要依赖自己的计算，而是向正确的对象索取信息。在这里，我们要求有限元告诉我们每个单元的自由度数，不管我们在程序中其他地方选择的空间尺寸或多项式程度如何，我们都会得到正确的数字。   
* 这里定义的快捷方式主要是为了讨论基本概念，而不是因为它节省了大量的打字量，然后会使下面的循环更容易阅读。在大型程序中，你会在很多地方看到这样的快捷方式，`dofs_per_cell`就是一个或多或少是这类对象的常规名称。
*


* [1.x.110]

* 现在，我们说我们想逐个单元地组装全局矩阵和向量。我们可以将结果直接写入全局矩阵，但是这样做效率不高，因为访问稀疏矩阵的元素的速度很慢。相反，我们首先在一个小矩阵中计算每个单元的贡献，并在这个单元的计算结束后将其转移到全局矩阵中。我们对右手边的向量也是这样做的。因此，让我们首先分配这些对象（这些是局部对象，所有的自由度都与所有其他的自由度耦合，我们应该使用一个完整的矩阵对象，而不是一个稀疏的对象来进行局部操作；以后所有的东西都将被转移到全局的稀疏矩阵中）。
*


* [1.x.111]
*
* 当集合每个单元的贡献时，我们用自由度的局部编号（即从零到dofs_per_cell-1的编号）来做。然而，当我们将结果转移到全局矩阵时，我们必须知道自由度的全局编号。当我们查询它们时，我们需要为这些数字建立一个从头开始的（临时）数组（关于这里使用的类型，[2.x.128]，见介绍末尾的讨论）。
*


* [1.x.112]
*
* 现在是所有单元格的循环。我们之前已经看到这对三角形的作用。DoFHandler的单元格迭代器与Triangulation的迭代器完全相似，但有关于你所使用的有限元的自由度的额外信息。在自由度处理程序的活动单元上循环的工作方式与三角法相同。   
* 注意，这次我们将单元的类型声明为`const auto &`，而不是`auto`。在第1步中，我们通过标记细化指标来修改三角形的单元。在这里，我们只检查单元格而不修改它们，所以把`cell`声明为`const`是很好的做法，以便执行这个不变性。
*


* [1.x.113]
*
* 我们现在坐在一个单元上，我们希望计算形状函数的值和梯度，以及参考单元和真实单元之间映射的雅各布矩阵的行列式，在正交点上。由于所有这些值都取决于单元格的几何形状，我们必须让FEValues对象在每个单元格上重新计算它们。
*


* [1.x.114]
*
* 接下来，在我们填充之前，将本地单元对全局矩阵和全局右手边的贡献重置为零。
*


* [1.x.115]
*
* 现在是时候开始对单元进行积分了，我们通过对所有的正交点进行循环来完成，我们将用q_index来编号。
*


* [1.x.116]
*
* 首先组装矩阵。对于拉普拉斯问题，每个单元格上的矩阵是对形状函数i和j的梯度的积分。由于我们不进行积分，而是使用正交，这是对所有正交点的积分之和乘以正交点的雅各布矩阵的行列式乘以该正交点的权重。你可以通过使用[2.x.130]得到形状函数[2.x.129]在数字为q_index的正交点上的梯度；这个梯度是一个二维向量（事实上它是张量[2.x.131]类型，这里dim=2），两个这样的向量的乘积是标量乘积，即两个shape_grad函数调用的乘积是点乘。这又要乘以雅各布行列式和正交点权重（通过调用[2.x.132]得到）。最后，对所有形状函数[2.x.133]和[2.x.134]重复这一过程。
*


* [1.x.117]

* 然后我们对右手边做同样的事情。在这里，积分是对形状函数i乘以右手边的函数，我们选择的是常值为1的函数（更有趣的例子将在下面的程序中考虑）。
*


* [1.x.118]
*
* 现在我们有了这个单元的贡献，我们必须把它转移到全局矩阵和右手边。为此，我们首先要找出这个单元上的自由度有哪些全局数字。让我们简单地询问该单元的信息。
*


* [1.x.119]
*
* 然后再次循环所有的形状函数i和j，并将局部元素转移到全局矩阵中。全局数可以用local_dof_indices[i]得到。
*


* [1.x.120]
*
* 再一次，我们对右边的向量做同样的事情。
*


* [1.x.121]

* 现在，几乎所有的东西都为离散系统的求解做好了准备。然而，我们还没有照顾到边界值（事实上，没有迪里切特边界值的拉普拉斯方程甚至不是唯一可解的，因为你可以在离散解中加入一个任意的常数）。因此，我们必须对这种情况做一些处理。   
* 为此，我们首先获得边界上的自由度列表，以及形状函数在那里的值。为了简单起见，我们只对边界值函数进行插值，而不是将其投影到边界上。库中有一个函数正是这样做的。  [2.x.135]它的参数是（省略存在默认值而我们不关心的参数）：DoFHandler对象，以获得边界上自由度的全局数字；边界的组成部分，其中边界值应被内插；边界值函数本身；以及输出对象。   
* 边界的组成部分是指：在许多情况下，你可能只想在边界的一部分施加某些边界值。例如，在流体力学中，你可能有流入和流出的边界，或者在身体变形计算中，身体的夹紧和自由部分。那么你就想用指标来表示边界的这些不同部分，并告诉interpolate_boundary_values函数只计算边界的某一部分（例如夹住的部分，或流入的边界）的边界值。默认情况下，所有的边界都有一个0的边界指标，除非另有规定。如果边界的部分有不同的边界条件，你必须用不同的边界指示器为这些部分编号。然后，下面的函数调用将只确定那些边界指标实际上是作为第二个参数指定的0的边界部分的边界值。   
* 描述边界值的函数是一个类型为Function或派生类的对象。其中一个派生类是[2.x.136]，它描述了一个到处为零的函数（并不意外）。我们就地创建这样一个对象，并将其传递给[2.x.137]函数。   
* 最后，输出对象是一对全局自由度数（即边界上的自由度数）及其边界值（这里所有条目都是零）的列表。这种自由度数到边界值的映射是由[2.x.138]类完成的。
*


* [1.x.122]
*
* 现在我们得到了边界DoF的列表和它们各自的边界值，让我们用它们来相应地修改方程组。这是由以下函数调用完成的。
*


* [1.x.123]
*
* [1.x.124] [1.x.125]。


*
* 下面的函数简单地解决了离散方程的问题。由于该系统对于直接求解器（如高斯消除法或LU分解法）来说是一个相当大的系统，因此我们使用共轭梯度算法。你应该记住，这里的变量数量（只有1089个）对于有限元计算来说是一个非常小的数字，而100.000是一个比较常见的数字。  对于这个数量的变量，直接方法已经无法使用，你不得不使用像CG这样的方法。
*


* [1.x.126]
*
* 首先，我们需要有一个对象，知道如何告诉CG算法何时停止。这是通过使用SolverControl对象来实现的，作为停止标准，我们说：在最多1000次迭代后停止（这远远超过1089个变量的需要；见结果部分以了解真正使用了多少次），如果残差的规范值低于[2.x.139]就停止。在实践中，后一个标准将是停止迭代的标准。
*


* [1.x.127]
*
* 然后我们需要解算器本身。SolverCG类的模板参数是向量的类型，留下空的角括号将表明我们采取的是默认参数（即[2.x.140]）。然而，我们明确地提到了模板参数。
*


* [1.x.128]

* 现在求解这个方程组。CG求解器需要一个前置条件作为它的第四个参数。我们觉得还没有准备好深入研究这个问题，所以我们告诉它使用身份运算作为预处理程序。
*


* [1.x.129]
*
* 现在，求解器已经完成了它的工作，求解变量包含了求解函数的节点值。
*


* [1.x.130]
*
* [1.x.131] [1.x.132]。


*
* 典型的有限元程序的最后一部分是输出结果，也许会做一些后处理（例如计算边界处的最大应力值，或者计算整个流出物的平均通量，等等）。我们这里没有这样的后处理，但是我们想把解决方案写到一个文件中。
*


* [1.x.133]
*
* 为了将输出写入文件，我们需要一个知道输出格式等的对象。这就是DataOut类，我们需要一个该类型的对象。
*


* [1.x.134]
*
* 现在我们必须告诉它从哪里获取它要写的值。我们告诉它使用哪个DoFHandler对象，以及求解向量（以及求解变量在输出文件中的名称）。如果我们有一个以上的矢量想在输出中查看（例如右手边，每个单元格的错误，等等），我们也要添加它们。
*


* [1.x.135]
*
* 在DataOut对象知道它要处理哪些数据后，我们必须告诉它把它们处理成后端可以处理的东西。原因是我们将前端（知道如何处理DoFHandler对象和数据向量）与后端（知道许多不同的输出格式）分开，使用一种中间数据格式将数据从前端传送到后端。数据通过以下函数转换为这种中间格式。
*


* [1.x.136]

* 现在我们已经为实际输出做好了一切准备。只要打开一个文件，用VTK格式把数据写进去就可以了（在我们这里使用的DataOut类中还有很多其他函数，可以把数据写成postscript、AVS、GMV、Gnuplot或其他一些文件格式）。
*


* [1.x.137]
*
* [1.x.138] [1.x.139]。


*
* 最后，这个类的最后一个函数是主函数，它调用[2.x.141]类的所有其他函数。这样做的顺序类似于大多数有限元程序的工作顺序。由于这些名字大多是不言自明的，所以没有什么可评论的。
*


* [1.x.140]
*
* [1.x.141] [1.x.142]。



* 这是该程序的主函数。由于主函数的概念大多是C++编程之前的面向对象时代的遗留物，它通常不做更多的事情，只是创建一个顶层类的对象并调用其原理函数。
*

*
* 最后，该函数的第一行是用来启用deal.II可以产生的一些诊断的输出。  [2.x.142]变量（代表deal-log，而不是de-allog）代表一个流，库的某些部分会将输出写入其中。例如，迭代求解器将产生诊断程序（起始残差、求解器步骤数、最终残差），在运行这个教程程序时可以看到。
*

*
* [2.x.143]的输出可以写到控制台，也可以写到文件，或者两者都写。两者在默认情况下都是禁用的，因为多年来我们已经知道，一个程序只应该在用户明确要求的时候才产生输出。但这是可以改变的，为了解释如何做到这一点，我们需要解释[2.x.144]是如何工作的。当库的个别部分想要记录输出时，它们会打开一个 "上下文 "或 "部分"，这个输出将被放入其中。在想要写输出的部分结束时，人们再次退出这个部分。由于一个函数可以在这个输出部分打开的范围内调用另一个函数，所以输出实际上可以分层嵌套到这些部分。LogStream类[2.x.145]是一个变量，它把这些部分中的每一个称为 "前缀"，因为所有的输出都以这个前缀打印在行的左端，前缀用冒号分开。总是有一个默认的前缀叫做 "DEAL"（暗示了deal.II的历史，它是以前一个叫做 "DEAL "的库的继承者，LogStream类是被带入deal.II的少数代码之一）。
*

*
* 默认情况下，[2.x.146]只输出前缀为零的行。
*
* - 即所有的输出都被禁用，因为默认的 "DEAL "前缀一直存在。但人们可以为应该输出的行设置不同的最大前缀数，以达到更大的效果，事实上在这里我们通过调用[2.x.147]将其设置为两个。这意味着对于所有的屏幕输出，在默认的 "DEAL "之外再推一个前缀的上下文被允许将其输出打印到屏幕上（"控制台"），而所有进一步嵌套的部分如果会有三个或更多的前缀被激活，将写到 [2.x.148] ，但 [2.x.149] 不会将这个输出转发给屏幕。因此，运行这个例子（或者看 "结果 "部分），你会看到解算器的统计数据前缀为 "DEAL:CG"，这是两个前缀。这对于当前程序的上下文来说已经足够了，但是你将在以后看到一些例子（例如，在[2.x.150]中），其中求解器嵌套得更深，你可能通过设置更高的深度来获得有用的信息。
*


* [1.x.143]
* [1.x.144][1.x.145] 。


* 程序的输出看起来如下。
* [1.x.146]
*
* 前两行是我们写给 [2.x.151] 的内容。最后两行是在没有我们干预的情况下由CGsolver生成的。前两行说明了迭代开始时的残差，而最后一行告诉我们求解器需要47次迭代才能使残差的规范值达到5.3e-13，即低于我们在 "solve "函数中设置的阈值1e-12。我们将在下一个程序中说明如何抑制这种输出，这种输出有时对调试很有用，但往往会使屏幕显示变得混乱。
* 除了上面显示的输出，该程序还生成了文件[2.x.152]，该文件采用VTK格式，目前被许多可视化程序广泛使用。
*
* - 包括两个重磅的[1.x.147]和[1.x.148]，它们是当今最常用的程序。
* 使用VisIt，生成一张像这样的解决方案的图片并不十分困难。[2.x.153] 它同时显示了解决方案和网格，根据每一点的解决方案的值，将其提升到[2.x.154] - [2.x.155]的平面之上。当然，这里的解并不特别令人兴奋，但这是拉普拉斯方程所代表的内容和我们为这个程序选择的右手边[2.x.156]的结果。拉普拉斯方程描述了（在许多其他用途中）受外力（也是垂直）作用的膜的垂直变形。在目前的例子中，膜的边界被夹在一个没有垂直变化的方形框架上；因此，一个恒定的力密度将直观地导致膜简单地向上凸起。
*
* --如上图所示。
* VisIt和Paraview都允许对解决方案进行各种类型的可视化处理。一些视频讲座展示了如何使用这些程序。[2.x.157]



* [1.x.149][1.x.150][1.x.151] 。


* 如果你想玩一下这个程序，这里有几个建议。
* [2.x.159] [2.x.160] 改变几何图形和网格。在程序中，我们通过使用[2.x.161]函数生成了一个正方形域和网格。然而，[2.x.162]也有大量的其他函数。试试L形域，环形域，或其他你在那里找到的域。   [2.x.163]
* [2.x.164] 改变边界条件。代码使用[2.x.165]函数来生成零边界条件。然而，你可能想用[2.x.166]而不是[2.x.167]尝试非零常数边界值，以获得单位Dirichlet边界值。在函数命名空间的文档中描述了更多的奇异函数，你可以挑选一个来描述你的特定边界值。   [2.x.168]
* [2.x.169] 修改边界条件的类型。目前，发生的情况是，我们在周围使用迪里希特边界值，因为默认情况是所有边界部分的边界指标为零，然后我们告诉[2.x.170]函数，在所有指标为零的边界部分上将边界值插值为零。   [2.x.171] 如果我们给边界的部分分配不同的指标，我们可以改变这种行为。例如，在调用[2.x.172]后立即尝试这样做
* [1.x.152]

* 这所做的是它首先要求三角计算返回一个指向第一个活动单元的迭代器。当然，作为一个正方形的三角测量的粗略网格，三角测量此时只有一个单元，而且是活动的。接下来，我们要求单元格返回它的第一个面的迭代器，然后我们要求面将该面的边界指标重置为1。接下来的事情就是这样。当网格被细化时，子单元的面会继承其父母的边界指示器，也就是说，即使在最细的网格上，广场一侧的面的边界指示器为1。稍后，当我们要插值边界条件时，[2.x.173]调用将只为那些边界指标为零的面产生边界值，而对那些具有不同边界指标的面则不予理会。这样做的目的是对前者施加Dirichlet边界条件，而对后者施加同质的Neumann条件（即解的法向导数为零，除非在变分等式的右边增加额外的条款来处理潜在的非零Neumann条件）。如果你运行该程序，你会看到这一点。
* 另一种改变边界指标的方法是根据面中心的笛卡尔坐标来标记边界。  例如，我们可以通过检查单元格中心的y坐标是否在一个公差范围内（这里是1e-12），将所有沿顶部和底部边界的单元格标注为边界指标1。
*
* 在调用[2.x.174]后立即尝试这样做，如前所述。
* [1.x.153]
* 尽管这段代码比之前的要长一些，但它对复杂的几何形状很有用，因为它不需要脸部标签的知识。
* [2.x.175] 最后一点的一个小变化是像上面那样设置不同的边界值，但随后对边界指标一使用不同的边界值函数。在实践中，你要做的是为边界指标一增加对[2.x.176]的第二次调用。
* [1.x.154]
* 如果你在这个函数的第一个调用之后立即进行这个调用，那么它将把边界指标为1的面的边界值内插到单位值上，并将这些内插值与先前为边界指标为0计算的值合并。结果是我们将得到不连续的边界值，在正方形的三个边上为0，在第四个边上为1。
* [2.x.177] 观察收敛性。我们将只在[2.x.178]中讨论规范的计算误差，但在这里已经很容易检查计算是否收敛。例如，我们可以评估单点的解的值，并比较不同%的全局细化的值（全局细化的步骤数在上面的[2.x.179]中设定）。为了评估某一点的解决方案，例如在[2.x.180]，我们可以在[2.x.181]函数中添加以下代码。
* [1.x.155]
* 对于1到9个全局细化步骤，我们就会得到以下的点值序列。   [2.x.182] 通过注意到每两个连续值之间的差异减少了大约4倍，我们可以猜测 "正确 "的值可能是[2.x.183] 。事实上，如果我们假设这是正确的值，我们可以证明上面的序列确实显示了[2.x.184]的收敛&mdash; 理论上，收敛顺序应该是[2.x.185]，但领域和网格的对称性可能导致观察到的更好的收敛顺序。
* 这方面的一个小变化是用二次元重复测试。你所需要做的就是在构造函数中把有限元的多项式程度设置为2 [2.x.186] 。
* [2.x.187] 平均值的收敛性。一个不同的方法是计算解的平均数，以观察解是否真的收敛了（收敛到某一数值&mdash；我们无法判断它是否真的是正确的数值！）。为此，在[2.x.188]中添加以下代码。
* [1.x.156]
* 该函数的文档解释了第二和第四个参数的含义，而第一和第三个参数应该是显而易见的。再做一次同样的研究，其中我们改变了全局细化步骤的数量，我们得到以下结果。   [2.x.189] 同样，两个相邻值之间的差异下降了约四倍，表明收敛为 [2.x.190] 。[2.x.191]
*


*[1.x.157][1.x.158]


* %HDF5是一种常用的格式，可以被许多脚本语言（如R或Python）读取。让deal.II产生一些%HDF5文件并不难，这些文件可以被外部脚本用来处理本程序产生的一些数据。以下是一些可能的想法。
*

*[1.x.159][1.x.160]


*为了充分利用自动化，我们首先需要为全局细化步骤的数量引入一个私有变量[2.x.192]，它将被用于输出文件名。在[2.x.193]中，用
* [1.x.161]
* 虽然HDF5 deal.II绑定支持串行和MPI，但是%HDF5 DataOut绑定只支持并行输出。这可以通过添加以下代码来实现。
* [1.x.162]
* 接下来我们改变[2.x.194]的输出例程，如DataOutBase命名空间文档中描述的那样。
* [1.x.163]
* 然后，生成的文件可以像教程的原始版本产生的VTK文件一样被可视化；但是，由于%HDF5是一种更通用的文件格式，它也可以很容易地被脚本语言处理，用于其他目的。
*

*[1.x.164][1.x.165]


* 在输出解决方案之后，该文件可以再次被打开以包括更多的数据集。  这使得我们可以在一个单一的结果文件中保留所有必要的实验信息，然后可以由一些后处理脚本来读取和处理。（关于可能的输出选项的进一步信息，请看[2.x.195]）。
* 为了实现这一点，我们首先在文件中加入必要的头文件。
* [1.x.166]
* 在我们的输出例程的结尾处添加以下几行，将关于某个特定点上的解的值以及解的平均值的信息添加到我们的%HDF5文件中。
* [1.x.167]
*
*


* [1.x.168][1.x.169] 。


* 上述放入%HDF5文件的数据可以通过脚本语言进行进一步的后期处理。在下文中，我们将展示如何使用[1.x.170]，一种在统计数据分析中广泛使用的语言来完成这一工作。(例如，类似的事情也可以在Python中完成。)如果你不熟悉R和ggplot2，你可以看看关于R的数据木工课程[1.x.171]。此外，由于大多数搜索引擎对 "R+主题 "形式的搜索感到困难，我们建议使用专门的服务[1.x.172]来代替。
* R和其他语言之间最突出的区别是赋值运算符（`a = 5`）通常写成`a <- 5`。由于后者被认为是标准的，我们将在我们的例子中也使用它。要在R中打开`.h5`文件，你必须安装[1.x.173]包，它是Bioconductor包的一部分。
* 首先，我们将包括所有必要的包，并看看我们的文件中的数据是如何结构化的。
* [1.x.174]
* 这给出了以下输出
* [1.x.175]
* 数据集可以通过 [2.x.196] 访问。该函数[2.x.197]给出了用于存储单元格的矩阵的尺寸。我们可以看到以下三个矩阵，以及我们添加的两个额外的数据点。[2.x.198] [2.x.199] [2.x.200] ：一个4x1024的矩阵，存储每个单元的（C++）顶点指数 [2.x.201] [2.x.202] ：一个2x1089的矩阵，存储单元顶点的位置值（x，y） [2.x.203] [2.x.204] ：一个1x1089的矩阵，存储每个顶点的解决方案的值 [2.x.205] 现在我们可以使用这些数据来生成各种图。用ggplot2绘图通常分为两步。首先，需要对数据进行处理并添加到一个[2.x.206]中。之后，构建一个[2.x.207]对象，并通过添加绘图元素对其进行操作。
* [2.x.208]包含了我们绘制网格所需的所有信息。下面的代码将所有的数据打包成一个数据框架，用于绘制我们的网格。
* [1.x.176]
*
* 有了这个完成的数据框架，我们就有了绘制网格所需的一切。
* [1.x.177]
*
* 这个文件的内容如下（不是很令人兴奋，但你会明白的）。[2.x.209]
* 我们也可以将解决方案本身可视化，这将看起来更有趣。为了使我们的解决方案的二维伪色图，我们将使用[2.x.210].这个函数需要一个结构化的网格，即在x和y方向上是均匀的，幸运的是我们的数据在这一点上是以正确的方式结构化。
* [1.x.178]
* 现在看来，这将是如下的。[2.x.211]
* 为了绘制收敛曲线，我们需要从1开始用不同的[2.x.212]值多次重新运行C++代码。由于每个文件只包含一个数据点，我们需要对它们进行循环，并将结果串联成一个向量。
* [1.x.179]
* 由于我们对数值本身不感兴趣，而是对与 "精确 "解决方案相比的误差感兴趣，我们将假设我们的最高细化水平是该解决方案，并从数据中省略它。
* [1.x.180]
* 现在我们有了所有可用的数据来生成我们的图。在对数尺度上绘制误差通常是有用的，这在以下代码中完成。
* [1.x.181]
* 这就产生了下面的图，显示了主题值和所选点的解值的误差如何很好地收敛为零。[2.x.213]
*

* [1.x.182][1.x.183] [2.x.214] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-31_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43][1.x.44][1.x.45][1.x.46][1.x.47][1.x.48][1.x.49][1.x.50]
* [2.x.2]
* [1.x.51]


*[1.x.52][1.x.53][1.x.54]


*[1.x.55][1.x.56]


* 这个程序涉及一个有趣的物理问题：如果流体（即液体或气体）经历了由温度差异引起的浮力差异，它是如何表现的？很明显，流体中温度较高（因此较轻）的部分会上升，而温度较低（密度较大）的部分会在重力作用下下沉。
* 在流体运动缓慢到可以忽略惯性效应的情况下，描述这种行为的方程是Boussinesq方程，其内容如下：[1.x.57] 。
* 这些方程属于矢量值问题的范畴（对这一主题的概述可在[2.x.3]模块中找到）。这里，[2.x.4]是速度场，[2.x.5]是压力，[2.x.6]是流体的温度。  [2.x.7]是速度的对称梯度。可以看出，速度和压力解决了描述不可压缩流体运动的斯托克斯方程，这个方程我们以前在[2.x.8]中考虑过；我们将广泛借鉴在该程序中获得的经验，特别是关于高效线性斯托克斯求解器的经验。
* 流体运动的强制项是流体的浮力，表示为密度[2.x.9]、热膨胀系数[2.x.10]、温度[2.x.11]和指向下方的重力矢量[2.x.12]的积。(在[2.x.13]的介绍中给出了右手边的推导。)前两个方程描述了流体如何通过运动对温差做出反应，第三个方程说明了流体运动如何影响温度场：这是一个平流扩散方程，即温度附着在流体颗粒上，在流场中平流，还有一个额外的扩散（热传导）项。在许多应用中，扩散系数相当小，温度方程实际上是传输的，而不是扩散主导的，因此在性质上更像是双曲而不是椭圆；我们在开发一个稳定的微分时必须考虑到这一点。
* 在上述方程中，右侧的[2.x.14]项表示热源，可能是一个空间和时间上变化的函数。  [2.x.15]和[2.x.16]表示粘度和扩散系数，在本教程中我们假定它们是恒定的。当[2.x.17]取决于温度时，更普遍的情况是物理应用中的一个重要因素。大多数材料随着温度的升高而变得更加流动（即[2.x.18]随着[2.x.19]的降低而降低）；有时，如在温度接近熔点的岩石矿物的情况下，[2.x.20]可能在典型的温度范围内发生数量级的变化。
* 我们注意到，上述斯托克斯方程可以通过引入[1.x.58][2.x.21]的非典型长度尺度[2.x.22]、典型温差[2.x.23]、密度[2.x.24]、热扩散率[2.x.25]和热导率[2.x.26]进行非维化。[2.x.27]是一个无量纲数字，它描述了由温差引起的浮力变化所导致的对流的热传输和由热扩散导致的热传输的比率。一个小的瑞利数意味着浮力相对于粘度来说并不强，而且流体运动[2.x.28]足够慢，以至于热扩散[2.x.29]是主要的热传输条款。另一方面，具有高雷利数的流体将显示出主导热传导的强烈对流。
* 对于我们感兴趣的计算热对流的大多数流体来说，瑞利数是非常大的，通常是[2.x.30]或更大。从方程的结构中，我们看到这将导致大的压力差和大的速度。因此，[2.x.31]的对流扩散方程中的对流项也会非常大，要准确解决这个方程，就需要我们选择小的时间步长。因此，具有大雷利数的问题很难用数值来解决，原因类似于当[1.x.60]很大时，解决[1.x.59]很难。
* 请注意，大的瑞利数不一定涉及大的绝对密度。例如，地幔中的雷利数大于[2.x.32]。然而，密度很小：该材料实际上是固体岩石，但它的温度和压力很高，它可以非常缓慢地流动，每年最多只有几厘米的速度。然而，这可能会导致在几百万年的时间尺度内发生混合，这个时间尺度比同样数量的热量通过热传导分布的时间尺度要短得多，而且这个时间尺度与影响地球内部和表面结构的演变有关。
* [2.x.33] 如果你有兴趣使用该程序作为你自己实验的基础，你也会想看看它在[2.x.34]中的续篇。此外，[2.x.35]后来被开发成更大的开源代码ASPECT（见https://aspect.geodynamics.org/），它可以解决现实的问题，在试图将[2.x.36]改造成可以解决任何你想解决的问题之前，你可能想要调查一下。
*

*[1.x.61][1.x.62]


* 由于Boussinesq方程是在流体运动的惯性不起作用的假设下推导出来的，所以流场在每个时间段都完全由当时的浮力差决定，而不是由以前的流场决定。这反映在上面的前两个方程是稳态的斯托克斯方程，不包含时间导数的事实。因此，我们不需要初始条件，也不需要初始条件，因为温度和压力都是如此。另一方面，温度场确实满足有时间导数的方程，所以我们需要初始条件[2.x.37]。
* 至于边界条件：如果[2.x.38]，那么温度满足一个二阶微分方程，需要边界周围所有时间的边界数据。这些可以是规定的边界温度[2.x.39]（Dirichlet边界条件），或规定的热通量[2.x.40]；在本程序中，我们将使用绝缘边界条件，即规定没有热通量。  [2.x.41] .
* 同样，速度场要求我们提出边界条件。如果流体粘在边界上，可以是[2.x.43]上的无滑移无通量条件[2.x.42]；如果流体可以沿边界流动但不能穿过边界，可以是无正常通量条件[2.x.44]，或者是其他任何数量的物理上合理的条件。在这个程序中，我们将使用无正常通量条件。
*

*[1.x.63][1.x.64]


* 与[2.x.45]中解决的方程一样，我们这里有一个微分代数方程（DAE）系统：就时间变量而言，只有温度方程是一个微分方程，而[2.x.46]和[2.x.47]的斯托克斯系统没有时间导数，因此属于代数约束，必须在每个时间瞬间都成立。与[2.x.48]的主要区别是，那里的代数约束是形式为[1.x.65]的混合拉普拉斯系统。
* 而现在我们有一个斯托克斯系统[1.x.66]。
* 其中[2.x.49]是一个类似于拉普拉斯系[2.x.50]的算子，应用于一个矢量场。
* 鉴于与我们在[2.x.51]中所做的相似，我们选择类似的方法可能并不奇怪，尽管我们将不得不对微分算子左上角的算子变化进行调整。
*

*[1.x.67][1.x.68]


* 作为DAE的问题结构允许我们使用与我们在[2.x.52]中已经使用的相同的策略，即我们使用一个时间滞后方案：我们首先解决温度方程（使用一个外推的速度场），然后将新的温度解插入速度方程的右侧。不过，我们在代码中实现这一点的方式是从一个稍微不同的角度来看问题的。我们首先使用前一个时间步长的温度场来求解速度和压力的斯托克斯方程，这意味着我们得到前一个时间步长的速度。换句话说，我们首先将时间步骤[2.x.53]的斯托克斯系统解为[1.x.69]。
* 然后用外推的速度场解温度方程，直到时间[2.x.54]。
* 与[2.x.55]相反，我们在这里使用一个高阶的时间步进方案，即用（单边）差分商[2.x.57]取代时间导数[2.x.56]，[2.x.58]为时间步长。这就得到了离散化的时间温度方程[1.x.71] 。
* 注意温度方程是如何以半显式方式求解的：扩散是隐式处理的，而平流是显式处理的，采用温度和速度的外推法（或前推法），包括刚刚计算的速度[2.x.59]。对当前时间层的正向投影[2.x.60]来自泰勒扩展[2.x.61]。我们需要这个投影来保持BDF-2方案的精度等级。换句话说，我们在显式右手边使用的温度场是当前温度场的二阶近似值&mdash；不完全是显式时间步进方案，但从特征上看也不是太远。
* 温度外推的引入限制了时间步长[1.x.72]，就像在[2.x.62]"[2.x.63]"中一样。（如果我们隐式处理对流项，就不会有这个稳定条件，因为BDF-2方案是A级稳定的，代价是我们需要在每个时间步长建立一个新的温度矩阵）。我们将在[1.x.73]中讨论时间步长的确切选择，但目前重要的是，这个CFL条件意味着时间步长[2.x.64]可能从一个时间步长变为另一个时间步长，我们必须稍微修改上述公式。如果[2.x.65]是当前和前一时间段的时间步长，那么我们使用近似值
* [1.x.74]
*和
* [1.x.75]
*上述方程被概括为：[1.x.76] 。
*
* 其中[2.x.66]表示速度[2.x.67]和温度[2.x.68]外推到时间水平[2.x.69]，使用前两个时间步骤的数值。这不是一个容易读懂的方程，但可以为我们提供所需的高阶精度。作为一致性检查，很容易验证，如果[2.x.70]，它可以还原成与上面相同的方程。
* 最后，我们注意到，选择高阶时隙方案当然会迫使我们在内存中保留更多的时隙；特别是，我们在这里需要保留[2.x.71]，一个我们以前可以抛弃的向量。这似乎是个麻烦事，我们以前只用一阶分步方案就能避免，但正如我们在下面讨论稳定化问题时看到的，我们无论如何都需要这个向量，所以保留它进行时间离散化基本上是免费的，并使我们有机会使用高阶方案。
*

*[1.x.77][1.x.78]


* 与解决混合拉普拉斯方程一样，解决斯托克斯方程需要我们为velocities和pressure变量选择特定的有限元对。因为这在[2.x.72]中已经讨论过了，所以我们只简单介绍一下这个话题：这里，我们使用稳定对[2.x.73]。这些都是连续元素，所以我们可以通过部分积分和用离散函数替代连续函数来形成斯托克斯方程的弱形式，而不存在问题：[1.x.79] 。
*为所有测试函数[2.x.74] 。第一个方程的第一项被认为是张量之间的内积，即[2.x.75].因为这个积中的第二个张量是对称的，[2.x.76]的反对称成分不起作用，如果我们用[2.x.77]的对称梯度代替，它导致完全相同的形式。因此，我们考虑并实施的表述是[1.x.80] 。
*
* 这与我们在[2.x.78]中已经讨论过的完全一样，这里没有什么可说的了。
*

*[1.x.81][1.x.82]


* 更有趣的问题是如何处理温度对流-扩散方程。默认情况下，并不是所有的离散化方程都是同样稳定的，除非我们做一些像上卷、稳定化或者所有这些的事情。实现这一目标的方法之一是使用不连续元素（即我们在[2.x.79]中离散传输方程时使用的FE_DGQ类，或者在[2.x.80]和[2.x.81]中离散压力时使用的FE_DGQ类），并在单元间的界面上定义一个考虑到上绕的流速。如果我们有一个纯粹的平流问题，这可能是最简单的方法。然而，在这里我们也有一些扩散，用不连续元素对拉普拉斯算子进行离散化是很麻烦的，因为有大量的附加项需要在细胞间的每个面上进行积分。不连续元素还有一个缺点，即使用数值通量会带来额外的数值扩散，这种扩散无处不在，而我们真正希望把数值扩散的影响降到最低，只在需要稳定方案的地方应用它。
* 因此，一个更好的选择是在模型中加入一些非线性粘性。从本质上讲，这样做的目的是将温度方程从[1.x.83]的形式转变为[1.x.83]的形式。
*变成类似[1.x.84]的形式。
*其中[2.x.82]是一个额外的粘度（扩散）项，只在冲击和其他不连续的附近起作用。  [2.x.83]的选择方式是，如果[2.x.84]满足原始方程，额外的粘度为零。
* 为了实现这一点，文献中包含了许多方法。我们在此将采用Guermond和Popov开发的一种方法，它建立在一个适当定义的残差和额外粘度的极限程序之上。为此，让我们定义一个残差[2.x.85]如下：[1.x.85] 。
*在这里，我们以后将从[2.x.87]的范围内选择稳定指数[2.x.86]。请注意，如果[2.x.89]满足温度方程，[2.x.88]将为零，因为此时括号内的项将为零。将条款相乘，我们得到以下完全等同的形式：[1.x.86] 。
*
* 有了这个残差，我们现在可以把人工黏度定义为一个分片常数函数，分别定义在直径为[2.x.91]的每个单元上，如下所示：[1.x.87] 。
*
* 这里，[2.x.92]是一个稳定常数（维度分析表明它是无单位的，因此与比例无关；我们将在[1.x.88]中讨论它的选择），[2.x.93]是一个归一化常数，必须有单位[2.x.94]。我们将选择它作为[2.x.95]，其中[2.x.96]是现有温度值的范围（记住，浮力是由温度变化驱动的，而不是绝对温度），[2.x.97]是一个无量纲常数。为了理解为什么这种方法有效，请考虑一下。如果在一个特定的细胞[2.x.98]上，温度场是平滑的，那么我们希望那里的残差很小（事实上是在[2.x.99]的数量级上），注入人工扩散的稳定项在那里将是大小为[2.x.100]&mdash；也就是说，相当小，就像我们希望它在没有必要的额外扩散的时候那样。另一方面，如果我们处于或接近温度场的不连续状态，那么它将是大的；[2.x.101]定义中的最小操作将确保稳定化具有大小[2.x.102]&mdash；确保方案稳定性的最佳人工粘性量。
* Guermond和Popov的计算表明，这种形式的稳定化实际上比周围的大多数其他稳定化方案（例如流线型扩散，仅举最简单的一种）表现得更好。此外，对于[2.x.103]，他们甚至可以证明，它比流线型扩散产生更好的线性传输方程收敛顺序。对于[2.x.104]，目前还没有理论结果，但数值测试表明，其结果比[2.x.105]好得多。
* 一个更实际的问题是如何将这种人工扩散引入我们想解决的方程中。请注意，当时的粘度[2.x.106]是随温度变化的，所以我们要解决的方程在[2.x.107]中是非线性的&mdash; 不是人们所希望的稳定方程的简单方法，如果我们意识到[2.x.108]在[2.x.109]中是不可微分的，那就更不是了。然而，我们没有理由感到绝望：我们仍然必须进行时间离散，而且我们不能明确地处理这个术语。
* 在稳定参数的定义中，我们用[2.x.110]对时间导数进行近似。这种近似只利用了可用的时间数据，这也是我们需要存储前两个时间步骤的数据的原因（这使我们能够使用BDF-2方案而不需要额外的存储成本）。我们现在可以简单地在[2.x.111]处评估其余的项，但这样一来，离散残差就只是一个向后的欧拉近似值，而这只是一阶精确。因此，如果是平滑解，尽管外部BDF-2方案和空间FE离散化的时间精度为二阶，但残差仍为[2.x.112]阶。这当然不是我们想要的（事实上，我们希望在解决方案表现良好的区域有较小的残差），所以需要更谨慎一些。这个问题的关键是观察我们构建的第一导数实际上是以[2.x.113]为中心的。如果我们通过使用近似值[2.x.115]来评估[2.x.114]处的所有空间项，我们就可以得到所需的二阶精确的剩余计算，这意味着我们将非线性粘度作为这个中间温度的函数来计算，[2.x.116] 。请注意，这种对残余物的评估不外乎是Crank-Nicholson方案，所以我们可以肯定，现在一切都很好。人们可能会想，现在的数值粘度没有在[2.x.117]的时候被评估（相对于方程的其余部分），这是否是一个问题。然而，这种抵消是不严谨的。对于平滑解，[2.x.118]将连续变化，所以时间偏移的误差比非线性粘度本身要小[2.x.119]倍，也就是说，它是一个被遗漏的小的高阶贡献。这很好，因为该术语本身已经达到了平滑区域的分化误差水平。
* 使用上面介绍的BDF-2方案，对于较简单的均匀时间步长为[2.x.120]的情况，可以得出：[1.x.89] 。
* 在这个方程的左边，仍然是来自时间导数和原始（物理）扩散的项，我们以隐式处理（这实际上是一个很好的项：从左边产生的矩阵是质量矩阵和拉普拉斯矩阵的倍数&mdash；两者都是正定的，如果时间步长[2.x.121]很小，和很容易反转）。在右手边，第一行的条款是时间导数的结果；第二行是时间[2.x.122]的人工扩散；第三行包含对流条款，第四行是来源。请注意，人工扩散对当前时间的外推温度的作用，与我们在时间步进一节中讨论的平流作用相同。
* 我们在现实中必须使用的非均匀时间步长的形式有点复杂（这就是为什么我们首先展示了较简单的形式），内容是：[1.x.90] 。
*
* 在解决了所有这些问题之后，弱形式自然而然地从最后一个方程中显示的强形式中产生，我们立即得出了离散化方程的弱形式：[1.x.91] 。
*对于所有离散测试函数 [2.x.123] 。在这里，扩散项已经被部分整合，而且我们已经使用了我们将不施加热通量， [2.x.124] 。
* 这就导致了矩阵方程的形式[1.x.92] 。
* 考虑到左边的矩阵结构（两个正定矩阵之和），可以用共轭梯度法轻松求解。
*


*[1.x.93][1.x.94]


* 如上所述，我们解决速度/压力联合系统和温度联合系统的方法是使用算子分割法，即首先用旧的温度场解决速度和压力的斯托克斯系统，然后用刚计算出的速度场解决新的温度场。关于算子分割方法的更广泛的讨论可以在 [2.x.125] 中找到）。
*

*[1.x.95][1.x.96] 。


* 解决来自斯托克斯系统的线性方程已经在 [2.x.126] 中进行了详细讨论。特别是，在该方案的结果部分，我们讨论了一些替代性的线性求解策略，结果发现这些策略比原来的方法更有效。在那里，我们发现最好的替代方法是使用GMRES求解器，以涉及Schur补数的块矩阵为前提条件。具体来说，斯托克斯算子导致了一个块状结构矩阵[1.x.97] 。
*正如那里所讨论的，一个好的预处理程序是[1.x.98] 。
*其中[2.x.127]是斯托克斯算子的舒尔补码[2.x.128]。当然，这个预处理程序是没有用的，因为我们不能形成矩阵的各种倒数，但我们可以用下面的方法作为预处理程序：[1.x.99] 。
*其中[2.x.129]是对逆矩阵的近似值。特别是，事实证明[2.x.130]在频谱上等同于质量矩阵，因此用适用于压力空间上的质量矩阵的CG求解器取代[2.x.131]是一个不错的选择。与[2.x.132]略有不同的是，我们在动量方程中有一个系数[2.x.133]，通过与那里相同的推导，我们应该得出结论，我们应该使用的是有条目[2.x.134]的加权质量矩阵。
* 在[2.x.137]中，我们使用了[2.x.138]的稀疏LU分解（使用SparseDirectUMFPACK类）。]的[2.x.139]&mdash；perfect preconditioner&mdash；在2D中，但对于3D来说，内存和计算时间通常不足以实际计算这个分解；因此，我们在3D中只使用不完全LU分解（ILU，使用SparseILU类）。
* 对于这个程序，我们希望能走得更远一些。为此，请注意，矢量场上的对称化双线性形式[2.x.140]与非对称化版本[2.x.141]相差不大（注意，在这种形式中，因子2已经消失了）。然而，后者的优点是测试函数的[2.x.142]矢量分量没有耦合（好吧，几乎没有，见下文），也就是说，得到的矩阵是块对角线的：每个矢量分量有一个块，这些块中的每个都等于这个矢量分量的拉普拉斯矩阵。因此，假设我们以这样的方式排列自由度，即首先对速度的所有[2.x.143]-分量进行编号，然后是[2.x.144]-分量，然后是[2.x.145]-分量，那么与这种稍有不同的双线性形式相关的矩阵[2.x.146]具有[1.x.100]形式
* 其中[2.x.147]是一个拉普拉斯矩阵，其大小等于与矢量值速度的每个分量相关的形状函数的数量。有了这个矩阵，我们就可以将速度矩阵[2.x.148]的预处理定义如下：[1.x.101] 。
* 其中[2.x.149]是拉普拉斯矩阵的预处理程序&mdash;我们非常清楚如何建立良好的预处理程序!
* 在现实中，故事并不那么简单。为了使矩阵[2.x.150]明确，我们需要通过应用边界条件使各个块[2.x.151]明确。我们可以尝试通过在边界周围施加迪里希特边界条件来做到这一点，如果后者的矩阵是由斯托克斯问题产生的，我们在域的周围也有迪里希特边界条件，也就是说，如果我们执行[2.x.154]，那么如此定义的预处理程序[2.x.152]就会变成[2.x.153]的良好预处理。
* 不幸的是，这个 "如果 "是一个 "如果和唯一的如果"：在下面的程序中，我们希望使用[2.x.155]形式的无流量边界条件（即允许平行于边界的流量%，但没有通过边界的流量）。在这种情况下，事实证明，上面定义的块状对角线矩阵并不是一个好的预处理条件，因为它忽略了边界上的分量的耦合。因此，更好的方法是如果我们把矩阵[2.x.156]建立为矢量拉普拉斯矩阵[2.x.157]，然后应用与我们应用于[2.x.158]相同的边界条件。如果这是一个围绕领域的迪里希特边界条件，[2.x.159]将像上面那样解耦为三个对角线块，如果边界条件是[2.x.160]的形式，那么这将在边界引入自由度的耦合，但只是在那里。事实上，这比上面介绍的那个预处理程序要好得多，而且几乎具有我们希望得到的所有好处。
*

* 总结这整个故事，我们可以看到。[2.x.161] [2.x.162] 与我们在[2.x.164]中从对称梯度产生的原始矩阵[2.x.163]构建的预处理器相比，我们不得不期待基于拉普拉斯双线性形式的预处理器表现得更糟，因为它没有考虑到矢量分量之间的耦合。
* [2.x.165] 另一方面，拉普拉斯矩阵的预处理程序通常更成熟，比矢量问题的预处理程序性能更好。例如，在写这篇文章的时候，代数%多重网格（AMG）算法对于标量问题已经非常成熟，但对于矢量问题却不是这样。
* [2.x.166] 在建立这个预处理程序时，我们将不得不建立起矩阵[2.x.167]及其预处理程序。虽然这意味着我们必须存储一个之前不需要的额外矩阵，但与存储耦合矩阵[2.x.169]的预处理程序相比，预处理程序[2.x.168]可能需要更少的内存。这是因为矩阵[2.x.170]在所有对应于内部自由度的行中每行只有三分之一的条目，并且只在边界条件引入耦合的部分包含向量分量间的耦合。因此，存储该矩阵是比较便宜的，我们可以预期，计算和存储预处理程序[2.x.171]也将比为完全耦合的矩阵做这些事情便宜得多。[2.x.172]
*


*[1.x.102][1.x.103]


* 这是最简单的部分。温度方程的矩阵具有[2.x.173]的形式，其中[2.x.174]是温度空间的质量和刚度矩阵，[2.x.175]是与时间步长和当前及前一个时间步长有关的常数。这是不对称正定和对称正半定矩阵之和，其结果也是对称正定的。此外，[2.x.176]是一个与时间步长成正比的数字，因此只要网格很细，就会变得很小，从而减弱当时条件不良的刚度矩阵的影响。
* 因此，用共轭梯度算法反演这个矩阵，使用一个简单的预处理程序，与反演斯托克斯矩阵相比，是微不足道和非常便宜的。
*


*[1.x.104][1.x.105]


*[1.x.106][1.x.107] 。


* 下面的程序中值得事先解释的一件事是使用了两个不同的DoFHandler对象。如果我们看一下上述方程的结构和它们的求解方案，就会意识到没有什么共同点可以使斯托克斯部分和温度部分保持一致。在以前所有讨论[2.x.177]"矢量值问题 "的教程程序中，我们总是只使用一个有几个矢量分量的单一无限元素和一个DoFHandler对象。有时，我们将得到的矩阵分解成块，以方便特定的求解方案；例如，在目前程序所基于的斯托克斯方程的[2.x.178]程序中就是如此。
* 当然，我们在这里也可以这样做。我们将得到的线性系统看起来像这样：[1.x.108] 。
* 这方面的问题是。我们从未同时使用整个矩阵。事实上，它从未真正存在于同一时间。如上所述，[2.x.179]和[2.x.180]依赖于已经计算出的解决方案[2.x.181]，在第一种情况下，通过时间步骤（依赖于[2.x.182]，因为它必须满足一个CFL条件）。因此，我们只有在已经解决了左上角[2.x.183]块斯托克斯系统后才能组装它，而一旦我们转向温度方程，我们就不再需要斯托克斯部分了；为一个在任何特定时间都不会以整体存在于内存中的矩阵建立网络对象的事实导致我们在[2.x.184]中跳过一些圈套，所以我们不要重复这类错误。此外，我们并不直接建立矩阵[2.x.185]：因为当我们进入温度方程时，我们已经知道了[2.x.186]，而且因为我们必须在这个时候组装右手边的[2.x.187]，我们只是将项[2.x.188]移到右手边并与所有其他项一起组装。这意味着矩阵中不存在温度变量和斯托克斯变量耦合的部分，因此所有自由度的全局列举不再重要：如果我们有所有斯托克斯自由度的列举，以及所有温度自由度的独立列举就足够了。
* 从本质上讲，将[1.x.109]放入一个块状矩阵中没有什么用处（当然对于[2.x.189]斯托克斯部分也有同样好的理由这样做），或者说，将所有东西放入同一个DoFHandler对象中。
* 但这样做是否有[1.x.110]的好处？这些问题是存在的，尽管它们一开始可能并不明显。主要的问题是，如果我们需要创建一个包含速度、压力和温度变形函数的全局无限元素，并使用它来初始化DoFHandler。但是我们也用这个无限元素对象来初始化我们使用的所有FEValues或FEFaceValues对象。这可能看起来不是什么大问题，但是想象一下，例如，当我们评估我们需要用来计算人工粘度[2.x.191]的残差[2.x.190]时会发生什么。  为此，我们需要温度的拉普拉斯，我们用形状函数的二阶导数（Hessians）张量来计算（我们必须给FEValues对象加上[2.x.192]标志）。现在，如果我们有一个包含速度、压力和温度的形状函数的有限性，这意味着我们必须计算[1.x.111]形状函数的Hessians，包括速度的许多高阶形状函数。这是我们不需要的大量计算，事实上，如果要这样做（正如我们在程序的早期版本中所做的那样），组装右手边需要大约四分之一的整体计算时间。
* 所以我们要做的是使用两个不同的有限元对象，一个用于斯托克斯成分，一个用于温度。这样就有了两个不同的DoFHandlers，两个稀疏模式和两个用于斯托克斯和温度部分的矩阵，等等。每当我们要组装包含温度和斯托克斯形状函数的东西时（特别是斯托克斯和温度方程的右侧），我们就使用两个FEValues对象，用两个单元格迭代器进行初始化，我们通过与同一个三角形对象相关的两个DoFHandler对象进行%的平行移动。对于这两个FEValues对象，我们当然使用相同的正交对象，以便我们可以在同一组正交点上进行迭代，但是每个FEValues对象将只根据它实际需要计算的内容获得更新标志。特别是，当我们像上面那样计算残差时，我们只要求得到斯托克斯形状函数的值，但也要求得到温度形状函数的Hessians &mdash；确实便宜得多，而且事实证明：组装温度方程的右侧现在是程序的一个组成部分，几乎无法测量。
* 有了这些变化，对程序进行计时的结果是，只有以下操作与整个运行时间相关。[2.x.193] [2.x.194] 解决斯托克斯系统：占运行时间的72%。   [2.x.195] 使用Trilinos ML软件包组装Stokes预处理程序和计算代数多网格层次：占运行时间的11%。   [2.x.196] 函数[2.x.197] ：占总体运行时间的7%。   [2.x.198] 组装斯托克斯和温度右侧向量以及组装矩阵。7%.[2.x.199] 实质上这意味着除了代数多重网格外，所有的瓶颈都已被消除。
*


*[1.x.112][1.x.113]


* 与我们在[2.x.200]和[2.x.201]中使用PETSc来支持我们的线性代数需要一样，我们在这个程序中使用了[1.x.114]库的接口（安装说明见deal.II README文件）。Trilinosis是一个非常大的集合，包含了所有与线性和非线性代数有关的东西，以及围绕这些东西的各种工具（看起来它在未来也会在许多其他方向上发展）。
* 使用Trilinos的主要原因，与我们探索PETSc类似，是它是一个非常强大的库，比deal.II自己的线性代数库提供更多的工具。这尤其包括在一个集群上使用MPI进行并行工作的能力，以及更多种类的预处理程序。在后一类中，最有趣的能力之一是Trilinos ML包的存在，它实现了代数多栅（AMG）方法。我们将使用这个预处理程序来预处理动量方程的二阶运算器部分。在[2.x.202]中，我们将利用这里讨论的相同问题，探讨以%并行方式解决问题的能力。
* 我们在[2.x.203]和[2.x.204]中使用的PETSc无疑是一个强大的库，它提供了大量处理矩阵、向量、迭代求解器和预处理器的函数，还有很多其他的东西，其中大部分在%并行中运行得很好。然而，它比Trilinos晚了几年，是用C语言编写的，通常不像其他一些库那样容易使用。因此，deal.II也获得了与Trilinos的接口，Trilinos与PETSc有很多相同的功能。然而，它是一个年轻了几年的项目，是用C++编写的，并且是由那些通常非常重视软体设计的人编写的。
*

*[1.x.115][1.x.116]


* 我们在这里要解决的情况如下：我们用[2.x.205]解决上述的Boussinesq方程，即一个相对缓慢运动的流体，它几乎没有热扩散传导性，主要通过对流来传输热量。在边界上，我们将要求速度（[2.x.206]）和温度（[2.x.207]）没有正态流量。这是[2.x.208]导言中讨论的情况之一，它固定了速度的一个分量，同时允许流动与边界平行%。还有[2.x.209]分量需要固定，即法向应力的切向分量；对于这些分量，我们选择同质条件，这意味着我们不需要任何特殊条件。初始条件只对温度场是必要的，我们选择它为恒定的零。
* 然后，问题的演变完全由温度方程的右侧[2.x.210]驱动，即由热源和热汇驱动。在这里，我们选择了一个在圣诞节讲座前发明的设置：美国的教室里当然禁止使用真实的蜡烛，但允许使用虚拟的蜡烛。因此，我们选择了三个球形的热源，不等距地靠近领域的底部，模仿三个蜡烛的样子。位于这些热源处的流体，最初处于静止状态，然后被加热，随着温度的升高，获得浮力，上升；更多的流体被拖上去并通过热源，导致三个热羽上升，直到它们被外面下沉的流体循环所捕获，取代了因加热而上升的空气。
*

* [1.x.117] [1.x.118]。
* [1.x.119] [1.x.120]。
*

*
* 像往常一样，第一步是包括这些著名的deal.II库文件和一些C++头文件的功能。
*


* [1.x.121]
*
* 然后我们需要包括一些头文件，这些文件提供了矢量、矩阵和预处理类，实现了各自Trilinos类的接口。特别是，我们将需要基于Trilinos的矩阵和向量类的接口，以及Trilinos预处理程序。
*


* [1.x.122]
*
* 最后，这里有几个C++头文件还没有被上述头文件之一所包含。
*


* [1.x.123]
*
* 在这个顶层事项的最后，我们将所有deal.II的名字导入全局命名空间。
*


* [1.x.124]
*
* [1.x.125] [1.x.126]。


*
* 同样，程序的下一阶段是定义方程数据，即各种边界条件、右手边和初始条件（记住，我们要解决的是一个随时间变化的系统）。这个定义的基本策略与 [2.x.211] 中的相同。不过关于细节，还是有一些区别。
*

*
* 首先，我们不对速度设置任何不均匀的边界条件，因为正如介绍中所解释的，我们将使用无流条件 [2.x.212] 。所以剩下的是[2.x.213]应力张量法线分量的切向部分的条件，[2.x.214]；我们假定这些分量的值是同质的，即一个自然的边界条件，不需要具体的动作（它作为一个零项出现在弱形式的右边）。   
* 对于温度[2.x.215]，我们假设没有热能通量，即[2.x.216]。这也是一个边界条件，不需要我们做任何特别的事情。   
* 其次，我们必须设置温度的初始条件（速度和压力不需要初始条件，因为我们在这里考虑的准稳态情况下的斯托克斯方程没有速度或压力的时间导数）。在这里，我们选择了一个非常简单的测试案例，即初始温度为零，所有的动力学都由温度的右手边驱动。   
* 第三，我们需要定义温度方程的右手边。我们选择它在域的底部某处的三个圆圈（或三维球体）内是恒定的，如介绍中所解释的那样，在域外是零。   
* 最后，或者说首先，在这个命名空间的顶部，我们定义我们需要的各种材料常数（ [2.x.217] ，密度 [2.x.218] 和热膨胀系数 [2.x.219] ）。
*


* [1.x.127]

* [1.x.128] [1.x.129]。


*
* 本节介绍了一些用于求解斯托克斯系统线性方程的对象，我们需要在每个时间步长中求解。这里使用的许多想法与[2.x.220]相同，其中介绍了基于Schur补数的预处理和求解器，实际接口来自[2.x.221]（特别是[2.x.222]的 "结果 "部分的讨论，其中我们介绍了直接Schur补数方法的替代方法）。然而，请注意，在这里我们不使用Schur补数来解决Stokes方程，尽管预处理程序中出现了一个近似的Schur补数（压力空间的质量矩阵）。
*


* [1.x.130]
*
* [1.x.131] [1.x.132]。



* 该类是一个接口，用于计算 "倒置 "矩阵对向量的作用（使用[2.x.223]操作），其方式与[2.x.224]中的相应类相同：当要求该类对象的乘积时，我们使用CG方法解决与该矩阵有关的线性方程组，通过（模板化）类[2.x.225]的前置条件器加速。     
* 与[2.x.226]中同一类别的实现略有不同，我们让[2.x.227]函数接受任何类型的向量类型（但是，如果矩阵不允许与这种向量进行矩阵-向量乘积，它将产生编译器错误）。     
* 其次，我们捕捉解算器可能抛出的任何异常。原因如下。在调试这样的程序时，偶尔会犯一个错误，即把一个不确定或不对称的矩阵或预处理程序传递给当前的类。在这种情况下，求解器将不能收敛并抛出一个运行时异常。如果在这里没有被捕捉到，它将在调用堆栈中传播，最终可能会在[2.x.228]中被发现，在那里我们将输出一个错误信息，说CG求解器失败了。那么问题来了。哪个CG求解器？倒置质量矩阵的那个？用拉普拉斯算子反转左上角块的那个？还是在当前代码中我们使用线性求解器的其他几个嵌套位置中的一个CG求解器？在运行时异常中没有这方面的指示，因为它没有存储调用的堆栈，我们通过堆栈到达了产生异常的地方。     
* 因此，与其让异常自由传播到[2.x.229]，不如让我们意识到，如果内部求解器失败了，外部函数能做的很少，不如将运行时异常转换为一个断言，该断言失败后会触发对[2.x.230]的调用，使我们能够在调试器中追溯我们是如何到达当前位置的。
*


* [1.x.133]
*
* [1.x.134] [1.x.135]。


*
* 这是在介绍中详细描述的Schur补码预处理的实现。与[2.x.231]和[2.x.232]相反，我们使用GMRES一次性解决块系统，并使用块结构矩阵的Schur补码来建立一个良好的预处理器。     
* 让我们看一下介绍中描述的理想的预处理矩阵[2.x.233]。如果我们在线性系统的求解中应用这个矩阵，迭代式GMRES求解器的收敛性将受矩阵[1.x.136]的制约，这确实非常简单。基于精确矩阵的GMRES求解器将在一次迭代中收敛，因为所有的特征值都是相等的（任何Krylov方法最多需要多少次迭代就有多少个不同的特征值）。Silvester和Wathen提出了这样一个用于受阻斯托克斯系统的预处理程序（"稳定的斯托克斯系统的快速迭代解第二部分。  Using general block preconditioners", SIAM J. Numer.Anal., 31 (1994), pp.1352-1367）。)     
* 用[2.x.235]代替[2.x.234]可以保持这种精神：乘积[2.x.236]仍将接近于特征值为1的矩阵，其分布不取决于问题的大小。这让我们希望能够得到一个与问题规模无关的GMRES迭代次数。     
*已经通过[2.x.237]和[2.x.238]教程的deal.II用户当然可以想象我们将如何实现这一点。  我们用一些由InverseMatrix类构建的近似逆矩阵来代替[2.x.239]中的精确逆矩阵，而逆舒尔补码将由压力质量矩阵[2.x.240]来近似（如介绍中提到的由[2.x.241]加权）。正如在[2.x.242]的结果部分所指出的，我们可以通过应用一个预处理程序来取代[2.x.243]的精确逆，在这种情况下，如介绍中所解释的那样，在一个矢量拉普拉斯矩阵上。这确实增加了（外部）GMRES的迭代次数，但仍然比精确的逆要便宜得多，因为[2.x.244]的每个[2.x.245]外部求解器步骤（使用AMG预处理器）需要20到35次CG迭代。     
* 考虑到上述解释，我们定义了一个具有[2.x.246]功能的预处理类，这就是我们在程序代码中进一步与通常的求解器函数互动所需要的全部内容。     
* 首先是声明。这与[2.x.247]中Schur补码的定义相似，不同的是我们在构造函数中需要更多的预处理程序，而且我们在这里使用的矩阵是建立在Trilinos之上的。
*


* [1.x.137]
*
* 当使用[2.x.248]或[2.x.249]时，Vector使用IndexSet进行初始化。IndexSet不仅用于调整[2.x.250]的大小，而且还将[2.x.251]中的一个索引与一个自由度联系起来（更详细的解释见[2.x.252]）。函数complete_index_set()创建了一个IndexSet，每个有效的索引都是这个集合的一部分。请注意，这个程序只能按顺序运行，如果并行使用，将抛出一个异常。
*


* [1.x.138]
*
* 接下来是[2.x.253]函数。我们以三个连续的步骤实现上述[2.x.254]的动作。  在公式中，我们要计算[2.x.255]，其中[2.x.256]都是有两个块成分的向量。     
* 第一步用矩阵[2.x.257]的预处理乘以矢量的速度部分，即我们计算[2.x.258] 。  然后将得到的速度矢量乘以[2.x.259]并减去压力，即我们要计算[2.x.260] 。这第二步只作用于压力向量，由我们矩阵类的残差函数完成，只是符号不对。因此，我们改变临时压力向量中的符号，最后乘以反压力质量矩阵，得到最终的压力向量，完成我们对斯托克斯预处理的工作。
*


* [1.x.139]
*
* [1.x.140] [1.x.141]。



* 定义解决随时间变化的Boussinesq问题的顶层逻辑的类的定义主要是基于[2.x.261]的教程程序。主要的区别在于，现在我们还必须求解温度方程，这迫使我们为温度变量准备第二个DoFHandler对象，以及当前和之前时间步骤的矩阵、右手边和求解向量。正如介绍中提到的，所有的线性代数对象都将使用相应的Trilinos功能的包装器。   
* 这个类的成员函数让人想起[2.x.262]，在那里我们也使用了一个交错的方案，首先解决流动方程（这里是斯托克斯方程，在[2.x.263]中是达西流动），然后更新平流量（这里是温度，那里是饱和度）。新的函数主要涉及到确定时间步长，以及人工粘性稳定的适当大小。   
* 最后三个变量表示在下一次调用相应的建立函数时，是否需要重新建立各种矩阵或预处理程序。这使得我们可以将相应的[2.x.264]移到相应的函数中，从而保持我们的主[2.x.265]函数的简洁和易读。
*


* [1.x.142]
*
* [1.x.143] [1.x.144]。



* [1.x.145] [1.x.146] 。
* 这个类的构造函数是 [2.x.266] 中构造函数的扩展。我们需要添加涉及温度的各种变量。正如介绍中所讨论的，我们将再次使用[2.x.267]（Taylor-Hood）元素来表示斯托克斯部分，并使用[2.x.268]元素表示温度。然而，通过使用存储斯托克斯和温度有限元的多项式程度的变量，可以很容易地持续修改这些元素的程度，以及下游使用的所有正交公式。此外，我们还初始化了时间步长，以及矩阵组合和预处理的选项。
*


* [1.x.147]
*
* [1.x.148] [1.x.149]。


*
* 开始这个类的真正功能是一个辅助函数，它确定域中（实际上是正交点处）的最大（[2.x.269]）速度。它是如何工作的，对所有已经达到本教程这一点的人来说应该是比较明显的。请注意，由于我们只对速度感兴趣，我们不使用[2.x.270]来获取整个斯托克斯解的值（速度和压力），而是使用[2.x.271]来提取速度部分。这样做还有一个好处，就是我们得到的是张量<1,dim>，而不是向量<double>中的一些分量，这样我们就可以马上用[2.x.272]函数来处理它，得到速度的大小。   
*唯一值得思考一下的是如何选择我们在这里使用的正交点。因为这个函数的目标是通过查看每个单元上的正交点来找到域上的最大速度。所以我们应该问，我们应该如何最好地选择每个单元上的这些正交点。为此，回顾一下，如果我们有一个单一的[2.x.273]场（而不是高阶的矢量值场），那么最大值将在网格的一个顶点达到。换句话说，我们应该使用QTrapezoid类，它的正交点只在单元的顶点。   
* 对于高阶形状函数，情况更为复杂：最大值和最小值可能在形状函数的支持点之间的点上达到（对于通常的[2.x.274]元素，支持点是等距的Lagrange插值点）；此外，由于我们正在寻找一个矢量值量的最大幅度，我们更不能肯定地说潜在的最大点集合在哪里。尽管如此，从直觉上讲，如果不能证明，拉格朗日插值点似乎是比高斯点更好的选择。   
* 现在有不同的方法来产生一个正交公式，其正交点等于有限元的插值点。一种选择是使用[2.x.275]函数，将输出减少到一组唯一的点以避免重复的函数评估，并使用这些点创建一个正交对象。另一个选择，这里选择的是使用QTrapezoid类，并将其与QIterated类相结合，该类在每个坐标方向的若干子单元上重复QTrapezoid公式。为了覆盖所有的支持点，我们需要将其迭代[2.x.276]次，因为这是使用中的斯托克斯元素的多项式程度。
*


* [1.x.150]
*
* [1.x.151] [1.x.152]。


*
* 接下来是一个函数，确定从前两个时间步长推算到当前时间步长时，[2.x.277]内正交点的最低和最高温度。我们在计算人工粘性参数[2.x.278]时需要这个信息，正如在介绍中所讨论的。   
* 外推温度的公式是 [2.x.279] 。计算它的方法是在所有正交点上循环，如果当前值比前一个值大/小，则更新最大和最小值。在对所有正交点进行循环之前，我们将存储最大和最小值的变量初始化为可表示为双数的最小和最大数字。然后我们就知道它比最小/最大值大/小，并且所有正交点的循环最终会用正确的值更新初始值。   
* 这里唯一值得一提的其他复杂情况是，在第一个时间步骤中，[2.x.280]当然还不能使用。在这种情况下，我们只能使用[2.x.281]，这是我们从初始温度得到的。作为正交点，我们使用与前一个函数相同的选择，但不同的是，现在重复的数量由温度场的多项式程度决定。
*


* [1.x.153]
*
* [1.x.154] [1.x.155]。


*
* 最后一个工具函数计算单元[2.x.282]上的人工粘度参数[2.x.283]，作为外推温度、其梯度和Hessian（二阶导数）、速度、当前单元正交点上的所有右手[2.x.284]和其他各种参数的函数，如介绍中详细描述。   
* 这里有一些值得一提的通用常数。首先，我们需要固定[2.x.285]；我们选择[2.x.286]，这个选择在本教程程序的结果部分有详细讨论。其次是指数[2.x.287]；[2.x.288]似乎对目前的程序来说工作正常，尽管选择[2.x.289]可能会有一些额外的好处。最后，有一件事需要特别说明。在第一个时间步骤中，速度等于零，[2.x.290]的公式没有定义。在这种情况下，我们返回[2.x.291]，这个选择无疑更多的是出于启发式的考虑（不过，它与第二个时间步骤中大多数单元的返回值处于同一数量级）。   
* 根据介绍中讨论的材料，该函数的其余部分应该是很明显的。
*


* [1.x.156]
*
* [1.x.157] [1.x.158]
* 这是一个函数，用来设置我们这里的DoFHandler对象（一个用于斯托克斯部分，一个用于温度部分），以及将本程序中线性代数所需的各种对象设置为正确的尺寸。它的基本操作与我们在 [2.x.292] 中的操作相似。   
* 该函数的主体首先列举了斯托克斯和温度系统的所有自由度。对于斯托克斯部分，自由度被排序以确保速度优先于压力自由度，这样我们就可以将斯托克斯矩阵划分为[2.x.293]矩阵。作为与[2.x.294]的区别，我们不进行任何额外的DoF重新编号。在那个程序中，它得到了回报，因为我们的求解器严重依赖ILU，而我们在这里使用AMG，它对DoF编号不敏感。用于反演压力质量矩阵的IC预处理程序当然会利用类似Cuthill-McKee的重新编号，但与速度部分相比，其成本很低，所以额外的工作并没有得到回报。   
* 然后，我们继续生成悬挂节点约束，这些约束来自于两个DoFHandler对象的自适应网格细化。对于速度，我们通过向已经存储了悬挂节点约束矩阵的对象添加约束来施加无流边界条件[2.x.295]。函数中的第二个参数描述了总dof向量中的第一个速度分量，这里是零。变量[2.x.296]表示设置无通量边界条件的边界指标；这里是边界指标0。   
* 做完这些后，我们计算各块中的自由度数量。
*


* [1.x.159]
*
* 下一步是为斯托克斯和温度系统矩阵以及预处理矩阵创建稀疏模式，我们从这些矩阵中建立斯托克斯预处理程序。如同在[2.x.297]中一样，我们选择使用DynamicSparsityPattern的封锁版本来创建模式。     
* 因此，我们首先释放存储在矩阵中的内存，然后设置一个BlockDynamicSparsityPattern类型的对象，该对象由[2.x.298]块（用于斯托克斯系统矩阵和前置条件器）或DynamicSparsityPattern（用于温度部分）组成。然后我们用非零模式填充这些对象，考虑到对于斯托克斯系统矩阵，在压力-压力块中没有条目（但所有速度矢量分量相互耦合并与压力耦合）。同样，在斯托克斯预处理矩阵中，只有对角线块是非零的，因为我们使用了介绍中讨论的矢量拉普拉斯。这个算子只把拉普拉斯的每个矢量分量与它自己联系起来，而不是与其他矢量分量联系起来。然而，应用无流量边界条件产生的约束条件将在边界处再次耦合矢量分量）。     
* 当生成稀疏模式时，我们直接应用悬挂节点和无流边界条件的约束。这种方法在[2.x.299]中已经使用过了，但与早期教程中的方法不同，在早期教程中，我们先建立原始的稀疏模式，然后才加入约束条件产生的条目。这样做的原因是，在以后的装配过程中，我们要在将本地道夫转移到全局道夫时立即分配约束。因此，在受限自由度的位置不会有数据写入，所以我们可以通过将最后一个布尔标志设置为[2.x.301]，让[2.x.300]函数省略这些条目。一旦疏散模式准备好了，我们就可以用它来初始化特里诺斯矩阵。由于Trilinos矩阵在内部存储了稀疏模式，因此在初始化矩阵之后，没有必要再保留稀疏模式。
*


* [1.x.160]
*
* 温度矩阵（或者说是矩阵，因为我们提供了一个温度质量矩阵和一个温度刚度矩阵，它们将在时间离散化中被加在一起）的创建与斯托克斯矩阵的生成相同；只是在这里要简单得多，因为我们不需要照顾任何块或组件之间的耦合。注意我们是如何初始化三个温度矩阵的。我们只使用稀疏模式对第一个矩阵进行再初始化，而对其余两个再初始化则使用先前生成的矩阵。这样做的原因是，从一个已经生成的矩阵进行重新初始化，可以让Trilinos重新使用稀疏模式，而不是为每个副本生成一个新的模式。这可以节省一些时间和内存。
*


* [1.x.161]
*
* 最后，我们为斯托克斯解[2.x.302]和[2.x.303]，以及温度[2.x.304]、[2.x.305]和[2.x.306]（时间步进所需）和所有系统的右手边设置为正确的尺寸和块结构。
*


* [1.x.162]
*
* [1.x.163] [1.x.164]。
* 这个函数集合了我们用于预处理斯托克斯系统的矩阵。我们需要的是速度分量上的矢量拉普拉斯矩阵和压力分量上的质量矩阵，并以[2.x.307]加权。我们首先生成一个适当阶数的正交对象，即FEValues对象，它可以给出正交点的值和梯度（连同正交权重）。接下来我们为单元格矩阵和局部与全局DoF之间的关系创建数据结构。向量[2.x.308]将保存基础函数的值，以便更快地建立局部矩阵，正如在[2.x.309]中已经完成的那样。在我们开始对所有活动单元进行循环之前，我们必须指定哪些成分是压力，哪些是速度。
*


* [1.x.165]
*
* 本地矩阵的创建相当简单。只有一个拉普拉斯项（关于速度）和一个由[2.x.310]加权的质量矩阵需要生成，所以本地矩阵的创建在两行中完成。一旦本地矩阵准备好了（在每个正交点上循环查看本地矩阵的行和列），我们就可以得到本地DoF指数，并将本地信息写入全局矩阵。我们像在[2.x.311]中那样做，也就是说，我们直接应用本地悬挂节点的约束。这样做，我们就不必事后再做，也不会在消除约束时把实际上会再次设置为零的条目写进矩阵中。
*


* [1.x.166]
*
* [1.x.167] [1.x.168].
* 该函数生成将用于Schur补码预处理程序的内部预处理程序。由于只有当矩阵发生变化时才需要重新生成预处理程序，因此在矩阵没有变化的情况下，该函数不需要做任何事情（即标志[2.x.312]的值为[2.x.313]）。否则，它的第一个任务是调用[2.x.314]来生成预处理矩阵。   
* 接下来，我们为速度-速度矩阵[2.x.315]设置预处理器。正如介绍中所解释的，我们将使用基于矢量拉普拉斯矩阵[2.x.316]的AMG预处理器（它在频谱上与斯托克斯矩阵[2.x.317]接近）。通常，[2.x.318]类可以被看作是一个好的黑箱预处理器，不需要任何特殊的知识。然而，在这种情况下，我们必须小心：由于我们为一个矢量问题建立了一个AMG，我们必须告诉预处理程序设置哪些道夫属于哪个矢量分量。我们使用函数[2.x.319]来做这件事，该函数生成一组[2.x.320]向量，其中每个向量在向量问题的相应分量中为1，在其他地方为0。因此，这些是每个分量上的常数模式，这解释了变量的名称。
*


* [1.x.169]

* 接下来，我们再设置一些AMG预处理程序的选项。特别是，我们需要告诉AMG设置，我们对速度矩阵使用二次基函数（这意味着矩阵中有更多的非零元素，因此需要在内部选择一个更稳健的算法）。此外，我们希望能够控制粗化结构的建立方式。Trilinos平滑聚合AMG的方法是寻找哪些矩阵条目与对角线条目大小相似，以便代数式地建立一个粗网格结构。通过将参数[2.x.321]设置为0.02，我们指定所有尺寸超过该行中一些对角线枢轴的百分之二的条目应该形成一个粗网格点。这个参数是比较特别的，对它进行一些微调会影响预处理程序的性能。根据经验，较大的[2.x.322]值会减少迭代次数，但增加每次迭代的成本。看一下Trilinos的文档会提供更多关于这些参数的信息。有了这个数据集，我们就可以用我们想要应用的矩阵来初始化预处理程序。     
* 最后，我们也初始化预处理程序，用于反转压力质量矩阵。这个矩阵是对称的，表现良好，所以我们可以选择一个简单的预处理程序。我们坚持使用不完全Cholesky（IC）因子化预处理器，它是为对称矩阵设计的。我们也可以选择SSOR预处理器，其松弛系数约为1.2，但IC对我们的例子来说更便宜。我们把预处理程序包成一个[2.x.323]指针，这使得下次重新创建预处理程序更加容易，因为我们不必关心破坏以前使用的对象。
*


* [1.x.170]
*
* [1.x.171][1.x.172] 。
* 我们用于推进耦合的斯托克斯-温度系统的时间滞后方案迫使我们将装配（以及线性系统的求解）分成两步。第一步是创建斯托克斯系统的矩阵和右手边，第二步是创建温度道夫的矩阵和右手边，这取决于速度的线性系统的结果。   
*这个函数在每个时间步的开始被调用。在第一个时间步骤中，或者如果网格已经改变，由[2.x.324]表示，我们需要组装斯托克斯矩阵；另一方面，如果网格没有改变，矩阵已经可用，这就没有必要了，我们需要做的是组装右手边的矢量，这在每个时间步骤中都会改变。   
* 关于实施的技术细节，与[2.x.325]相比没有太大变化。我们重置矩阵和向量，在单元格上创建正交公式，然后创建相应的FEValues对象。对于更新标志，我们只在完全装配的情况下需要基函数导数，因为右手边不需要它们；像往常一样，根据当前需要选择最小的标志集，使程序中进一步调用[2.x.326]的效率更高。   
* 有一件事需要评论&ndash；因为我们有一个单独的有限元和DoFHandler来处理温度问题，所以我们需要生成第二个FEValues对象来正确评估温度解决方案。要实现这一点并不复杂：只需使用温度结构，并为我们需要用于评估温度解决方案的基函数值设置一个更新标志。这里需要记住的唯一重要部分是，两个FEValues对象使用相同的正交公式，以确保我们在两个对象的正交点上循环时得到匹配的信息。   
* 声明的过程中，对数组的大小、本地矩阵和右手的创建以及与全局系统相比，本地道夫的指数的向量都有一些捷径。
*


* [1.x.173]
*
* 接下来我们需要一个向量，它将包含前一个时间层次的温度解在正交点的值，以组装动量方程右边的源项。让我们把这个向量称为 [2.x.327] 。     
* 我们接下来创建的一组向量包含了基函数的评估以及它们的梯度和对称梯度，这些梯度将被用于创建矩阵。将这些放到自己的数组中，而不是每次需要时都向FEValues对象询问这些信息，这是一种优化，可以加速装配过程，详见 [2.x.328] 。     
* 最后两个声明是用来从整个FE系统中提取各个块（速度、压力、温度）的。
*


* [1.x.174]
*
* 现在开始对问题中的所有单元格进行循环。我们正在为这个装配例程处理两个不同的DoFHandlers，所以我们必须为使用中的两个对象设置两个不同的单元格迭代器。这可能看起来有点奇怪，因为斯托克斯系统和温度系统都使用相同的网格，但这是保持自由度同步的唯一方法。循环中的第一条语句也是非常熟悉的，按照更新标志的规定对有限元数据进行更新，对局部数组进行清零，并在正交点上获得旧解的值。然后，我们准备在单元上的正交点上进行循环。
*


* [1.x.175]

* 接下来我们提取与内积中的条款相关的基函数的值和梯度。如[2.x.329]所示，这有助于加速装配。             
* 一旦完成这些，我们就开始在局部矩阵的行和列上进行循环，并将相关的产品送入矩阵。右手边是由重力方向的温度驱动的强迫项（在我们的例子中是垂直方向）。  请注意，右手边的项总是生成的，而矩阵的贡献只有在[2.x.330]标志要求时才会更新。
*


* [1.x.176]
*
* 在所有单元的循环中，最后一步是将局部贡献输入到全局矩阵和向量结构中，到 [2.x.331] 指定的位置。  同样，我们让AffineConstraints类来做单元格矩阵元素插入全局矩阵的工作，它已经浓缩了悬挂节点的约束。
*


* [1.x.177]
*
* [1.x.178] [1.x.179]。
* 这个函数组装温度方程中的矩阵。温度矩阵由两部分组成，一个质量矩阵和时间步长乘以刚度矩阵，刚度矩阵由拉普拉斯项乘以扩散量给出。由于该矩阵取决于时间步长（从一个步长到另一个步长），温度矩阵需要在每个时间步长进行更新。我们可以简单地在每个时间步长中重新生成矩阵，但这并不真正有效，因为质量和拉普拉斯矩阵只有在我们改变网格时才会改变。因此，我们通过在这个函数中生成两个单独的矩阵，一个是质量矩阵，一个是刚度（扩散）矩阵，这样做更有效率。一旦我们知道了实际的时间步长，我们将把这个矩阵加上刚度矩阵乘以时间步长的总和。   
*所以这第一步的细节非常简单。如果我们需要重建矩阵（即网格发生了变化），我们将数据结构归零，得到一个正交公式和一个FEValues对象，并为基础函数创建局部矩阵、局部dof指数和评估结构。
*


* [1.x.180]
*
* 现在，让我们开始对三角形中的所有单元进行循环。我们需要将局部矩阵清零，更新有限元评价，然后在每个正交点上循环矩阵的行和列，然后我们创建质量矩阵和刚度矩阵（拉普拉斯项乘以扩散 [2.x.332] 。最后，我们让约束对象将这些值插入全局矩阵中，并直接将约束条件浓缩到矩阵中。
*


* [1.x.181]
*
* [1.x.182] [1.x.183]
* 这个函数对温度矩阵进行第二部分的装配工作，实际添加压力质量和刚度矩阵（时间步长在这里起作用），以及创建依赖于速度的右手边。这个函数中的右侧装配的声明与其他装配例程中使用的声明基本相同，只是这次我们把自己限制在矢量上。我们将计算温度系统的残差，这意味着我们必须评估二阶导数，由更新标志 [2.x.333] 指定。   
* 温度方程是通过流体速度与斯托克斯系统耦合的。解决方案的这两部分与不同的DoFHandlers相关联，因此我们需要再次创建第二个FEValues对象来评估正交点的速度。
*


* [1.x.184]
*
* 接下来是向量的声明，用来保存旧的和较早的解值（分别作为时间级别的符号 [2.x.334] 和 [2.x.335] ）以及当前单元的正交点的梯度。我们还声明了一个对象来保存温度的右侧值（[2.x.336]），并且我们再次使用温度基函数的快捷方式。最终，我们需要找到温度极值和计算域的直径，这将用于稳定参数的定义（我们得到了最大速度作为这个函数的输入）。
*


* [1.x.185]
*
* 现在，让我们开始在三角结构中的所有单元格上进行循环。同样，我们需要两个单元格迭代器，平行走过斯托克斯和温度部分的两个相关DoFHandler对象的单元格。在这个循环中，我们首先将本地rhs设置为零，然后在正交点上获得旧的解函数的值和导数，因为它们将被用于稳定参数的定义和作为方程中的系数，分别需要。请注意，由于温度有自己的DoFHandler和FEValues对象，我们在正交点得到整个解（反正只有标量温度场），而对于斯托克斯部分，我们只限于通过使用[2.x.337]提取速度部分（而忽略压力部分）。
*


* [1.x.186]
*
* 接下来，我们根据介绍中的讨论，用专用函数计算用于稳定的人工黏度。有了这个，我们就可以进入正交点和局部rhs矢量分量的循环了。这里的术语相当冗长，但其定义遵循本方案介绍中开发的时间-离散系统。BDF-2方案比用于第一时间步的后向欧拉方案多需要一个旧时间步的术语（并且涉及更复杂的因素）。当所有这些都完成后，我们将局部向量分配到全局向量中（包括悬挂节点约束）。
*


* [1.x.187]
*
* [1.x.188] [1.x.189]。
* 这个函数解决了线性方程组的问题。在介绍之后，我们从斯托克斯系统开始，在这里我们需要生成我们的块舒尔预处理程序。由于所有相关的动作都在类[2.x.338]中实现，我们所要做的就是适当地初始化这个类。我们需要传递的是压力质量矩阵的[2.x.339]对象，我们使用相应的类与我们已经生成的IC预处理程序和速度-速度矩阵的AMG预处理程序一起设置。注意，[2.x.340]和[2.x.341]都只是指针，所以我们使用[2.x.342]来传递实际的预处理器对象。   
* 一旦预处理程序准备就绪，我们就为该块系统创建一个GMRES求解器。由于我们正在使用特里诺斯数据结构，我们必须在求解器中设置相应的模板参数。GMRES需要在内部存储每次迭代的临时向量（见[2.x.343]结果部分的讨论）&ndash；它可以使用的向量越多，通常表现越好。为了控制内存需求，我们将向量的数量设置为100。这意味着在求解器的100次迭代中，每个临时向量都可以被存储。如果求解器需要更频繁地迭代以获得指定的容忍度，它将通过每100次迭代重新开始，在一个减少的向量集上工作。   
* 有了这一切的设置，我们求解系统并在斯托克斯系统中分配约束条件，即悬挂节点和无流体边界条件，以便即使在受约束的道夫也有适当的解值。最后，我们把迭代次数写在屏幕上。
*


* [1.x.190]
*
* 一旦我们知道了斯托克斯解，我们就可以根据最大速度确定新的时间步长。我们必须这样做以满足CFL条件，因为对流项在温度方程中得到了明确的处理，这在介绍中已经讨论过了。这里用于时间步长的公式的确切形式将在本程序的结果部分讨论。     
* 这里有一个插曲。该公式包含一个除以速度的最大值。然而，在计算开始时，我们有一个恒定的温度场（我们以恒定的温度开始，只有在源作用的第一个时间步长后，它才会成为非恒定的）。恒定温度意味着没有浮力作用，所以速度为零。除以它不可能导致任何好的结果。     
* 为了避免产生无限的时间步长，我们要问最大的速度是否非常小（特别是小于我们在下面任何一个时间步长中遇到的值），如果是，我们就不除以零，而是除以一个小值，从而产生一个大的但有限的时间步长。
*


* [1.x.191]
*
* 接下来我们用函数 [2.x.344] 设置温度系统和右手边。  知道了温度方程的矩阵和右手边，我们设置了一个预处理程序和一个求解器。温度矩阵是一个质量矩阵（特征值在1左右）加上一个拉普拉斯矩阵（特征值在0和[2.x.345]之间）乘以一个与时间步长成正比的小数字 [2.x.346] 。因此，产生的对称和正定矩阵的特征值在[2.x.347]范围内（至于常数）。这个矩阵即使对于小的网格尺寸也只是适度的条件不良，我们通过简单的方法得到一个相当好的预处理，例如用一个不完全的Cholesky分解预处理（IC），因为我们也用于预处理压力质量矩阵求解器。作为一个求解器，我们选择共轭梯度法CG。和以前一样，我们通过模板参数[2.x.348]告诉求解器使用Trilinos向量。最后，我们求解，分配悬挂节点约束，并写出迭代次数。
*


* [1.x.192]
*
* 在这个函数的结尾，我们通过向量的步骤，读出最大和最小的温度值，我们也想输出这些值。这在确定选择时间步长的正确常数时将会很方便，正如本程序的结果部分所讨论的那样。
*


* [1.x.193]
*
* [1.x.194] [1.x.195]。
* 该函数将解决方案写入VTK输出文件，用于可视化，每隔10个时间步长就会完成。这通常是一个相当简单的任务，因为deal.II库提供的函数几乎为我们完成了所有的工作。与以前的例子相比，有一个新的函数。我们想把斯托克斯解和温度都看作一个数据集，但是我们已经根据两个不同的DoFHandler对象完成了所有的计算。幸运的是，DataOut类已经准备好处理这个问题。我们所要做的就是不要在开始时附加一个单一的DoFHandler，然后将其用于所有添加的向量，而是为每个向量分别指定DoFHandler。剩下的就像 [2.x.349] 中所做的那样。我们创建解决方案的名称（这些名称将出现在各个组件的可视化程序中）。第一个[2.x.350]分量是矢量速度，然后我们有斯托克斯部分的压力，而温度是标量。这些信息是用DataComponentInterpretation辅助类读出来的。接下来，我们将数据向量与它们的DoFHandler对象连接起来，根据自由度建立补丁，这些补丁是描述可视化程序数据的（子）元素。最后，我们打开一个文件（包括时间步数），并将vtk数据写入其中。
*


* [1.x.196]
*
* [1.x.197] [1.x.198].
* 这个函数负责处理自适应网格细化的工作。这个函数执行的三个任务是：首先找出需要细化/粗化的单元，然后实际进行细化，最终在两个不同的网格之间转移解向量。第一个任务是通过对温度使用成熟的凯利误差估计器来实现的（对于这个程序，我们主要关注的是温度，我们需要在高温度梯度的区域保持精确，同时也要避免有太多的数值扩散）。第二项任务是实际进行再塑形。这也只涉及到基本函数，例如[2.x.351]，它可以细化那些具有最大估计误差的单元，这些误差合计占80%，并粗化那些具有最小误差的单元，这些误差合计占10%。   
* 如果像这样实施，我们会得到一个不会有太大进展的程序。请记住，我们期望的温度场几乎是不连续的（扩散率[2.x.352]毕竟非常小），因此我们可以预期，一个自由适应的网格会越来越细化到大梯度的区域。网格大小的减少将伴随着时间步数的减少，需要超多的时间步数来解决给定的最终时间。这也会导致在几个网格细化周期后，网格的不连续性的解决要比开始时好得多。   
* 特别是为了防止时间步长的减少和相应的大量时间步数，我们限制了网格的最大细化深度。为此，在细化指标应用于单元格后，我们简单地在所有最细的单元格上循环，如果它们会导致网格级别过高，则取消选择它们进行细化。
*


* [1.x.199]
*
* 作为网格细化的一部分，我们需要将旧网格中的解向量转移到新网格中。为此，我们使用SolutionTransfer类，我们必须准备好需要转移到新网格的解向量（一旦完成细化，我们将失去旧的网格，所以转移必须与细化同时发生）。我们肯定需要的是当前温度和旧温度（BDF-2时间步长需要两个旧的解决方案）。由于SolutionTransfer对象只支持在每个dof处理程序中传输一个对象，我们需要在一个数据结构中收集两个温度解决方案。此外，我们也选择转移斯托克斯解，因为我们需要前两个时间步长的速度，其中只有一个是在飞行中计算的。     
* 因此，我们为斯托克斯和温度的DoFHandler对象初始化了两个SolutionTransfer对象，将它们附加到旧的dof处理程序中。有了这些，我们就可以准备三角测量和数据向量的细化了（按照这个顺序）。
*


* [1.x.200]
*
* 现在一切都准备好了，所以进行细化，在新的网格上重新创建dof结构，并初始化矩阵结构和[2.x.353]函数中的新向量。接下来，我们实际执行网格之间的插值解。我们为温度创建另一份临时向量（现在与新网格相对应），并让插值函数完成这项工作。然后，产生的向量数组被写入各自的向量成员变量中。     
* 记住，约束集将在setup_dofs()调用中为新的三角结构进行更新。
*


* [1.x.201]
*
* 在解决方案被转移后，我们再对转移的解决方案实施约束。
*


* [1.x.202]
*
* 对于斯托克斯向量，一切都一样&ndash；除了我们不需要另一个临时向量，因为我们只是插值一个向量。最后，我们必须告诉程序，矩阵和预处理程序需要重新生成，因为网格已经改变。
*


* [1.x.203]
*
* [1.x.204] [1.x.205]。
* 这个函数执行Boussinesq程序中的所有基本步骤。它首先设置一个网格（根据空间维度，我们选择一些不同级别的初始细化和额外的自适应细化步骤，然后在[2.x.354]维度上创建一个立方体，并首次设置了道夫。由于我们想用一个自适应细化的网格开始时间步进，我们执行一些预细化步骤，包括所有的装配、求解和细化，但实际上没有在时间上推进。相反，我们使用被人诟病的[2.x.355]语句，在网格细化后立即跳出时间循环，从[2.x.356]标签开始的新网格上重新开始。([2.x.357]的使用在[2.x.358]中讨论) 。
* 在我们开始之前，我们将初始值投影到网格上，并获得[2.x.359]矢量的第一个数据。然后，我们初始化时间步数和时间步长，开始时间循环。
*


* [1.x.206]
*
* 时间循环的第一步都是显而易见的；我们组装斯托克斯系统、预调节器、温度矩阵（矩阵和预调节器实际上只在我们之前重新网格的情况下才会改变），然后进行求解。在继续下一个时间步骤之前，我们必须检查我们是否应该首先完成预精炼步骤，或者是否应该重新啮合（每五个时间步骤），精炼到一个与初始精炼和预精炼步骤一致的水平。循环的最后一个步骤是推进解，即把解复制到下一个 "老 "时间级别。
*


* [1.x.207]
*
* 做所有上述工作，直到我们到达时间100。
*


* [1.x.208]
*
* [1.x.209] [1.x.210]。



* 主函数看起来与所有其他程序几乎相同。
*

*
* 有一个区别我们必须要小心。这个程序使用Trilinos，通常，Trilinos被配置成可以使用MPI以%并行方式运行。这并不意味着它[1.x.211]可以在%并行中运行，事实上这个程序（与[2.x.360]不同）根本没有尝试使用MPI在%并行中做任何事情。然而，Trilinos希望MPI系统被初始化。我们通过创建一个类型为[2.x.361]的对象来做到这一点，该对象使用给main()的参数（即[2.x.362]和[2.x.363]）初始化MPI（如果可用的话），并在对象超出范围时再次去初始化它。
*


* [1.x.212]
*
* 这个程序只能在串行中运行。否则，抛出一个异常。
*


* [1.x.213]
* [1.x.214][1.x.215] 。


*[1.x.216][1.x.217]


* 当你在2D中运行该程序时，输出将看起来像这样：<code><pre>活动单元的数量：256（在5层）自由度的数量：3556（2178+289+1089
* 时间步数0：t=0 正在组装......   重新建立斯托克斯预处理程序...   解算...   斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.919118 温度的9次CG迭代。   温度范围。
*
* - .16687 1.30011
* 活动单元的数量：280（在6层）自由度的数量：4062（2490+327+1245）。
* 时间步数 0: t=0 正在组装...   重新建立斯托克斯预处理程序...   解算...   斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.459559温度的9次CG迭代。   温度范围。
*
* - .0982971 0.598503
* 活动单元的数量：520（在7层）自由度数量：7432（4562+589+2281）。
* 时间步数 0: t=0 正在组装...   重新建立斯托克斯预处理程序...   解算...   斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.229779 温度的9次CG迭代。   温度范围。
*
* - .0551098 0.294493
* 活动单元的数量：1072（在8层）自由度的数量：15294（9398+1197+4699
* 时间步数 0: t=0 正在组装...   重新建立斯托克斯预处理程序...   解算...   斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.11489 温度的9次CG迭代。   温度范围。
*
* - .0273524 0.156861
* 活动单元数：2116（9层）自由度数：30114（18518+2337+9259）。
* 时间步数 0: t=0 正在组装...   重建斯托克斯预处理程序...   解算...   斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.0574449 温度的9次CG迭代。   温度范围。
*
* - .014993 0.0738328
* 时间步数1：t=0.0574449 装配...   解决...   斯托克斯子系统的56次GMRES迭代。   时间步长：0.0574449 温度的9次CG迭代。   温度范围。
*
* - .0273934 0.14488
* ...</pre></code>
* 在开始的时候，我们自适应地细化了几次网格，并且总是返回到时间步长为零的地方，在新细化的网格上重新开始。只有这样，我们才开始实际的时间迭代。
* 该程序运行了一段时间。时间步数为0、500、1000、1500、2000、3000、4000和5000的温度场看起来是这样的（注意用于温度的色标并不总是相同）。
* [2.x.364]
* 这里显示的视觉效果是使用例子的一个版本生成的，该版本在传输网格后没有强制执行约束。
* 可以看出，我们有三个加热流体的热源，因此产生了一个浮力效应，使流体的热袋上升并旋转。通过烟囱效应，这三股气流被来自外部并想加入上升气流的流体压在一起。请注意，由于流体最初处于静止状态，与后来被充分发展的流场拖过源头的流体相比，最初在源头上的那些部分获得的加热时间更长。因此，它是更热的，这一事实可以从三个烟羽的红色尖端看出。还请注意流场的相对精细的特征，这是我们选择的温度方程的复杂传输稳定化的结果。
* 除了上面的图片之外，下面的图片显示了自适应网格和同一时间步长的流场。
* [2.x.365]
*

*[1.x.218][1.x.219]


* 同样的事情当然也可以在3D中完成，将[2.x.366]中BoussinesqFlowProblem对象的templateparameter从2改为3，这样现在的输出看起来就像下面这样。
<code><pre>活动单元的数量：64（在3层）自由度的数量：3041（2187+125+729
* 时间步数 0: t=0 正在组装...   重建斯托克斯预处理程序...   解算...   斯托克斯子系统的GMRES迭代次数为0。   时间步长：2.45098 温度的9次CG迭代。   温度范围。
*
* - .675683 4.94725
* 活动单元数：288（在4层）自由度数：12379（8943+455+2981）。
* 时间步数 0: t=0 正在组装...   重新建立斯托克斯预处理程序...   解算...   斯托克斯子系统的GMRES迭代次数为0。   时间步长：1.22549 温度的9次CG迭代。   温度范围。
*
* - .527701 2.25764
* 活动单元的数量：1296（在5层）自由度的数量：51497（37305+1757+12435
* 时间步数 0: t=0 正在组装...   重新建立斯托克斯预处理程序...   解算...   斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.612745温度的10次CG迭代。   温度范围。
*
* - .496942 0.847395
* 活动单元的数量：5048（在6层）自由度的数量：192425（139569+6333+46523）。
* 时间步数 0: t=0 正在组装...   重建斯托克斯预处理程序...   解算...   斯托克斯子系统的GMRES迭代次数为0。   时间步长：0.306373 温度的10次CG迭代。   温度范围。
*
* - .267683 0.497739
* 时间步数1：t=0.306373 装配...   解决...   斯托克斯子系统的27次GMRES迭代。   时间步长：0.306373 温度的10次CG迭代。   温度范围。
*
* - .461787 0.958679
* ...</pre></code>。
* 在时间步长为0,50,100,150,200,300,400,500,600,700,和800的情况下，将温度等值线可视化，得到以下图示。
* [2.x.367]
* 第一幅图看起来像三只刺猬，这是因为我们的方案基本上是将源乘以第一时间步长投射到网格上，以获得第一时间步的温度场。由于源函数是不连续的，我们需要从这个投影中期待过冲和欠冲。这就是事实上发生的情况（在2d中更容易检查），并导致等值面的皱缩外观。  这里所显示的视觉效果是用一个例子的版本生成的，该版本在传输网格后没有强制执行约束。
*


*[1.x.220][1.x.221]


* 该程序有三个参数，我们在理论上没有掌握如何以最佳方式选择。这些参数是。[2.x.368] [2.x.369] 时间步长必须满足一个CFL条件 [2.x.370] 。这里，[2.x.371]是无量纲的，但什么是正确的值？   [2.x.372] 在计算人工黏度时，[1.x.222] 。
*与[2.x.373] 。      这里，无量纲%数[2.x.374]的选择是有意义的。[2.x.375] 在所有这些情况下，我们将不得不期待每个值的正确选择取决于其他值，而且很可能也取决于用于温度的有限元的间隔尺寸和多项式程度。下面我们将讨论一些数值实验来选择常数 [2.x.376] 和 [2.x.377] 。
* 下面，我们将不讨论[2.x.378]的选择。在程序中，我们把它设置为[2.x.379]。这个值的原因有点复杂，与程序的历史而不是推理有关：虽然全局缩放参数[2.x.380]的正确公式如上所示，但程序（包括随deal.II 6.2提供的版本）最初有一个错误，即我们计算的是[2.x.381]，而我们将缩放参数设为1。由于我们只在[2.x.382]的单位平方/立方体上进行计算，这完全等同于使用[2.x.383]的正确公式。由于[2.x.384]的这个值对于当前的程序来说似乎很好用，我们纠正了程序中的公式，并将[2.x.385]设置为一个能完全重现我们之前结果的值。然而，我们将在[2.x.386]中再次讨论这个问题。
* 然而，现在回到讨论选择[2.x.387]和[2.x.388]的什么值。
*

* [1.x.223][1.x.224][1.x.225] 。


* 这两个常数肯定有某种联系。其原因很容易看出来。在纯平流问题的情况下，[2.x.389]，任何显式方案都必须满足形式为[2.x.390]的CFL条件。另一方面，对于纯扩散问题，[2.x.391]，显式方案需要满足一个条件[2.x.392]。因此，鉴于上述[2.x.393]的形式，像我们这里要解决的对流扩散问题将导致[2.x.394]形式的条件。由此可见，我们必须面对这样一个事实：我们可能想把[2.x.395]选得更大，以提高数值方案的稳定性（通过增加人工扩散的数量），但我们必须付出更小的代价，因此也需要更多的时间步骤。因此，在实践中，我们要尽可能选择小的[2.x.396]，以保持传输问题的充分稳定，同时尽量选择大的时间步长，以减少总体工作量。
* 要找到正确的平衡，唯一的办法是做一些计算实验。这就是我们所做的。我们略微修改了程序，以允许无网格细化（所以我们不必总是等待那么长时间），并选择[2.x.397]来消除常数[2.x.398]的影响（我们知道通过使用这个版本的[2.x.399]作为人工粘度，解决方案是稳定的，但我们可以改进一些东西
*
*--即让解决方案更清晰
*
但我们可以通过使用这个人工粘度的更复杂的公式来改善情况**--即使解决方案更加清晰**）。)然后我们对不同的值[2.x.400]运行程序，观察域中的最大和最小温度。我们期望看到的情况是这样的。如果我们选择的时间步长过大（即选择一个比理论上允许的大的[2.x.401]），那么我们将得到温度的指数增长。如果我们选择[2.x.402]太小，传输稳定就会变得不充分，解决方案将显示出明显的振荡，但不是指数增长。
*

*[1.x.226][1.x.227]


* 以下是我们对[2.x.403]，和[2.x.404]，[2.x.405]的不同选择，以及2d中的双线性元素（[2.x.406]）的结果。
* [2.x.407]
* 解释这些图形的方法是这样的：对于[2.x.408]和[2.x.409]，我们看到指数增长或至少是大的变化，但如果我们选择[2.x.410]或更小，那么这个方案是稳定的，尽管有点摇摆不定。对于更多的人工扩散，我们可以选择[2.x.411]或更小的[2.x.412]，[2.x.413]或更小的[2.x.414]，并再次需要[2.x.415]的[2.x.416]（这次是因为许多扩散需要一个小的时间步长）。
* 那么如何选择呢？如果我们只是对大的时间步长感兴趣，那么我们会选择[2.x.417]和[2.x.418].另一方面，我们也对准确性感兴趣，在这里，实际调查这些曲线所显示的内容可能是有趣的。为此，请注意，我们从零温度开始，而且我们的来源是正的&mdash；所以我们会直观地期望温度永远不会降到零以下。但它确实如此，这是使用连续补充物来近似不连续的解决方案时，吉布现象的结果。因此，我们可以看到，把[2.x.419]放得太小是不好的：太少的人工扩散会导致没有被扩散掉的过冲和欠冲。另一方面，对于大的[2.x.420]，最低温度在开始时下降到零以下，但随后很快就扩散回零。
* 另一方面，我们也来看看最高温度。观察溶液的视频，我们可以看到，最初流体处于静止状态。源源不断地加热同一体积的流体，其温度在开始时呈线性增长，直到其浮力能够使其向上移动。因此，最热的那部分流体被带离了溶液，取而代之的流体只被加热了很短的时间就被带出了源区，因此仍然比最初的气泡冷。如果[2.x.421]（在程序中是非零的，但非常小），那么流体中最热的部分应该随着温度恒定的流动而被平移。这就是我们在最小的[2.x.422]图中所看到的：在达到最高温度时，它几乎不再变化。另一方面，人工扩散越大，热点被扩散的程度越大。请注意，对于这个标准，时间步长并没有发挥重要的作用。
* 因此，总结起来，最好的选择似乎是[2.x.423]和[2.x.424]。曲线有点摇摆不定，但总的来说，图片看起来很合理，但由于Gibb的现象，在接近开始时间时出现了一些过冲和欠冲的情况。
*

*[1.x.228][1.x.229]


* 我们也可以对更高的元素重复同样的实验序列。下面是温度的双二次方形状函数（[2.x.425]）的图表，同时对斯托克斯系统的[2.x.426]稳定泰勒-胡德元素进行了研究。
* [2.x.427]
* 同样，[2.x.428]的小值会导致较少的扩散，但我们必须选择非常小的时间步长来保持事情的控制。[2.x.429]的大值会导致更多的扩散，但同样需要很小的时间步长。最佳值似乎是[2.x.430]，就像[2.x.431]元素一样，然后我们必须选择[2.x.432]&mdash；正好是[2.x.433]元素的一半大小。]元素，如果我们把CFL条件说成是要求时间步长足够小，以便在每个时间步长中运输的距离不超过一个[1.x.230]的距离（对于[2.x.434]元素是[2.x.435]，但对于[2.x.436]元素是[2.x.437]），这一事实可能并不令人惊讶。事实证明，[2.x.438]需要稍微大一点，以便在模拟后期获得稳定的结果，时间大于60，所以我们实际上在代码中选择它作为[2.x.439]。
*

*[1.x.231][1.x.232]


* 我们可以在3D中重复这些实验，找到每个[2.x.440]值的最佳时间步骤，并找到[2.x.441]的最佳值。我们发现，对于在2D中已经使用的相同的[2.x.442]，时间步长需要小一点，大约是1.2倍左右。这很容易解释：时间步长的限制是[2.x.443]，其中[2.x.444]是单元的[1.x.233]。然而，真正需要的是网格点之间的距离，它是[2.x.445]。所以更合适的形式是[2.x.446] 。
* 第二个发现是需要选择[2.x.447]稍微大一点（大约[2.x.448]左右）。这就再次减少了我们可以采取的时间步骤。
*


*

*[1.x.234][1.x.235]。


* 总之，从上面的简单计算来看，[2.x.449]似乎是2D中稳定参数的良好选择，而[2.x.450]是3D中的稳定参数。以独立维度的方式，我们可以将其建模为[2.x.451]。如果在更细的网格上做更长时间的计算（几千个时间步长），就会发现时间步长还不够小，为了稳定，必须把上述数值再降低一些（大约是[2.x.452]的一个系数）。
* 因此，调和2D、3D和可变多项式度并考虑到所有因素的公式如下：[1.x.236] 。
* 在第一种形式中（方程的中心），[2.x.453]是一个普遍的常数，[2.x.454]是说明单元直径和网格点分离之间的差异的因素，[2.x.455]说明[2.x.456]随着空间尺寸的增加而增加，[2.x.457]说明高阶元素的网格点之间的距离，[2.x.458]说明相对于单元尺寸的局部传输速度。这就是我们在程序中使用的公式。
* 至于是使用[2.x.459]还是[2.x.460]元素来计算温度的问题，以下考虑可能是有用的。首先，解决温度方程在总体方案中几乎不是一个因素，因为几乎所有的计算时间都用于解决每个时间步骤中的斯托克斯系统。因此，温度方程的高阶元素并不是一个重要的缺点。另一方面，如果比较一下由于不连续的源描述而产生的过冲和欠冲的大小，就会发现，对于上述[2.x.461]和[2.x.462]的选择，[2.x.463]的解下降到[2.x.464]左右，而[2.x.465]的解只到[2.x.466]（记住，精确解根本不应该变成负数。这意味着[2.x.467]解明显更准确；因此程序使用这些高阶元素，尽管我们在较小的时间步长方面付出了代价。
*

*[1.x.237][1.x.238]


* 有各种方法来扩展当前的程序。当然，特别感兴趣的是使其更快和/或提高程序的分辨率，特别是在3D方面。这是[2.x.468]教程程序的主题，它将实现在集群上以%并行方式解决这个问题的策略。它也是更大的开源代码ASPECT（见https://aspect.geodynamics.org/）的基础，它可以解决现实的问题，并构成了[2.x.469]的进一步发展。
* 另一个方向是使流体流动更加逼真。该程序最初是为了模拟各种情况，模拟地幔中的物质对流，即外地核和固体地壳之间的区域：在那里，物质从下面被加热，从上面被冷却，导致热对流。然而，这种流体的物理学原理要比这个程序中显示的复杂得多。地幔材料的粘度与温度有很大关系，即[2.x.470]，这种关系经常被模拟为粘度随着温度的升高而呈指数下降。其次，地幔的大部分动态是由化学反应决定的，主要是构成地幔的各种晶体的相变；因此，斯托克斯方程右边的浮力项不仅取决于温度，而且还取决于某个特定位置的化学成分，这些化学成分被流场平流，但也作为压力和温度的函数而变化。在后面的教程中，我们也将研究其中的一些影响。
*

* [1.x.239][1.x.240] [2.x.471] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-32_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43][1.x.44][1.x.45]
* [2.x.3]
* [1.x.46][1.x.47][1.x.48][1.x.49][1.x.50]


*[1.x.51][1.x.52][1.x.53]


* 这个程序的作用与[2.x.4]已经做的差不多：它解决了描述温度不平衡的流体运动的Boussinesq方程。因此，我们在[2.x.5]中描述的所有方程仍然成立：我们使用相同的有限元方案、相同的时间步进算法以及或多或少相同的温度平流-扩散方程的稳定方法来解决相同的一般偏微分方程（只做了些许修改，以适应问题设置的现实性）。因此，你可能首先要了解那个程序和它的实现，然后再研究当前的程序。
* [2.x.6]和当前程序的不同之处在于，在这里我们想以%并行的方式做事，既利用集群中许多机器的可用性（基于MPI的并行化），也利用单台机器中的多处理器内核（基于线程的并行化）。因此，这个程序的主要工作是引入必要的变化，以利用这些%并行计算机资源的可用性。在这方面，它建立在[2.x.7]程序的基础上，该程序首先介绍了大部分并行功能所需的类，并在[2.x.8]中展示了如何对矢量值问题进行处理。
* 除了这些变化之外，我们还使用了一个略微不同的预设条件器，而且我们将不得不做出一些改变，因为我们想在这里解决一个[1.x.54]问题，而不是一个模型问题。特别是后者，要求我们考虑比例问题，以及所考虑的方程中所有这些参数和系数的实际含义。我们将首先讨论影响数学公式和求解器结构变化的问题，然后是如何并行化的问题，最后是我们将考虑的实际测试案例。
*

*[1.x.55][1.x.56]


* 在[2.x.9]中，我们对速度和压力场使用了以下斯托克斯模型：[1.x.57] 。
* 第一个方程的右手边似乎有点无动机。事情的真相应该是这样的。我们需要作用在流体上的外力，我们假设这些外力仅由重力赋予。在目前的情况下，我们假设流体会为了这个重力的目的而轻微膨胀，但还不至于让我们需要修改不可压缩性条件（第二个方程式）。这意味着，为了右边的目的，我们可以假设[2.x.10] 。一个可能不完全合理的假设是，我们可以假设密度作为温度的函数的变化很小，导致一个形式为[2.x.11]的表达，即密度在参考温度下等于[2.x.12]，并随着温度的升高（随着材料的膨胀）线性下降。然后，力平衡方程看起来正确地写成这样：[1.x.58] 。
* 现在请注意，重力是由重力势产生的[2.x.13]，因此我们可以将其重新写成如下：[1.x.59] 。
* 右边的第二项是与时间无关的，因此我们可以引入一个新的 "动态 "压力[2.x.14]，这样斯托克斯方程就变成了：[1.x.60] 。
* 这正是我们在[2.x.15]中使用的形式，这样做是合适的，因为流体流动的所有变化只是由温度差异导致的动态压力所驱动。(换句话说。换句话说：由于采取标量场的梯度而对右手边的任何贡献都对速度场没有影响）。)
* 另一方面，我们在这里将使用考虑总压力的斯托克斯方程的形式来代替：[1.x.61] 。
* 这样做有几个好处。
*
* 这样，我们就可以在我们的程序中绘制压力图，它实际上显示的是总压力，包括温差的影响以及上层岩石的静压力。由于压力没有进一步出现在任何其他方程中，因此使用一个还是另一个，更多的是口味问题，而不是正确性问题。流动场是完全相同的，但我们得到的压力现在可以与地球物理书籍中给出的地球地幔底部的压力值进行比较，比如说。
*
* 如果我们想使模型更加真实，我们就必须考虑到许多材料参数（如粘度、密度等）不仅取决于温度，而且还取决于[1.x.62]压力。
*
* - 上面的模型假设了一个线性依赖[2.x.16]，并假定[2.x.17]很小。在实践中，情况可能并非如此。事实上，现实的模型肯定不是线性的，而且[2.x.18]至少在部分温度范围内也可能不小，因为密度的行为不仅在很大程度上取决于热膨胀，而且取决于相变。
*
* - 在结果部分讨论了这样做的最后一个原因，涉及到对我们在这里使用的模型的可能扩展。这与我们在这里使用的温度方程（见下文）不包括包含压力的条款这一事实有关。然而，它应该包括：岩石，像气体一样，在你压缩它的时候会升温。因此，上升的物质以绝热方式冷却，而下沉的冷物质以绝热方式升温。我们在下面进一步讨论这个问题。
*[2.x.19] 然而，这个过程有一个缺点。在地球上，动压比总压要小几个数量级。如果我们使用上述方程并求解所有变量，例如4位数的精度，那么我们可能会得到正确的速度和总压力，但如果我们通过从总压力中减去静态部分来计算动态压力，我们将完全没有精度 [2.x.20] 。例如，如果动压比静压小6个数量级，那么我们需要解出总压至少7位数的精度才能得到任何精确的结果。也就是说，在实践中，这并不是一个限制性因素。
*


*[1.x.63][1.x.64]


* 记住，我们要解决以下方程组：[1.x.65] 。
* 用适当的边界条件和初始条件加以补充。正如在[2.x.21]中所讨论的，我们将通过在每个时间步长中首先解决斯托克斯问题来解决这组方程，然后将温度方程向前推进一个时间区间。
* 本节所考虑的问题是斯托克斯问题：如果我们像往常一样离散它，我们会得到一个线性系统[1.x.66] 。
* 在这个程序中，我们将用FGMRES求解器来解决这个问题。这个求解器一直计算到这些线性方程的残差低于一定的公差，也就是说，直到[1.x.67]为止。]（最容易确定的是考虑到项[2.x.23]，并考虑到压力有单位[2.x.24]，积分产生的系数为[2.x.25]），其中残差的第二部分有单位[2.x.26]。取这个残差向量的北面将得到一个单位为[2.x.27]的量。很明显，这样做是没有意义的，而且我们不应该惊讶这样做最终会伤害到我们。
* 那么，为什么这在这里是个问题，而在[2.x.28]中不是？那里的原因是一切都很平衡：速度是1的数量级，压力也是1的数量级，粘度是1的数量级，域的直径是[2.x.29]。结果是，尽管很荒谬，但没有发生什么坏事。另一方面，正如我们下面要解释的那样，这里的事情不会是那么简单的缩放。  [2.x.30]将在[2.x.31]左右，速度在[2.x.32]左右，压力在[2.x.33]左右，而域的直径是[2.x.34]。换句话说，第一个方程的数量级将是[2.x.35]，而第二个方程将是[2.x.36]左右。那么，这将导致这样的结果：如果求解器想让残差变小，它几乎会完全集中在第一组方程上，因为它们大得多，而忽略描述质量保持的发散方程。这正是发生的情况：除非我们将容忍度设置为极小的数值，否则所得到的流场肯定不是无发散的。作为一个辅助问题，事实证明，很难找到一个始终有效的公差；在实践中，我们往往最终得到一个公差，在大多数时间步骤中需要30或40次迭代，而在某些时间步骤中需要10,000次。
* 那么，在这样的情况下，数字分析员该怎么做呢？答案是从根本上入手，首先确保一切都在数学上是一致的。在我们的例子中，这意味着如果我们想联合解决斯托克斯方程组，我们必须对其进行缩放，使其具有相同的物理尺寸。在我们的例子中，这意味着将第二个充分值乘以具有单位[2.x.37]的东西；一个选择是乘以[2.x.38]，其中[2.x.39]是我们领域中的一个典型的长度尺度（实验表明，最好选择羽流的直径&mdash；大约10公里&mdash；而不是领域的直径）。使用[2.x.40]和[2.x.41]的这些%数，这个系数约为[2.x.42]。因此，我们现在得到斯托克斯系统的这个数字：[1.x.68] 。
* 这方面的问题是，结果不再是对称的（我们在左下方有[2.x.43]，但在右上方没有它的转置运算器）。然而，这可以通过引入升压[2.x.44]来解决，我们可以得到缩放的方程[1.x.69]。
* 现在是对称的。很明显，我们可以很容易地从按比例计算的压力[2.x.46]中恢复原来的压力[2.x.45]，我们是通过这个程序计算出来的。
* 在下面的程序中，我们将引入一个对应于[2.x.48]的因子[2.x.47]，我们将在系统矩阵和预处理程序的组装中使用这个因子。因为这很烦人，而且容易出错，我们将在线性系统的解之后立即恢复未标定的压力，也就是说，解向量的压力分量将立即被标定以检索物理压力。由于求解器使用的是我们可以通过外推以前的解来使用一个好的初始猜测的事实，所以我们也必须立即对压力进行缩放[1.x.70]求解。
*


*[1.x.71][1.x.72]


* 在这个教程程序中，我们应用了[2.x.49]中使用的预处理程序的一个变体。该预处理程序是为了对系统矩阵[2.x.50]进行块状操作，从而使乘积矩阵[1.x.73]
*是基于Krylov的迭代求解器（如GMRES）可以在几次迭代中解决的形式。然后，我们用基于矢量拉普拉斯矩阵的AMG预处理程序[2.x.52]的作用来取代[2.x.51]的精确逆，用压力空间上的质量矩阵[2.x.54]来逼近舒尔补码[2.x.53]，并编写了一个<tt>InverseMatrix</tt>类，用于实现[2.x.55]对矢量的作用。在InverseMatrix类中，我们使用了一个带有不完全Cholesky（IC）预处理的CG求解器来进行内部求解。
* 一个可以观察到的现象是，我们仅仅使用了一个预处理器的作用来逼近速度逆[2.x.56]（而后面的GMRES迭代处理了逆的近似特性），而我们对[2.x.57]使用了一个差不多的[1.x.74]逆，由一个完全收敛的CG解实现。这似乎是不平衡的，但这种疯狂是有系统的：几乎所有的努力都在左上角的区块，我们应用了AMG预处理程序，而即使是对压力质量矩阵的精确反转，也基本上没有花费什么。因此，如果它能帮助我们在一定程度上减少迭代的总次数，那么这种努力是值得的。
* 也就是说，尽管该求解器在[2.x.58]中运行良好，但我们在这里遇到的问题更复杂一些（细胞变形，压力变化的数量级，我们想为更复杂的物理学提前做好计划），因此我们将稍微改变一些东西。
*
* - 对于更复杂的问题，事实证明，只用一个AMG V-循环作为预处理程序并不总是足够。外围求解器在大多数情况下都能在合理的迭代次数内收敛（比如，少于50次），但偶尔会有一些时间步骤，它突然需要700次左右。到底发生了什么，很难确定，但这个问题可以通过对左上角的块使用更精确的求解器来避免。因此，我们要使用CG迭代来反转预处理矩阵的左上角块，并使用AMG作为CG求解器的预处理。
*
* - 这样做的缺点是，当然，斯托克斯预处理程序变得更加昂贵（比我们只用一个V型循环时大约贵10倍）。我们的策略是这样的：让我们只用V型循环作为预处理程序做多达30次的GMRES迭代，如果没有收敛，那么在第一轮迭代后得到的斯托克斯解的最佳近似值，并将其作为我们使用具有相当宽松容忍度的完整内部求解器作为预处理程序的迭代的起始猜测。在我们所有的实验中，这只导致了少数额外迭代的收敛。
*
* - 我们需要注意的一点是，当使用具有宽松容限的CG作为前置条件时，[2.x.59]不再是[2.x.60]的线性函数（当然，如果我们的求解器具有非常严格的容限，或者我们只应用单一的V-循环，则是如此）。这是一个问题，因为现在我们的预处理程序不再是一个线性算子；换句话说，每次GMRES使用它时，预处理程序看起来都不一样。标准的GMRES求解器不能处理这个问题，导致收敛缓慢甚至崩溃，但F-GMRES变体正是为了处理这种情况而设计的，因此我们使用它。
*
* - 另一方面，一旦我们确定使用F-GMRES，我们就可以放宽用于反转[2.x.61]的预处理程序的容忍度。在[2.x.62]中，我们对[2.x.63]运行了一个预处理的CG方法，直到残差被减少了7个数量级。在这里，我们又可以更宽松一些，因为我们知道外部预处理程序并没有受到影响。
*
* - 在[2.x.64]中，我们使用了一个左边的预处理程序，我们首先反转预处理矩阵的左上块，然后应用左下块（发散），再反转右下块。换句话说，预处理器的应用起到了左下块三角矩阵的作用。另一个选择是使用右预处理器，这里将是右上块三角化，即我们首先反转右下舒尔补码，应用右上（梯度）算子，然后反转椭圆的左上块。在某种程度上，选择哪一个是一个品味的问题。也就是说，在GMRES类型的求解器中，右预处理有一个显著的优势：我们决定是否应该停止迭代的残差是真正的残差，而不是预处理方程的规范。因此，将其与我们通常使用的停止标准，即右手边向量的规范进行比较要简单得多。在编写这段代码时，我们发现上面讨论的缩放问题也使我们难以确定适合于左预处理线性系统的停止准则，因此本程序使用了右预处理程序。
*
* - 在[2.x.65]中，我们对舒尔补码预处理中的压力质量矩阵和温度系统的求解使用了IC（不完全Cholesky）预处理。在这里，我们原则上也可以这样做，但我们确实选择了一个更简单的预处理程序，即两个系统的雅可比预处理程序。这是因为在这里我们的目标是大规模的并行计算，IC/ILU的分解必须在每个处理器上对本地拥有的自由度逐块执行。这意味着，无论如何，预处理程序会变得更像一个雅可比预处理程序，所以我们宁愿直接从这个变体开始。请注意，我们只对有质量矩阵的CG求解器使用Jacobi预处理，在那里它们可以提供最佳的（[1.x.75]独立的）收敛性，尽管它们通常需要比IC预处理多一倍的迭代。
* 最后，让我们指出，在[2.x.66]中，我们通过近似[2.x.68]来计算舒尔补码[2.x.67]。然而现在，我们重新缩放了[2.x.69]和[2.x.70]的运算符。所以[2.x.71]现在应该近似于[2.x.72].我们用它的右手边的离散形式作为我们的近似[2.x.73]到[2.x.74]。
*

*[1.x.76][1.x.77] 。


* 与[2.x.75]类似，我们将使用基于方程残差的人工黏度进行稳定化。  作为与[2.x.76]的区别，我们将提供两个略有不同的稳定参数的定义。对于[2.x.77]，我们使用与[2.x.78]相同的定义：[1.x.78] 。
* 我们从方程的残差[2.x.79]中计算粘度，在残差较大的区域（陡峭的梯度周围）由与网格大小[2.x.80]成比例的扩散来限制。这个定义对于给定的情况[2.x.81]在[2.x.82]中被证明是有效的，但是对于[2.x.83]来说，它通常不如扩散有效。对于这种情况，我们选择了一个稍微可读的粘度定义，[1.x.79] 。
* 其中第一项又给出了最大耗散量（类似于一阶上风方案），[1.x.80] 。
* 熵粘度的定义为[1.x.81] 。
*
* 这个公式在文章[1.x.82]中描述。 与[2.x.84]的情况相比，熵是由温度熵计算出来的，[2.x.85]有[2.x.86]个平均温度（我们在计算中选择最大和最小温度之间的平均值），这给出了以下公式[1.x.83] 。
* [2.x.87]公式中的分母被计算为熵与空间平均熵[2.x.88]的全球偏差。与[2.x.89]一样，我们根据前两个时间层次的温度和速度来评价人工粘度，以避免其定义中的非线性。
* 上述粘度的定义很简单，但取决于两个参数，即[2.x.90]和[2.x.91] 。  对于目前的程序，我们想在[2.x.92]的情况下对两个参数更系统地处理这个问题，使用我们在离散化中选择其他两个参数[2.x.93]和[2.x.94]的相同推理，在[2.x.95]的结果部分。特别是要记住，我们希望使人工粘滞度尽可能小，同时保持必要的大。在下文中，让我们描述一个人可能遵循的一般策略。这里显示的计算是用程序的早期版本完成的，因此你在运行程序时得到的实际数值可能与这里显示的数值不一致；也就是说，一般的方法仍然有效，并被用来寻找程序中实际使用的参数值。
* 要想知道发生了什么，请注意，下面我们将对973和4273开尔文之间的温度施加边界条件，初始条件也选择在这个范围内；为了考虑到这一点，我们在没有%的内部热源或散热器的情况下运行程序，因此温度应该总是在这个范围内，没有任何%的内部振荡。如果最低温度下降到973开尔文以下，那么我们需要通过增加[2.x.96]或减少[2.x.97]来增加稳定度。
* 正如我们在[2.x.98]中所做的那样，我们首先通过使用 "传统 "公式[1.x.84]来确定[2.x.99]的最佳值。
*我们知道，只要[2.x.100]足够大，它就是稳定的。在2d中做几百个时间步长（在比程序中显示的网格更粗的网格上，用不同的粘度影响传输速度，从而影响时间步长）将产生以下图表。
* [2.x.101]
* 可以看出，[2.x.102]的数值太小，而[2.x.103]似乎是有效的，至少在这里显示的时间范围内。作为旁观者，这里至少有两个问题值得思考。首先，当解决方案变得不稳定的时候会发生什么？看一下图形输出，我们可以看到，在这些实验所选择的不合理的粗糙网格下，大约在[2.x.104]秒的时间里，一直向冷的外部边界上升的热物质羽流，然后向侧面扩散，开始相互靠近，挤压出中间的冷物质。这就形成了一个细胞层，流体从两个相反的方向流入，并向第三个方向流出，显然，这种情况会在没有足够稳定的情况下产生这些不稳定。第二：在[2.x.105]中，我们使用了[2.x.106]；为什么这在这里不起作用？这个问题的答案并不完全清楚
*
* - 稳定参数肯定取决于单元格的形状，在[2.x.107]中我们使用的是正方形，而在目前的程序中是梯形。不管具体原因是什么，我们至少有一个[2.x.108]的值，即2d的0.052，对当前的程序是有效的。
* 有了这个值，我们就可以回到粘度的原始公式[2.x.111]，并玩弄常数[2.x.112]，使其尽可能大，以使[2.x.113]尽可能小。这给我们提供了这样的画面。
* [2.x.114]
* 因此，[2.x.115]似乎是这里的正确值。虽然这个图形是针对指数[2.x.116]得到的，但在程序中我们用[2.x.117]代替，在这种情况下，我们必须重新调整参数（注意[2.x.118]出现在分子中而不是分母中）。事实证明，[2.x.119]与[2.x.120]一起使用。
*

*[1.x.85][1.x.86]


* Stokes的标准Taylor-Hood离散化，使用[2.x.121]元素，是全局保守的，即[2.x.122] 。这很容易看出：发散方程的弱形式为 [2.x.123] 。因为压力空间确实包含函数[2.x.124]，我们可以得到
* [1.x.87]
*根据发散定理。这个属性很重要：如果我们想用速度场[2.x.125]来传输其他的量（比如当前方程中的温度，但也可能是化学物质的浓度或完全是人工的示踪量），那么保存属性保证了被输送的量保持不变。
* 也就是说，在有些应用中，这个[1.x.88]属性是不够的。相反，我们希望它在每个细胞上都持有[1.x.89]。这可以通过使用空间[2.x.126]进行离散化来实现，其中我们用相同程度的完整多项式的[1.x.91]空间代替压力的[1.x.90]度数的张量积多项式[2.x.127]空间。(注意2d的张量积多项式包含函数[2.x.128]，而完全多项式只有函数[2.x.129]。)这个空间对于斯托克斯方程来说是稳定的。
* 由于该空间是不连续的，我们现在可以特别选择测试函数[2.x.130]，即单元的特征函数[2.x.131]。然后我们以类似于上述的方式得到
* [1.x.92]
*显示了细胞[2.x.132]的守恒特性。这显然对每个单元格都是成立的。
* 使用这种离散化有很好的理由。如上所述，该元素保证了每个单元上平流量的守恒。第二个优点是，我们用压力质量矩阵代替舒尔补码作为调节器，成为块状对角线，因此非常容易反转。然而，也有缺点。首先，现在有更多的压力变量，增加了问题的总体规模，尽管这在实践中似乎没有造成太大的影响。但更重要的是，现在每个单元上的发散是零，而以前不是，这并不能保证发散是逐渐变小的。事实上，我们可以很容易地验证，与标准Taylor-Hooddiscretization相比，这个发散的[2.x.133]准则是[1.x.93]。然而，两者都以同样的速度收敛到零，因为很容易看到[2.x.134]）。因此，不能先验地认为，仅仅因为我们现在有更多的自由度，误差就真的小了。
* 鉴于这些考虑，我们仍然不清楚应该选择哪种离散化。因此，我们把这个问题留给用户，在输入文件中设置一个参数来决定使用哪一个。
*

*[1.x.94][1.x.95] 。


* 在本程序中，我们将使用一个球壳作为域。这意味着域的内部和外部边界不再是 "直的"（我们通常指它们是可以用FlatManifold类表示的双线性表面）。相反，它们是弯曲的，如果我们已经使用高阶有限元来计算速度，那么在程序中使用一个弯曲的近似值似乎是很谨慎的。因此，我们将引入一个MappingQ类型的成员变量来表示这样的映射（[2.x.135]和[2.x.136]首次引入了这样的映射），我们将在与边界相邻的单元上的所有计算中使用它。由于这只影响到相对较小的一部分单元，所以额外的努力并不是很大，我们将对这些单元使用一个四元映射的奢侈。
*

*[1.x.96][1.x.97] 。


* 在三维空间中运行具有显著雷利数的对流代码需要大量的计算，在整个地球模拟的情况下，需要一个或几个亿的未知数。这显然不能用一台机器来完成（至少在2010年我们开始写这个代码时不能）。因此，我们需要将其并行化。科学代码在计算机集群的多台机器上的并行化几乎总是使用消息传递接口（MPI）来完成。这个程序也不例外，它遵循了[2.x.137]和[2.x.138]程序的一般精神，尽管在实践中它更多地借鉴了[2.x.139]，其中我们首先介绍了当我们想[1.x.98]分布所有计算时使用的类和策略，以及[2.x.140]展示了如何对[2.x.141]"向量值问题 "进行分配：包括，例如，将网格分割成若干部分，使每个处理器只存储自己的份额和一些幽灵单元，以及使用一些策略，使每个处理器都有足够的内存来保存本地的组合解向量的条目。我们的目标是在数百甚至数千个处理器上运行这段代码，并具有合理的可扩展性。
* [2.x.142]尽管它有一个较大的数字，但[2.x.143]在逻辑上排在当前程序之前。对于[2.x.144]也是如此。在你试图理解我们在这里做什么之前，你可能想看看这些程序。
* MPI是一个相当笨拙的编程接口。它是一个半面向对象的函数集，当人们用它在网络上发送数据时，需要明确地描述数据类型，因为MPI函数坚持将数据地址作为[2.x.145]对象来获取，而不是通过重载或模板来自动推断数据类型。我们已经在[2.x.146]和[2.x.147]中看到了如何通过将所有必要的通信放到deal.IIlibrary中，或者在这些程序中放到PETSc中，来避免几乎所有的MPI。我们将在这里做一些类似的事情：就像在[2.x.148]和[2.x.149]中，deal.II和底层的p4est库负责分配网格所需的所有通信，而我们将让Trilinos库（以及命名空间TrilinosWrappers中的包装器）处理线性代数组件的并行化。我们已经在[2.x.150]中使用了Trilinos，并将在此再次使用，不同的是我们将使用其%的并行能力。
* Trilinos由大量的包组成，实现了基本的%并行线性代数操作（Epetra包），不同的求解器和先决条件包，以及对odeal.II不太重要的东西（例如。deal.II的Trilinos接口封装了Trilinos提供的许多与PDE求解器相关的东西，并提供了封装类（在命名空间TrilinosWrappers中），使Trilinos的矩阵、向量、求解器和预处理器类看起来与deal.II自己对这些功能的实现非常相似。然而，与deal.II的类相比，如果我们给它们提供必要的信息，它们可以在%的范围内并行使用。因此，有两个Trilinos类我们必须直接处理（而不是通过包装器），这两个类都是Trilinos的Epetra基本线性代数和工具类库的一部分。[2.x.151] [2.x.152] Epetra_Comm类是MPI "通信器 "的抽象，也就是说，它描述了多少台机器和哪些机器可以相互通信。  每个分布式对象，如稀疏矩阵或矢量，我们可能想在不同的机器上存储部分，需要有一个通信器对象来知道有多少部分，在哪里可以找到它们，以及如何访问它们。
* 在这个程序中，我们实际上只使用了一个通信器对象
*
* - 基于MPI变量[2.x.153]。
*
* - 涵盖了一起工作的[1.x.99]进程。在[2.x.154]机器上启动一个进程，但只在其中的一个子集上存储向量，产生一个只包括这个子集的机器的通信器对象是完全合法的；然而，在这里确实没有令人信服的理由这样做。
* [2.x.155] IndexSet类用于描述向量的哪些元素或矩阵的哪些行应该驻留在属于通信器的当前机器上。要创建这样一个对象，你需要知道（i）元素或行的总数，（ii）你想在本地存储的元素的索引。我们将在下面的[2.x.156]函数中设置这些[2.x.157]，然后把它交给我们创建的每个%parallel对象。
* 与PETSc不同，Trilinos没有假设矢量的元素需要被分割成连续的小块。至少在原则上，我们可以在一个处理器上存储所有偶数索引的元素，在另一个处理器上存储所有奇数索引的元素。当然，这不是很有效率，但这是可能的。此外，这些分区的元素不一定是相互排斥的。这一点很重要，因为在对解决方案进行后处理时，我们需要访问所有本地相关的或至少是本地活跃的自由度（定义见[2.x.158]上的模块，以及[2.x.159]中的讨论）。那么Trilinos矢量认为哪些元素是本地拥有的，对我们来说并不重要。我们所关心的是它在本地存储了我们需要的那些元素。[2.x.160]
* 还有一些与将网格分布到若干处理器有关的概念；在试图理解这个程序之前，你可能想看一下[2.x.161]模块和[2.x.162]或[2.x.163]。  程序的其余部分几乎完全不考虑我们并不完全在本地存储所有对象的事实。在一些地方，我们必须将所有单元的循环限制在本地拥有的单元上，或者我们需要区分只存储本地拥有的元素的向量和存储所有本地相关元素的向量（见[2.x.164]"本词汇表条目"），但总的来说，使程序在%并行中运行所需的大量繁琐工作都很好地隐藏在本程序赖以建立的库中。在任何情况下，我们都会在程序代码中对这些位置进行评论。
*

*[1.x.100][1.x.101]


* 使程序并行化的第二个策略是利用这样一个事实，即今天大多数计算机都有一个以上的处理器，它们都可以访问相同的内存。换句话说，在这个模型中，我们不需要明确说明哪块数据在哪里。
*
* 我们需要的所有数据都可以直接访问，我们所要做的就是将这些数据在可用的处理器之间进行分割。然后，我们将把它与上述的MPI并行化结合起来，也就是说，我们将让一台机器上的所有处理器一起工作，例如，为这台机器实际 "拥有 "的单元汇集对全局矩阵的本地贡献，而不是为其他机器拥有的单元汇集。我们将把这种策略用于本程序中经常进行的四种操作：组装斯托克斯和温度矩阵，组装形成斯托克斯条件反射的矩阵，以及组装温度系统的右侧。
* 所有这些操作基本如下：我们需要在[2.x.165]等于我们机器在用于所有通信的通信器对象（即[2.x.166]，如上所述）中的索引的所有单元上循环。我们实际要使用的测试是[2.x.167]，它简明扼要地描述了为什么要测试这个条件。在每一个单元中，我们需要把对全局矩阵或向量的局部贡献集合起来，然后我们必须把每个单元的贡献复制到全局矩阵或向量中。请注意，第一部分（循环）定义了一个必须发生的迭代器的范围。第二部分，组装本地贡献是这一系列步骤中占用CPU时间最多的部分，也是可以以%并行方式完成的典型例子：每个单元的贡献完全独立于所有其他单元的贡献。第三部分，复制到全局矩阵中，不能以%并行的方式进行，因为我们正在修改一个对象，所以几个线程不能同时读取一个现有的矩阵元素，增加他们的贡献，并将总和写回内存中，而不会产生危险[1.x.103]。
* deal.II有一个类，正是为这个工作流程而生的。WorkStream，最早在 [2.x.168] 和 [2.x.169] 中讨论过。它的使用在[2.x.170]模块中也有大量的记录（在[2.x.171]"WorkStream类 "一节），我们不会在这里重复那里的理由和详细说明，尽管你会想通过这个模块来理解从头开始的空间和每单元数据之间的区别。我只想说，我们需要以下条件。
*
* - 为我们要处理的单元格提供一个迭代器范围。这是由FilteredIterator类提供的，它的作用与deal.II中的其他单元格迭代器一样，只是它跳过了所有不满足特定谓词（即一个评估为真或假的标准）的单元格。在我们的例子中，该谓词是一个单元格是否为本地所有。
*
* - 一个为上面确定的每项任务在每个单元上做工作的函数，即集合对斯托克斯矩阵和预调节器、温度矩阵和温度右侧的局部贡献的函数。这些是下面代码中的[2.x.172]、[2.x.173]、[2.x.174]和[2.x.175]函数。这四个函数都可以有几个实例同时并行运行。
*
* - %函数将前一个函数的结果复制到全局对象中，并按顺序运行以避免竞赛条件。这些是[2.x.176]、[2.x.177]、[2.x.178]和[2.x.179]函数。
* 我们将对实际代码中的一些要点进行评论，但总的来说，它们的结构在 [2.x.180] 中的讨论中应该是清楚的。
* WorkStream的底层技术确定了需要进行工作的 "任务"（例如，在一个单元上组装本地贡献），并将这些任务自动调度到可用的处理器。WorkStream通过将迭代器范围分割成合适的小块，自动创建这些任务。
* [2.x.181] 在每个MPI进程中使用多个线程，只有当你在集群的每个节点上运行的MPI进程少于这个机器上的处理器核心时才有意义。否则，MPI已经让你的处理器很忙了，你不会从使用线程中得到任何额外的速度提升。例如，如果你的集群节点有8个内核，在写这篇文章的时候，它们通常有8个内核，如果你的批处理调度程序在每个节点上放置8个MPI进程，那么使用线程并不会使程序更快。因此，你可能想在配置deal.II时不使用线程，或者在运行前将[2.x.182]中的线程数设为1（第三个参数），或者 "export DEAL_II_NUM_THREADS=1"。也就是说，在写这篇文章的时候，我们只用WorkStream类来组装（部分）线性系统，而程序的75%或更多的运行时间是花在没有并行化的线性求解器上&mdash；换句话说，我们最好的希望是将剩下的25%并行化。
*

*[1.x.104][1.x.105]


* 这个程序的设置稍微让人想起我们最初想解决的问题（见[2.x.183]的介绍）：地幔的对流。因此，我们选择了以下数据，所有这些数据在程序中都以米和秒为单位（SI系统）出现，即使我们在这里以其他单位列出。然而，我们注意到，这些选择基本上仍然只是示范性的，而不是要形成对地幔对流的完全现实的描述：为此，必须实现更多、更困难的物理学，而且目前在这个程序中还缺少其他几个方面。我们将在结果部分再次讨论这个问题，但现在要说明的是，在写这篇文章的时候，提供真实的描述是[1.x.106]代码开发的一个目标。
* 作为提醒，让我们再次说明我们要解决的方程是这样的：[1.x.107] 。
*由边界和初始条件增强。然后我们必须选择以下数量的数据。[2.x.184] [2.x.185] 领域是一个环形（2D）或一个球壳（3D），其内外半径与地球的半径一致：地球的总半径为6371km，地幔从大约35km的深度开始（就在由[1.x.109]和[1.x.110]组成的固体地球[1.x.108]之下）到2890km的深度（[1.x.111]开始）。因此，半径为[2.x.186] 。这个领域是使用[2.x.187]函数方便地生成的。
* [2.x.188] 在地壳和地幔的界面上，温度在500到900摄氏度之间，而在其底部则是4000摄氏度左右（例如，见[1.x.112]）。因此，在开尔文中，我们选择[2.x.189] ，[2.x.190]作为内部和外部边缘的边界条件。
*除此之外，我们还必须指定一些温度场的初始条件。地球的真实温度场是相当复杂的，因为对流已经持续了40多亿年。
*
* 事实上，我们想用这样的程序探索的正是这种温度分布的特性。因此，我们在这里并没有什么有用的东西可以提供，但是我们可以希望，如果我们从一些东西开始，让事情运行一段时间，确切的初始条件就不再那么重要了&mdash；事实上，看一下[1.x.113]中显示的图片就可以看出。我们在这里使用的初始温度场是以半径为单位给出的，即
* [1.x.114]
* 其中
* [1.x.115]
*这个复杂的函数本质上是内部和外部温度之间的线性轮廓的扰动。在2D中，函数[2.x.191]看起来是这样的（我从[1.x.116]得到的图片）。
* [2.x.192]
* 这个轮廓的重点是，如果我们在[2.x.195]的定义中使用[2.x.193]而不是[2.x.194]，那么它将只是一个线性内插。  [2.x.196]在内部和外部边界具有与[2.x.197]相同的函数值（分别为0和1），但它根据角度和3D中的[2.x.198]值将温度曲线拉长一些，对线性插值场产生一个与角度有关的扰动。我们将在结果部分看到，这是一个完全不实际的温度场（尽管它将产生有趣的图像），因为温度的平衡状态将是一个几乎恒定的温度，在内部和外部边界有边界层。
* [2.x.199] 温度方程的右边包含了内部加热%的速率 [2.x.200] 。地球确实通过几种机制自然升温：放射性衰变、化学分离（较重的元素沉到底部，较轻的元素升到顶部；逆流耗散的能量相当于这种分离过程中的势能损失）；随着地球内部固体核心的增长，液态金属的结晶释放热量；以及流体运动时粘性摩擦的热量耗散。
* 化学分离很难建模，因为它需要将地幔材料建模为多个相；它也是一个相对较小的影响。结晶热就更难了，因为它只限于温度和压力允许相变的区域，也就是一个不连续的过程。鉴于对这两个现象进行建模的困难，我们将忽略它们。
* 其他两个很容易处理，考虑到我们缩放温度方程的方式，导致方程[1.x.117]，其中[2.x.201]是[2.x.202]中的辐射性加热，枚举器中的第二个项是粘性摩擦加热。  [2.x.203] 是密度，[2.x.204] 是比热。文献中提供了以下近似值。  [2.x.205] .  其他参数将在本节的其他地方讨论。
* 我们在这里忽略了一个内部热源，即绝热加热，这将导致一个令人惊讶的温度场。这一点将在下面的结果部分详细评论。
* [2.x.206] 对于速度，我们在内半径处选择[2.x.207]作为边界条件（即流体粘在地心上），在外半径处选择[2.x.208]（即流体沿地壳底部切向流动）。这两种情况在物理上都不过分正确：当然，在这两个边界上，流体可以切向流动，但它们会通过与界面另一侧的介质（分别是金属核心和地壳）摩擦而产生剪切应力。这样的情况可以用切向速度的罗宾式边界条件来模拟；在这两种情况下，法向（垂直）速度将为零，尽管即使这样也不完全正确，因为大陆板块也有垂直运动（例如，见[1.x.118]的现象）。但是，对于切向速度来说，另一侧的介质也在运动，这已经使事情变得更糟了，因此，在最简单的情况下，剪应力将与[1.x.119]成正比，导致边界条件的形式为
* [1.x.120]
*有一个比例常数[2.x.209]。然而，我们没有走这条路，而是选择了零（棒）和切向流的边界条件。
* 作为一个有趣的附带说明，我们也可以在内部和外部边界上选择切向流动条件。然而，这有一个明显的缺点：它使速度不是唯一定义的。原因是所有对应于实体绕域中心旋转的速度场[2.x.210]都满足[2.x.211]，和[2.x.212]。因此，如果[2.x.213]满足方程和边界条件，那么[2.x.214]也满足。这当然不是一个我们想避免的好情况。传统的方法是在边界上选择一个任意的点，通过选择速度在那里的所有分量为零，把这个点称为你的固定点。(在三维空间中，必须选择两个点。)由于这个程序开始时并不打算太现实，我们通过简单地固定整个内部边界的速度来避免这种复杂情况。
* [2.x.215] 在第一阶中，重力矢量总是指向下方。对于像地球这样大的物体，问题只是："向上 "在哪里。天真的答案当然是 "径向向内，朝向地球中心"。所以在地球表面，我们有[1.x.121]，其中[2.x.216]刚好是地球表面的平均重力加速度。但是在地球内部，问题变得有点复杂：例如，在地球的（轨道）中心，你有物质在各个方向上同样用力拉扯，所以[2.x.217] 。在这之间，净力的描述如下：让我们通过[1.x.123]来定义[1.x.122]，然后[2.x.218] 。如果我们假设整个地球的密度[2.x.219]是恒定的，我们可以产生一个重力矢量的分析表达式（不要试图以某种方式整合上述方程式
*
*-它导致了椭圆积分；更简单的方法是注意到[2.x.220]，并利用径向对称性在所有[2.x.221]中求解这个偏微分方程）。)  [1.x.124]因子[2.x.222]是指向径向内的单位矢量。当然，在这个问题中，我们只对与地球内部有关的分支感兴趣，即[2.x.223] 。因此，我们将只考虑表达式[1.x.125]，我们可以推断出最后一个表达式，因为我们知道地球在表面的重力（其中[2.x.224] ）。
* 我们可以通过整合[2.x.225]的微分方程，在密度分布是径向对称的情况下，即[2.x.226]，推导出一个更一般的表达式。在这种情况下，我们将得到[1.x.126] 。
*

* 然而，这有两个问题。(i) 地球不是均匀的，即密度[2.x.227]取决于[2.x.228]；事实上，它甚至不是一个只取决于半径的函数[2.x.229]。因此，在现实中，重力并不总是随着我们的深入而减少：因为地心的密度比地幔大得多，重力实际上在地心地幔边界的[2.x.230]左右达到峰值（见[1.x.127]）。(ii) 密度，以及由此产生的重力矢量，在时间上甚至不是恒定的：毕竟，我们要解决的问题是与时间相关的热的、密度较小的物质的上涌和冷的密度较大的物质的下涌。这就导致了重力矢量随空间和时间的变化而变化，并不总是直指下方。
* 为了不使情况变得更加复杂，我们可以使用这样的近似值：在地幔的内部边界，重力是[2.x.231]，在外部边界是[2.x.232]，在每一种情况下都是径向向内的，在两者之间，重力随着离地球中心的径向距离而线性变化。这就是说，实际上要稍微现实一点，假设（就像我们下面做的那样）地幔具有恒定的密度并不难。在这种情况下，上面的方程可以被整合，我们可以得到一个[2.x.233]的表达式，我们可以拟合常数以匹配地幔顶部和底部的重力，得到[1.x.128]
* [2.x.234] 地幔的密度在空间上有变化，但变化幅度不大。  [2.x.235]是参考温度[2.x.236]开尔文时的密度的一个相对较好的平均值。
* [2.x.237] 热膨胀系数[2.x.238]也随深度变化（通过其对温度和压力的依赖）。在接近地表的地方，它似乎是[2.x.239]，而在地心地幔边界，它可能更接近[2.x.240]。作为一个合理的值，让我们选择[2.x.241]。那么密度与温度的关系是[2.x.242] 。
* [2.x.243] 我们需要指定的第二个至最后一个参数是粘度 [2.x.244] 。这是一个棘手的问题，因为在地幔典型的温度和压力下，岩石的流动非常缓慢，以至于在实验室里无法准确地确定粘度。那么我们如何知道地幔的粘度呢？最常用的方法是考虑在冰期和冰期之后，冰盾形成和消失的时间尺度比地幔流动的时间尺度短。因此，大陆在冰盾的附加重量下慢慢沉入地幔，而在冰盾再次消失后，它们又慢慢升起（这被称为[1.x.129][1.x.130]）。通过测量这种反弹的速度，我们可以推断出流向反弹的大陆板块下腾出的区域的物质的粘度。
* 利用这种技术，人们发现[2.x.245]附近的数值是最有可能的，尽管这个数值的误差至少是一个数量级的。
* 虽然我们将使用这个值，但我们不得不再次提醒，有许多物理原因可以假设这不是一个正确的值。首先，它确实应该取决于温度：较热的材料很可能比较冷的材料的粘性要小。然而，在现实中，情况甚至更为复杂。地幔中的大多数岩石随着温度和压力的变化而发生相变：根据温度和压力的不同，不同的晶体构型在热力学上比其他的更受青睐，即使地幔的化学成分是均匀的。例如，常见的地幔物质MgSiO<sub>3</sub>在整个地幔的大部分地区以其[1.x.131]的形式存在，但在地幔下部，同样的物质只以[1.x.132]的形式稳定。显然，为了计算现实的粘度，我们不仅需要知道地幔的确切化学成分和所有物质的粘度，而且还必须计算所有物质在每个正交点的热力学上最稳定的配置。在写这个程序的时候，这不是一个可行的建议。
* [2.x.246] 我们的最后一个材料参数是热扩散率[2.x.247] ，其定义为[2.x.248] 其中[2.x.249] 是热导率，[2.x.250] 是密度，[2.x.251] 是比热。对于这一点，文献表明，它从上地幔的[2.x.252]左右增加到下地幔的[2.x.253]左右，尽管确切的数值其实并不那么重要：通过对流的热传输比通过热传导的热传输要重要几个数量级。我们可能有兴趣知道，地幔中最丰富的材料--过氧化物，在超过大约120GPa的压力下似乎变得透明（例如，见J.Badro等人，《科学》305，383-386（2004））；因此，在下地幔中，通过辐射传输的热传输可能比通过热传导更有效。
* 鉴于这些考虑，让我们为本方案的目的选择[2.x.254]。[2.x.255]
* 所有这些方程数据都在程序中定义在[2.x.256]名称空间中。当运行时，该程序产生的长期最大速度约为每年10-40厘米（见下面的结果部分），大约是物理上正确的数量级。我们将设定结束时间为10亿年。
* [2.x.257] 上述常数和材料参数的选择在很大程度上遵循了G. Schubert和D. L. Turcotte和P. Olson（剑桥，2001年）的综合著作《地球和行星的地幔对流，第一部分》。它包含了对使程序更加真实的方法的广泛讨论。
*

*[1.x.133][1.x.134] 。


* 与[2.x.258]相比，本程序有许多值得注意的差异。
*
* - [2.x.259]的命名空间要大得多，这反映了我们现在有更多的物理学需要处理。也就是说，这些额外的物理细节大部分是在这个命名空间的函数中自成一体的，并没有扩散到程序的其他部分。
*
* - 更明显的是，我们把大量的参数放到了一个由ParameterHandler类处理的输入文件中（例如，见[2.x.260]，关于用这个类设置运行时参数文件的方法）。当人们想避免重新编译程序时，这往往是有意义的，只因为他们想玩弄一个参数（例如，想想确定上面讨论的稳定常数的最佳值的参数研究），特别是考虑到重新编译当前规模的程序需要花费非同寻常的时间。为了仅仅概述我们从固定值移入输入文件的参数种类，这里列出了一个典型的[2.x.261]文件。
* [1.x.135]

*
* - 很明显，有相当多的变化是与我们想在可能非常多的机器上运行我们的程序有关的。尽管人们可能会怀疑这需要我们完全重新构造我们的代码，但事实上并非如此（尽管在deal.II中实现大部分功能的类从实现的角度来看肯定非常不同，但这并没有反映在它们的公共接口中）。相反，这些变化大多是微妙的，主类的整体结构几乎没有变化。也就是说，魔鬼在细节中：正确地进行%并行计算，没有死锁，确保正确的数据在正确的地方可用（例如，见关于全分布式向量与有鬼魂元素的向量的讨论），以及避免瓶颈是很困难的，关于这个话题的讨论将出现在本程序中的很多地方。
*

*[1.x.136][1.x.137]


* 这是一个指导性的程序。这意味着至少它的大部分重点需要放在演示如何使用deal.II和相关的库上，而不是通过过度关注物理细节来稀释这个教学课程。尽管上面有关于物理参数选择的长篇大论，但程序中专门讨论这个问题的部分实际上是很短的，而且是自成一体的。
* 也就是说，[2.x.262]和目前的[2.x.263]都不是偶然出现的，而是作为通往更全面的程序的路标，模拟地幔的对流。我们把这个代码称为[1.x.138]（简称[1.x.139]）；它的开发是由国家科学基金会支持的[1.x.140]计划资助的。关于[1.x.141]的更多信息可在其[1.x.142]中找到。
*

* [1.x.143] [1.x.144]。
* [1.x.145] [1.x.146]。


*
* 像往常一样，第一个任务是包括这些著名的deal.II库文件和一些C++头文件的功能。
*


* [1.x.147]
*
* 这是唯一一个新的包含文件：它引入了相当于[2.x.264]的[2.x.265]类，用于在网格细化时将解决方案从一个网格带到下一个网格，但在并行分布式三角计算的情况下。
*


* [1.x.148]
*
* 以下的类用于并行分布式计算，在[2.x.266]中已经全部介绍过。
*


* [1.x.149]

* 下一步就像以前所有的教程程序一样。我们把所有东西放到一个自己的命名空间中，然后把deal.II的类和函数导入其中。
*


* [1.x.150]
*
* [1.x.151] [1.x.152]。


*
* 在下面的命名空间中，我们定义了描述该问题的各种方程数据。这对应于使问题至少有一点现实性的各个方面，并且在介绍中对测试案例的描述中已经详尽地讨论了这些方面。   
* 我们从一些有常数的系数开始（数值后面的注释表示其物理单位）。
*


* [1.x.153]
*
* 下一组定义是用于编码作为温度函数的密度、重力矢量和温度的初始值的函数。同样，所有这些（以及它们所计算的值）都在介绍中讨论过。
*


* [1.x.154]
*
* 正如介绍中提到的，我们需要重新调整压力的比例，以避免动量和质量守恒方程的相对条件不良。比例系数为[2.x.267]，其中[2.x.268]是一个典型的长度尺度。通过实验发现，一个好的长度尺度是烟羽的直径，大约是10公里。
*


* [1.x.155]
*
* 这个命名空间的最后一个数字是一个常数，表示每（平均，热带）年的秒数。我们只在生成屏幕输出时使用它：在内部，这个程序的所有计算都是以SI单位（公斤、米、秒）进行的，但是用秒来写地质学时间产生的数字无法与现实联系起来，所以我们用这里定义的因子转换为年。
*


* [1.x.156]
*
* [1.x.157] [1.x.158]。


*
* 这个命名空间实现了预处理程序。正如介绍中所讨论的，这个预处理程序在一些关键部分与 [2.x.269] 中使用的不同。具体来说，它是一个右预处理器，实现了矩阵的


* [1.x.159]
* 其中两个逆矩阵运算由线性求解器近似，或者，如果给这个类的构造函数以正确的标志，则由单个AMG V-循环来实现速度块的运算。[2.x.270]函数的三个代码块实现了与该预处理矩阵的三个块的乘法运算，如果你读过[2.x.271]或[2.x.272]中关于组成求解器的讨论，应该是不言自明的。
*


* [1.x.160]
*
* [1.x.161] [1.x.162].
* 正如介绍中所述，我们将使用[2.x.273]模块中讨论的WorkStream机制，在一台机器的处理器之间进行并行操作。WorkStream类要求数据在两种数据结构中传递，一种用于抓取数据，一种用于将数据从装配函数传递到将本地贡献复制到全局对象的函数。   
* 下面的命名空间（以及两个子命名空间）包含了服务于这一目的的数据结构的集合，在介绍中讨论的四种操作中的每一种都有一对，我们将想把它们并行化。每个装配例程都会得到两组数据：一个是Scratch数组，收集所有用于计算单元格贡献的类和数组，另一个是CopyData数组，保存将被写入全局矩阵的本地矩阵和向量。而CopyData是一个容器，用来存放最终写入全局矩阵和向量的数据（因此是绝对必要的），Scratch数组只是出于性能方面的考虑而存在；在每个单元上设置一个FEValues对象，要比只创建一次并更新一些衍生数据要昂贵得多。   
* [2.x.274]有四个汇编程序。一个用于斯托克斯系统的预处理矩阵，一个用于斯托克斯矩阵和右手边，一个用于温度矩阵和温度方程的右手边。我们在这里使用[2.x.275]环境为这四个装配组件中的每一个组织从头数组和CopyData对象（因为我们认为这些是我们传递的临时对象，而不是实现自己功能的类，尽管这是区分[2.x.276]es的一个比较主观的观点）。   
* 关于Scratch对象，每个结构都配备了一个构造函数，可以使用[2.x.278]、正交、[2.x.279]（描述弯曲边界的插值）和[2.x.280]实例创建一个[2.x.277]对象。此外，我们手动实现了一个复制构造函数（因为FEValues类本身是不可复制的），并提供了一些额外的矢量字段，用于在计算局部贡献时保存中间数据。   
* 让我们从抓取数组开始，特别是用于组装斯托克斯预处理程序的数组。
*


* [1.x.163]
*
* 下一个是用于组装完整的斯托克斯系统的划痕对象。请注意，我们从上面的StokesPreconditioner类派生出StokesSystem scratch类。我们这样做是因为所有用于组装预处理程序的对象也需要用于实际的矩阵系统和右手边，还有一些额外的数据。这使得程序更加紧凑。还需要注意的是，斯托克斯系统的装配和进一步的温度右手边分别需要温度和速度的数据，所以我们实际上需要两个FEValues对象来处理这两种情况。
*


* [1.x.164]
*
* 在定义了用于组装斯托克斯系统的对象之后，我们对温度系统所需的矩阵的组装也做了同样的工作。一般的结构是非常相似的。
*


* [1.x.165]
*
* 最后的划痕对象用于组装温度系统的右手边。这个对象比上面的对象大得多，因为有更多的量进入温度方程右边的计算。特别是，前两个时间步骤的温度值和梯度需要在正交点评估，还有速度和应变率（即速度的对称梯度），它们作为摩擦加热项进入右侧。尽管有很多条款，但以下内容应该是不言自明的。
*


* [1.x.166]
*
* CopyData对象比Scratch对象更简单，因为它们所要做的就是存储本地计算的结果，直到它们可以被复制到全局矩阵或向量对象中。因此，这些结构只需要提供一个构造函数，一个拷贝操作，以及一些用于本地矩阵、本地向量和本地与全局自由度之间关系的数组（又称[2.x.281]）。同样，我们为我们将使用WorkStream类并行化的四个操作中的每一个都有一个这样的结构。
*


* [1.x.167]
*
* [1.x.168] [1.x.169]。
* 这是主类的声明。它与[2.x.282]非常相似，但有一些区别我们将在下面评论。   
* 该类的顶部与[2.x.283]基本相同，列出了公共方法和一组做重活的私有函数。与[2.x.284]相比，本节只增加了两个内容：计算所有单元的最大CFL数的函数[2.x.285]，然后我们根据它计算全局时间步长；以及用于计算熵值稳定的函数[2.x.286]。它类似于我们在[2.x.288]中用于此目的的[2.x.287]，但它的工作对象是熵而不是温度。
*


* [1.x.170]
*
* 第一个重要的新组件是根据介绍中的讨论为参数定义了一个结构。这个结构是在构建这个对象的过程中通过读取参数文件来初始化的。
*


* [1.x.171]
*
* [2.x.289]（用于[1.x.172]）对象被用来简化写输出：每个MPI进程都可以像往常一样使用它来产生输出，但由于这些进程中的每一个都会（希望）产生相同的输出，它只是被多次复制；使用ConditionalOStream类，只有一个MPI进程产生的输出会真正被打印到屏幕上，而所有其他线程的输出将被简单遗忘。
*


* [1.x.173]
*
* 接下来的成员变量将再次与[2.x.290]中的成员变量相似（也与其他教程程序相似）。正如介绍中提到的，我们完全分布计算，所以我们将不得不使用[2.x.291]类（见[2.x.292] ），但这些变量的其余部分相当标准，有两个例外。
*


*


*


*


*


*


*


*


*


*
* - [2.x.293]变量是用来表示高阶多项式映射的。正如在介绍中提到的，我们在通过正交形成积分时，对所有与我们的域的内边界或外边界相邻的、边界是弯曲的单元使用这种映射。
*


*


*


*


*


*


*


*


*


*
* - 在一个命名混乱的问题上，你会注意到下面一些来自命名空间TrilinosWrappers的变量取自命名空间[2.x.294]（比如右手边的向量），而其他变量则不是（比如各种矩阵）。这是由于遗留的原因。我们经常需要查询任意正交点的速度和温度；因此，每当我们需要访问与本地相关但属于另一个处理器的自由度时，我们不是导入矢量的幽灵信息，而是以%并行方式求解线性系统，但随后立即初始化一个矢量，包括求解的幽灵项，以便进一步处理。因此，各种[2.x.295]向量在以%parallel求解各自的线性系统后立即被填充，并将始终包含所有[2.x.296]"本地相关自由度 "的值；我们从求解过程中获得的完全分布的向量，只包含[2.x.297]"本地拥有的自由度"，在求解过程中和我们将相关值复制到成员变量向量后，立即被销毁。
*


* [1.x.174]
*
* 下一个成员变量，[2.x.298]是用来方便核算重复输入的某些代码 "部分 "的计算时间。例如，我们将进入（和离开）斯托克斯矩阵装配的部分，并希望在所有的时间步骤中累积在这部分花费的运行时间。每隔一段时间，以及在程序结束时（通过TimerOutput类的析构器），我们将产生一个漂亮的摘要，总结在不同部分所花费的时间，我们把这个程序的运行时间归类为这些部分。
*


* [1.x.175]
*
* 在这些成员变量之后，我们有一些辅助函数，这些函数已经从上面列出的函数中分解出来。具体来说，首先有三个函数是我们从[2.x.299]中调用的，然后是做线性系统的组装的。
*


* [1.x.176]
*
* 遵循[2.x.300]"基于任务的并行化 "范式，我们将所有的装配例程分成两部分：第一部分可以在某个单元上进行所有的计算，而不需要照顾其他线程；第二部分（就是将本地数据写入全局矩阵和向量中），每次只能由一个线程进入。为了实现这一点，我们为这一程序中使用的所有四个汇编例程的这两个步骤分别提供了函数。以下八个函数正是这样做的。
*


* [1.x.177]
*
* 最后，我们向前声明一个成员类，我们将在以后定义这个成员类，它将被用来从我们的解决方案向量中计算一些数量，我们想把这些数量放到输出文件中，用于可视化。
*


* [1.x.178]
*
* [1.x.179] [1.x.180]。



* [1.x.181] [1.x.182]。
* 这里是对斯托克斯问题的参数的定义。我们允许设置模拟的结束时间、细化水平（包括全局和适应性，总的来说就是指定允许单元的最大水平），以及细化的时间步长间隔。   
* 然后，我们让用户指定稳定参数的常数（如介绍中所讨论的），斯托克斯速度空间的多项式程度，是否对压力使用基于FE_DGP元素的局部保守离散化（对压力使用FE_Q元素），以及对温度插值的多项式程度。   
* 构造函数检查是否有有效的输入文件（如果没有，将写一个带有默认参数的文件），并最终解析参数。
*


* [1.x.183]
*
* 接下来我们有一个函数，声明我们在输入文件中期望的参数，以及它们的数据类型、默认值和描述。
*


* [1.x.184]
*
* 然后我们需要一个函数来读取我们通过读取输入文件得到的ParameterHandler对象的内容，并将结果放入储存我们之前声明的参数值的变量。
*


* [1.x.185]
*
* [1.x.186] [1.x.187].
* 该问题的构造函数与 [2.x.301] 中的构造函数非常相似。不同的是%并行通信。Trilinos使用消息传递接口（MPI）进行数据分配。当进入BoussinesqFlowProblem类时，我们必须决定如何进行并行化。我们选择一个相当简单的策略，让所有正在运行程序的处理器一起工作，由通信器 [2.x.302] 指定。接下来，我们创建输出流（就像我们在[2.x.303]中已经做的那样），它只在第一个MPI进程上产生输出，而在其他所有进程上则完全不考虑。这个想法的实现是在[2.x.304]得到一个真实参数时检查进程号，它使用[2.x.305]流进行输出。例如，如果我们是一个处理器五，那么我们将给出一个 [2.x.306] ，这意味着该处理器的输出将不会被打印。除了映射对象（我们对其使用4度的多项式），除了最后的成员变量，其他都与 [2.x.307] 中的完全相同。   
* 这个最后的对象，TimerOutput对象，然后被告知限制输出到[2.x.308]流（处理器0），然后我们指定要在程序结束时得到一个汇总表，该表显示我们的壁时钟时间（而不是CPU时间）。我们还将在下面的[2.x.309]函数中手动请求每隔这么多时间步骤的中间总结。
*


* [1.x.188]
*
* [1.x.189] [1.x.190]。
* [1.x.191] [1.x.192]。


*
* 除了两个小细节，计算速度的全局最大值的函数与[2.x.310]中的相同。第一个细节实际上是所有在三角形的所有单元上实现循环的函数所共有的。当以%并行方式操作时，每个处理器只能处理一大块单元，因为每个处理器只拥有整个三角形的某一部分。我们要处理的这块单元是通过所谓的[2.x.311]来确定的，我们在[2.x.312]中也做过。因此，我们需要改变的是只对当前进程所拥有的单元格（相对于幽灵或人造单元格）进行与单元格相关的操作，即对子域id等于进程ID的数字。由于这是一个常用的操作，所以这个操作有一个捷径：我们可以用 [2.x.313] 询问单元格是否为当前处理器所拥有。   
* 第二个区别是我们计算最大值的方式。以前，我们可以简单地有一个[2.x.314]变量，在每个单元的每个正交点上检查。现在，我们必须更加小心，因为每个处理器只对一个单元的子集进行操作。我们要做的是，首先让每个处理器计算其单元中的最大值，然后做一个全局通信操作[2.x.315]，计算各个处理器所有最大值中的最大值。MPI提供了这样的调用，但更简单的是使用MPI通信器对象在命名空间[2.x.316]中使用相应的函数，因为即使我们没有MPI并且只在一台机器上工作，这也会做正确的事情。对[2.x.317]的调用需要两个参数，即本地最大值（input）和MPI通信器，在这个例子中是MPI_COMM_WORLD。
*


* [1.x.193]
*
* [1.x.194] [1.x.195]。


*
* 下一个函数做了类似的事情，但我们现在计算CFL数，即一个单元上的最大速度除以单元直径。这个数字对于确定时间步长是必要的，因为我们对温度方程使用半显式的时间步长方案（讨论见[2.x.318]）。我们的计算方法与上述相同。在所有本地拥有的单元上计算本地最大值，然后通过MPI交换，找到全球最大值。
*


* [1.x.196]
*
* [1.x.197] [1.x.198]。


*
* 接下来是计算全局熵的变化[2.x.319]，其中熵[2.x.320]的定义如介绍中所讨论的。  这对于评估温度方程中的稳定度是需要的，正如介绍中所解释的。实际上，只有当我们在残差计算中使用[2.x.321]作为幂时，才需要熵的变化。无限准则是由正交点上的最大值计算的，就像离散计算中通常的那样。   
*为了计算这个量，我们首先要找到空间平均数[2.x.322]，然后评估最大值。然而，这意味着我们需要执行两个循环。我们可以通过注意到[2.x.323]，即在正负方向上与平均熵的偏差的最大值来避免开销。我们在后一个公式中需要的四个量（最大熵、最小熵、平均熵、面积）都可以在所有单元格的同一个循环中评估，所以我们选择这个更简单的变体。
*


* [1.x.199]
*
* 在上面的两个函数中，我们计算了全部为非负数的数字的最大值，所以我们知道零肯定是一个下界。另一方面，在这里我们需要找到与平均值的最大偏差，也就是说，我们需要知道熵的最大和最小值，而我们并不预先知道其符号。     
* 为了计算它，我们因此可以从我们可以存储在一个双精度数字中的最大和最小的可能值开始。最小值被初始化为一个更大的数字，最大值被初始化为一个比任何一个将要出现的数字更小的数字。然后，我们保证这些数字将在第一个单元的循环中被覆盖，或者，如果这个处理器不拥有任何单元，最迟在通信步骤中被覆盖。下面的循环将计算最小和最大的本地熵，并跟踪我们本地拥有的域的部分的面积/体积，以及对它的熵的积分。
*


* [1.x.200]
*
* 现在我们只需要在处理器之间交换数据：我们需要将两个积分相加（ [2.x.324] ），并得到最大和最小的极值。我们可以通过四个不同的数据交换来完成这个任务，但我们只需要两个就可以了。  [2.x.325]也存在一个变体，它接收一个数组的值，这些值都要被加起来。我们还可以利用[2.x.326]函数，认识到在最小熵上形成最小值等于在最小熵的负值上形成最大值的负值；然后这个最大值可以与在最大熵上形成的最大值相结合。
*


* [1.x.201]
*
* 以这种方式计算了所有的东西之后，我们就可以计算平均熵，并通过取最大值或最小值与平均值的偏差中的较大者来找到[2.x.327]规范。
*


* [1.x.202]
*
* [1.x.203] [1.x.204]。


*
* 下一个函数是计算整个领域内外推温度的最小值和最大值。同样，这只是[2.x.328]中相应函数的一个稍加修改的版本。和上面的函数一样，我们收集局部最小值和最大值，然后用上面的技巧计算出全局极值。   
* 正如在[2.x.329]中已经讨论过的，该函数需要区分第一个和所有后续的时间步骤，因为当至少有两个以前的时间步骤时，它使用了一个高阶温度外推方案。
*


* [1.x.205]
*
* [1.x.206] [1.x.207]。


*
* 计算粘度的函数是纯粹的局部函数，所以根本不需要通信。它与[2.x.330]中的函数基本相同，但如果选择[2.x.331]，则对粘度的表述会有所更新。
*


* [1.x.208]
*
* [1.x.209] [1.x.210]。


*
* 下面的三个函数设置了斯托克斯矩阵、用于斯托克斯预处理的矩阵和温度矩阵。该代码与[2.x.332]中的代码基本相同，但为了简单起见，它被分成了三个自己的函数。   
* 这里的代码与[2.x.333]中的代码在功能上的主要区别是，我们要建立的矩阵是分布在多个处理器上。由于我们仍然希望出于效率的原因先建立起稀疏性模式，我们可以继续将[1.x.211]的稀疏性模式作为BlockDynamicSparsityPattern来建立，就像我们在[2.x.334]中做的那样。然而，这将是低效的：每个处理器将建立相同的稀疏模式，但只使用它初始化矩阵的一小部分。这也违反了一个原则，即每个处理器应该只在它拥有的单元上工作（如果有必要的话，还有它周围的幽灵单元层）。   
* 相反，我们使用一个类型为[2.x.335]的对象，它（显然）是对Trilinos提供的稀疏模式对象的一个包装器。这样做的好处是Trilinos稀疏模式类可以在多个处理器之间进行通信：如果这个处理器填入它所拥有的单元格产生的所有非零条目，而其他每个处理器也都这样做，那么在由[2.x.336]调用发起的MPI通信结束后，我们将有全局组装的稀疏模式可用，全局矩阵可以被初始化。   
* 在并行初始化Trilinos稀疏性模式时，有一个重要的方面。除了通过[2.x.337]索引集指定矩阵的本地拥有的行和列之外，我们还提供了在某个处理器上装配时可能要写进的所有行的信息。本地相关行的集合包含了所有这样的行（可能还有一些不必要的行，但在实际获得所有单元格的索引和解决约束之前，很难找到准确的行索引）。这种额外的信息可以准确地确定在装配过程中发现的非处理器数据的结构。虽然Trilinos矩阵也能在飞行中收集这些信息（当从其他一些reinit方法初始化它们时），但效率较低，在用多线程组装矩阵时，会导致问题。在这个程序中，我们悲观地假设每次只有一个处理器可以在组装时写入矩阵（而计算是并行的），这对特里诺斯矩阵是没有问题的。在实践中，可以通过在不共享顶点的单元中提示WorkStream来做得更好，允许这些单元之间的并行性（参见图形着色算法和带有彩色迭代器的WorkStream参数）。然而，这只在只有一个MPI处理器的情况下有效，因为Trilinos的内部数据结构在飞行中积累非处理器的数据，不是线程安全。有了这里介绍的初始化，就不存在这样的问题，人们可以安全地为这个算法引入图形着色。   
* 我们唯一需要做的改变是告诉[2.x.338]函数，它只应该在一个单元格子集上工作，即那些[2.x.339]等于当前处理器编号的单元格，而忽略所有其他单元格。   
* 这一策略被复制到以下三个函数中。   
* 请注意，Trilinos矩阵存储的信息包含在稀疏模式中，所以一旦矩阵被赋予稀疏结构，我们就可以安全地释放[2.x.340]变量。
*


* [1.x.212]
*
* 设置函数的其余部分（在拆分出上面的三个函数后）主要是处理我们需要做的跨处理器并行化的事情。因为设置所有这些都是程序的一个重要的计算时间支出，我们把我们在这里做的所有事情放到一个定时器组中，这样我们就可以在程序结束时得到关于这部分时间的总结信息。   
* 在顶部像往常一样，我们列举自由度，并按组件/块进行排序，然后从零号处理器开始将它们的数字写到屏幕上。当[2.x.341]函数应用于[2.x.342]对象时，对自由度进行排序，与子域0相关的所有自由度排在与子域1相关的所有自由度之前，等等。对于斯托克斯部分，这意味着速度和压力会混在一起，但这可以通过再次按块排序来解决；值得注意的是，后一种操作只保留了所有速度和压力的相对顺序，即在速度块内，我们仍然会将所有与子域零相关的速度放在与子域一相关的速度之前，等等。这一点很重要，因为我们把这个矩阵的每一个块都分布在所有的处理器上，并且希望这样做的方式是，每个处理器存储的矩阵部分与它将实际工作的单元上的自由度大致相等。   
* 当打印自由度的数字时，注意如果我们使用许多处理器，这些数字将会很大。因此，我们让流在每三个数字之间放一个逗号分隔符。流的状态，使用locale，从这个操作之前保存到之后。虽然有点不透明，但这段代码是有效的，因为默认的locale（我们使用构造函数调用[2.x.343]得到的）意味着打印数字时，每三位数字都有一个逗号分隔符（即千、百万、十亿）。   
* 在这个函数以及下面的许多函数中，我们测量了我们在这里花费的时间，并将其收集在一个名为 "设置dof系统 "的部分中，跨函数调用。这是用一个[2.x.344]对象完成的，该对象在构建本地变量时，在`computing_timer`对象的上述部分中启动了一个定时器；当`timing_section`变量的析构器被调用时，定时器又被停止。  当然，这要么发生在函数的结尾，要么我们通过`return`语句离开函数，或者在某个地方抛出异常时发生。
*
* - 换句话说，只要我们以任何方式离开这个函数。因此，使用这种 "范围 "对象可以确保我们不必手动添加代码，告诉定时器在每个可能离开这个函数的地方停止。
*


* [1.x.213]
*
* 在这之后，我们必须设置各种分区器（类型为[2.x.345] ，见介绍），描述每个矩阵或向量的哪些部分将被存储在哪里，然后调用实际设置矩阵的函数，最后还要调整我们在这个程序中保留的各种向量的大小。
*


* [1.x.214]
*
* 在这之后，我们可以计算解向量的约束，包括悬挂节点的约束以及斯托克斯和温度场的同质和非同质边界值。请注意，与其他一切一样，约束对象不能在每个处理器上都持有[1.x.215]约束。相反，鉴于每个处理器只在其拥有的单元上组装线性系统，因此每个处理器只需要存储那些对正确性实际必要的约束。正如在[2.x.346]"本文 "中所讨论的，我们需要知道的约束集正是所有本地相关自由度的约束集，所以这就是我们用来初始化约束对象的东西。
*


* [1.x.216]
*
* 所有这些完成后，我们就可以将各种矩阵和向量对象初始化为适当的大小。在最后，我们还记录了所有的矩阵和预调节器都必须在下一个时间步长开始时重新计算。注意我们是如何初始化斯托克斯和温度右侧的向量的。这些是可写的向量（最后一个布尔参数设置为[2.x.347]），具有正确的本地拥有元素的一对一分区，但仍被赋予相关的分区，以弄清要立即设置的向量条目。至于矩阵，这允许用多个线程将本地贡献写入向量（总是假设同一向量条目不被多个线程同时访问）。其他向量只允许读取单个元素的访问，包括鬼魂，但不适合求解器。
*


* [1.x.217]
*
* [1.x.218] [1.x.219]。
* 按照介绍和[2.x.348]模块中的讨论，我们将汇编函数分成不同的部分。
* [2.x.349] [2.x.350] 矩阵和右手边的局部计算，给定某个单元格作为输入（这些函数在下面命名为[2.x.351]）。换句话说，所产生的函数本质上是[2.x.352]中所有单元格的循环体。然而，请注意，这些函数将本地计算的结果存储在CopyData命名空间的类的变量中。   
* [2.x.353] 然后这些对象被交给第二步，将本地数据写入全局数据结构中（这些函数被命名为下面的[2.x.354]）。这些函数是相当琐碎的。   
* [2.x.355] 这两个子函数然后被用于各自的汇编例程（下面称为[2.x.356]），在那里，一个WorkStream对象被设置并在属于处理器子域的所有单元中运行。   [2.x.357]
*


* [1.x.220] [1.x.221]。
* 让我们从构建斯托克斯预处理程序的函数开始。考虑到上面的讨论，其中的前两个是非常微不足道的。特别要注意的是，使用scratch数据对象的要点是，我们要避免每次访问新单元时在自由空间上分配任何对象。因此，下面的汇编函数只有自动的局部变量，其他的都是通过从头开始的数据对象访问的，在我们开始对所有单元进行循环之前，只分配了一次。
*


* [1.x.222]
*
* 现在是使用WorkStream函数实际把事情放在一起的函数。   [2.x.358]需要一个开始和结束迭代器来列举它应该工作的单元格。通常，我们会使用[2.x.359]和[2.x.360]来做这件事，但在这里，我们实际上只想获得实际上由当前处理器拥有的单元格子集。这就是FilteredIterator类发挥作用的地方：你给它一个单元格的范围，它提供一个迭代器，只迭代满足某个谓词的单元格子集（谓词是一个参数的函数，要么返回真，要么返回假）。我们在这里使用的谓词是[2.x.361]，也就是说，如果单元格为当前处理器所拥有，它正好返回真。这样得到的迭代器范围正是我们需要的。   
* 解决了这个障碍，我们用这组单元格、scratch和copy对象以及两个函数的指针来调用[2.x.362]函数：本地汇编和copy-local-to-global函数。这些函数需要有非常具体的签名：前者有三个参数，后者有一个参数（关于这些参数的含义，请参见[2.x.363]函数的文档）。注意我们是如何使用lambda函数来创建一个满足这一要求的函数对象的。它使用了指定单元格、抓取数据和复制数据的本地装配函数的函数参数，以及期望将数据写入全局矩阵的复制函数的函数参数（也可参见[2.x.364]的[2.x.365]函数中的讨论）。另一方面，成员函数的隐含的第2个参数（即该成员函数要操作的对象的[2.x.366]指针）是[1.x.223]到当前函数的[2.x.367]指针的，并被捕获。因此，[2.x.368]函数不需要知道这些函数所操作的对象的任何信息。   
* 当WorkStream被执行时，它将为几个单元创建几个第一类的本地装配例程，并让一些可用的处理器对它们进行工作。然而，需要同步的函数，即向全局矩阵的写操作，每次只由一个线程按规定的顺序执行。当然，这只适用于单个MPI进程上的并行化。不同的MPI进程将有自己的WorkStream对象，并完全独立地进行这项工作（并且在不同的内存空间）。在分布式计算中，一些数据将积累在不属于各自处理器的自由度上。如果每次遇到这样的自由度就把数据送来送去，那就没有效率了。取而代之的是，Trilinos稀疏矩阵将保留这些数据，并在装配结束时通过调用[2.x.369]命令将其发送给所有者。
*


* [1.x.224]
*
* 这个模块的最后一个函数启动了斯托克斯预处理矩阵的装配，然后实际上是建立了斯托克斯预处理。它与串行情况下的功能基本相同。与[2.x.370]的唯一区别是，我们对压力质量矩阵使用雅可比预处理，而不是IC，正如在介绍中所讨论的。
*


* [1.x.225]
*
* [1.x.226] [1.x.227]。


*
* 接下来的三个函数实现了斯托克斯系统的装配，同样分为执行局部计算的部分，一个用于将局部数据写入全局矩阵和向量，一个用于在WorkStream类的帮助下实际运行所有单元的循环。请注意，只有在我们改变了网格的情况下才需要进行斯托克斯矩阵的组装。否则，这里只需要计算（与温度有关的）右手边。由于我们正在处理分布式矩阵和向量，我们必须在装配结束时调用相应的[2.x.371]函数，以便将非本地数据发送到所有者进程。
*


* [1.x.228]
*
* [1.x.229] [1.x.230]。



* 接下来三个函数要完成的任务是计算质量矩阵和温度系统的拉普拉斯矩阵。这些将被结合起来，以产生半隐式时间步进矩阵，该矩阵由质量矩阵加上一个与时间[2.x.372]相关的权重系数乘以拉普拉斯矩阵组成。这个函数实质上又是来自 [2.x.373] 的所有单元的循环体。   
* 以下两个函数的服务与上面的函数类似。
*


* [1.x.231]
*
* [1.x.232] [1.x.233]。


*
* 这是最后一个装配函数。它计算温度系统的右侧，其中包括对流和稳定项。它包括在正交点上对旧解的大量评估（这对于计算稳定化的人工粘性是必要的），但在其他方面与其他装配函数类似。请注意，我们再次解决了具有不均匀边界条件的困境，只是在这一点上做了一个右手边（比较上面对[2.x.374]函数的评论）。我们创建一些矩阵列，其值正好是为温度刚度矩阵输入的值，以防我们有不均匀约束的道夫。这将说明右边的向量与温度矩阵系统的正确平衡。
*


* [1.x.234]
*
* 在运行实际计算右手边的WorkStream的函数中，我们也生成了最终的矩阵。如上所述，它是质量矩阵和拉普拉斯矩阵的总和，再加上一些与时间[2.x.375]相关的权重。这个权重是由BDF-2时间积分方案指定的，见 [2.x.376] 中的介绍。本教程中的新内容（除了使用MPI并行化和WorkStream类），是我们现在也预先计算了温度预处理程序。原因是与求解器相比，设置雅可比预处理器需要明显的时间，因为我们通常只需要10到20次迭代来解决温度系统（这听起来很奇怪，因为雅可比实际上只包括一个对角线，但在Trilinos中，它是从更普遍的点松弛预处理器框架衍生出来的，效率有点低）。因此，尽管由于时间步长可能会发生变化，矩阵条目可能会略有变化，但预先计算预处理程序的效率更高。这不是一个太大的问题，因为我们每隔几步就重新啮合一次（然后重新生成预调节器）。
*


* [1.x.235]

* 接下来的部分是计算右手边的向量。  为此，我们首先计算平均温度 [2.x.377]，我们通过残差 [2.x.378] 来评估人工黏度的稳定度。我们通过在熵粘度的定义中把最高和最低温度之间的中点定义为平均温度来做到这一点。另一种方法是使用积分平均，但结果对这种选择不是很敏感。那么剩下的部分只需要再次调用[2.x.379]，将每次调用都相同的[2.x.380]函数的参数绑定到正确的值上。
*


* [1.x.236]
*
* [1.x.237] [1.x.238]。


*
* 这个函数解决了Boussinesq问题的每个时间步的线性系统。首先，我们在斯托克斯系统上工作，然后在温度系统上工作。实质上，它所做的事情与 [2.x.381] 中的相应函数相同。然而，这里有一些变化。   
* 第一个变化与我们存储解决方案的方式有关：我们在每个MPI节点上保留具有本地拥有的自由度的向量加鬼魂节点。当我们进入一个应该用分布式矩阵执行矩阵-向量乘积的求解器时，这并不是合适的形式，虽然。在那里，我们希望求解向量的分布方式与矩阵的分布方式相同，即没有任何重影。因此，我们首先要做的是生成一个名为[2.x.382]的分布式向量，并只将本地拥有的dof放入其中，这由特里诺斯向量的[2.x.383]巧妙地完成。   
* 接下来，我们为求解器缩放压力解（或者说，初始猜测），使其与矩阵中的长度尺度相匹配，正如在介绍中讨论的那样。在求解完成后，我们也会立即将压力值缩回到正确的单位。  我们还需要将悬挂节点的压力值设置为零。这一点我们在[2.x.384]中也做过，以避免一些在求解阶段实际上无关紧要的向量项干扰舒尔补数。与[2.x.385]不同的是，这里我们只对局部拥有的压力道夫进行处理。在对斯托克斯解进行求解后，每个处理器将分布式解复制到解向量中，其中也包括幽灵元素。   
* 第三个也是最明显的变化是，我们有两种斯托克斯求解器的变体。一种是有时会崩溃的快速求解器，另一种是较慢的稳健求解器。这就是我们在介绍中已经讨论过的。以下是我们如何实现它的。首先，我们用快速求解器进行30次迭代，该求解器是基于AMG V型循环的简单预处理，而不是近似求解（这由[2.x.386]对象的参数来表示）。如果我们收敛了，一切都很好。如果我们没有收敛，求解器控制对象将抛出一个异常[2.x.388]通常，这将中止程序，因为我们在通常的[2.x.389]函数中没有捕获它们。这当然不是我们想在这里发生的。相反，我们希望切换到强求解器，并继续用我们目前得到的任何矢量进行求解。因此，我们用C++的try/catch机制来捕获这个异常。然后我们在[2.x.390]子句中简单地再次经历相同的求解器序列，这次我们将[2.x.391]标志传递给强求解器的预处理程序，标志着一个近似CG求解。
*


* [1.x.239]
*
* 现在让我们转到温度部分。首先，我们计算时间步长的大小。我们发现，对于壳的几何形状，我们需要三维的时间步长比二维的小。这是因为在这种情况下，单元格的变形更大（决定CFL数值的是最小的边长）。我们不是像[2.x.392]中那样从最大速度和最小网格尺寸计算时间步长，而是计算局部的CFL数，即在每个单元上计算最大速度乘以网格尺寸，并计算它们的最大值。因此，我们需要将时间步长前面的因子选择得稍微小一些。     
*在温度的右手边装配后，我们解决温度的线性系统（有完全分布的向量，没有任何重影），应用约束条件，并将向量复制回有重影的向量。     
* 最后，我们提取温度范围与[2.x.393]类似，以产生一些输出（例如为了帮助我们选择稳定常数，如介绍中所讨论的）。唯一的区别是，我们需要在所有处理器上交换最大值。
*


* [1.x.240]

* [1.x.241] [1.x.242]。


*
* 接下来是生成输出的函数。输出的数量可以像我们在 [2.x.394] 中那样手动引入。另一种方法是把这个任务交给一个继承自DataPostprocessor类的PostProcessor，它可以被附加到DataOut。这允许我们从解决方案中输出派生量，比如本例中的摩擦热。它重载了虚拟函数[2.x.395]，然后从[2.x.396]内部调用。 我们必须给它数值解、它的导数、单元的法线、实际评估点和任何额外的数量。这与[2.x.397]和其他程序中讨论的程序相同。
*


* [1.x.243]
*
* 这里我们定义了我们要输出的变量的名称。这些是速度、压力和温度的实际求解值，以及摩擦热和每个单元拥有的处理器的编号。这使我们能够直观地看到处理器之间的领域划分。除了速度是矢量值的，其他的量都是标量。
*


* [1.x.244]
*
* 现在我们实现计算派生量的函数。正如我们对输出所做的那样，我们将速度从其SI单位重新调整为更容易阅读的单位，即厘米/年。接下来，压力被缩放到0和最大压力之间。这使得它更容易比较
*
* - 实质上使所有的压力变量都是正数或零。温度按原样计算，摩擦热按 [2.x.398] 计算。   
* 我们在这里输出的数量更多是为了说明问题，而不是为了实际的科学价值。我们在本程序的结果部分简要地回到这一点，并解释人们实际上可能感兴趣的是什么。
*


* [1.x.245]
*
* [2.x.399]函数的任务与[2.x.400]中的类似。然而，在这里我们要演示一种不同的技术，即如何合并来自不同DoFHandler对象的输出。我们要实现这种重组的方法是创建一个联合的DoFHandler，收集两个部分，斯托克斯解和温度解。这可以通过将两个系统的有限元结合起来形成一个FES系统来很好地完成，并让这个集体系统定义一个新的DoFHandler对象。为了确保一切都做得很正确，我们进行了一次理智的检查，确保我们从斯托克斯和温度两个系统中得到了所有的道夫，甚至是在组合系统中。然后我们将数据向量合并。不幸的是，没有直接的关系告诉我们如何将斯托克斯和温度矢量分类到联合矢量中。我们可以绕过这个麻烦的方法是依靠FES系统中收集的信息。对于一个单元上的每个dof，联合有限元知道它属于哪个方程分量（速度分量、压力或温度）--这就是我们所需要的信息！这就是我们所需要的。因此，我们通过所有单元（迭代器进入所有三个DoFHandlers同步移动），对于每个联合单元dof，我们使用[2.x.401]函数读出该分量（关于其返回值的各个部分的描述见这里）。我们还需要跟踪我们是在斯托克斯道次还是温度道次，这包含在joint_fe.system_to_base_index(i).first.first中。最终，三个系统中的任何一个系统的dof_indices数据结构都会告诉我们全局矢量和局部dof之间的关系在当前单元上是怎样的，这就结束了这项繁琐的工作。我们确保每个处理器在建立联合求解向量时，只在其本地拥有的子域上工作（而不是在幽灵或人工单元上）。然后在[2.x.402]中也要这样做，但该函数会自动这样做。   
* 我们最终得到的是一组补丁，我们可以使用DataOutBase中的函数以各种输出格式编写补丁。在这里，我们必须注意，每个处理器所写的实际上只是它自己领域的一部分，也就是说，我们要把每个处理器的贡献写进一个单独的文件。我们通过在写解决方案时给文件名添加一个额外的数字来做到这一点。这其实并不新鲜，我们在 [2.x.403] 中也是这样做的。注意，我们用压缩格式[2.x.404]而不是普通的vtk文件来写，这样可以节省不少存储空间。   
* 所有其余的工作都是在PostProcessor类中完成的。
*


* [1.x.246]
*
* [1.x.247] [1.x.248]。


*
* 这个函数也不是真正的新函数。因为我们在中间调用的[2.x.405]函数有自己的定时器部分，所以我们把这个函数的定时分成两部分。这也可以让我们很容易地识别出这两个中哪个更昂贵。   
* 不过，有一点值得注意的是，我们只想在本地拥有的子域上计算错误指标。为了实现这一点，我们向[2.x.406]函数传递一个额外的参数。请注意，用于误差估计的向量被调整为当前进程上存在的活动单元的数量，这小于所有处理器上活动单元的总数（但多于本地拥有的活动单元的数量）；每个处理器只有本地拥有的单元周围有一些粗略的单元，这在 [2.x.407] 中也有解释。   
* 然后，本地误差估计值被交给GridRefinement的%并行版本（在命名空间[2.x.408]中，也见[2.x.409]），它查看误差并通过比较各处理器的误差值找到需要细化的单元。正如在[2.x.410]中，我们希望限制最大的网格级别。因此，如果有些单元格已经被标记为最细的级别，我们只需清除细化标志。
*


* [1.x.249]
*
* 有了所有标记的必要，我们就可以告诉[2.x.411]对象准备将数据从一个网格转移到下一个网格，当Triangulation通知它们时，它们就会作为[2.x.412]调用的一部分来做。语法类似于非%并行解决方案的传输（例外的是这里有一个指向向量项的指针就足够了）。下面函数的其余部分是在网格细化后再次设置数据结构，并在新的网格上恢复求解向量。
*


* [1.x.250]
*
* 强制执行约束条件，使插值后的解在新的网格上符合要求。
*


* [1.x.251]
*
* 强制执行约束条件，使插值后的解在新的网格上符合要求。
*


* [1.x.252]
*
* [1.x.253] [1.x.254]。


*
* 这是这个类中的最后一个和控制性的函数。事实上，它运行了整个程序的其余部分，并且再次与 [2.x.413] 非常相似。唯一的实质性区别是我们现在使用了一个不同的网格（一个[2.x.414]而不是一个简单的立方体几何）。
*


* [1.x.255]
*
* [2.x.415]通过deal.II自己的本地MatrixFree框架支持具有大多数标准有限元素的并行矢量类：由于我们使用中等阶数的标准拉格朗日元素，这个功能在这里很好地工作。
*


* [1.x.256]
*
* 在如此计算了当前的温度场之后，让我们设置保存温度节点的成员变量。严格地说，我们实际上只需要设置[2.x.416]，因为我们要做的第一件事是计算斯托克斯解，它只需要前一个时间步长的温度场。尽管如此，如果我们想扩展我们的数值方法或物理模型，不初始化其他的向量也不会有什么好处（尤其是这是一个相对便宜的操作，而且我们只需要在程序开始时做一次），所以我们也初始化[2.x.417]和[2.x.418]。这个赋值可以确保左边的向量（初始化后也包含鬼魂元素）也得到正确的鬼魂元素。换句话说，这里的赋值需要处理器之间的通信。
*


* [1.x.257]
*
* 为了加快线性求解器的速度，我们从旧的时间水平上推断出新的解决方案。这可以提供一个非常好的初始猜测，将求解器所需的迭代次数减少一半以上。我们不需要在最后一次迭代中进行推断，所以如果我们达到了最后的时间，我们就在这里停止。         
* 作为一个时间步骤中的最后一件事（在实际提高时间步骤的数量之前），我们检查当前时间步骤的数量是否被100整除，如果是的话，我们让计算计时器打印一个迄今为止所花费的CPU时间的摘要。
*


* [1.x.258]
*
* Trilinos sadd不喜欢鬼魂向量，即使作为输入。暂时复制到分布式向量中。
*


* [1.x.259]
*
* 如果我们要生成图形输出，那么也要为最后一个时间步长做这件事，除非我们在离开do-while循环之前刚刚做过这件事。
*


* [1.x.260]
*
* [1.x.261] [1.x.262]。


*
* 主函数像往常一样简短，与 [2.x.419] 中的函数非常相似。由于我们使用了一个在命令行中被指定为参数的文件，我们必须在这里读取它，并将其传递给Parameters类进行解析。如果在命令行中没有给出文件名，我们就简单地使用与程序一起分发的 [2.x.420] 文件。
*

*
* 因为除非你投入大量的处理器，否则3D计算是非常慢的，程序默认为2D计算。你可以通过把下面的常数维度改为3来获得三维版本。
*


* [1.x.263]
* [1.x.264][1.x.265] 。


* 当运行时，该程序以与[2.x.421]相同的方式模拟三维对流，尽管有一个完全不同的测试案例。
*

*[1.x.266][1.x.267]


* 然而，在我们讨论这个测试案例之前，让我们展示一下这个程序的稍早版本的一些结果，该版本正是在解决我们在[2.x.422]中使用的测试案例，只是我们现在以并行方式和更高的分辨率来解决它。我们展示这些结果主要是为了比较。
* 下面是两张图片，显示了这种更高的分辨率，如果我们在[2.x.423]中选择一个3D计算，如果我们设置[2.x.424]和[2.x.425]。在所示的时间步骤中，themeshes大约有72,000和236,000个单元，分别为2,680,000和8,250,000个自由度，比我们在[2.x.426]中的可用数量级要多得多。
* [2.x.427]
* 计算是在德克萨斯A&amp;M大学Brazoscluster的50个处理器的子集上完成的。
*

*[1.x.268][1.x.269]


* 接下来，我们将用目录中的参数文件运行[2.x.428]，但有一点变化：我们将最终时间增加到1e9。这里我们使用的是16个处理器。启动的命令是（注意，[2.x.429] .prm是默认的）。
* <code><pre></p><p> [2.x.430] mpirun
*
* - p 16 ./ [2.x.431] 活动单元的数量：12,288（在6层）自由度的数量：186624（99,840+36,864+49,920）。
* 时间步数0：t=0年
* 重建斯托克斯预处理程序...   解决斯托克斯系统...41次迭代。   最大速度：60.4935厘米/年 时间步长：18166.9年 温度的17次CG迭代 温度范围：973 4273.16
* 活动单元的数量：15,921（在7层）自由度的数量：252,723（136,640+47,763+68,320)
* 时间步数0：t=0年
* 重建斯托克斯预处理程序...   解决斯托克斯系统...50次迭代。   最大速度：60.3223厘米/年 时间步长：10557.6年 温度的19次CG迭代 温度范围：973 4273.16
* 活动单元的数量：19,926（在8层）自由度的数量：321,246（174,312+59,778+87,156）。
* 时间步数0：t=0年
* 重建斯托克斯预处理程序...   解决斯托克斯系统...50次迭代。   最大速度：57.8396厘米/年 时间步长：5453.78年 温度的18次CG迭代 温度范围：973 4273.16
* 时间步数1：t=5453.78年
* 解决斯托克斯系统...49次迭代。   最大速度：59.0231厘米/年 时间步骤：5345.86年 温度的18次CG迭代 温度范围：973 4273.16
* 时间步数2：t=10799.6年
* 解决斯托克斯系统...24次迭代。   最大速度：60.2139厘米/年 时间步长：5241.51年 17次温度的CG迭代 温度范围：973 4273.16
* [...]
* 时间步长100：t=272151年
* 解决斯托克斯系统...21次迭代。   最大速度：161.546厘米/年 时间步长：1672.96年 温度的17次CG迭代 温度范围：973 4282.57
* 活动单元的数量：56,085（在8层）自由度的数量：903,408（490,102+168,255+245,051）。
*

*
* +---------------------------------------------+------------+------------+|从开始到现在，总的壁挂时间经过了115s||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||| ||||||||||||||| ||||||||| |||| ||||||| |||| |||||||||||||||||||| ||||||||||||||| | ||||建立斯托克斯预处理程序 | 12 | 2.09s | 1.8% ||求解斯托克斯系统 | 103 | 90.4s | 79% ||求解温度系统 | 103 | 1.53s | 1.3% ||后处理 | 3 | 0.532s | 0.46% ||完善网格结构，第一部分 | 12 | 0.93s | 0.81% ||完善网格结构，第二部分 | 12 | 0.384s | 0.33% ||设置阻尼系统 | 13 | 2.96s | 2.6% |+---------------------------------+-----------+------------+------------+
* [...]
* +---------------------------------------------+------------+------------+|从开始到现在，总的壁挂时间经过了9.14e+04s|||||部分|调用次数|壁挂时间|占总数的百分比|+---------------------------------+-----------+------------+------------+|组装斯托克斯系统|47045|2.05e+03s|2.2%||组装温度矩阵|4707|310s|0.34%||组装温度rhs|47045|8.7e+03s|9。5% ||建立斯托克斯预调节器 | 4707 | 1.48e+03s | 1.6% ||求解斯托克斯系统 | 47045 | 7.34e+04s | 80% ||求解温度系统 | 47045 | 1.46e+03s | 1.6% ||后期处理 | 1883 | 222s | 0.24% ||完善网格结构，第一部分 | 4706 | 641s | 0.7% ||完善网格结构，第二部分 | 4706 | 259s | 0.28% ||设置dof系统 | 4707 | 1.86e+03s | 2% |+---------------------------------+-----------+------------+</pre>/code>
* 当时间达到输入文件中选择的10亿年时，模拟就会终止。  你可以从中推断出不同的最终时间，模拟需要多长时间（时间步长最终定在2万年左右，所以计算20亿年需要10万个时间步长，大概需要20%）。  从这里可以看出，我们把大部分的计算时间花在组装线性系统和&mdash;最重要的&mdash;解决Stokess系统。
*

* 为了演示输出，我们在这里展示了每1250个时间步骤的输出。[2.x.432]
* 最后两张图片显示了网格以及16个子域和16个处理器的同一计算中的网格划分情况。这个模拟的全部动态只有通过看动画才能看到，例如[1.x.270]。由于其艺术质量和对岩浆羽流演变的迷人描述，这个图像非常值得观看。
* 如果你观看这部电影，你会看到对流模式经历了几个阶段。首先，它摆脱了不稳定的温度分层，热物质被致密的冷物质覆盖。在这个巨大的驱动力被消除后，我们有了一种稳定的情况，一些小球开始从内环的热边界层中分离出来并上升，一些冷指也从外部边界层中掉下来。在这一阶段，溶液大部分保持对称，反映了原始网格的12倍对称性。在最后一个阶段，流体进入剧烈的混沌搅拌，所有的对称性都消失了。这是一种持续主导流动的模式。
* 如果我们看一下模拟中的最大速度与时间的关系，也可以确定这些不同的阶段。
* [2.x.433]
* 在这里，当温度分层不稳定时，速度（以厘米/年表示）在开始时变得非常大，达到几米/年的数量级。然后，在混乱的搅拌状态下，速度平静下来，变成相对较小的数值，然后再次回升。在那里，它保持在每年10-40厘米的范围内，完全在物理学上的预期范围内。
*

*[1.x.271][1.x.272] 。


* 3D计算在计算上非常昂贵。此外，如上所述，有趣的行为只有在相当长的时间后才会开始，这需要比典型集群上可用的CPU时间更多。因此，与其在这里展示一个完整的模拟，不如让我们简单地展示几张图片，我们使用这个程序的后续程序，称为[1.x.273]（简称[1.x.274]），该程序正在独立于deal.II进行开发，已经包含了下面讨论的一些扩展。下面两张图片显示了温度的ontours和领域（连同网格）在512个处理器上的划分。
* [2.x.434]
*

* [1.x.275][1.x.276][1.x.277] 。


* 这个程序有许多可以扩展的方向。正如在介绍的最后提到的那样，在本教程程序完成时，其中大部分正在[1.x.278]（简称[1.x.279]）代码中进行激活开发。具体来说，以下是人们应该解决的问题，以使程序更加有用。
* [2.x.435] [2.x.436] [1.x.280] 我们在模拟中得到的温度场在一段时间后大多是恒定的，在内部和外部边界有边界层，冷和热材料的流线混合了一切。然而，这并不符合我们的预期，即靠近地心的东西应该比靠近地表的东西更热。原因是我们使用的能量方程不包括一个描述绝热冷却和加热的术语：岩石，像气体一样，在你压缩它的时候会加热。因此，上升的物质以绝热方式冷却，而下沉的冷物质则以绝热方式加热。因此，正确的温度方程看起来有点像这样。  [1.x.281]
* 或者，扩大平流导数[2.x.437] ：[1.x.282] 。
* 换句话说，随着岩石体积中压力的增加（[2.x.438]），我们得到一个额外的热源，反之亦然。
* 压力的时间导数在实现上有点困难。如果有必要，我们可以利用导言中概述的事实进行近似计算，即压力可以分解为由温差和由此产生的流动造成的动态部分，以及仅由上覆岩石的静压力造成的静态部分。由于后者要大得多，我们可以对[2.x.439]以及[2.x.440]进行近似分析。  换句话说，如果流体沿着重力方向（向下）运动，它将被压缩，因为在这种情况下[2.x.441]我们得到一个正的热源。相反，如果流体逆着重力方向运动，它将被冷却。
* [2.x.442] [1.x.283] 正如在上面的温度模型中已经暗示的那样，地幔岩石不是不可压缩的。相反，鉴于地幔中的巨大压力（在地核-地幔边界，压力约为140GPa，相当于大气压力的140万倍），岩石实际上确实被压缩到它在表面压力下的密度的1.5倍左右。建立这个模型有很多困难。首先，质量守恒方程不再是[2.x.443]，而应该是[2.x.444]，其中密度[2.x.445]现在不再是空间常数，而是取决于温度和压力。一个后果是，该模型现在不再是线性的；线性化的斯托克斯方程也不再是对称的，需要我们重新考虑预处理程序，甚至可能是离散化。至于如何解决这个问题，我们在这里就不做详细介绍了。
* [2.x.446] [1.x.284] 正如在不同地方已经暗示的那样，材料参数，如密度、粘度和各种热参数在整个地幔中不是恒定的。相反，它们非线性地依赖于压力和温度，在粘度的情况下，还依赖于应变率 [2.x.447] 。对于复杂的模型，准确解决这种模型的唯一方法可能是在每个时间步骤中实际迭代出这种依赖关系，而不是简单地将系数冻结在从前一个（几个）时间步骤推算出来的数值上。
* [2.x.448] [1.x.285] 在一些处理器上运行这个2D程序可以在一两天内解决现实的模型。然而，在3d中，计算时间非常大，以至于人们遇到了两个典型的问题。(i) 在大多数计算集群上，排队系统将单个作业的运行时间限制在2到3天；(ii) 当在数百个处理器上运行几天时，由于硬件故障、错误配置或断电而丢失计算结果是一种耻辱。这两个问题都可以通过定期保存程序的状态来解决，如果有必要，在这个时候重新启动程序。这种技术通常被称为[1.x.286]，它要求将程序的整个状态写到一个永久的存储位置（如硬盘）。考虑到这个程序的数据结构的复杂性，这并不是完全微不足道的（也可能涉及到写入数千兆字节或更多的数据），但可以通过意识到可以在两个时间步骤之间保存状态，其中基本上只包括网格和解向量；在重新启动期间，然后首先按照之前的方式重新列举自由度，然后重新组装矩阵。然而，考虑到这里涉及的数据结构的分布性质，保存和恢复程序的状态并不简单。一个额外的复杂性是由以下事实引入的：人们可能希望在两次运行之间改变处理器的数量，例如，因为人们可能希望在一个比用于在中间时间预计算起始温度场的网格更精细的网格上继续计算。
* [2.x.449] [1.x.287] 像这样的计算的重点不是简单地解决方程。相反，它通常是探索不同的物理模型，并将其与我们在地球表面可以测量到的东西进行比较，以发现哪些模型是现实的，哪些与现实相矛盾。为此，我们需要从我们的解决方案向量中计算出与我们可以观察到的东西有关的数量。其中包括，例如，地球表面的热流，以及整个地幔的地震速度，因为这些影响到地震仪记录的地震波。
* [2.x.450] [1.x.288] 从上面的3d案例可以看出，3d的网格主要是沿着内边界细化。这是因为那里的边界层比领域中的任何其他过渡层都要强，导致我们几乎只在那里进行细化，而基本上不按照羽流的方向进行。当然，我们需要更好的细化标准来跟踪我们真正感兴趣的部分，比这里使用的标准要好，即应用于温度的KellyErrorEstimator，是可以做到的。[2.x.451]
*

* 还有许多其他的方法来扩展当前的程序。然而，与其在这里讨论它们，不如让我们指出更大的开源代码ASPECT（见https://aspect.geodynamics.org/），它构成了[2.x.452]的进一步发展，已经包括了许多这样的可能扩展。
*

* [1.x.289][1.x.290] [2.x.453] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-33_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43][1.x.44][1.x.45]
* [2.x.3]
* [1.x.46]
* [2.x.4] 该程序使用[1.x.47]线性求解器（这些可以在Trilinos的Aztec/Amesos包中找到）和一个自动差分包，Sacado，也是Trilinos的一部分。请参考[1.x.48]文件，了解如何操作。
* [2.x.5] 虽然这个程序很好地演示了自动微分的使用，但它并没有表达欧拉方程求解器的技术水平。对于这个方程，有更快、更准确的方法，你应该看看[2.x.6]和[2.x.7]，看看如何更有效地解决这个方程。
*


* [1.x.49][1.x.50] [1.x.51] 。


*[1.x.52][1.x.53]


* 描述可压缩、不粘性气体运动的方程（所谓气体动力学的欧拉方程）是基本的守恒定律系统。在空间维度[2.x.8]中，它们读作[1.x.54]，解[2.x.9]由[2.x.10]流体密度、[2.x.11]流速（因此[2.x.12]是线性动量密度）和[2.x.13]气体的能量密度组成。我们将上述方程解释为 [2.x.14] , [2.x.15] 。
* 对于欧拉方程，通量矩阵[2.x.16]（或通量函数系统）被定义为（此处显示为[2.x.17]的情况）[1.x.55] 。
*我们将选择重力的影响作为特定的右手边强制力，由[1.x.56]描述。
*其中[2.x.18]表示重力矢量。这样，整个方程组为：[1.x.57]
* 这些方程分别描述了动量、质量和能量的守恒。系统由定义压力的关系封闭。  [2.x.19] .对于空气（主要是氮气和氧气）和其他双原子气体的成分，其比热比为 [2.x.20] 。
* 这个问题显然属于矢量值问题的范畴。在[2.x.21]模块中可以找到关于如何处理这些问题的deal.II的一般概述。
* [1.x.58][1.x.59] 。
*

* 考虑到这是一个与[2.x.22]中讨论的简单问题相同的双曲问题，具体化以通常的方式进行：我们选择一个有限元空间[2.x.23]，并针对我们的（矢量值）测试函数[2.x.24]积分我们的保护法。  然后我们通过部分积分，用[1.x.60]通量[2.x.25]、[1.x.61]近似边界通量。
* 扩散项[2.x.28]是严格为了稳定而引入的，其中[2.x.29]是网格大小，[2.x.30]是一个参数，规定了要增加多少扩散。
* 在边界上，我们必须说明外部跟踪[2.x.31]是什么。根据边界条件，我们规定以下两种情况。[2.x.32] [2.x.33] 流入边界：[2.x.34]被规定为期望值。[2.x.35] 超音速流出边界：[2.x.36] [2.x.37] 亚音速流出边界：[2.x.38] 除了能量变量被修改为支持规定的压力[2.x.39] ，即[2.x.40] [2.x.41] 反射边界：我们设定[2.x.42] ，使[2.x.43] 和[2.x.44] 。[2.x.45]
* 关于这些问题的更多信息可以在RalfHartmann的博士论文中找到（"Adaptive Finite Element Methods for theCompressible Euler Equations"，博士论文，海德堡大学，2002）。
* 我们使用一个时间步进方案来替代上述方程中的时间导数。为简单起见，我们将[2.x.46]定义为时间步长[2.x.47]的空间残差。
* [1.x.62]
*
* 在每个时间步骤，我们的完全离散化是指应用于任何测试函数[2.x.48]的残差等于零：[1.x.63] 。
* 其中[2.x.49]和[2.x.50] 。选择[2.x.51]的结果是显式（正向）欧拉方案，[2.x.52]是稳定的隐式（反向）欧拉方案，而[2.x.53]是克拉克-尼克尔森方案。
* 在下面的实现中，我们为函数[2.x.54]选择Lax-Friedrichs通量，即[2.x.55]，其中[2.x.56]是输入文件中指定的一个固定数字，或者[2.x.57]是一个与网格有关的值。在后一种情况下，它被选为[2.x.58]，其中[2.x.59]是应用流量的面的直径，而[2.x.60]是当前的时间步长。
*有了这些选择，将残差等效为零的结果是一个非线性方程组 [2.x.61] 。我们通过牛顿迭代来解决这个非线性系统（与[2.x.62]中解释的方法相同），即通过迭代[1.x.64] 来解决。
*直到[2.x.63]（残差）足够小。通过用有限元空间的节点基础而不是所有的[2.x.64]进行测试，我们得出[2.x.65]的线性系统：[1.x.65] 。
* 这个线性系统，一般来说，既不是对称的，也没有任何特定的确定性属性。我们将使用直接求解器或Trilinos的GMRES实现来解决它。从[1.x.66]中可以看出，这种全隐式迭代转换速度非常快（通常为3步），并具有牛顿方法所期望的二次转换顺序。
*

*[1.x.67][1.x.68]


* 由于计算雅各布矩阵[2.x.66]是一个可怕的野兽，我们使用一个自动微分包，Sacado，来做这个。  Sacado是[1.x.69]框架内的一个包，提供了一个C++模板类[2.x.67]（[2.x.68]代表 "前向自动微分"），支持基本的算术运算和函数，如[2.x.69]等。为了使用这一特性，人们声明了一个这种类型的变量集合，然后将这个集合中的一些变量表示为自由度，其余的变量是独立变量的函数。  这些变量被用于一个算法中，当变量被使用时，它们对自由度的敏感度被不断地更新。
* 我们可以想象，对于整个雅各布矩阵来说，这可能是非常昂贵的：自变量的数量是[2.x.70]，因变量是向量[2.x.71]的元素。这两个向量很容易有几万个元素或更多。  然而，需要注意的是，并非[2.x.72]的所有元素都依赖于[2.x.73]的所有元素：事实上，[2.x.74]中的一个条目只依赖于[2.x.75]的一个元素，如果两个对应的形状函数重叠并以弱形式耦合。
* 具体来说，明智的做法是定义一个最小的独立AD变量集，当前单元上的残差可能依赖于这些变量：在每一个元素上，我们定义这些变量为独立变量，对应于定义在这个单元上的自由度（或者，如果我们必须计算单元之间的跳跃项，则对应于定义在两个相邻单元上的自由度），而依赖变量是当地残差向量的元素。如果不这样做，即把[1.x.70]中的[2.x.76]元素定义为独立的，将导致大量零的计算非常昂贵：局部残差向量的元素几乎与解向量的所有元素无关，因此它们的导数为零；然而，试图计算这些零很容易占用整个程序90%甚至更多的计算时间，正如这个程序首次编写几年后，一个学生无意中做的实验所示。
*

* 回到自动计算雅各布的问题上：作者将这种方法与手工编码的雅各布并列用于不可压缩的Navier-Stokes问题，发现Sacado方法与使用手工编码的雅各布一样快，但无限简单，而且不容易出错。由于使用自动差分法只需要对残差进行编码[2.x.77]，确保代码的正确性和维护代码变得非常简单。
*
* - 雅各布矩阵[2.x.78]基本上是由计算残差[2.x.79]的相同代码来计算的。
* 综上所述，这里有一个非常简单的例子，展示了Sacado的使用方法。
* [1.x.71]
*
* 输出是[2.x.81]在[2.x.82]的导数[2.x.80] 。
* 应该注意的是，Sacado提供了比本程序中使用的小子集更多的自动差分能力。  然而，理解上面的例子就足以理解Sacado在这个欧拉流程序中的使用。
* [1.x.72][1.x.73] 。
* 该程序使用Aztec迭代求解器或Amesossparse直接求解器，两者均由Trilinos软件包提供。  这个软件包本身就是为了用于并行程序而设计的，然而，它也可以像这里一样方便地用于串行程序。  Epetra软件包是基本的矢量/矩阵库，解算器就是在此基础上建立的。  这个非常强大的包可以用来描述向量的平行分布，并定义对这些向量进行操作的稀疏矩阵。  请查看注释代码以了解更多关于这些求解器在例子中的使用细节。
* [1.x.74][1.x.75] 。
* 这个例子使用了一个特殊的细化指标，该指标在冲击型问题和下坡流例子中显示出一定的作用。  我们根据密度的平方梯度进行细化。悬空节点是通过计算不同细化水平的单元的数值通量来处理的，而不是像到目前为止的所有其他教程程序那样使用AffineConstraints类。  通过这种方式，这个例子结合了连续和DG的方法论。它还简化了Jacobian的生成，因为我们不必通过用于计算的自动微分来跟踪受约束的自由度。
* [2.x.83] 虽然这个程序是在2008年写的，但我们不知道是否有任何出版物会真正使用这种方法。然而，A. Dedner, R. Kl&ouml;fkorn, and M. Kr&auml;nkel最近的一篇论文（"Continuous Finite-Elements on Non-Conforming Grids UsingDiscontinuous Galerkin Stabilization", Proceedings of Finite Volumesfor Complex Applications VII
*
* - 方法和理论方面，Springer，2014）接近。
* 此外，我们强制规定了细化水平的最大数量，以控制细化。  根据作者的经验，对于随时间变化的问题的适应性，如果不注意，细化很容易导致模拟的戛然而止，因为时间步长的限制，如果网格在领域的任何部分变得太细的话。  在这个例子中，细化的数量是有限的，用户可以指定网格中任何地方的最大细化程度。  这样一来，细化就不会使仿真速度减慢到停顿。  当然，这纯粹是一种启发式的策略，如果作者的顾问听说了，作者可能会被永远放逐出有限元误差估计界。
*[1.x.76][1.x.77]
*

* 我们使用一个输入文件平台来驱动仿真。  通过这种方式，我们可以改变边界条件和其他重要的模拟属性，而不必重新编译。  关于格式的更多信息，请看[1.x.78]，那里我们更详细地描述了一个输入文件的例子。
* 在以前的例子程序中，我们通常对初始和边界条件进行硬编码。在这个程序中，我们使用了表达式解析器类FunctionParser，这样我们就可以在输入文件中指定一个通用的表达式，并在运行时对其进行解析&mdash;这样，我们就可以改变初始条件而不需要重新编译程序。因此，在下面的程序中不会声明名为初始条件（InitialConditions）或边界条件（BoundaryConditions）的类。
*

*[1.x.79][1.x.80]


* 本程序的实现分为三个基本部分。[2.x.84] [2.x.85] [2.x.86] 类，它封装了完全描述欧拉方程具体内容的一切。这包括通量矩阵[2.x.87]，数值通量[2.x.88]，右手边[2.x.89]，边界条件，细化指标，输出的后处理，以及类似的需要了解解向量和方程的各个组成部分的含义的东西。
* [2.x.90] 一个命名空间，处理与运行时参数有关的一切。
* [2.x.91] 处理时间步进、外部非线性和内部线性求解、组装线性系统以及驱动这一切的顶层逻辑的[2.x.92]类。[2.x.93]
* 采用这种方法的原因是它将程序中的各种关注点分开：[2.x.94]是以这样一种方式编写的，即相对简单地将其适应于不同的方程组。我们只需为其他双曲方程重新实现[2.x.95]类的成员，或者用额外的方程来增强现有的方程（例如通过移动额外的变量，或者通过增加化学成分等）。然而，这些修改不会影响时间步进，也不会影响非线性求解器，如果做得正确的话，因此[2.x.96]中的任何内容都不必修改。
* 同样，如果我们想改进线性或非线性求解器，或改进时间步进方案（正如在[1.x.81]的末尾所暗示的那样），那么这根本不需要修改[2.x.97]。
*

* [1.x.82] [1.x.83]。
* [1.x.84][1.x.85] 。


*
*首先是一套标准的交易。II包括。这里没有什么特别需要评论的。
*


* [1.x.86]
*
* 然后，正如介绍中提到的，我们使用各种Trilinos软件包作为线性求解器以及自动微分。这些都在以下的包含文件中。
*

*
* 由于deal.II提供了基本的Trilinos矩阵、预处理程序和求解器的接口，我们把它们类似于deal.II线性代数结构。
*


* [1.x.87]
*
* Sacado是Trilinos中的自动微分包，用于寻找全隐式牛顿迭代的雅各布系数。
*


* [1.x.88]

* 而这又是C++。



* [1.x.89]
*
* 在本节结束时，将dealii库中的所有内容引入本程序的内容所处的命名空间。
*


* [1.x.90]
*
* [1.x.91] [1.x.92]。


*
* 在这里，我们为这个特定的守恒定律系统定义了通量函数，以及几乎所有与气体动力学的欧拉方程有关的其他东西，原因在介绍中已经讨论过。我们将所有这些归入一个结构，该结构定义了与通量有关的一切。这个结构的所有成员都是静态的，也就是说，这个结构没有由实例成员变量指定的实际状态。与其说是一个拥有所有静态成员的结构，不如说是使用一个命名空间来做到这一点
*
* - 但是命名空间不能被模板化，而且我们希望结构的一些成员变量取决于空间维度，我们以通常的方式用模板参数引入。
*


* [1.x.93]
*
* [1.x.94] [1.x.95]。


*
*首先是一些变量，它们以通用的方式描述了我们的解矢量的各个组成部分。这包括系统中分量的数量（欧拉方程中每个空间方向的动量都有一个条目，加上能量和密度分量，总共有[2.x.98]个分量），以及描述第一个动量分量、密度分量和能量密度分量在解向量中的索引的函数。请注意，所有这些%数都取决于空间维度；以通用的方式定义它们（而不是通过隐含的惯例）使我们的代码更加灵活，并使以后的扩展更加容易，例如，在方程中添加更多的分量。
*


* [1.x.96]
*
* 在这个程序中，当生成图形输出的时候，我们需要指定解变量的名称，以及各种成分如何分组为矢量和标量场。我们可以在这里进行描述，但为了使与欧拉方程有关的事情在这里得到解决，并使程序的其他部分尽可能通用，我们在以下两个函数中提供这类信息。
*


* [1.x.97]
*
* [1.x.98] [1.x.99]。


*
* 接下来，我们定义气体常数。我们将在紧随这个类的声明之后的定义中把它设置为1.4（与整数变量不同，比如上面的变量，静态常数浮点成员变量在C++中不能在类的声明中被初始化）。这个1.4的值代表了由两个原子组成的分子的气体，比如空气，它几乎完全由[2.x.99]和[2.x.100]组成，痕迹很小。
*


* [1.x.100]

* 在下文中，我们需要从保守变量的矢量中计算动能和压力。我们可以根据能量密度和动能[2.x.101]做到这一点（注意，独立变量包含动量分量[2.x.102]，而不是速度[2.x.103]）。
*


* [1.x.101]
*
* [1.x.102] [1.x.103]。


*
* 我们把通量函数[2.x.104]定义为一个大矩阵。  这个矩阵的每一行都代表该行成分的标量守恒定律。  这个矩阵的确切形式在介绍中给出。请注意，我们知道这个矩阵的大小：它的行数与系统的分量一样多，[2.x.105]列数一样多；我们没有为这样的矩阵使用FullMatrix对象（它的行数和列数是可变的，因此每次创建这样的矩阵都必须在堆上分配内存），而是马上使用一个矩形的数字阵列。     
* 我们将通量函数的数值类型模板化，这样我们就可以在这里使用自动微分类型。  同样地，我们将用不同的输入矢量数据类型来调用该函数，所以我们也对其进行模板化。
*


* [1.x.104]
*
* 首先计算出现在通量矩阵中的压力，然后计算矩阵中对应于动量项的前[2.x.106]列。
*


* [1.x.105]
*
* 然后是密度（即质量守恒）的条款，最后是能量守恒。
*


* [1.x.106]
*
* [1.x.107] [1.x.108]。


*
* 在域的边界和跨挂节点上，我们使用一个数值通量函数来强制执行边界条件。  这个程序是基本的Lax-Friedrich的通量，有一个稳定参数 [2.x.107] 。它的形式也已经在介绍中给出。
*


* [1.x.109]
*
* [1.x.110] [1.x.111]。


*
* 与描述通量函数[2.x.108]的方式相同，我们也需要有一种方法来描述右侧的强迫项。正如介绍中提到的，我们在这里只考虑重力，这导致了具体的形式[2.x.109]，这里显示的是三维情况。更具体地说，我们将只考虑三维的[2.x.110]，或二维的[2.x.111]。这自然导致了以下的函数。
*


* [1.x.112]
*
* [1.x.113] [1.x.114]。


*
* 我们要处理的另一件事是边界条件。为此，让我们首先定义一下我们目前知道如何处理的各种边界条件。
*


* [1.x.115]
*
* 下一部分是实际决定在每种边界上做什么。为此，请记住，从介绍中可以看出，边界条件是通过在给定的不均匀性[2.x.113]的边界外侧选择一个值[2.x.112]和可能的解的内侧的值[2.x.114]而指定的。然后将两者传递给数值通量[2.x.115]以定义边界对双线性形式的贡献。     
* 边界条件在某些情况下可以为解矢量的每个分量独立指定。例如，如果分量[2.x.116]被标记为流入，那么[2.x.117] 。如果是流出，那么[2.x.118] 。在下面的函数中首先处理这两种简单的情况。     
* 从C++语言的角度看，有一个小插曲使这个函数不讨人喜欢。输出向量[2.x.119]当然会被修改，所以它不应该是一个[2.x.120]的参数。然而，在下面的实现中，它却成为了参数，而且为了使代码能够编译，它必须成为参数。原因是我们在[2.x.121]类型为[2.x.122]的地方调用这个函数，这是一个2d表，其指数分别代表正交点和向量分量。我们用[2.x.123]作为最后一个参数来调用这个函数；对2d表进行下标会产生一个代表1d向量的临时访问器对象，这正是我们在这里想要的。问题是，根据C++ 1998和2003标准，临时访问器对象不能被绑定到一个函数的非静态引用参数上，就像我们在这里希望的那样（这个问题将在下一个标准中以rvalue引用的形式得到解决）。  我们在这里把输出参数变成常量，是因为[1.x.116]对象是常量，而不是它所指向的表：那个表仍然可以被写到。然而，这个黑客是不愉快的，因为它限制了可以作为这个函数的模板参数的数据类型：一个普通的向量是不行的，因为当标记为[2.x.124]时，它不能被写到。由于目前没有好的解决方案，我们将采用这里显示的务实的，甚至是不漂亮的解决方案。
*


* [1.x.117]
*
* 规定的压力边界条件要复杂一些，因为即使压力是规定的，我们在这里真正设置的是能量分量，它将取决于速度和压力。因此，尽管这似乎是一个Dirichlet类型的边界条件，我们得到了能量对速度和密度的敏感性（除非这些也是规定的）。
*


* [1.x.118]
*
* 我们规定了速度（我们在这里处理的是一个特定的分量，所以速度的平均值是与表面法线正交的。  这就产生了整个速度分量的敏感度。
*


* [1.x.119]
*
* [1.x.120] [1.x.121]。


*
* 在这个类中，我们还想指定如何细化网格。将使用我们在[2.x.126]类中提供的所有信息的[2.x.125]类对于它所求解的特定守恒定律是不可知的：因为它甚至不关心一个求解向量有多少个分量。因此，它不可能知道合理的细化指标是什么。另一方面，在这里我们知道，或者至少我们可以想出一个合理的选择：我们简单地看一下密度的梯度，并计算出[2.x.127]，其中[2.x.128]是单元格[2.x.129]的中心。     
* 当然也有一些同样合理的细化指标，但这个指标确实如此，而且很容易计算。
*


* [1.x.122]
*
* [1.x.123] [1.x.124]。


*
* 最后，我们声明一个实现数据成分后处理的类。这个类解决的问题是，我们使用的欧拉方程的表述中的变量是保守的而不是物理形式的：它们是动量密度 [2.x.130] 、密度 [2.x.131] 和能量密度 [2.x.132] 。我们还想把速度 [2.x.133] 和压力 [2.x.134] 放入我们的输出文件中。     
* 此外，我们还想增加生成Schlieren图的可能性。Schlieren图是一种将冲击和其他尖锐界面可视化的方法。"schlieren "这个词是一个德语单词，可以翻译成 "条纹"。
*
* 然而，用一个例子来解释可能更简单：比如说，当你把高浓度的酒精或透明的盐水溶液倒入水中时，你会看到schlieren；这两种物质的颜色相同，但它们的折射率不同，因此在它们完全混合之前，光线会沿着弯曲的光线穿过混合物，如果你看它，会导致亮度变化。这就是 "分光"。类似的效果发生在可压缩流中，因为折射率取决于气体的压力（以及因此的密度）。     
* 这个词的起源是指三维体积的二维投影（我们看到的是三维流体的二维图片）。在计算流体力学中，我们可以通过考虑其原因来了解这种效应：密度变化。因此，Schlieren图是通过绘制[2.x.135]产生的；显然，[2.x.136]在冲击和其他高度动态的地方很大。如果用户需要（通过在输入文件中指定），我们希望除了上面列出的其他派生量之外，还能生成这些裂缝图。     
* 计算解决我们问题的派生量并将其输出到数据文件的算法的实现依赖于DataPostprocessor类。它有大量的文档，该类的其他用途也可以在 [2.x.137] 中找到。因此，我们不做广泛的评论。
*


* [1.x.125]

* 这是唯一值得评论的函数。在生成图形输出时，DataOut和相关的类将在每个单元格上调用这个函数，以获取每个正交点的值、梯度、Hessians和法向量（如果我们在处理面）。请注意，每个正交点的数据本身就是矢量值，即保守变量。我们在这里要做的是计算每个正交点上我们感兴趣的量。注意，为此我们可以忽略Hessians（"inputs.solution_hessians"）和法向量（"inputs.normals"）。
*


* [1.x.126]
*
* 在函数的开始，让我们确保所有的变量都有正确的大小，这样我们就可以访问各个向量元素，而不必怀疑我们是否可能读或写无效的元素；我们还检查[2.x.138]向量只包含我们真正需要的数据（系统知道这一点，因为我们在下面的[2.x.139]函数中这样说）。对于内向量，我们检查至少外向量的第一个元素具有正确的内部大小。
*


* [1.x.127]
*
* 然后在所有的正交点上循环，在那里做我们的工作。这段代码应该是非常不言自明的。输出变量的顺序首先是[2.x.140]速度，然后是压力，如果需要的话，还可以是SCHLIEREN图。请注意，我们尝试使用[2.x.141]和[2.x.142]的信息，对输入向量中的变量顺序进行通用处理。
*


* [1.x.128]
*
* [1.x.129] [1.x.130]。


*
* 我们接下来的工作是定义一些包含运行时参数的类（例如，求解器的公差、迭代次数、稳定参数等等）。我们可以在主类中做这件事，但是我们把它和主类分开，以使程序更加模块化，更容易阅读。所有与运行时参数有关的东西都将在下面的命名空间中，而程序逻辑则在主类中。   
* 我们将把运行时参数分成几个独立的结构，我们将把这些结构都放在一个命名空间中 [2.x.143] 。在这些类中，有几个是为单独的组进行参数分组的，比如为求解器、网格细化或输出。这些类中的每一个都有函数 [2.x.144] 和 [2.x.145] ，分别在ParameterHandler对象中声明参数子段和条目，并从这样的对象中检索实际的参数值。这些类在ParameterHandler的子段中声明它们的所有参数。   
* 以下命名空间的最后一个类结合了之前的所有类，从它们派生出来，并负责处理输入文件顶层的一些条目，以及其他一些奇怪的条目，这些条目在子段中太短，不值得单独建立结构。   
* 这里值得指出的是一件事。下面的类中没有一个构造函数可以初始化各种成员变量。不过这不是问题，因为我们将从输入文件中读取这些类中声明的所有变量（或者间接地：一个ParameterHandler对象将从那里读取，而我们将从这个对象中获取数值），它们将以这种方式被初始化。如果输入文件中根本没有指定某个变量，这也不是问题。在这种情况下，ParameterHandler类将简单地采取默认值，这个默认值是在声明下面这些类的[2.x.146]函数中的一个条目时指定的。
*


* [1.x.131]
*
* [1.x.132] [1.x.133]。
* 这些类中的第一个涉及到线性内部求解器的参数。它提供的参数表明使用哪种求解器（GMRES作为一般非对称不定式系统的求解器，或稀疏直接求解器），要产生的输出量，以及调整阈值不完全LU分解（ILUT）的各种参数，我们使用它作为GMRES的预处理器。     
* 特别是，ILUT需要以下参数。
*


*
* - ilut_fill: 形成ILU分解时要增加的额外条目的数量。
*


*
* - ilut_atol, ilut_rtol:在形成预处理程序时，对于某些问题，不良的条件（或只是运气不好）会导致预处理程序的条件很差。  因此，将对角线扰动添加到原始矩阵中，并为这个稍好的矩阵形成预处理程序会有帮助。  ATOL是一个绝对扰动，在形成预处理之前加到对角线上，RTOL是一个比例因子 [2.x.147] 。
*


*
* - ilut_drop。ILUT将放弃任何幅度小于此值的数值。  这是一种管理该预处理程序所使用的内存量的方法。     
* 每个参数的含义在 [2.x.148] 调用的第三个参数中也有简要说明 [2.x.149] 。
*


* [1.x.134]

* [1.x.135] [1.x.136].
* 同样的，这里有几个参数决定了网格如何被细化（以及是否要被细化）。关于冲击参数的具体作用，请看下面的网格细化函数。
*


* [1.x.137]
*
* [1.x.138] [1.x.139]。
* 接下来是关于通量修改的部分，使其更加稳定。特别是，提供了两个选项来稳定Lax-Friedrichs通量：要么选择[2.x.150]，其中[2.x.151]是在输入文件中指定的一个固定数字，要么[2.x.152]是一个与网格有关的值。在后一种情况下，它被选择为[2.x.153]，其中[2.x.154]是应用通量的面的直径，而[2.x.155]是当前的时间步长。
*


* [1.x.140]
*
* [1.x.141] [1.x.142]。
* 然后是关于输出参数的部分。我们提供产生Schlieren图（密度的平方梯度，一种可视化冲击前沿的工具），以及图形输出的时间间隔，以防我们不希望每个时间步骤都有输出文件。
*


* [1.x.143]
*
* [1.x.144] [1.x.145]。
* 最后，这个类将所有的东西集中在一起。它自己声明了一些参数，主要是参数文件顶层的参数，以及一些太小的部分，以至于没有必要有自己的类。它还包含所有实际上与空间维度有关的东西，比如初始或边界条件。     
* 由于这个类是由上面所有的类派生出来的，[2.x.156]函数也会调用基类的相应函数。     
* 请注意，这个类也处理输入文件中指定的初始和边界条件的声明。为此，在这两种情况下，都有像 "w_0值 "这样的条目，它代表了[2.x.157]方面的表达式，将初始或边界条件描述为一个公式，随后将由FunctionParser类来解析。类似的表达方式还有 "w_1"、"w_2 "等，表示欧拉系统的[2.x.158]守恒变量。同样，我们允许在输入文件中使用多达[2.x.159]个边界指标，这些边界指标中的每一个都可以与流入、流出或压力边界条件相关联，同质边界条件要分别为每个成分和每个边界指标指定。     
* 用来存储边界指标的数据结构有点复杂。它是一个[2.x.160]元素的数组，表示将被接受的边界指标的范围。对于这个数组中的每个条目，我们在[2.x.161]结构中存储一对数据：首先是一个大小为[2.x.162]的数组，对于解向量的每个分量，表明它是流入、流出还是其他类型的边界，其次是一个FunctionParser对象，一次性描述这个边界ID的解向量的所有分量。     
* [2.x.163]结构需要一个构造器，因为我们需要在构造时告诉函数解析器对象它要描述多少个向量分量。因此，这个初始化不能等到我们在后面的[2.x.164]中实际设置FunctionParser对象所代表的公式。
* 由于必须在构造时告诉Function对象其向量大小的同样原因，我们必须有一个[2.x.165]类的构造函数，至少要初始化另一个FunctionParser对象，即描述初始条件的对象。
*


* [1.x.146]
*
* [1.x.147] [1.x.148]。


*
* 这里终于出现了一个类，它实际上是对我们上面定义的所有欧拉方程和参数的具体内容做了一些事情。公有接口和往常一样（构造函数现在需要一个文件名来读取参数，这个文件名在命令行中传递）。私有函数接口也与通常的安排非常相似，[2.x.166]函数被分成三个部分：一个包含所有单元的主循环，然后分别调用另外两个单元和面的积分。
*


* [1.x.149]
*
* 前面几个成员变量也是相当标准的。请注意，我们定义了一个映射对象，在整个程序中组装术语时使用（我们将把它交给每个FEValues和FEFaceValues对象）；我们使用的映射只是标准的[2.x.167]的映射
*
* - 没有什么花哨的，换句话说
*
* 但在这里声明一个映射并在整个程序中使用它将使以后在有必要时改变它变得更简单。这实际上是相当相关的：众所周知，对于欧拉方程的跨音速模拟，如果边界近似没有足够高的阶数，计算就不会收敛，即使是[2.x.168]。
*


* [1.x.150]
*
* 接下来是一些数据向量，对应于前一个时间步骤的解决方案（[2.x.169]），当前解决方案的最佳猜测（[2.x.170]；我们说[1.x.151]是因为计算它的牛顿迭代可能还没有收敛，而[2.x.171]是指前一个时间步骤的完全收敛的最终结果），以及下一个时间步骤的解决方案的预测器，通过将当前和之前的解决方案推断到未来一个时间步骤计算。
*


* [1.x.152]
*
* 这最后一组成员变量（除了最下面的持有所有运行时参数的对象和一个只在要求verbose输出时才打印东西的屏幕输出流）是处理我们在这个程序中与Trilinos库的接口，该库为我们提供了线性求解器。与在[2.x.172]和[2.x.173]中包括PETSc矩阵类似，我们需要做的是创建一个Trilinos稀疏矩阵而不是标准的deal.II类。该系统矩阵在每个牛顿步骤中被用于雅各布系数。由于我们不打算并行运行这个程序（不过用Trilinos数据结构也不会太难），所以我们不必考虑其他的事情，比如分配自由度。
*


* [1.x.153]
*
* [1.x.154] [1.x.155]。
* 关于构造函数，没有什么可说的。基本上，它读取输入文件并将解析后的值填充到参数对象中。
*


* [1.x.156]
*
* [1.x.157] [1.x.158]
* 每次改变网格时都会调用下面这个（简单的）函数。它所做的就是根据我们在以前的所有教程程序中生成的稀疏模式来调整特里诺斯矩阵的大小。
*


* [1.x.159]
*
* [1.x.160] [1.x.161]。
* 这个和下面的两个函数是这个程序的核心。它们集合了将牛顿方法应用于非线性守恒方程组的线性系统。   
* 第一个函数将所有的装配部件放在一个例行程序中，为每个单元格/面派送正确的部件。  对这些对象的装配的实际实现是在以下函数中完成的。   
* 在函数的顶部，我们做了常规的内务处理：分配FEValues、FEFaceValues和FESubfaceValues对象，这些对象是在单元格、面和子面（在不同细化水平上的相邻单元的情况下）进行积分所必需的。请注意，我们并不需要所有这些对象的所有信息（如值、梯度或正交点的真实位置），所以我们只让FEValues类通过指定最小的UpdateFlags集来获得实际需要的信息。例如，当使用邻接单元的FEFaceValues对象时，我们只需要形状值。给定一个特定的面，正交点和[2.x.174]值与当前单元格相同，法向量已知为当前单元格的法向量的负值。
*


* [1.x.162]
*
* 然后循环所有单元，初始化当前单元的FEValues对象，并调用在此单元上组装问题的函数。
*


* [1.x.163]
*
* 然后在这个单元的所有面进行循环。  如果一个面是外部边界的一部分，那么就在那里集合边界条件（[2.x.175]的第五个参数表示我们是在外部面还是内部面工作；如果是外部面，表示邻居自由度指数的第四个参数被忽略，所以我们传递一个空矢量）。
*


* [1.x.164]
*
* 另一种情况是，我们正在处理一个内部面。我们需要区分两种情况：这是在同一细化水平的两个单元之间的正常面，以及它是不同细化水平的两个单元之间的面。           
* 在第一种情况下，我们不需要做什么：我们使用的是连续有限元，在这种情况下，面条款不会出现在双线性表格中。第二种情况下，如果我们强烈地执行悬挂节点约束，通常也不会导致面状项的出现（就像到目前为止，只要我们使用连续有限元，在以前的所有教程程序中都是这样的
*
*-这种执行是由AffineConstraints类和[2.x.176]一起完成的 在当前的程序中，我们选择在不同细化水平的单元之间的面弱执行连续性，原因有二。(i)因为我们可以，更重要的是(ii)因为我们必须通过AffineConstraints类的操作将我们用来计算牛顿矩阵元素的自动微分穿起来。这是有可能的，但不是微不足道的，所以我们选择了这种替代方法。           
* 需要决定的是我们坐在不同细化水平的两个单元之间的接口的哪一边。           
* 让我们先来看看邻居更细化的情况。然后，我们必须在当前单元格的面的子代上循环，并在每个子代上进行整合。我们在代码中加入了几个断言，以确保我们试图找出邻居的哪个子面与当前单元格的某个子面相吻合的推理是正确的。
*
* - 一点防御性的编程永远不会有坏处。           
* 然后我们调用对面进行整合的函数；由于这是一个内部面，第五个参数是假的，第六个参数被忽略了，所以我们再次传递一个无效的值。
*


* [1.x.165]
*
* 我们必须关注的另一种可能性是邻居是否比当前单元更粗（特别是，由于每个面只有一个悬挂节点的通常限制，邻居必须正好比当前单元更粗一层，这一点我们用断言来检查）。同样，我们在这个界面上进行整合。
*


* [1.x.166]
*
* [1.x.167] [1.x.168]
* 这个函数通过计算残差的单元部分来组合单元项，将其负数加到右手边的向量上，并将其相对于局部变量的导数加到雅各布系数（即牛顿矩阵）上。回顾一下，单元格对残差的贡献为[2.x.177] [2.x.178] [2.x.179]，其中[2.x.180] [2.x.181] [2.x.182]为[2.x.183]和[2.x.184]，[2.x.185]为[2.x.186]第1个向量值的测试函数。此外，标量积[2.x.187]可以理解为[2.x.188]，其中[2.x.189]是[2.x.191]第1个测试函数的[2.x.190]分量。   
*
* 在这个函数的顶部，我们做了一些常规的内务工作，即分配一些我们以后需要的局部变量。特别是，我们将分配一些变量，用于保存[2.x.193]次牛顿迭代后的当前解[2.x.192]（变量[2.x.194]）和前一个时间步长的解[2.x.195]（变量[2.x.196] ）的值。   
* 除此以外，我们还需要当前变量的梯度。  我们必须计算这些是有点遗憾的，我们几乎不需要。  一个简单的守恒定律的好处是，通量一般不涉及任何梯度。  然而，我们确实需要这些梯度，用于扩散稳定。   
* 我们存储这些变量的实际格式需要一些解释。首先，我们需要在每个正交点为解矢量的[2.x.197]分量取值。这就构成了一个二维表，我们使用deal.II的表类（这比[2.x.198]更有效，因为它只需要分配一次内存，而不是为外向量的每个元素分配一次）。同样地，梯度是一个三维表，Table类也支持。   
* 其次，我们想使用自动微分。为此，我们使用[2.x.199]模板来计算所有我们想计算导数的变量。这包括当前解和正交点的梯度（是自由度的线性组合），以及由它们计算出来的所有东西，如残差，但不包括前一个时间步长的解。这些变量都可以在函数的第一部分找到，同时还有一个变量，我们将用它来存储残差的一个分量的导数。
*


* [1.x.169]

* 接下来，我们必须定义自变量，我们将尝试通过解决一个牛顿步骤来确定自变量。这些自变量是我们在这里提取的局部自由度的值。
*


* [1.x.170]
*
* 下一步包含了所有的魔力：我们宣布自分变量的一个子集为独立自由度，而所有其他的自由度仍然是依赖函数。这些正是刚刚提取的局部自由度。所有引用它们（直接或间接）的计算都将积累与这些变量有关的敏感度。     
* 为了将这些变量标记为独立变量，下面的方法可以做到这一点，将[2.x.200]标记为总共[2.x.202]中的[2.x.201]个独立变量。
*


* [1.x.171]
*
* 在所有这些声明之后，让我们实际计算一些东西。首先，[2.x.203]和[2.x.204]的值，我们可以通过使用公式[2.x.205]从局部DoF值计算出来，其中[2.x.206]是解向量（局部部分）的第[2.x.207]个条目，而[2.x.208]是在正交点[2.x.210]评估的[2.x.209]个矢量值的形状函数值。梯度可以用类似的方法来计算。     
* 理想情况下，我们可以通过调用类似[2.x.211]和[2.x.212]的东西来计算这些信息，但是由于（i）我们必须为此扩展FEValues类，（ii）我们不想让整个[2.x.213]矢量的fad类型，只是局部单元变量，我们明确编码上面的循环。在这之前，我们添加另一个循环，将所有的fad变量初始化为零。
*


* [1.x.172]
*
* 接下来，为了计算单元贡献，我们需要在所有正交点评估[2.x.214] , [2.x.215] 和 [2.x.216] , [2.x.217] 。为了存储这些，我们还需要分配一点内存。请注意，我们以自分变量的方式计算通量矩阵和右手边，这样以后就可以很容易地从中计算出雅各布贡献。
*


*


* [1.x.173]
*
* 我们现在已经有了所有的部件，所以要进行组装。  我们有一个通过系统组件的外循环，和一个通过正交点的内循环，在那里我们积累了对[2.x.218]的残差[2.x.219]的贡献。这个残差的一般公式在引言和本函数的顶部给出。然而，考虑到[2.x.220] 第三个（矢量值）测试函数[2.x.221]实际上只有一个非零分量，我们可以将其简化一下（关于这个主题的更多内容可以在[2.x.222] 矢量值模块中找到）。它将由下面的变量[2.x.223]表示。有了这个，残差项可以重新写成[1.x.174]。
*其中积分可以理解为通过对正交点求和来评估。     
* 我们最初对残差的所有贡献进行正意义上的求和，这样我们就不需要对雅各布项进行负数。  然后，当我们对[2.x.224]矢量求和时，我们要否定这个残差。
*


* [1.x.175]
*
* 每一行（i）的残差将被累积到这个法德变量中。  在这一行的装配结束时，我们将查询这个变量的敏感度，并将其加入到雅各布系数中。
*


*


* [1.x.176]
*
* 在循环结束时，我们必须将敏感度加入到矩阵中，并从右手边减去残差。Trilinos FAD数据类型让我们可以使用[2.x.225]访问导数，因此我们将数据存储在一个临时数组中。然后，这些关于整行局部道夫的信息被一次性添加到Tridinos矩阵中（它支持我们选择的数据类型）。
*


* [1.x.177]
*
* [1.x.178] [1.x.179]。
* 在这里，我们的做法与前面的函数基本相同。在顶部，我们引入自变量。因为如果我们在两个单元之间的内部面上工作，也会使用当前的函数，所以自变量不仅是当前单元上的自由度，而且在内部面上的情况下，也是邻近单元上的自由度。
*


* [1.x.180]
*
* 接下来，我们需要定义保守变量[2.x.226]在面的这一侧（[2.x.227]）和另一侧（[2.x.228]）的值，对于[2.x.229]和[2.x.230]。"这一边 "的值可以用与前一个函数完全相同的方式计算，但注意[2.x.231]变量现在是FEFaceValues或FESubfaceValues的类型。
*


* [1.x.181]

* 计算 "对立面 "就比较复杂了。如果这是一个内部面，我们可以像上面那样，简单地用邻居的独立变量来计算。
*


* [1.x.182]

* 另一方面，如果这是一个外部边界面，那么[2.x.232]的值将是[2.x.233]的函数，或者它们将是规定的，取决于这里施加的边界条件的种类。     
* 为了开始评估，让我们确保为这个边界指定的边界ID是我们在参数对象中实际有数据的一个。接下来，我们对不均匀性的函数对象进行评估。  这有点棘手：一个给定的边界可能同时有规定的和隐含的值。  如果一个特定的成分没有被规定，那么这些值就会被评估为零，并在下面被忽略。     
* 其余的由一个实际上知道欧拉方程边界条件的具体内容的函数来完成。请注意，由于我们在这里使用的是fad变量，敏感度将被适当地更新，否则这个过程将是非常复杂的。
*


* [1.x.183]
*
*这里我们假设边界类型、边界法向量和边界数据值在时间推进中保持不变。
*


* [1.x.184]
*
* 现在我们有了[2.x.234]和[2.x.235]，我们可以去计算每个正交点的数值通量函数[2.x.236]。在调用这个函数之前，我们还需要确定Lax-Friedrich的稳定参数。
*


*


* [1.x.185]
*
* 现在以与前面函数中的单元贡献完全相同的方式组装面项。唯一的区别是，如果这是一个内部面，我们还必须考虑到剩余贡献对邻近单元自由度的敏感性。
*


* [1.x.186]
*
* [1.x.187] [1.x.188].
* 在这里，我们实际求解线性系统，使用Trilinos的Aztec或Amesos线性求解器。计算的结果将被写入传递给这个函数的参数向量中。其结果是一对迭代次数和最终的线性残差。
*


*


* [1.x.189]
*
* 如果参数文件中指定要使用直接求解器，那么我们就会到这里。这个过程很简单，因为deal.II在Trilinos中为Amesos直接求解器提供了一个封装类。我们所要做的就是创建一个求解器控制对象（这里只是一个虚拟对象，因为我们不会进行任何迭代），然后创建直接求解器对象。在实际进行求解时，注意我们没有传递一个预处理程序。无论如何，这对直接求解器来说没有什么意义。  最后，我们返回求解器的控制统计信息&mdash；它将告诉我们没有进行任何迭代，并且最终的线性残差为零，这里没有任何可能提供的更好的信息。
*


* [1.x.190]
*
* 同样地，如果我们要使用一个迭代求解器，我们使用Aztec的GMRES求解器。我们也可以在这里使用Trilinos的迭代求解器和预处理类，但是我们选择直接使用Aztec求解器。对于给定的问题，Aztec的内部预处理实现优于deal.II的包装类，所以我们在AztecOO求解器中使用ILU-T预处理，并设置了一堆可以从参数文件中修改的选项。         
* 还有两个实际问题。由于我们将右手边和求解向量建立为deal.II向量对象（而不是矩阵，它是一个Trilinos对象），我们必须将Trilinos Epetra向量交给求解器。  幸运的是，他们支持 "视图 "的概念，所以我们只需发送一个指向deal.II向量的指针。我们必须为设置平行分布的向量提供一个Epetra_Map，这只是一个串行的假对象。最简单的方法是要求矩阵提供它的地图，我们要用它为矩阵-向量乘积做好准备。         
* 其次，Aztec求解器要我们传入一个Trilinos Epetra_CrsMatrix，而不是deal.II包装类本身。所以我们通过trilinos_matrix()命令来访问Trilinos包装类中的实际Trilinos矩阵。Trilinos希望矩阵是非常量的，所以我们必须使用const_cast手动删除常量。
*


* [1.x.191]
*
* [1.x.192] [1.x.193]。


*
* 这个函数是非常简单的。我们并不假装我们在这里知道一个好的细化指标是什么。相反，我们假设[2.x.237]类会知道这个问题，所以我们只是简单地服从于我们在那里实现的相应函数。
*


* [1.x.194]
*
* [1.x.195] [1.x.196]。


*
* 这里，我们使用之前计算的细化指标来细化网格。在开始的时候，我们在所有的单元格上循环，并标记那些我们认为应该被细化的单元格。
*


* [1.x.197]
*
* 然后我们需要在进行细化的同时，将各种解向量从旧网格转移到新网格。SolutionTransfer类是我们的朋友；它有相当丰富的文档，包括例子，所以我们不会对下面的代码做太多评论。最后三行只是把其他一些向量的大小重新设置为现在的正确大小。
*


* [1.x.198]
*
* [1.x.199] [1.x.200]。


*
* 这个函数现在是相当直接的。所有的魔法，包括将数据从保守变量转化为物理变量，都已经被抽象化，并被移到EulerEquations类中，以便在我们想要解决其他双曲守恒定律时可以被替换。   
* 请注意，输出文件的数量是通过保持一个静态变量形式的计数器来确定的，这个计数器在我们第一次来到这个函数时被设置为零，并在每次调用结束时被增加一。
*


* [1.x.201]
*
* [1.x.202] [1.x.203]。


*
* 这个函数包含了这个程序的顶层逻辑：初始化、时间循环和牛顿内部迭代。   
* 开始时，我们读取参数文件指定的网格文件，设置DoFHandler和各种向量，然后在这个网格上插值给定的初始条件。然后我们在初始条件的基础上进行一系列的网格细化，以获得一个已经很适应起始解的网格。在这个过程结束时，我们输出初始解。
*


* [1.x.204]
*
* 所有字段的大小。
*


* [1.x.205]
*
* 然后我们进入主时间步进循环。在顶部，我们简单地输出一些状态信息，这样就可以跟踪计算的位置，以及显示非线性内部迭代进展的表格的标题。
*


* [1.x.206]
*
* 然后是内牛顿迭代，在每个时间步长中解决非线性问题。它的工作方式是将矩阵和右手边重置为零，然后组装线性系统。如果右手边的规范足够小，那么我们就宣布牛顿迭代已经收敛了。否则，我们求解线性系统，用牛顿增量更新当前解，并输出收敛信息。最后，我们检查牛顿迭代的次数是否超过10次的限制。
*
* 如果超过了，就说明迭代有可能出现分歧，继续迭代也没有好处。如果发生这种情况，我们会抛出一个异常，这个异常会在[2.x.238]中被捕获，并在程序终止前显示状态信息。         
* 注意，我们在下面写AssertThrow宏的方式大体上等同于写<code>if (!(nonlin_iter [2.x.239] 10)) throw ExcMessage ("No convergence in nonlinear solver");</code>。唯一显著的区别是，AssertThrow还确保被抛出的异常带有它产生的位置（文件名和行号）的信息。这在这里不是太关键，因为只有一个地方可能发生这种异常；然而，当人们想找出错误发生的地方时，它通常是一个非常有用的工具。
*


* [1.x.207]
*
* 我们只有在牛顿迭代已经收敛的情况下才会到达这一点，所以在这里做各种收敛后的任务。         
* 首先，我们更新时间并产生图形输出（如果需要）。然后，我们通过近似[2.x.240]来更新下一个时间步长的解决方案的预测器，以尝试使适应性更好地工作。  我们的想法是尝试在前面进行细化，而不是步入一个粗略的元素集并抹去旧的解决方案。  这个简单的时间推断器可以完成这个工作。有了这个，如果用户需要的话，我们就可以细化网格，最后继续进行下一个时间步骤。
*


* [1.x.208]
*
* [1.x.209] [1.x.210]。


*
* 下面的``main''函数与以前的例子类似，不需要注释。注意，如果在命令行上没有给出输入文件名，程序就会中止。
*


* [1.x.211]
* [1.x.212][1.x.213][1.x.214] 。


* 我们用网格[2.x.241]（该文件与本程序的源代码在同一目录下）和以下输入盘（可在同一目录下作为[2.x.242]）运行该问题。
* [1.x.215]

* 当我们运行该程序时，我们会得到以下那种输出。
* [1.x.216]
*
* 这个输出报告了牛顿迭代的进度和时间步进的情况。请注意，我们对牛顿迭代的实现确实显示了预期的二次收敛顺序：每一步的非线性残差的规范大致是前一步的规范的平方。这导致了我们在这里可以看到的非常快速的收敛。这种情况一直保持到[2.x.243]，这时非线性迭代报告缺乏收敛性。
* [1.x.217]
*
* 我们可以通过查看解决方案的动画来找出原因和可能的补救措施。
* 运行这些计算的结果是一堆输出文件，我们可以将其传递给我们选择的可视化程序。当我们把它们整理成amovie时，过去几个时间步骤的结果看起来像这样。
* [2.x.244]
* 正如我们所看到的，当沉重的流体质量撞到左下角时，会发生一些振荡，导致迭代的发散。解决这个问题的一个懒办法是添加更多的粘性。如果我们将扩散功率设置为[2.x.245]而不是[2.x.246]，模拟将能够度过这一危机。那么，结果就会是这样的。
*

* [2.x.247]
* 沉重的流体在重力作用下被拉下斜坡，在那里与滑雪屋相撞，并被抛向空中!  希望每个人都能逃出生天!还有，我们可以看到重质和轻质之间的边界由于人为的粘性而迅速模糊了。
* 我们还可以看到自适应细化网格的演变。
* [2.x.248]
*根据上面讨论的启发式精炼方案，自适应性跟随并先于流动模式。
*


*

*[1.x.218][1.x.219][1.x.220]


*[1.x.221][1.x.222]


* 我们所选择的数值方案在人工粘度较小的情况下不是特别稳定，而在人工粘度较大的情况下则过于扩散。此外，众所周知，还有更先进的技术来稳定解决方案，例如流线型扩散、最小二乘法稳定条款、熵粘性。
*


*[1.x.223][1.x.224]


* 虽然作为非线性求解器的牛顿方法在时间步长足够小的情况下似乎效果很好，但线性求解器可以得到改进。例如，在目前的方案中，只要我们使用迭代求解器，每个牛顿步骤都要重新计算ILU；同样，对于直接求解器，每个步骤都要计算牛顿矩阵的LU分解。这显然是一种浪费：从一个牛顿步骤到另一个牛顿步骤，可能还有不同的时间步骤，牛顿矩阵并没有发生根本性的变化：一个牛顿步骤的ILU或稀疏LU分解可能仍然是下一个牛顿或时间步骤的非常好的预处理。因此，避免这些计算是减少计算时间的一个好办法。
* 我们可以再进一步：由于接近收敛时，牛顿矩阵只发生一点点变化，我们可以定义一个准牛顿方案，在这个方案中，我们只在每次牛顿迭代中重新计算残差（即右手边的向量），并重新使用牛顿矩阵。由此产生的方案很可能不是二次收敛的，我们必须期望多做几次非线性迭代；然而，鉴于我们不必每次都花时间建立牛顿矩阵，由此产生的方案很可能更快。
*

*[1.x.225][1.x.226]


*在[2.x.249]中计算的残差读作[2.x.250]，这意味着我们在一个牛顿迭代步骤中计算两次空间残差：一次是关于当前解[2.x.251]，另一次是关于最后一个时间步骤的解[2.x.252]，在一个时间步骤的所有牛顿迭代中保持不变。在牛顿迭代中缓存残差的明确部分[2.x.253] 将节省大量劳动力。
*

*[1.x.227][1.x.228]


* 最后，作为超越欧拉方程直接求解的一个方向，本程序努力将欧拉方程特有的一切实现分离到一个类中（[2.x.254]类），而将矩阵和向量、非线性和线解器以及一般顶层逻辑特有的一切分离到另一个类中（[2.x.255]类）。
* 通过替换这个类中的通量矩阵和数值通量的定义，以及其中定义的各种其他部分，应该可以将[2.x.256]类也应用于其他双曲守恒定律。
*

* [1.x.229][1.x.230] [2.x.257] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-34_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25]
* [2.x.2]
* [1.x.26]
* [2.x.3]
* [1.x.27]
*[1.x.28][1.x.29]


*[1.x.30][1.x.31]
* 无粘性流体经过物体时的不可压缩运动（例如空气经过飞机机翼，或空气或水经过螺旋桨），通常用流体动力学的欧拉方程来模拟。
* [1.x.32]其中流体密度[2.x.4]和外力加速度[2.x.5]是给定的，速度[2.x.6]和压力[2.x.7]是未知数。这里[2.x.8]是一个封闭的有界区域，代表流体围绕身体运动。
* 上述方程可以从纳维-斯托克斯方程推导出来，假设与压力梯度、惯性力和外力的影响相比，粘度造成的影响可以忽略不计。这与[2.x.9]中讨论的斯托克斯方程的情况正好相反，斯托克斯方程是主导粘度的极限情况，即速度非常小，惯性力可以忽略不计。另一方面，由于假定的不可压缩性，该方程不适合于非常高速的气体流动，在这种情况下，必须考虑气体的可压缩性和状态方程，导致气体动力学的欧拉方程，一个双曲系统。
* 在本教程中，我们将只考虑没有外力的静止流动：[1.x.33] 。
*

* 欧拉方程的解的唯一性是通过添加边界条件[1.x.34]来保证的。
* 也就是说，身体在我们的坐标系中是静止的，不具有渗透性，而流体在无限远处具有（恒定）速度[2.x.10]。另一种观点是，我们的坐标系随着身体移动，而背景流体在无穷远处处于静止状态。注意，我们将法线[2.x.11]定义为域[2.x.12]的[1.x.35]法线，它与积分域的外法线相反。
* 对于静止和非静止的流动，求解过程从求解第二个方程中的速度开始，然后代入第一个方程以求得压力。静止欧拉方程的求解通常是为了了解给定的（可能是复杂的）几何体在对系统实施规定运动时的行为。
* 这个过程的第一步是将参照系从一个与身体一起运动的坐标系改变为一个身体在无限远处静止的流体中运动的坐标系。这可以通过引入一个新的速度[2.x.13]来表示，对于这个速度，我们发现同样的方程成立（因为[2.x.14]），我们有边界条件[1.x.36]
* 如果我们假设流体是无旋转的，即[2.x.15]中的[2.x.16]，我们可以将速度，以及由此产生的扰动速度，表示为一个标量函数的梯度：[1.x.37因此，上述欧拉方程的第二部分可以改写为未知数[2.x.17]的同质拉普拉斯方程：[1.x.38]，而动量方程则简化为伯努利方程，将压力[2.x.18]表示为势的函数[2.x.19] ：[1.x.39]
* 因此，我们可以通过解决电势的拉普拉斯方程来解决这个问题。  我们回顾一下，下列函数，称为拉普拉斯方程的基本解。
* [1.x.40]
* 在分布意义上满足该方程。
* [1.x.41]
* 其中导数是在变量[2.x.20]中完成的。通过使用通常的格林定理，我们的问题可以只写在边界[2.x.21]上。我们回顾一下第二个格林同位数的一般定义。
* [1.x.42]
* 其中[2.x.22]是[2.x.23]表面的法线，从积分域[2.x.24]向外指向。
* 在我们的例子中，积分域是域[2.x.25]，其边界是[2.x.26]，其中无限远处的 "边界 "被定义为
* [1.x.43]
* 在我们的程序中，法线被定义为域[2.x.27]的[1.x.44]，也就是说，它们实际上是积分域的[1.x.45]，在定义各种法线符号正确的积分时需要注意，即用[2.x.29]取代[2.x.28]。
* 如果我们将[2.x.30]和[2.x.31]与[2.x.32]以及拉普拉斯方程的基本解分别替换为格林%同位数，只要[2.x.33]被选在[2.x.34]区域内，我们就可以得到：[1.x.46]
*其中法线现在指向[1.x.47]这个积分域。
* 注意在上述方程中，我们也有在[2.x.35]的边界比例上的积分。利用我们问题的边界条件，我们发现[2.x.36]在无穷远处为零（这简化了右手边[2.x.37]上的积分）。
* 左手边出现的[2.x.38]上的积分可以通过观察[2.x.39]来处理，这意味着[2.x.40]在无穷远处必然是常数。我们把它的值定义为[2.x.41]。  要证明这一点是很容易的
* [1.x.48]
* 利用这个结果，我们可以使用所谓的单层和双层势能算子，只在边界[2.x.42]上还原上述方程。
* [1.x.49]
* (这些算子的名字来自于它们分别描述了[2.x.43]中由于沿表面的单层薄电荷和由于沿表面的双层电荷和反电荷而产生的电动势。)
* 在我们的例子中，我们知道边界上[2.x.44]的诺伊曼值：[2.x.45] .因此，[1.x.50]如果我们对上述方程的[2.x.46]采取倾向于[2.x.47]的极限，利用众所周知的单层和双层运算符的特性，我们得到一个关于[2.x.48]的方程，就在[2.x.50]边界的[2.x.49] 。
* [1.x.51]
* 这就是我们要找的边界积分方程（BIE），其中[2.x.51]这个量是点[2.x.52]看到积分域[2.x.53]的角度或实体角的分数。
* 特别是，在边界[2.x.55]可微的点[2.x.54]（即光滑），我们有[2.x.56]，但在边界有角或边的点，该值可能较小或较大。
* 代入单层和双层算子，我们得到：二维流动的[1.x.52]和三维流动的[1.x.53]，其中基本决议的法向导数被写成一种形式，使计算更容易。在这两种情况下，[2.x.57]都是完全在边界上提出的积分方程的解，因为[2.x.58]。
* 注意，点[2.x.60]看到域[2.x.61]的角度（2D）或实体角（3D）的分数[2.x.59]可以用双层势本身来定义：[1.x.54] 。
* 如果我们考虑到纯诺伊曼问题的解在一个任意常数[2.x.62]内是已知的，这意味着，如果我们将诺伊曼数据设置为零，那么任何常数[2.x.63]都将是一个解，就可以理解这一点。
* [1.x.55]
* [2.x.64]上的积分是统一的，见上文，所以除以常数[2.x.65]，我们就得到了上面[2.x.66]的明确表达式。
* 虽然本例程序实际上只关注边界积分方程的求解，但在现实的设置中，我们仍然需要对速度进行求解。为此，请注意，我们刚刚计算了[2.x.67]的所有[2.x.68]。在下一步，我们可以在所有的[2.x.70]中计算（如果我们想的话，可以用分析法）解[2.x.69]。为此，回顾一下我们的[1.x.56]，现在我们有了右手边的所有东西（[2.x.71]和[2.x.72]是我们可以评估的积分，边界上的法线速度是给定的，边界上的[2.x.73]我们刚刚计算过）。最后，我们可以将速度恢复为[2.x.74] 。
* 注意，对[2.x.75]的上述公式的评估结果应该是零，因为狄拉克三角[2.x.76]在域[2.x.77]的积分根据定义总是零。
* 作为最后的测试，让我们验证这个速度是否确实满足静止流场的动量平衡方程，也就是说，对于某个（未知）压力[2.x.80]和一个给定的常数[2.x.81]，[2.x.78]是否在[2.x.79]中。换句话说，我们想验证上面所说的伯努利定律是否真的成立。为了证明这一点，我们用这个方程的左手边等于
* [1.x.57]
*其中我们使用了[2.x.82]是常数。我们想把这个表达式写成某个东西的梯度（记住[2.x.83]是一个常数）。如果我们单独考虑方程的各个部分（对出现两次的指数求和是隐含的），那么下一步就比较方便了。
* [1.x.58]
*因为[2.x.84]和[2.x.85] 。接下来。
* [1.x.59]
* 同样，最后一项消失了，因为[2.x.86]是常数，我们可以将第一项和第三项合并为一项。
* [1.x.60]
*
* 我们现在只需要对最后一项再做一些按摩。使用乘积规则，我们得到
* [1.x.61]
* 这些项中的第一个是零（因为，同样，对[2.x.87]的求和得到[2.x.88]，它是零）。最后一项可以写成[2.x.89]，它是理想的梯度形式。因此，我们现在可以最终说明
* [1.x.62]
* 或者以矢量形式：[1.x.63]或者换句话说：[1.x.64]因为压力只确定到一个常数（它在方程中只出现梯度），一个同样有效的定义是[1.x.65]这正是上面提到的伯努利定律。
*

*[1.x.66][1.x.67]


* 边界积分方程(BIE)的数值近似通常被称为边界元素法或面板法(后者主要用于计算流体力学界)。以下测试问题的目标是解决具有Neumann边界条件的拉普拉斯方程的积分形式，分别使用一个圆和一个球体在两个和三个间隔维中，沿途说明了允许人们使用deal.II库处理边界元素问题几乎与有限元问题一样容易。
* 为此，如果[2.x.93]，让[2.x.90]是将平面[2.x.91]细分为[2.x.92]条线段，如果[2.x.95]，让[2.x.94]条四边形。我们将每个单独的线段或四边形称为[1.x.68]或[1.x.69]，与周围空间[2.x.97]的维度[2.x.96]无关。我们将有限维空间[2.x.98]定义为[1.x.70]，基函数[2.x.99]，我们将使用通常的FE_Qfinite元素，但这次是定义在一个一维的流形上（我们通过使用第二个模板参数来做到这一点，通常默认为等于第一个；这里，我们将在一个[2.x.100] 。 [2.x.103]的一个元素[2.x.102]被其系数[2.x.105]的向量[2.x.104]所唯一识别，即：[1.x.71]，其中的求和隐含在重复索引中。请注意，我们可以在这里使用连续的元素；事实上，没有真正的理由使用连续的元素，因为积分公式并没有对我们的试验函数施加任何导数，所以连续性是不必要的，而且在文献中通常只使用片状常数元素。
*[1.x.72][1.x.73]
*

* 到目前为止，最常见的边界积分方程的近似方法是使用基于边界元素的配位法。
* 这种方法要求在一定数量的同位点上对边界积分方程进行评估，同位点的数量等于系统的未知数。这些点的选择是一个微妙的问题，需要仔细研究。假设这些点暂时是已知的，并称它们为[2.x.106]和[2.x.107]。
* 那么问题就变成了：给定基准点[2.x.108]，在[2.x.110]中找到一个函数[2.x.109]，使以下[2.x.111]方程得到满足。
* [1.x.74]
* 其中数量[2.x.112]是点[2.x.113]看到域[2.x.114]的（实体）角度的分数，如上所述，我们设置[2.x.115]为零。  如果适当地选择支持点[2.x.116]，那么问题可以写成以下线性系统。
* [1.x.75]
* 其中
* [1.x.76]
* 从线性代数的角度来看，最佳的坐标点选择是使矩阵[2.x.117]成为最对角线主导的。一个自然的选择是选择[2.x.118]坐标点作为节点基函数[2.x.119]的支持点。在这种情况下，[2.x.120]，因此矩阵[2.x.121]是对角线，其条目[1.x.77]，我们用[2.x.122]作为通常的Lagrangeelements。]、[2.x.124]和右手边[2.x.125]的计算需要对三角形[2.x.126]的元素进行奇异积分的评估。].在这些情况下，通常所有的积分都是在一个参考简单域上进行的，也就是说，我们假设[2.x.129]的每个元素[2.x.128]可以表示为参考边界元素[2.x.130]的线性（二维）或双线性（三维）变换，并且我们在从实数元素[2.x.131]到参考元素[2.x.132]的变量改变后进行积分。
*[1.x.78][1.x.79] 。
*

* 在二维空间中，没有必要计算系统矩阵的对角线元素[2.x.133]，因为即使分母在[2.x.134]时归零，分子也总是为零，因为[2.x.135]和[2.x.136]是正交的（在我们对[2.x.137]边界的多边形近似上），唯一的奇异积分出现在对[2.x.138]的第i个元素的计算上：[1.x.80]
* 这可以通过QGaussLogR正交公式轻松处理。
* 同样地，也可以用QGaussOneOverR正交公式来进行三维的奇异积分。有兴趣的读者可以在其文档中找到关于这些正交规则如何工作的详细解释。
* 结果矩阵[2.x.140]是完整的。根据其大小，使用直接求解器或迭代求解器可能比较方便。为了这个例子代码的目的，我们选择只使用迭代求解器，而不提供任何预处理程序。
* 如果这是一个生产代码，而不是一个原理的演示，有一些技术可以不存储完整的矩阵，而只存储那些大的和/或相关的条目。在关于边界元素方法的文献中，有大量的方法可以确定哪些元素是重要的，哪些是不重要的，从而使这些矩阵的表示明显地更加稀疏，也有利于快速评估向量和矩阵之间的标量积。这不是本程序的目标，我们把它留给更复杂的实现方式。
*

*[1.x.81][1.x.82]


* 实现是相当直接的。在以前的教程中没有使用过的主要一点是，deal.II中的大多数类不仅在维度上有模板，而且实际上在我们提出微分方程的流形的维度以及这个流形嵌入的空间的维度上也有模板。默认情况下，第二个模板参数等于第一个，这意味着我们要在二维空间的二维区域内求解。在这种情况下，要使用的三角类是[2.x.141]，这相当于写成[2.x.142]。
* 然而，情况并非如此：在目前的例子中，我们想在一个球体的表面上求解，这是一个嵌入三维空间的二维法域。因此，正确的类将是[2.x.143]，相应地，我们将使用[2.x.144]作为DoF处理类，[2.x.145]作为有限元。
* 关于人们可以对生活在曲面上的事物做什么的一些进一步细节，可以在报告[1.x.83][1.x.84]中找到。此外，[2.x.146]教程程序将我们在这里展示的内容扩展到流形上提出的方程不是积分算子而实际上涉及导数的情况。
*

*[1.x.85][1.x.86]


* 我们要解决的测试案例是一个圆形（2D）或球形（3D）的障碍物。这些几何体的网格将从当前目录下的文件中读入，然后将一个SphericalManifold类型的对象附加到三角形上，以允许网格细化，从而尊重离散初始网格背后的连续几何体。
* 对于一个半径为[2.x.147]的球体，以[2.x.148]的速度向[2.x.149]方向平移，其势为
* [1.x.87]
* 见，例如J.N. Newman, [1.x.88], 1977,pp.127.对于单位速度和半径，并限制[2.x.150]位于球体表面，[2.x.151] 。在试验问题中，流向是[2.x.152]，所以球面上适当的精确解是上述解与沿[2.x.153]和[2.x.154]轴的类似解的叠加，即[2.x.155] 。
*

* [1.x.89] [1.x.90]。
* [1.x.91] [1.x.92]。



* 程序开始时包括一堆include文件，我们将在程序的各个部分使用这些文件。其中大部分已经在以前的教程中讨论过了。
*


* [1.x.93]
*
* 这里还有一些我们需要的C++标准头文件。
*


* [1.x.94]
*
* 本序言的最后部分是将dealii命名空间中的所有内容导入到本程序中的所有内容中。
*


* [1.x.95]
*
* [1.x.96] [1.x.97]。


*
*首先，让我们定义一下边界积分方程的机制。
*

*
* 以下两个函数是单层和双层势能核的实际计算，即 [2.x.156] 和 [2.x.157] 。只有当矢量[2.x.158]不同于零时，它们才是定义良好的。
*


* [1.x.98]
*
* [1.x.99] [1.x.100]。


*
* 边界元素方法代码的结构与有限元素代码的结构非常相似，因此该类的成员函数与其他大多数教程程序的成员函数一样。特别是，现在你应该已经熟悉了从外部文件中读取参数，以及将不同的任务分割成不同的模块。这同样适用于边界元素方法，我们不会对其进行过多的评论，只是说说其中的区别。
*


* [1.x.101]

* 我们在这里发现的唯一真正不同的函数是装配程序。我们以最可能的通用方式编写了这个函数，以便能够方便地推广到高阶方法和不同的基本解（例如斯托克斯或麦克斯韦）。     
* 最明显的区别是，最终的矩阵是完整的，而且我们在通常的单元格循环内有一个嵌套的循环，访问所有自由度的支持点。  此外，当支持点位于我们所访问的单元内时，我们所执行的积分就会变成单数。     
* 实际结果是，我们有两套正交公式、有限元值和临时存储，一套用于标准积分，另一套用于奇异积分，在必要时使用。
*


* [1.x.102]
*
* 这个问题的解决有两个选项。第一个是使用直接求解器，第二个是使用迭代求解器。我们选择了第二种方案。     
* 我们组装的矩阵不是对称的，我们选择使用GMRES方法；然而为边界元素方法构建一个有效的预处理程序并不是一个简单的问题。这里我们使用了一个非预处理的GMRES求解器。迭代求解器的选项，如公差、最大迭代次数等，都是通过参数文件选择的。
*


* [1.x.103]
*
* 一旦我们得到了解决方案，我们就计算计算势的[2.x.159]误差以及实体角的近似值的[2.x.160]误差。我们使用的网格是平滑曲线的近似值，因此计算出的角的分量或实体角的对角线矩阵 [2.x.161] 应该一直等于 [2.x.162] 。在这个例程中，我们输出势的误差和计算角度的近似值的误差。注意，后者的误差实际上不是计算角度的误差，而是我们对球体和圆的近似程度的衡量。     
* 对角度的计算做一些实验，对于较简单的几何形状，可以得到非常准确的结果。为了验证这一点，你可以在read_domain()方法中注释掉tria.set_manifold(1, manifold)一行，并检查程序生成的alpha。通过删除这个调用，每当细化网格时，新的节点将沿着构成粗略网格的直线放置，而不是被拉到我们真正想要近似的表面。在三维案例中，球体的粗网格是从一个立方体开始得到的，得到的字母值在面的节点上正好是[2.x.163]，在边的节点上是[2.x.164]，在顶点的八个节点上是[2.x.165]。
*


* [1.x.104]
*
* 一旦我们在一维领域得到了一个解，我们就想把它插值到空间的其他部分。这可以通过在compute_exterior_solution()函数中再次进行解与核的卷积来完成。     
* 我们想绘制速度变量，也就是势解的梯度。势解只在边界上是已知的，但我们使用与基本解的卷积在标准的二维连续有限元空间上进行插值。外推解的梯度图将给我们提供我们想要的速度。     
* 除了外域上的解，我们还在output_results()函数中输出域的边界上的解，当然了。
*


* [1.x.105]
*
* 为了允许不受维度限制的编程，我们对这个单一的函数进行了专业化处理，以提取整合单元内部的奇异核所需的奇异正交公式。
*


* [1.x.106]
*
* 通常的deal.II类可以通过指定问题的 "cod dimension "来用于边界元素方法。这是通过将Triangulation, FiniteElement和DoFHandler的可选第二模板参数设置为嵌入空间的维度来实现的。在我们的例子中，我们生成了嵌入到2或3维空间的1或2维网格。     
* 可选的参数默认等于第一个参数，并产生我们在之前所有例子中看到的通常的有限元类。     
* 该类的构造方式是允许任意的域（通过高阶映射）和有限元空间的逼近顺序。有限元空间和映射的顺序可以在该类的构造函数中选择。
*


*


* [1.x.107]
*
* 在BEM方法中，生成的矩阵是密集的。根据问题的大小，最终的系统可能通过直接的LU分解来解决，或者通过迭代方法来解决。在这个例子中，我们使用了一个无条件的GMRES方法。为BEM方法建立一个预处理程序是不容易的，我们在此不做处理。
*


*


* [1.x.108]
*
* 接下来的两个变量将表示解决方案[2.x.166]以及一个向量，它将保持[2.x.167]的值（从一个点[2.x.169]可见的[2.x.168]的部分）在我们形状函数的支持点。
*


*


* [1.x.109]
*
*收敛表用于输出精确解和计算的字母的误差。
*


*


* [1.x.110]

* 以下是我们通过参数文件填充的变量。  在这个例子中，我们使用的新对象是[2.x.170]对象和QuadratureSelector对象。     
* [2.x.171]类允许我们通过参数文件轻松快速地定义新的函数对象，自定义的定义可以非常复杂（所有可用的选项见该类的文档）。     
* 我们将使用QuadratureSelector类来分配正交对象，该类允许我们根据一个识别字符串和公式本身的可能程度来生成正交公式。我们用它来允许自定义选择标准积分的正交公式，并定义奇异正交规则的顺序。     
* 我们还定义了几个参数，这些参数是在我们想把解决方案扩展到整个领域的情况下使用的。
*


*


* [1.x.111]
*
* [1.x.112] [1.x.113]。


*
* 构造函数初始化各种对象的方式与有限元程序（如 [2.x.172] 或 [2.x.173] ）中的方式基本相同。这里唯一的新成分是ParsedFunction对象，它在构造时需要说明组件的数量。   
* 对于精确解来说，向量分量的数量是1，而且不需要任何操作，因为1是ParsedFunction对象的默认值。然而，风需要指定dim组件。注意，在为[2.x.174]的表达式声明参数文件中的条目时，我们需要明确指定分量的数量，因为函数[2.x.175]是静态的，对分量的数量没有了解。
*


* [1.x.114]
*
* 对于二维和三维，我们将默认的输入数据设置为：解是[2.x.176]或[2.x.177] 。实际计算出的解在无穷大时的值为零。在这种情况下，这与精确解相吻合，不需要额外的修正，但是你应该意识到，我们任意设置[2.x.178]，而我们传递给程序的精确解需要在无穷远处有相同的值才能正确计算出误差。     
* [2.x.179]对象的使用是非常直接的。[2.x.180]函数需要一个额外的整数参数，指定给定函数的分量数量。它的默认值是1。当相应的[2.x.181]方法被调用时，调用对象必须有与这里定义的相同数量的组件，否则会产生异常。     
* 在声明条目时，我们同时声明二维和三维的函数。然而，最终只有二维的那个被解析。这使得我们对二维和三维的问题都只有一个参数文件。     
* 注意，从数学的角度来看，边界上的风函数应该满足条件[2.x.182]，这样问题才有解。如果不满足这个条件，那么就找不到解，求解器也不会收敛。
*


* [1.x.115]
*
* 在求解器部分，我们设置所有的SolverControl参数。然后，该对象将被送入GMRES求解器的solve_system()函数中。
*


* [1.x.116]
*
* 在向ParameterHandler对象声明了所有这些参数后，让我们读取一个输入文件，该文件将给这些参数提供它们的值。然后我们继续从ParameterHandler对象中提取这些值。
*


* [1.x.117]
*
* 最后，这里还有一个例子说明如何在独立维度编程中使用参数文件。  如果我们想关闭两个模拟中的一个，我们可以通过设置相应的 "运行2D模拟 "或 "运行3D模拟 "标志为假来实现。
*


* [1.x.118]
*
* [1.x.119] [1.x.120]。


*
* 边界元素法三角剖分基本上与（dim-1）维三角剖分相同，不同的是，顶点属于（dim）维空间。   
* deal.II中支持的一些网格格式默认使用三维点来描述网格。这些格式与deal.II的边界元素方法功能兼容。特别是我们可以使用UCD或GMSH格式。在这两种情况下，我们必须特别注意网格的方向，因为与标准有限元的情况不同，这里没有进行重新排序或兼容性检查。  所有的网格都被认为是有方向性的，因为它们被嵌入到一个高维空间中。参见GridIn和Triangulation的文档，以进一步了解三角结构中单元的方向。在我们的例子中，网格的法线是外在于2D的圆和3D的球体。   
* 对边界元素网格进行适当细化所需要的另一个细节是对网格所逼近的流形的准确描述。对于标准有限元网格的边界，我们已经看到过多次（例如在[2.x.183]和[2.x.184]中），这里的原理和用法是一样的，只是SphericalManifold类需要一个额外的模板参数来指定嵌入空间的维度。
*


*


* [1.x.121]
*
* 对[2.x.185]的调用复制了流形（通过[2.x.186]，所以我们不需要担心对[2.x.187]的无效指针。
*


* [1.x.122]
*
* [1.x.123] [1.x.124]。


*
* 这个函数全局地细化网格，分配自由度，并调整矩阵和向量的大小。
*


*


* [1.x.125]
*
* [1.x.126] [1.x.127]。



* 下面是这个程序的主要功能，组装与边界积分方程相对应的矩阵。
*


* [1.x.128]
*
* 首先，我们用正交公式初始化一个FEValues对象，用于在非奇异单元中进行核的积分。这个正交公式是通过参数文件选择的，并且需要相当精确，因为我们要积分的函数不是多项式函数。
*


* [1.x.129]
*
* 与有限元方法不同，如果我们使用拼合边界元方法，那么在每个装配循环中，我们只装配指一个自由度（与支撑点[2.x.188]相关的度）和当前单元之间的耦合信息。这是用一个fe.dofs_per_cell元素的向量完成的，然后它将被分配到全局行的矩阵中 [2.x.189] 。以下对象将持有这些信息。
*


* [1.x.130]
*
* 指数[2.x.190]在拼合点上运行，这些拼合点是[2.x.191]个基函数的支持点，而[2.x.192]在内部积分点上运行。
*

*
* 我们构建一个支持点的向量，它将被用于局部积分。
*


* [1.x.131]
*
* 这样做之后，我们就可以开始对所有单元进行积分循环，首先初始化FEValues对象，得到正交点的[2.x.193]的值（这个向量场应该是常数，但更通用也无妨）。
*


* [1.x.132]
*
* 然后我们在当前单元上形成所有自由度的积分（注意，这包括不在当前单元上的自由度，这与通常的有限元积分有偏差）。如果其中一个局部自由度与支持点[2.x.194]相同，我们需要执行的积分是单数。因此，在循环的开始，我们检查是否是这种情况，并存储哪一个是奇异索引。
*


* [1.x.133]

* 然后我们进行积分。如果指数[2.x.195]不是局部自由度之一，我们只需将单层项加到右边，将双层项加到矩阵中。
*


* [1.x.134]

* 现在我们处理更微妙的情况。如果我们在这里，这意味着在[2.x.196]索引上运行的单元包含support_point[i]。在这种情况下，单层和双层电势都是单数，它们需要特殊处理。                 
* 每当在给定的单元内进行积分时，都会使用一个特殊的正交公式，允许人们对参考单元上的奇异权重进行任意函数的积分。                 
* 正确的正交公式是由get_singular_quadrature函数选择的，下面将详细说明。
*


* [1.x.135]
*
* 最后，我们需要将当前单元格的贡献添加到全局矩阵中。
*


* [1.x.136]
*
* 积分算子的第二部分是术语 [2.x.197] 。由于我们使用的是配位方案，[2.x.198]和相应的矩阵是一个对角线，其条目等于[2.x.199] 。
*

*
* 计算这个实体角的对角线矩阵的一个快速方法是使用诺伊曼矩阵本身。只需将该矩阵与一个元素的矢量相乘，这些元素都等于
*
* - ，得到阿尔法角或实体角的对角矩阵（见介绍中的公式）。然后将这个结果加回到系统矩阵对象上，得到矩阵的最终形式。
*


* [1.x.137]
*
* [1.x.138] [1.x.139]。


*
* 下一个函数简单地解决了线性系统。
*


* [1.x.140]
*
* [1.x.141] [1.x.142]。


*
* 误差的计算在其他所有的例子程序中都是完全一样的，我们就不做过多的评论。请注意，这里可以使用有限元方法中的相同方法。
*


* [1.x.143]
*
*α向量的误差可以直接使用[2.x.200]函数来计算，因为在每个节点上，该值应该是[2.x.201] 。然后，所有的误差都被输出并附加到我们的ConvergenceTable对象中，以便以后计算收敛率。
*


* [1.x.144]
*
* 奇异积分需要仔细选择正交规则。特别是deal.II库提供的正交规则是为对数奇异性（QGaussLog, QGaussLogR）以及1/R奇异性（QGaussOneOverR）量身定做的。   
* 奇异积分通常是通过构建具有奇异权重的加权正交公式得到的，因此可以写成
* [1.x.145]
* 其中[2.x.202]是一个给定的奇点，权重和正交点[2.x.203]是精心选择的，以使上述公式对某类函数[2.x.204]是一个等式。   
* 在我们迄今为止看到的所有有限元例子中，正交点本身的权重（即函数[2.x.205]），总是不断等于1。  对于奇异积分，我们有两个选择：我们可以使用上面的定义，从积分中剔除奇异性（即用特殊的正交规则对[2.x.206]进行积分），或者我们可以要求正交规则用[2.x.208]对权重[2.x.207]进行 "标准化"。
* [1.x.146]
* 我们通过QGaussLogR和QGaussOneOverR的[2.x.209]参数，使用这第二个选项。   
* 这些积分有些微妙，特别是在二维空间，由于从实数到参考单元的转换，积分的变量会随着转换的行列式而缩放。   
* 在二维空间中，这个过程不仅导致一个因子作为常数出现在整个积分上，而且还导致一个需要评估的额外积分。   
* [1.x.147]
* 这个过程由QGaussLogR类的构造函数来处理，它增加了额外的正交点和权重，以考虑到积分的第二部分。   
* 类似的推理应该在三维情况下进行，因为奇异正交是在参考单元的半径[2.x.210]的逆上定制的，而我们的奇异函数生活在实空间，然而在三维情况下一切都更简单，因为奇异性与变换的行列式呈线性比例。这使得我们可以只建立一次奇异的二维正交规则，并在所有单元中重复使用它们。   
* 在一维的奇异积分中，这是不可能的，因为我们需要知道正交的缩放参数，而这个参数并不是先验的。这里，正交规则本身也取决于当前单元的大小。由于这个原因，有必要为每个奇异积分创建一个新的正交法则。   
* 不同的正交规则是在get_singular_quadrature中建立的，它专门用于dim=2和dim=3，它们在assemble_system函数中被检索。作为参数给出的索引是奇点所在的单位支持点的索引。
*


*


* [1.x.148]
*
* [1.x.149] [1.x.150]。


*
* 我们还想知道一些关于外域中电势[2.x.211]的值：毕竟我们考虑边界积分问题的动机是我们想知道外域中的速度!   
* 为此，我们在此假设边界元素域包含在盒子[2.x.212]中，我们用与基本解的卷积来推算这个盒子内的实际解。这方面的公式在引言中已经给出。   
* 整个空间的解的重构是在一个维数为dim的连续有限元网格上完成的。这些都是常见的，我们不做进一步评论。在函数结束时，我们再次以通常的方式输出这个外部解。
*


* [1.x.151]
*
* [1.x.152] [1.x.153]。


*
* 输出我们的计算结果是一个相当机械的任务。这个函数的所有组成部分在前面已经讨论过了。
*


* [1.x.154]

* [1.x.155] [1.x.156]。


*
* 这是最主要的功能。它应该是不言自明的简短。



* [1.x.157]
*
* [1.x.158] [1.x.159]。



* 这是本程序的主要功能。它和以前所有的教程程序完全一样。



* [1.x.160]
* [1.x.161][1.x.162] 。


* 我们使用以下[2.x.213]文件（也可以在所有其他源文件所在的目录中找到）运行该程序。
* [1.x.163]

*当我们运行该程序时，屏幕上打印出以下内容。
* [1.x.164]

* 从2d中的收敛表可以看出，如果我们选择足够精确的正交公式，那么我们对[2.x.214]得到的误差应该正好是元素数的倒数。用N个大小相等的线段对圆进行近似，会产生一个有N个面的正多边形，其角度正好是[2.x.215]，因此我们的误差应该正好是[2.x.216] 。事实上，这是一个很好的指标，表明我们正在以适当的方式进行奇异积分。
* 势的近似[2.x.217]的误差主要是由于域的近似造成的。通过使用高阶映射可以获得更好的近似值。
* 如果我们修改main()函数，将fe_degree和mapping_degreet设置为2，并提高参数文件中正交公式的阶数，我们可以得到以下二维模拟的收敛表
* [1.x.165]
*
*和
* [1.x.166]
*
*为三维情况。我们可以看到，高阶映射的收敛结果要好得多，这主要是由于曲线几何的分辨率更高。请注意，在自由度相同的情况下，例如在三维模拟中Q1情况的第3步和Q2情况的第2步，误差大约要低三个数量级。
* 运行这些计算的结果是一堆输出文件，我们可以将其传递给我们选择的可视化程序。输出文件有两种：边界元素表面的势，以及扩展到外部和内部领域的势。在二维情况下，这两个文件的组合看起来像
* [2.x.218]
* 而在三维情况下，我们首先显示的是表面上的势，同时还有一个等高线图。
* [2.x.219]
* 然后是势的外部等高线图，不透明度设置为25%。
* [2.x.220]
*

* [1.x.167][1.x.168][1.x.169] 。


* 这是第一个考虑解决嵌入高维空间的表面上定义的方程的教程程序。但这里讨论的方程相对简单，因为它只涉及到一个积分算子，而不是在曲面上更难定义的导数。[2.x.221]教程程序考虑了这类问题并提供了必要的工具。
* 从实践的角度来看，这里使用的边界元素法（BEM）有两个瓶颈。首先是组装矩阵的成本与未知数的数量成二次方，即[2.x.222]，其中[2.x.223]是未知数的总数量。通过查看 "assemble_system() "函数可以看出，它的结构是这样的。
* [1.x.170]
* 这里，第一个循环遍历了所有单元（[2.x.224]的一个因子），而内循环则贡献了[2.x.225]的另一个因子。
* 这必须与局部*的有限元方法进行对比。
微分算子。在那里，我们在所有单元上循环（一个[2.x.226]的因子），在每个单元上做的工作与有多少个单元或未知数无关。这显然是一个瓶颈。
* 第二个瓶颈是系统矩阵是密集的（即是FullMatrix类型），因为每个自由度都与其他自由度耦合。如上所述，仅仅计算*这个带有[2.x.227]非零项的矩阵必然需要至少[2.x.228]次操作，但值得指出的是，仅仅做一个矩阵-向量乘积也要花费这么多操作。如果用于求解线性系统的GMRES方法需要的运算次数随着问题的大小而增加，这就是典型的情况，那么求解线性系统需要的运算次数甚至比[2.x.229]还要快。
* 真正的 "边界元素方法 "通过确定矩阵的哪些项是小的，因而可以忽略的策略来解决这些问题（当然，代价是引入一个额外的错误）。这可以通过认识到矩阵项随着自由度[2.x.230]和[2.x.231]定义的位置之间的（物理）距离衰减而实现。这一点可以在快速多极法（FMM）等方法中得到利用，这些方法可以控制哪些矩阵条目必须被存储和计算以达到一定的精度，以及
*
* - 如果做得好的话
*
* - 导致方法中，线性系统的组装和解决都需要少于[2.x.232]的操作。
* 实现这些方法显然提供了扩展当前程序的机会。
*

* [1.x.171][1.x.172] [2.x.233] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-35_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28]
* [2.x.2]
* [1.x.29]
* [1.x.30][1.x.31][1.x.32] 。


* [1.x.33][1.x.34][1.x.35] 。
* 本程序的目的是展示如何有效解决不可压缩的时间依赖性Navier-Stokes方程。这些方程描述了粘性不可压缩流体的流动，其内容如下
* [1.x.36]
* 其中[2.x.3]表示流速，[2.x.4]表示压力。这个方程组由初始条件[1.x.37]与[2.x.5]充分光滑和螺线管，以及合适的边界条件补充而成。例如，一个可接受的边界条件是[1.x.38]，也可以规定其他边界条件。在我们这里解决的测试案例中，边界被划分为两个不相交的子集[2.x.6]，我们有[1.x.39]和[1.x.40]，其中[2.x.7]是外部单位法线。[2.x.8]上的边界条件经常被用来模拟外流条件。
* 在以前的教程中（例如见[2.x.9]和[2.x.10]），我们已经看到了如何使用Schur补数方法来解决时间无关的斯托克斯方程。对于时间依赖的情况，在时间离散化之后，我们将得到一个系统，如
* [1.x.41]
* 其中[2.x.11]是时间步长。尽管这个系统的结构与斯托克斯系统相似，因此可以用Schur补数的方法来解决，但事实证明，Schur补数的条件数与[2.x.12]成正比。这使得该系统非常难以解决，并意味着对于纳维-斯托克斯方程来说，这不是一个有用的解决途径。
* [1.x.42][1.x.43][1.x.44] 。
*

* 相反，我们需要想出一种不同的方法来解决与时间有关的Navier-Stokesequations。解决这些问题的困难来自于速度和压力是通过约束[1.x.45]耦合在一起的，对于这个约束，压力是拉格朗日乘数。
* 让我们简短地描述一下投影方法在半离散情况下的样子。我们的目标是获得一个速度[2.x.13]和压力[2.x.14]的序列。假设从初始条件和一阶方法的应用中我们已经找到了[2.x.16]和[2.x.17]。那么投影法包括以下步骤。[2.x.18] [2.x.19] [1.x.46]。外推法。定义一下。  [1.x.47] [2.x.20] [1.x.48]。扩散步骤。我们发现[2.x.21]可以解决单一线性方程[1.x.49]。
* [2.x.22] [1.x.50]。投影。找到解决[1.x.51] [2.x.24] [1.x.52]的[2.x.23]。压力校正。这里我们有两个选项。     [2.x.25] [2.x.26] [1.x.53]。压力的更新方式是。      [1.x.54] [2.x.27] [1.x.55]。在这种情况下[1.x.56] [2.x.28] [2.x.29] 。
* 在不详细说明的情况下，让我们对我们刚刚描述的投影方法做一些说明。[2.x.30] [2.x.31] 平流项[2.x.32]被其[1.x.57] [1.x.58]取代，这与连续方程一致（因为[2.x.33]，尽管这对离散解来说不是点状的），并且需要它来保证时间步进方案的无条件稳定性。此外，为了使该术语线性化，我们使用[2.x.35]的二阶外推法[2.x.34] 。   [2.x.36] 投影步骤是亥姆霍兹分解[1.x.59]的实现，其中[1.x.60]和[1.x.61] 事实上，如果我们在[2.x.37]上使用这一分解，我们得到[1.x.62]与[2.x.38] 。取这个方程的发散，我们得出了投影方程。   [2.x.39] 上述两种变体中更准确的是旋转变体。然而，下面的程序同时实现了两种变体。此外，根据作者的经验，如果粘度[2.x.40]是可变的，应该使用标准形式。[2.x.41]
*

* [2.x.42] van Kan在[2.x.43] [2.x.44] J. van Kan, "A second-order accurate pressure-correction scheme for viscous incompressible flow", SIAM Journal on Scientific and Statistical Computing, Vol. 7, no.3, pp. 870-891, 1986 [2.x.45] 并由Guermond在[2.x.46] [2.x.47] J.-L. Guermond, "Un résultat de convergence d'ordre deux en temps pour l'approximation des équations de Navier-Stokes par une technique de projection incrémentale" , ESAIM: Mathematical Modelling and Numerical Analysis, vol. 33, no. 1, pp. 169-189, 1999 [2.x.48]的情况[2.x.49]。事实证明，这种技术受到运动压力的非物理边界条件的影响，导致收敛率降低。为了防止这种情况，Timmermans等人在[2.x.50] [2.x.51] L. Timmermans, P. Minev, and F. Van De Vosse, "An approximate projection scheme for incompressible flow using spectral elements", International Journal for Numerical Methods in Fluids, vol. 22, no. 7, pp.673-688, 1996 [2.x.52]。 [2.x.53] [2.x.54] J.-L. Guermond 和 J. Shen, "On the error estimates for the rotational pressure-correction projection methods", Mathematics of Computation, vol. 73, no. 248, pp.1719-1737, 2004 [2.x.55] 对Stokes问题进行了全面分析。[2.x.56]
* [1.x.63][1.x.64][1.x.65] 。
* 为了获得该方法的完全离散设置，我们一如既往地需要一个变分公式。鉴于边界条件的性质，这里有一个微妙的问题。当我们把方程乘以一个合适的检验函数时，出现的一个项是[1.x.66]如果我们，比如说，在整个边界上有迪里希特边界条件，那么经过部分积分，我们将得到[1.x.67]这种表述的一个优点是，它完全解耦了速度的各个组成部分。此外，它们都共享同一个系统矩阵。这一点可以在程序中加以利用。
* 然而，考虑到非标准的边界条件，为了能够将其考虑在内，我们需要使用下面的%同位素[1.x.68]，这样当我们进行分项积分并考虑到边界条件时，就可以得到[1.x.69]，这是我们必须使用的形式。此外，为了强制执行压力的边界条件，我们需要重写[1.x.70]，在速度的边界条件下，[2.x.57]中的边界积分等于零，在压力的边界条件下，[2.x.58]的边界积分等于零。
* 在边界[2.x.59]平行于坐标轴的简化情况下，即我们下面进行的试验情况下，实际上可以证明[1.x.71]这个问题在文献中并不经常涉及。更多信息，读者可以参考，例如，[2.x.60] [2.x.61] J.-L. GUERMOND, L. QUARTAPELLE, On the approximation of the unsteady Navier-Stokes equations by finite element projection methods, Numer.Math., 80 (1998) 207-238 [2.x.62] J.-L. GUERMOND, P. MINEV, J. SHEN, Error analysis of pressure-correction schemes for the Navier-Stokes equations with open boundary conditions, SIAM J. Numer.Anal., 43 1 (2005) 239-258.[2.x.63]
*


*[1.x.72][1.x.73][1.x.74]


* 我们对投影方法的实现遵循[1.x.75]上面的描述。然而，我们必须注意到，与其他大多数有多个求解分量的问题不同，我们没有使用矢量值的有限元。相反，我们对速度和压力的分量分别使用单独的有限元，并对它们使用不同的[2.x.64]'s。这样做的主要原因是，正如我们从方案的描述中看到的，速度和压力的[2.x.65]分量是解耦的。因此，所有速度分量的方程看起来都是一样的，具有相同的系统矩阵，并且可以以%的方式并行求解。很明显，这种方法也有其缺点。例如，在集合矩阵和右手边时，我们需要保持几个[2.x.66]s和迭代器的同步；获得矢量值函数的固有量（如发散）变得有点尴尬，还有其他的。
* [1.x.76][1.x.77][1.x.78] 。
*

* 我们在这个程序中使用的测试案例包括围绕一个方形障碍物的流动。其几何形状如下。
* [2.x.67]
* 与[2.x.68]一起，使几何形状略微不对称。
* 我们在顶壁、底壁和障碍物上都施加了无滑动的边界条件。在左边，我们有流入的边界条件[1.x.79]与[2.x.69]，即流入的边界条件对应于这个配置的Poiseuille流。最后，在右边的垂直壁上，我们施加条件，速度的垂直分量和压力都应该是零。
*

* [1.x.80] [1.x.81]。
* [1.x.82] [1.x.83]。


*
* 我们首先包括所有必要的deal.II头文件和一些C++相关的文件。它们中的每一个都已经在以前的教程程序中讨论过了，所以我们在这里就不做详细介绍了。
*


* [1.x.84]

* 最后这和以前的所有程序一样。
*


* [1.x.85]
*
* [1.x.86] [1.x.87]
* 由于我们的方法有几个可以微调的参数，我们把它们放到一个外部文件中，这样就可以在运行时确定它们。   
* 这尤其包括辅助变量[2.x.71]的方程表述，为此我们声明一个[2.x.72]。接下来，我们声明一个类，该类将读取和存储我们程序运行所需的所有参数。
*


* [1.x.88]
*
* 在这个类的构造函数中，我们声明所有的参数。这方面的细节已经在其他地方讨论过了，例如在 [2.x.73] 。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。


*
* 在下一个命名空间，我们声明初始和边界条件。
*


* [1.x.92]
*
* 由于我们选择了一个完全解耦的公式，我们将不利用deal.II处理矢量值问题的能力。然而，我们确实希望使用一个独立于维度的方程数据接口。为了做到这一点，我们的函数应该能够知道我们目前在哪个空间分量上工作，而且我们应该能够有一个通用的接口来做到这一点。下面的类是在这个方向上的一个尝试。
*


* [1.x.93]
*
* 有了这个类的定义，我们声明描述速度和压力的边界条件的类。
*


* [1.x.94]
*
* [1.x.95] [1.x.96]。


*
* 现在是该程序的主类。它实现了纳维-斯托克斯方程的各种版本的投影方法。所有的方法和成员变量的名称应该是不言自明的，同时考虑到介绍中给出的实现细节。
*


* [1.x.97]
*
* 接下来的几个结构和函数是用来做各种并行的事情。它们遵循[2.x.74]中提出的方案，使用WorkStream类。正如那里所解释的，这需要我们为每个汇编器声明两个结构，一个是每个任务的数据，一个是scratch数据结构。然后，这些结构被移交给组装本地贡献的函数，并将这些本地贡献复制到全局对象上。     
* 这个程序的一个特点是，我们不只是有一个代表速度和压力的DoFHandler对象，而是为这两种变量使用单独的DoFHandler对象。当我们想把涉及这两个变量的条款，如速度的发散和压力的梯度，乘以各自的测试函数时，我们要为这种优化付费。在这样做的时候，我们不能再仅仅使用一个FEValues对象，而是需要两个，而且需要用单元格迭代器来初始化它们，这些单元格迭代器指向三角形中的同一个单元格，但不同的DoFHandlers。     
* 为了在实践中做到这一点，我们声明一个 "同步 "迭代器
*
* 一个内部由多个（在我们的例子中是两个）迭代器组成的对象，每当同步迭代器向前移动一步，内部存储的每个迭代器也向前移动一步，从而始终保持同步。碰巧的是，有一个deal.II类可以促进这种事情。这里重要的是要知道，建立在同一个三角形上的两个DoFHandler对象将以相同的顺序走过三角形的单元。
*


* [1.x.98]

* 同样的一般布局也适用于以下实现装配平流项的类和函数。
*


* [1.x.99]
*
* 最后几个函数实现了扩散解以及输出的后处理，包括计算速度的卷曲。
*


* [1.x.100]
*
* [1.x.101] [1.x.102]。


*
* 在构造函数中，我们只是从作为参数传递的[2.x.75]对象中读取所有数据，验证我们读取的数据是否合理，最后，创建三角形并加载初始数据。
*


* [1.x.103]
*
* [1.x.104] [1.x.105]。


*
* 创建三角形的方法，并将其细化到所需的次数。在创建三角形后，它创建了与网格相关的数据，即分配自由度并重新编号，并初始化我们将使用的矩阵和向量。
*


* [1.x.106]
*
* [1.x.107] [1.x.108]。


*
* 该方法创建常数矩阵并加载初始数据。
*


* [1.x.109]
*
* [1.x.110] [1.x.111]。


*
* 在这组方法中，我们初始化了稀疏模式、约束条件（如果有的话）并组装了不依赖于时间步长的矩阵 [2.x.76] 。注意，对于拉普拉斯矩阵和质量矩阵，我们可以使用库中的函数来完成。因为这个函数的昂贵操作
*
* - 创建这两个矩阵
*
* 是完全独立的，我们原则上可以把它们标记为可以使用[2.x.77]函数并行工作的任务。我们在这里不会这样做，因为这些函数在内部已经被并行化了，特别是由于当前的函数在每个程序运行中只被调用一次，所以在每个时间步长中不会产生成本。然而，必要的修改将是非常直接的。
*


* [1.x.112]
*
*作用于压力空间的矩阵的初始化与作用于速度空间的矩阵相似。
*


* [1.x.113]
*
* 对于梯度算子，我们从初始化稀疏模式和压缩它开始。这里需要注意的是，梯度算子是从压力空间作用到速度空间的，所以我们必须处理两个不同的有限元空间。为了保持循环的同步，我们使用之前定义的别名，即[2.x.78] 。
*


* [1.x.114]
*
* [1.x.115] [1.x.116]。


*
* 这是时间行进函数，从[2.x.79]开始，使用时间步长[2.x.80]的投影法在时间上前进，直到[2.x.81] 。   
* 它的第二个参数[2.x.82]表示该函数是否应该输出它在任何特定时刻正在做什么的信息：例如，它将说明我们是否正在进行扩散、投影子步骤；更新前置条件器等。我们没有使用像[2.x.83]那样的代码来实现这种输出，而是使用ConditionalOStream类来为我们做这个。该类接受一个输出流和一个条件，该条件表明你传递给它的东西是否应该被传递到给定的输出流，或者应该被忽略。这样，上面的代码就变成了[2.x.84]，并且在任何情况下都能做正确的事情。
*


* [1.x.119]
*
* [1.x.120] [1.x.121]。


*
* 扩散步骤的实现。请注意，昂贵的操作是函数末尾的扩散解，我们必须为每个速度分量做一次。为了加快进度，我们允许以%并行方式进行，使用[2.x.85]函数，该函数确保[2.x.86]求解全部得到处理，并被安排到可用的处理器上：如果你的机器有一个以上的处理器核心，并且这个程序的其他部分目前没有使用资源，那么扩散求解将以%并行方式运行。另一方面，如果你的系统只有一个处理器核心，那么以%并行方式运行将是低效的（因为它导致了，例如，缓存拥堵），事情将被顺序执行。
*


* [1.x.122]
*
* [1.x.123] [1.x.124]。


*
* 下面几个函数是关于集合平流项的，这是扩散步骤的系统矩阵的一部分，在每一个时间步骤中都会发生变化。如上所述，我们将使用WorkStream类和[2.x.87]文件模块中描述的其他设施，在所有单元上以%并行方式运行装配循环。
*


* [1.x.125]
*
* [1.x.126] [1.x.127]。


*
* 这实现了投影的步骤。
*


* [1.x.128]
*
* [1.x.129] [1.x.130]。


*
* 这是投影法的压力更新步骤。它实现了该方法的标准表述，即[1.x.131]或旋转形式，即[1.x.132] 。
*


* [1.x.133]
*
* [1.x.134] [1.x.135]。


*
* 该方法绘制了当前的解决方案。主要的困难是，我们想创建一个单一的输出文件，其中包含所有的速度分量、压力以及流动的涡度的数据。另一方面，速度和压力存在于不同的DoFHandler对象中，因此不能用一个DataOut对象写入同一个文件。因此，我们必须更努力地把各种数据放到一个DoFHandler对象中，然后用它来驱动图形输出。   
* 我们不会在这里详细说明这个过程，而是参考[2.x.88]，那里使用了一个类似的程序（并有记录），为所有变量创建一个联合的DoFHandler对象。   
* 我们还注意到，我们在这里将涡度作为一个单独的函数中的标量来计算，使用[2.x.89]中的量[2.x.90]投影到用于速度分量的有限元空间。但原则上，我们也可以把速度作为一个点状量来计算，并通过[2.x.91]和[2.x.92]中讨论的数据后处理机制来实现。
*


* [1.x.136]
*
* 下面是一个辅助函数，通过将[2.x.93]项投影到用于速度分量的有限元空间来计算涡度。这个函数只有在我们生成图形输出时才会被调用，所以不是很频繁，因此我们没有像对待其他装配函数那样，麻烦地使用WorkStream概念来并行化它。不过，如果需要的话，这应该不会太复杂。此外，我们在这里的实现只适用于2D，所以如果情况不是这样，我们也会保释。
*


* [1.x.137]
*
* [1.x.138] [1.x.139]。


*
* 主功能看起来与其他所有的教程程序非常相似，所以这里没有什么可评论的。
*


* [1.x.140]
* [1.x.141][1.x.142][1.x.143] 。


*[1.x.144][1.x.145][1.x.146]


* 我们用下面的[2.x.94]运行代码，它可以在与源代码相同的目录中找到。
* [1.x.147]
*
* 如果我们把它设置为[2.x.96]，我们就可以得到程序正在做什么以及每个迭代过程需要多少步才能收敛等信息。
* 让我们绘制[2.x.97]（即时间步骤200、1000、2400、4000和5000）的结果，在左边一栏中我们显示涡度，在右边显示速度场。
* [2.x.98]
* 这些图像很好地显示了障碍物后面的涡流链的发展和延伸，涡度的符号表明这是一个左转或右转的涡流。
*

* [1.x.148][1.x.149][1.x.150] 。


* 我们可以将参数文件中的雷诺数[2.x.99]改为[2.x.100]。这样做，并在一定程度上减少时间步长，在[2.x.101]时产生以下图像。
* [2.x.102]
* 对于这个较大的雷诺数，我们观察到不符合物理规律的振荡，特别是涡度的振荡。这些现象是典型的离散化方案，它们在未充分解决的情况下缺乏稳健性，其中未充分解决意味着用网格尺寸而不是几何体的物理尺寸计算的雷诺数很大。我们看一下放大的障碍物后面的区域，以及那里的网格尺寸。
*

* [2.x.103]
* 我们可以通过在参数文件中多设置一个mesh细化来重新运行模拟，从而轻松地测试我们的假设。
* [2.x.104]
* 事实上，现在的涡度场看起来更加平滑。虽然我们可以预期进一步细化网格也会抑制剩余的振荡，但我们应该采取措施在粗解的限制下获得一个强大的方案，如下所述。
*

* [1.x.151][1.x.152][1.x.153] 。


* 本程序可向以下方向扩展。[2.x.105] [2.x.106] 自适应网格细化。正如我们所看到的，我们在一个单一的固定网格上计算了所有的东西。  使用自适应网格细化可以提高精度，同时不明显增加计算时间。
* [2.x.107] 自适应时间步进。虽然目前显然没有关于可变时间步长的投影方法的理论，但实践表明，它们的表现非常好。
* [2.x.108] 高雷诺%数。正如我们从结果中看到的，增加雷诺数会显著改变离散化方案的行为。使用众所周知的稳定技术，我们可以计算这个问题或许多其他问题中的流动，当雷诺数非常大，计算成本要求空间分辨率，而流动只能得到有限的解决，特别是对于三维湍流。
* [2.x.109] 可变密度的不可压缩流。对于密度可变的不可压缩流的情况，有类似投影的方法。如果不同密度的流体混合，例如淡水和盐水，或者酒精和水，这种流动就会发挥作用。
* [2.x.110] 可压缩纳维-斯托克斯方程。这些方程适用于以下情况：速度高到足以使流体变得可压缩，但还没有快到我们进入一个粘度变得可以忽略不计的制度，纳维-斯托克斯方程需要被气体动力学的双曲欧拉方程所取代。如果速度超过音速的三分之一，可压缩性就开始成为一个因素，所以它对几乎所有的地面交通工具来说都不是一个因素。另一方面，商业喷气式飞机的飞行速度约为音速的85%，机翼上的流动变得明显超音速，在这种情况下，可压缩的纳维尔-斯托克斯方程也不再适用。然而，在这两者之间的范围内有重要的应用，如小型飞机或许多欧洲和东亚国家的快速列车。[2.x.111]
*

* [1.x.154][1.x.155] [2.x.112] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-36_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19]
* [2.x.2]
* [1.x.20]
* [1.x.21][1.x.22][1.x.23] 。


* 在这个例子中，我们要解决的问题是一个特征值问题（eigenspectrumproblem）。特征值问题出现在许多问题中，例如，在计算电磁驻波的空腔、鼓膜的振动模式或湖泊和河口的振荡时。最神秘的应用之一可能是量子力学中静止或准静止波函数的计算。后一种应用是我们想在这里研究的，尽管本计划中概述的一般技术当然同样适用于上述其他应用。
* Eigenspectrum问题有一般的形式
* [1.x.24]
* 其中[2.x.3]上的Dirichlet边界条件也可以由Neumann或Robin条件取代；[2.x.4]是一个算子，一般也包含微分算子。
* 在适当的条件下，上述方程有一组解[2.x.5]、[2.x.6]，其中[2.x.7]可以是一个有限的或无限的集合（在后一种情况下，它可能是一个离散的或有时至少部分是连续的集合）。无论哪种情况，我们都要注意，我们要计算的不再是一个单一的解，而是一组解（变量特征函数和相应的特征值）。从数字上寻找这种特征值问题的所有特征值（特征函数）是一个艰巨的挑战。事实上，如果集合[2.x.8]是无限的，这个挑战当然是难以解决的。  然而，大多数时候，我们真正感兴趣的只是这些数值（函数）中的一小部分；幸运的是，我们在本教程中使用的SLEPc库的接口允许我们选择特征谱的哪一部分和我们想要解决的多少个解决方案。
* 在这个程序中，我们使用的重谱求解器是由deal.II提供的类，围绕[1.x.25]库的线性代数实现；SLEPc本身建立在[1.x.26]库的线性代数内容上。
* [1.x.27][1.x.28][1.x.29] 。
*

* 静态量子力学的基本方程是薛定谔方程，它模拟粒子在外部势中的运动 [2.x.9] 。粒子由一个波函数[2.x.10]描述，该波函数满足（非维度化）形式的关系
* [1.x.30]
* 因此，这个粒子只能存在于一定数量的特征态中，这些特征态对应于作为该方程解的能量特征值[2.x.11]。量子力学的正统（哥本哈根）解释认为，如果粒子具有能量[2.x.12]，那么在位置[2.x.13]发现它的概率与[2.x.14]成正比，其中[2.x.15]是对应于这个特征值的特征函数。
* 为了在数值上找到这个方程的解，即一组成对的特征值/特征函数，我们使用通常的有限元方法，将方程从左边乘以测试函数，通过部分积分，在有限维空间中通过近似[2.x.16]寻找解，其中[2.x.17]是一个扩展系数的矢量。然后我们立即得出以下方程，该方程离散化了连续特征值问题：[1.x.31]用矩阵和矢量符号表示，该方程为。[1.x.32] 其中[2.x.18]是由微分算子[2.x.19]产生的刚度矩阵，而[2.x.20]是质量矩阵。特征值问题的解决方案是一个新谱系[2.x.21]，以及相关的特征函数[2.x.22] 。
*

*[1.x.33][1.x.34]


* 在这个程序中，我们对波函数[2.x.23]使用迪里切特边界条件。从有限元代码的角度来看，这意味着只有内部自由度是[1.x.35]的真实度：边界上的自由度不是自由的，但毕竟是被迫为零的。另一方面，无限元方法的强大和简单在于，我们只需在每个单元上做同样的事情，而不必过多考虑一个单元的位置，它是否与一个不那么精细的单元相接，因而有一个悬空的节点，或者与边界相接。所有这些检查都会使有限元线性系统的组装变得难以编写，甚至更难阅读。
* 当然，当你用DoFHandler对象分配自由度时，你并不关心你列举的一些自由度是否在迪里切特边界。它们都有数字。我们只需要在以后应用边界值的时候照顾到这些自由度。有两种基本的方法（要么使用[2.x.24][1.x.36]装配线性系统，要么使用[2.x.25][1.x.37]装配；详见[2.x.26]"约束模块"），但两者的结果是一样的：线性系统的总行数等于[1.x.38]自由度的数目，包括那些位于边界的自由度。然而，受迪里希特条件约束的自由度与线性系统的其他部分分开，方法是将相应的行和列清零，在对角线上放一个正条目，并在右手边放相应的迪里希特值。
* 如果你暂时假设我们对自由度进行了重新编号，使迪里切特边界上的所有自由度都排在最后，那么在解一个有右手边的常规PDE时，我们会得到这样的线性系统。
* [1.x.39]
* 这里，下标[2.x.27]和[2.x.28]分别对应于内部和边界自由度。内部自由度满足线性系统[2.x.29]，在内部产生正确的解决方案，边界值由[2.x.30]决定，其中[2.x.31]是一个对角线矩阵，由消除边界自由度的过程产生，[2.x.32]的选择方式是，[2.x.33对于每个边界自由度[2.x.34]都有正确的边界值（对于好奇的人来说，矩阵[2.x.35]的条目是将修改后的局部贡献添加到全局矩阵中的结果，对于局部矩阵来说，对角线元素如果不是零，则被设置为其绝对值；否则，它们被设置为对角线绝对值的平均值。这个过程保证了[2.x.36]的条目是正的，而且大小与对角线的其他条目相当，确保所产生的矩阵不会因为涉及到大小截然不同的矩阵条目的舍入而造成不合理的精度损失。最终出现在对角线上的实际数值是很难预测的，你应该把它们当作任意的和不可预测的，但却是正数。)
* 对于 "常规 "线性系统，这一切都导致了正确的解决方案。另一方面，对于特征值问题，这就不是那么简单了。
* [1.x.40]
* 这种形式清楚地表明，有两组特征值：我们关心的那些，以及来自这些分割问题的虚假特征值[1.x.41]这些特征值是虚假的，因为它们是由一个只对边界节点进行操作的特征值系统产生的。
*
* 当然，由于两个矩阵[2.x.39]是对角线，我们可以准确地量化这些虚假的特征值：它们是[2.x.40]（其中指数[2.x.41]完全对应于受迪里切特边界值约束的自由度）。
* 那么，如何处理这些问题呢？第一部分是识别我们的特征值求解器何时发现其中一个。为此，程序通过计算所有受限自由度的表达式[2.x.42]的最小值和最大值，计算并打印出这些特征值所在的区间。在下面的程序中，这已经足够了：我们发现这个区间位于我们感兴趣并计算的最小特征值和相应的特征函数的集合之外，所以这里我们不需要做什么。
* 另一方面，我们可能会发现，我们在这个程序中计算的一个特征值恰好在这个区间内，在这种情况下，我们不会立即知道它是一个假的还是一个真的特征值。在这种情况下，我们可以在计算完两个矩阵后，简单地缩放两个矩阵的对角线元素，从而使它们远离特征谱中的感兴趣的频率。这可以通过使用以下代码来完成，确保所有假特征值都正好等于[2.x.43] 。
* [1.x.43]
* 然而，这里没有采用这种策略，因为我们从程序中得到的虚假特征值恰好大于我们要计算的和感兴趣的最低的五个。
*

*[1.x.44][1.x.45]


* 下面的程序实质上只是[2.x.44]的一个稍加修改的版本。不同的地方有以下几点。
* [2.x.45]
* [2.x.46] 主类（名为[2.x.47]）现在不再有单一的解向量，而是有一整套我们要计算的各种特征函数的向量。此外，[2.x.48]函数，在这里拥有最高级别的控制权，通过[2.x.49]和[2.x.50]同时初始化和最终确定SLEPc和PETSc的接口。[2.x.51]
* [2.x.52] 我们使用PETSc的矩阵和向量，如[2.x.53]和[2.x.54]，因为那是SLEPc特征值求解器所要求的。[2.x.55]
* [2.x.56] 函数[2.x.57]与本教程中迄今所见的任何函数都完全不同，因为它不只是求解线性系统，而是实际求解特征值问题。它建立在SLEPc库上，而且更直接地建立在类[2.x.58]中的deal.IISLEPc包装器上。
* [2.x.59] 我们使用ParameterHandler类来描述一些输入参数，如势的确切形式[2.x.60] ，网格的全局细化步数，或我们要解决的特征值数量。我们可以在这方面做得更多，但也只能将一些在运行时可以选择的东西变成实际的输入文件参数。为了了解在这方面可以做什么，请看 [2.x.61] " [2.x.62] " 和 [2.x.63] 。[2.x.64]
* [2.x.65] 我们使用FunctionParser类，使潜在的 [2.x.66] 成为运行时参数，可以在输入文件中指定为公式。[2.x.67]
* [2.x.68]
* 程序的其余部分以一种相当直接的方式从[2.x.69]开始。
*

* [1.x.46] [1.x.47]。
* [1.x.48][1.x.49] 。
*


* 正如在介绍中提到的，本程序基本上只是[2.x.70]的一个小修改版本。因此，以下大多数include文件都是在那里使用的，或者至少是在以前的教程程序中已经使用的。
*


* [1.x.50]
*
* IndexSet用于设置每个 [2.x.71] 的大小。
*


* [1.x.51]
*
* PETSc出现在这里是因为SLEPc依赖于这个库。
*


* [1.x.52]
*
* 然后我们需要实际导入SLEPc提供的求解器的接口。
*


* [1.x.53]
*
* 我们还需要一些标准的C++。
*


* [1.x.54]
*
* 最后，和以前的程序一样，我们将所有的deal.II类和函数名导入到这个程序中的所有东西都将进入的名字空间。
*


* [1.x.55]
*
* [1.x.56] [1.x.57]。


*
* 以下是主类模板的类声明。它看起来和在 [2.x.72] 中已经展示过的差不多了。
*


* [1.x.58]
*
* 有了这些例外情况。对于我们的特征值问题，我们既需要左手边的刚度矩阵，也需要右手边的质量矩阵。我们还需要的不仅仅是一个解函数，而是一整套用于我们要计算的特征函数的解函数，以及相应的特征值。
*


* [1.x.59]
*
* 然后我们需要一个对象来存储几个运行时参数，我们将在输入文件中指定。
*


* [1.x.60]

* 最后，我们将有一个包含对我们自由度的 "约束 "的对象。如果我们有自适应细化的网格（在目前的程序中我们没有），这可能包括悬挂节点的约束。在这里，我们将存储边界节点的约束 [2.x.73] 。
*


* [1.x.61]
*
* [1.x.62] [1.x.63]。



* [1.x.64] [1.x.65]。


*
* 首先是构造函数。主要的新部分是处理运行时的输入参数。我们需要首先声明它们的存在，然后从输入文件中读取它们的值，该文件的名称被指定为该函数的参数。
*


* [1.x.66]
*
* TODO调查为什么获得正确的特征值退化所需的最小细化步骤数为6
*


* [1.x.67]
*
* [1.x.68] [1.x.69]。


*
* 下一个函数在域[2.x.74]上创建一个网格，根据输入文件的要求对其进行多次细化，然后给它附加一个DoFHandler，并将矩阵和向量初始化为正确的大小。我们还建立了对应于边界值的约束条件 [2.x.75] 。   
* 对于矩阵，我们使用PETSc包装器。这些包装器能够在非零项被添加时根据需要分配内存。这似乎是低效的：我们可以先计算稀疏模式，用它来初始化矩阵，然后在我们插入条目时，我们可以确定我们不需要重新分配内存和释放之前使用的内存。一种方法是使用这样的代码。  [2.x.76]，而不是下面两个[2.x.77]的刚度和质量矩阵的调用。   
* 不幸的是，这并不完全可行。上面的代码可能会导致在非零模式下的一些条目，我们只写零条目；最值得注意的是，对于那些属于边界节点的行和列的非对角线条目，这一点是成立的。这不应该是一个问题，但是不管什么原因，PETSc的ILU预处理程序（我们用来解决特征值求解器中的线性系统）不喜欢这些额外的条目，并以错误信息中止。   
* 在没有任何明显的方法来避免这种情况的情况下，我们干脆选择了第二种最佳方案，即让PETSc在必要时分配内存。也就是说，由于这不是一个时间上的关键部分，这整个事件就不再重要了。
*


* [1.x.71]

* 下一步是处理特征谱的问题。在这种情况下，输出是特征值和特征函数，所以我们把特征函数和特征值列表的大小设置为我们在输入文件中要求的那样大。当使用[2.x.78]时，Vector是使用IndexSet初始化的。IndexSet不仅用于调整[2.x.79]的大小，而且还将[2.x.80]中的一个索引与一个自由度联系起来（更详细的解释见[2.x.81]）。函数complete_index_set()创建了一个IndexSet，每个有效的索引都是这个集合的一部分。请注意，这个程序只能按顺序运行，如果并行使用，将抛出一个异常。
*


* [1.x.72]
*
* [1.x.73] [1.x.74]。


*
* 在这里，我们分别从局部贡献[2.x.82]和[2.x.83]中组合出全局刚度和质量矩阵。如果你看过以前的教程程序，这个函数应该会很熟悉。唯一新的东西是使用我们从输入文件得到的表达式设置一个描述势[2.x.84]的对象。然后我们需要在每个单元的正交点上评估这个对象。如果你见过如何评估函数对象（例如，见[2.x.85]中的系数），这里的代码也会看起来相当熟悉。
*


* [1.x.75]
*
* 现在我们有了局部的矩阵贡献，我们把它们转移到全局对象中，并照顾到零边界约束。
*


* [1.x.76]
*
* 在这个函数的结尾，我们告诉PETSc，矩阵现在已经被完全组装好了，稀疏矩阵表示法现在可以被压缩了，因为不会再增加任何条目。
*


* [1.x.77]
*
* 在离开函数之前，我们计算虚假的特征值，这些特征值是由零迪里切特约束条件引入系统的。正如在介绍中所讨论的，使用Dirichlet边界条件，加上位于域的边界的自由度仍然是我们所求解的线性系统的一部分，引入了一些虚假的特征值。下面，我们输出它们所处的区间，以确保我们在计算中出现时可以忽略它们。
*


* [1.x.78]
*
* [1.x.79] [1.x.80]。


*
* 这是该程序的关键新功能。现在系统已经设置好了，现在是实际解决问题的好时机：和其他例子一样，这是通过 "求解 "例程完成的。从本质上讲，它的工作原理与其他程序一样：你设置一个SolverControl对象，描述我们要解决的线性系统的精度，然后我们选择我们想要的解算器类型。在这里，我们选择SLEPc的Krylov-Schur求解器，对于这种问题来说，这是一个相当快速和强大的选择。
*


* [1.x.81]
*
* 我们从这里开始，就像我们通常做的那样，指定我们想要的收敛控制。
*


* [1.x.82]
*
*在我们实际求解特征函数和
*
在我们实际求解特征函数和 * - 路径之前，我们还必须选择哪一组特征值来求解。让我们选择那些实部最小的特征值和相应的特征函数（事实上，我们在这里解决的问题是对称的，所以特征值是纯实部的）。之后，我们就可以真正让SLEPc做它的工作了。
*


* [1.x.83]
*
* 上述调用的输出是一组向量和数值。在特征值问题中，特征函数只确定到一个常数，这个常数可以很随意地固定。由于对特征值问题的原点一无所知，SLEPc除了将特征向量归一到[2.x.86]（向量）准则外，没有其他选择。不幸的是，这个规范与我们从特征函数角度可能感兴趣的任何规范没有什么关系：[2.x.87]规范，或者可能是[2.x.88]规范。     
*让我们选择后者，重新划分特征函数的尺度，使其具有[2.x.89]而不是[2.x.90]（其中[2.x.91]是[2.x.92]第三个特征[1.x.84]，[2.x.93]是相应的结点值矢量）。对于这里选择的[2.x.94]元素，我们知道函数[2.x.95]的最大值是在其中一个节点上达到的，所以[2.x.96]，使得在[2.x.97]准则下的归一化是很简单的。请注意，如果我们选择[2.x.98]元素与[2.x.99]，这就不那么容易了：在那里，函数的最大值不一定要在一个节点上达到，所以[2.x.100]（尽管平等通常几乎是真的）。
*


* [1.x.85]
*
* 最后返回收敛所需的迭代次数。
*


* [1.x.86]
*
* [1.x.87] [1.x.88]。



* 这是本程序的最后一个重要功能。它使用DataOut类来生成特征函数的图形输出，以便日后进行可视化。它的工作原理与其他许多教程中的一样。   
* 整个函数的集合被输出为一个单一的VTK文件。
*


* [1.x.89]
*
* 唯一值得讨论的可能是，由于势在输入文件中被指定为一个函数表达式，如果能把它和特征函数一起作为图形表示就更好了。实现这一目的的过程相对简单：我们建立一个代表[2.x.101]的对象，然后将这个连续函数插值到有限元空间。其结果我们也附加到DataOut对象上，以便于可视化。
*


* [1.x.90]
*
* [1.x.91] [1.x.92]。


*
* 这是一个对一切都有顶层控制的函数。它几乎与 [2.x.102] 中的内容完全相同。
*


* [1.x.93]
*
* [1.x.94] [1.x.95]。



* [1.x.96]
*
* 这个程序只能在串行中运行。否则，抛出一个异常。
*


* [1.x.97]
*
* 同时，我们也在注意是否有任何异常应该被生成。如果是这样的话，我们就会惊慌失措...
*


* [1.x.98]
*
* 如果没有抛出异常，那么我们就告诉程序不要再胡闹了，乖乖地退出。
*


* [1.x.99]
*[1.x.100][1.x.101]


*[1.x.102][1.x.103] 。


* 该问题的输入由一个输入文件[2.x.103]作为参数，例如，该文件可以包含以下文本。
* [1.x.104]
*
* 这里，域内的势是零，我们知道特征值由 [2.x.104] 给出，其中 [2.x.105] 。特征函数是正弦和余弦，在[2.x.106]和[2.x.107]方向有[2.x.108]和[2.x.109]的周期。这与我们的程序产生的输出相匹配。
* [1.x.105] 这些特征值正是对应于[2.x.110]、[2.x.111]和[2.x.112]、[2.x.113]和[2.x.114]等对。相应的特征方程的可视化会像这样。
* [2.x.115]
*[1.x.106][1.x.107]。


* 在操场上玩几个游戏总是值得的!因此，这里有几个建议。
* [2.x.116]
* [2.x.117] 上面使用的势（称为[1.x.108]，因为它是一个由无限高的墙包围的平坦势）是有趣的，因为它允许有分析性的已知解。然而，除此之外，它是相当无聊的。也就是说，只要在输入文件中设置不同的势，就可以很容易地玩转这个势。例如，让我们假设我们想在2d中处理以下电势：[1.x.109]换句话说，该电势为
*
* - 00在半径为0.75的圆的两个扇形中。
*
在另外两个扇形区域内为* - ，而在圆外为零。我们可以通过在输入文件中使用以下内容来实现这一点。
* [1.x.110]
* 此外，如果我们还将网格细化程度提高一级，我们将得到以下结果。
* [1.x.111]
*
* 输出文件还包含一个内插的势的版本，看起来像这样（注意，正如预期的那样，最低的几个特征模式的概率密度[2.x.118]只有在势最低的地方才有意义，即在势的内圆的右上角和左下角部分）。
* [2.x.119]
* 前五个特征函数现在是这样的。
* [2.x.120]
* [2.x.121] 在我们对问题的推导中，我们假设粒子被限制在一个域[2.x.122]中，并且在这个域的边界，其存在的概率[2.x.123]为零。这相当于解决所有[2.x.124]的特征值问题，并假设能量势只在一个区域[2.x.125]内是有限的，而在外面是无限的。相对来说，可以证明[2.x.126]在[2.x.127]的所有位置上，[2.x.128] 。那么问题来了，如果我们的势不是这种形式的，也就是说，没有一个势是无限的有界域，会发生什么？在这种情况下，可能值得考虑在边界上有一个非常大的域，其中[2.x.129]即使不是无限的，也至少是非常大的。玩玩这样的几个案例，探索一下当我们把计算区域越做越大时，频谱和特征函数是如何变化的。
* [2.x.130] 如果我们研究简单的谐波振荡器问题[2.x.131]会怎样？这个势正是上一段所讨论的形式，具有超球面对称性。人们可能想用一个大的外半径的球面域来近似整个空间问题（例如，通过调用[2.x.132]
* [2.x.133] 上面的图显示了波函数[2.x.134]，但感兴趣的物理量实际上是粒子在位置[2.x.136]的概率密度[2.x.135]。 一些可视化程序可以从输入文件中的数据计算出衍生量，但我们也可以在创建输出文件时立即这样做。做到这一点的工具是DataPostprocessor类，可以和DataOut类一起使用。如何做到这一点的例子可以在 [2.x.137] 和 [2.x.138] 中找到。
* [2.x.139] 如果盒子里的粒子有%的内部自由度会怎样？例如，如果该粒子是一个自旋[2.x.140]粒子？在这种情况下，我们可能要开始解决一个矢量值的问题，而不是。
* 我们在这里对deal.II库的实现使用了PETScWrappers和SLEPcWrappers，适用于在串行机器结构上运行。然而，对于更大的网格和大量的自由度，我们可能希望在并行架构上运行我们的应用程序。上述编解码器的并行实现在这里特别有用，因为广义谱系问题的解决比前面大多数教程中所考虑的标准问题要昂贵一些。幸运的是，修改上述程序使其符合MPI标准是一个相对简单的过程。关于如何做到这一点，可以在[2.x.142] " [2.x.143] " 中找到。
* 最后，还有一些使用SLEPc特征值求解器的替代方法。deal.II有与其中之一ARPACK（见[1.x.112]中的设置说明）的接口，在ArpackSolver类中实现。下面是一个简短的概述，说明使用它需要改变什么，前提是你有一个有效的ARPACK安装，并且deal.II已经为它进行了正确的配置（见deal.II [1.x.113]文件）。
* 首先，为了使用ARPACK接口，我们可以回到使用标准的deal.II矩阵和向量，所以我们开始替换PETSc和SLEPcheaders
* [1.x.114]
* 用这些来代替。
* [1.x.115]
* ARPACK允许复杂的特征值，所以我们还需要
* [1.x.116]
*
* 其次，我们换回main类中的deal.II矩阵和向量定义。
* [1.x.117]
* 并像往常一样在[2.x.145]中初始化它们。
* [1.x.118]
*
* 为了用ARPACK解决特征值问题，我们最后需要修改[2.x.146] 。
* [1.x.119]
* 请注意我们是如何使用精确分解（使用SparseDirectUMFPACK）作为ARPACK的去调节器的。[2.x.147]
*

*[1.x.120][1.x.121] [2.x.148]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-37_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31]
* [2.x.3]
* [1.x.32][1.x.33] 。
* [1.x.34][1.x.35][1.x.36] 。


* 这个例子展示了如何实现一个无矩阵方法，即一个不明确存储矩阵元素的方法，用于处理超立方体上系数可变的二阶Poissonequation。这个线性系统将用多网格方法来解决，并使用MPI的大规模并行性。
* 无矩阵方法的主要动机是，在今天的处理器上，对主内存的访问（即对不适合缓存的对象）已成为许多偏微分方程求解器的瓶颈。为了执行基于矩阵的矩阵-向量乘积，现代CPU花在等待数据从内存到达的时间远远多于实际进行浮点乘法和加法的时间。因此，如果我们可以通过重新计算矩阵元素，或者更确切地说，通过这些条目所代表的运算符，来替代在内存中查找矩阵元素，我们可能会在整体运行时间方面获胜，即使这需要大量额外的浮点运算。也就是说，用一个微不足道的实现来实现这一点是不够的，我们需要真正关注细节来获得性能。这个教程程序和上面提到的论文展示了如何实现这样一个方案，并展示了可以获得的速度提升。
*

*[1.x.37][1.x.38]


* 在这个例子中，我们考虑泊松问题[1.x.39]，其中[2.x.4]是一个可变系数。下面，我们解释如何为这个问题实现矩阵-向量乘积，而不明确形成矩阵。当然，对于其他方程也可以用类似的方法进行构造。
* 我们选择[2.x.5]和[2.x.6]作为域。由于系数是围绕原点对称的，但域却不是，我们最终会得到一个非对称的解决方案。
*

*[1.x.40][1.x.41]


*为了找出我们如何编写一个执行矩阵-向量乘积的代码，但不需要存储矩阵元素，让我们先看看一个有限元矩阵[1.x.42]是如何组装的：[1.x.43] 。
* 在这个公式中，矩阵[1.x.44]<sub>cell,loc-glob</sub>是一个矩形矩阵，定义了从当前单元的局部自由度到全局自由度的索引映射。可以建立这个运算器的信息通常被编码在[2.x.7]变量中，并被用于交易二中的汇编调用填充矩阵。这里，[1.x.45]<sub>cell</sub>表示与[1.x.46]相关的单元矩阵。
* 如果我们要进行矩阵-向量乘积，我们可以因此使用[1.x.47]。
*其中[1.x.48]<sub>cell</sub>是[1.x.49]在各单元自由度上的值，[1.x.50]<sub>cell</sub>=[1.x.51]<sub>cell</sub>[1.x.52]<sub>cell</sub>相应地得到结果。因此一个天真的尝试来实现拉普拉斯的局部作用将使用以下代码。
* [1.x.53]
*
* 这里我们忽略了边界条件以及我们可能拥有的任何悬空节点，尽管使用AffineConstraints类来包括这两者都不是很困难。请注意，我们首先以常规方式生成局部矩阵，作为每个局部矩阵条目在所有正交点上的总和。为了形成上述公式中表达的实际乘积，我们提取了单元格相关自由度的[2.x.8]的值（[1.x.54]的作用]<sub>cell,loc-glob</sub>的作用），乘以局部矩阵（[1.x.55]<sub>cell</sub>的作用），最后将结果加到目的地向量[2.x.9]（[1.x.56]<sub>cell,loc-glob</sub><sup>T</sup>的作用，在所有元素上加起来）。原则上，这不会比这更难。
* 虽然这个代码是完全正确的，但它非常慢。对于每个单元，我们生成一个局部矩阵，这需要三个嵌套的循环，循环长度等于局部自由度的数量来计算。乘法本身是由两个嵌套循环完成的，这意味着它要便宜得多。
* 改善这个问题的一个方法是，从概念上讲，局部矩阵可以被认为是三个矩阵的乘积，[1.x.57] 。
* 在拉普拉斯算子的例子中，[1.x.58]*dim+[1.x.59])-[1.x.60]<sub>cell</sub>的元素是由[2.x.10]给出。这个矩阵由[2.x.11]行和[2.x.12]列组成。矩阵[1.x.61]<sub>cell</sub>是对角线，包含[2.x.13]的值（或者说，[2.x.14]这些值的二进制副本）。在工程文献中经常可以看到这种关于无限元素矩阵的表述。
* 当单元格矩阵被应用于一个矢量时，[1.x.62]。
* 那么，我们就不会形成矩阵与矩阵的乘积，而是每次将一个矩阵与一个向量从右到左相乘，这样就只形成三个连续的矩阵-向量乘积。这种方法消除了局部矩阵计算中的嵌套循环，从而将一个单元的工作复杂度从类似[2.x.15]降低到[2.x.16] 。对这一算法的解释是，我们首先将局部DoF上的值向量转换为正交点上的梯度向量。在第二个循环中，我们将这些梯度乘以积分权重和系数。第三次循环应用第二个梯度（转置形式），这样我们就得到了单元斗室上的（拉普拉斯）值矢量。
* 上述代码的瓶颈是对每一个[2.x.18]调用[2.x.17]所做的操作，其花费的时间与其他步骤加起来差不多（至少如果网格是非结构化的；deal.II可以识别梯度在结构化的网格上往往是不变的）。这当然不理想，我们希望能做得更好。该函数所做的是计算实空间的梯度，通过使用从实空间到参考单元的变形的Jacobian来转换参考单元上的梯度。这是对单元上的每个基函数和每个正交点进行的。雅各布系数并不取决于基函数，但它在不同的正交点上一般是不同的。如果你只建立一次矩阵，就像我们在之前的所有教程中所做的那样，没有什么需要优化的，因为[2.x.19]需要在每个单元上调用。在这个过程中，转换是在计算本地矩阵元素时应用的。
* 然而，在一个无矩阵的实现中，我们会经常计算这些积分，因为迭代求解器在求解过程中会多次应用矩阵。因此，我们需要考虑是否能够缓存一些在运算器应用中被重用的数据，也就是积分计算。另一方面，我们意识到，我们不能缓存太多的数据，否则我们又会回到内存访问成为主导因素的情况。因此，我们不会在矩阵[1.x.63]中存储转换后的梯度，因为一般来说，对于曲线网格的每个基函数和每个元素上的每个正交点，它们都是不同的。
* 诀窍是去掉雅各布变换的因素，首先只在参考单元上应用梯度。这个操作将局部道夫上的数值矢量插值为正交点上的（单位坐标）梯度矢量。在这里，我们首先应用我们从梯度中分解出来的Jacobian，然后应用正交的权重，最后应用转置的Jacobian来准备第三个循环，通过单元格上的梯度来测试，并对正交点求和。
* 让我们再次以矩阵的形式来写。让矩阵[1.x.64]<sub>cell</sub>表示与单元格相关的梯度矩阵，每一行都包含正交点的值。它由矩阵与矩阵的乘积构成[1.x.65]，其中[1.x.66]<sub>ref_cell</sub>表示参考单元的梯度，[1.x.67]<sup>-T</sup><sub>cell</sub>表示从单元到实数单元转换的反转置Jacobian（在转换语言中，由[1.x.68]<sup>-T</sup><sub>cell</sub>代表的操作为变数转换）。[1.x.69]<sup>-T</sup><sub>cell</sub>是块对角线的，块的大小等于问题的维度。每个对角线块都是雅各布变换，从定义单元到实际单元。
* 把事情放在一起，我们发现[1.x.70]。
* 所以我们计算积（从右边开始计算局部积）[1.x.71] 。
*
* [1.x.72]
*
* 注意我们是如何为参考单元格梯度创建一个额外的FEValues对象，以及如何将其初始化为参考单元格的。然后，实际的衍生数据由反转的雅各布矩阵来应用（deal.II将雅各布矩阵从实心单元到单位单元称为inverse_jacobian，因为前向转换是由单位单元到实心单元）。因子[2.x.20]是块对角线超过正交的。在这种形式下，人们意识到可变系数（可能通过张量表示）和一般的网格拓扑结构与雅各布变换对单元格导数的系数变换有类似的影响。
* 在这一点上，人们可能会想，为什么我们要分别存储矩阵[2.x.21]和系数，而不是只存储完整的系数[2.x.22]。后者将使用更少的内存，因为张量是对称的，在三维中具有六个独立的值，而对于前者，我们需要九个条目用于反转雅各布，一个用于正交权重和雅各布行列式，一个用于系数，总共是11个双数。原因是前者允许通过一个通用的缓存数据框架来实现通用的微分算子，而后者则专门存储拉普拉斯的系数。如果应用需要的话，这种特殊化可能会带来回报，值得考虑。请注意，deal.II的实现足够聪明，可以检测出笛卡尔或仿生几何，在这种情况下，Jacobian在整个单元中是恒定的，不需要为每个单元存储（实际上在不同的单元中也经常是一样的）。
* 从操作数的角度来看，最后一个最关键的优化是利用基函数中的张量积结构。这是可能的，因为我们将梯度从[1.x.73]<sub>ref_cell</sub>描述的关系单元操作中剔除，即在关系单元的完全规则数据域上进行插值操作。我们举例说明在两个空间维度上降低复杂度的过程，但是同样的技术也可以用于更高的维度。在该单元上，基函数为张量积形式 [2.x.23] 。矩阵[1.x.74]<sub>ref_cell</sub>计算第一分量的部分具有[2.x.24]的形式，其中[1.x.75]<sub>grad,x</sub>和[1.x.76]<sub>val,y</sub>包含对所有一维正交点上所有一维基函数的评估。用含有基函数[2.x.25]所属系数的[1.x.78]组成矩阵[1.x.77]，我们得到[2.x.26]。这将计算这个乘积的复杂性从[2.x.27]降低到[2.x.28]，其中[1.x.79]-1是有限元的度数（即，相当于，[1.x.80]是每个坐标方向上的形状函数的数量），或者一般来说[2.x.29] 到[2.x.30]。我们之所以用多项式度数来看复杂度，是因为我们希望能够达到高度，并可能增加多项式度数[1.x.81]而不是网格分辨率。像这里所用的中等度数的好算法是独立于维度的多项式度数的线性算法，而不是基于矩阵的方案或通过FEValues的天真评价。在deal.II的实现中使用的技术自20世纪80年代以来在谱元界已经建立起来。
* 实现一个无矩阵和基于单元的有限元算子需要与以前的教程程序中显示的通常的矩阵装配代码相比，有一些不同的程序设计。这样做的数据结构是MatrixFree类和FEEvaluation类，前者收集所有数据并对所有单元进行（并行）循环，后者利用张量积结构来评估有限元基函数。
* 本教程中显示的无矩阵的矩阵-向量乘积的实现比使用稀疏矩阵的线性元素的矩阵-向量乘积要慢，但由于张量乘积结构降低了复杂性，并且在计算过程中减少了内存转移，所以对所有高阶元素来说，速度更快。当在多核处理器上工作时，减少内存传输的影响尤其有利，因为在多核处理器上有多个处理单元共享内存的访问。在这种情况下，一个受计算约束的算法将显示出几乎完美的并行加速（除了可能通过涡轮模式改变处理器的时钟频率，取决于有多少个核心在工作），而一个受内存传输约束的算法可能无法实现类似的加速（即使当工作是完全并行的，我们可以期待完美的缩放，如在疏散矩阵-向量产品）。这种实现方式的另一个好处是，我们不必建立稀疏矩阵本身，这也可能是相当昂贵的，这取决于基础微分方程。此外，上述框架可以简单地推广到非线性运算，正如我们在[2.x.31]中展示的那样。
*

*[1.x.82][1.x.83] 。


* 以上，我们花了很大的力气来实现一个不实际存储矩阵元素的矩阵-向量积。然而，在许多用户代码中，人们想要的不仅仅是做一些矩阵-向量乘积&mdash；在求解线性系统时，人们想要尽可能少地做这些操作。理论上，我们可以使用CG方法，而不需要预处理；然而，这对拉普拉斯的效率并不高。相反，预处理是用来提高收敛速度的。不幸的是，大多数比较常用的预处理程序，如SSOR、ILU或代数多网格(AMG)不能在这里使用，因为它们的实现需要了解系统矩阵的元素。
* 一个解决方案是使用几何多网格方法，如[2.x.32]所示。它们是已知的非常快的方法，而且适合于我们的目的，因为所有的成分，包括不同网格层之间的转移，都可以用与细胞集合相关的矩阵-向量产品来表达。我们需要做的就是找到一个基于矩阵-向量乘积而不是所有矩阵条目的平滑器。一个这样的候选方法是阻尼雅可比迭代法，它需要访问矩阵对角线，但它在阻尼所有高频误差方面往往不够好。Jacobi方法的特性可以通过所谓的Chebyshev迭代进行几次改进。Chebyshev迭代是由矩阵-向量乘积的多项式表达式描述的，其中的系数可以被选择来实现某些特性，在这种情况下，可以平滑误差的高频分量，这些分量与雅可比预处理矩阵的特征值相关。在零度时，具有最佳阻尼参数的雅各布方法被检索出来，而高阶修正则用于改善平滑特性。切比雪夫平滑法在多网格中的有效性已经在文章[1.x.84][1.x.85]中得到证明。这篇文章还指出了我们在这里利用的Chebyshev平滑器的另一个优势，即它们很容易并行化，而SOR/Gauss&ndash;Seidel平滑器则依赖于替换，对于这种替换，天真的并行化工作在矩阵的对角线子块上，从而降低了效率（更多细节见例如Y. Saad, IterativeMethods for Sparse Linear Systems, SIAM, 2nd edition, 2003, chapters 11 & 12）。
* 因此，在多网格框架中的实现是很简单的。本程序中的多网格实现与[2.x.33]类似，包括aptivity。
*

*[1.x.86][1.x.87]


* FEEvaluation中用于评估的计算内核是以优化使用计算资源的方式编写的。为了达到这个目的，它们不对双倍数据类型进行操作，而是采用我们称之为VectorizedArray的东西（例如，查看[2.x.34]的转向类型，该类型是指ascal元素的VectorizedArray，以及矢量有限元素的Tensor）。矢量数组是一个双数或浮点数的短数组，其长度取决于所使用的特定计算机系统。例如，基于x86-64的系统支持流式SIMD扩展（SSE），处理器的矢量单元可以通过一条CPU指令处理两个双数（或四个单精度浮点）。较新的处理器（大约从2012年起）支持所谓的高级向量扩展（AVX），有256位操作数，可以分别使用四个双数和八个浮点数。矢量化是一个单指令/多数据（SIMD）的概念，也就是说，一条CPU指令被用来同时处理多个数据值。通常情况下，有限元程序不会明确使用矢量化，因为这个概念的好处只体现在算术密集型操作上。大部分典型的有限元工作负载的内存带宽有限（对稀疏矩阵和向量的操作），额外的计算能力是无用的。
* 在幕后，优化的BLAS包可能严重依赖矢量化。另外，优化的编译器可能会自动将涉及标准代码的循环转化为更有效的矢量化形式（deal.II在矢量更新的常规循环中使用OpenMP SIMD pragmas）。然而，数据流必须非常有规律，才能使编译器产生有效的代码。例如，受益于矢量化的原型操作的自动矢量化，即矩阵三乘法，在大多数编译器上都失败了（截至2012年初编写本教程和2016年底更新时，gcc和英特尔编译器都无法为[2.x.35]函数，甚至在更简单的情况下也不行，即矩阵边界是编译时常量而不是[2.x.36]中的运行时常量。主要原因是在最内层循环（即应用矢量化的地方）要处理的信息不一定是矢量长度的倍数，留下部分资源没有使用。此外，有可能被一起处理的数据在内存中可能不是以连续的方式布置的，或者没有对准处理器需要的地址边界。或者编译器可能无法证明在一次加载几个元素时数据阵列不会重叠。
* 在deal.II的无矩阵实现中，我们选择在最适合有限元素计算的层次上应用矢量化。单元计算通常对所有单元完全相同（除了从向量读写时使用的间接寻址中的索引），因此可以使用SIMD来一次处理几个单元。在下面的所有内容中，你可以考虑用一个向量数组来存放几个单元的数据。记住，它与空间维度和元素数量无关，例如在张量或点中。
* 请注意，矢量化取决于代码运行的CPU，以及代码是为哪种CPU编译的。为了给你的计算机生成最快的FEEvaluation内核，你应该用所谓的[1.x.88]处理器变量编译deal.II。当使用gcc编译器时，可以通过在cmake构建设置中设置变量<tt>CMAKE_CXX_FLAGS</tt>为<tt>"-march=native"</tt>来启用它（在命令行中，指定<tt>-DCMAKE_CXX_FLAGS="-march=native"</tt>，更多信息见deal.II阅读手册）。其他编译器也有类似的选项。我们在本例的run()函数中输出当前的矢量化长度。
*

*[1.x.89][1.x.90]


* 如上所述，无矩阵框架中的所有组件都可以很容易地通过MPI使用领域分解进行并行化。由于在deal.II中通过p4est（详见[2.x.37]）可以很容易地访问大规模的并行网格，而且基于单元的无矩阵评估循环[1.x.91]需要将网格分解成每个处理器上大小基本相同的块，因此编写一个使用分布式内存的并行程序所需的工作相对较少。当其他使用MPI的教程程序依赖于PETSc或Trilinos时，这个程序使用deal.II自己的并行向量设施。
* deal.II的并行向量类，[2.x.38]持有解决方案的处理器本地部分，以及ghostedDoFs的数据字段，即由远程处理器拥有的DoFs，但由当前处理器拥有的单元访问。在[2.x.39]的 "词汇表 "中，这些自由度被称为本地活动自由度。函数[2.x.40]提供了一种设置这种设计的方法。请注意，悬挂节点可以与额外的托管自由度有关，这些自由度必须包括在分布式矢量中，但不属于[2.x.41]"词汇表 "意义上的本地活动自由度。此外，分布式向量持有本地拥有但其他处理器需要的DoF的MPI元数据。这个向量类设计的一个好处是对ghostedentries的访问方式。在向量的存储方案中，数据阵列延伸到解决方案的处理器本地部分之外，有更多的向量可用于重现自由度。这为所有本地活动自由度提供了一个连续的索引范围。(注意，索引范围取决于网格的具体配置。)由于无矩阵操作可以被认为是在做性能关键的线性代数，而性能关键的代码不能把时间浪费在做MPI全局到MPI局部的索引转换上，一个MPI等级的局部索引空间的可用性是很重要的。这里访问事物的方式是直接数组访问。这是通过[2.x.42]提供的，但实际上很少需要，因为所有这些都发生在FEEvaluation的内部。
* [2.x.43]的设计与我们之前在[2.x.46]和[2.x.47]中使用的[2.x.44]和[2.x.45]数据类型类似，但由于我们不需要这些库的任何其他并行功能，我们使用deal.II的[2.x.48]类而不是在这个教程程序中链接另一个大型库。还要注意的是，PETSc和Trilinosvectors不提供对直接阵列访问的幽灵条目的细粒度控制，因为它们抽象出了必要的实现细节。
*

* [1.x.92] [1.x.93]。
*首先包括deal.II库中的必要文件。
*


* [1.x.94]
*
* 这包括有效实现无矩阵方法的数据结构，或用MatrixFree类的更通用的有限元算子。
*


* [1.x.95]
*
* 为了提高效率，在无矩阵实现中进行的操作需要在编译时了解循环长度，这些长度是由有限元的度数给出的。因此，我们收集了两个模板参数的值，可以在代码中的一个地方改变。当然，我们可以把有限元的度数作为一个运行时的参数，通过编译所有可能的度数（比如，1到6之间）的计算核，并在运行时选择合适的核。在这里，我们只是选择二阶[2.x.49]元素，并选择维度3作为标准。
*


* [1.x.96]
*
* [1.x.97] [1.x.98]。


*
* 我们为泊松问题定义了一个可变系数函数。它类似于[2.x.50]中的函数，但我们使用的是[2.x.51]的形式，而不是一个不连续的形式。这只是为了证明这种实现的可能性，而不是在物理上有什么意义。我们定义系数的方式与早期教程程序中的函数相同。有一个新的函数，即一个带有模板参数[2.x.53]的[2.x.52]方法
*


* [1.x.99]

* 这就是上面提到的新函数。评估抽象类型[2.x.54]的系数 它可能只是一个普通的双数，但它也可以是一个有点复杂的类型，我们称之为VectorizedArray。这种数据类型本质上是一个短的双数数组，正如在介绍中所讨论的那样，它可以容纳几个单元格的数据。例如，我们在这里评估的系数不是像通常那样在一个简单的点上，而是交给一个Point<dim,VectorizedArray<double>>点，在AVX的情况下，它实际上是四个点的集合。不要把VectorizedArray中的条目与点的不同坐标混淆。事实上，数据的布局是这样的：[2.x.55]返回一个VectorizedArray，它又包含了第一个点和第二个点的x坐标。你可以使用例如 [2.x.56] 单独访问坐标，j=0,1,2,3，但建议尽可能在一个VectorizedArray上定义操作，以便利用矢量操作。   
* 在函数的实现中，我们假设数字类型重载了基本的算术运算，所以我们只需照常写代码。然后，基类函数[2.x.57]是由双倍类型的模板函数计算出来的，以避免重复的代码。
*


* [1.x.100]
*
* [1.x.101] [1.x.102]。


*
* 下面这个名为[2.x.58]的类，实现了微分运算符。就所有的实际目的而言，它是一个矩阵，也就是说，你可以向它询问它的大小（成员函数 [2.x.59] ），你可以将它应用于一个矢量（[2.x.60] 函数）。当然，与实数矩阵的区别在于，这个类实际上并不存储矩阵的[1.x.103]，而只知道如何计算运算符应用于向量时的作用。   
* 描述矩阵大小、从MatrixFree对象初始化以及通过vmult()和Tvmult()方法实现矩阵-向量乘积的各种接口的基础结构，是由本类派生的[2.x.61]类提供的。这里定义的LaplaceOperator类只需要提供几个接口，即通过vmult()函数中使用的apply_add()方法来实现运算符的实际操作，以及计算底层矩阵对角线项的方法。我们需要对角线来定义多梯度平滑器。由于我们考虑的是一个具有可变系数的问题，我们进一步实现了一个可以填充系数值的方法。   
* 注意文件[2.x.62]已经包含了通过类[2.x.63]对拉普拉斯的实现。 出于教育目的，在这个教程程序中重新实现了该运算符，解释了其中的成分和概念。   
* 本程序利用了集成在deal.II中的有限元算子应用的数据缓存。这个数据缓存类被称为MatrixFree。它包含局部和全局自由度之间的映射信息（Jacobian）和索引关系。它还包含约束条件，如来自悬挂节点或迪里切特边界条件的约束。此外，它可以在所有单元上以%并行方式发出一个循环，确保只有不共享任何自由度的单元被处理（这使得循环在写入目标向量时是线程安全的）。与[2.x.64]模块中描述的WorkStream类相比，这是一个更先进的策略。当然，为了不破坏线程安全，我们在写入类全局结构时必须小心。   
* 实现拉普拉斯算子的类有三个模板参数，一个是维度（正如许多deal.II类所携带的），一个是有限元的度数（我们需要通过FEEvaluation类实现高效计算），还有一个是底层标量类型。我们希望对最终矩阵使用[2.x.65]数字（即双精度，64位浮点），但对多网格级矩阵使用浮点数（单精度，32位浮点数字）（因为那只是一个预处理程序，而浮点数的处理速度是两倍）。FEEvaluation类也需要一个模板参数，用于确定一维正交点的数量。在下面的代码中，我们把它硬编码为 [2.x.66] 。如果我们想独立于多项式程度来改变它，我们需要添加一个模板参数，就像在[2.x.67]类中做的那样。   
* 作为附带说明，如果我们在同一个网格和自由度上实现了几个不同的操作（比如质量矩阵和拉普拉斯矩阵），我们将为每个操作者定义两个像现在这样的类（源自[2.x.68]类），并让它们都引用一般问题类中的同一个MatrixFree数据缓存。通过[2.x.69]的接口要求我们只提供一组最小的函数。这个概念允许编写具有许多无矩阵操作的复杂应用代码。   
*

*
* [2.x.70] 储存[2.x.71]类型的值需要注意。在这里，我们使用deal.II表类，它准备以正确的排列方式来保存数据。然而，存储例如一个[2.x.72]是不可能用矢量的。数据与内存地址的边界需要一定的对齐（基本上，在AVX情况下，一个32字节长的VectorizedArray需要从一个能被32整除的内存地址开始）。表类（以及它所基于的AlignedVector类）确保这种对齐方式得到尊重，而[2.x.73]一般不这样做，这可能会导致一些系统在奇怪的地方出现分段故障，或者其他系统的性能不理想。
*


* [1.x.104]
*
* 这是[2.x.74]类的构造函数。它所做的就是调用基类[2.x.75]的默认构造函数，而基类又是基于Subscriptor类的，它断言这个类在超出范围后不会被访问，例如在一个预处理程序中。
*


* [1.x.105]
*
* [1.x.106] [1.x.107]。


*
* 为了初始化系数，我们直接赋予它上面定义的系数类，然后选择方法[2.x.76]与矢量数（编译器可以从点数据类型中推导出来）。下面将解释FEEvaluation类（及其模板参数）的使用。
*


* [1.x.108]
*
* [1.x.109] [1.x.110]。


*
* 这里是这个类的主要功能，矩阵-向量乘积的评估（或者，一般来说，一个有限元算子的评估）。这是在一个需要四个参数的函数中完成的，MatrixFree对象，目标和源向量，以及要处理的单元格的范围。MatrixFree类中的方法[2.x.77]将在内部用一些单元格范围来调用这个函数，这些单元格范围是通过检查哪些单元格可以同时工作来获得的，这样写操作就不会引起任何竞赛条件。请注意，循环中使用的单元格范围并不是直接指当前网格中的（活动）单元格数量，而是一个单元格批次的集合。  换句话说，"单元 "可能是一个错误的开始，因为FEEvaluation将几个单元的数据分组在一起。这意味着在正交点的循环中，我们实际上是将几个单元的正交点作为一个块来看待。这样做是为了实现更高的矢量化程度。  这种 "单元 "或 "单元批 "的数量存储在MatrixFree中，可以通过[2.x.78]查询。与deal.II单元迭代器相比，在这个类别中，所有的单元都被布置在一个普通的数组中，不直接知道水平或相邻关系，这使得通过无符号整数来索引单元成为可能。   
* 拉普拉斯运算符的实现是非常简单的。首先，我们需要创建一个对象FEEvaluation，它包含计算核，并有数据字段来存储临时结果（例如，在几个单元格集合的所有正交点上评估的梯度）。请注意，临时结果不会使用大量的内存，而且由于我们用元素顺序指定模板参数，数据被存储在堆栈中（没有昂贵的内存分配）。通常，只需要设置两个模板参数，维度作为第一个参数，有限元的度数作为第二个参数（这等于每个维度的自由度数减去FE_Q元素的一个）。然而，在这里，我们也希望能够使用浮点数来计算多网格预处理，这是最后一个（第五个）模板参数。因此，我们不能依赖默认的模板参数，因此必须填写第三和第四个字段。第三个参数指定每个方向的正交点的数量，其默认值等于元素的度数加1。第四个参数设置分量的数量（在PDEs系统中也可以评估矢量值的函数，但默认是标量元素），最后一个参数设置数字类型。   
* 接下来，我们在给定的单元格范围内循环，然后继续进行实际的实现。  [2.x.79] [2.x.80] 告诉FEEvaluation对象我们要处理的（宏）单元。   [2.x.81] 读入源向量的值（ [2.x.82] 包括约束的解析。这存储了[2.x.83]，如介绍中所述。   [2.x.84] 计算单元格梯度（有限元函数的评价）。由于FEEvaluation可以结合值计算和梯度计算，它使用一个统一的接口来处理0到2阶之间的各种导数。我们只想要梯度，不想要值，也不想要二阶导数，所以我们在梯度槽（第二槽）中将函数参数设置为真，而在值槽（第一槽）中设置为假。还有一个用于Hessian的第三槽，默认为假，所以不需要给它。请注意，FEEvaluation类在内部以一种有效的方式评估形状函数，一次只处理一个维度（如介绍中提到的使用形状函数和正交点的张量积形式）。与FEValues中使用的在所有局部自由度和正交点上循环的天真方法相比，在[2.x.87]维度上，这给出了等于[2.x.85]的多项式程度[2.x.86]的复杂度，并且花费[2.x.88] 。   [2.x.89] 接下来是雅各布变换的应用，乘以变量系数和正交权重。FEEvaluation有一个访问函数[2.x.90]，可以应用Jacobian并返回实空间中的梯度。然后，我们只需要乘以（标量）系数，并让函数[2.x.91]应用第二个雅各布式（用于测试函数）和正交权重及雅各布式行列式（JxW）。注意，提交的梯度存储在与[2.x.92]中读取梯度的地方相同的数据字段中。因此，你需要确保在调用[2.x.93]后不要再从同一正交点读取该特定正交点。一般来说，当[2.x.94]被多次使用时，复制它的结果是个好主意。   [2.x.95] 接下来是对所有测试函数的正交点进行求和，对应于实际积分步骤。对于拉普拉斯算子，我们只是乘以梯度，所以我们用各自的参数集调用积分函数。如果你有一个方程，同时用测试函数的值和梯度进行测试，那么两个模板参数都需要设置为真。先调用积分函数的值，再单独调用梯度，会导致错误的结果，因为第二次调用会在内部覆盖第一次调用的结果。请注意，积分步骤的二次导数没有函数参数。   [2.x.96] 最终，介绍中提到的向量[2.x.97]中的局部贡献需要被添加到结果向量中（并应用约束）。这是通过调用[2.x.98]来完成的，该函数与AffineConstraints中的相应函数名称相同（只是我们现在将局部向量存储在FEEvaluation对象中，正如局部和全局自由度之间的指数一样）。   [2.x.99]



* [1.x.111]
*
* 这个函数实现了[2.x.100]接口的所有单元的循环。这是通过MatrixFree类的[2.x.101]来实现的，它接受该类的operator()，参数为MatrixFree, OutVector, InVector, cell_range。当使用MPI并行化工作时（但没有线程），如本教程程序中所做的，单元格循环对应于以下三行代码。   
* [2.x.102]
* 这里，两个调用update_ghost_values()和compress()为MPI执行处理器边界上的数据交换，一次是源向量，我们需要从远程处理器拥有的条目中读取，另一次是目的向量，我们已经积累了部分残差，需要添加到所有者处理器的相应条目中。然而，[2.x.103]不仅抽象出了这两个调用，而且还进行了一些额外的优化。一方面，它将把update_ghost_values()和compress()的调用拆开，以允许通信和计算的重叠。然后用三个代表从0到[2.x.104]的单元格范围的分区来调用local_apply函数。另一方面，cell_loop也支持线程并行，在这种情况下，单元格范围被分割成更小的块，并以一种先进的方式安排，避免了几个线程对同一个向量条目的访问。这一特性在 [2.x.105] 中有解释。   
* 请注意，在单元格循环之后，受约束的自由度需要再次被触及，以获得合理的vmult()操作。由于装配循环会自动解决约束问题（就像[2.x.106]中的调用一样），它不会计算约束自由度的任何贡献，使各自的条目为零。这将表示一个矩阵的受限自由度的行和列都是空的。然而，像CG这样的迭代求解器只对非星形矩阵有效。最简单的方法是将矩阵中对应于受限自由度的子块设置为同一矩阵，在这种情况下，矩阵的应用只是将右侧向量的元素复制到左侧。幸运的是，vmult()的实现[2.x.107]在apply_add()函数之外自动为我们做了这个，所以我们不需要在这里采取进一步的行动。   
* 当使用MatrixFree和FEEvaluation的组合与MPI并行时，有一个方面需要注意&mdash；用于访问向量的索引。出于性能的考虑，MatrixFree和FEEvaluation被设计为在MPI本地索引空间中访问向量，当与多个处理器一起工作时也是如此。在本地索引空间工作意味着除了不可避免的间接寻址外，在向量访问发生的地方不需要进行索引转换。然而，本地索引空间是模糊的：虽然标准的惯例是用0和本地大小之间的索引访问向量的本地拥有的范围，但对于重影项的编号并不那么明确，而且有些随意。对于矩阵-向量乘积，只有出现在本地拥有的单元格上的指数（加上那些通过悬挂节点约束引用的指数）是必要的。然而，在deal.II中，我们经常将重影元素上的所有自由度设置为重影向量条目，称为[2.x.108]"术语表中描述的局部相关自由度"。在这种情况下，尽管指的是同一个全局索引，但在两个可能的重影集中，重影向量条目的MPI本地索引一般会有所不同。为了避免问题，FEEvaluation通过一个名为[2.x.109]的检查来检查用于矩阵-向量乘积的向量分区是否确实与MatrixFree中的索引分区相匹配。 为了方便，[2.x.110]类包括一个机制来使鬼魂集适应正确的布局。这发生在向量的ghost区域，所以请记住，在调用vmult()方法后，目标和源向量的ghost区域都可能被修改。这是合法的，因为分布式deal.II矢量的ghost区域是一个可变的部分，并按需填充。在矩阵-向量乘积中使用的向量在进入vmult()函数时不能被重影，所以没有信息丢失。
*


* [1.x.113]

* 下面的函数实现了算子的对角线的计算。计算无矩阵算子评价的矩阵项原来比评价算子更复杂。从根本上说，我们可以通过在[1.x.114]单位向量上应用算子来获得算子的矩阵表示。当然，这将是非常低效的，因为我们需要进行[1.x.115]运算符的评估来检索整个矩阵。此外，这种方法会完全忽视矩阵的稀疏性。然而，在单个单元上，这是一种方法，而且实际上效率并不低，因为单元内的所有自由度之间通常存在着耦合。   
* 我们首先将对角线向量初始化为正确的并行布局。这个向量被封装在基类[2.x.111]中DiagonalMatrix类型的一个名为inverse_diagonal_entries的成员中，这个成员是一个共享指针，我们首先需要初始化它，然后获取代表矩阵中对角线条目的向量。至于实际的对角线计算，我们再次使用MatrixFree的cell_loop基础设施来调用一个名为local_compute_diagonal()的本地工作程序。由于我们只写进一个向量，而没有任何源向量，我们用一个<tt>unsigned int</tt>类型的假参数来代替源向量，以便与cell_loop接口确认。在循环之后，我们需要将受Dirichlet边界条件约束的向量条目设置为1（要么是MatrixFree内部AffineConstraints对象描述的边界上的条目，要么是自适应多网格中不同网格层次之间的索引）。这是通过函数[2.x.112]完成的，并与Base算子提供的矩阵-向量乘积中的设置相匹配。最后，我们需要反转对角线条目，这是基于Jacobi迭代的Chebyshev平滑器所要求的形式。在循环中，我们断言所有条目都是非零的，因为它们应该从积分中获得了正的贡献，或者被约束并被[2.x.113]以下的cell_loop处理。
*


* [1.x.116]
*
* 在本地计算循环中，我们通过循环本地矩阵的所有列来计算对角线，并将条目1放在[1.x.117]的槽中，将条目0放在所有其他槽中，也就是说，我们一次在一个单位向量上应用单元微分算子。调用[2.x.114]的内部部分是对正交点的循环，而[2.x.115]则与local_apply函数完全相同。之后，我们挑选出本地结果的第[1.x.118]个条目，并将其放入一个临时存储器中（因为我们在下一次循环迭代时覆盖了[2.x.116]后面数组中的所有条目）。最后，临时存储被写到目标向量中。注意我们是如何使用[2.x.117]和[2.x.118]来读取和写入FEEvaluation用于积分的数据字段，并在另一方面写入全局向量。   
* 鉴于我们只对矩阵的对角线感兴趣，我们干脆扔掉一路走来计算过的本地矩阵的所有其他条目。虽然计算完整的单元格矩阵，然后扔掉除对角线以外的所有东西看起来很浪费，但整合的效率很高，所以计算不会花费太多的时间。请注意，对于多项式程度来说，每个元素的算子评估的复杂度是[2.x.119]，所以计算整个矩阵要花费我们[2.x.121]次操作，与用FEValues计算对角线的复杂度[2.x.122]相差不大。由于FEEvaluation也由于矢量化和其他优化而大大加快了速度，所以用这个函数计算对角线实际上是最快的（简单的）变量。(有可能用[2.x.123]操作中的和因子化技术来计算对角线，这涉及到特别适应的内核&mdash;但由于这种内核只在特定情况下有用，而对角线的计算通常不在关键路径上，所以它们没有在deal.II中实现。)   
* 请注意，在向量上调用distribution_local_to_global来将对角线条目累积到全局矩阵的代码有一些限制。对于具有悬挂节点约束的操作者来说，将一个受约束的DoF的积分贡献分配到distribution_local_to_global调用中的其他几个条目上，这里使用的向量接口并不完全计算对角线条目，而是将一些位于本地矩阵对角线上的贡献，最终在全局矩阵的对角线以外的位置上堆积起来。正如[1.x.119]中所解释的，该结果在离散化精度上是正确的，但在数学上并不平等。在这个教程程序中，不会发生任何危害，因为对角线只用于没有悬挂节点约束出现的多网格级矩阵。
*


* [1.x.120]
*
* [1.x.121] [1.x.122]。


*
* 这个类是基于 [2.x.124] 中的一个类。然而，我们用我们的无矩阵实现取代了SparseMatrix<double>类，这意味着我们也可以跳过稀疏性模式。请注意，我们定义LaplaceOperator类时，将有限元的度数作为模板参数（该值在文件的顶部定义），并且我们使用浮点数来表示多网格级矩阵。   
* 该类还有一个成员变量，用来记录在我们真正去解决问题之前设置整个数据链的所有详细时间。此外，还有一个输出流（默认情况下是禁用的），可以用来输出各个设置操作的细节，而不是默认情况下仅打印出的摘要。   
* 由于这个程序被设计成与MPI一起使用，我们也提供了通常的[2.x.125]输出流，只打印MPI等级为0的处理器的信息。这个程序使用的网格可以是基于p4est的分布式三角形（如果deal.II被配置为使用p4est），否则它就是一个只在没有MPI的情况下运行的串行网格。
*


* [1.x.123]
*
* 当我们初始化有限元时，我们当然也要使用文件顶部指定的度数（否则，在某些时候会抛出一个异常，因为在模板化的LaplaceOperator类中定义的计算内核和MatrixFree读出的有限元信息将不匹配）。三角形的构造函数需要设置一个额外的标志，告诉网格要符合顶点上的2:1单元平衡，这对于几何多网格例程的收敛是必需的。对于分布式网格，我们还需要特别启用多网格的层次结构。
*


* [1.x.124]
*
* LaplaceProblem类拥有一个额外的输出流，收集关于设置阶段的详细时间。这个流被称为time_details，默认情况下通过这里指定的[2.x.126]参数被禁用。对于详细的时间，去掉[2.x.127]参数可以打印出所有的细节。
*


* [1.x.125]
*
* [1.x.126] [1.x.127]。


*
* 设置阶段与[2.x.128]类似，由于LaplaceOperator类的存在而有相关的变化。首先要做的是设置DoFHandler，包括多网格层次的自由度，以及初始化悬挂节点的约束和同质Dirichlet条件。由于我们打算在%parallel的MPI中使用这个程序，我们需要确保约束条件能知道本地相关的自由度，否则在使用超过几亿个自由度时，存储会爆炸，见[2.x.129] 。
*

*
* 一旦我们创建了多网格dof_handler和约束条件，我们就可以为全局矩阵算子以及多网格方案的每一级调用 reinit 函数。主要的操作是为问题设置[2.x.130]实例。2.x.131]类的基类，[2.x.132]被初始化为一个指向MatrixFree对象的共享指针。这样，我们可以在这里简单地创建它，然后将它分别传递给系统矩阵和水平矩阵。为了设置MatrixFree，我们需要激活MatrixFree的AdditionalData字段中的更新标志，使其能够存储实空间中的正交点坐标（默认情况下，它只缓存梯度（反转置的雅各布）和JxW值的数据）。请注意，如果我们调用 reinit 函数而不指定级别（即给出 [2.x.133] ），MatrixFree 会在活动单元上构建一个循环。在本教程中，除了MPI之外，我们不使用线程，这就是为什么我们通过将[2.x.134]设置为[2.x.135]来明确地禁用它 最后，系数被评估，向量被初始化，如上所述。
*


* [1.x.128]
*
* 接下来，初始化所有层次上的多网格方法的矩阵。数据结构MGConstrainedDoFs保留了受边界条件约束的指数信息，以及不同细化层次之间的边缘指数，如[2.x.136]教程程序中所述。然后，我们穿过网格的各个层次，在每个层次上构建约束和矩阵。这与原始网格上的系统矩阵的构造密切相关，只是在访问各层信息而不是活动单元时，在命名上略有不同。
*


* [1.x.129]
*
* [1.x.130] [1.x.131]。


*
* 组装函数非常简单，因为我们要做的就是组装右手边的数据。多亏了FEEvaluation和所有缓存在MatrixFree类中的数据，我们从[2.x.137]中查询，这可以在几行中完成。由于这个调用没有被包装成一个[2.x.138]（这将是一个替代方案），我们一定不要忘记在装配结束时调用compress()，将右手边的所有贡献发送给各自自由度的所有者。
*


* [1.x.132]
*
* [1.x.133] [1.x.134]。


*
* 解决的过程与[2.x.139]中类似。我们先从转移的设置开始。对于[2.x.140]来说，有一个非常快速的转移类，叫做MGTransferMatrixFree，它用同样的快速和因子化核在网格层之间进行插值，这也被用于FEEvaluation。
*


* [1.x.135]
*
* 作为一个平滑器，本教程程序使用切比雪夫迭代，而不是[2.x.141]中的SOR。（SOR将很难实现，因为我们没有明确的矩阵元素，而且很难使它在%并行中有效工作）。  平滑器是用我们的水平矩阵和切比雪夫平滑器的强制性附加数据初始化的。我们在这里使用一个相对较高的度数（5），因为矩阵-向量乘积是比较便宜的。我们选择在平滑器中平滑出[2.x.142]的范围，其中[2.x.143]是最大特征值的估计值（系数1.2在PreconditionChebyshev内部应用）。为了计算该特征值，Chebyshev初始化执行了几步没有预处理的CG算法。由于最高的特征值通常是最容易找到的，而且一个粗略的估计就足够了，我们选择10次迭代。最后，我们还设置了切比雪夫方法中的内部预处理类型，这是一个雅可比迭代。这由DiagonalMatrix类来表示，该类得到了我们的LaplaceOperator类所提供的反对角线条目。     
* 在零级，我们以不同的方式初始化平滑器，因为我们想使用切比雪夫迭代作为求解器。PreconditionChebyshev允许用户切换到求解器模式，其中迭代次数在内部选择为正确值。在附加数据对象中，通过选择多项式程度为[2.x.144]来激活这一设置，然后算法将攻击粗级矩阵中最小和最大之间的所有特征值。切比雪夫平滑器的步数是这样选择的：切比雪夫收敛估计值保证将残差减少到变量[2.x.145]平滑_范围中指定的数量。注意，对于求解来说，[2.x.146]是一个相对的公差，并且选择小于1，在这种情况下，我们选择三个数量级，而当只对选定的特征值进行平滑时，它是一个大于1的数字。     
* 从计算的角度来看，只要粗粒度适中，Chebyshev迭代是一个非常有吸引力的粗粒度求解器。这是因为Chebyshev方法只执行矩阵-向量乘积和向量更新，这通常比其他迭代方法中涉及的内积更好地并行到具有几万个核心的最大集群规模。前者只涉及（粗）网格中邻居之间的局部通信，而后者则需要在所有处理器上进行全局通信。
*


* [1.x.136]
*
* 下一步是设置悬挂节点情况下所需的接口矩阵。deal.II中的自适应多网格实现了一种叫做局部平滑的方法。这意味着最细级别的平滑只覆盖固定（最细）网格级别所定义的网格的局部部分，而忽略了计算域中终端单元比该级别更粗的部分。随着该方法向更粗的级别发展，越来越多的全局网格将被覆盖。在某个更粗的层次上，整个网格将被覆盖。由于多网格方法中的所有层次矩阵都覆盖了网格中的单一层次，所以在层次矩阵上不会出现悬空节点。在多网格层之间的界面上，在平滑的同时设置同质Dirichlet边界条件。然而，当残差被转移到下一个更粗的层次时，需要考虑到多网格界面的耦合。这是由所谓的界面（或边缘）矩阵来完成的，它计算了被具有同质Dirichlet条件的层次矩阵所遗漏的残差部分。我们参考[2.x.147]"Janssen和Kanschat的多网格论文 "以了解更多细节。     
* 对于这些接口矩阵的实现，已经有一个预定义的类[2.x.148]，它将例程[2.x.149]和[2.x.150]包装在一个带有[2.x.151]vmult()和[2.x.152]操作（最初是为矩阵编写的，因此期待这些名字）的新类中。请注意，vmult_interface_down是在多网格V周期的限制阶段使用的，而vmult_interface_up是在延长阶段使用。     
* 一旦接口矩阵被创建，我们就完全类似于[2.x.153]来设置其余的多重网格预处理基础设施，以获得一个可以应用于矩阵的[2.x.154]对象。
*


* [1.x.137]
*
* 多网格程序的设置非常简单，与[2.x.155]相比，在求解过程中看不出有什么不同。所有的魔法都隐藏在[2.x.156]操作的实现背后。请注意，我们通过标准输出打印出求解时间和累积的设置时间，也就是说，在任何情况下，而设置操作的详细时间只有在构造函数中的detail_times标志被改变的情况下才会打印。
*


*


* [1.x.138]
*
* [1.x.139] [1.x.140]。


*
* 这里是数据输出，是[2.x.157]的简化版本。我们对细化过程中产生的每个网格使用标准的VTU（=压缩的VTK）输出。此外，我们还使用了一种针对速度而不是磁盘使用量进行优化的压缩算法。默认设置（针对磁盘使用进行优化）使得保存输出的时间是运行线性求解器的4倍，而将[2.x.158]设置为[2.x.159]则将其降低到仅为线性求解的四分之一。   
* 当网格过大时，我们会禁用输出。这个程序的一个变种已经在几十万个MPI行列上运行，网格单元多达1000亿个，经典的可视化工具无法直接访问。
*


* [1.x.141]
*
* [1.x.142] [1.x.143]。


*
* 运行该程序的函数与 [2.x.160] 中的函数非常相似。与2D相比，我们在3D中做了很少的细化步骤，但仅此而已。   
* 在我们运行程序之前，我们输出一些关于检测到的矢量化水平的信息，正如介绍中所讨论的那样。
*


* [1.x.144]
*
* [1.x.145] [1.x.146]。


*
* 除了我们根据[2.x.161]设置了MPI框架之外，在主函数中没有任何意外。
*


* [1.x.147]
* [1.x.148][1.x.149] 。


*[1.x.150][1.x.151]


* 由于这个例子解决的是与[2.x.162]相同的问题（除了一个不同的系数），所以对解决方案没有什么可说的。但我们还是展示了一张图片，通过等高线和体积渲染来说明解决方案的大小。
* [2.x.163]
当我们在二维上运行这个程序时，对于二次（[2.x.164]）元素，我们得到以下输出（当在释放模式下在一个核心上运行时）： *更感兴趣的是评估多网格求解器的某些方面。
* [1.x.152]
*
* 如同在[2.x.165]中，我们看到CG迭代的数量在自由度增加的情况下保持不变。恒定的迭代次数（加上最佳的计算特性）意味着计算时间随着问题大小从一个周期到下一个周期的四倍而翻倍增长。该代码在存储方面也非常有效。大约2-4百万度的自由度适合于1GB的内存，也见下面的MPI结果。一个有趣的事实是，尽管没有建立矩阵，但解决一个线性系统比设置要便宜（大约一半的时间花在[2.x.166]和[2.x.167]调用上）。这表明这种方法的效率很高，但也表明deal.II数据结构的设置相当昂贵，设置成本必须在几次系统求解中摊销。
* 如果我们在三个空间维度上运行该程序，则变化不大。由于我们使用统一的网格细化，我们得到八倍的元素和大约八倍的自由度的每个周期。
* [1.x.153]
*
* 既然如此简单，我们来看看如果我们增加多项式的度数会发生什么。当在三维中选择四度，即在[2.x.168]元素上，通过改变程序顶部的<code>const unsigned intdegree_finite_element=4;</code>一行，我们得到以下的程序输出。
* [1.x.154]
*
* 由于某个网格上的[2.x.169]元素对应于一半网格大小上的[2.x.170]元素，我们可以比较在第四周期使用四度多项式和第五周期使用二次多项式的运行时间，两者都是210万自由度。令人惊讶的是，尽管多用了一次线性迭代，[2.x.171]元素的求解器实际上比四次方的情况略快。高阶多项式同样快，甚至比低阶多项式更快，这是通过和因子化进行无矩阵算子评估的主要优势之一，见[1.x.155]。这与基于矩阵的方法有根本的不同，后者随着多项式度数的增加和耦合的密集，每个未知数的成本也越来越高。
* 此外，高阶的设置也会变得便宜一些，这是因为需要设置的元素较少。
* 最后，让我们看一下度数为8的时间，这相当于低阶方法的另一轮网格细化。
* [1.x.156]
*
* 在这里，初始化似乎比以前慢了很多，这主要是由于矩阵对角线的计算，它实际上是在每个单元上计算一个729 x 729的矩阵，并丢弃除对角线以外的所有东西。然而，解算时间又非常接近四分法的情况，表明理论上预期的随着多项式度数增加的线性增长几乎完全被更好的计算特性所抵消，而且高阶方法在几个单元上的自由度份额较小，增加了评估的复杂性。
*[1.x.157][1.x.158]
*

* 为了了解无矩阵实现的能力，我们通过测量问题初始化的计算时间（分配DoF、设置和装配矩阵、设置多网格结构），以及无矩阵变体和基于稀疏矩阵的变体的实际解法，来比较上述3D例子和基于稀疏矩阵的变体的性能。如上所示，我们将预处理程序建立在浮点数上，而实际的矩阵和向量建立在双数上。测试在英特尔Corei7-5500U笔记本处理器上运行（两个核心，支持[1.x.159]，即用一条CPU指令可以完成对双数的四次操作，这在FEE评估中被大量使用），优化模式，以及两个MPI等级。
* [2.x.173]
* 该表清楚地表明，无矩阵实现的求解器速度是原来的两倍多，而在初始化成本方面则是六倍多。由于问题的大小被放大了8倍，我们注意到时间通常也上升了8倍（因为求解器的迭代次数恒定为6）。主要的偏差是在5k到36k自由度的稀疏矩阵中，时间增加了12倍。这是处理器中的(L3)缓存不能再容纳矩阵-向量乘积所需的所有数据的阈值，所有的矩阵元素必须从主内存中获取。
* 当然，这种情况不一定适用于所有情况，因为有些问题，对矩阵项的了解可以使解算器的效果更好（如当系数的变化比上面的例子更强烈时就会发生）。此外，这也取决于计算机系统。目前的系统具有良好的内存性能，因此稀疏矩阵的性能相当好。尽管如此，对于本例中使用的[1.x.160]<sub>2</sub>元素，无矩阵的实现已经给出了一个很好的速度。这一点对于时间依赖性或非线性问题尤其明显，在这些问题中，疏散矩阵需要一次又一次地被重新组合，这在这个类别中变得更加容易。当然，由于products有更好的复杂性，当元素的阶数增加时，该方法会获得越来越大的优势（无矩阵实现的成本是4[1.x.161]<sup>2</sup>[1.x.162]每个自由度，而稀疏矩阵的成本是2[1.x.163]，所以在3D中阶数4和更高时它会赢）。
*[1.x.164][1.x.165]
*

* 正如介绍和代码中的注释所解释的，这个程序可以用MPI并行运行。事实证明，几何多网格方案工作得非常好，可以扩展到非常大的机器。据作者所知，这里显示的几何多网格结果是截至2016年底用deal.II进行的最大计算，在[1.x.166]的147456个核心上运行。超过1000个核心的可扩展性的要素是，没有任何依赖于全局问题大小的数据结构在单个处理器上保持其完整性，并且通信不是太频繁，以避免遇到网络的延迟问题。  对于用迭代求解器求解的PDEs，通信延迟往往是限制性因素，而不是网络的吞吐量。以SuperMUC系统为例，两个处理器之间的点对点延迟在1e-6到1e-5秒之间，这取决于MPI网络的远近。这一类的矩阵-向量积[2.x.174]涉及几个点对点的通信步骤，与每个核上的计算交错进行。矩阵-向量乘积的延迟约为1e-4秒。全局通信，例如一个[2.x.175]操作，在MPInetwork的所有等级上累积每个等级的一个数字之和，其延迟为1e-4秒。这个程序中使用的多网格V型循环也是全局通信的一种形式。想一想发生在单个处理器上的粗略的网格解算。在开始之前，它积累了来自所有处理器的贡献。当完成后，粗网格解决方案被转移到更细的层次，在那里越来越多的处理器帮助进行平滑，直到细网格。从本质上讲，这是在网络中的处理器上的一个树状模式，由网格控制。与[2.x.176]操作不同的是，多网格V型循环是根据MPI网络中的实际链路来优化还原树，而多网格V型循环则是根据网格的划分来进行。因此，我们不能期望有同样的优化效果。此外，多网格循环并不是简单地在细化树上走来走去，而是在做平滑时在每一层上进行通信。换句话说，多网格中的全局通信更具有挑战性，并且与提供较少优化机会的网格有关。测得的V-循环的延迟在6e-3和2e-2秒之间，即与60到200个MPI_Allreduce操作相同。
* 下图显示了在[2.x.177]元素上进行的缩放实验。沿着这条线，问题的大小随着核数的增加而保持不变。当内核数量增加一倍时，人们期望计算时间减少一半，灰色虚线表示。结果显示，在达到0.1秒左右的绝对时间之前，该实现几乎显示了理想的行为。解算器的容差被设定为解算器进行了五次迭代。这种绘制数据的方式是该算法的[1.x.167]。当我们进入非常大的核数时，曲线会提前变平，这是因为SuperMUC的通信网络，较远的处理器之间的通信速度稍慢。
* [2.x.178]
* 此外，该图还包含了[1.x.168]的结果，列出了当处理器内核和元素的数量以同样的速度增加时，算法的表现。在这种情况下，我们希望计算时间保持不变。在算法上，CG的迭代次数恒定在5次，所以我们在这方面做得很好。图中的线条是这样排列的：每个数据系列中的左上角代表每个处理器的相同大小，即131,072个元素（或每个核心约3.5百万自由度）。表示理想的强标度的灰色线条相隔8个相同的系数。结果再次表明，扩展性几乎是理想的。从288个核到147456个核的并行效率约为75%，每个核的局部问题大小为750,000自由度，在288个核上需要1.0秒，在2304个核上需要1.03秒，在18000个核上需要1.19秒，在147000个核上需要1.35秒。这些算法也达到了非常高的处理器利用率。在147k核上的最大计算量在SuperMUC上达到约1.7 PFLOPs/s，其中算术峰值为3.2 PFLOPs/s。对于一个迭代式PDE求解器来说，这是一个非常高的数字，而且通常只有密集线性代数才会达到明显的数字。稀疏线性代数被限制在这个数值的十分之一。
* 正如在介绍中提到的，无矩阵方法减少了数据结构的内存消耗。除了由于较少的内存传输而带来的更高的性能外，这些算法还允许非常大的问题在内存中得到解决。下图显示了当我们增加问题大小时的计算时间，直到计算耗尽内存的上限。我们对1k核、8k核和65k核进行了计算，发现问题的大小几乎可以在两个数量级上进行理想的扩展。这张图中显示的最大的计算涉及2920亿（[2.x.179]）个自由度。在147k核的DG计算中，上述算法也被运行，涉及多达5490亿（2^39）个自由度。
* [2.x.180]
* 最后，我们注意到，在对上述大规模系统进行测试的同时，deal.II中的多网格算法的改进也被开发出来了。最初的版本包含了基于MGSmootherPrecondition的次优代码，其中一些MPI_Allreduce命令（检查所有向量条目是否为零）在每一级的平滑操作上进行，这只有在65k核以上才变得明显。然而，下面的图片显示，改进已经在较小的规模上得到了回报，这里显示的是对[2.x.181]元素在多达14,336个核心上的计算。
* [2.x.182]
*

*[1.x.169][1.x.170]


* 正如代码中所解释的，这里介绍的算法是为运行在自适应细化的网格上而准备的。如果只有部分网格被细化，多网格循环将以局部平滑的方式运行，并在细化程度不同的界面上施加迪里切条件，通过[2.x.183]类进行平滑。由于自由度在层次上的分配方式，将层次单元的所有者与第一个下级活动单元的所有者联系起来，在MPI中不同的处理器之间可能存在不平衡，这限制了可扩展性，约为2-5倍。
*[1.x.171][1.x.172]
*

*[1.x.173][1.x.174]


* 如上所述，代码已准备好用于局部自适应h-精简。对于泊松方程，可以采用KellyErrorEstimator类中实现的Kelly误差指标。为了评估误差指标中的跳跃项，每个MPI进程都需要知道本地相关的DoFs.然而[2.x.184]函数只用一些本地相关的自由度初始化向量。向量中提供的鬼魂指数是一个严格的集合，只有那些在单元积分中被触及的指数（包括约束条件的解决）。]，如下图所示。
* [1.x.175]

* [1.x.176][1.x.177] 。
*

* 这个程序只用MPI来并行化。作为一种选择，MatrixFreeloop也可以在混合模式下发布，例如，在一个集群的节点上使用MPI并行化，在一个节点的共享内存区域内通过Intel TBB使用线程。要使用这个方法，需要在主函数的MPI_InitFinalize数据结构中设置线程数，并设置[2.x.186]topartition_color来实际进行并行循环。这个用例在 [2.x.187] 中进行了讨论。
* [1.x.178][1.x.179] 。
*

*所提出的程序假定了同质的Dirichlet边界条件。如果涉及到非均质条件，情况就比较复杂了。为了了解如何实现这样的设置，让我们首先回顾一下这些条件是如何在数学公式中出现的，以及它们是如何在基于矩阵的变体中实现的。从本质上讲，非均质迪里希特条件将解中的一些节点值设定为给定值，而不是通过变分原理来确定它们，[1.x.180] 。
*其中[2.x.188]表示解决方案的节点值，[2.x.189]表示所有节点的集合。集合[2.x.190]是受Dirichlet边界条件约束的节点子集，其中解决方案被迫等于[2.x.191]作为Dirichlet约束节点点[2.x.192]上的插值边界值。然后我们把这个解的表示插入到弱的形式中，例如上面显示的拉普拉斯，并把已知量移到右边：[1.x.181] 。
* 在这个公式中，方程对所有与迪里希特条件约束的节点无关的基函数[2.x.193]和[2.x.194]进行检验。
* 在deal.II的实现中，右侧的积分[2.x.195]已经包含在我们在每个单元上组装的局部矩阵贡献中。当使用[2.x.196]时，如[2.x.197]和[2.x.198]教程程序中首次描述的那样，我们可以通过将本地矩阵的列[1.x.183]和行[1.x.184]相乘来说明同质约束[1.x.182]的贡献。]的局部矩阵根据积分[2.x.199]乘以不均匀性，然后从全局右侧向量的位置[1.x.185]中减去所得到的结果，也见[2.x.200]模块。实质上，我们使用了一些从方程左手边消除的积分来最终确定右手边的贡献。当首先将所有条目写进左手边的矩阵，然后通过[2.x.201]消除矩阵的行和列时，也会涉及类似的数学。
* 原则上，属于受限自由度的成分可以从线性系统中消除，因为它们不携带任何信息。在实践中，在deal.II中，我们始终保持线性系统的大小不变，以避免处理两种不同的编号系统，并避免对两种不同的索引集产生混淆。为了确保线性系统在不向约束行添加任何东西时不会变得奇异，我们会在矩阵对角线上添加与实际条目无关的假条目。
* 在无矩阵方法中，我们需要采取不同的方法，因为[2.x.202]LaplaceOperator类代表了[1.x.186]算子的矩阵-向量乘积（最后一个公式的左侧）。  传递给[2.x.203]的AffineConstraints对象是否包含不均匀约束并不重要，[2.x.204]调用将只解决约束的均匀部分，只要它代表一个[1.x.187]算子。
* 在我们的无矩阵代码中，非均质条件的贡献最后的右手边计算与矩阵算子完全脱钩，由上述不同的函数处理。因此，我们需要明确地生成进入右手边的数据，而不是使用矩阵装配的副产品。由于我们已经知道如何在向量上应用运算符，我们可以尝试对一个向量使用这些设施，在那里我们只设置Dirichlet值。
* [1.x.188]
* 或者说，如果我们已经将不均匀约束填入AffineConstraints对象中。
* [1.x.189]
*
* 然后我们可以将向量[2.x.205]传递给[2.x.206][2.x.207]函数，并将新的贡献添加到[2.x.208]system_rhs向量中，该向量在[2.x.209]函数中被填充。然而，这个想法并不奏效，因为vmult()函数中使用的[2.x.210]调用假定所有约束条件的值都是同质的（否则算子就不是线性算子，而是仿生算子）。为了同时检索同质性的值，我们可以选择以下两种策略之一。
*[1.x.190][1.x.191]
*

* FEEvaluation类有一个设施，正好解决了这个要求。对于非均质的Dirichlet值，我们确实希望在从向量[2.x.211]中读取数据时跳过对均质（Dirichlet）约束的隐式施加。例如，我们可以扩展[2.x.212][2.x.213]函数来处理非均质的Dirichlet值，如下所示，假设Dirichlet值已被插值到对象[2.x.214]中
* [1.x.192]
*
* 在这段代码中，我们用[2.x.216]代替了用于暂定解向量的[2.x.215]函数，该函数忽略了所有的约束。由于这种设置，我们必须确保其他约束条件，例如悬挂的节点，已经正确地分布到输入向量中，因为它们没有像[2.x.217]中那样被解决。 在循环中，我们然后评估拉普拉斯，并用[2.x.219]类中的[2.x.218]重复二次导数的调用，但将符号调换，因为我们想根据上面的公式减去右侧向量中迪里切条件的贡献。当我们调用[2.x.220]调用时，我们将关于值槽和第一导数槽的两个参数都设置为真，以说明在正交点的循环中增加的这两个条件。一旦右手边组装完毕，我们就继续求解同质问题的线性系统，例如涉及到一个变量[2.x.221]在求解之后，我们可以将[2.x.222]添加到包含最终（非同质）解决方案的[2.x.223]向量。
* 请注意，拉普拉斯的负号与我们需要建立右手边的强制力的正号一起，是一个更普遍的概念。我们所实施的只不过是牛顿的非线性频率方法，但应用于线性系统。我们根据迪里切特边界条件对变量[2.x.224]进行了初始猜测，并计算了一个残差[2.x.225]。然后对线性系统进行求解[2.x.226]，最后计算出[2.x.227]。对于线性系统，我们显然在一次迭代后就能得到精确的解。如果我们想将代码扩展到非线性问题，我们会将[2.x.228]函数命名为一个更具描述性的名字，如[2.x.229] assemble_residual()，计算残差的（弱）形式，而[2.x.230]函数将得到残差相对于解变量的线性化。
*[1.x.193][1.x.194]
*

* 获得重新使用[2.x.231][2.x.232]函数的第二个替代方法是添加第二个LaplaceOperator，跳过Dirichlet约束。为了做到这一点，我们初始化第二个MatrixFreeobject，它没有任何边界值约束。这个[2.x.233]对象然后被传递给一个[2.x.234]类实例[2.x.235]inhomogeneous_operator，它只用于创建右手边。
* [1.x.195]
*
* 这个技术的一个更复杂的实现可以重用原始MatrixFree对象。这可以通过用多个块初始化MatrixFree对象来实现，其中每个块对应于不同的AffineConstraints对象。这样做需要对LaplaceOperator类进行大量修改，但库中的[2.x.236]类可以做到这一点。参见[2.x.237]中关于块的讨论，以了解更多关于如何设置块的信息。
*

* [1.x.196][1.x.197] [2.x.238]。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-38_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19]
* [2.x.2]
* [1.x.20]
* [1.x.21]
* [1.x.22][1.x.23]。


* 在这个例子中，我们展示了如何在由四边形组成的一维表面[2.x.3]上解决偏微分方程（PDE），即在三维的表面或二维的线上。
* [1.x.24]
我们专注于以下的椭圆二阶PDE * [1.x.24]，它概括了我们之前在几个早期教程程序中解决的拉普拉斯方程。我们的实现是基于 [2.x.4] 。  [2.x.5]也解决了低维曲面上的问题；然而，在那里我们只考虑不涉及解变量上的导数的积分方程，而在这里我们实际上必须研究只在（可能是弯曲的）曲面上定义的函数的导数意味着什么。
* 让[2.x.6]是参考元素[2.x.8]对曲面[2.x.7]的参数化，即每个点[2.x.9]诱导一个点[2.x.10]。然后让[1.x.25]表示相应的第一基本形式，其中[2.x.11]是映射的导数（Jacobian）。]或者，对于有限元方法来说，更方便的是任何一个面[2.x.14]，其中[2.x.15]是[2.x.16]的一个由四边形组成的分区（三角形）。我们现在可以通过[1.x.26]定义一个函数[2.x.17]的切向梯度。表面拉普拉斯(Laplacian)(也称为Laplace-Beltrami算子)定义为[2.x.18] 。请注意，在光滑表面上计算表面梯度[2.x.19]的另一种方法是[1.x.27]，其中[2.x.20]是[2.x.21]的 "光滑 "延伸。]在[2.x.22]的管状邻域的 "平滑 "延伸，[2.x.23]是[2.x.24]的法线。由于[2.x.25]，我们推导出[1.x.28]值得一提的是，上述表达中出现的项[2.x.26]是曲面的总曲率（主曲率之和）。
* 像往常一样，我们只对弱解感兴趣，我们可以使用[2.x.27]有限元（而不是像强解那样要求[2.x.28]的连续性）。因此，我们求助于弱公式[1.x.29]，并利用分区[2.x.29]来进一步写出[1.x.30]此外，上述表达式中的每个积分都是在参考元素[2.x.30]中计算的，以便
* [1.x.31]
*和[1.x.32]最后，我们使用由点[2.x.31]和权重[2.x.32]定义的正交公式来评价上述积分，得到[1.x.33]和[1.x.34]
*

* 幸运的是，deal.II已经有了计算上述表达式的所有工具。事实上，它们与我们解决通常拉普拉斯的方式几乎没有区别，只需要在FEValues类的构造器中提供表面坐标映射。
* [1.x.35]
* 这正好提供了我们的计算所需要的条件。
* 在更广泛的意义上，表面有限元逼近的细节可以在[Dziuk, in Partial differential equations and calculus ofvariations 1357, Lecture Notes in Math., 1988], [Demlow, SIAM J. Numer. Anal. 47(2), 2009]和[Bonito, Nochetto, and Pauletti, SIAM J. Numer. Anal. 48(5), 2010]找到。
*


*[1.x.36][1.x.37]


* 一般来说，当你想用数字来测试一个算法的准确性和/或收敛顺序时，你需要提供一个精确的解决方案。通常的技巧是选择一个我们希望成为解决方案的函数，然后对其应用微分算子，为右手边定义一个强制项。这就是我们在这个例子中所做的。在当前情况下，域的形式显然也是至关重要的。
* 我们为一个二维问题和另一个三维问题制作了一个测试案例。
* [2.x.35] [2.x.36] 在2D中，让我们选择一个半圆作为域。在这个域上，我们选择函数[2.x.37]作为解决方案。为了计算右手边，我们必须计算解函数的表面拉普拉斯。有（至少）两种方法可以做到这一点。第一种是使用[2.x.38]的自然延伸（仍然用[2.x.39]表示）在[2.x.40]上投影掉上述的法向导数，即计算[1.x.38]，其中[2.x.41]是[2.x.42]的总曲率。  由于我们在单位圆上，[2.x.43]和[2.x.44]所以[1.x.39]。
* 一个更简单的方法，至少对于目前二维空间中的曲线的情况，是注意到我们可以用变换[2.x.47]将区间[2.x.45]映射到域[2.x.46]。  在位置[2.x.48]，解的值是[2.x.49]。  考虑到变换是保长的，即长度为[2.x.50]的一段曲线被映射到长度完全相同的一段曲线上，那么切向拉普拉斯就满足了
* [1.x.40]
*这当然与我们上面的结果相同。[2.x.51] [2.x.52] 在三维中，域又是单位球表面的一半，即半球形或穹顶。我们选择[2.x.53]作为解决方案。我们可以用上面的方法计算方程的右边，[2.x.54]，（用[2.x.55]），得到一个笨拙而冗长的表达。你可以在源代码中找到完整的表达式。[2.x.56] [2.x.57]。
* 在程序中，我们还将计算出解的[2.x.58]半正态误差。由于解函数及其数值近似只在流形上定义，这个误差函数的明显定义是[2.x.59] 。这就要求我们为函数[2.x.61]（首次在[2.x.62]中介绍）提供[1.x.41]梯度[2.x.60]，我们将通过在下面的程序中实现函数[2.x.63]来实现。
*

*[1.x.42][1.x.43] 。


* 如果你已经读完了[2.x.64]，并且理解了上面关于解决方案和右手边如何对应的讨论，你也会立即熟悉这个程序。事实上，只有两件事情是有意义的。
*
* - 我们生成三角形计算域的网格的方式。
*
* - 我们使用映射对象来描述我们解决偏微分方程的领域不是平面的，实际上是弯曲的。
* 映射对象已经在[2.x.65]和[2.x.66]中介绍过了，正如那里所解释的那样，只要你对边界的外观有一个有效的描述，你通常不需要知道它们是如何工作的。实质上，我们将简单地声明一个适当的MappingQ类型的对象，它将自动从三角测量中获得边界描述。然后，映射对象将被传递给适当的函数，我们将得到库中预定义的半圆或半球形的边界描述。
* 程序的其余部分紧跟[2.x.67]，就计算误差而言，紧跟[2.x.68]。这个程序的某些方面，特别是在Triangulation、DoFHandler和类似的类上使用两个模板参数，已经在[2.x.69]中作了详细描述；你可能希望也读一下这个教程程序。
*

* [1.x.44] [1.x.45]。
* [1.x.46] [1.x.47]。
*

*
* 如果你读过[2.x.70]和[2.x.71]，你会认识到我们已经在那里使用了以下所有的 include 文件。因此，我们不会在这里再次解释它们的含义。
*


* [1.x.48]
*
* [1.x.49] [1.x.50]。


*
* 这个类几乎与 [2.x.72] 中的 [2.x.73] 类完全相似。
*


* 基本的区别是这些。
*


*


*


*


*


*


*


*
* - 模板参数现在表示嵌入空间的维度，它不再与域和我们计算的三角形的维度相同。我们通过调用参数[2.x.74]并引入一个等于域的维度的常数[2.x.75]来表明这一点。
*
* - 这里等于[2.x.76] 。
*


*
* - 所有具有几何特征的成员变量现在都需要知道它们自己的维度以及嵌入空间的维度。因此，我们需要同时指定它们的模板参数，一个是网格的维度[2.x.77]，另一个是嵌入空间的维度，[2.x.78] 这正是我们在[2.x.79]中所做的，请看那里有更深的解释。
*


*
* - 我们需要一个对象来描述从参考单元到三角形所组成的单元的哪种映射。从Mapping基类派生出来的类正是这样做的。在deal.II的大部分时间里，如果你不做任何事情，图书馆会假定你想要一个使用（双，三）线性映射的MappingQ1对象。在许多情况下，这已经足够了，这就是为什么这些对象的使用大多是可选的：例如，如果你有一个二维空间中的多边形二维域，参考单元到三角形单元的双线性映射会产生该域的精确表示。如果你有一个弯曲的域，你可能想对那些位于域的边界的单元使用一个高阶映射
*
* - 例如，这就是我们在[2.x.80]中所做的。然而，在这里我们有一个弯曲的域，而不仅仅是一个弯曲的边界，虽然我们可以用双线性映射的单元来近似它，但对所有单元使用高阶映射才是真正谨慎的。因此，这个类有一个MappingQ类型的成员变量；我们将选择映射的多项式程度等于计算中使用的有限元的多项式程度，以确保最佳近似，尽管这种等参数性不是必须的。
*


* [1.x.51]
*
* [1.x.52] [1.x.53]。


*
* 接下来，让我们定义描述问题的精确解和右手边的类。这与[2.x.81]和[2.x.82]相类似，在那里我们也定义了这类对象。鉴于介绍中的讨论，实际的公式应该是不言自明的。值得关注的一点是，我们是如何使用一般模板的明确特殊化，分别定义2D和3D情况下的值和梯度函数的。除了这样做之外，另一种方法可能是定义一般的模板，并为空间维度的每个可能的值制定一个[2.x.83]声明（或一连串的[2.x.84]s）。
*


* [1.x.54]
*
* [1.x.55] [1.x.56]。


*
* 如果你知道 [2.x.85] ，程序的其余部分实际上是很不引人注目的。我们的第一步是定义构造函数，设置有限元和映射的多项式程度，并将DoF处理程序与三角形关联。
*


* [1.x.57]
*
* [1.x.58] [1.x.59]。



* 下一步是创建网格，分配自由度，并设置描述线性系统的各种变量。所有这些步骤都是标准的，只有如何创建一个描述曲面的网格是例外。我们可以为我们感兴趣的领域生成一个网格，用一个网格生成器生成一个三角形，然后用GridIn类将其读入。或者，就像我们在这里做的那样，我们使用GridGenerator命名空间中的设施来生成网格。   
* 具体来说，我们要做的是这样的（围在下面的一组大括号之间）：我们使用[2.x.86]函数为半圆盘（2D）或半球（3D）生成一个[2.x.87]维的网格。这个函数将位于圆盘/球周边的所有面的边界指标设置为零，而在将整个圆盘/球分成两半的直线部分设置为一。接下来就是重点了。[2.x.88]函数创建的网格是由那些作为前一个网格的面的单元组成的，也就是说，它描述了原始（体积）网格的[1.x.60]单元。然而，我们不需要所有的面：只需要那些在圆盘或球的周边，边界指示器为零的面；我们可以用一组边界指示器来选择这些单元，并传递给[2.x.89]。
* 有一点需要提及。为了在流形是弯曲的情况下适当地细化表面网格（类似于细化与弯曲边界相邻的单元面），三角形必须有一个对象附加在它上面，描述新顶点应该位于何处。如果你不附加这样的边界对象，它们将位于现有顶点之间的中间位置；如果你有一个具有直线边界的域（例如多边形），这是很合适的，但如果像这里一样，流形具有曲率，则不合适。因此，为了让事情正常进行，我们需要将流形对象附加到我们的（表面）三角形上，其方式与我们在1d中为边界所做的大致相同。我们创建这样一个对象，并将其附加到三角剖面上。   
* 创建网格的最后一步是对其进行多次细化。该函数的其余部分与以前的教程程序相同。
*


* [1.x.61]
*
* [1.x.62] [1.x.63]。


*
* 下面是这个程序的中心函数，组装对应于表面拉普拉斯（Laplace-Beltrami算子）的矩阵。也许令人惊讶的是，它实际上与在例如 [2.x.90] 中讨论的常规拉普拉斯算子看起来完全一样。关键是[2.x.91]函数发挥了神奇的作用：它返回[2.x.93]个形状函数在[2.x.94]个正交点的表面梯度[2.x.92]。其余的也不需要任何改变。
*


* [1.x.64]
*
* [1.x.65] [1.x.66]。


*
* 下一个函数是解决线性系统的函数。在这里，也不需要做任何改变。
*


* [1.x.67]
*
* [1.x.68] [1.x.69]。


*
* 这是一个从解决方案中生成图形输出的函数。它的大部分都是模板代码，但有两点值得指出。
*


*


*


*


*


*


*


*
* - [2.x.95]函数可以接受两种向量。一种是之前通过[2.x.96]附加的DoFHandler对象定义的每个自由度有一个值的向量，另一种是三角测量的每个单元有一个值的向量，例如，输出每个单元的估计误差。通常，DataOut类知道如何区分这两种向量：自由度几乎总是比单元多，所以我们可以通过两种向量的长度来区分。我们在这里也可以这样做，但只是因为我们很幸运：我们使用了一个半球体。如果我们用整个球体作为域和[2.x.97]元素，我们将有相同数量的单元格作为顶点，因此这两种向量将有相同数量的元素。为了避免由此产生的混淆，我们必须告诉[2.x.98]函数我们有哪种矢量。DoF数据。这就是该函数的第三个参数的作用。
*


*
* - [2.x.99]函数可以生成细分每个单元的输出，这样可视化程序可以更好地解析曲面流形或更高的多项式程度的形状函数。在这里，我们在每个坐标方向上对每个单元进行细分，其次数与使用中的有限元的多项式程度相同。
*


* [1.x.70]
*
* [1.x.71] [1.x.72]。


*
* 这是最后一块功能：我们要计算数值解的误差。它是之前在 [2.x.100] 中展示和讨论的代码的逐字复制。正如介绍中提到的，[2.x.101]类提供了解决方案的（切向）梯度。为了避免只评估超融合点的误差，我们选择一个足够高阶的正交规则。
*


* [1.x.73]
*
* [1.x.74] [1.x.75]。


*
* 最后一个函数提供了顶层的逻辑。它的内容是不言自明的。
*


* [1.x.76]
*
* [1.x.77] [1.x.78]。


*
* 程序的其余部分被[2.x.102]函数所占用。它完全遵循首次在[2.x.103]中介绍的一般布局，并在随后的所有教程程序中使用。
*


* [1.x.79]
* [1.x.80][1.x.81] 。


*当你运行该程序时，屏幕上应打印出以下输出。
* [1.x.82]

*

* 通过在[2.x.104]函数中玩弄全局细化的数量，可以增加或减少网格细化。例如，多做一次细化，只运行三维曲面问题，产生以下输出。
* [1.x.83]
*
* 这就是我们所期望的：将网格尺寸缩小2倍，错误就会减少4倍（记得我们使用的是双四边形元素）。从一到五次细化的全部误差序列看起来像这样，整齐地遵循理论上预测的模式。
* [1.x.84]
*
* 最后，该程序产生的图形输出，我们可以直观地看到。下面是结果的图表。
* [2.x.105]
* 这个程序也适用于2D中的1D曲线，而不仅仅是3D中的2D曲面。你可以通过改变 [2.x.106] 中的模板参数来测试这一点。
* [1.x.85]
* 域是一条2D的曲线，我们可以通过使用第三维（和颜色）来表示函数的值来使解决方案可视化 [2.x.107] 。这样看起来就像这样（白色的曲线是域，彩色的曲线是被挤压到第三维的解决方案，清楚地显示了曲线从域的一个象限移动到相邻象限时的符号变化）。
* [2.x.108]


*[1.x.86][1.x.87][1.x.88]


* 只有当曲面比半球形更有趣时，曲面上的计算才会变得有趣。为了达到这个目的，deal.II可以通过通常的GridIn类读取描述曲面的网格。或者，如果你有一个分析性的描述，一个简单的网格有时可以被拉伸和弯曲成我们所感兴趣的形状。
* 让我们考虑一个相对简单的例子：我们把之前用过的半球体，在Z方向上拉伸10倍，然后把X和Y坐标拼一下。在我们讨论下面的实现细节之前，我们先展示一下计算域和解决方案。
* [2.x.109]
* [2.x.110]
* 产生这种网格的方法是通过使用[2.x.111]函数。它需要一个方法来转换每个单独的网格点到不同的位置。让我们在这里使用下面这个相当简单的函数（记住：在一个方向上拉伸，在另外两个方向上混杂）。
* [1.x.89]
*
* 如果我们遵循[2.x.112]函数，我们将像以前一样提取半球形表面的网格，将其扭曲成我们想要的形状，并根据需要经常进行细化。但这并不像我们所希望的那样简单：细化要求我们有一个适当的流形对象附加到三角形上，描述细化时网格的新顶点应该位于何处。我相信可以通过简单地撤消上面的变换（重新得到球面），找到球面上新点的位置，然后重新扭曲结果，以一种不太复杂的方式描述这个流形。但我是个懒人，既然这样做并不是真正的重点，让我们的生活变得更容易一些：我们将提取半球体，必要时对其进行软化，摆脱描述流形的对象，因为我们现在不再需要它，然后最后对网格进行扭曲。使用上面的函数，这将看起来如下。
* [1.x.90]
*
* 注意，唯一必要的补充是标有asterisks的那一行。这里值得指出的是：由于我们将流形描述从曲面网格中分离出来，当我们在程序的其余部分使用mapping对象时，它就没有曲线边界描述可言了。相反，它将不得不使用隐含的FlatManifold类，该类被用于域的所有部分，并被明确指定为不同的流形对象。因此，无论我们使用MappingQ(2)、MappingQ(15)还是MappingQ1，我们的网格的每个单元都将使用双线性近似进行映射。
* 撇开所有这些缺点不谈，所得到的图片仍然是漂亮的。与[2.x.113]中的内容唯一不同的是，我们将右侧改为[2.x.114]，将边界值（通过[2.x.115]类）改为[2.x.116] 。当然，我们现在不再知道确切的解决方案，所以在[2.x.117]末尾的误差计算将产生一个无意义的数字。
*

* [1.x.91][1.x.92] [2.x.118] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-39_0.txt
[0.x.0]*
 [2.x.0]
* 本教程取决于[2.x.1] b.
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9]
* [1.x.10]
* 在这个程序中，我们使用内部惩罚法和Nitsche的弱边界条件来解决Poisson方程。我们在局部细化的网格上使用多网格方法，这些网格是用一个bulkcriterion和一个基于单元和面的标准误差估计器生成的。所有的操作都是通过MeshWorker接口实现的。
* 与[2.x.2]一样，离散化依赖于有限元空间，其在网格单元内是多项式的[2.x.3]，但在单元之间没有连续性。由于这种函数在每个内部面[2.x.4]上有两个值，每边一个，我们定义均值和跳跃算子如下：让[1.x.11]<sub>1</sub>和[1.x.12]<sub>2</sub>为两个单元，并让函数的轨迹[1.x.13]和外层法向量[1.x.14][1.x.15] 被相应地标记为。然后，在这个面上，我们让[1.x.16]。
* 注意，如果这样的表达式包含一个法向量，平均运算符就会变成一个跳跃。对问题[1.x.17]的内部惩罚方法变成[1.x.18] 。
*
* 这里，[2.x.5]是惩罚参数，选择如下：对于单元格[1.x.20]的一个面[1.x.19]，计算值[1.x.21]，其中[1.x.22]是有限元函数的多项式程度，[2.x.6]和[2.x.7]表示相应对象的[2.x.8]和[2.x.9]维的豪斯多尔夫度。如果该面位于边界，则选择[2.x.10] .对于内部面，我们取该面的两个值的平均值。
* 在我们的有限元程序中，我们区分了三个不同的积分，分别对应于上面的单元格、内部面和边界面的总和。由于[2.x.11]为我们组织了和，我们只需要实现每个网格元素的积分。下面的MatrixIntegrator类有这三个函数用于公式的左边，RHSIntegrator类用于右边。
* 正如我们将在下面看到的，即使是误差估计也是相同结构的，因为它可以写成
* [1.x.23]
*
* 因此，下面用于组装矩阵、右手边和误差估计的函数表明，这些循环都是通用的，可以用同样的方式进行编程。
* 这个程序与[2.x.12] b有关，因为它使用MeshWorker和非连续Galerkin方法。在那里，我们解决的是一个平流问题，而这里是一个扩散问题。在这里，我们还使用了多网格预处理和一个理论上合理的误差估计器，见Karakashian和Pascal(2003)。Kanschat(2004)详细讨论了多层次方案。Hoppe, Kanschat和Warburton (2009)讨论了自适应迭代及其收敛性（对于三角形网格）。
*

* [1.x.24] [1.x.25]。
* 线性代数的包含文件。一个普通的SparseMatrix，它又将包括SparsityPattern和Vector类的必要文件。
*


* [1.x.26]
*
*包括用于设置网格的文件
*


* [1.x.27]
*
* FiniteElement类和DoFHandler的包含文件。
*


* [1.x.28]
*
* 使用MeshWorker框架的包含文件
*


* [1.x.29]
*
*与拉普拉斯相关的局部积分器的包含文件
*


* [1.x.30]
*
* 支持多棱镜方法
*


* [1.x.31]
*
* 最后，我们从库中取出我们的精确解，以及正交和附加工具。
*


* [1.x.32]
*
* deal.II库的所有类都在dealii命名空间中。为了节省打字，我们告诉编译器也要在那里搜索名字。
*


* [1.x.33]
*
* 这是我们用来设置边界值的函数，也是我们比较的精确解。
*


* [1.x.34]
*
* [1.x.35] [1.x.36]。


*
* MeshWorker将局部积分与单元格和面的循环分离开来。因此，我们必须编写局部积分类来生成矩阵、右手边和误差估计器。
*

*
* 所有这些类都有相同的三个函数，分别用于在单元格、边界面和内部面的积分。局部积分所需的所有信息都是由[2.x.13]提供的。请注意，这些函数的签名不能被改变，因为它是由[2.x.14]预期的。
*

*
* 定义局部积分器的第一类负责计算单元和面矩阵。它被用来组装全局矩阵以及水平矩阵。
*


* [1.x.37]
*
* 在每个单元上，我们对Dirichlet形式进行积分。我们使用LocalIntegrators中的现成积分库来避免自己编写这些循环。同样地，我们实现了Nitsche边界条件和单元间的内部惩罚通量。   
* 边界和通量项需要一个惩罚参数，这个参数应该根据单元的大小和多项式的度数来调整。在[2.x.15]中可以找到这个参数对常数系数的安全选择，我们在下面使用这个参数。
*


* [1.x.38]
*
* 内部面使用内部惩罚方法
*


* [1.x.39]
*
* 第二个局部积分器建立了右手边。在我们的例子中，右手边的函数是零，这样，这里只设置了弱形式的边界条件。
*


* [1.x.40]
*
* 第三个局部积分器负责对误差估计的贡献。这是由Karakashian和Pascal (2003)提出的标准能量估计器。
*


* [1.x.41]
*
* 单元贡献是离散解的拉普拉斯，因为右手边是零。
*


* [1.x.42]
*
* 在边界，我们简单地使用边界残差的加权形式，即有限元解和正确边界条件之间的差值的规范。
*


* [1.x.43]
*
* 最后，在内部面，估计器由解的跳跃和它的法向导数组成，适当加权。
*


* [1.x.44]
*
* 最后我们有一个误差的积分器。由于不连续Galerkin问题的能量准则不仅涉及到单元内部的梯度差，而且还涉及到跨面和边界的跳跃项，所以我们不能仅仅使用[2.x.16] 而是使用MeshWorker接口来计算误差。
*

*
* 有几种不同的方法来定义这个能量准则，但是所有的方法都是随着网格大小的变化而等价的（有些不是随着多项式程度的变化而等价）。这里，我们选择[1.x.45]。
*


*


* [1.x.46]

* 这里我们有单元格上的积分。目前MeshWorker中还没有一个很好的接口可以让我们访问正交点的正规函数的值。因此，我们必须在单元格积分器中为精确的函数值和梯度创建向量。之后，一切照旧，我们只需将差值的平方加起来。
*

*
* 除了计算能量准则的误差，我们还利用网格工作者的能力，在同一时间计算两个函数，并在同一循环中计算[1.x.47]的误差。很明显，这个函数没有任何跳跃项，只出现在单元格的积分中。
*


* [1.x.48]
*
* [1.x.49] [1.x.50]。


*
* 这个类做主要的工作，就像前面的例子一样。关于这里声明的函数的描述，请参考下面的实现。
*


* [1.x.51]
*
* 与离散化有关的成员对象在此。
*


* [1.x.52]

* 然后，我们有与全局离散系统有关的矩阵和向量。
*


* [1.x.53]
*
* 最后，我们有一组与多级预处理程序有关的稀疏模式和稀疏矩阵。  首先，我们有一个水平矩阵和它的稀疏性模式。
*


* [1.x.54]
*
* 当我们在局部细化的网格上进行局部平滑的多重网格时，需要额外的矩阵；见Kanschat（2004）。这里是这些边缘矩阵的稀疏性模式。我们只需要一个，因为上矩阵的模式是下矩阵的转置。实际上，我们并不太关心这些细节，因为MeshWorker正在填充这些矩阵。
*


* [1.x.55]
*
*细化边缘的通量矩阵，将细级自由度与粗级自由度耦合。
*


* [1.x.56]
*
*细化边缘的通量矩阵的转置，将粗级自由度耦合到细级。
*


* [1.x.57]
*
*构造函数简单地设置了粗略的网格和DoFHandler。FiniteElement作为一个参数被提供，以实现灵活性。
*


* [1.x.58]
*
* 在这个函数中，我们设置了线性系统的维度和全局矩阵以及水平矩阵的稀疏性模式。
*


* [1.x.59]

* 首先，我们使用有限元将自由度分布在网格上并对其进行编号。
*


* [1.x.60]

* 然后，我们已经知道代表有限元函数的向量的大小。
*


* [1.x.61]
*
* 接下来，我们为全局矩阵设置稀疏性模式。由于我们事先不知道行的大小，所以我们首先填充一个临时的DynamicSparsityPattern对象，一旦完成，就把它复制到常规的SparsityPattern中。
*


* [1.x.62]
*
* 全局系统已经设置好了，现在我们来处理关卡矩阵。我们调整所有矩阵对象的大小，以便每一级都有一个矩阵。
*


* [1.x.63]
*
* 在为水平矩阵调用<tt>clear()</tt>之后，更新稀疏模式非常重要，因为矩阵通过SmartPointer和Subscriptor机制锁定了稀疏模式。
*


* [1.x.64]
*
* 现在所有的对象都准备好了，每一层都有一个稀疏模式或矩阵。剩下的就是在每个层次上设置稀疏模式了。
*


* [1.x.65]
*
* 这些是与上面的全局矩阵大致相同的行，现在是针对每个级别。
*


* [1.x.66]
*
* 此外，我们需要初始化各级之间细化边缘的转移矩阵。它们被存储在指代两个索引中较细的索引处，因此在0层没有这样的对象。
*


* [1.x.67]
*
* 在这个函数中，我们组装全局系统矩阵，这里的全局是指我们解决的离散系统的矩阵，它覆盖了整个网格。
*


* [1.x.68]

* 首先，我们需要设置提供我们集成值的对象。这个对象包含所有需要的FEValues和FEFaceValues对象，并且自动维护它们，使它们总是指向当前的单元。为此，我们首先需要告诉它，在哪里计算，计算什么。由于我们没有做任何花哨的事情，我们可以依靠他们对正交规则的标准选择。     
* 由于他们的默认更新标志是最小的，我们额外添加我们需要的东西，即所有对象（单元、边界和内部面）上的形状函数的值和梯度。之后，我们准备初始化容器，它将创建所有必要的FEValuesBase对象进行整合。
*


* [1.x.69]

* 这是我们整合本地数据的对象。它由MatrixIntegrator中的局部整合例程填充，然后由汇编者用来将信息分配到全局矩阵中。
*


* [1.x.70]
*
* 此外，我们需要一个将局部矩阵组装成全局矩阵的对象。这些装配对象拥有目标对象结构的所有知识，在这种情况下是一个稀疏矩阵，可能的约束和网格结构。
*


* [1.x.71]
*
* 现在是我们自己编码的部分，局部积分器。这是唯一与问题有关的部分。
*


* [1.x.72]

* 现在，我们把所有东西都扔到[2.x.17]中，这里遍历网格的所有活动单元，计算单元和面的矩阵，并把它们集合到全局矩阵中。我们在这里使用变量<tt>dof_handler</tt>，以便使用全局自由度的编号。
*


* [1.x.73]
*
* 现在，我们对水平矩阵做同样的处理。不太令人惊讶的是，这个函数看起来像前一个函数的孪生兄弟。事实上，只有两个小的区别。
*


* [1.x.74]
*
* 很明显，汇编器需要被一个填充水平矩阵的汇编器所取代。请注意，它也会自动填充边缘矩阵。
*


* [1.x.75]
*
* 这里是与前一个函数的另一个区别：我们在所有的单元上运行，而不仅仅是活动单元。而且我们使用以[2.x.18]结尾的函数，因为我们需要每一层的自由度，而不是全局的编号。
*


* [1.x.76]
*
* 这里我们有另一个assemble函数的克隆。与组装系统矩阵的区别在于，我们在这里组装了一个向量。
*


* [1.x.77]
*
* 因为这个汇编器允许我们填充几个向量，所以接口要比上面复杂一些。向量的指针必须存储在一个AnyData对象中。虽然这在这里似乎造成了两行额外的代码，但实际上在更复杂的应用中它是很方便的。
*


* [1.x.78]
*
* 现在我们已经编码了建立离散线性系统的所有函数，现在是我们实际解决它的时候了。
*


* [1.x.79]
*
*选择的求解器是共轭梯度。
*


* [1.x.80]

* 现在我们正在设置多级预处理程序的组件。首先，我们需要在网格层之间进行转移。我们在这里使用的对象为这些转移生成了稀疏矩阵。
*


* [1.x.81]
*
* 然后，我们需要在最粗的层次上对矩阵进行精确求解。
*


* [1.x.82]
*
* 虽然转移和粗略的网格求解器几乎是通用的，但为平滑器提供了更多的灵活性。首先，我们选择Gauss-Seidel作为我们的平滑方法。
*


* [1.x.83]
*
* 在每个级别上做两个平滑的步骤。
*


* [1.x.84]
*
* 由于SOR方法不是对称的，但我们在下面使用共轭梯度迭代，这里有一个技巧，使多级预处理器成为对称算子，即使是对非对称平滑器。
*


* [1.x.85]
*
* 平滑器类可以选择实现变量V-cycle，我们在这里不需要。
*


* [1.x.86]
*
* 最后，我们必须将我们的矩阵包裹在一个具有所需乘法函数的对象中。
*


* [1.x.87]

* 现在，我们准备设置V型循环算子和多级预处理程序。
*


* [1.x.88]
*
* 我们不要忘记因为自适应细化而需要的边缘矩阵。
*


* [1.x.89]
*
* 在所有的准备工作完成后，将Multigrid对象包装成另一个对象，它可以作为一个普通的预处理程序使用。
*


* [1.x.90]

* 并用它来解决这个系统。
*


* [1.x.91]
*
* 另一个克隆的assemble函数。与之前的最大区别是，这里我们也有一个输入向量。
*


* [1.x.92]
*
* 估计器的结果存储在一个向量中，每个单元格有一个条目。由于deal.II中的单元格没有编号，我们必须建立自己的编号，以便使用这个向量。对于下面使用的汇编器来说，结果存储在向量的哪个分量中的信息是由每个单元的user_index变量传送的。我们需要在这里设置这个编号。     
* 另一方面，有人可能已经使用了用户索引。所以，让我们做个好公民，在篡改它们之前保存它们。
*


* [1.x.93]
*
*这和以前一样开始。
*


* [1.x.94]
*
* 但现在我们需要通知信息框我们要在正交点上评估的有限元函数。首先，我们用这个向量创建一个AnyData对象，这个向量就是我们刚刚计算的解。
*


* [1.x.95]
*
* 然后，我们告诉单元格的[2.x.19]，我们需要这个解决方案的第二导数（以计算拉普拉斯）。因此，选择函数值和第一导数的布尔参数是假的，只有选择第二导数的最后一个参数是真的。
*


* [1.x.96]
*
* 在内部和边界面，我们需要函数值和第一导数，但不需要第二导数。
*


* [1.x.97]
*
* 我们继续像以前一样，除了默认的更新标志已经被调整为我们上面要求的值和导数之外。
*


* [1.x.98]
*
* 汇编器在每个单元格中存储一个数字，否则这就与右手边的计算相同。
*


* [1.x.99]
*
* 就在我们返回错误估计的结果之前，我们恢复了旧的用户索引。
*


* [1.x.100]
*
* 这里我们将我们的有限元解与（已知的）精确解进行比较，并计算梯度和函数本身的平均二次方误差。这个函数是上面那个估计函数的克隆。
*

*
* 因为我们分别计算了能量和[1.x.101]-norm的误差，所以我们的块向量在这里需要两个块。
*


* [1.x.102]
*
* 创建图形输出。我们通过整理其各个组成部分的名称来产生文件名，包括我们用两个数字输出的细化周期。
*


* [1.x.103]
*
* 最后是自适应循环，或多或少和前面的例子一样。
*


* [1.x.104]
* [1.x.105][1.x.106] 。


* [1.x.107][1.x.108] 。
* 首先，该程序产生通常的日志文件，在这里存储在<tt>deallog</tt>。它的内容是（省略了中间的步骤
* [1.x.109]
*
* 例如，这个日志显示共轭梯度迭代步骤的数量恒定在大约15个。
* [1.x.110][1.x.111] 。
*

* [2.x.20] 使用perl脚本<tt>postprocess.pl</tt>，我们提取相关数据到<tt>output.dat</tt>中，可以用<tt>gnuplot</tt>绘制图形。例如，上面的图是用gnuplot脚本<tt>plot_errors.gpl</tt>通过以下方式制作的
* [1.x.112]
*
* 参考数据可以在<tt>output.reference.dat</tt>中找到。
*

* [1.x.113][1.x.114] [2.x.21] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-40_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18]
* [2.x.2]
* [1.x.19]


*
* [2.x.3] 作为这个程序的先决条件，你需要同时安装PETSc和thep4est库。在[1.x.20]文件中描述了deal.II和这两个附加库的安装情况。还需要注意的是，为了正常工作，本程序需要访问实现代数多重网格的Hyprepreconditioner包；它可以作为PETSc的一部分安装，但必须在PETSc配置时明确启用；参见PETSc安装说明中的链接页面。
*

*[1.x.21][1.x.22][1.x.23]


* [2.x.4]
* 鉴于当今的计算机，大多数有限元计算可以在一台机器上完成。因此，以前的大多数教程程序只显示了这一点，可能是在一些处理器之间分工合作，但这些处理器都可以访问同一个共享的内存空间。也就是说，有些问题对于单台机器来说实在是太大了，在这种情况下，必须以适当的方式将问题分割给多台机器，每台机器都要为整体贡献自己的一部分。一个简单的方法是在[2.x.5]和[2.x.6]中展示的，在那里我们展示了一个程序如何使用[1.x.24]来并行化组装线性系统，存储它，解决它，并计算误差估计。所有这些操作的扩展都是相对琐碎的（关于操作 "扩展 "的定义，见[2.x.7]"本词汇表条目"），但有一个明显的缺点：为了使其实现得适度简单，每个MPI处理器都必须保留自己的整个Triangulation和DoFHandler对象副本。因此，虽然我们可以怀疑（有充分的理由）上面列出的操作可以扩展到数千台计算机和数十亿个单元和数十亿个自由度的问题规模，但为这数千台计算机在每个最后的处理器上解决的整个问题建立一个大的网格显然是不能扩展的：这将需要很长时间，也许更重要的是没有一台机器有足够的内存来存储一个有十亿个单元的网格（至少在写这篇文章的时候没有）。在现实中，像[2.x.8]和[2.x.9]这样的程序不可能在超过100或200个处理器上运行，甚至在那里存储三角形和DoFHandler对象会消耗每台机器的绝大部分内存。
* 因此，我们需要以不同的方式来处理这个问题：为了扩展大型问题，每个处理器只能存储自己的一小部分Triangulation和DoFHandler对象。 deal.II在[2.x.10]命名空间和其中的类中实现了这样一个方案。它建立在一个外部库上，[1.x.25]（对表达式[1.x.26]的发挥，该表达式描述了平行存储一个hierarchically constructed mesh as a forest of quad- oroct-trees）。你需要[1.x.27]，除此之外，它的所有工作原理都隐藏在交易的表面之下。
* 本质上，[2.x.11]类和DoFHandler类中的代码所做的是分割全局网格，使每个处理器只存储它 "拥有 "的一小部分，以及围绕它所拥有的单元的一层 "幽灵"。在我们想要解决偏微分方程的领域的其余部分发生了什么，对每个处理器来说都是未知的，如果需要这些信息，可以通过与其他机器的通信来推断出来。这意味着我们还必须以不同于我们在[2.x.12]和[2.x.13]中的方式来考虑问题：例如，没有一个处理器可以拥有用于后处理的整个解矢量，而且程序的每一部分都必须并行化，因为没有一个处理器拥有顺序操作所需的所有信息。
* 在[2.x.14]文档模块中描述了这种并行化如何发生的一般概况。在阅读这个程序的源代码之前，你应该先阅读它的顶层概述。在[2.x.15]"分布式计算论文 "中也提供了许多我们将在程序中使用的术语的简明讨论，可能值得一读，以了解本程序内部如何工作的背景信息。
*

*[1.x.28][1.x.29]


* 这个程序基本上重新解决了我们在[2.x.16]中已经做过的事情，即它解决了拉普拉斯方程。
* [1.x.30]
* 当然，不同的是，我们现在要在一个可能有十亿个单元、十亿个左右自由度的网格上进行求解。毫无疑问，对于这样一个简单的问题，这样做是完全愚蠢的，但是一个教程程序的重点毕竟不是要做一些有用的事情，而是要展示如何用deal.II实现有用的程序。虽然如此，为了使事情至少有一点意思，我们选择右边的非连续函数。
* [1.x.31]
* 这样一来，解决方案就会沿着蜿蜒穿过领域的正弦线出现奇异点。因此，网格细化将集中在这条线上。你可以在下面的结果部分的网格图中看到这一点。
* 与其在这里继续做冗长的介绍，不如让我们直接进入程序代码。如果你已经读完了[2.x.17]和[2.x.18]的文档模块，大部分将要发生的事情你应该已经熟悉了。事实上，比较这两个程序，你会注意到为使事情在%并行状态下运行所需的额外努力几乎是微不足道的：这两个程序的代码行数大致相同（尽管[2.x.19]在处理系数和输出方面花费了更多的空间）。在任何情况下，下面的评论将只针对[2.x.20]与[2.x.21]不同的地方，以及[2.x.22]文档模块中还没有涉及的地方。
*


* [2.x.23] 这个程序将能够在你想扔给它的多少个处理器上进行计算，而且你有多少内存和耐心来解决多大的问题。然而，[1.x.32]有一个限制：未知数的数量不能超过可以用类型[2.x.24]的对象存储的最大数量。默认情况下，这是<code>unsignedint</code>的别名，在今天的大多数机器上是一个32位整数，限制了你的40亿（实际上，由于这个程序使用PETSc，你将被限制在一半，因为PETSc使用有符号整数）。然而，这可以在配置时改变为使用64位整数，见ReadMe文件。这将使问题的大小在短期内不可能超过。
*

* [1.x.33] [1.x.34]。
* [1.x.35][1.x.36] 。
*


* 我们在这个程序中需要的大部分include文件已经在以前的程序中讨论过了。特别是，以下所有的文件都应该是熟悉的朋友。
*


* [1.x.37]
*
* 这个程序可以使用PETSc或Trilinos来满足其并行代数的需要。默认情况下，如果deal.II已经被配置为PETSc，它将使用PETSc。否则，下面几行将检查deal.II是否已经配置了Trilinos，并采用该配置。
*

*
* 但在某些情况下，你可能想使用Trilinos，即使deal.II也已经*配置了PETSc，例如，比较这两个库的性能。要做到这一点，请在源代码中添加以下的\#define。  [2.x.25]
*

*
* 使用这个逻辑，下面几行将导入PETSc或Trilinos包装器到命名空间`LA`（代表 "线性代数"）。在前一种情况下，我们还定义了宏 `USE_PETSC_LA`，这样我们就可以检测到我们是否在使用PETSc（参见solve()中需要用到的例子）。
*


* [1.x.39]
*
* 然而，下面的内容将是新的或在新的角色中使用。让我们走过它们。其中第一个将提供[2.x.26]命名空间的工具，我们将用它来查询诸如与当前MPI宇宙相关的处理器数量，或者这个作业运行的处理器在这个宇宙中的数量。
*


* [1.x.40]
*
* 下一个提供了一个类，ConditionOStream，它允许我们写代码，将东西输出到一个流（如[2.x.27]在每一个处理器上，但在除了一个处理器以外的所有处理器上都将文本扔掉。我们可以通过简单地在每个可能产生输出的地方前面放一个[2.x.28]语句来实现同样的目的，但这并不能使代码更漂亮。此外，这个处理器是否应该向屏幕输出的条件，每次都是一样的
*
* - 因此，把它放在产生输出的语句中本身就应该是很简单的。
*


* [1.x.41]
*
* 在这些预演之后，这里就变得更加有趣了。正如在[2.x.29]模块中提到的，在大量处理器上解决问题的一个基本事实是，任何处理器都不可能存储所有的东西（例如，关于网格中所有单元的信息，所有自由度，或者解向量中所有元素的值）。相反，每个处理器都会[1.x.42]其中的几个，如果有必要，还可能[1.x.43]另外几个，例如，位于与该处理器自己拥有的单元相邻的单元。我们通常称后者为[1.x.44]、[1.x.45]或[1.x.46]。这里讨论的重点是，我们需要有一种方法来表明一个特定的处理器拥有或需要知道哪些元素。这就是IndexSet类的领域：如果总共有[2.x.30]个单元、自由度或向量元素，与（非负）积分指数[2.x.31]相关，那么当前处理器拥有的元素集以及它需要知道的（可能更大）指数集都是集合的子集[2.x.32]。IndexSet是一个类，它以一种有效的格式存储这个集合的子集。
*


* [1.x.47]
*
* 下一个头文件对于一个单一的函数是必要的，[2.x.33] 这个函数的作用将在下面解释。
*


* [1.x.48]
*
* 最后两个新的头文件提供了类[2.x.34]，它提供了分布在可能非常多的处理器上的网格，而第二个文件提供了命名空间[2.x.35]，它提供了可以自适应地细化这种分布式网格的函数。
*


* [1.x.49]
*
* [1.x.50] [1.x.51]。


*
* 接下来我们来声明这个程序的主类。它的结构几乎与[2.x.36]的教程程序一模一样。唯一显著的区别是。
*


*
* - [2.x.37]变量，描述了我们希望这段代码运行的处理器集合。在实践中，这将是MPI_COMM_WORLD，即批处理调度系统分配给这个特定作业的所有处理器。
*


*
* - ConditionOStream类型的[2.x.38]变量的存在。
*


*
* - 明显使用[2.x.39]而不是Triangulation。
*


*
* - 两个IndexSet对象的存在，表示我们在当前处理器上拥有哪些自由度集（以及解和右手向量的相关元素），以及我们需要哪些（作为幽灵元素）来使本程序的算法工作。
*


*
* - 现在所有的矩阵和向量都是分布式的。我们使用PETSc或Trilinos包装类，这样我们就可以使用Hypre（使用PETSc）或ML（使用Trilinos）所提供的复杂的预处理程序之一。请注意，作为这个类的一部分，我们存储的解向量不仅包含当前处理器拥有的自由度，还包括（作为鬼魂元素）所有对应于 "本地相关 "自由度的向量元素（即所有生活在本地拥有的单元或围绕它的鬼魂单元层的自由度）。
*


* [1.x.52]
*
* [1.x.53] [1.x.54]。



* [1.x.55] [1.x.56]。


*
* 构造器和解构器是相当微不足道的。除了我们在[2.x.40]中所做的，我们将我们想要工作的处理器集合设置为所有可用的机器（MPI_COMM_WORLD）；要求三角化以确保网格保持平滑并自由地精制岛屿，例如；并初始化[2.x.41]变量，只允许处理器0输出任何东西。最后一块是初始化一个定时器，我们用它来决定程序的不同部分需要多少计算时间。
*


* [1.x.57]
*
* [1.x.58] [1.x.59]。


*
* 可以说，下面这个函数是整个程序中最有趣的一个，因为它涉及到了%并行 [2.x.42] 和顺序 [2.x.43] 的核心区别。   
* 在最上面，我们做了我们一直在做的事情：告诉DoFHandler对象来分配自由度。由于我们在这里使用的三角测量是分布式的，DoFHandler对象足够聪明，它认识到在每个处理器上只能在它所拥有的单元上分配自由度；接下来是一个交换步骤，处理器相互告诉对方关于ghost单元的自由度。结果是DoFHandler知道本地拥有的单元和幽灵单元（即与本地拥有的单元相邻的单元）的自由度，但对更远的单元则一无所知，这与分布式计算的基本理念一致，即没有处理器可以知道所有的事情。
*


* [1.x.60]
*
* 接下来的两行提取一些我们稍后需要的信息，即两个索引集，提供哪些自由度为当前处理器所拥有（这些信息将用于初始化解和右手向量以及系统矩阵，表明哪些元素要存储在当前处理器上，哪些要期望存储在其他地方）；以及一个索引集，表明哪些自由度是本地相关的（即生活在当前处理器所拥有的单元上或本地所拥有的单元周围的幽灵单元上；我们需要所有这些自由度，例如用于估计本地的误差。例如，生活在当前处理器拥有的单元上或本地拥有的单元周围的幽灵单元层上；我们需要所有这些自由度，例如，估计本地单元的误差）。)
*


* [1.x.61]

* 接下来，让我们初始化解和右手向量。如上所述，我们所寻求的解向量不仅存储我们拥有的元素，而且还存储鬼魂条目；另一方面，右手向量只需要拥有当前处理器拥有的条目，因为我们所做的只是向其中写入，而不是从其中读取本地拥有的单元（当然，线性求解器会从其中读取，但它们并不关心自由度的几何位置）。
*


* [1.x.62]
*
* 下一步是计算悬挂节点和边界值的约束，我们将其合并为一个存储所有约束的对象。     
* 就像在%parallel中的所有其他事情一样，口头禅必须是没有一个处理器可以存储关于整个宇宙的所有信息。因此，我们需要告诉AffineConstraints对象哪些自由度可以存储约束条件，哪些自由度可能不需要存储任何信息。在我们的例子中，正如在[2.x.44]模块中所解释的，我们在每个处理器上需要关心的自由度是本地相关的自由度，所以我们把这个传递给[2.x.45]函数。顺便提一下，如果你忘记传递这个参数，AffineConstraints类将分配一个长度等于它目前看到的最大自由度索引的数组。对于MPI进程数较多的处理器，这可能是非常大的。
*
* - 可能是数十亿的数量级。然后，程序将为这个单一的数组分配比其他所有操作加起来还要多的内存。
*


* [1.x.63]
*
* 这个函数的最后一部分涉及到用伴随的稀疏模式初始化矩阵。和以前的教程程序一样，我们使用DynamicSparsityPattern作为中介，然后用它初始化系统矩阵。为了做到这一点，我们必须告诉稀疏模式它的大小，但如上所述，所产生的对象不可能为每个全局自由度存储哪怕一个指针；我们最好的希望是它能存储每个局部相关自由度的信息，即所有我们在组装矩阵的过程中可能接触到的自由度（[2.x.46]"分布式计算论文 "有很长的讨论，为什么我们真正需要局部相关自由度，而不是在这种情况下的小的局部活动自由度集）。     
* 所以我们告诉稀疏模式它的大小和要存储什么自由度，然后要求[2.x.47]来填充它（这个函数忽略了所有不属于本地的单元，模仿我们下面在装配过程中的做法）。在这之后，我们调用一个函数，在处理器之间交换这些稀疏模式的条目，以便最后每个处理器真正知道它将拥有的那部分有限元矩阵中的所有条目。最后一步是用稀疏模式初始化矩阵。
*


* [1.x.64]
*
* [1.x.65] [1.x.66]。


*
* 然后组装线性系统的函数相对来说比较无聊，几乎和我们之前看到的一模一样。需要注意的地方是。
*


*
* - 汇编必须只在本地拥有的单元格上循环。有多种方法来测试；例如，我们可以将一个单元的subdomain_id与三角形的信息进行比较，如<code>cell->subdomain_id() == triangulation.local_owned_subdomain()</code>，或者跳过所有条件<code>cell->is_ghost() || cell->is_artificial()</code>为真的单元。然而，最简单的方法是简单地询问单元格是否为本地处理器所拥有。
*


*
* - 将局部贡献复制到全局矩阵必须包括分配约束和边界值。换句话说，我们不能（就像我们在[2.x.48]中所做的那样）首先将每个局部贡献复制到全局矩阵中，然后在后面的步骤中才处理悬挂节点的约束和边界值。原因是，正如在[2.x.49]中所讨论的那样，一旦矩阵中的任意元素被组合到一起，并行矢量类就不能提供对这些元素的访问。
*
* - 部分原因是它们可能不再驻留在当前的处理器上，而是被运到了另一台机器上。
*


*
* - 我们计算右手边的方式（考虑到介绍中的公式）可能不是最优雅的，但对于重点在某个完全不同的地方的程序来说是可以的。
*


* [1.x.67]

* 注意，上面的装配只是一个局部操作。因此，为了形成 "全局 "的线性系统，需要在所有处理器之间进行同步。这可以通过调用函数compress()来实现。参见[2.x.50] "压缩分布式对象"，以了解更多关于compress()的设计目的。
*


* [1.x.68]
*
* [1.x.69] [1.x.70]。


*
* 尽管在可能是数以万计的处理器上求解线性系统到目前为止并不是一个微不足道的工作，但做这个的函数是
*
* - 至少在外部
*
* - 相对简单。大部分的部分你以前都见过。真正值得一提的只有两件事。



*
* - 求解器和预处理器是建立在PETSc和Trilinos功能的deal.II包装上的。众所周知，大规模并行线性求解器的主要瓶颈实际上不是处理器之间的通信，而是很难产生能够很好地扩展到大量处理器的预处理程序。在21世纪前十年的后半段，代数多网格（AMG）方法在这种情况下显然是非常有效的，我们将使用其中的一种方法。
*
* - 要么是Hypre软件包的BoomerAMG实现，可以通过PETSc接口，要么是由ML提供的预处理程序，它是Trilinos的一部分
*
* - 用于当前程序。其余的求解器本身是模板，之前已经展示过了。由于线性系统是对称和正定的，我们可以使用CG方法作为外解器。
*


*
* - 最终，我们希望有一个向量，不仅存储当前处理器拥有的自由度的解的元素，而且还存储所有其他本地相关的自由度。另一方面，求解器本身需要一个在处理器之间唯一分割的向量，没有任何重叠。因此，我们在这个函数的开头创建一个具有这些特性的向量，用它来求解线性系统，并在最后才将它分配给我们想要的向量。这最后一步确保所有的鬼魂元素也在必要时被复制。
*


* [1.x.71]
*
* [1.x.72] [1.x.73]。


*
* 估计误差和细化网格的函数又与 [2.x.51] 中的函数几乎完全一样。唯一不同的是，标志着要细化的单元格的函数现在是在命名空间 [2.x.52] 中。
*
* 这个命名空间中的函数可以在所有参与的处理器之间进行通信，并确定全局阈值，以决定哪些单元需要细化，哪些需要粗化。   
* 请注意，我们不必对KellyErrorEstimator类做任何特殊处理：我们只是给它一个向量，其元素数量与本地三角形的单元（本地拥有的单元、幽灵单元和人工单元）一样多，但它只填入那些对应于本地拥有的单元的条目。
*


* [1.x.74]
*
* [1.x.75] [1.x.76]。


*
* 与[2.x.53]中的相应函数相比，这里的函数要复杂一些。有两个原因：第一个原因是我们不只是想输出解决方案，还想输出每个单元的处理器（即它在哪个 "子域"）。其次，正如在[2.x.54]和[2.x.55]中详细讨论的那样，生成图形数据可能是并行化的一个瓶颈。在[2.x.56]中，我们将这一步骤从实际计算中移出，而是将其转移到一个单独的程序中，随后将各个处理器的输出合并到一个文件中。但这并不具规模：如果处理器的数量很大，这可能意味着在单个处理器上合并数据的步骤后来成为程序中运行时间最长的部分，或者它可能产生一个大到无法再可视化的文件。我们在这里遵循一个更合理的方法，即为每个MPI进程创建单独的文件，并将其留给可视化程序来理解。   
* 首先，函数的顶部看起来和平时一样。除了附加解决方案向量（有所有本地相关元素的条目，而不仅仅是本地拥有的元素）外，我们还附加一个数据向量，为每个单元存储该单元所属的子域。这稍微有点棘手，因为当然不是每个处理器都知道每个单元。因此，我们附加的向量有一个当前处理器在其网格中拥有的每个单元的条目（本地拥有的单元、幽灵单元和人工单元），但DataOut类将忽略所有对应于不属于当前处理器的单元的条目。因此，我们在这些向量条目中写入什么值实际上并不重要：我们只需用当前MPI进程的编号（即当前进程的子域_id）填充整个向量；这就正确地设置了我们关心的值，即对应于本地拥有的单元的条目，而为所有其他元素提供错误的值
*
* - 但无论如何这些都会被忽略。
*


* [1.x.77]

* 下一步是把这些数据写到磁盘上。在MPI-IO的帮助下，我们最多可并行写入8个VTU文件。此外，还产生了一个PVTU记录，它将写入的VTU文件分组。
*


* [1.x.78]
*
* [1.x.79] [1.x.80]。


*
* 控制程序整体行为的函数又和 [2.x.57] 中的函数一样。小的区别是使用[2.x.58]来输出到控制台（也见[2.x.59]），而且我们只在最多涉及32个处理器的情况下产生图形输出。如果没有这个限制，人们很容易在没有阅读程序的情况下粗心大意地运行这个程序，从而导致集群互连中断，并填满任何可用的文件系统 :-)   
* 与[2.x.60]的一个功能上的区别是使用了一个正方形的域，并且我们从一个稍细的网格开始（5个全局细化循环）。
*
* - 在4个单元上开始展示一个大规模的%并行程序并没有什么意义（尽管承认在1024上开始的意义只是稍微强一些）。
*


* [1.x.81]
*
* [1.x.82] [1.x.83]。


*
* 最后的函数，[2.x.61] ，同样具有与所有其他程序相同的结构，特别是 [2.x.62] 。像其他使用MPI的程序一样，我们必须初始化和最终确定MPI，这是用辅助对象[2.x.63]完成的，该类的构造函数也初始化了依赖MPI的库，如p4est、PETSc、SLEPc和Zoltan（尽管最后两个在本教程中没有使用）。这里的顺序很重要：在这些库被初始化之前，我们不能使用它们，所以在创建[2.x.64]的实例之前做任何事情都没有意义。
*


* 在求解器完成后，LaplaceProblem解构器将运行，然后是[2.x.65]这个顺序也很重要：[2.x.66]调用[2.x.67]（以及其他库的最终确定函数），这将删除任何正在使用的PETSc对象。这必须在我们解构拉普拉斯求解器之后进行，以避免双重删除错误。幸运的是，由于C++的析构器调用顺序规则，我们不需要担心这些：一切都以正确的顺序发生（即，与构造顺序相反）。由[2.x.68]调用的最后一个函数是[2.x.69] : 也就是说，一旦这个对象被解构，程序就应该退出，因为MPI将不再可用。
*


* [1.x.84]
* [1.x.85][1.x.86] 。


* 当你在单个处理器上或在几个本地MPIinstallation上运行该程序时，你应该得到这样的输出。
* [1.x.87]
*
* 确切的数字是不同的，取决于我们使用多少个处理器；这是由于预处理程序取决于问题的分区，然后解决方案在最后的几个数字上有所不同，因此，网格细化也略有不同。这就保证了我们可以有效地解决最大的问题。
* 当在足够多的机器上运行时（比如几千台），这个程序可以相对容易地在不到一分钟内解决超过10亿个未知数的问题。另一方面，这样的大问题不能再被视觉化，所以我们也在只有16个处理器的情况下运行这个程序。下面是一个网格，以及它在16个处理器上的分区，和相应的解决方案。
* [2.x.70]
* 左边的网格仅有7,069个单元。当然，这个问题我们可以很容易地在单处理器上用[2.x.71]来解决，但这个程序的重点是展示如何编写一个可以扩展到更多机器的程序。例如，这里有两张图，显示了如果我们使用越来越多的处理器，程序中大量部分的运行时间是如何在5200万和37500万自由度的问题上进行扩展的（这些图和接下来的几张图取自[2.x.72]"分布式计算论文 "的早期版本；显示在更多处理器上运行数据的更新图，以及更多的解释可以在该论文的最终版本中找到）。
* [2.x.73]
* 可以清楚地看到，该程序可以很好地扩展到非常大的处理器数量。（关于我们认为的 "可扩展 "程序的讨论，见[2.x.74曲线，特别是线性求解器，在图形的右端变得有点摇摆不定，因为每个处理器的工作量太小，无法抵消通信成本(在上述两个例子中，每个处理器要解决的整个问题的部分，在使用4,096个处理器时，只有13,000和90,000个自由度；一个好的经验法则是，如果每个处理器至少有100,000个未知数，并行程序就会运行良好)。
* 虽然上面的强扩展图显示，如果我们使用越来越多的处理器，我们可以越来越快地解决一个固定规模的问题，但更有趣的问题可能是，问题可以变得多大，以便它们仍然可以在一个特定规模的机器上的合理时间内得到解决。我们在下面两张256和4096处理器的图表中展示了这一点。
* [2.x.75]
* 这些图表显示，程序的所有部分都随着自由度的增加而呈线性增长。这一次，由于局部问题的大小太小，线条在左边摇摆不定。关于这些结果的更多讨论，请参考[2.x.76]"分布式计算论文"。
* 那么，一个人能够解决的最大问题是多大呢？在写这个问题的时候，限制因素是程序使用了[1.x.88]中的BoomerAMG代数多重网格方法作为预处理程序，不幸的是它使用有符号的32位整数来索引%分布式矩阵的元素。这将问题的大小限制在[2.x.77]个自由度。从上面的图表中可以看出，可扩展性会超过这个数字，而且人们可以预期，给定超过上面显示的4096台机器也会进一步减少计算时间。这就是说，我们当然可以期待这个限制最终会被前面的开发者解除。
* 另一方面，这并不意味着deal.II不能解决更大的问题。事实上，[2.x.78]展示了如何解决不只是一点点，而是大大超过我们在这里展示的任何问题。
*


* [1.x.89][1.x.90][1.x.91] 。


* 从某种意义上说，这个程序是拉普拉斯方程的终极解算器：只要你有足够的处理器可用，它基本上可以解出你想要的任何精度。由于拉普拉斯方程本身在这种精度水平上并不十分有趣，因此，更有趣的扩展可能性不在于这个程序，而在于它之外的东西。例如，本教程中的其他几个程序都有相当长的运行时间，特别是在3D中。因此，使用这里解释的技术来扩展其他程序以支持并行的分布式计算将是有趣的。我们在[2.x.80]教程程序中对[2.x.79]做了这样的处理，但同样的做法也适用于，例如，[2.x.81]和[2.x.82]的双曲时间相关问题，[2.x.83]的气体动力学，或[2.x.84]的纳维尔-斯托克斯方程。
* 也许同样有趣的是后处理的问题。如上所述，我们只展示了16个处理器的解和网格的图片，因为4,096个处理器解决10亿个未知数会产生几万亿字节的图形输出。目前，没有任何程序能够以任何合理的方式将这一数量的数据可视化，除非它也在至少几百个处理器上运行。然而，也有一些方法，可视化程序直接与每个处理器上的求解器进行通信，每个可视化程序渲染由该处理器上的求解器计算的场景部分。实现这样的接口，可以快速地将那些在其他方面不适合用图形显示的东西可视化。
*

* [1.x.92][1.x.93] [2.x.85] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-4_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18]
*[1.x.19][1.x.20][1.x.21] 。


* [2.x.2]
* deal.II有一个独特的功能，我们称之为 "无维度编程"。你可能已经注意到在前面的例子中，许多类在角括号中附加了一个数字。这是为了表明，例如，二维和三维空间的三角计算是不同的，但是相关的数据%类型。我们也可以把它们称为[2.x.3]，而不是[2.x.4]和[2.x.5]来命名这两个类，但这有一个重要的缺点：假设你有一个功能完全相同的函数，但在二维或三维三角上，取决于我们现在想在哪个维度上解决方程（如果你不相信一个函数在所有维度上都做同样的事情是常见的情况，就看看下面的代码吧
*
*--2D和3D之间几乎没有区别！）。)我们将不得不把同一个函数写两次，一次在[2.x.6]上工作，一次在[2.x.7]上工作。这在编程中是一个不必要的障碍，并且导致了保持两个函数同步的麻烦（最好是），或者在两个版本不同步时难以发现错误（最坏的情况是；这可能是更常见的情况）。
*


*

* 这种障碍可以通过使用C++语言提供的一些模板魔法来规避：模板化的类和函数并不是真正的类或函数，而只是取决于一个尚未定义的数据类型参数或一个在定义时也是未知的数值的模式。然而，如果你向它提供所需的信息，编译器可以从这些模板中建立适当的类或函数。当然，模板的某些部分可以依赖于模板参数，它们将在编译时针对特定的模板参数进行解决。例如，考虑下面这段代码。
* [1.x.22]
*
*

*
* 在编译器看到这个函数的时候，它对[2.x.8]的实际值并不了解。编译器唯一拥有的是一个模板，也就是一个蓝图，用来生成函数[2.x.9]，如果给定[2.x.10]的特定值为未知值，编译器目前没有可以生成的代码。
*

*
* 然而，如果后来编译器会遇到看起来像这样的代码，比如说。
* [1.x.23]
* 那么编译器将推断出[2.x.11]是为[2.x.12]而请求的函数，并将上面的模板编译成一个到处都用2代替dim的函数，也就是说，它将编译这个函数，就好像它被定义为
* [1.x.24]
*
*

*
* 然而，值得注意的是，函数[2.x.13]也取决于维度，所以在这种情况下，编译器将调用函数[2.x.14]，而如果dim是3，它将调用[2.x.15]，这可能是（而且实际上是）一个完全不相关的函数。
*

*
* 同样可以用成员变量来做。考虑一下下面的函数，它可能反过来调用上面的函数。
* [1.x.25]
* 这个函数有一个类型为[2.x.16]的成员变量。同样，编译器在知道哪个维度之前不能编译这个函数。如果你像上面那样为一个特定的维度调用这个函数，编译器将采取模板，用它所调用的维度替换所有出现的dim，并编译它。如果你为不同的维度多次调用该函数，它将多次编译，每次都调用正确的[2.x.17]函数，并为成员变量保留适当数量的内存；注意，[2.x.18]的大小可能，而且确实取决于空间维度。
*

*
* deal.II库是围绕这个维度无关的编程概念建立的，因此允许你以一种不需要区分空间维度的方式进行编程。应该注意的是，只有极少数地方需要使用[2.x.19]es来实际比较维度。然而，由于编译器必须为每个维度单独编译每个函数，即使在编译时它知道[2.x.20]的值，因此能够优化掉[2.x.21]语句和未使用的分支。
*

*
* 在这个例子中，我们将展示如何进行不依赖于维度的编程（事实上，这比你必须关心维度还要简单），我们将把上一个例子中的拉普拉斯问题扩展到一个可以同时在两个和三个间隔维度上运行的程序。其他的扩展是使用非常数的右侧函数和非零的边界值。
*

*
* [2.x.22] 在使用模板时，C++规定了各种各样的语法限制，这使得人们有时很难理解为什么某些东西必须这样写。一个典型的例子是在很多地方都需要使用关键字[2.x.23]。如果你对这个问题还不完全熟悉，那么在[1.x.26]中链接的deal.IIF常见问题（FAQ）中解释了其中的几个困难。
* <！--我们需要一个空行来正确地结束上述块。
*

* [1.x.27] [1.x.28]。
* [1.x.29] [1.x.30]。


*
* 前面几个（很多）include文件已经在前面的例子中使用过了，所以我们在这里不再解释它们的含义。
*


* [1.x.31]
*
* 这是新的，然而：在前面的例子中，我们从线性求解器得到了一些不需要的输出。如果我们想抑制它，我们必须包括这个文件，并在程序的某个地方添加一行字（见下面的main()函数）。
*


* [1.x.32]
*
* 最后一步，和以前的程序一样，是把所有deal.II的类和函数名导入全局命名空间。
*


* [1.x.33]
*
* [1.x.34] [1.x.35]。


*
* 这又是一个与前面例子中相同的[2.x.24]类。唯一不同的是，我们现在把它声明为一个带有模板参数的类，而模板参数当然是我们想要解决拉普拉斯方程的空间尺寸。当然，几个成员变量也取决于这个维度，特别是Triangulation类，它必须分别表示四边形或六面体。除此以外，一切都和以前一样。
*


* [1.x.36]
*
* [1.x.37] [1.x.38]。


*
* 在下文中，我们又声明了两个类，分别表示右手边和非均质Dirichlet边界值。两者都是一个二维空间变量的函数，所以我们也把它们声明为模板。
*

*
* 这些类中的每一个都是从一个共同的、抽象的基类Function派生出来的，它声明了所有函数都必须遵循的共同接口。特别是，具体的类必须重载[2.x.25]函数，该函数将二维空间中的一个点作为参数，并将该点的值作为一个[2.x.26]变量返回。
*

*
* [2.x.27]函数需要第二个参数，我们在这里将其命名为[2.x.28] ：这只适用于向量值函数，你可能想访问向量的某个分量，在[2.x.29]点。然而，我们的函数是标量的，所以我们不需要担心这个参数，在函数的实现中也不会使用它。在库的头文件中，Function基类对[2.x.30]函数的声明中，分量的默认值为0，所以我们在访问右手边的[2.x.31]函数时，只需要一个参数，即我们要评估函数的点。然后，对于标量函数，可以简单地省略分量的值。
*


* 函数对象在库中很多地方都有使用（例如，在[2.x.32]中，我们用[2.x.33]实例作为[2.x.34]的参数，这是第一个我们定义继承于Function的新类的教程。由于我们只调用过[2.x.35]，所以我们可以只用一个普通的函数（这也是[2.x.36]中的做法），但由于这是一个教程，为了举例说明，我们继承了Function。
*


* [1.x.39]
*
* 如果你不熟悉上述函数声明中的关键字 "virtual "和 "override "是什么意思，你可能会想看看你最喜欢的C++书籍或在线教程，如http://www.cplusplus.com/doc/tutorial/polymorphism/ 。从本质上讲，这里发生的事情是Function<dim>是一个 "抽象 "基类，它声明了某种 "接口"
*
* - 一组可以在这类对象上调用的函数。但它实际上并没有实现*这些函数：它只是说 "Function对象是这样的"，但它实际上是什么类型的函数，则留给实现了`value()'函数的派生类。
*

*
* 从一个类派生出另一个类，通常被称为 "is-a "关系函数。在这里，`RightHandSide`类 "是一个 "Function类，因为它实现了Function基类所描述的接口。("value() "函数的实际实现在下面的代码块中)。那么`virtual`关键字意味着 "是的，这里的函数可以被派生类覆盖"，而`override`关键字意味着 "是的，这实际上是一个我们知道已经被声明为基类一部分的函数"。覆盖 "关键字不是严格必要的，但它是防止打字错误的一个保险。如果我们把函数的名字或一个参数的类型弄错了，编译器会警告我们说："你说这个函数覆盖了基类中的一个函数，但我实际上不知道有任何这样的函数有这个名字和这些参数。"
*

*
* 但回到这里的具体案例。在本教程中，我们选择二维中的函数[2.x.37]，或三维中的[2.x.38]作为右手边。我们可以用空间维度上的if语句来写这个区别，但这里有一个简单的方法，通过使用一个短循环，也可以让我们在一维（或四维，如果你想这样做的话）中使用同一个函数。  幸运的是，编译器在编译时就知道循环的大小（记住，在你定义模板时，编译器不知道[2.x.39]的值，但当它后来遇到语句或声明[2.x.40]时，它将采取模板，用2替换所有出现的dim，并编译出结果函数）。  换句话说，在编译这个函数的时候，主体将被执行的次数是已知的，编译器可以将循环所需的开销降到最低；结果将和我们马上使用上面的公式一样快。
*

*
* 最后要注意的是，[2.x.41]表示二维空间中的一个点，它的各个组成部分（即[2.x.42]、[2.x.43]、...坐标）可以使用（）运算符访问（事实上，[]运算符也可以工作），索引从零开始，就像C和C++中通常的那样。
*


* [1.x.40]
*
* 作为边界值，我们在二维选择[2.x.44]，在三维选择[2.x.45]。这恰好等于从原点到我们想评估函数的点的矢量的平方，而不考虑维度。因此，这就是我们的回报。
*


* [1.x.41]
*
* [1.x.42] [1.x.43]。


*
* 接下来是利用上述函数的类模板的实现。和以前一样，我们将把所有东西都写成模板，这些模板有一个形式参数[2.x.46]，我们在定义模板函数的时候假定是未知的。只有在以后，编译器才会发现[2.x.47]函数的声明，实际上），并在编译整个类时将[2.x.48]替换为2，这个过程被称为 "模板的实例化"。这样做的时候，它也会用[2.x.50]替换[2.x.49]的实例，并从类模板中实例化后一个类。
*

*
* 事实上，编译器也会在[2.x.52]中发现一个声明[2.x.51]。这将导致它再次回到一般的[2.x.53]模板，替换所有出现的[2.x.54]，这次是3，并第二次编译这个类。请注意，两个实例[2.x.55]和[2.x.56]是完全独立的类；它们唯一的共同特征是它们都是从同一个通用模板中实例化出来的，但它们不能相互转换，例如，它们没有共享代码（两个实例都是完全独立编译的）。
*



*
* [1.x.44] [1.x.45]。


*
* 在这个介绍之后，这里是[2.x.57]类的构造函数。它指定了所需的有限元的多项式程度，并将DoFHandler与三角形关联起来，就像前面的例子程序一样， [2.x.58] 。
*


* [1.x.46]
*
* [1.x.47] [1.x.48]。


*
* 网格的创建在本质上是依赖于维度的东西。然而，只要领域在二维或三维中足够相似，库就可以为你抽象出来。在我们的例子中，我们想再次在二维的正方形[2.x.59]上求解，或者在三维的立方体[2.x.60]上求解；两者都可以被称为[2.x.61]，因此我们可以在任何维度上使用同一个函数。当然，在二维和三维中创建超立方体的函数有很大的不同，但这是你不需要关心的事情。让库来处理这些困难的事情。
*


* [1.x.49]
*
* [1.x.50] [1.x.51]。


*
* 这个函数看起来和前面的例子完全一样，尽管它执行的动作在细节上有很大不同，如果[2.x.62]刚好是3的话。从用户的角度来看，唯一显著的区别是所产生的单元格的数量，在三个空间维度上比两个空间维度上要高得多！**。
*


* [1.x.52]
*
* [1.x.53] [1.x.54]。


*
* 与前面的例子不同，我们现在想使用一个非恒定的右手函数和非零边界值。这两个任务都很容易实现，只需在矩阵和右手边的组合中增加几行代码即可。
*

*
* 更有趣的是，我们将矩阵和右手边的向量维度独立起来的方式：与二维的情况根本没有区别。由于这个函数中使用的重要对象（正交公式、FEValues）也是通过模板参数的方式依赖维度的，它们可以为这个函数所编译的维度正确设置一切。通过使用模板参数声明所有可能依赖维度的类，库可以为你完成几乎所有的工作，你不必关心大多数事情。
*


* [1.x.55]
*
* 我们希望有一个非恒定的右手，所以我们使用上面声明的类的一个对象来生成必要的数据。由于这个右手对象只在本函数中局部使用，所以我们在这里把它声明为一个局部变量。
*


* [1.x.56]
*
* 与之前的例子相比，为了评估非恒定右手函数，我们现在还需要我们目前所在单元上的正交点（之前我们只需要FEValues对象中的形状函数的值和梯度，以及正交权重，[2.x.63]）。我们可以通过给FEValues对象添加#update_quadrature_points标志来让它为我们做事。
*


* [1.x.57]

* 然后我们再次定义与前面程序中相同的缩写。这个变量的值当然取决于我们目前使用的维度，但是FiniteElement类为你做了所有必要的工作，你不必关心与维度有关的部分。
*


* [1.x.58]
*
* 接下来，我们又要对所有的单元格进行循环，并对局部贡献进行组合。  请注意，一个单元在两个空间维度上是一个四边形，但在三维上是一个六面体。事实上，[2.x.64]的数据类型是不同的，这取决于我们所处的维度，但对外界来说，它们看起来是一样的，你可能永远不会看到有什么区别。在任何情况下，真正的类型是通过使用`auto`来隐藏的。
*


* [1.x.59]
*
* 现在我们要组装本地矩阵和右手边。这个过程和前面的例子完全一样，但是现在我们重新调整循环的顺序（我们可以安全地这样做，因为它们是相互独立的），并尽可能地合并局部矩阵和局部向量的循环，以使事情变得更快。       
* 组装右侧呈现出与我们在[2.x.65]中的做法的唯一显著区别：我们没有使用值为1的常数右侧，而是使用代表右侧的对象，并在正交点对其进行评估。
*


* [1.x.60]
*
* 作为对这些循环的最后说明：当我们将局部贡献集合到[2.x.66]时，我们必须将形状函数[2.x.67]和[2.x.68]在点号q_index的梯度相乘并与标量权重JxW相乘。这就是实际发生的情况。  [2.x.69]返回一个[2.x.70]维向量，由[2.x.71]对象表示，将其与[2.x.72]的结果相乘的运算器*确保两个向量的[2.x.73]分量被适当收缩，结果是一个标量浮点数，然后与权重相乘。在内部，这个操作符*确保对向量的所有[2.x.74]分量都能正确发生，无论[2.x.75]是2、3还是其他空间维度；从用户的角度来看，这并不值得费心，然而，如果想独立编写代码维度，就会使事情简单得多。
*

*
* 随着本地系统的组装，转移到全局矩阵和右手边的工作与之前完全一样，但在这里我们再次合并了一些循环以提高效率。
*


* [1.x.61]

* 作为这个函数的最后一步，我们希望在这个例子中拥有非同质的边界值，与之前的例子不同。这是一个简单的任务，我们只需要用一个描述我们想使用的边界值的类的对象（即上面声明的[2.x.77]类）来取代那里使用的[2.x.76]。
* 函数[2.x.78]只对标有边界指标0的面起作用（因为我们在下面的第二个参数中说这个函数应该对其起作用）。如果有的面的边界指标不是0，那么函数interpolate_boundary_values将对这些面不起作用。对于拉普拉斯方程来说，什么都不做相当于假设在边界的这些部分，零诺伊曼边界条件成立。
*


* [1.x.62]
*
* [1.x.63] [1.x.64]。


*
* 解决线性方程组是大多数程序中看起来几乎相同的事情。特别是，它与维度无关，所以这个函数是从前面的例子中逐字复制的。
*


* [1.x.65]
*
* 不过我们做了一个补充：由于我们抑制了线性求解器的输出，我们必须手工打印迭代次数。
*


* [1.x.66]
*
* [1.x.67] [1.x.68]。


*
* 这个函数也做了 [2.x.79] 中相应的函数。这里也没有改变维度的独立性。
*


* 由于该程序将同时运行2d和3d版本的拉普拉斯求解器，我们使用文件名中的维度为每次运行生成不同的文件名（在一个更好的程序中，会检查[2.x.80]是否可以有2或3以外的其他值，但为了简洁起见，我们在这里忽略了这一点）。
*


* [1.x.69]
*
* [1.x.70] [1.x.71]。


*
* 这是一个对所有事情都有最高级别控制的函数。除了一行额外的输出外，它与前面的例子相同。
*


* [1.x.72]
*
* [1.x.73] [1.x.74]。


*
* 而这就是主函数。它看起来也大多像[2.x.81]，但如果你看看下面的代码，注意我们是如何首先创建一个[2.x.82]类型的变量（迫使编译器用[2.x.83]编译类模板）并运行一个2d模拟，然后我们用3d做整个事情的。
*

*
* 在实践中，这可能不是你经常做的事情（你可能要么想解决一个2D问题，要么想解决一个3D问题，但不会同时解决这两个问题）。然而，它展示了一种机制，我们可以在一个地方简单地改变我们想要的维度，从而迫使编译器为我们要求的维度重新编译独立的类模板。这里的重点在于，我们只需要改变一个地方。这使得在计算速度较快的2D环境下调试程序变得非常简单，然后将一个地方切换到3，在3D环境下运行计算量更大的程序，进行 "真实 "计算。
*

*
* 这两个块中的每一个都用大括号括起来，以确保[2.x.84]变量在我们继续为三维问题分配内存之前就已经超出了范围（并释放了它所持有的内存）。如果没有额外的大括号，[2.x.85]变量只会在函数结束时被销毁，也就是在运行3d问题之后，并且会在3d运行时不必要地占用内存。
*


* [1.x.75]
* [1.x.76][1.x.77] 。


*
* 程序的输出看起来如下（迭代次数可能会有一到两次的变化，这取决于你的计算机，因为这往往取决于浮点运算的舍入精度，这在不同的处理器中是不同的）。
* [1.x.78]
* 很明显，在三个空间维度中，单元的数量和自由度的数量都要高得多。这里看不到的是，除了矩阵的行数和列数较多之外，在三个空间维度中，矩阵的每行条目也明显增多。这就导致了解方程组时需要付出更多的数值努力，当你实际运行程序时，你可以从两个解算步骤的运行时间中感受到这一点。
*


*该程序产生两个文件。  [2.x.86]和[2.x.87]，可以用VisIt或Paraview程序查看（如果你没有这些程序，你可以很容易地在程序中改变输出格式，以便你能更容易地查看）。解决方案的可视化是一门艺术，但它也可以是一种乐趣，你应该玩玩你最喜欢的可视化工具，熟悉它的功能。下面是我想出的2d解决方案。
* [2.x.88]
* ( [2.x.89] 图中显示了所考虑的问题的解决方案，是一个三维图。可以看出，该解在域的内部几乎是平的，而在边界附近有一个较高的曲率。当然，这是因为对于拉普拉斯方程来说，解的曲率等于右手边，而右手边被选为四次方多项式，在内部几乎为零，只有在接近域的边界时才急剧上升；右手边函数的最大值在域的角落，在那里解的移动也最迅速。很高兴看到解沿着域的边界遵循所需的二次边界值，这也是很好的。关于这一技术的解释，见[2.x.90] 。
* 另一方面，尽管图片中没有明确显示网格线，但你可以看到它们在解中的小结点。这清楚地表明，该解没有被计算到非常高的精度，为了得到更好的解，我们可能需要在更细的网格上进行计算。
* 在三个空间维度上，可视化是比较困难的。左图显示了解决方案和它在域的表面上计算的网格。这很好，但它的缺点是完全掩盖了内部的情况。右边的图片是通过显示解的恒定值的表面（如左上角的图例所示），试图将内部情况也可视化。如果我们把各个表面做得稍微透明一些，就有可能看穿它们，看到后面的东西，这样的等值面图看起来就最好。
* [2.x.91]
* [2.x.92] 关于可视化的最后一句话：可视化的理念是提供洞察力，这与显示信息是不同的。特别是，在一张图片上超载信息是很容易的，但在显示更多信息的同时，也会使人们更难获得洞察力。举个例子，我用来生成这些图片的程序，VisIt，默认情况下在每个轴上都有刻度线，在[2.x.93]轴上贴上一个大的标签 "X轴"，其他轴也类似，在左上方显示数据的文件名，在右下方显示用户的名字以及时间和日期。这一点在这里并不重要：轴同样容易辨认，因为左下角的三脚架仍然可见，而且我们从程序中知道域是[2.x.94]，所以不需要打钩标记。因此，我关掉了图片中所有不相干的东西：可视化的艺术就是把图片缩减到那些重要的部分，以看到人们想要看到的东西，而不是更多。
*


* [1.x.79][1.x.80][1.x.81] 。



* 本质上，玩弄程序的可能性与前一个程序相同，只是它们现在也适用于3d案例。为了获得灵感，请阅读[1.x.82]。
*

* [1.x.83][1.x.84] [2.x.95]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-41_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27]
* [2.x.2]
* [1.x.28]


*[1.x.29][1.x.30][1.x.31]


* 这个例子是基于二维的拉普拉斯方程，涉及的问题是，如果一个膜受到某种外力的偏转，但同时也受到障碍物的限制，会发生什么？换句话说，想想一个弹性膜在边界处被夹在一个矩形框架上（我们选择[2.x.3]），由于重力作用而下垂。如果膜下有一个障碍物，阻止它达到平衡位置，如果重力是唯一存在的力，现在会发生什么？在目前的例子程序中，我们将考虑在膜下有一个空气台阶的障碍物，重力将膜推到上面。
* 这个问题通常被称为 "障碍物问题"（也见[1.x.32]），它的结果是一个变量不等式，而不是一个弱化形式的变量方程。我们将在下面从经典公式中推导出它，但在我们继续讨论数学之前，让我们展示一下我们将在本教程中考虑的问题的解决方案，以获得一些我们应该期待的直觉。
* [2.x.4]
* 这里，在左边，我们看到膜的位移。下面的障碍物的形状是清晰可见的。在右边，我们叠加了膜的哪些部分与障碍物接触。我们以后会把这组点称为 "活动集"，以表明这里有一个不等式约束是活动的。
*

*[1.x.33][1.x.34]


*该问题的经典表述拥有以下形式。
* [1.x.35]
*与[2.x.5] 。   2.x.6]是一个标量值函数，表示膜的垂直位移。第一个方程被称为平衡条件，有一个面积密度为 [2.x.7] 的力。在这里，我们将考虑这个力是重力。第二个方程被称为胡克定律，即应力[2.x.8]与位移[2.x.9]的梯度成正比（比例常数，通常用[2.x.10]表示，在这里被设定为1，但不失为一般性的；如果它是常数，它可以被放入右手边的函数）。在边界，我们有零迪里希条件。很明显，前两个方程可以结合起来得到[2.x.11]。
* 直观地说，重力作用是向下的，所以[2.x.12]是一个负函数（我们在这个程序中选择[2.x.13]）。那么第一个条件意味着作用在膜上的总力是重力加上一些正值：即障碍物在它们两个接触的地方对膜施加的向上的力。这个额外的力有多大？我们还不知道（我们也不知道它实际作用的 "位置"），但它必须使膜不能穿透障碍物。
* 上面的第四个等式和最后一个不等式构成了障碍条件，它必须在整个领域的每一点上都成立。这两个条件中的后者意味着膜必须在任何地方都高于障碍物[2.x.14]。第二个到最后一个方程，通常被称为 "互补条件"，说的是在膜不与障碍物接触的地方（即那些[2.x.15]和[2.x.16]的地方），那么[2.x.17]在这些地方；换句话说，在那里没有额外的力作用，正如预期的那样。另一方面，在[2.x.18]的地方，我们可以有[2.x.19]，也就是说，可以有额外的力（尽管不一定要有：膜有可能只是接触而不是压住障碍物）。
*

*[1.x.36][1.x.37]


* 获得障碍问题的变异表述的一个明显方法是考虑总势能：[1.x.38] 。
* 我们必须找到以下最小化问题的解[2.x.20]：[1.x.39] 。
*用可接受位移的凸集：[1.x.40] 。
* 这个集合照顾到了上面的第三和第五个条件（边界值和互补性条件）。
* 现在考虑[2.x.22]的最小化器[2.x.21]和任何其他函数[2.x.23] 。那么函数[1.x.41]的
*在[2.x.24]处取最小值（因为[2.x.25]是能量函数[2.x.26]的最小值），因此，对于任何选择[2.x.28]的情况，[2.x.27]。请注意，[2.x.29]是因为[2.x.30]的凸性。如果我们计算出[2.x.31]，就会得到我们要寻找的变分公式。
*[1.x.42][1.x.43] 。
*
* 这就是典型的变分不等式的形式，在双线性形式中不仅有[2.x.32]出现，而且还有[2.x.33]。原因是这样的：如果[2.x.34]不受约束，那么我们可以在[2.x.36]中找到测试函数[2.x.35]，从而使[2.x.37]可以有任何符号。通过选择测试函数[2.x.38]使[2.x.39]，我们可以推断出，如果两边实际上是相等的，那么不等式只能对[2.x.40]和[2.x.41]都成立，也就是说，我们得到一个变异的相等。
* 另一方面，如果[2.x.42]，那么[2.x.43]只允许检验函数[2.x.44]，所以事实上[2.x.45] 。这意味着我们不能像上面那样用[2.x.46]和[2.x.47]来测试这个方程，所以我们不能再得出两边实际上相等的结论。因此，这就模拟了我们在上面讨论互补条件的方式。
*


*[1.x.44][1.x.45]


* 上面的变分不等式是很难处理的。因此，我们希望将其重新表述为一个等价的鞍点问题。我们引入一个拉格朗日乘子[2.x.48]和拉格朗日乘子[2.x.51]、[2.x.52]的凸锥[2.x.49]、[2.x.50]对偶空间，其中[2.x.53]表示[2.x.54]和[2.x.55]之间的对偶性。直观地说，[2.x.56]是所有 "非正函数 "的锥体，但[2.x.57]除外，因此也包含除正函数之外的其他对象。
* [1.x.46]
* [1.x.47]
* [1.x.48]
* [1.x.49]
* 换句话说，我们可以把[2.x.58]看作是障碍物对膜施加的额外正向力的负数。上面陈述的第二行中的不等式似乎只有错误的符号，因为我们在[2.x.60]的地方有[2.x.59]，鉴于[2.x.61]的定义。
* 这个鞍点问题的[2.x.62]的存在性和唯一性已经在Glowinski, Lions and Tr&eacute;moli&egrave;res:Numerical Analysis of VariationalInequalities, North-Holland, 1981.
*


*[1.x.50][1.x.51]


* 有不同的方法来解决变量不等式。作为一种可能性，你可以将鞍点问题理解为一个具有不平等约束的凸二次方程序（QP）。
* 为了达到这个目的，让我们假设我们用相同的有限元空间来离散[2.x.63]和[2.x.64]，例如，通常的[2.x.65]空间。我们将得到方程[1.x.52]。
* 其中[2.x.66]是所选有限元空间上的质量矩阵，上述指数[2.x.67]是位于域内部的自由度集合[2.x.68]中的所有自由度（我们在周边有迪里希条件）。然而，如果我们在组合产生这个质量矩阵的所有条款时使用一个特殊的正交规则，即一个正交公式，其中正交点只位于定义了形状函数的插值点；由于除了一个形状函数外，所有的形状函数在这些位置都是零，我们得到一个对角线质量矩阵，即
* [1.x.53]
* 为了定义[2.x.69]，我们使用与[2.x.70]相同的技术。换句话说，我们定义了
* [1.x.54]
*其中[2.x.71]是[2.x.72]的一个合适的近似值。然后，[2.x.73]和[2.x.74]定义中的积分由梯形规则近似。
*
* 现在我们为每个自由度[2.x.75]定义函数[1.x.56] 。
* 在这个程序中我们选择[2.x.77]。这是一种惩罚性参数，取决于问题本身，需要选择足够大的参数；例如，如果我们使用7个全局细化，使用当前程序对[2.x.78]没有收敛作用）。)
* 经过一番挠头，人们可以说服自己，上面的不等式可以等效地改写为[1.x.57] 。
* 我们在这里将使用的原始-双重活动集策略是一个迭代方案，它基于这个条件来预测下一个活动集和非活动集[2.x.79]和[2.x.80]（即那些指数[2.x.81]的互补集，对于这些指数[2.x.82]要么等于要么不等于障碍物的值[2.x.83]）。关于这种方法的更深入的处理，见Hintermueller, Ito, Kunisch:The primal-dual active setstrategy as a semismooth newton method, SIAM J. OPTIM., 2003, Vol. 13, No. 3,pp.865-888.
*[1.x.58][1.x.59]
*

* 初级-二级主动集方法的算法工作如下（注：[2.x.84] ）。
* 1. 初始化[2.x.85]和[2.x.86] ，使[2.x.87]和[2.x.88]并设置[2.x.89] .2.找出满足以下条件的原始-双数对[2.x.90]： 1.


* [1.x.60]
* 注意第二和第三条件意味着恰恰是[2.x.91]的未知数是固定的，第一个条件产生了确定[2.x.93]和[2.x.94]所需的其余[2.x.92]方程 .3。用[1.x.61]定义新的活动和非活动集。
* 4. 如果[2.x.95]（然后，显然也是[2.x.96]），则停止，否则设置[2.x.97]并转到步骤（2）。
* 该方法被称为 "原始-双重"，因为它同时使用原始变量（位移[2.x.98]）和双重变量（拉格朗日乘数[2.x.99]）来确定下一个活动集合。
* 在本节的最后，让我们补充两点意见。首先，对于任何满足条件的原始-对偶[2.x.100]，我们可以区分以下几种情况。
* 1. [2.x.101]（i active）。   [2.x.102] 然后要么是[2.x.103]和[2.x.104]（渗透），要么是[2.x.105]和[2.x.106]（压载）。  [2.x.107] (i不活动)。   [2.x.108] 然后是[2.x.109]和[2.x.110]（无接触）或[2.x.111]和[2.x.112]（解压负荷）。
* 其次，上面的方法从直觉上看是正确的，也是有用的，但有点临时性。然而，它可以通过以下方式简明地推导出来。为此，请注意，我们要解决非线性系统[1.x.62] 。
* 我们可以通过始终围绕前一个iterate进行线性化（即应用牛顿方法）来迭代求解，但为此我们需要将不可微调的函数[2.x.113]线性化。也就是说，它是可微的，事实上我们有[1.x.63] 。
* [1.x.64]
* 这表明一个半光滑的牛顿步骤的形式[1.x.65] 。
* 在这里，我们以自然的方式将矩阵[2.x.114]和向量分割开来，其索引属于活动集[2.x.115]或非活动集[2.x.116]。
* 我们也可以通过设置[2.x.118]和[2.x.119]并将所有已知项带到右边来解决我们感兴趣的变量，而不是求解更新[2.x.117]。这就得到了[1.x.66]。
* 这些是上面基本算法描述中概述的方程。
* 我们甚至可以更进一步。很容易看到，我们可以消除第三行和第三列，因为它意味着[2.x.120] :[1.x.67] 。
* 这表明，事实上我们只需要解决位于活动集上的拉格朗日乘数。通过考虑第二行，我们可以通过[1.x.68]恢复全部拉格朗日乘数矢量。
* 由于第三行和[2.x.121]是一个对角线矩阵的事实，我们能够直接计算出[2.x.122]。因此，我们也可以把这个线性系统写成如下：[1.x.69] 。
* 幸运的是，这种形式很容易得到：我们只需建立通常的拉普拉斯线性系统[1.x.70] 。
* 然后让AffineConstraints类消除所有受限的自由度，即[2.x.123]，其方式与[2.x.124]中的自由度是Dirichlet数据一样。结果线性系统（上面倒数第二条）是对称的和正无限的，我们用CG方法和Trilinos的AMG预处理程序来解决它。
*

*[1.x.71][1.x.72]


* 本教程与[2.x.125]十分相似。程序的总体结构遵循[2.x.126]，但有细微差别。
*
* - 我们需要两个新方法， [2.x.127] 和 [2.x.128] 。
*
* - 我们需要新的成员变量来表示我们这里的约束。
*
* - 我们改变求解器的预处理程序。
*

* 如果你想了解当前的程序，你可能想阅读一下[2.x.129]。
*

* [1.x.73] [1.x.74]。
* [1.x.75][1.x.76] 。


*
* 像往常一样，在开始的时候，我们把所有我们需要的头文件都包含在这里。除了为Trilinos库提供接口的各种文件外，没有什么意外。
*


* [1.x.77]
*
* [1.x.78] [1.x.79]。


*
* 这个类提供了描述障碍物问题所需的所有函数和变量。它与我们在[2.x.130]中要做的很接近，所以相对简单。唯一真正的新组件是计算主动集合的update_solution_and_constraints函数和一些描述线性系统原始（无约束）形式所需的变量（ [2.x.131] 和 [2.x.132] ），以及主动集合本身和主动集合公式中用于缩放拉格朗日乘数的质量矩阵的对角线 [2.x.133] 。其余的与[2.x.134]中一样。
*


* [1.x.80]
*
* [1.x.81] [1.x.82]。


*
* 在下文中，我们定义了描述右侧函数、Dirichlet边界值以及作为[2.x.135]函数的障碍物高度的类。在这三种情况下，我们都从函数[2.x.136]派生出这些类，尽管在[2.x.137]和[2.x.138]的情况下，这更多的是出于惯例而不是必要，因为我们从未将这类对象传递给库。在任何情况下，鉴于我们选择了 [2.x.139] , [2.x.140] ，右手和边界值类的定义是明显的。
*


* [1.x.83]
*
* 我们用一个级联的障碍物（想想看：楼梯的阶梯）来描述障碍物的功能。
*


* [1.x.84]
*
* [1.x.85] [1.x.86]。





* [1.x.87] [1.x.88]。


*
* 对于每个看过前几个教程程序的人来说，构造函数是完全显而易见的。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。


*
* 我们在二维的正方形[2.x.141]上解决我们的障碍物问题。因此这个函数只是设置了一个最简单的网格。
*


* [1.x.92]
*
* [1.x.93] [1.x.94]。


*
* 在这个值得注意的第一个函数中，我们设置了自由度处理程序，调整了向量和矩阵的大小，并处理了约束。最初，约束条件当然只是由边界值给出的，所以我们在函数的顶部对它们进行插值。
*


* [1.x.95]
*
* 这里唯一要做的事情是计算[2.x.142]矩阵中的因子，该矩阵用于缩放残差。正如在介绍中所讨论的，我们将使用一个小技巧来使这个质量矩阵成为对角线，在下文中，然后首先将所有这些计算成一个矩阵，然后提取对角线元素供以后使用。
*


* [1.x.96]
*
* [1.x.97] [1.x.98]。


*
* 这个函数一下子就把系统矩阵和右手边集合起来，并把约束条件（既由于活动集，也由于边界值）应用到我们的系统中。否则，它在功能上等同于例如[2.x.143]中的相应函数。
*


* [1.x.99]
*
* [1.x.100] [1.x.101]。


*
* 下一个函数用于计算对角线质量矩阵[2.x.144]，用于在主动集方法中缩放变量。正如介绍中所讨论的，我们通过选择正交的梯形规则来获得质量矩阵的对角线。这样一来，我们就不再需要在正交点、指数[2.x.145]和指数[2.x.146]上进行三层循环，而是可以直接使用双层循环。考虑到我们在以前的许多教程程序中讨论过的内容，该函数的其余部分是显而易见的。   
* 请注意，在调用这个函数时，约束对象只包含边界值约束；因此我们在最后的复制-本地-全局步骤中不必注意保留矩阵项的值，这些项以后可能会受到活动集的约束。   
* 还需要注意的是，只有在我们拥有[2.x.147]元素的情况下，使用梯形规则的技巧才有效。对于更高阶的元素，我们需要使用一个正交公式，在有限元的所有支持点都有正交点。构建这样一个正交公式其实并不难，但不是这里的重点，所以我们只是在函数的顶部断言我们对有限元的隐含假设实际上得到了满足。
*


* [1.x.102]
*
* [1.x.103] [1.x.104]。



* 在某种意义上，这是本程序的核心功能。  它更新了引言中所讨论的活动的受限自由度集，并从中计算出一个AffineConstraints对象，然后可以用来消除下一次迭代的解中的受限自由度。同时，我们将解决方案的受限自由度设置为正确的值，即障碍物的高度。   
* 从根本上说，这个函数是相当简单的。我们必须在所有自由度上循环，并检查函数[2.x.148]的符号，因为在我们的例子中[2.x.149] 。为此，我们使用介绍中给出的公式，通过该公式我们可以计算出拉格朗日乘数，作为原始线性系统的残差（通过变量[2.x.150]给出。在这个函数的顶部，我们使用一个属于矩阵类的函数来计算这个残差。
*


* [1.x.105]
*
*计算 contact_force[i] =
*
* - lambda[i] diagonal_of_mass_matrix[i]。
*


* [1.x.106]
*
* 下一步是重置活动集和约束对象，并开始在所有自由度上进行循环。由于我们不能只是在求解向量的所有元素上循环，这使事情变得稍微复杂，因为我们没有办法找出一个自由度与哪个位置相关；但是，我们需要这个位置来测试一个自由度的位移是大于还是小于这个位置的障碍物高度。     
* 我们通过对所有单元和定义在每个单元上的DoF进行循环来解决这个问题。我们在这里使用位移是用[2.x.151]函数来描述的，对于该函数来说，自由度总是位于单元格的顶点上；因此，我们可以通过询问顶点来获得每个自由度的索引及其位置的信息。另一方面，这显然对高阶元素不起作用，因此我们添加了一个断言，确保我们只处理所有自由度都位于顶点的元素，以避免在有人想玩增加解的多项式程度时用非功能性代码绊倒自己。     
* 循环处理单元格而不是自由度的代价是，我们可能不止一次地遇到一些自由度，即每次我们访问与某个顶点相邻的一个单元格时。因此，我们必须跟踪我们已经接触过的顶点和尚未接触的顶点。我们通过使用一个标志数组来做到这一点 [2.x.152] 。
*


* [1.x.107]
*
* 现在我们知道我们还没有触及这个DoF，让我们得到那里的位移函数的值以及障碍函数的值，用它来决定当前DoF是否属于活动集。为此，我们使用上面和介绍中给出的函数。           
* 如果我们决定该DoF应该是活动集的一部分，我们将其索引添加到活动集中，在AffineConstraints对象中引入一个不均匀的平等约束，并将解的值重置为障碍物的高度。最后，系统的非接触部分的残差作为一个额外的控制（残差等于剩余的、未计算的力，在接触区之外应该为零），所以我们将残差向量的分量（即拉格朗日乘数lambda）清零，这些分量对应于身体接触的区域；在所有单元的循环结束时，残差将因此只包括非接触区的残差。我们在循环结束后输出这个残差的规范和活动集的大小。
*


* [1.x.108]
*
* 在最后一步中，我们将迄今为止从活动集中得到的关于DoF的约束集加入那些由Dirichlet边界值产生的约束，并关闭约束对象。
*


* [1.x.109]
*
* [1.x.110] [1.x.111]。


*
* 关于求解函数，其实没有什么可说的。在牛顿方法的背景下，我们通常对非常高的精度不感兴趣（为什么要求一个高度精确的线性问题的解，而我们知道它只能给我们一个非线性问题的近似解），因此我们使用ReductionControl类，当达到一个绝对公差（为此我们选择[2.x.153]）或当残差减少一定的系数（这里是[2.x.154]）时停止迭代。
*


* [1.x.112]
*
* [1.x.113] [1.x.114]。


*
* 我们使用vtk-format进行输出。  该文件包含位移和活动集的数字表示。
*


* [1.x.115]
*
* [1.x.116] [1.x.117]。


*
* 这是一个对所有事情都有顶层控制的函数。  它并不长，而且事实上相当直接：在主动集方法的每一次迭代中，我们都要组装线性系统，求解它，更新主动集并将解投射回可行集，然后输出结果。只要主动集在前一次迭代中没有变化，迭代就会终止。   
* 唯一比较棘手的部分是，我们必须在第一次迭代中组装好线性系统（即矩阵和右手边）后保存它。原因是这是唯一的步骤，我们可以在没有任何接触约束的情况下访问建立的线性系统。我们需要这个来计算其他迭代中解决方案的残差，但是在其他迭代中，我们形成的线性系统中对应于约束自由度的行和列被消除了，因此我们不能再访问原始方程的全部残差。
*


* [1.x.118]
*
* [1.x.119] [1.x.120]。


*
* 而这是主函数。它遵循所有其他主函数的模式。调用初始化MPI是因为我们在这个程序中建立线性求解器的Trilinos库需要它。
*


* [1.x.121]
*
* 这个程序只能在串行中运行。否则，抛出一个异常。
*


* [1.x.122]
* [1.x.123][1.x.124] 。


* 运行该程序会产生这样的输出。
* [1.x.125]
*
* 一旦活动集不再变化，迭代就结束了（此时它有5,399个受限自由度）。代数条件显然工作得很好，因为我们只需要4-6次CG迭代来解决线性系统（尽管这也与我们对线性求解器的精度要求不高有很大关系）。
* 更具启发性的是看一连串的图形输出文件（每三步显示一次，最左边一栏是迭代数）。
* [2.x.155]
* 这些图片显示，在第一步中，解决方案（在没有任何约束条件的情况下计算出来的）是如此的弯曲，以至于几乎每一个内部点都必须被弹回第一步的函数，产生了一个不连续的解决方案。在活动集迭代的过程中，这种不切实际的膜的形状被磨平了，与最下层阶梯的接触消失了，解决方案也稳定下来。
* 除此以外，该程序还输出了拉格朗日乘数的值。请记住，这些是接触力，所以在接触集上应该是正的，而在接触集外是零。另一方面，如果一个拉格朗日乘数在行动集上是负的，那么这个自由度必须从行动集上删除。下面的图片显示了迭代1、9和18中的乘数，我们用红色和棕色表示正值，蓝色表示负值。
* [2.x.156]
* 很容易看到，正值在接触集的内部很好地收敛为适度的值，在台阶的边缘有很大的上升力，正如人们所期望的那样（以支持那里的膜的大曲率）；在活动集的边缘，乘数最初是负的，导致该集缩小，直到在迭代18，没有更多的负乘数，算法已经收敛了。
*


* [1.x.126][1.x.127][1.x.128] 。


* 与本教程的任何程序一样，有许多明显的扩展和实验的可能性。第一个可能性很明显：引入适应性。接触问题是自适应网格的主要候选者，因为解决方案有一些线条，沿着这些线条是不太规则的（在膜和障碍物之间建立接触的地方），而其他区域的解决方案是非常平滑的（或者，在目前的情况下，在与障碍物接触的地方是恒定的）。在目前的程序中加入这一点应该不会造成太大的困难，但要找到一个好的误差估计器来实现这一目的并不容易。
* 一个更具挑战性的任务是扩展到三维。这里的问题不是简单地让所有的东西都在三维中运行。相反，当一个三维体变形并与一个障碍物接触时，障碍物并不像这里的情况那样在域内起约束体的作用。相反，接触力只作用于物体的边界。那么不等式就不在微分方程中，而实际上是在（诺伊曼型）边界条件中，尽管这导致了一种类似的变分质量。在数学上，这意味着拉格朗日乘数只存在于表面，当然，如果方便的话，它也可以通过零点扩展到域。在目前的程序中，我们不需要明确地形成和存储这个拉格朗日乘数。
* 在三维情况下，另一个有趣的问题是考虑有摩擦的接触问题。在几乎每个机械过程中，摩擦都有很大的影响。对于建模，我们必须考虑到接触面的切向应力。我们还必须注意到，摩擦给我们的问题增加了另一个非线性。
* 另一个不简单的修改是实现一个更复杂的构成法，如非线性弹性或弹塑性材料行为。这里的困难是处理通过非线性构成法产生的额外非线性。
*

* [1.x.129][1.x.130] [2.x.157] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-42_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38]
* [2.x.3]
*[1.x.39][1.x.40] 。



* [1.x.41][1.x.42][1.x.43] 。

* 这个例子是[2.x.4]的扩展，考虑的是三维接触问题，其材料行为是各向同性的硬化。换句话说，它考虑的是，如果把一个刚性的障碍物推到三维体上（接触问题），其变形受弹塑性材料法则（一种只能容纳一定最大应力的材料）支配，随着变形的累积而硬化。为了说明我们打算做什么，在讨论太多细节之前，让我们先看看解决方案是什么样子的（可变形体是一个立方体
*
* -实际上只显示了一半的内容
*
* - 障碍物对应于一个汉字，将在下面讨论）。)
* [2.x.5]
*

* 这个问题的描述意味着，与[2.x.6]相比，我们必须照顾到一个额外的非线性因素：材料行为。由于我们在这里考虑的是一个三维问题，我们还必须考虑到一个事实，即现在接触区是在可变形体的边界，而不是在内部。最后，与[2.x.7]相比，在处理线性系统和不等式约束时，我们还必须处理悬挂节点的问题，因为我们希望使用自适应网格；在后一种情况下，我们必须处理悬挂节点的约束还是不等式的约束更重要的优先次序。
* 由于在三维空间中很容易达到几百万个自由度，即使使用自适应网格细化，我们决定使用Trilinos和p4est来并行运行我们的代码，在[2.x.8]的框架上进行并行化。其他并行化的指针可以在[2.x.9]中找到。
*

*[1.x.44][1.x.45]


*该问题的经典表述拥有以下形式。
* [1.x.46]
* 这里，这些方程中的第一个定义了应变[2.x.10]和应力[2.x.11]之间的关系，即四阶顺应性张量[2.x.12]；[2.x.13]提供了应变的塑性成分，以确保应力不超过屈服应力。我们将只考虑各向同性的材料，对于这些材料，[2.x.14]可以用Lam&eacute;模量[2.x.15]和[2.x.16]表示，或者用体模量[2.x.17]和[2.x.18]表示。第二个方程是力平衡；我们将不考虑任何体力，因此假设[2.x.19] 。第三行的互补条件意味着如果[2.x.21]，则[2.x.20]，但如果且仅如果[2.x.23]，则[2.x.22]可能是一个非零张量，特别是在这种情况下，[2.x.24]必须指向[2.x.25]方向。不等式[2.x.26]是塑性材料只能支持有限的应力；换句话说，如果外力会导致应力[2.x.28]，而[2.x.29]会导致塑性变形[2.x.27]，它们就会发生反应。这种[1.x.47]的典型形式是[2.x.30]，其中[2.x.31]是张量的偏离部分，[2.x.32]表示Frobenius规范。
* 进一步的方程描述了在[2.x.33]上的固定的零位移，在可能出现接触的表面[2.x.34]上，障碍物施加的法向力[2.x.35]是向内的（障碍物对我们身体没有 "拉"），切向分量为零[2.x.36最后一个条件也是一个互补条件，它意味着在[2.x.37]上，只有当身体与障碍物接触时，法向力才可能是非零的；第二部分描述了障碍物和身体的不可穿透性。
* 大多数材料
*
* - 特别是金属
*
* - 具有这样的特性：它们在变形后会出现一些硬化。换句话说，[2.x.38]随着变形而增加。实际上，导致硬化的不是弹性变形，而是塑性成分。有不同的构成规律来描述这些材料行为。最简单的是线性各向同性硬化，由流动函数[2.x.39]描述。
*

*[1.x.48][1.x.49]


* 一般来说，处理不等式是相当笨拙的。在这里，我们必须处理两个问题：塑性和接触问题。正如本页顶部提到的论文中详细描述的那样，至少可以重新表述塑性，使其看起来像一个非线性，然后我们可以用牛顿方法处理。这在数学上略显棘手，因为非线性不只是一些平滑的函数，而是在应力达到屈服应力的地方有结点；然而，对于这样的[1.x.50]函数，可以证明牛顿方法仍然收敛。
* 在不详细说明的情况下，我们也将摆脱应力作为一个独立变量，而只用位移[2.x.40]来工作。最终，这个重构的目标是我们希望最终得到一个对称的、正定的问题
*
* - 如一个线性化的弹性问题，其空间可变系数由塑性行为产生。
*
* - 需要在每个牛顿步骤中解决。我们希望如此，因为有高效和可扩展的方法来解决这样的线性系统，如用代数多重网格的CG预处理。这与类似于混合拉普拉斯的鞍点问题（见[2.x.41]）相反，如果我们继续使用包含位移和应力的混合公式，就会得到鞍点问题，对于这个问题，[2.x.42]已经提示了构建良好的求解器和预处理器是多么困难。
* 说到这里，让我们简单陈述一下重构后得到的问题（同样，细节可以在论文中找到）。找到一个位移[2.x.43]，以便
* [1.x.51]
*其中投影仪[2.x.44]被定义为
* [1.x.52]
* 而空间[2.x.45]是满足接触条件的所有位移的空间。
* [1.x.53]
*
* 在实际代码中，我们将使用缩写[2.x.46] 。
* 鉴于这种表述，我们将应用两种技术。
*
* - 运行一个牛顿方法来迭代出投影仪中的非线性。
*
* - 为接触条件运行一个主动集方法，其方式与我们在 [2.x.47] 中所做的基本相同。
* 一个严格的方法是在我们迭代牛顿方法到收敛时保持活动集的固定（或者反过来：在进入下一次牛顿迭代前找到最终的活动集）。在实践中，事实证明，每次活动集迭代只做一个牛顿步骤就足够了，因此我们将同时迭代它们。我们还将每隔一段时间细化一下网格。
*

*[1.x.54][1.x.55]


* 如前所述，我们将通过应用牛顿方法来处理算子[2.x.48]的非线性问题，尽管该算子在严格意义上是不可微的。然而，它满足[1.x.56]的可微条件，这就足以让牛顿方法发挥作用。由此产生的方法被称为[1.x.57]，听起来令人印象深刻，但实际上只是将牛顿方法应用于具有适当 "导数 "的半光滑函数。
* 在当前情况下，我们将通过在每次迭代中求解[2.x.49]来运行我们的迭代，即以下方程（仍然是一个不等式，但已线性化）。
* [1.x.58]
*其中等级4的张量[2.x.50]由以下公式给出
* [1.x.59]
* 这个张量是[2.x.51]围绕[2.x.52]的（形式）线性化。对于我们这里考虑的线性各向同性材料，投影仪的体积和剪切成分由[1.x.60]给出。
* 其中[2.x.53]和[2.x.54]分别是等级为2和4的认同张量。
* 请注意，这个问题对应于一个线性弹性接触问题，其中[2.x.55]起到弹性张量[2.x.56]的作用。事实上，如果材料在某一点上没有塑性，那么[2.x.57] 。然而，在材料具有塑性的地方，[2.x.58]是一个空间变化的函数。在任何情况下，我们必须为牛顿迭代[2.x.59]求解的系统使我们更接近重写问题的目标，使我们能够使用众所周知的求解器和预处理器来处理椭圆系统。
* 作为对牛顿方法的最后说明，让我们提到，与牛顿方法一样，我们需要通过控制步长使其全球化。换句话说，虽然上面的系统求解的是[2.x.60]，但最终的迭代结果将是
* [1.x.61]
* 其中右侧括号中的差值代表了传统的牛顿方向，即[2.x.61]。我们将使用标准的直线搜索来确定[2.x.62]。
*

*[1.x.62][1.x.63]


* 这个在每个牛顿步骤中要解决的线性化问题基本上与[2.x.63]相似。唯一的区别在于接触区是在边界而不是在域中。但这没有进一步的后果，所以我们参考文献[2.x.64]，唯一的提示是[2.x.65]包含了接触边界[2.x.66]上的所有顶点的时间。如同那里，我们需要做的是保持自由度的一个子集的固定，导致额外的约束，可以写成鞍点问题。然而，正如论文中所讨论的，通过以适当的方式写这些约束，消除自由度之间的耦合，我们最终得到一组节点，基本上只是有Dirichlet值附加在它们身上。
*

*[1.x.64][1.x.65]


* 上述算法结合了阻尼半光滑牛顿法（我们用于非线性构成法）和半光滑牛顿法，用于接触。它的工作原理如下。[2.x.67] [2.x.68] 初始化主动集和非主动集[2.x.69]和[2.x.70]，使得[2.x.71]和[2.x.72]和设置[2.x.73] 。这里，[2.x.74]是位于可能发生接触的域的表面的所有自由度的集合。起始值[2.x.75]满足我们的障碍条件，也就是说，我们将初始零位移投射到可行位移集合上。
* [2.x.76] 组建牛顿矩阵 [2.x.77] 和右手边 [2.x.78] 。这些对应于线性化的牛顿步骤，暂时忽略了接触不等式。
* [2.x.79] 找到满足以下条件的主-偶对[2.x.80]： 1.


* [1.x.66]
* 如同[2.x.81]，我们可以通过从第一个方程中消除[2.x.82]中的那些自由度来得到这个问题的解决方案，并得到一个线性系统[2.x.83]。
*


* [2.x.84] 通过应用直线搜索和计算[2.x.86]和[2.x.87]的线性组合来抑制[2.x.85]的牛顿迭代。这需要找到一个[2.x.88]，以便[1.x.67]
* 满足[1.x.68]与[2.x.89]，除了(i)我们设置[2.x.91]的元素[2.x.90]，和(ii)对应悬挂节点的元素，我们以通常的方式消除。
* [2.x.92] 通过[1.x.69]定义新的活动和非活动集。
* [1.x.70]

* [2.x.93] 项目[2.x.94]，使其满足接触不等式，[1.x.71] 。
* 这里，[2.x.95]是[2.x.96]中的活性成分对间隙[1.x.72]的投影。
*其中[2.x.97]是[1.x.73]，表示障碍物与身体未位移配置的距离。
* [2.x.98] 如果[2.x.99]和[2.x.100]则停止，否则设置[2.x.101]并转到步骤（1）。这一步确保我们只有在找到正确的活动集和塑性已经迭代到足够的精度时才停止迭代。[2.x.102]
* 在该算法的第3步中，矩阵[2.x.103]、[2.x.104]描述了位移和拉格朗日乘数（接触力）的基数的耦合，在我们的情况下它不是二次的，因为[2.x.105]只定义在[2.x.106]上，即可能发生接触的表面。如本文所示，我们可以选择[2.x.107]是一个每行只有一个条目的矩阵，（另见H&uuml;eber, Wohlmuth:A primal-dual activeset strategy for non-linear multibody contact problems, Comput.MECH.Engrg.194, 2005, pp.Engrg.194, 2005, pp.3147-3166）。向量[2.x.108]是由间隙[2.x.110][1.x.74]的合适近似值[2.x.109]定义的。]
*
*

*[1.x.75][1.x.76]


* 由于我们的程序是在三维空间中运行的，所以程序所进行的计算是很昂贵的。因此，使用自适应网格细化是在可接受的运行时间内的一个重要步骤。为了使我们的生活更轻松，我们简单地选择已经在deal.II中实现的KellyErrorEstimator。我们把包含位移[2.x.111]的解决向量交给它。正如我们将在结果中看到的，它产生了一个相当合理的接触区和塑性的自适应网格。
*

*[1.x.77][1.x.78]


* 本教程基本上是[2.x.112]和[2.x.113]的混合体，但我们不使用PETSc，而是让Trilinos库来处理线性代数的并行化问题（就像[2.x.114]中那样）。由于我们试图解决一个类似于[2.x.115]的问题，我们将使用同样的方法，但现在是并行的。
* 一个困难是如何处理来自Dirichlet条件的约束，悬挂的节点和接触产生的不平等条件。为此，我们创建了三个AffineConstraints类型的对象，它们描述了各种约束条件，我们将在每次迭代中适当地将它们组合起来。
* 与[2.x.116]相比，本程序有几个新的类。
* [2.x.117] [2.x.118] [2.x.119] 描述材料的塑性行为。
* [2.x.120] [2.x.121] 描述了一个球体，它作为障碍物被推入可变形的弹塑性体。  是用这个还是下一个类来描述障碍物，由输入参数文件决定。
* [2.x.122] [2.x.123] （和一个辅助类）是一个允许我们从文件中读入障碍物的类。在我们将在结果部分展示的例子中，这个文件将是[2.x.124]，并对应于显示力或功率的中文、日文或韩文符号的数据（见http://www.orientaloutpost.com/ : "这个词可以用于激励
*
* - 它也可以指权力/运动/推动/力量。它可以是任何使你前进的内部或外部的东西。这是用中文表达动机的最安全的方式。如果你的听众是日本人，请看另一个关于动机的条目。这是日语和韩语中的一个词，但它的意思是 "动力 "或 "动能"（没有你可能正在寻找的动机的意思）"）。实质上，我们将假装有一个印章（即对应于平底障碍物的面具，没有中间高度的碎片），我们把它压在身上。有关的符号看起来如下（也可参见本节顶部的图片，了解最终结果是怎样的）。
* [2.x.125] [2.x.126]。
*除此之外，我们只对以下几个方面进行评论。[2.x.127] [2.x.128] 程序允许你通过参数文件从两个不同的粗略网格中选择。这些是立方体[2.x.129]或半球体，其开放面朝向正方向[2.x.130]。
* [2.x.131]在这两种情况下，我们将假定惯例，即可能与障碍物接触的边界部分具有边界指标一。对于这两种网格，我们假定这是一个自由表面，即身体要么在那里接触，要么没有力作用在它身上。对于半球体，弯曲部分的边界指标为零，我们在那里施加零位移。对于盒子，我们沿底部施加零位移，但允许沿边的垂直位移（尽管没有水平位移）。[2.x.132]
*

* [1.x.79] [1.x.80]。
* [1.x.81] [1.x.82] 这套包含文件目前已经没有什么惊喜了。
*


* [1.x.83]

* 最后，我们包括两个系统头文件，让我们为输出文件创建一个目录。第一个头文件提供了[2.x.133]的功能，第二个头文件让我们确定在[2.x.134]失败时发生了什么。
*


* [1.x.84]
*
* [1.x.85] [1.x.86]。


*
* 该类提供了一个构成法的接口，即应变 [2.x.135] 和应力 [2.x.136] 之间的关系。在这个例子中，我们使用的是具有线性、各向同性的硬化的弹塑性材料行为。这种材料的特点是杨氏模量 [2.x.137] ，泊松比 [2.x.138] ，初始屈服应力 [2.x.139] 和各向同性硬化参数 [2.x.140] 。  对于[2.x.141]我们得到完美的弹塑性行为。   
*正如描述这个程序的论文中所解释的，第一个牛顿步骤是用完全弹性材料模型来解决的，以避免同时处理两种非线性（塑性和接触）。为此，这个类有一个函数[2.x.142]，我们以后用它来简单地设置[2.x.143]为一个非常大的值
*
* - 基本上保证了实际的应力不会超过它，从而产生一个弹性材料。当我们准备使用塑性模型时，我们使用相同的函数，将[2.x.144]设置回其适当的值。  由于这种方法，我们需要将[2.x.145]作为这个类的唯一非静态成员变量。
*


* [1.x.87]
*
* ConstitutiveLaw类的构造函数为我们的可变形体设置所需的材料参数。弹性各向同性介质的材料参数可以用多种方式定义，如一对[2.x.146]（弹性模量和泊松数），使用Lam&eacute; 参数[2.x.147]或其他几种常用的约定。在这里，构造器采用[2.x.148]形式的材料参数描述，但由于这证明这些不是出现在塑性投影仪方程中的系数，我们立即将它们转换为更合适的体模和剪模的集合[2.x.149]。  此外，构造器将[2.x.150]（无任何塑性应变的屈服应力）和[2.x.151]（硬化参数）作为参数。在这个构造器中，我们还计算了应力-应变关系的两个主成分及其线性化。
*


* [1.x.88]
*
* [1.x.89] [1.x.90]。


*
* 这是构成法的主成分。它计算四阶对称张量，根据上面给出的投影，当在一个特定的应变点上评估时，它将应变与应力联系起来。我们需要这个函数来计算[2.x.152]中的非线性残差，我们将这个张量与正交点给出的应变相乘。计算遵循引言中列出的公式。在比较那里的公式和下面的实现时，记得[2.x.153]和[2.x.154] 。   
* 该函数返回正交点是否是塑性的，以便在下游对有多少正交点是塑性的，有多少是弹性的进行一些统计。
*


* [1.x.91]
*
* [1.x.92] [1.x.93]。


*
* 该函数返回线性化的应力应变张量，围绕前一个牛顿步骤[2.x.155]的解进行线性化。  参数[2.x.157]（通常表示为[2.x.158]）必须作为参数传递，并作为线性化点。该函数在变量stress_strain_tensor中返回非线性构成法的导数，在stress_strain_tensor_linearized中返回线性化问题的应力-应变张量。  参见[2.x.159]，该函数的使用情况。
*


* [1.x.94]
*
* [1.x.95]
* 下面的内容应该是比较标准的。我们需要边界强迫项（我们在此选择为零）和不属于接触面的边界部分的边界值（在此也选择为零）的类。
*


* [1.x.96]
*
* [1.x.97] [1.x.98]。


*
* 下面这个类是可以从输入文件中选择的两个障碍物中的第一个。它描述了一个以位置[2.x.160]和半径[2.x.161]为中心的球体，其中[2.x.162]是可变形体的（平）表面的垂直位置。该函数的[2.x.163]返回给定[2.x.164]值的障碍物位置，如果该点实际位于球体下方，则返回一个大的正值，如果它位于球体的 "阴影 "之外，就不可能干扰变形。
*


* [1.x.99]
*
*前面的断言
*


* [1.x.100]
*
* [1.x.101] [1.x.102]。


*
* 以下两个类描述了介绍中概述的障碍，即汉字。这两个中的第一个，[2.x.165]负责从一个以pbm ascii格式存储的图片文件中读入数据。这个数据将被双线性插值，从而提供一个描述障碍物的函数。(下面的代码显示了如何通过在给定的数据点之间进行内插来构建一个函数。人们可以使用本教程程序写完后引入的[2.x.166]，它正好做了我们这里想要的东西，但看看如何用手做是有启发的）。)     
* 我们从文件中读取的数据将被存储在一个名为 obstacle_data 的双倍数 [2.x.167] 中。  这个向量构成了计算单片双线性函数的基础，作为一个多项式插值。我们将从文件中读取的数据包括零（白色）和一（黑色）。     
* [2.x.168]变量表示[2.x.169]和[2.x.170]方向的像素之间的间距。  [2.x.171]是这些方向上每个像素的数量。   [2.x.172]返回图像在给定位置的值，由相邻的像素值插值而成。
*


* [1.x.103]
*
* 该类的构造函数从给定的文件名中读入描述障碍物的数据。
*


* [1.x.104]
*
* 以下两个函数返回坐标为[2.x.173]的给定像素的值，我们将其与定义在位置[2.x.174]的函数值相识别，并在任意坐标[2.x.175]处对两个函数中的第一个返回的点值进行双线性插值。在第二个函数中，对于每个[2.x.176]，我们首先计算离[2.x.177]左下方最近的像素坐标的（整数）位置，然后计算这个像素内的坐标[2.x.178]。我们从下方和上方截断这两种变量，以避免在评估函数时超出其定义的范围而可能发生的舍入误差问题。
*


* [1.x.105]
*
* 最后，这是一个实际使用上面的类的类。它有一个BitmapFile对象作为成员，描述障碍物的高度。如上所述，BitmapFile类将为我们提供一个掩码，也就是0或1的值（如果你要求的是像素之间的位置，则是在0和1之间插值的值）。这个类将其转化为高度，即低于可变形体表面的0.001（如果BitmapFile类在此位置报告为1）或高于障碍物的0.999（如果BitmapFile类报告为0）。那么下面的函数应该是不言自明的。
*


* [1.x.106]
*
*前面的断言
*


* [1.x.107]
*
* [1.x.108] [1.x.109]。


*
* 这是本程序的主类，提供描述非线性接触问题所需的所有函数和变量。它接近于[2.x.179]，但有一些额外的功能，如处理悬空节点，牛顿方法，使用Trilinos和p4est进行并行分布式计算。处理悬空节点使生活变得有点复杂，因为我们现在需要另一个AffineConstraints对象。我们为接触情况下的主动集合方法创建一个牛顿方法，并处理构成法的非线性算子。   
* 这个类的总体布局与其他大多数教程程序非常相似。为了使我们的生活更容易一些，这个类从输入文件中读取一组输入参数。这些参数，使用ParameterHandler类，在[2.x.180]函数中声明（该函数是静态的，因此它可以在我们创建当前类型的对象之前被调用），然后一个已经用于读取输入文件的ParameterHandler对象将被传递给该类的构造函数。   
* 其余的成员函数大体上与我们在其他几个教程程序中看到的一样，尽管为当前的非线性系统增加了一些内容。我们将在下面进一步讨论它们的目的。
*


* [1.x.110]
*
* 就成员变量而言，我们先用一些变量来表示这个程序运行的MPI宇宙，我们用一个流来让正好一个处理器产生输出到控制台（见[2.x.181] ），还有一个变量用来为程序的各个部分计时。
*


* [1.x.111]
*
* 下一组描述网格和有限元空间。特别是，对于这个并行程序，有限元空间有与之相关的变量，表明哪些自由度存在于当前的处理器上（索引集，也见[2.x.182]和[2.x.183]文档模块），以及各种约束：那些由悬挂节点，由Dirichlet边界条件，以及由接触节点的活动集施加的约束。在这里定义的三个AffineConstraints变量中，第一个变量只包含悬挂节点的约束，第二个变量也包含与Dirichlet边界条件相关的约束，第三个变量包含这些约束和接触约束。     
* 变量[2.x.184]包括那些由接触约束的自由度，我们用[2.x.185]来跟踪每个单元上应力等于屈服应力的正交点的分数。后者仅用于创建显示塑性区的图形输出，但不用于任何进一步的计算；该变量是该类的成员变量，因为该信息是作为计算残差的副产品计算的，但仅在很久之后才使用。(注意，该向量是一个长度等于[1.x.112]上活动单元数量的向量；它从未被用来在处理器之间交换信息，因此可以是一个常规的deal.II向量)。
*


* [1.x.113]
*
* 下一个变量块对应于解决方案和我们需要形成的线性系统。特别是，这包括牛顿矩阵和右手边；对应于残差（即牛顿右手边）但我们没有消除各种约束的向量，该向量用于确定在下一次迭代中需要约束哪些自由度；以及对应于介绍中简要提到并在随文讨论的[2.x.186]矩阵对角线的向量。
*


* [1.x.114]

* 下一个块包含描述材料响应的变量。
*


* [1.x.115]
*
* 然后还有各种各样的其他变量，用于识别参数文件所选择的要求我们建立的网格，被推入可变形体的障碍物，网格细化策略，是否将解决方案从一个网格转移到下一个网格，以及要执行多少个网格细化循环。在可能的情况下，我们将这类变量标记为[2.x.187]，以帮助读者识别哪些变量以后可能会被修改，哪些可能不会被修改（输出目录是一个例外
*
* - 它从未在构造函数之外被修改过，但在构造函数中冒号后面的成员初始化列表中初始化是很尴尬的，因为在那里我们只有一次机会来设置它；对于网格细化准则也是如此）。)
*


* [1.x.116]
*
* [1.x.117] [1.x.118]。



* [1.x.119] [1.x.120]。


*
* 让我们从声明可以在输入文件中选择的运行时参数开始。这些值将在这个类的构造函数中读回，以初始化这个类的成员变量。
*


* [1.x.121]
*
* [1.x.122] [1.x.123]。


*
* 鉴于成员变量的声明以及从输入文件中读取的运行时参数的声明，在这个构造函数中没有任何令人惊讶的地方。在主体中，我们初始化网格细化策略和输出目录，必要时创建这样一个目录。
*


* [1.x.124]
*
* 如果有必要，为输出创建一个新的目录。
*


* [1.x.125]
*
* [1.x.126] [1.x.127]。


*
* 下一个区块涉及到构建起始网格。我们将使用下面的辅助函数和[2.x.188]的第一个块来构造一个对应于半球形的网格。deal.II有一个函数可以创建这样的网格，但是它的位置和方向都是错误的，所以我们需要在使用它之前对它进行一些移动和旋转。   
*供以后参考，如[2.x.189]的文件中所述，半球体的平坦表面的边界指标为0，而其余部分的边界指标为1。
*


* [1.x.128]
*
* 因为我们将在下面附加一个不同的歧管，所以我们立即清除默认的歧管描述。
*


* [1.x.129]
*
* 或者，创建一个超立方体网格。创建后，按如下方式分配边界指标。  [2.x.190] 换句话说，立方体的边的边界指标是8。底部的边界指标是6，顶部的指标是1。我们通过循环所有面的所有单元并查看单元中心的坐标值来设置这些指标，并在以后评估哪个边界将携带迪里希特边界条件或将受到潜在接触时利用这些指标。(在目前的情况下，网格只包含一个单元，它的所有面都在边界上，所以严格来说，所有单元的循环和查询一个面是否在边界上都是不必要的；我们保留它们只是出于习惯：这种代码可以在许多程序中找到，基本上都是这种形式。)
*


* [1.x.131]
*
* [1.x.132] [1.x.133]。



* 谜题的下一块是设置DoFHandler，调整向量大小，并处理其他各种状态变量，如索引集和约束矩阵。   
* 在下文中，每一组操作都被放入一个大括号封闭的块中，该块被块顶部声明的变量计时（[2.x.191]变量的构造器开始计时部分，在块的末端调用的析构器又停止计时）。
*


* [1.x.134]
*
* 最后，我们设置了稀疏模式和矩阵。我们暂时（ab）用系统矩阵也建立（对角线）矩阵，我们在消除与障碍物接触的自由度时使用，但我们随后立即将牛顿矩阵设为零。
*


* [1.x.135]
*
* [1.x.136] [1.x.137]。


*
* 这个函数从前面的函数中分离出来，计算与迪里切特型边界条件相关的约束，并通过与来自悬挂节点的约束合并，将其放入[2.x.192]变量。   
* 正如介绍中所阐述的，我们需要区分两种情况。
*


*
* - 如果域是一个盒子，我们将底部的位移设置为零，并允许沿侧面在Z方向的垂直运动。如[2.x.193]函数所示，前者对应于边界指标6，后者对应于8。
*


*
* - 如果域是一个半球形，那么我们沿边界的弯曲部分施加零位移，与边界指标零相关。
*


* [1.x.138]
*
*插值解决方案的所有组成部分
*


* [1.x.139]
*
*插值解决方案的x-和y-分量（这是一个位掩码，所以应用运算器|）。
*


* [1.x.140]
*
* [1.x.141] [1.x.142]。


*
* 下一个辅助函数计算（对角线）质量矩阵，用于确定我们在接触算法中使用的主动集合方法的主动集合。这个矩阵是质量矩阵类型的，但是与标准质量矩阵不同，我们可以通过使用正交公式使其成为对角线（甚至在高阶元素的情况下），该公式的正交点与有限元插值点的位置完全一致。我们通过使用QGaussLobatto正交公式来实现这一点，同时用一组从同一正交公式得出的插值点初始化有限元。该函数的其余部分相对简单：我们将得到的矩阵放入给定的参数中；因为我们知道矩阵是对角线的，所以只需在[2.x.194]而不是[2.x.195]上有一个循环即可。严格来说，我们甚至可以避免在正交点[2.x.196]处将形状函数的值与自身相乘，因为我们知道形状值是一个恰好有一个一的向量，当与自身相点时产生一。由于这个函数不是时间关键，为了清楚起见，我们添加了这个术语。
*


* [1.x.143]
*
* [1.x.144] [1.x.145]。


*
* 以下函数是我们在[2.x.197]函数中每次牛顿迭代时调用的第一个函数。它的作用是将解决方案投射到可行集上，并更新接触或穿透障碍物的自由度的活动集。   
*为了实现这个功能，我们首先需要做一些记账工作。我们需要写进解决方案向量（我们只能用没有鬼魂元素的完全分布的向量来写），我们需要从各自的向量中读取拉格朗日乘数和对角线质量矩阵的元素（我们只能用确实有鬼魂元素的向量来写），所以我们创建各自的向量。然后我们还初始化约束对象，该对象将包含来自接触和所有其他来源的约束，以及一个包含所有属于接触的本地自由度的索引集的对象。
*


* [1.x.146]
*
* 第二部分是对所有单元的循环，在这个循环中，我们看每个点的自由度是否定义了活动集条件为真，我们需要把这个自由度加入到接触节点的活动集中。正如我们一直所做的，如果我们想在单个点上评估函数，我们用一个FEValues对象（或者，这里是FEFaceValues对象，因为我们需要检查表面的接触）和一个适当选择的正交对象来做。我们通过选择定义在单元格面上的形状函数的 "支持点 "来创建这个面的正交对象（关于支持点的更多信息，请参见这个[2.x.198]"词汇表条目"）。因此，我们有多少个正交点就有多少个面的形状函数，在正交点上循环就相当于在面的形状函数上循环。有了这个，代码看起来如下。
*


* [1.x.147]
*
* 在每个正交点（即位于接触边界上的自由度的每个支持点），我们再询问它是否是z-位移自由度的一部分，如果我们还没有遇到这个自由度（对于那些位于面之间的边缘的自由度可能会发生），我们需要评估变形物体和障碍物之间的差距。如果活动集条件为真，那么我们在AffineConstraints对象中添加一个约束，下一次牛顿更新需要满足该约束，将解向量的相应元素设置为正确的值，并将索引添加到IndexSet对象中，该索引存储哪个自由度是接触的一部分。
*


* [1.x.148]
*
* 在这个函数的最后，我们在处理器之间交换数据，更新[2.x.199]变量中那些已经被其他处理器写入的幽灵元素。然后我们将Dirichlet约束和那些来自悬挂节点的约束合并到已经包含活动集的AffineConstraints对象中。我们通过输出主动约束自由度的总数来结束这个函数，对于这个自由度，我们对每个处理器所拥有的主动约束自由度的数量进行求和。这个本地拥有的受限自由度的数量当然是活动集和本地拥有的自由度集的交集的元素数量，我们可以通过在两个IndexSets上使用[2.x.200]得到。
*


* [1.x.149]
*
* [1.x.150] [1.x.151]。


*
* 考虑到问题的复杂性，我们在每次牛顿迭代中要解决的线性系统的组合实际上是相当简单的，这可能会让人感到惊讶。下面的函数建立了牛顿的右手边和牛顿矩阵。它看起来相当简单，因为繁重的工作发生在对[2.x.201]的调用中，特别是在[2.x.202]中使用了我们之前计算的约束。
*


* [1.x.152]
*
* 在计算了应力-应变张量及其线性化之后，我们现在可以把矩阵和右手边的部分放在一起。在这两者中，我们需要线性化的应力-应变张量乘以[2.x.203]的对称梯度，即术语[2.x.204]，所以我们引入这个术语的缩写。回顾一下，该矩阵对应于随附出版物的符号中的双线性形式[2.x.205]，而右手边是[2.x.206]，其中[2.x.207]是当前的线性化点（通常是最后的解）。这可能表明，如果材料是完全弹性的，右手边将为零（其中[2.x.208]），但这忽略了一个事实，即右手边还将包含由于接触而产生的非均质约束的贡献。                   
* 接下来的代码块增加了由于边界力的贡献，如果有的话。
*


* [1.x.153]
*
* [1.x.154] [1.x.155]。


*
* 以下函数计算给定当前解（或任何其他线性化点）的方程的非线性残差。这在线性搜索算法中是需要的，我们需要尝试以前和当前（试验）解的各种线性组合来计算当前牛顿步骤的（真实的、全局化的）解。   
* 也就是说，在略微滥用函数名称的情况下，它实际上做得更多。例如，它还计算对应于牛顿残差的向量，但没有消除受限自由度。我们需要这个向量来计算接触力，并最终计算出下一个活动集。同样，通过跟踪我们在每个单元上遇到的显示塑性屈服的正交点的数量，我们也可以计算出[2.x.209]矢量，随后我们可以输出这个矢量来可视化塑性区。在这两种情况下，作为线条搜索的一部分，这些结果是不必要的，因此我们可能会浪费少量的时间来计算它们。同时，无论如何，这些信息是作为我们在这里需要做的事情的自然副产品出现的，而且我们想在每个牛顿步骤结束时收集一次，所以我们不妨在这里做。   
* 这个函数的实际实现应该是相当明显的。
*


* [1.x.156]
*
* [1.x.157] [1.x.158]。


*
* 在我们讨论单个网格上实际的牛顿迭代之前的最后一块是线性系统的求解器。有几个复杂的问题使代码略显模糊，但大多数情况下，它只是设置然后求解。在这些复杂的问题中，包括。
*


*


*


*


*


*


*


*
* - 对于悬空节点，我们必须将[2.x.210]函数应用于newton_rhs。如果一个求解值为[2.x.211]的悬空节点有一个与障碍物接触的数值为[2.x.212]的邻居和一个没有接触的邻居[2.x.213]，这就有必要。因为前者的更新将是规定的，所以悬挂的节点约束将有一个不均匀性，看起来像 [2.x.214] 。所以右侧的相应条目是无意义的非零值。这些值我们必须设置为零。
*


*
* - 与[2.x.215]一样，在求解或使用解决方案时，我们需要在有鬼元素和无鬼元素的向量之间进行洗牌。   
* 该函数的其余部分与[2.x.216]和[2.x.217]类似，只是我们使用BiCGStab求解器而不是CG。这是由于对于非常小的硬化参数[2.x.218]，线性系统变得几乎是半无限的，尽管仍然是对称的。BiCGStab似乎更容易处理这种线性系统。
*


* [1.x.159]
*
* [1.x.160] [1.x.161]。


*
* 最后，这是一个在当前网格上实现阻尼牛顿方法的函数。有两个嵌套的循环：外循环用于牛顿迭代，内循环用于直线搜索，只有在必要时才会使用。为了获得一个好的和合理的起始值，我们在每个网格上的第一个牛顿步骤中解决一个弹性问题（如果我们在网格之间转移解决方案，则只在第一个网格上解决）。我们通过在这些迭代中将屈服应力设置为一个不合理的大值，然后在随后的迭代中将其设置为正确的值。   
* 除此以外，这个函数的顶部部分应该是相当明显的。我们将变量[2.x.219]初始化为可以用双精度数字表示的最负值，这样，比较当前残差是否小于上一步的残差，在第一步中总是会失败。
*


* [1.x.162]
*
* 在我们计算了当前牛顿步骤的试解[2.x.220]之后，情况就变得有点棘手了。我们处理的是一个高度非线性的问题，所以我们必须用直线搜索的方式来抑制牛顿方法。为了理解我们如何做到这一点，请回顾一下，在我们的公式中，我们在每一个牛顿步骤中计算一个试解，而不是在新旧解之间进行更新。由于解集是一个凸集，我们将使用直线搜索，尝试以前的解和试验解的线性组合，以保证阻尼解再次出现在我们的解集中。我们最多应用5个阻尼步骤。         
* 我们使用直线搜索的时候有一些例外情况。首先，如果这是任何网格上的第一个牛顿步骤，那么我们就没有任何点来比较残差，所以我们总是接受一个完整的步骤。同样地，如果这是第一个网格上的第二个牛顿步骤（如果我们不在网格之间转移解决方案，则是任何网格上的第二个牛顿步骤），则我们只用弹性模型计算了其中的第一个步骤（见上文我们如何将屈服应力σ设置为一个不合理的大值）。在这种情况下，第一个牛顿解是一个纯粹的弹性解，第二个牛顿解是一个塑性解，任何线性组合都不一定会位于可行的集合中
*
* - 所以我们就接受刚才的解。         
* 在这两种情况下，我们绕过直线搜索，只是在必要时更新残差和其他向量。
*


* [1.x.163]

* 最后一步是检查收敛性。如果活动集在所有处理器上都没有变化，并且残差小于阈值[2.x.221] ，那么我们就终止在当前网格上的迭代。
*


* [1.x.164]
*
* [1.x.165] [1.x.166]。


*
* 如果你已经在deal.II教程中做到了这一点，下面这个细化网格的函数应该不会再对你构成任何挑战。它对网格进行细化，可以是全局的，也可以是使用Kelly误差估计器的，如果这样要求的话，还可以将前一个网格的解转移到下一个网格。在后一种情况下，我们还需要再次计算活动集和其他数量，为此我们需要由[2.x.222]计算的信息。
*


* [1.x.167]
*
* 强制执行约束条件，使插值后的解在新的网格上符合要求。
*


* [1.x.168]

* [1.x.169] [1.x.170]。


*
* 在我们到达[2.x.223]之前，剩下的三个函数都与生成输出有关。下面一个是尝试显示变形体的变形配置。为此，这个函数接收一个位移矢量场，通过先前计算的位移来移动网格（局部）的每个顶点。在生成图形输出之前，我们将以当前的位移场调用该函数，在生成图形输出之后，我们将以负的位移场再次调用该函数，以撤销对网格的改变。   
* 这个函数本身是非常简单明了的。我们所要做的就是跟踪我们已经接触过的顶点，因为我们在单元格上循环时多次遇到相同的顶点。
*


* [1.x.171]
*
* [1.x.172] [1.x.173]。


*
* 接下来是我们用来实际生成图形输出的函数。这个函数有点繁琐，但实际上并不特别复杂。它在顶部移动网格（最后再把它移回来），然后计算沿接触面的接触力。我们可以通过取未处理的残差向量，并通过询问它们是否有与之相关的不均匀约束来确定哪些自由度对应于有接触的自由度（如随文所示）。像往常一样，我们需要注意的是，我们只能写进完全分布的向量（即没有鬼魂元素的向量），但当我们想产生输出时，我们需要的向量确实有所有局部相关自由度的鬼魂条目。
*


* [1.x.174]

* 接触力的计算
*


* [1.x.175]
*
* 在函数的其余部分，我们在每个处理器上生成一个VTU文件，以这个处理器的子域ID为索引。在第一个处理器上，我们还创建了一个[2.x.224]文件，对VTU文件的[1.x.176]进行索引，这样就可以一次读取整个输出文件集。这些[2.x.225]被Paraview用来描述整个并行计算的输出文件。然后我们再为Paraview的竞争者--VisIt可视化程序做同样的事情，创建一个匹配的[2.x.226]文件。
*


* [1.x.177]
*
* [1.x.178] [1.x.179]。


*
* 这最后一个辅助函数通过计算接触面积上Z方向的接触压力的积分来计算接触力。为此，我们将所有非活动因子的接触压力lambda设置为0（一个自由度是否是接触的一部分，就像我们在前一个函数中所做的那样确定）。对于所有活动的自由度，lambda包含非线性残差（newton_rhs_uncondensed）和质量矩阵（diag_mass_matrix_vector）的相应对角线条目的商数。因为悬空节点出现在接触区的可能性不小，所以对分布式_lambda向量应用constraints_hanging_nodes.distribution很重要。
*


* [1.x.180]
*
* [1.x.181] [1.x.182]。


*
* 和其他所有的教程程序一样，[2.x.227]函数包含了整体逻辑。这里没有太多的内容：本质上，它在所有的网格细化循环中执行循环，在每个循环中，将事情交给[2.x.228]中的牛顿求解器，并调用函数为如此计算出的解决方案创建图形输出。然后输出一些关于运行时间和内存消耗的统计数据，这些数据是在这个网格的计算过程中收集的。
*


* [1.x.183]
*
* [1.x.184] [1.x.185]。


*
* [2.x.229]函数真的没有多少内容。看起来他们总是这样做。
*


* [1.x.186]
* [1.x.187][1.x.188] 。


* 包含该程序的目录还包含一些输入参数文件，可以用来创建各种不同的模拟。例如，用[2.x.230]参数文件（用球作为障碍物，用盒子作为领域）在16个核心上运行该程序，会产生这样的输出。
* [1.x.189]

* 每个周期末尾的表格显示了最近一次网格细化周期的计算时间（这些数字当然是针对产生该输出的机器的）和程序不同部分的调用次数，如装配或计算残差。上面的一些数字可以通过将解决方案从一个网格转移到另一个网格而得到改善，我们在这里没有使用这种方法。当然，你也可以通过使用更多的处理器来使程序运行得更快，尤其是在后期的细化周期中：附带的论文显示了至少1000个内核的良好扩展性。
* 在一个典型的运行中，你可以观察到，在每一个细化步骤中，活动集
*
* - 接触点
*
* --首先被迭代出来。之后，牛顿方法只需要解决塑性问题。对于更细的网格，在最后4或5次牛顿迭代中可以看到二次收敛。
* 我们不会在这里详细讨论每个输入文件的情况。相反，让我们只展示解决方案的图片（如果单元格的正交点为零，则省略域的左半部分，因为该单元格的塑性质量是有效的）。
* [2.x.231]
* 图片显示了自适应细化，以及一个单元在与球接触过程中的塑化程度。请记住，我们考虑的是每个正交点的应力偏差部分的形式，看是否有弹性或塑性行为。蓝颜色意味着该单元只包含弹性正交点，与红色单元相比，所有正交点都是塑性的。
*
* - 这里的网格是最细的
*
* - 仔细观察可以看到由障碍物造成的凹陷。这就是[2.x.232]函数的结果。然而，由于我们在这里考虑的障碍物的压痕非常小，所以很难辨别这种效果；我们可以用计算出的位移的倍数来替换网格的顶点。
* 关于使用这个程序可以得到的结果的进一步讨论，见本页面顶部提到的出版物。
*

* [1.x.190][1.x.191][1.x.192] 。


* 像往常一样，有多种可能性来扩展这个程序。从算法的角度来看，这个程序在编写时已经尽可能地使用了接触质量、塑性非线性和线性求解器的最佳可用算法。然而，就更多的现实情况而言，人们还想用这个程序做一些事情。[2.x.233] [2.x.234] 将程序从静态扩展到准静态，也许可以通过选择后向欧拉模式进行时间离散化。一些理论结果可以在Jörg Frohne的博士论文中找到，[1.x.193]，德国锡根大学，2011。
* [2.x.235] 考虑有摩擦的接触问题也是一个有趣的进展。在几乎每个机械过程中，摩擦都有很大的影响。  为了模拟这种情况，我们必须考虑到接触面的切向应力。摩擦也给我们的问题增加了另一个不等式，因为只要切向应力不超过某个极限，物体和障碍物通常会粘在一起，超过这个极限，两个物体就会互相滑动。
* 如果我们已经模拟了摩擦性接触，下一步要考虑的是接触区的发热。由两个物体之间的摩擦引起的热量会提高可变形物体的温度，并引起一些材料参数的变化。
* [2.x.237] 对于接触和塑性，实施更精确的、与问题相适应的误差估计器可能是有意义的。[2.x.238]
*

* [1.x.194][1.x.195] [2.x.239]。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-43_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43]
* [2.x.2]
* [1.x.44]


* [1.x.45][1.x.46] [1.x.47] 。


* 多孔介质中的多相流模拟是一个无处不在的问题，我们以前在 [2.x.3] 和 [2.x.4] 中已经以某种形式解决了这个问题。然而，正如在那里很容易看到的，它面临着两个主要困难：数值精度和效率。第一个困难在固定解算器[2.x.5]中很容易看到：使用最低阶的Raviart-Thomas元素不能期望产生高度精确的解。我们需要更精确的方法。第二个原因从时间依赖性[2.x.6]中可以看出：该程序慢得惊人，没有希望在合理的时间范围内得到三维的高度精确的解。
* 在这个程序中，为了克服这两个问题，有五个方面我们正在努力改进，以建立一个高性能的模拟器。
* [2.x.7] [2.x.8] 高阶空间离散 [2.x.9] 自适应网格细化 [2.x.10] 自适应时间步进 [2.x.11] 运算器分割 [2.x.12] 高效求解器和预处理 [2.x.13]
* 本程序的大部分灵感来自于[2.x.14]，但这里讨论的几个技术是原创的。
*

*[1.x.48][1.x.49]


* 我们考虑的是两相不混杂、不可压缩的流体的流动。毛细管和重力效应被忽略，而粘性效应被假定为主导因素。这种流动的管理方程与[2.x.15]中使用的方程相同，为
* [1.x.50]
* 其中[2.x.16]是第二（润湿）相的饱和度（体积分数在0和1之间），[2.x.17]是压力，[2.x.18]是渗透性张量，[2.x.19]是总流动性，[2.x.20]是孔隙率，[2.x.21]是润湿相的分流量，[2.x.22]是源项，[2.x.23]是总速度。总流动性、润湿相的分流量和总速度分别由以下公式给出
* [1.x.51]
* 其中，下标[2.x.24]分别代表湿润相和非湿润相。
* 为方便起见，饱和度方程中的孔隙度[2.x.25]可视为时间变量的上升因子，被设定为1。根据相对渗透率[2.x.26]和[2.x.27]对饱和度的依赖性的常用规定，我们使用
* [1.x.52]
*
* 上面的多孔介质方程由饱和度的初始条件和压力的边界条件组成。由于饱和度和压力梯度唯一地决定了速度，因此不需要速度的边界条件。由于流动方程不包含时间导数，因此不需要速度和压力变量的初始条件。流动场将边界分为流入或流出部分。具体来说，[1.x.53]，我们通过对流入边界的饱和度变量施加边界值，得出一个完整的模型[2.x.28] 。
*

*[1.x.54][1.x.55]


* 正如在[2.x.29]中所看到的，一旦我们知道了流量变量，求解速度和压力的流量方程是程序中花费时间远大于饱和度变量的（显式）更新步骤的部分。另一方面，压力和速度对饱和度的依赖性很弱，因此可以考虑每隔几步只求解压力和速度，而每步更新饱和度。如果我们能找到一个关于何时需要更新流量变量的标准，我们就把这种分割称为 "自适应运算器分割 "方案。
* 在这里，我们使用以下后验标准来决定何时重新计算压力和速度变量（详细推导和描述可参见[Chueh, Djilali和Bangerth 2011]）。
* [1.x.56]
* 其中括号内的上标表示定义任何数量的饱和时间步数，[2.x.30]代表我们实际计算压力和速度的最后一步。如果[2.x.31]超过某个阈值，我们就重新计算流量变量；否则，我们就在时间步骤[2.x.32]中停止计算，只将饱和变量向前移动一个时间步骤。
* 简言之，该算法允许我们执行若干长度为[2.x.33]的饱和时间步长，直到上述准则告诉我们要重新计算速度和压力变量，从而导致一个长度为[1.x.57]的宏观时间步长。]，我们已经证实，对于下面讨论的饱和方程的有限元和时间步长方案的选择是稳定的（[2.x.34]表示单元格[2.x.35]的直径）。结果是一个方案，微观和宏观时间步长都不一致，两者都是自适应选择。
*[1.x.59][1.x.60]。
* 使用这种时间离散化，我们可以从IMPES方法中得到以下每个时间步长的方程组（见[2.x.36]）。
* [1.x.61]
*
*

*利用[2.x.37]这一事实，时间离散饱和度方程变为
* [1.x.62]
*
* [1.x.63][1.x.64] 。


* 通过将定义总速度的方程[2.x.38]和用源项表示其发散的方程分别与检验函数[2.x.39]和[2.x.40]相乘，然后根据需要进行分项积分，该问题的弱式为：。找出[2.x.41]，以便对所有测试函数[2.x.42]而言，持有[1.x.65] 。
* 这里，[2.x.43]代表[2.x.44]的单位外向法向量，压力[2.x.45]可以在边界的开放部分[2.x.46]弱化规定，而在那些规定了速度的部分（例如具有[2.x.47]的不透水边界），该术语完全消失，因为[2.x.48] 。
* 我们使用连续有限元来离散化速度和压力方程。具体而言，我们使用混合有限元来确保同时对矢量变量（如流体速度）和标量变量（如压力）进行高阶逼近。对于鞍点问题，已经确定所谓的Babuska-Brezzi或Ladyzhenskaya-Babuska-Brezzi（LBB）条件[Brezzi 1991, Chen 2005]需要得到满足以确保压力-速度系统的稳定性。在本工作中，通过使用比压力高一阶的速度元素来满足这些稳定性条件，即[2.x.49]和[2.x.50]，其中[2.x.51]、[2.x.52]是空间维度，[2.x.53]表示每个变量的张量积拉格朗多项式的空间[2.x.54]。
* [1.x.66][1.x.67] 。
* 为饱和方程选择的[2.x.55]元素不能导致没有上卷或其他类型的稳定化的稳定微分，并且在数值解中会出现虚假的震荡。添加一个人工扩散项是消除这些振荡的一种方法[Chen 2005]。另一方面，添加过多的扩散项会在解中涂抹出尖锐的锋芒，并且会有网格定位的困难[Chen 2005]。为了避免这些影响，我们使用了由[Guermond and Pasquetti 2008]提出并在[Chueh, Djilali, Bangerth 2011]和[Kronbichler, Heister and Bangerth, 2011]以及[2.x.56]中验证的人工扩散项。
* 这种方法修改了饱和方程的（离散）弱形式，将其改为
* [1.x.68]
* 其中[2.x.57]是人工扩散参数，[2.x.58]是在域的边界上适当选择的数值通量（我们为此选择明显的全上风通量）。
* 按照[Guermond and Pasquetti 2008]（以及[Chueh, Djilali and Bangerth 2011]中的详细说明），我们将参数作为一个片断常数函数，设置在每个单元[2.x.59]上，直径为[1.x.69]，其中[2.x.61]是一个稳定指数，[2.x.62]是一个无尺寸的用户定义的稳定常数。按照[Guermond and Pasquetti 2008]以及[2.x.63]中的实现，速度和饱和全局正常化常数[2.x.64]以及残差[2.x.65]分别由[1.x.70]和[1.x.71]，其中[2.x.66]是用户定义的第二个无维常数，[2.x.67]是域的直径，[2.x.68]是整个计算域中的饱和度值范围[2.x.69]。
* 这种稳定方案与更简单的方案相比有很多优势，如有限体积（或不连续Galerkin）方法或流线型上风Petrov Galerkin（SUPG）离散。特别是，人工扩散项主要作用于不连续点附近，因为在饱和度平稳的地方，残差很小。因此，它提供了一个更高的精度。另一方面，它是非线性的，因为[2.x.70]取决于饱和度[2.x.71]。我们通过明确处理所有的非线性项来避免这一困难，这导致了在时间步长[2.x.72]的以下离散问题。
* [1.x.72]
* 其中[2.x.73]为从[2.x.74]和[2.x.75]线性外推到当前时间的速度[2.x.76]，如果[2.x.77]，而[2.x.78]为[2.x.79]，如果[2.x.80]。因此，该方程在[2.x.81]是线性的，所需要的是用饱和空间的质量矩阵解决。
* 由于饱和度的Dirichlet边界条件只施加在流入边界上，所以上述方程左侧的第三项需要进一步拆分为两部分。
* [1.x.73]
* 其中[2.x.82]和[2.x.83]分别代表流入和流出的边界。我们使用上风公式选择数值，即[2.x.84]和[2.x.85]对应于从当前单元中获取的数值，而[2.x.86]和[2.x.87]的数值是从邻近边界[2.x.88]获取的数值。
*

*[1.x.74][1.x.75]


* 适应性地选择网格以解决尖锐饱和前沿问题是我们算法中实现效率的一个基本要素。在这里，我们使用[Chueh, Djilali and Bangerth 2011]中使用的相同的冲击型细化方法来选择那些应该被细化或粗化的单元。三角形的每个单元[2.x.89]的细化指标由[1.x.76]计算，其中[2.x.90]是在单元[2.x.92]的中心[2.x.91]评价的离散饱和变量的梯度。这种方法类似于在可压缩流动问题中经常使用的方法，其中密度梯度被用来表示细化。也就是说，正如我们将在[1.x.77]末尾讨论的那样，这并不是一个非常有用的标准，因为它基本上在任何地方都导致了细化。我们在这里只是为了说明问题而展示它。
*

*[1.x.78][1.x.79] 。


* 按照上面讨论的治理方程的离散化，我们得到一个时间步长[2.x.93]的线性方程组，其形式如下：[1.x.80]其中各个矩阵和向量的定义如下，使用形状函数[2.x.94]表示速度，[2.x.95]表示压力和饱和度。
* [1.x.81]
*和[2.x.96]，如稳定运输方程的定义中给出的。
* 如果我们把矩阵的左上角[2.x.97]板块视为一个板块，则上述线性系统是块状三角形形式的。因此，我们可以首先求解速度和压力（除非我们决定用[2.x.98]代替速度），然后再求解饱和度变量。其中第一个步骤要求我们求解[1.x.82]，我们对这个线性系统采用广义最小残差（GMRES）方法[Saad和Schultz1986]。速度-压力系统的理想预处理程序是
* [1.x.83]
* 其中[2.x.99]是该系统的Schur补码[Zhang 2005]。这个预处理程序是最佳的，因为
* [1.x.84]
* 可以证明，GMRES在两次迭代中收敛。
* 然而，我们当然不能指望使用速度质量矩阵和Schur补码的精确求逆。因此，我们遵循[Silvester and Wathen 1994]最初为斯托克斯系统提出的方法。将其适用于当前的方程组，可以得到预设条件器
* [1.x.85]
* 其中，斜线表示精确反矩阵的近似值。特别是，由于[2.x.100]是一个稀疏的对称和正定矩阵，我们为[2.x.101]选择了这个矩阵的一个稀疏的不完全Cholesky分解的应用[Golub和Van Loan 1996]。我们注意到，对应于非混合形式的多介质流算子的Schur补，[2.x.102]和[2.x.103]应该是实际Schur补矩阵[2.x.104]的良好近似。由于这两个矩阵又都是对称和正定的，我们使用[2.x.105]的不完全Cholesky分解来表示[2.x.106]。需要注意的是，[2.x.107]需要用迪里希特边界条件建立，以确保其可逆性。
* 一旦有了速度[2.x.108]，我们就可以把[2.x.109]和[2.x.110]组合起来，用以下方法解决饱和问题
* [1.x.86]
* 其中质量矩阵[2.x.111]用共轭梯度法求解，再次使用不完整的Cholesky分解作为预处理。
* [1.x.87][1.x.88] 。
*


* [2.x.112] 这里讨论的实现使用并扩展了本库的[2.x.113]、[2.x.114]和[2.x.115]教程中的部分程序。特别是，如果你想了解它是如何工作的，请参考[2.x.116]关于数学问题的讨论，以及[2.x.117]，大部分的实现都是来自于此。我们不会讨论已经在[2.x.118]中讨论过的实现的各个方面。
* 我们展示了一些两相流方程的数值结果，这些方程通过适当的初始和边界条件与两种不同的渗透率模型的选择进行了增强。在所考虑的问题中，没有内源项（ [2.x.119] ）。如上所述，定量的数值结果在[Chueh, Djilali and Bangerth 2011]中提出。
* 为了简单起见，我们选择了[2.x.120]，尽管所有的方法（以及我们的实现）在一般的非结构化网格上都应该同样好用。
* 初始条件只需要饱和变量，我们选择[2.x.121]，即多孔介质最初由非湿润（80%）和湿润（20%）的混合相填充。这与[2.x.122]中的初始条件不同，我们采用了[2.x.123]，但由于复杂的数学原因，在那里有一个很长的注释提到，目前使用基于熵的人工扩散项的方法在这个初始条件下不能收敛到粘度解，不需要对该方法进行额外的修改。因此，我们为目前的方案选择了这个修改过的版本。
* 此外，我们在边界上规定了一个线性压力：[1.x.89]压力和饱和度唯一地决定了一个速度，而速度决定了一个边界段是流入还是流出的边界。在边界的流入部分，[2.x.124]，我们规定
* [1.x.90]
* 换句话说，领域被来自左边的湿润相淹没。对于边界的流出部分，不需要饱和的边界条件。
* 所有用于二维/三维案例的数值和物理参数都列在下表中。
* [2.x.125]
*

*[1.x.91][1.x.92] 。



* [2.x.126] [2.x.127] CC Chueh, N Djilali and W Bangerth.[2.x.128] 三维异质多孔介质中两相流的h-适应性算子分割方法。[2.x.129] SIAM Journal on Scientific Computing, vol. 35 (2013), pp.
* [2.x.130] M. Kronbichler, T. Heister, and W. Bangerth [2.x.131] High Accuracy Mantle Convection Simulation through Modern NumericalMethods.[2.x.132] Geophysics Journal International, vol. 191 (2012), pp.
* [2.x.133] F Brezzi and M Fortin.[2.x.134] [1.x.93].[2.x.135] Springer-Verlag, 1991.
* [2.x.136] Z Chen.[2.x.137] [1.x.94].[2.x.138] Springer, 2005.
* [2.x.139] JL Guermond和R Pasquetti.[2.x.140] 基于熵的非线性黏度，用于守恒定律的傅里叶近似。[2.x.141] [1.x.95], 346(13-14): 801-806, 2008.
* [2.x.142] CC Chueh, M Secanell, W Bangerth, and N Djilali.[2.x.143] 异质多孔介质中瞬态两相流的多级自适应模拟。[2.x.144] [1.x.96], 39:1585-1596, 2010.
* [2.x.145] Y Saad和MH Schultz。[2.x.146] Gmres:用于解决非对称线性系统的广义最小残差算法。[2.x.147] [1.x.97], 7(3):856-869, 1986.
* [2.x.148] F Zhang.[2.x.149] [1.x.98].[2.x.150] Springer, 2005.
* [2.x.151] D Silvester and A Wathen.[2.x.152] 稳定的斯托克斯系统的快速迭代求解第二部分：使用一般块状先决条件。[2.x.153] [1.x.99], 31(5):1352-1367, 1994.
* [2.x.154] GH Golub和CF van Loan.[2.x.155] [1.x.100].[2.x.156] 第三版，约翰霍普金斯大学，1996年。
* [2.x.157] SE Buckley和MC Leverett。[2.x.158] 沙子中流体位移的机制。[2.x.159] [1.x.101], 146:107-116, 1942.
* [2.x.160]


* [1.x.102] [1.x.103]。
* [1.x.104] [1.x.105]。


*
* 像往常一样，第一步是包括一些deal.II和C++头文件的功能。
*


* 列表中包括一些头文件，这些文件提供了向量、矩阵和先决条件器类，这些类实现了各自Trilinos类的接口；关于这些的一些更多信息可以在 [2.x.161] 中找到。
*


* [1.x.106]
*
* 在这个顶层设计的最后，我们为当前的项目打开一个命名空间，下面的所有材料都将进入这个命名空间，然后将所有deal.II的名字导入这个命名空间。
*


* [1.x.107]
*
* [1.x.108] [1.x.109]。


*
* 下面的部分直接取自[2.x.162]，所以没有必要重复那里的描述。
*


* [1.x.110]
*
* [1.x.111] [1.x.112]。


*
* 在本教程中，我们仍然使用以前在[2.x.163]中使用的两个渗透率模型，所以我们再次避免对它们进行详细的评论。
*


* [1.x.113]
*
* [1.x.114] [1.x.115]。


*
* 所有物理量的实现，如总流动性[2.x.164]和水的部分流量[2.x.165]都来自[2.x.166]，所以我们也没有对它们做任何评论。与[2.x.167]相比，我们增加了检查，以确保传递给这些函数的饱和度实际上是在物理上的有效范围内。此外，鉴于润湿相以速度[2.x.168]移动，很明显[2.x.169]必须大于或等于零，所以我们也断言，以确保我们为得到导数的公式而进行的计算是合理的。
*


* [1.x.116]
*
* [1.x.117] [1.x.118]。


*
* 在这第一部分中，我们定义了一些我们在构建线性求解器和预处理器时需要的类。这一部分与 [2.x.170] 中使用的基本相同。唯一不同的是，原来的变量名称stokes_matrix被另一个名称darcy_matrix取代，以配合我们的问题。
*


* [1.x.119]
*
* [1.x.120] [1.x.121]。



* 定义了解决随时间变化的平流主导的两相流问题（或Buckley-Leverett问题[Buckley 1942]）的顶层逻辑的类，主要是基于教程程序[2.x.171]和[2.x.172]，特别是[2.x.173]，我们在这里使用的一般结构基本相同。与[2.x.174]一样，在下面的实现中需要寻找的关键例程是[2.x.175]函数。   
* 与[2.x.176]的主要区别是，由于考虑了自适应算子拆分，我们需要多几个成员变量来保存最近两次计算的Darcy（速度/压力）解，以及当前的解（直接计算，或从前两次计算中推导出来），我们需要记住最近两次计算Darcy解的时间。我们还需要一个辅助函数来确定我们是否确实需要重新计算达西解。   
* 与[2.x.177]不同，这一步多用了一个AffineConstraints对象，叫做 darcy_preconditioner_constraints。这个约束对象仅用于为Darcy预处理程序组装矩阵，包括悬挂节点约束以及压力变量的Dirichlet边界值约束。我们需要这个，因为我们正在为压力建立一个拉普拉斯矩阵，作为舒尔补数的近似值），如果应用边界条件，这个矩阵是正定的。   
* 这样在这个类中声明的成员函数和变量的集合与[2.x.178]中的相当相似。
*


* [1.x.122]
*
* 我们接下来会有一些辅助函数，这些函数在整个程序中的不同地方都会用到。
*


* [1.x.123]
*
* 这一切之后是成员变量，其中大部分与[2.x.179]中的变量相似，但与速度/压力系统的宏观时间步长有关的变量除外。
*


* [1.x.124]
*
* 在最后，我们声明一个变量，表示材料模型。与[2.x.180]相比，我们在这里把它作为一个成员变量，因为我们想在不同的地方使用它，所以有一个声明这样一个变量的中心位置将使我们更容易用另一个类来替代一个类（例如，用[2.x.182]替代[2.x.181]）。
*


* [1.x.125]
*
* [1.x.126] [1.x.127]。


*
* 这个类的构造函数是对 [2.x.183] 和 [2.x.184] 中的构造函数的扩展。我们需要添加有关饱和度的各种变量。正如介绍中所讨论的，我们将再次使用[2.x.185]（Taylor-Hood）元素来表示Darcy系统，这是一个满足Ladyzhenskaya-Babuska-Brezzi（LBB）条件的元素组合[Brezzi and Fortin 1991, Chen 2005]，以及[2.x.186]元素表示饱和度。然而，通过使用存储Darcy和温度有限元的多项式程度的变量，可以很容易地持续修改这些元素的程度以及在其上使用的所有正交公式的下游。此外，我们还初始化了与算子分割有关的时间步进变量，以及矩阵装配和预处理的选项。
*


* [1.x.128]
*
* [1.x.129] [1.x.130]。


*
* 这个函数设置了我们这里的DoFHandler对象（一个用于Darcy部分，一个用于饱和部分），以及将本程序中线性代数所需的各种对象设置为合适的尺寸。其基本操作与[2.x.187]所做的类似。   
* 函数的主体首先列举了达西和饱和系统的所有自由度。对于Darcy部分，自由度被排序以确保速度优先于压力DoF，这样我们就可以将Darcy矩阵划分为一个[2.x.188]矩阵。   
* 然后，我们需要将悬挂节点约束和迪里切特边界值约束纳入darcy_preconditioner_constraints。  边界条件约束只设置在压力分量上，因为对应于非混合形式的多孔介质流算子的Schur补码预处理[2.x.189] ，只作用于压力变量。因此，我们使用一个过滤掉速度分量的分量掩码，这样冷凝就只在压力自由度上进行。   
* 做完这些后，我们计算各块中的自由度数量。然后，这些信息被用来创建达西和饱和系统矩阵的稀疏模式，以及用于建立达西预处理的预处理矩阵。如同在[2.x.190]中，我们选择使用DynamicSparsityPattern的封锁版本来创建模式。因此，对于这一点，我们遵循与[2.x.191]相同的方式，对于成员函数的其他部分，我们不必再重复描述。
*


* [1.x.131]
*
* [1.x.132] [1.x.133]。


*
* 接下来的几个函数是专门用来设置我们在这个程序中必须处理的各种系统和预处理矩阵及右手边的。
*


* [1.x.134] [1.x.135]。


*
* 这个函数组装了我们用于预处理达西系统的矩阵。我们需要的是一个由[2.x.192]加权的速度分量的矢量质量矩阵和一个由[2.x.193]加权的压力分量的质量矩阵。我们首先生成一个适当阶数的正交对象，即FEValues对象，可以给出正交点的数值和梯度（连同正交权重）。接下来我们为单元格矩阵和局部与全局DoF之间的关系创建数据结构。向量phi_u和grad_phi_p将保存基函数的值，以便更快地建立局部矩阵，正如在 [2.x.194] 中已经做的。在我们开始对所有活动单元进行循环之前，我们必须指定哪些成分是压力，哪些是速度。   
* 本地矩阵的建立相当简单。只有一个由[2.x.195]加权的项（关于速度）和一个由[2.x.196]加权的拉普拉斯矩阵需要生成，所以局部矩阵的创建基本上在两行完成。由于该文件顶部的材料模型函数只提供了渗透率和迁移率的反值，我们必须根据给定的值手工计算[2.x.197]和[2.x.198]，每个正交点一次。   
* 一旦本地矩阵准备好了（在每个正交点上循环计算本地矩阵的行和列），我们就可以得到本地的DoF指数，并将本地信息写入全局矩阵中。我们通过直接应用约束条件（即darcy_preconditioner_constraints）来做到这一点，该约束条件负责处理悬挂节点和零Dirichlet边界条件约束。这样做，我们就不必事后再做，以后也不必使用[2.x.199]和[2.x.200]这两个需要修改矩阵和向量项的函数，因此对于我们不能立即访问单个内存位置的特里诺斯类来说，很难编写。
*


* [1.x.136]
*
* [1.x.137] [1.x.138]。


*
* 在调用上述函数组装预处理矩阵后，该函数生成将用于舒尔补块预处理的内部预处理器。前置条件需要在每个饱和时间步长时重新生成，因为它们取决于随时间变化的饱和度[2.x.201]。   
*在这里，我们设置了速度-速度矩阵[2.x.202]和Schur补码[2.x.203]的预处理器。正如介绍中所解释的，我们将使用一个基于矢量矩阵[2.x.204]的IC预处理器和另一个基于标量拉普拉斯矩阵[2.x.205]的IC预处理器（其频谱上接近达西矩阵的Schur补集）。通常，[2.x.206]类可以被看作是一个很好的黑箱预处理程序，不需要对矩阵结构和/或背后的算子有任何特殊的了解。
*


* [1.x.139]
*
* [1.x.140] [1.x.141]。


*
* 这是为达西系统组装线性系统的函数。   
* 关于执行的技术细节，其程序与 [2.x.207] 和 [2.x.208] 中的程序相似。我们重置矩阵和向量，在单元格上创建正交公式，然后创建相应的FEValues对象。   
* 有一件事需要评论：由于我们有一个单独的有限元和DoFHandler来处理饱和问题，我们需要生成第二个FEValues对象来正确评估饱和解。要实现这一点并不复杂：只需使用饱和结构，并为基函数值设置一个更新标志，我们需要对饱和解进行评估。这里需要记住的唯一重要部分是，两个FEValues对象使用相同的正交公式，以确保我们在两个对象的正交点上循环时得到匹配的信息。   
* 声明的过程中，对数组的大小、本地矩阵的创建、右手边以及与全局系统相比的本地道夫的指数的向量都有一些快捷方式。
*


* [1.x.142]
*
* 接下来我们需要一个向量，该向量将包含前一个时间层的饱和解在正交点的值，以组装达西方程中的饱和依赖系数。     
* 我们接下来创建的向量集包含了基函数的评价以及它们的梯度，将用于创建矩阵。把这些放到自己的数组中，而不是每次都向FEValues对象索取这些信息，这是一种优化，可以加速组装过程，详情见[2.x.209]。     
* 最后两个声明是用来从整个FE系统中提取各个块（速度、压力、饱和度）的。
*


* [1.x.143]
*
* 现在开始对问题中的所有单元格进行循环。我们正在为这个装配例程处理两个不同的DoFHandlers，所以我们必须为使用中的两个对象设置两个不同的单元格迭代器。这可能看起来有点奇怪，但是由于达西系统和饱和系统都使用相同的网格，我们可以假设这两个迭代器在两个DoFHandler对象的单元格上同步运行。     
* 循环中的第一条语句又是非常熟悉的，按照更新标志的规定对有限元数据进行更新，将局部数组清零，并在正交点处得到旧解的值。  在这一点上，我们还必须在正交点上获得前一个时间步长的饱和函数的值。为此，我们可以使用[2.x.210]（之前已经在[2.x.211]、[2.x.212]和[2.x.213]中使用），这个函数接收一个解向量，并返回当前单元的正交点的函数值列表。事实上，它返回每个正交点的完整矢量值解，即不仅是饱和度，还有速度和压力。     
* 然后，我们就可以在单元上的正交点上进行循环，以进行积分。这方面的公式直接来自介绍中所讨论的内容。     
* 一旦完成，我们就开始在局部矩阵的行和列上进行循环，并向矩阵提供相关的产物。     
* 循环所有单元的最后一步是将本地贡献输入到全局矩阵和向量结构中，并在local_dof_indices中指定位置。同样，我们让AffineConstraints类将单元矩阵元素插入到全局矩阵中，全局矩阵已经浓缩了悬挂的节点约束。
*


* [1.x.144]
*
* [1.x.145] [1.x.146]。


*
* 这个函数是为了组装饱和传输方程的线性系统。如果有必要，它会调用另外两个成员函数：assemble_saturation_matrix() 和 assemble_saturation_rhs()。前一个函数然后组装饱和度矩阵，只需要偶尔改变。另一方面，后一个组装右手边的函数必须在每个饱和时间步骤中调用。
*


* [1.x.147]
*
* [1.x.148] [1.x.149]。


*
*这个函数很容易理解，因为它只是通过基函数phi_i_s和phi_j_s为饱和线性系统的左侧形成一个简单的质量矩阵。最后，像往常一样，我们通过在local_dof_indices中指定位置将局部贡献输入全局矩阵。这是通过让AffineConstraints类将单元矩阵元素插入全局矩阵来完成的，全局矩阵已经浓缩了悬挂节点约束。
*


* [1.x.150]
*
* [1.x.151] [1.x.152]。


*
* 这个函数是用来组装饱和输运方程的右侧的。在进行这项工作之前，我们必须为达西系统和饱和系统分别创建两个FEValues对象，此外，还需要为这两个系统创建两个FEFaceValues对象，因为我们在饱和方程的弱形式中有一个边界积分项。对于饱和系统的FEFaceValues对象，我们还需要法向量，我们使用update_normal_vectors标志来申请。   
* 接下来，在对所有单元进行循环之前，我们必须计算一些参数（例如global_u_infty、global_S_variation和global_Omega_diameter），这是人工粘度[2.x.214]需要的。这与在[2.x.215]中所做的大致相同，所以你可以在那里获得更多信息。   
* 真正的工作开始于对所有饱和和Darcy单元的循环，以将局部贡献放入全局矢量。在这个循环中，为了简化实现，我们把一些工作分成两个辅助函数：assemble_saturation_rhs_cell_term和assemble_saturation_rhs_boundary_term。  我们注意到，我们在这两个函数中把细胞或边界贡献插入全局向量，而不是在本函数中。
*


* [1.x.153]
*
* [1.x.154] [1.x.155]。


*
* 这个函数负责整合饱和度方程右边的单元项，然后将其组装成全局右边的矢量。鉴于介绍中的讨论，这些贡献的形式很清楚。唯一棘手的部分是获得人工黏度和计算它所需的一切。该函数的前半部分专门用于这项任务。   
* 该函数的最后部分是将局部贡献复制到全局向量中，其位置由local_dof_indices指定。
*


* [1.x.156]
*
* [1.x.157] [1.x.158]。


*
* 下一个函数负责饱和方程右侧形式中的边界积分项。  对于这些，我们必须计算全局边界面上的上行通量，也就是说，我们只对全局边界的流入部分弱加迪里切特边界条件。如前所述，这在[2.x.216]中已经描述过了，所以我们不对其进行更多的描述。
*


* [1.x.159]
*
* [1.x.160] [1.x.161]。


*
* 该函数实现了算子分割算法，即在每个时间步长中，它要么重新计算达西系统的解，要么从以前的时间步长中推算出速度/压力，然后确定时间步长的大小，再更新饱和变量。其实现主要遵循 [2.x.217] 中的类似代码。除了run()函数外，它是本程序中的核心函数。   
* 在函数的开始，我们询问是否要通过评估后验准则来解决压力-速度部分（见下面的函数）。如果有必要，我们将使用GMRES求解器与Schur补充块预处理来求解压力-速度部分，如介绍中所述。
*


* [1.x.162]
*
* 另一方面，如果我们已经决定不想计算当前时间步长的达西系统的解，那么我们需要简单地将前两个达西解外推到与我们计算速度/压力时相同的时间。我们做一个简单的线性外推，即给定从上次计算达西解到现在的宏观时间步长[2.x.218]（由[2.x.219]给出），以及[2.x.220]上一个宏观时间步长（由[2.x.221]给出），然后我们得到[2.x.222]，其中[2.x.223]和[2.x.224]是最近两个计算的达西解。我们只需用两行代码就可以实现这个公式。     
* 请注意，这里的算法只有在我们至少有两个先前计算的达西解，我们可以从中推断出当前时间的情况下才会起作用，这一点通过要求重新计算前两个时间步骤的达西解来保证。
*


* [1.x.163]
*
*用这样计算出来的速度矢量，根据介绍中讨论的CFL标准计算出最佳时间步长......
*


* [1.x.164]
*
* ......然后还要更新我们使用的宏观时间步长，同时我们要处理时间步长的问题。具体而言，这涉及到(i) 如果我们刚刚重新计算了达西解，那么之前的宏观时间步长现在是固定的，当前的宏观时间步长，到现在为止，只是当前（微观）时间步长。(ii) 如果我们没有重新计算达西解，那么当前的宏观时间步长刚刚增长了[2.x.225] 。
*


* [1.x.165]
*
* 这个函数的最后一步是根据我们刚刚得到的速度场重新计算饱和解。这自然发生在每一个时间步骤中，我们不会跳过任何一个计算。在计算饱和度的最后，我们投射回允许的区间[2.x.226]，以确保我们的解保持物理状态。
*


* [1.x.166]
*
* [1.x.167] [1.x.168]。


*
* 下一个函数是对网格进行细化和粗化。它的工作分三块进行。(i) 计算细化指标，方法是通过使用各自的时间步长（如果这是第一个时间步长，则取唯一的解决方案），从前两个时间步长中线性推断出的解决方案向量的梯度。(ii) 在梯度大于或小于某一阈值的单元中标记出细化和粗化的单元，保留网格细化的最小和最大水平。(iii) 将解决方案从旧网格转移到新网格。这些都不是特别困难。
*


* [1.x.169]
*
* [1.x.170] [1.x.171]。


*
* 这个函数生成了图形输出。它本质上是对 [2.x.227] 中的实现的一个复制。
*


* [1.x.172]
*
* [1.x.173] [1.x.174]。



* [1.x.175] [1.x.176]。


*
* 这个函数实现了自适应算子拆分的后验准则。考虑到我们在上面实现其他函数的方式，并考虑到论文中得出的准则公式，这个函数是相对简单的。   
* 如果我们决定要采用原始的IMPES方法，即在每个时间步长中求解Darcy方程，那么可以通过将阈值[2.x.228]（默认为[2.x.229]）设置为零来实现，从而迫使该函数总是返回真。   
* 最后，请注意，该函数在前两个时间步骤中无条件地返回真，以确保我们在跳过达西系统的解时总是至少解了两次，从而允许我们从[2.x.230]中的最后两个解中推算出速度。
*


* [1.x.177]
*
* [1.x.178] [1.x.179]。


*
* 下一个函数只是确保饱和度值始终保持在[2.x.231]的物理合理范围内。虽然连续方程保证了这一点，但离散方程并没有。然而，如果我们允许离散解逃脱这个范围，我们就会遇到麻烦，因为像[2.x.232]和[2.x.233]这样的项会产生不合理的结果（例如[2.x.234]为[2.x.235]，这将意味着润湿液相的流动方向为[1.x.180]的散流体速度））。因此，在每个时间步骤结束时，我们只需将饱和场投射回物理上合理的区域。
*


* [1.x.181]
*
* [1.x.182] [1.x.183]。
* 另一个比较简单的辅助函数。计算总速度乘以分数流函数的导数的最大值，即计算 [2.x.236] 。这个项既用于时间步长的计算，也用于人工黏度中的熵留项的归一化。
*


* [1.x.184]
*
* [1.x.185] [1.x.186]。
* 为了计算稳定化项，我们需要知道饱和变量的范围。与[2.x.237]不同的是，这个范围很容易被区间[2.x.238]所约束，但我们可以通过在正交点的集合上循环，看看那里的值是什么，从而做得更好。如果可以的话，也就是说，如果周围至少有两个时间步长，我们甚至可以把这些值外推到下一个时间步长。   
* 和以前一样，这个函数是以最小的修改取自[2.x.239] 。
*


* [1.x.187]
*
* [1.x.188] [1.x.189]。
* 最后一个工具函数是用来计算给定单元上的人工粘度的。如果你面前有它的公式，这并不特别复杂，看一下 [2.x.240] 中的实现。与该教程程序的主要区别是，这里的速度不是简单的[2.x.241]，而是[2.x.242]，一些公式需要做相应的调整。
*


* [1.x.190]
*
* [1.x.191] [1.x.192]。


*
* 除了[2.x.243]之外，这个函数是这个程序的主要功能，因为它控制了迭代的时间，以及何时将解写入输出文件和何时进行网格细化。   
* 除了启动代码通过[2.x.244]标签循环回到函数的开头之外，一切都应该是相对简单的。无论如何，它模仿了 [2.x.245] 中的相应函数。
*


* [1.x.193]
*
* [1.x.194] [1.x.195]。



* 主函数看起来与所有其他程序几乎相同。对于使用Trilinos的程序，需要初始化MPI子系统
*
* - 即使对于实际上没有并行运行的程序也是如此
*
* - 在 [2.x.246] 中有解释。
*


* [1.x.196]
*
* 这个程序只能在串行中运行。否则，抛出一个异常。
*


* [1.x.197]
* [1.x.198][1.x.199] 。


*
* 这个程序的输出与[2.x.247]的输出其实没有什么不同：毕竟它解决的是同一个问题。更重要的是量化指标，如解决方案的准确性，以及计算所需的时间。这些在本页顶部列出的两份出版物中都有详细记载，我们在此不再重复。
* 尽管如此，如果没有几张好的图片，任何教程程序都是不完整的，所以这里有一些3D运行的输出。
* [2.x.248]
*

* [1.x.200][1.x.201][1.x.202] 。


* 人们对这个程序的主要反对意见是它仍然太慢了：在合理的细网格上进行三维计算实在是太昂贵了，不可能经常性地进行，也不可能有合理的快速周转。这与我们编写[2.x.249]时的情况类似，本程序也是从中得到很多启发的。解决办法也和当时的情况类似。我们需要以类似于从[2.x.251]中导出[2.x.250]的方式将程序并行化。事实上，[2.x.252]中使用的所有技术也可以转移到这个程序中，使程序立即在几十或几百个处理器上运行。
* 一个不同的方向是使该程序与许多其他有孔媒体应用更相关。具体来说，一个途径是进入多孔介质流动模拟器的主要用户，即石油工业。在那里，该领域的应用以多相流动为主（即超过我们这里的两相），以及它们之间可能发生的反应（或任何其他相的质量交换方式，如通过溶解和气泡从油相中流出的气体）。此外，气体的存在通常会导致流体的可压缩性效应。这些效应通常共同构成了广泛使用的 "黑油模型"。多相之间的真实反应在油藏模型中也起作用，因为考虑到油藏中石油的控制性燃烧以提高压力和温度。不过，这些问题要复杂得多，留待今后的项目处理。
* 最后，从数学的角度来看，我们得出了在某一时间步长重新计算速度/压力解的标准，假设我们想把当前时间步长得到的解与上次实际解决该系统时的解进行比较。然而，在程序中，每当我们没有重新计算解决方案时，我们不只是使用之前计算的解决方案，而是从之前两次解决该系统的过程中推断出来。因此，该标准被悲观地表述为：我们真正应该比较的是我们在当前时间步长中得到的解和外推的解。在这方面，重新阐述该定理是一个练习。
* 还有其他方法可以扩展这个程序的数学基础；例如，我们可以说，我们关心的不是速度，而实际上是饱和度。因此，人们可能会问，我们在这里用来决定是否需要计算[2.x.253]的标准是否合适；例如，人们可能会建议，决定一个错误的速度场是否（以及多少）事实上影响到饱和方程的解，也是很重要的。这自然会导致敏感性分析。
* 从算法的角度来看，我们在这里使用了工程中经常使用的细化标准，即通过观察解的梯度。然而，如果你检查解决方案，你会发现它几乎在所有地方都能迅速导致细化，甚至在明显不需要细化的区域：因此经常使用并不意味着它是一个有用的标准。另一方面，用一个不同的、更好的标准来取代这个标准应该不是很困难。例如，许多其他程序中使用的KellyErrorEstimator类肯定也适用于当前的问题。
*

* [1.x.203][1.x.204] [2.x.254]。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-44_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39][1.x.40][1.x.41][1.x.42][1.x.43][1.x.44][1.x.45][1.x.46][1.x.47][1.x.48][1.x.49][1.x.50][1.x.51]
* [2.x.2]
* [1.x.52]
* [2.x.3]
* [1.x.53][1.x.54][1.x.55] 。
*

* 本教程的主题是非线性固体力学。经典的单场方法（例如，见[2.x.4)不能正确描述准不可压缩材料的响应，其响应过于僵硬；这种现象被称为锁定。
* 本报告的目的是为使用deal.II处理非线性固体力学问题提供基础。线性问题在[2.x.5]中得到了解决。在[2.x.6]中部分考虑了几何非线性问题的非标准、超弹性类型的形式：使用线性化构成关系的速率形式，问题域随运动变化而变化。围绕非线性运动学的重要概念在理论和实施中都没有。然而，[2.x.7]确实描述了许多关键概念，以便在交易框架内实现弹性。
* 我们从非线性运动学的速成课程开始。为了简单起见，我们将注意力限制在准静态问题上。此后，我们介绍了各种关键的应力措施，并描述了构成模型。
* [2.x.8] 本教程是针对三维空间的弹性问题而开发的（并在介绍中进行了描述）。虽然空间维度可以在main()例程中改变，但需要注意的是。一般来说，二维弹性问题只是作为三维问题的理想化而存在。也就是说，它们要么是平面应变，要么是平面应力。这些选择中的任何一个的假设都需要被一致地施加。更多信息见 [2.x.9] 中的说明。
* [1.x.56][1.x.57] 。
*

* 这里实施的三场公式是由Simo等人（1985年）开创的，被称为混合雅各布-压力公式。重要的相关贡献包括Simo和Taylor（1991年）以及Miehe（1994年）。这里采用的符号在很大程度上借鉴了Holzapfel（2001年）对非线性固体力学理论方面的出色概述。
* [2.x.10] [2.x.11] J.C. Simo, R.L. Taylor and K.S. Pister (1985), Variational and projection methods for the volume constraint in finite deformation elasto-plasticity,［2.x.12DOI: [1.x.58]; [2.x.14] J.C. Simo and R.L. Taylor (1991), 本质拉伸中的准不可压缩的有限弹性。Continuum basis and numerical algorithms, [2.x.15] Computer Methods in Applied Mechanics and Engineering [2.x.16] , <strong> 85 </strong>, 3, 273-310. DOI: [1.x.59]; [2.x.17] C. Miehe（1994）, Aspects of the formulation and finite element implementation of large strain isotropic elasticity [2.x.18国际工程数值方法杂志 [2.x.19] <strong> 37 </strong>, 12, 1981-2004. DOI: [1.x.60]; [2.x.20] G.A. Holzapfel（2001），非线性固体力学。ISBN: 0-471-82304-X; [2.x.21] T.J.R.Hughes (2000), The Finite Element Method., A Continuum Approach for Engineering, John Wiley & Sons:ISBN: 978-0486411811 [2.x.22] T.J.R. Hughes (2000), The Finite Element Method: Linear Static and Dynamic Finite Element Analysis, Dover.
* 一个在耦合问题中使用这种三场公式的例子记录在[2.x.23] [2.x.24] J-P.V. Pelteret, D. Davydov, A. McBride, D. K. Vu, and P. Steinmann (2016), Computational electro-and magneto-elasticity for quasi-incompressible media immersed in free space, [2.x.25] International Journal for Numerical Methods in Engineering [2.x.26] 。 DOI: [1.x.61] [2.x.27] 。
* [1.x.62][1.x.63] 。
*

* 我们可以把四阶张量看作是将二阶张量（矩阵）映射到自己身上的线性算子，其方式与矩阵将向量映射到向量上一样。]和[2.x.29]由[1.x.64]定义，注意[2.x.30]。此外，我们用[1.x.65]定义对称和偏斜对称的四阶单位张量，这样[1.x.66]由identity_tensor()返回的四阶[2.x.31]是[2.x.32] 。
*

*[1.x.67][1.x.68]


*让时间域表示为[2.x.33]，其中[2.x.34]和[2.x.35]是总的问题持续时间。考虑一个连续体，在时间[2.x.37]占据参考配置[2.x.36]。%参考配置中的粒子由位置矢量[2.x.38]识别。称为当前配置，表示为[2.x.40]，粒子由矢量[2.x.41]识别。参考配置和当前配置之间的非线性映射，表示为[2.x.42]，作用如下：[1.x.69]粒子位移的材料描述定义为[1.x.70] 。]
* 变形梯度[2.x.43]被定义为运动的材料梯度：[1.x.71]变形梯度[2.x.44]的行列式在参考配置和当前配置中对应的体积元素，分别表示为[2.x.45]和[2.x.46]，为[1.x.72] 。
* 就空间和材料坐标而言，变形的两个重要衡量标准是左和右Cauchy-Green张量，分别表示为[2.x.47]和[2.x.48] .它们都是对称和正定的。
* 格林-拉格朗日应变张量定义为[1.x.73]，如果假设变形量为无穷小，那么右边的第二个项可以忽略，[2.x.49]（线性化应变张量）是应变张量的唯一组成部分。从问题的设置来看，这一假设在[2.x.50]中是无效的，因此在该教程程序中使用线性化[2.x.51]作为应变度量是值得怀疑的。
* 为了处理材料在受到体型和剪切型变形时表现出的不同响应，我们考虑将变形梯度[2.x.52]和左Cauchy-Green张量[2.x.53]分解为体积变化（volumetric）和体积保持（isochoric）部分：[1.x.74] 显然，[2.x.54] 。
* 空间速度场表示为[2.x.55] .空间速度场相对于空间坐标的导数给出了空间速度梯度[2.x.56] ，即[1.x.75] 其中[2.x.57] .
*

*[1.x.76][1.x.77] 。


* 考奇应力定理将作用在当前构型[2.x.59]中无限小的表面元素上的考奇牵引力[2.x.58]等同于考奇应力张量[2.x.60]（一个空间量）与表面的外向单位法线[2.x.61]的乘积，即[1.x.78]考奇应力是对称的。] 作用于参考构型[2.x.63]中的无限小的表面元素，是第一Piola-Kirchhoff应力张量[2.x.64]（两点张量）与表面的外向单位法线[2.x.65]的乘积，如[1.x.79]Cauchy牵引[2.x.66]和第一Piola-Kirchhoff牵引[2.x.67]的关系为[1.x.80] 这可以用[1.x.81] 来证明。
* 第一Piola-Kirchhoff应力张量与Cauchy应力的关系为[1.x.82]，其他重要的应力测量是（空间）Kirchhoff应力[2.x.68]和（参考）第二Piola-Kirchhoff应力[2.x.69] 。
*

*[1.x.83][1.x.84] 。


* 前推和后拉运算允许人们在材料和空间设置之间转换各种措施。这里使用的应力措施是忌变的，而应变措施是协变的。
* 二阶协变张量的前推和后拉运算[2.x.70]分别由以下公式给出：[1.x.85] 。
* 二阶不变量张量[2.x.71]的前推和后拉操作分别由：[1.x.86]例如[2.x.72] 。
*

*[1.x.87][1.x.88] 。


* 例如，如果亥姆霍兹自由能取决于右Cauchy-Green张量[2.x.74]，那么各向同性的超弹性反应就是[1.x.89]。如果亥姆霍兹自由能取决于左Cauchy-Green张量[2.x.75]，那么各向同性的超弹性反应就是[1.x.90] 。
* 按照变形梯度的乘法分解，亥姆霍兹自由能可以分解为[1.x.91]同样，基尔霍夫应力可以分解为体积部分和等熵部分[2.x.76]，其中。
* [1.x.92]
*其中[2.x.77]是压力反应。[2.x.78]是投影张量，它提供了欧拉设置中的偏差算子。虚构的基尔霍夫应力张量[2.x.79]由[1.x.93]定义。
*

*
* [2.x.80] 上面定义的压力响应不同于固体力学中广泛使用的压力定义[2.x.81] .这里[2.x.82]是静水压力。我们在本教程中使用压力响应（尽管我们把它称为压力）。
* [1.x.94][1.x.95] 。
*

* 与可压缩性[1.x.96]相对应的亥姆霍兹自由能由[1.x.97]给出，其中[2.x.83]是体积模量（[2.x.84]和[2.x.85]是Lam&eacute;参数）和[2.x.86] .函数[2.x.87]被要求是严格凸的并满足[2.x.88]等条件，进一步细节见 Holzapfel （2001）. 在这项工作[2.x.89] .
* 不可压缩性对所有运动施加了等时约束[2.x.90] [2.x.91] .对应于不可压缩的新胡克材料的Helmholtz自由能由[1.x.98]给出，其中[2.x.92] .因此，不可压缩响应是通过从可压缩自由能中去除体积成分并强制执行[2.x.93] 得到的。
*

*[1.x.99][1.x.100]


* 我们将使用牛顿-拉弗森策略来解决非线性边界值问题。因此，我们需要线性化构成关系。
* 材料描述中的四阶弹性张量定义为[1.x.101]空间描述中的四阶弹性张量[2.x.94]由[2.x.95]的前推得到[1.x.102]四阶弹性张量（对于超弹性材料）拥有主要对称性和次要对称性。
* 四阶空间弹性张量可以写成以下解耦形式：[1.x.103]其中
* [1.x.104]
*其中空间描述中的虚构弹性张量[2.x.96]由[1.x.105]定义。
*[1.x.106][1.x.107] 。
*

* 系统的总势能[2.x.97]是内部和外部势能的总和，分别表示为[2.x.98]和[2.x.99]。我们希望通过最小化势能找到平衡配置。
* 如上所述，我们采用三场公式。我们用[2.x.100]表示主要未知数集。独立运动变量[2.x.101]作为对[2.x.102]的约束进入公式，由拉格朗日乘数[2.x.103]（压力，我们将看到）执行。
* 这里使用的三场变分原理由[1.x.108]给出，其中外部势由[1.x.109]定义。当前配置[2.x.104]的边界由两部分组成，即[2.x.105]，其中[2.x.106].规定的Cauchy牵引力，表示为[2.x.107]，被应用于[2.x.108]，而运动被规定在边界的其余部分[2.x.109].每单位当前体积的体力表示为[2.x.110] 。
*

*
*势的静止性如下
* [1.x.110]
* 对于所有虚拟位移[2.x.111]，受[2.x.112]对[2.x.113]的约束，以及所有虚拟压力[2.x.114]和虚拟膨胀[2.x.115]。
* 人们应该注意到，三场公式中的体积基尔霍夫应力[2.x.116]和随后的体积正切的定义与超弹性材料一节中给出的一般形式略有不同，其中[2.x.117].这是因为压力[2.x.118]现在是一个主要场，而不是一个构成性的派生量。人们需要仔细区分主要场和那些从构成性关系中获得的场。
* [2.x.119] 虽然变量都是用空间量表示的，但积分域是初始配置。这种方法被称为[2.x.120] 总拉格朗日公式[2.x.121] 。[2.x.122] 中给出的方法，其积分域是当前配置，可称为[2.x.123] 更新拉格朗日公式[2.x.124] 。这两种方法的各种优点在文献中被广泛讨论。但应注意，它们是等同的。
*

* 与残余物相对应的欧拉-拉格朗日方程是：。
* [1.x.111]
* 第一个方程是空间设置中的（准静态）平衡方程。第二个是约束条件，即 [2.x.125] .第三个是压力的定义 [2.x.126] 。
* [2.x.127] 下面简化的单场推导（[2.x.128]是唯一的主要变量）使我们清楚地知道如何将积分的极限转化为参考域。
* [1.x.112]
* 其中[2.x.129] 。
* 我们将使用迭代牛顿-拉弗森方法来解决非线性残差方程 [2.x.130] .为了简单起见，我们假设死荷载，即荷载不因变形而改变。
* 在[2.x.131]的已知状态和[2.x.132]的当前未知状态之间的量的变化表示为[2.x.133] .在当前迭代[2.x.134]的量的值表示为[2.x.135] .迭代[2.x.136]和[2.x.137]之间的增量变化表示为[2.x.138] 。
* 假设在某个迭代[2.x.139]中系统的状态是已知的。使用牛顿-拉弗森方法解决非线性治理方程的线性化近似是：找到[2.x.140]，使[1.x.113]，然后设置[2.x.141].切线由以下方法给出
* [1.x.114]因此。
* [1.x.115]
*其中
* [1.x.116]
*
* 请注意，以下条款被称为几何应力和材料对切线矩阵的贡献。
* [1.x.117]
*
*

*[1.x.118][1.x.119]


* 这里使用的三场公式对准不可压缩材料是有效的，即在[2.x.142]（其中[2.x.143]是[1.x.120]）的情况下，对[2.x.144]和[2.x.145]的插值场进行良好选择。通常选择[2.x.146] 。一个流行的选择是[2.x.148]，它被称为平均扩张法（见Hughes（2000）的直观讨论）。
* 对于完全不可压缩的材料，[2.x.152]和三场公式仍然会表现出锁定行为。这可以通过在自由能中引入一个额外的约束条件来克服，其形式为[2.x.153]。
* 线性化问题可以写成[1.x.121]，其中
* [1.x.122]

* 因此，压力和膨胀的不连续有限元插值产生了[2.x.155]、[2.x.156]和[2.x.157]的块对角矩阵，因此我们可以很容易地表达每个单元上的场[2.x.158]和[2.x.159]，只需反转一个局部矩阵并乘以局部右手。然后，我们可以将结果插入其余的方程中，并恢复一个经典的基于位移的方法。为了在元素层面凝结出压力和膨胀贡献，我们需要以下结果。
* [1.x.123]
* 因而[1.x.124]其中[1.x.125]注意，由于[2.x.160]和[2.x.161]被选择为元素级的不连续，所有需要反转的矩阵都在元素级定义。
*构建各种贡献的程序如下。
*
* - 构建 [2.x.162] 。
*
* - 为元素形成[2.x.163]，并将[2.x.164]存储在[2.x.165]的地方 .
*
* - 形成 [2.x.166] 并添加到 [2.x.167] 得到 [2.x.168] 。
*
* - 修改后的系统矩阵被称为 [2.x.169] 。  也就是 [1.x.126] 。
*

* [1.x.127][1.x.128] 。


* 在本教程中，我们只有一个名为Material_Compressible_Neo_Hook_Three_Field的材料类，理想情况下，这个类会派生自HyperelasticMaterial类，而HyperelasticMaterial则派生自基类Material。
* 三场公式的Helmholtz自由能函数是[2.x.170].Kirchhoff应力的等效部分[2.x.171]与使用超弹性材料的单场公式得到的是一样的。因此，对于三场公式来说，基尔霍夫应力[2.x.173]的体积部分（和正切）的构成反应并不像单场公式那样由超弹性构成法给出。我们可以将术语[2.x.174]标记为体积基尔霍夫应力，但是压力[2.x.175]并不是由自由能得出；它是一个主场。
*为了有一个灵活的方法，决定Material_Compressible_Neo_Hook_Three_Field仍然能够计算并返回体积Kirchhoff应力和切线。为了做到这一点，我们选择将内插的主场[2.x.176]和[2.x.177]存储在与正交点相关的Material_Compressible_Neo_Hook_Three_Field类中。这个决定应该在以后的阶段，当教程被扩展到考虑其他材料时再进行讨论。
*

*[1.x.129][1.x.130]


*这里考虑的数值例子是一个压缩下的几乎不可压缩的块。这个基准问题取自于
*
* - S. Reese, P. Wriggers, B.D. Reddy (2000), A new locking-free brick element technique for large deformation problems in elasticity, [2.x.178] Computers and Structures [2.x.179] , <strong> 75</strong>, 291-304.  DOI：[1.x.131] 。
* [2.x.180]
* 该材料是准不可压缩的新胡克式，具有[1.x.132] [2.x.181]和[2.x.182] .对于这样一个材料属性的选择，传统的单场[2.x.183]方法将被锁定。初始和最终配置如上图所示。利用对称性，我们只求解四分之一的几何体（即尺寸为[2.x.184]的立方体），域上表面的内四分之一受到[2.x.185]的载荷。
*

* [1.x.133] [1.x.134]。
* 我们首先包括所有必要的deal.II头文件和一些C++相关的文件。它们已经在以前的教程程序中详细讨论过了，所以你只需要参考过去的教程就可以了。
*


* [1.x.135]
*
* 这个标头给我们提供了在正交点存储数据的功能
*


* [1.x.136]
*
* 这里是使用LinearOperator类所需的头文件。这些也都被方便地打包到一个头文件中，即<deal.II/lac/linear_operator_tools.h>，但为了透明起见，我们在此列出那些特别需要的头文件。
*


* [1.x.137]
*
* 这两个标题中定义了一些与有限应变弹性相关的操作。第一个将帮助我们计算一些运动量，第二个提供一些标准的张量定义。
*


* [1.x.138]
*
* 然后我们把所有与这个教程程序有关的东西都塞进一个自己的命名空间，并把所有deal.II的函数和类名导入其中。
*


* [1.x.139]
*
* [1.x.140] [1.x.141].
* 有几个参数可以在代码中设置，所以我们设置了一个ParameterHandler对象，在运行时读入选择。
*


* [1.x.142]
*
* [1.x.143] [1.x.144]。


*
* 正如介绍中提到的，对于位移[2.x.186]应该使用不同的阶次插值，而不是压力[2.x.187]和膨胀[2.x.188]。  选择[2.x.189]和[2.x.190]作为元素层面的不连续（常数）函数，导致平均扩张方法。不连续的近似允许[2.x.191]和[2.x.192]被浓缩出来，并恢复了一个基于位移的经典方法。这里我们指定用于近似解的多项式阶数。正交阶数应作相应调整。
*


* [1.x.145]
*
* [1.x.146] [1.x.147]。



*对问题的几何形状和施加的载荷进行调整。  由于这里所模拟的问题相当特殊，因此可以将荷载比例改变为特定的数值，以便与文献中给出的结果进行比较。
*


* [1.x.148]
*
* [1.x.149] [1.x.150]。


*
* 我们还需要新胡克材料的剪切模量[2.x.193]和泊松率[2.x.194]。
*


* [1.x.151]
*
* [1.x.152] [1.x.153]。


*
* 接下来，我们选择求解器和预处理器的设置。  当牛顿增量中出现大的非线性运动时，使用有效的预处理程序对于确保收敛性至关重要。
*


* [1.x.154]

* [1.x.155] [1.x.156]。



* 使用牛顿-拉弗森方案来解决非线性治理方程组。  我们现在定义牛顿-拉普森非线性求解器的公差和最大迭代次数。
*


* [1.x.157]
*
* [1.x.158] [1.x.159]。


*
* 设置时间步长[2.x.195]和模拟结束时间。
*


* [1.x.160]
*
* [1.x.161] [1.x.162]。


*
* 最后，我们将上述所有的结构合并到一个容器中，该容器容纳我们所有的运行时选择。
*


* [1.x.163]
*
* [1.x.164] [1.x.165]。


*
* 一个简单的类来存储时间数据。它的功能是透明的，所以没有必要讨论。为了简单起见，我们假设一个恒定的时间步长。
*


* [1.x.166]
*
* [1.x.167] [1.x.168]。



* 正如在介绍中所讨论的，新胡克材料是一种超弹性材料。  整个领域被假定为由可压缩的新胡克材料组成。  这个类别定义了这种材料在三场公式中的行为。  可压缩的新胡克材料可以用应变能量函数（SEF）来描述 [2.x.196] 。   
* 等效响应由[2.x.197]给出，其中[2.x.198]和[2.x.199]是左或右等效Cauchy-Green变形张量的第一不变量。这就是[2.x.200] 。在这个例子中，支配体积响应的SEF定义为[2.x.201] ，其中[2.x.202]是[1.x.169]，[2.x.203]是[1.x.170] 。   
* 下面的类将被用来描述我们工作的材料的特征，并提供了一个中心点，如果要实现不同的材料模型，就需要对其进行修改。为了工作，我们将在每个正交点存储一个这种类型的对象，并在每个对象中存储当前状态（由三个场的值或度量来表征），以便我们能够计算围绕当前状态线性化的弹性系数。
*


* [1.x.171]
*
* 我们根据[2.x.204]以及压力[2.x.205]和膨胀[2.x.206]，用各种与变形有关的数据更新材料模型，并在函数的最后包括一个内部一致性的物理检查。
*


* [1.x.172]
*
* 第二个函数决定了基尔霍夫应力[2.x.207] 。
*


* [1.x.173]
*
*空间设置中的四阶弹性张量[2.x.208]由SEF[2.x.209]计算为[2.x.210] 其中[2.x.211]



* [1.x.174]
*
* 体积自由能相对于[2.x.212]的导数 返回[2.x.213]



* [1.x.175]
*
* 相对于[2.x.214]的体积自由能的二阶导数。我们需要在切线中明确地进行以下计算，所以我们将其公开。  我们计算[2.x.215]。
*


* [1.x.176]
*
* 接下来的几个函数返回各种数据，我们选择与材料一起存储。
*


* [1.x.177]
*
* 定义构成模型参数 [2.x.216] （体积模量）和新胡克模型参数 [2.x.217] 。
*


* [1.x.178]

* 模型的具体数据，方便与材料一起存储。
*


* [1.x.179]
*
* 以下函数在内部用于确定上述一些公共函数的结果。第一个是确定体积基尔霍夫应力 [2.x.218] 。
*


* [1.x.180]
*
* 接下来，确定等时基尔霍夫应力 [2.x.219] 。
*


* [1.x.181]
*
* 然后，确定虚构的基尔霍夫应力[2.x.220] 。
*


* [1.x.182]
*
*计算切线的体积部分 [2.x.221] 。
*


* [1.x.183]
*
*计算切线的等值部分 [2.x.222] 。
*


* [1.x.184]
*
* 计算虚构的弹性张量 [2.x.223] 。对于所选择的材料模型，这只是零。
*


* [1.x.185]
*
* [1.x.186] [1.x.187]。


*
* 正如在[2.x.224]中所看到的，[2.x.225]类提供了一种在正交点存储数据的方法。  这里每个正交点都持有一个指向材料描述的指针。  因此，不同的材料模型可以用在域的不同区域。  在其他数据中，我们选择为正交点存储Kirchhoff应力[2.x.226]和正切[2.x.227]。
*


* [1.x.188]
*
* 第一个函数用于创建一个材料对象并正确地初始化所有的张量。第二个函数根据当前的变形量[2.x.228]、压力[2.x.229]和扩张[2.x.230]场值更新存储的数值和应力。
*


* [1.x.189]
*
* 为此，我们从位移梯度[2.x.232]中计算出变形梯度[2.x.231]，即[2.x.233]，然后让与此正交点相关的材料模型自行更新。当计算变形梯度时，我们必须注意和[2.x.234]的数据类型：由于[2.x.235]的数据类型是SymmetricTensor，只要写出[2.x.236]就可以将第二个参数转换成对称张量，执行和，然后将结果投给Tensor（即可能是非对称张量的类型）。然而，由于[2.x.237]在一般情况下是非对称的，转换为SymmetricTensor将会失败。我们可以通过先将[2.x.238]转换为张量，然后像在非对称张量之间一样执行加法，来避免这种来回奔波。
*


* [1.x.190]
*
* 材料已经更新，所以我们现在计算基尔霍夫应力[2.x.239]，切线[2.x.240]和体积自由能的一、二次导数。       
* 我们还存储了变形梯度的逆值，因为我们经常使用它。
*


* [1.x.191]
*
* 我们提供一个接口来检索某些数据。  下面是运动学变量。
*


* [1.x.192]
*
* ...和动力学变量。  这些都用于材料和全局切线矩阵和残余装配操作。
*


* [1.x.193]

* 最后是切线。
*


* [1.x.194]
*
* 在成员函数方面，这个类为它所代表的正交点存储了一个材料类型的副本，以备在域的不同区域使用不同的材料，以及变形梯度的逆值...
*


* [1.x.195]
*
* ......和应力型变量与切线[2.x.241]一起。



* [1.x.196]
*
* [1.x.197] [1.x.198]。


*
* Solid类是中心类，它代表了手头的问题。它遵循通常的方案，即它真正拥有的是一个构造函数、解构函数和一个[2.x.242]函数，该函数将所有的工作分派给该类的私有函数。
*


* [1.x.199]
*
* 在这个类的私有部分，我们首先向前声明一些对象，这些对象在使用WorkStream对象进行并行工作时使用（关于这方面的更多信息，请参见[2.x.243]模块）。     
* 我们声明这样的结构，用于正切（刚度）矩阵和右手向量的计算，静态冷凝，以及更新正交点。
*


* [1.x.200]
*
* 我们以一个建立网格的成员函数开始收集。
*


* [1.x.201]
*
* 设置要解决的有限元系统。
*


* [1.x.202]
*
* 为增量位移场创建Dirichlet约束。
*


* [1.x.203]
*
* 有几个函数使用多线程来组装系统和右侧矩阵。它们中的每一个都是包装函数，一个是在WorkStream模型中对一个单元做工作时执行的，另一个是将对这一个单元做的工作复制到代表它的全局对象中。
*


* [1.x.204]
*
* 还有类似的执行全局静态凝结。
*


* [1.x.205]
*
* 创建并更新正交点。在这里，没有数据需要被复制到全局对象中，所以copy_local_to_global函数是空的。
*


* [1.x.206]
*
* 用Newton-Raphson方法求解位移。我们把这个函数分成非线性循环和解决线性化的Newton-Raphson步骤的函数。
*


* [1.x.207]
*
* 解决方案的检索以及后期处理和将数据写入文件。
*


* [1.x.208]
*
* 最后是一些描述当前状态的成员变量。用于描述问题设置的参数的集合...
*


* [1.x.209]
*
* ...参考配置的体积...
*


* [1.x.210]
*
* ......以及解决该问题所依据的几何形状的描述。
*


* [1.x.211]
*
* 同时，记录当前时间和评估某些函数的时间
*


* [1.x.212]
*
* 一个用于正交点信息的存储对象。与[2.x.244]相反，这里采用了deal.II的本地正交点数据管理器。
*


* [1.x.213]
*
* 对有限元系统的描述，包括位移多项式程度、自由度处理程序、每个单元的DoF数量以及用于从解向量中检索信息的提取器对象。
*


* [1.x.214]
*
* 描述块系统是如何安排的。有3个块，第一个包含一个矢量DOF [2.x.245] ，而另外两个描述标量DOF， [2.x.246] 和 [2.x.247] 。
*


* [1.x.215]
*
* 单元和面的高斯正交规则。单元和面的正交点的数量被记录下来。
*


* [1.x.216]
*
* 用于存储收敛的解和右手边向量以及切线矩阵的对象。有一个AffineConstraints对象，用于跟踪约束条件。  我们利用了为块状系统设计的稀疏性模式。
*


* [1.x.217]
*
* 然后定义一些变量来存储规范，并更新规范和归一化系数。
*


* [1.x.218]
*
* 计算误差措施的方法
*


* [1.x.219]
*
* 计算空间配置中的体积
*


* [1.x.220]
*
* 以一种令人愉悦的方式将信息打印到屏幕上...
*


* [1.x.221]
*
* [1.x.222] [1.x.223]。


*
* [1.x.224] [1.x.225]。


*
* 我们使用从参数文件中提取的数据来初始化Solid类。
*


* [1.x.226]
*
* 有限元系统由昏暗的连续位移DOF，以及不连续的压力和膨胀DOF组成。为了满足Babuska-Brezzi或LBB稳定性条件（见Hughes (2000)），我们设置了一个[2.x.248]系统。  [2.x.249]元素满足这一条件，而[2.x.250]元素不满足。然而，事实证明，后者还是表现出良好的收敛特性。
*


* [1.x.227]
*
* 在解决准静态问题时，时间成为一个加载参数，即我们随着时间线性增加加载量，使得这两个概念可以互换。我们选择用一个恒定的时间步长来线性增加时间。   
* 我们以预处理开始函数，设置初始扩张值，然后输出初始网格，再以第一次时间（和载荷）递增开始模拟。   
* 在对初始解场施加约束[2.x.251]时，必须注意（或者至少要考虑一下）。该约束对应于未变形构型中变形梯度的行列式，也就是身份张量。我们使用FE_DGPMonomial基数来插值扩张场，因此我们不能简单地将相应的dof设置为unity，因为它们对应于单项式系数。因此，我们使用[2.x.252]函数来为我们做这个工作。[2.x.253]函数需要一个表明悬挂节点约束的参数。我们在这个程序中没有 所以我们必须创建一个约束对象。在原始状态下，约束对象是没有排序的，必须先进行排序（使用[2.x.254]函数）才能使用。请看 [2.x.255] 以了解更多信息。我们只需要强制执行扩张的初始条件。为了做到这一点，我们使用ComponentSelectFunction，它作为一个掩码，将n_components的J_component设置为1。 这正是我们想要的。请看一下[2.x.256]中的用法，以了解更多信息。
*


* [1.x.228]
*
* 然后我们宣布增量解决方案更新[2.x.257]，并开始在时域上循环。     
* 在开始的时候，我们重新设定这个时间步骤的解决方案更新...
*


* [1.x.229]
*
* ...解决当前的时间步骤并更新总的解决方案向量 [2.x.258] ...
*


* [1.x.230]
*
* ......并在愉快地进入下一个时间步骤之前绘制结果。
*


* [1.x.231]
*
* [1.x.232] [1.x.233]。



* [1.x.234] [1.x.235]。


*
* 第一组私有成员函数与并行化有关。我们使用线程积木库（TBB）来执行尽可能多的计算密集型分布式任务。特别是，我们使用TBB组装正切矩阵和右手向量、静态凝结贡献，以及更新存储在正交点的数据。我们在这方面的主要工具是WorkStream类（更多信息见[2.x.259]线程模块）。
*

*
* 首先我们处理切线矩阵和右手边的装配结构。PerTaskData对象存储了本地对全局系统的贡献。
*


* [1.x.236]
*
* 另一方面，ScratchData对象存储了较大的对象，如形状函数值数组（ [2.x.260] ）和形状函数梯度和对称梯度向量，我们将在装配时使用这些对象。
*


* [1.x.237]
*
* 然后我们定义结构来组装静态凝结的切线矩阵。回顾一下，我们希望解决一个基于位移的公式。由于[2.x.261]和[2.x.262]字段是元素间不连续的，所以我们在元素层面上进行缩合。  由于这些操作是基于矩阵的，我们需要设置一些矩阵来存储一些切线矩阵子块的局部贡献。  我们将这些放在PerTaskData结构中。   
* 我们选择不在[2.x.263]函数中重置任何数据，因为矩阵提取和替换工具会处理这个问题。
*


* [1.x.238]
*
* 我们希望在这里执行的操作的ScratchData对象是空的，因为我们不需要临时数据，但它仍然需要为当前deal.II中TBB的实现进行定义。  所以我们为此创建了一个假结构。
*


* [1.x.239]
*
* 最后我们定义结构以协助更新正交点信息。与SC的装配过程类似，我们不需要PerTaskData对象（因为这里没有什么可存储的），但还是必须定义一个。请注意，这是因为对于我们这里的操作来说
*
*-更新正交点的数据
*
* 该操作是纯粹的本地操作：我们在每个单元上做的事情在每个单元上都会被消耗掉，没有任何全局的聚合操作，就像使用WorkStream类时通常的情况一样。我们仍然必须定义每个任务的数据结构，这表明WorkStream类可能不适合这种操作（原则上，我们可以简单地使用[2.x.264]为每个单元创建一个新的任务），但无论如何这样做并没有什么坏处。此外，如果有不同的材料模型与一个正交点相关联，需要不同程度的计算费用，那么这里使用的方法可能是有利的。
*


* [1.x.240]
*
* ScratchData对象将被用来存储解向量的别名，这样我们就不必复制这个大的数据结构。然后我们定义一些向量来提取正交点的解值和梯度。
*


* [1.x.241]
*
* [1.x.242] [1.x.243]。



* 进入第一个私有成员函数。在这里我们创建域的三角形，为此我们选择了按比例的立方体，每个面都有一个边界ID号。  对于压痕问题，网格必须至少被细化一次。   
* 然后我们确定参考配置的体积并打印出来进行比较。
*


* [1.x.244]
*
* 因为我们希望将诺伊曼BC应用于顶面的一个补丁，所以我们必须找到域的这一部分的单元面，并用一个明显的边界ID号来标记它们。  我们要找的面在+y面上，将得到边界ID 6（0到5已经在创建立方体域的六个面时使用了）。
*


* [1.x.245]
*
* [1.x.246] [1.x.247]。


*
* 接下来我们描述FE系统是如何设置的。  我们首先确定每块的分量数量。由于位移是一个矢量分量，前两个分量属于它，而后两个分量描述标量压力和扩张DOF。
*


* [1.x.248]
*
* 然后，DOF处理程序被初始化，我们以一种有效的方式对网格进行重新编号。我们还记录了每块DOF的数量。
*


* [1.x.249]
*
* 设置稀疏模式和切线矩阵
*


* [1.x.250]
*
* 全局系统矩阵最初具有以下结构


* [1.x.251]
* 我们优化了稀疏模式以反映这种结构，并防止为右对角块成分创建不必要的数据。
*


* [1.x.252]
*
* 然后我们设置了存储向量
*


* [1.x.253]
*
* ...最后设置正交点历史。



* [1.x.254]
*
* [1.x.255] [1.x.256] 接下来，我们从FE系统中计算出一些信息，描述哪些局部元素DOF是连接到哪个块组件。  这将在后面用于从全局矩阵中提取子块。   
* 从本质上讲，我们所需要的是FESystem对象指出参考单元上的DOF连接到哪个块状部件上。  目前，插值场的设置是这样的：0表示位移DOF，1表示压力DOF，2表示膨胀DOF。
*


* [1.x.257]
*
* [1.x.258] [1.x.259] 用于存储正交信息的方法已经在 [2.x.265] 中描述。这里我们为SMP机器实现一个类似的设置。   
* 首先，实际的QPH数据对象被创建。这必须在网格被细化到最细的程度后才能完成。
*


* [1.x.260]

* 接下来我们设置初始正交点数据。请注意，当正交点数据被检索时，它将作为一个智能指针的向量返回。
*


* [1.x.261]
*
* [1.x.262] [1.x.263] 由于QP信息的更新经常发生，并涉及一些昂贵的操作，我们定义了一个多线程的方法，将任务分布在若干CPU核心上。   
* 要开始这样做，首先我们需要获得这个牛顿增量时的总解，然后创建初始的从头开始和复制数据对象的副本。
*


* [1.x.264]
*
* 然后我们将它们和单细胞更新函数传递给WorkStream进行处理。
*


* [1.x.265]
*
* 现在我们描述一下我们如何从解决方案向量中提取数据并将其传递给每个QP存储对象进行处理。
*


* [1.x.266]
*
* 我们首先需要找到当前单元内正交点的数值和梯度，然后利用位移梯度和总压力及扩张解数值更新每个局部QP。
*


* [1.x.267]
*
* [1.x.268] [1.x.269]。


*
* 下一个函数是牛顿-拉弗逊方案的驱动方法。在它的顶部，我们创建一个新的向量来存储当前的牛顿更新步骤，重置错误存储对象并打印求解器头。
*


* [1.x.270]
*
* 我们现在进行一些牛顿迭代来迭代解决这个非线性问题。  由于问题是完全非线性的，而且我们使用的是完全牛顿方法，所以存储在正切矩阵和右手边向量中的数据是不能重复使用的，必须在每个牛顿步骤中清除。然后，我们最初建立线性系统并检查收敛性（并在第一次迭代中存储这个值）。rhs向量的无约束DOF保存了失去平衡的力，并共同决定是否达到了平衡解。     
* 尽管对于这个特定的问题，我们可以在组装系统矩阵之前构建RHS向量，但为了扩展性，我们选择不这样做。分别组装RHS向量和系统矩阵的好处是，后者是一个昂贵的操作，我们可以通过在达到收敛时不组装切线矩阵来避免一个额外的组装过程。然而，这使得使用MPI并行化代码变得更加困难。此外，当把问题扩展到瞬态情况时，由于时间离散化和对速度和加速度场的约束应用，可能会对RHS产生额外贡献。
*


* [1.x.271]
*
* 我们构建线性系统，但暂不求解它（这个步骤应该比组装要贵得多）。
*


* [1.x.272]
*
* 我们现在可以确定归一化的残余误差并检查解决方案的收敛性。
*


* [1.x.273]
*
* 如果我们已经决定要继续迭代，我们就解决线性化系统。
*


* [1.x.274]
*
* 我们现在可以确定归一化的牛顿更新误差。
*


* [1.x.275]
*
* 最后，由于我们隐含地接受了求解步骤，我们可以对当前时间步骤的求解增量进行实际更新，更新与这个新位移和应力状态有关的所有正交点信息，并继续迭代。
*


* [1.x.276]
*
* 在最后，如果发现我们事实上做了比参数文件允许的更多的迭代，我们会引发一个异常，可以在main()函数中捕获。调用<code>AssertThrow(condition, exc_object)</code>实质上等同于<code>if (!cond) throw exc_object;</code>，但前一种形式在异常对象中填充了某些字段，这些字段标识了异常发生的位置（文件名和行号），以便更简单地识别问题发生的位置。
*


* [1.x.277]
*
* [1.x.278] [1.x.279]。


*
* 这个程序在一个漂亮的表格中打印出数据，这个表格在每次迭代的基础上更新。接下来的两个函数设置了表头和表脚。
*


* [1.x.280]
*
* [1.x.281] [1.x.282]。


*
*计算空间配置中的域的体积
*


* [1.x.283]
*
* 与之前调用的不同，在这个例子中，正交点数据是特别不可修改的，因为我们将只访问数据。我们通过将这个更新函数标记为常量来确保正确的get_data函数被调用。
*


* [1.x.284]
*
* 从[2.x.268]的误差[2.x.269]计算扩张[2.x.266]与[2.x.267]的吻合程度。我们还返回域的当前体积与参考体积的比率。这对不可压缩介质很有意义，因为我们要检查等压线约束的执行情况。
*


* [1.x.285]
*
* [1.x.286] [1.x.287]。


*
*确定问题的真实残差误差。  也就是说，确定无约束自由度的残差误差。  注意，要做到这一点，我们需要忽略受约束的自由度，将这些向量分量的残差设置为零。
*


* [1.x.288]
*
* [1.x.289] [1.x.290]。


*
*确定问题的真实牛顿更新误差
*


* [1.x.291]
*
* [1.x.292] [1.x.293]。


*
* 这个函数提供了总解，它在任何牛顿步都是有效的。这是必须的，因为为了减少计算误差，总解只在时间步数结束时更新。
*


* [1.x.294]
*
* [1.x.295] [1.x.296]。


*
* 因为我们使用TBB进行装配，所以我们只需设置一个流程所需的数据结构的副本，并将它们和装配函数一起传递给WorkStream对象进行处理。请注意，我们必须确保在任何装配操作发生之前，矩阵和RHS向量被重置。此外，由于我们描述的是一个诺伊曼BC的问题，我们将需要面的法线，因此必须在面的更新标志中指定这个。
*


* [1.x.297]
*
* 这里用于向WorkStream类传递数据的语法在 [2.x.270] 中讨论。
*


* [1.x.298]

* 当然，我们仍然要定义我们如何为单个单元组装切线矩阵的贡献。  我们首先需要重置和初始化一些从头开始的数据结构，并检索一些关于这个单元上DOF编号的基本信息。  我们可以预先计算单元的形状函数值和梯度。请注意，形状函数梯度是针对当前配置而定义的。  也就是 [2.x.271] 。
*


* [1.x.299]
*
* 现在我们建立局部单元刚度矩阵和RHS向量。由于全局和局部系统矩阵是对称的，我们可以利用这一特性，只建立局部矩阵的下半部分，并将其值复制到上半部分。  所以我们只组装一半的[2.x.272] , [2.x.273] , [2.x.274]块，而整个[2.x.275] , [2.x.276] , [2.x.277]块被建立。     
*在这样做的时候，我们首先从我们的正交历史对象中提取一些配置相关的变量，用于当前的正交点。
*


* [1.x.300]
*
* 这两个张量存储了一些预先计算的数据。它们的用途将很快得到解释。
*


* [1.x.301]

* 接下来我们定义一些别名，使装配过程更容易操作。
*


* [1.x.302]

* 我们首先计算来自内力的贡献。  注意，根据rhs作为残差负数的定义，这些贡献被减去。
*


* [1.x.303]
*
* 在我们进入内循环之前，我们还有最后一次机会来引入一些优化。我们已经考虑到了系统的对称性，现在我们可以预先计算一些在内循环中反复应用的常用项。我们在这里不会过分，而是将重点放在昂贵的操作上，即那些涉及等级4材料刚度张量和等级2应力张量的操作。             
* 我们可以观察到的是，这两个张量都是以 "i "DoF为索引的形状函数梯度收缩的。这意味着，当我们在 "j "DoF上循环时，这个特殊的操作保持不变。出于这个原因，我们可以从内循环中提取这个操作，并节省许多操作，对于每个正交点和DoF索引 "i "和重复索引 "j"，需要用等级4的对称张量来双重收缩等级2的对称张量，以及用等级2的张量收缩等级1的张量。             
* 在损失一些可读性的情况下，当使用模拟默认参数时，这个小变化将使对称系统的装配时间减少约一半，并且随着h-精化水平的提高而变得更加显著。
*


* [1.x.304]
*
* 现在我们准备计算正切矩阵的贡献。
*


* [1.x.305]
*
* 这是[2.x.278]贡献。它包括一个材料贡献，和一个几何应力贡献，只沿局部矩阵对角线添加。
*


* [1.x.306]
*
* 材料的贡献。
*


* [1.x.307]
*
* 几何应力的贡献。
*


* [1.x.308]
*
* 接下来是[2.x.279]的贡献
*


* [1.x.309]

* 最后是[2.x.280]和[2.x.281]的贡献。
*


* [1.x.310]
*
* 接下来我们组装诺伊曼贡献。我们首先检查单元格面是否存在于一个施加了牵引力的边界上，如果是这样的话，我们就加入贡献。
*


* [1.x.311]
*
* 使用该正交点的面法线，我们指定参考配置中的牵引力。对于这个问题，在参考构型中施加一个定义的压力。假设施加的牵引力的方向不随领域的变形而变化。牵引力的定义是使用第一个Piola-Kirchhoff应力，即[2.x.282]我们使用时间变量来线性增加压力负荷。               
* 请注意，我们在这里计算的右手边矢量的贡献只存在于矢量的位移成分中。
*


* [1.x.312]
*
* 最后，我们需要将本地矩阵的下半部分复制到上半部分。
*


* [1.x.313]
*
* [1.x.314] [1.x.315] 这个问题的约束条件很容易描述。在这个特殊的例子中，边界值将被计算为牛顿算法的两次第一次迭代。一般来说，我们会在第2次迭代中建立非均质约束（也就是在后面的代码块中`apply_dirichlet_bc == true`时），在接下来的步骤中只建立相应的均质约束。虽然目前的例子只有同质约束，但以前的经验表明，一个常见的错误是在重构代码到特定用途时忘记添加额外的条件。这可能导致难以调试的错误。本着这种精神，我们选择让代码在每个牛顿步骤中执行什么操作方面更加节略。
*


* [1.x.316]
*
* 由于我们(a)处理的是牛顿迭代方法，(b)使用位移的增量公式，以及(c)将约束条件应用于增量位移场，对位移更新的任何非同质约束只应在第2次迭代时指定。由于该迭代后约束条件将被完全满足，因此不需要做后续的贡献。
*


* [1.x.317]
*
* 此外，在一个时间段内的第一次牛顿迭代后，约束条件保持不变，只要不清除[2.x.283]对象，我们就不需要修改或重建它们。
*


* [1.x.318]
*
* 在牛顿第2次迭代时，我们希望应用代表位移增量的边界条件的全套非均质和均质约束。由于一般情况下，每个时间步长的约束条件可能是不同的，我们需要清除约束矩阵并完全重建它。一个例子是，如果一个表面正在加速，在这种情况下，每个时间步长之间的位移变化是不恒定的。
*


* [1.x.319]
*
* 3D中压痕问题的边界条件如下。在
*
* - ,
*
* - 和
*
* -面（IDs 0,2,4）我们设置了一个对称条件，只允许平面运动，而+x和+z面（IDs 1,5）是无牵引的。在这个设计好的问题中，+y面的一部分（ID 3）被设定为在x-和z-分量上没有运动。最后，如前所述，+y面的另一部分有一个施加的压力，但在x和z方向上也受到约束。         
* 在下文中，我们将不得不告诉函数插值的边界值应该约束解向量的哪些分量（即，是x-、y-、z-位移还是它们的组合）。这是用ComponentMask对象完成的（见[2.x.284]），如果我们为有限元提供一个我们希望选择的分量的提取器对象，我们可以从有限元得到这些对象。为此，我们首先设置了这样的提取器对象，然后在生成相关构件掩码时使用它。
*


* [1.x.320]
*
* 由于所有的Dirichlet约束在牛顿第2次迭代后被完全满足，我们要确保对这些条目不做进一步的修改。这意味着我们要将所有非均质的Dirichlet约束转换成均质的约束。         
* 在这个例子中，这样做的程序是非常直接的，事实上，当只应用同质边界条件时，我们可以（也将）规避任何不必要的操作。在一个更普遍的问题中，我们应该注意悬挂节点和周期性约束，这也可能引入一些不均匀性。那么，为不同类型的约束保留不同的对象可能是有利的，一旦构建了同质的Dirichlet约束，就将它们合并在一起。
*


* [1.x.321]
*
* 由于仿生约束是在上一次牛顿迭代中确定的，所以不能直接修改。所以我们需要将它们复制到另一个临时对象中并在那里进行修改。一旦我们完成了，我们将把它们转移回主[2.x.285]对象。
*


* [1.x.322]
*
* [1.x.323] [1.x.324] 解决整个块系统有点问题，因为没有对[2.x.286]块的贡献，使其不可逆转（当使用迭代求解器时）。由于压力和扩张变量DOFs是不连续的，我们可以将它们浓缩成一个较小的仅有位移的系统，然后我们将求解并随后进行后处理以检索压力和扩张的解决方案。
*

*
* 静态凝结过程可以在全局层面进行，但我们需要其中一个块的逆。然而，由于压力和膨胀变量是不连续的，静态凝结（SC）操作也可以在每个单元的基础上进行，我们可以通过反转局部块产生块对角线[2.x.287]块的逆。我们可以再次使用TBB来做这件事，因为每个操作将是相互独立的。   
* 通过WorkStream类使用TBB，我们将每个元素的贡献集合起来，形成[2.x.288]。然后这些贡献被添加到全局刚度矩阵中。鉴于这样的描述，以下两个功能应该是清楚的。
*


* [1.x.325]
*
* 现在我们描述一下静态凝结过程。按照惯例，我们必须首先找出这个单元上的自由度有哪些全局数字，并重置一些数据结构。
*


* [1.x.326]
*
* 我们现在提取与当前单元相关的道夫对全局刚度矩阵的贡献。  [2.x.289]和[2.x.290]插值的不连续性质意味着它们在全局水平上没有局部贡献的耦合。而[2.x.291]道夫则不是这种情况。  换句话说，[2.x.292]、[2.x.293]和[2.x.294]，当从全局刚度矩阵中提取时是元素贡献。  这不是[2.x.295]的情况。     
* 注意：小写的符号用于表示元素刚度矩阵。
*

*
* 目前，与当前元素相关的dof对应的矩阵（有点松散地表示为[2.x.296]）是这样的。


* [1.x.327]
*
* 我们现在需要修改它，使其显示为


* [1.x.328]
* 与 [2.x.297] 其中 [2.x.298] 和 [2.x.299] .     
* 在这一点上，我们需要注意到全局数据已经存在于[2.x.300] , [2.x.301] 和 [2.x.302] 子块中。  因此，如果我们要修改它们，我们必须考虑到已经存在的数据（也就是说，如果需要的话，简单地添加到它或删除它）。  由于copy_local_to_global操作是一个 "+="操作，我们需要考虑到这一点
* 特别是对于[2.x.303]块，这意味着已经从周围的单元格中添加了贡献，所以我们在操作这个块时需要小心。  我们不能直接擦除子块。     
* 这就是我们将采用的策略，以获得我们想要的子块。
*


*


*


*


*


*


*


*


*


*
* - [2.x.304] : 由于我们无法访问[2.x.305]，但我们知道它的贡献被添加到全局[2.x.306]矩阵中，我们只想添加元素明智的静态凝结[2.x.307] 。
*


*


*


*


*


*


*


*


*


*
* - [2.x.308] : 同样，[2.x.309]也存在于子块中。由于复制操作是一个+=操作，我们除了要 "添加 "我们希望替换的[2.x.310]子矩阵外，还需要减去现有的[2.x.310]子矩阵。
*


*


*


*


*


*


*


*


*


*
* - [2.x.311] : 由于全局矩阵是对称的，这块和上面的一样，我们可以简单地用[2.x.312]来代替这块。     
* 我们首先从系统矩阵中提取元素数据。所以首先我们得到单元格的整个子块，然后提取[2.x.313]与当前元素相关的道夫值
*


* [1.x.329]

* 接下来是[2.x.314][2.x.315]和[2.x.316]的局部矩阵。



* [1.x.330]
*
* 为了得到[2.x.317]的逆值，我们直接将其反转。  这个操作相对便宜，因为[2.x.318]是块状对角线的。
*


* [1.x.331]
*
* 现在我们可以做凝结项来添加到[2.x.319]块中，并把它们放在单元格局部矩阵[2.x.320]中。
*


* [1.x.332]
*
* [2.x.321]



* [1.x.333]
*
* [2.x.322]



* [1.x.334]
*
* [2.x.323]



* [1.x.335]
*
* 接下来我们把[2.x.324]放在[2.x.325]块中进行后处理。  再次注意，我们需要删除那里已经存在的贡献。
*


* [1.x.336]
*
* [1.x.337] [1.x.338] 我们现在拥有所有必要的组件，可以使用两种可能的方法之一来解决线性化系统。第一种是在元素层面上进行静态凝结，这需要对切线矩阵和RHS向量进行一些改动。或者，可以通过在全局层面上进行凝结来解决全块系统。下面我们将实现这两种方法。
*


* [1.x.339]
*
* 首先，这里是使用切线矩阵的（永久）增量的方法。对于下面的内容，请记住，


* [1.x.340]
*和


* [1.x.341]
*因而[1.x.342]其中[1.x.343]
*

*
* 在顶部，我们分配了两个临时向量以帮助静态凝结，还有一些变量用来存储线性求解器的迭代次数和（希望是收敛的）残差。
*


* [1.x.344]
*
* 在这个函数的第一步，我们求解增量位移 [2.x.326] 。  为此，我们进行静态浓缩，使[2.x.327]，并将[2.x.328]放入原[2.x.329]块中。也就是说，我们做出[2.x.330] 。
*


* [1.x.345]
*
* [2.x.331]



* [1.x.346]
*
* [2.x.332]



* [1.x.347]
*
* [2.x.333]



* [1.x.348]
*
* [2.x.334]



* [1.x.349]
*
* [2.x.335]



* [1.x.350]
*
* [2.x.336]



* [1.x.351]
*
* 我们默认选择了SSOR预调节器，因为它似乎为这个问题在单线程机器上提供了最快的求解器收敛特性。  然而，对于不同的问题规模，这可能不是真的。
*


* [1.x.352]
*
* 否则，如果问题足够小，可以利用直接求解器。
*


* [1.x.353]
*
* 现在我们有了位移更新，把约束分配回牛顿更新。
*


* [1.x.354]
*
* 解决位移问题后的下一步是进行后处理，从替换中得到扩张解。  [2.x.337]
*


* [1.x.355]
*
* [2.x.338]



* [1.x.356]
*
* [2.x.339]



* [1.x.357]
*
* [2.x.340]



* [1.x.358]
*
* [2.x.341]



* [1.x.359]
*
* 我们在这里确保任何迪里希特约束都分布在更新的解决方案上。
*


* [1.x.360]

* 最后我们用代入法求解压力的更新。  [2.x.342]
*


* [1.x.361]
*
* [2.x.343]



* [1.x.362]
*
* [2.x.344]



* [1.x.363]
*
* [2.x.345]



* [1.x.364]
*
* 和最后....  [2.x.346]



* [1.x.365]
*
* 我们现在已经到了终点，所以我们将所有受限的道夫分配回牛顿更新。
*


* [1.x.366]
*
* 在局部水平上手动凝结扩张和压力场，以及随后的后处理，需要花费相当大的努力才能实现。简而言之，我们必须产生逆矩阵[2.x.347]，并将其永久写入全局切线矩阵中。然后我们对[2.x.348]进行永久修改，产生[2.x.349]。这涉及到对切线矩阵的局部子块的提取和操作。在对位移进行求解后，对扩张和压力进行求解所需的各个矩阵-向量操作被仔细地执行。将这些众多的步骤与使用LinearOperator类提供的功能进行的更简单、更透明的实现形成对比。
*

*
* 为了便于以后使用，我们为RHS向量中的块定义了一些别名
*


* [1.x.367]
*
* ... 对于牛顿更新向量中的块。
*


* [1.x.368]
*
* 接下来我们为切线矩阵子块定义一些线性算子 我们将利用系统的对称性，所以并不是所有的块都需要。
*


* [1.x.369]
*
* 然后我们构造一个LinearOperator，代表（方形块）[2.x.350]的逆。由于它是对角线的（或者，当使用高阶分解时，几乎是对角线的），所以雅可比预处理器是合适的。
*


* [1.x.370]
*
* 现在我们可以构建[2.x.351]的那个转置和一个线性算子，它代表了浓缩的操作[2.x.352]和[2.x.353]以及最后的增强矩阵[2.x.354] 。请注意，schur_complement()算子在这里也能派上用场，但为了清楚起见，也为了展示线性求解方案的表述和实现之间的相似性，我们将手动执行这些操作。
*


* [1.x.371]
*
* 最后，我们定义了一个增强刚度矩阵的逆运算，即 [2.x.355] 。请注意，增强的刚度矩阵的预处理与我们使用静态凝结的情况不同。在这种情况下，预处理程序是基于未修改的[2.x.356]，而在第一种方法中，我们实际上修改了这个子块的条目。然而，由于[2.x.357]和[2.x.358]在同一空间操作，它对这个问题仍然足够。
*


* [1.x.372]

* 现在我们可以对位移场进行求解了。我们可以对线性运算进行嵌套，结果立即被写入牛顿更新向量中。很明显，这个实现紧密地模仿了介绍中所说的推导。
*


* [1.x.373]
*
* 需要对扩张场和压力场进行后处理的操作，也同样容易表达。
*


* [1.x.374]

* 用直接求解器求解全块系统。由于它是相对稳健的，它可能对因零[2.x.359]块的存在而产生的问题免疫。
*


* [1.x.375]
*
* 最后，我们在此再次确保任何迪里切特约束都分布在更新的解决方案上。
*


* [1.x.376]
*
* [1.x.377] [1.x.378] 这里我们介绍如何将结果写入文件，以便用ParaView或Visi来查看。该方法与以前的教程中显示的方法类似，因此将不作详细讨论。
*


* [1.x.379]
*
* 因为我们要处理的是一个大的变形问题，如果能在一个位移的网格上显示结果就更好了!  与DataOut类相连的MappingQEulerian类提供了一个接口，通过这个接口可以实现这一点，而不需要我们自己物理性地移动Triangulation对象中的网格点。  我们首先需要将解决方案复制到一个临时矢量，然后创建欧拉映射。我们还向DataOut对象指定了多项式的程度，以便在使用高阶多项式时产生更精细的输出数据集。
*


* [1.x.380]
*
* [1.x.381] [1.x.382] 最后，我们提供了主要的驱动功能，看起来与其他教程没有什么不同。
*


* [1.x.383]
* [1.x.384][1.x.385] 。


* 首先，我们提出了一系列与文献（见Reese等人(2000)）中的3维结果的比较，以证明该程序如预期的那样工作。
* 我们首先比较了[2.x.360]和[2.x.361]方案的网格细化收敛情况，如下图所示。结果与文献中的结果一致。低阶公式通常高估了低水平细化的位移，而高阶插值方案则低估了位移，但程度较轻。这个基准，以及其他一系列未在此显示的基准，使我们相信代码在正常工作。
* [2.x.363]
*

* 很明显，使用Newton-Raphson方法，可以得到二次收敛的解决方案。
* [1.x.386]

*

*
* 使用Timer类，我们可以看出代码的哪些部分需要最高的计算费用。对于一个有大量自由度的案例（即高水平的细化），Timer的一个典型输出如下。由于超过93%的时间花在线性求解器上，很明显，对于大型三维问题，可能有必要投资一个更好的求解器。
*


* [1.x.387]

*

* 然后我们用ParaView来显示两种情况的结果。第一种是最粗的网格和最低阶插值方法。  第二种是使用[2.x.368]公式的精炼网格。位移的垂直分量、压力[2.x.369]和膨胀[2.x.370]场显示如下。
*

* 对于第一种情况，很明显，粗略的空间离散化加上大的位移导致了低质量的解决方案（加载比为[2.x.371]）。此外，元素之间的压力差非常大。在这种离散性较差的情况下，也不会出现锁定现象。扩张解场和压力场明显相关，正的扩张表示正压区域，负的表示压缩区域。正如介绍中所讨论的，压缩压力有一个负号，而扩张压力有一个正号。
*

* [2.x.373]
*结合空间细化和高阶插值方案，产生了高质量的解决方案。三个网格细化加上一个[2.x.374]的公式，产生了一个清楚地抓住问题力学的结果。我们现在可以观察到施加牵引力的实际范围，最大的力施加在表面的中心点，造成最大的压缩。在压缩和膨胀区域之间有明显的区别和过渡，压力场的线性近似允许在子元素尺度上对压力进行精细的可视化处理，但是应该注意的是，压力场仍然是不连续的，可以在连续网格上进行平滑处理以达到后处理目的。
*


* [2.x.375]
* 这个简短的结果分析表明，三场公式能够有效地规避高度不可压缩介质的体积锁定。混合公式能够准确地模拟一个接近不可压缩的块在压缩下的位移。
* 就运行时间而言，[2.x.376]公式往往比[2.x.377]公式的计算费用更高。高阶方法计算时间的增加可能是由于高阶元素所需的带宽增加了。如前所述，使用更好的求解器和预调节器可以减轻使用高阶公式的费用。据观察，对于给定的问题，与单线程的SSOR预处理程序相比，使用多线程的Jacobi预处理程序可以减少72%的计算运行时间（在最坏的情况下是具有大量自由度的高阶公式）。
*

* [2.x.378]


* 最后，下面展示了两个不同层次的网格细化的2维问题的位移解决方案的结果。很明显，由于2维模拟的额外限制，所产生的位移场，虽然在质量上相似，但与3维情况不同。
*

* [2.x.379]
* [1.x.388][1.x.389][1.x.390] 。


*这项工作有许多明显的延伸。
*
* - 首先，可以在自由能函数中增加一个额外的约束条件，以便在材料中强制执行高度的不可压缩性。一个额外的拉格朗日乘数将被引入，但这可以最容易地使用增强的拉格朗日乘数的原则来处理。这在 [2.x.380] Simo和Taylor (1991) [2.x.381] 中得到了证明。
*
* - 本模型中使用的构成关系是比较基本的。将材料类分成两个独立的类，一个处理体积响应，另一个处理等熵响应，并产生一个通用的材料类（即具有抽象的虚拟函数，派生类必须实现），允许增加更复杂的材料模型，可能是有益的。这样的模型可以包括其他超弹性材料、塑性和粘弹性材料及其他。
*
* - 该程序是为解决单节点多核机器上的问题而开发的。只要稍加努力，该程序就可以通过使用Petsc或Trilinos扩展到大规模的计算环境，使用的技术与 [2.x.382] 中演示的类似。这主要涉及对设置、装配、[2.x.383]和线性求解器程序的修改。
*
* - 由于该程序假定为准静态平衡，因此有必要进行扩展以包括动态效应，以研究惯性效应重要的问题，例如涉及冲击的问题。
*
* - 对于高度非线性问题，负载和解决方案限制程序可能是必要的。可以增加一个线搜索算法，将步长限制在牛顿增量范围内，以确保最佳收敛性。也可能需要使用负载限制方法，如Riks方法，来解决涉及几何不稳定性的不稳定问题，如屈曲和快穿。
*
* - 许多物理问题涉及接触。有可能将物体之间的摩擦或无摩擦接触的影响纳入本程序。这将涉及到在自由能函数中增加一个额外的项，因此需要增加装配程序。我们还需要管理接触问题（检测和应力计算）本身。在自由能函数中增加惩罚项的一个替代方法是使用主动集方法，如[2.x.384]中使用的方法。
*
* - 使用LinearOperators的完整凝结程序已经被编码到线性求解器例程中。这也可以通过应用schur_complement()操作符来实现，以更自动化的方式缩减一个或多个字段。
*
* - 最后，自适应网格细化，如[2.x.385]和[2.x.386]所示，可以提供额外的求解精度。
*

* [1.x.391][1.x.392] [2.x.387]。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-45_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6]
* [2.x.2]
* [1.x.7][1.x.8][1.x.9][1.x.10]


* 在这个例子中，我们介绍了如何使用周期性的边界条件。周期性边界条件是代数约束，通常出现在一个更大领域的代表性区域的计算中，这些区域在一个或多个方向上重复。
* 一个例子是模拟光子晶体的电子结构，因为它们有一个类似格子的结构，因此，往往只需要在格子的一个盒子上进行实际计算就可以了。为了能够以这种方式进行，我们必须假设该模型可以周期性地扩展到其他盒子；这就要求解具有周期性结构。
*[1.x.11][1.x.12][1.x.13]
*

应用周期性边界条件的一般方法包括三个步骤（也见[2.x.3]"关于周期性边界条件的词汇表"）： * deal.II提供了一些高水平的入口来施加周期性边界条件。
*
* - 创建一个网格
*
* - 使用[2.x.4]确定边界不同部分的一对面，在这些面上的解应该是对称的。
*
* - 使用[2.x.5]将周期性信息添加到网格中。
*
* - 使用[2.x.6]添加周期性约束。
* 第二和第三步对于使用[2.x.7]类的平行网格是必要的，以确保位于域的对面但由周期性面连接的单元是幽灵层的一部分，如果其中一个单元被存储在本地处理器上的话。
* 第一步包括收集匹配的周期性面，并将它们存储在[2.x.10]的[2.x.9]中，这是通过函数[2.x.11]完成的，例如可以这样调用。
* [1.x.14]
*
* 这个调用在容器dof_handler的所有面中循环进行，周期性边界的边界指标分别为[2.x.12]和[2.x.13]。(你可以在创建粗略的网格后手工指定这些边界指标，见[2.x.14] "边界指标"。另外，如果你指定了 "colorize "标志，你也可以让GridGenerator命名空间中的许多函数来做这件事；在这种情况下，这些函数会给边界的不同部分分配不同的边界指标，细节通常在这些函数的文档中详细说明）。)
* 具体来说，如果[2.x.15]是两个面[2.x.16]的顶点，那么上面的函数调用将匹配成对的面（和道夫），使得[2.x.17]和[2.x.18]之间的差异除了方向之外在每个分量上都消失，并将产生的对与相关数据存储在[2.x.19]中（关于匹配过程的详细信息见[2.x.20]。
* 例如，考虑彩色单元格[2.x.21]，其边界指示器0在左边，1在右边，2在下面，3在上面。见[2.x.22]的文件，了解这个关于如何分配边界指标的公约）。然后。
* [1.x.15]
* 将产生周期性约束，从而使[2.x.23]对所有[2.x.24]。
* 如果我们考虑由[2.x.25], [2.x.26], [2.x.27], [2.x.28]的凸壳给出的平行四边形，我们可以通过指定一个[2.x.30]来实现约束[2.x.29] 。
* [1.x.16]
*或
* [1.x.17]
*这里，同样，边界指标0和1的分配源于[2.x.31]的文件。
* 由此产生的[2.x.32]可以用在[2.x.33]中，用于用周期性约束填充AffineConstraintsobject。
* [1.x.18]
*
* 除了这个高级接口外，还有一些[2.x.34]的变体可以结合这两个步骤（见[2.x.35]的变体）。
* 如果需要更多的灵活性，还有一个[2.x.36]的低层次接口。低级变体允许直接指定两个应被约束的面。
* [1.x.19]
* 这里，我们需要使用[2.x.37][2.x.38]和[2.x.39]来指定两个面的方向。 关于更详细的描述，请看[2.x.40]的文档。除了自我解释的[2.x.41]和[2.x.42]之外，其余参数与高级接口相同。
*

*[1.x.20][1.x.21][1.x.22]


* 在下文中，我们将展示如何在一个更复杂的例子中使用上述函数。我们的任务是对斯托克斯流的速度分量实施旋转周期性约束。
* 在一个由[2.x.43]定义的四分之一圆上，我们要解决斯托克斯问题[1.x.23] 。
* 边界[2.x.44]定义为[2.x.45]。对于边界的其余部分，我们将使用周期性边界条件，即
* [1.x.24]
*
* 网格将由[2.x.46]生成，它也记录了如果它的`colorize'参数设置为`true'，它如何给它的各个边界分配边界指标。
*

* [1.x.25] [1.x.26]。
* 这个例子程序是对[2.x.47]的轻微修改，使用Trilinos并行运行，以演示在deal.II中使用周期性边界条件。因此我们不讨论大部分的源代码，只对处理周期性约束的部分进行评论。其余的请看[2.x.48]和底部的完整源代码。
*

*
*为了实现周期性的边界条件，只有两个函数需要修改。
*


*
* - [2.x.49] : 要用周期性约束来填充AffineConstraints对象
*


*
* - [2.x.50] : 为分布式三角形提供周期性信息。
*


* 程序的其余部分与[2.x.51]相同，所以让我们跳过这一部分，只在下面展示这两个函数。(完整的程序可以在下面的 "普通程序 "部分找到。)
*




*
* [1.x.27] [1.x.28]。



* [1.x.29]
*
* 在我们可以规定周期性约束之前，我们需要确保位于域的对面但由周期性面连接的单元是幽灵层的一部分，如果其中一个单元存储在本地处理器上。在这一点上，我们需要考虑我们要如何规定周期性。左边边界上的面的顶点[2.x.52]应该与下边边界上的面的顶点[2.x.53]相匹配，由[2.x.54]给出，其中旋转矩阵[2.x.55]和偏移量[2.x.56]由以下几点给出


* [1.x.30]
* 我们要把得到的信息保存到这里的数据结构是基于三角法的。
*


* [1.x.31]
*
* 现在只要调用[2.x.57]就可以告诉三角函数关于所需的周期性，特别容易。
*


* [1.x.32]
*
* 在我们为网格提供了周期性约束的必要信息后，我们现在就可以实际创建它们了。对于描述匹配，我们使用与之前相同的方法，也就是说，左边边界上的一个面的[2.x.58]应该与下方边界上的一个面的顶点[2.x.59]相匹配，这些顶点的旋转矩阵[2.x.61]和偏移量[2.x.62]是由以下公式给出的


* [1.x.33]
* 这两个对象不仅描述了面孔应该如何匹配，而且还描述了解决方案应该在哪种意义上从[2.x.63]转换到[2.x.64]。
*


* [1.x.34]
*
* 为了设置约束，我们首先将周期性信息存储在一个类型为[2.x.65] [2.x.66] </code>的辅助对象中。周期性边界的边界指标为2（x=0）和3（y=0）。所有其他的参数我们之前已经设置好了。在这种情况下，方向并不重要。由于[2.x.67]这正是我们想要的。
*


* [1.x.35]

* 接下来，我们需要提供关于解决方案中哪些矢量值分量应该被旋转的信息。由于我们在这里选择只约束速度，而且是从解向量的第一个分量开始的，所以我们只需插入一个0。
*


* [1.x.36]
*
* 在周期性_vector中设置了所有的信息后，我们要做的就是告诉make_periodicity_constraints来创建所需的约束。
*


* [1.x.37]
*
* 然后程序的其余部分又与[2.x.68]相同。我们现在省略它，但和以前一样，你可以在下面的 "普通程序 "部分找到这些部分。
*


*[1.x.38][1.x.39]


*创建的输出结果并不十分令人惊讶。我们只是看到，相对于左边界和下边界，解决方案是周期性的。
* [2.x.69]
* 如果没有周期性约束，我们最终会得到以下的解决方案。
* [2.x.70]
*

*[1.x.40][1.x.41] [2.x.71]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-46_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] , [2.x.3] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34]
* [2.x.4]
* [1.x.35]


*[1.x.36][1.x.37][1.x.38]


* 这个程序处理的是在领域的不同部分耦合不同物理学的问题。具体来说，让我们考虑以下情况，将斯托克斯流体与弹性固体耦合起来（这两个问题以前在[2.x.5]和[2.x.6]中分别讨论过，你可能想在那里阅读一下各个方程式）。
*
* - 在[2.x.8]的[2.x.7]部分，我们有一个流动的流体，它满足与时间无关的斯托克斯方程（以涉及应变张量的形式）。
* [1.x.39]
* 这里，[2.x.9]分别是流体的速度和压力。  我们规定了部分外部边界上的速度。
* [1.x.40]
* 而我们假设外部边界的其余部分为自由流动条件。
* [1.x.41]
*
*
* - 域的其余部分，[2.x.10]被一个固体占据，其变形场[2.x.11]满足弹性方程。
* [1.x.42]
*其中[2.x.12]是等级4的弹性张量（我们将使用一个特别简单的形式，假设该固体是各向同性的）。  它在对沿固体边界流动的流体所施加的力的反应中发生变形。我们假设这种变形非常小，以至于它对流体没有反馈作用，也就是说，这种耦合只是在一个方向。为了简单起见，我们将假设固体的外部边界是被夹紧的，也就是说。
* [1.x.43]
*
*
* - 作为小位移假设的结果，我们将在流体和固体的界面上提出以下边界条件：首先，我们对流体没有滑移边界条件。
* [1.x.44]
* 第二，固体上的力（牵引力）等于流体的法向应力。
* [1.x.45]
* 其中[2.x.13]是[2.x.14]上从固体指向流体的法向量。
* 通过遵循我们通常的规则，即从左边乘以一个测试函数并在域上积分，我们得到了这个问题的弱表述。那么它看起来像这样。找到[2.x.15]，使得
* [1.x.46]
*对于所有测试函数[2.x.16]；第一、第二和第三条线分别对应于流体、固体和界面的贡献。注意[2.x.17]只是上述空间的一个子空间，以适应各种迪里希特边界条件。
* 这种耦合当然可以通过简单地拥有两个Triangulation和两个DoFHandler对象来实现，两个子域各一个。另一方面，如果有一个DoFHandler对象知道整个问题的离散化，那么deal.II使用起来就简单多了。
* 这个程序是关于如何实现这一目标的。请注意，我们的目标并不是呈现一个特别有用的物理模型（一个现实的流体-结构相互作用模型必须考虑到固体的有限变形以及它对流体的影响）：毕竟，这只是一个旨在演示技术的教程程序，而不是解决实际问题。此外，我们将假设子域之间的界面与粗略的网格单元面对齐。
*

*[1.x.47][1.x.48] 。


* 在进入更多的细节之前，让我们先说明一下：这是一个有多个解变量的问题；为此，你可能想先读一下[2.x.18]文件模块，它代表了我们处理有多个解变量的问题的基本哲学框架。但回到手头的问题上。
* 在deal.II中实现这类问题的基本思路如下：在问题的表述中，速度和压力变量[2.x.19]只存在于流体子域[2.x.20]中。但我们假设将它们以零点扩展到整个域[2.x.21]（在一般情况下，这意味着它们沿[2.x.22]将是不连续的）。那么，对于这些变量来说，合适的函数空间是什么？我们知道在[2.x.23]上我们需要[2.x.24]，所以对于[2.x.25]到整个领域的扩展，下面的函数空间似乎是一个有用的集合。
* [1.x.49]
* 由于这对目前的讨论并不重要，我们在选择函数空间时省略了边界值的问题；这个问题也影响到我们是否可以为压力选择[2.x.26]，或者我们是否必须为压力选择空间[2.x.27]。不过，这些问题都与下面的讨论无关）。)
* 请注意，这些确实是一个具有明显规范的线性函数空间。由于在实践中不可能发生混淆，因此我们将再次省略省略号，以表示一个函数对整个域的扩展，并简单地用[2.x.28]指代原始函数和扩展函数。
* 对于离散化，我们需要[2.x.30]的有限维子空间[2.x.29] 。对于斯托克斯，我们从[2.x.31]中知道，适当的选择是[2.x.32]，但这只适用于流体占据的那部分域。对于扩展场，让我们使用定义在三角形上的以下子空间[2.x.33] 。
* [1.x.50]
* 换句话说，在[2.x.34]上，我们选择通常的离散空间，但我们保持（不连续的）扩展为零。需要指出的是，我们现在需要描述一个在单元上为零的函数的有限元空间&mdash;这就是FE_Nothing类的作用：它描述了一个有限维度的函数空间，即恒定为零。这个特殊的线性向量空间的一个特殊属性是它没有自由度：它不仅仅是有限维度的，它实际上是零维的，因此对于这种类型的对象，[2.x.35]将返回零。为了下面的讨论，让我们给这个空间一个合适的符号：[1.x.51]符号[2.x.36]提醒了这个空间的函数为零的事实。很明显，我们选择[2.x.37]。
* 上面的整个讨论可以重复用于我们用来描述弹性方程的变量。这里，对于扩展变量，我们有
* [1.x.52]
* 我们通常会使用这样的有限元空间
* [1.x.53]
*多项式度数[2.x.38]。
* 因此，总的来说，我们要在以下空间中寻找一个离散的矢量估值解[2.x.39]。
* [1.x.54]

*


*[1.x.55][1.x.56]


* 那么我们如何实现这种事情呢？首先，我们意识到离散空间[2.x.40]本质上需要两个不同的有限元。首先，在流体子域上，我们需要元素[2.x.41]，在deal.II中很容易通过以下方式实现
* [1.x.57]
* 其中[2.x.42]实现的是永远为零的函数空间。第二，在实体子域上，我们需要元素[2.x.43]，我们用以下方法得到它
* [1.x.58]
*
* 下一步是我们将这两个元素分别与占据两个子域的单元联系起来。为此，我们认识到，从某种意义上说，这两个元素只是彼此的变化，因为它们具有相同数量的向量分量，但具有不同的多项式度数&mdash；这听起来非常像[2.x.44]有限元方法中的做法，而这正是我们在这里要做的：我们将（ab）使用hp命名空间的类和设施，将不同的元素分配给不同的单元。换句话说，我们将使用[2.x.45]中的两个有限元与适当的[2.x.46]集成，使用[2.x.47]对象，而我们的DoFHandler将处于[1.x.59]模式。你可能希望看一下[2.x.48]，了解所有这些概念的概况。
* 在继续描述测试案例之前，让我们澄清一下[1.x.60]这种将函数以0扩展到整个领域，然后将问题映射到HP-框架上的方法是有意义的。
*
* - 它使事情变得统一。在所有单元上，向量分量的数量是相同的（这里是[2.x.49]）。这使得各种事情都成为可能，因为统一的描述允许代码的重复使用。例如，计算每个向量分量的自由度[2.x.50]按分量对自由度进行排序[2.x.51]，随后将矩阵和向量分割成块，以及其他许多函数都能像以前一样工作，而不需要给它们添加特殊的逻辑，描述某些变量只存在于部分域的情况。因此，在像现在这样的程序中，你已经有了各种工具，这些工具最初并不是为多物理场情况编写的，但在目前的情况下却能正常工作。
*
* - 它可以方便地进行图形输出。我们支持的所有图形输出格式都要求输出中的每个字段都定义在网格的所有节点上。但是考虑到现在所有的解决方案组件都存在于各个地方，我们现有的DataOut例程可以像以前一样工作，并产生适合可视化的图形输出。
*
* - 这些字段将简单地以0扩展，如果不需要的话，可视化程序可以很容易地过滤掉这个值。
*
* - 基本上没有成本。使用FE_Nothing的技巧不会给整个问题增加任何自由度，我们也从来不需要处理属于这些分量的形状函数&mdash；FE_Nothing没有自由度，也没有形状函数，它所做的只是占用矢量分量。
*

*[1.x.61][1.x.62]


*更具体地说，在该方案中，我们必须解决以下问题。
*
* - 实现双线性形式，特别是处理界面项，包括矩阵和稀疏模式。
*
* - 在边界的外部和内部部分实现迪里切特边界条件 [2.x.52] 。
*

*[1.x.63][1.x.64]


* 让我们首先讨论实现双线性形式，在离散水平上，我们记得它是
* [1.x.65]
* 鉴于我们已经将场扩展为零，原则上我们可以将子域上的积分写成整个域[2.x.53]，尽管在决定对哪些项进行积分之前，首先询问一个单元是弹性区域还是流体区域的一部分，这几乎是额外的努力。实际上，对这些项进行积分并不十分困难；对于斯托克斯方程，相关步骤已在[2.x.54]中显示，而对于弹性方程，我们基本上采取[2.x.55]模块中的形式（而不是[2.x.56]中的形式）。
* 更令人感兴趣的是界面项，[1.x.66]基于我们的假设，即界面[2.x.57]与单元格边界相吻合，这实际上可以写成一组面积分。如果我们用抽取式注解[2.x.59]来表示形状函数[2.x.58]的速度、压力和位移分量，那么上述条款就会产生对全局矩阵入口[2.x.60]的如下贡献：[1.x.67]虽然不是很明显，但这个条款有一个小小的复杂化：虽然[2.x.61]和[2.x.62]是在界面的实体一侧评估的（它们分别是位移的测试函数和[2.x.63]的法向量，我们需要在界面的流体一侧评估[2.x.64]，因为它们对应于流体施加的应力/力。换句话说，在我们的实现中，我们将需要界面两边的FEFaceValue对象。更糟糕的是，我们可能还必须处理这样一个事实，即一方或另一方可能被细化，使我们需要整合一个面的部分内容。请看下面的实现，看看如何处理这个问题。
* 作为一个额外的复杂因素，由这个术语产生的矩阵条目需要以某种方式加入到矩阵的稀疏模式中。这就是DoFTools命名空间中的各种函数的作用，比如[2.x.65]和[2.x.66]从本质上讲，这些函数所做的是模拟系统矩阵装配过程中发生的事情：每当装配将一个非零条目写入全局矩阵时，DoFTools中的函数就会在稀疏模式中添加一个条目。因此，我们可以这样做：让[2.x.67]将所有由常规逐个单元积分产生的条目添加到稀疏模式中，然后用手做同样的事情，即由接口项产生的。如果你看一下下面程序中界面积分的实现，那么如何做应该是显而易见的，最多只需要100行代码就可以了。
* 但我们是懒人：界面项是沿一个面的两个相邻单元的自由度的耦合，这正是人们在非连续Galerkin方案中要做的事情，函数[2.x.68]就是为此而写。与通常的[2.x.69]相比，这是一个矩阵条目的超集，它还将添加所有计算来自所有面的两边自由度耦合项的条目。不幸的是，对于这个函数的最简单版本，这是一个相当大的超集。例如，考虑以下有两个单元和一个[2.x.70]有限元的网格。
* [1.x.68]
* 这里，由[2.x.71]产生的稀疏模式将只有在单元上耦合的自由度的条目。然而，它不会有稀疏模式条目[2.x.72]。然而，由[2.x.73]生成的稀疏模式会有这些条目：它假定你想为相邻单元的自由度[1.x.69]耦合的线性形式建立一个稀疏模式。这不是我们想要的：我们的界面项只作用于一小部分单元，我们当然不需要两个相邻流体单元或两个相邻固体单元之间的所有额外耦合。此外，我们使用高阶元素的事实意味着我们确实会产生比实际需要多得多的条目：在最粗的网格上，在2D中，44,207个非零条目而不是16,635个[2.x.74]，导致我们后来建立的矩阵中出现大量的零（当然，16,635个是不够的，因为它们不包括界面条目）。这个比例在3D中会更糟糕。
* 所以极度懒惰是有代价的：矩阵中的条目太多。但是我们可以适度偷懒：有一个[2.x.75]的变体，允许我们指定有限元的哪些向量分量与哪些分量相耦合，既可以用单元术语，也可以用面术语。对于处于实体子域中的单元，我们将所有位移相互耦合；对于流体单元，所有速度与所有速度和压力耦合，但压力与自身不耦合。由于没有一个单元同时具有这两组变量，因此没有必要区分这两种单元，我们可以这样写掩码。
* [1.x.70]
* 在这里，我们使用了这样一个事实：无限元素的第一个[2.x.76]分量是速度，然后是压力，最后是[2.x.77]位移。(我们也可以说，速度/压力也与位移耦合，因为没有一个单元同时拥有这两组变量)。另一方面，界面条款需要一个类似于这样的掩码。
* [1.x.71]
* 换句话说，所有位移测试函数（组件[2.x.78]）与界面另一侧的所有速度和压力形状函数耦合。这并不完全正确，尽管很接近：事实上，界面的确切形式仅指那些在共同界面上确实为非零的压力位移形状函数，这对所有形状函数来说并不真实；另一方面，它确实耦合了所有的velocities（因为积分涉及速度形状函数的梯度，这些梯度在单元的所有面上都是非零的）。然而，上面构建的掩码网络并不具备这些微妙的能力。尽管如此，通过掩码，我们还是设法将稀疏模式的条目数降到了21,028个&mdash; 目前来说已经足够了。
*


*[1.x.72][1.x.73]。


* 第二个困难是，虽然我们知道如何在外部边界上强制执行速度或应力为零（使用[2.x.79]调用适当的分量掩码，并为固体和液体外部边界设置不同的边界指示器），但我们现在还需要在内部界面上使速度为零，即[2.x.80] 。在写这篇文章的时候，deal.II中没有处理这部分的函数，但用手实现并不特别困难：基本上，我们只需要在所有单元上循环，如果它是一个流体单元，而它的邻居是一个固体单元，然后添加约束，确保这个面上的速度自由度为零。在处理相邻的实体单元被细化的情况时，需要注意一些问题，产生以下代码。
* [1.x.74]
*
* 调用[2.x.81]告诉AffineConstraints为自由度[2.x.82]启动一个新的约束，其形式为[2.x.83] 。通常情况下，我们会将单个系数[2.x.84]设置为非零值（使用[2.x.85]或将[2.x.86]设置为非零值（使用[2.x.87]不做任何事情，看起来很有趣，只是将约束设为[2.x.88]，这正是我们在当前情况下需要的。对[2.x.89]的调用保证了我们只将速度分量的边界值设置为零，而不是压力分量。
* 请注意，在有些情况下这可能会产生不正确的结果：特别是，一旦我们找到当前流体单元的一个固体邻接子，我们就会假定共同面上的所有邻接子都在固体子域中。但事实并非如此，例如，考虑以下的网格。
* [1.x.75]
*
* 在这种情况下，我们会将左单元右面的所有速度自由度设置为零，这对该面的顶部自由度来说是不正确的。也就是说，只有当流体和固体子域不与一组完整的粗网格单元重合时，才会发生这种情况；但这与本介绍第一节末尾的假设相矛盾。
*


*[1.x.76][1.x.77]


* 我们将考虑以下情况作为一个测试案例。
* [2.x.90]
* 正如本文顶部所讨论的，我们需要在一些地方假设一个单元完全处于域的流体部分或固体部分，此外，一个不活动的单元的所有子域也属于同一子域。如果粗网格已经将网格划分为固体和流体的粗网格单元，这一点肯定可以得到保证；考虑到上述的几何形状，我们可以通过使用[2.x.91]粗网格来做到这一点，[2.x.92]函数可以方便地提供。
* 底部的固定边界意味着[2.x.93]，我们也为顶部的流动规定了迪里希特条件，这样我们就可以在左边得到内流，在右边得到外流。在左边和右边的边界，没有对流动施加明确的边界条件，产生隐含的无应力条件[2.x.94]。两个领域之间的界面条件已经在上面讨论过。
* 为了简单起见，我们选择材料参数为[2.x.95]。在下面的结果部分，我们还将展示可以从同一程序中获得的三维模拟。界限条件和几何形状的定义几乎与上面的2d情况类似。
*

*[1.x.78][1.x.79] 。


*在程序中，我们需要一种方法来识别一个细胞处于域的哪一部分。有许多不同的方法可以做到这一点。一个典型的方法是使用每个单元的[2.x.96]"subdomain_id "标签，尽管这个字段在%并行计算中具有特殊意义。另一种方法是[2.x.97]"material_id "字段，也是每个单元格都有的。它有一个额外的优点，即在网格细化时，它可以从另一个单元继承到子单元；换句话说，我们在创建网格时设置一次材料ID，即使经过几次细化循环，它对所有活动单元都是正确的。因此，我们采用这种替代方法：我们定义一个[2.x.98]，用符号名称构成材料id数字，并使用它们来识别单元格在域的哪一部分。
* 其次，我们使用一个在[1.x.80]模式下运行的DoFHandler类型的对象。该类需要知道哪些单元将使用斯托克斯（Stokes）元素，哪些单元将使用弹性无限元素。因此，在每个细化周期的开始，我们必须走过所有的单元，并将（在hp-parlance中）活跃的FE索引设置为适合当前情况的索引。虽然我们可以用符号名来表示材料ID，但实际上主动FE索引是一个数字，经常用于索引对象集合（例如[2.x.99]和[2.x.100]类型），这意味着主动FE索引实际上对于流体部分必须是0，对于领域的弹性部分必须是1。
*

*[1.x.81][1.x.82]


* 这个程序主要是为了展示如何处理领域内不同部分的不同物理现象，以及如何在deal.II中实现这些模型。因此，我们不会费心想出一个好的求解器：我们只使用SparseDirectUMFPACK类，它总是能发挥作用，即使不是以最佳的复杂度。然而，我们将在[1.x.83]部分对可能的其他求解器进行评论。
*

*[1.x.84][1.x.85]


* 这个程序中比较棘手的一个方面是如何估计错误。因为它几乎适用于任何程序，所以我们想使用KellyErrorEstimator，在这里我们也可以用下面这样的代码相对容易地做到。
* [1.x.86]
* 这为每个单元格提供了两套误差指标。我们将以某种方式将它们合并为一个网格细化，例如使用类似下面的代码（注意，我们将两个向量中的平方误差指标归一化，因为误差量的物理单位在当前情况下并不匹配，导致两个子域之间的误差指标可能有数量级的差异）。
* [1.x.87]
* 在代码中，我们实际上以4:1的比例权衡误差指标，以支持在斯托克斯子域上计算的误差指标，因为细化在其他方面严重偏向于弹性子域，但这只是一个技术问题。因素4已被启发式地确定为相当好的工作。)
* 虽然这个原则是合理的，但它并不完全像预期的那样工作。原因是KellyErrorEstimator类是通过整合每个单元面周围的解的梯度跳跃来计算误差指标。在解不连续且扩展为零的地方，这个跳跃可能非常大；它也不会随着网格的细化而变小。KellyErrorEstimator类不能忽视这个接口，因为它基本上只在[1.x.88]模式下看到一个DoFHandler，其中元素类型从一个单元变为另一个单元&mdash；正是[1.x.89]模式所设计的东西，当前程序中的接口看起来与[2.x.101]中的接口没有什么不同，例如，当然也少不了合法化。尽管如此，最终的结果是，在两个子域之间的界面两侧都有一层细胞，误差指标大得不合理。因此，大部分的网格细化工作都集中在界面上。
* 如果我们有一个真正理解问题的细化指标，并且在积分跳跃项时简单地忽略子域之间的界面，这种情况显然不会发生。另一方面，这个程序是关于如何表示我们有不同的物理学上无所谓的子域的问题，而不是关于KellyErrorEstimator的特殊性，因此我们求助于称为 "启发法 "的大锤子：我们简单地将界面上的单元的误差指标设置为零。这就切断了误差指标的尖峰。乍一看，我们也会认为这将阻止网格在界面上的细化，但是相邻的单元只能有一个细化级别的差异的要求仍然会导致一个合理的细化网格。
* 虽然这显然是一个次优的解决方案，但它目前是有效的，并为将来的改进留下了空间。
*

* [1.x.90] [1.x.91]。
* [1.x.92] [1.x.93]。


*
* 这个程序的include文件和之前的许多其他程序是一样的。唯一的新文件是在介绍中讨论的声明FE_Nothing的文件。hp目录下的文件已经在 [2.x.102] 中讨论过了。
*


*


* [1.x.94]
*
* [1.x.95] [1.x.96]。


*
* 这是主类。如果你想的话，它是[2.x.103]和[2.x.104]的组合，因为它的成员变量要么针对全局问题（Triangulation和DoFHandler对象，以及[2.x.105]和各种线性代数对象），要么与弹性或斯托克斯子问题有关。然而，该类的一般结构与其他大多数实现静止问题的程序一样。   
* 有几个不言自明的辅助函数（<code>cell_is_in_fluid_domain, cell_is_in_solid_domain</code>）（对两个子域的符号名称进行操作，这些符号名称将被用作属于子域的单元的 material_ids。正如介绍中所解释的那样）和几个函数（<code>make_grid, set_active_fe_indices, assemble_interface_terms</code>），这些函数已经从其他函数中分离出来，可以在其他许多教程程序中找到，我们将在实现它们时讨论。   
* 最后一组变量（ [2.x.106] ）描述了用于两个物理模型的材料属性。
*


* [1.x.97]
*
* [1.x.98] [1.x.99]。


*
* 下面这个类就像它的名字所暗示的那样。速度的边界值分别为2d的[2.x.107]和3d的[2.x.108]。这个问题的其余边界条件都是同质的，在导言中已经讨论过。右边的强迫项对于流体和固体都是零，所以我们不需要为它设置额外的类。
*


* [1.x.100]
*
* [1.x.101] [1.x.102]。



* [1.x.103] [1.x.104]。



* 现在让我们来看看这个程序的主类的实现。最初的几个函数是构造函数和辅助函数，可以用来确定一个单元格在域的哪个部分。鉴于介绍中对这些主题的讨论，它们的实现是相当明显的。在构造函数中，注意我们必须从斯托克斯和弹性的基本元素中构造[2.x.109]对象；使用[2.x.110]函数在这个集合中为它们分配了0和1的位置，这个顺序我们必须记住并在程序的其余部分中一致使用。
*


* [1.x.105]
*
* [1.x.106] [1.x.107]。


*
* 下一对函数处理生成网格，并确保所有表示子域的标志是正确的。  [2.x.111] ，正如在介绍中所讨论的，生成一个[2.x.112]的网格（或者一个[2.x.113]的三维网格）以确保每个粗略的网格单元完全在一个子域内。生成这个网格后，我们在其边界上循环，并在顶部边界设置边界指标为1，这是我们设置非零迪里希特边界条件的唯一地方。在这之后，我们再次在所有单元上循环，设置材料指标&mdash；用来表示我们处于域的哪一部分，是流体还是固体指标。
*


* [1.x.108]
*
* 这对函数的第二部分决定在每个单元上使用哪个有限元。上面我们为每个粗略的网格单元设置了材料指标，正如在介绍中提到的，这个信息在网格细化时是由母单元继承到子单元的。   
*换句话说，只要我们细化（或创建）了网格，我们就可以依靠材料指标来正确描述一个单元所处的域的哪一部分。然后我们利用这一点将单元的活动FE索引设置为该类的[2.x.114]成员变量中的相应元素：流体单元为0，固体单元为1。
*


* [1.x.109]
*
* [1.x.110] [1.x.111]。


*
* 下一步是为线性系统设置数据结构。为此，我们首先要用上面的函数设置活动的FE指数，然后分配自由度，再确定线性系统的约束。后者包括像往常一样的悬挂节点约束，但也包括顶部流体边界的不均匀边界值，以及沿固体子域周边的零边界值。
*


* [1.x.112]
*
* 不过我们还必须处理更多的约束条件：我们必须确保在流体和固体的界面上速度为零。下面这段代码已经在介绍中介绍过了。
*


* [1.x.113]
*
* 在这一切结束时，我们可以向约束对象声明，我们现在已经准备好了所有的约束，并且该对象可以重建其内部数据结构以获得更好的效率。
*


* [1.x.114]
*
* 在这个函数的其余部分，我们创建了一个在介绍中广泛讨论的稀疏模式，并使用它来初始化矩阵；然后还将向量设置为正确的大小。
*


* [1.x.115]
*
* [1.x.116] [1.x.117]。



* 以下是这个程序的中心功能：组装线性系统的功能。它在开始时有一长段设置辅助功能的内容：从创建正交公式到设置FEValues、FEFaceValues和FESubfaceValues对象，这些都是整合单元项以及界面项所必需的，在这种情况下，界面上的单元以相同的尺寸或不同的细化程度聚集在一起...
*


* [1.x.118]
*
* ...到需要描述局部对全局线性系统贡献的对象...
*


* [1.x.119]
*
* ...到变量，允许我们提取形状函数的某些分量并缓存它们的值，而不是在每个正交点上重新计算它们。
*


* [1.x.120]
*
* 然后是所有单元的主循环，与[2.x.115]一样，为当前单元初始化[2.x.116]对象，并提取适合于当前单元的FEValues对象。
*


* [1.x.121]
*
* 所有这些完成后，我们继续为属于斯托克斯和弹性区域的单元组装单元项。虽然我们原则上可以在一个公式中完成这些，实际上就是实现介绍中所说的一个双线性形式，但我们意识到，我们的有限元空间的选择方式是，在每个单元上，有一组变量（速度和压力，或者位移）总是为零，因此，计算局部积分的更有效方式是，根据[2.x.117]条款，只做必要的事情，测试我们处于域的哪一部分。         
*局部矩阵的实际计算与[2.x.118]以及[2.x.119]文件模块中给出的弹性方程的计算相同。
*


* [1.x.122]
*
* 一旦我们有了单元积分的贡献，我们就把它们复制到全局矩阵中（通过[2.x.120]函数，立即处理约束）。请注意，我们没有把任何东西写进[2.x.121]变量中，尽管我们仍然需要把它传递出去，因为消除非零边界值需要修改局部的，因此也需要修改全局的右手边值。
*


* [1.x.123]

* 这个函数更有趣的部分是我们沿着两个子域之间的界面看到关于面的条款。为此，我们首先要确保我们只组装一次，即使在所有单元的所有面的循环中会遇到界面的每个部分两次。我们武断地决定，只有当当前单元是固体子域的一部分，并且因此一个面不在边界上，并且它后面的潜在邻居是流体域的一部分时，我们才会评估界面条款。让我们从这些条件开始。
*


* [1.x.124]
*
* 在这一点上，我们知道当前的单元格是一个候选的整合对象，并且面[2.x.122]后面存在一个邻居。现在有三种可能性。
*


*


*


*


*


*


*


*


*


*


*


*


*


*


*


*


*


*


*


*


*


*
* - 邻居处于相同的细化水平，没有子女。
*


*
* - 邻居有孩子。
*


*
* - 邻居是比较粗的。                 
* 在这三种情况下，我们只对它感兴趣，如果它是流体子域的一部分。因此，让我们从第一种最简单的情况开始：如果邻居处于同一层次，没有子女，并且是一个流体单元，那么这两个单元共享一个边界，这个边界是界面的一部分，我们想沿着这个边界整合界面项。我们所要做的就是用当前面和邻接单元的面初始化两个FEFaceValues对象（注意我们是如何找出邻接单元的哪个面与当前单元接壤的），然后把东西传给评估界面项的函数（这个函数的第三个到第五个参数为它提供了抓取数组）。然后，结果再次被复制到全局矩阵中，使用一个知道本地矩阵的行和列的DoF指数来自不同单元的函数。
*


* [1.x.125]
*
* 第二种情况是如果邻居有更多的孩子。在这种情况下，我们必须对邻居的所有子代进行循环，看它们是否是流体子域的一部分。如果它们是，那么我们就在共同界面上进行整合，这个界面是邻居的一个面和当前单元的一个子面，要求我们对邻居使用FEFaceValues，对当前单元使用FESubfaceValues。
*


* [1.x.126]
*
* 最后一个选项是，邻居比较粗大。在这种情况下，我们必须为邻居使用一个FESubfaceValues对象，为当前单元使用一个FEFaceValues；其余的和以前一样。
*


* [1.x.127]
*
* 在组装全局系统的函数中，我们将计算接口条款传递给了我们在此讨论的一个单独的函数。关键是，尽管我们无法预测FEFaceValues和FESubfaceValues对象的组合，但它们都是从FEFaceValuesBase类派生出来的，因此我们不必在意：该函数只是被调用，其中有两个这样的对象，表示面的两边正交点上的形状函数值。然后我们做我们一直在做的事情：我们用形状函数的值和它们的导数来填充从头数组，然后循环计算矩阵的所有条目来计算局部积分。我们在这里评估的双线性形式的细节在介绍中给出。
*


* [1.x.128]
*
* [1.x.129] [1.x.130]。



* 正如介绍中所讨论的，我们在这里使用了一个相当琐碎的求解器：我们只是将线性系统传递给SparseDirectUMFPACK直接求解器（例如，见[2.x.123]）。在求解之后，我们唯一要做的是确保悬挂的节点和边界值约束是正确的。
*


* [1.x.131]
*
* [1.x.132] [1.x.133]。


*
* 生成图形输出在这里是相当微不足道的：我们所要做的就是确定解向量的哪些分量属于标量和/或向量（例如，见[2.x.124]之前的例子），然后把它全部传递给DataOut类。
*


* [1.x.134]

* [1.x.135] [1.x.136]。


*
* 下一步是细化网格。正如在介绍中所讨论的，这有点棘手，主要是因为流体和固体子域使用的变量具有不同的物理尺寸，因此误差估计的绝对大小是不能直接比较的。因此，我们将不得不对它们进行缩放。因此，在函数的顶部，我们首先分别计算不同变量的误差估计值（在流体域中使用速度而不是压力，在固体域中使用位移）。
*


* [1.x.137]
*
* 然后，我们通过除以其常数来归一化误差估计值，并按照介绍中所讨论的那样，将流体误差指标按4的系数进行调整。然后将结果加在一起，形成一个包含所有单元的误差指标的向量。
*


* [1.x.138]
*
* 该函数的倒数第二部分，在实际细化网格之前，涉及到我们在介绍中已经提到的启发式方法：由于解是不连续的，KellyErrorEstimator类对位于子域之间边界的单元格感到困惑：它认为那里的误差很大，因为梯度的跳跃很大，尽管这完全是预期的，而且事实上在精确解中也存在这一特征，因此不表明任何数值错误。     
* 因此，我们将界面上的所有单元的误差指标设置为零；决定影响哪些单元的条件略显尴尬，因为我们必须考虑到自适应细化网格的可能性，也就是说，邻近的单元可能比当前的单元更粗，或者事实上可能被细化一些。这些嵌套条件的结构与我们在[2.x.125]中组装界面条款时遇到的情况基本相同。
*


* [1.x.139]
*
* [1.x.140] [1.x.141]。


*
* 像往常一样，这是控制整个操作流程的函数。如果你读过教程程序[2.x.126]到[2.x.127]，例如，那么你已经相当熟悉以下结构了。
*


* [1.x.142]
*
* [1.x.143] [1.x.144]。


*
* 这个，最后的，函数包含几乎完全是其他大多数教程程序的内容。
*


* [1.x.145]
* [1.x.146][1.x.147][1.x.148] 。


*[1.x.149][1.x.150]



* 当运行该程序时，你应该得到如下输出。
* [1.x.151]

* 结果很容易直观化。
* [2.x.128]
* 图形很容易解释：当水流在固体直立部分的左边向下、右边向上时，它产生的压力在左边高，在右边低，这些力量使固体的垂直部分向右弯曲。
*

*[1.x.152][1.x.153] 。


* 通过将[2.x.130]中的[2.x.129]类的维度改为3，我们也可以运行同样的problem3d。你会得到如下的输出。
* [1.x.154]
* 你会注意到，最大的瓶颈是求解器。SparseDirectUmfpack在2016年的工作站上解决这个问题的最后一次迭代需要将近5个小时和大约80GB的内存（倒数第二次迭代只花了16分钟）。显然，这里需要一个更好的求解器，这个话题将在下面讨论。
* 结果也可以被可视化，并产生良好的图片。这里有一张，显示了速度的矢量图（橙色），实体位移（蓝色），以及实体区域的阴影。
* [2.x.131]
* 除了缺乏一个好的求解器之外，网格也有点不平衡：网格细化严重偏向于流体子域（在2d中，情况正好相反，促使我们对流体误差指标的权重更高）。显然，如果想继续做更多的三维计算，对两个子域的误差指标的相对重要性进行一些调整是很重要的。
*

* [1.x.155][1.x.156][1.x.157] 。


*[1.x.158][1.x.159] 。


* 改进程序的一个明显的地方是使用一个更复杂的求解器&mdash；特别是一个能很好地扩展并能解决现实的三维问题的求解器。这在这里应该不难实现，因为从流体到固体是单向耦合的。为此，假设我们对自由度进行了重新排序，首先是所有的速度和压力自由度，然后是所有的位移自由度（用[2.x.132]很容易实现），那么系统矩阵可以分成以下块状形式：[1.x.160] 其中[2.x.133]是速度和压力的斯托克斯矩阵（它可以进一步细分为[2.x.134]矩阵，如[2.x.135]，尽管这对目前的目的并不重要），[2.x.136]来自位移的弹性方程，而[2.x.137]是来自界面条件的矩阵。现在注意到矩阵[1.x.161]是[2.x.138]的逆值。应用这个矩阵只需要解决[2.x.139]和[2.x.140]，因为[1.x.162]可以被计算为[2.x.141]，然后是[2.x.142]。
* 因此，我们可以预期，如果[2.x.143]，[1.x.163]将是一个好的预处理程序。
* 这意味着，我们只需要为斯托克斯和弹性方程分别提供良好的预处理。这些都是众所周知的：对于斯托克斯，我们可以使用[2.x.144]的结果部分所讨论的预处理程序；对于弹性，一个好的预处理程序将是一个几何或代数多重网格的单一V-循环。然而，还有更多的问题没有解决。对于由两个子预处理器构建的 "优化 "求解器块状三角预处理器来说，经常出现的一点是，在为子预处理器选择参数时，在单独求解两个问题时效果很好的值，在组合成多重物理学预处理器时可能不是最佳值。  特别是，当单独解决固体或流体力学问题时，在收敛所需的迭代次数和每次迭代应用预调节器的成本之间的平衡行为，可能导致人们为斯托克斯问题选择昂贵的预调节器，为弹性问题选择廉价的预调节器（反之亦然）。  然而，当两者结合在一起时，还有一个额外的约束，即你希望这两个子调节器以大致相同的速度收敛，否则便宜的调节器可能会增加全局的迭代次数，而昂贵的调节器则会增加每迭代的成本。例如，虽然单个AMGV循环本身就是一个很好的弹性方法，但当结合到一个多物理问题中时，可能有动力使用一个完整的W循环或多个循环来帮助降低总的求解时间。
*

*[1.x.164][1.x.165]


* 正如在介绍中提到的，我们在这个程序中使用的细化指标是比较特别的。一个更好的方法是理解解的梯度在界面上的跳跃并不是错误的指示，而是预期的，并且在整合跳跃值时忽略界面。然而，这并不是KellyErrorEstimator类所做的。另一个更大的问题是，这种估算器首先是否是一个好的策略：例如，如果我们想在位移的一个特定方面（例如实体右上角的位移）有最大的准确性，那么将流体和实体的误差指标扩大到相同的程度是否合适？也许有必要以比固体更高的精度来解决流体问题，因为流体的解决方案会直接影响到固体的解决方案？也许恰恰相反？
* 因此，改进该程序的一个明显的可能性是实施一个更好的细化标准。这方面有一些文献，其中一个可能的起点是Thomas Wick的论文 "Adaptive finite elements for monolithic fluid-structureinteraction on a prolongated domain:应用于心脏瓣膜模拟"，2011年机械学计算机方法会议论文集（CMM-2011），2011年5月9-12日，波兰华沙。


*[1.x.166][1.x.167] 。


* 上面的结果纯粹是定性的，因为没有证据表明我们的方案实际上是收敛的。因此，一个显而易见的做法是增加一些定量的措施来检查该方案至少收敛到[1.x.168]。例如，我们可以为每个细化周期输出实体的右上角突出到流体子域的部分的挠度。或者我们可以计算出流体对实体施加的净力矢量或扭矩。
*

*[1.x.169][1.x.170]


* 在现实中，大多数流体结构的相互作用问题是这样的：固体的运动确实影响到流体的流动。例如，空气在空气箔周围的作用力导致它弯曲并改变其形状。同样地，一面旗帜在风中飘动，完全改变了它的形状。
* 这种双向耦合的问题通常在Arbitrary Lagrangian Eulerian（ALE）框架中处理，其中固体的位移以某种平滑的方式扩展到流体域中，而不是像我们在这里做的那样以零为单位。然后，扩展的位移场被用来使网格变形，我们在上面计算流体流动。此外，界面上流体的边界条件不再是速度为零；相反，在一个随时间变化的程序中，流体的速度必须等于沿界面的位移的时间导数。
*

* [1.x.171][1.x.172] [2.x.145]。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-47_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34]
* [2.x.2]
* [1.x.35]
* [1.x.36][1.x.37][1.x.38] 。


* 本程序涉及[1.x.39]。
* [1.x.40]
* 这个方程出现在薄结构的建模中，如体育场的屋顶。当然，这些物体在现实中是三维的，具有较大的横向范围与垂直厚度的长宽比，但人们通常可以通过对内力在垂直方向上的变化作出假设，将这些结构非常准确地建模为二维的。这些假设导致了上面的公式。
* 该模型通常有两种不同的类型，取决于施加什么样的边界条件。第一种情况。
* [1.x.41]
* 对应于薄结构的边缘连接到高度为[2.x.3]的墙顶，这样作用在结构上的弯曲力为[2.x.4]；在大多数物理情况下，我们会有[2.x.5]，对应于结构只是坐在墙顶。
* 在边界值的第二种可能情况下，我们将有
* [1.x.42]
* 这相当于一个 "夹紧 "的结构，非零的[2.x.6]意味着与水平面有一定的角度。
* 正如拉普拉斯方程的迪里切特和诺依曼边界条件一样，当然也可以在边界的一部分有一种边界条件，而在另一部分有另一种边界条件。
*

*[1.x.43][1.x.44]


* 该方程的基本问题是它需要解的四次方。在我们在[2.x.7]、[2.x.8]和其他几个教程中处理的拉普拉斯方程的情况下，一个人乘以一个测试函数，进行积分，通过部分积分，最后在测试函数和试验函数上都只有一个导数。
*
* - 这是对全局连续的函数可以做的，但在单元间的界面上可能有结点。导数可能不是在界面上定义的，但那是在一个低维流形上（因此不会显示在积分值中）。
* 但是对于双调方程来说，如果按照同样的程序，用整个域（即所有单元的联盟）的积分来计算，最终会有两个导数在测试函数和试用函数上。如果使用通常的片状多项式函数，并在单元格界面上有结点，则第一个导数将产生一个不连续的梯度，第二个导数将在界面上撤回δ函数。
*
* 但由于测试函数和试验函数的二次导数都产生了德尔塔函数，我们将尝试整合两个德尔塔函数的乘积。例如，在1d中，[2.x.9]是通常的线性 "帽子函数"，我们会得到这样的积分
* [1.x.45]
* 其中[2.x.10]是定义形状函数[2.x.11]的节点位置，[2.x.12]是网格大小（假定为均匀的）。问题是，积分中的delta函数是用以下关系定义的
* [1.x.46]
* 但这只有在以下情况下才有效：(i) [2.x.13]实际上在[2.x.14]处定义良好，以及(ii)它是有限的。另一方面，一个积分的形式为
* [1.x.47]
*是没有意义的。类似的推理可以适用于2d和3ds的情况。
* 换句话说。这种试图在整个域上进行积分，然后通过部分积分的方法是行不通的。
* 历史上，数值分析家试图通过发明 "C<sup>1</sup>连续 "的有限元来解决这个问题，也就是说，使用的形状函数不仅是连续的，而且还有连续的第一次导数。这是诸如Argyriselement、Clough-Tocher元素和其他元素的领域，这些元素都是在20世纪60年代末开发的。从二十一世纪的角度来看，它们的结构只能说是怪异的。如果想使用一般的网格，它们的实现也是非常麻烦的。因此，它们在很大程度上已经失去了作用，目前deal.II并不包含这些形状函数的实现。
*

*[1.x.48][1.x.49]


* 那么，如何解决这些问题呢？这取决于边界条件。如果有第一组边界条件，即，如果方程是
* [1.x.50]
* 那么下面的窍门就会起作用（至少如果域是凸的，见下文）。就像我们通过引入第二个变量从常规拉普拉斯方程得到[2.x.15]的混合拉普拉斯方程一样，我们可以在这里引入一个变量[2.x.16]，然后可以用下面的 "混合 "系统代替上面的方程。
* [1.x.51]
* 换句话说，我们最终得到的实质上是[2.x.17]的两个耦合拉普拉斯方程系统，每个方程都有迪里希勒型边界条件。我们知道如何解决这样的问题，使用[2.x.18]或[2.x.19]的技术为这个系统构造良好的求解器和预处理器应该不是很困难。因此，这个案例的处理非常简单。
* [2.x.20] 值得指出的是，这只适用于边界有角的域，如果该域也是凸形的话
*
*--换句话说，如果没有重入角的话。  这听起来是一个相当随意的条件，但考虑到以下两个事实，它是有意义的。原始双调方程的解必须满足 [2.x.21] 。另一方面，上面的混合系统重述表明，[2.x.22]和[2.x.23]都满足[2.x.24]，因为这两个变量只解决一个泊松方程。换句话说，如果我们想保证混合问题的解[2.x.25]也是原来的偏谐方程的解，那么我们需要能够以某种方式保证[2.x.26]的解实际上比只是[2.x.27]更平稳。这一点可以作如下论证。对于凸域，[1.x.52]意味着，如果右侧[2.x.28]，那么[2.x.29]如果域是凸的并且边界足够光滑。(如果域的边界足够光滑，也可以保证这一点。
*
* - 但边界没有角的域在现实生活中并不十分实用）。)  我们知道[2.x.30]，因为它解决了方程[2.x.31]，但我们仍然留下了边界凸性的条件；我们可以证明多边形、凸形域在这种情况下足以保证[2.x.32]（光滑有界的凸形域将导致[2.x.33]，但我们不需要这么多规则性）。另一方面，如果域不是凸的，我们不能保证混合系统的解在[2.x.34]中，因此可能得到一个不能等于原始双调方程的解。
* 更复杂的情况是，如果我们有 "钳制 "的边界条件，也就是说，如果方程看起来像这样。
* [1.x.53]
* 混合系统的相同技巧在这里不起作用，因为我们最终会对[2.x.35]设定迪里切特和诺伊曼边界条件，但对[2.x.36]则没有。
*

*在20世纪90年代和21世纪初，这一难题的解决方案随着非连续加尔金法的出现而到来。与使用[1.x.55]形状函数处理拉普拉斯方程一样，我们可以使用[1.x.56]（而不是[2.x.37]连续）形状函数的方案，通过惩罚不连续的大小来获得每个形状函数上有一个导数的方程的方案，从而获得每个形状函数上有两个导数的方案。与拉普拉斯方程的内部惩罚（IP）方法类似，这个用于双调方程的方案通常被称为[2.x.38]IP（或C0IP）方法，因为它使用[2.x.39]（连续但不可连续微分）形状函数与内部惩罚公式。
*

*[1.x.57][1.x.58]


* 我们以SusanneBrenner和Li-Yeng Sung在 "C [2.x.41] Interior Penalty Methodfor Linear Four Order Boundary Value Problems on polygonaldomains"[2.x.42]一文中提出的[2.x.40]IP方法为基础，该方法是针对具有 "钳制 "边界条件的双谐波方程提出的。
* 如前所述，该方法依赖于使用[2.x.43]Lagrange有限元，其中[2.x.44]的连续性要求被放宽并被内部惩罚技术所取代。为了推导这个方法，我们考虑一个[2.x.45]形状函数[2.x.46]，它在[2.x.47]上消失。我们引入符号[2.x.48]作为[2.x.49]的所有面的集合，[2.x.50]作为边界面的集合，而[2.x.51]作为内部面的集合，以便在下面进一步使用。的高阶导数在每个界面[2.x.53]上有两个值（由两个单元[2.x.54]共享），我们通过在[2.x.55]上定义以下单值函数来应对这一不连续性。
* [1.x.59]
*用于[2.x.56]（即用于梯度和次导数矩阵），其中[2.x.57]表示指向[2.x.58]的单位向量法线，从[2.x.59]指向[2.x.60]。在文献中，这些函数分别被称为 "跳跃 "和 "平均 "操作。
* 为了得到[2.x.61]的IP近似值[2.x.62]，我们用[2.x.63]乘以双谐波方程，然后对[2.x.64]进行积分。如上所述，我们不能用这些形状函数对[2.x.65]的所有部分进行积分，但我们可以对每个单元单独进行积分，因为形状函数只是每个单元的多项式。因此，我们首先在每个网格单元[2.x.66]上使用下面的分部分项积分公式。
* [1.x.60]
* 在这一点上，我们有两个选择。我们可以对域项的[2.x.67]再进行一次积分，得到
* [1.x.61]
* 由于各种原因，这被证明是一个对我们的目的无用的变化。
* 相反，我们所做的是承认[2.x.68]，我们可以将这些操作重新排序为[2.x.69]，通常写成[2.x.70]，以表明这是第二导数的 "黑森 "矩阵。通过这样的排序，我们现在可以整合发散，而不是梯度算子，我们得到以下结果。
* [1.x.62]
* 这里，冒号表示对其左边和右边的矩阵指数的双重收缩，即两个张量之间的标量乘积。两个向量[2.x.71]的外积产生了矩阵[2.x.72]。
* 然后，我们对所有单元格[2.x.73]进行求和，并考虑到这意味着每个内部面在求和中出现两次。因此，如果我们把所有的东西分成细胞内部的积分之和和细胞界面的单独之和，我们就可以使用上面定义的跳跃和平均运算符。还有两个步骤。首先，由于我们的形状函数是连续的，形状函数的梯度可能是不连续的，但是连续性保证了实际上只有梯度的法向分量在各面是不连续的，而切向分量是连续的。第二，当网格大小为零时，所产生的离散公式是不稳定的，为了得到一个稳定的公式，收敛到正确的解，我们需要添加以下条款。
* [1.x.63]
* 然后，在对出现的情况进行抵消后，我们得到以下双调子方程的C0IP表述：找到[2.x.74]，使[2.x.75]在[2.x.76]上，并且
* [1.x.64]
*其中
* [1.x.65]
*和
* [1.x.66]
* 这里，[2.x.77]是惩罚参数，它既弱化了边界条件的执行力
* [1.x.67]
*在边界界面[2.x.78]上，也确保在极限[2.x.79]中，[2.x.80]收敛为[2.x.81]连续函数。  [2.x.82]被选择为足够大，以保证方法的稳定性。我们将在下面的程序中讨论我们的选择。
*

*[1.x.68][1.x.69]。
* 在多边形域上，双调方程的弱解[2.x.83]存在于[2.x.84]中，其中[2.x.85]是由[2.x.86]的角的内角决定的。例如，只要[2.x.87]是凸的，[2.x.88]；[2.x.89]可能小于1，如果域有重心角，但如果所有内角之一接近[2.x.92]，[2.x.90]就接近于[2.x.91] 。
* 现在假设[2.x.93]的IP解[2.x.94]被[2.x.95]的形状函数以多项式程度[2.x.96]所近似。那么，上述的解算就会产生下面所讨论的收敛率。
*

* [1.x.70]
* 理想情况下，我们希望在 "能量准则"[2.x.97]中测量收敛性。然而，这并不可行，因为同样，离散解[2.x.98]并没有两个（弱）导数。相反，我们可以定义一个离散([2.x.99] IP)半规范，"等同于 "能量规范，如下所示。
* [1.x.71]
*
* 在这个半规范中，上面提到的论文中的理论得出，我们可以期望
* [1.x.72]
* 与我们所知道的拉普拉斯方程的通常离散化的收敛率一样。
* 当然，只有在精确解足够光滑的情况下，这才是真的。事实上，如果[2.x.100]中有[2.x.101]，[2.x.102]中有[2.x.103]，那么[2.x.104]IP方法的收敛率为[2.x.105]。换句话说，只有在解非常平滑的情况下，才能期望达到最佳收敛率[2.x.106]；如果(i)域是凸的，有足够平滑的边界，以及(ii)[2.x.107]，这种情况就会发生。当然，在实践中，解决方案是什么就是什么（与我们选择的多项式程度无关），那么最后一个条件可以等同于说，如果[2.x.109]也不大，那么选择[2.x.108]大就肯定没有意义。换句话说，[2.x.110]的唯一合理选择是[2.x.111]，因为更大的多项式度数不会导致更高的收敛顺序。
* 就本程序而言，我们有点懒得去实际实现这个等价的语义准则。
*
* 尽管这并不难，而且会成为一个很好的练习。相反，我们将在程序中简单地检查一下 "破碎的"[2.x.112]语义规范是什么？
* [1.x.73]
*产生的结果。从理论上看，这个准则的收敛率当然不会比[2.x.113]的收敛率高[1.x.74]，因为它只包含必要条件的一个子集，但至少可以想象到它会更好。还有一种情况是，即使程序中存在一个错误，我们也能得到最佳收敛率，而这个错误只会在[2.x.114]中出现的额外条款中显示出次优收敛率。但是，人们可能希望，如果我们在破碎规范和下面讨论的规范中得到最优速率，那么这个程序确实是正确的。结果部分将证明我们在所有所述的规范中都得到了最优率。
*

* [1.x.75]
* 在 [2.x.115] -norm中的最佳收敛率是 [2.x.116] 提供 [2.x.117] 。更多细节可以在 [2.x.118] 的定理4.6中找到。
* 在下面的程序中，默认是选择[2.x.119]。在这种情况下，该定理并不适用，事实上，人们只能得到[2.x.120]而不是[2.x.121]，我们将在结果部分展示。
*

* [1.x.76]
* 鉴于我们在最好的情况下期望[2.x.122]的规范等同于[2.x.123]的半规范，而[2.x.124]的规范等同于[2.x.125]的半规范，我们可能会问在[2.x.126]的半规范中会发生什么，这与其他两个规范是中间的。一个合理的猜测是，我们应该期待[2.x.127]。可能在某个地方有一篇论文证明了这一点，但是我们也验证了这个猜想在实验中是真实的。
*


*[1.x.77][1.x.78]


* 我们注意到，[2.x.128]IP方法对具有其他边界条件的双谐波方程的推导
*
* - 例如，对于第一组边界条件，即[2.x.129]和[2.x.130]对[2.x.131]的边界条件
*
* 可以通过对书中[2.x.132]和[2.x.133]的适当修改得到。
*

*[1.x.79][1.x.80]


* 剩下的最后一步要描述的是这个程序的求解内容。一如既往，三角函数既是一个好的选择，也是一个坏的选择，因为它不在任何我们可以寻求解决方案的多项式空间中，同时又比实数解决方案通常更平滑（在这里，它在[2.x.135]中，而实数解决方案通常只在[2.x.136]左右的凸多边形域中，如果域不是凸的，则在[2.x.137]和[2.x.138]之间）。但是，由于我们没有办法用相对简单的公式来描述现实问题的解决方案，我们只是用下面的方法，在域[2.x.139]的单位平方上。
* [1.x.81]
* 因此，我们需要选择以下条件作为边界条件。
* [1.x.82]
* 右手边很容易计算为
* [1.x.83]
* 该程序有类[2.x.140]和[2.x.141]，对这些信息进行编码。
*

* [1.x.84] [1.x.85]。
* [1.x.86] [1.x.87]


*
* 前面的几个include文件已经在前面的例子中使用过了，所以我们在这里不再解释它们的含义。该程序的主要结构与例如[2.x.142]的结构非常相似，因此我们包含了许多相同的头文件。
*


*


* [1.x.88]
*
* 两个最有趣的头文件将是这两个。
*


* [1.x.89]
*
* 其中第一个负责提供FEInterfaceValues类，该类可用于评估诸如形状函数（或其梯度）在单元间界面上的跳跃或平均值等数量。这个类在评估C0IP公式中出现的惩罚项时相当有用。
*




*


* [1.x.90]
*
* 在下面的命名空间中，让我们定义精确的解决方案，我们将与数值计算的解决方案进行比较。它的形式是[2.x.143]（只实现了2d的情况），该命名空间还包含一个对应于产生该解的右手边的类。
*


* [1.x.91]
*
* [1.x.92] [1.x.93]。
* 以下是本教程程序的主要类别。它具有许多其他教程程序的结构，其内容和后面的构造函数应该没有什么特别令人惊讶的地方。
*


* [1.x.94]
*
* 接下来是创建初始网格（一次精炼的单元格）和设置每个网格的约束、向量和矩阵的函数。同样，这两个函数与以前的许多教程程序基本没有变化。
*


* [1.x.95]
*
* [1.x.96] [1.x.97]。
* 下面的代码更有趣。它们都与线性系统的装配有关。虽然组装单元格内部条款的难度不大
*
* - 这在本质上就像拉普拉斯方程相应项的装配，你已经在[2.x.144]或[2.x.145]中看到了这是如何工作的，比如说
*
* - 困难在于公式中的惩罚项。这需要在单元格的界面上评估形状函数的梯度。因此，至少需要使用两个FEFaceValues对象，但如果其中一个面是自适应细化的，那么实际上需要一个FEFaceValues和一个FESubfaceValues对象；我们还需要跟踪哪些形状函数在哪里，最后我们需要确保每个面只被访问一次。所有这些对于我们真正想要实现的逻辑（即双线性形式中的惩罚项）来说都是一笔不小的开销。因此，我们将使用FEInterfaceValues类。
*
* - deal.II中的一个辅助类，它允许我们抽象出两个FEFaceValues或FESubfaceValues对象，直接访问我们真正关心的东西：跳跃、平均数等。   
* 但这还没有解决我们的问题，即当我们在所有单元格和它们的所有面中循环时，必须跟踪我们已经访问过哪些面。为了使这个过程更简单，我们使用了[2.x.146]函数，它为这个任务提供了一个简单的接口：基于WorkStream命名空间文档中概述的想法，[2.x.147]需要三个函数对单元、内部面和边界面进行工作。这些函数对中间结果的从头开始工作，然后将其计算结果复制到复制数据对象中，由复制器函数将其复制到全局矩阵和右侧对象中。   
* 下面的结构就提供了这种方法所需的从头开始和复制对象。你可以查阅WorkStream命名空间以及[2.x.148]"多处理器的并行计算 "模块，以了解更多关于它们通常如何工作的信息。
*


* [1.x.98]
*
* 更有趣的部分是我们实际组装线性系统的地方。从根本上说，这个函数有五个部分。



*
* - "cell_worker "λ函数的定义，这是一个定义在`assemble_system()`函数中的小函数，它将负责计算单个单元上的局部积分。它将在 "ScratchData "类的副本上工作，并将其结果放入相应的 "CopyData "对象。
*


*
* - `face_worker` lambda函数的定义，它对生活在细胞间界面上的所有术语进行整合。
*


*
* - `boundary_worker`函数的定义，它做同样的事情，但对位于域的边界上的单元面。
*


*
* - `copier`函数的定义，该函数负责将前面三个函数为单个单元格放入复制对象的所有数据，复制到全局矩阵和右侧。   
* 第五部分是我们把所有这些都集中在一起。   
* 让我们轮流浏览一下这些组装所需的每一块。
*


* [1.x.99]
*
* 第一块是`cell_worker`，它在单元格内部进行装配。它是一个（lambda）函数，接受一个单元（输入）、一个抓取对象和一个复制对象（输出）作为参数。它看起来像许多其他教程程序的装配函数，或者至少是所有单元的循环主体。     
* 我们在这里整合的术语是单元格的贡献


* [1.x.100]
*到全局矩阵，以及


* [1.x.101]
*到右边的向量。     
* 我们使用与[2.x.149]的装配相同的技术来加速该函数。我们不在最里面的循环中调用`fe_values.shape_hessian(i, qpoint)`，而是创建一个变量`hessian_i`，在循环中对`i`进行一次评估，在循环中对`j`重新使用如此评估的值。为了对称，我们对变量`hessian_j`也做了同样的处理，尽管它确实只用了一次，而且我们可以在计算两个项之间标量乘积的指令中留下对`fe_values.shape_hessian(j,qpoint)`的调用。
*


* [1.x.102]
*
* 下一个构建模块是在网格的每个内部面组装惩罚项。正如在[2.x.150]的文档中所描述的，这个函数收到的参数表示一个单元和它的相邻单元，以及（对于这两个单元中的每一个）我们需要整合的面（和可能的子面）。同样，我们也得到了一个从头开始的对象，以及一个用于放置结果的副本对象。     
* 这个函数本身有三个部分。在顶部，我们初始化FEInterfaceValues对象，并创建一个新的[2.x.151]对象来存储我们的输入。这将被推到`copy_data.face_data`变量的末尾。我们需要这样做，因为我们对一个给定单元进行积分的面（或子面）的数量因单元而异，而且这些矩阵的大小也不同，取决于面或子面相邻的自由度。正如[2.x.152]文档中所讨论的，每次访问一个新的单元时，复制对象都会被重置，所以我们推到`copy_data.face_data()`末尾的内容实际上就是后来的`copier`函数在复制每个单元的贡献到全局矩阵和右侧对象时所能看到的全部内容。
*


* [1.x.103]
*
* 第二部分涉及到确定惩罚参数应该是什么。通过观察双线性形式中各种项的单位，很明显，惩罚必须具有[2.x.153]的形式（即，超过长度尺度的一个），但如何选择无维数[2.x.154]并不是先验的。从拉普拉斯方程的不连续Galerkin理论来看，人们可能猜想正确的选择是[2.x.155]是正确的选择，其中[2.x.156]是所用有限元的多项式程度。我们将在本方案的结果部分更详细地讨论这个选择。       
* 在上面的公式中，[2.x.157]是单元格[2.x.158]的大小。但这也不是很直接的事情。如果使用高度拉伸的单元格，那么一个更复杂的理论说，[2.x.159]应该被单元格[2.x.160]的直径取代，该直径是有关边缘方向的法线。  事实证明，在deal.II中有一个函数用于此。其次，当从一个面的两个不同侧面看时，[2.x.161]可能是不同的。       
* 为了安全起见，我们取这两个值的最大值。我们将注意到，如果使用自适应网格细化产生的悬空节点，这个计算有可能需要进一步调整。
*


* [1.x.104]
*
* 最后，像往常一样，我们在正交点和指数`i`和`j`上循环，把这个面或子面的贡献加起来。然后将这些数据存储在上面创建的`copy_data.face_data`对象中。至于单元格工作者，如果可能的话，我们将平均数和跳跃的评估从循环中拉出来，引入局部变量来存储这些结果。然后组件只需要在最里面的循环中使用这些局部变量。关于这段代码实现的具体公式，回顾一下，双线性形式的接口条款如下。


* [1.x.105]

*


* [1.x.106]
*
* 第三部分是对处于边界的面做同样的装配。当然，想法和上面一样，唯一不同的是，现在有惩罚条款也进入了右手边。     
* 和以前一样，这个函数的第一部分只是设置了一些辅助对象。
*


* [1.x.107]
*
* 积极的是，因为我们现在只处理与面相邻的一个单元（因为我们在边界上），惩罚因子[2.x.162]的计算大大简化了。
*


* [1.x.108]
*
* 第三块是术语的组合。由于这些条款包含了矩阵的条款和右手边的条款，所以现在稍微有点麻烦了。前者与上面所说的内部面完全相同，如果我们只是适当地定义了跳跃和平均（这就是FEInterfaceValues类所做的）。后者需要我们评估边界条件[2.x.163]，在当前情况下（我们知道确切的解决方案），我们从[2.x.164]中计算出来。然后，要添加到右侧向量的项是 [2.x.165] 。
*


* [1.x.109]
*
* 第四部分是一个小函数，它将上面的单元格、内部和边界面装配程序产生的数据复制到全局矩阵和右手向量中。这里真的没有什么可做的。我们分配单元格矩阵和右侧贡献，就像我们在其他几乎所有的教程程序中使用约束对象那样。然后，我们还必须对面矩阵的贡献做同样的处理，这些贡献已经获得了面（内部和边界）的内容，并且`面_工作`和`边界_工作`已经添加到`copy_data.face_data`数组中。
*


* [1.x.110]
*
* 在设置了所有这些之后，剩下的就是创建一个从头开始和复制数据的对象，并调用[2.x.166]函数，然后遍历所有的单元格和面，调用它们各自的工作器，然后是复制器函数，将东西放入全局矩阵和右侧。作为一个额外的好处，[2.x.167]以并行方式完成所有这些工作，使用你的机器恰好有多少个处理器核心。
*


* [1.x.111]
*
* [1.x.112] [1.x.113]。
* 到此为止，节目基本结束。其余的函数并不太有趣或新颖。第一个函数只是用一个直接求解器来求解线性系统（也见[2.x.168] ）。
*


* [1.x.114]
*
* 下一个函数评估了计算出的解和精确解之间的误差（在这里是已知的，因为我们选择了右手边和边界值的方式，所以我们知道相应的解）。在下面的前两个代码块中，我们计算了[2.x.169]准则和[2.x.170]半准则的误差。
*


* [1.x.115]

* 现在也计算一下[2.x.171]半正态误差的近似值。实际的[2.x.172]半规范要求我们对解[2.x.173]的二阶导数进行积分，但是考虑到我们使用的拉格朗日形状函数，[2.x.174]在单元间的界面上当然有结点，因此二阶导数在界面上是单数。因此，我们实际上只对单元的内部进行积分，而忽略了界面的贡献。这并不是*个与问题的能量准则等价的准则，但仍然给了我们一个关于误差收敛速度的概念。     
* 我们注意到，我们可以通过定义一个等同于能量准则的准则来解决这个问题。这将涉及到不仅要像我们下面所做的那样将细胞内部的积分相加，而且还要为[2.x.175]的导数在界面上的跳跃添加惩罚项，并对这两种项进行适当的缩放。我们将把这个问题留给以后的工作。
*


* [1.x.116]

* 同样无趣的是生成图形输出的函数。它看起来和 [2.x.176] 中的一模一样，比如说。
*


* [1.x.117]
*
* `run()`函数的情况也是如此。就像在以前的程序中一样。
*


* [1.x.118]
*
* [1.x.119] [1.x.120]。


*
* 最后是 "main() "函数。同样，这里没有什么可看的。它看起来和以前的教程程序中的一样。有一个变量，可以选择我们要用来解方程的元素的多项式程度。因为我们使用的C0IP公式要求元素的度数至少为2，所以我们用一个断言来检查，无论为多项式度数设置什么都是有意义的。
*


* [1.x.121]
* [1.x.122][1.x.123] 。


* 我们用介绍中讨论的右手边和边界值运行程序。我们用[2.x.179]、[2.x.180]和[2.x.181]元素来测试这个设置，我们可以通过`main()`函数中的`fe_degree`变量来改变。通过网格精简，[2.x.182]的收敛率、[2.x.183]的近似值收敛率和[2.x.184]的近似值收敛率对于[2.x.186]应该是2、2、1左右（如简介中讨论的[2.x.187]的规范次优）；对于[2.x.188]是4、3、2；而对于[2.x.189]是5、4、3。
* 从文献中，并不清楚惩罚参数[2.x.190]应该是什么。例如，[2.x.191]指出它需要大于1，并选择了[2.x.192]。FEniCS/Dolphin教程选择了它为[2.x.193]，见https://fenicsproject.org/docs/dolfin/1.6.0/python/demo/documented/biharmonic/python/documentation.html。  [2.x.194]使用的[2.x.195]值大于Kirchhoff板的元素所属的边数（见第4.2节）。这表明也许[2.x.196]、[2.x.197]太小了；另一方面，[2.x.198]的值也是合理的，其中[2.x.199]是多项式的度。最后一个选择是人们期望通过比较拉普拉斯方程的非连续Galerkin公式来实现的(例如，见[2.x.200]和[2.x.201]中的讨论)。但是我们应该检查一下[2.x.202]的值是多少，我们将在下面进行；改变[2.x.203]在`assemble_system()`定义的两个`face_worker`和`boundary_worker`函数中很容易。
*

* [1.x.124][1.x.125][1.x.126][1.x.127]


* 我们用不同的细化网格运行代码，得到以下收敛率。
* [2.x.204] 我们可以看到，[2.x.205]的收敛率约为2，[2.x.206] -seminorm收敛率约为2，而[2.x.207] -seminorm收敛率约为1。
*

* [1.x.128][1.x.129][1.x.130][1.x.131]



* [2.x.208] 我们可以看到，[2.x.209] 收敛率约为4，[2.x.210] -seminorm收敛率约为3,而[2.x.211] -seminorm收敛率约为2.当然，这与我们的理论预期相符。
*

* [1.x.132][1.x.133][1.x.134][1.x.135]


* [2.x.212] 我们可以看到[2.x.213]规范收敛率约为5，[2.x.214] -seminorm收敛率约为4，[2.x.215] -seminorm收敛率约为3。在最细的网格上，[2.x.216] 规范收敛率远小于我们的理论预期，因为线性求解器因舍入而成为限制因素。当然，在这种情况下，[2.x.217]误差也已经非常小了。
*

* [1.x.136][1.x.137][1.x.138][1.x.139]


* 为了与上面的结果进行比较，现在让我们也考虑一下我们只是选择[2.x.218]的情况。
* [2.x.219] 虽然[2.x.220]规范的收敛率或多或少符合理论预期，但[2.x.222] -seminorm和[2.x.223] -seminorm似乎并没有像预期那样收敛。鉴于[2.x.227]对于[2.x.228]元素来说已经太小了，如果用[2.x.229]元素重复实验，结果更加令人失望，这可能并不令人惊讶。我们又一次只得到了2、1、0的收敛结果。
*
* 然而，也许令人惊讶的是，当使用[2.x.231]元素时，人们获得了或多或少的预期收敛顺序。无论如何，这种不确定性表明[2.x.232]充其量是一个有风险的选择，在最坏的情况下是一个不可靠的选择，我们应该选择[2.x.233]更大。
*

* [1.x.140][1.x.141][1.x.142][1.x.143]


* 由于[2.x.234]显然太小，人们可能猜想[2.x.235]实际上可能效果更好。下面是在这种情况下得到的结果。
* [2.x.236] 在这种情况下，收敛率或多或少符合理论预期，但与[2.x.237]的结果相比，变化更大。同样，我们可以对[2.x.238]和[2.x.239]元素重复这种实验。在这两种情况下，我们都会发现我们获得了大致上的预期收敛率。那么，更有趣的是比较误差的绝对大小。在上表中，对于[2.x.240]情况，最细网格上的误差在[2.x.241]和[2.x.242]情况之间是可比的，而对于[2.x.243]，[2.x.244]的误差比[2.x.245]大很多。对于[2.x.246]的情况也是如此。
*

*[1.x.144][1.x.145] 。


* 我们应该使用哪种 "合理 "的惩罚参数的结论是：[2.x.247]产生了预期的结果。因此，这就是目前编写的代码所使用的。
*

*[1.x.146][1.x.147] 。


*这个程序有许多明显的扩展，会有意义。
*
* 该程序使用了一个正方形域和一个均匀的网格。真正的问题不是这样的，我们应该在其他形状的域上验证收敛性，特别是在弯曲的边界上。人们也可能对使用自适应网格细化来解决规则性较差的区域感兴趣。
*
* - 从更多的理论角度来看，上面的收敛结果只使用了 "破碎的"[2.x.248]半规范[2.x.249]，而不是 "等效的 "规范[2.x.250] 。这足以让我们相信，这个程序并没有从根本上被破坏。然而，测量我们有理论结果的实际规范的误差可能是有趣的。例如，使用FEInterfaceValues类与[2.x.251]结合，实现这一补充应该不会太困难，其精神与我们用于装配线性系统的精神相同。
*

* [1.x.148] [1.x.149]。


* 类似于实施中涉及的 "夹持 "边界条件，我们将推导出[2.x.252]简支板的IP有限元方案。
* [1.x.150]
* 我们用测试函数[2.x.253]乘以偏谐方程，并对[2.x.254]进行积分，得到。
* [1.x.151]
*
* 在所有单元格[2.x.255]上求和，因为[2.x.256]的法线方向在两个单元格和[2.x.257]共享的每条内边上指向相反方向。
* [1.x.152]
*根据单元格界面上的跳跃定义。
* [1.x.153]
* 我们把域的内部面和边界面分开。
* [1.x.154]
*其中[2.x.259]是内部面的集合。  这使我们得出
* [1.x.155]
*
*为了使离散问题对称化和稳定化，我们加入了对称化和稳定化项。  我们最终得到双调方程的[2.x.260]IP有限元方案：找到[2.x.261]，使[2.x.262]对[2.x.263]和
* [1.x.156]
*其中
* [1.x.157]
*和
* [1.x.158]
* 这个边界案例的实现与 "钳制 "版本类似，只是在系统装配时不再需要`边界_工人'，并且根据配方改变右手边。
*

* [1.x.159][1.x.160] [2.x.264] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-48_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23]
*
* [1.x.24][1.x.25]。
* [1.x.26][1.x.27][1.x.28] 。


* 本程序演示了如何使用MatrixFree类的基于单元的有限元算子实现，该类首次在[2.x.3]中介绍，用于解决非线性偏微分方程。最后，我们将使用明确的时间步进方法来解决问题，并介绍高斯-洛巴特有限元，在这种情况下非常方便，因为它们的质量矩阵可以准确地由对角线接近，因此是可逆的矩阵。这一特性的两个要素是：首先，根据Gauss-Lobatto正交规则的点分布，对拉格朗日多项式的结点进行分布。其次，正交是用同样的Gauss-Lobatto正交规则完成的。在这个公式中，只要[2.x.5]，积分[2.x.4]就变成零，因为在定义拉格朗日多项式的点中，正好有一个函数[2.x.6]是一，其他都是零。此外，拉格朗日多项式的节点的Gauss-Lobatto分布将节点向元素边界聚集。这就为高阶离散化方法提供了条件良好的多项式基础。事实上，具有等距节点的FE_Q元素的条件数随着度数的增加而呈指数级增长，这破坏了五阶以上的任何好处。因此，高斯-洛巴特点是FE_Q元素的默认分布（但在度数为1和2时，它们等同于等距点）。
*[1.x.29][1.x.30]
*

* 作为一个例子，我们选择解决正弦戈登孤子方程[1.x.31] 。
*这在[2.x.7]中已经介绍过。作为一种简单的显式时间积分方法，我们选择使用方程的二阶形式的跃迁方案。在这种时间步长的情况下，该方案以弱的形式读出
* [1.x.32]其中[1.x.33]表示一个测试函数，索引[1.x.34]代表时间步长。
* 对于空间离散化，我们选择FE_Q元素，其基函数定义为插值高斯-洛巴托正交规则的支持点。此外，当我们计算基函数上的积分以形成质量矩阵和上述方程右边的算子时，我们使用高斯-洛巴特正交规则，其支持点与有限元的节点相同，以评估积分。由于有限元是拉格朗日的，这将产生方程左侧的对角线质量矩阵，使得每个时间步长的线性系统的解决方案变得微不足道。
* 使用这个正交规则，对于[1.x.35]阶有限元，我们使用[1.x.36]阶精确公式来评估积分。由于在计算质量矩阵时，两个[1.x.37]阶基函数的乘积在每个方向上都给出了一个具有多项式程度[1.x.38]的函数，所以积分的计算并不精确。  然而，整体收敛性能并不受到正交误差的干扰，在具有亲和元素形状的网格上，L2误差与[1.x.39]成正比。但是请注意，当积分项不再是多项式时，在变形（非affine）元素形状的波浪方程上，已经有报道[1.x.40]甚至[1.x.41]的L2误差的次优收敛率的减序[1.x.42]。
* 除了在使用显式时间步进时我们可以避免用这种类型的元素解决线性系统外，它们还有另外两个优点。当我们使用和-因子化方法来评价有限元算子时（参见[2.x.8]），我们必须在正交点评价函数。在Gauss-Lobatto元素的情况下，正交点和无限元素的节点点是重合的，这种操作是微不足道的，因为正交点的函数值是由其一维系数给出的。这样一来，与一般的高斯正交相比，有限元运算估值的算术工作大约减少了2倍。
* 综上所述，通过使用正确的有限元和正交规则组合，我们最终得到的方案是只需要计算对应于上述公式的右手边向量，然后在每个时间步长中乘以对角线质量矩阵的逆。当然，在实践中，我们提取对角线元素并在程序开始时只反转一次。
*[1.x.43][1.x.44]
*

* 在[2.x.9]中处理约束的通常方法是使用AffineConstraints类，该类建立了一个稀疏矩阵，存储关于哪些自由度（DoF）被约束以及它们如何被约束的信息。这种格式使用了不必要的大量内存，因为没有那么多不同类型的约束：例如，在悬挂节点的情况下，当在每个单元上使用线性有限元时，大多数约束具有[2.x.10]的形式，其中系数[2.x.11]总是相同的，只有[2.x.12]不同。虽然存储这些多余的信息在一般情况下不是问题，因为它在矩阵和右手边的装配过程中只需要一次，但它在无矩阵方法中成为一个瓶颈，因为每次我们应用算子时都要访问这些信息，而算子评估的其他部分是如此之快。因此，MatrixFree使用一个我们称之为[2.x.13]的变量来收集不同约束的权重，而不是一个AffineConstraints对象。然后，只需要存储网格中每个约束的标识符而不是所有的权重。此外，约束不是在前后处理步骤中应用的，而是在我们评估有限元运算器时应用的。因此，约束信息被嵌入到变量[2.x.14]中，该变量用于从全局矢量中提取单元信息。如果一个DoF受到约束，[2.x.15]变量包含了它所约束的DoF的全局指数。然后，我们还有一个变量[2.x.16]，在每个单元中都有被约束的DoF的局部指数，以及约束类型的标识符。幸运的是，你不会在示例程序中看到这些数据结构，因为类[2.x.17]会在没有用户交互的情况下处理这些约束。
* 在存在悬空节点的情况下，通过Gauss-Lobatto正交/节点点程序在元素层面获得的对角质量矩阵并不能直接转化为对角的全局质量矩阵，因为遵循行和列的约束也会增加非对角条目。正如[1.x.45]中所解释的那样，在一个矢量上插值约束，保持质量矩阵的对角线形状，与方程一致，但误差的大小与正交误差相同。在下面的程序中，我们将简单地把质量矩阵的对角线作为一个矢量进行组合，以实现这种近似。
*

*[1.x.46][1.x.47]


* MatrixFree类有三个层次的并行化选项：分布式节点集群上的MPI并行化，由Threading Building Blocks库调度的线程并行化，以及最后通过SIMD数据类型在两个（或更多）单元的批次上工作的矢量化（有时称为跨元素或外部矢量化）。正如我们在[2.x.18]中所讨论的，你将通过使用特定于你的系统的指令集来获得最佳性能，例如，使用cmake变量<tt>-DCMAKE_CXX_FLAGS="-march=native"</tt>。在 [2.x.19] 中已经利用了MPI并行化。在这里，我们额外考虑了用TBB进行线程并行化。这相当简单，因为我们需要做的就是告诉MatrixFree对象的初始化，我们想通过变量[2.x.20]使用线程并行方案。 在设置过程中，建立了一个类似于[2.x.21]中描述的依赖图，这允许安排[2.x.22]函数在单元块上的工作，而没有几个线程访问同一个向量索引。相对于WorkStream循环，一些额外的巧妙技巧也被应用，以避免[1.x.48]中描述的全球同步。
* 请注意，这个程序被设计为与分布式三角计算[2.x.23]一起运行，这需要deal.II与[1.x.49]一起配置，如[1.x.50]文件中所述。然而，也支持非分布式三角计算，在这种情况下，计算将以串行方式运行。
*[1.x.51][1.x.52]
*

* 在我们的例子中，我们选择初始值为[1.x.53]，并在时间区间[-10,10]内解方程。常数被选择为[2.x.24]和[1.x.54]。正如在[2.x.25]中提到的，在一维中[1.x.55]作为[1.x.56]的函数是正弦-戈登方程的精确解。对于更高的维度，情况并非如此。
*

* [1.x.57] [1.x.58]。
* deal.II库中的必要文件。
*


* [1.x.59]
*
* 这包括用于有效实现无矩阵方法的数据结构。
*


* [1.x.60]
*
* 我们首先定义了两个全局变量，以便在一个地方收集所有需要改变的参数。一个是尺寸，一个是有限元度。维度在主函数中是作为实际类的模板参数使用的（就像所有其他deal.II程序一样），而有限元的度数则更为关键，因为它是作为模板参数传递给Sine-Gordon算子的实现。因此，它需要成为一个编译时常数。
*


* [1.x.61]
*
* [1.x.62] [1.x.63]。


*
* [2.x.26]类实现了每个时间步长中需要的基于单元的操作。这个非线性操作可以在[2.x.27]类的基础上直接实现，与线性操作在这个实现的有限元算子应用中的处理方式相同。我们对该类应用两个模板参数，一个是尺寸，一个是有限元的度数。这与deal.II中的其他函数不同，其中只有维度是模板参数。这对于向[2.x.28]中的内循环提供关于循环长度等的信息是必要的，这对于效率是至关重要的。另一方面，这使得将度数作为一个运行时参数来实现更具挑战性。
*


* [1.x.64]
*
* [1.x.65] [1.x.66]。


*
* 这是SineGordonOperation类的构造函数。它接收一个对MatrixFree的引用，该引用持有问题信息和时间步长作为输入参数。初始化程序设置了质量矩阵。由于我们使用Gauss-Lobatto元素，质量矩阵是一个对角矩阵，可以存储为一个矢量。利用FEEvaluation提供的数据结构，质量矩阵对角线的计算很容易实现。只要在所有的单元格批次上循环，即由于SIMD矢量化的单元格集合，通过使用[2.x.29]函数与[2.x.30]参数在槽中取值，在所有正交点上常一的函数上积分。最后，我们将对角线条目进行反转，以便在每个时间步长中直接得到反质量矩阵。
*


* [1.x.67]
*
* [1.x.68] [1.x.69]。


*
* 这个算子实现了程序的核心操作，即对正弦-戈登问题的非线性算子进行单元范围的积分。其实现是基于 [2.x.31] 中的FEEvaluation类。由于Gauss-Lobatto元素的特殊结构，某些操作变得更加简单，特别是正交点上的形状函数值的评估，这只是单元自由度值的注入。MatrixFree类在初始化时检测正交点的有限元的可能结构，然后由FEEvaluation自动用于选择最合适的数值核。
*

*
* 我们必须为时间步进例程评估的非线性函数包括当前时间[2.x.32]的函数值以及上一个时间步进[2.x.33]的值，这两个值都在源向量集合[2.x.34]中传递给运算器，它只是一个指向实际解向量的[2.x.35]的指针。这种将多个源向量收集到一起的结构是必要的，因为[2.x.36]中的单元格循环正好需要一个源向量和一个目的向量，即使我们碰巧使用许多向量，如本例中的两个。请注意，单元格循环接受任何有效的输入和输出类，这不仅包括向量，还包括一般的数据类型。  然而，只有在遇到收集这些向量的[2.x.37]或[2.x.38]时，它才会在循环的开始和结束时调用由于MPI而交换幽灵数据的函数。在单元格的循环中，我们首先要读入与本地值相关的向量中的值。  然后，我们评估当前求解向量的值和梯度以及正交点的旧向量的值。接下来，我们在正交点的循环中结合方案中的条款。最后，我们将结果与测试函数进行积分，并将结果累积到全局解向量[2.x.39] dst。
*


* [1.x.70]
*
* [1.x.71] [1.x.72]。


*
* 该函数根据单元格本地策略执行时间步进例程。请注意，在添加当前时间步长的积分贡献之前，我们需要将目标向量设置为零（通过[2.x.40]调用）。在本教程中，我们通过传递给[2.x.41]的第五个`true`参数让单元格循环进行归零操作。 循环可以将归零操作安排在更接近对支持的向量项的操作，从而可能提高数据的定位性（首先被归零的向量项后来在`distribute_local_to_global()`调用中重新使用）。单元循环的结构是在单元有限元运算器类中实现的。在每个单元上，它应用定义为类 [2.x.42] 方法的例程 [2.x.43] 。我们也可以提供一个具有相同特征的、不属于类的函数。最后，积分的结果被乘以逆质量矩阵。
*


* [1.x.73]
*
* [1.x.74] [1.x.75]。



* 我们定义了一个随时间变化的函数，作为初始值使用。通过改变起始时间可以得到不同的解。这个函数取自[2.x.44]，将代表所有时间的一维分析解，但在这里只是用于设置一些感兴趣的起始解。在 [2.x.45] 中给出了可以测试这个程序的收敛性的更详细的选择。
*


* [1.x.76]
*
* [1.x.77] [1.x.78]。


*
* 这是在 [2.x.46] 中的类基础上的主类。  然而，我们用MatrixFree类代替了SparseMatrix<double>类来存储几何数据。另外，我们在这个例子中使用了一个分布式三角形。
*


* [1.x.79]
*
* [1.x.80] [1.x.81]。


*
* 这是正弦戈登问题类的构造函数。时间间隔和时间步长在此定义。此外，我们使用我们在程序顶部定义的有限元的程度来初始化基于Gauss-Lobatto支持点的FE_Q有限元。这些点很方便，因为与同阶的QGauss-Lobatto正交规则相结合，它们可以得到一个对角线质量矩阵，而不会太影响精度（注意，虽然积分是不精确的），也可以参见介绍中的讨论。请注意，FE_Q默认选择Gauss-Lobatto结点，因为它们相对于等距结点有更好的条件。为了使事情更加明确，我们还是要说明节点的选择。
*


* [1.x.82]
*
* [1.x.83] [1.x.84]。


*
* 与[2.x.47]中一样，这个函数在[2.x.48]维度上设置了一个范围为[2.x.49]的立方体网格。我们在域的中心更多的细化网格，因为解决方案都集中在那里。我们首先细化所有中心在半径为11的单元，然后再细化一次半径为6的单元。  这种简单的临时细化可以通过在时间步进过程中使用误差估计器使网格与解相适应来完成，就像在其他例子程序中所做的那样，并使用[2.x.50]来将解转移到新的网格中。
*


* [1.x.85]
*
* 我们生成悬挂节点约束，以确保解决方案的连续性。如同在[2.x.51]中，我们需要为约束矩阵配备本地相关自由度的IndexSet，以避免它在大问题中消耗过多的内存。接下来，问题的<code>MatrixFree</code>对象被设置。请注意，我们为共享内存并行化指定了一个特定的方案（因此，人们会使用多线程来实现节点内的并行化，而不是MPI；我们在这里选择了标准选项&mdash；如果我们想在程序中有一个以上的TBB线程的情况下禁用共享内存并行化，我们会选择[2.x.52]也请注意，我们提供一个QGaussLobatto正交公式，而不是使用默认的QGauss正交参数，以实现期望的行为。最后，三个求解向量被初始化。MatrixFree期望有一个特定的鬼魂索引布局（因为它在MPI本地数字中处理索引访问，需要在向量和MatrixFree之间匹配），所以我们只是要求它初始化向量，以确保鬼魂交换得到正确处理。
*


* [1.x.86]
*
* [1.x.87] [1.x.88]。


*
* 这个函数打印出解的规范，并将解的向量写到一个文件中。法线是标准的（除了我们需要在所有处理器上累积平行网格的法线，我们通过[2.x.53]函数来做），第二项类似于我们在[2.x.54]或[2.x.55]中的做法。请注意，我们可以使用与计算过程中使用的相同的向量进行输出。无矩阵框架中的向量总是提供所有本地拥有的单元的全部信息（这也是本地评估中需要的），包括这些单元上的鬼向量条目。这是[2.x.56]函数以及DataOut中唯一需要的数据。这时唯一要做的就是确保在我们从矢量中读取数据之前更新其鬼魂值，并在完成后重置鬼魂值。这是一个只存在于[2.x.57]类中的特性。另一方面，带有PETSc和Trilinos的分布式向量需要被复制到包括ghost值的特殊向量（见[2.x.58]中的相关章节 ）。如果我们还想访问幽灵单元上的所有自由度（例如，在计算使用单元边界上的解的跳跃的误差估计器时），我们需要更多的信息并创建一个初始化了本地相关自由度的向量，就像在 [2.x.59] 中那样。还请注意，我们需要为输出分配约束条件
*
* - 它们不是在计算过程中填充的（相反，它们是在无矩阵方法中即时插值的 [2.x.60] 。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。


*
* 这个函数被主函数调用，并步入类的子程序中。   
* 在打印了一些关于并行设置的信息后，第一个动作是设置网格和单元运算器。然后，根据构造函数中给出的CFL编号和最细的网格尺寸计算出时间步长。最细的网格尺寸计算为三角形中最后一个单元的直径，也就是网格中最细层次上的最后一个单元。这只适用于一个层次上的所有元素都具有相同尺寸的网格，否则就需要对所有单元进行循环。请注意，我们需要查询所有处理器的最细单元，因为不是所有的处理器都可能持有网格处于最细级别的区域。然后，我们重新调整一下时间步长，以准确地达到最后的时间。
*


* [1.x.92]
*
* 接下来是初始值的设定。由于我们有一个两步的时间步进方法，我们还需要一个在时间步进时的解的值。为了得到准确的结果，需要从初始时间的解的时间导数来计算，但这里我们忽略了这个困难，只是将其设置为该人工时间的初始值函数。
*

*
* 然后我们将初始状态写入文件，并将两个起始解收集到[2.x.61]的指针中，随后被[2.x.62]函数所消耗。接下来，根据文件顶部指定的有限元程度，建立一个[2.x.63]的实例。
*


* [1.x.93]
*
* 现在在时间步数上循环。在每个迭代中，我们将解的向量移动一个，并调用`正弦戈登运算器'类的`应用'函数。然后，我们将解决方案写到一个文件中。我们对所需的计算时间和创建输出所需的时间进行计时，并在时间步长结束后报告这些数字。     
* 注意这个换位是如何实现的。我们只是在两个向量上调用了交换方法，只交换了一些指针，而不需要复制数据，这在显式时间步进方法中是一个相对昂贵的操作。让我们来看看发生了什么。首先，我们交换[2.x.64]，这意味着[2.x.65]得到[2.x.66]，这就是我们所期望的。同样，在下一步中，[2.x.67]也是如此。在此之后，[2.x.68]持有[2.x.69]，但在这一步中会被覆盖。
*


* [1.x.94]
*
* [1.x.95] [1.x.96]。


*
* 与[2.x.70]中一样，我们在程序开始时初始化MPI。由于我们一般会将MPI并行化与线程混合在一起，所以我们也将MPI_InitFinalize中控制线程数量的第三个参数设置为无效数字，这意味着TBB库会自动选择线程数量，通常为系统中可用的内核数量。作为一种选择，如果你想设置一个特定的线程数（例如，当需要只使用MPI时），你也可以手动设置这个数字。
*


* [1.x.97]
*[1.x.98][1.x.99]


*[1.x.100][1.x.101]


* 为了证明使用MatrixFree类而不是标准的[2.x.71]汇编例程来评估旧的时间步长的信息的好处，我们研究了一个简单的在非适应性网格上的序列运行的代码。由于许多时间花在评估正弦函数上，我们不仅显示了完整的正弦-戈登方程的数字，也显示了波浪方程（正弦-戈登方程中跳过的正弦项）的数字。我们同时使用二阶和四阶元素。结果总结在以下表格中。
* [2.x.72]
* 很明显，无矩阵代码远远超过了deal.II中的标准汇编程序。在三维和四阶元素中，一个操作值的速度也几乎是稀疏矩阵-向量积的十倍。
*[1.x.102][1.x.103]
*

* 我们从12个核心/24线的工作站上获得的程序输出开始（一个英特尔至强E5-2687W v4 CPU运行在3.2GHz，启用了超线程），在发布模式下运行该程序。
* [1.x.104]
*
*在3D中，各自的输出看起来像
* [1.x.105]
*
* 一个自由度超过一百万度的时间步长需要0.008秒（注意，在求解线性系统时，我们需要很多处理器来达到这样的数字）。
* 如果我们用一个纯粹的MPI并行化取代线程并行化，那么时间就会变成。
* [1.x.106]
*
* 我们观察到输出的大幅加速（这是有道理的，因为输出的大部分代码没有通过线程并行化，而MPI则是如此），但低于我们从并行性中期望的12的理论系数。更有趣的是，当从只用线程的变量切换到只用MPI的变量时，计算也变得更快。这是对MatrixFree框架的一般观察（截至2019年更新该数据）。主要原因是，为实现并行执行而做出的关于冲突单元批的工作的决定过于悲观：虽然它们确保在不同线程上不会同时对相邻单元进行工作，但这种保守的设置意味着在相邻单元被触及时，相邻单元的数据也会从缓存中被驱逐。此外，对于具有17592个单元的给定网格，目前的方案无法为所有24个线程提供恒定的负载。
* 目前的方案允许混合MPI并行化和线程并行化。当在有多个节点的集群上运行程序时，使用MPI进行节点间并行化，使用线程进行节点内并行化，这是最有利的。在上面使用的工作站上，我们可以在超线程区域运行线程（即在12个MPI等级中每个使用2个线程）。将MPI与线程混合在一起的一个重要设置是确保任务与CPU的正确分工。在许多集群上，通过`mpirun/mpiexec`环境自动放置，或者手动设置。在这里，我们简单地报告了程序的普通版本的运行时间（注意，当适当的定位完成后，事情可以向MPI-only程序的时间改进）。
* [1.x.107]

*


*[1.x.108][1.x.109]。


* 在这个程序中，有几处地方可以改进，使其更加有效（除了在[2.x.73]中讨论的改进边界条件和物理材料）。
* [2.x.74] [2.x.75] [1.x.110] 从上面的平波方程和正弦-戈登方程的比较中可以明显看出，正弦项的评估在有限元算子应用的总时间中占主导地位。这有几个原因。首先，VectorizedArray场的deal.II正弦计算没有被矢量化（与算子应用的其他部分相反）。这可以通过将正弦计算交给一个具有矢量化正弦计算的库来解决，比如英特尔的数学内核库（MKL）。通过使用MKL中的函数[2.x.76]，该程序在二维中使用了一半的计算时间，在三维中使用了40%的时间。另一方面，正弦计算在结构上要比其他本地操作中的加法和乘法等简单算术操作复杂得多。
* [2.x.77] [1.x.111] 虽然实现允许空间部分的任意顺序（通过调整有限元的程度），但时间步进方案是标准的二阶跃迁方案。由于波的传播问题的解通常是非常平滑的，所以误差很可能被时间步进部分所支配。当然，这可以通过使用较小的时间步长（在固定的空间分辨率下）来解决，但使用高阶时间步长也会更有效率。虽然对于一阶系统来说，这样做是很简单的（使用一些高阶的Runge&ndash;Kutta方案，可能与自适应时间步长选择相结合，如[1.x.112]），但对于二阶公式来说，这是更大的挑战。至少在有限差分界，人们通常用PDE来寻找改善时间误差的空间修正项。
* [2.x.78]
*

* [1.x.113][1.x.114] [2.x.79] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-49_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31]
* [1.x.32]
* [1.x.33][1.x.34][1.x.35] 。
* 本教程是对[2.x.2]的扩展，演示了几种方法，以获得比那里显示的更多的网格。
* [2.x.3] 本教程也可以作为Jupyter Python笔记本，使用deal.II python接口。该笔记本与原始的C++程序在同一目录下可用。
* 生成复杂的几何图形是一项具有挑战性的任务，尤其是在三空间维度上。我们将讨论几种方法，但这个清单并不详尽。此外，也没有一种方法适合所有的问题。
* 这个例子程序显示了一些为计算而创建和修改网格的方法，并以与我们在[2.x.5]中相同的方式将它们输出为[2.x.4]文件。没有做其他的计算或适应性修正；我们的想法是，你可以把这里使用的技术作为其他更复杂的模拟器的构建模块。请注意，这个示例程序并没有展示本介绍中所讨论的所有生成网格的方法。
*

*[1.x.36][1.x.37]


* 当你使用自适应网格细化时，你肯定希望初始网格尽可能地粗大。原因是只要你有内存和CPU时间，你就可以用自适应细化技术把它做得很细。然而，这就要求你不要把网格单元浪费在域的某些地方，因为这些单元是没有价值的。因此，你不希望从一个太细的网格开始，因为这已经占用了你的单元预算的很大一部分，而且你无法粗化初始网格中的单元。
* 也就是说，你的网格需要充分地捕捉给定的几何体。
*

*[1.x.38][1.x.39]


* 有几种方法可以创建一个初始网格。网格可以通过多种方式进行修改或组合，这一点将在后面讨论。
*[1.x.40][1.x.41]
*

* 生成网格最简单的方法是使用namespaceGridGenerator中的函数，在 [2.x.6] 中已经讨论过。  有许多不同的辅助函数可用，包括 [2.x.7] [2.x.8] [2.x.9] 和 [2.x.10] 。
*

*[1.x.42][1.x.43] 。


* 如果GridGenerator命名空间中没有适合你要做的事情，你总是可以在你的程序中 "手工 "创建一个三角测量。为此，你需要一个带有坐标的顶点列表和一个引用这些顶点的单元格列表。你可以在[2.x.11]中的函数<tt>create_coarse_grid()</tt>中找到一个例子。GridGenerator中的所有函数都是以这种方式实现。
* 我们很乐意接受更多的函数被添加到GridGenerator中。所以，如果你最终写了一个对更多人有用的函数，请贡献出来。
*

*[1.x.44][1.x.45]


* GridIn类可以从磁盘的文件中读取许多不同的网格格式。如何做到这一点，在[2.x.12]中有解释，在这个例子中可以看到函数[2.x.13]，见下面的代码。
* 网格可以由不同的工具生成，如[1.x.46]、[1.x.47]和[1.x.48]。更多信息见GridIn的文档。问题是，deal.II需要的网格只由四边形和六面体组成。
*
* - 四面体网格无法工作（这意味着不能直接使用tetgen等工具）。
* 我们将描述一个使用%Gmsh的可能工作流程。%Gmsh是我们所知道的最小的、最快速设置的开源工具。它可以生成非结构化的二维四边形网格。在三维中，它可以将二维网格挤压成六面体网格；可以将非结构化的几何体三维网格化为六面体，尽管这些网格的质量有一些问题，这意味着这些网格有时只能在交易中工作。
* 在%Gmsh中，网格的基本描述是基于文本的[2.x.14]文件，其格式可以包含计算、循环、变量等。这种格式相当灵活，允许描述复杂的几何形状。网格是由表面表示法生成的，表面表示法是由线环列表建立的，线环列表是由线组成的，而线又是由点组成的。[2.x.15]脚本可以手工编写和编辑，也可以通过在%Gmsh中以图形方式创建对象自动生成。在许多情况下，最好是把这两种方法结合起来。如果你想用手写的话，可以在 "Geometry "标签下按 "reload "键轻松加载该文件，并在gmsh的图形用户界面上看到效果。
* 本教程包含一个[2.x.16]文件的例子，它描述了一个内部有两个物体被切割出来的盒子。这就是[2.x.17]在%Gmsh中的样子（显示边界指示器以及下面要讨论的网格）。
* [2.x.18]
* 你可能想用文本编辑器打开[2.x.19]文件（它与<tt> [2.x.20] .cc</tt>源文件位于同一目录下），看看它的结构如何。你可以看到域的边界是如何由一些线组成的，以及后来我们如何将一些线组合成 "物理线"（或 "物理面"），列出逻辑线的编号。"物理 "对象是携带边界指标信息的对象（见[2.x.21]"本词汇表条目"）。
* [2.x.22] 这个文件包含 "物理线 "和 "物理面 "是很重要的。它们提供了在deal.II中使用的边界指标和材料ID。没有这些物理实体，任何东西都不会被导入到deal.II中。
* deal.II的GridIn类可以读取由%Gmsh编写的[2.x.23]格式，该格式包含为[2.x.24]描述的几何体创建的网格，通过运行以下命令，可以从[2.x.25]中创建网格
* [1.x.49]
*
*在命令行中，或者在加载文件后点击%Gmsh中的 "Mesh "和 "2D"。  现在这是从[2.x.26]文件中读取的网格，并由deal.II再次保存为图像（见当前程序的[2.x.27]功能）。
* [2.x.28]
* [2.x.29] %Gmsh有许多其他接口，人们可以通过这些接口来描述几何图形。特别是，它能够与Python和Julia这样的脚本语言对接，但它也可以用C++来编写脚本。这些接口很有用，如果人们不只是想为一个单一的几何体生成网格（在这种情况下，图形界面或者在简单的情况下，手写的".geo "文件可能是最简单的方法），而是想对几何体进行参数化研究，为此需要为某些参数不同的几何体生成许多网格。另一种情况是，如果已经有一个CAD几何体，只需要一个网格；事实上，这可以在deal.II中使用[2.x.30]函数来完成。
*

*[1.x.50][1.x.51]


* 在以上述方式获得一个（或几个）网格后，在将其用于有限元计算之前，有许多方法可以对其进行操作。
*

*[1.x.52][1.x.53]


* GridTools命名空间包含了一系列的小函数，用于以各种方式转换给定的网格。函数 [2.x.31] [2.x.32] [2.x.33] 的用法相当明显，所以我们在此不讨论这些函数。
* 函数[2.x.34]允许你使用平滑函数来变换给定网格的顶点。在[2.x.35]的结果部分也给出了一个使用的例子，但让我们在这里展示一个更简单的例子：在当前程序的函数[2.x.36]中，我们用正弦曲线扰动一个网格的y坐标。
* [2.x.37]
* 同样地，我们可以用公式[2.x.38]将一个有规律的细化的正方形转化为y方向的墙体适应的网格。这在本教程的 [2.x.39] 中完成。[2.x.40]
* 最后，函数[2.x.41]允许你将网格中的顶点（可选择忽略边界节点）随机移动。这在[2.x.42]中进行了演示，其结果如下。
* [2.x.43]
* 这个函数主要是为了否定在研究常规网格收敛时得到的一些超级收敛效应，同时也是为了抑制deal.II中的一些优化，这些优化可以利用细胞形状相似的事实。超级收敛是指，如果一个网格具有某些对称性，那么它的收敛性就会降低。
*
* 例如，如果进入一个顶点的边对这个顶点是对称的，并且如果对一个单元的所有顶点都是这样的话
*
* 解往往比通常的误差分析所预期的更高阶收敛。最后，这是一个事实，即如果对误差进行泰勒扩展，对称性导致了这样一个事实，即预期的扩展的下一个项恰好是零，而误差的阶数是由第二项决定的。
*第二项下*项。一个扭曲的网格没有这些对称性，因此，误差反映了在任何*种网格上解方程时都会看到的情况，而不是显示只反映特定情况的东西)。
*

*[1.x.54][1.x.55]


* 该函数[2.x.44]允许你将两个给定的三角形对象合并成一个。  要做到这一点，共享边或面的顶点必须完全匹配。  排列两个网格可以用 [2.x.45] 和 [2.x.46] 来实现。 在本教程的函数 [2.x.47] 中，我们合并了一个带圆孔的正方形（用 [2.x.48] 生成）和一个三角形（用 [2.x.49] 生成）。函数 [2.x.50] 允许你指定重复的数量和角的位置，所以这里不需要手动移动三角网格。你应该以图形方式检查网格，以确保单元格排布正确，并且在三角剖分中没有未配对的节点存在。
* 这些是输入的网格和输出的网格。
* [2.x.51]
*

*[1.x.56][1.x.57]


* 函数[2.x.52]展示了在现有网格中挑选单个顶点并移动它们的能力。请注意，这有可能产生退化或倒置的单元，你不应该指望使用这样的网格会产生任何有用的东西。这里，我们通过向上移动顶部顶点来创建一个不完全居中的圆柱形孔的盒子。
* [2.x.53]
* 关于如何做到这一点的确切方法，见下面的代码。
*

*[1.x.58][1.x.59]


* 如果你需要一个可以通过挤压给定的2D网格（可以通过上述任何一种方式创建）来创建的3D网格，你可以使用函数[2.x.54] 参见本教程中的[2.x.55]函数的例子。请注意，在这个特殊的情况下，给定的结果也可以用3D版本的[2.x.56]来实现。主要用途是一个2dmesh，例如用%Gmsh生成，如上所述从[2.x.57]文件中读入。这是grid_4()的输出。
* [2.x.58]
*

*[1.x.60][1.x.61]


* 使用上面讨论的方法创建一个粗略的网格只是第一步。当你有了它，它通常会作为进一步的网格细化的基础。这并不困难，事实上，如果你的几何体只由直面组成，那就没有其他事情可做。然而，如果你有一个更复杂的几何体，情况往往就不是这样了，除了创建网格之外，还有更多的步骤是必须的。我们将在下面的[1.x.62]中介绍其中的一些步骤。
*

* [1.x.63] [1.x.64]。
* 这个教程程序很奇怪，因为与其他大多数步骤不同，介绍已经提供了关于如何使用各种策略来生成网格的大部分信息。因此，这里没有什么需要评论的，我们在代码中穿插了相对较少的文字。从本质上讲，这里的代码只是提供了一个在介绍中已经描述过的参考实现。
*


* [1.x.65] [1.x.66]。



*


* [1.x.67]
*
* [1.x.68] [1.x.69]。


*
* 下面的函数为我们将在本程序的剩余部分生成的任何网格生成一些输出。特别是，它生成了以下信息。
*


*


*
* - 一些关于这个网格所处的空间维数和它的单元数的一般信息。
*


*
* - 使用每个边界指标的边界面的数量，这样就可以与我们预期的情况进行比较。
*

*
* 最后，该函数输出VTU格式的网格，可以在Paraview或VisIt中轻松实现可视化。
*


* [1.x.70]
*
* 接下来循环所有单元格的所有面，找出每个边界指标的使用频率（记得如果你访问一个不存在的[2.x.59]对象的元素，它将被隐式创建并默认初始化
*
* - 为零，在当前情况下
*
* - 在我们向它递增之前）。)
*


* [1.x.71]
*
* 最后，产生一个网格的图形表示到一个输出文件。
*


* [1.x.72]
*
* [1.x.73] [1.x.74]。



* [1.x.75] [1.x.76]。


*
* 在这第一个例子中，我们展示了如何加载我们在介绍中讨论过的如何生成的网格。这与在[2.x.60]中使用的加载网格的模式相同，尽管那里是以不同的文件格式（UCD而不是MSH）编写的。
*


* [1.x.77]
*
* [1.x.78] [1.x.79]。


*
* 在这里，我们首先创建两个三角形，然后将它们合并成一个。  正如介绍中所讨论的，必须确保共同界面的顶点位于相同的坐标上。
*


* [1.x.80]
*
* [1.x.81] [1.x.82]。


*
* 在这个函数中，我们移动一个网格的顶点。这比人们通常想象的要简单：如果你用[2.x.61]询问一个单元格的第[2.x.62]个顶点的坐标，它并不只是提供这个顶点的位置，实际上是对存储这些坐标的位置的一个引用。然后我们可以修改存储在那里的值。
*

*
* 所以这就是我们在这个函数的第一部分所做的。我们创建一个几何形状为[2.x.63]的正方形，在原点上有一个半径为0.25的圆孔。然后我们在所有单元格和所有顶点上循环，如果一个顶点的[2.x.64]坐标等于1，我们就把它向上移动0.5。
*

*
* 请注意，这种程序通常不会这样工作，因为人们通常会多次遇到相同的顶点，并可能多次移动它们。它在这里起作用是因为我们根据顶点的几何位置来选择要使用的顶点，一个被移动过一次的顶点在未来将无法通过这个测试。解决这个问题的一个更普遍的方法是保留一个[2.x.65]的那些我们已经移动过的顶点索引（我们可以用[2.x.66]获得，并且只移动那些索引还不在这个集合中的顶点。
*


* [1.x.83]
*
* 在第二步，我们将对网格进行两次细化。为了正确做到这一点，我们应该沿着以原点为中心的圆的表面在内部边界上放置新的点。幸运的是，[2.x.67]已经在内部边界上附加了一个Manifold对象，所以我们不需要做任何事情，只需要细化网格（参见[1.x.84]中一个完全可行的例子，我们[2.x.68]做[2.x.69]附加一个Manifold对象）。
*


* [1.x.85]
*
* 如上图所示，做事有一个障碍。如果像这里显示的那样移动边界上的节点，由于内部的节点没有被移动，往往会导致内部的单元严重变形。在目前的情况下，这并不是一个很大的问题，因为当节点被移动时，网格并不包含任何内部节点。
*
* - 这是粗略的网格，而且恰好所有顶点都在边界上。还有一种情况是，我们在这里的移动，与平均单元大小相比，并没有过于夸张。然而，有时我们确实想把顶点移动一段距离，在这种情况下，我们也需要移动内部节点。一个自动完成的方法是调用函数[2.x.70]，该函数接收一组转换后的顶点坐标并移动所有其他的顶点，使生成的网格在某种意义上有一个小的变形。
*




*


* [1.x.86] [1.x.87]。


*
* 这个例子从前面的函数中获取初始网格，并简单地将其挤压到第三空间维度。
*


* [1.x.88]
*
* [1.x.89] [1.x.90]。


*
* 这个例子和下一个例子首先创建一个网格，然后根据一个函数移动网格的每个节点，这个函数接收一个点并返回一个映射的点。在这个例子中，我们转换[2.x.71] .
*

*
* [2.x.72]需要一个三角函数和一个参数，这个参数可以像一个函数一样被调用，接收一个点并返回一个点。有不同的方式来提供这样一个参数。它可以是一个函数的指针；它可以是一个具有`operator()`的类的对象；它可以是一个lambda函数；或者它可以是任何通过[2.x.73]对象描述的东西。
*

*
* 决定性的是，更现代的方法是使用一个接受一个点并返回一个点的lambda函数，这就是我们在下面所做的。
*


* [1.x.91]
*
* [1.x.92] [1.x.93]。


*
* 在第二个例子中，我们将使用映射[2.x.74]将原始网格中的点转换为新的网格。为了使事情更有趣，而不是像前面的例子那样在一个单一的函数中完成，我们在这里创建一个具有[2.x.75]的对象，这个对象将被[2.x.76]所调用。当然，这个对象实际上可能要复杂得多：这个对象可能有成员变量，在计算顶点的新位置方面起作用。
*


* [1.x.94]
*
* [1.x.95] [1.x.96]。


*
* 在这最后一个例子中，我们创建了一个网格，然后通过随机扰动使其（内部）顶点变形。这不是你想在生产计算中做的事情（因为在具有 "良好形状 "单元的网格上的结果通常比在由[2.x.77]产生的变形单元上的结果要好），但它是一个有用的工具，用于测试离散化和代码，以确保它们不会因为网格碰巧是均匀结构和支持超收敛特性而意外地工作。
*


* [1.x.97]
*
* [1.x.98] [1.x.99]。


*
* 最后是主函数。这里没有什么可做的，只是调用我们上面写的所有各种函数。
*


* [1.x.100]
* [1.x.101][1.x.102] 。


* 该程序产生一系列[2.x.78]的三角计算文件。这些方法在上面已经讨论过了。
*

*[1.x.103][1.x.104] 。


* 正如在介绍中提到的，使用这里讨论的方法创建一个粗略的网格仅仅是第一步。为了细化网格，三角计算需要知道在边、面和单元的中点上放置新的顶点。默认情况下，这些新的点会被放置在周围点的算术平均值上，但如果你需要的是没有被粗网格充分解决的弯曲边界，这并不是你想要的。例如，对于这个网格，中心孔应该是圆形的。
* [2.x.79]
* 如果你简单地细化它，三角剖分类不能知道你想让孔是圆的还是八角形的。默认的做法是在现有的直线上放置新的点。经过两个网格细化步骤后，会产生以下的网格，这不是我们想要的。
* [2.x.80]
* 需要做的是，你告诉三角计算，你实际上是想使用一个弯曲的几何体。要做到这一点需要三个步骤。
*
* - 创建一个描述所需几何体的对象。这个对象将在细化三角测量的新点位置时被查询。如果在系统装配过程中使用了MappingQ或MappingQGeneric这样的高阶映射，它也将被用来计算形状函数值。  在deal.II中，Manifold类和继承自它的类（如PolarManifold和FlatManifold）执行这些计算。
*
* - 通知Triangulation对象使用哪个Manifold类。默认情况下，一个Triangulation使用FlatManifold来进行所有的几何计算，它假设所有的单元格边缘都是直线，所有的四边形都是平的。你可以通过调用[2.x.81]函数将Manifold类附加到Triangulation上，该函数将[2.x.82]与Manifold对象关联。关于这一点的更多信息，请参见[2.x.83]"关于这个主题的词汇条"。
*
* - 最后，你必须用正确的 [2.x.84] 标记单元格和单元格面。例如，你可以通过以下方式得到一个在直角坐标中带有弯曲单元的环形扇面（但在极坐标中是矩形）。
* [1.x.105]
* 现在，当网格被细化时，所有的单元格分割计算都将在极坐标中完成。
* GridGenerator命名空间中所有创建网格的函数都会将正确的Manifold对象附加到提供的Triangulation上：也就是说，对于这些函数，我们默认会得到正确的行为。然而，对于手工生成的网格，情况要有趣得多。
* 为了更详细地说明这个过程，让我们考虑一个由Yuhan Zhou创建的例子，作为2013年德克萨斯A&amp;M大学的一个学期项目的一部分。在一个CAD程序中，这个几何体看起来像这样。
* [2.x.85]
* 在下文中，我们将指导你完成为这个几何体创建网格的整个过程，包括一些常见的陷阱，展示可能出错的东西。
* 第一步是创建一个粗略的网格，通过为每个截面创建一个2D粗略的网格，将它们挤压到第三个方向，然后将它们粘在一起。下面的代码使用之前描述的技术完成了这个工作。
* [1.x.106]

* 这将创建以下的网格。
* <img src="https://www.dealii.org/images/steps/developer/ [2.x.86] .yuhan.8.png" alt="" width="400" height="355"> * 这个网格具有正确的总体形状。
* 这个网格有正确的大体形状，但是顶部的单元格现在是多边形的：线不再是沿着圆的，我们没有一个非常准确的原始几何的代表。下一步是教给域的顶部部分，它应该是弯曲的。换句话说，所有在顶部边界单元上进行的计算都应该在圆柱坐标而不是笛卡尔坐标中进行。我们可以通过创建一个CylindricalManifold对象并将其与上面的单元格相关联来做到这一点 [2.x.87] 。这样一来，当我们细化上面的单元格时，我们将沿着同心圆而不是直线来放置新的点。
* 在交易二中，我们用继承自Manifold的类来描述所有的几何体。默认的几何形状是笛卡尔式的，在FlatManifold类中实现。顾名思义，Manifold及其继承类提供了一种用微分几何的思想和术语来描述曲线和曲线单元的方法：例如，CylindricalManifold继承自ChartManifold，后者通过后拉和前推来描述一个几何体。一般来说，我们应该认为Triangulation类描述了一个域的拓扑结构（当然，除了存储顶点的位置之外），而Manifold类描述了一个域的几何结构（例如，一对顶点是否位于圆弧或直线上）。Triangulation将通过对与该单元相关的Manifold进行计算来细化单元，而不管该单元是否在边界上。换句话说：Manifold类不需要任何关于三角函数的边界在哪里的信息：由三角函数来查询正确的Manifold来计算一个单元。大多数Manifold函数（例如，[2.x.88]）对域本身一无所知，只是假设给它的点是沿着测度线的。在这种情况下，对于下面构建的圆柱形模子，节点线是沿着以[2.x.89]轴为中心的正交圆弧。
* 由于域的三个顶部部分都使用相同的测地线，我们将把中心在[2.x.91]线以上的所有单元标记为圆柱性质。
* [1.x.107]
*
* 通过这个代码，我们得到一个看起来像这样的网格。
* <img src="https://www.dealii.org/images/steps/developer/ [2.x.92] .yuhan.9.png" title="" width="400" height="355">
* 这一变化修复了边界，但产生了一个新的问题：与圆柱体轴线相邻的单元格被严重扭曲了。我们应该使用直角坐标对这些中心单元进行计算以避免这个问题。沿着中心线的单元格都有一个面接触到线[2.x.93]，因此，为了实现这一点，我们回头将这些单元格上的[2.x.94]s覆盖为零（这是默认的）。
* [1.x.108]
*
* 这给了我们以下的网格。
* <img src="https://www.dealii.org/images/steps/developer/ [2.x.95] .yuhan.10.png" alt="" width="400" height="355">。
* 这给了我们一个很好的网格，每个圆心的单元仍然是笛卡尔式的，而边界周围的单元是沿着圆的。如果我们再细化两次，我们就能真正看到边界拟合网格的良好细节。
* <img src="https://www.dealii.org/images/steps/developer/ [2.x.96] .yuhan.11.png" alt="" width="400" height="355">。
*

*[1.x.109][1.x.110]


*[1.x.111][1.x.112] 。


* 对本教程中描述的以某种形式生成的网格分配不同的边界ID，以应用不同的边界条件，通常是很有用的。
* 例如，你可能想为本程序中第一个网格的右边边界应用不同的边界条件。要做到这一点，需要遍历单元格和它们的面，并识别正确的面（例如，使用`cell->center()`查询单元格中心的坐标，如[2.x.97]，或者使用`cell->face(f)->get_boundary_id()`查询该单元格[2.x.98]的当前边界指示灯）。你可以使用`cell->face(f)->set_boundary_id()`来设置边界指标。你可以回顾一下[2.x.99]如何对网格进行迭代。
*[1.x.113][1.x.114]
*

* 在流形上的计算，就像在[2.x.100]中所做的那样，需要一个嵌入高维空间的曲面网格。虽然有些网格可以用GridGenerator命名空间来构建，或者从文件中加载，但有时从体积网格中提取一个表面网格也是很有用的。
* 使用函数[2.x.101]来提取网格的表面元素。在一个三维网格上使用该函数(一个`Triangulation<3,3>`，例如来自`grid_4()`)，这将返回一个`Triangulation<2,3>`，你可以在 [2.x.102] 中使用。  也可以尝试提取`Triangulation<2,2>`的边界网格。
*

* <!--
* 本教程可能的扩展。
*
* - 用于收敛研究的非结构化网格数据库
*
* - 如何删除或禁用网格内的一个单元
*
* - >
*

* [1.x.115][1.x.116][2.x.103]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-50_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27]
* [2.x.3]
* [1.x.28]
* [2.x.4]
* [2.x.5] 作为这个程序的先决条件，你需要同时安装p4est和PETScor Trilinos库。在[1.x.29]文件中描述了deal.II和这些附加库的安装情况。
*

*[1.x.30][1.x.31][1.x.32]


*
* 这个例子展示了deal.II中的多级函数在平行分布式网格上的应用，并给出了几何多栅和代数多栅方法的比较。考虑了两种几何多网格(GMG)的预处理方法：一种是类似于[2.x.7]中的基于矩阵的版本（但用于并行计算），另一种是[2.x.8]中讨论的无矩阵版本。我们的目标是找出哪种方法能够为大型并行计算提供最好的解算器。
* 本教程是基于 [2.x.9] 中的一个数值例子。请参阅该出版物，以了解交易.II中多网格实现的详细背景。我们将在下面的文字中总结一些结果。
* 代数多网格方法显然是最容易用deal.II实现的，因为诸如[2.x.10]和[2.x.11]这样的类本质上是黑布尔调节器，即使对于并行计算，也只需要几行就可以设置好。另一方面，几何多网格方法需要对整个代码库进行修改
*
* - 不是非常多，但必须知道自己在做什么。
* 本程序的结果将显示，代数和几何多网格方法的性能大致相当[1.x.33]，而无矩阵的几何多网格方法对于这里所考虑的问题来说要好得多。次要的结论是，当每个处理器的未知数小于20,000个时，基于矩阵的几何多网格方法确实不能很好地扩展。
*

*[1.x.34][1.x.35]


* 我们考虑变系数拉普拉斯的弱表述
* [1.x.36]
*在域[2.x.12]（二维为L形域，三维为Fichera角）上，如果[2.x.14]，则为[2.x.15]。换句话说，[2.x.16]是沿着域的边缘或面的小的，这些边缘或面跑到再入角，在下面的图中会看到。
* 边界条件在整个边界上是[2.x.17]，右手边是[2.x.18]。我们使用连续的[2.x.19]元素来表示离散的有限元空间[2.x.20]，并使用来自[2.x.22]的基于单元的后验误差估计器[2.x.21]。
* [1.x.37]
* 适应性地细化网格。(这是KellyErrorEstimator类中使用的Kellyerror估计器的一般化，KellyErrorEstimator类在大多数其他教程程序中驱动网格细化。)下图是2D的解决方案和细化的可视化： [2.x.23] 在3D中，解决方案看起来类似(见下文)。在左边你可以看到解决方案，在右边我们展示了靠近域中心的[2.x.24]的切片，显示了自适应细化的网格。[2.x.25]在二维和三维中，你都可以看到自适应细化拾取了角部奇点和粘度跳跃的内部奇点，而沿着分离两个粘度的线的界面（正确）没有被细化，因为它被充分解决了。
*

*[1.x.38][1.x.39]


* 如上所述，这个程序的目的是展示代数和几何多网格方法在这个问题上的应用，并且是在并行计算中的应用。使算法扩展到大型并行机器的一个重要组成部分是确保每个处理器都有相同的工作量要做。更确切地说，重要的是没有一小部分处理器比其他处理器有更多的工作，因为如果是这样的话，很大一部分处理器将闲置，等待一小部分处理器完成工作。相反，一小部分处理器拥有大量[1.x.40]的工作并不是一个问题，因为大多数处理器会继续生产，只有一小部分处理器在完成工作后会闲置。)
* 对于活跃的网格，我们使用[2.x.26]类，正如在[2.x.27]中所做的那样，它使用外部库[1.x.41]中的功能来分配活跃单元在处理器之间。对于多级层次结构中的非活动单元，deal.II实现了我们所说的 "第一子规则"，对于层次结构中的每个单元，我们递归地将一个单元的父级分配给第一个子单元的所有者。下面的图给出了这样一个分布的例子。左图表示使用空间填充曲线划分的二维网格样本的活动单元（这也是p4est用来划分单元的方法）；中图给出活动网格的树状表示；右图给出单元的多级层次。颜色和数字代表不同的处理器。树状图中的圆形节点是非活动单元，使用 "长子规则 "进行分配。
* [2.x.28]
* 在这个例子中，屏幕上的输出包括一个 "分区效率 "的数值，这个数值由[2.x.29]表示，用[2.x.30]来量化在多网格层次结构的每一层上没有完美工作平衡所产生的开销。这种不平衡在上面的例子中很明显：虽然[2.x.31]层在三个处理器的四个单元中尽可能的平衡，但粗略的[2.x.32]层只有一个处理器的工作，而[2.x.33]层只有两个处理器的工作，其中一个的工作是另一个的三倍。
* 对于定义[2.x.34]，需要注意的是，由于我们使用局部平滑来定义多网格层次（见[2.x.35]"多网格论文 "中对局部平滑的描述），一个单元的细化水平与该单元的多网格水平相对应。现在，让[2.x.36]为[2.x.37]层的单元数（包括活动和非活动单元），[2.x.38]为进程[2.x.39]所拥有的子集。我们还将用[2.x.40]表示处理器的总数。假设任何一个处理器的工作量与该处理器拥有的单元格数量成正比，每个处理器的最佳工作量为
* [1.x.42]
* 接下来，假设每一层的工作都是同步的（即在V型循环的每一层，在进入下一层之前，所有的处理器都必须完成工作），每一层的极限工作由以下公式给出
* [1.x.43]
*而总的并行复杂度
* [1.x.44]
* 然后我们将[2.x.41]定义为最佳分区与当前分区的并行复杂度的比率
* [1.x.45]
* 对于上面的例子分布，我们有
* [1.x.46]
*该值 [2.x.42] 1/mathbb{E}。[2.x.43] `mathbb{E}的价值[2.x.44] `mathbb{E}。\约1 [2.x.45] Mathematbb{E}。[2.x.46] 1/2.x.x.[2.x.47] 1/mathbb{E]。[2.x.48] W_\ell [2.x.49] W [2.x.50] r_0 = f-Au_0 [2.x.51] u_0 [2.x.52] u = u_0 + A^{-1}r_0 [2.x.53] u_0 [2.x.54] A^{-1}r_0 [2.x.55] u_0 [2.x.56] A [2.x.57] u_0 [2.x.58] f [2.x.59] u_0 [2.x.60] h^2 \| f + \epsilon \triangle u \|_K^2 [2.x.61] \sum_F h_F \| jump{\epsilon \nabla u \cdot n}.\|2.x.62] 矩阵{E}。[2.x.63] 0.371/0.161=2.3 [2.x.64] `mathbb{E}.[2.x.65] {cal O}(N\log N) [2.x.66] {cal O}(N) [2.x.67] 9\times 9 [2.x.68] 27\times 27 [2.x.69] L [2.x.70] 21\times 21 [2.x.71] 117\times 117$ in 3d.但是，如果粗网格由数百或数千个单元组成，这种方法将不再起作用，并可能开始主导每个V-cyle的整体运行时间。一个常见的方法是使用代数多网格预处理器解决粗网格问题；然而，这将需要组装粗矩阵（即使是无矩阵版本）作为AMG实现的输入。
*

*[1.x.134][1.x.135] [2.x.72]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-5_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16]
*[1.x.17][1.x.18][1.x.19] 。


* [2.x.2]
* 这个例子没有展示革命性的新东西，但它展示了比以前的例子更多的小改进，也有许多通常可以在有限元程序中找到的小东西。其中包括。[2.x.3] [2.x.4] 在连续细化的网格上进行计算。至少在数学科学中，在一个层次的网格上计算解是很常见的，以获得对解的精度的感觉；如果你在一个网格上只有一个解，你通常无法猜测解的精度。此外，deal.II被设计用来支持自适应算法，其中在连续细化的网格上的迭代求解是算法的核心。尽管在这个例子中没有使用自适应网格，但这里为它们奠定了基础。   [2.x.5] 在实际应用中，领域经常被自动网格生成器细分为三角形。为了使用它们，从文件中读取粗大的网格是很重要的。在这个例子中，我们将读取一个UCD（非结构化单元数据）格式的粗网格。当这个程序在2000年左右首次编写时，UCD格式是AVS资源管理器所使用的格式
*
*--这个程序在当时被合理地广泛使用，但现在已经不再重要了。(尽管如此，该文件格式仍然存在，并且仍然被一些程序所理解)。   [2.x.6] 有限元程序通常使用大量的计算时间，所以有时需要进行一些优化。我们将展示其中的一些。   [2.x.7] 另一方面，有限元程序往往是相当复杂的，所以调试是一个重要方面。我们通过使用断言来支持安全编程，断言在调试模式下检查参数和%内部状态的有效性，但在优化模式下被移除。( [2.x.8] [2.x.9] 关于数学方面，我们展示了如何支持椭圆算子的可变系数，以及如何对线性方程组使用预处理迭代求解器。[2.x.10]
* 这里要解决的方程如下。
* [1.x.20]
* 如果[2.x.11]是一个恒定系数，这将是简单的Poissone方程。但是，如果它确实是空间变量，那就是一个更复杂的方程（通常被称为 "扩展泊松方程"）。根据变量[2.x.12]指的是什么，它模拟了各种具有广泛适用性的情况。
*
* 如果[2.x.13]是电动势，那么[2.x.14]是介质中的电流，系数[2.x.15]是介质在任何给定点的导电性。在这种情况下，方程的右侧将是电源密度，通常为零或由局部的、类似德尔塔的函数组成）。
*
* - 如果[2.x.16]是薄膜的垂直挠度，那么[2.x.17]将是对局部刚度的测量。这就是让我们能够解释下面结果部分所显示的图像的解释。
* 由于拉普拉斯/泊松方程出现在如此多的背景下，除了上面列出的两种解释外，还有许多其他解释。
* 当组装这个方程的线性系统时，我们需要弱形式，这里的弱形式如下。
* [1.x.21]
* 在[2.x.18]函数中的实现是直接从这里开始的。
*

* [1.x.22] [1.x.23]。
* [1.x.24][1.x.25] 。


*
* 同样，前几个include文件已经知道了，所以我们不会对它们进行评论。
*


* [1.x.26]

* 这个是新的。我们想从磁盘上读取一个三角图，做这个的类在以下文件中声明。
*


* [1.x.27]
*
* 我们将使用一个圆形域，而描述其边界的对象来自这个文件。
*


* [1.x.28]
*
* 这是C++ ...
*


* [1.x.29]

* 最后，这在以前的教程程序中已经讨论过了。
*


* [1.x.30]
*
* [1.x.31] [1.x.32]。


*
* 主类主要和前面的例子一样。最明显的变化是删除了函数[2.x.19]，因为现在创建网格是在[2.x.20]函数中完成的，其余的功能都在[2.x.21]中。除此以外，一切都和以前一样。
*


* [1.x.33]
*
* [1.x.34] [1.x.35]。


*
* 在[2.x.22]中，我们展示了如何使用非恒定边界值和右手边。  在这个例子中，我们想在椭圆算子中使用一个可变系数来代替。由于我们有一个只取决于空间中的点的函数，我们可以做得更简单一点，使用一个普通的函数，而不是继承自Function。
*

*
* 这是对单点的系数函数的实现。我们让它在与原点的距离小于0.5的情况下返回20，否则返回1。
*


* [1.x.36]
*
* [1.x.37] [1.x.38]。



* [1.x.39] [1.x.40]。


*
* 这个函数和以前一样。
*


* [1.x.41]
*
* [1.x.42] [1.x.43]。


*
* 这是前面例子中的函数[2.x.23]，减去了生成网格的部分。其他的东西都没有变化。
*


* [1.x.44]
*
* [1.x.45] [1.x.46]。


*
* 和前面的例子一样，这个函数在功能上没有太大的变化，但是仍然有一些优化，我们将展示这些优化。对此，需要注意的是，如果使用高效的求解器（如预设条件的CG方法），组装矩阵和右手边会花费相当长的时间，你应该考虑在某些地方使用一到两个优化方法。
*

*
* 该函数的前几部分与之前完全没有变化。
*


* [1.x.47]
*
* 接下来是对所有单元的典型循环，计算局部贡献，然后将它们转移到全局矩阵和向量中。与[2.x.24]相比，这部分的唯一变化是我们将使用上面定义的[2.x.25]函数来计算每个正交点的系数值。
*


* [1.x.48]
*
* 有了这样建立的矩阵，我们再次使用零边界值。
*


* [1.x.49]
*
* [1.x.50] [1.x.51]。


*
*求解过程看起来又和前面的例子差不多。然而，我们现在将使用一个预设条件的共轭梯度算法。做出这种改变并不难。事实上，我们唯一需要改变的是，我们需要一个作为预处理程序的对象。我们将使用SSOR（对称连续过度放松），放松系数为1.2。为此，[2.x.26]类有一个函数可以做一个SSOR步骤，我们需要把这个函数的地址和它应该作用的矩阵（也就是要反转的矩阵）以及松弛因子打包成一个对象。[2.x.27]类为我们做到了这一点。([2.x.28]类需要一个模板参数，表示它应该处理的矩阵类型。默认值是[2.x.29]，这正是我们在这里需要的，所以我们只需坚持使用默认值，不在角括号中指定任何东西)。
*

*
* 请注意，对于目前的情况，SSOR的表现其实并不比其他大多数预处理程序好多少（尽管比没有预处理好）。在下一个教程程序[2.x.30]的结果部分对不同的预处理程序进行了简要的比较。
*

*
* 有了这个，剩下的函数就很简单了：我们现在使用我们声明的预设条件器，而不是之前创建的[2.x.31]对象，CG求解器将为我们完成剩下的工作。
*


* [1.x.52]
*
* [1.x.53] [1.x.54]。


*
* 将输出写入文件的方法与上一个教程中的方法基本相同。唯一不同的是，我们现在需要为每个细化周期构建一个不同的文件名。
*

*
* 该函数以VTU格式写入输出，这是VTK格式的一个变种，因为它压缩了数据，所以需要更少的磁盘空间。当然，如果你希望使用一个不懂VTK或VTU的可视化程序，DataOut类还支持许多其他格式。
*


* [1.x.55]
*
* [1.x.56] [1.x.57]。


*
* 这个程序中倒数第二件事是[2.x.32]函数的定义。与之前的程序不同，我们将在一个网格序列上进行计算，在每次迭代后都会进行全局细化。因此，该函数由6个周期的循环组成。在每个循环中，我们首先打印循环编号，然后决定如何处理网格。如果这不是第一个周期，我们就简单地对现有的网格进行一次全局精炼。然而，在运行这些循环之前，我们必须先生成一个网格。
*

*
* 在之前的例子中，我们已经使用了[2.x.33]类中的一些函数。这里我们想从一个存储有单元格的文件中读取网格，这个文件可能来自其他人，也可能是一个网格生成工具的产物。
*

*
* 为了从文件中读取网格，我们生成一个数据类型为GridIn的对象，并将三角测量与之相关联（也就是说，当我们要求它读取文件时，我们告诉它要填充我们的三角测量对象）。然后我们打开相应的文件，用文件中的数据初始化三角剖分。
*


* [1.x.58]

* 我们现在想读取该文件。但是，输入文件只针对二维三角测量，而这个函数是一个任意维度的模板。由于这只是一个演示程序，我们不会为不同的维度使用不同的输入文件，而是在不在二维的情况下迅速杀死整个程序。当然，由于下面的主函数假定我们是在二维空间工作，我们可以跳过这个检查，在这个版本的程序中，没有任何不良影响。   
* 事实证明，90%以上的编程错误是无效的函数参数，如无效的数组大小等，所以我们在整个deal.II中大量使用断言来捕捉这种错误。为此，[2.x.34]宏是一个很好的选择，因为它确保作为第一个参数的条件是有效的，如果不是，就抛出一个异常（它的第二个参数），通常会终止程序，并给出错误发生的位置和原因的信息。关于[2.x.35]宏的具体作用，可以在[2.x.36]"异常文档模块 "中找到更详细的讨论）。这通常会大大减少发现编程错误的时间，我们发现断言是快速编程的宝贵手段。   
* 另一方面，所有这些检查（目前库中有超过10,000个），如果你想做大型计算，应该不会使程序太慢。为此，[2.x.37]宏只在调试模式下使用，如果在优化模式下则扩展为零。因此，当你在小问题上测试你的程序并进行调试时，断言会告诉你问题出在哪里。一旦你的程序稳定了，你可以关闭调试，程序将在没有断言的情况下以最大速度运行你的实际计算。更准确地说：通过在优化模式下编译你的程序，关闭库中的所有检查（这些检查可以防止你用错误的参数调用函数，从数组中走出来，等等），通常可以使程序的运行速度提高四倍左右。即使优化后的程序性能更高，我们仍然建议在调试模式下开发，因为它允许库自动发现许多常见的编程错误。对于那些想尝试的人来说。从调试模式切换到优化模式的方法是用<code>make release</code>命令重新编译你的程序。现在[2.x.38]程序的输出应该向你表明，该程序现在是以优化模式编译的，以后也会被链接到已经为优化模式编译的库。为了切换回调试模式，只需用 [2.x.39] 命令重新编译。
*


* [1.x.59]
*
* ExcInternalError是一个全局定义的异常，每当有什么可怕的事情发生时，它就会被抛出。通常，人们希望使用更具体的异常，特别是在这种情况下，如果[2.x.40]不等于2，人们当然会尝试做其他事情，例如使用库函数创建一个网格。终止程序通常不是一个好主意，断言实际上只应该用于不应该发生的特殊情况，但由于程序员、用户或其他人的愚蠢而可能发生。上面的情况并不是对Assert的巧妙使用，但还是那句话：这是一个教程，也许值得展示什么是不应该做的，毕竟。
*

*
* 因此，如果我们通过了断言，我们就知道dim==2，现在我们可以真正地读取网格。它的格式是UCD（非结构化单元数据）（尽管惯例是使用UCD文件的后缀[2.x.41]）。
*


* [1.x.60]
*
* 如果你想使用其他的输入格式，你必须使用其他[2.x.42]函数之一。参见[2.x.43]类的文档以了解目前支持哪些输入格式）。
*

*
* 文件中的网格描述了一个圆。因此，我们必须使用一个流形对象，告诉三角计算在细化网格时将边界上的新点放在哪里。与[2.x.44]不同的是，由于GridIn不知道域有一个圆形的边界（与[2.x.45]不同，我们必须在创建三角剖分后明确地将流形附加到边界上，以便在细化网格时得到正确的结果。
*


* [1.x.61]
*
* 现在我们有了一个确定的网格，我们写一些输出，做所有我们在前面的例子中已经看到的事情。
*


* [1.x.62]
*
* [1.x.63] [1.x.64]。


*
* 主函数看起来和前面的例子中的函数差不多，所以我们不会对它作进一步评论。
*


* [1.x.65]
* [1.x.66][1.x.67] 。


*
* 以下是控制台的输出。
* [1.x.68]
*
*

*
*在每个周期中，单元格的数量翻了两番，CGiterations的数量大约翻了一番。另外，在每个周期中，程序以VTU格式写出一个输出图形文件。它们被描述为以下内容。
* [2.x.46]


*
* 由于系数的变化（曲率的减少与系数的增加是相同的），溶液的顶部区域被压扁了。溶液的梯度沿着界面是不连续的，尽管在上面的图片中并没有很清楚地看到这一点。我们将在下一个例子中更详细地研究这个问题。
* 图片还显示，在非常粗的网格上，这个程序计算出的解实际上是非常错误的（其幅度是错误的）。这是因为没有一种数值方法能够保证在粗大的网格上的解是特别准确的。
*
* - 但我们知道解[1.x.69]是精确的解，事实上你可以看到从一个网格到下一个网格的解似乎在最后不再有太大的变化。
*

* [1.x.70][1.x.71] [2.x.47] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-51_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] , [2.x.3] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38]
* [2.x.4]
* [1.x.39]
* [1.x.40][1.x.41][1.x.42] 。


* 本教程程序介绍了对流-扩散方程的混合非连续Galkerin方法的实现。
* [1.x.43][1.x.44] 。
*

* 反对使用不连续Galerkin元素的一个常见的理由是，在隐式系统中必须解决大量的全局耦合自由度。  这是因为，与连续有限元不同，在典型的非连续元中，每个顶点都有一个自由度[1.x.45]，而不是只有一个，同样，边和面也有。  作为未知数增长速度的一个例子，考虑FE_DGPMonomial基础：每个标度解分量都由度数为[2.x.5]的多项式表示，每个元素有[2.x.6]个自由度。通常，一个元素的所有自由度都与相邻元素的所有自由度相耦合。  由此产生的离散方程很快就会产生非常大的线性系统，特别是对于2或3维的方程系统。
*[1.x.46][1.x.47]
* 为了减轻解决这些大型线性系统的计算成本，Cockburn和同事们提出了可混合的非连续Galerkin（HDG）方法（见Nguyen和Peraire最近发表的HDG概述文章中的参考文献[2.x.7]）。
* HDG方法通过使用Dirichlet-to-Neumann映射制定数学问题来实现这一目标。  偏微分方程首先被写成一阶系统，然后通过DG方法将每个场离散化。  在这一点上，网格骨架上的单值 "跟踪 "值，即元素面，被视为独立的未知量。这在离散表述中产生的未知量分为两类。
*
* - 面未知数，只与面的两侧的单元未知数耦合。
*
* - 单元未知数，只与定义在同一单元内的单元和面的未知数耦合。最重要的是，一个单元的内部自由度不会与另一个单元的任何内部自由度相耦合。
* Dirichlet-to-Neumann地图的概念允许以下求解过程。[2.x.8] [2.x.9] 使用局部元素内部数据来强制执行三角结构的诺依曼条件。  然后，全局问题是求解轨迹值，这是唯一全局耦合的未知数。   [2.x.10] 使用已知的骨架值作为Dirichlet数据来求解局部元素级的解决方案。  这被称为 "局部求解器"，是一个[1.x.48]逐个元素的求解过程。[2.x.11]
*[1.x.49][1.x.50]
* 上述程序也有一个线性代数的解释--被称为[1.x.51]--被Guyan在连续有限元[2.x.12]和Fraeijs de Veubeke在混合方法[2.x.13]的背景下利用来减少全球线性系统的大小。在后一种情况下（混合公式），系统的减少是通过使用不连续的通量与引入额外的辅助变量[1.x.52]来实现的，该变量近似于每个元素边界上的未知数的轨迹。这个过程被称为混合化，并通过类比，是Cockburn、Gopalakrishnan和Lazarov在2009年引入的局部不连续Galerkin方法[2.x.14]的原因，随后他们的合作者又开发了这种方法，最终被称为[1.x.53]（HDG）方法。
* 让我们把与HDG问题相关的完整线性系统写成一个块状系统，离散DG（单元内部）变量[2.x.15]为第一块，骨架（面）变量[2.x.16]为第二块：[1.x.54] 。
* 我们现在的目标是用类似于[2.x.18]的Schur补足法来消除[2.x.17]块，这将导致以下两个步骤：[1.x.55] 。
* 重点是[2.x.19]的存在不是问题，因为[2.x.20]是一个块对角线矩阵，每个块对应一个单元，因此很容易反转。与其他单元的耦合是由骨架变量上的矩阵[2.x.21]和[2.x.22]引入。[2.x.23]的块对角性以及[2.x.24]和[2.x.25]的结构使我们能够逐元反转矩阵[2.x.26]（迪里希勒问题的局部解）并从[2.x.28]中减去[2.x.27]。因此，Dirichlet-to-Neumannmap概念的步骤对应于[2.x.29] [2.x.30]构建Schur互补矩阵[2.x.31]和右手边[2.x.32] [1.x.56]并以通常的方式将贡献插入全局跟踪矩阵，[2.x.33]求解舒尔互补系统[2.x.34]，[2.x.35]使用第二个方程求解[2.x.36]，给出[2.x.37] 。[2.x.38]
*

*[1.x.57][1.x.58]
* 对传统DG方法的另一个批评是，近似通量的收敛是次优的。  局部HDG解决方案可以被证明是收敛的[2.x.39]，即以最优顺序收敛。  此外，超级收敛特性可以用来对新的近似解进行后处理，以[2.x.40]的速率收敛。
*

*[1.x.59][1.x.60]


* 可混合的非连续Galerkin方法只是解决非连续Galerkin方法问题的一种方法。另一个想法是所谓的 "弱Galerkin "方法。它在[2.x.41]中进行了探讨。
*

*[1.x.61][1.x.62]


* 本例使用的HDG公式取自[2.x.42][1.x.63][1.x.64][1.x.65] 。
* 我们考虑域[2.x.43]上的对流-扩散方程，其边界为Dirichlet边界[2.x.44]和Neumann边界[2.x.45] : [1.x.66]
*
* 引入辅助变量[2.x.46]，将上述方程改写为一阶系统：[1.x.67] 。
*
* 我们将这些方程乘以权重函数[2.x.47]，并对每个元素[2.x.48]进行部分积分，得到：[1.x.68] 。
*
* 带帽子的条款表示数值轨迹（通常也被称为数值通量）。  它们是对元素边界上的内部值的近似。  为了确保守恒，这些项必须是任何给定元素边缘的单值[2.x.49]，尽管对于不连续的形状函数，当然可能有来自界面附近单元的多个值。我们通过使用以下形式的迹线消除数值迹线[2.x.50]：[1.x.69]
*
* 变量[2.x.51]是作为一个额外的独立变量引入的，是我们最终建立一个全局耦合线性系统的变量。如上所述，它被定义在元素面上，并且在面与面的交汇处（2D中的顶点，3D中的边和顶点），从一个面到另一个面是不连续的。
* 局部稳定参数[2.x.55]对HDG解的稳定性和准确性有影响；进一步的讨论见文献。据报道，稳定参数为1是给出最佳结果的选择。趋向于无穷大的稳定参数[2.x.56]禁止在元素边界上的解决方案的跳跃，使HDG解决方案接近于连续有限元素的近似值。在下面的程序中，我们选择稳定参数为[1.x.70] 。
* 我们将扩散[2.x.57]和扩散长度尺度设置为[2.x.58] 。
* HDG方法中的轨迹/骨架变量在元素面上是单值的。  因此，它们必须强有力地代表[2.x.59]上的迪里希特数据。  这意味着[1.x.71]。
* 其中等号实际上是指边界函数[2.x.61]对面变量空间的[2.x.60]投影（例如面的线性函数）。然后，这个约束被应用于骨架变量[2.x.62]，使用非均质约束的方法[2.x.63]。
* 将三角结构中所有元素的分量相加，强制执行数值通量的法向分量，并对由[2.x.64]加权的方程进行部分积分，我们得出问题的最终形式：找到[2.x.65]，以便
* [1.x.72]

* 未知数[2.x.66]被称为局部变量；它们被表示为标准DG变量。  未知数[2.x.67]是骨架变量，在网格的一维表面（面）上有支持。
* 我们用[2.x.68]表示所有单元的积分之和，[2.x.69]表示所有单元的所有面的积分，也就是说，内部面被访问两次，每边一次，并有相应的法向量。当结合共享一个面的两个元素的贡献时，上述方程产生了DG方法中熟悉的条款，在单元格边界上有跳跃的解。
* 在上述方程中，标量变量[2.x.70]的空间[2.x.71]被定义为在每个单元上为张量多项式[2.x.72]且在单元边界上不连续的函数空间[2.x.73]，即由[2.x.74]描述的空间。梯度或通量变量的空间[2.x.75]是一个矢量元素空间，其中每个分量都是局部多项式且不连续 [2.x.76] 。在下面的代码中，我们将这两个局部部分收集在一个FES系统中，其中第一个[2.x.77]二维分量表示梯度部分，最后一个标量分量对应于标量变量。对于骨架分量[2.x.78]，我们定义了一个由不连续的张量积多项式组成的空间，该空间活在元素面上，在deal.II中由FE_FaceQ类实现。这个空间在其他方面与FE_DGQ相似，即解函数在两个相邻的面之间不连续，也可参见下面的结果部分来说明。
* 在上面给出的弱形式中，我们可以注意到以下的耦合模式。[2.x.79] [2.x.80] 矩阵[2.x.81] 由局部-局部耦合项组成。  当局部加权函数[2.x.82]与局部求解项[2.x.83]相乘时就会产生这些耦合项。因为这些元素是不连续的，所以[2.x.84]是块对角线的。   [2.x.85] 矩阵[2.x.86]代表局部面的耦合。  这些是具有加权函数[2.x.87]的条款，乘以骨架变量[2.x.88] 。   [2.x.89] 矩阵[2.x.90]代表面-局域耦合，它涉及加权函数[2.x.91]乘以局域解[2.x.92] 。   [2.x.93] 矩阵[2.x.94]是面-面耦合；条款涉及[2.x.95]和[2.x.96] 。[2.x.97]
* [1.x.73][1.x.74] 。


* HDG方法的一个特点是，它们通常允许构建一个丰富的解决方案，以提高精度。这种后处理方法以逐个元素的方式获取HDG解决方案，并将其结合起来，从而在使用度数为[2.x.99]的多项式时可以获得[2.x.98]的精度。要做到这一点，有两个必要因素。[2.x.100] [2.x.101] 计算的解决方案梯度[2.x.102] 以最佳速度收敛，即[2.x.103] 。   [2.x.104] 解的标量部分的单元平均，[2.x.105] ，以[2.x.106]的速度超级收敛。[2.x.107]
* 现在我们引入一个新的变量[2.x.108]，通过在约束条件[2.x.111]下最小化单元[2.x.109]的表达式来找到它。这个约束是必要的，因为最小化函数并不能确定[2.x.112]的常数部分。这就转化为以下方程组：[1.x.75] 。
*
* 由于我们在第二组方程中用张量多项式空间中的整套基函数来测试[2.x.113]，这是一个过度确定的系统，方程比未知数多一个。我们在下面的代码中通过省略其中的一个方程来解决这个问题（因为拉普拉斯的行在代表一个常数函数时是线性依赖的）。正如我们将在下面看到的，这种形式的后处理给出了所希望的超级收敛结果，其比率为[2.x.114]。  应该注意的是，在构建[2.x.115]时有一些自由度，这种从梯度中提取信息的最小化方法并不是唯一的方法。特别是，这里定义的后处理方案在任何意义上都不满足对流-扩散方程。作为替代方案，上面引用的Nguyen, Peraire和Cockburn的论文提出了另一个更复杂的对流-扩散公式，该公式也可以将通量变量后处理为[2.x.116]-符合的变体，并在扩散较小时更好地代表局部对流-扩散算子。我们把更复杂的后处理的实现作为一个可能的扩展留给感兴趣的读者。
* 请注意，对于矢量值问题，后处理的工作原理是类似的。我们只需为每个向量分量的平均值分别设置约束，并使用梯度作为主要信息来源。
*[1.x.76][1.x.77]
*

* 在这个教程中，我们考虑了与[2.x.117]中几乎相同的测试案例。计算域是[2.x.118]，确切的解决方案对应于[2.x.119]中的解决方案，除了一个缩放比例。我们使用以下源中心[2.x.120]的指数[2.x.121] [2.x.122] 一维：[2.x.123] , [2.x.124] 二维：[2.x.125] , [2.x.126] 三维：[2.x.127] 。[2.x.128]
* 有了精确的解决方案，我们就可以选择右手边的强制力和诺伊曼边界条件，这样就可以得到这个解决方案（制造的解决方案技术）。在这个例子中，我们选择扩散等于1，对流为[1.x.78]注意，对流是无发散的，[2.x.129] 。
*[1.x.79][1.x.80] 。
*

* 除了实现上述方程，下面的实现还提供了以下功能。[2.x.130] [2.x.131] WorkStream使本地求解器并行化。工作流已在 [2.x.132] 中详细介绍。   [2.x.133] 从跟踪中重构本地DG解。   [2.x.134] 对解进行后处理以实现超融合。   [2.x.135] 用于直接输出全局骨架解的DataOutFaces。[2.x.136]
*

* [1.x.81] [1.x.82]。
* [1.x.83] [1.x.84]。


*
* 大多数deal.II的include文件在以前的例子中已经涉及到了，没有注释。
*


* [1.x.85]
*
* 然而，我们确实为这个例子准备了一些新的包括。第一个定义了三角形面上的有限元空间，我们称其为 "骨架"。这些有限元在元素内部没有任何支持，它们表示在每个模数一的表面上有一个单一的值的多项式，但在模数二的表面上承认不连续。
*


* [1.x.86]
*
* 我们包括的第二个新文件定义了一种新的稀疏矩阵类型。  常规的[2.x.137]类型存储了所有非零条目的索引。  [2.x.138]则利用了DG解的耦合性质。  它存储了一个指定大小的矩阵子块的索引。  在HDG背景下，这个子块大小实际上是由骨架解字段定义的每个面的自由度数量。这使得矩阵的内存消耗减少了三分之一，并且在求解器中使用矩阵时也会有类似的速度提升。
*


* [1.x.87]
*
* 这个例子的最后一个新内容是关于数据输出的。  由于我们在网格的骨架上定义了一个有限元场，所以我们希望能将这个解决方案的实际情况可视化。DataOutFaces正是这样做的，它的界面与我们熟悉的DataOut几乎一样，但输出的数据只有模拟的二维1数据。
*


* [1.x.88]
*
* 我们首先把所有的类放到自己的命名空间中。
*


* [1.x.89]
*
* [1.x.90] [1.x.91].
* 分析解的结构与 [2.x.139] 中的结构相同。有两个例外。首先，我们也为三维情况创建了一个解决方案，其次，我们对解决方案进行了缩放，因此对于解决方案宽度的所有值，其规范都是统一的。
*


* [1.x.92]
*
* 这个类实现了一个函数，标量解和它的负梯度被收集在一起。这个函数在计算HDG近似的误差时使用，它的实现是简单地调用Solution类的值和梯度函数。
*


* [1.x.93]
*
* 接下来是对流速度的实现。如介绍中所述，我们选择的速度场在二维是[2.x.140]，在三维是[2.x.141]。这就给出了一个无发散的速度场。
*


* [1.x.94]
*
* 我们实现的最后一个函数是制造解的右手边。它与[2.x.142]非常相似，不同的是我们现在有一个对流项而不是反应项。由于速度场是不可压缩的，即[2.x.143]，对流项简单读作[2.x.144] 。
*


* [1.x.95]
*
* [1.x.96] [1.x.97]。



* HDG的求解过程与 [2.x.145] 的求解过程非常相似。主要区别在于使用了三套不同的DoFHandler和FE对象，以及ChunkSparseMatrix和相应的求解向量。我们还使用WorkStream来实现多线程的局部求解过程，利用局部求解器令人尴尬的并行性质。对于WorkStream，我们定义了对单元格的本地操作和复制到全局矩阵和向量的函数。我们这样做既是为了装配（装配要运行两次，一次是在我们生成系统矩阵时，另一次是在我们从骨架值计算元素内部解时），也是为了后处理，在后处理中我们提取一个在高阶收敛的解。
*


* [1.x.98]
*
*用于组装和解决原始变量的数据。
*


* [1.x.99]
*
* 对解决方案进行后处理以获得[2.x.146]是一个逐个元素的过程；因此，我们不需要集合任何全局数据，也不需要声明任何 "任务数据 "供WorkStream使用。
*


* [1.x.100]
*
* 以下三个函数被WorkStream用来做程序的实际工作。
*


* [1.x.101]
*
* "局部 "解是每个元素的内部。  这些代表原始解场 [2.x.147] 以及辅助场 [2.x.148] 。
*


* [1.x.102]
*
* 新的有限元类型和相应的[2.x.149]被用于耦合元素级局部解的全局骨架解。
*


* [1.x.103]
*
* 如介绍中所述，HDG解可以通过后处理达到[2.x.150]的超级收敛率。  后处理的解是一个不连续的有限元解，代表每个单元内部的原始变量。  我们定义了一个程度为[2.x.151]的FE类型来表示这个后处理的解，我们只在构造后用于输出。
*


* [1.x.104]
*
* 与骨架相对应的自由度强烈地执行Dirichlet边界条件，就像在连续Galerkin有限元方法中一样。我们可以通过AffineConstraints对象以类似的方式强制执行边界条件。此外，悬挂节点的处理方式与连续有限元的处理方式相同。对于只在面定义自由度的面元素，这个过程将精炼面的解设置为与粗略面的表示相吻合。     
* 请注意，对于HDG来说，消除悬空节点并不是唯一的可能性&mdash；就HDG理论而言，我们也可以使用精炼侧的未知数，并通过精炼侧的跟踪值表达粗略侧的局部解。然而，这样的设置在deal.II环路方面不容易实现，没有进一步分析。
*


* [1.x.105]
*
* ChunkSparseMatrix类的用法与通常的稀疏矩阵类似。你需要一个ChunkSparsityPattern类型的稀疏模式和实际的矩阵对象。在创建稀疏模式时，我们只需要额外传递局部块的大小。
*


* [1.x.106]
*
* 与 [2.x.152] 相同。
*


* [1.x.107]
*
* [1.x.108] [1.x.109]。


*
* [1.x.110] [1.x.111] 构造函数与其他例子中的构造函数类似，除了处理多个DoFHandler和FiniteElement对象。请注意，我们为局部DG部分创建了一个有限元系统，包括梯度/通量部分和标量部分。
*


* [1.x.112]
*
* [1.x.113] [1.x.114] HDG解决方案的系统是以类似于其他大多数教程程序的方式设置的。  我们小心翼翼地用我们所有的DoFHandler对象来分配道夫。  [2.x.153]和[2.x.154]对象与全局骨架解决方案一起。
*


* [1.x.115]
*
* 在创建块状稀疏模式时，我们首先创建通常的动态稀疏模式，然后设置块状大小，这等于一个面的道夫数，当把它复制到最终的稀疏模式时。
*


* [1.x.116]
*
* [1.x.117] [1.x.118] 接下来是定义并行装配的本地数据结构。第一个结构[2.x.155]包含了被写入全局矩阵的本地向量和矩阵，而ScratchData包含了我们在本地装配中需要的所有数据。这里有一个变量值得注意，即布尔变量[2.x.156] trace_reconstruct。正如介绍中提到的，我们分两步解决HDG系统。首先，我们为骨架系统创建一个线性系统，通过舒尔补码[2.x.157] 将局部部分浓缩到其中。然后，我们用骨架的解来解决局部部分。对于这两个步骤，我们需要两次元素上的相同矩阵，我们希望通过两个装配步骤来计算。由于大部分的代码是相似的，我们用相同的函数来做这件事，但只是根据我们在开始装配时设置的一个标志在两者之间切换。由于我们需要将这一信息传递给本地工作程序，所以我们在任务数据中存储一次。
*


* [1.x.119]
*
* [1.x.120] [1.x.121] [2.x.158] 包含WorkStream中每个线程的持久化数据。  FEValues、矩阵和矢量对象现在应该很熟悉了。  有两个对象需要讨论。  [2.x.159] int> > fe_local_support_on_face` 和 [2.x.160] int> > fe_support_on_face`。  这些用于指示所选择的有限元是否对与[2.x.161]相关的局部部分和骨架部分[2.x.162]的参考单元的特定面有支持（非零值）。 我们在构造函数中提取这一信息，并对我们工作的所有单元存储一次。  如果我们不存储这一信息，我们将被迫在每个单元上装配大量的零项，这将大大降低程序的速度。
*


* [1.x.122]
*
* [1.x.123] [1.x.124] [2.x.163] 包含WorkStream在后期处理本地解决方案时使用的数据 [2.x.164] 。  它与 [2.x.165] 类似，但要简单得多。
*


* [1.x.125]
*
* [1.x.126] [1.x.127] [2.x.166]函数与[2.x.167]上的函数类似，其中正交公式和更新标志被设置，然后[2.x.168]被用来以多线程的方式进行工作。  [2.x.169]的输入参数用来决定我们是求全局骨架解（假）还是局部解（真）。   
* 对于汇编的多线程执行，有一点值得注意的是，`assemble_system_one_cell()`中的局部计算会调用BLAS和LAPACK函数，如果这些函数在deal.II中可用。因此，底层的BLAS/LAPACK库必须支持同时来自多个线程的调用。大多数实现都支持这一点，但有些库需要以特定方式构建以避免问题。例如，在BLAS/LAPACK调用内部没有多线程的情况下编译的OpenBLAS需要在构建时将一个名为`USE_LOCKING'的标志设置为true。
*


* [1.x.128]
*
* [1.x.129] [1.x.130] HDG程序的真正工作是由 [2.x.170] 组装局部矩阵 [2.x.171] 在这里完成，同时还有全局矩阵的局部贡献 [2.x.172] 。
*


* [1.x.131]
*
* 为FEValues的dof_handler_local构建迭代器，重新启动函数。
*


* [1.x.132]
*
* 我们首先计算对应于局部-局部耦合的[2.x.173]矩阵（在介绍中称为矩阵[2.x.174]）的单元内部贡献，以及局部右侧矢量。  我们在每个正交点存储基函数、右手边值和对流速度的值，以便快速访问这些场。
*


* [1.x.133]
*
* 面条款是在所有元素的所有面上装配的。这与更传统的DG方法相反，在组装过程中，每个面只被访问一次。
*


* [1.x.134]
*
* 在求解局部变量时需要已经得到的[2.x.175]值。
*


* [1.x.135]
*
* 这里我们计算介绍中讨论的稳定参数：由于扩散是1，并且扩散长度尺度被设定为1/5，它只是导致扩散部分的贡献为5，而通过元素边界的对流的大小为中心方案的对流部分。
*


* [1.x.136]
*
* 我们存储非零流量和标量值，利用我们在[2.x.176]中创建的support_on_face信息。
*


* [1.x.137]
*
* 当[2.x.177]我们准备为骨架变量[2.x.178]组装系统。如果是这种情况，我们必须组装所有与问题相关的局部矩阵：局部-局部、局部-面部、面部-局部和面部-面部。  面-面矩阵被存储为[2.x.179]，这样就可以通过[2.x.180]copy_local_to_global将其组装到全局系统中。
*


* [1.x.138]
*
* 注意face_no-local矩阵的符号。  我们在组装时否定了这个符号，这样我们就可以在计算舒尔补数时使用[2.x.181]的加法。
*


* [1.x.139]
*
* 这最后一项是将[2.x.182]项的贡献加入到本地矩阵中。相对于上面的面矩阵，我们在两个装配阶段都需要它。
*


* [1.x.140]
*
* 当[2.x.183]我们在逐个元素的基础上求解局部解。  局部右手边的计算是通过用计算值[2.x.186]trace_values替换[2.x.184]计算中的基函数[2.x.185]tr_phi。  当然，现在矩阵的符号是减号，因为我们已经把所有的东西移到了方程的另一边。
*


* [1.x.141]

* 一旦完成了所有局部贡献的组装，我们必须：(1)组装全局系统，或者(2)计算局部解的数值并保存。(1)组装全局系统，或者(2)计算局部解值并保存。无论哪种情况，第一步都是对局部-局部矩阵进行反转。
*


* [1.x.142]
*
* 对于(1)，我们计算舒尔补码，并将其添加到[2.x.187]cell_matrix，矩阵[2.x.188]的介绍中。
*


* [1.x.143]
*
* 对于(2)，我们只需解决(ll_matrix).(solution_local)=(l_rhs)。因此，我们用[2.x.189]乘以我们已经倒置的局部-局部矩阵，并用[2.x.190]函数来存储结果。
*


* [1.x.144]
*
* [1.x.145] [1.x.146] 如果我们处于解的第一步，即[2.x.191]，那么我们把局部矩阵组合到全局系统中。
*


* [1.x.147]
*
* [1.x.148] [1.x.149] 骨架解是通过使用带有身份预处理程序的BiCGStab求解器来解决的。
*


* [1.x.150]
*
* 一旦我们求出了骨架解，我们就可以以逐个元素的方式求出局部解。  我们通过重新使用相同的[2.x.192]函数来做到这一点，但将[2.x.193]切换为真。
*


* [1.x.151]
*
* [1.x.152] [1.x.153]。


*
* 后处理方法有两个目的。首先，我们要在度数为[2.x.194]的元素空间中构造一个后处理的标量变量，我们希望它能在阶[2.x.195]上收敛。这又是一个逐个元素的过程，只涉及标量解以及局部单元上的梯度。为了做到这一点，我们引入了已经定义好的从头开始的数据以及一些更新标志，并运行工作流来并行地完成这一工作。   
* 其次，我们要计算离散化误差，就像我们在 [2.x.196] 中所做的那样。整体程序与调用[2.x.197]相似，区别在于我们如何计算标量变量和梯度变量的误差。在[2.x.198]中，我们通过计算[2.x.199]或[2.x.200]的贡献来做到这一点。在这里，我们有一个DoFHandler，计算了这两个贡献，并按其矢量分量排序，[2.x.201]为梯度，[2.x.202]为标量。为了计算它们的值，我们用一个ComponentSelectFunction来计算它们中的任何一个，再加上上面介绍的[2.x.203]SolutionAndGradient类，它包含了它们中任何一个的分析部分。最终，我们还计算了后处理的解决方案的L2-误差，并将结果添加到收敛表中。
*


* [1.x.154]

* [1.x.155] [1.x.156]
* 这是为后处理所做的实际工作。根据介绍中的讨论，我们需要设置一个系统，将DG解的梯度部分投影到后处理变量的梯度上。此外，我们还需要将新的后处理变量的平均数设置为等于单元上标量DG解的平均数。   
* 从技术上讲，梯度的投影是一个有可能填满我们的[2.x.204]乘以[2.x.205]矩阵的系统，但它是单数（所有行之和为零，因为常数函数的梯度为零）。因此，我们拿掉一行，用它来强加标量值的平均值。我们为标量部分挑选第一行，尽管我们可以为[2.x.206]元素挑选任何一行。然而，如果我们使用FE_DGP元素，第一行将对应常数部分，删除例如最后一行将得到一个奇异系统。这样一来，我们的程序也可以用于这些元素。
*


* [1.x.157]
*
* 在集合了所有的项之后，我们又可以继续解决这个线性系统。我们对矩阵进行反转，然后将反转结果乘以右手边。另一种方法（在数值上更稳定）是只对矩阵进行因式分解，然后应用因式分解。
*


* [1.x.158]
*
* [1.x.159] [1.x.160] 我们有三组我们想要输出的结果：局部解，后处理的局部解，以及骨架解。前两个结果都 "活 "在元素体积上，而后者则活在三角形的一维表面上。  我们的[2.x.207]函数将所有的局部解决方案写入同一个vtk文件，尽管它们对应于不同的DoFHandler对象。  骨架变量的图形输出是通过使用DataOutFaces类完成的。
*


* [1.x.161]
*
* 我们首先定义本地解决方案的名称和类型，并将数据添加到[2.x.208]。
*


* [1.x.162]
*
* 我们添加的第二个数据项是后处理的解决方案。在这种情况下，它是一个属于不同DoFHandler的单一标量变量。
*


* [1.x.163]
*
* [2.x.209]类的工作原理类似于[2.x.210]，它定义了三角形骨架上的解决方案。  我们在此将其视为如此，其代码与上面的类似。
*


* [1.x.164]
*
* [1.x.165] [1.x.166]。


*
* 我们为HDG实现了两种不同的细化情况，就像在[2.x.211]中一样：adaptive_refinement 和 global_refinement。  global_refinement选项每次都会重新创建整个三角结构。这是因为我们想使用比一个细化步骤更细的网格序列，即每个方向2、3、4、6、8、12、16、...个元素。
*

*
* adaptive_refinement模式使用[2.x.212]来对标量局部解中的非规则区域进行体面的指示。
*


* [1.x.167]
*
* 就像在[2.x.213]中一样，我们将两个面的边界指标设置为1，在这里我们要指定诺伊曼边界条件而不是迪里希特条件。由于我们每次在全局细化时都会重新创建三角形，所以在每个细化步骤中都会设置标志，而不仅仅是在开始时。
*


* [1.x.168]
*
* [1.x.169] [1.x.170] 这里的功能与[2.x.214] 基本相同。我们在10个周期中循环，在每个周期中细化网格。  在最后，收敛表被创建。
*


* [1.x.171]

* 与[2.x.215]相比，收敛表有一个微小的变化：由于我们没有在每个周期内以系数2来细化我们的网格（而是使用2, 3, 4, 6, 8, 12, ...的序列），我们需要告诉收敛率评估关于这一点。我们通过设置单元格数量作为参考列，并额外指定问题的维度来实现这一目的，这为单元格数量和网格大小之间的关系提供了必要的信息。
*


* [1.x.172]
*
* 现在是对主类的三次调用，完全类似于 [2.x.216] 。
*


* [1.x.173]
* [1.x.174][1.x.175] 。


*[1.x.176][1.x.177]


* 我们首先看一下程序在二维运行时产生的输出。在下面的四张图片中，我们展示了多项式程度[2.x.217]的解决方案和程序的第2、3、4和8周期。在这些图中，我们将内部数据（DG部分）和骨架部分（[2.x.218]）生成的数据叠加到同一图中。我们不得不生成两个不同的数据集，因为细胞和面孔代表了不同的几何实体，而这些实体的组合（在同一个文件中）在VTK输出的deal.II中是不支持的。
* 这些图像显示了HDG的明显特征：单元格的解（coloredsurfaces）在单元格之间是不连续的。骨架变量上的解决方案位于面孔上，并将局部部分联系在一起。骨架解在面与面之间的顶点上是不连续的，尽管它的值沿着同一坐标方向的线相当接近。骨架解可以被解释为两边之间的橡胶弹簧，它可以平衡解的跳跃（或者说，通量[2.x.219]）。从左上角的图片可以看出，大体解经常出现过冲和欠冲，而骨架变量确实是对精确解的一个更好的近似；这就解释了为什么我们可以通过后处理步骤得到一个更好的解。
* 随着网格的细化，单元之间的跳跃变得很小（我们代表一个平滑的解决方案），并且骨架解决方案接近内部部分。对于第8周期，两个变量没有明显的区别。我们还看到边界条件是如何被弱化的，内部变量并不完全满足边界条件。在下边界和左边界，我们设置了诺伊曼边界条件，而在右边界和上边界，我们设置了迪里切特条件。
* [2.x.220]
* 接下来，我们看一下后处理的解决方案，还是在周期2、3、4和8。这是一个不连续的解决方案，局部由二阶多项式描述。虽然在第二周期的网格上，解决方案看起来不是很好，但在第三和第四周期，它看起来要好得多。正如下面的收敛表所示，我们发现它也更快地收敛到了理论解。
* [2.x.221]
* 最后，我们看一下[2.x.222]在第二周期的解。尽管只有64个单元的粗网格，但后处理的解在质量上与第8周期4,096个单元的线性解（未进行后处理）相似。这清楚地表明了高阶方法在平滑解方面的优越性。
* [2.x.223]
*[1.x.178][1.x.179]
*

*当程序运行时，它还会输出有关各步骤的信息和收敛表，并在最后列出各部分的误差。在2D中，收敛表看起来如下。
* [1.x.180]
*
*

* 人们可以看到网格细化后的误差减少，对于进行了全局细化的情况，也可以看到收敛率。在[2.x.224]准则下，标量变量和梯度变量的Q1元素的二次收敛率很明显，在[2.x.225]准则下，后处理的标量变量的三次收敛率也很明显。请注意HDG解决方案的这一独特特征。在典型的连续有限元中，阶[2.x.226]的解的梯度只以[2.x.227]的速率收敛，而实际的解则是[2.x.228]。即使有限元的超级收敛结果也是可用的（例如Zienkiewicz和Zhu首次提出的超级收敛补丁恢复），但这些通常只限于结构化网格和其他特殊情况。对于Q3 HDG变量，标量变量和梯度在四阶收敛，后处理的标量变量在五阶收敛。
* 同样的收敛率在三维中也被观察到。
* [1.x.181]
*
* [1.x.182][1.x.183] 。
*

*[1.x.184][1.x.185]


*收敛表验证了介绍中所述的预期收敛率。现在，我们想展示一下HDG方法与通常的有限元（连续Galkerin）方法在本教程的问题上的计算效率的快速比较。当然，在实践中，HDG方法与连续有限元相比，在传输为主的问题上的稳定性也很重要，这是在光滑解析解的问题上所看不到的。在下面的图片中，我们比较了[2.x.229]的误差与自由度数的函数（左）和线性求解器花费的计算时间（右），连续有限元（CG）和本教程中介绍的混合非连续Galerkin方法的两个空间维度。相对于教程中我们只使用无条件的BiCGStab，下面的图中显示的时间使用了[2.x.230]中的Trilinos代数多网格预处理器 对于HDG部分，为了在最细的层次上利用矩阵中的块状结构，使用了跟踪变量的ChunkSparseMatrix包装器。
* [2.x.231]
* 图中的结果显示，HDG方法在[2.x.232]时比连续无限元慢，对立方体元素的速度差不多，对六阶元素则更快。然而，我们在上面看到，HDG方法实际上产生的解比原始变量所表示的更准确。因此，在下面两幅图中，我们转而显示HDG的后处理解的误差（例如用[2.x.233]表示）。现在我们看到，对于[2.x.234]和[2.x.235]来说，在相同的工作量下，HDG有明显的优势，对于[2.x.236]来说，质量也差不多。
* [2.x.237]
* 由于HDG方法实际上产生了如[2.x.238]那样的收敛结果，我们应该将其与具有相同渐进收敛行为的连续Galerkinsolution进行比较，即具有程度[2.x.239]的FE_Q。如果我们这样做，我们会得到下面的收敛曲线。我们看到带有二阶多项式的CG又明显优于带有线性的HDG。然而，HDG对高阶的优势依然存在。
* [2.x.240]
* 这些结果与一般DG方法的特性一致。最佳性能通常不是在线性元素上实现的，而是在稍高的阶数上实现的，通常在[2.x.241]左右。这是因为对于不连续的解来说，有太多的解住在表面上，因此当元素是线性的时候，就会出现浮点--表面效应。换句话说，尽管DG方法专注于不连续的（因此似乎是低精度的）解的表示，但在使用相对高阶的时候往往是最有效的。
* [1.x.186][1.x.187] 。
*

* 我们现在展示了同样的三维数字：第一行显示了自由度数和计算时间与标量变量[2.x.242]中[2.x.243]的误差在阶数[2.x.244]下的对比，第二行显示了后处理的HDG解决方案，而不是原始解决方案，第三行是后处理的HDG解决方案与阶数[2.x.245]下的CG对比。在三维中，体积-表面效应使得HDG的成本较高，对于任何尺度的线段，CG的解决方案显然比HDG更好。对于立方体，HDG和CG的质量相似，而对于六阶多项式，HDG又更有效率。我们也可以使用FE_DGP和FE_FaceP的组合来代替（FE_DGQ, FE_FaceQ），它们不使用[2.x.246]度的张量积多项式，而是使用[1.x.188]度的Legendre多项式[2.x.247]。在给定的网格尺寸下，FE_FaceP的骨架变量自由度较少，但解的质量（误差与自由度数量）与FE_FaceQ的结果非常相似。
* [2.x.248]
* 关于效率比较的最后一点说明。我们试图使用通用的解析矩阵结构和类似的求解器(两者的最佳AMG预处理器都没有对AMG参数进行特别的调整)，以便在一个玩具例子中对两种方法的成本与精度进行公平的描述。然而，应该注意的是，连续有限元的几何多网格（GMG）比[2.x.249]和[2.x.250]快4到5倍。截至2019年，研究界仍在开发HDG的最佳复杂度迭代求解器。此外，CG可用的其他实施方面，如[2.x.251]中所示的快速无矩阵方法，使高阶连续元素更具竞争力。同样，本教程的作者也不清楚是否可以对HDG做出类似的改进。我们参考[1.x.189]中的最新效率评估。
*

*[1.x.190][1.x.191]。


* 正如介绍中已经提到的，一种可能性是实施文献中讨论的另一种后处理技术。
* 第二项没有做得很好的是关于这个程序的性能，这当然是实际应用中的一个问题（也要权衡(H)DG方法对传输主导问题的更好的解决质量）。让我们看看这个教程程序的计算时间和各个部分的份额。
* [2.x.252]
* 从表中可以看出，解算器和汇编的调用在程序的运行时间中占主导地位。这也清楚地表明了哪里的改进是最有意义的。
* [2.x.253] [2.x.254] 更好的线性求解器。我们使用的是BiCGStab迭代求解器，没有预设条件，迭代次数随着问题大小的增加而增加（Q1元素和全局细化的迭代次数小的时候是35次，大的时候增加到701次）。为了做得更好，例如可以使用Trilinos的代数多网格预处理程序，或者像[1.x.192]中讨论的一些更高级的变体。对于以扩散为主的问题，比如我们手头的问题，只要我们不与MPI并行工作，就可以设计这样一个求解器，在最细的层次上使用更高效的ChunkSparseMatrix的矩阵-向量乘积。对于MPI并行化的计算，可以使用一个标准的[2.x.255]。
* [2.x.256] 通过预先组装不从一个单元改变到另一个单元的部分（那些既不包含可变系数也不包含映射依赖项的部分）来加速组装。[2.x.257]


* [1.x.193][1.x.194] [2.x.258] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-52_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25]
* [2.x.2]
* [1.x.26]
* [2.x.3] 为了运行这个程序，deal.II必须被配置为使用UMFPACK稀疏直接求解器。请参考[1.x.27]中关于如何做的说明。
* [1.x.28][1.x.29][1.x.30]
*

* 这个程序展示了如何使用Runge-Kutta方法来解决一个随时间变化的问题。它解决了在[2.x.4]中首先讨论的热方程的一个小变体，但由于这个程序的目的只是为了演示使用更高级的方法与deal.II的时间步进算法相连接，所以只解决了一个均匀细化网格上的简单问题。
*

*[1.x.31][1.x.32]


* 在这个例子中，我们求解中子输运方程的单组时间依赖性扩散近似值（关于时间依赖性多组扩散见[2.x.5]）。这是一个关于中子如何在高散射介质中移动的模型，因此它是时间依赖性扩散方程的一个变体。
*
* 我们假设介质是不允许的，因此，中子通量满足以下方程：[1.x.33]。
*由适当的边界条件增强。这里，[2.x.7]是中子的速度（为简单起见，我们假设它等于1，这可以通过简单地缩放时间变量来实现），[2.x.8]是扩散系数，[2.x.9]是吸收截面，[2.x.10]是一个源。因为我们只对时间依赖性感兴趣，我们假设[2.x.11]和[2.x.12]是恒定的。
* 由于本程序只打算演示如何使用先进的时隙算法，我们将只寻找相对简单的问题的解决方案。具体来说，我们要在一个正方形域[2.x.13]上寻找解，其形式为[1.x.34] 。
* 通过使用二次有限元，我们可以在任何特定的时间精确地表示这个函数，所有的误差都是由于时间微分造成的。我们这样做是因为这样就很容易观察到我们将要考虑的各种时间步进方案的收敛顺序，而不需要将空间和时间误差分开。
* 我们施加了以下边界条件：[2.x.14]和[2.x.15]的同质Dirichlet条件，[2.x.16]和[2.x.17]的同质Neumann条件。我们选择源项，以便相应的解实际上是上述形式：[1.x.35] 。
* 因为解是时间上的正弦，我们知道精确的解满足[2.x.18].因此，时间[2.x.19]的误差只是数值解的规范，即[2.x.20]，而且特别容易评估。在代码中，我们评估[2.x.21]的节点值的规范，而不是相关空间函数的[2.x.23]规范，因为前者更容易计算；然而，在均匀网格上，两者只是由一个常数相关，我们可以因此观察时间收敛顺序，要么。
*

*[1.x.36][1.x.37]


* 在deal.II中实现的Runge-Kutta方法假定要解决的方程可以写成：[1.x.38] 。
* 另一方面，当使用有限元时，离散化的时间导数总是导致左手边存在一个质量矩阵。考虑到如果上式中的解向量[2.x.24]实际上是一个形式[1.x.39]的变量的节点系数向量[2.x.25]，这一点就很容易看出。
*与空间形状函数[2.x.26]，然后将形式为[1.x.40]的方程乘以测试函数。
*用测试函数，对[2.x.27]进行积分，代入[2.x.28]并将测试函数限制在上面的[2.x.29]，那么这个空间离散化方程的形式为[1.x.41] 。
*其中[2.x.30]是质量矩阵，[2.x.31]是[2.x.32]的空间离散化版本（其中[2.x.33]通常是空间衍生物出现的地方，但鉴于我们只考虑时间衍生物，这一点目前还不太关心）。换句话说，如果我们写成[1.x.42]，这种形式符合上述的一般方案。
*
* Runk-Kutta方法是一种时间步进方案，通过特定的一步法对[2.x.34]进行近似。它们通常被写成[1.x.43]的形式。
* 其中对于上面的右手边的形式[1.x.44]。
* 这里[2.x.35]、[2.x.36]和[2.x.37]是已知的系数，用于识别你要使用的特定Runge-Kutta方案，[2.x.38]是使用的时间步长。Runge-Kutta类的不同时间步长方法在级数[2.x.39]和系数[2.x.40]、[2.x.41]和[2.x.42]上有所不同，但由于可以查找这些系数的列表值，所以很容易实现。这些表格通常被称为Butcher tableaus）。
* 在编写本教程时，deal.II中实现的方法可以分为三类。[2.x.43] [2.x.44] 显式Runge-Kutta；为了使一个方法成为显式，必须在上述定义[2.x.45]的公式中，[2.x.46]不出现在右手边上。换句话说，这些方法必须满足[2.x.47] 。[2.x.48] 嵌入式（或自适应）Runge-Kutta；我们将在下面讨论其特性。[2.x.49] 隐式Runge-Kutta；这类方法需要解决上述阶段[2.x.50]的可能非线性系统，即它们至少有[2.x.51]个阶段 [2.x.52] 。[2.x.53] 许多众所周知的时间步进方案，通常不与Runge或Kutta的名字联系在一起，事实上，它们也可以用这些类别来表达。它们通常代表了这些家族的最低阶成员。
*

*[1.x.45][1.x.46]


* 这些方法，只需要一个函数来评估[2.x.54]，但不需要（作为隐式方法）来解决涉及[2.x.55]的[2.x.56]的方程。与所有显式时间步长方法一样，当选择的时间步长过大时，它们会变得不稳定。
* 这类著名的方法包括正向欧拉、三阶Runge-Kutta和四阶Runge-Kutta（通常缩写为RK4）。
*

*[1.x.47][1.x.48] 。


* 这些方法同时使用低阶和高阶方法来估计误差，并决定是否需要缩短或增加时间步长。术语 "嵌入 "是指低阶方法不需要对函数进行额外的评估[2.x.57]，而是重复使用那些必须为高阶方法计算的数据。换句话说，它基本上是免费的，而我们得到的误差估计是使用高阶方法的副产品。
* 这类方法包括Heun-Euler、Bogacki-Shampine、Dormand-Prince（Matlab中的ode45，通常缩写为RK45，表示这里使用的低阶和高阶方法分别为4阶和5阶Runge-Kutta方法）、Fehlberg和Cash-Karp。
* 在撰写本文时，只有嵌入式显式方法得到了实现。
*

*[1.x.49][1.x.50]


* 隐式方法要求在每个（子）时间步长中解决[2.x.58]和[2.x.59]形式的（可能是非线性）系统。在内部，这是用牛顿式方法完成的，因此，它们要求用户提供能够评估[2.x.60]和[2.x.61]或等同于[2.x.62]的函数。
* 这个运算符的特殊形式是由于每个牛顿步骤都需要解决一个形式的方程。
* [1.x.51]
*对于某些（给定的）[2.x.63]。无论时间步长如何，隐式方法始终是稳定的，但过大的时间步长当然会影响解的[1.x.52]，即使数值解仍然是稳定和有界的。
* 这类方法包括后退欧拉法、隐式中点法、Crank-Nicolson法和两阶段SDIRK法（"单对角隐式Runge-Kutta "的简称，这个术语是用来表示定义时间步长方法的对角线元素[2.x.64]都是相等的；这个特性使得牛顿矩阵[2.x.65]可以在各阶段之间重复使用，因为[2.x.66]每次都相同）。
*

*[1.x.53][1.x.54]


*通过扩展我们的模型问题的解决方案，即始终使用形状函数[2.x.67]并写出[1.x.55]。
* 我们立即得到扩散方程的空间离散化版本，即[1.x.56] 。
* 其中[1.x.57]为
* 参见[2.x.68]和[2.x.69]以了解我们是如何到达这里的。由于当前问题所选择的边界条件，边界项是不必要的。为了使用Runge-Kutta方法，我们将其改写如下：[1.x.58] 。
* 在代码中，我们将需要能够评估这个函数[2.x.70]及其导数，[1.x.59] 。
*
*

*[1.x.60][1.x.61]


* 为了简化问题，域是二维的，网格是均匀细化的（不需要调整网格，因为我们使用的是二次无限元，而且精确解是二次的）。从二维域到三维域并不是很有挑战性的。然而，如果你打算解决更复杂的问题，其中网格必须进行调整（例如，在[2.x.71]中的做法），那么记住以下问题是很重要的。
* [2.x.72] [2.x.73] 当网格被改变时，你需要将解决方案投射到新的网格。当然，在每个时间步长中，所使用的网格应该是相同的，这个问题是由于Runge-Kutta方法在每个时间步长中对方程进行多次评估而产生的。[2.x.74] 每次改变网格时，你都需要更新质量矩阵和它的逆值。[2.x.75] 这些步骤的技术可以通过查看 [2.x.76] 随时获得。
*

* [1.x.62] [1.x.63]。
* [1.x.64] [1.x.65]。


*
* 像往常一样，第一个任务是包括这些著名的deal.II库文件和一些C++头文件的功能。
*


* [1.x.66]
*
* 这是唯一一个新的包含文件：它包括所有的Runge-Kutta方法。
*


* [1.x.67]

* 下一步就像以前所有的教程程序一样。我们把所有东西放到一个自己的命名空间中，然后把deal.II的类和函数导入其中。
*


* [1.x.68]
*
* [1.x.69] [1.x.70]。


*
* 下一块是主类的声明。这个类中的大多数函数都不是新的，在以前的教程中已经解释过了。唯一有趣的函数是 [2.x.77] 和 [2.x.78] 评估扩散方程， [2.x.79] ，在给定的时间和给定的 [2.x.80] 。  [2.x.81] 在给定的时间和给定的[2.x.84]和[2.x.85]下，评估[2.x.82]或等同于[2.x.83] 。当使用隐式方法时，需要这个函数。
*


* [1.x.71]
*
* 接下来的三个函数分别是显式方法、隐式方法和嵌入式显式方法的驱动。嵌入显式方法的驱动函数返回执行的步数，鉴于它只接受作为参数传递的时间步数作为提示，但内部计算了最佳时间步数本身。
*


* [1.x.72]

* 我们选择二次有限元，我们初始化参数。
*


* [1.x.73]
*
* [1.x.74] [1.x.75] 现在，我们创建约束矩阵和稀疏模式。然后，我们初始化这些矩阵和解决方案的向量。
*


* [1.x.76]
*
* [1.x.77] [1.x.78] 在这个函数中，我们计算 [2.x.86] 和质量矩阵 [2.x.87] 。然后使用直接求解器对质量矩阵进行反演；然后[2.x.88]变量将存储质量矩阵的反值，这样[2.x.89]就可以使用该对象的[2.x.90]函数应用于一个矢量。在内部，UMFPACK并没有真正存储矩阵的逆，而是存储它的LU因子；应用逆矩阵就相当于用这两个因子做一次正解和一次逆解，这与应用矩阵的显式逆具有相同的复杂性）。
*


* [1.x.79]
*
* [1.x.80] [1.x.81]。
* 在这个函数中，计算出给定时间和给定点的方程的源项。
*


* [1.x.82]
*
* [1.x.83] [1.x.84]。
* 接下来，我们在给定的时间[2.x.91]和给定的矢量[2.x.92]评估扩散方程的弱形式。换句话说，正如介绍中所述，我们评估 [2.x.93] 。为此，我们必须将矩阵[2.x.94]（之前计算并存储在变量[2.x.95]中）应用于[2.x.96]，然后添加源项，我们像通常那样进行积分。(如果你想节省几行代码，或者想利用并行积分的优势，可以用[2.x.97]来进行积分。)然后将结果乘以[2.x.98] 。
*


* [1.x.85]
*
* [1.x.86] [1.x.87]。
* 我们计算 [2.x.99] 。这要分几个步骤进行。
*


*
* - 计算[2.x.100]。



*
* - 反转矩阵，得到[2.x.101]。
*


*
* - 计算 [2.x.102]



*
* - 计算 [2.x.103]



*
* - 返回z。
*


* [1.x.88]
*
* [1.x.89] [1.x.90]
* 下面的函数会以时间步长和时间步长方法的名称为索引输出vtu文件中的解。当然，所有的时间步长方法的（精确）结果应该是一样的，但是这里的输出至少可以让我们对它们进行比较。
*


* [1.x.91]
*
* [1.x.92] [1.x.93]。
* 这个函数是所有显式方法的驱动。在顶部，它初始化了时间步长和解决方案（通过将其设置为零，然后确保边界值和悬挂节点约束得到尊重；当然，对于我们在这里使用的网格，悬挂节点约束实际上并不是一个问题）。然后调用[2.x.104]，执行一个时间步骤。时间是通过一个DiscreteTime对象来存储和增加的。   
* 对于显式方法，[2.x.105]需要评估[2.x.106]，即，它需要[2.x.107]。因为[2.x.108]是一个成员函数，它需要被绑定到[2.x.109]。在每个进化步骤之后，我们再次应用正确的边界值和悬挂节点约束。   
* 最后，每隔10个时间步骤就会输出解决方案。
*


* [1.x.94]
*
* [1.x.95] [1.x.96] 这个函数等同于[2.x.110]，但用于隐式方法。当使用隐式方法时，我们需要评估[2.x.111]和[2.x.112]，为此我们使用之前介绍的两个成员函数。
*


* [1.x.97]
*
* [1.x.98] [1.x.99] 这个函数是嵌入式显式方法的驱动。它需要更多的参数。
*


*
* - coarsen_param：当误差低于阈值时，乘以当前时间步骤的系数。
*


*
* - refine_param：当误差超过阈值时，乘以当前时间步数的系数。
*


*
* - min_delta: 可接受的最小的时间步长。
*


*
* - max_delta: 可接受的最大时间步长。
*


*
* - refine_tol：阈值，超过这个阈值的时间步长将被精炼。
*


*
* - coarsen_tol：阈值，低于该阈值的时间步长将被粗化。   
* 嵌入式方法使用一个猜测的时间步长。如果使用这个时间步长的误差太大，时间步长将被缩小。如果误差低于阈值，则在下一个时间步长中会尝试更大的时间步长。  [2.x.113]是由嵌入方法产生的猜测时间步长。总之，时间步长有可能以三种方式修改。
*


*
* - 在[2.x.114]内减少或增加时间步长



*
* - 使用计算的[2.x.115].
*


*
* - 自动调整最后一个时间步骤的步长，以确保模拟在[2.x.116]处精确结束。这种调整是在DiscreteTime实例中处理的。
*


* [1.x.100]
*
* [1.x.101] [1.x.102]。
* 以下是该程序的主要功能。在顶部，我们创建网格（一个[0,5]x[0,5]的正方形）并对其进行四次细化，得到一个有16乘16单元的网格，共256个。  然后我们将边界指示器设置为1，用于边界中[2.x.117]和[2.x.118]的部分。
*


* [1.x.103]
*
* 接下来，我们设置了线性系统，并为其填充内容，以便在整个时间步进过程中使用它们。
*


* [1.x.104]
*
* 最后，我们使用命名空间TimeStepping中实现的几种Runge-Kutta方法来解决扩散问题，每次都会在结束时间输出误差。(正如介绍中所解释的，由于精确解在最后时间为零，所以误差等于数值解，只需取解向量的[2.x.119]准则就可以计算出来)。
*


* [1.x.105]
*
* [1.x.106] [1.x.107]。


*
* 下面的[2.x.120]函数与以前的例子类似，不需要注释。
*


* [1.x.108]
* [1.x.109][1.x.110] 。


* 这个程序的重点不在于显示特定的结果，而在于显示它是如何完成的。我们已经通过讨论上面的代码证明了这一点。因此，该程序的输出相对较少，只包括控制台输出和用于可视化的VTU格式的解决方案。
* 控制台输出包含错误和一些方法所执行的步骤数。
* [1.x.111]
*
* 正如预期的那样，高阶方法给出了（更）准确的解决方案。我们还看到，（相当不准确的）Heun-Euler方法增加了时间步骤的数量，以满足公差。另一方面，其他嵌入式方法使用的时间步数比规定的要少得多。
*

* [1.x.112][1.x.113] [2.x.121] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-53_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13]
* [2.x.2]
* [1.x.14]
* [2.x.3] 这个程序阐述了几何学的概念和实现它的类。这些类被归入[2.x.4]"三角形的流形描述 "的文档模块。更多信息请见那里。
* [2.x.5] 本教程也可作为Jupyter Python笔记本，使用deal.II python接口。该笔记本与原始的C++程序在同一目录下可用。渲染的笔记本也可以在[1.x.15]上查看。
*

*[1.x.16][1.x.17][1.x.18]


* 现实问题的偏微分方程往往是在具有复杂几何形状的领域内提出的。为了提供几个例子，请考虑这些情况。
*
* 在有限元方法的两个最重要的工业应用中，空气动力学和更广泛的流体动力学是其中之一。今天，计算机模拟被用于每架飞机、汽车、火车和船舶的设计。在这些情况下，提出偏微分方程的领域是飞机周围的空气，包括机翼、襟翼和发动机；汽车周围的空气，包括车轮、轮井、后视镜，以及赛车中的各种空气动力设备；火车周围的空气，包括车轮和车厢之间的空隙。在船舶的情况下，领域是船舶周围的水和它的船舵和螺旋桨。
*
* - 有限元方法的另一大应用是结构工程，其领域是桥梁、飞机机舱和机翼以及其他通常形状复杂的实体。
*
* - 有限元建模也经常被用来描述地震波的产生和传播。在这些情况下，人们需要准确表示地壳中断层的几何形状。由于断层相交、倾斜，而且往往不是完全笔直的，所以域经常是非常复杂的。我们可以举出更多的复杂几何形状的例子，在这些例子中，我们要提出并解决一个偏微分方程。这表明，"真实 "的世界比我们在这之前的几乎所有教程程序中所展示的要复杂得多。
* 因此，本程序致力于展示如何通过具体的应用来处理复杂的几何图形。特别是，它所展示的是我们如何使网格符合我们想要解决的领域。另一方面，该程序没有展示的是如何为一个域创建一个粗的。形成粗大网格的过程被称为 "网格生成"，有许多高质量的程序在这方面做得比我们做得更好。然而，deal.II确实有能力读取由网格生成器生成的多种格式的网格，然后通过对网格进行变形或多次细化，使其适合给定形状。deal.II的常见问题页面参考了http://www.dealii.org/provides 网格生成器的资源。
*

*[1.x.19][1.x.20]


* 让我们假设你有一个复杂的领域，并且你已经有一个粗略的网格，以某种方式代表了该领域的一般特征。在两种情况下，有必要向deal.II程序描述你的几何形状的细节。
*
* - 网格细化。每当一个单元被细化时，有必要在三角网中引入新的顶点。在最简单的情况下，我们假设构成三角网的对象是直线段、双线性表面或三线性体。然后，下一个顶点被简单地放在旧顶点的中间。然而，对于弯曲的边界，或者如果我们想解决一个嵌入高维空间的弯曲的低维流形上的PDE，这是不充分的，因为它将不尊重实际的几何。因此，我们必须告诉Triangulation将新的点放在哪里。
*
* - 整合。当使用高阶有限元方法时，经常需要使用边界的曲线近似来计算积分，即把单元的每个边缘或面描述为曲线，而不是直线段或双线性补丁。当然，在积分边界条款时也是如此（例如，不均匀的诺伊曼边界条件）。为了整合的目的，各种Mapping类就提供了从参考单元到实际单元的转换。
* 在这两种情况下，我们都需要一种方法来提供关于单个单元、其面和边的域的几何信息。这就是Manifold类开始发挥作用的地方。Manifold是一个抽象的基类，它只定义了一个接口，Triangulation和Mapping类可以通过这个接口查询域的几何信息。从概念上讲，Manifold看待世界的方式与数学分支学科几何学看待世界的方式并无二致：域本质上只是一个点的集合，它被赋予了点之间距离的概念，这样我们就可以在其他一些点的 "中间 "获得一个点。
* deal.II提供了一些实现Manifold所提供的接口的类，用于各种常见的几何形状。另一方面，在这个程序中，我们将只考虑一个非常常见和简单得多的情况，即我们要解决的域的（一部分）可以通过转换一个更简单的域（我们将称之为 "参考域"）来描述的情况。图表是由一个平滑函数描述的，该函数从较简单的域映射到图表（"前推 "函数）及其逆向（"后拉 "函数）。如果域作为一个整体不是一个图表（例如，一个球体的表面），那么它通常可以被描述为一个图表的集合（例如，北半球和南半球各自是一个图表），然后域可以由一个[1.x.22]描述。
* 如果一个领域可以被分解成一个图集，我们需要做的就是为每个图集提供拉回和推回函数。在deal.II中，这意味着提供一个从ChartManifold派生的类，而这正是我们在这个程序中要做的。
*

*[1.x.23][1.x.24]


* 为了说明如何在deal.II中使用图表描述几何形状，我们将考虑一个源于[1.x.25]的应用的案例，使用D. Sarah Stamps提供的数据集。在这个具体的应用中，我们对描述[1.x.26]下的地幔流动感兴趣，这是一个两个大陆板块漂移的区域。不拐弯抹角，我们想要描述的几何形状是这样的。
* [2.x.6]
* 特别是，虽然你在这里看不到，但顶面不仅仅是被海拔所染，事实上，它是按照正确的地形而变形的。我们感兴趣的领域是地球的一部分，范围从表面到500公里深，从格林威治子午线以东26度到35度，从赤道以北5度到南10度。
* 对几何学的这一描述建议从一个盒子[2.x.7]开始（以度、度和米为单位），并提供一个地图[2.x.8]，以便[2.x.9]，其中[2.x.10]是我们寻找的领域。  然后[2.x.11]是一个图表，[2.x.12]是回拉运算符，[2.x.13]是前推运算符。如果我们需要一个点[2.x.14]是其他点[2.x.15]的 "平均值"，ChartManifold类首先应用回拉运算得到[2.x.16]，将其平均到一个点[2.x.17]，然后计算出[2.x.18]。
* 因此我们的目标是实现一个描述[2.x.19]和[2.x.20]的类。如果地球是一个球体，那么这并不困难：如果我们用[2.x.21]指出[2.x.22]的点（即向东计算的经度，向北计算的纬度，以及相对于零深度的高度），那么[1.x.27]提供直角坐标系的坐标，其中[2.x.23]是球体的半径。然而，地球不是一个球体。
* [2.x.24] [2.x.25]它在两极是扁平的，在赤道上较大：半主轴比半次轴长约22公里。我们将使用[1.x.28]的地球形状参考标准来说明这一点。WGS 84中使用的公式是[1.x.29]，其中[2.x.26]，半径和椭圆度由[2.x.27]给出，以获得直角坐标的位置。在这个公式中，我们假设正弦和余弦的参数是以度数而不是弧度来计算的（尽管我们将不得不在代码中改变这个假设）。
* [2.x.28] 它有山脉和山谷形式的地形。我们将使用真实的地形数据来说明这一点（见下文对这些数据来源的描述）。使用这个数据集，我们可以在地球表面的经纬度网格上查找高程。从方框[2.x.29]开始，我们将首先在垂直方向上拉伸它，然后再交给WGS 84函数：如果[2.x.30]是经度[2.x.31]和纬度[2.x.32]的高度，那么我们定义[1.x.30] 使用这个函数，方框[2.x.33]的顶部表面被移到正确的地形，底部表面保持原状，中间的点被线性内插。[2.x.34]
* 使用这两个函数，我们就可以将整个前推函数[2.x.35]定义为[1.x.31]此外，我们还必须定义这个函数的逆函数，即拉回操作，我们可以写成[1.x.32]我们可以通过反转上面的公式得到这个函数的一个组成部分：[1.x.33]计算[2.x.36]也是可能的，尽管要麻烦很多。我们不会在这里展示这个公式，而只是提供程序中的实现。
*

*[1.x.34][1.x.35]


* 在这个程序中，我们需要解决一些问题。在最大范围内，我们需要编写一个实现ChartManifold接口的类。这涉及到一个函数[2.x.37]，该函数在参考域[2.x.38]中取一个点，并使用上面概述的函数[2.x.39]将其转换为实空间，以及实现[2.x.41]的反函数[2.x.40]。我们将在下面的[2.x.42]类中这样做，该类本质上看起来像这样。
* [1.x.36]
*
* 上面的变换有两个部分：WGS 84变换和地形变换。因此，[2.x.43]类将有额外的（非虚拟的）成员函数[2.x.44]和[2.x.45]来实现这两部分，以及相应的回拉函数。
* WGS 84的转换函数不是特别有趣（尽管它们实现的公式令人印象深刻）。更有趣的部分是地形变换。回顾一下，为此我们需要评估高程函数[2.x.46]。当然，这没有公式。地球就是这样，人们能做的最好的事情就是从一些表格中查找海拔高度。事实上，这就是我们要做的。
* 我们使用的数据最初是由[1.x.37]创建的，从美国地质调查局（USGS）下载，由D. Sarah Stamps处理，他还编写了WGS 84转换函数的初始版本。这样处理过的地形数据被储存在一个文件[2.x.47]中，解压后看起来像这样。
* [1.x.38]
* 数据的格式为[2.x.48]，其中前两栏以赤道以北的度数和格林威治子午线以东的度数提供。最后一列是以WGS 84零点以上的米数为单位。
* 在转换函数中，我们需要对给定的经度[2.x.50]和纬度[2.x.51]评估[2.x.49]。一般来说，这个数据点是不可用的，我们将不得不在相邻的数据点之间进行插值。编写这样一个插值程序并不特别困难，但它有点乏味和容易出错。幸运的是，我们可以以某种方式将这个数据集塞进一个现有的类中。[2.x.52] .不幸的是，这个类并不完全适合，所以我们需要绕过它。问题来自于我们初始化这个类的方式：在其最简单的形式下，它需要一个数值流，它假定这些数值在[2.x.53]平面（或者，这里是[2.x.54]平面）上形成一个等距的网格。这就是它们在这里的作用，有点像：它们的顺序是纬度第一，经度第二；更尴尬的是，第一列从最大的数值开始往下数，而不是通常的其他方式。
* 现在，虽然教程程序是为了说明如何用deal.II编码，但它们不一定要满足与生产代码相同的质量标准。在生产代码中，我们会写一个函数来读取数据，并(i)自动确定第一列和第二列的范围，(ii)自动确定每个方向的数据点的数量，(iii)无论数据排列的顺序如何，都要进行插值，如果有必要的话，在读取和提交给[2.x.55]类之间切换顺序。
* 另一方面，辅导课程最好是简短的，并展示关键点，而不是停留在不重要的方面，从而掩盖了我们真正想要展示的东西。因此，我们将允许自己有一点回旋余地。
*
* - 由于这个程序只针对东非裂谷地区的特定几何形状，而且这正是数据文件所描述的区域，我们将在程序中硬编码，即有[2.x.56]个数据。
*
* - 我们将硬编码数据的边界 [2.x.57] 。
*
* - 我们将对[2.x.58]类说谎：该类将只看到该数据文件最后一列的数据，我们将假装数据的排列方式是：在第一坐标方向有1139个数据点，这些数据点按[1.x.39]的顺序排列，但在一个区间[2.x.59]（不是否定的边界）。然后，当我们需要查询一个纬度[2.x.60]的东西时，我们可以向内插表类索取一个位于[2.x.61]的值。有了这个小技巧，我们就可以避免在从文件中读取数据的时候切换顺序。
* 所有这些然后调用一个类，基本上看起来像这样。
* [1.x.40]
*
* 注意[2.x.62]函数如何否定了纬度。它也从我们在其他地方使用的格式[2.x.63]切换到表格中使用的纬度-经度格式。最后，它的参数以弧度为单位，因为我们在程序中的其他地方也是这样做的，但随后将它们转换为用于表格查询的基于度的系统。正如你在下面的实现中所看到的，这个函数还有几个（静态）成员函数，我们将在初始化[2.x.64]成员变量时调用：这个变量的类类型有一个构造函数，允许我们在构造时设置好一切，而不是在以后填充数据，但这个构造函数需要一些不能就地构造的对象（至少在C++98中不能）。因此，我们想在初始化中传递的每个对象的构造都发生在一些静态成员函数中。
* 在讨论了我们想要实现的东西的大体轮廓之后，让我们进入程序并展示它在实践中是如何完成的。
*

* [1.x.41] [1.x.42]。
* 让我们从这里需要的包含文件开始。很明显，我们需要描述三角形的文件（ [2.x.65] ），以及允许我们创建和输出三角形的文件（ [2.x.66] 和 [2.x.67] ）。此外，我们还需要声明Manifold和ChartManifold类的头文件，我们将需要这些类来描述几何图形（[2.x.68]）。然后我们还需要以下头文件中的[2.x.69]函数；这个函数的用途将在我们使用它的时候讨论。
*


* [1.x.43]
*
* 其余的包含文件与读取地形数据有关。正如介绍中所解释的，我们将从一个文件中读取它，然后使用下面头文件中第一个声明的[2.x.70]类。因为数据很大，所以我们读取的文件是以gzip压缩数据的形式存储的，我们利用BOOST提供的一些功能，直接从gzip压缩数据中读取。
*


* [1.x.44]
*
* 上事的最后部分是打开一个命名空间，把所有东西都放进去，然后把dealii命名空间导入其中。
*


* [1.x.45]
*
* [1.x.46] [1.x.47]。
* 这个程序的第一个重要部分是描述地形的类[2.x.71]，它是经度和纬度的函数。正如在介绍中所讨论的，我们在这里将使我们的生活更容易一些，不以最普遍的方式来写这个类，而只为我们在这里感兴趣的特殊目的来写：插值从一个非常具体的数据文件中获得的数据，该文件包含了我们知道其范围的世界上的一个特定地区的信息。   
* 上面已经讨论了这个类的总体布局。下面是它的声明，包括我们在初始化[2.x.72]成员变量时需要的三个静态成员函数。
*


* [1.x.48]
*
* 让我们来看看这个类的实现。这个类的有趣部分是构造函数和[2.x.73]函数。前者初始化了[2.x.74]成员变量，我们将使用这个构造函数，它要求我们传入我们要插值的二维数据集的端点（这里是由间隔[2.x.75]，使用介绍中讨论的切换端点的技巧，以及[2.x.76]，都是以度数给出的），数据被分割成的区间数（纬度方向379，经度方向219，总共[2.x.77]个数据点），以及一个包含数据的表对象。然后，数据的大小当然是[2.x.78]，我们通过提供一个迭代器给下面[2.x.80]函数返回的[2.x.79]对象的83,600个元素中的第一个来初始化它。请注意，我们在这里调用的所有成员函数都是静态的，因为(i)它们不访问类的任何成员变量，(ii)因为它们是在对象没有完全初始化的时候调用的。
*


* [1.x.49]

* 其他唯一比较有兴趣的函数是[2.x.81]函数。它返回一个临时向量，包含所有描述海拔的83,600个数据点，并从文件中读取 [2.x.82] 。因为该文件被gzip压缩了，我们不能直接通过[2.x.83]类型的对象来读取它，但是在BOOST库中有一些方便的方法（见http://www.boost.org），允许我们从压缩文件中读取，而不必先在磁盘上解压。其结果是，基本上，只是另一个输入流，就所有的实际目的而言，看起来就像我们一直使用的那些输入流。   
* 读取数据时，我们读取三栏，但忽略前两栏。最后一列中的数据被附加到我们返回的数组中，该数组将被复制到初始化[2.x.84]的表格中。由于BOOST.iostreams库在输入文件不存在、不可读或不包含正确的数据行数时没有提供一个非常有用的异常，我们捕捉它可能产生的所有异常，并创建我们自己的异常。为此，在[2.x.85]子句中，我们让程序运行到一个[2.x.86]语句。由于条件总是假的，这总是会触发一个异常。换句话说，这相当于写了[2.x.87]，但它也填补了异常对象中的某些字段，这些字段以后将被打印在屏幕上，识别出发生异常的函数、文件和行。
*


* [1.x.50]
*
* 创建一个流，我们从压缩的数据中读取
*


* [1.x.51]
*
* [1.x.52] [1.x.53].
* 下面这个类是这个程序的主要类。它的结构已经在介绍中详细描述过了，不需要再多做介绍。
*


* [1.x.54]
*
* 如果你读过介绍，其实现也是非常直接的。特别是，回拉和前推函数都只是WGS 84和地形图映射各自函数的串联。
*


* [1.x.55]
*
* 下一个函数是Manifold基类的接口所要求的，它允许克隆AfricaGeometry类。注意，虽然该函数返回一个[2.x.88]，但我们在内部创建了一个`unique_ptr<AfricaGeometry>`。换句话说，这个库需要一个指向基类的指针，我们通过创建一个指向派生类的指针来提供这个指针。
*


* [1.x.56]
*
* 下面两个函数就定义了对应于地球WGS84参考形状的正向和反向变换。正向转换遵循介绍中的公式。反变换要复杂得多，至少不是直观的。它还存在一个问题，即它返回的角度在函数结束时我们需要将其夹回区间[2.x.89]，如果它应该从那里逃出来。
*


* [1.x.57]
*
* 与此相反，地形变换完全遵循介绍中的描述。因此，没有什么可补充的。
*


* [1.x.58]
*
* [1.x.59] [1.x.60].
* 在描述了几何体的属性之后，现在是处理用于离散它的网格的时候了。为此，我们为几何体和三角形创建对象，然后继续创建一个与参考域[2.x.91]相对应的[2.x.90]矩形网格。我们选择这个数目的细分，因为它导致了细胞大致上像立方体，而不是在某个方向上被拉伸。   
* 当然，我们实际上对参考域的网格划分不感兴趣。我们感兴趣的是对真实域的网格划分。因此，我们将使用[2.x.92]函数，它只是根据一个给定的变换来移动三角形的每个点。它想要的变换函数是一个将参考域中的一个点作为其单一参数并返回我们想要映射到的域中的相应位置的函数。当然，这正是我们使用的几何学的前推函数。我们用一个lambda函数来包装它，以获得转换所需的那种函数对象。
*


* [1.x.61]
*
* 下一步是向三角计算说明，在细化网格时，只要需要一个新的点，就使用我们的几何对象。我们通过告诉三角计算对所有流形指示器为0的物体使用我们的几何体，然后继续用流形指示器0标记所有单元及其边界面和边。这确保了三角计算在每次需要新的顶点时都会参考我们的几何对象。由于流形指标是由母体继承给子体的，这也会在几个递归细化步骤之后发生。
*


* [1.x.62]
*
* 最后一步是在最初的[2.x.93]粗略网格之外细化网格。我们可以在全局范围内细化若干次，但由于本教程程序的目的，我们实际上只对靠近表面的情况感兴趣，我们只是对所有在边界上有一个指标为5的面的单元细化6次。在我们上面使用的[2.x.94]函数的文档中查找，发现边界指标5对应于域的顶面（这就是上面调用[2.x.96]的最后一个[2.x.95]参数的含义：通过给每个边界分配一个独特的边界指标来给边界 "着色"）。
*


* [1.x.63]
*
* 做完这一切后，我们现在可以将网格输出到一个自己的文件中。
*


* [1.x.64]
*
* [1.x.65] [1.x.66]。


*
* 最后是主函数，它遵循从[2.x.97]开始的所有教程程序中使用的相同方案。这里没有什么可做的，只是调用单一的[2.x.98]函数。
*


* [1.x.67]
* [1.x.68][1.x.69] 。


* 运行程序会产生一个网格文件[2.x.99]，我们可以用任何可以读取VTU文件格式的常用可视化程序来进行可视化。如果只看网格本身，实际上很难看到任何不只是看起来像一块完全圆形的球体的东西（尽管如果修改程序，使其确实产生一个球体并同时观察它们，整体球体和WGS 84形状之间的差异是相当明显的）。显然，地球实际上是一个相当平坦的地方。当然，我们已经从卫星图片中知道了这一点。然而，我们可以通过对细胞的体积进行着色来找出更多东西。这既产生了顶层表面的轻微色调变化，也为可视化程序提供了应用其着色算法的东西（因为单元的顶层表面现在不再只是与球体相切，而是倾斜的）。
* [2.x.100]
* 然而，至少就可视化而言，这仍然不是太令人印象深刻。相反，让我们用一种可视化的方式来显示沿顶面的实际海拔。换句话说，我们想要一张像这样的图片，有大量的细节。
* [2.x.101]
* 这张图片的放大显示了垂直方向的位移（这里，从西-西北方向看裂谷，[1.x.70]、[1.x.71]和[1.x.72]的三座山峰在[1.x.73]、[1.x.74]和向[1.x.75]的巨大平坦处）。
* [2.x.102]


* 这些图片是经过三个小的修改后产生的。[2.x.103] [2.x.104] 这两张图片中的第一张在顶面增加了第七个网格细化，第二张总共增加了九个。在第二张图片中，水平方向的网格大小约为1.5km，垂直方向的网格大小略低于1km。(这张图也是用一个更有分辨率的数据集制作的；但是，它太大了，不能作为教程的一部分分发)。
* [2.x.105] 增加了以下函数，即给定一个点[2.x.106]，通过将该点转换为参考WGS 84坐标并只保留深度变量来计算海拔高度（因此，该函数是[2.x.107]函数的简化版本）。
* [1.x.76]
*
* [2.x.108] 在[2.x.109]函数的底部增加以下一块。
* [1.x.77]
* [2.x.110] 这最后一段代码首先在网格上创建一个[2.x.111]有限元空间，然后（ab）使用[2.x.112]来评估顶部边界（边界指示器为5的节点）的levation函数。我们在这里用ScalarFunctionFromFunctionObject类来包装对[2.x.113]的调用，使一个普通的C++函数看起来像一个派生自Function类的对象，我们想在[2.x.114]中使用该类。然后，这个向量像往常一样用DataOut输出，并可以像上面所示那样可视化。
*

*[1.x.78][1.x.79] 。


* 如果你放大上图所示的网格并仔细观察，你会发现在悬空节点处，连接悬空节点的两条小边与相邻单元的大边的位置不完全相同。这可以通过使用不同的表面描述来更清楚地显示出来，在这种描述中，我们放大了垂直地形以增强效果（由Alexander Grayver提供）。
* [2.x.116]
* 那么这里发生了什么？部分地，这只是可视化的结果，但也有一个潜在的真实原因。
* [2.x.117] [2.x.118] 当你使用任何一个常见的可视化程序对网格进行可视化时，它们真正显示的只是一组在三维空间中被绘制成直线的边缘。这是因为几乎所有用于可视化的数据文件格式都只将六面体单元描述为三维空间中八个顶点的集合，而不允许进行任何更复杂的描述。这就是为什么[2.x.119]需要一个可以设置为大于1的参数的主要原因）。这些线性边缘可能是你进行实际计算的单元格的边缘，也可能不是，这取决于你在使用FEValues进行积分时使用何种映射。当然，在默认情况下，FEValues使用的是线性映射（即MappingQ1类的对象），在这种情况下，一个3D单元确实完全由其8个顶点描述，它所填充的体积是这些点之间的三线插值，从而产生了线性边缘。但是，你也可以使用三次方、三次立方、甚至更高阶的映射，在这些情况下，每个单元的体积将由二次方、三次方或高阶多项式曲线来限定。然而，你只能在可视化程序中看到这些带有线性边缘的曲线，因为如前所述，文件格式不允许描述单元的真实几何形状。
* [2.x.120] 也就是说，为了简单起见，让我们假设你确实在使用三线性映射，那么上面显示的图像就是你形成积分的单元的忠实代表。在这种情况下，一般来说，悬空节点上的小单元并不与大单元紧密贴合，而是留有空隙或可能与大单元相交。这是为什么呢？  因为当三角测量需要在它想要细化的边缘上增加一个新的顶点时，它会询问流形描述这个新的顶点应该在哪里，流形描述通过（在从ChartManifold派生的几何体的情况下）将线的相邻点拉回到参考域，平均它们的位置，并将这个新的位置推到真实域，从而适当地返回这样一个点。但是这个新的位置通常不是沿着相邻顶点之间的直线（在实空间），因此，形成精炼边的两条小直线并不完全位于形成悬挂节点的未精炼边的一条大直线上。[2.x.121]
* 如果你使用一个使用MappingQ类的高阶映射，情况会稍微复杂一些，但没有根本性的不同。让我们暂且以aquadratic映射为例（即使是高阶映射也没有什么根本的变化）。那么你需要把你所整合的单元格的每条边想象成一条二次曲线，尽管你实际上不会看到可视化程序以这种方式来绘制。但是，请先想象一下。那么，MappingQ采用哪条二次曲线呢？它是经过边缘末端的两个顶点以及中间的一个点的二次曲线，它从流形中查询。在未精炼一侧的长边的情况下，这当然正是悬挂节点的位置，所以描述长边的二次曲线确实经过了悬挂节点，这与线性映射的情况不同。但是两条小边也是二次曲线；例如，左边的小边将穿过长边的左顶点和悬挂节点，再加上它从流形中查询到的一个点。因为，如前所述，流形沿左小边中途返回的点很少完全在描述长边的二次曲线上，二次短边通常不会与二次长边的左半边重合，而右短边也是如此。换句话说，大单元的几何形状和它的小邻居在悬挂的节点上并不紧密地接触。
* 这一切引出了两个问题：第一，这是否重要；第二，这是否可以被修复。让我们在下文中讨论这些问题。
* [2.x.122] [2.x.123] 这重要吗？几乎可以肯定的是，这取决于你所求解的方程。例如，众所周知，在复杂几何体上求解气体动力学的欧拉方程需要高度精确的边界描述，以确保衡量靠近边界的流动的量的收敛性。另一方面，具有椭圆成分的方程（如拉普拉斯方程或斯托克斯方程）通常对这些问题比较宽容：无论如何都要做正交来近似积分，鉴于每个悬空节点的重叠或间隙的体积只有[2.x.124]，进一步近似几何可能不会像人们担心的那样造成伤害。]，即使是线性映射，对于度数[2.x.126]的映射，也只有[2.x.125]。 你可以通过考虑以下情况来了解：在2D中，间隙/重叠是一个三角形，底[2.x.127]，高[2.x.128]；在3D中，它是一个金字塔状结构，底面积[2.x.129]，高[2.x.130] 。类似的考虑也适用于高阶映射，其中间隙/重叠的高度为 [2.x.131] .)换句话说，如果你使用线性元素的线性映射，你所积分的体积的误差已经与使用通常的高斯正交的积分误差处于同一水平。当然，对于高阶元素，人们必须选择匹配的映射对象。
* 关于为什么可能不值得过分担心这个问题的另一个观点是，在数值分析界肯定没有人说这些问题是使用复杂几何体时需要注意的主要问题。如果在从业人员中似乎并不经常讨论这个问题，如果有的话，那么它至少不是人们认定的一个普遍问题。
* 这个问题与在弯曲的边界上有悬挂的节点没有什么不同，边界的几何描述通常将悬挂的节点拉到边界上，而大的边缘仍然是直的，使得相邻的小单元和大单元不能相互匹配。虽然这种行为从一开始就存在于deal.II中，在流形描述出现之前的15年，但在邮件列表的讨论或与同事的交谈中，它从未出现过。
* [2.x.132]它可以被修复吗？原则上是的，但这是一个复杂的问题。让我们暂时假设我们只使用MappingQ1类，即线性映射。在这种情况下，每当三角化类需要沿一条将成为悬空节点的边建立一个新的顶点时，它就会直接取相邻顶点的平均值[1.x.80]，也就是说，不问流形的描述。这样一来，该点就位于长直边上，两条短直边将与一条长直边匹配。只有当所有相邻的单元都被细化，并且该点不再是一个悬挂的节点时，我们才会用通过流形得到的坐标来替换它的坐标。这在实现上可能比较困难，但肯定是可以的。
* 更复杂的问题出现了，因为人们可能想使用更高阶的MappingQ对象。在这种情况下，Triangulation类可以自由选择悬挂节点的位置（因为长边的二次曲线可以选择通过悬挂节点的方式），但是MappingQ类在确定中边点的位置时，必须确保如果该边是相邻的较粗单元的长边的一半，那么中点不能从流形中得到，而必须沿着长的二次边选择。对于立方体（和所有其他奇数）映射，这个问题又有点复杂了，因为人们通常安排立方体边沿着边的1/3和2/3点走，因此必然要通过悬挂的节点，但这可能是可以解决的。在任何情况下，即使如此，这也有两个问题。
*


*


*
* - 在细化三角函数时，三角函数类不能知道将使用什么映射。事实上，在同一个程序中，一个三角函数在不同的环境中被使用的情况并不少见。如果使用的映射决定了我们是否可以自由选择一个点，那么，三角剖分应该如何定位新的顶点？
*


*


*
* - 映射是纯粹的局部构造：它们只对孤立的单元起作用，而这正是有限元方法的重要特征之一。要问一条边上的一个顶点是否是悬空节点，需要查询一个单元的邻域；此外，这样的查询不只是涉及3D中一个单元的6个面的邻域，而是可能需要遍历与一条边相连的其他大量的单元。即使可以做到这一点，人们仍然需要根据邻域的样子做不同的事情，产生的代码可能非常复杂，难以维护，而且可能很慢。
* 因此，至少在目前，这些想法都没有被实施。这导致了不连续的几何形状的不良后果，但是，正如上面所讨论的，这种影响在实际应用中似乎并不构成问题。
* [2.x.133]
*

* [1.x.81][1.x.82] [2.x.134] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-54_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16]
* [2.x.2]
* [1.x.17]
* [2.x.3] 这个程序阐述了工业几何的概念，使用与OpenCASCADE库（http://www.opencascade.org）接口的工具，允许指定任意的IGES文件来描述你的几何图形的边界。
* [2.x.4]
* [1.x.18][1.x.19][1.x.20] 。
*

*
* 在以前的一些教程（[2.x.5]、[2.x.6]、[2.x.7]、[2.x.8]和[2.x.9]等）中，我们已经学会了如何使用 deal.II中提供的网格细化方法。这些教程展示了如何使用这些工具为一次模拟制作精细的网格，如[2.x.10]；或者从粗大的网格开始，在自适应细化的网格上进行一系列的模拟，如[2.x.11]的情况。无论采取哪种方法，网格细化都需要对计算域边界进行适当的几何描述，以便在每次细化时，将新的网格节点置于边界表面。例如，[2.x.12]展示了如何创建一个圆形网格，将一个圆形流形对象自动附加到计算域上，从而使位于边界上的面被细化到圆上。  [2.x.13]展示了如何用实验获得的数据定义的流形来做这件事。但是，至少就基本边界形状而言，deal.II实际上只提供了圆形、球形、盒子和其他基本组合。在本教程中，我们将展示如何使用一套开发出来的类来导入任意的CAD几何图形，把它们分配到计算域的所需边界，并在这样的复杂形状上细化计算网格。
*

*[1.x.21][1.x.22]


*在最常见的工业实践中，任意形状的物体的几何模型是通过计算机辅助设计（CAD）工具实现的。在过去的几十年里，CAD建模工具的使用范围不断扩大，因为它们可以为每个设计对象生成一个完整的虚拟模型，在实物制作之前，可以通过计算机对其进行可视化、检查和分析，以获得最精细的细节。  从数学的角度来看，CAD建模者的引擎是由分析几何学来表示的，特别是由参数化的曲线和曲面，如B-splines和NURBS，它们足够丰富，可以表示大多数实际感兴趣的表面。  一旦一个虚拟模型准备好了，所需物体的所有几何特征都被存储在文件中，这些文件实质上包含了构成该物体的参数化曲面和曲线的系数。根据用于定义几何模型的特定CAD工具，有几种不同的文件格式，可以组织CAD模型的信息。为了提供一个跨CAD工具交换数据的共同基础，美国国家标准局在1980年发布了初始图形交换表示法（IGES）中性文件格式，在本例中使用。
* [1.x.23][1.x.24] 。
*

* 为了导入和查询CAD模型，deal.II库实现了一系列用于CAD建模的OpenCASCADE开源库的封装函数。这些函数允许将IGES文件导入OpenCASCADE本地对象，并将它们封装在一系列Manifold类中。
* 一旦从IGES文件导入，模型就被存储在[2.x.14]中，这是OpenCASCADE框架中定义的通用拓扑实体。从[2.x.15]中，就可以访问组成它的所有子形状（如顶点、边和面），以及它们的几何描述。在deal.II框架中，组成一个形状的拓扑实体被用来创建一个相应的Manifold表示。在[2.x.16]中，我们看到了如何使用[2.x.17]来创建一个超球体，它自动将一个球形的Manifold附加到所有边界面。这保证了边界面在网格细化过程中保持在球体或圆上。CAD建模界面的功能被设计为保留相同的结构，允许用户使用导入的CAD形状建立一个投影仪对象，保持我们在其他教程程序中使用的相同程序，即把这种投影仪对象分配给粗略网格的单元、面或边。在每个细化周期，新的网格节点将通过将现有对象的中点投影到指定的几何体上而自动生成。
* 与球形或圆形边界不同，具有复杂几何形状的边界带来的问题是，在细化过程中创建的新节点最好放在规定形状上。例如，PolarManifold将周围的点转化为极坐标，计算该坐标系中的平均值（每个坐标单独计算），最后将点转化回直角坐标。
* 在一个任意的、复杂的形状的情况下，一个适当的选择来放置一个新的节点并不是那么容易确定的。deal.II中的OpenCASCADEwrappers提供了几个采用不同投影策略的投影器类。第一个投影仪，在[2.x.18]类中实现，只用于边缘细化。它的建立是给它分配一个一维的拓扑形状，或者是一个[2.x.19]（这是一个复合形状，由几个相连的[2.x.20]组成），并细化一个网格边缘，找到新的顶点作为两个偶数部分的CAD曲线部分的曲线长度，该曲线位于原始边缘的顶点之间。
* [2.x.21]
*

* 在[2.x.22]类中实现了一个不同的投影策略。在构造时分配的[2.x.23]可以是任意的（形状、面、边的集合或单个面或边都可以）。新的单元格节点首先通过对周围的点进行平均计算，方法与FlatManifolddo相同。在第二步中，所有的新节点将沿着形状的法线方向被投射到[2.x.24]。如果有非法线投影，则选择最接近形状的点--通常位于形状的边界上--。  如果形状是由几个子形状组成的，则投影到每个子形状上，并选择最接近的投影点。
* [2.x.25] [2.x.26]。
* 正如我们即将体验到的，对于某些形状，将投影方向设置为CAD表面的法线将不会导致合适质量的表面网格。这是因为CAD表面的法线方向原则上与网格需要新节点的方向没有关系。在这种情况下，[2.x.27]类可以提供帮助。这个类的构造是指定一个[2.x.28]（至少包含一个面）和一个方向，所有的投影将沿着这个方向进行。新的点将被计算出来，首先对周围的点进行平均化（就像在FlatManifold的情况下），然后沿着构建时使用的方向，取拓扑形状和通过所得到的点的线之间的最接近的交点。  通过这种方式，用户可以对投影方向有更高的控制，以确保良好的网格质量。
* [2.x.29]


* 当然，后一种方法只有在表面的方向相当统一时才有效，这样就可以确定一个单一的投影方向。在表面方向接近投影方向的情况下，甚至有可能找不到方向性的投影。为了克服这些问题，[2.x.30]类实现了第三个投影算法。[2.x.31]类是在构造函数中分配了一个[2.x.32]（至少包含一个面），其工作原理与[2.x.33]完全一样。但是，正如该类的名称所暗示的，[2.x.34]试图想出一个对要精化的网格元素的法线方向的适当估计，并使用它来将新节点投射到CAD表面。如果我们考虑二维空间中的网格边缘，其轴线方向是一个方向，沿着这个方向分割，以产生两个相同长度的新单元。我们将这一概念延伸到三维空间，并将所有新的节点投射到接近单元法线的方向。
* 在下图中，受本教程中所考虑的几何形状的启发，我们试图比较所考虑的三种投影仪的行为。从左边可以看出，给定原始单元（蓝色）后，用法线投影找到的新点所处的位置不允许生成均匀的新元素（红色）。这种情况在进一步的细化步骤中会变得更糟。  由于我们考虑的几何体在某种程度上垂直于水平方向，以水平方向为投影方向的定向投影（中心图像）在获得新的网格点方面做得相当好。然而，在图片的底部，表面几乎是水平的，当进一步细化的步骤进行时，我们可以预期在这些区域会有问题。最后，右边的图片显示，位于cellaxis上的节点将导致两个具有相同长度的新单元。当然，三维的情况比这个简单的二维案例所描述的情况要复杂一些。然而，这个测试的结果证实，当考虑到任意形状的表面时，除非你有一个几何形状，已知有一个更具体的方法是合适的，否则法线到网格方向是三个测试中最好的方法。
*

* [2.x.35]


*[1.x.25][1.x.26]


* 在这个程序中，我们将考虑为一个描述船头的真实几何体创建一个表面网格（这个几何体经常被用于CAD和网格生成的比较中，并且可以免费获得）。我们得到的表面网格可以用来解决边界元素方程，以模拟水在船上的流动（类似于[2.x.36]），但我们不会在这里尝试这样做。为了让你对我们所考虑的几何形状有一个概念，这里有一张图片。
* [2.x.37]
* 在这个程序中，我们从文件中读取几何体和粗略的网格，然后使用上面讨论的几个选项来放置新的顶点，进行一系列的网格细化步骤。
*

* [1.x.27] [1.x.28]。
* [1.x.29] [1.x.30]。



* 我们首先包括一堆文件，我们将在程序的各个部分使用这些文件。其中大部分已经在以前的教程中讨论过了。
*


* [1.x.31]
*
* 这些是opencascade支持类和函数的头文件。注意，只有当你在编译deal.II库时支持OpenCASCADE，即在deal.II配置过程中调用[2.x.40]时指定[2.x.38]和[2.x.39]，这些才会包含合理的数据。
*


* [1.x.32]
*
* 最后，一些C++标准头文件
*


* [1.x.33]

* 我们将程序的其余部分隔离在它自己的命名空间中
*


* [1.x.34]
*
* [1.x.35] [1.x.36]。


*
* 这是主类。它真正做的是存储输入和输出文件的名称，以及一个三角图。然后，它提供了一个函数，可以从一个粗略的网格中生成这样一个三角形，使用介绍中讨论的策略之一，并在类的顶部的枚举类型中列出。   
* 这个类的成员函数类似于你可以在大多数其他教程程序中找到的模拟用网格的设置阶段。
*


*


* [1.x.37]
*
* [1.x.38] [1.x.39]。


*
* TriangulationOnCAD类的构造函数非常简单。输入参数是输入和输出文件名的字符串，以及决定在网格细化循环中使用哪种曲面投影仪的枚举类型（详见下文）。
*


*


* [1.x.40]
*
* [1.x.41] [1.x.42]。



*
* 下面的函数代表了这个程序的核心。  在这个函数中，我们导入CAD形状，在此基础上生成并完善我们的三角测量。我们假设CAD曲面包含在[2.x.41]文件中（我们在输入目录中提供了一个名为 "input/DTMB-5415_bulbous_bow.iges "的IGES文件的例子，它代表了一艘船的球形船头）。几个凸和凹的高曲率区域的存在使我们提供的几何体成为一个特别有意义的例子。   
* 在导入船首表面后，我们提取了组成它的一些曲线和曲面，并利用它们生成了一组投影仪。这些投影仪定义了三角法在单元细化过程中定位每个新节点所必须遵循的规则。   
* 为了初始化Triangulation，就像以前的教程程序一样，我们导入一个以VTK格式保存的已有网格。在这里我们假设用户已经在外部生成了一个粗略的网格，与IGES的几何图形相匹配。在编写本教程的时候，deal.II库并不自动支持生成这样的网格，但是有一些工具可以从CAD文件开始为你提供合理的初始网格。在我们的例子中，导入的网格是由一个四边形单元组成的，其顶点被放置在CAD的形状上。   
* 在导入IGES几何体和初始网格后，我们将之前讨论过的投影仪分配给每个需要在CAD表面进行细化的边和单元。   
* 在本教程中，我们将测试介绍中所描述的三种不同的CAD表面投影仪，并将分析每一种投影仪所获得的结果。  如前所述，这些投影策略中的每一个都在不同的类中实现了，这些类型的对象可以用[2.x.42]的方法分配给一个三角形。   
* 然后，下面的函数首先导入给定的CAD文件。函数的参数是一个包含所需文件名的字符串，以及一个比例因子。在这个例子中，比例因子被设置为1e-3，因为原始几何体是以毫米为单位的（这是大多数IGES文件的典型计量单位），而我们更喜欢以米为单位工作。  该函数的输出是一个OpenCASCADE通用拓扑形状类的对象，即一个[2.x.43]。
*


* [1.x.43]
*
* 每个CAD几何对象都定义了一个公差，表示其位置可能的不精确性。例如，顶点的公差[2.x.44]表示它可以位于以标称位置为中心、半径为[2.x.45]的球体中的任何一点。当把一个点投射到一个表面（这也有其公差）时，我们必须记住，投射的精度将受到建立表面的公差限制。
*

*
* 下面的方法提取了给定形状的公差，并使其稍大一些，以避免麻烦。
*


* [1.x.44]
*
* 我们现在要从通用形状中提取一组复合子形状。特别是，CAD文件的每个面都是由类型为[2.x.46]的修剪曲线组成的，它是构成曲面边界的[2.x.47]的集合，以及曲面本身的NURBS描述。我们将使用一个线条投影仪来将我们的三角形的边界与划定曲面的线联系起来。  为了提取所有的复合子形状，如线、壳或实体，我们求助于OpenCASCADE命名空间的一种方法。  [2.x.48]的输入是一个形状和一组空的[2.x.49]子形状，它将被填充为在给定拓扑形状中发现的所有复合形状。
*


* [1.x.45]
*
* 接下来的几个步骤比较熟悉，允许我们从外部VTK文件中导入一个现有的网格，并将其转换为一个交易三角。
*


* [1.x.46]
*
* 我们输出这个初始网格，将其保存为细化步骤0。
*


* [1.x.47]
*
* 导入的网格有一个单一的、位于三维空间的二维单元。我们现在要确保它是根据上面导入的CAD几何图形进行细化。为此，我们得到一个单元的迭代器，并给它分配manifold_id 1（见[2.x.50] "这个词汇条"）。我们还得到了一个指向其四个面的迭代器，并为每个面分配了manifold_id 2。
*


* [1.x.48]
*
* 一旦CAD几何体和初始网格都被导入和消化，我们就用CAD的曲面和曲线来定义投影仪，并将它们分配给刚才指定的流形ID。
*

*
* 第一个投影仪是用我们的CAD文件中的单线来定义的。  ArclengthProjectionLineManifold将确保位于导线上的每条网格边缘都被细化为一个位于导线上的点，并将其分割为两个位于边缘顶点之间的等距弧。我们首先检查导线矢量是否至少包含一个元素，然后为其创建一个Manifold对象。     
*一旦创建了投影仪，我们就把它分配给三角形的所有部分，manifold_id = 2。
*


* [1.x.49]
*
* 根据构造函数的[2.x.51]选项所指定的内容来创建曲面投影仪。特别是，如果surface_projection_kind的值等于[2.x.52]，我们选择[2.x.53] 新的网格点将在考虑的单元格/边的arycenter处最初生成，然后沿其法线方向投影到CAD表面。  NormalProjectionManifold构造器只需要一个形状和一个公差，然后我们把它分配给三角结构，用于所有具有id 1的流形的零件。
*


* [1.x.50]
*
* [2.x.54] surface_projection_kind值为[2.x.55]，我们选择[2.x.56]类。新的网格点将在所考虑的单元格/边的arycenter处初始生成，然后沿着[2.x.57]构造函数指定的方向投影到CAD表面上。在这种情况下，投影是沿着Y轴进行的。
*


* [1.x.51]
*
* 作为第三个选项，如果[2.x.58]的值是[2.x.59]，我们选择[2.x.60] 新的网格点将再次在所考虑的单元格/边的arycenter处初始生成，然后沿着一个估计为网格法线方向的方向投影到CAD表面。[2.x.61] 构造函数只需要一个形状（至少包含一个面）和一个公差。
*


* [1.x.52]
*
* 最后，我们使用良好的软件清洁性，确保这真的涵盖了[2.x.62]语句的所有可能的选项。如果我们得到任何其他的值，我们就直接中止程序。
*


* [1.x.53]
*
* [1.x.54] [1.x.55]。


*
* 这个函数对网格进行全局细化。在其他教程中，它通常也会分配自由度，并调整矩阵和向量的大小。这些任务在这里没有进行，因为我们没有在生成的三角网格上运行任何模拟。   
* 虽然这个函数看起来很简单，但这是我们对这个教程程序感兴趣的大部分工作实际发生的地方。特别是在细化定义船体表面的四边形和直线时，Triangulation类会询问我们分配给处理单个流形ID的各种对象，以确定新顶点应该位于何处。
*


* [1.x.56]
*
* [1.x.57] [1.x.58]。



* 输出我们的计算结果是一个相当机械的任务。这个函数的所有组成部分在前面已经讨论过了。
*


* [1.x.59]
*
* [1.x.60] [1.x.61]。


*
* 这是最主要的功能。它应该是不言自明的简短。
*


* [1.x.62]
*
* [1.x.63] [1.x.64]。



* 这是本程序的主要功能。它的基本结构和以前所有的教程程序一样，但通过新顶点放置的三种可能性来运行主类。
*


* [1.x.65]
* [1.x.66][1.x.67] 。


* 程序的执行会产生一系列的网格文件[2.x.63]，我们可以用任何可以读取VTK文件格式的常用可视化程序进行可视化。
* 下表说明了采用正常投影策略得到的结果。该表的前两行显示的是逐步细化的网格的侧视图，覆盖在精确几何形状的非常精细的渲染上。深红色和浅红色的区域只是表示当前网格或精细几何体更接近观察者；这种区别并没有任何特别深刻的意义。最后两张图片描述了第二行中显示的相同网格的正面视图（镜像到几何体的两侧）。
*

* [2.x.64]
* 从图片中可以看出，正如我们所预料的那样，当应用于具有明显曲率变化的表面时，普通的细化策略无法产生良好的形状的元素。这一点在船体的球体上尤其明显，所有的新点都被放置在球体的上部，而下部则完全没有被解决。
* 下表和上表一样，说明了采用方向性投影方法得到的结果，其中选择的投影方向是Y轴（在每张图片的左下方用一个小的黄色箭头表示）。
*

* [2.x.65]
* 图像证实，用定向投影得到的网格质量比沿表面法线投影得到的网格质量要高。然而，在球体底部观察到一些在Y方向上拉长的元素，那里的表面几乎与选择的投影方向平行。
* 最后的测试显示了使用面的法线投影的结果。
* [2.x.66]
* 这些图片证实了法线对网格投影的方法导致网格在整个细化步骤中保持均匀的间距。同时，这些网格很好地表现了原始的几何形状，甚至在灯泡的底部区域也是如此，这一点用定向投影仪或法线投影仪都不能很好地恢复。
*

* [1.x.68][1.x.69] [2.x.67] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-55_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19]
* [2.x.3]
* [1.x.20]


*
* [2.x.4] 作为这个程序的先决条件，你需要安装PETSc或Trilinos和p4est库。在[1.x.21]文件中描述了deal.II和这些附加库的安装情况。
* [1.x.22][1.x.23][1.x.24] 。
*

* 在[2.x.5]的基础上，本教程展示了如何使用MPI与PETSc或Trilinos的线性代数并行地解决具有多个组成部分的线性PDEs。为此，我们回到了 [2.x.6] 中讨论的斯托克斯方程。编写本教程的动机是在[2.x.7]（并行拉普拉斯）和[2.x.8]（针对时间相关问题的并行耦合斯托克斯与布西尼斯克）之间提供一个中间步骤（双关）。
* 本教程的学习成果是。
*
* - 你能够以并行方式解决有多个变量的PDEs，并能将其应用于不同的问题。
*
* - 你理解了最佳预处理的概念，并能够为一个特定的问题检查这个概念。
*
* - 你能够使用免费的计算机algreba系统SymPy(https://sympy.org)构建人造解决方案。
*
* - 你能够实现并行程序的各种其他任务：错误计算、编写图形输出等。
*
* - 你可以将矢量场、流线和矢量的轮廓线可视化。
* 我们正在求解满足斯托克斯方程的速度[2.x.9]和压力[2.x.10]，其读数为[1.x.25] 。
*
*

*[1.x.26][1.x.27]


* 确保你阅读（甚至更好：尝试）[2.x.11]中 "可能的扩展 "一节中描述的 "块状舒尔补强预处理"。就像那里描述的那样，我们将使用Krylovmethod和块状预处理来解决块状系统。
* 我们的目标是为线性系统构造一个非常简单的（也许是最简单的）最优预处理程序。如果预处理系统的迭代次数与网格大小无关，则该预处理程序被称为 "最优 "或 "最优复杂性"[2.x.12]。你可以把这个定义扩展到也要求与所使用的处理器数量无关（我们将在结果部分讨论这个问题），计算域和网格质量，测试案例本身，有限元空间的多项式程度，等等。
* 为什么恒定的迭代次数被认为是 "最佳 "的？假设被分解的PDE给出一个有N个未知数的线性系统。由于有限元离散化产生的矩阵是稀疏的，矩阵-向量乘积可以在O(N)时间内完成。先决条件的应用充其量也只能是O(N)(例如可以用多棱镜方法)。如果解决线性系统所需的迭代次数与[2.x.13]无关（因此也与N无关），那么解决该系统的总成本将是O(N)。不可能超越这个复杂度，因为即使是查看右手边的所有条目也已经需要O(N)的时间。更多信息见[2.x.14]，第2.5章（多网格）。
* 这里描述的预处理程序比[2.x.15]中描述的更简单，通常需要更多的迭代，从而需要更多的时间来解决。在考虑预处理程序时，最优性不是唯一重要的指标。但是一个最佳的、昂贵的预处理程序通常比一个便宜的、非最佳的预处理程序更受欢迎。这是因为，最终，随着网格尺寸越来越小，线性问题越来越大，前者将最终战胜后者。
*[1.x.28][1.x.29]
*

* 我们对线性系统进行预处理[1.x.30]。
*
*用块对角线预处理[1.x.31]来预处理。
* 其中[2.x.16]是舒尔补码。
* 通过对[2.x.17]的选择，假设我们准确地处理了[2.x.18]和[2.x.19]（这是一种 "理想化 "的情况），预处理的线性系统有三个独立于[2.x.20]的特征值，因此是 "最优 "的。  见[2.x.21]第6.2.1节（特别是第292页）。作为比较，使用[2.x.22]中理想版本的上块三角预处理(也用于[2.x.23])会使所有特征值都等于1。
* 我们将使用[2.x.24]中的逆运算的近似值，它（几乎）与[2.x.25]无关。在这种情况下，我们可以再次证明，特征值与[2.x.26]无关。对于Krylov方法，我们选择MINRES，它对分析很有吸引力(迭代次数被证明与[2.x.27]无关，见上述书中第6.2.1章的其余部分)，从计算的角度看很好(比GMRES等更简单、更便宜)，而且适用(矩阵和预处理器是对称的)。
* 对于近似，我们将使用质量矩阵在压力空间的CG解来近似[2.x.28]的作用。请注意，质量矩阵在光谱上等同于[2.x.29]。我们可以预期CGiterations的数量与[2.x.30]无关，即使使用像ILU这样简单的预处理程序。
* 对于速度块[2.x.31]的近似，我们将执行一个AMGV循环。在实践中，这种选择并不完全独立于[2.x.32]，这可以解释迭代次数的轻微增加。一个可能的解释是，最粗的层次将被精确解决，而最粗矩阵的层次数和大小是不可预测的。
*

*[1.x.32][1.x.33]


* 我们将根据经典的Kovasznay问题构建一个人造解，见[2.x.33]。这里是一个由X速度着色的解决方案的图像，包括速度的流线。
* [2.x.34]
* 但我们必须在这里作弊，因为我们不是在求解非线性的Navier-Stokes方程，而是求解没有对流项的线性Stokes系统。因此，为了重现完全相同的解决方案，我们使用Kovasznay问题的解决方案的制造方法。这将有效地把对流项移到右手边[2.x.35]。
* 右手边是用脚本 "reference.py "计算的，我们用精确的解来计算边界条件和误差。
*

* [1.x.34] [1.x.35]。



* [1.x.36]
*
* 下面这块出的代码与[2.x.36]相同，可以在PETSc和Trilinos之间切换。
*


*


* [1.x.37]
*
* [1.x.38] [1.x.39]。


*
* 我们需要一些辅助类来表示我们在介绍中描述的求解器策略。
*


*


* [1.x.40]
*
* 这个类暴露了通过函数[2.x.37]应用一个给定矩阵的逆的动作，在内部，逆不是明确形成的。相反，一个带有CG的线性求解器被执行。该类扩展了[2.x.38]中的InverseMatrix类，增加了一个指定预处理程序的选项，并允许在vmult函数中使用不同的矢量类型。
*


* [1.x.41]
*
* 该类是2x2矩阵的简单块状对角线预处理的模板类。
*


* [1.x.42]
*
* [1.x.43] [1.x.44]。


*
* 下面的类代表了测试问题的右手边和精确解。
*


*


* [1.x.45]
*
* [1.x.46] [1.x.47]。
* 主类与[2.x.39]非常相似，只是矩阵和向量现在是块状版本，我们为拥有的和相关的DoF存储一个[2.x.40]，而不是一个IndexSet。我们正好有两个IndexSets，一个用于所有速度未知数，一个用于所有压力未知数。
*


* [1.x.48]
*
* Kovasnay流被定义在域[-0.5, 1.5]^2上，我们通过将最小和最大值传递给[2.x.41]来创建这个域。
*


* [1.x.49]
*
* [1.x.50] [1.x.51]。
* 与[2.x.42]相比，块状矩阵和向量的构造是新的，与[2.x.43]这样的串行代码相比是不同的，因为我们需要提供属于我们处理器的行的集合。
*


* [1.x.52]
*
* 把所有昏暗的速度放入0区块，压力放入1区块，然后按区块重新排列未知数。最后计算一下我们每块有多少个未知数。
*


* [1.x.53]
*
* 我们根据我们想要创建块状矩阵和向量的方式，将本地拥有的和本地相关的DoF的IndexSet分割成两个IndexSets。
*


* [1.x.54]
*
* 设置边界条件和悬空节点的约束与 [2.x.44] 相同。尽管我们没有任何悬空节点，因为我们只进行全局细化，但把这个函数调用放进去仍然是个好主意，以防以后引入自适应细化。
*


* [1.x.55]
*
* 现在我们根据BlockDynamicSparsityPattern来创建系统矩阵。我们知道我们不会有不同速度分量之间的耦合（因为我们使用的是拉普拉斯而不是变形张量），也不会有压力与其测试函数之间的耦合，所以我们用一个表来把这个耦合信息传达给 [2.x.45]



* [1.x.56]
*
* 先决条件矩阵有不同的耦合（我们只在1,1块中填入质量矩阵），否则这段代码与上述system_matrix的构造相同。
*


* [1.x.57]
*
* owned_partitioning,
*


* [1.x.58]
*
* 最后，我们以正确的尺寸构建块状向量。带有两个[2.x.46]的函数调用将创建一个重影向量。
*


* [1.x.59]
*
* [1.x.60] [1.x.61].
* 这个函数集合了系统矩阵、预处理矩阵和右手边。代码是非常标准的。
*


* [1.x.62]
*
* [1.x.63] [1.x.64]
* 这个函数用MINRES求解线性系统，如介绍中所述，对两个对角线块采用块对角线预处理和AMG。该预处理程序对0,0块应用v循环，对1,1块应用质量矩阵的CG（Schur补码）。
*


* [1.x.65]
*
* InverseMatrix用于解决质量矩阵的问题。
*


* [1.x.66]
*
* 这是在上面定义的单个块的预处理基础上构造块预处理。
*


* [1.x.67]

* 有了这些，我们终于可以设置线性求解器并求解系统。
*


* [1.x.68]
*
* 与[2.x.47]一样，我们减去平均压力，以便对我们的参考方案进行误差计算，该方案的平均值为零。
*


* [1.x.69]
*
* [1.x.70] [1.x.71]
* 其余处理网格细化、输出和主循环的代码相当标准。
*


* [1.x.72]
*[1.x.73][1.x.74]


* 正如上面的讨论所预期的那样，迭代次数与处理器的数量无关，只与[2.x.48]有非常小的关系。
* [2.x.49]
* [2.x.50]
* 虽然PETSc的结果显示迭代次数不变，但使用Trilinos时，迭代次数增加。这可能是由于对AMG预处理程序的不同设置。出于性能的考虑，我们不允许在几千个未知数以下进行粗解。由于粗解器是精确求解（我们默认使用LU），层数的变化会影响到V型循环的质量。因此，对于较小的问题规模，V型循环更接近于精确求解器。
* [1.x.75][1.x.76][1.x.77] 。
*

*[1.x.78][1.x.79] 。


*玩弄平滑器、平滑步骤和Trilinos AMG的其他属性，以实现最佳的预处理程序。
*[1.x.80][1.x.81]


* 这一变化需要将外解器改为GMRES或BiCGStab，因为系统不再是对称的了。
* 你可以在对流项[2.x.52]中规定精确的流解为[2.x.51]。如果你把右手边设置为零，这应该会得到与原问题相同的解。
*[1.x.82][1.x.83] 。
*

* 到目前为止，这个教程程序在每一步中都会对网格进行全局细化。将[2.x.53]中的代码替换为类似的内容
* [1.x.84]
* 使得探索自适应网格细化变得简单。
*

* [1.x.85][1.x.86] [2.x.54] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-56_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28]
* [1.x.29]
* [2.x.3]
* [1.x.30][1.x.31][1.x.32] 。


*[1.x.33][1.x.34]


* 本教程的目的是为斯托克斯方程创建一个高效的线性求解器，并将其与其他方法进行比较。  在这里，我们将使用FGMRES与几何多栅作为预处理速度块，并将在结果部分显示，这是比[2.x.4]中使用的线性求解器（包括 "可能的扩展 "中描述的方案）更好的根本性方法。  从根本上说，这是因为只有多网格才有可能获得[2.x.5]的求解时间，其中[2.x.6]是线性系统的未知数的数量。通过使用Timer类，我们收集了一些统计数据来比较设置时间、求解时间和迭代次数。我们还计算错误，以确保我们所实现的是正确的。
* 让[2.x.7]和[2.x.8] 。斯托克斯方程在非维度形式下读作如下。
* [1.x.35]
*
* 注意，我们使用的是变形张量而不是[2.x.9]（关于两者之间的区别的详细描述可以在[2.x.10]中找到，但总的来说，变形张量更有物理意义，也更昂贵）。
*[1.x.36][1.x.37]
*

* 离散方程的微弱形式自然导致速度场和压力场的节点值的以下线性系统：[1.x.38] 。
*
* 我们的目标是比较几种解决方法。  虽然[2.x.11]使用 "舒尔补码法 "分两步解决了线性系统，但我们本着[2.x.12]中 "结果 "一节所述的方法的精神，使用FMGRES与有效的预处理器一次性解决了该系统。其思路如下：如果我们找到一个块状修饰器[2.x.13]，使矩阵
* [1.x.39]
*
* 是简单的，那么使用该预处理程序的迭代求解器将在几个迭代中得到解决。请注意，我们在这里做的是正确的预处理。  使用舒尔补码[2.x.14]，我们发现
* [1.x.40]
*
*是一个很好的选择。让[2.x.15]是[2.x.16]的近似值，[2.x.17]是[2.x.18]的近似值，我们看到[1.x.41]。
*
* 由于[2.x.19]的目的只是作为一个预处理程序，我们将在上面的方程中使用右边的近似值。
* 正如在[2.x.20]、[2.x.21]中所讨论的，其中[2.x.22]是压力质量矩阵，通过使用CG与ILU作为预处理程序来近似求解，而[2.x.23]是通过多种方法之一得到的：用CG和ILU作为预处理程序求解线性系统，仅仅使用ILU的一次应用，用CG和GMG（GeometricMultigrid，如[2.x.24]中所述）作为预处理程序求解线性系统，或者仅仅执行GMG的一个V-循环。
* 作为比较，我们还在整个系统上使用了直接求解器UMFPACK，而不是FGMRES，来比较我们的结果。  如果你想使用直接求解器（如UMFPACK），系统需要是可逆的。为了避免恒定压力带来的一维无效空间，我们将第一个压力未知数固定为零。这对迭代求解器来说是没有必要的。
*

*[1.x.42][1.x.43] 。


* 测试问题是一个 "制造的解决方案"（详见[2.x.25]），我们选择[2.x.26]和[2.x.27] .我们在域的整个边界上对速度应用迪里希特边界条件[2.x.28] .为了执行边界条件，我们可以直接使用我们的参考解决方案。
* 如果你在deal.II手册中查找创建一个源自[2.x.29]的类所需的内容，你会发现这个类有许多[2.x.30]函数，包括[2.x.31] [2.x.32] [2.x.33]等，所有这些都可以被重载。  deal.II的不同部分将需要这些特定函数中的不同部分。这在一开始会让人感到困惑，但幸运的是，你真正需要实现的只有[2.x.34]，函数类中的其他虚拟函数在默认情况下会调用你对[2.x.35]的实现。
* 请注意，我们的参考方案符合 [2.x.36] 。此外，压力被选择为平均值为零。  在[2.x.37]的 "制造解决方案的方法 "中，我们需要找到[2.x.38]，以便。
* [1.x.44]

* 使用上面的参考解，我们得到。
* [1.x.45]
*
* [1.x.46][1.x.47] 。


*因为我们在线性系统中没有强制要求平均压力为零，所以我们需要在求解后对解决方案进行后处理。为了做到这一点，我们使用[2.x.39]函数来计算压力的平均值，并将其从压力中减去。
*

*[1.x.48][1.x.49]


* 我们在这里实现几何多网格的方式只对速度变量（即上面描述的[2.x.40]矩阵）而不是压力进行执行。我们可以用不同的方法来实现这一点，包括将所有粗网格操作视为作用于[2.x.41]块系统，而我们只考虑左上角的块。另外，我们也可以通过真正只考虑整个有限元离散化的速度部分的线性系统来实现。后者是我们在这里想要使用的方式。
* 为了实现这一点，我们需要能够提出这样的问题："我可以只拥有一个DoFHandler的一部分吗？"。在写这个程序的时候，这是不可能的，所以为了满足我们的需求，我们只是为velocities创建一个单独的、第二个DoFHandler。然后，我们只根据这个第二DoFHandler为多网格预处理程序建立线性系统，并简单地将第一块（整体）向量转为整个第二DoFHandler的相应向量。为了实现这一目的，我们必须保证两个DoFHandler对象中的（速度）自由度排序的[1.x.50]是相同的。这实际上是通过首先在两个对象上分配自由度，然后在两个对象上使用相同的DoFRenumbering操作序列来实现的。
*

*[1.x.51][1.x.52]


* [2.x.42]和[2.x.43]之间的主要区别是，我们使用块解算器而不是[2.x.44]中使用的Schur补足方法。这种方法的细节可以在[2.x.45]的 "可能的扩展 "部分的 "Block Schur Complement preconditioner "小节中找到。对于速度块的预处理，我们从[1.x.53]中借用了一个名为[2.x.46]的类，该类可以选择求解[2.x.47]的逆，或者只对其应用一个预处理扫频，这分别为我们提供了一种昂贵和便宜的方法。
*

* [1.x.54] [1.x.55]。
* [1.x.56] [1.x.57]。



*


* [1.x.58]
*
* 我们需要包括以下文件来做计时。
*


* [1.x.59]
*
* 这包括我们使用几何多网格所需的文件
*


* [1.x.60]
*
* 为了方便在使用的不同求解器之间进行切换，我们声明了一个枚举，可以作为参数传递给主类的构造函数。
*


* [1.x.61]
*
* [1.x.62] [1.x.63].
* 类Solution是用来定义边界条件和计算数值解的误差的。请注意，我们需要定义数值和梯度，以便计算L2和H1误差。在这里，我们决定使用模板的特殊化来分离2D和3D的实现。   
* 请注意，前面的昏暗分量是速度分量，最后一个是压力。
*


* [1.x.64]
*
* 注意，对于梯度，我们需要返回一个Tensor<1,dim>。
*


* [1.x.65]
*
* [2.x.48]的实现。更多信息见介绍。
*


* [1.x.66]
*
* [1.x.67] [1.x.68]。



* 在下文中，我们将实现一个预处理程序，它扩展了 [2.x.49] 的结果部分所讨论的想法。具体来说，我们1.使用一个上块三角的预处理器，因为我们想使用右预处理。2.可选择允许使用速度块的内部求解器，而不是单一的预处理程序应用。3.不使用InverseMatrix，而是明确地调用SolverCG。这种方法也被用于ASPECT代码（见https://aspect.geodynamics.org），该代码在模拟地幔对流的背景下求解斯托克斯方程，该代码已被用于解决成千上万个处理器上的问题。   
* 构造函数中的bool标志[2.x.50]允许我们对速度块应用一次预处理，或者使用内部迭代求解器来代替更精确的近似。   
* 注意我们是如何跟踪内部迭代的总和（预处理程序的应用）的。
*


* [1.x.69]

*首先用S的近似值求解
*


* [1.x.70]
*
* 其次，应用右上方的块状物（B^T）。
*


* [1.x.71]
*
* 最后，要么用左上角的区块进行求解，要么只应用一个预处理器进行清扫
*


* [1.x.72]
*
* [1.x.73] [1.x.74]。
* 这是该问题的主要类别。
*


* [1.x.75]

* 仅为速度的有限元。
*


* [1.x.76]

* 整个系统的有限元。
*


* [1.x.77]
*
* [1.x.78] [1.x.79]。


*
* 这个函数设置了DoFHandler、矩阵、向量和Multigrid结构（如果需要）。
*


* [1.x.80]
*
* 主DoFHandler只需要活动的DoF，所以我们不在这里调用distribution_mg_dofs()。
*


* [1.x.81]
*
* 这个块结构将dim速度分量与压力分量（用于重新排序）分开。注意，我们有2个而不是像[2.x.51]中的dim+1块，因为我们的FES系统是嵌套的，dim速度分量作为一个块出现。
*


* [1.x.82]
*
* 速度从组件0开始。
*


* [1.x.83]
*
* 如果我们应用重排序来减少填充，ILU的表现会更好。对于其他求解器来说，这样做并没有什么好处。
*


* [1.x.84]
*
* 这确保所有的速度DoF在压力未知数之前被列举出来。这允许我们使用块来处理向量和矩阵，并允许我们为dof_handler和velocity_dof_handler获得相同的DoF编号。
*


* [1.x.85]
*
* 这将在一个单独的DoFHandler中分配速度空间的主动道夫和多网格道夫，如介绍中所述。
*


* [1.x.86]
*
* 下面的代码块初始化了MGConstrainedDofs（使用速度的边界条件），以及每个层次的稀疏模式和矩阵。MGLevelObject<T>的resize()函数将破坏所有现有的包含对象。
*


* [1.x.87]
*
* 下面利用分量掩码对速度的边界值进行插值，这在矢量值dealii [2.x.52]教程中进一步解释。
*


* [1.x.88]
*
* 正如介绍中所讨论的，我们需要固定压力变量的一个自由度以确保问题的可解性。我们在这里通过标记第一个压力自由度来做到这一点，该自由度的索引为n_u，是一个受约束的自由度。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。


*
* 在这个函数中，系统矩阵被组装起来。我们在(1,1)块中组装压力质量矩阵（如果需要），并在此函数结束时将其移出该位置。
*


* [1.x.92]
*
* 如果是真的，我们将在(1,1)块中组装压力质量矩阵。
*


* [1.x.93]
*
* [1.x.94] [1.x.95]。


*
* 在这里，就像在[2.x.53]中一样，我们有一个函数来组装多棱镜前处理程序所需的水平和界面矩阵。
*


* [1.x.96]
*
* 这个迭代器覆盖所有的单元格（不仅仅是活动的）。
*


* [1.x.97]
*
* [1.x.98] [1.x.99]。


*
* 这个函数根据你是否想使用ILU或GMG作为预处理程序来设置不同的东西。  这两种方法共享相同的求解器（FGMRES），但需要初始化不同的预处理器。在这里，我们不仅对整个求解函数进行计时，而且对预调节器的设置以及求解本身分别进行计时。
*


* [1.x.100]
*
*在这里，我们必须确保以 "足够好 "的精度来解决残差问题
*


* [1.x.101]
*
* 这是用来传递我们是否要在预处理程序中求解A的信息。  我们可以把它改为false，看看是否还有收敛性，如果有的话，程序会不会运行得更快或更慢。
*


* [1.x.102]
*
* 在各级之间转移操作者
*


* [1.x.103]
*
*设置粗略的网格求解器
*


* [1.x.104]
*
* Multigrid，当作为CG的预处理程序时，需要是一个对称的算子，所以平滑器必须是对称的
*


* [1.x.105]

* 现在，我们准备设置V型循环算子和多级预处理程序。
*


* [1.x.106]
*
* [1.x.107] [1.x.108]。


*
* 这个函数计算出解决方案的L2和H1误差。为此，我们需要确保压力的平均值为零。
*


* [1.x.109]
*
* 计算平均压力[2.x.54]，然后从每个压力系数中减去它。这将产生一个平均值为零的压力。这里我们利用了压力是分量[2.x.55]和有限元空间是节点的事实。
*


* [1.x.110]
*
* [1.x.111] [1.x.112]。


*
* 这个函数生成图形输出，就像在 [2.x.56] 中那样。
*


* [1.x.113]
*
* [1.x.114] [1.x.115]。


*
*斯托克斯类的最后一步是，像往常一样，生成初始网格的函数，并按各自的顺序调用其他函数。
*


* [1.x.116]
*
* [1.x.117] [1.x.118]。



* [1.x.119]
*
* SolverType的选项。umfpack fgmres_ilu fgmres_gmg
*


* [1.x.120]
*[1.x.121][1.x.122]


*[1.x.123][1.x.124] 。


* 我们首先运行代码，确认有限元解以混合有限元问题的误差分析所预测的正确速率收敛。鉴于足够平滑的精确解[2.x.57]和[2.x.58]，Taylor-Hood元[2.x.59]的误差应该是
* [1.x.125]
*例如见Ern/Guermond "有限元素的理论与实践"，第4.2.5节第195页。这确实是我们观察到的，以[2.x.60]元素为例（这就是代码中的做法，但在[2.x.61]中很容易改变）。
* [2.x.62]
* [1.x.126][1.x.127]。
*

* 让我们比较一下使用UMFPACK的直接求解方法和我们选择[2.x.63]和[2.x.64]的两种方法，即使用CG求解[2.x.65]的线性系统。CG的预处理程序是ILU或GMG。下表总结了求解器的迭代次数、时间和虚拟内存（VM）的峰值使用。
* [2.x.66]
* 从表中可以看出。
* 1. UMFPACK使用了大量的内存，特别是在3D中。而且，UMFPACK的优化并不随问题的大小而扩展。
* 2. 因为我们对[2.x.67]和[2.x.68]使用内部求解器，ILU和GMG需要相同数量的外部迭代。
* 3. ILU对[2.x.69]的（内部）迭代次数随着细化而增加，导致求解时间的线性扩展性差。相比之下，[2.x.70]的内部迭代次数在GMG中保持不变，导致解算时间几乎完美的缩放。
* GMG需要比ILU多一点的内存来存储水平和界面矩阵。
* [1.x.128][1.x.129] 。
*

*[1.x.130][1.x.131]


* 用高阶稳定的FE对进行实验，检查你是否观察到正确的收敛率。
*[1.x.132][1.x.133]
*

* 介绍中还概述了另一种对整个系统进行预处理的方案，即我们不选择上表中的[2.x.71]，而只选择[2.x.72]，分别用GMG或ILU的单一预处理程序。
* 这实际上是在代码中实现的。目前，布尔值[2.x.73]被设置为[2.x.74] 上面提到的选项是通过设置为[2.x.75]得到的。
* 你会发现，如果你以这种方式使用GMG，FGMRES的迭代次数在细化过程中是不变的。这意味着Multigrid是最优的，并且与[2.x.76]无关。
*

*[1.x.134][1.x.135] [2.x.77]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-57_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33]
* [2.x.3]
* [1.x.34]
* [2.x.4]
* [1.x.35][1.x.36][1.x.37] 。


*[1.x.38][1.x.39]


* 在本教程中，我们展示了如何用牛顿方法解决不可压缩的NavierStokes方程（NSE）。我们在这里考虑的流动是稳定的。在一个域[2.x.5]，[2.x.6]，具有片状光滑边界[2.x.7]，和一个给定的力场[2.x.8]，我们看到一个速度场[2.x.9]和一个压力场[2.x.10]，满足[1.x.40] 。
*
* 与[2.x.11]中讨论的斯托克斯方程不同，由于对流项的存在，NSE是一个非线性方程组 [2.x.12] 。计算数值解的第一步是将系统线性化，这将用牛顿方法完成。时间相关的问题在[2.x.13]中讨论，其中系统使用最后一个时间步骤的解进行线性化，不需要非线性解。
* [1.x.41][1.x.42] 。
*

* 我们定义一个非线性函数，其根是NSE的解，由[1.x.43]定义。
*
* 假设初始猜测足够好，可以保证牛顿迭代的收敛性，并表示为[2.x.14]，牛顿对向量函数的迭代可以定义为[1.x.44] 。
*
* 其中[2.x.15]是步骤[2.x.16]中的近似解，[2.x.17]代表上一步的解，[2.x.18]是在[2.x.19]处评估的雅各布矩阵。类似的迭代可以在[2.x.20]找到。
* 牛顿迭代公式意味着新闻解决方案是通过在旧的解决方案中加入更新项来获得的。我们不评估雅各布矩阵并取其倒数，而是将更新项视为一个整体，即[1.x.45] 。
*
*其中[2.x.21] 。
* 我们可以通过解决系统[1.x.46]来找到更新项。
*
* 这里，前一个方程的左边代表[2.x.22]沿[2.x.23]在[2.x.24]的方向梯度。根据定义，方向性梯度由[1.x.47]给出。
*
* 因此，我们得出线性化系统：[1.x.48] 。
*
* 其中[2.x.25]和[2.x.26]是前次迭代的解。此外，第二个方程的右手边不是零，因为离散解不完全是无发散的（连续解是无发散的）。这里的右手边作为一个修正，导致速度的离散解沿着牛顿迭代是无发散的。在这个线性系统中，唯一的未知数是更新项[2.x.27]和[2.x.28]，我们可以使用与[2.x.29]类似的策略（并以同样的方式推导出弱形式）。
* 现在，可以用牛顿迭代法来解决更新项。
* [2.x.30] [2.x.31] 初始化。初始猜测 [2.x.32] 和 [2.x.33] ，公差 [2.x.34] ； [2.x.35] [2.x.36] 线性求解计算更新项 [2.x.37] 和 [2.x.38] ； [2.x.39] [2.x.40] 更新近似值。       [2.x.41] 和 [2.x.42] ; [2.x.43] [2.x.44] 检查残差规范。  [2.x.45] : [2.x.46] [2.x.47] 如果 [2.x.48] , 停止。[2.x.49] [2.x.50] 如果 [2.x.51] ，回到步骤2。[2.x.52] [2.x.53] [2.x.54] [2.x.55]。
* [1.x.49][1.x.50]。


* 初始猜测需要足够接近牛顿方法收敛的解；因此，找到一个好的起始值对非线性求解器是至关重要的。
* 当粘度[2.x.56]较大时，可以通过解决带有粘度[2.x.57]的斯托克斯方程来获得一个好的初始猜测。虽然与问题有关，但对于这里考虑的测试问题来说，这对[2.x.58]有效。
* 然而，如果粘度较小，对流项[2.x.59]将占主导地位，如测试案例2的[2.x.60]。  在这种情况下，我们使用延续法建立一系列的辅助NSE，其粘度接近于目标NSE中的粘度。相应地，我们建立一个[2.x.61]与[2.x.62]的序列，如果[2.x.65]较小，则接受两个NSE的粘度[2.x.63]和[2.x.64]的解是接近的。  然后，我们使用带有粘度的NSE[2.x.66]的解作为带有[2.x.67]的NSE的初始猜测。这可以被认为是一个从斯托克斯方程到我们要解决的NSE的阶梯。
* 也就是说，我们首先解决一个斯托克斯问题[1.x.51] 。
*
* 以得到[1.x.52]的初始猜测。
*
* 这里[2.x.68]相对较大，因此带粘度的斯托克斯问题的解[2.x.69]可以作为牛顿迭代中NSE的初始猜测。
*然后是[1.x.53]的解。
*
*作为[1.x.54]的初始猜测。
*
* 这个过程是用实验确定的粘度序列[2.x.70]重复进行的，这样最终的解可以作为牛顿迭代的初始猜测。
*[1.x.55][1.x.56]
*

*在牛顿迭代的每一步，问题的结果是解决形式为[1.x.57]的无鞍点系统。
*
* 这个系统矩阵与[2.x.71]中的矩阵具有相同的块结构。然而，左上角的矩阵[2.x.72]并不是对称的，因为有非线性项。我们可以不求解上述系统，而是求解等价系统[1.x.58] 。
*
*有一个参数[2.x.73]和一个可逆矩阵[2.x.74] 。这里[2.x.75]是增强的拉格朗日项；详见[1]。
*用[2.x.76]表示新系统的系统矩阵，用[2.x.77]表示右侧，我们用右侧预处理[2.x.78]反复求解为[2.x.79]，其中[1.x.59]

*与[2.x.80]，[2.x.81]是对应的Schur补码[2.x.82]。我们让[2.x.83]，其中[2.x.84]是压力质量矩阵，那么[2.x.85]可以被[1.x.60]所近似。
*
* 详见[1]。
* 我们将[2.x.86]分解为[1.x.61]。
*
* 这里需要两个不精确的求解器，分别用于[2.x.87]和[2.x.88]（见[1]）。由于压力质量矩阵是对称的和正定的，用ILU作为预处理程序的CG适合用于[2.x.89]。为了简单起见，我们对[2.x.90]使用直接求解器UMFPACK。最后一个成分是与[2.x.91]的疏散矩阵-向量乘积。我们不计算[2.x.92]中增强拉格朗日项的矩阵乘积，而是采用Grad-Div稳定化[2.x.93]，如[2]中所解释的。
*[1.x.62][1.x.63]。
*

* 我们使用盖子驱动的空腔流作为我们的测试案例；详见[3]。计算域是单位方格，右手边是[2.x.94] 。边界条件是[1.x.64] 。
*
* 当解决这个问题时，误差由非线性误差（来自牛顿迭代）和离散化误差（取决于网格大小）组成。非线性部分随着牛顿迭代的进行而减少，离散化误差随着网格的细化而减少。在这个例子中，粗网的解被转移到连续的细网中，并作为初始猜测使用。因此，非线性误差总是低于牛顿迭代的容忍度，离散化误差也随着每次网格细化而减少。
* 在循环内部，我们涉及三个求解器：一个用于[2.x.95]，一个用于[2.x.96]和一个用于[2.x.97]。前两个求解器在预处理程序中被调用，外部求解器给出更新项。总体收敛性由非线性残差控制；由于牛顿方法不需要精确的雅各布，我们采用了FGMRES，其外部线性求解器的相对公差仅为1e-4。事实上，我们对这个系统使用了截断的牛顿求解。正如在[2.x.98]中所描述的，内部线性求解也不需要做得非常精确。这里我们使用CG，压力质量矩阵的相对公差为1e-6。正如预期的那样，我们仍然看到非线性残差收敛到了1e-14。另外，我们使用了一个简单的线搜索算法来实现牛顿方法的全球化。
* [2.x.99]和[2.x.100]的腔体参考值分别来自[4]和[5]，其中[2.x.101]是雷诺数，可以位于[8]。这里的粘度是由[2.x.102]定义的。即使我们仍然可以找到[2.x.103]的解决方案，并且这些参考文献包含了用于比较的结果，我们在这里的讨论仅限于[2.x.104]。这是因为从[2.x.105]附近开始，解不再是静止的，而是变成了周期性的，详见[7]。
* [1.x.65][1.x.66] 。
* [2.x.106]
* [2.x.107] An Augmented Lagrangian-Based Approach to the Oseen Problem, M. Benzi and M. Olshanskii, SIAM J. SCI. COMPUT.COMPUT.2006 [2.x.108] Efficient augmented Lagrangian-type preconditioning for the Oseen problem using Grad-Div stabilization, Timo Heister and Gerd Rapin [2.x.109] http://www.cfd-online.com/Wiki/Lid-driven_cavity_problem [2.x.110] High-Re solution for incompressible flow using the Navier-Stokes Equations and a Multigrid Method, U. Ghia, K. N. Ghia, and C. T. Shin [2.x.111] 高雷诺数下二维稳定不可压缩驱动空腔流的数值解，E. Erturk, T.C. Corke and C. Gokcol [2.x.112] 三维不可压缩Navier-Stokes方程的隐式加权ENO方案，Yang等人，1998 [2.x.113] 二维盖子驱动空腔问题再探讨，C. Bruneau and M. Saad, 2006 [2.x.114] https://en.wikipedia.org/wiki/Reynolds_number [2.x.115]
*

* [1.x.67] [1.x.68]。
* [1.x.69][1.x.70] 。


*
* 像往常一样，我们首先包括一些著名的文件。
*


* [1.x.71]
*
*为了在网格之间转移解决方案，包括这个文件。
*


* [1.x.72]
*
* 这个文件包括UMFPACK：直接求解器。
*


* [1.x.73]

* 还有ILU预处理程序的那个。
*


* [1.x.74]
*
* [1.x.75] [1.x.76]。


*
* 这个类管理介绍中描述的矩阵和向量：特别是，我们为当前的解决方案、当前的牛顿更新和直线搜索更新存储了一个BlockVector。  我们还存储了两个AffineConstraints对象：一个是强制执行Dirichlet边界条件的对象，另一个是将所有边界值设为零的对象。第一个约束解向量，第二个约束更新（也就是说，我们从不更新边界值，所以我们强制相关的更新向量值为零）。
*


* [1.x.77]
*
* [1.x.78] [1.x.79]。



* 在这个问题中，我们设定沿空腔上表面的速度为1，其他三面墙的速度为0。右边的函数为零，所以我们在本教程中不需要设置右边的函数。边界函数的分量数为 [2.x.116] 。我们最终将使用[2.x.117]来设置边界值，这就要求边界值函数的分量数与解相同，即使没有全部使用。换句话说：为了让这个函数高兴，我们为压力定义边界值，即使我们永远不会实际使用它们。
*


* [1.x.80]
*
* [1.x.81] [1.x.82].
* 正如介绍中所讨论的，Krylov迭代方法中的预处理器是作为一个矩阵-向量乘积算子实现的。在实践中，舒尔补码预处理器被分解为三个矩阵的乘积（如第一节所述）。第一个因素中的[2.x.118]涉及到线性系统[2.x.119]的解。在这里，为了简单起见，我们通过一个直接求解器来解决这个系统。第二个因素中涉及的计算是一个简单的矩阵-向量乘法。舒尔补码[2.x.120]可以被压力质量矩阵很好地近似，其逆值可以通过不精确求解器得到。因为压力质量矩阵是对称的和正定的，我们可以用CG来解决相应的线性系统。
*


* [1.x.83]
*
* 我们可以注意到，左上角的矩阵逆的初始化是在构造函数中完成的。如果是这样的话，那么预处理程序的每一次应用就不再需要计算矩阵因子了。
*


*


* [1.x.84]
*
* [1.x.85] [1.x.86]
* [1.x.87] [1.x.88]
* 该类的构造函数看起来与 [2.x.121] 中的构造函数非常相似。唯一的区别是粘度和增强的拉格朗日系数 [2.x.122] 。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]
* 这个函数初始化DoFHandler，列举当前网格的自由度和约束。
*


* [1.x.92]
*
* 第一步是将DoF与给定的网格联系起来。
*


* [1.x.93]
*
* 我们对组件进行重新编号，使所有的速度DoFs排在压力DoFs之前，以便能够将解向量分成两个块，在块预处理程序中分别访问。
*


* [1.x.94]
*
* 在牛顿方案中，我们首先对初始步骤得到的解施加边界条件。为了确保边界条件在牛顿迭代过程中保持满足，在更新时使用零边界条件 [2.x.123] 。因此，我们设置了两个不同的约束对象。
*


* [1.x.95]
*
* [1.x.96] [1.x.97].
* 在每个网格上的SparsityPattern和线性系统的大小是不同的。这个函数在网格细化后初始化它们。
*


* [1.x.98]
*
* [1.x.99] [1.x.100]。
* 这个函数建立了我们目前工作的系统矩阵和右手边。[2.x.124]参数用于确定我们应用哪一组约束（初始步骤为非零，其他为零）。[2.x.125]参数分别决定是组装整个系统还是只组装右手边的向量。
*


* [1.x.101]
*
* 对于线性化系统，我们为现在的速度和梯度，以及现在的压力建立临时存储。在实践中，它们都是通过其在正交点的形状函数获得的。
*


*


* [1.x.102]
*
* 装配类似于 [2.x.126] 。一个以gamma为系数的附加项是扩增拉格朗日（AL），它是通过grad-div稳定化组装的。  正如我们在介绍中所讨论的，系统矩阵的右下块应该为零。由于压力质量矩阵是在创建预处理程序时使用的，所以我们在这里组装它，然后在最后把它移到一个单独的SparseMatrix中（与[2.x.127]相同）。
*


* [1.x.103]
*
* 最后我们把压力质量矩阵移到一个单独的矩阵中。
*


* [1.x.104]
*
* 注意，将这个压力块设置为零并不等同于不在这个块中装配任何东西，因为这里的操作将（错误地）删除从压力作用力的悬挂节点约束中进来的对角线条目。这意味着，我们的整个系统矩阵将有完全为零的行。幸运的是，FGMRES处理这些行没有任何问题。
*


* [1.x.105]
*
* [1.x.106] [1.x.107].
* 在这个函数中，我们使用FGMRES和在程序开始时定义的块状预处理程序来解决线性系统。我们在这一步得到的是解向量。如果这是初始步骤，解向量为我们提供了纳维尔-斯托克斯方程的初始猜测。对于初始步骤，非零约束被应用，以确保边界条件得到满足。在下面的步骤中，我们将求解牛顿更新，所以使用零约束。
*


* [1.x.108]
*
* [1.x.109] [1.x.110]
* 在粗略的网格上找到一个好的初始猜测后，我们希望通过细化网格来减少误差。这里我们做了类似于[2.x.128]的自适应细化，只是我们只对速度使用Kelly估计器。我们还需要使用SolutionTransfer类将当前的解转移到下一个网格。
*


* [1.x.111]
*
* 首先，DoFHandler被设置，约束被生成。然后我们创建一个临时的BlockVector [2.x.129] ，其大小与新网格上的解决方案一致。
*


* [1.x.112]
*
* 将解决方案从粗网格转移到细网格，并对新转移的解决方案应用边界值约束。注意，present_solution仍然是对应于旧网格的一个向量。
*


* [1.x.113]
*
* 最后设置矩阵和向量，并将present_solution设置为插值的数据。
*


* [1.x.114]
*
* [1.x.115] [1.x.116]
* 这个函数实现了牛顿迭代，给定公差，最大迭代次数，以及要做的网格细化次数。   
* 参数[2.x.130]告诉我们是否需要[2.x.131]，以及哪一部分，系统矩阵或右手边的矢量，应该被组装起来。如果我们做直线搜索，在最后一次迭代中检查残差准则时，右手边已经被组装起来了。因此，我们只需要在当前迭代中装配系统矩阵。最后一个参数[2.x.132]决定了是否应该产生图形输出。
*


* [1.x.117]
*
* 为了确保我们的解决方案越来越接近精确的解决方案，我们让解决方案用权重[2.x.133]更新，使新的残差小于上一步的残差，这在下面的循环中完成。这与[2.x.134]中使用的线搜索算法相同。
*


* [1.x.118]
*
* [1.x.119] [1.x.120]。
* 这个函数将通过使用延续法为我们提供一个初始猜测，正如我们在介绍中讨论的那样。雷诺数被逐级增加[2.x.135]，直到我们达到目标值。通过实验，斯托克斯的解足以成为雷诺数为1000的NSE的初始猜测，所以我们从这里开始。  为了确保前一个问题的解决方案与下一个问题足够接近，步长必须足够小。
*


* [1.x.121]
*
* [1.x.122] [1.x.123]。
* 这个函数与[2.x.136]中的相同，只是我们为输出文件选择一个也包含雷诺数（即在当前背景下的粘度的倒数）的名称。
*


* [1.x.124]
*
* [1.x.125] [1.x.126]。
* 在我们的测试案例中，我们不知道分析解。该函数输出沿[2.x.137]和[2.x.138]的速度分量，因此可以与文献中的数据进行比较。
*


* [1.x.127]

* [1.x.128] [1.x.129]。
* 这是本程序的最后一步。在这一部分，我们分别生成网格和运行其他函数。最大细化可以通过参数来设置。
*


* [1.x.130]
*
* 如果粘度小于[2.x.139]，我们必须首先通过延续法搜索一个初始猜测。我们应该注意的是，搜索总是在初始网格上进行的，也就是这个程序中的[2.x.140]网格。之后，我们只需做与粘度大于[2.x.141]时相同的工作：运行牛顿迭代，细化网格，转移解决方案，并重复。
*


* [1.x.131]
*
* 当粘度大于1/1000时，斯托克斯方程的解作为初始猜测已经足够好。如果是这样，我们就不需要用延续法来寻找初始猜测。牛顿迭代可以直接开始。
*


*


* [1.x.132]
* [1.x.133][1.x.134] 。


* 现在我们用上面讨论的方法来解决有粘度的纳维尔-斯托克斯方程 [2.x.142] 和 [2.x.143] 。
* [1.x.135][1.x.136] 。
*

* 在第一个测试案例中，粘度被设定为[2.x.144]。正如我们在导论中所讨论的，初始猜测是相应的斯托克斯问题的解。在下面的表格中，显示了每一个网格上的牛顿迭代的残差。表中的数据显示，牛顿迭代的结果是四等分的。
* [2.x.145]
*


*


*

* 下面的数字显示了生成网格的顺序。对于[2.x.146]的情况，初始猜测是通过在[2.x.147]网格上求解斯托克斯得到的，并且网格是自适应细化的。在不同的网格之间，粗的网格中的解被内插到细的网格中，作为初始猜测使用。
* [2.x.148]
* 这张图是用[2.x.149]绘制的盖子驱动的空腔的流线图结果。[2.x.150]
* 然后将该解与来自[4]的参考解进行比较，参考解的数据可以在文件 "ref_2d_ghia_u.txt "中找到。
* [2.x.151]
* [1.x.137][1.x.138] 。
*

* 牛顿迭代法需要一个良好的初始猜测。然而，当雷诺数很大时，非线性项占主导地位，因此，斯托克斯方程的解可能与精确解相去甚远。如果斯托克斯解作为初始猜测，收敛性就会丧失。下图显示了非线性迭代被卡住，残差在进一步迭代中不再减少。
* [2.x.152]
* 因此，初始猜测必须通过延续法来获得，这在介绍中已经讨论过了。这里延续法的步长，即[2.x.153]，为2000，初始网格的大小为[2.x.154]。在获得初始猜测后，如前述测试案例一样对网格进行细化。下图显示，在每次细化中，牛顿迭代都有二次收敛。为解决这个测试案例，共执行了52步牛顿迭代。
* [2.x.155]
* 我们还显示了每个网格上牛顿迭代的每一步的残差。二次收敛的情况在表中清晰可见。
* [2.x.156]
*


*


*

* 生成的网格序列看起来像这样。[2.x.157] 我们将我们的解决方案与[5]的参考解决方案进行比较。[2.x.158] 下图是图形结果。[2.x.159]
* 此外，误差由非线性误差和离散化误差组成，前者随着牛顿迭代的进行而减少，后者则取决于网格大小。这就是为什么我们必须细化网格并在下一个更细的网格上重复牛顿迭代。从上表中，我们可以看到每个网格上的残差（非线性误差）都在1e-12以下，但下面的图片显示了在随后的细网格上解的差异。
* [2.x.160]
* [1.x.139]
* [1.x.140][1.x.141] 。
*

*[1.x.142][1.x.143]。


* 很容易比较目前实现的线性求解器和仅仅使用UMFPACK来解决整个线性系统。你需要去掉包含常数压力的nullspace，这在 [2.x.161] 中已经完成。更有趣的是与其他最先进的预处理程序如PCD的比较。事实证明，这里的预处理器是非常有竞争力的，在论文[2]中可以看到。
* 下表显示了我们的迭代方法（FGMRES）与直接求解器（UMFPACK）之间的时间结果，整个系统的粘度设置为1/400。尽管我们在迭代求解器中的速度块使用了相同的直接求解器，但它的速度要快得多，消耗的内存也少。这在三维中会更加明显。
* [2.x.162]
*

*[1.x.144][1.x.145] 。


* 该代码被设置为也可以在3D中运行。当然，参考值是不同的，例如，见[6]。高分辨率的计算在这个例子中是不可行的，因为速度块的直接求解器在三维中不能很好地工作。相反，需要一个基于代数或几何多重网格的并行求解器。见下文。
* [1.x.146][1.x.147] 。
*

* 对于较大的计算，特别是三维计算，有必要实现MPI并行求解器和预处理器。一个好的起点是[2.x.163]，它在斯托克方程的速度块上使用代数多网格。另一个选择是看一下[1.x.148]中的代码列表，它已经包含了并行的纳维-斯托克斯求解器。
*

* [1.x.149][1.x.150] [2.x.164] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-58_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27]
* [2.x.3]
* [1.x.28][1.x.29]。
* [1.x.30][1.x.31][1.x.32] 。


* 一个函数[2.x.4]和一个势[2.x.5]的[1.x.33]是量子力学和非线性光学中经常使用的一个模型。如果用适当的量子进行测量（以便[2.x.6]），则读作如下。
* [1.x.34]
* 如果没有电位，即[2.x.7]，那么它可以用来描述光在光纤中的传播。如果[2.x.8]，该方程有时也被称为[1.x.35]，可用于模拟[1.x.36]的时间依赖行为。
* 对于这个特定的教程程序，方程的物理解释对我们来说不是很重要。相反，我们想用它作为一个模型，让我们解释两个方面。
*
* - 它是一个[1.x.37]的[2.x.9]。我们以前在[2.x.10]中看到过复值方程，但那里选择了将方程分成实部和虚部，结果是解决了两个实值方程的系统。相比之下，这里的目标是展示如何解决我们将所有东西都保留为复数的问题。
*
* 这个方程是一个很好的模型问题，可以解释[1.x.38]如何工作。这是因为它有一些具有根本不同性质的项：一方面，[2.x.11]是一个常规的空间算子，其方式我们以前已经见过多次；另一方面，[2.x.12]没有空间或时间导数，即它是一个纯粹的局部算子。事实证明，我们对这些项中的每一项都有有效的方法（特别是，我们对后者有分析解），而且我们可能最好对这些项进行不同的、单独的处理。我们将在下文中详细解释这一点。
*


*[1.x.39][1.x.40]


* 乍一看，这些方程似乎是抛物线，与热力方程相似（见[2.x.13]），因为只有一个时间导数和两个空间导数。事实上，如果我们暂时假设势[2.x.14]和[2.x.15]不是正确的解释，就更容易看出这一点。那么我们就会有这样的方程
* [1.x.41]
* 如果我们把解分成实部和虚部，[2.x.16]和[2.x.17]，那么我们可以像在[2.x.18]中一样，把一个方程分成实部和虚部。
* [1.x.42]
* 毫不奇怪，时间导数前面的因子[2.x.19]将方程的实部和虚部结合起来。如果我们想进一步理解这个方程，可以用其中一个方程的时间导数，例如
* [1.x.43]
*（这里我们假设，至少在某种形式上，我们把空间和时间导数相抵消），然后把另一个方程插入其中。
* [1.x.44]
* 这个方程是双曲线的，在性质上与波浪方程相似。如果你看一下这个程序的 "结果 "部分的视频，这一点也会很明显）。此外，我们也可以得出与[2.x.20]相同的方程。因此，对于NLSE来说，更好的假设是将其视为一个双曲的波传播方程，而不是像热方程那样的扩散方程。你可能会问，算子[2.x.21]以正号出现，而在波浪方程中，[2.x.22]是负号，这是否正确？这确实是正确的。在与测试函数相乘并通过部分积分后，我们希望得到一个正的（半）定义形式。因此，从[2.x.23]我们得到[2.x.24]。同样，经过两次积分，我们从[2.x.25]得到[2.x.26]的形式。在这两种情况下，我们都能得到所需的正号。)
* 当然，实数NLSE也有[2.x.27]和[2.x.28]项。然而，这些都是低阶的空间衍生物，虽然它们显然很重要，但它们并不改变方程的特征。
* 在任何情况下，本讨论的目的是要弄清楚什么样的时间步进方案可能适合该方程。结论是，作为一个双曲型方程，我们需要选择一个满足CFL型条件的时间步长。如果我们使用显式方法（我们不会这样做），我们将不得不研究与空间运算器相对应的矩阵的特征值。如果你跟随视频讲座的讨论( [2.x.29]，那么你会记得，模式是需要确保[2.x.30]，其中[2.x.31]是时间步长，[2.x.32]是网格宽度，而[2.x.33无论你采用原始方程([2.x.34])还是只对实部或虚部进行重构，结果都是如果我们要使用显式时间步长方法，我们需要选择[2.x.35]。这是不可行的，原因与[2.x.36]中的热方程相同。这将产生不切实际的小的时间步长，甚至只有适度精细的网格。相反，我们必须使用隐式时间步长方法，然后可以选择一个更平衡的[2.x.37]。事实上，我们将使用隐式的Crank-Nicolson方法，正如我们之前在[2.x.38]中对正波方程所做的那样。
*

*[1.x.45][1.x.46]


* [2.x.39]
* 如果我们把NLSE看作是一个普通微分方程，其中的右手边恰好有空间导数，即把它写为
* [1.x.47]
* 人们可能会想通过对时间间隔[2.x.40]的两边积分来 "正式解决 "它，并得到
* [1.x.48]
* 当然，这不是那么简单的：积分中的[2.x.41]仍在根据微分方程随时间变化，所以我们不能只是评估积分（或通过正交轻松近似），因为我们不知道[2.x.42]。但我们可以用下面的单独贡献来写，这将使我们能够分别处理不同的条款。
* [1.x.49]
* 现在可以把这个方程解读为以下方式。对于每个时间间隔[2.x.43]，溶液中的变化[2.x.44]由三个贡献组成。
*
* - 拉普拉斯算子的贡献。
*
* - 势的贡献[2.x.45] 。
*
* - "相位 "项的贡献 [2.x.46] .
* [1.x.50]是现在的一种近似技术，允许我们分别处理这些贡献中的每一个。(如果我们想的话。在实践中，我们将把前两项放在一起处理，而把最后一项分开。但这是一个细节，从概念上讲，我们可以以不同的方式处理所有这些贡献）。)为此，让我们介绍三个独立的 "解决方案"。
* [1.x.51]
*
* 这三个 "解决方案 "可以被认为是满足了以下的微分方程。
* [1.x.52]
* 换句话说，它们都是以[2.x.47]为起点的轨迹，并恰好整合了三条准则中的一条的影响。在我们的时间间隔内，这些条款的增量分别是[2.x.49]、[2.x.50]和[2.x.51] 。
* 现在我们可以合理地假设（这是一个近似值！），由于所有这三种效应引起的变化是由三个单独的增量的总和来近似的。
* [1.x.53]
* 这个直觉确实是正确的，尽管这个近似并不精确：准确的左手边和术语[2.x.52]之间的差异（即从[2.x.54]移动到[2.x.55]时准确解[1.x.54]的增量与右手边三部分组成的增量之间的差异），与[2.x.56]成正比。换句话说，这种方法引入了一个大小为[2.x.57]的误差。到目前为止，我们所做的一切都没有在时间或空间上离散化，所以[1.x.55]的误差将是[2.x.58]加上我们在近似积分时犯的任何错误（时间离散化误差）加上我们在近似[2.x.59]的空间依赖关系时犯的任何错误（空间误差）。
* 在我们继续讨论运算符拆分之前，让我们谈谈为什么要这样做？答案很简单。对于[2.x.60]的一些独立方程，我们可能有办法比把所有东西放在一起一次解决更有效地解决它们。例如，在目前的情况下，尤其是与之相关的。[2.x.61]的方程式，即。
* [1.x.56]
* 或等价的。
* [1.x.57]
* 可以准确地解决：方程的解法是
* [1.x.58]
* 如果(i)你把这个解插入微分方程，(ii)意识到[2.x.62]的幅度是常数，即指数中的[2.x.63]项实际上等于[2.x.64]，这就很容易看出。换句话说，[2.x.65]的ODE的解只改变了它的[1.x.59]，但复值函数[2.x.66]的[1.x.60]保持不变。这使得计算[2.x.67]特别方便：我们实际上不需要解决任何ODE，我们可以用手写下解决方案。使用算子拆分方法，没有任何一种计算[2.x.68]的方法需要处理非线性项和所有相关的不愉快：只要我们允许自己使用算子拆分方法，我们就可以摆脱只解决[1.x.61]的问题了。
* 其次，如果不同的项所描述的不同的物理效应具有不同的时间尺度，我们经常使用算子拆分。例如，想象一下，我们确实有某种扩散方程的情况。扩散作用缓慢，但如果[2.x.69]很大，那么[2.x.70]项的 "相位旋转 "作用很快。如果我们把一切都放在一起处理，这就意味着必须采取相当小的时间步长。但是有了算子分割，我们可以对扩散采取大的时间步长[2.x.71]，并且（假设我们没有分析解）使用具有许多小时间步长的ODE求解器来整合从[2.x.73]到[2.x.74]的 "相位旋转 "方程。换句话说，算子分割使我们能够将慢速和快速的时间尺度结合起来，并以不同的方式处理它们，并根据每种情况调整方法。
*

*[1.x.62][1.x.63]


* 虽然上述方法允许并行计算三个贡献[2.x.75]，但如果我们愿意，如果我们不让[2.x.76]的轨迹全部从[2.x.77]开始，而是让[2.x.78]的轨迹从[2.x.79]的[1.x.64]开始，即[2.x.80]，该方法可以变得稍微准确和容易实施。]，而是让[2.x.78]的轨迹从[2.x.79]的轨迹的[1.x.64]开始，即[2.x.80]；同样，我们将从[2.x.81]的轨迹的终点开始，即[2.x.83]。这种方法被称为 "Lie splitting"，其误差顺序与上述方法相同，即分割误差为[2.x.84] 。
* 运算符拆分的这一变化可以写成以下内容（仔细比较初始条件和上面的条件）。
* [1.x.65]
* 显然，虽然上面的公式意味着我们应该以这种特定的顺序来解决这些问题，但首先解决轨迹3，然后是2，然后是1，或任何其他的排列组合也同样有效。
* 然后，这些方程的综合形式是
* [1.x.66]
* 从实用的角度来看，这样做的好处是我们需要保持较少的解向量。一旦[2.x.85]被计算出来，我们就不再需要[2.x.86]了；一旦[2.x.87]被计算出来，我们就不再需要[2.x.88]了。一旦[2.x.89]被计算出来，我们就可以直接称之为[2.x.90]，因为如果你把第一个方程插入第二个方程，然后再插入第三个方程，你会看到[2.x.91]的右手边现在包含所有三个物理效应的贡献。
* [1.x.67]
* 换句话说，Lie拆分法比上述的原始方法简单得多，因为数据处理要简单得多。
*

*[1.x.68][1.x.69] 。


* 如上所述，Lie拆分只具有[2.x.94]的准确性。如果我们使用一阶时间微分，例如使用显式或隐式Eulermethods来解决[2.x.95]的微分方程，这是可接受的。这是因为这些时间积分方法引入了与[2.x.96]本身成正比的误差，因此分割误差与我们无论如何都会引入的误差成正比，并不会减少整体收敛的顺序。
* 但我们通常希望使用更高的阶数
*
* - 例如，[1.x.70]或[1.x.71]方法
*
* 因为这些方法通常不会比简单的欧拉方法更昂贵。如果我们使用[2.x.97]的时隙方法，但由于算子分裂而再次失去准确性，那将是一种耻辱。
*这就是[1.x.72]方法的作用。如果我们只有两部分，就更容易解释，因此让我们把拉普拉斯算子和势的影响合二为一，把相位旋转合二为一。事实上，这就是我们在代码中要做的，因为用拉普拉斯方程求解，无论有无电势，其代价都是一样的。
*
* 所以我们把这两个步骤合并起来）。)上面的Lie拆分方法将做以下工作。它计算出以下两个ODE的解。
* [1.x.73]
*然后使用近似值[2.x.98]。换句话说，我们首先为物理效应一做一个完整的时间步骤，然后为物理效应二做一个完整的时间步骤。在时间步数结束时的解决方案只是分别由这些物理效应引起的增量的总和。
* 相比之下，[1.x.74]（20世纪中期开始的数值分析领域的泰斗之一）发现，先对一个物理效应做一个半步，然后对另一个物理效应做一个全时步，再对第一个物理效应做一个半步，这样更准确。哪个是哪个并不重要，但由于做相位旋转是如此简单，我们将使用这个效应做半步，然后只需要用拉普拉斯算子加电势做一个空间解。这种算子拆分方法现在[2.x.99]是准确的。写在公式中，这产生了以下的步骤序列。
* [1.x.75]
* 如前所述，第一和第三步可以准确地计算出这个特定的方程，得出的结果是
* [1.x.76]
*
* 这就是我们要在这个程序中实现的东西：在每个时间步骤中，我们执行三个步骤，即
*
* - 通过分析整合相位旋转方程的半个时间步长，更新每个节点的解值。
*
* - 解决对应于[2.x.100]的全步骤的时空方程，即[2.x.101]，其初始条件等于上述第一个半步骤的解。
*
* - 通过对相位旋转方程再进行半个时间步长的分析积分，更新每个节点的解值。
* 这一结构将以明显的方式反映在程序的主时间环中。
*


*[1.x.77][1.x.78]


*从上面的讨论中，我们应该清楚，我们在每个时间步长中要解决的唯一部分微分方程是
* [1.x.79]
* 这个方程是线性的。此外，我们只需要解决从[2.x.102]到[2.x.103]的问题，也就是说，正好是一个时间步骤。
* 为了做到这一点，我们将应用二阶精确的Crank-Nicolson方案，我们已经在其他一些时间相关的代码中使用过了（特别是：[2.x.104] 和 [2.x.105] ）。它的内容如下。
* [1.x.80]
* 这里，"先前 "的解决方案[2.x.106]（或这部分时间步骤的 "初始条件"）是第一个阶段旋转半步的输出；当前步骤的输出将用[2.x.107]表示。  [2.x.108]是时间步骤的长度。人们可以争论[2.x.109]和[2.x.110]是生活在时间步长[2.x.111]还是[2.x.112]以及它们的上限值应该是什么。这是一个没有实际影响的哲学讨论，人们可以把[2.x.113]看作是类似于[2.x.114]的东西，而把[2.x.115]看作是[2.x.116]，如果这有助于澄清事情的话。
*
* 不过，[2.x.117]也不能理解为"[2.x.118]之后的第三个时间步骤"，而更像是 "我们已经完成了时间步骤[2.x.119]所需的三分之一的工作"）。)
* 如果我们将整个方程与[2.x.120]相乘，并将未知数[2.x.121]的条款排序到左边，将已知数[2.x.122]的条款排序到右边，那么我们得到以下（空间）偏微分方程，需要在每个时间步长进行求解。
* [1.x.81]
*
*


*[1.x.82][1.x.83]。


* 如上所述，以前处理复值解的教程程序（即[2.x.123]）将解的实部和虚部分开。因此，它把一切都简化为实数运算。与此相反，我们在这里希望保持复数值的东西。
* 这方面的第一部分是，我们需要将离散化的解决方案定义为[2.x.124]，其中[2.x.125]是通常的形状函数（是实值的），但时间步长[2.x.127]的扩展系数[2.x.126]现在是复值的。这在deal.II中很容易做到：我们只需要用[2.x.128]而不是Vector<double>来存储这些系数。
* 更有趣的是如何建立和解决线性系统。显然，这只对上面讨论的Strang拆分的第二步有必要，即上一小节中的时间离散化。我们通过将[2.x.129]直接替换为[2.x.130]并乘以一个测试函数，得到完全离散的版本。
* [1.x.84]
* 或者以更紧凑的方式写。
* [1.x.85]
* 这里，矩阵是以其明显的方式定义的。
* [1.x.86]
* 请注意，所有的矩阵都是对称的、实值的，而且至少是正半无限的，不过对于系统矩阵[2.x.131]和右侧的相应矩阵[2.x.132]来说，显然不是这样的。
*

*[1.x.87][1.x.88] 。


* [2.x.133]
*关于解决程序的唯一剩下的重要问题是如何解决复值线性系统的问题
* [1.x.89]
* 矩阵[2.x.134]的右手边很容易被计算为已知矩阵与上一步骤的解的乘积，像往常一样，这归结为矩阵[2.x.135]具有什么属性的问题。如果它是对称的和正定的，那么我们可以使用共轭梯度法。
* 不幸的是，该矩阵唯一有用的属性是它是复数对称的，即[2.x.136]，回顾一下[2.x.137]都是对称的，就不难发现。然而，它不是[1.x.90]，这就要求[2.x.138]，其中横杠表示完全共轭。
* 复杂的对称性可以被用于迭代求解器，正如快速的文献搜索所显示的那样。我们在这里不会试图变得复杂（实际上是把这个问题留给下面的[1.x.91]部分），而是简单地用老式的好办法来解决没有属性的问题。直接求解器。这不是最好的，特别是对于大问题，但对于一个教程程序来说，这已经足够了。
*

*[1.x.92][1.x.93] 。


* 无法律约束力文书的初始条件通常被选择来代表特定的物理情况。这超出了本程序的范围，但只要说这些初始条件是(i)位于不同点的粒子的波函数的叠加，以及(ii)因为[2.x.139]对应于粒子密度函数，积分[1.x.94]对应于系统中的粒子数。显然，如果要在物理上正确，如果系统是封闭的，[2.x.140]最好是一个常数，如果有吸收边界条件，[2.x.141]则是常数）。重要的一点是，我们应该选择初始条件，使[1.x.95]有意义。
* 我们在这里使用的，主要是因为它的图形很好，如下：[1.x.96]其中[2.x.142]是与（固定）位置[2.x.143]的距离，而[2.x.144]的选择是为了使我们所添加的每个高斯都能为[2.x.145]增加整数的粒子。我们通过确保[1.x.97]是一个正整数来实现这一点。换句话说，我们需要选择[2.x.146]作为[1.x.98]的整数倍，暂时假设[2.x.147]
*
* --当然不是这样的，但我们会忽略积分的微小差异。
* 因此，我们选择[2.x.148]为所有，而[2.x.149]。这个[2.x.150]足够小，以至于精确（无限）积分和[2.x.151]上的积分之间的差异不应该太在意。我们选择[2.x.152]这四个点作为[2.x.153]
*
*--也离[2.x.154]的边界足够远，以保证我们自己的安全。
* 为简单起见，我们在正方形[2.x.155]上提出问题。对于边界条件，我们将使用[1.x.99]形式的时间无关的诺伊曼条件，这不是一个现实的边界条件选择，但对于我们想在这里展示的东西来说是足够的。我们将在下面的[1.x.100]部分对此作进一步评论。
* 最后，我们选择[2.x.156]，势为[1.x.101]，使用一个大的势可以确保波函数[2.x.157]在半径为0.7的圆外保持很小。构成初始条件的所有高斯都在这个圆内，解决方案将主要在这个圆内振荡，有少量的能量辐射到圆外。大势的使用也确保了非物理边界条件不会产生太大影响。
*

* [1.x.102] [1.x.103]。
* [1.x.104] [1.x.105] 程序以通常的包含文件开始，所有这些文件你现在应该都见过了。
*


* [1.x.106]
*
* 然后按照惯例将这个程序的所有内容放入一个命名空间，并将deal.II命名空间导入到我们将要工作的命名空间中。
*


* [1.x.107]
*
* [1.x.108] [1.x.109]。
* 然后是主类。它看起来非常像[2.x.158]或[2.x.159]中的相应类，唯一的例外是，矩阵和向量以及其他所有与线性系统相关的元素现在都存储为[2.x.160]类型，而不仅仅是`double`。
*


* [1.x.110]
*
* [1.x.111] [1.x.112]。


*
* 在我们继续填写主类的细节之前，让我们定义与问题相对应的方程数据，即初始值，以及一个右手类。(我们将重复使用初始条件也用于边界值，我们只是保持边界值不变)。我们使用派生自Function类模板的类来做这件事，这个模板之前已经用过很多次了，所以下面的内容看起来并不令人惊讶。唯一值得注意的是，我们这里有一个复值问题，所以我们必须提供Function类的第二个模板参数（否则会默认为`double`）。此外，`value()`函数的返回类型当然也是复数。   
* 这些函数准确地返回什么，在介绍部分的最后已经讨论过了。
*


* [1.x.113]
*
* [1.x.114] [1.x.115]。


*
* 我们首先指定该类的构造函数的实现。除了我们选择二次（[2.x.161]）拉格朗日元素外，这里没有什么值得惊奇的。
*
* - 解决方案预计是平滑的，所以我们选择了比最低限度更高的多项式度数。
*


* [1.x.116]
*
* [1.x.117] [1.x.118]。


*
* 下一个函数是在程序开始时，也就是在第一个时间步骤之前，设置网格、DoFHandler以及矩阵和向量。如果你已经阅读了至少到[2.x.162]为止的教程程序，那么前几行是相当标准的。
*


* [1.x.119]
*
* 接下来，我们把相关的矩阵组合起来。按照我们对斯特朗分裂的空间步骤（即每个时间步骤中三个部分步骤中的第二个步骤）的Crank-Nicolson离散化的写法，我们被引导到线性系统 [2.x.163] 。换句话说，这里有两个矩阵在起作用
*
*--一个是左手边的，一个是右手边的。我们分别建立这些矩阵。(我们可以避免建立右手边的矩阵，而只是在每个时间步骤中对[2.x.164]形成矩阵的作用*。这可能更有效，也可能不更有效，但是对于这个程序来说，效率并不是最重要的）。)
*


* [1.x.120]
*
* [1.x.121] [1.x.122]。


*
* 在建立了上述所有数据结构后，我们现在可以实现构成斯特朗分裂方案的部分步骤。我们从半步推进阶段开始，这被用作每个时间步骤的第一和最后部分。   
* 为此，回顾一下，对于第一个半步，我们需要计算 [2.x.165] 。这里，[2.x.166]和[2.x.167]是空间的函数，分别对应于前一个完整时间步骤的输出和三个部分步骤中第一个步骤的结果。必须为第三个部分步骤计算相应的解决方案，即[2.x.168] ，其中[2.x.169]是整个时间步骤的结果，其输入[2.x.170]是斯特朗分割的空间步骤的结果。   
* 一个重要的认识是，虽然[2.x.171]可能是一个有限元函数（即，是片状多项式），但对于我们使用指数因子更新相位的 "旋转 "函数来说，情况不一定如此（回顾一下，该函数的振幅在该步骤中保持不变）。换句话说，我们可以在每一个点[2.x.173]计算*[2.x.172]，但我们不能在网格上表示它，因为它不是一个片状多项式函数。在一个离散的环境中，我们能做的最好的事情就是计算一个投影或内插。换句话说，我们可以计算[2.x.174]，其中[2.x.175]是一个投影或内插算子。如果我们选择插值，情况就特别简单。那么，我们需要计算的就是在节点点上的右手边的值*，并将这些作为自由度向量[2.x.176]的节点值。这很容易做到，因为在这里使用的拉格朗日有限元的节点点上评估右手边，需要我们只看节点向量的一个（复值）条目。换句话说，我们需要做的是计算[2.x.177]，其中[2.x.178]在我们解向量的所有条目上循环。这就是下面这个函数的作用
*
* - 事实上，它甚至没有为[2.x.179]和[2.x.180]使用单独的向量，而只是适当地更新同一个向量。
*


* [1.x.123]
*
* 下一步是求解每个时间步骤中的线性系统，即我们使用的斯特朗分割的后半步。记得它的形式是[2.x.181]，其中[2.x.182]和[2.x.183]是我们之前组装的矩阵。   
* 我们在这里解决这个问题的方法是使用直接求解器。我们首先使用[2.x.185]函数求出右边的[2.x.184]，并将结果放入`system_rhs`变量。然后我们调用[2.x.186]，该函数以矩阵[2.x.187]和右手边的向量为参数，并将解决方案返回到同一向量`system_rhs`中。最后一步是将计算出的解放回`solution`变量中。
*


* [1.x.124]
*
* [1.x.125] [1.x.126]。


*
* 我们应该讨论的最后一个辅助函数和类是那些创建图形输出的函数。对Strang分裂的局部和空间部分运行半步和全步的结果是，我们在每个时间步长结束时将`solution`向量[2.x.188]更新为正确值。它的条目包含有限元网格节点上的解的复数。   
* 复数不容易被可视化。我们可以输出它们的实部和虚部，即字段[2.x.189]和[2.x.190]，这正是DataOut类在通过[2.x.191]附加复数向量，然后调用[2.x.192]时所做的。
*

*
*但很多时候，我们对解矢量的实部和虚部并不特别感兴趣，而是对解的幅度[2.x.193]和相位角[2.x.194]等衍生量感兴趣。在这里这样的量子系统的背景下，幅值本身并不那么有趣，相反，"振幅"[2.x.195]才是一个物理属性：它对应于在一个特定的状态场所找到一个粒子的概率密度。将计算出的量放入输出文件的方式，以便于可视化
*
* - 如同在以前众多的教程程序中使用的那样
*
* 是使用DataPostprocessor和派生类的设施。具体来说，一个复数的振幅和它的相位角都是标量，所以DataPostprocessorScalar类是我们要做的正确工具。   
* 因此，我们在这里做的是实现两个类`ComplexAmplitude`和`ComplexPhase`，为DataOut决定生成输出的每一点计算解决方案的振幅[2.x.196]和相位[2.x.197]，以实现可视化。下面有相当多的模板代码，这两个类中的第一个唯一有趣的部分是其`evaluate_vector_field()`函数如何计算`computed_quantities`对象。   
*（还有一个相当尴尬的事实是，[1.x.127]函数并没有计算人们天真的想象，即[2.x.198]，而是返回[2.x.199]。一个标准函数以这样的方式被错误地命名，这当然是相当令人困惑的......)
*


* [1.x.128]
*
* 其中第二个后处理器类计算每一点的复值解决方案的相位角。换句话说，如果我们表示[2.x.200]，那么这个类就会计算[2.x.201]。函数[1.x.129]为我们做这个，并将角度作为[2.x.202]和[2.x.203]之间的一个实数返回。     
* 由于我们将在结果部分详细解释的原因，我们实际上没有在产生输出的每个位置输出这个值。相反，我们取该阶段所有评估点的最大值，然后用这个最大值填充每个评估点的输出域。
*
* 本质上，我们将相位角作为一个片状常数域来输出，其中每个单元都有自己的常数值。一旦你读完下面的讨论就会明白其中的原因。
*


* [1.x.130]
*
* 在如此实现了这些后处理程序后，我们像往常一样创建输出。如同在其他许多时间相关的教程程序中一样，我们给DataOut附加标志，表示时间步数和当前的模拟时间。
*


* [1.x.131]
*
* [1.x.132] [1.x.133]。



* 剩下的步骤是我们如何设置这个程序的整体逻辑。这其实是比较简单的。设置数据结构；将初始条件插值到有限元空间；然后迭代所有时间步长，在每个时间步长上执行斯特朗分割法的三个部分。每隔10个时间步长，我们就生成图形输出。这就是了。
*


* [1.x.134]

* [1.x.135] [1.x.136]。


*
* 其余的部分又是锅炉板，与以前几乎所有的教程程序完全一样。
*


* [1.x.137]
* [1.x.138][1.x.139] 。


*运行代码的结果是屏幕输出如下：``活动单元的数量：4096自由度的数量：16641
*时间步数1在t=0时间步数2在t=0.00390625时间步数3在t=0.0078125时间步数4在t=0.0117188[...]``运行该程序也会产生大量的输出文件，我们将在下面进行展示。
*

*[1.x.140][1.x.141] 。


* 本程序的 "output_results() "函数生成由若干变量组成的输出文件。解（分为实部和虚部）、振幅和相位。如果我们将这四个场可视化，在几个时间步骤后，我们会得到如下图像（在时间[2.x.204]，精确地说。
* [2.x.205]
* 虽然上述解决方案的实部和虚部并不特别有趣（因为从物理角度来看，相位的全局偏移以及实部和虚部之间的平衡是没有意义的），但将解决方案的振幅[2.x.206]和相位[2.x.207]可视化，特别是它们的演变，则更有趣。这就导致了以下的图片。
* 这里显示的相位图显然有一些缺陷。
*
* - 首先，相位是一个 "循环量"，但是色标对接近[2.x.208]的值和接近[2.x.209]的值使用了根本不同的颜色。这是个麻烦的问题
*
* - 我们需要的是一个 "循环色图"，对相位范围的两个极端使用相同的颜色。这样的颜色图是存在的，例如见 [1.x.142] 或 [1.x.143] 。问题是，作者最喜欢的两个大的可视化软件包之一VisIt并没有内置这些颜色图。无奈之下，我只好使用Paraview，因为它已经实现了上面帖子中提到的几种颜色地图。下面的图片使用了`nic_Edge`地图，其中两个极端值都显示为黑色。
*
* - 在相位缠绕的单元格上有一个问题。如果在单元格的某个评估点，相位值接近[2.x.210]，而在另一个评估点则接近[2.x.211]，那么我们真正希望发生的是整个单元格的颜色接近于极端值。但是，相反，可视化程序产生了一个线性插值，其中单元格内的值，即评估点之间的值，是在这两个值之间线性插值的，基本上涵盖了整个可能的相位值范围，因此，在一个单元格的过程中，从深红色到深绿色的整个彩虹色循环往复。解决这个问题的方法是将每个单元的相位值作为一个片断常数输出。因为对接近[2.x.212]和[2.x.213]的值进行平均会导致一个与实际相位角无关的平均值，`ComplexPhase'类只是使用每个单元上遇到的最大*相位角。
* 经过这些修改，现在的相位图看起来如下。
* [2.x.214]
* 最后，我们可以用它来生成一部电影。(准确地说，这段视频又有两个全局细化周期，时间步长是上面程序中使用的一半。)这几行字的作者用VisIt制作了这部电影，因为这是他比较熟悉的，并使用了一个黑客的颜色地图，它也是循环的。
*
* - 尽管这个颜色图缺乏上面链接中提到的写帖子的人所采用的所有技巧。然而，如果你看一下半径为0.7的圆以外的域的阴影部分，它显示了作为波浪方程的解决方案的特点，在这个圆中，电势为零。
*
* 你可以看到每次有一个凸点（显示振幅[2.x.215]）撞到电势大的区域时：一个波从那里向外传播。看看这个视频吧。
* [1.x.144]
*
* 那么，为什么我最终会在电势[2.x.216]较大的区域设置阴影？在那个外部区域，解决方案是相对较小的。它也是相对平滑的。因此，在某种近似程度上，该区域的方程简化为[1.x.145]，或者也许更容易阅读：[1.x.146]在这个近似有效的程度上（除其他外，消除了你在视频中看到的行波），这个方程有一个解[1.x.147因为[2.x.217]很大，这意味着相位的变化相当快*。如果你把注意力放在域的半透明外部，你可以看到这一点。如果你把这个区域的颜色和域的内部一样，这个快速闪烁的外部区域可能是迷幻的，但也会分散内部发生的事情；也很难真正看到辐射波，在视频的开头很容易看到。
*

* [1.x.148][1.x.149][1.x.150] 。


*[1.x.151][1.x.152]


* 这里选择的求解器实在是太简单了。我们在这里所做的是在每一个步骤中把矩阵交给一个稀疏的直接求解器，让它找到线性系统的解。但我们知道，我们可以做得更好。
*
* - 首先，我们应该利用这样一个事实，即矩阵实际上并没有从时间步长到时间步长的变化。这是一个伪命题，因为我们这里有恒定的边界值，而且我们不改变时间步长。
*
* - 这两个假设在实际应用中可能不成立。但至少在这种情况下，只对矩阵进行一次因式分解（即计算一次[2.x.218]和[2.x.219]因子），然后在接下来的所有时间步长中使用这些因子，直到矩阵[2.x.220]发生变化，需要进行新的因式分解。SparseDirectUMFPACK类的接口允许这样做。
*
* - 然而，最终，稀疏直接求解器只对相对较小的问题有效，比如说最多几十万个未知数。除此之外，我们需要迭代求解器，如共轭梯度法（用于对称和正定问题）或GMRES。我们已经在其他教程程序中使用了许多这样的方法。在所有情况下，它们都需要伴随着良好的预处理程序。对于目前的情况，原则上可以使用GMRES
*
* - 一种不需要矩阵的任何特定属性的方法
*
* 但最好是实施一个迭代方案，利用我们知道的这个问题的一个结构特征：矩阵是复数对称的（尽管不是赫米特的）。
*

*[1.x.153][1.x.154]


* 为了能够用于实际的、现实的问题，非线性Schr&ouml;dinger方程的求解器需要利用对手头问题有意义的边界条件。在此，我们将自己限制在简单的诺伊曼边界条件上。
*
* 但这些条件对问题来说实际上是没有意义的。事实上，这些方程通常是在一个无限的域上提出的。但是，由于我们不能在无限域上进行计算，我们需要在某处截断它，而提出对这个人为的小域有意义的边界条件。广泛使用的方法是使用[1.x.155]方法，该方法对应于衰减的一种特殊形式。在不同的情况下，它也被用于[2.x.221]。
*

*[1.x.156][1.x.157] 。


* 最后，我们从经验和其他许多教程程序中知道，使用自适应细化的网格是值得的，而不是这里使用的单网格。事实上，在这里添加网格并不十分困难。它只是需要周期性的重塑和将解决方案从一个网格转移到下一个网格。  [2.x.222]将是一个很好的指南，说明如何实现这一点。
*

* [1.x.158][1.x.159] [2.x.223] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-59_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15]
* [2.x.2]
* [1.x.16]
* [1.x.17][1.x.18][1.x.19] 。


* 无矩阵算子评估使高阶多项式基的离散化得到了非常有效的实现，这是由于一种叫做sumfactorization的方法。这个概念已经在[2.x.3]和[2.x.4]的教程程序中介绍过。在本教程中，我们将这些概念扩展到包括面积分的非连续Galerkin（DG）方案，这是一类高阶特别普遍的方法。
* 无矩阵评估的基本思想与连续元素的评估相同。迭代求解器或多网格平滑器中出现的矩阵-向量乘积不是由经典的稀疏矩阵内核实现的，而是通过对基础积分的评估隐式应用。对于用张量积正交规则积分的张量积形状函数，这种评估通过使用总和因子化技术特别有效，该技术将最初涉及[2.x.6]度[2.x.7]的张量积形状函数在[2.x.8]维的插值操作分解为[2.x.9]正交点的[2.x.10]单维操作，每个成本[2.x.11]。在三维中，这将复杂度降低了 [2.x.12] 的两次幂。如果以每个自由度的复杂度来衡量，复杂度是[2.x.13]的多项式程度。由于DG中存在面积分，而且对正交点的操作涉及到更多的内存传输，这两个因素都是以[2.x.14]为尺度的，所以观察到的复杂度往往是中等的常数[2.x.15]。这意味着以每秒自由度计算，高阶方法可以与低阶方法的吞吐量相同。
* 关于算法的更多信息见Martin Kronbichler和Katharina Kormann的预印本[2.x.16] [1.x.20]，arXiv：1711.03590。
* [1.x.21][1.x.22] 。


* 在本教程中，我们以无矩阵的DG框架为例，对拉普拉斯进行内部惩罚离散化，即与[2.x.17]教程中使用的方案相同。拉普拉斯的离散化是由以下弱形式给出的
* [1.x.23]
* 其中[2.x.18]表示数量[2.x.19]从两个相关单元[2.x.20]和[2.x.21]的定向跳跃，[2.x.22]是两边的平均值。
* 方程中的项代表分项积分后的单元积分，由于分项积分和插入平均通量而在元素界面产生的原始一致性项，为恢复底层矩阵的对称性而添加的邻接一致性项，以及系数为[2.x.23]的惩罚项，其大小等于单元在面的法线方向的长度乘以[2.x.24]，见[2.x.25]。惩罚项的选择是为了使逆估计成立，并且最终的弱形式是强制性的，即离散化的正定。邻接一致性项和惩罚项涉及元素界面上的跳跃[2.x.26]，这在分析解[2.x.27]中消失了。因此，这些条款与原始PDE是一致的，确保该方法可以保持最佳收敛顺序。
* 在下面的实现中，我们通过将法向量[2.x.28]从跳跃项移到导数中，形成[1.x.24]形式的导数[2.x.29]来实现上述的弱形式。这使得在正交点上的实现稍微有效一些，因为我们只需要处理标量项而不是张量，而且在数学上是等价的。
* 对于边界条件，我们使用所谓的镜像原理，通过从内部解[2.x.31]的外推，结合给定的边界数据来定义[1.x.25]外部值[2.x.30]，在Dirichlet边界设置[2.x.32]和[2.x.33]，在Neumann边界设置[2.x.34]和[2.x.35]，对于给定Dirichlet值[2.x.36]和Neumann值[2.x.37] 。然后将这些表达式插入上述弱形式中。涉及已知量[2.x.38]和[2.x.39]的贡献最终被移到右手边，而未知值[2.x.40]被保留在左手边，对矩阵项的贡献与内部面类似。通过这些操作，可以得到与[2.x.41]中相同的弱形式。
*[1.x.26][1.x.27]。
*

* deal.II的无矩阵框架提供了必要的基础设施来实现上述离散方程的动作。与我们在[2.x.43]和[2.x.44]中使用的[2.x.42]相反，我们现在用[2.x.45]建立了一个代码，它需要三个函数指针，一个用于单元积分，一个用于内面积分，一个用于边界面积分（类似于[2.x.46]教程程序中使用的MeshWorker的设计）。在这三个函数中，我们在正交点上实现各自的条款。对于向量条目与正交点上的数值和梯度之间的插值，我们使用FEEvaluation类来处理单元贡献，FEFaceEvaluation类来处理面的贡献。这些函数的基本用法已经在[2.x.47]教程程序中进行了广泛的讨论。
* 在[2.x.48]中，所有的内部面都正好被访问一次，所以必须确保计算测试函数[2.x.49]和[2.x.50]的贡献。鉴于两边的测试函数确实是独立的，上面的弱形式实际上意味着我们将相同的贡献提交给一个名为 "phi_inner "和 "phi_outer "的FEFaceEvaluation对象，用于测试测试函数的法向导数，而用测试函数的值进行测试时，则提交相反的符号，因为后者由于跳跃项而涉及相反的符号。对于不同细化水平的单元之间的面，整合是从细化面开始的，FEFaceEvaluation自动执行内插到粗化面的子面。因此，悬空节点从未明确地出现在用户实现的弱形式中。
* 每个面被精确访问一次的事实也适用于那些用MPI并行化时不同处理器之间的子域边界的面，其中一个单元属于一个处理器，一个属于另一个。[2.x.51]中的设置将面分成两部分，最终只报告[2.x.52]和[2.x.53]中分别实际处理的面。请注意，与[2.x.54]中讨论的单元积分相类似，deal.II在几个面上应用矢量化以使用SIMD，在我们称之为[1.x.28]的东西上用一条指令工作。面的批次与单元的批次是独立的，尽管处理面的积分的时间与处理各自单元的积分的时间保持一致，以增加数据的可定位性。
* 这个程序的另一个新特点是，我们不再从求值和积分步骤中拆分像[2.x.55]或[2.x.56]那样的向量访问，而是分别调用组合函数[2.x.57]和[2.x.58]。这对面积分很有用，因为根据面的评估内容，并非所有单元格的向量项都必须首先被触及。例如，想想节点元素FE_DGQ的情况，节点点在元素表面。如果我们对面的形状函数值感兴趣，只有[2.x.59]个自由度以非微不足道的方式对它们有贡献（用更专业的方式来说，只有[2.x.60]个形状函数在面的支持度为零，并且对[2.x.61]个自由度返回真。
* 现在，我们当然不只对函数值感兴趣，而且对单元格上的导数也感兴趣。幸运的是，在deal.II中有一个元素，它将这种减少访问的特性也扩展到面的导数上，即FE_DGQHermite元素。
*[1.x.29][1.x.30]
*

* FE_DGQHermite元素属于FE_DGQ元素家族，即它的形状函数是一维多项式的张量乘积，元素是完全不连续的。与通常的FE_DGQ元素中的节点特征相反，FE_DGQHermite元素是一个基于Hermite-like概念的节点贡献和衍生贡献的混合物。底层多项式类是[2.x.63]，可以概括为以下几点。对于三次多项式，我们用两个多项式来表示单位区间左端的函数值和第一次导数，[2.x.64] ，用两个多项式来表示单位区间右端的函数值和第一次导数，[2.x.65] 。在相反的两端，形状函数的值和一阶导数都是零，确保四个基础函数中只有两个对各自末端的值和导数有贡献。然而，我们偏离了经典的赫米特内插法，没有严格地为值和一导数分配一个自由度，而是允许一导数是第一和第二形状函数的线性组合。这样做是为了改善插值的条件。此外，当度数超过三时，我们在元素内部以类似拉格朗日的方式增加节点点，并在[2.x.66]和[2.x.67]这两个点上结合双零。这些额外节点的位置是由一些贾科比多项式的零点决定的，在类[2.x.68]的描述中解释过。
* 使用这个元素，我们只需要访问[2.x.69]自由度来计算一个面的值和导数。检查赫米特属性是否被满足是在[2.x.70]和[2.x.71]中透明地完成的，它们检查基础的类型并尽可能减少对数据的访问。显然，如果我们将[2.x.72]与[2.x.73]分开，这将是不可能的，因为我们需要读取的条目数量取决于导数的类型（只有值，一导数，等等），因此必须给`read_dof_values()`。
* 这种优化不仅对计算面积分有用，而且对MPI鬼层交换也有用。在一个天真的交换中，如果另一个处理器负责计算面的贡献，我们就需要将一个单元的所有自由度发送给另一个处理器。由于我们知道在用FEFaceEvaluation进行的评估中只有部分自由度被触及，所以自然只交换相关自由度。[2.x.74]函数在与[2.x.75]结合时支持选定的数据交换。为了实现这一点，我们需要使用[2.x.76]类型的参数告诉循环我们要对脸部进行哪种评估，正如在下面[2.x.77]的实现中可以看到的。在这种情况下，数据交换的方式是如下的。矢量中的幽灵层数据仍然假装代表所有的自由度，这样，FEFaceEvaluation可以继续读取数值，就像单元格是本地拥有的一样。数据交换程序负责将数据打包和解包成这种格式。虽然这听起来很复杂，但我们将在下面的结果部分显示，通过与没有指定面的数据访问的基线代码进行性能比较，这确实是值得的。
* [1.x.31][1.x.32] 。
*

* 按照[2.x.78]程序的传统，我们再次用共轭梯度解算器内的几何多网格预处理来解决泊松问题。在这个教程中，我们没有计算对角线和使用基本的Precondition Chebyshev作为平滑器，而是选择了一个不同的策略。我们实现了一个块状Jacobi预处理程序，其中块状指的是一个单元上的所有自由度。我们没有在预处理程序中建立完整的单元矩阵并应用它的LU因子化（或逆）；这种操作将受到严重的内存带宽限制，因此速度相当慢；我们通过一种特殊的技术，即快速对角线化方法，对块的逆进行近似处理。
* 该方法的理念是利用单元矩阵的结构。对于在直角坐标系上离散的常数系数的拉普拉斯，单元矩阵[2.x.79]可以写为
* [1.x.33]
*在二维和
* [1.x.34]
*在三维中。矩阵[2.x.80]和[2.x.81]表示一维拉普拉斯矩阵（包括与当前单元值[2.x.82]和[2.x.83]相关的单元和面项），[2.x.84]和[2.x.85]是质量矩阵。请注意，一旦单元上有非恒定系数或几何形状不再恒定，这种简单的张量积结构就会消失。我们提到，一个类似的设置也可以用来用这个矩阵的最终张量积形式来代替计算的积分，这将把运算器的评估操作减少到一半以下。然而，考虑到这只适用于笛卡尔单元和恒定系数，这是一个相当狭窄的情况，我们没有继续研究这个想法。
* 有趣的是，由于1964年[1.x.35]引入的方法，矩阵[2.x.86]的准确逆值可以通过张量积找到。
* [1.x.36]
*其中[2.x.87]是给定张量方向的广义特征值问题的特征向量矩阵[2.x.88] 。
* [1.x.37]
* [2.x.89] 是代表广义特征值的对角线矩阵 [2.x.90] 。请注意，向量[2.x.91]是这样的，即[2.x.92]和[2.x.93]同时对角线化，即[2.x.94]和[2.x.95] 。
* deal.II库使用这个概念实现了一个类，叫做TensorProductMatrixSymmetricSum。
* 在本程序中，我们坚持使用常数系数和笛卡尔网格，尽管基于张量积的近似版本仍然可以用于更普遍的网格，而且算子评估本身当然也是通用的。此外，我们也不关心自适应网格，因为多网格算法需要获取不同细化边上的通量矩阵，如[2.x.96]中所解释的。然而，我们所做的一件事是仍然将我们的块状Jacobi预处理器包裹在Precondition Chebyshev中。该类使我们不必寻找适当的松弛参数（对于block-Jacobi平滑器来说，二维的松弛参数约为0.7，三维的松弛参数约为0.5），并且通常比普通的Jacobi平滑器提高了一些平滑效率，因为当Chebyshev多项式的程度设置为1或2时，它可以降低求解时间。
* 请注意，块状雅可比平滑法有一个额外的好处：快速对角线化方法也可以解释为从FE_DGQHermite的Hermite-like多项式转变为一个单元格拉普拉斯的对角线的基础。因此，它抵消了基础的影响，无论我们使用FE_DGQHermite还是FE_DGQ，我们都能得到相同的迭代次数。这与使用只有对角线的Precondition Chebyshev类（点Jacobi方案）相比，FE_DGQ和FE_DGQHermite的表现确实不同，FE_DGQ比FE_DGQHermite需要少2-5次迭代，尽管对类似Hermite的形状函数做了修改以确保良好的调节。
*

* [1.x.38] [1.x.39]。
* 包含的文件与[2.x.97]中的基本相同，只是用有限元类FE_DGQHermite代替了FE_Q。所有对面积分进行无矩阵计算的功能已经包含在`fe_evaluation.h`中。
*


* [1.x.40]
*
* 和[2.x.98]一样，为了简单起见，我们在程序的顶部将维数和多项式的度数收集为常数。与[2.x.99]不同的是，这次我们选择了一个真正的高阶方法，度数为8，任何不使用和分解的实现都会变得非常慢，而使用MatrixFree的实现则提供了与度数为2或3时基本相同的效率。此外，本教程程序中的所有类都是模板化的，所以在运行时从输入文件或命令行参数中选择度数是很容易的，只要在`main()`函数中添加相应度数的实例即可。
*


*


* [1.x.41]
*
* [1.x.42] [1.x.43]。


*
* 与[2.x.100]相类似，我们定义了一个分析解，并试图用我们的离散化来重现。由于本教程的目的是展示无矩阵方法，我们选择一个最简单的可能性，即一个余弦函数，其导数对我们来说足够简单，可以用分析法计算。再往下看，我们在这里选择的波数2.4将与[2.x.101]方向的域范围即2.5相匹配，这样我们在[2.x.102]包括[2.x.103]或余弦的三个整波旋转处得到一个周期性的解。第一个函数定义了解和它的梯度，分别用于表达Dirichlet和Neumann边界条件的解析解。此外，一个代表解的负拉普拉斯的类被用来表示右手边（强制）函数，我们用它来匹配离散化版本中的给定分析解（制造解）。
*


*


* [1.x.44]
*
* [1.x.45] [1.x.46]。


*
* `LaplaceOperator`类类似于 [2.x.104] 中的相应类。一个重要的区别是，我们没有从[2.x.105]中派生出这个类，因为我们想呈现[2.x.106]中的一些额外功能，这些功能在通用类[2.x.107]中是没有的。 我们从Subscriptor类中派生出这个类，以便能够在Chebyshev预处理程序中使用该操作符，因为该预处理程序通过SmartPointer存储底层矩阵。   
* 鉴于我们手工实现了一个完整的矩阵接口，我们需要添加一个`initialize()`函数，一个`m()`函数，一个`vmult()`函数，以及一个`Tvmult()`函数，这些都是之前由 [2.x.108] 我们的LaplaceOperator还包含一个成员函数`get_penalty_factor()`，根据 [2.x.109] 集中选择对称内部惩罚方法中的惩罚参数.
*


*


* [1.x.47]
*
* `%PreconditionBlockJacobi`类定义了我们对这个问题的自定义预处理程序。与基于矩阵对角线的[2.x.110]不同，我们在这里通过使用介绍中讨论的所谓快速对角线化方法来计算不连续Galerkin方法中对角线块的近似反演。
*


*


* [1.x.48]
*
* 这个独立的函数在 "LaplaceOperator "和"%PreconditionBlockJacobi "类中都被用来调整鬼魂范围。这个函数是必要的，因为`vmult()`函数所提供的一些向量没有用包括正确的鬼魂条目布局的[2.x.111]来正确初始化，而是来自MGTransferMatrixFree类，该类对无矩阵类的鬼魂选择没有概念。为了避免索引混乱，我们必须在对这些向量进行实际操作之前调整鬼域。由于向量在多网格平滑器和传输类中被保留下来，一个曾经被调整过重影范围的向量在对象的整个生命周期中都会保持这种状态，所以我们可以在函数的开始使用一个快捷方式来查看分布式向量的分区器对象（以共享指针的形式存储）是否与MatrixFree所期望的布局相同，它存储在一个通过[2.x.112]访问的数据结构中]，其中的0表示从中提取的DoFHandler编号；我们在MatrixFree中只使用一个DoFHandler，所以这里唯一有效的编号是0。
*


*


* [1.x.49]
*
* 接下来的五个函数用于清除和初始化`LaplaceOperator`类，返回持有MatrixFree数据容器的共享指针，以及正确初始化向量和运算符的大小，与[2.x.113]或者说[2.x.114]的内容相同。
*


* [1.x.50]
*
* 这个函数实现了LaplaceOperator对向量`src`的操作，并将结果存储在向量`dst`中。与[2.x.115]相比，这个调用有四个新特性。   
* 第一个新特性是上面提到的`adjust_ghost_range_if_necessary`函数，它需要将向量适合于单元格和面函数中FEEvaluation和FEFaceEvaluation所期望的布局。   
* 第二个新特征是我们没有像[2.x.116]中那样实现`vmult_add()`函数（通过虚拟函数[2.x.117]，而是直接实现`vmult()`功能。由于单元和面的积分都将和到目的向量中，我们当然必须在某处将向量归零。对于DG元素，我们有两个选择&ndash；一个是使用[2.x.118]而不是下面`apply_cell`函数中的[2.x.119]。这是因为MatrixFree中的循环布局是这样的：单元积分总是在面积分之前触及给定的向量条目。然而，这实际上只适用于完全不连续的基数，其中每个单元都有自己的自由度，不与邻近的结果共享。另一种设置，即这里选择的设置，是让[2.x.120]来处理向量的归零问题。这可以被认为是简单地在代码中调用`dst = 0;`。对于像[2.x.121]这样的支持性向量来说，实现起来就比较麻烦了，因为我们的目标是不要一次性将整个向量清零。在足够小的几千个向量项上进行归零操作的好处是，在[2.x.122]和[2.x.123]中再次访问之前，被归零的向量项会保留在缓存中，因为无矩阵运算符的评估真的很快，仅仅归零一个大的向量就会相当于运算符评估时间的25%，我们显然希望避免这种代价。这种将向量归零的选项也适用于[2.x.124]和连续基数，尽管在[2.x.125]或[2.x.126]的教程程序中没有使用它。   
* 第三个新特性是我们提供在单元格、内面和边界面计算的函数的方式。MatrixFree类有一个叫做`loop`的函数，它接收三个函数指针，用于三种情况，允许分开实现不同的东西。正如在[2.x.127]中所解释的，这些函数指针可以是[2.x.128]对象或类的成员函数。在这种情况下，我们使用成员函数的指针。   
* 最后的新特征是可以给[2.x.129]类型的最后两个参数，这个类将面积分的数据访问类型传递给并行向量的MPI数据交换例程[2.x.131]和[2.x.132]。其目的是不发送相邻元素的所有自由度，而是将数据量减少到手头计算真正需要的程度。数据交换是一个真正的瓶颈，特别是对于高自由度的DG方法来说，因此一个更严格的交换方式往往是有益的。枚举字段[2.x.133]可以取值`none`，这意味着根本不做面的积分，这与[2.x.134]的值`values`类似，意味着只使用面的形状函数值（但不使用导数），而值`gradients`则意味着除了值之外还可以访问面的第一导数。值`unspecified`意味着所有的自由度将被交换给位于处理器边界的面，并指定在本地处理器上进行处理。   
* 为了了解数据如何被减少，想想节点元素FE_DGQ的情况，节点点在元素表面，在一个单元的[2.x.138]自由度中，只有[2.x.135]自由度对一个面的多项式程度[2.x.136]的值有贡献。类似的减少也可以用于内部惩罚方法，该方法对面的数值和一阶导数进行评估。当在一维中使用类似Hermite的基时，最多只有两个基函数对值和导数有贡献。FE_DGQHermite类实现了这一概念的张量乘积，在介绍中已经讨论过。因此，每个面只必须交换[2.x.139]个自由度，一旦[2.x.140]个自由度大于4个或5个，这显然是一种胜利。请注意，FE_DGQHermite的这种减少的交换在具有弯曲边界的网格上也是有效的，因为导数是在参考元素上取的，而几何体只在内部混合它们。因此，这与试图用连续的Hermite型形状函数获得[2.x.141]的连续性是不同的，在这种情况下，非笛卡尔的情况大大改变了情况。显然，在非笛卡尔网格上，导数还包括超出法向导数的形状函数的切向导数，但这些也只需要元素表面的函数值。如果元素不提供任何压缩，循环会自动交换受影响单元的所有条目。
*


*


* [1.x.51]
*
* 因为拉普拉斯是对称的，所以`Tvmult()`（多网格平滑界面需要）操作被简单地转发到`vmult()`的情况。
*


*


* [1.x.52]
*
* 单元操作与 [2.x.142] 非常相似。不过我们在这里没有使用系数。第二个区别是，我们用一个单一的函数调用[2.x.145]代替了[2.x.143]后面的两个步骤，该函数在内部调用了两个单独方法的序列。同样，[2.x.146]实现了[2.x.147]之后的[2.x.148]的序列。 在这种情况下，这些新函数只是节省了两行代码。然而，我们将它们用于与FEFaceEvaluation的类比，在那里它们更重要，如下所述。
*


*

* [1.x.53]
*
* 面的操作实现了与[2.x.149]相类似的内部惩罚方法的条款，正如介绍中所解释的。我们需要两个评价器对象来完成这个任务，一个用来处理来自内部面的两边之一的单元格的解，另一个用来处理来自另一边的解。面积分的评价器被称为FEFaceEvaluation，并在构造函数的第二个槽中接受一个布尔参数，以指示评价器应属于两边中的哪一边。在FEFaceEvaluation和MatrixFree中，我们称两边中的一边为 "内部"，另一边为 "外部"。`外部'这个名字是指两边的评价器将返回相同的法向量。对于 "内部 "一侧，法向量指向外部，而另一侧则指向内部，并且与该单元的外部法向量相对应。除了新的类名之外，我们再次得到了一系列的项目，与[2.x.150]中讨论的类似，但在这种情况下是针对内部面的。请注意，MatrixFree的数据结构形成了面的批次，类似于单元积分的单元批次。一批中的所有面涉及不同的单元格编号，但在参考单元格中具有相同的面编号，具有相同的细化配置（无细化或相同的子面）和相同的方向，以保持SIMD操作的简单和高效。   
* 请注意，除了法线方向的逻辑决定外，内部与外部没有任何隐含的意义，这在内部是相当随机的。我们绝对不能依赖分配内部与外部标志的某种模式，因为这个决定是为了MatrixFree设置例程中的访问规则性和统一性而做出的。由于大多数正常的DG方法都是保守的，也就是说，通量在接口的两边看起来都是一样的，所以如果内部/外部标志被调换，法线向量得到相反的符号，那么数学是不会改变的。
*


*


* [1.x.54]
*
* 在给定的一批面孔上，我们首先更新指向当前面孔的指针，然后访问矢量。如上所述，我们将向量的访问与评估结合起来。在面积分的情况下，对于FE_DGQHermite基础的特殊情况，可以减少对向量的数据访问，正如上面解释的数据交换。因为在[2.x.152]个单元自由度中只有[2.x.151]个被乘以非零值或形状函数的导数，这种结构可以被用于评估，大大减少了数据访问。减少数据访问不仅是有益的，因为它减少了飞行中的数据，从而有助于缓存，而且当从单元格索引列表中相距较远的单元格中收集数值时，对面的数据访问往往比对单元格积分更不规则。
*


* [1.x.55]
*
* 接下来的两个语句是计算内部惩罚方法的惩罚参数。正如在介绍中所解释的，我们希望有一个像[2.x.153]那样的长度[2.x.154]法线到面的缩放比例。对于一般的非笛卡尔网格，这个长度必须由反雅各布系数乘以实坐标的法向量的乘积来计算。从这个 "dim "分量的向量中，我们必须最终挑选出与参考单元的法线方向一致的分量。在MatrixFree中存储的几何数据中，雅各布式中的分量被应用，使得后一个方向总是最后一个分量`dim-1`（这很有利，因为参考单元的导数排序可以与面的方向无关）。这意味着我们可以简单地访问最后一个分量`dim-1`，而不必在`data.get_face_info(face).internal_face_no`和`data.get_face_info(face).exterior_face_no`中查找局部面的编号。最后，我们还必须取这些因素的绝对值，因为法线可能指向正或负的方向。
*


* [1.x.56]
*
* 在正交点的循环中，我们最终计算了对内部惩罚方案的所有贡献。根据介绍中的公式，测试函数的值被乘以解决方案中的跳跃乘以惩罚参数和实空间中的法向导数的平均值的差值。由于内侧和外侧的两个评估器由于跳跃而得到不同的符号，我们在这里用不同的符号传递结果。测试函数的正态导数会被内侧和外侧的解决方案中的负跳跃所乘。这个术语，被称为邻接一致性术语，根据其与原始一致性术语的关系，在代码中还必须包括[2.x.155]的系数，由于测试函数槽中的平均数，它得到了二分之一的系数。
*


* [1.x.57]
*
* 一旦我们完成了对正交点的循环，我们就可以对面的积分循环进行和因子化操作，并将结果加到结果向量中，使用`integrate_scatter`函数。`scatter'这个名字反映了使用与`gather_evaluate'相同的模式将矢量数据分布到矢量中的分散位置。像以前一样，整合+写操作的组合允许我们减少数据访问。
*


* [1.x.58]
*
* 边界面函数大体上沿用了内部面函数。唯一的区别是，我们没有一个单独的FEFaceEvaluation对象为我们提供外部值 [2.x.156] ，但我们必须从边界条件和内部值 [2.x.157] 来定义它们。正如介绍中所解释的，我们在Dirichlet边界上使用[2.x.158]和[2.x.159]，在Neumann边界上使用[2.x.160]和[2.x.161] 。由于这个操作实现了同质部分，即矩阵-向量乘积，我们必须在这里忽略边界函数[2.x.162]和[2.x.163]，并在[2.x.164]中把它们加到右手边 注意，由于通过[2.x.166]把解[2.x.165]扩展到外部，我们可以保持所有因子[2.x.167]与内表面函数相同，也请看[2.x.168]中的讨论。   
* 在这一点上有一个陷阱。下面的实现使用一个布尔变量`is_dirichlet`来切换Dirichlet和Neumann情况。然而，我们解决的问题是，我们还想在一些边界上施加周期性的边界条件，即沿[2.x.169]方向的边界。人们可能会问，这里应该如何处理这些条件。答案是MatrixFree会自动将周期性边界视为技术上的边界，即两个相邻单元的解值相遇的内面，必须用适当的数值通量来处理。因此，周期性边界上的所有面将出现在`apply_face()`函数中，而不是这个函数中。
*


*


* [1.x.59]
*
* 接下来我们转向预处理程序的初始化。正如介绍中所解释的，我们想从一维质量和拉普拉斯矩阵的乘积中构造一个（近似的）单元矩阵的逆。我们的首要任务是计算一维矩阵，我们通过首先创建一个一维有限元来实现。在这里，我们没有预见到FE_DGQHermite<1>，而是从DoFHandler获得有限元的名称，用1替换[2.x.170]参数（2或3）来创建一个一维名称，并通过使用FETools来构造一维元素。
*


*


* [1.x.60]
*
* 至于在单位元素上计算一维矩阵，我们简单地写下在矩阵的行和列以及正交点上的典型装配程序会做什么。我们一劳永逸地选择相同的拉普拉斯矩阵，对内部面使用系数0.5（但可能由于网格的原因，在不同方向上的缩放比例不同）。因此，我们在Dirichlet边界（正确的系数应该是导数项为1，惩罚项为2，见[2.x.171]）或在Neumann边界（系数应该为0）犯了一个小错误。由于我们只在多网格方案中使用这个类作为平滑器，这个错误不会有任何重大影响，只是影响了平滑的质量。
*


* [1.x.61]
*
* 接下来的两个语句所集合的左右边界项似乎有一些任意的符号，但这些都是正确的，可以通过查看[2.x.172]并插入值来验证
*
* - 以及1D情况下的法向量的1。
*


* [1.x.62]
*
* 接下来，我们通过单元格，将缩放后的矩阵传递给TensorProductMatrixSymmetricSum，以实际计算代表逆的广义特征值问题。由于矩阵近似的构造为[2.x.173]，并且每个元素的权重是恒定的，我们可以在拉普拉斯矩阵上应用所有的权重，并且简单地保持质量矩阵不被缩放。在单元格的循环中，我们要利用MatrixFree类提供的几何体压缩，并检查当前的几何体是否与上一批单元格上的几何体相同，在这种情况下就没有什么可做的。一旦调用了`reinit()`，就可以通过[2.x.174]访问这种压缩。     
* 一旦我们通过FEEvaluation访问函数访问了反雅各布系数（我们取第4个正交点的，因为它们在笛卡尔单元的所有正交点上都应该是一样的），我们检查它是对角线的，然后提取原始雅各布系数的行列式，即反雅各布系数的行列式，并根据一维拉普拉斯乘以质量矩阵的[2.x.176]拷贝，设置权重为[2.x.175] 。
*


* [1.x.63]
*
* 一旦我们知道应该用什么系数来缩放拉普拉斯矩阵，我们就将这个权重应用于未缩放的DG拉普拉斯矩阵，并将数组发送到TensorProductMatrixSymmetricSum类中，用于计算介绍中提到的广义特征值问题。
*


*


* [1.x.64]
*
* 在DG背景下，用于近似块状Jacobi预处理的vmult函数非常简单。我们只需要读取当前单元格批的值，对张量积矩阵阵列中的给定条目进行逆运算，并将结果写回来。在这个循环中，我们覆盖了`dst`中的内容，而不是首先将条目设置为零。这对于DG方法来说是合法的，因为每个单元都有独立的自由度。此外，我们手动写出所有单元批的循环，而不是通过[2.x.177]我们这样做是因为我们知道我们在这里不需要通过MPI网络进行数据交换，因为所有的计算都是在每个处理器上的本地单元上完成的。
*


*


* [1.x.65]

* LaplaceProblem类的定义与 [2.x.178] 非常相似。一个区别是我们将元素度作为模板参数添加到类中，这将允许我们通过在`main()`函数中创建不同的实例，更容易在同一个程序中包含多个度。第二个区别是选择了FE_DGQHermite这个元素，它是专门用于这种方程的。
*


*


* [1.x.66]
*
* 设置函数在两个方面与 [2.x.179] 不同。首先是我们不需要为不连续的Ansatz空间插值任何约束，只需将一个假的AffineConstraints对象传入[2.x.180] 第二个变化是因为我们需要告诉MatrixFree也要初始化面的数据结构。我们通过为内部面和边界面分别设置更新标志来做到这一点。在边界面，我们需要函数值、它们的梯度、JxW值（用于积分）、法向量和正交点（用于边界条件的评估），而对于内部面，我们只需要形状函数值、梯度、JxW值和法向量。只要`mapping_update_flags_inner_faces`或`mapping_update_flags_boundary_faces`中的一个与UpdateFlags的默认值`update_default`不同，MatrixFree中的面数据结构总是被建立的。
*


*


* [1.x.67]

* 右手边的计算比[2.x.181]中要复杂一些。现在的单元项包括分析解的负拉普拉斯，`RightHandSide'，为此我们需要首先将VectorizedArray字段的Point，即一批点，通过分别评估VectorizedArray中的所有通道，拆成一个点。请记住，通道的数量取决于硬件；对于不提供矢量化的系统（或deal.II没有本征），它可能是1，但在最近的Intel架构的AVX-512上也可能是8或16。
*


* [1.x.68]
*
* 其次，我们还需要应用迪里切特和诺伊曼边界条件。这个函数是到函数[2.x.182]函数的缺失部分，一旦在迪里希特边界上的外部解决值[2.x.183]和[2.x.184]以及在诺伊曼边界上的[2.x.185]和[2.x.186]被插入并以边界函数[2.x.187]和[2.x.188]展开。需要记住的一点是，我们把边界条件移到右手边，所以符号与我们在解的部分施加的相反。     
* 我们本可以通过[2.x.189]部分发出单元格和边界部分，但我们选择手动写出所有面的完整循环，以了解面指数的索引布局在MatrixFree中是如何设置的：内部面和边界面都共享索引范围，所有批次的内部面的数字都比批次的边界单元格低。两种变体的单一索引使我们可以很容易地在两种情况下使用相同的数据结构FEFaceEvaluation，它附着在同一个数据域上，只是位置不同。内层面的批次数（其中一个批次是由于将几个面合并成一个面进行矢量化）由[2.x.190]给出，而边界面的批次数由[2.x.191]给出。
*


* [1.x.69]
*
* MatrixFree类让我们可以查询当前面批的边界_id。请记住，MatrixFree为矢量化设置了批次，使一个批次中的所有面具有相同的属性，其中包括它们的`边界_id`。因此，我们可以在这里为当前面的索引`face`查询该id，并在Dirichlet情况下（我们在函数值上添加一些东西）或Neumann情况下（我们在法线导数上添加一些东西）施加。
*


* [1.x.70]
*
* 由于我们手动运行了单元格的循环，而不是使用[2.x.192]，我们不能忘记与MPI进行数据交换
*
* 或者说，对于DG元素来说，我们不需要这样做，因为每个单元都有自己的自由度，而且单元和边界积分只对本地拥有的单元进行量的评估。与相邻子域的耦合只能通过内表面积分来实现，我们在这里没有做这个。尽管如此，在这里调用这个函数并没有什么坏处，所以我们这样做是为了提醒大家里面发生了什么[2.x.193] 。
*


* [1.x.71]
*
* `solve()`函数几乎是逐字复制自 [2.x.194] 。我们设置了相同的多网格成分，即水平转移、平滑器和粗网格求解器。唯一不同的是，我们没有使用拉普拉斯的对角线作为用于平滑的切比雪夫迭代的预处理，而是使用我们新解决的类`%PreconditionBlockJacobi`。不过，机制是一样的。
*


* [1.x.72]
*
* 因为我们已经用分析法解决了一个问题，所以我们想通过计算数值结果与分析法的L2误差来验证我们实现的正确性。
*


*


* [1.x.73]
*
* `run()`函数设置了初始网格，然后以常规方式运行多网格程序。作为一个域，我们选择一个矩形，在[2.x.195]-方向上有周期性的边界条件，在[2.x.196]方向上的正面（即索引号为2的面，边界id等于0）有一个Dirichlet条件，在3D情况下，背面以及[2.x.197]方向上的两个面有Neumann条件（边界id等于1）。与[2.x.199]和[2.x.200]方向相比，[2.x.198]方向的域的范围有些不同（鉴于 "解决方案 "的定义，我们希望在这里实现周期性的解决方案）。
*


*


* [1.x.74]
*
* `main()`函数中没有任何意外。我们通过`MPI_Init()`类调用`MPI_InitFinalize`，传入文件顶部设置的关于维度和度的两个参数，然后运行拉普拉斯问题。
*


*


* [1.x.75]
* [1.x.76][1.x.77] 。


*[1.x.78][1.x.79] 。


* 就像在[2.x.201]中一样，我们以运行时间来评估多栅格求解器。  在两个空间维度上，元素的度数为8，可能的输出如下。
* [1.x.80]

* 与[2.x.202]一样，随着问题大小的增加，CG的迭代次数保持不变。迭代次数要高一些，这是因为我们使用的切比雪夫多项式的度数较低（[2.x.203]中是2比5），而且内部惩罚离散化的不特征值分布也比较大。尽管如此，13次迭代将残差减少了12个数量级，或者说每次迭代几乎是9个系数，这表明这是一个总体上非常有效的方法。特别是，当使用12个核心时，我们可以在5秒内解决一个具有2100万自由度的系统，这是一个非常好的效率。当然，在二维中，我们已经进入了八次方程的四舍五入体系；事实上，大约83000个自由度或0.025个自由度就足以完全收敛这个（简单的）分析解。
* 如果我们在三个空间维度上运行这个程序，并没有什么变化，只是我们现在用更高的多项式度和更大的网格尺寸来做一些更有用的事情，因为舍入误差只在最细的网格上获得。尽管如此，我们仍然可以在一台12核心的机器上非常容易地解决一个具有三个周期的波浪的三维拉普拉斯问题，并达到四舍五入的精度，这一点非常了不起。
*
* - 在第二至最大的案例中，24m DoFs总共使用了约3.5GB的内存，花费不超过8秒。最大的案例使用了30GB的内存，有1.91亿个DoFs。
* [1.x.81]

*[1.x.82][1.x.83]
*

* 在介绍和代码注释中，多次提到用FEE评估和FEFaceEvaluation评估器可以非常有效地处理高阶。现在，我们想通过观察三维多网格求解器对不同多项式阶数的吞吐量来证实这些说法。我们收集的时间如下。我们首先在接近一千万的问题规模下运行一个求解器，如表前四行所示，并记录时间。然后，我们通过记录每秒解决的百万自由度数（MDoFs/s）来规范吞吐量，以便能够比较不同自由度的效率，其计算方法是自由度数除以求解器时间。
* [2.x.204]
* 我们清楚地看到每个自由度的效率最初是如何提高的，直到它达到多项式程度的最大值 [2.x.205] 。这种效果是令人惊讶的，不仅是因为较高的多项式度数通常会产生一个好得多的解决方案，而且特别是当考虑到基于矩阵的方案时，在较高的度数下密度耦合会导致单调地减少吞吐量（在三维中是巨大的，[2.x.206]比[2.x.207]慢十倍以上！）。对于更高的度数，吞吐量略有下降，这既是由于迭代次数的增加（从[2.x.208]的12次到[2.x.209]的19次），也是由于操作评估的[2.x.210]的复杂性。尽管如此，对于更高的多项式度数来说，解题时间的效率仍然会更好，因为它们有更好的收敛率（至少对于像这个问题一样简单的问题）。对于[2.x.211]，我们在100万个DoFs（求解时间小于1秒）的情况下已经达到了舍入精度，而对于[2.x.212]，我们需要2400万个DoFs和8秒。对于[2.x.213]，误差约为[2.x.214]，有5700万个DoFs，因此，尽管需要16秒的时间，但仍然离舍入很远。
* 请注意，上述数字有点悲观，因为它们包括切比雪夫平滑器计算特征值估计的时间，这大约是求解器时间的10%。如果系统被多次求解（例如在流体力学中很常见），这个特征值的成本只需支付一次，更快的时间就可以得到。
*[1.x.84][1.x.85]
*

* 最后，我们看一下教程中的一些特殊成分，即FE_DGQHermite基础和[2.x.215]的指定。]设置为 "未指定 "而非最佳 "梯度"，最后一行是用基本的FE_DGQ元素替换FE_DGQHermite，其中MPI交换更加昂贵，操作由[2.x.217]和[2.x.218]完成。
* [2.x.219]
* 表中的数据显示，如果不使用[2.x.220]，对于较高的多项式度数，成本会增加10%左右。对于较低的度数，差异显然没有那么明显，因为体积与表面的比例更有利，需要改变的数据更少。如果只看矩阵-向量乘积，而不是这里显示的完整的多网格求解器，差异会更大，仅仅因为MPI通信，就有大约20%的工作量。
* 对于[2.x.221]和[2.x.222]，类似Hermite的基函数显然没有真正发挥作用（事实上，对于[2.x.223]，多项式与FE_DGQ完全相同），其结果与FE_DGQ基类似。然而，对于从三开始的度数，我们看到FE_DGQHermite的优势越来越大，显示了这些基函数的有效性。
* [1.x.86][1.x.87] 。


* 正如介绍中提到的，快速对角线化方法是与具有恒定系数的笛卡尔网格相联系的。如果我们想解决可变系数的问题，我们需要在平滑参数的设计上投入更多的时间，选择适当的概括（例如，在最近的箱形元素上近似反）。
* 另一种扩展程序的方式是包括对自适应网格的支持，对于这种支持，在不同细化水平的边缘的界面操作是必要的，正如在[2.x.224]中所讨论的那样。
*

* [1.x.88][1.x.89] [2.x.225] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-60_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21]
* [2.x.2]
* [1.x.22]
* [2.x.3]
*

*[1.x.23][1.x.24]


*[1.x.25][1.x.26]



* 在本教程中，我们考虑两个域的情况，[2.x.5]中的[2.x.4]和[2.x.7]中的[2.x.6]，其中[2.x.8]被嵌入到[2.x.9]中（[2.x.10]）。我们想解决[2.x.11]上的偏微分方程，对嵌入域*[2.x.12]上的问题的解决强制执行一些条件。
* 有两种有趣的情况。
*
* - 嵌入域[2.x.13]的几何维度`dim`与域[2.x.14]相同（`spacedim`），即[2.x.15]的spacedim维度不为零，或
*
* - 嵌入域[2.x.16]的内在维度`dim`小于[2.x.17]（`spacedim`），因此其间隔维度为零；例如，它是一条嵌入二维域的曲线，或嵌入三维域的面。
* 在这两种情况下，定义限制算子[2.x.18]为算子，给定[2.x.19]上的连续函数，返回其在[2.x.20]上的（连续）限制，即：。
* [1.x.27]
* 众所周知，当[2.x.25]的内在维度与[2.x.26]相同时，算子[2.x.21]可以扩展为[2.x.22]上的连续算子，将[2.x.23]中的函数映射到[2.x.24]中的函数。
* 当[2.x.28]的维数比[2.x.29]少一个时，同样的情况也适用于一个不太规则的范围空间（即[2.x.27]），并且[2.x.30]没有边界。在这第二种情况下，算子[2.x.31]也被称为轨迹*算子，它对于嵌入[2.x.33]的Lipschitz共维度一的曲线和曲面[2.x.32]有很好的定义（关于轨迹算子的进一步细节请阅读[1.x.28]）。
* 二维的情况要复杂一些，一般来说，当[2.x.36]的维度为零或一的时候，不可能构造一个连续的轨迹算子，甚至不可能从[2.x.34]到[2.x.35]，分别在二维和三维中构造。
* 在本教程中，我们对[2.x.37]的进一步细节不感兴趣：假设嵌入域的维数(`dim`)总是小于或等于嵌入域[2.x.39]的维数(`spacedim`)，我们认为扩展[2.x.38]是当然的。
* 我们要解决以下微分问题：给定[2.x.41]上的一个充分无规则函数[2.x.40]，求[2.x.42]的解。
* [1.x.29]
*
* 这是一个约束问题，我们正在寻找一个谐波函数[2.x.43]，满足[2.x.44]上的同质边界条件，并在约束条件[2.x.45]下使用拉格朗日乘法器。
* 这个问题有一个物理解释：谐波函数，即满足拉普拉斯方程的函数，可以被认为是边界值被规定的膜的位移。目前的情况相当于找到一个膜的形状，不仅边界上的位移，而且[2.x.46]上的位移也是规定的。例如，如果[2.x.47]是二维空间中的一条封闭曲线，那么这将是一个肥皂膜的模型，它被沿[2.x.48]的一个线环和沿[2.x.49]的第二个线环固定。在[2.x.50]是整个区域的情况下，你可以把它看作是在障碍物上伸展的膜，其中[2.x.51]是接触区域。如果接触面积不知道，我们有一个不同的问题
*
* 称为 "障碍物问题"
*
* --在[2.x.52]中进行建模）。)
* 作为第一个例子，我们研究[2.x.53]上的零迪里切特边界条件。如果我们在[2.x.54]上应用零Neumann边界条件或两者的混合，也适用同样的方程。
* 变分公式可以通过引入两个无限空间[2.x.55]和[2.x.56]来得到，分别用于解[2.x.57]和拉格朗日乘子[2.x.58]。
* 将第一个方程乘以[2.x.59]，第二个方程乘以[2.x.60]，可能时进行部分积分，并利用[2.x.61]的边界条件，我们得到以下变量问题。
* 给定[2.x.63]上的一个足够规则的函数[2.x.62]，找到[1.x.30]的解[2.x.64]。
*
*其中[2.x.65]和[2.x.66]分别代表[2.x.67]在[2.x.68]和[2.x.69]中的标量积。
* 对变量公式的检查告诉我们，空间[2.x.70]可以被看作是[2.x.71]。空间[2.x.72]，在同维度为零的情况下，应取为[2.x.73]，而在同维度为一的情况下，应取为[2.x.74]。
* 因此，函数[2.x.75]应该在[2.x.76]（对于同维度零的情况）或[2.x.77]（对于同维度一的情况）中，这给我们留下了一个拉格朗日乘数[2.x.78]，即[2.x.80]或[2.x.81] 。
* 上述问题的离散化有两种选择。人们可以选择匹配离散化，即[2.x.82]的三角法与[2.x.83]的三角法相一致，或者选择以完全独立的方式离散化这两个域。
* 对于我们上面提出的简单问题，第一种选择显然更有意义：只需对[2.x.84]使用单一的三角法，然后根据[2.x.85]施加某些约束。这种方法的一个例子是在[2.x.86]中研究的，其中解决方案必须保持在一个障碍物之上，这是在[2.x.87]上施加的约束。
* 为了解决更复杂的问题，例如领域[2.x.88]与时间有关的问题，第二种方法可能是更可行的解决方案。处理不对齐的网格本身就很复杂：为了说明如何做，我们研究一个简单的问题。
* 我们在这里描述的技术在文献中使用了许多名称：[1.x.31]、[1.x.32]、[1.x.33]和其他名称之一。其主要原理是，两个网格和两个有限元空间的离散化是完全独立的。这种技术对于模拟流固耦合问题特别有效，其中嵌入结构的配置是问题本身的一部分，人们要解决一个（可能是非线性的）弹性问题来确定[2.x.89]的（与时间有关的）配置，以及[2.x.90]的（可能是非线性的）流动问题，加上流体和固体之间界面上的耦合条件。
* 在这个教程程序中，我们把事情变得简单一些，我们假设嵌入域的配置是以两种可能的方式之一给出的。
*
* -作为变形映射[2.x.91]，定义在[2.x.92]上的连续有限维空间上，对于任何点[2.x.93]，其坐标[2.x.94]在[2.x.95]中表示。
*
* - 作为[2.x.97]的位移映射[2.x.96]，代表任何点[2.x.98]的位移矢量，以使[2.x.99]形成其实际配置[2.x.100] 。
* 我们定义了嵌入式参考域[2.x.101]`embedded_grid`：在这个三角形上，我们构建了一个有限维空间（`embedded_configuration_dh`），通过FE_Q对象的有限单元系统（`embedded_configuration_fe`）来描述变形或位移。这个有限维度空间仅用于插值用户提供的函数（`embedded_configuration_function`），代表[2.x.102]（如果参数`use_displacement`被设置为[2.x.103]）或[2.x.104]（如果参数`use_displacement`被设置为[2.x.105] ）。
* 拉格朗日乘数[2.x.106]和用户提供的函数[2.x.107]是通过另一个有限维空间`embedded_dh`和另一个有限元素`embedded_fe`定义的，使用相同的参考域。为了考虑到域的变形，MappingFEField或MappingQEulerian对象都用`embedded_configuration`向量初始化。
* 在嵌入空间中，使用FiniteElement `space_fe`在嵌入网格`space_grid`上构建了一个标准的有限维空间`space_dh`，几乎逐字逐句地遵循[2.x.108]中的方法。
* 我们分别用[1.x.34]和[1.x.35]表示空间[2.x.109]和[2.x.110]的离散化，其中[2.x.111]是`space_dh`的尺寸，[2.x.112]是`embedded_dh`的尺寸。
* 一旦所有的有限维空间都被定义，上述问题的变分公式就会给我们留下以下的有限维方程组。
* [1.x.36]
* 其中
* [1.x.37]
*
* 虽然矩阵[2.x.113]是[2.x.114]上泊松问题的标准刚度矩阵，而向量[2.x.115]是[2.x.117]上带有强制项[2.x.116]的有限元问题的标准右手向量（例如，见[2.x.118]），但矩阵[2.x.119]或其转置[2.x.120]是非标准的，因为它们在两个非匹配的网格上耦合信息。
* 特别是，在计算[2.x.121]的一个条目时出现的积分，是在[2.x.122]上计算的。像通常的有限元一样，我们把这个积分分成来自用于解算[2.x.123]的三角形的所有单元的贡献，我们把[2.x.124]上的积分转化为其边界元素[2.x.125]上的积分，其中[2.x.126]是从[2.x.127]到[2.x.128]的映射，并使用正交公式计算[2.x.129]上的积分。
* [1.x.38]
* 计算这个和是不容易的，因为我们必须评估[2.x.130]。一般来说，如果[2.x.131]和[2.x.132]没有对齐，那么[2.x.133]点相对于[2.x.134]是完全任意的，除非我们想出一个办法，在[2.x.136]上的一个任意点上插值[2.x.135]的所有基函数，否则我们无法计算出矩阵[2.x.137]的一个条目所需的积分。
* 为了评估[2.x.138]，需要采取以下步骤（如下图所示）。
*
* - 对于[2.x.140]中的给定单元[2.x.139]，计算实点[2.x.141]，其中[2.x.142]是用于对[2.x.143]进行积分的正交点之一。
*
* - 找到[2.x.144]的单元，[2.x.145]位于其中。我们将称这个单元为[2.x.146]。
*
* - 为了评估基函数，使用映射[2.x.147]的逆映射，将参考元素[2.x.148]转换为元素[2.x.149]：[2.x.150] 。
* [2.x.151]
* 上面的三个步骤可以通过依次调用来计算。
*
* - [2.x.152]，然后是
*
* - [2.x.153] 我们然后
*
* - 构建一个自定义的正交公式，包含参考单元格中的点，然后
*
* - 构建一个FEValues对象，使用给定的正交公式，并以第一步中获得的单元格为初始化。
* 这就是deal.II函数[2.x.154]在评价一个任意点的有限元场（而不仅仅是一个单一的形状函数）时的做法；但在这种情况下，这将是低效的。
* 一个更好的解决方案是使用一个方便的包装器在一个点的集合上执行前三个步骤。  [2.x.155]如果人们确实对计算完整的耦合矩阵感兴趣，那么可以调用方法[2.x.156]，该方法以有效的方式执行上述步骤，重复使用所有可能的数据结构，并将昂贵的步骤集合起来。这就是我们在本教程后面要使用的函数。
* 我们通过迭代求解器来解决最终的鞍点问题，应用于舒尔补码[2.x.157]（其构造在[2.x.158]中有所描述），我们使用LinearOperator类构造[2.x.159]。
*

*[1.x.39][1.x.40]


* 我们在这里解决的问题与[2.x.160]相同，不同的是我们对一个嵌入域施加了一些约束[2.x.161]。本教程是以独立于维度的方式编写的，在结果部分我们展示了如何改变`dim`和`spacedim`。
* 本教程是在`dim`等于1，`spacedim`等于2的情况下编译的。如果你想在嵌入维度`spacedim`等于3的情况下运行程序，你很可能想改变[2.x.162]的参考域，例如，你从文件中读到的东西，或者你后来变形为更有趣的东西的封闭球。
* 在默认情况下，[2.x.163]的同维度为1，本教程程序实现了虚构边界法。事实证明，同样的技术被用于变异沉浸有限元法，上面定义的耦合算子[2.x.164]在几乎所有的非匹配方法中都是一样的。
* 嵌入域被假定包括在[2.x.165]中，我们把它当作单元方[2.x.166]。虚域[2.x.167]的定义可以通过参数文件进行修改，可以给出从界线区间[2.x.168]到[2.x.169]中的一条曲线的映射。
* 如果该曲线是封闭的，那么结果将类似于在边界为[2.x.170]的网格上运行相同的问题。程序也可以在非封闭的[2.x.171]上运行，尽管在这些情况下，问题的数学表述更加困难，因为[2.x.172]本身就有一个边界，相对于域[2.x.173]来说是二维的。
*

*[1.x.41][1.x.42]


* [2.x.174] [2.x.175] Glowinski, R., T.-W.Pan, T.I. Hesla, and D.D. Joseph.1999."分布式拉格朗日乘数/虚构域方法用于颗粒物流动"。  International Journal of Multiphase Flow 25 (5).Pergamon: 755-94.
* [2.x.176] Boffi, D., L. Gastaldi, L. Heltai, and C.S. Peskin.2008."论沉浸边界法的超弹性公式"。应用力学和工程中的计算机方法197（25-28）。
* [2.x.177] Heltai, L., and F. Costanzo.2012."浸没式有限元方法的变量实现"。应用力学和工程中的计算机方法》229-232。[2.x.178]


* [1.x.43] [1.x.44]。
* [1.x.45] [1.x.46] 其中大部分已经在其他地方介绍过了，我们只对新的内容进行评论。
*


*


* [1.x.47]
*
* 参数接受器类是本教程程序的第一个新颖之处：一般来说，参数文件是用来在运行时引导程序的执行。虽然即使是简单的方法也能节省编译时间，因为同一个可执行文件可以用不同的参数设置来运行，但要同时处理数百个参数，同时保持不同程序之间的兼容性会变得很困难。这就是ParameterAcceptor类证明有用的地方。
*


* 该类用于定义一个公共接口，供那些希望使用一个全局ParameterHandler来处理参数的类使用。该类提供了一个静态的ParameterHandler成员，即[2.x.179]，并实现了 "命令设计模式"（例如，见E. Gamma, R. Helm, R. Johnson, J. Vlissides, Design Patterns:Elements of Reusable Object-Oriented Software, Addison-Wesley Professional, 1994. https://goo.gl/FNYByc）。)
*

*
* ParameterAcceptor提供了一个全局订阅机制。每当一个从ParameterAcceptor派生出来的类的对象被构造出来，一个指向该派生类型的对象的指针就会被注册，同时在参数文件中也有一个部分条目。这种注册表在调用单一函数[2.x.180]时被遍历，该函数反过来确保所有存储在全局注册表中的类都声明它们将使用的参数，在声明了这些参数后，它读取`file.prm`的内容来解析实际参数。
*

*
* 如果你为你想在代码中使用的每个参数调用方法[2.x.181]，你就不需要做其他事情了。如果你使用的是一个已经存在的类，它提供了两个函数`declare_parameters`和`parse_parameters`，你仍然可以使用ParameterAcceptor，方法是将现有的类封装成ParameterAcceptorProxy类。
*

*
* 在这个例子中，我们将使用两种策略，为deal.II类使用ParameterAcceptorProxy，并直接从ParameterAcceptor派生我们自己的参数类。
*


* [1.x.48]
*
* 另一个新的包含文件是包含[2.x.182]类的文件。deal.II的结构和许多现代数值库一样，是按照有向无环图（DAG）组织的。DAG是一个具有拓扑顺序的有向图：每个节点在结构上代表一个对象，并通过一条（或多条）有向边与非根节点相连，从父节点到子节点。这种结构最重要的例子是Triangulation及其[2.x.183]结构。从Triangulation（主节点），我们可以访问每个单元（三角形的子节点）。从单元本身，我们可以访问该单元的所有顶点。在这个简单的例子中，DAG结构可以表示为三种节点类型（三角结构、单元格迭代器和顶点），由从三角结构到单元格迭代器，以及从单元格迭代器到顶点的定向边连接。这有几个优点，但它本质上造成了 "不对称"，使某些操作变得很快，而它们的逆向操作却很慢：寻找一个单元的顶点的计算成本很低，可以通过简单地遍历DAG来完成，而寻找所有共享一个顶点的单元则需要进行非难事的计算，除非添加一个新的DAG数据结构来表示逆向搜索。
*

*
* 由于在有限元代码中通常不需要反操作，所以在GridTools中实现了这些操作，而没有使用与三角形相关的额外数据结构，这将使它们的速度更快。例如，一个这样的数据结构是一个从三角形的顶点到所有共享这些顶点的单元的映射，这将减少回答前面问题所需的计算。
*

*
* 有些方法，例如[2.x.184]大量使用了这些非标准的操作。如果你需要多次调用这些方法，那么把这些数据结构存储在某个地方就变得很方便。  [2.x.185]正是这样做的，它让你可以访问以前计算过的对象，或者在飞行中计算它们（然后将它们存储在类中供以后使用），并确保每当三角测量被更新时，相关的数据结构也被重新计算。
*


* [1.x.49]
*
* 在这个例子中，我们将使用一个参考域来描述一个嵌入的三角形，通过一个有限元矢量场进行变形。
*

*
* 接下来的两个包含文件包含了在这些情况下可以使用的两个类的定义。MappingQEulerian允许人们通过位移*场来描述一个领域，基于FESystem[FE_Q(p)^spacedim]有限元空间。第二种是比较通用的，允许你使用任意的矢量有限元空间，只要它们能提供一个连续的*域描述。
 对你的领域的描述。在这种情况下，描述是通过实际变形*场，而不是位移*场完成的。
*

*
* 使用哪一个取决于用户想如何指定参考域，和/或实际配置。我们将提供这两个选项，并在本教程程序的结果部分做一些实验。
*


* [1.x.50]
*
* 被解析的函数类是另一个新条目。它允许人们创建一个Function对象，从参数文件中的一个字符串开始，它被解析成一个对象，你可以在deal.II接受Function的任何地方使用（例如，用于插值、边界条件等）。
*


* [1.x.51]
*
* 这是本教程程序的最后一个新条目。命名空间NonMatching包含了一些方法，这些方法在对非匹配网格或不与底层网格对齐的曲线进行计算时非常有用。
*

*
* 我们将在后面的 "setup_coupling "方法中详细讨论其用途。
*


* [1.x.52]
*
* [1.x.53] [1.x.54].
* 在DistributedLagrangeProblem中，我们需要两个参数来描述域[2.x.186]（`dim`）和域[2.x.187]（`spacedim`）的尺寸。   
* 这些将被用来初始化一个三角形<dim,spacedim>（用于[2.x.188]）和一个三角形<spacedim,spacedim>（用于[2.x.189] ）。   
* 与其他教程程序相比，一个新奇之处在于大量使用了 [2.x.190] 这些行为就像经典的指针，其优点是可以进行自动的内部管理：一旦unique_ptr超出范围，所包含的对象就会被自动销毁，即使它在一个容器中或者有一个异常。此外，它不允许有重复的指针，这可以防止所有权问题。我们这样做，是因为我们希望能够 i) 构建问题，ii) 读取参数，iii) 根据参数文件中指定的内容初始化所有对象。   
* 我们在派生于ParameterAcceptor的内部类`Parameters`中构建我们问题的参数。DistributedLagrangeProblem "类需要一个对 "Parameters "对象的常量引用，因此不可能从DistributedLagrangeProblem类本身修改参数。   
* 我们可以先初始化参数，然后将参数传递给DistributedLagrangeProblem，假设所有条目都设置为所需的值，但这有两个缺点。
*


*


*


*


*


*


*


*
* - 我们不应该对用户如何初始化一个不受我们直接控制的类做出假设。如果用户未能初始化该类，我们应该注意到并抛出一个异常。
*


*


*


*


*


*


*


*
* - 当我们构造参数时，并不是所有需要从参数文件中读取参数的对象都是可用的；对于复杂的程序，有多种物理现象，或者我们在一些外部类中重复使用现有的代码，往往是这种情况。我们通过将一些 "复杂 "的对象，如ParsedFunction对象，保留在`DistributedLagrangeProblem`内而不是`Parameters`内来模拟这种情况。   
* 这里我们假设在构建时，构建我们问题的类还不能使用。解析参数文件是确保我们有所有的成分来建立我们的类，我们的设计是，如果解析失败，或者没有被执行，运行就会被中止。
*


*


* [1.x.55]
*
* `Parameters`类派生于ParameterAcceptor。这使得我们可以在其构造函数中使用[2.x.191]方法。     
* 这个函数的成员都是非常量的，但是`DistributedLagrangeProblem`类需要一个对`Parameters`对象的常量引用：这确保参数不会从`DistributedLagrangeProblem`类中被修改。
*


* [1.x.56]
*
* 现在描述的参数都可以用参数文件在外部设置：如果运行可执行文件时没有参数文件，程序会用这里定义的默认值创建一个 "参数.prm "文件，然后中止，让用户有机会修改参数.prm文件。
*

*
* 嵌入网格的初始细化，对应于域[2.x.192] 。
*


* [1.x.57]
*
* 嵌入网格[2.x.193]和嵌入网格[2.x.194]之间的互动是通过计算[2.x.195]来处理的，这涉及到[2.x.196]的所有单元与[2.x.197]的部分重叠：对这些单元进行更高的细化可能提高我们计算的质量。为此，我们定义了 "delta_refinement"：如果它大于零，那么我们将空间网格中包含嵌入网格顶点的每个单元及其相邻的单元标记出来，执行细化，并重复这个过程 "delta_refinement "次。
*


* [1.x.58]
*
*开始细化嵌入式网格，对应于域[2.x.198]。
*


* [1.x.59]
*
* 边界id的列表，在这个列表中我们施加同质的Dirichlet边界条件。在其余的边界id上（如果有的话），我们施加同质的诺伊曼边界条件。作为一个默认的问题，我们在[2.x.199]上设置了零迪里切特边界条件。
*


* [1.x.60]
*
* 嵌入空间的有限元素程度。  [2.x.200]
*


* [1.x.61]
*
* 嵌入空间的有限元素程度。  [2.x.201]
*


* [1.x.62]
*
* 用于描述嵌入域的变形的空间的有限元程度
*


* [1.x.63]
*
*用于整合耦合的正交公式的顺序
*


* [1.x.64]
*
* 如果设置为 "true"，那么嵌入式配置函数将被解释为位移函数
*


* [1.x.65]

* 在输出中使用的粗略程度
*


* [1.x.66]
*
* 一个标志，用于跟踪我们是否被初始化了
*


* [1.x.67]
*
* DistributedLagrangeProblem的入口点
*


* [1.x.68]
*
* 包含实际参数的对象
*


* [1.x.69]
*
* 下面的函数与其他所有的教程程序相似，不同的是我们现在需要为两个不同系列的对象进行设置，即与embedding*网格相关的对象，以及与embedded*相关的对象。
*


*


* [1.x.70]
*
* 我们这里唯一的非常规函数是`setup_coupling()`方法，用于生成耦合矩阵的稀疏模式 [2.x.202] 。
*


*


* [1.x.71]
*
*首先我们收集所有与嵌入空间几何学有关的对象
*


*


* [1.x.72]
*
* 然后是与嵌入网格有关的，与拉格朗日乘数`lambda`有关的DoFHandler
*


*


* [1.x.73]
*
* 最后，所有需要形成*内嵌三角形的东西。
*


* [1.x.74]
*
* ParameterAcceptorProxy类是一个 "透明 "的包装器，从ParameterAcceptor和作为其模板参数传递的类型中衍生出来。在构造时，参数被分成两部分：第一个参数是转发给ParameterAcceptor类的[2.x.203]，并包含应该用于该类的部分名称，而所有其余的参数都被转发给模板类型的构造器，在这里是转发给[2.x.204]构造器。     
* 这个类允许你结合ParameterAcceptor注册机制使用现有的类，只要这些类有`declare_parameters()`和`parse_parameters()`成员。     
* 这里就是这种情况，使得利用[2.x.205]类相当容易：不要求用户在代码中为RHS、边界函数等创建新的Function对象（就像在其他大多数教程中那样），这里我们允许用户使用deal.II接口到muParser（http://muparser.beltoforion.de），其中函数的规范不是在编译时完成，而是在运行时，使用一个字符串被解析成一个实际的Function对象。     
* 在这种情况下，`embedded_configuration_function`是一个向量值的Function，根据`parameters.use_displacement`的布尔值，可以被解释为adeformation*或adisplacement*。组件的数量在后面的构造中指定。
*


*


* [1.x.75]
*
* 我们做同样的事情来指定函数[2.x.206]的值，这就是我们希望我们的解在嵌入空间中的值。在这种情况下，该函数是一个标量函数。
*


* [1.x.76]
*
* 与我们对[2.x.207]类所做的类似，我们对ReductionControl类重复同样的做法，允许我们为我们以后使用的Schur补码迭代求解器指定所有可能的停止标准。
*


* [1.x.77]
*
* 接下来我们收集所有我们需要的SparsityPattern, SparseMatrix, 和Vector对象
*


* [1.x.78]
*
* TimerOutput类被用来提供一些关于我们程序性能的统计数据。
*


* [1.x.79]
*
* [1.x.80] [1.x.81]
* 在构建时，我们也要初始化ParameterAcceptor类，并在解析参数文件时使用我们希望的章节名称。   
* 参数文件可以被组织成节/子节/等等：这样做的好处是，定义的对象在共享同一节/子节/等等时可以共享参数。ParameterAcceptor允许使用Unix约定的路径来指定部分名称。如果部分名称以斜线（"/"）开头，那么该部分将被解释为绝对路径*，ParameterAcceptor为路径中的每个目录输入一个小节，使用它遇到的最后一个名称作为当前类的登陆小节。   
* 例如，如果你用`ParameterAcceptor("/first/second/third/My Class")`构建你的类，参数将被组织如下。   
* [2.x.208]
*在内部，存储在ParameterAcceptor中的current path*现在被认为是"/first/second/third/"，也就是说，当你指定一个绝对路径时，ParameterAcceptor会将*当前的部分改为当前路径，即改为直到最后*"/"的部分名称的路径。   
* 你现在可以使用相对路径（例如，`ParameterAcceptor("My Other Class")`）而不是绝对路径（例如，`ParameterAcceptor("/first/second/third/My Other Class")`）构建从ParameterAcceptor派生的另一个类，获得。  [2.x.209]
* 如果部分名称*以斜线结尾，那么后续的类将把它解释为完整的路径：例如，与上面类似，如果我们有两个类，一个用`ParameterAcceptor("/first/second/third/My Class/")`初始化，另一个用`ParameterAcceptor("My Other Class")`，那么得到的参数文件将看起来像。   
* [2.x.210]
* 我们将利用这一点，使我们的`Parameters`成为所有后续构建的类的父*。由于大多数其他的类都是 "DistributedLagrangeProblem "的成员，这允许，例如，为两个不同的维度构造两个 "DistributedLagrangeProblem"，而不会在这两个问题的参数中产生冲突。
*


* [1.x.85]
*
* [2.x.211]函数做了几件事。
*


*


*


*


*


*


*


*


*


*
* - 在施工时向ParameterAcceptor输入指定的分节。
*


*


*


*


*


*


*


*


*


*
* - 调用[2.x.212]函数
*


*


*


*


*


*


*


*


*


*
* - 调用你可能附加在[2.x.213]上的任何信号
*


*


*


*


*


*


*


*


*


*
* - 离开分节
* 反过来，[2.x.214]。



*


*


*


*


*


*


*


*


*
* - 在参数处理程序中为给定的变量声明一个条目。
*


*


*


*


*


*


*


*


*


*
* - 获取变量的当前值
*


*


*


*


*


*


*


*


*


*
* - 将其转换为一个字符串，作为参数文件的默认值使用
*


*


*


*


*


*


*


*


*


*
* - 在[2.x.215]中附加一个动作*，当文件被解析时，或当一个条目被设置时，它会更新传递给`add_parameter()`的变量的值，将其设置为输入文件中指定的内容（当然，是在输入文件被解析并将文本表示法转换为变量的类型之后）。
*


* [1.x.86]
*
* 一旦参数文件被解析，那么参数就可以使用了。设置内部变量`initialized`为true。
*


* [1.x.87]
*
* 构造函数是非常标准的，除了 "ParameterAcceptorProxy "对象，如前所述。
*


* [1.x.88]
*
* 这里有一种方法可以为使用ParameterAcceptorProxy构建的ParameterAcceptor类设置默认值。     
* 在这种情况下，我们将嵌入式网格的默认变形设置为半径为[2.x.216]、中心为[2.x.217]的圆，我们将embedded_value_function的默认值设置为常数，并为SolverControl对象指定一些合理的值。     
* 嵌入[2.x.218]是最基本的：从[2.x.219]的定义可以看出，如果[2.x.220]，矩阵[2.x.221]的某些行将为零。这将是一个问题，因为舒尔补码法要求[2.x.222]具有全列秩。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。
* 函数[2.x.223]是用来设置有限元空间的。注意[2.x.224]是如何用来创建包裹在[2.x.225]对象内的对象的。
*


* [1.x.92]
*
* 初始化 [2.x.226] : 构建三角形，并将其包装成一个[2.x.227]对象
*


* [1.x.93]
*
* 接下来，我们使用[2.x.228]实际创建三角形，最后一个参数设置为真：这激活了着色（即为边界的不同部分分配不同的边界指标），我们用它来分配迪里切特和诺伊曼条件。
*


* [1.x.94]
*
* 一旦我们构建了一个三角形，我们就根据参数文件中的规格对其进行全局细化，并用它构建一个[2.x.229]。
*


* [1.x.95]
*
* 对嵌入式网格也是如此。由于嵌入式网格是变形的，我们首先需要设置变形映射。我们在下面几行中这样做。
*


* [1.x.96]
*
* 一旦我们为变形定义了一个有限维度的空间，我们就对参数文件中定义的 "嵌入_配置_函数 "进行插值。
*


* [1.x.97]
*
* 现在我们可以根据用户在参数文件中指定的内容来解释它：作为位移，在这种情况下，我们构建一个映射，将我们的配置有限元空间的每个支持点的位置在相应的配置矢量上按指定的量进行位移*，或者作为赦免位置。     
* 在第一种情况下，MappingQEulerian类提供其服务，而在第二种情况下，我们将使用MappingFEField类。它们实际上是非常相似的。MappingQEulerian只适用于FE_Q有限元空间系统，其中位移矢量存储在FES系统的第一个`spacedim`分量中，并且在构造时作为参数给出的度数必须与第一个`spacedim`分量的度数一致。     
* MappingFEField类稍显一般，因为它允许你在构造近似时选择任意的FiniteElement类型。当然，根据你选择的FiniteElement的类型，一些选择可能（也可能没有）意义。MappingFEField实现了纯粹的等参量概念，例如，可以通过与FE_Bernstein有限元类结合，在deal.II中实现等参量分析代码。在这个例子中，我们将考虑到一个配置将是一个 "位移"，而另一个将是一个绝对的 "变形 "场，从而将两者互换使用。
*


*


* [1.x.98]
*
* 在这个教程程序中，我们不仅对[2.x.230]进行全局细化，还允许根据[2.x.231]的位置进行局部细化，根据`parameters.delta_refinement`的值，我们用来决定应该对[2.x.232]进行多少轮局部细化，对应于[2.x.233]的位置。     
* 有了这个映射，现在就可以通过调用方法[2.x.234]来查询与`嵌入式_dh'相关的所有支持点的位置。
* 这个方法有两个变体。一种是不*接受Mapping，另一种是接受Mapping。如果你使用第二种类型，就像我们在这个案例中做的那样，支持点是通过指定的映射来计算的，它可以对它们进行相应的操作。     
* 这正是`embedded_mapping`的作用。
*


* [1.x.99]
*
* 一旦我们有了嵌入有限元空间的支持点，我们就想确定嵌入空间的哪些单元包含哪些支持点，以便在有必要的地方，也就是嵌入网格的地方，获得完善嵌入网格的机会。这可以手动完成，在每个支持点上循环，然后为嵌入空间的每个单元调用方法[2.x.235]，直到我们找到一个返回单位参考单元中的点，或者可以用更智能的方式完成。     
* [2.x.236]是一个可能的选择，它以更便宜的方式执行上述任务，首先确定嵌入三角的最接近目标点的顶点，然后只对那些共享找到的顶点的单元调用[2.x.237]。     
* 事实上，在GridTools命名空间中，有一些算法利用[2.x.238]对象，可能还有KDTree对象来尽可能地加快这些操作。     
* 利用最大速度的最简单的方法是调用一个专门的方法，[2.x.239]，在第一个点的搜索过程中会存储很多有用的信息和数据结构，然后在后续的点上重用所有这些。     
* [2.x.240]返回一个元组，其中第一个元素是一个包含输入点的单元格向量，在这里是support_points。对于细化，这是我们唯一需要的信息，而这正是现在发生的事情。     
* 然而，当我们需要组装一个耦合矩阵时，我们还需要每个点的参考位置来评估嵌入空间的基础函数。由[2.x.241]返回的元组的其他元素允许你重建，对于每个点，什么单元包含它，以及什么是给定点的参考单元的位置。由于这些信息最好被分组到单元格中，那么这就是算法返回的内容：一个元组，包含所有单元格中至少有一个点的向量，以及所有参考点的列表和它们在原始向量中的相应索引。     
* 在下面的循环中，我们将忽略所有返回的对象，除了第一个，确定所有单元格至少包含一个嵌入空间的支持点。这允许一个简单的自适应细化策略：细化这些单元和它们的邻居。     
* 注意，我们需要做一些理智的检查，在这个意义上，我们希望有一个嵌入网格，它在嵌入网格周围被很好地细化，但其中两个连续的支持点要么位于同一个单元，要么位于邻居嵌入单元。     
* 这只有在我们确保嵌入网格的最小单元尺寸仍然大于嵌入网格的最大单元尺寸的情况下才能实现。由于用户可以修改细化水平，以及他们希望在嵌入网格周围进行的局部细化的数量，我们要确保所得到的网格满足我们的要求，如果不是这样，我们就以例外的方式放弃。
*


* [1.x.100]
*
* 为了构建一个良好的耦合插值算子[2.x.242]，对嵌入域和被嵌入域之间的网格的相对尺寸有一些限制。耦合算子[2.x.243]和空间[2.x.244]和[2.x.245]必须满足一个inf-sup条件，以使问题有一个解决方案。事实证明，只要空间[2.x.247]和[2.x.248]之间相互兼容（例如，只要它们被选为引言中描述的那些），非匹配[2.x.246]投影就满足这样的inf-sup条件。     
* 然而，discrete* inf-sup条件也必须成立。这里没有出现复杂的情况，但事实证明，当非匹配网格的局部直径离得太远时，离散inf-sup常数会恶化。特别是，事实证明，如果你选择一个相对于嵌入网格更细*的嵌入网格，那么inf-sup常数的恶化程度要比你让嵌入网格更细的情况下大得多。     
* 为了避免问题，在本教程中，如果用户选择的参数使嵌入网格的最大直径大于嵌入网格的最小直径，我们将抛出一个异常。     
* 这种选择保证了几乎每个嵌入网格的单元都不超过两个嵌入网格的单元，只有一些罕见的例外，这些例外在结果的inf-sup方面可以忽略不计。
*


* [1.x.101]
*
* [2.x.249]已被完善，我们现在可以设置它的DoF了
*


* [1.x.102]
*
* 我们现在设置[2.x.250]和[2.x.251]的DoF：因为它们从根本上是独立的（除了[2.x.252]的网格在[2.x.253]周围更加精细），程序是标准的。
*


* [1.x.103]
*
* 根据定义，刚度矩阵只涉及[2.x.254]的DoF。
*


* [1.x.104]
*
* 根据定义，我们要解决的系统的Rhs只涉及一个零向量和[2.x.255]，它只用[2.x.256]的DoF计算。
*


* [1.x.105]
*
* 创建耦合稀疏模式是一个复杂的操作，但可以使用[2.x.257]轻松完成，它需要两个DoFHandler对象，耦合的正交点，一个DynamicSparsityPattern（然后需要像往常一样复制到稀疏模式中），嵌入和嵌入三角形的分量掩码（我们留空）以及嵌入和嵌入三角形的映射。
*


* [1.x.106]
*
* [1.x.107] [1.x.108].
* 以下函数创建矩阵：如前所述，计算刚度矩阵和rhs是一个标准程序。
*


* [1.x.109]
*
* 嵌入刚度矩阵 [2.x.258] ，以及右手边 [2.x.259] 。



* [1.x.110]
*
* 为了计算耦合矩阵，我们使用[2.x.260]工具，其工作原理与[2.x.261]相似。
*


* [1.x.111]
*
* [1.x.112] [1.x.113]。
* 所有的部分都已经组装好了：我们用舒尔补数法解决这个系统
*


* [1.x.114]

*从创建反刚度矩阵开始
*


* [1.x.115]
*
* 初始化运算符，如介绍中所述
*


* [1.x.116]
*
* 使用舒尔补数法
*


* [1.x.117]

* 下面的函数只是在两个独立的文件上生成标准结果输出，每个网格一个。
*


* [1.x.118]
*
* 这两个输出例程之间的唯一区别是，在第二种情况下，我们想在当前配置上输出数据，而不是在参考配置上。这可以通过将实际的embedded_mapping传递给[2.x.262]函数来实现。该映射将负责在实际变形的配置上输出结果。
*


*


* [1.x.119]
*
* 与所有其他教程程序类似，`run()`函数只是按正确的顺序调用所有其他方法。没有什么特别需要注意的，只是在我们实际尝试运行我们的程序之前，我们检查是否完成了解析。
*


* [1.x.120]
*
* 与其他教程程序中的情况不同，这里我们使用ParameterAcceptor风格的初始化，即首先构建所有对象，然后对静态方法[2.x.263]发出一次调用，以填充从ParameterAcceptor派生的类的所有参数。       
* 我们检查用户是否在程序启动时指定了一个参数文件名来使用。如果是，就尝试读取该参数文件，否则就尝试读取文件 "参数.prm"。       
* 如果指定的参数文件（隐含的或明确的）不存在，[2.x.264]将为你创建一个，并退出程序。
*


*


* [1.x.121]
* [1.x.122][1.x.123] 。


*运行这个程序的目录中默认不包含参数文件。另一方面，这个程序想从一个叫做parameters.prm的文件中读取它的参数。
*
* 因此，当你第一次执行它时，你会得到一个异常，即找不到这样的文件。
* [1.x.124]
*
* 然而，正如错误信息已经指出的那样，触发该异常的代码也将生成一个参数.prm文件，该文件只包含该程序所关心的所有参数的默认值。通过检查参数文件，我们看到以下内容。
* [1.x.125]
*
* 如果你现在运行这个程序，你会得到一个叫做`used_parameters.prm`的文件，其中包含上述参数的简短版本（没有注释和文档），记录了所有用于运行程序的参数。
* [1.x.126]
*
* 首先创建`parameters.prm`文件(程序第一次运行)，然后创建`used_parameters.prm`(每隔一段时间运行程序)，其理由是你可能想让大多数参数保持其默认值，而只修改其中一小部分。
* 例如，你可以在这个教程程序中使用以下（完全有效的）参数文件。
* [1.x.127]
*
* 你会得到与下面测试案例1完全相同的结果。
* [1.x.128][1.x.129] 。


* 对于默认问题，[2.x.265]在[2.x.266]上的值被设置为常数[2.x.267]：这就像在[2.x.268]上施加一个常数迪里切特边界条件，被视为[2.x.269]在[2.x.270]内的部分的边界。同样，在[2.x.271]上我们有零迪里切特边界条件。
*

* [2.x.272]
* 该程序的输出结果将如下所示。
* [1.x.130]
*
* 你可能会注意到，就CPU时间而言，组装耦合系统的成本是组装标准泊松系统的两倍，尽管矩阵更小。这是由于离散化的非匹配性质造成的。这是否可以接受，取决于应用。
* 如果问题被设置在三维环境中，并且浸入式网格与时间有关，那么在每一步重新创建网格要比使用我们这里介绍的技术要昂贵得多。此外，你也许可以在一个均匀细化的正方形或立方体网格上创建一个非常快速和优化的求解器，并在你想进行计算的领域嵌入这里的技术。这就要求你只拥有你的领域的表面代表（一个更便宜和更容易制作的网格）。
* 为了玩一玩，我们要把虚构的领域以及我们施加在它上面的边界条件复杂化一点。
* [1.x.131][1.x.132] 。
*

* 如果我们使用以下参数文件。
* [1.x.133]
*
* 我们得到一个看起来像 "花 "的域，在这里我们施加一个线性边界条件 [2.x.273] 。这个测试表明，该方法在从其边界条件中恢复一个完全线性的函数方面实际上是相当准确的，即使网格没有对齐，我们也得到了一个相当好的结果。
* 用[2.x.275]替换[2.x.274]，即修改参数文件，以便我们有
* [1.x.134]
* 产生右边的马鞍。
* [2.x.276]
* [1.x.135][1.x.136][1.x.137] 。


*[1.x.138][1.x.139]。


* 虽然目前的教程程序是为 "spacedim "等于2而编写的，但为了使程序能够在不同的尺寸组合中运行，你只需要做一些小的改动。
* 如果你想在 "spacedim "等于3，"dim "等于2的情况下运行，你几乎肯定要做以下改动。
*
* - 为嵌入式网格使用不同的参考域，也许是从文件中读取。不可能用一个正方形域的单一参数来构造一个光滑的封闭表面，因此你很可能想使用一个拓扑学上等同于球体边界的参考域。
*
* - 使用位移而不是变形来将[2.x.277]映射到[2.x.278]。
* [1.x.140][1.x.141]。
*

* 我们已经在其他教程中看到（例如在[2.x.279]和[2.x.280]）如何从输入文件中读取网格。对于这个教程程序来说，一个很好的概括是允许用户从参数文件中选择要读取的网格，而不是在教程程序本身硬编码网格类型。
* [1.x.142][1.x.143] 。


* 目前，我们没有关于Schur补数的预处理程序。这在二维问题上是可以的，几百次迭代就可以把残差降低到机器的精度，但在三维问题上就不行了。
* 在这里，好的预处理程序是什么并不明显。我们用舒尔补码解决的物理问题是将迪里切特数据[2.x.281]与拉格朗日乘数[2.x.282]的值联系起来。  [2.x.283]可以解释为法线梯度的跳跃*，需要强加在[2.x.284]和[2.x.285]之间，以获得Dirichlet数据[2.x.286]。
* 所以[2.x.287]是某种诺伊曼到迪里切特的地图，我们希望有一个迪里切特到诺伊曼地图的良好近似。一个可能性是使用[2.x.288]上的问题的边界元素近似，并构建一个与[2.x.289]相关的泊松问题的超星形算子的近似，这正是一个迪里切特到诺依曼的映射。
*[1.x.144][1.x.145]
*

* 这里提出的简单代码可以作为更复杂问题的起点，要解决这些问题，需要在并行代码上运行，可能使用分布式网格（见[2.x.290]、[2.x.291]，以及[2.x.292]和[2.x.293]的文档）。
* 当并行使用非匹配网格时，会出现一个问题：为了计算矩阵[2.x.294]，一个进程需要关于真实空间同一区域的两个网格的信息，但是，当使用分布式网格时，这种信息可能无法获得，因为存储在特定处理器上的[2.x.295]三角测量的本地拥有部分可能与存储在同一处理器上的[2.x.296]三角测量的本地拥有部分不在同一位置上。
* 可以实施各种策略来解决这个问题。
*
* - 分布两个网格，以便满足这个约束条件。
*
* - 对不满足该约束的实空间部分使用通信。
*
* - 对嵌入空间使用分布式三角法，对模拟配置使用共享三角法。
* 后一种策略显然是最容易实现的，因为本教程程序中使用的大多数函数在并行情况下也会不变地工作。当然，我们可以使用反转策略（即有一个分布式嵌入式三角函数和一个共享的嵌入三角函数）。
* 然而，这种策略很可能会更加昂贵，因为根据定义，嵌入网格要比嵌入网格大，而且分布两个网格中最大的网格更有意义，保持所有处理器之间共享的小石块。
*

* [1.x.146][1.x.147] [2.x.297] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-6_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28]
*[1.x.29][1.x.30][1.x.31] 。


* [2.x.2]
* 这个程序最终是关于deal.II的主要特征之一：使用自适应（局部）细化网格。这个程序仍然基于[2.x.3]和[2.x.4]，正如你将看到的，它实际上不需要太多的代码来实现自适应性。事实上，虽然我们做了大量的解释，但自适应网格可以被添加到一个现有的程序中，只需十几行的额外代码。该程序显示了这些行是什么，以及自适应网格细化（AMR）的另一个重要成分：一个标准，可以用来确定是否有必要细化一个单元，因为它的误差很大，是否可以粗化该单元，因为它的误差特别小，或者我们是否应该保持该单元的原状。我们将在下文中讨论所有这些问题。
*

*[1.x.32][1.x.33]


* 有许多方法可以适应性地细化网格。整个算法的基本结构总是相同的，包括以下步骤的循环。
*
* 解决当前网格上的PDE。
*
* - 使用一些指示性的标准来估计每个单元的误差。
*
* - 标记那些有大误差的单元进行细化，标记那些有特别小误差的单元进行粗化，其余的不做处理。
*
* - 细化和粗化那些被标记的单元，以获得一个新的网格。
*
* - 在新的网格上重复上述步骤，直到整体误差足够小。
* 由于一些可能被历史遗忘的原因(可能是这些函数曾经用FORTRAN语言实现，这种语言并不关心某个东西是用小写字母还是大写字母拼写，程序员往往习惯性地选择大写字母)，上述循环在关于网格适应性的出版物中经常被引用为SOLVE-ESTIMATE-MARK-REFINE循环(用这种拼法)。
* 然而，除了这个结构之外，还有各种方法来实现这一目标。从根本上说，它们的区别在于如何从上一个网格生成一个网格。
* 如果使用三角形(deal.II不做)，那么有两种基本的可能性。
*
* - 最长边细化。在这个策略中，通过从最长边的中点到对面的顶点引入一条新的边，将标记为细化的三角形切割成两个。当然，来自最长边的中点必须以某种方式通过也*细化该边另一侧的单元格（如果有的话）来平衡。如果有问题的边也是相邻单元的最长边，那么我们就可以直接通过相邻单元运行一条新的边到对面的顶点；否则就需要一个稍微复杂的构造，在相邻单元的至少一条其他边上增加更多的新顶点，然后可能传播到相邻单元的邻居，直到算法终止。这很难用语言描述，而且因为deal.II不使用三角形，不值得在这里花时间。  但如果你很好奇，你可以随时在本介绍顶部显示的链接中观看视频讲座15。
*
* - 红绿色的细化。另一个选择是所谓的 "红绿细化"。  这种策略甚至更难描述（但也在视频讲座中讨论过），其优点是细化不会传播到我们想要细化的单元的近邻之外。然而，它的实施难度大大增加。
* 这些方法还有其他的变化，但重要的一点是，它们总是产生一个网格，其中两个单元的接触线是两个相邻单元的整个边缘。只要稍加努力，这种策略就可以很容易地适用于由四面体构成的三维网格。
* 这两种方法对二维的四边形和三维的六面体都不起作用，或者至少不容易。原因是，从要精化的四边形单元的四边形邻居中创建的过渡元素将是三角形，而我们并不希望如此。因此，在deal.II中选择的适应性方法是使用网格，其中相邻的单元在细化水平上可能相差一个。这就导致在单元的界面上出现了属于一方的节点，但在另一方是不平衡的。这些节点的通用术语是 "悬空节点"，这些网格在一个非常简单的情况下看起来是这样的。
* [2.x.5]
* 一个更复杂的二维网格会是这样的（在下面的 "结果 "部分会讨论）。
* <img src="https://www.dealii.org/images/steps/developer/step_6_grid_5_ladutenko.svg" alt="第五个自适应细化的Ladutenko网格：单元格沿着内圈聚集。" width="300" height="300">。
* 最后，一个具有这种悬挂节点的三维网格（来自[2.x.6]）显示在这里。
* <img src="https://www.dealii.org/images/steps/developer/ [2.x.7] .3d.mesh.png" alt="" width="300" height="300">。
* 第一个和第三个网格当然是基于一个正方形和一个立方体，但正如第二个网格所显示的，这并不是必要的。重要的一点是，我们可以独立于其邻居来细化一个网格（受制于一个单元只能比其邻居多细化一次的约束），但是如果我们这样做，我们就会出现这些&ldquo;悬空节点&rdquo;。
*

*[1.x.34][1.x.35]


* 现在你已经看到了这些自适应细化网格的样子，你应该问[1.x.36]我们为什么要这样做。毕竟，我们从理论上知道，如果我们对网格进行全局细化，误差会下降到零，因为
* [1.x.37]
* 其中[2.x.8]是独立于[2.x.9]和[2.x.10]的某个常数，[2.x.11]是使用中的有限元的多项式程度，[2.x.12]是最大单元的直径。那么，如果[1.x.38]单元很重要，为什么我们要在域的某些部分而不是所有的部分制作精细的网格？
* 答案是上面的公式并不是最优的。事实上，一些更多的工作表明，以下是一个更好的估计（你应该与上述估计的平方进行比较）。
* [1.x.39]
* (因为[2.x.13]，如果你只是把网格大小从总和中拉出来，这个公式立刻就暗示了前面的公式。)这个公式所暗示的是，没有必要把[1.x.40]单元做小，而是单元真的只需要做小[1.x.41]！换句话说。例如，如果我们使用一个线性元素[2.x.15]，那么即使网格很粗，那些几乎是线性的地方（如[2.x.16]很小）也会得到很好的解决。只有那些二阶导数大的地方才会被大的元素解决得很差，因此这就是我们应该把网格变小的地方。
* 当然，这个[1.x.42]在实践中不是很有用，因为我们不知道问题的精确解[2.x.17]，因此，我们不能计算[2.x.18]。但是，这也是通常采取的方法，我们可以只根据我们之前计算的离散解[2.x.20]来计算[2.x.19]的数字近似值。我们将在下面稍微详细地讨论这个问题。这将有助于我们确定哪些单元具有较大的[2.x.21]st导数，然后这些单元将成为细化网格的候选单元。
*

*[1.x.43][1.x.44]


* 上面提到的使用三角形网格的方法要花很大力气确保每个顶点都是所有相邻单元的顶点。
*
* 也就是说，没有悬空的节点。这就自动地确保了我们能够以这样的方式定义形状函数，即它们是全局连续的（如果我们使用迄今为止在教程程序中一直使用的常见的[2.x.22]Lagrange有限元方法，如FE_Q类所代表的）。
* 另一方面，如果我们在有悬挂节点的网格上定义形状函数，我们最终可能得到不连续的形状函数。请看这一点，想想上面的情况，即右上角的单元没有被细化，并考虑一下使用双线性有限元。在这种情况下，与悬挂节点相关的形状函数是以明显的方式定义在与每个悬挂节点相邻的两个小单元上。但我们如何将它们扩展到相邻的大单元上呢？显然，函数对大单元格的扩展不能是双线性的，因为这样它需要沿着大单元格的每条边线性化，这意味着它在整条边上需要为零，因为它在该边上的大单元格的两个顶点需要为零。但是，当从小单元一侧看时，它在悬空节点本身不是零。
*
* - 所以它不是连续的。以下三幅图显示了沿着有关边的三个形状函数，当以通常的方式简单地根据它们相邻的单元格来定义时，这些形状函数被证明是不连续的。
* [2.x.23]
*

*但我们确实希望有限元解是连续的，这样我们就有一个&ldquo;符合要求的有限元方法&rdquo;，其中离散有限元空间是我们寻求拉普拉斯方程解的[2.x.24]函数空间的一个适当子集。诀窍是要认识到，虽然上面显示的形状函数是不连续的（因此它们的[1.x.45]线性组合也是不连续的），但形状函数加起来为[2.x.25]的线性组合可以是连续的[1.x.46]。换句话说，系数[2.x.26]不能任意选择，而必须满足某些约束条件，使函数[2.x.27]实际上是连续的。这些约束条件在概念上比较容易理解，但在软件中的实现是复杂的，需要几千行代码。另一方面，在用户代码中，当处理悬空节点时，你只需要添加大约半打的行。
* 在下面的程序中，我们将展示如何从deal.II中获得约束条件，以及如何在解决线性方程组中使用它们。在讨论下面程序的细节之前，你可能想看一下[2.x.28]文档模块，它解释了这些约束如何计算，以及deal.II中的哪些类对它们起作用。
*

*[1.x.47][1.x.48] 。


* 悬空节点约束的实践比我们上述的理论要简单得多。在现实中，你只需要在[2.x.29]这样的程序中添加半打额外的代码，就可以使它与具有悬挂节点的自适应网格一起工作。有趣的是，这与你要解决的方程完全无关。这些约束的代数性质与方程无关，只取决于有限元的选择。因此，处理这些约束的代码完全包含在deal.II库本身中，你不需要担心细节问题。
* 你需要使其工作的步骤基本上是这样的。
*
* 你必须创建一个AffineConstraints对象，（顾名思义）它将存储有限元空间的所有约束。在目前的情况下，这些约束是由于我们希望在有悬空节点的情况下也能保持解空间的连续。(下面我们还将简要地提到，我们还将把边界值放到这个对象中，但这是一个单独的问题)。
*
* - 你必须使用函数[2.x.30]来填充这个对象，以确保有限元空间的元素的连续性。
*
* - 当你通过使用[2.x.31]将矩阵和右手边的局部贡献复制到全局对象中时，你必须使用这个对象。 到目前为止，我们已经自己完成了这些，但现在有了约束，这就是神奇的地方，我们将约束应用到线性系统中。这个函数所做的是确保位于悬空节点的自由度事实上不是真正的自由。相反，通过将它们的行和列设置为零，并在对角线上放置一些东西以确保矩阵保持可反转，它们实际上被从线性系统中消除了。  对于我们在这里解决的拉普拉斯方程来说，这个过程产生的矩阵仍然是对称和正定的，所以我们可以继续使用共轭梯度法来解决。
*
* - 然后你像往常一样求解线性系统，但在这一步结束时，你需要确保位于悬挂节点上的 "自由度 "得到正确的（约束的）值，这样你随后可视化的或以其他方式评估的解决方案实际上是连续的。这可以通过在求解后立即调用[2.x.32]来实现。
* 这四个步骤实际上是所有必要的
*
* -从用户的角度来看，就是这么简单。事实上，在上面提到的函数调用中，你将通过几千行并不复杂的代码来运行，这一点完全不重要。在用户代码中，实际上只有四个额外的步骤。
*

*[1.x.49][1.x.50]


* 下一个问题，既然我们知道如何[1.x.51]处理有这些悬挂节点的网格，那么我们如何[1.x.52]它们。
* 一个简单的方法已经在[2.x.33]中展示过了：如果你[1.x.53]有必要细化网格，那么你可以手工创建一个。但是在现实中，我们并不知道这一点。我们不知道前面的PDE的解（因为，如果我们知道，我们就不必使用有限元方法），因此我们不知道哪里需要增加局部网格细化，以更好地解决解有强烈变化的地方。但是上面的讨论表明，也许我们可以用一个网格上的离散解[2.x.34]来估计导数[2.x.35]，然后用它来确定哪些单元太大，哪些已经足够小。我们可以使用局部网格细化法从当前的网格中生成一个新的网格。
*
* - 或者，更常见的是，直到我们耗尽了计算资源或耐心。
* 所以这正是我们要做的。局部细化的网格是用一个[1.x.54]来产生的，它估计了拉普拉斯算子的数值解的能量误差。由于它是由Kelly和他的同事开发的，所以我们经常在库、文档和邮件列表中把它称为&ldquo;Kelly refinementindicator&rdquo; 。实现它的类被称为KellyErrorEstimator，在该类的文档中可以找到大量的信息，这里不需要重复。然而，摘要是，该类计算一个有[2.x.36]个 "活动单元 "的条目的向量，其中每个条目包含对该单元的误差估计。我们不需要用手来做这个。一旦我们获得了误差估计矢量，GridRefinement中的函数将为我们完成这一切。
* 值得注意的是，虽然Kelly误差估计器是为拉普拉斯方程开发的，但它已被证明是一个合适的工具，可以为广泛的方程生成局部细化网格，甚至不限于椭圆问题。尽管它将为其他方程创建非最优网格，但它通常是快速生成适应解的特征的网格的好方法，如大变化区域或不连续性。
*


*[1.x.55][1.x.56]


* 事实证明，我们可以把迪里希特边界条件看作是对自由度的另一种约束。这确实是一个特别简单的条件。如果[2.x.37]是边界上的一个自由度，其位置为[2.x.38]，那么在[2.x.40]上施加边界条件[2.x.39]就会产生约束[2.x.41]。
*AffineConstraints类也可以处理这样的约束，这使得我们很方便地让我们用于悬挂节点约束的同一个对象也处理这些Dirichlet边界条件。这样，我们不需要在装配后应用边界条件（像我们在前面的步骤中做的那样）。
*

* [1.x.57] [1.x.58]。


*
* 由于用于局部细化网格的概念非常重要，我们在这个例子中没有展示很多其他材料。最重要的例外是，我们展示了如何使用双二次元，而不是之前所有例子中使用的双线性元素。事实上，使用高阶元素只需替换程序中的三行，即初始化本程序主类构造函数中的[2.x.44]成员变量，以及在两处使用适当的正交公式。程序的其他部分没有变化。
* 唯一的新东西是在[2.x.45]函数中捕捉异常的方法，以便在程序因某种原因崩溃时输出一些信息。下面将详细讨论这个问题。
*

* [1.x.59] [1.x.60]。
* [1.x.61] [1.x.62]。
*

*
* 前面的几个文件已经在前面的例子中涉及到了，因此将不再进一步评论。
*


* [1.x.63]
*
* 从下面的include文件中我们将导入H1-conforming有限元形状函数的声明。这个系列的有限元被称为 [2.x.46] ，在之前的所有例子中已经用于定义通常的双线性或三线性元素，但我们现在将把它用于双二次元元素。
*


* [1.x.64]
*
* 我们不会像前面的例子那样从文件中读取网格，而是使用库的一个函数来生成网格。然而，我们将希望在每一步中写出局部精炼的网格（只是网格，而不是解决方案），因此我们需要以下的include文件来代替[2.x.47] 。
*


* [1.x.65]
*
* 当使用局部细化网格时，我们会得到所谓的<code>悬空节点</code>。然而，标准的有限元方法假定离散解空间是连续的，所以我们需要确保悬挂节点上的自由度符合一些约束条件，从而使全局解是连续的。我们也要在这个对象中存储边界条件。下面的文件包含一个用来处理这些约束条件的类。
*


* [1.x.66]
*
* 为了在本地细化我们的网格，我们需要一个来自库的函数，根据我们计算出的误差指标来决定哪些单元需要细化或粗化的标志。这个函数被定义在这里。
*


* [1.x.67]
*
* 最后，我们需要一个简单的方法来实际计算基于某种误差估计的细化指标。虽然在一般情况下，适应性是非常具体的问题，但以下文件中的误差指标通常会对一类广泛的问题产生相当好的适应网格。
*


* [1.x.68]
*
* 最后，这和以前的程序一样。
*


* [1.x.69]
*
* [1.x.70] [1.x.71]。


*
* 主类又是几乎没有变化的。然而，我们增加了两项内容：我们增加了[2.x.48]函数，它被用来自适应地细化网格（而不是之前例子中的全局细化），还有一个变量，它将保存约束。
*


* [1.x.72]
*
* 这是主类中的新变量。我们需要一个对象，它持有一个约束条件的列表，以保持悬挂节点和边界条件。
*


* [1.x.73]
*
* [1.x.74] [1.x.75]。


*
* 非恒定系数的实现是逐字复制自 [2.x.49] 。
*


* [1.x.76]
*
* [1.x.77] [1.x.78]。



* [1.x.79] [1.x.80]。


*
* 这个类的构造函数与之前的基本相同，但是这一次我们要使用二次元。为此，我们只需用所需的多项式度数（这里是[2.x.51]）来替换构造函数的参数（在以前的例子中是[2.x.50]）。
*


* [1.x.81]
*
* [1.x.82] [1.x.83]。


*
* 下一个函数设置了所有描述线性有限元问题的变量，如DoFHandler、矩阵和向量。与我们在[2.x.52]中所做的不同的是，我们现在还必须照顾到悬挂节点的约束。这些约束几乎完全由库来处理，也就是说，你只需要知道它们的存在以及如何获得它们，但你不必知道它们是如何形成的，也不必知道对它们到底做了什么。
*

*
* 在函数的开头，你会发现所有与[2.x.53]中相同的东西：设置自由度（这次我们有二次元，但从用户代码的角度看与线性的没有区别
*
* - 或任何其他程度，对于这个问题
*
* 情况下），生成稀疏模式，并初始化解和右手边的向量。请注意，现在每行的稀疏模式将有更多的条目，因为现在每个单元有9个自由度（而不是只有4个），它们可以相互耦合。
*


* [1.x.84]
*
* 我们现在可以用悬挂节点的约束来填充AffineConstraints对象。由于我们将在一个循环中调用这个函数，我们首先要清除上一个系统中的当前约束集，然后计算新的约束。
*


* [1.x.85]
*
* 现在我们准备用指标0（整个边界）来插值边界值，并将产生的约束存储在我们的[2.x.54]对象中。请注意，我们并不像在前面的步骤中那样，在装配后应用边界条件：相反，我们将所有的约束条件放在AffineConstraints对象中的我们的函数空间。我们可以以任何顺序向AffineConstraints对象添加约束：如果两个约束发生冲突，那么约束矩阵要么中止，要么通过Assert宏抛出一个异常。
*


* [1.x.86]
*
* 在所有约束条件被添加后，需要对它们进行排序和重新排列，以便更有效地执行一些操作。这种后处理是用[2.x.55]函数完成的，之后就不能再添加任何约束了。
*


* [1.x.87]
*
* 现在我们首先建立我们的压缩稀疏度模式，就像我们在前面的例子中做的那样。尽管如此，我们并没有立即将其复制到最终的稀疏度模式中。  请注意，我们调用了make_sparsity_pattern的一个变体，它把AffineConstraints对象作为第三个参数。我们通过将参数[2.x.57]设置为false（换句话说，我们永远不会写入对应于受限自由度的矩阵条目），让该例程知道我们永远不会写入[2.x.56]所给的位置。如果我们要在组装后压缩约束，我们就必须通过[2.x.58]来代替，因为这样我们就会先写进这些位置，然后在压缩过程中再将它们设置为零。
*


* [1.x.88]
*
* 现在，矩阵的所有非零条目都是已知的（即那些来自定期组装矩阵的条目和那些通过消除约束引入的条目）。我们可以将我们的中间对象复制到稀疏模式中。
*


* [1.x.89]
*
* 我们现在可以，最后，初始化稀疏矩阵。
*


* [1.x.90]
*
* [1.x.91] [1.x.92]。


*
* 接下来，我们要对矩阵进行组装。然而，为了将每个单元上的本地矩阵和向量复制到全局系统中，我们不再使用手写的循环。相反，我们使用[2.x.59]，在内部执行这个循环，同时对对应于受限自由度的行和列进行高斯消除。
*

*
* 形成本地贡献的其他代码保持不变。然而，值得注意的是，在引擎盖下，有几处地方与以前不同。首先，变量[2.x.60]和返回值[2.x.61]现在各为9，以前是4。引入这样的变量作为缩写是一个很好的策略，可以使代码与不同的元素一起工作，而不需要改变太多的代码。其次，[2.x.62]对象当然也需要做其他事情，因为现在的形状函数是二次的，而不是线性的，在每个坐标变量中。不过，这也是完全由库来处理的事情。
*


* [1.x.93]
*
* 最后，将[2.x.63]和[2.x.64]中的贡献转入全局对象。
*


* [1.x.94]

* 现在我们已经完成了线性系统的组装。约束矩阵照顾到了边界条件的应用，也消除了悬挂的节点约束。受约束的节点仍然在线性系统中（在矩阵的对角线上有一个非零条目，选择的方式是使矩阵具有良好的条件，并且这一行的所有其他条目都被设置为零），但是计算出来的值是无效的（也就是说，[2.x.65]中的相应条目目前是没有意义的）。我们在[2.x.66]函数的最后为这些节点计算出正确的值。
*


* [1.x.95]
*
* [1.x.96] [1.x.97]。


*
* 我们继续逐步改进。解决线性系统的函数再次使用了SSOR预处理程序，而且除了我们必须加入悬空节点约束外，再次没有任何变化。如上所述，通过对矩阵的行和列进行特殊处理，从AffineConstraints对象中删除了对应于悬挂节点约束和边界值的自由度。这样一来，这些自由度的值在求解线性系统后就有了错误的、但定义明确的值。然后我们要做的就是利用约束条件给它们分配它们应该有的值。这个过程被称为[2.x.67]约束，从无约束的节点的值中计算出约束节点的值，只需要一个额外的函数调用，你可以在这个函数的末尾找到。
*


*


* [1.x.98]
*
* [1.x.99] [1.x.100]。


*
* 我们使用一个复杂的误差估计方案来细化网格，而不是全局细化。我们将使用KellyErrorEstimator类，该类实现了拉普拉斯方程的误差估计器；原则上它可以处理可变系数，但我们不会使用这些高级功能，而是使用其最简单的形式，因为我们对定量结果不感兴趣，只对生成局部细化网格的快速方法感兴趣。
*

*
* 尽管Kelly等人推导的误差估计器最初是为拉普拉斯方程开发的，但我们发现它也很适合为一类广泛的问题快速生成局部细化网格。这个误差估计器使用了解梯度在单元面上的跳跃（这是一个测量二阶导数的方法），并将其按单元的大小进行缩放。因此，它是对每个单元的解的局部平滑性的测量，因此可以理解，它对双曲运输问题或波浪方程也能产生合理的网格，尽管这些网格与专门为该问题定制的方法相比肯定是次优的。因此，这个误差估计器可以理解为测试自适应程序的一种快速方法。
*

*
* 估算器的工作方式是将描述自由度的[2.x.68]对象和每个自由度的数值向量作为输入，并为三角形的每个活动单元计算一个指标值（即每个活动单元一个数值）。为此，它需要两个额外的信息：一个面部正交公式，即[2.x.69]维物体上的正交公式。我们再次使用3点高斯法则，这个选择与本程序中的双二次方有限元形状函数是一致和合适的。当然，什么是合适的正交规则取决于对误差估计器评估解场的方式的了解。如上所述，梯度的跳跃在每个面上都是集成的，对于本例中使用的二次元元素来说，这将是每个面上的二次元函数。然而，事实上，它是梯度跳跃的平方，正如该类文件中所解释的那样，这是一个二次函数，对于它来说，3点高斯公式就足够了，因为它可以精确地整合5阶以下的多项式）。)
*

*
* 其次，该函数需要一个边界指标列表，用于那些我们施加了[2.x.70]类型的诺伊曼值的边界，以及每个此类边界的一个函数[2.x.71]。这些信息通过一个从边界指标到描述诺伊曼边界值的函数对象的映射来表示。在本例程序中，我们不使用诺伊曼边界值，所以这个映射是空的，实际上是在函数调用期望得到相应函数参数的地方使用映射的默认构造器构造的。
*

*
* 输出是所有活动单元的值的向量。虽然非常精确地计算一个解的自由度的[1.x.101]可能是有意义的，但通常没有必要特别精确地计算一个单元上对应于解的[1.x.102]。因此，我们通常使用一个浮点数的矢量而不是一个双数的矢量来表示误差指标。
*


* [1.x.103]
*
* 上述函数为[2.x.72]数组中的每个单元格返回一个错误指标值。现在的细化工作如下：细化那些误差值最高的30%的单元格，粗化那些误差值最低的3%的单元格。   
* 人们可以很容易地验证，如果第二个数字为零，这大约会导致在两个空间维度上的每一步中的细胞增加一倍，因为对于每一个30%的细胞，四个新的将被替换，而其余70%的细胞保持不动。在实践中，通常会产生一些更多的单元，因为不允许一个单元被精炼两次而相邻的单元没有被精炼；在这种情况下，相邻的单元也会被精炼。   
* 在许多应用中，被粗化的单元格数量将被设置为大于百分之三的数值。一个非零的值是有用的，特别是当由于某种原因，初始（粗）网格已经相当精细了。在这种情况下，可能有必要在某些区域进行细化，而在另一些区域进行粗化是有用的。在我们这里，初始网格是非常粗的，所以粗化只需要在一些可能发生过度细化的区域。因此，一个小的、非零的值在这里是合适的。   
* 下面的函数现在采用这些细化指标，并使用上述方法对三角形的一些单元进行细化或粗化标记。它来自一个类，该类实现了几种不同的算法，根据单元的误差指标来细化三角形。
*


* [1.x.104]
*
* 在前一个函数退出后，一些单元被标记为细化，另一些单元被标记为粗化。然而，细化或粗化本身并没有被执行，因为在有些情况下，进一步修改这些标志是有用的。在这里，我们不想做任何这样的事情，所以我们可以告诉三角计算执行单元格被标记的动作。
*


* [1.x.105]
*
* [1.x.106] [1.x.107]。


*
* 在每个网格的计算结束后，就在我们继续下一个网格细化周期之前，我们要输出这个周期的结果。
*

*
* 我们已经在[2.x.73]中看到了如何对网格本身实现这一点。在这里，我们改变了一些东西。  [2.x.74] [2.x.75] 我们使用两种不同的格式。gnuplot和VTU。[2.x.76] [2.x.77] 我们将周期号嵌入到输出文件名中。[2.x.78] [2.x.79] 对于gnuplot输出，我们设置了一个[2.x.80]对象，以提供一些额外的可视化参数，使边缘看起来是弯曲的。这在 [2.x.81] 中有进一步的详细解释。[2.x.82] [2.x.83]。
*


* [1.x.108]
*
* [1.x.109] [1.x.110]。


*
* [2.x.84]之前的最后一个函数仍然是该类的主要驱动，[2.x.85] 。它与 [2.x.86] 的函数类似，只是我们在程序中再次生成一个文件，而不是从磁盘中读取，我们自适应地而不是全局地细化网格，并且我们在本函数中输出最终网格上的解。
*

*
* 该函数主循环的第一个块是处理网格的生成。如果这是该程序的第一个循环，而不是像前面的例子那样从磁盘上的文件中读取网格，我们现在再次使用一个库函数来创建它。域还是一个圆，中心在原点，半径为1（这是函数的两个隐藏参数，有默认值）。
*

*
* 通过观察粗略的网格，你会发现它的质量比我们在前面的例子中从文件中读出的网格要差：单元格的形成不太平均。然而，使用库函数，这个程序可以在任何空间维度上工作，这在以前是不可能的。
*


* 万一我们发现这不是第一个周期，我们要细化网格。与上一个例子程序中采用的全局细化不同，我们现在使用上述的适应性程序。
*

*
* 循环的其余部分看起来和以前一样。
*


* [1.x.111]
*
* [1.x.112] [1.x.113]。


*
* 主函数的功能与前面的例子相比没有改变，但我们采取了额外的谨慎措施。有时，会出现一些问题（比如写输出文件时磁盘空间不足，试图分配向量或矩阵时内存不足，或者由于某种原因我们无法从文件中读出或写入文件），在这些情况下，库会抛出异常。由于这些都是运行时的问题，而不是可以一劳永逸的编程错误，所以这种异常在优化模式下是不会被关闭的，这与我们用来测试编程错误的[2.x.87]宏相反。如果没有被捕获，这些异常会传播到[2.x.88]函数的调用树上，如果它们在那里也没有被捕获，程序就会被中止。在很多情况下，比如内存或磁盘空间不足，我们什么也做不了，但我们至少可以打印一些文字，试图解释程序失败的原因。下面显示了一种方法。以这种方式编写任何较大的程序当然是有用的，你可以通过或多或少地复制这个函数来做到这一点，除了[2.x.89]块，它实际上编码了本应用程序所特有的功能。
*


* [1.x.114]
*
* 这个函数布局的总体思路如下：让我们试着像以前那样运行程序......
*


* [1.x.115]
*
* ...如果这应该是失败的，尽量收集尽可能多的信息。具体来说，如果被抛出的异常是一个从C++标准类[2.x.90]派生出来的类的对象，可以通过成员函数得到一个字符串，这个字符串描述了异常被抛出的原因。   
* deal.II的异常类都是从标准类派生出来的，特别是[2.x.91]函数将返回与使用[2.x.92]宏抛出的异常所产生的字符串大致相同。在前面的例子中，你已经看到了这种异常的输出，然后你知道它包含了异常发生的文件和行号，以及其他一些信息。这也是下面的语句会打印的内容。   
* 除此以外，除了用错误代码退出程序（这就是[2.x.93]的作用），我们能做的并不多。
*


* [1.x.116]
*
* 如果在某处抛出的异常不是从标准[2.x.94]类派生出来的对象，那么我们根本就不能做任何事情。我们就简单地打印一个错误信息并退出。
*


* [1.x.117]
*
* 如果我们走到这一步，就没有任何异常传播到主函数上（可能有异常，但它们在程序或库的某个地方被捕获）。因此，程序按预期执行，我们可以无误返回。
*


* [1.x.118]
* [1.x.119][1.x.120] 。



* 程序的输出看起来如下。
* [1.x.121]
*
*

*
* 正如预期的那样，在每个周期中，细胞的数量大约增加了一倍。度数是单元数的四倍多；在无限网格的两个空间维度上，我们可以期待一个正好是四的系数（因为自由度之间的间距是单元宽度的一半：每个边缘有一个额外的自由度，每个单元的中间有一个），但是由于网格的有限尺寸和由悬挂节点和局部细化引入的额外自由度，它比这个系数大。
*

*
* 该程序在每个循环中输出解决方案和网格。解决方案看起来如下。
* [2.x.95]
* 有趣的是，我们可以看到程序是如何得出最终的网格的。
* [2.x.96]


* 可以清楚地看到，在解有扭结的区域，即距中心0.5的径向距离的圆，被精炼得最多。此外，解非常光滑且几乎平坦的中心区域几乎完全没有被细化，但这是由于我们没有考虑到那里的系数很大的事实。外面的区域被任意地细化了，因为那里的二阶导数是恒定的，因此细化主要是基于单元的大小和它们与最优方格的偏差。
*


* [1.x.122][1.x.123][1.x.124] 。


*[1.x.125][1.x.126] 。


*
* 如果一个人要解决相当大的问题（比我们这里的问题大得多），有一件事总是值得一试的，那就是尝试不同的求解器或预处理器。在目前的情况下，线性系统是对称的和正定的，这使得CG算法几乎成了解题的典型选择。然而，我们在[2.x.97]函数中使用的SSOR预处理器是有待商榷的。
* 在deal.II中，改变预处理程序是比较简单的。例如，通过改变现有的几行代码
* [1.x.127]
* 变成
* [1.x.128]
* 我们可以尝试SSOR的不同松弛参数。通过使用
* [1.x.129]
* 我们可以使用Jacobi作为预处理程序。而通过使用
* [1.x.130]
* 我们可以使用一个简单的不完整的LU分解，没有任何对角线的阈值或加强（要使用这个预处理程序，你还必须把头文件[2.x.98]加入到文件顶部的include列表中）。
* 使用这些不同的预处理程序，我们可以比较所需的CG迭代次数（可通过[2.x.99]调用，见[2.x.100]）以及所需的CPU时间（使用Timer类，例如在[2.x.101]中讨论），得到以下结果（左边：迭代次数；右边：CPU时间）。
* [2.x.102]
* 我们可以看到，所有的预处理程序在这个简单问题上的表现都差不多，迭代次数以[2.x.103]的方式增长，由于每次迭代需要大约[2.x.104]次操作，总的CPU时间以[2.x.105]的方式增长（对于几个最小的网格，CPU时间非常小，以至于没有记录）。请注意，即使是简单的方法，Jacobi对于这个问题也是最快的。
* 当有限元不是本程序构造函数中设定的二次元，而是二次元时，情况会有一些变化。如果作出这种改变，结果如下。
* [2.x.106]
* 换句话说，虽然迭代次数和CPU时间的增加和以前一样，但雅可比现在是需要最多迭代的方法；不过，由于它必须执行的操作很简单，所以它仍然是最快的方法。这并不是说Jacobi实际上是一个好的预处理程序。
*
* 对于相当大的问题，它肯定不是，其他方法会好得多。
*
* 但实际上只是因为它的实现非常简单，所以它可以补偿更多的迭代次数。
* 从这里得到的信息并不是说预设条件器的简单性总是最好的。虽然这对当前的问题可能是正确的，但一旦我们转向更复杂的问题（弹性或斯托克斯，例如[2.x.107]或[2.x.108]），就绝对不是这样了。其次，所有这些预处理程序仍然导致迭代次数随着自由度[2.x.109]的增加而增加，例如[2.x.110]；这反过来又导致总工作量的增加，因为每次迭代都需要[2.x.112]工作。这种行为是不可取的：我们真的希望用[2.x.113]个未知数解决线性系统，总工作量为[2.x.114]个；有一类预处理程序可以实现这一点，即几何（[2.x.115], [2.x.116], [2.x.117]）或代数多网格（[2.x.118], [2.x.119] ，以及其他几个）预处理程序。然而，它们要比上述的预处理程序复杂得多。
* 最后，要带回家的最后一个信息是，当上面显示的数据产生时（2018年），有10万个未知数的线性系统在台式机上很容易在大约一秒钟内解决，使相对简单的2D问题的解决甚至达到非常高的精度，即使在过去也不是一个大任务。当时，三维问题的情况完全不同，但即使是这样，在过去的时间里也发生了很大的变化。
*
* - 尽管在三维中解决高精确度的问题仍然是一个挑战。
*

*[1.x.131][1.x.132]


* 如果你看一下上面的网格，你会发现尽管领域是一个圆盘，而且系数的跳动是沿着一个圆的，但是组成网格的单元并没有很好地跟踪这个几何形状。原因在[2.x.120]中已经提示过了，在没有其他信息的情况下，三角剖分类只看到一堆粗大的网格单元，但当然不知道它们在一起时可能代表什么样的几何。出于这个原因，我们需要告诉Triangulation当一个单元被细化时应该做什么：边缘中点和单元中点的新顶点应该位于哪里，以便子单元比父单元更好地代表所需的几何形状。
* 为了直观地了解三角测量对几何体的实际了解，仅仅输出顶点的位置和为每条边画一条直线是不够的；相反，我们必须将内部线和边界线都输出为多条线段，使它们看起来是弯曲的。我们可以通过对[2.x.121]的gnuplot部分做一个改动来实现这一点。
* [1.x.133]
*
* 在上面的代码中，我们已经对位于边界的面做了这个处理：由于我们使用了[2.x.122]，它将SphericalManifold附加到域的边界上，所以这就自动发生了。为了使网格[1.x.134]也能追踪到一个圆形域，我们需要更努力一些。首先，回顾一下我们的粗略网格是由一个中心的正方形单元和周围的四个单元组成的。现在首先考虑一下，如果我们将球形网格对象不仅连接到四个外部面，而且连接到周边的四个单元以及它们的所有面，会发生什么。我们可以通过添加下面的片段来实现这一点（测试一个单元格的中心是否大于单元格直径的一个小倍数，比如说十分之一，只对网格中心的正方形无效）。
* [1.x.135]
*
* 经过几个全局细化步骤后，这将导致以下类型的网格。
*

* [2.x.123]
* 创建好的网格，特别是使它们适合你想要的几何形状，本身就是一个复杂的话题。你可以在[2.x.124]、[2.x.125]和[2.x.126]中找到更多关于这个问题的内容，以及其他涉及这个问题的教程程序。  [2.x.127]展示了另一种不太需要手工操作的方法来实现对这里的问题的网格井拟合。关于弯曲域的信息也可以在[2.x.128]的文档模块 "流形描述 "中找到。
* 为什么选择一个跟踪内部界面的网格是有意义的？有很多原因，但最重要的原因是我们在双线型中实际集成了什么。从概念上讲，我们想把[2.x.129]作为单元格[2.x.130]对矩阵条目[2.x.131]的贡献进行积分。我们无法精确计算，只能采用正交法。我们知道，如果积分是平滑的，正交是准确的。这是因为正交法实质上是计算积分的多项式近似值，与正交点的积分重合，然后计算该多项式下的体积，作为原始积分下的体积的近似值。如果积分在一个单元上是平滑的，那么这个多项式插值是准确的，但如果积分在一个单元上是不连续的，那么它通常是相当不准确的。
* 因此，值得注意的是，在排列单元时，系数不连续的界面要与单元的界面对齐。这样，系数在每个单元上都是恒定的，这样积分就会很平滑，其多项式近似和积分的正交近似都会很准确。请注意，这样的排列方式在实际情况中很常见，所以deal.II提供了一些函数（如[2.x.132]"material_id"）来帮助管理这样的情况。请参考[2.x.133]和[2.x.134]关于如何应用material ids的例子。
* 最后，让我们考虑一个在空间中具有平滑和非均匀分布的系数的情况。我们可以再一次重复上面关于用正交函数表示这种函数的所有讨论。因此，为了准确地模拟它，有几个现成的选择：你可以减少单元格的大小，增加正交公式中使用的多项式的阶数，选择一个更合适的正交公式，或执行这些步骤的组合。关键是，用正交多项式提供系数的空间依赖性的最佳拟合，将导致PDE的更精确的有限元解。
* 最后说明：前面的讨论表明，我们在这里有一个非常具体的方法来说明我们认为的好的网格
*
*-它应该与系数的跳动保持一致。但是我们也可以在一个更普遍的环境中提出这样的问题。给出一些具有光滑解和光滑系数的方程，我们能说一个好的网格是什么样子的吗？这个问题的答案在直觉上比数学上更容易表述。一个好的网格所包含的单元大体上都像正方形（或立方体，在三维空间）。一个不好的网格会包含一些在某些方向上非常细长的单元，或者，更广泛地说，有一些单元的边缘既短又长。有很多方法可以给每个单元分配一个数字质量指数，以衡量该单元是 "好 "还是 "坏"；其中一些方法经常被选择，因为它们便宜且容易计算，而另一些方法则基于收敛性的证明。前者的一个例子是一个单元格的最长边与最短边的比率。在理想的情况下，这个比率应该是1；不好的单元格的数值远远大于1。后者的例子是考虑从参考单元[2.x.135]到实际单元[2.x.136]的映射的梯度（"雅各布"）；这个梯度是一个矩阵，进入误差估计的一个量是参考单元上所有点的最大比率，即这个矩阵的最大和最小的特征值。同样不难看出，如果单元格[2.x.137]是[2.x.138]的仿生图像，这个比率是恒定的，对于正方形和立方体来说，这个比率是一个。
* 在实践中，将这种质量度量可视化可能是很有趣的。函数[2.x.139]提供了获得这种信息的途径。甚至更好的是，可视化工具，如VisIt，通常允许你在可视化软件中对各种措施进行可视化；在VisIt的情况下，只需添加一个 "伪色 "图，并选择其中一个网格质量措施，而不是解域。
*

*[1.x.138][1.x.139]。


*从数学的角度来看，拉普拉斯方程[1.x.140]在光滑有界的凸域上的解，已知本身是光滑的。平滑性的确切程度，即解所处的函数空间，取决于域的边界到底有多平滑，以及右手边的平滑程度。特别是如果右手边满足[2.x.140]，那么[2.x.141]，其中[2.x.142]是[2.x.143]的任何紧凑子集（[2.x.144]是一个开放域，所以紧凑子集需要与[2.x.145]保持一个正距离），解的一些规律性可能会在边界上丢失，但一般来说，解是比右手边多一倍的可微积分。
* 然而，我们为目前的例子选择的情况是不同的：我们看一个具有非常数系数的方程[2.x.146]：[1.x.141]这里，如果[2.x.147]不光滑，那么无论[2.x.148]如何，解也不会光滑。特别是，我们希望在[2.x.149]沿直线（或沿三维平面）不连续的地方，解会有一个结点。这很容易看出来：例如，如果[2.x.150]是连续的，那么[2.x.151]也需要是连续的。这意味着[2.x.152]必须是可连续微分的（不存在扭结）。因此，如果[2.x.153]有一个不连续，那么[2.x.154]必须有一个相反的不连续，这样两者正好抵消，它们的乘积得到一个没有不连续的函数。但要使[2.x.155]有一个不连续，[2.x.156]必须有一个结点。当然，这正是当前例子中所发生的情况，在解的图片中也很容易观察到。
* 一般来说，如果系数[2.x.157]沿着2D的直线或3D的平面是不连续的，那么解可能会有一个结点，但解的梯度不会到无穷大。这意味着，该解至少仍在[1.x.142][2.x.158]中（即，大致上，在导数有界的函数空间中）。另一方面，我们知道，在最极端的情况下
*
*--即域有重合角的情况下，右手边只满足[2.x.159]，或者系数[2.x.160]只在[2.x.161]。
*
* - 我们所能期望的是，[2.x.162]（即导数是可平方整数的函数的[1.x.143]），是一个比[2.x.163]大得多的空间。创造一些案例并不难，在这些案例中，解在一个空间[2.x.164]中，我们可以让[2.x.165]变得像我们想要的那样小。这种情况经常被用来测试自适应有限元方法，因为网格必须解决导致解不在[2.x.166]中的奇点。
* 典型的例子是[1.x.144]（指[2.x.167]），在常用的形式中，它的系数[2.x.168]在平面的四个象限内有不同的值（或在[2.x.169]的八个象限内有不同的值）。确切的规则性程度（上述索博列夫空间索引中的[2.x.170]）取决于[2.x.171]的值在原点处聚集，通过选择足够大的跳跃，可以使解的规则性尽可能地接近[2.x.172]。
* 为了实现类似的目的，我们可以用下面的方法来代替系数函数（这里只显示2d的情况）。
* [1.x.145]
*（在结尾处添加[2.x.173]可以确保在我们到达那个点时，要么抛出一个异常，要么程序中止。
*
* 当然我们不应该这样做，但这是一个很好的方法来保证自己：我们都会犯错误，有时没有想到所有的情况，例如检查[2.x.174]是否小于和大于零，而不是大于或等于零，从而忘记了一些情况，否则会导致很难发现的错误。最后的[2.x.175]只是为了避免编译器对函数没有以[2.x.176]语句结束的警告。
*
* - 编译器无法看到，由于前面的[2.x.177]语句，函数实际上永远不会到达这一点）。)
* 通过玩弄这种四个或更多扇形组合在一起，并且在这些扇形上的系数有不同的值的情况，我们可以构建出解在原点有奇异点的情况。我们还可以看到在这种情况下网格是如何被细化的。
*

* [1.x.146][1.x.147] [2.x.178] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-61_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38][1.x.39]
* [2.x.2]
* [1.x.40]
* [1.x.41][1.x.42][1.x.43] 。


* 本教程程序介绍了泊松方程的 "弱Galerkin "有限元方法的实现。从某种意义上说，考虑这种方法的动机与[2.x.3]中的动机相同：我们想考虑不连续的形状函数，但需要解决这样一个事实：与通常的连续Galerkin方法相比，所产生的问题有更多的自由度（因为，举例来说，每个顶点携带的自由度与相邻的单元一样多）。我们还必须处理这样一个事实：与连续Galerkin方法不同，[1.x.44]一个单元上的自由度与它的每个面的邻居单元上的所有自由度相耦合。因此，从 "传统 "非连续Galerkin方法得到的矩阵既大又相对密集。
* [2.x.4]中的混合非连续Galerkin方法（HDG）和本教程中的弱Galerkin（WG）方法都是通过引入额外的自由度来解决耦合问题的，这些自由度的形状函数只存在于单元间的面（即。在网格的 "骨架 "上），因此将相邻单元上的自由度相互 "隔离"：单元自由度只与同一单元上的其他单元自由度以及面自由度耦合，而不与相邻单元上的自由度耦合。
* 对于一个给定的方程，例如二阶泊松方程，HDG和WG方法的区别在于如何精确地表述连接所有这些不同形状函数的问题。(事实上，对于某些WG和HDG的表述，有可能表明它们是等价的。)HDG通过用一阶方程组重新表述二阶问题，然后在概念上认为面自由度是这个一阶系统的 "通量"。与此相反，WG方法保持二阶形式，认为面自由度与主解变量的类型相同，只是限制在低维面。为了方程的目的，在定义对其应用微分算子的含义时，我们需要以某种方式将这些形状函数 "扩展 "到单元内部。与HDG相比，该方法的优势在于它不会因为将方程改写为一阶系统而导致未知数的增加，但它也不太容易实现。然而，正如我们在下文中所看到的，这种额外的努力并不可怕。
*

*[1.x.45][1.x.46]


* 弱加勒金有限元方法（WGFEMs）使用离散的弱函数来近似标量未知数，使用离散的弱梯度来近似经典梯度。该方法最初是由王俊平和叶修在论文中提出的[1.x.47][1.x.48] 。与连续Galerkin方法相比，弱Galerkin方法满足重要的物理特性，即局部质量守恒和体法通量连续。
*

* [1.x.49][1.x.50] 。
* 该程序使用弱加勒金有限元方法求解泊松方程。
* [1.x.51]
* 其中[2.x.5]为有界域。在流体流经多孔介质的情况下，[2.x.6]为压力，[2.x.7]为渗透率张量，[2.x.8]为源项，[2.x.9我们可以引入一个通量，[2.x.10]，对应于达西速度（以我们在[2.x.11]中的方式），这个变量在下面的考虑中很重要。
* 在这个程序中，我们将考虑一个测试案例，即在单位平方域上的确切压力为[2.x.12]，具有同质的Dirichelet边界条件和[2.x.13]的身份矩阵，然后我们将计算压力、速度和流量的[2.x.14]误差。
*

*[1.x.52][1.x.53]


* 上述泊松方程有一个解[2.x.15]，需要满足问题的弱式表述，[1.x.54] 。
*对于所有测试函数[2.x.16]，其中[1.x.55]
*和[1.x.56]。
* 这里，我们以双线性形式进行了部分积分，我们正在评估[2.x.17]在内部的梯度和[2.x.18]在域的边界的值。所有这些都有很好的定义，因为我们假定解在[2.x.19]中，对它来说，取梯度和评估边界值是有效的操作。
* 弱Galerkin方法的想法是用一个[1.x.57][2.x.21]来近似精确的[2.x.20]解。这个函数可能只在单元格之间的界面上是连续的，由于我们也想沿着界面评价这个函数，我们不仅要规定它在单元格内部应该有什么值，而且还要规定它在界面上的值。我们的做法是，[2.x.22]实际上是一个元组，[2.x.23]，尽管它实际上只是一个单一的函数，它要么等于[2.x.24]，要么等于[2.x.25]，取决于它是在细胞内部还是在细胞界面上的某一点[2.x.26]被评价。
* 然后我们想把这个近似值简单地贴到上面的双线型中。这适用于我们必须在边界上评估测试函数[2.x.27]的情况（我们只需取其界面部分[2.x.28]），但我们必须小心处理梯度，因为它只在细胞内部定义。因此，泊松方程的弱Galerkin方案由[1.x.58]定义。
*对于所有离散测试函数[2.x.29]，其中[1.x.59]定义为
*和[1.x.60]
* 关键的一点是，在这里，我们用[1.x.61]算子[2.x.31]代替了梯度[2.x.30]，这对于我们特殊定义的近似值[2.x.32]是有意义的。
* 问题是该算子如何工作。为此，让我们首先说说我们是如何看待压力的离散近似[2.x.33]的。如上所述，"函数"[2.x.34]实际上由两部分组成：单元内部的值[2.x.35]和界面上的[2.x.36]。我们必须为这两部分定义离散的（有限维）函数空间；在这个程序中，我们将使用FE_DGQ来表示[2.x.37]作为细胞内部的空间（在每个细胞上定义，但一般是沿界面不连续的），并使用FE_FaceQ来表示[2.x.38]作为界面上的空间。
* 然后让我们只考虑一个单元（因为上面的积分都是逐个单元定义的，而且弱离散梯度是逐个单元定义的）。从本质上讲，我们可以认为[2.x.43]是定义在[2.x.44]上的某个函数，它接近于梯度；特别是，如果[2.x.45]是一个可微函数的限制（对[2.x.46]的内部和边界
*
* 这将使它在内部和边界之间是连续的），那么[2.x.47]将只是准确的梯度[2.x.48] 。但是，由于[2.x.49]在[2.x.50]的内部和边界之间不是连续的，我们需要一个更一般的定义；此外，我们不能处理任意函数，因此要求[2.x.51]也是在一个有限元空间（由于梯度是一个矢量，必须是矢量值，而且由于弱梯度是在每个单元上单独定义的，因此在单元之间也是不连续的）。
* 这样做的方法是以下列方式定义这个弱梯度算子[2.x.52]（其中[2.x.53]是单元格[2.x.55]上的矢量值Raviart-Thomas空间，阶数为[2.x.54]）：[1.x.62]
*对于所有测试函数[2.x.56].这在本质上是简单地应用了逐部积分公式。换句话说，对于一个给定的[2.x.57]，我们需要把[2.x.58]看作是度数为[2.x.59]的Raviart-Thomas函数，对于这个函数，左手边和右手边在所有测试函数中是相等的。
* 那么，需要说明的一个关键点是以下几点。通常的梯度[2.x.60]是一个局部*算子，它仅仅根据一个函数在某一点及其（无限小）邻域的值来计算导数，而弱离散梯度[2.x.61]却没有这个特性。它取决于它在整个单元上所应用的函数值，包括单元的边界。然而，两者都是线性算子，从上面[2.x.62]的定义可以看出，这将允许我们在下面的讨论中通过矩阵来表示[2.x.63]。
* [2.x.64] 可能值得指出的是，虽然弱离散梯度是Raviart-Thomas空间[2.x.65]中每个单元[2.x.66]上的一个元素，但它在单元之间是不连续的。另一方面，定义在整个网格上并由FE_RaviartThomas类实现的Raviart-Thomas空间[2.x.67]代表了在单元间界面上具有连续法线分量的函数。这意味着[1.x.63], [2.x.68]不在[2.x.69]中，尽管它在[2.x.70]中的每个单元上。  相反，它是在一个 "破碎的 "拉维亚特-托马斯空间中，下面我们将用符号[2.x.72]来表示。 这里的术语 "破碎 "是指 "把东西打碎 "的过程，而不是指 "没有功能 "的同义词）。因此，人们可能会（理所当然地）争辩说，弱加尔金文献中使用的符号有点误导性，但这往往取决于使用某种符号的环境
*
* - 在目前的背景下，对Raviart-Thomas空间或元素的提及总是被理解为对 "破碎 "空间的提及。
* [2.x.73] deal.II恰好有一个这种破碎的Raviart-Thomas空间的实现。FE_DGRT类。因此，在本教程中，我们将简单地一直使用FE_DGRT类，尽管在所有那些我们必须计算单元格本地矩阵和向量的地方，它没有任何区别。
*

*[1.x.64][1.x.65]


* 由于[2.x.74]是有限元空间的一个元素，我们可以像往常一样在一个基中展开它，也就是说，我们可以写成[1.x.66] 。
* 这里，由于[2.x.75]有两个分量（内部和界面分量），基函数[2.x.76]也必须如此，我们可以写成[2.x.77]。如果你遵循了[2.x.78]、[2.x.79]和[2.x.80]"向量值问题文档模块 "中的描述，就不会奇怪，对于[2.x.81]的某些值，[2.x.82]将为零，而对于[2.x.83]的其他值，[2.x.84]则为零
*
*--也就是说，形状函数将是一种或另一种的。然而，这在这里并不重要。重要的是，我们需要思考如何表示[2.x.85]，因为当我们想实现双线性形式[1.x.67]时，这显然是会出现在问题中的。
*
* 关键是[2.x.86]是已知的 "破碎 "Raviart-Thomas空间[2.x.87]的成员。这意味着我们可以（在每个单元[2.x.88]上分别表示）[1.x.68] 。
*其中的函数[2.x.89]，以及[2.x.90]是一个维度的矩阵
* [1.x.69]
* 弱离散梯度可以被表示为一个矩阵，这并不奇怪：它是一个从一个有限维空间到另一个有限维空间的线性算子。如果选择这两个空间的基数，那么[1.x.70]当然可以写成一个矩阵，将与算子的域空间的基数有关的扩展系数向量映射到与图像空间的基数有关的扩展系数向量）。)
* 使用这个扩展，我们可以很容易地使用上面的弱离散梯度的定义来定义矩阵的内容：[1.x.71] 。
* 对于所有测试函数[2.x.91] 。
* 这显然导致了一个线性系统的形式[1.x.72] 。
*有[1.x.73]。
* 因此，[1.x.74]也是如此。
* (在最后一步中，我们假设指数[2.x.92]只涵盖那些在单元[2.x.93]上活动的自由度，从而确保空间[2.x.94]上的质量矩阵是可逆的。)等价地，利用矩阵[2.x.95]的对称性，我们有[1.x.75]
* 另外值得指出的是，矩阵[2.x.96]和[2.x.97]当然不是正方形而是长方形。
*

*[1.x.76][1.x.77] 。


* 在解释了弱离散梯度是如何定义的之后，我们现在可以回到如何组装有关方程的线性系统的问题上了。具体来说，利用上面显示的双线性形式[2.x.98]的定义，我们就需要计算对全局矩阵[1.x.78]的局部贡献元素。
* 如上所述，我们可以根据每个单元的Raviart-Thomas基来展开[2.x.99]，同样，对于[2.x.100]：[1.x.79]也是如此。
* 通过重新排列和，可以得到以下表达式：[1.x.80] 。
* 因此，如果我们有每个单元[2.x.102]的矩阵[2.x.101]，那么我们可以很容易地计算单元[2.x.104]对矩阵[2.x.105]的贡献[2.x.103]如下：[1.x.81] 。
* 这里，[1.x.82] 是质量矩阵。
* 这实际上只是使用Raviart-Thomas基数的单元[2.x.106]的质量矩阵，并通过渗透性张量[2.x.107]加权。这里的推导表明，弱Galerkin方法实际上只需要我们计算每个单元[2.x.108]和[2.x.109]的矩阵，然后再计算[2.x.111]，这很容易计算。下面要显示的代码正是这样做的。
* 在计算出单元格[2.x.112]对全局矩阵的贡献后，我们要做的就是将这些局部贡献 "分配 "到全局矩阵中。如何做到这一点，首先显示在 [2.x.114] 和 [2.x.115] 中。在当前的程序中，这将通过调用[2.x.116]来促进。
* 一个线性系统当然也需要一个右手边。在这里，除了我们只需要使用单元内部的部分[2.x.117]来计算形状函数[2.x.118]之外，没有任何与计算右手边相关的困难。
*

*[1.x.83][1.x.84][1.x.85]


* 前面几节的讨论给了我们一个线性系统，我们可以解决数值压力[2.x.119]。我们可以用它来计算变量[2.x.120]的近似值，如果这就是我们要解决的模型，它对应于介质在多孔介质中的流动速度。这种步骤
*
* - 从离散问题的解决方案中计算一个派生量
*
* - 通常被称为 "后处理"。
* 这里，我们不使用[2.x.121]的精确梯度，而是使用[2.x.122]的离散弱梯度来计算每个元素上的速度。如上所述，在每个元素上，数值压力[2.x.123]的梯度可以由离散弱梯度[2.x.124]：[1.x.86]接近。
*
* 在单元[2.x.125]上，数值速度[2.x.126]可写为
* [1.x.87]
* 其中[2.x.127]是上面的扩展矩阵，[2.x.128]是单元上[2.x.129]空间的基础函数。
* 不幸的是，[2.x.130]可能不在[2.x.131]空间中（当然，除非[2.x.132]是常数乘以身份矩阵）。因此，为了在有限元程序中表示它，我们需要把它投影回我们可以处理的有限维空间。在这里，我们将使用[2.x.133]投影来把它投射回（破碎的）[2.x.134]空间。
* 我们将每个单元格[2.x.136]上的投影定义为[2.x.135] .对于任何[2.x.137] ，[2.x.138] 所以，而不是上面的公式，单元格[2.x.139]上的数值速度反而变成[1.x.88] 。
* 我们有以下系统来解决系数[2.x.140]：[1.x.89] 。
* 在下面的实现中，元素[2.x.141]的矩阵被称为[2.x.142]，而元素[2.x.143]的矩阵被称为[2.x.144] 。
* 那么元素速度是[1.x.90] 。
* 其中[2.x.145]在代码中被称为 "细胞速度"。
* 使用这个通过 "后处理 "得到的速度，我们可以通过以下公式定义压力、速度和通量的[2.x.146] 误差。
* [1.x.91]
*其中[2.x.147]是元素的面积，[2.x.148]是元素的面，[2.x.149]是每个面的单位法向量。最后一项是测量网格单元之间界面上速度向量的法向分量的精度。缩放因子[2.x.150]的选择是为了随着网格大小的变化而缩小界面集合的长度（或面积）的差异。
* 上面的第一个错误很容易用[2.x.151]计算出来，其他的需要更多的工作，在下面的代码中实现。
*

* [1.x.92] [1.x.93]。
* [1.x.94] [1.x.95] 本程序基于[2.x.152]、[2.x.153]和[2.x.154]，所以以下大部分头文件都很熟悉。我们需要以下文件，其中只有导入FE_DGRaviartThomas类的文件（即`deal.II/fe/fe_dg_vector.h`）是真正的新文件；FE_DGRaviartThomas实现了介绍中讨论的 "破碎 "Raviart-Thomas空间。
*


* [1.x.96]
*
* 我们的第一步，像往常一样，是把所有与本教程程序有关的东西放到自己的命名空间中。
*


* [1.x.97]
*
* [1.x.98] [1.x.99]。



* 这是本程序的主要类别。我们将使用弱加勒金（WG）方法求解内部和面上的数值压力，并计算压力的[2.x.155]误差。在后处理步骤中，我们还将计算速度和通量的[2.x.156] 误差。   
* 该类的结构与以前的教程程序没有根本的不同，所以除了一个例外，没有必要对细节进行评论。该类有一个成员变量`fe_dgrt`，对应于介绍中提到的 "破碎 "的Raviart-Thomas空间。还有一个与之匹配的`dof_handler_dgrt`，表示从这个元素创建的有限元场的全局枚举，还有一个向量`darcy_velocity`，用于保持这个场的节点值。在求解压力后，我们将使用这三个变量来计算一个后处理的速度场，然后我们可以对其进行误差评估，并可以输出用于可视化。
*


* [1.x.100]
*
* [1.x.101] [1.x.102]。


*
* 接下来，我们定义系数矩阵[2.x.157]（这里是身份矩阵），迪里希特边界条件，右手边[2.x.158]，以及对应于这些选择的[2.x.159]和[2.x.160]的精确解，即[2.x.161] 。
*


* [1.x.103]
*
* 实现精确压力解的类有一个奇怪的地方，我们把它实现为一个有两个分量的向量值。(我们在构造函数中说它有两个分量，在这里我们调用了基础函数类的构造函数)。在`value()`函数中，我们不测试`component`参数的值，这意味着我们为向量值函数的两个分量返回相同的值。我们这样做是因为我们将本程序中使用的有限元描述为一个包含内部和界面压力的矢量值系统，当我们计算误差时，我们希望使用相同的压力解来测试这两个分量。
*


* [1.x.104]
*
* [1.x.105] [1.x.106]。



* [1.x.107] [1.x.108]。


*
* 在这个构造函数中，我们为矢量值函数创建一个有限元空间，这里将包括用于内部和界面压力的函数， [2.x.162] 和 [2.x.163] 。
*


* [1.x.109]
*
* [1.x.110] [1.x.111]。


*
* 我们在单位平方域上生成一个网格并对其进行细化。
*


* [1.x.112]
*
* [1.x.113] [1.x.114]。


*
* 在我们创建了上面的网格之后，我们分配自由度并调整矩阵和向量的大小。这个函数中唯一值得关注的部分是我们如何插值压力的边界值。由于压力由内部和界面分量组成，我们需要确保我们只插值到矢量值解空间中与界面压力相对应的分量上（因为这些分量是唯一定义在域的边界上的）。我们通过一个只针对界面压力的分量屏蔽对象来做到这一点。
*


* [1.x.115]
*
* 在双线性形式中，在两个相邻单元之间的面上没有积分项，所以我们可以直接使用[2.x.164]来计算稀疏矩阵。
*


* [1.x.116]
*
* [1.x.117] [1.x.118]。


*
* 这个函数比较有趣。正如介绍中所详述的，线性系统的装配要求我们评估形状函数的弱梯度，它是Raviart-Thomas空间中的一个元素。因此，我们需要定义一个Raviart-Thomas有限元对象，并有FEValues对象在正交点评估它。然后我们需要计算每个单元[2.x.166]上的矩阵[2.x.165]，为此我们需要在介绍中提到的矩阵[2.x.167]和[2.x.168]。   
* 可能不明显的一点是，在以前所有的教程程序中，我们总是用DoFHandler的单元格迭代器来调用[2.x.169]。这样就可以调用诸如[2.x.170]这样的函数，在单元格的正交点上提取有限元函数的值（用DoF值的向量表示）。为了使这一操作发挥作用，我们需要知道哪些向量元素对应于给定单元上的自由度
*
*--也就是说，正是DoFHandler类所提供的那种信息和操作。   
* 我们可以为 "破碎的 "Raviart-Thomas空间创建一个DoFHandler对象（使用FE_DGRT类），但我们在这里真的不想这样做。至少在当前函数中，我们不需要任何与这个破碎空间相关的全局定义的自由度，而只需要引用当前单元上的这种空间的形状函数。因此，我们利用这样一个事实，即人们也可以用单元格迭代器来调用[2.x.171]的Triangulation对象（而不是DoFHandler对象）。在这种情况下，FEValues当然只能为我们提供只引用单元格的信息，而不是这些单元格上列举的自由度。所以我们不能使用[2.x.172]，但我们可以使用[2.x.173]来获得当前单元格上正交点的形状函数值。下面我们要利用的就是这种功能。下面给我们提供Raviart-Thomas函数信息的变量是`fe_values_rt`（和相应的`fe_face_values_rt`）对象。   
* 鉴于上述介绍，下面的声明应该是非常明显的。
*


* [1.x.119]
*
* 接下来，让我们声明介绍中讨论的各种单元格矩阵。
*


* [1.x.120]
*
* 我们需要[2.x.174]来访问形状函数的[2.x.175]和[2.x.176]部分。
*


* [1.x.121]
*
* 这最终让我们在所有单元格上进行循环。在每个单元，我们将首先计算用于构建本地矩阵的各种单元矩阵
*
* - 因为它们取决于相关的单元，所以它们需要在每个单元上重新计算。我们还需要Raviart-Thomas空间的形状函数，为此我们需要首先创建一个通往三角化单元的迭代器，我们可以通过从指向DoFHandler的单元中的赋值来获得。
*


* [1.x.122]
*
* 我们要计算的第一个单元矩阵是Raviart-Thomas空间的质量矩阵。  因此，我们需要循环计算速度FEValues对象的所有正交点。
*


* [1.x.123]
*
* 接下来我们通过使用[2.x.177]对这个矩阵进行求逆，它将被用来计算后面的系数矩阵[2.x.178]。值得回顾的是，`cell_matrix_M`实际上包含了[2.x.179]的逆*。
 的逆值。
*


* [1.x.124]

* 从介绍中，我们知道定义[2.x.181]的方程的右边[2.x.180]是面积分和单元积分的区别。在这里，我们对内部的贡献的负值进行了近似。这个矩阵的每个分量都是多项式空间的一个基函数与拉维-托马斯空间的一个基函数的发散之间的乘积的积分。这些基函数是在内部定义的。
*


* [1.x.125]

* 接下来，我们用正交法对面的积分进行近似。每个分量都是多项式空间的基函数与Raviart-Thomas空间的基函数和法向量的点积之间的积分。所以我们在元素的所有面上循环，得到法向量。
*


* [1.x.126]
*
* [2.x.182]是[2.x.183]的转置与质量矩阵的逆向之间的矩阵乘积（该逆向存储在[2.x.184]）。
*


* [1.x.127]

* 最后我们可以计算出局部矩阵 [2.x.185] 。  元素 [2.x.186] 由 [2.x.187] 得到。我们在上一步已经计算了系数[2.x.188]，因此在适当地重新排列循环后得到以下结果。
*


* [1.x.128]

* 接下来，我们计算右手边，[2.x.189] 。
*


* [1.x.129]
*
* 最后一步是将局部矩阵的组件分配到系统矩阵中，并将单元格右侧的组件转移到系统右侧。
*


* [1.x.130]
*
* [1.x.131] [1.x.132]。



* 这一步相当琐碎，与以前的许多教程程序相同。



* [1.x.133]
*
* [1.x.134] [1.x.135]。


*
* 在这个函数中，从先前计算的压力解中计算出速度场。速度的定义为[2.x.190]，这需要我们计算许多与系统矩阵的组装相同的项。还有我们需要组装的矩阵[2.x.191]（见介绍），但它们实际上只是遵循同一种模式。   
* 在这里计算与我们在`assemble_system()`函数中已经完成的相同的矩阵，当然是在CPU时间上浪费了。同样，我们从那里复制了一些代码到这个函数中，这通常也是一个糟糕的主意。一个更好的实现可能会提供一个函数来封装这些重复的代码。我们也可以考虑使用计算效率和内存效率之间的经典权衡，在装配过程中每个单元只计算一次[2.x.192]矩阵，把它们存储在某个地方，然后在这里重新使用它们。例如，[2.x.193]就是这样做的，`assemble_system()`函数需要一个参数来决定是否重新计算本地矩阵，还有一个类似的方法
*


*
* - 也许与存储在其他地方的本地矩阵
*
* - 可以为目前的程序进行调整)。
*


* [1.x.136]
*
* 在介绍中，我们解释了如何计算单元上的数值速度。我们需要每个单元上的压力解值、格拉姆矩阵的系数和[2.x.194]投影的系数。我们已经计算了全局解，所以我们将从全局解中提取单元解。格拉姆矩阵的系数在我们计算压力的系统矩阵时已经计算过了。我们在这里也要这样做。对于投影的系数，我们做矩阵乘法，即用格拉姆矩阵的倒数乘以[2.x.195]的矩阵作为组成部分。然后，我们将所有这些系数相乘，称之为β。数值速度是贝塔和拉维尔特-托马斯空间的基础函数的乘积。
*


* [1.x.137]
*
* 这个[2.x.196]的组成部分是[2.x.197]的积分。  [2.x.198]是格拉姆矩阵。
*


* [1.x.138]
*
* 为了计算介绍中提到的矩阵[2.x.199]，我们就需要按照介绍中的解释来评估[2.x.200]。
*


* [1.x.139]
*
* 然后，我们还需要再次计算矩阵[2.x.201]，用来评估弱离散梯度。这与组装系统矩阵时使用的代码完全相同，所以我们只需从那里复制它。
*


* [1.x.140]

* 最后，我们需要提取对应于当前单元的压力未知数。
*


* [1.x.141]
*
* 我们现在可以计算当地的速度未知数（相对于我们将[2.x.202]项投射到的拉维阿特-托马斯空间而言）。
*


* [1.x.142]
*
* 我们计算达西速度。这与cell_velocity相同，但用于绘制Darcy速度图。
*


* [1.x.143]
*
* [1.x.144] [1.x.145]。


*
* 这一部分是计算压力的[2.x.203]误差。  我们定义一个向量，用来保存每个单元上的误差的规范。接下来，我们使用[2.x.204]来计算每个单元上的[2.x.205]准则的误差。然而，我们实际上只关心解向量的内部分量的误差（我们甚至不能评估正交点的界面压力，因为这些都位于单元格的内部），因此必须使用一个权重函数，确保解变量的界面分量被忽略。这是通过使用ComponentSelectFunction来实现的，其参数表明我们要选择哪个分量（零分量，即内部压力）以及总共有多少分量（两个）。
*


* [1.x.146]
*
* [1.x.147] [1.x.148]。


*
* 在这个函数中，我们评估每个单元的速度的[2.x.206]误差，以及面的通量的[2.x.207]误差。该函数依赖于之前计算过的`compute_postprocessed_velocity()`函数，该函数根据之前计算过的压力解来计算速度场。   
* 我们将评估每个单元的速度，并计算数值速度和精确速度之间的差异。
*


* [1.x.149]
*
* 在之前计算了后处理的速度之后，我们在这里只需要提取每个单元和面的相应数值，并与精确的数值进行比较。
*


* [1.x.150]
*
* 首先计算后处理的速度场与精确速度场之间的[2.x.208]误差。
*


* [1.x.151]
*
* 为了重建通量，我们需要单元和面的大小。由于通量是按面计算的，我们要在每个单元的所有四个面上进行循环。为了计算面的速度，我们从之前计算的`darcy_velocity`中提取正交点的值。然后，我们计算法线方向的速度平方误差。最后，我们通过对面和单元面积的适当缩放来计算单元上的[2.x.209]通量误差，并将其加入全局误差。
*


* [1.x.152]
*
* 将所有单元和面的误差相加后，我们进行平方根计算，得到速度和流量的[2.x.210]误差。这些我们都输出到屏幕上。
*


* [1.x.153]
*
* [1.x.154] [1.x.155]。



* 我们有两组结果要输出：内部解和骨架解。我们使用[2.x.211]来实现内部结果的可视化。骨架结果的图形输出是通过使用DataOutFaces类完成的。   
*在这两个输出文件中，内部和面的变量都被储存起来。对于界面输出，输出文件只是包含了内部压力对面的插值，但是因为没有确定从两个相邻的单元中得到的是哪一个内部压力变量，所以在界面输出文件中最好是忽略内部压力。相反，对于单元格内部输出文件，当然不可能显示任何界面压力[2.x.212]，因为这些压力只适用于界面，而不是单元格内部。因此，你会看到它们被显示为一个无效的值（比如一个无穷大）。   
* 对于细胞内部的输出，我们还想输出速度变量。这有点棘手，因为它生活在同一个网格上，但使用不同的DoFHandler对象（压力变量生活在`dof_handler`对象上，达西速度生活在`dof_handler_dgrt`对象上）。幸运的是，[2.x.213]函数有一些变化，允许指定一个矢量对应的DoFHandler，因此我们可以在同一个文件中对两个DoFHandler对象的数据进行可视化。
*


* [1.x.156]
*
*首先将压力解决方案附加到DataOut对象上。
*


* [1.x.157]
*
* 然后对达西速度场做同样的处理，并继续将所有的东西写到文件中。
*


* [1.x.158]
*
* [1.x.159] [1.x.160]。


*
* 这是主类的最后一个函数。它调用我们类的其他函数。
*


* [1.x.161]
*
* [1.x.162] [1.x.163]。


*
* 这是主函数。我们可以在这里改变维度以在3D中运行。
*


* [1.x.164]
* [1.x.165][1.x.166] 。


* 我们运行的程序的右手边将产生解决方案[2.x.214]，并且在域[2.x.215]中具有同质的迪里希边界条件。此外，我们选择微分算子[2.x.216]中的系数矩阵作为身份矩阵。我们使用[2.x.217]、[2.x.218]和[2.x.219]元素组合来测试这个设置，可以通过使用`main()`WGDarcyEquation`对象的适当构造器参数来选择。然后我们将可视化单元内部和面上的压力值。我们希望看到压力最大值在1左右，最小值在0左右。通过网格细化，压力、速度和通量的收敛率对于[2.x.220]应该是1左右，对于[2.x.221]是2，对于[2.x.222]是3。
*

* [1.x.167][1.x.168][1.x.169] 。


* 下面的数字显示了使用[2.x.223]元素的内部压力和表面压力。网格分别被细化了2倍（顶部）和4倍（底部）。(这个数字可以在`make_grid()`函数中调整)。当网格较粗时，我们可以看到面压[2.x.224]与相邻两个单元的内压[2.x.225]的值之间的整齐排列。
* [2.x.226]
* 从图中我们可以看出，随着网格的细化，最大和最小的压力值正在接近我们预期的数值。由于网格是矩形网格，每个方向的单元数是偶数，所以我们有对称的解决方案。从右边的三维图中，我们可以看到在[2.x.227]上，压力在单元的内部是一个常数，正如预期的那样。
* [1.x.170][1.x.171][1.x.172] 。
*

* 我们用不同的细化网格（在`make_grid()`函数中选择）运行代码，得到以下压力、速度和通量的收敛率（如介绍中定义的）。
* [2.x.228]
* 我们可以看到，[2.x.229]的收敛率大约为1.当然，这与我们的理论预期相符。
*

* [1.x.173][1.x.174][1.x.175] 。


* 我们可以使用下一个更高的多项式度数来重复上面的实验：下面的数字是使用[2.x.230]实现的内部压力和表面压力。网格被细化了4次。  与之前使用[2.x.231]的数字相比，在每个单元上，解决方案不再是恒定的，因为我们现在使用双线性多项式来做近似。因此，在一个内部有4个压力值，每个面有2个压力值。
* [2.x.232]
* 与[2.x.233]组合的相应图像相比，现在的解决方案明显更准确，特别是在界面上非常接近于连续，我们不再能够区分界面压力[2.x.234]和相邻单元的内部压力[2.x.235]。
* [1.x.176][1.x.177][1.x.178] 。
*

* 以下是我们从使用[2.x.236]元素组合得到的压力、速度和通量的收敛率。
* [2.x.237]
* [2.x.238]的收敛率在2左右，符合预期。
*


* [1.x.179][1.x.180][1.x.181] 。


* 让我们再提高一个多项式度数。以下是使用[2.x.239]实现的内部压力和表面压力，网格大小为[2.x.240]（即5个全局网格细化步骤）。在程序中，当生成图形输出时，我们使用`data_out_face.build_patches(fe.degree)`（见文献[2.x.241]，这里意味着我们将每个2d单元内部分为4个子单元，以提供一个更好的二次多项式的可视化。[2.x.242]
*

* [1.x.182][1.x.183][1.x.184] 。


* 和以前一样，我们可以用[2.x.244]的组合来生成压力、速度和流量的[2.x.243]误差的收敛数据。
* [2.x.245]
* 再一次，[2.x.246]的收敛率符合预期，数值在3左右。
*

* [1.x.185][1.x.186] [2.x.247] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-62_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33][1.x.34][1.x.35][1.x.36][1.x.37][1.x.38]
* [2.x.3]
* [1.x.39] [2.x.4]


*
* [2.x.5] 作为这个程序的先决条件，你需要安装HDF5、复杂的PETSc和p4est库。在[1.x.40]文件中描述了deal.II和这些附加库的安装情况。
* [1.x.41][1.x.42] 。
* 声子晶体是一种周期性的纳米结构，它可以改变机械振动或[声子]的运动(https://en.wikipedia.org/wiki/Phonon)。声子结构可以用来分散、引导和限制机械振动。这些结构在[量子信息](https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.86.1391)方面有潜在的应用，并被用来研究[宏观量子现象](https://science.sciencemag.org/content/358/6360/203)。声子晶体通常在[洁净室]中制造(https://en.wikipedia.org/wiki/Cleanroom)。
* 在本教程中，我们展示了如何设计一个[声子超晶格空腔](https://doi.org/10.1103/PhysRevA.94.033813)，这是一种特殊类型的声子晶体，可以用来限制机械振动。声子超晶格空腔是由两个[分布式布拉格反射器](https://en.wikipedia.org/wiki/Distributed_Bragg_reflector)、镜子和一个[2.x.6]空腔组成，其中[2.x.7]是声学波长。声学DBRs是一种周期性结构，一组具有对比物理特性（声速指数）的双层叠层被重复[2.x.8] 次。超晶格空腔通常通过[分子束外延](https://en.wikipedia.org/wiki/Molecular-beam_epitaxy)在[砷化镓](https://en.wikipedia.org/wiki/Gallium_arsenide)晶片上生长。双层对应于GaAs/AlAs镜像对。如下图所示，镜像层（褐色和绿色）的厚度为[2.x.9]，空腔（蓝色）的厚度为[2.x.10] 。
* [2.x.11]
* 在本教程中，我们计算了一个声子超晶格空腔的[带隙](https://en.wikipedia.org/wiki/Band_gap)和机械共振，但是这里介绍的代码可以很容易地用于设计和计算其他类型的[声子晶体](https://science.sciencemag.org/content/358/6360/203)。
* 本教程的模拟是在二维中完成的，但代码与尺寸无关，可以很容易地用于三维模拟。波导宽度等于域的[2.x.12]维，波导长度等于域的[2.x.13]维。
*
*-单模。在这种情况下，结构的宽度要比波长小得多。  这种情况可以用有限元法（我们在此采取的方法）或用简单的半分析法[一维转移矩阵形式]（https://en.wikipedia.org/wiki/Transfer_matrix）来解决。
*
* - 多模。在这种情况下，结构的宽度比波长大。  这种情况可以用有限元法或[散射矩阵形式主义](https://doi.org/10.1103/PhysRevA.94.033813)来解决。  虽然我们在本教程中没有研究这种情况，但通过增加波导宽度参数（jupyter笔记本中的`dimension_y'），很容易达到多模制度。
* 本教程的模拟是在频域中进行的。为了计算传输光谱，我们使用了一个[程序](https://meep.readthedocs.io/en/latest/Python_Tutorials/Resonant_Modes_and_Transmission_in_a_Waveguide_Cavity/)，这在时域[FDTD](https://en.wikipedia.org/wiki/Finite-difference_time-domain_method)模拟中是常用的。在结构的左侧产生一个特定频率的脉冲，在结构的右侧测量传输的能量。首先，我们用声子结构运行模拟，并测量传输的能量。
* [2.x.14]
* 然后，我们运行没有声子结构的模拟，并测量传输的能量。我们使用没有结构的模拟来进行校准。
* [2.x.15]
* 传输系数相当于第一个模拟的能量除以校准能量。我们对每个频率步骤重复这一程序。
*

*[1.x.43][1.x.44]
* 我们在这里要模拟的是弹性波的传输。因此，对问题的正确描述是使用弹性方程，在时域中由[1.x.45]给出，其中刚度张量[2.x.16]取决于空间坐标，应变是位移的对称梯度，由[1.x.46]给出。
* [完全匹配层（PML）](https://en.wikipedia.org/wiki/Perfectly_matched_layer)可用于在边界处截断解决方案。PML是一种导致复杂坐标拉伸的变换。
* 本教程程序没有采用时域方法，而是通过对时间变量进行傅里叶变换，将上述方程转换为频域。然后，频域中的弹性方程如下[1.x.47] 。
*其中系数[2.x.17]说明了吸收情况。在三维中有3个[2.x.18]系数，在二维中有2个。[2.x.19]的虚部在PML外等于零。PML只对精确的波方程无反射。当方程组被离散化时，PML不再无反射。只要hemedium缓慢变化，反射可以被任意地变小，见[绝热定理] (https://doi.org/10.1103/PhysRevE.66).066608）。在代码中使用了PML的二次开启。线性和三次开启也[已知可行](https://doi.org/10.1364/OE.16.011376)。这些方程可以扩展为[1.x.48][1.x.49]，其中对重复指数进行求和（这里是[2.x.20]，以及[2.x.21]和[2.x.22])的求和总是隐含的。注意，在应用PML的复数坐标拉伸后，应变不再是对称的。这组方程可以写成[1.x.50]
* 与应变一样，应力张量在PML内也不是对称的（[2.x.23]）。事实上，PML内的场不是物理的。引入张量[2.x.24]和[2.x.25]是有用的。
* 我们可以乘以[2.x.26]，并在域[2.x.27]上进行积分，并通过部分积分。
* 正是这组方程，我们要解决一组频率[2.x.28]，以计算传输系数作为频率的函数。
*
*[1.x.54][1.x.55]。
* 在本教程中，我们使用python[jupyter notebook](https://github.com/dealii/dealii/blob/master/examples/ [2.x.29] / [2.x.30] .ipynb)来设置参数和运行模拟。首先，我们创建一个HDF5文件，在其中存储参数和模拟的结果。
* 每个模拟（位移和校准）都存储在一个单独的HDF5组中。
* [1.x.56]
*
*

* [1.x.57] [1.x.58]。
* [1.x.59][1.x.60] 。
*

*
* 我们在这个程序中需要的大部分包含文件已经在以前的程序中讨论过了，特别是在 [2.x.31] 中。
*


* [1.x.61]

* 下面的标头提供了我们用来表示材料属性的张量类。
*


* [1.x.62]
*
* 以下是deal.II的HDF5接口所需的头。
*


* [1.x.63]
*
* 这个标头是我们用来评估模拟结果的函数[2.x.32]所需要的。
*


* [1.x.64]

* 我们需要这些头文件，用于我们在函数[2.x.34]中使用的函数[2.x.33] 。



* [1.x.65]
*
* [1.x.66] [1.x.67] 以下类用于存储模拟的参数。
*

*
* [1.x.68] [1.x.69] 该类用于定义结构左侧的力脉冲。
*


* [1.x.70]
*
* 变量`data`是[2.x.35]，所有的模拟结果都将存储在其中。注意，变量[2.x.36][2.x.37][2.x.38]和[2.x.39]指向HDF5文件的同一组。当[2.x.40]被复制时，它将指向HDF5文件的同一组。
*


* [1.x.71]
*
* 仿真参数作为HDF5属性存储在`data`中。以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。
*


* [1.x.72]
*
*在这个特定的模拟中，力只有一个[2.x.41]分量，[2.x.42] 。
*


* [1.x.73]
*
* [1.x.74] [1.x.75] 该类用于定义完美匹配层（PML）的形状，以吸收向边界传播的波。
*


* [1.x.76]
*
* [2.x.43]，所有的模拟结果都将被储存在其中。
*


* [1.x.77]
*
* 和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。
*


* [1.x.78]
*
* [1.x.79] [1.x.80] 该类用于定义质量密度。
*


* [1.x.81]
*
* [2.x.44]，所有的模拟结果将被储存在其中。
*


* [1.x.82]
*
* 和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。
*


* [1.x.83]
*
* [1.x.84] [1.x.85] 该类包含所有将在模拟中使用的参数。
*


* [1.x.86]
*
* [2.x.45]，所有的模拟结果将被储存在其中。
*


* [1.x.87]
*
* 和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在`data`中，然后由构造函数读取。
*


* [1.x.88]
*
* [1.x.89] [1.x.90] 质量和刚度矩阵的计算非常昂贵。这些矩阵对所有的频率步骤都是一样的。右手边的向量对于所有的频率步骤也是一样的。我们用这个类来存储这些对象，并在每个频率步骤中重新使用它们。请注意，这里我们不存储集合的质量和刚度矩阵以及右手边，而是存储单个单元的数据。QuadratureCache "类与 "PointHistory "类非常相似，后者已在 [2.x.46] 中使用。
*


* [1.x.91]
*
* 我们在变量mass_coefficient和stiffness_coefficient中存储质量和刚度矩阵。我们还存储了右手边和JxW值，这些值对所有的频率步骤都是一样的。
*


* [1.x.92]
*
* [1.x.93] [1.x.94]。



* 这个函数返回材料的刚度张量。为了简单起见，我们认为刚度是各向同性和同质的；只有密度 [2.x.47] 取决于位置。正如我们之前在 [2.x.48] 中所表明的，如果刚度是各向同性和均质的，刚度系数 [2.x.49] 可以表示为两个系数 [2.x.50] 和 [2.x.51] 的函数。系数张量简化为 [1.x.95] 。
*


* [1.x.96]
*
* [1.x.97] [1.x.98]。


*
* 接下来我们来声明这个程序的主类。它的结构与[2.x.52]的教程程序非常相似。主要的区别是。
*


*
* - 扫过的频率值。
*


*
* - 我们将刚度和质量矩阵保存在`quadrature_cache`中，并将其用于每个频率步骤。
*


*
* - 我们在HDF5文件中存储每个频率步骤的探头测量的能量。
*


* [1.x.99]
*
* 在每一个频率步骤之前都会被调用，以便为缓存变量设置一个原始状态。
*


* [1.x.100]
*
* 这个函数在频率向量上循环，并对每个频率步骤运行模拟。
*


* [1.x.101]
*
* 参数存储在这个变量中。
*


* [1.x.102]
*
* 我们为每个单元存储质量和刚度矩阵，这个向量。
*


* [1.x.103]
*
* 这个向量包含我们要模拟的频率范围。
*


* [1.x.104]
*
* 这个向量包含了测量探头的点的坐标[2.x.53]。
*


* [1.x.105]
*
* HDF5数据集来存储频率和`探针位置`向量。
*


* [1.x.106]
*
* HDF5数据集，存储探针测量的能量值。
*


* [1.x.107]
*
* [1.x.108] [1.x.109]。



* [1.x.110] [1.x.111]。


*
*构造函数使用[2.x.54]函数从[2.x.55]`data`中读取所有参数。
*


* [1.x.112]
*
* 这个函数定义了力矢量脉冲的空间形状，其形式为高斯函数


* [1.x.113]
*其中[2.x.56]是取力的最大振幅，[2.x.57]和[2.x.58]是[2.x.59]和[2.x.60]成分的标准偏差。注意，脉冲已被裁剪为[2.x.61]和[2.x.62] 。
*


* [1.x.114]
*
* [1.x.115] [1.x.116]。


*
* 和以前一样，构造函数使用[2.x.63] `data`函数从[2.x.64]中读取所有参数。正如我们已经讨论过的，在jupyter笔记本中已经定义了PML的二次方开启。通过改变参数`pml_coeff_degree`，可以使用线性、立方或其他幂度。参数`pml_x`和`pml_y`可以用来开启和关闭`x`和`y`PML。
*


* [1.x.117]
*
* `x`部分的PML系数的形式为[2.x.65] 。
*


* [1.x.118]
*
* [1.x.119] [1.x.120]。


*
* 这个类是用来定义质量密度的。正如我们之前解释的那样，声学超晶格空腔是由两个[分布式反射器](https://en.wikipedia.org/wiki/Band_gap)、镜子和一个[2.x.66]空腔组成，其中[2.x.67]是声学波长。声学DBRs是一种周期性结构，其中一组具有对比物理特性（声速指数）的双层叠层被重复[2.x.68]次。波速的变化是由具有不同密度的层交替产生的。
*


* [1.x.121]
*
* 为了提高精度，我们使用[子像素平滑](https://meep.readthedocs.io/en/latest/Subpixel_Smoothing/)。
*


* [1.x.122]
*
* 声速由[1.x.123]定义，其中[2.x.69]是有效弹性常数，[2.x.70]是密度。这里我们考虑波导宽度远小于波长的情况。在这种情况下，可以证明对于二维的情况[1.x.124]和三维的情况[2.x.71]等于杨氏模量。[1.x.125]
*


* [1.x.126]
*
*密度[2.x.72]采取以下形式 <img alt="音素超晶格空腔" src="https://www.dealii.org/images/steps/developer/ [2.x.73] .04.svg" height="200" />其中棕色代表材料_a，绿色代表材料_b。
*


* [1.x.127]
*
* 这里我们定义了[subpixel smoothing](https://meep.readthedocs.io/en/latest/Subpixel_Smoothing/)，它可以提高模拟的精度。
*


* [1.x.128]
*
* 那么腔体
*


* [1.x.129]
*
* material_a层
*


* [1.x.130]
*
* material_b层
*


* [1.x.131]
*
* 最后默认为 material_a。
*


* [1.x.132]
*
* [1.x.133] [1.x.134]。


*
*构造函数使用[2.x.74]函数从[2.x.75]`data`中读取所有参数。
*


* [1.x.135]
*
* [1.x.136] [1.x.137]。


*
* 我们需要为质量和刚度矩阵以及右手边的矢量保留足够的空间。
*


* [1.x.138]
*
* [1.x.139] [1.x.140]。



* [1.x.141] [1.x.142]。


*
* 这与 [2.x.76] 的构造函数非常相似。此外，我们创建了HDF5数据集`frequency_dataset`，`position_dataset`和`displacement`。注意在创建HDF5数据集时使用了`template'关键字。这是C++的要求，使用`template`关键字是为了将`create_dataset`作为一个依赖的模板名称。
*


* [1.x.143]
*
* [1.x.144] [1.x.145]。


*
* 这个函数没有什么新内容，与[2.x.77]的唯一区别是，我们不必应用边界条件，因为我们用PML来截断域。
*


* [1.x.146]
*
* [1.x.147] [1.x.148]。


*
* 这个函数也与[2.x.78]非常相似，尽管有明显的区别。我们为每个频率/欧米茄步骤组装系统。在第一步中，我们设置`calculate_quadrature_data = True`，我们计算质量和刚度矩阵以及右手边的矢量。在随后的步骤中，我们将使用这些数据来加速计算。
*


* [1.x.149]

* 这里我们存储了右手边的值，rho和PML。
*


* [1.x.150]
*
* 我们计算在jupyter笔记本中定义的[2.x.79]和[2.x.80]的刚度张量。注意，与[2.x.81]相反，刚度在整个领域中是恒定的。
*


* [1.x.151]

* 我们使用[2.x.82]的相同方法处理向量值问题。
*


* [1.x.152]
*
* 只有当我们要计算质量和刚度矩阵时，我们才必须计算右手边的值，rho和PML。否则我们可以跳过这个计算，这样可以大大减少总的计算时间。
*


* [1.x.153]

* 我们在 [2.x.83] 中已经做了这个。获得一个指向当前单元本地的正交缓存数据的指针，作为一种防御措施，确保这个指针在全局数组的范围内。
*


* [1.x.154]
*
* quadrature_data变量用于存储质量和刚度矩阵、右手边向量和`JxW`的值。
*


* [1.x.155]

* 下面我们声明力向量和PML的参数 [2.x.84] 和 [2.x.85] 。
*


* [1.x.156]

* 下面的块只在第一个频率步骤中计算。
*


* [1.x.157]
*
* 存储`JxW`的值。
*


* [1.x.158]
*
* 将向量转换为张量并计算xi
*


* [1.x.159]
*
* 这里我们计算[2.x.86]和[2.x.87]的张量。
*


* [1.x.160]
*
* 计算质量矩阵的值。
*


* [1.x.161]
*
*在刚度张量的[2.x.88]指数上循环。
*


* [1.x.162]
*
* 这里我们计算了刚度矩阵。注意，由于PML的存在，刚度矩阵不是对称的。我们使用梯度函数（见[文件](https://www.dealii.org/current/doxygen/deal.II/group__vector__valued.html)），它是一个 [2.x.89] 。矩阵[2.x.90]由条目[1.x.163]组成 注意指数[2.x.91]和[2.x.92]的位置以及我们在本教程中使用的符号。  [2.x.93] .由于刚度张量不是对称的，所以很容易出错。
*


* [1.x.164]
*
* 我们将刚度矩阵的值保存在quadrature_data中
*


* [1.x.165]
*
*和正交_数据中的右手边的值。
*


* [1.x.166]
*
* 我们再次循环单元的自由度来计算系统矩阵。这些循环真的很快，因为我们已经计算了刚度和质量矩阵，只有[2.x.94]的值发生了变化。
*


* [1.x.167]
*
* [1.x.168] [1.x.169]。


*
* 这比[2.x.95]中更加简单。我们使用并行的直接求解器MUMPS，它比迭代求解器需要更少的选项。缺点是它的规模不是很好。用迭代求解器来解决Helmholtz方程并不简单。移位拉普拉斯多网格法是一种众所周知的预处理该系统的方法，但这超出了本教程的范围。
*


* [1.x.170]
*
* [1.x.171] [1.x.172]。


*
* 我们用这个函数来计算位置向量的值。
*


* [1.x.173]
*
* 因为运算符+和的方式
*
* -被重载来减去两个点，所以必须做如下操作。`Point_b<dim> + (-Point_a<dim>)`。
*


* [1.x.174]
*
* [1.x.175] [1.x.176]。


*
* 这个函数在HDF5文件中存储了探头测量的能量。
*


* [1.x.177]
*
* 我们存储[2.x.96]方向的位移；[2.x.97]方向的位移可以忽略不计。
*


* [1.x.178]
*
* 向量坐标包含HDF5文件中位于本地所有单元中的探针点的坐标。向量displacement_data包含这些点的位移值。
*


* [1.x.179]
*
* 然后我们可以在`displacement_data`中存储探头各点的位移值。
*


* [1.x.180]

* 我们在HDF5文件中写入位移数据。调用[2.x.98]是MPI集体的，这意味着所有的进程都要参与。
*


* [1.x.181]
*
* 因此，即使进程没有数据可写，它也必须参与集体调用。为此，我们可以使用[2.x.99] 注意，我们必须指定数据类型，在这种情况下是[2.x.100] 。
*


* [1.x.182]
*
* 如果输入文件中的变量`save_vtu_files`等于`True`，那么所有的数据将被保存为vtu。写入`vtu`文件的程序已经在 [2.x.101] 中描述。
*


* [1.x.183]
*
* 在我们不感兴趣的单元格上，将各自的值设置为一个假的值，以确保如果我们的假设有什么错误，我们会通过看图形输出发现的。
*


* [1.x.184]
*
* [1.x.185] [1.x.186]。


*
* 这个函数写入尚未写入的数据集。
*


* [1.x.187]
*
* 向量`频率`和`位置`对所有进程都是一样的。因此任何一个进程都可以写入相应的`数据集'。因为调用[2.x.102]是MPI集体的，其余进程将不得不调用[2.x.103]。
*


* [1.x.188]
*
* [1.x.189] [1.x.190]。


*
* 我们在计算开始时使用这个函数来设置缓存变量的初始值。这个函数已经在 [2.x.104] 中描述过。与 [2.x.105] 的函数没有区别。
*


* [1.x.191]
*
* [1.x.192] [1.x.193]。


*
* 为了清楚起见，我们把[2.x.106]的函数`run`分为`run`和`frequency_sweep`两个函数。在函数`frequency_sweep`中，我们在频率向量上进行迭代。
*


* [1.x.194]
*
*只写一次模拟参数
*


* [1.x.195]

* 我们计算出这个特定步骤的频率和欧米茄值。
*


* [1.x.196]
*
* 在第一个频率步骤中，我们计算出质量和刚度矩阵以及右手边。在随后的频率步骤中，我们将使用这些值。这大大地改善了计算时间。
*


* [1.x.197]
*
* [1.x.198] [1.x.199]。


*
* 这个函数与 [2.x.107] 中的函数非常相似。
*


* [1.x.200]
*
* [1.x.201] [1.x.202]。


*
* 主函数与 [2.x.108] 中的函数非常相似。
*


* [1.x.203]
*
* 每个模拟（位移和校准）都存储在一个单独的HDF5组中。
*


* [1.x.204]
*
* 对于这两个组名中的每一个，我们现在创建组并将属性放入这些组。具体来说，这些是。
*


*
* - 波导的尺寸（在[2.x.109]和[2.x.110]方向）。
*


*
* - 探头的位置（在[2.x.111]和[2.x.112]方向）。
*


*
* - 探针中的点的数量
*


*
* - 全局细化水平
*


*
* - 腔体谐振频率
*


*
* - 镜像对的数量
*


*
* - 材料属性



*
* - 力量参数
*


*
* - PML的参数
*


*
* - 频率参数
*


*


* [1.x.205]
*
* 位移模拟。参数从位移HDF5组中读取，结果保存在同一HDF5组中。
*


* [1.x.206]
*
* 校准模拟。参数从校准HDF5组中读取，结果保存在同一HDF5组中。
*


* [1.x.207]
* [1.x.208][1.x.209] 。


*[1.x.210][1.x.211]


* 在[jupyter notebook](https://github.com/dealii/dealii/blob/master/examples/ [2.x.113] / [2.x.114] .ipynb)中用以下代码分析结果
* [1.x.212]
*
* 一个声腔的特点是[共振频率](https://en.wikipedia.org/wiki/Resonance)和[品质因数](https://en.wikipedia.org/wiki/Q_factor)。品质因数等于共振器中储存的能量与每周期耗散的能量之间的比率，大约相当于共振频率与[半满宽度（FWHM）](https://en.wikipedia.org/wiki/Full_width_at_half_maximum)之间的比率。FWHM等于振动功率大于共振频率功率一半的带宽。[1.x.213]
*机械共振[2.x.115]振幅的平方作为频率的函数具有高斯形状[1.x.214]，其中[2.x.116]是共振频率，[2.x.117]是耗散率。我们在jupyter笔记本中使用之前的方程式来拟合机械共振。
*鉴于我们为参数选择的值，人们可以通过分析来估计共振频率。事实上，我们在这个程序中得到的结果证实了这一点：声子超晶格空腔在20GHz时表现出机械共振，质量系数为5046。以下图片显示了在共振频率附近的传输振幅和相位与频率的函数关系。
* [2.x.118] [2.x.119]。
* 上述图像表明，周期性结构有其预期的效果：它实际上只让一个非常特殊的频率的波通过，而所有其他的波都被反射。当然，这正是人们建造这类装置的目的。但这并不十分容易。在实践中，实际上只有一个 "带隙"，也就是说，该设备只在一定的频率范围内阻止20GHz以外的其他波。事实上，要想知道这个 "差距 "有多大，我们可以通过输入文件中的适当参数将频率范围扩大到16GHz。然后我们得到以下图像。
* [2.x.120]
* 这张图表明，在18到22GHz左右的范围内，实际上只有频率为20GHz的波被允许通过，但在这个范围之外，还有很多其他频率的波可以通过设备。
*[1.x.215][1.x.216]
*

* 我们可以用Paraview或VisIt检查模式剖面。正如我们已经讨论过的，在共振时，所有的机械能都被传输，运动的振幅在腔内被放大了。
* [2.x.121]
* 另一方面，在共振之外，所有的机械能都被反射了。下图显示了19.75GHz时的轮廓。注意力脉冲和反射波在[2.x.122]位置的干扰。
* [2.x.123]
* [1.x.217][1.x.218] 。
*

* 声波超晶格空腔在[量子光学力学](https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.86.1391)中找到了应用。这里我们介绍了一个二维超晶格空腔的模拟，但这个代码也可以用来模拟 "现实世界 "的三维器件，如[微柱超晶格空腔](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.99.060101)，它是研究宏观量子现象的有希望的候选器件。微柱超晶格空腔的20GHz模式本质上是一个机械谐波振荡器，与环境隔离得非常好。如果该装置在稀释冰箱中被冷却到20mK，那么该模式将成为一个宏观的量子谐波振荡器。
*

*[1.x.219][1.x.220]


* 我们可以用Python脚本来设置参数，并将其保存在我们将用于模拟的HDF5文件中，而不是在C++文件中设置参数。然后，deal.II程序将从HDF5文件中读取这些参数。
* [1.x.221]
*
* 为了读取HDF5参数，我们必须使用[2.x.124]标志。
* [1.x.222]
*
*

* [1.x.223][1.x.224] [2.x.125] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-63_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33]
* [2.x.2]
* [1.x.34]
* [2.x.3]
* [1.x.35][1.x.36][1.x.37] 。


* 该程序使用几何多网格(GMG)预处理程序解决了一个平流-扩散问题。这个预处理程序的基本原理在[2.x.4]中讨论过；这里我们讨论非对称PDE所需的必要变化。此外，我们还介绍了块平滑的概念（与[2.x.5]中的点平滑相比），并研究了加法和乘法平滑器的DoF重编号的效果。
*[1.x.38][1.x.39]
* 平流-扩散方程由以下公式给出
* [1.x.40]
* 其中[2.x.6] ，[2.x.7]是[1.x.41]，而[2.x.8]是一个源。有几个注意事项。
* 1.如果[2.x.9]，这是在[2.x.10]中解决的拉普拉斯方程（以及其他许多地方）。
* 2.如果[2.x.11]，这是在[2.x.12]中解决的固定平流方程。
* 3.人们可以为这个问题定义一个无维数，称为[1.x.42]。  [2.x.13] ，其中[2.x.14] 是域的长度尺度。它描述了我们所考虑的那种方程。如果[2.x.15]，我们说问题是[1.x.43]，否则如果[2.x.16]，我们会说问题是[1.x.44]。
* 在本教程的讨论中，我们将关注以对流为主的流动。这是很复杂的情况。我们知道，对于扩散主导的问题，标准的Galerkin方法可以很好地工作，我们也知道简单的多网格方法，如[2.x.17]中定义的方法，非常有效。另一方面，对于以对流为主的问题，标准Galerkin方法会导致震荡和不稳定的离散，而且简单的求解器往往不是很有效。因此，本教程的目的是解决这两个问题。
*

*[1.x.45][1.x.46]


* 使用标准的Galerkin有限元方法，对于合适的测试函数 [2.x.18] ，PDE的离散弱形式将为
* [1.x.47]
*其中
* [1.x.48]
*
* 不幸的是，用这种方法通常会得到震荡解。事实上，对于这种形式，可以显示出以下误差估计。
* [1.x.49]
* 如果精确解足够平滑，右边的下限可以被估计为如下。
* [1.x.50]
*其中[2.x.19]是所用有限元的多项式程度。因此，我们得到的估计是
* [1.x.51]
* 换句话说，数值解会收敛。另一方面，鉴于上述[2.x.20]的定义，我们不得不期待在[2.x.21]时，即在问题只有少量扩散的情况下，有较大误差的数值解。
* 为了解决这个问题，我们将考虑新的弱形式
* [1.x.52]
* 其中，总和是在所有单元[2.x.22]上进行的，每个单元都有内积，[2.x.23]是定义在[2.x.24]中的一个单元常数稳定参数。
* 本质上，加入离散强形式残差会增强双线性形式[2.x.25]的矫捷性，从而提高离散解的稳定性。这种方法通常被称为[1.x.53]或[1.x.54]（流线上风/Petrov-Galerkin）。
*

*[1.x.55][1.x.56]


* 本教程的目标之一是扩展使用一个简单的（point-wise）高斯-赛德尔（SOR）平滑器，该平滑器在[2.x.26]中使用。对于标量问题，这意味着使用一个求解器，每次更新线性系统的一个未知数，同时保持所有其他未知数的固定；然后对问题中的所有未知数进行迭代，一旦完成，从第一个未知数重新开始，直到这些 "扫频 "收敛。Jacobi、Gauss-Seidel和SOR迭代都可以用这种方式来解释。在多重网格的背景下，人们不认为这些方法是 "求解器"，而是 "平滑器"。因此，人们对实际解决线性系统不感兴趣。为了使多网格方法发挥作用，只需去除残差中的高频部分即可，因为这样可以将解限制在更粗的网格中。  因此，我们只需对所有未知数进行少数固定数量的 "扫描"。在本教程的代码中，这是由 "平滑步骤 "参数控制的。
* 但众所周知，这些方法在用于解析器时收敛得相当慢。虽然作为多网格平滑器，它们出乎意料地好，但它们也可以被改进。特别是，我们在这里也考虑 "基于单元 "的平滑器。这些方法一次解决一个单元的所有未知数，保持所有其他未知数的固定；然后转到下一个单元，如此反复。我们可以把它们看作是雅可比（Jacobi）、高斯-赛德尔（Gauss-Seidel）或SOR的 "区块 "版本，但由于自由度是由多个单元共享的，这些区块是重叠的，这些方法实际上最好是在加法和乘法施瓦茨方法的框架内解释。
* 与[2.x.27]相比，我们的测试问题包含一个平流项。特别是在扩散常数较小的情况下[2.x.28]，信息是沿着给定的平流方向的流线进行传输的。这意味着，如果平滑器在一次平滑应用中允许信息沿下游方向传播，那么平滑器可能会更有效。如果我们想按照这些未知数（或未知数块）被列举的顺序每次解决一个未知数（或未知数块），那么这种信息传播特性要求我们相应地重新排列自由度或单元（对于基于单元的平滑器），以便更上游的自由度被提前处理（指数较低），更下游的自由度被推迟处理（指数较大）。排序的影响将在结果部分显现。
* 现在让我们简单地定义一下本教程中使用的平滑器。关于更详细的介绍，我们参考[2.x.29]和书籍[2.x.30]和[2.x.31]。 一个Schwarzpreconditioner需要一个分解
* [1.x.57]
*我们的有限元空间 [2.x.32] 。每个子问题 [2.x.33] 也有一个基于双线性形式 [2.x.35] 的里兹投影 [2.x.34] 。这个投影为每个子问题[2.x.37]诱导了一个局部算子[2.x.36]。如果[2.x.38]是对[2.x.39]的正交投影，可以证明[2.x.40] 。
* 由此，我们可以为运算符[2.x.41]定义一个[1.x.58]为
* [1.x.59]
* 换句话说，我们将我们的解决方案投射到每个子问题中，应用子问题[2.x.42]的逆，并将所有[2.x.43]的贡献相加。
* 请注意，我们可以通过为每个自由度定义一个子问题[2.x.44]，将逐点（一次一个未知数）的雅可比方法解释为加性施瓦茨方法。然后，[2.x.45]成为与[2.x.46]的对角线条目的逆数相乘的结果。
* 对于本教程中使用的 "Block Jacobi "方法，我们为当前层次上的每个网格单元定义一个子问题[2.x.47]。注意，我们使用的是连续有限元，所以这些块是重叠的，因为两个单元之间的界面上的自由度属于两个子问题。在子问题上操作施瓦兹算子的逻辑（在deal.II中它们被称为 "块"）是在RelaxationBlock类中实现的。BlockJacobi "方法在RelaxationBlockJacobi类中实现。该类的许多方面（例如如何定义块以及如何反转局部子问题[2.x.48]）可以在平滑数据中配置，详见[2.x.49]和[2.x.50]。
* 到目前为止，我们讨论的是加法平滑器，其中的更新可以独立应用，并且在单一平滑器应用中没有信息流动。一个[1.x.60]解决了这个问题，其定义为
* [1.x.61]
* 与上述不同的是，对子问题[2.x.51]的更新是依次应用的。这意味着在反转子问题[2.x.52]时得到的更新立即用于[2.x.53]。这在写出项目时就可以看到。
* [1.x.62]
*
* 当把子空间[2.x.54]定义为整个自由度块时，这个方法在RelaxationBlockSOR类中实现，当你在本教程中选择 "Block SOR "时使用。RelaxationBlockSOR类也是从RelaxationBlock派生出来的。因此，加法和乘法施瓦茨方法都在一个统一的框架内实现。
* 最后，让我们注意到，标准的高斯-赛德尔（或SOR）方法可以被看作是一个乘法施瓦兹方法，每个DoF都有一个子问题。
*

*[1.x.63][1.x.64]


* 我们将考虑以下测试问题：[2.x.55]，即一个以原点为中心的半径为0.3的正方形被移除。此外，我们使用[2.x.56]、[2.x.57]、[2.x.58]和迪里切特边界值。
* [1.x.65]
*
* 以下数字描述了有（左）和无（右）流线扩散的解决方案。在没有流线扩散的情况下，我们看到边界层周围有很大的振荡，这表明标准Galerkin有限元方法对这个问题的不稳定性。
* [2.x.59]
*

* [1.x.66] [1.x.67]。
* [1.x.68] [1.x.69]。


*
*标准交易所需的典型文件.II:
*


* [1.x.70]
*
* 包括所有相关的多层次文件。
*


* [1.x.71]
*
* C++:
*


* [1.x.72]

* 我们将使用[2.x.60]功能来组装矩阵。
*


* [1.x.73]
*
* [1.x.74] [1.x.75]。


*
* 像往常一样，我们将把与这个程序有关的所有东西放入一个自己的命名空间。
*

*
* 由于我们将使用MeshWorker框架，第一步是定义以下结构，这些结构是由[2.x.61]使用的assemble_cell()函数所需要的 `ScratchData`包含一个FEValues对象，这是组装一个单元的局部贡献所需要的，而`CopyData`包含一个单元的局部贡献的输出和复制到全局系统的必要信息。它们的目的在WorkStream类的文档中也有解释）。
*


* [1.x.76]
*
* [1.x.77] [1.x.78]。



* 第二步是定义处理要从输入文件中读取的运行时参数的类。   
* 我们将使用ParameterHandler在运行时传入参数。结构`Settings`解析并存储整个程序要查询的参数。
*


* [1.x.79]
*
* [1.x.80] [1.x.81].
* 遍历单元和自由度的顺序将对乘法的收敛速度起作用。这里我们定义了一些函数，这些函数返回单元格的特定排序，供块平滑器使用。   
* 对于每种类型的单元格排序，我们定义了一个用于活动网格的函数和一个用于水平网格的函数（即用于多网格层次结构中的一个水平的单元格）。虽然求解系统所需的唯一重新排序是在水平网格上进行的，但我们在output_results()中包含了活动网格的重新排序，以达到可视化的目的。   
* 对于两个下游排序函数，我们首先创建一个包含所有相关单元的数组，然后使用一个 "比较器 "对象在下游方向进行排序。然后，函数的输出是一个简单的数组，包含了刚刚计算出的排序中的单元格的索引。
*


* [1.x.82]
*
* 产生随机排序的函数在精神上是相似的，它们首先将所有单元的信息放入一个数组。但是，它们不是对它们进行排序，而是利用C++提供的生成随机数的设施对元素进行随机洗牌。这样做的方式是在数组的所有元素上进行迭代，为之前的另一个元素抽取一个随机数，然后交换这些元素。其结果是对数组中的元素进行随机洗牌。
*


* [1.x.83]
*
* [1.x.84] [1.x.85]。


*
* 本教程中所解决的问题是对[1.x.86]第118页上的例3.1.3的改编。主要的区别是我们在域的中心增加了一个洞，其边界条件为零的Dirichlet。   
* 为了完整的描述，我们需要首先实现零右手边的类（当然，我们可以直接使用[2.x.62]）。
*


* [1.x.87]

* 我们也有迪里希特的边界条件。在外部正方形边界的连接部分，我们将数值设置为1，其他地方（包括内部圆形边界）的数值设置为0。
*


* [1.x.88]
*
* 如果 [2.x.63] ，或如果 [2.x.64] 和 [2.x.65] ，则将边界设置为 1 。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。


*
* 流水线扩散方法有一个稳定常数，我们需要能够计算出来。这个参数的计算方式的选择取自于[1.x.92]。
*


* [1.x.93]
*
* [1.x.94] [1.x.95]。


*
* 这是程序的主类，看起来应该与 [2.x.66] 非常相似。主要的区别是，由于我们是在运行时定义我们的多网格平滑器，我们选择定义一个函数`create_smoother()`和一个类对象`mg_smoother`，这是一个 [2.x.67] 派生于MGSmoother的平滑器。请注意，对于从RelaxationBlock派生的平滑器，我们必须为每个级别包括一个`smoother_data`对象。这将包含关于单元排序和单元矩阵倒置方法的信息。
*


*


* [1.x.96]
*
* [1.x.97] [1.x.98]。


*
* 在这里我们首先为活动和多网格级别的网格设置DoFHandler、AffineConstraints和SparsityPattern对象。   
* 我们可以用DoFRenumbering类对活动的DoFs进行重新编号，但是平滑器只作用于多网格层，因此，这对计算并不重要。相反，我们将对每个多网格层次上的DoFs进行重新编号。
*


* [1.x.99]
*
* 在列举了全局自由度以及（上面最后一行）水平自由度之后，让我们对水平自由度进行重新编号，以获得一个更好的平滑器，正如介绍中所解释的那样。  如果需要的话，下面的第一个区块会对下游或上游方向的每个层次的自由度进行重新编号。这只对点平滑器（SOR和Jacobi）是必要的，因为块平滑器在单元上操作（见`create_smoother()`）。下面的块也实现了随机编号。
*


* [1.x.100]
*
* 该函数的其余部分只是设置了数据结构。下面代码的最后几行与其他GMG教程不同，因为它同时设置了接口输入和输出矩阵。我们需要这样做，因为我们的问题是非对称性的。
*


* [1.x.101]
*
* [1.x.102] [1.x.103]。


*
* 这里我们定义了每个单元上的线性系统的装配，以便被下面的Mesh_loop()函数使用。这个函数为活动单元或水平单元(不管它的第一个参数是什么)装配单元矩阵，并且只有在调用活动单元时才装配右手边。
*


*


* [1.x.104]
*
* 如果我们使用流线扩散，我们必须将其贡献加入到单元矩阵和单元的右手边。如果我们不使用流线扩散，设置[2.x.68]就可以否定下面的贡献，我们就可以使用标准的Galerkin有限元组合。
*


* [1.x.105]
*
*局部矩阵的组装有两个部分。首先是Galerkin贡献。
*


* [1.x.106]

* 然后是流线扩散贡献。
*


* [1.x.107]

* 同样适用于右手边。首先是Galerkin贡献。
*


* [1.x.108]

* 然后是流线扩散贡献。
*


* [1.x.109]
*
* [1.x.110] [1.x.111]。


*
* 这里我们采用[2.x.69]来翻阅单元格，为我们组装system_matrix、system_rhs和所有mg_matrices。
*


*


* [1.x.112]
*
* 与活动层的约束不同，我们选择为每个多网格层在这个函数的本地创建约束对象，因为它们在程序的其他地方从来不需要。
*


* [1.x.113]
*
* 如果[2.x.70]是一个 "interface_out "关系对，那么[2.x.71]是一个 "interface_in "关系对。注意：对于 "interface_in"，我们加载接口条目的转置，即，dof对[2.x.72]的条目被存储在 "interface_in(i,j)"。这是对对称情况的优化，允许在solve()中设置边缘矩阵时只使用一个矩阵。然而，在这里，由于我们的问题是非对称的，我们必须同时存储`interface_in`和`interface_out`矩阵。
*


* [1.x.114]
*
* [1.x.115] [1.x.116]。


*
* 接下来，我们根据`.prm`文件中的设置来设置平滑器。两个重要的选项是多网格v周期每一级的平滑前和平滑后步骤的数量以及松弛参数。
*

*
* 因为乘法往往比加法更强大，所以需要更少的平滑步骤来看到与网格大小无关的收敛。这一点对于块平滑器和点平滑器同样适用。这反映在对每一种平滑器的平滑步数的选择上，如下所示。
*

*
* 点平滑器的松弛参数是根据试验和错误选择的，反映了在我们细化网格时保持GMRES求解的迭代次数不变（或尽可能接近）的必要值。在`.prm`文件中给 "Jacobi "和 "SOR "的两个值是针对1度和3度有限元的。如果用户想改成其他度数，他们可能需要调整这些数字。对于块平滑器，这个参数有一个更直接的解释，即对于二维的加法，一个DoF可以有多达4个单元的重复贡献，因此我们必须将这些方法放松0.25来补偿。对于乘法来说，这不是一个问题，因为每个单元的逆向应用都会给其所有的DoF带来新的信息。
*

*
* 最后，如上所述，点平滑器只对DoF进行操作，而块平滑器对单元进行操作，所以只有块平滑器需要被赋予有关单元排序的信息。点平滑器的DoF排序已经在`setup_system()`中得到了处理。
*


*


* [1.x.117]
*
* [1.x.118] [1.x.119]。


*
* 在我们解决这个系统之前，我们必须首先设置多网格预处理程序。这需要设置各级之间的转换，粗略的矩阵求解器和平滑器。这个设置几乎与[2.x.73]相同，主要区别在于上面定义的各种平滑器，以及由于我们的问题是非对称的，我们需要不同的界面边缘矩阵。实际上，在本教程中，这些接口矩阵是空的，因为我们只使用全局细化，因此没有细化边。然而，我们在这里仍然包括了这两个矩阵，因为如果我们简单地切换到自适应细化方法，程序仍然可以正常运行）。)
*

*
* 最后要注意的是，由于我们的问题是非对称性的，我们必须使用适当的Krylov子空间方法。我们在这里选择使用GMRES，因为它能保证在每次迭代中减少残差。GMRES的主要缺点是，每次迭代，存储的临时向量的数量都会增加一个，而且还需要计算与之前存储的所有向量的标量积。这是很昂贵的。通过使用重启的GMRES方法可以放松这一要求，该方法对我们在任何时候需要存储的向量数量设置了上限（这里我们在50个临时向量后重启，即48次迭代）。这样做的缺点是我们失去了在整个迭代过程中收集的信息，因此我们可以看到收敛速度较慢。因此，在哪里重启是一个平衡内存消耗、CPU工作量和收敛速度的问题。然而，本教程的目标是通过使用强大的GMG预处理程序来实现非常低的迭代次数，所以我们选择了重启长度，使下面显示的所有结果在重启发生之前就能收敛，因此我们有一个标准的GMRES方法。如果用户有兴趣，deal.II中提供的另一种合适的方法是BiCGStab。
*


*


* [1.x.120]
*
* [1.x.121] [1.x.122]。


*
* 最后感兴趣的函数产生图形输出。这里我们以.vtu格式输出解决方案和单元格排序。
*

*
* 在函数的顶部，我们为每个单元格生成一个索引，以可视化平滑器所使用的排序。请注意，我们只对活动单元而不是平滑器实际使用的层次做这个工作。对于点平滑器，我们对DoFs而不是单元进行重新编号，所以这只是对现实中发生的情况的一种近似。最后，这个随机排序并不是我们实际使用的随机排序（见`create_smoother()`）。   
* 单元的（整数）排序然后被复制到一个（浮点）矢量，用于图形输出。
*


* [1.x.123]
*
* 然后，考虑到以前的教程程序，该函数的其余部分就很简单了。
*


* [1.x.124]
*
* [1.x.125] [1.x.126]。


*
* 和大多数教程一样，这个函数创建/细化网格并调用上面定义的各种函数来设置、装配、求解和输出结果。
*

*
* 在第0个周期中，我们在正方形[2.x.74]上生成网格，以原点为中心有一个半径为3/10单位的洞。对于`manifold_id`等于1的对象（即与洞相邻的面），我们分配一个球形流形。
*


*


* [1.x.127]

* [1.x.128] [1.x.129]。



* 最后，主函数和大多数教程一样。唯一有趣的一点是，我们要求用户传递一个`.prm`文件作为唯一的命令行参数。如果没有给出参数文件，程序将在屏幕上输出一个带有所有默认值的样本参数文件的内容，然后用户可以复制并粘贴到自己的`.prm`文件中。
*


*


* [1.x.130]
* [1.x.131][1.x.132] 。


*[1.x.133][1.x.134] 。


* GMG的主要优势在于它是一种[2.x.75]方法，也就是说，问题的复杂性随着问题的大小而线性增加。为了证明本教程中介绍的线性求解器实际上是[2.x.76]，我们需要做的就是证明GMRES求解的迭代次数随着网格的细化而保持大致不变。
* 以下各表给出了GMRES的迭代次数，以减少初始残差的系数[2.x.77]。我们选择了足够数量的平滑步骤(基于该方法)来获得与网格大小无关的迭代数。从下面的表格可以看出，该方法确实是[2.x.78] 。
*[1.x.135][1.x.136] 。
*

* 逐点平滑器（"Jacobi "和 "SOR"）是按照DoF在每一层的编号顺序应用的。我们可以使用DoFRenumbering命名空间来影响这一点。块平滑器的应用是基于我们在`setup_smoother()`中设置的顺序。我们可以直观地看到这个编号。下面的图片显示了在下游、随机和上游编号中的活动单元的编号（从左到右）。
* [2.x.79]
* 让我们从加法平滑器开始。下表显示了从GMRES获得收敛所需的迭代次数。
* [2.x.80]
* 我们看到，对DoFs/单元进行重新编号对收敛速度没有影响。这是因为这些平滑器对每个DoF(点平滑器)或单元(块平滑器)进行独立计算，并将结果相加。由于我们可以将这些平滑器定义为矩阵之和的应用，而矩阵加法是交换性的，所以我们对不同组件的加法顺序不会影响最终结果。
* 另一方面，乘法平滑器的情况则不同。
* [2.x.81]
* 在这里，我们可以通过在平流方向上对DoFs/单元进行重新编号来加快收敛，同样，如果我们在相反的方向上进行重新编号，也会减慢收敛。这是因为平流主导的问题有一个信息流的方向性（平流方向），如果对DoFs/单元进行正确的重新编号，乘法就能够抓住这个方向。
* 然而，乘法的这一特点取决于[2.x.82]的值。当我们增加[2.x.83]，问题变得更加以扩散为主时，我们在网格上的信息传播更加均匀，在平流方向上的编号优势就会减弱。相反，在[2.x.84]的极端情况下（仅有平流），我们有一个一阶PDE和乘法，正确的重编号方法成为有效的求解器。正确的下游编号可能会导致只需要一次迭代的方法，因为信息可以从流入边界向下游传播，而没有相反方向的信息传输。然而，请注意，在[2.x.85]的情况下，必须对这种情况下的边界条件给予特别关注）。
*

*[1.x.137][1.x.138]。


* 我们将把结果限制在使用下游编号的运行上。下面是对[2.x.86]和[2.x.87]两个元素的所有四个平滑器的交叉比较。
* [2.x.88]
* 我们看到，对于[2.x.89]，两个乘法平滑器所需要的平滑步骤和迭代次数的组合都比两个加法平滑器小。然而，当我们将度数增加到[2.x.90]元素时，在平滑步骤和迭代次数方面，块平滑器有明显的优势。具体来说，块状SOR平滑器在度数上给出了恒定的迭代次数，而块状Jacobi平滑器的迭代次数只增加了约38%，而Jacobi和SOR则分别增加了75%和183%。
* [1.x.139][1.x.140] 。
*

* 迭代次数并不能完全说明一个单一平滑器对另一个平滑器的最优性。很明显，我们必须检查迭代的成本。块状平滑器在这里处于不利地位，因为它们必须为每个单元构建和反转一个单元矩阵。下面是一个具有74,496个DoF的[2.x.91]元素的求解时间的比较。
* [2.x.92]
* 需要最多迭代的平滑器（Jacobi）实际上花费了最短的时间（大约是下一个快速方法的2/3）。这是因为应用Jacobismo的步骤所需要的只是乘以一个对角线矩阵，这是非常快的。另一方面，虽然SOR需要比块SOR多3倍的迭代（每个迭代有3倍的平滑步骤），但时间却完全相等，这意味着块SOR的平滑步骤比SOR的平滑步骤慢9倍。最后，Jacobi块的成本比SOR块高6倍，这从每个方法的1个步骤具有相同的成本（反转单元格矩阵并将它们相加或相乘），而Jacobi块每次迭代的平滑步骤数是2倍的事实中可以直观地理解。
*

*[1.x.141][1.x.142] 。


* 还有几个重要的点需要提及。
* [2.x.93] [2.x.94] 对于平行分布的网格，乘法不能在整个领域内执行。这是因为它们一次只操作一个单元，而下游的单元只有在上游的单元完成后才能被处理。这在单个处理器上是没有问题的。处理器只是一个接一个地浏览单元的列表。然而，在并行的情况下，这意味着一些处理器处于空闲状态，因为上游处理器还没有完成对当前处理器所拥有的上游单元的工作。一旦上游处理器完成工作，下游处理器就可以开始工作，但那时上游处理器已经没有工作了。换句话说，在这些平稳的步骤中，大多数时间，大多数处理器实际上是空闲的。这不是获得良好的并行可扩展性的方法!
* 我们可以使用一种混合方法，在每个子域上应用乘法平滑器，但是当你增加子域的数量时，该方法接近于加法的行为。这是这些方法的一个主要缺点。[2.x.95]
* [2.x.96] 目前对块平滑器的研究表明，很快我们就可以计算单元矩阵的逆值，比目前在交易里面做的便宜得多。这项研究是基于快速对角线化方法（可追溯到20世纪60年代），在光谱界已经使用了20年左右（见，例如，[1.x.143]）。目前，人们正在努力将这些方法推广到DG，并使其更加强大。此外，似乎应该能够利用无矩阵的实现，以及在域的内部，单元格矩阵往往看起来非常相似的事实，允许更少的矩阵逆计算。[2.x.97] [2.x.98] *结合1.
* 结合1.和2.给出了一个很好的理由，期望类似块状雅可比的方法在未来变得非常强大，尽管目前对这些例子来说它是相当慢的。
*

*[1.x.144][1.x.145] 。


*[1.x.146][1.x.147] 。


* 改变平滑步骤的数量和平滑器松弛参数（在[2.x.99]中设置在[2.x.100]内，只对点平滑器有必要），以便我们对一个[2.x.101]元素保持恒定的迭代次数。
*[1.x.148][1.x.149]。
*

* 增加/减少乘法的`.prm`文件中的参数 "Epsilon"，观察哪些数值的重新编号不再影响收敛速度。
*[1.x.150][1.x.151]
*

* 该代码被设置为可以在自适应细化的网格中正常工作（界面矩阵被创建和设置）。设计一个合适的细化临界点或者尝试KellyErrorEstimator类。
*

*[1.x.152][1.x.153] [2.x.102]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-64_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15]
* [2.x.3]
* [1.x.16]


*[1.x.17][1.x.18]


* 这个例子展示了如何使用CUDA在GPU上实现无矩阵方法，以解决超立方体上系数可变的亥姆霍兹方程的问题。线性系统将使用共轭梯度法进行求解，并通过MPI进行并行化。
* 在过去的几年中，异构计算，特别是GPU，获得了很大的普及。这是因为在给定的功率预算下，GPU比CPU提供了更好的计算能力和内存带宽。在2019年初可用的架构中，GPU的功率效率约为服务器CPU的2-3倍，对于PDE相关的任务来说，GPU具有宽[1.x.19]。GPU也是机器学习中最受欢迎的架构。另一方面，GPU并不容易编程。这个程序探索了deal.II的能力，看看这样的程序可以如何有效地实现。
* 虽然我们试图让CPU和GPU的无矩阵类的接口尽可能接近，但还是有一些区别。当在GPU上使用无矩阵框架时，人们必须编写一些CUDA代码。然而，其数量相当少，而且CUDA的使用仅限于几个关键词。
*

*[1.x.20][1.x.21]


* 在这个例子中，我们考虑亥姆霍兹问题[1.x.22] 。
* 其中[2.x.4]是一个可变系数。
* 我们选择 [2.x.5] 和 [2.x.6] 作为域。由于系数是围绕原点对称的，但域却不是，我们最终会得到一个非对称的解决方案。
* 如果你在本教程中读到这里，你就会知道这个问题的弱式表述是怎样的，以及原则上是怎样为它组成线性系统的。当然，在这个程序中，我们实际上不会形成矩阵，而只是在与之相乘时表示其作用。
*

*[1.x.23][1.x.24]


* GPU（从现在开始我们将使用术语 "设备 "来指代GPU）有自己的内存，它与CPU（从现在开始我们将使用术语 "主机"）可访问的内存分开。设备上的正常计算可以分为三个独立的步骤。
*


*
* - 数据从主机移至设备。
*


*
* - 计算是在设备上完成的。
*


*
* - 结果从设备上移回主机上
* 数据移动可以由用户代码明确完成，也可以使用UVM（统一虚拟内存）自动完成。在deal.II中，只支持第一种方法。虽然这对用户来说意味着额外的负担，但这可以更好地控制数据移动，更重要的是可以避免在主机上而不是设备上错误地运行重要的内核。
* 在deal.II中的数据移动是通过[2.x.7]完成的，这些向量可以被看作是主机上的缓冲区，用来存储从设备接收的数据或向设备发送数据。有两种类型的向量可以在设备上使用。
*
* - [2.x.8] 类似于更常见的Vector<Number>，和
*
* - [2.x.9] [2.x.10] 这是一个普通的[2.x.11]，我们已经指定了要使用的内存空间。
* 如果没有指定内存空间，默认是[2.x.12]。
* 接下来，我们展示如何使用[2.x.13]将数据移入/移出设备。
* [1.x.25]
* 这里使用的两个向量类都只在一台机器上工作，也就是说，一个内存空间在主机上，一个在设备上。
* 但在有些情况下，人们希望在若干台机器上的多个MPI进程之间运行并行计算，而每台机器都配备有GPU。在这种情况下，人们希望使用[2.x.14]，它是类似的，但`import()`阶段可能涉及MPI通信。
* [1.x.26]
* `relevant_rw_vector`是一个存储向量的等价物子集的对象。通常，这些是[2.x.15]"本地相关的DoFs"，这意味着它们在不同的MPI进程之间是重叠的。因此，在机器上存储在该向量中的元素可能与在该机器上由GPU存储的元素不一致，需要MPI通信来导入它们。
* 在所有这些情况下，当导入一个向量时，数值可以被插入（使用[2.x.16]或添加到向量的先前内容中（使用[2.x.17] ）。
*

*[1.x.27][1.x.28]


* 设备上评估无矩阵算子所需的代码与主机上的代码非常相似。然而，也有一些区别，主要是[2.x.18]中的`local_apply()`函数和循环过正交点都需要被封装在自己的函数中。
*

* [1.x.29] [1.x.30]。
*首先包括从以前的教程中知道的deal.II库中的必要文件。
*


* [1.x.31]
*
* 以下的包括在GPU上实现无矩阵方法的数据结构。
*


* [1.x.32]
*
* 像往常一样，我们把所有的东西都包围在一个自己的命名空间中。
*


* [1.x.33]
*
* [1.x.34] [1.x.35]。


*
* 接下来，我们定义一个类，实现我们想在亥姆霍兹算子中使用的变化系数。后来，我们想把这个类型的对象传递给一个[2.x.19]对象，该对象期望该类有一个`operator()`，为给定的单元填充构造器中提供的值。这个操作符需要在设备上运行，所以需要为编译器标记为`__device__`。
*


* [1.x.36]

* 由于[2.x.20]不知道其数组的大小，我们需要在这个类中存储正交点的数量和自由度的数量，以进行必要的索引转换。
*


* [1.x.37]

* 下面的函数实现了这个系数。记得在介绍中我们曾将其定义为[2.x.21]。
*


* [1.x.38]
*
* [1.x.39] [1.x.40]。


*
* `HelmholtzOperatorQuad`类实现了对每个正交点的Helmholtz算子的评估。它使用了类似于 [2.x.22] 中介绍的 MatrixFree 框架的机制。与那里不同的是，实际的正交点索引是通过转换当前线程索引隐式处理的。和以前一样，这个类的函数需要在设备上运行，所以需要为编译器标记为`__device__`。
*


* [1.x.41]
*
* 我们在这里要解决的亥姆霍兹问题以弱的形式读取如下。[1.x.42]
* 如果你看过[2.x.23]，那么很明显，左边的两个项对应于这里的两个函数调用。
*


* [1.x.43]
*
* [1.x.44] [1.x.45]。


*
* 最后，我们需要定义一个类，实现整个运算符的评估，在基于矩阵的方法中对应于矩阵-向量乘积。
*


* [1.x.46]
*
* 同样，[2.x.24]对象不知道自由度的数量和正交点的数量，所以我们需要在调用运算符中存储这些来进行指数计算。
*


* [1.x.47]
*
* 这是一个调用运算器，在给定的单元上执行亥姆霍兹运算器的评估，类似于CPU上的MatrixFree框架。特别是，我们需要访问源向量的值和梯度，并将值和梯度信息写入目标向量。
*


* [1.x.48]
*
* [1.x.49] [1.x.50]。


*
* `HelmholtzOperator`类作为`LocalHelmholtzOperator`的包装，定义了一个可以与SolverCG等线性求解器一起使用的接口。特别是，像每一个实现线性算子接口的类一样，它需要有一个`vmult()'函数，对源向量执行线性算子的操作。
*


* [1.x.51]
*
* 下面是这个类的构造函数的实现。在第一部分，我们初始化`mf_data`成员变量，该变量将在评估运算符时为我们提供必要的信息。   
* 在后半部分，我们需要在每个活动的、本地拥有的单元中存储每个正交点的系数值。我们可以向平行三角法询问活动的、本地拥有的单元的数量，但手头只有一个DoFHandler对象。由于[2.x.25]返回的是Triangulation对象，而不是[2.x.26]对象，我们必须对返回值进行下移。在这里这样做是安全的，因为我们知道三角形实际上是一个[2.x.27]对象。
*


* [1.x.52]
*
* 那么关键的一步就是使用前面所有的类来循环所有的单元格来进行矩阵-向量的乘积。我们在下一个函数中实现这一点。   
* 在应用亥姆霍兹算子时，我们必须注意正确处理边界条件。因为本地算子不知道约束条件，所以我们必须在之后将正确的值从源头复制到目的向量。
*


* [1.x.53]
*
* [1.x.54] [1.x.55]。



* 这是本程序的主类。它定义了我们用于教程程序的通常框架。唯一值得评论的是`solve()`函数和向量类型的选择。
*


* [1.x.56]
*
* 因为`solve()`函数中的所有操作都是在显卡上执行的，所以所使用的向量也有必要在GPU上存储其值。  [2.x.28]可以被告知要使用哪个内存空间。还有[2.x.29]，总是使用GPU内存存储，但不与MPI一起工作。值得注意的是，如果MPI实现是CUDA感知的，并且配置标志`DEAL_II_MPI_WITH_CUDA_SUPPORT`被启用，不同MPI进程之间的通信可以得到改善。这个标志的值需要在安装deal.II时调用`cmake`时设置）。     
*此外，我们还保留了一个有CPU存储的解决方案向量，这样我们就可以像平常一样查看和显示解决方案。
*


* [1.x.57]
*
* 除了[2.x.30]之外，这个类的所有其余函数的实现并不包含任何新的内容，我们不会对整体的方法进一步发表过多的评论。
*


* [1.x.58]
*
* 与[2.x.31]或[2.x.32]等程序不同，我们不必组装整个线性系统，只需组装右手边的向量。这在本质上与我们在[2.x.33]中做的一样，例如，但我们必须注意在将局部贡献复制到全局向量中时使用正确的约束对象。特别是，我们需要确保对应于边界节点的条目被正确地清零了。这对于CG的收敛是必要的。  另一个解决方案是修改上面的`vmult()`函数，我们假装源向量的条目为零，在矩阵-向量乘积中不考虑它们。但这里使用的方法更简单）。)   
* 在函数的最后，我们不能直接将数值从主机复制到设备上，而是需要使用一个类型为[2.x.34]的中间对象来构建必要的正确通信模式。
*


* [1.x.59]
*
* 这个solve()函数最后包含了对之前讨论的新类的调用。这里我们不使用任何预处理程序，即通过身份矩阵预处理，只关注[2.x.35]框架的特殊性。当然，在实际应用中，选择一个合适的预处理程序是至关重要的，但我们至少有与[2.x.36]中相同的限制，因为矩阵条目是即时计算的，而不是存储的。   
* 在函数的第一部分解出线性系统后，我们将解从设备上复制到主机上，以便能够查看其值并在`output_results()`中显示。这种转移的工作方式与前一个函数的结尾相同。
*


* [1.x.60]
*
* 输出结果函数和平常一样，因为我们已经把数值从GPU复制回CPU了。   
* 当我们已经在用这个函数做事情的时候，我们不妨计算一下解决方案的[2.x.37]规范。我们通过调用[2.x.38]来做到这一点，该函数旨在通过评估数值解（由自由度值的向量给出）和代表精确解的对象之间的差异来计算误差。但是我们可以通过传入一个零函数来轻松地计算解决方案的[2.x.39]准则。也就是说，我们不是在评估误差[2.x.40]，而是在评估[2.x.41]。
*


* [1.x.61]
*
* `run()`函数中也没有什么令人惊讶的地方。我们只是在一系列（全局）细化的网格上计算出了解决方案。
*


* [1.x.62]
*
* [1.x.63] [1.x.64]。


*
* 最后是 "main() "函数。  默认情况下，所有的MPI等级将尝试访问编号为0的设备，我们假设它是与某一MPI等级运行的CPU相关的GPU设备。这是可行的，但是如果我们在运行MPI支持时，可能会有多个MPI进程在同一台机器上运行（例如，每个CPU核心一个），然后它们都想访问该机器上的同一个GPU。如果机器上只有一个GPU，我们对此无能为力。该机器上的所有MPI行列都需要共享它。但是如果有不止一个GPU，那么最好为不同的进程解决不同的显卡。下面的选择是基于MPI进程的ID，通过将GPU轮流分配给GPU行列。(为了正确地工作，这个方案假定一台机器上的MPI等级是连续的。如果不是这样的话，那么等级与GPU的关联可能就不是最佳的了）。)为了使其正常工作，在使用这个函数之前，需要对MPI进行初始化。
*


* [1.x.65]
* [1.x.66][1.x.67] 。


* 由于本教程的主要目的是演示如何使用[2.x.42]接口，而不是计算任何有用的东西本身，我们只是在这里显示预期的输出。
* [1.x.68]
*
* 人们可以在这里提出两个意见。首先，数值解的规范与精确（但未知）解的规范相对应。其次，随着网格的细化，迭代次数大约增加一倍。这与CG迭代次数随矩阵条件数的平方根增长的预期一致；而且我们知道二阶微分运算的矩阵条件数会像[2.x.43]那样增长）。这当然是相当低效的，因为一个最佳解算器的迭代次数与问题的大小是无关的。但是要有这样一个求解器，就需要使用比我们在这里使用的身份矩阵更好的预处理程序。
*

*[1.x.69][1.x.70][1.x.71]


* 目前，这个程序完全没有使用预处理程序。这主要是因为构建一个高效的无矩阵预处理程序并不困难。  然而，只需要相应矩阵的对角线的简单选择是很好的选择，这些选择也可以用无矩阵的方式来计算。另外，也许更好的是，我们可以扩展教程，使用类似于[2.x.44]的切比雪夫平滑器的多网格。
*

* [1.x.72][1.x.73] [2.x.45] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-65_0.txt
[0.x.0]*
 [2.x.0]
* 本教程取决于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21]

* [2.x.2]
* [1.x.22]
* [1.x.23][1.x.24][1.x.25] 。


* 本教程程序介绍了一个高级流形类，即TransfiniteInterpolationManifold，以及如何解决其主要缺点，即相对较高的成本。
* [1.x.26][1.x.27] 。
*

*[1.x.28][1.x.29]


* 在许多应用中，有限元网格必须能够表示相对复杂的几何形状。在[2.x.3]、[2.x.4]和[2.x.5]教程程序中，已经介绍了一些在deal.II库中生成网格的技术。给定一个基本网格，deal.II能够通过将单元格均匀地或仅在计算域的选定部分细分为子网格来创建更细的网格。除了GridGenerator命名空间中的基本网格划分功能外，deal.II还带有接口，可以通过GridIn命名空间的功能读入（仅四边形和六边形）网格生成器生成的网格，例如在[2.x.6]中演示的那样。外部生成的网格的一个基本限制是，网格中生成的单元所提供的信息只包括顶点的位置和它们的连接性，而没有最初创建这个网格的网格生成器所提供的底层几何的背景。一旦网格在deal.II中被细化，需要放置更多的点，这就成了问题。教程[2.x.7]展示了如何通过使用OpenCASCADE库的CAD曲面来克服这个限制，以及[2.x.8]通过在源代码中提供同样的信息来克服。
* 在deal.II中，网格细化过程中新点的放置或高阶映射的定义是由流形对象控制的，详见[2.x.9]中的 "流形模块"。如果我们从10个单元的初始网格开始，在不附加任何流形模块的情况下对网格进行三次全局细化，我们将得到以下网格。
* [2.x.10]
* 这幅图看起来像这样，因为在默认情况下，deal.II只知道通过平均父单元顶点的位置来放置子单元的顶点。这就产生了一个多边形域，其面是原始（粗略网格）单元的边缘。显然，我们必须在三角结构的边界面附加一个曲线描述，以便在网格细化时重现圆形，如下图所示。
* [2.x.11]
* 这就更好了。然而，这幅图中的网格对于一个环形来说仍然不是最理想的，因为从一个单元到下一个单元的[1.x.30]线在某些顶点上有扭结，所以我们更希望使用以下的网格。
* [2.x.12]
* 在这最后一种（最佳）情况下，也是由[2.x.13]产生的默认情况，弯曲流形描述（在这种情况下是极性流形描述）不仅应用于边界面，而且应用于整个域。每当三角计算要求一个新的点，例如，边缘的id点，或者当它将一个单元细化为四个子单元时，它将沿着极坐标系统中各自的中点放置它们。相比之下，在上述只有边界受制于极地流形的情况下，只有沿边界的中点会沿着曲线描述被放置，而内部的中点会通过直角坐标系中周围点的适当平均数来计算（更多细节见[2.x.14]"流形模块"）。
* 在这一点上，人们可能会认为弧形体积描述是一种方式。这一般来说是不会错的，尽管有时并不那么容易描述这到底应该如何工作。这里有几个例子。
*
* - 想象一下，上面的网格实际上是一个圆盘，而不仅仅是一个环。  在这种情况下，极地流形会在原点退化，不会产生合理的新点。事实上，为那些应该 "看起来是圆的 "但可能在原点或接近原点的东西定义流形描述是出乎意料地非常困难。
*
* - 当人们试图将球形流形附加到整个体积上时，类似的事情也会在三维球的原点发生；在这种情况下，新流形点的计算会因异常而中止。
*
* - CAD几何图形通常只描述域的边界，这与我们在上面第二幅图中只将流形附着在边界上的方式相似。同样，[2.x.15]只使用CAD几何体来生成一个表面网格（也许是因为这是解决相关问题所需要的），但如果想解决那里描述的水或船周围的空气中的问题，我们就需要有一个体积网格。那么问题来了，我们应该如何准确地描述域的内部应该发生什么。
* 这些简单的例子清楚地表明，对于许多有趣的情况，我们必须从对全体积进行分析性曲线描述的愿望中退一步。需要有[1.x.31]种信息来导致内部的曲率，但必须有可能做到这一点，而不需要实际写下一个明确的公式来描述那种几何。
* 那么，如果我们不在内部做任何事情，只把表面描述为流形，会发生什么呢？有时候，就像上面展示的环，结果并不可怕。但有时会很糟糕。考虑环状体的情况（例如用[2.x.16]生成的环状体，其表面只附加了一个环状体对象，内部单元和面没有附加流形，并且在环状体方向上有六个单元，然后再进行细化。如果网格被细化一次，我们将得到以下的网格，如图所示，网格的上半部分被剪掉了。
* [2.x.17]
* 这显然是次优的。事实上，如果我们从少于上面所示的环形方向的六个单元开始，映射实际上在某些区域发生了逆转，因为沿着内部单元放置的新点与边界相交，因为它们不是沿着环形方向的圆形。环状体的简单情况仍然可以被固定下来，因为我们知道环状体的方向是沿着圆柱坐标系的，所以将环状体的表面与圆柱体的表面结合起来，在环状体方向上有适当的周期性，应用于所有的内部实体，会产生一个高质量的网格，如下所示，现在有两个顶部单元被隐藏起来。
* [2.x.18]
* 这个网格是相当好的，但显然它与良好的体积描述有关，而我们在其他情况下缺乏这种描述。实际上，在这种情况下也有一个不完美之处，因为我们可以看到域内部的两个相邻的单元有一些不自然的扭结，这些扭结被顶部的两个边界单元所隐藏，与下面的设置相反（由[2.x.19]应用的默认流形并使用TransfiniteInterpolationManifold）。
* [2.x.20]
*[1.x.32][1.x.33]


* 为了找到一个更好的策略，让我们再看看二维圆盘（这也是沿环形方向在环形内旋转的基础实体）。正如我们上面所学到的，我们只能将弯曲的极点描述应用于边界（或离原点足够远的单元的边缘），但最终必须过渡到对盘中心的直线描述。如果我们在单元内部使用平坦流形（即新顶点是通过相邻的现有顶点的平均化而产生的），而在盘的边界使用极性流形，我们就可以在四个全局细化上得到以下网格。
* [2.x.21]
* 这并不是一个可怕的网格。同时，如果你知道最初的粗略网格是由中间的一个正方形和周围的四个盖子组成的，那么就不难看出这个网格的每一个细化步骤都是为了得到上面的图片。
* 虽然deal.II的三角化类在创建新点时试图将信息从边界传播到内部，但这种算法的影响是有限的。
* [2.x.22]
* 上图强调了磁盘上那些接触边界的单元，在这些单元中，原则上可以考虑到边界信息，当时只看了一个单元。显然，随着网格的细化，可以考虑到一些曲率的区域变得更加有限，因此在网格中产生了一些看似不规则的点。当计算最左边图片中任何一个边界单元的中心时，理想的位置是外圈和中间的单元之间的中间点。这正是三角剖分类中第一个细化步骤所使用的。然而，对于第二次细化，所有的内部边缘以及内部单元格层都只能根据平面描述来加点。
* 在这一点上，我们意识到要创建一个更好的网格需要什么。对于[1.x.34]在[1.x.35]子单元中的新点，也就是在最左边的红色阴影层中创建的新点，我们要计算相对于各自coarsecell所覆盖区域内的曲率的插值。这可以通过在上图最左边的粗略网格的高亮单元中添加TransfiniteInterpolationManifold类来实现。该类遵守一般流形接口，即在其定义域内给定任何点集，它可以计算出符合流形的加权平均数（使用的公式将在一分钟内给出）。这些加权平均数在细化网格时，或者在评估符合该流形的特定单元格的高阶映射（如MappingQGeneric或MappingC1）时使用。在圆盘粗网格的阴影单元上使用该流形（即不仅仅是最外层的单元），经过四个全局步骤的细化，产生了以下网格。
* [2.x.23]
* 这个网格的线条仍有一些扭结，但它们仅限于粗大的网格单元之间的面，而网格的其他部分则如人们所希望的那样平滑。事实上，给定一个直边的中心单元，这种表现形式是最好的，因为所有的网格单元都遵循一个平滑的过渡，从内部的方形块中的直边到边界上的圆形。(我们可以做得更好一些，在中心的方形块中也允许一些曲率，随着中心的接近，这些曲率最终会消失。)
*

*[1.x.36][1.x.37]


* 在一个有一条曲线和三条直边的圆盘的简单情况下，我们可以明确写出如何实现形状的混合。为此，将物理单元（如顶部的单元）映射回参考坐标系[2.x.24]是很有用的，我们在那里计算某些点之间的平均数。如果我们使用一个简单的由四个顶点[2.x.25]跨越的双线性地图，一个点[2.x.26]的图像将是
* [1.x.38]
*
* 对于曲面的情况，我们要修改这个公式。对于圆盘粗网格的顶部单元，我们可以假设点[2.x.27]和[2.x.28]位于下端的直线上，而点[2.x.29]和[2.x.30]则由顶部的四分之一圆连接。然后我们将点[2.x.31]映射为
* [1.x.39]
* 其中[2.x.32]是一条描述四分之一圆的[2.x.33]坐标的曲线，以一个长度参数[2.x.34]表示。这代表了单元格的直线下边缘和曲线上边缘之间的线性插值，是上图的基础。
* 这个公式很容易被推广到所有四个边缘都由曲线而不是直线描述的情况。我们称这四个函数为参数化的单一坐标[2.x.35]或[2.x.36]，在水平和垂直方向上，[2.x.37]分别代表四边形的左、右、下和上边缘。然后，内插法为
* [1.x.40]
*
* 这个公式假设边界曲线与顶点[2.x.38]相匹配和重合，例如[2.x.39]或[2.x.40]。公式第二行中的双线性插值的减法确保了边界上的规定曲线被完全遵循：沿着四条边中的每一条，我们需要减去在角上评估的两条相邻的边的贡献，这就是简单的一个顶点位置。很容易检查出，如果四条曲线[2.x.41]中的三条是直的，从而与双线性插值重合，那么上述圆的公式就会再现。
* 这个公式被称为转折插值，由[1.x.41]在1973年提出。尽管无限插值本质上只代表边界曲线的线性混合，但插值完全遵循每个实数[2.x.42]或[2.x.43]的边界曲线，也就是说，它插值的点数是无限的，这就是Gordon和Hall将这种插值的变体称为无限插值的最初动机。另一种解释是，无限插值从左右和上下线性插值，我们需要从中减去双线性插值，以确保在域的内部有一个单位重量。
* 无限插值很容易被推广到三个空间维度。在这种情况下，插值可以为一个三维单元的任何一个四边形混合6种不同的表面描述，为一个单元的线混合12种边缘描述。同样，为了确保地图的一致性，有必要减去边的贡献，再加上顶点的贡献，使曲线遵循规定的表面或边的描述。在三维的情况下，也可以使用无限插值，从一个弯曲的边缘插到相邻的面和相邻的单元。
*处理.II中的转折插值是一般意义上的插值，它可以处理任意的曲线。它将根据[2.x.44]维空间的原始坐标来评估曲线，但有一个（或两个，在三维边缘的情况下）坐标固定在[2.x.45]或[2.x.46]，以确保任何其他流形类，包括CAD文件，如果需要的话，可以应用在盒子外面。无限插值是网格生成器的标准成分，因此在deal.II库中集成这一功能的主要优势是在自适应细化和粗化网格的过程中，以及在创建更高程度的映射时，使用流形来插入网格顶点以外的额外点。
* 作为对无限插值的最后评论，我们提到在没有体积流形描述的情况下，deal.II中的网格细化策略也是基于无限插值的权重，在这个意义上是最优的。不同的是，默认算法每次只看到一个单元，因此只对那些接触到曲面流形的单元应用最优算法。相反，在整个[1.x.42]单元上使用无限映射（从一个较粗的单元开始）可以使用无限插值方法，将信息从边界传播到较远的单元。
*

*[1.x.43][1.x.44]


* 一个具有转折流形描述的网格通常分两步建立。第一步是创建一个粗略的网格（或者从文件中读入），并在一些网格实体上附加一个曲面流形。对于上面的圆盘例子，我们将极坐标流形附加到沿外圆的面（这是由[2.x.47]自动完成的）。在我们开始细化网格之前，我们再为网格的所有内部单元和边缘分配一个TransfiniteInterpolationManifold，当然，这需要基于我们分配给这些实体的一些流形ID（除了边界上的圆以外的一切）。我们是否也给圆盘的内部方块分配一个Transfinite InterpolationManifold并不重要，因为对有直边的粗单元（或3D中的平面）进行Transfinite插值，只是产生有直边（平面）的细分子。
* 稍后，当网格被细化或基于此网格建立高阶映射时，单元将查询底层流形对象的新点。这个过程需要一组周围的点，例如一个二维单元的四个顶点，以及一组对这些点的权重，以定义一个新的点。对于一个单元格的中间点，四个顶点中的每一个都会得到0.25的权重。对于无限插值模子，建立加权和的过程需要一些严肃的工作。通过构建，我们想根据周围点的参考坐标[2.x.48]和[2.x.49]（或三维的[2.x.50]）来组合这些点。然而，deal.II中流形类的界面并没有得到周围点的参考坐标（因为它们不是全球存储的），而只是物理坐标。因此，无限插值流形所要做的第一步是反转映射，并在无限插值的一个粗单元内找到参考坐标（例如，圆盘网槽的四个阴影粗网格单元之一）。这种反演是通过牛顿迭代（或者说，基于有限差分的牛顿方案与布罗伊登方法相结合）完成的，并根据上述公式多次查询转折插值。这些查询中的每一次都可能依次调用一个昂贵的流形，例如球的非球面描述，而且本身就很昂贵。由于deal.II的Manifold接口类只提供了一组点，无限插值最初甚至不知道周围的点集属于哪个粗大的网格单元，需要根据一些启发式方法在几个单元中搜索。就[1.x.45]而言，我们可以把转折插值的实施描述为基于[1.x.46]的实施。三角形初始粗网格的每个单元都代表一个有自己参考空间的图表，周围的流形提供了一种从图表空间（即参考单元）到物理空间的转换方法。粗大网格单元的图表集合是一个图集，像往常一样，当人们在图集中查找东西时，首先要做的是找到正确的图表。
* 一旦找到周围点的参考坐标，参考坐标系中的新点就会通过一个简单的加权和计算出来。最后，参考点被插入到无限插值的公式中，这就得到了所需的新点。
* 在许多情况下，曲面流形不仅在网格细化过程中使用，而且还用于确保计算域单元内的边界的曲面表示。这是保证复杂几何上高阶多项式的高阶收敛的必要条件，但有时也需要线性形状函数的精确几何。这通常是通过对单元的多项式描述来实现的，如果表示曲面网格元素的多项式程度与当时的数值解的多项式程度相同，则称为等参数概念。如果几何体的度数高于或低于解的度数，则分别称为超参数或次参数的几何体表示。在deal.II中，多项式表示的标准类是MappingQGeneric。例如，如果在三维中使用这个类的多项式度数[2.x.51]，那么总共需要125个（即[2.x.52]）点来进行内插。在这些点中，8个是单元格的顶点，已经可以从网格中获得，但其他117个点需要由网格提供。如果使用无限插值流形，我们可以想象，通过拉回某个尚未确定的粗略单元的参考坐标，然后在117个点上进行后续的前推，是大量的工作，可能非常耗时。
* 使事情变得更糟的是，许多程序的结构是这样的：映射被独立地对同一个单元进行多次查询。它的主要用途是组装线性系统，即通过FEValues对象的 "mapping "参数计算系统矩阵和右手边。然而，边界值的插值、数值误差的计算、输出的写入和误差估计器的评估也必须涉及相同的映射，以确保对解向量的一致解释。因此，即使是一次解决的线性静止问题也会多次评估映射的点。对于上面提到的三维案例，这意味着要用一种昂贵的算法多次计算每个单元的117个点。对于非线性或随时间变化的问题，情况更为紧迫，因为这些操作要反复进行。
* 由于通过无限插值的流形描述很容易比平流形上的类似查询贵几百倍，所以只计算一次额外的点并在所有后续的调用中使用它们是有意义的。deal.II库提供的MappingQCache类正是为了这个目的。与系统矩阵所消耗的内存相比，这个缓存通常不会太大，在看这个教程程序的结果时就会明白。MappingQCache的使用很简单。当网格建立好后（或在细化过程中改变），我们调用[2.x.53]，并将所需的三角测量和所需的映射作为参数。然后，初始化会遍历网格中的所有单元，并查询给定的映射的附加点。这些点会被储存在单元的标识符中，这样当映射计算一些与单元相关的量时（比如参考坐标和物理坐标之间的映射的雅克比），它们就可以被返回。
* 最后，我们提到TransfiniteInterpolationManifold也会使网格的细化更加昂贵。在这种情况下，MappingQCache并没有帮助，因为它将计算出一些随后不能再使用的点；目前在deal.II中并不存在一个更有效的机制。然而，网格细化也包含许多其他昂贵的步骤，所以与其他的计算相比，它并不是一个大问题。它也只在每个时间段或非线性迭代中最多发生一次。
* [1.x.47][1.x.48] 。
*

* 在这个教程程序中，TransfiniteInterpolationManifold与MappingQCache的结合是个例子。这个测试案例相对简单，占用了许多典型程序中的解决阶段，例如[2.x.54]的教程程序。作为一个几何体，我们选择了一个使用TransfiniteInterpolationManifold的原型，即一个涉及球形的设置，它又被一个立方体所包围。例如，这样的设置可用于嵌入背景介质中的球形包容物，如果该包容物具有不同的材料特性，需要通过元素界面来跟踪两种材料之间的界面。这里给出了网格的可视化。
* [2.x.55]
* 在这种情况下，我们要在域内的表面附加一个球形描述，并使用无限插值来平滑地切换到外部立方体的直线和球中心的立方体。
* 在程序中，我们将遵循有限元程序的典型流程，从DoFHandler和稀疏模式的设置开始，组装解决泊松方程的跳跃系数的线性系统，用简单的迭代方法解决它，用[2.x.56]计算一些数值误差以及误差估计器。我们记录了每个部分的时间，并运行了两次代码。在第一次运行中，我们将一个MappingQGeneric对象分别交给程序的每个阶段，其中的点被反复计算。在第二次运行中，我们用MappingQCache代替。
*

* [1.x.49] [1.x.50]。
* [1.x.51] [1.x.52]。
*

*
* 本教程的包含文件与 [2.x.57] 中的基本相同。重要的是，我们将使用的TransfiniteInterpolationManifold类是由`deal.II/grid/manifold_lib.h`提供。
*


*


* [1.x.53]
*
* 唯一的新include文件是MappingQCache类的文件。
*


* [1.x.54]
*
* [1.x.55] [1.x.56]。


*
* 在这个教程程序中，我们要解决泊松方程，其系数沿半径为0.5的球体跳跃，并使用一个恒定的右手边值[2.x.58] 。 这个设置与[2.x.59]和[2.x.60]类似，但系数和右手边的具体数值不同）。由于系数的跳跃，分析解必须有一个结点，即系数从一个值切换到另一个值。为了保持简单，我们选择了一个在所有分量中都是二次的分析解，即在半径为0.5的球中为[2.x.61]，在域的外部为[2.x.62]。在系数在内球中为0.5，在外球中为5的情况下，这个分析解与右手边兼容。它也是沿着半径为0.5的圆连续的。
*


* [1.x.57]
*
* [1.x.58] [1.x.59]。
* 泊松问题的实现与我们在[2.x.63]教程程序中使用的非常相似。两个主要的区别是，我们向程序中的各个步骤传递了一个映射对象，以便在两种映射表示法之间进行切换，正如介绍中所解释的那样，还有一个`计时器'对象（TimerOutput类型），将用于测量各种情况下的运行时间。(映射对象的概念在[2.x.64]和[2.x.65]中首次提出，如果你想查一下这些类的用途的话)。
*


* [1.x.60]
*
* 在构造函数中，我们设置了定时器对象来记录墙的时间，但在正常执行过程中是安静的。我们将在[2.x.66]函数中查询它的计时细节。此外，我们为使用中的有限元选择了一个相对较高的多项式三度。
*


* [1.x.61]
*
* [1.x.62] [1.x.63]。
* 接下来的函数介绍了TransfiniteInterpolationManifold的典型用法。第一步是创建所需的网格，这可以通过GridGenerator的两个网格的组合来完成。内球网格是很简单的。我们以原点为中心运行[2.x.67]，半径为0.5（第三个函数参数）。第二个网格更有趣，构造如下。我们希望有一个在内部是球形的，但在外表面是平坦的网格。此外，内球的网格拓扑结构应该与外球的网格兼容，即它们的顶点重合，这样才能使两个网格合并起来。从[2.x.68]出来的网格满足了内侧的要求，如果它是用[2.x.69]的粗大单元创建的（我们将使用3D的6个粗大单元）&ndash；这与球的边界面的单元数量相同。对于外表面，我们利用这样一个事实：没有流形附着的壳表面的6个面将退化为一个立方体的表面。我们仍然缺少的是外壳边界的半径。由于我们想要一个范围为[2.x.70]的立方体，而6单元壳将其8个外顶点放在8条对角线上，我们必须将点[2.x.71]转化为半径。显然，半径必须是[2.x.73]维度的[2.x.72]，也就是说，对于我们要考虑的三维情况，半径必须是[2.x.74]。   
* 因此，我们有一个计划。在创建了球的内部三角形和外壳的三角形之后，我们将这两个网格合并，但要从产生的三角形中删除GridGenerator中的函数可能设置的所有流形，以确保我们对流形的完全控制。特别是，我们希望在细化过程中在边界上添加的额外点能够遵循平坦的流形描述。为了开始添加更合适的流形ID的过程，我们给所有的网格实体（单元、面、线）分配流形ID 0，这些实体以后将与TransfiniteInterpolationManifold相关联。然后，我们必须识别沿着半径为0.5的球体的面和线，并给它们标记一个不同的流形ID，以便随后给这些面和线分配一个SphericalManifold。由于我们在调用[2.x.75]后丢弃了所有预先存在的流形，我们手动检查了网格的单元格和所有的面。如果四个顶点的半径都是0.5，我们就在球体上找到了一个面，或者像我们在程序中写的那样，有 [2.x.76] 。注意，我们调用`cell->face(f)->set_all_manifold_ids(1)`来设置面和周围线上的流形id。此外，我们希望通过一个材料ID来区分球内和球外的单元，以利于可视化，对应于介绍中的图片。
*


* [1.x.64]
*
* 有了所有单元格、面和线的适当标记，我们可以将流形对象附加到这些数字上。流形标识为1的实体将得到一个球形流形，而流形标识为0的其他实体将被分配到TransfiniteInterpolationManifold。正如介绍中提到的，我们必须通过调用[2.x.77]明确地将流形初始化为当前的网格，以获取粗略的网格单元和连接到这些单元边界的流形。我们还注意到，我们在这个函数中本地创建的流形对象是允许超出范围的（就像它们在函数范围结束时那样），因为Triangulation对象在内部复制它们。     
* 在连接了所有的流形之后，我们最后将去细化网格几次，以创建一个足够大的测试案例。
*


* [1.x.65]
*
* [1.x.66] [1.x.67]
* 下面的函数在其他教程中是众所周知的，它枚举了自由度，创建了一个约束对象，并为线性系统设置了一个稀疏矩阵。唯一值得一提的是，该函数接收到一个映射对象的引用，然后我们将其传递给[2.x.78]函数，以确保我们的边界值在用于装配的高阶网格上被评估。在本例中，这并不重要，因为外表面是平的，但对于弯曲的外单元，这将导致边界值的更精确的近似。
*


* [1.x.68]
*
* [1.x.69] [1.x.70].
* 组装线性系统的函数在以前的教程程序中也是众所周知的。有一点需要注意的是，我们将正交点的数量设置为多项式的度数加2，而不是像其他大多数教程中的度数加1。这是因为我们期望有一些额外的准确性，因为映射也涉及到比解的多项式多一度的程度。   
* 汇编中唯一有点不寻常的代码是我们计算单元格矩阵的方式。我们没有使用正交点索引、行和矩阵列的三个嵌套循环，而是首先收集形状函数的导数，乘以系数和积分因子`JxW`的乘积的平方根，放在一个单独的矩阵`partial_matrix`中。为了计算单元矩阵，我们在 "partial_matrix.mTmult(cell_matrix, partial_matrix); "一行中执行 "cell_matrix = partial_matrix transpose(partial_matrix)"。为了理解这一点的原因，我们知道矩阵与矩阵的乘法是对`partial_matrix`的列进行求和。如果我们用[2.x.79]表示系数，临时矩阵的条目是[2.x.80]。如果我们把[1.x.71]行与该矩阵的[1.x.72]列相乘，我们会计算一个涉及[2.x.81]的嵌套和，这正是拉普拉斯方程的双线性形式所需的条款。   
* 之所以选择这种有点不寻常的方案，是因为计算三维中相对较高的多项式程度的单元矩阵所涉及的工作很繁重。由于我们想在这个教程程序中强调映射的成本，我们最好以优化的方式进行装配，以便不追逐已经被社区解决的瓶颈问题。矩阵-矩阵乘法是HPC背景下最好的优化内核之一，[2.x.82]函数将调用到那些优化的BLAS函数。如果用户在配置deal.II时提供了一个好的BLAS库（如OpenBLAS或英特尔的MKL），那么单元矩阵的计算将执行到接近处理器的峰值算术性能。顺便提一下，尽管有优化的矩阵-矩阵乘法，但目前的策略在复杂性方面是次优的，因为要做的工作与[2.x.83]度[2.x.84]的运算成正比（这也适用于用FEValues的通常评估）。我们可以通过利用形状函数的张量积结构，用[2.x.85]的操作来计算单元格矩阵，就像交易二中的无矩阵框架那样。我们参考[2.x.86]和张量积感知评估器FEEvaluation的文档，以了解如何实现更有效的单元矩阵计算的细节。
*


* [1.x.73]
*
* [1.x.74] [1.x.75]
* 对于线性系统的求解，我们选择一个简单的雅可比条件共轭梯度求解器，类似于早期教程中的设置。
*


* [1.x.76]
*
* [1.x.77] [1.x.78]
* 在下一个函数中，我们对解决方案做了各种后处理步骤，所有这些步骤都以这样或那样的方式涉及映射。   
* 我们做的第一个操作是把解决方案以及材料ID写到VTU文件中。这与其他许多教程程序中的做法类似。这个教程程序中提出的新成分是，我们要确保写到文件中用于可视化的数据实际上是deal.II内部使用的数据的忠实代表。这是因为大多数的可视化数据格式只通过顶点坐标来表示单元，但没有办法表示弧形边界，而在deal.II中使用高阶映射时，弧形边界是用来表示的。
*
* 换句话说，你在可视化工具中看到的东西实际上不是你正在计算的东西。顺带一提，在使用高阶形状函数时也是如此。大多数可视化工具只呈现双线性/三线性的表示。这在[2.x.87]中有详细讨论。
* 所以我们需要确保高阶表示被写入文件。我们需要考虑两个特别的话题。首先，我们通过[2.x.88]告诉DataOut对象，我们打算将元素的细分解释为高阶拉格朗日多项式，而不是双线性斑块的集合。最近的可视化程序，如ParaView 5.5版或更新版，然后可以呈现高阶解决方案（更多细节见[1.x.79]）。其次，我们需要确保映射被传递给[2.x.89]方法。最后，DataOut类默认只打印[1.x.80]单元的曲面，所以我们需要确保通过映射将内部单元也打印成曲面。
*


* [1.x.81]
*
* 后处理函数的下一个操作是对照分析解计算[2.x.90]和[2.x.91]的误差。由于分析解是一个二次多项式，我们期望在这一点上得到一个非常准确的结果。如果我们是在一个具有平面面的简单网格上求解，并且系数的跳动与单元间的面对齐，那么我们会期望数值结果与分析解相吻合，直至舍去精度。然而，由于我们使用的是跟随球体的变形单元，这些单元只能由4度的多项式跟踪（比有限元的度数多一个），我们会看到在[2.x.92]附近有一个误差。我们可以通过增加多项式的度数或细化网格来获得更多的精度。
*


* [1.x.82]
*
* 我们在这里做的最后一个后处理操作是用KellyErrorEstimator计算一个误差估计。我们使用与[2.x.93]教程程序中完全相同的设置，只是我们还交出了映射，以确保误差是沿曲线元素评估的，与程序的其余部分一致。然而，我们并没有真正使用这里的结果来驱动网格适应步骤（会沿着球体细化材料界面周围的网格），因为这里的重点是这个操作的成本。
*


* [1.x.83]
*
* [1.x.84] [1.x.85]
* 最后，我们定义了`run()`函数，控制我们要如何执行这个程序（由main()函数以常规方式调用）。我们首先调用`create_grid()`函数，用适当的流形设置我们的几何体。然后我们运行两个求解器链的实例，从方程的设置开始，组装线性系统，用一个简单的迭代求解器求解，以及上面讨论的后处理。这两个实例在使用映射的方式上有所不同。第一个使用传统的MappingQGeneric映射对象，我们将其初始化为比有限元多一级的程度；毕竟，我们期望几何表示是瓶颈，因为分析解只是二次多项式。实际上，事情在相当程度上是相互关联的，因为实坐标中多项式的评估涉及到高阶多项式的映射，而高阶多项式代表一些光滑的有理函数。因此，高阶多项式还是有回报的，所以进一步增加映射的度数是没有意义的)。一旦第一遍完成，我们就让定时器打印出各个阶段的计算时间的摘要。
*


* [1.x.86]
*
* 对于第二个实例，我们转而设置了MappingQCache类。它的使用非常简单。在构建了它之后（考虑到我们希望它在其他情况下显示正确的度数功能，所以用度数），我们通过[2.x.94]函数填充缓存。在这个阶段，我们为缓存指定我们想要使用的映射（显然，为了重复同样的计算，与之前的MappingQGeneric相同），然后再次运行同样的函数，现在交出修改后的映射。最后，我们再次打印自重置以来的累计壁挂时间，看看这些时间与原来的设置相比如何。
*


* [1.x.87]
*
* [1.x.88][1.x.89] 。


*[1.x.90][1.x.91]


* 如果我们用三度的多项式运行这个程序的三维版本，我们会得到以下程序输出。
* [1.x.92]
*
* 在讨论时序之前，我们看一下MappingQCache对象的内存消耗。我们的程序显示，它使用了23MB的内存。如果我们把这个数字与单个（解或右手边）向量的内存消耗联系起来，即1.5MB（即181,609个元素乘以每条8字节的双精度），或者与系统矩阵和稀疏模式消耗的内存联系起来（274MB），我们就会发现，考虑到它的好处，它并不是一个过于沉重的数据结构。
* 关于定时器，我们看到程序的整体运行时间明显改善了2.7倍。如果我们不考虑迭代求解器，它在两种情况下都是一样的（考虑到我们使用的简单的预处理程序，以及稀疏矩阵-向量乘积对立方体多项式的操作浪费的事实，它的优势是几乎5倍。这对于一个线性静止问题来说是非常令人印象深刻的，而对于时间依赖性和非线性问题来说，成本的节省确实要突出得多，因为在这些问题上会多次调用汇编。如果我们研究一下各个组件，我们就能更清楚地了解发生了什么，以及为什么缓存会如此高效。在MappingQGeneric的情况下，基本上每个涉及映射的操作都需要至少5秒的时间。准则的计算运行了两个[2.x.95]函数，每个都要花费5秒钟的时间。(约束条件的计算比较便宜，因为它只在边界的单元格中评估映射，以便对边界条件进行插值。)如果我们将这5秒与填充MappingQC缓存所需的时间相比较，即5.2秒（对所有单元，而不仅仅是活动单元），很明显，在MappingQGeneric情况下，映射支持点的计算优先于其他一切。也许最引人注目的结果是误差估计器的时间，标记为 "计算误差估计器"，其中MappingQGeneric的实现需要17.3秒，而MappingQCache的变体不到0.5秒。前者如此昂贵的原因（例如，比装配贵三倍）是误差估计涉及到对面的数量评估，其中网格中的每个面都要求映射的额外点，这就需要通过非常昂贵的TransfiniteInterpolationManifold类。由于每个单元有六个面，这种情况比在装配中发生得更频繁。同样，MappingQCache很好地消除了重复评估，将所有涉及流形的昂贵步骤聚集在一个被重复使用的初始化调用中。
*

* [1.x.93][1.x.94] [2.x.96] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-66_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33]
* [2.x.3]
* [1.x.34]


* [1.x.35][1.x.36][1.x.37] 。


* 本教程程序的目的是演示如何在无矩阵框架内使用牛顿方法解决一个非线性问题。本教程结合了在[2.x.4]、[2.x.5]、[2.x.6]、[2.x.7]和其他文献中已经介绍的几种技术。
*

*[1.x.38][1.x.39]
*在单位圆[2.x.8]上，我们考虑以下非线性椭圆边界值问题，受制于不均匀的Dirichlet边界条件。找到一个函数[2.x.9]，使其成立。
* [1.x.40]
* 这个问题也被称为[1.x.41]，是燃烧理论问题的典型例子，例如见[2.x.10] 。
*

*[1.x.42][1.x.43] 。
* 像往常一样，我们首先推导出这个问题的弱式，即用一个光滑的测试函数[2.x.11]乘以边界条件并在域[2.x.12]上积分。分别进行积分，并将右边的项放到左边，就得到了弱式计算。找到一个函数[2.x.13]，使所有测试函数[2.x.14]都成立。
* [1.x.44]

* 选择拉格朗日有限元空间[2.x.15]，它直接包含了同质Dirichlet边界条件，我们可以定义一个基[2.x.16]，因此只需用这些基函数进行测试即可。因此离散的问题如下。找到[2.x.17]，使所有[2.x.18]都成立。
* [1.x.45]
* 由于每个有限元函数是基础函数[2.x.19]的线性组合，我们可以通过[2.x.20]的一个向量来确定有限元解决方案，该向量由每个自由度（DOF）的未知值组成。因此，我们定义非线性函数[2.x.21]代表离散非线性问题。
* 为了解决这个非线性问题，我们使用牛顿方法。因此，给定一个初始猜测[2.x.22]，它已经满足了Dirichlet边界条件，我们通过连续应用以下方案来确定一连串的牛顿步骤[2.x.23] 。
* [1.x.46]
* 因此，在每个牛顿步骤中，我们必须解决一个线性问题[2.x.24]，其中系统矩阵[2.x.25]由雅各布[2.x.26]表示，右手边[2.x.27]由负残差[2.x.28]表示。在这种情况下，解向量[2.x.29]是[2.x.30]第1个牛顿步骤的牛顿更新。请注意，我们假设初始猜测[2.x.31]已经满足了问题公式中的迪里希特边界条件（事实上这也可能是一个不均匀的迪里希特边界条件），因此牛顿更新[2.x.32]满足不均匀的迪里希特条件。
* 到目前为止，我们只测试了基函数，然而，我们也可以将[2.x.33]的任何函数表示为基函数的线性组合。更确切地说，这意味着[2.x.34]的每个元素都可以通过表示公式与向量[2.x.35]识别。[2.x.36] .因此，利用这一点我们可以给出离散雅各布和残差的表达式。
* [1.x.47]
* 与[2.x.37]相比，我们也可以形成与问题的强表述相对应的非线性函数的Frech{\'e}t导数，并在之后将其具体化。然而，最终我们会得到同样的一组离散方程。
*

* [1.x.48][1.x.49] 。
* 注意，系统矩阵，实际上是雅各布系数，是如何取决于前一个牛顿步骤的 [2.x.38] 。因此，我们需要告诉计算系统矩阵的函数关于最后一个牛顿步骤的解决方案。在经典[2.x.39]函数的实施中，我们将通过使用成员函数[2.x.40]和[2.x.41]从装配过程中的最后一个牛顿步骤中收集这一信息，然后[2.x.42]函数将看起来像。
* [1.x.50]
*
* 由于我们想在不存储矩阵的情况下解决这个问题，我们需要在使用前告诉无矩阵运算器这些信息。因此，在派生类[2.x.43]中，我们将实现一个名为[2.x.44]的函数，它将在使用矩阵-向量实现之前处理最后一个牛顿步骤的信息。此外，我们想为线性求解器使用一个几何多网格（GMG）预处理器，因此为了应用多层次算子，我们需要将最后一个牛顿步骤也传递给这些算子。这是一项棘手的任务，因为包含最后一个牛顿步骤的向量必须被内插到所有级别的三角计算中。在代码中，这项任务将由函数[2.x.45]完成。 注意，与之前我们设置和使用几何多网格预处理的情况的一个根本区别是，我们可以重复使用MGTransferMatrixFree对象来计算所有牛顿步骤。所以我们可以在这里节省一些工作，定义一个类变量，并使用已经设置好的MGTransferMatrixFree对象[2.x.46]，该对象在[2.x.47]函数中被初始化。
* [1.x.51]
*
* 评估非线性的函数与[2.x.49]中评估系数函数的函数[2.x.48]的工作方式基本相同。我们的想法是使用一个FEEvaluation对象来评估牛顿步骤，并将所有单元和所有正交点的表达式存储在一个表中。
* [1.x.52]
*
*

*[1.x.53][1.x.54]
* 正如在[2.x.50]中所说，如果我们选择高阶有限元空间，无矩阵方法会变得更有效率。由于我们想在[2.x.51]维的单位球上解决问题，最好有一个适当的边界逼近来克服收敛问题。出于这个原因，我们使用MappingQGeneric类的异参数方法来恢复平滑边界以及内单元的映射。此外，为了得到一个好的三角计算，我们使用了TransfiniteInterpolationManifold。
*

* [1.x.55] [1.x.56]。
*首先我们包括本教程所需的deal.II库的典型头文件。
*


* [1.x.57]
*
* 特别是，我们需要包括无矩阵框架的头文件。
*


* [1.x.58]
*
* 由于我们要使用几何多网格预处理程序，所以我们还需要多级头文件。
*


* [1.x.59]
*
* 最后是一些常用的C++头文件，用于输入和输出。
*


* [1.x.60]
*
* [1.x.61] [1.x.62]。


*
* 在开始时，我们定义了雅各布的无矩阵算子。作为指导，我们遵循教程[2.x.52]和[2.x.53]，其中对[2.x.54]类的精确接口做了大量的记录。   
* 由于我们希望将雅各布（Jacobian）作为系统矩阵使用，并将其传递给线性求解器以及多级预处理类，我们从[2.x.56]类派生出[2.x.55]类，这样我们就有了正确的接口。我们需要从基类中覆盖的两个函数是[2.x.57]和[2.x.58]函数。为了允许用浮动精度进行预处理，我们定义数字类型作为模板参数。   
* 正如在介绍中提到的，我们需要在最后一个牛顿步骤[2.x.60]中评估雅各布[2.x.59]，以计算牛顿更新[2.x.61]。为了获得最后一个牛顿步骤[2.x.62]的信息，我们的做法与[2.x.63]基本相同，在使用无矩阵算子之前，我们将一个系数函数的值存储在一个表中[2.x.64]。我们在这里实现的不是一个函数 [2.x.65] ，而是一个函数 [2.x.66] 。   
* 作为[2.x.67]的额外私有成员函数，我们实现了[2.x.68]和[2.x.69]函数。第一个是矩阵-向量应用的实际工作函数，我们在[2.x.71]函数中把它传递给[2.x.70]。后一个是计算对角线的工作函数，我们将其传递给[2.x.72]函数。   
* 为了提高源代码的可读性，我们进一步为FEEvaluation对象定义了一个别名。
*


* [1.x.63]

* [2.x.73]的构造函数只是调用基类[2.x.74]的构造函数，而基类本身就是由Subscriptor类派生的。
*


* [1.x.64]
*
* [2.x.75]函数重置了保存非线性值的表格，并调用基类的[2.x.76]函数。
*


* [1.x.65]
*
* [1.x.66] [1.x.67]。


*
* 下面的 [2.x.77] 函数是基于 [2.x.79] 的 [2.x.78] 函数。然而，它并不评估一个函数对象，而是评估一个代表有限元函数的向量，即雅各布系数所需的最后一个牛顿步骤。因此，我们设置了一个FEEvaluation对象，用[2.x.80]和[2.x.81]函数评估正交点的有限元函数。我们将有限元函数的评估值直接存储在[2.x.82]表中。   
* 这样做效果很好，在[2.x.83]函数中我们可以使用存储在表中的值来应用矩阵-向量乘积。然而，我们也可以在这个阶段优化雅各布系数的实现。我们可以直接评估非线性函数[2.x.84]并将这些值存储在表中。这就跳过了在每次调用[2.x.85]函数时对非线性的所有评估。
*


* [1.x.68]
*
* [1.x.69] [1.x.70]。


*
* 现在在[2.x.86]函数中，实际上实现了系统矩阵的单元格动作，我们可以使用存储在表[2.x.87]中的最后一个牛顿步骤的信息。这个函数的其余部分与 [2.x.88] 中的基本相同。我们设置FEEvaluation对象，收集并评估输入向量的值和梯度 [2.x.89] ，根据Jacobian的形式提交值和梯度，最后调用 [2.x.90] 进行单元积分，将局部贡献分配到全局向量 [2.x.91] 。
*


* [1.x.71]
*
*接下来我们使用[2.x.92]对所有单元进行实际循环，计算单元对矩阵-向量积的贡献。
*


* [1.x.72]
*
* [1.x.73] [1.x.74]。


*
* 用于计算对角线的内部工作函数 [2.x.93] 与上述工作函数 [2.x.94] 类似。然而，作为主要的区别，我们不从输入向量中读取数值，也不将任何局部结果分配给输出向量。相反，唯一的输入参数是使用的FEEvaluation对象。
*


* [1.x.75]
*
* 最后我们覆盖了[2.x.95]的基类的[2.x.96]的函数。虽然这个函数的名字表明只是计算对角线，但这个函数的作用更大一些。因为我们实际上只需要矩阵对角线元素的逆值，用于多网格预处理器的切比雪夫平滑器，我们计算对角线并存储逆值元素。因此我们首先初始化[2.x.97] 。然后我们通过将工作函数[2.x.98]传递给[2.x.99]函数来计算对角线。最后，我们在对角线上循环，用手反转这些元素。注意，在这个循环过程中，我们捕捉受限的DOFs，并手动将它们设置为1。
*


* [1.x.76]
*
* [1.x.77] [1.x.78]。


*
* 在实现了无矩阵算子之后，我们现在可以为[1.x.79]定义求解器类。这个类是基于之前所有教程程序的共同结构，特别是它是基于[2.x.100]，解决的也是一个非线性问题。由于我们使用的是无矩阵框架，所以我们不再需要assemble_system函数，相反，在每次调用[2.x.101]函数时都会重建矩阵的信息。然而，对于牛顿方案的应用，我们需要组装线性化问题的右手边并计算残差。因此，我们实现了一个额外的函数[2.x.102]，后来我们在[2.x.103]函数中调用该函数。最后，典型的[2.x.104]函数在这里实现了牛顿方法，而线性化系统的解是在函数[2.x.105]中计算的。由于MatrixFree框架将拉格朗日有限元方法的多项式程度作为模板参数来处理，我们也将其作为问题求解器类的模板参数来声明。
*


* [1.x.80]
*
* 对于并行计算，我们定义了一个 [2.x.106] 由于计算域在二维是一个圆，在三维是一个球，我们除了为边界单元分配SphericalManifold外，还为内部单元的映射分配了TransfiniteInterpolationManifold对象，它负责内部单元的映射。在这个例子中，我们使用了一个等参数的有限元方法，因此使用了MappingQGeneric类。注意，我们也可以创建一个MappingQ类的实例，并在构造器调用中设置[2.x.107]标志为[2.x.108] 。关于MappingQ和MappingQGeneric连接的进一步细节，你可以阅读这些类的详细描述。
*


* [1.x.81]
*
* 像往常一样，我们定义拉格朗日有限元FE_Q和一个DoFHandler。
*


* [1.x.82]
*
* 对于线性化离散系统，我们定义了一个AffineConstraints对象和[2.x.109]，在本例中它被表示为一个无矩阵算子。
*


* [1.x.83]
*
* 多级对象也是基于雅各布系数的无矩阵算子。由于我们需要用最后一个牛顿步骤来评估雅各布式，所以我们也需要用最后一个牛顿步骤来评估水平算子的预调节器。因此，除了[2.x.110]之外，我们还需要一个MGLevelObject来存储每一级的插值解向量。与[2.x.111]一样，我们对预处理程序使用浮点精度。此外，我们将MGTransferMatrixFree对象定义为一个类变量，因为我们只需要在三角形变化时设置一次，然后可以在每个牛顿步骤中再次使用它。
*


* [1.x.84]

* 当然，我们还需要持有 [2.x.112] , [2.x.113] 的向量。这样，我们就可以一直将上一个牛顿步骤存储在解决方案向量中，只需添加更新就可以得到下一个牛顿步骤。
*


* [1.x.85]
*
* 最后我们有一个变量用于线性求解器的迭代次数。
*


* [1.x.86]
*
* 对于与MPI并行运行的程序中的输出，我们使用ConditionalOStream类来避免不同的MPI等级对同一数据的多次输出。
*


* [1.x.87]
*
* 最后，对于时间的测量，我们使用一个TimerOutput对象，它在程序结束后将每个函数的耗时CPU和墙体时间打印在一个格式很好的表格中。
*


* [1.x.88]
*
* [2.x.114]的构造函数初始化了类的变量。特别是，我们为[2.x.115]设置了多级支持，设置映射度等于有限元度，初始化ConditionalOStream，并告诉TimerOutput我们只想在需求时看到墙体时间。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。


*
* 作为计算域，我们使用[2.x.116]-维的单位球。我们遵循TransfiniteInterpolationManifold类的说明，同时也为边界指定了一个SphericalManifold。最后，我们将初始网格细化为3
*
* - [2.x.117]次全局。
*


* [1.x.92]
*
* [1.x.93] [1.x.94]。


*
* [2.x.118]函数与[2.x.119]中的函数几乎完全相同。唯一的区别显然是只用一个[2.x.120]来测量时间，而不是单独测量每个部分，更重要的是对前一个牛顿步骤的内插解矢量进行MGLevelObject的初始化。另一个重要的变化是MGTransferMatrixFree对象的设置，我们可以在每个牛顿步骤中重复使用它，因为[2.x.121]不会被改变。   
* 请注意，我们可以两次使用同一个MatrixFree对象，用于[2.x.122]和多棱镜预处理程序。
*


* [1.x.95]
*
* [1.x.96] [1.x.97]。


*
* 接下来，我们实现了一个函数，它评估了给定输入矢量的非线性离散残差（[2.x.123]）。这个函数随后被用于组装线性化系统的右手边，随后用于计算下一个牛顿步骤的残差，以检查我们是否已经达到了误差容忍度。由于这个函数不应该影响任何类别的变量，我们把它定义为一个常数函数。在内部，我们通过FEEvaluation类和类似于[2.x.125]的[2.x.124]来利用快速有限元评估。   
*首先我们创建一个指向MatrixFree对象的指针，它被存储在 [2.x.126] 中。然后，我们将用于残差的单元评价的工作函数 [2.x.127] 以及输入和输出向量传递给 [2.x.128] 此外，我们在循环中启用输出向量的清零，这比之前单独调用<code>dst = 0.0</code>更有效率。   
* 请注意，使用这种方法，我们不必关心MPI相关的数据交换，因为所有的记账工作都由[2.x.129]完成。
*


* [1.x.98]
*
* [1.x.99] [1.x.100]。


*
* 这是用于评估残差的内部工作函数。本质上，它与 [2.x.131] 的 [2.x.130] 函数具有相同的结构，在给定的单元格 [2.x.133] 上对输入向量 [2.x.132] 进行残差评估。与上述[2.x.134]函数不同的是，我们将[2.x.135]函数分为[2.x.136]和[2.x.137]，因为输入向量可能有受限的DOF。
*


* [1.x.101]
*
* [1.x.102] [1.x.103]。


*
* 使用上述函数[2.x.138]来评估非线性残差，现在组装线性化系统的右手边变得非常容易。我们只需调用[2.x.139]函数并将结果与减一相乘。   
* 经验表明，使用FEEvaluation类比使用FEValues和co的经典实现要快很多。
*


* [1.x.104]
*
* [1.x.105] [1.x.106]。


*
* 根据[2.x.140]，下面的函数在[2.x.142]函数的帮助下计算出解的非线性残差的规范。如果我们使用牛顿方法的自适应版本，牛顿步长[2.x.143]就变得很重要。例如，我们将计算不同步长的残差并比较残差。然而，对于我们的问题来说，全牛顿步长[2.x.144]是我们能做的最好的。如果我们没有好的初始值，牛顿方法的自适应版本就变得很有趣。请注意，在理论上，牛顿方法是以二次方顺序收敛的，但只有当我们有一个合适的初始值时才会收敛。对于不合适的初始值，牛顿方法甚至在二次方程下也会发散。一个常见的方法是使用阻尼版本[2.x.145]，直到牛顿步骤足够好，可以进行完整的牛顿步骤。这在[2.x.146]中也有讨论。
*


* [1.x.107]
*
* [1.x.108] [1.x.109]。


*
* 为了在每个牛顿步骤中计算牛顿更新，我们用CG算法和几何多网格预处理器一起解决线性系统。为此，我们首先像在[2.x.147]中那样用切比雪夫平滑器设置PreconditionMG对象。
*


* [1.x.110]

* 我们记得Jacobian取决于存储在解向量中的最后一个牛顿步骤。所以我们更新牛顿步骤的鬼魂值，并将其传递给[2.x.148]来存储信息。
*


* [1.x.111]
*
* 接下来我们还要将最后一个牛顿步骤传递给多级运算符。因此，我们需要将牛顿步骤插值到三角化的所有层次。这是用[2.x.149]来完成的。
*


* [1.x.112]

* 现在我们可以设置预处理程序了。我们定义平滑器并将牛顿步骤的内插向量传递给多级运算器。
*


* [1.x.113]

* 最后我们设置了SolverControl和SolverCG来解决当前牛顿更新的线性化问题。实现SolverCG或SolverGMRES的一个重要事实是，持有线性系统解决方案的向量（这里是[2.x.150]）可以被用来传递一个起始值。为了使迭代求解器总是以零矢量开始，我们在调用[2.x.152]之前明确地重置了[2.x.151]，然后我们分配了存储在[2.x.153]中的Dirichlet边界条件，并为以后的输出存储了迭代步数。
*


* [1.x.114]
*
* 然后为了记账，我们把鬼魂的值清零。
*


* [1.x.115]
*
* [1.x.116] [1.x.117]。


*
* 现在我们为非线性问题实现实际的牛顿求解器。
*


* [1.x.118]
*
* 我们定义了牛顿步骤的最大数量和收敛标准的容忍度。通常，在良好的起始值下，牛顿方法在三到六步内收敛，所以最大的十步应该是完全足够的。作为公差，我们使用[2.x.154]作为残差的规范，[2.x.155]作为牛顿更新的规范。这似乎有点过头了，但我们将看到，对于我们的例子，我们将在几步之后达到这些公差。
*


* [1.x.119]

* 现在我们开始进行实际的牛顿迭代。
*


* [1.x.120]
*
* 我们将线性化问题的右侧集合起来，计算牛顿更新。
*


* [1.x.121]
*
* 然后我们计算误差，即牛顿更新的规范和残差。请注意，在这一点上，我们可以通过改变compute_residual函数的输入参数[2.x.156]来加入牛顿方法的步长控制。然而，在这里我们只是使用[2.x.157]等于1来进行普通的牛顿迭代。
*


* [1.x.122]
*
* 接下来我们通过将牛顿更新添加到当前的牛顿步骤中来推进牛顿步骤。
*


* [1.x.123]

* 一个简短的输出将告知我们当前的牛顿步骤。
*


* [1.x.124]
*
* 在每个牛顿步骤之后，我们检查收敛标准。如果其中至少有一个得到满足，我们就完成了，并结束循环。如果我们在牛顿迭代的最大数量之后还没有找到一个满意的解决方案，我们就会通知用户这个缺点。
*


* [1.x.125]
*
* [1.x.126] [1.x.127]。


*
* 解决方案的H1-seminorm的计算可以用与[2.x.158]相同的方式进行。我们更新鬼魂值并使用函数 [2.x.159] 最后我们收集所有MPI等级的所有计算并返回规范。
*


* [1.x.128]
*
* [1.x.129] [1.x.130]。


*
* 我们通过调用[2.x.160]函数，以与[2.x.161]中相同的方式，一次性生成vtu格式的图形输出文件和pvtu主文件。此外，与 [2.x.162] 一样，我们查询每个单元的 [2.x.163] 并将三角形在MPI行列中的分布写进输出文件。最后，我们通过调用[2.x.164]生成解决方案的补丁。然而，由于我们有一个边界弯曲的计算域，我们另外传递[2.x.165]和有限元度作为细分的数量。但这仍然不足以正确表示解决方案，例如在ParaView中，因为我们将TransfiniteInterpolationManifold附加到内部单元上，这导致内部的单元是弯曲的。因此，我们将[2.x.166]选项作为第三个参数，这样内部单元也使用相应的流形描述来构建补丁。   
* 请注意，我们可以用标志[2.x.167]来处理高阶元素，但是由于对ParaView以前版本的兼容性有限，而且VisIt的支持缺失，我们把这个选项留给了未来的版本。
*


* [1.x.131]
*
* [1.x.132] [1.x.133]。


*
* [1.x.134]的求解器类的最后一个缺失的函数是运行函数。在开始的时候，我们打印关于系统规格和我们使用的有限元空间的信息。该问题在一个连续细化的网格上被解决了几次。
*


* [1.x.135]
*
* 实际解决问题的第一项任务是生成或完善三角图。
*


* [1.x.136]

* 现在我们建立了系统并解决了问题。这些步骤都伴随着时间测量和文本输出。
*


* [1.x.137]
*
* 在问题被解决后，我们计算出解决方案的法线，并生成图形输出文件。
*


* [1.x.138]
*
* 最后在每个周期后，我们打印计时信息。
*


* [1.x.139]
*
* [1.x.140] [1.x.141]。


*
* 作为使用MPI并行运行的典型程序，我们设置了MPI框架，并通过将线程数限制为1来禁用共享内存并行化。最后，为了运行[1.x.142]的求解器，我们创建一个[2.x.168]类的对象并调用运行函数。举例来说，我们用四阶拉格朗日有限元在二维和三维中各解一次问题。
*


* [1.x.143]
* [1.x.144][1.x.145] 。


*本教程步骤的目的是演示用无矩阵框架解决一个非线性PDE。
*


*[1.x.146][1.x.147]
* 通过释放模式在两个进程上运行程序
* [1.x.148]
* 在控制台给出以下输出
* [1.x.149]
*
* 我们在下图中显示了二维和三维问题的解决方案。
* [2.x.169]



* [1.x.150][1.x.151] 。
* 在上面的程序输出中，我们发现一些关于牛顿迭代的有趣信息。每个细化周期的终端输出显示了牛顿方法的详细诊断，首先显示了牛顿步骤的数量，以及每一步的残差[2.x.170]，牛顿更新的规范[2.x.171]，和CG迭代的数量[2.x.172]。
* 我们观察到，在所有情况下，牛顿方法大约在三到四步内收敛，这表明牛顿方法在全步长下的二次收敛 [2.x.173] 。通常，如果你没有一个合适的初始猜测，你可以尝试减少步长的几个阻尼牛顿步骤[2.x.175]，直到牛顿步骤再次进入二次收敛域。这种阻尼和放松牛顿步长的做法确实需要更复杂的牛顿方法的实现，我们将其指定为本教程的一个可能的扩展。
* 此外，我们看到，随着网格的不断细化和DoF数量的增加，CG的迭代次数大致不变。这当然是由于几何多网格预处理的缘故，而且与其他使用这种方法的教程中的观察结果相似，例如 [2.x.176] 和 [2.x.177] 。仅举一例，在三维案例中，经过五次修正后，我们有大约1470万个分布式DoFs和四阶拉格朗日有限元，但CG迭代的次数仍然少于10次。
* 此外，我们还应用了一个非常有用的优化，在此应该提及。在[2.x.178]函数中，我们在将牛顿更新的矢量作为输出矢量传递给求解器之前，明确地重置了该矢量。在这种情况下，我们为CG方法使用了一个零的起始值，这比之前的牛顿更新更合适，[2.x.179]的实际内容在重置之前，因此减少了几步CG迭代的次数。
*


* [1.x.152][1.x.153] 。
* 有几个可能的扩展是关于目前代码的小更新，以及对格尔凡德问题进行更深入的数值研究。
* [1.x.154][1.x.155]
* 除了在[2.x.180]中已经提到的牛顿迭代的步长控制版本外，我们还可以为牛顿迭代实现一个更灵活的停止准则。例如，我们可以取代对残差的固定公差[2.x.181]，实现一个具有给定绝对和相对公差的混合误差控制，这样牛顿迭代就可以成功存在，例如。
* [1.x.156]
* 对于有许多非线性系统需要解决的更高级的应用，例如，在时间依赖性问题的每个时间步长，事实证明，没有必要在每一个牛顿步长甚至每个时间步长重新设置和组装雅各布系数。相反，在牛顿迭代中可以使用前一个步骤中的现有Jacobian。只有在牛顿迭代收敛过慢的情况下，才会重新建立雅各布式，例如，牛顿迭代。这样的想法产生了一个[1.x.157]。诚然，当使用无矩阵框架时，无论如何都会省略雅各布矩阵的组装，但通过这种方式，我们可以尝试优化几何多网格预处理的重新组装。请记住，每次来自旧牛顿步骤的解决方案都必须分布到所有层面，并且必须重新初始化多重网格预处理程序。
* [1.x.158][1.x.159] 。
* 在[2.x.182]和其他文章的结果部分，无矩阵框架在大量处理器上的并行可扩展性已经得到了非常令人印象深刻的证明。在我们这里考虑的非线性情况下，我们注意到瓶颈之一可能成为无矩阵雅可比算子及其多阶段算子在前一个牛顿步骤中的转移和评估，因为我们需要在每个步骤中的所有阶段转移旧的解决方案。[2.x.183]中的首次并行可扩展性分析显示，当问题规模足够大时，可扩展性非常好。然而，为了得到可靠的结果，还需要进行更详细的分析。此外，到目前为止，这个问题只用MPI解决，没有使用线程的共享内存并行化的可能性。因此，对于这个例子，你可以尝试使用MPI和线程的混合并行化，如[2.x.184]中所述。
* [1.x.160][1.x.161] 。
* 类似于[2.x.185]和提到的[2.x.186]的可能扩展，你可以说服自己哪个方法更快。
* [1.x.162][1.x.163] 。
* 我们可以考虑相应的特征值问题，也就是所谓的Bratuproblem。例如，如果我们定义一个固定的特征值[2.x.187]，我们可以计算出相应的离散特征函数。你会注意到，随着[2.x.188]的增加，牛顿步骤的数量也会增加。为了减少牛顿步数，你可以使用以下技巧：从某个[2.x.189]开始，计算特征函数，增加[2.x.190]，然后使用之前的解作为牛顿迭代的初始猜测。最后你可以在特征值[2.x.192]上绘制出[2.x.191]-norm。如果进一步增加[2.x.193]，你会观察到什么？
*

* [1.x.164][1.x.165] [2.x.194] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-67_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] , [2.x.3] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28]
*
* [2.x.4]
* [1.x.29]
* [1.x.30][1.x.31][1.x.32] 。


* 本教程程序使用显式时间积分器求解流体力学的欧拉方程，采用无矩阵框架，适用于空间的高阶非连续Galerkin离散化。关于欧拉系统的细节和另一种隐式方法，我们也参考了[2.x.5]的教程程序。你可能还想看看[2.x.6]中解决这些方程的其他方法。
*

*[1.x.33][1.x.34]


* 欧拉方程是一个守恒定律，描述了可压缩无iscid气体的运动，[1.x.35]其中解矢量的[2.x.7]分量为[2.x.8] 。这里，[2.x.9]表示流体密度，[2.x.10]表示流体速度，[2.x.11]表示气体的能量密度。速度不是直接求出的，而是变量[2.x.12]，即线性动量（因为它是保留量）。
* 欧拉通量函数，一个[2.x.13]矩阵，定义为[1.x.36]，其中[2.x.14]是[2.x.15]的身份矩阵，[2.x.16]是外积；其组成部分分别表示质量、动量和能量通量。右面的强制由[1.x.37]给出，其中矢量[2.x.17]表示重力方向和大小。然而，它也可以表示作用于流体的任何其他单位质量的外力。例如，想想外部电场对带电粒子所施加的静电力）。
* 这三组方程，第二组涉及[2.x.18]成分，描述了质量、动量和能量的守恒。压力不是决议变量，但需要通过其他变量的 "闭合关系 "来表达；我们在此选择适合由两个原子组成的分子的气体的关系，在中等温度下，由[2.x.19]和常数[2.x.20]给出。
*

*[1.x.38][1.x.39]


* 对于空间离散化，我们使用高阶不连续Galerkin（DG）离散化，使用形式为[1.x.40]的解扩展，这里，[2.x.21]表示[2.x.22]的基函数，以矢量形式写出不同成分的单独形状函数，并让[2.x.23]分别通过密度、动量和能量变量。在这种形式下，空间依赖性包含在形状函数中，时间依赖性包含在未知系数中 [2.x.24] 。与连续有限元方法中一些形状函数跨越元素边界的情况不同，在DG方法中，形状函数是单个元素的局部，从一个元素到下一个元素是不连续的。从一个单元到其相邻单元的解的连接是由下面规定的数值通量来实现的。这允许一些额外的灵活性，例如，在数值方法中引入方向性，例如，上卷。
* DG方法是解决传输特性问题的流行方法，因为它们结合了低分散误差和可控的耗散，在极少解决的尺度上。这使得它们在流体动力学领域的模拟中特别有吸引力，因为在这个领域中，需要代表广泛的活动尺度，而不充分解决的特征很容易干扰重要的良好解决的特征。此外，高阶DG方法非常适用于现代硬件的正确实施。同时，DG方法也不是银弹。特别是当解出现不连续（冲击）时，如欧拉方程在某些流动状态下的典型情况，高阶DG方法往往会出现振荡解，就像不使用通量或坡度限制器的所有高阶方法一样。这是[1.x.41]的结果，即任何线性的总变差（TVD）方案（如基本的DG离散化）最多能达到一阶精度。换句话说，由于DG方法的目标是高阶精度，它们不能对产生冲击的解进行TVD。尽管有些人声称DG方法中的数值通量可以控制耗散，但这一点价值有限，除非[1.x.42]问题中的冲击与单元边界一致。任何穿过单元内部的冲击都会因为高阶多项式而再次产生震荡成分。在有限元和DG领域，存在许多不同的方法来处理冲击，例如在有问题的单元上引入人工扩散（使用基于解的模态分解的有问题单元指标），在子网格上转换为耗散性低阶有限体积方法，或者增加一些限制程序。考虑到这种情况下的充分可能性，再加上相当大的实施难度，我们在此不讨论带有明显冲击的欧拉方程体系，而是集中讨论带有波状现象的亚声速流动体系。对于一个能很好地处理冲击的方法（但每个未知数的成本更高），我们参考了[2.x.25]的教程程序。
* 对于DG公式的推导，我们将欧拉方程与测试函数[2.x.26]相乘，并在单个单元上进行积分[2.x.27]，从而得到[1.x.43] 。
* 然后我们对第二项进行分项积分，将分歧从解槽移到测试函数槽，并产生元素边界上的积分：[1.x.44]在表面积分中，我们将项[2.x.28]替换为项[2.x.29]，数值通量。数值通量的作用是连接相邻元素上的解，并弱化了解的连续性。这保证了PDE的全局耦合反映在离散化上，尽管单元上有独立的基函数。通过将数值通量定义为来自内部面两侧的解的函数[2.x.30]和[2.x.32]，包括与邻居的连接性。我们要求的一个基本属性是，数值通量需要是[1.x.45]。也就是说，我们希望所有的信息（即质量、动量和能量）在一个面上离开一个单元时，都能完整地进入邻近的单元，反之亦然。这可以表示为[2.x.33]，也就是说，数值通量从任何一边都评估为相同的结果。结合数值通量乘以所考虑的表面上的单位外法向量的事实，该法向量从两边指向相反的方向，我们看到守恒被满足了。数值通量的另一个观点是作为一个单值的中间状态，从两边微弱地联系着解决方案。
* 有大量的数值通量函数可用，也称为Riemann求解器。对于欧拉方程，存在所谓的精确黎曼求解器
*
* 意味着来自两边的状态以符合欧拉方程的方式沿着不连续点结合起来
*
* 以及近似黎曼求解器，它违反了一些物理特性，并依靠其他机制来使方案总体上准确。近似黎曼求解器的优点是计算成本较低。大多数通量函数都起源于有限体积界，它们类似于单元（称为体积）内的多项式0度的DG方法。由于Euler算子的体积积分[2.x.34]对于恒定的解和检验函数会消失，所以数值通量必须完全代表物理算子，这也解释了为什么在该社区有大量的研究。对于DG方法，一致性是由单元内的高阶多项式保证的，这使得数值通量不再是一个问题，通常只影响收敛率，例如，对于度数为[2.x.39]的多项式，解是否转化为[2.x.35]、[2.x.36]或者[2.x.37]的准则。因此，数值流可以被看作是一种机制，用来选择更有利的耗散/分散特性，或者关于被分解和线性化的算子的极值特征，这影响到显式时间积分器中最大的可接受的时间步长。
* 在这个教程程序中，我们实现了两种通量的变体，可以通过程序中的开关来控制（当然，通过输入文件来控制它们的运行时间参数也很容易）。第一个通量是本地的Lax--Friedrichs通量[1.x.46] 。
* 在Lax--Friedrichs通量的原始定义中，使用了一个系数[2.x.40]（对应于信息在界面两边移动的最大速度），说明两个状态之间的差异，[2.x.41]被欧拉通量的最大特征值惩罚，即[2.x.42]，其中[2.x.43]是音速。在下面的实现中，我们对惩罚项进行了一些修改，因为无论如何惩罚都是近似的。我们使用
* [1.x.47]
* 额外的因子[2.x.44]降低了惩罚强度（这导致特征值的负实数部分减少，从而增加了允许的时间步长）。这种简化导致参数[2.x.45]的减少最多为2倍，因为[2.x.46]，最后一个不等式来自于杨氏不等式。
* 第二个数值通量是由Harten, Lax和van Leer提出的，称为HLL通量。它考虑到Eulerequations的不同传播方向，取决于声速。它利用一些中间状态 [2.x.47] 和 [2.x.48] 来定义两个分支 [2.x.49] 和 [2.x.50] 。关于中间状态[2.x.51]和[2.x.52]的定义，已经提出了几个变种。最初提出的变体采用密度平均的速度定义[2.x.53]。由于我们考虑的是没有冲击的欧拉方程，因此我们在本教程中简单地使用算术手段，[2.x.54]和[2.x.55]，以及[2.x.56]，而将其他变体留给可能的扩展。我们还注意到，HLL通量在文献中被扩展为所谓的HLLC通量，其中C代表表示接触不连续的能力。
* 在没有邻接状态[2.x.57]的边界，从边界条件中推导出合适的外部值是很常见的做法（详见关于DG方法的一般文献）。在本教程中，我们考虑了三种类型的边界条件，即[1.x.49]，其中所有成分都是规定的；[1.x.50][1.x.51]，其中我们不规定外部解，因为流场正在离开域，而是使用内部值；我们仍然需要规定能量，因为欧拉通量中还有一个传入特征；[1.x.52]和[1.x.53]，描述了一个无穿透配置：[1.x.54]
*解的多项式展开最后被插入到弱形式中，测试函数被基础函数所取代。这就得到了一个空间上离散、时间上连续的非线性系统，该系统具有有限数量的不可知系数 [2.x.58] , [2.x.59] 。关于DG方法中多项式度数的选择，截至2019年，文献中并没有就何种多项式度数最有效达成共识，这个决定取决于问题的性质。高阶多项式可以确保更好的收敛率，因此对[1.x.55]解的中高精确度要求来说是比较好的。同时，自由度所在的体积与表面之比随着高阶而增加，这使得数值通量的影响变弱，通常会减少耗散。然而，在大多数情况下，解决方案是不平滑的，至少与可以承受的分辨率相比是不平滑的。例如，在不可压缩流体力学、可压缩流体力学以及与之相关的波传播课题中就是如此。在这个前渐进制度中，误差大约与数值分辨率成正比，而其他因素，如分散误差或耗散行为变得更加重要。非常高阶的方法往往被排除在外，因为它们有更多的限制性CFL条件，与未知数的数量相比，它们在表示复杂几何形状时也不那么灵活。因此，在实践中，2到6之间的多项式度数是最受欢迎的，例如，见[2.x.60]中的效率评估和其中引用的参考文献。
*[1.x.56][1.x.57]
*

* 为了在时间上进行离散，我们略微重新排列弱的形式，并在所有单元上求和：[1.x.58]其中[2.x.61]贯穿所有基础函数，从1到[2.x.62] 。
* 我们现在用[2.x.63]表示质量矩阵的条目[2.x.64]，用[1.x.59]表示评价欧拉算子右边的算子，给定一个与全局未知数矢量和使用中的有限元相关的函数[2.x.65]。这个函数[2.x.66]是明确地随时间变化的，因为在边界上评估的数值通量将涉及边界上某些部分的随时间变化的数据[2.x.67]、[2.x.68]和[2.x.69]，这取决于边界条件的分配情况。有了这个符号，我们可以把空间上的离散、时间上的连续系统紧凑地写成[1.x.60]，其中我们还冒昧地用[2.x.70]表示全局解向量（除了相应的有限元函数之外）。等价地，上述系统的形式为[1.x.61] 。
* 对于用高阶非连续Galerkinmethods离散的双曲系统，该系统的显式时间积分非常流行。这是因为质量矩阵[2.x.71]是块对角线（每个块只对应于定义在同一单元上的同类变量），因此很容易倒置。在每个时间步骤中
*
* - 或Runge--Kutta方案的阶段
*
* 只需要使用给定的数据评估一次微分算子，然后应用质量矩阵的逆向。另一方面，对于隐式时间步进，人们首先要对方程进行线性化，然后迭代解决线性系统，这涉及到几个残差评估和至少十几个线性化算子的应用，正如在[2.x.72]教程程序中所证明的那样。
* 当然，显式时间步进的简单性是有代价的，即所谓的Courant-Friedrichs-Lewy（CFL）条件带来的条件稳定性。它规定时间步长不能大于离散化微分算子的最快信息传播速度。用更现代的术语来说，传播速度对应于离散算子的最大特征值，反过来又取决于网格大小、多项式程度[2.x.73]和欧拉算子的物理特性，即[2.x.74]相对于[2.x.75]的线性化的特征值。在这个程序中，我们将时间步长设定为：[1.x.62] 。
*在所有正交点和所有单元中取最大值。无维数[2.x.76]表示Courant数，可以选择最大稳定数[2.x.77]，其值取决于所选择的时间步长方法及其稳定性。用于多项式缩放的功率[2.x.78]是启发式的，代表最接近1到8的多项式度数，例如，见[2.x.79] 。在更高的度数限制下，[2.x.80]，[2.x.81]的比例更准确，与通常用于内部惩罚方法的逆向估计有关。关于公式中使用的[1.x.63]网格尺寸[2.x.82]和[2.x.83]，我们注意到，对流传输是有方向性的。因此，一个合适的比例是使用速度方向上的元素长度[2.x.84]。下面的代码从参考单元到实际单元的Jacobian的倒数推导出这个比例，也就是说，我们接近[2.x.85] 。相反，声波具有各向同性的特点，这就是为什么我们使用最小的特征尺寸，由[2.x.86]的最小奇异值代表，用于声学缩放 [2.x.87] 。最后，我们需要添加对流和声学限制，因为欧拉方程可以以速度传输信息 [2.x.88] 。
* 在这个教程程序中，我们使用了[1.x.64]的一个具体变体，一般来说，它使用以下更新程序，从时间[2.x.90]的状态[2.x.89]到新时间[2.x.91]的[2.x.92]：[1.x.65]在[2.x.95]阶段方案中，向量[2.x.93]、[2.x.94]是对算子在某个中间状态的评价，用于通过某种线性组合来定义步骤结束值[2.x.96]。这个方案中的标量系数[2.x.97]、[2.x.98]和[2.x.99]是这样定义的，即满足高阶方案的某些条件，最基本的就是[2.x.100]。参数通常以所谓的[1.x.66]的形式收集，该参数收集了定义该方案的所有系数。对于一个五阶段方案，它看起来像这样：[1.x.67] 。
* 在本教程中，我们使用了显式Runge--Kutta方法的一个子集，即所谓的低存储Runge--Kutta方法（LSRK），它假定了系数的额外结构。在参考文献[2.x.101]使用的变体中，假设使用Butcher tableaus ofthe form[1.x.68]，有了这样的定义，对[2.x.102]的更新共享存储与中间值的信息[2.x.103]。从[2.x.104]和[2.x.105]开始，每个[2.x.106]阶段的更新简化为[1.x.69]除了被连续更新的向量[2.x.107]，这个方案只需要两个辅助向量，即保存微分算子评价的向量[2.x.108]，以及保存微分算子应用的右手边的向量[2.x.109]。在随后的阶段[2.x.110]中，值[2.x.111]和[2.x.112]可以使用相同的存储。
* 低存储量变体的主要优点是一方面减少了内存消耗（如果必须在内存中容纳非常多的未知数，持有所有的[2.x.113]来计算后续的更新，对于[2.x.114]来说已经是一个极限，在5到8之间
*
*-记得我们使用的是显式方案，所以我们不需要存储任何通常比几个向量大得多的矩阵），而另一个是减少的内存访问。在这个程序中，我们对后一个方面特别感兴趣。由于运算符评估的成本只是使用交易二中的优化的无矩阵方法从内存中流出输入和输出向量的一小部分，我们必须考虑向量更新的成本，低存储量的变体可以提供两倍于传统的显式Runge--Kutta方法的吞吐量，因为这个原因，例如，见[2.x.115]中的分析。
* 除了参考文献[2.x.116]中的三阶、四阶和五阶精度的三种变体外，我们还使用了[2.x.117]中针对声学设置优化的七阶精度变体。声学问题是欧拉方程亚声速体系的有趣方面之一，其中可压缩性导致了声波的传递；通常，人们使用围绕背景状态的线性化欧拉方程或围绕固定框架的声波方程的进一步简化。
*

*[1.x.70][1.x.71]


* 本程序中使用的主要成分是我们用来评估算子[2.x.118]和反质量矩阵[2.x.119]的快速无矩阵技术。实际上，[1.x.72]这个术语有点名不副实，因为我们是在处理一个非线性算子，而不是将这个算子线性化，而这个算子又可以用矩阵表示。然而，正如[2.x.120]和[2.x.121]中所显示的，积分的法估值已成为流行的疏散矩阵-向量乘积的替代方法，我们在交易二中创造了这个基础设施[1.x.73]，就是出于这个原因。此外，反质量矩阵确实是以无矩阵方式应用的，详见下文。
* 无矩阵基础设施使我们能够快速评估弱形式的积分。其成分是将解系数快速插值为正交点的值和导数，在正交点上进行点对点运算（在这里我们实现了上述的微分算子），以及与所有测试函数相乘并在正交点上进行求和。第一和第三部分使用了和因子化，并在[2.x.122]教程中对单元积分和[2.x.123]对面积分进行了广泛的讨论。唯一不同的是，我们现在处理的是一个[2.x.124]分量系统，而不是以前教程程序中的标量系统。在代码中，所有的变化是FEEvaluation和FEFaceEvaluation类的一个模板参数，即设置分量的数量。对向量的访问和以前一样，都由评价器透明地处理。我们还注意到，下面的代码中选择的带有单个评价器的变体并不是唯一的选择
*
* 我们也可以为独立的组件[2.x.125]、[2.x.126]和[2.x.127]使用单独的评估器；考虑到我们对所有组件的处理是相似的（也反映在我们将方程陈述为一个向量系统的方式上），这在这里会更复杂。和以前一样，FEEvaluation类通过结合对几个单元（和面）的操作提供了显式的矢量化，涉及的数据类型称为矢量数组。由于这种类型的算术运算是重载的，所以我们不必太在意它，除了通过函数接口对函数进行评估，我们需要同时为几个正交点的位置提供特定的[1.x.74]评估。
* 本程序中更大的变化是在正交点的操作。在这里，多分量评估器为我们提供了以前没有讨论过的返回类型。当[2.x.128]为[2.x.129]的拉普拉斯返回一个标量（更准确地说，是一个矢量数组类型，因为跨单元的矢量化）时，它现在返回的类型是`张量<1,dim+2,矢量数组<Number>'。同样，梯度类型现在是`张量<1,dim+2,张量<1,dim,矢量化数组<Number>>`，其中外张量收集欧拉系统的`dim+2`分量，内张量收集不同方向的偏导数。例如，欧拉系统的flux[2.x.130]就属于这种类型。为了减少我们为拼写这些类型而写的代码量，我们尽可能使用C++的 "自动 "关键字。
* 从实现的角度来看，非线性并不是一个很大的困难。它是在我们表达欧拉弱形式的条款时自然引入的，例如以动量条款的形式 [2.x.131] 。为了得到这个表达式，我们首先从动量变量[2.x.133]推导出速度[2.x.132]。鉴于[2.x.134]和[2.x.136]一样，被表示为[2.x.135]度的多项式，速度[2.x.137]是参考坐标[2.x.138]的一个有理表达。当我们进行乘法[2.x.139]时，我们得到一个表达式，它是两个多项式的比值，多项式的度数[2.x.140]在总分母中，多项式的度数[2.x.141]在分母中。结合测试函数的梯度，对于仿生单元，即平行四边形/平行四边形，积分项在umerator中为[2.x.142]，在分母中为[2.x.143]。在这一点上，我们通常需要放弃对精确积分的坚持，而采取高斯（更确切地说，高斯-勒格朗德）正交所提供的任何精度。这种情况与拉普拉斯方程的情况类似，在这种情况下，积分项包含非王子单元上的有理表达式，而且也只是近似积分。由于这些公式都是对多项式进行精确积分，所以我们必须以积分误差的形式来处理[1.x.75]的问题。
* 虽然不准确的积分对椭圆问题来说通常是可以容忍的，但对双曲问题来说，不准确的积分会引起一些令人头痛的影响，这种影响称为[1.x.76]。这个术语来自于信号处理，表达了不适当的、过于粗糙的采样情况。就正交而言，不适当的采样意味着我们使用的正交点比准确采样可变系数积分所需的正交点要少。在DG文献中已经表明，对于[1.x.77]解析的模拟，混叠误差会在数值解析中引入非物理性的振荡。事实上，混叠主要影响的是粗略的分辨率。
*
* - 而更细的网格在相同的方案下却很好。
*
* 这并不奇怪，因为分辨率高的模拟往往在单元的长度尺度上是平滑的（即它们在较高的多项式度数上有很小的系数，被太少的正交点所遗漏，而在较低的多项式度数上的主要解贡献仍然被很好地捕捉到了
*
* 这只是泰勒定理的一个结果）。)为了解决这个问题，DG文献中提出了各种方法。一种技术是过滤，它可以抑制与较高多项式度数有关的解成分。由于所选择的节点基不是分级的，这就意味着要从节点基转化为分级基（例如，基于Legendre多项式的模态基），其中单元内的分量按多项式程度划分。在这个基础上，我们可以将与高度数相关的求解系数乘以一个小数，保持低度数不变（以避免破坏一致性），然后再转换回节点基础。然而，过滤器会降低该方法的准确性。另一个在某种意义上更简单的策略是使用更多的正交点来更准确地捕捉非线性项。每个坐标方向使用超过[2.x.144]个正交点有时被称为过度积分或一致积分。后者在不可压缩的Navier-Stokes方程的背景下最为常见，其中[2.x.145]非线性导致度数为[2.x.146]的多项式积分（当同时考虑测试函数时），只要元素的几何形状是仿生的，就可以用每个方向的[2.x.147]正交点进行精确积分。在非多项式积分的欧拉方程的背景下，选择就不太清楚了。根据各种变量的变化，[2.x.148]或[2.x.149]点（分别积分度为[2.x.150]或[2.x.151]的精确多项式）都很常见。
* 为了反映程序中正交选择的这种可变性，我们把正交点的数量作为一个变量来指定，就像多项式的度数一样，并注意到人们会根据流量配置做出不同的选择。默认选择是[2.x.152]点。
*
* - 比最小可能的[2.x.153]点多了一点。FEEvaluation和FEFaceEvaluation类允许通过模板参数无缝地改变点的数量，这样程序就不会因此而变得更加复杂。
*

*[1.x.78][1.x.79] 。


* 最后一项内容是反质量矩阵的评估 [2.x.154] 。在具有显式时间积分的DG方法中，质量矩阵是块状对角线，因此很容易被反转。
*
* - 我们只需要反转对角线块。然而，考虑到无矩阵的积分评估在成本上更接近于只访问向量，即使应用块对角矩阵（例如通过LU因子的数组）也会比评估[2.x.155]贵几倍，仅仅是因为对于高阶有限元来说，仅仅存储和加载大小为`dofs_per_cell`x`dofs_per_cell的矩阵就很昂贵。由于这显然是不可取的，部分研究人员已经转向质量矩阵是对角线的基础，例如[1.x.80]正交Legendre基础，使用hierarchical多项式或Gaussianquadrature点上的Lagrange多项式（这只是利用Legendre信息的另一种方式）。虽然对角线特性对于变形元素来说是无效的，但是通过采取对角线质量矩阵而忽略其余部分（质量包络的变体，虽然不是[2.x.156]中使用的带有额外积分误差的变体）所产生的误差已经被证明不会改变离散化的准确性。高斯正交点中的拉格朗日基础有时也被称为同位设置，因为多项式的结点与正交点重合（="同位"），避免了一些内插操作。鉴于我们想在[2.x.157]中对非线性项使用更多的正交点，然而，collocationproperty已经消失。(更确切地说，在改变基础后，它仍然用于FEEvaluation和FEFaceEvaluation，见无矩阵论文 [2.x.158] )。
* 在这个教程程序中，我们使用拼合的思想来应用反质量矩阵，但有一个小小的转折。与其在高斯四分法的点上通过拉格朗日多项式使用拼合，我们更倾向于在高斯-洛巴特的点上使用传统的拉格朗日基础，因为这些使面积分的评估变得很便宜。这是因为对于高斯-洛巴特点，一些节点位于单元格的面上，而且不难证明，在任何给定的面上，唯一具有非零值的形状函数正是其节点实际上位于该面上的那些。当然，我们也可以像[2.x.159]那样使用高斯-洛巴特正交（有一些额外的积分误差），但我们不想牺牲精度，因为这些正交公式通常比一般高斯正交公式的阶数低。相反，我们使用参考文献[2.x.160]中描述的一个想法，其中提出为了应用反质量矩阵而改变基础。让我们用[2.x.161]来表示在正交点评估的形状函数矩阵，形状函数在矩阵的两边，正交点在列中。然后，单元格[2.x.162]上的质量矩阵由[1.x.81]给出。这里，[2.x.163]是对角线矩阵，以雅各布时间的行列式和正交权重（JxW）作为条目。矩阵[2.x.164]被构造为一维矩阵的克朗克积（张量积），例如在三维中为[1.x.82]，这是基础函数是一维形状函数的张量积，正交公式是一维正交公式的张量积的结果。对于多项式的数量等于正交点的数量的情况，[2.x.165]中的所有矩阵都是正方形的，而且克朗克积中[2.x.166]的成分也是正方形的。因此，我们可以对每个矩阵进行反转，形成整体的逆，[1.x.83]这个公式的结构与用和因子化技术对积分进行正向评价的步骤完全相同（即交易二的FEE评价和无矩阵框架）。因此，我们可以利用相同的代码路径，使用不同的插值矩阵，[2.x.167]而不是[2.x.168] 。
*类[2.x.169]实现了这个操作。它从有限元中包含的基(在这个例子中，FE_DGQ)改变为高斯正交点中的拉格朗日基。在这里，对角线质量矩阵的逆值可以被评估，这只是 "JxW "因子的逆值（即正交权重乘以从参考坐标到实坐标的Jacobian的行列式）。一旦这样做了，我们就可以回到标准的节点高斯-洛巴托基础。
* 这种应用反质量矩阵的特殊方式的优点是成本类似于质量矩阵的正向应用，比用超积分和面积分评估空间算子[2.x.170]更便宜。(我们将在[1.x.84]中用详细的时序信息证明这一点。)事实上，它是如此便宜，以至于在大多数现代体系结构上，它受到读取源向量、读取对角线和写入目标向量的带宽的限制。用于结果部分的硬件可以使计算的速度至少比从内存中提取向量的速度快一倍。
*

*[1.x.85][1.x.86]


* 在这个教程程序中，我们实现了两个测试案例。第一个案例是一个限于两个空间维度的融合测试。它运行一个所谓的各向异性漩涡，该漩涡通过一个背景流场进行传输。第二个案例使用了一个更令人兴奋的设置。我们使用[2.x.171]函数，从一个浸泡在通道中的圆柱体开始。在这里，我们在马赫数为[2.x.172]的亚音速初始场，在[2.x.173]方向有一个恒定的速度。在顶壁和底壁以及圆柱体上，我们施加一个无穿透（即切向流动）的条件。与初始条件相比，这种设置迫使气流重新定向，从而产生一个远离圆柱体的大声波。在上游方向，声波的传播速度较慢（因为它必须与迎面而来的气体对抗），包括密度和压力的不连续。在下游方向，由于声音的传播和流体的流动方向相同，传输速度较快，这在一定程度上抹去了不连续的现象。一旦声波碰到上下壁，声音就会被反射回来，形成一些漂亮的形状，如下图[1.x.87]所示。
*

* [1.x.88] [1.x.89]。
* 包含的文件与之前的无矩阵教程程序[2.x.174]，[2.x.175]，和[2.x.176]相似。
*


* [1.x.90]
*
* 以下文件包括CellwiseInverseMassMatrix数据结构，我们将用于质量矩阵的反演，这是本教程程序唯一的新包含文件。
*


* [1.x.91]
*
* 与其他无矩阵教程程序类似，我们在文件的顶部收集所有控制程序执行的参数。除了我们想要运行的维度和多项式程度，我们还指定了我们想要用于欧拉方程中的非线性项的高斯正交公式中的点数。此外，我们指定了随时间变化的问题的时间间隔，并实现了两个不同的测试案例。第一个是二维的分析解，而第二个是介绍中描述的围绕圆柱体的通道流。根据测试案例，我们还改变了运行模拟的最终时间，以及一个变量`output_tick`，它指定了我们要在哪个时间间隔内写入输出（假设tick大于时间步长）。
*


* [1.x.92]
*
* 接下来是时间积分器的一些细节，即用公式[2.x.177]来衡量时间步长的库朗数，以及选择一些低存储量的Runge--Kutta方法。我们指定Runge--Kutta方案每级的Courant数，因为这对不同级数的方案给出了一个更现实的数字成本表达。
*


* [1.x.93]
*
* 最终，我们选择了空间离散化的一个细节，即单元间面的数值通量（黎曼求解器）。对于这个程序，我们实现了Lax--Friedrichs通量和Harten--Lax--van Leer(HLL)通量的一个修正变体。
*


* [1.x.94]
*
* [1.x.95] [1.x.96]。


*
* 我们现在定义了一个带有测试案例0的精确解的类和一个带有通道测试案例1的背景流场的类。鉴于欧拉方程是一个在[2.x.179]维度上有[2.x.178]方程的问题，我们需要告诉函数基类关于正确的分量数量。
*


* [1.x.97]
*
* 就实际实现的函数而言，分析性测试案例是一个等熵涡旋案例（例如，见Hesthaven和Warburton的书，第209页第6.6节的例6.1），它满足欧拉方程，右侧的力项为零。考虑到这个定义，我们返回密度、动量或能量，这取决于所要求的成分。请注意，密度的原始定义涉及一些表达式的[2.x.180]-次方。由于[2.x.181]在某些系统上的实现速度相当慢，我们用对数和指数（以2为底）来代替它，这在数学上是等价的，但通常优化得更好。与[2.x.182]相比，这个公式对于非常小的数字来说，在最后一位数上可能会失去准确性，但我们还是很高兴，因为小数字映射到接近1的数据。
* 对于通道测试案例，我们简单地选择密度为1，[2.x.183]方向的速度为0.4，其他方向的速度为0，以及对应于根据背景速度场测量的1.3声速的能量，根据关系[2.x.184]计算。
*


* [1.x.98]
*
* [1.x.99] [1.x.100]。


*
* 接下来的几行实现了一些低存储量的Runge--Kutta方法的变体。这些方法有特定的布彻表，系数为[2.x.185]和[2.x.186]，如介绍中所示。如同Runge--Kutta方法中的惯例，我们可以从这些系数中推导出时间步长[2.x.187]。这种方案的主要优点是每个阶段只需要两个向量，即解的累积部分[2.x.188]（在最后一个阶段后的新时间[2.x.190]保持解[2.x.189]），在各阶段被评估的更新向量[2.x.191]，加上一个向量[2.x.192]以保持运算器的评估。这样的Runge--Kutta设置减少了内存存储和内存访问。由于内存带宽通常是现代硬件上的性能限制因素，当微分算子的评估得到很好的优化时，性能可以比标准的时间积分器得到改善。考虑到传统的Runge--Kutta方案可能允许稍大的时间步长，因为更多的自由参数可以获得更好的稳定性，这也是真实的。   
* 在本教程中，我们集中讨论Kennedy, Carpenter和Lewis(2000)的文章中定义的低存储方案的几个变体，以及Tselios和Simos(2007)描述的一个变体。还有一大系列的其他方案，可以通过额外的系数集或稍微不同的更新公式来解决。   
* 我们为这四种积分器定义了一个单一的类别，并以上述枚举方式加以区分。对每个方案，我们再将[2.x.193]和[2.x.194]的向量填充到类中的给定变量。
*


* [1.x.101]
*
* 首先是Kennedy等人（2000）提出的三阶方案。虽然它的稳定区域明显小于其他方案，但它只涉及三个阶段，所以它在每个阶段的工作方面非常有竞争力。
*


* [1.x.102]
*
* 下一个方案是四阶的五级方案，同样在Kennedy等人（2000）的论文中定义。
*


* [1.x.103]

* 下面这个七级四阶的方案已被明确推导出用于声学问题。它在四阶方案中兼顾了虚数特征值的精度，并结合了一个大的稳定区域。由于DG方案在最高频率之间是耗散的，这不一定转化为每级可能的最高时间步长。在本教程方案的背景下，数值通量在耗散中起着至关重要的作用，因此也是最大的稳定时间步长。对于修改后的Lax--Friedrichs通量，如果只考虑稳定性，该方案在每级步长方面与`stage_5_order_4`方案相似，但对于HLL通量来说，效率稍低。
*


* [1.x.104]
*
* 这里包括的最后一个方案是Kennedy等人（2000）的五阶九级方案。它是这里使用的方案中最精确的，但更高的精度牺牲了一些稳定性，所以每级的步长归一化后比四阶方案要小。
*


* [1.x.105]
*
* 时间积分器的主要功能是经历各个阶段，评估算子，为下一次评估准备[2.x.195]矢量，并更新解矢量 [2.x.196] 。我们把工作交给所涉及的`pde_operator`，以便能够把Runge--Kutta设置的矢量操作与微分算子的评估合并起来，以获得更好的性能，所以我们在这里所做的就是委托矢量和系数。     
* 我们单独调用第一阶段的算子，因为我们在那里需要稍作修改的参数。我们从旧的解决方案[2.x.197]而不是[2.x.198]向量中评估解决方案，所以第一个参数是`solution`。我们在这里让阶段向量[2.x.199]也持有评估的临时结果，因为它不用于其他方面。对于所有后续阶段，我们使用向量`vec_ki`作为第二个向量参数来存储运算符的求值结果。最后，当我们处于最后阶段时，我们必须跳过对向量[2.x.200]的计算，因为没有系数[2.x.201]可用（也不会被使用）。
*


* [1.x.106]
*
* [1.x.107] [1.x.108]。


*
* 在下面的函数中，我们实现了与欧拉方程有关的各种特定问题的运算。每个函数都作用于我们在解向量中持有的守恒变量向量[2.x.202]，并计算各种派生量。   
* 首先是速度的计算，我们通过除以[2.x.204]从动量变量[2.x.203]中得出。这里需要注意的是，我们用关键字`DEAL_II_ALWAYS_INLINE`来装饰所有这些函数。这是一个特殊的宏，映射到一个编译器专用的关键字，告诉编译器永远不要为这些函数创建一个函数调用，而是将实现[1.x.109]移到它们被调用的地方。这对性能至关重要，因为我们对其中一些函数的调用达到了几百万甚至几十亿次。例如，我们既使用速度来计算通量，也使用速度来计算压力，而这两个地方都要在每个单元的每个正交点进行评估。确保这些函数是内联的，不仅可以确保处理器不必执行跳转指令进入函数（以及相应的返回跳转），而且编译器可以在调用函数的地方之后的代码中重新使用一个函数的上下文的中间信息。(我们注意到，编译器通常很善于自己找出哪些函数要内联。这里有一个地方，编译器可能是自己想出来的，也可能不是，但我们可以肯定的是，内联是一个赢家）。)   
* 我们应用的另一个技巧是为反密度设置一个单独的变量 [2.x.205] 。这使得编译器只对通量进行一次除法，尽管除法在多个地方被使用。由于除法的费用大约是乘法或加法的10到20倍，避免多余的除法对性能至关重要。我们注意到，由于四舍五入的影响，在浮点运算中，先取反数，后与之相乘并不等同于除法，所以编译器不允许用标准的优化标志来交换一种方式。然而，以正确的方式编写代码也不是特别困难。   
* 总而言之，所选择的策略是总是内联和仔细定义昂贵的算术运算，这使得我们可以写出紧凑的代码，而不需要将所有的中间结果传递出去，尽管要确保代码映射到优秀的机器代码。
*


* [1.x.110]
*
* 下一个函数使用公式[2.x.206]从保守变量矢量计算压力。如上所述，我们使用`euler_velocity()`函数中的速度。注意，我们需要在这里指定第一个模板参数`dim`，因为编译器无法从张量的参数中推导出它，而第二个参数（数字类型）可以自动推导出来。
*


* [1.x.111]
*
* 这里是欧拉通量函数的定义，也就是实际方程的定义。考虑到速度和压力（编译器的优化将确保只做一次），考虑到引言中所述的方程，这是直截了当的。
*


* [1.x.112]
*
* 接下来的这个函数是一个简化数值通量实现的辅助工具，它实现了一个张量（具有大小为`dim + 2`的非标准外维，所以deal.II的张量类所提供的标准重载在这里并不适用）与另一个相同内维的张量的作用，即一个矩阵-向量积。
*


* [1.x.113]
*
* 这个函数实现了数值通量（黎曼求解器）。它从一个界面的两边获得状态，并获得法向量，从解的一边 [2.x.207] 面向解 [2.x.208] 。在依赖片断恒定数据的有限体积方法中，数值通量是核心成分，因为它是唯一输入物理信息的地方。在DG方法中，由于元素内部的多项式和那里使用的物理通量，数值通量就不那么核心了。由于在连续解的极限中，两边的数值一致的高阶插值，数值通量可以被看作是对两边解的跳跃的控制，以弱化连续性。必须认识到，在存在冲击的情况下，仅靠数值通量是无法稳定高阶DG方法的，因此任何DG方法都必须与进一步的冲击捕捉技术相结合，以处理这些情况。在本教程中，我们重点讨论了欧拉方程在亚声速体系中的波状解，在这种情况下，我们的基本方案是足够的。   
* 尽管如此，数值通量对整个方案的数值耗散起着决定性作用，并影响到显式Runge-Kutta方法的可接受的时间步长。我们考虑两种选择，一种是改良的Lax-Friedrichs方案，另一种是广泛使用的Harten-Lax-van Leer（HLL）通量。对于这两种方案，我们首先需要得到界面两边的速度和压力，并评估物理欧拉通量。   
* 对于局部Lax--Friedrichs通量，定义是[2.x.209]，其中因子[2.x.210]给出了最大波速，[2.x.211]是音速。在这里，考虑到通量对解的影响较小，出于计算效率的考虑，我们选择该表达式的两个修改。对于上述因子[2.x.212]的定义，我们需要取四个平方根，两个用于两个速度规范，两个用于两侧的声速。因此，第一个修改是宁可使用[2.x.213]作为最大速度的估计（如介绍中所示，它与实际最大速度最多相差2倍）。这使得我们可以从最大速度中抽出平方根，并且只需进行一次平方根计算就可以了。第二个修改是进一步放宽参数[2.x.214]--它越小，耗散系数就越小（与[2.x.215]中的跳跃相乘，最终可能会导致耗散变小或增大）。这使我们能够将频谱纳入显式Runge--Kutta积分器的稳定区域，并具有更大的时间步长。然而，我们不能使耗散太小，因为否则假想的特征值会越来越大。最后，目前的保守公式在[2.x.216]的极限中不是能量稳定的，因为它不是偏斜对称的，在这种情况下需要额外的措施，如分裂形式的DG方案。   
* 对于HLL通量，我们遵循文献中的公式，通过一个参数[2.x.217]引入Lax--Friedrichs的两个状态的额外加权。它是由欧拉方程的物理传输方向得出的，以当前的速度方向和声速为准。对于速度，我们在这里选择一个简单的算术平均数，这对于危险情况和材料参数的适度跳跃来说是足够的。   
*由于数值通量在弱式中是与法向量相乘的，所以我们对方程中的所有项都用法向量来乘以结果。在这些乘法中，上面定义的 "运算器*"能够实现类似于数学定义的紧凑符号。   
* 在这个和下面的函数中，我们使用变量后缀`_m`和`_p`来表示从[2.x.218]和[2.x.219]中得到的量，即在看相邻单元时，相对于当前单元的 "这里 "和 "那里 "的值。
*


* [1.x.114]
*
* 这个和下一个函数是辅助函数，提供紧凑的评估调用，因为多个点通过VectorizedArray参数被分批放在一起（详见[2.x.220] 教程）。这个函数用于亚音速外流边界条件，我们需要将能量分量设置为一个规定值。下一个函数请求所有分量上的解，用于流入边界，其中解的所有分量都被设置。
*


* [1.x.115]
*
* [1.x.116] [1.x.117]。


*
* 这个类实现了欧拉问题的评估器，类似于 [2.x.221] 或 [2.x.222] 的 `LaplaceOperator`类。由于本算子是非线性的，不需要矩阵接口（交给预处理程序），我们跳过了无矩阵算子中的各种`vmult`函数，只实现了`apply`函数以及`apply`与上述低存储Runge-Kutta时间积分器所需的矢量更新的组合（称为`perform_stage`）。此外，我们还增加了三个涉及无矩阵程序的额外函数，即根据元素中的速度和声速计算时间步长的估计值（与实际时间步长的Courant数相结合），一个用于解决方案的投影（专门针对DG情况的[2.x.223]），以及一个用于计算针对可能的分析解决方案的误差或针对某些背景状态的规范。   
* 本课的其余部分与其他无矩阵教程相似。正如介绍中所讨论的，我们提供了一些函数，允许用户在由[2.x.224]变量标记的领域边界的不同部分传递各种形式的边界条件，以及可能的体力。
*


* [1.x.118]
*
* 对于欧拉算子的初始化，我们设置了类中包含的MatrixFree变量。这可以通过给定一个描述可能的弯曲边界的映射以及一个描述自由度的DoFHandler对象来完成。由于我们在这个教程程序中使用的是不连续的Galerkin离散化，没有对解场施加强烈的约束，所以我们不需要传入AffineConstraints对象，而是使用一个假的来构造。关于正交，我们要选择两种不同的方式来计算基础积分。第一种是灵活的，基于模板参数`n_points_1d`（将被分配到本文件顶部指定的`n_q_points_1d`值）。更精确的积分是必要的，以避免由于欧拉算子中的可变系数而产生的混叠问题。第二个不太精确的正交公式是一个基于`fe_degree+1`的紧缩公式，需要用于反质量矩阵。虽然该公式仅在仿生元素形状上提供了精确的反，而在变形元素上则没有，但它能够通过张量积技术快速反转质量矩阵，这对于确保整体的最佳计算效率是必要的。
*


* [1.x.119]
*
* 随后的四个成员函数是必须从外部调用以指定各种类型的边界。对于一个流入的边界，我们必须以密度 [2.x.225] 、动量 [2.x.226] 和能量 [2.x.227] 来指定所有成分。考虑到这些信息，我们将函数和各自的边界ID一起存储在这个类别的地图成员变量中。同样，我们对亚音速外流边界（我们也要求一个函数，用来检索能量）和壁面（无穿透）边界进行处理，其中我们施加了零法向速度（不需要函数，所以我们只要求边界ID）。对于目前的DG代码来说，边界条件只作为弱形式的一部分被应用（在时间积分期间），设置边界条件的调用可以出现在对这个类的`reinit()`调用之前或之后。这与连续有限元代码不同，后者的边界条件决定了被送入MatrixFree初始化的AffineConstraints对象的内容，因此需要在无矩阵数据结构的初始化之前设置。   
* 在四个函数中的每一个中添加的检查是用来确保边界条件在边界的各个部分是相互排斥的，也就是说，用户不会意外地将一个边界既指定为流入边界，又指定为例如亚声速流出边界。
*


* [1.x.120]
*
* [1.x.121] [1.x.122]。


*
* 现在我们开始研究欧拉问题的局部评价器。评估器相对简单，并遵循 [2.x.228] 、 [2.x.229] 或 [2.x.230] 中的内容。第一个明显的区别是，我们使用的FEE估值具有非标准的正交点数量。以前我们总是将正交点的数量设置为等于多项式度数加1（确保在仿生元素形状上的精确积分），现在我们将正交点的数量设置为一个单独的变量（例如多项式度数加多项式度数的二分之一或三分之一），以便更准确地处理非线性项。由于评估器通过模板参数输入了适当的循环长度，并在变量[2.x.231]中保留了整个单元格的正交点数量，我们现在可以自动操作更精确的公式，而无需进一步修改。   
* 第二个区别是由于我们现在评估的是一个多分量系统，而不是之前考虑的标量系统。无矩阵框架提供了几种处理多成分情况的方法。这里显示的变体是利用一个嵌入了多个分量的FEEvaluation对象，由第四个模板参数`dim + 2`指定欧拉系统中的分量。因此，[2.x.232]的返回类型不再是一个标量（这将返回一个VectorizedArray类型，收集几个元素的数据），而是一个`dim+2`组件的Tensor。该功能与标量的情况类似；它由一个基类的模板专业化处理，称为FEEvaluationAccess。另一个变体是使用几个FEEvaluation对象，一个标量对象用于密度，一个带`dim`分量的矢量值对象用于动量，另一个标量评价器用于能量。为了确保这些分量指向解决方案的正确部分，FEEvaluation的构造函数在所需的MatrixFree字段之后需要三个可选的整数参数，即多DoFHandler系统的DoFHandler编号（默认取第一个），如果有多个Quadrature对象，则取正交点的编号（见下文），以及作为第三个参数的矢量系统中的分量。由于我们有一个单一的矢量来表示所有的分量，我们将使用第三个参数，并将其设置为`0`表示密度，`1`表示矢量值的动量，`dim+1`表示能量槽。FEEvaluation然后在[2.x.233]和[2.x.234]或更紧凑的[2.x.235]和[2.x.236]调用中选择适当的解矢量子范围。   
*当涉及到体力向量的评估时，出于效率的考虑，我们对两种情况进行了区分。如果我们有一个常数函数（从[2.x.237]中导出，我们可以在正交点的循环外预先计算出数值，并简单地在所有地方使用该数值。对于一个更通用的函数，我们反而需要调用我们上面提供的`evaluate_function()`方法；这个路径更昂贵，因为我们需要访问与正交点数据相关的内存。   
* 其余的部分沿用其他教程的程序。由于我们已经在单独的`euler_flux()`函数中实现了欧拉方程的所有物理学，我们在这里所要做的就是调用这个函数，给定在正交点评估的当前解，由`phi.get_value(q)`返回，并告诉FEEvaluation对象排队，通过形状函数的梯度（这是一个外部`dim+2`分量的张量，每个张量持有一个`dim`分量的[2.x.238] 欧拉通量的分量）。)最后值得一提的是，在我们得到一个外部函数的情况下，我们通过测试函数`phi.submit_value()`的值来排队测试数据的顺序。我们必须在调用`phi.get_value(q)'之后进行，因为`get_value()'（读取解决方案）和`submit_value()'（排队等待测试函数的乘法和正交点的求和）访问同一个底层数据域。这里很容易实现没有临时变量`w_q`，因为值和梯度之间没有混合。对于更复杂的设置，我们必须首先复制出例如正交点的值和梯度，然后通过[2.x.239]和[2.x.240]再次排队等待结果。
* 最后，我们提到我们没有使用这个函数的第一个MatrixFree参数，它是对[2.x.241]的回调，接口规定了现在的参数列表，但是由于我们在一个成员函数中，MatrixFree对象已经作为`data`变量可用，我们坚持使用它以避免混淆。
*


* [1.x.123]
*
* 下一个函数涉及到内部面的积分计算，在这里我们需要来自面的相邻两个单元的评估器。我们将变量`phi_m`与解分量[2.x.242]相关联，将变量`phi_p`与解分量[2.x.243]相关联。在FEFaceEvaluation的构造函数中，我们通过第二个参数来区分两个面，`true`代表内部面，`false`代表外部面，内部和外部表示相对于法向量的方向。   
* 注意调用[2.x.244]和[2.x.245]结合了对向量和因式分解部分的访问。这种合并操作不仅节省了一行代码，而且还包含了一个重要的优化。鉴于我们在Gauss-Lobatto正交公式的点上使用拉格朗日多项式的节点基础，[2.x.246]中只有[2.x.247]的基础函数在每个面上评估为非零。因此，评估器只访问了向量中的必要数据，而跳过了被零乘的部分。如果我们首先读取向量，我们就需要从向量中加载所有的数据，因为孤立的调用不知道后续操作中需要哪些数据。如果随后的[2.x.248]调用要求数值和导数，确实需要每个分量的所有[2.x.249]向量条目，因为所有基函数的正常导数都是非零的。   
* 评估器的参数以及程序与单元格评估相似。由于非线性项的存在，我们再次使用更精确的（过度）积分方案，指定为列表中第三个模板参数。在正交点上，我们再去找我们的自由函数来计算数值通量。它从两边（即[2.x.250]和[2.x.251]）接收在正交点评估的解决方案，以及到负边的法向量。正如上面所解释的，数值通量已经乘以来自减法侧的法向量了。我们需要转换符号，因为在引言中导出的弱形式中，边界项带有一个减号。然后，通量在负号和正号上都被排队测试，由于正号上的法向量与负号上的法向量正好相反，所以要调换符号。
*


* [1.x.124]
*
* 对于位于边界的面，我们需要施加适当的边界条件。在这个教程程序中，我们实现了上述的四种情况。第五种情况，即超音速流出条件，将在下面的 "结果 "部分讨论）。不连续的Galerkin方法对边界条件的施加不是作为约束条件，而只是弱化。因此，各种条件是通过找到一个适当的[1.x.125]量[2.x.252]来施加的，然后交给也用于内部面的数值通量函数。实质上，我们在域外 "假装 "一个状态，如果那是现实，PDE的解将满足我们想要的边界条件。   
* 对于墙的边界，我们需要对动量变量施加一个无正态通量的条件，而对于密度和能量，我们使用的是诺伊曼条件 [2.x.253] 和 [2.x.254] 。为了实现无法线通量条件，我们将外部数值设定为内部数值，并减去墙面法线方向，即法线矢量方向的2倍速度。   
* 对于流入边界，我们只是将给定的Dirichlet数据[2.x.255]作为边界值。另一种方法是使用[2.x.256]，即所谓的镜像原理。   
* 外流的施加本质上是一个诺伊曼条件，即设置[2.x.257] 。对于亚音速流出的情况，我们仍然需要为能量施加一个值，我们从各自的函数中得出。对于[1.x.126]的情况，即在Neumann部分有动量通入域的情况，需要一个特殊的步骤。根据文献（这一事实可以通过适当的能量论证得出），我们必须改用流入部分的通量的另一种变体，见Gravemeier, Comerford, Yoshihara, Ismail, Wall, "A novel formulation for Neumann inflow conditions in biomechanics", Int.J. Numer.Meth.生物医学。Eng., vol. 28 (2012).这里，动量项需要再次添加，这相当于去除动量变量上的通量贡献。我们在后处理步骤中这样做，而且只适用于我们都处于外流边界且法向量与动量（或等同于速度）之间的点积为负的情况。由于我们在SIMD矢量化中一次处理几个正交点的数据，我们在这里需要明确地在SIMD数组的条目上循环。   
* 在下面的实现中，我们在正交点的层面上检查各种类型的边界。当然，我们也可以将决定权移出正交点循环，将整个面作为同类处理，这就避免了在正交点的内循环中进行一些地图/集合查找。然而，效率的损失并不明显，所以我们在这里选择了更简单的代码。还要注意的是，最后的 "else "子句会捕捉到这样的情况：边界的某些部分没有通过[2.x.258]被分配任何边界条件。
*


* [1.x.127]
*
* 下一个函数实现了质量矩阵的逆运算。在介绍中已经广泛讨论了算法和原理，所以我们在这里只讨论[2.x.259]类的技术问题。它所做的操作与质量矩阵的正向评估类似，只是有一个不同的插值矩阵，代表逆[2.x.260]因子。这些代表了从指定的基础（在这种情况下，高斯--洛巴托正交公式点中的拉格朗日基础）到高斯正交公式点中的拉格朗日基础的改变。在后者的基础上，我们可以应用点的逆向`JxW`因子，即正交权重乘以从参考坐标到实坐标的映射的雅各布系数。一旦完成了这一操作，基数将再次变回节点高斯-洛巴托基数。所有这些操作都由下面的 "apply() "函数完成。我们需要提供的是要操作的局部场（我们通过FEEvaluation对象从全局向量中提取），并将结果写回质量矩阵操作的目标向量。   
* 需要注意的一点是，我们在FEEvaluation的构造函数中添加了两个整数参数（可选），第一个是0（在多DoFHandler系统中选择DoFHandler；在这里，我们只有一个），第二个是1，用于进行正交公式选择。由于我们将正交公式0用于非线性项的过度积分，我们将公式1与默认的[2.x.261]（或变量名称中的`fe_degree+1`）点用于质量矩阵。这导致了对质量矩阵的平方贡献，并确保了精确的积分，正如介绍中所解释的。
*


* [1.x.128]
*
* [1.x.129] [1.x.130]。


*
* 我们现在来看看实现欧拉算子整体评估的函数，即[2.x.262]，调用到上面介绍的局部评估器。这些步骤在前面的代码中应该是清楚的。需要注意的一点是，我们需要调整与边界各部分相关的函数中的时间，以便在边界数据随时间变化的情况下与方程一致。然后，我们调用[2.x.263]来执行单元和面的积分，包括在`src`向量中进行必要的ghost数据交换。该函数的第七个参数，"true"，指定我们要在开始向其累积积分之前，将 "dst "向量作为循环的一部分归零。这个变体比在循环之前明确调用`dst = 0.;`要好，因为归零操作是在矢量的子范围内完成的，其部分是由附近的积分写入的。这加强了数据的定位，并允许缓存，节省了向量数据到主内存的一次往返，提高了性能。循环的最后两个参数决定了哪些数据被交换：由于我们只访问一个面的形状函数的值，这是典型的一阶双曲问题，并且由于我们有一个节点基础，节点位于参考元素表面，我们只需要交换这些部分。这又节省了宝贵的内存带宽。   
* 一旦应用了空间算子[2.x.264]，我们需要进行第二轮，应用反质量矩阵。这里，我们称之为[2.x.265]，因为只有单元积分出现。单元循环比全循环更便宜，因为只访问与本地拥有的单元相关的自由度，这只是DG离散化的本地拥有的自由度。因此，这里不需要鬼魂交换。   
* 在所有这些函数周围，我们设置了定时器范围来记录计算时间，以统计各部分的贡献。
*


* [1.x.131]
*
* 让我们转到做Runge--Kutta更新的整个阶段的函数。它调用[2.x.266]，然后对向量进行一些更新，即`next_ri = solution + factor_ai k_i`和`solution += factor_solution k_i`。与其通过向量接口执行这些步骤，我们在此提出一个替代策略，在基于缓存的架构上速度更快。由于向量所消耗的内存往往比缓存所能容纳的要大得多，所以数据必须有效地来自缓慢的RAM内存。这种情况可以通过循环融合来改善，即在一次扫描中对`next_ki`和`solution`进行更新。在这种情况下，我们将读取两个向量`rhs`和`solution`并写入`next_ki`和`solution`，而在基线情况下，至少有4次读取和两次写入。在这里，我们更进一步，当质量矩阵反转在向量的某一部分完成后，立即执行循环。  [2.x.267]提供了一种机制，在单元格的循环第一次接触到一个向量条目之前，附加一个[2.x.268]（我们在这里没有使用，但是例如用于向量的归零），以及在循环最后接触到一个条目之后调用第二个[2.x.269]。回调的形式是给定向量的范围（就MPI宇宙中的本地索引编号而言），可以由`local_element()`函数处理。   
* 对于这第二个回调，我们创建一个在范围上工作的lambda，并在这个范围上写入相应的更新。理想情况下，我们会在本地循环之前添加`DEAL_II_OPENMP_SIMD_PRAGMA`，以建议编译器对这个循环进行SIMD并行化（这意味着在实践中，我们要确保我们在循环内使用的指针的索引范围之间没有重叠，也称为别名）。事实证明，在写这篇文章的时候，GCC 7.2无法编译lambda函数中的OpenMP pragma，所以我们在下面注释了这个pragma。如果你的编译器比较新，你应该可以再次取消注释这些行。   
* 注意，当我们不需要更新`next_ri`向量时，我们为最后的Runge--Kutta阶段选择了不同的代码路径。这个策略带来了相当大的速度提升。在40核机器上，默认矢量更新时，逆质量矩阵和矢量更新需要60%以上的计算时间，而在更优化的变体中，这一比例约为35%。换句话说，这是一个大约三分之一的速度提升。
*


* [1.x.132]
*
* 在讨论了处理推进解的一个时间步长的函数的实现后，现在让我们来看看实现其他辅助操作的函数。具体来说，这些是计算投影、评估误差和计算单元上信息传输速度的函数。   
* 其中第一个函数基本上等同于[2.x.270]，只是速度快得多，因为它是专门针对DG元素的，不需要设置和解决线性系统，因为每个元素都有独立的基函数。我们在这里展示代码的原因，除了这个非关键操作的小幅提速之外，还因为它展示了[2.x.271]提供的额外功能。
* 投影操作的工作原理如下。如果我们用[2.x.272]表示在正交点评估的形状函数矩阵，在单元格[2.x.273]上的投影是一个形式为[2.x.274]的操作，其中[2.x.275]是包含雅各布系数乘以正交权重（JxW）的对角线矩阵，[2.x.276]是单元格质量矩阵，[2.x.277]是要投影到正交点的领域评估。实际上，矩阵[2.x.278]通过张量积有额外的结构，如介绍中所解释的）。这个系统现在可以等效地写成[2.x.279] 。现在，项[2.x.280]和[2.x.281]相抵消，导致最后的表达式[2.x.282] 。这个操作由[2.x.283]实现。这个名字来自于这个投影只是乘以[2.x.284]，一个从高斯正交点的节点基到给定的有限元基的基数变化。请注意，我们调用[2.x.285]将结果写入向量，覆盖之前的内容，而不是像典型的积分任务那样将结果累积起来。
*
* - 我们可以这样做，因为对于不连续的Galerkin离散，每个向量条目都只有一个单元的贡献。
*


* [1.x.133]
*
* 下一个函数再次重复了同样由deal.II库提供的功能，即[2.x.286]我们在这里展示了明确的代码，以强调跨几个单元的矢量化是如何工作的，以及如何通过该接口累积结果。回顾一下，每个[1.x.134]的矢量化数组持有来自不同单元的数据。通过对当前MPI进程所拥有的所有单元批的循环，我们就可以填充一个结果的VectorizedArray；为了得到一个全局的总和，我们需要进一步去对SIMD阵列中的条目进行求和。然而，这样的程序并不稳定，因为SIMD数组事实上可能并不持有其所有通道的有效数据。当本地拥有的单元的数量不是SIMD宽度的倍数时，就会发生这种情况。为了避免无效数据，我们必须在访问数据时明确地跳过那些无效的通道。虽然人们可以想象，我们可以通过简单地将空车道设置为零（从而不对总和做出贡献）来使其工作，但情况比这更复杂。如果我们要从动量中计算出一个速度呢？那么，我们就需要除以密度，密度为零。
*
* - 结果将是NaN，并污染了结果。当我们在单元格批次中循环时，使用函数[2.x.287]给我们提供有效数据的通道数，累积有效SIMD范围内的结果，就可以避免这种陷阱。它在大多数单元上等于[2.x.288]，但如果与SIMD宽度相比，单元数有余数，则在最后一个单元批上可能更少。
*


* [1.x.135]
*
* 这个EulerOperator类的最后一个函数用于估计传输速度，由网格大小缩放，这与设置显式时间积分器中的时间步长有关。在欧拉方程中，有两种传输速度，即对流速度[2.x.289]和声波的传播，其声速[2.x.290]相对于介质的运动速度[2.x.291] 。   
*在时间步长的公式中，我们感兴趣的不是这些绝对速度，而是信息穿过一个单元所需的时间。对于与介质一起传输的信息，[2.x.292]是由网格大小缩放的，所以最大速度的估计可以通过计算[2.x.293]得到，其中[2.x.294]是实域到参考域的转换的雅各布系数。请注意，[2.x.295]返回的是反转和转置的雅各布，代表从实数到参考坐标的度量项，所以我们不需要再转置它。我们在下面的代码中把这个极限存储在变量`convective_limit`中。   
* 声音的传播是各向同性的，所以我们需要考虑到任何方向的网格大小。然后，适当的网格大小比例由[2.x.296]的最小奇异值给出，或者，等同于[2.x.297]的最大奇异值。请注意，当忽略弯曲的单元时，可以用单元顶点之间的最小距离来近似这个量。为了得到Jacobian的最大奇异值，一般的策略是使用一些LAPACK函数。由于我们在这里所需要的是一个估计值，我们可以避免将一个向量数组的张量分解成几个矩阵的麻烦，并进入一个（昂贵的）没有向量的特征值函数，而是使用应用于[2.x.298]的幂方法的几次迭代（在下面的代码中为五次）。这种方法的收敛速度取决于最大特征值与次大特征值的比率以及初始猜测，即所有1的矢量。这可能表明，我们在接近立方体形状的单元上得到缓慢的收敛，在这种情况下，所有的长度几乎都是一样的。然而，这种缓慢的收敛意味着结果将位于两个最大的奇异值之间，而这两个奇异值无论如何都是接近最大值的。在所有其他情况下，收敛将是快速的。因此，我们可以只在这里硬编码5次迭代，并确信结果是好的。
*


* [1.x.136]
*
* 与前面的函数类似，我们必须确保只在一个单元格批次的有效单元格上积累速度。
*


* [1.x.137]
*
* [1.x.138] [1.x.139]。


*
* 该类将EulerOperator类与时间积分器和通常的全局数据结构（如FiniteElement和DoFHandler）相结合，以实际运行欧拉问题的模拟。   
* 成员变量是一个三角形、一个有限元、一个映射（用于创建高阶曲面，见例如[2.x.299]）和一个描述自由度的DoFHandler。此外，我们还保留了上面描述的EulerOperator的一个实例，它将完成所有积分方面的繁重工作，以及一些时间积分的参数，如当前时间或时间步长。   
* 此外，我们使用一个PostProcessor实例来向输出文件写入一些额外的信息，这与 [2.x.300] 中的做法类似。DataPostprocessor类的接口很直观，要求我们提供关于需要评估的信息（通常只有解的值，除了Schlieren图，我们只在二维中启用它是有意义的），以及被评估的东西的名称。请注意，也可以通过可视化程序（如ParaView）中的计算器工具来提取大部分信息，但在写输出的时候就已经做了，这要方便得多。
*


* [1.x.140]
*
* 对于字段变量的主要评估，我们首先检查数组的长度是否等于预期值（长度`2*dim+4`或`2*dim+5`是由我们在下面的get_names()函数中指定的名字的大小得出）。然后我们在所有的评估点上循环，填充相应的信息。首先，我们填写密度[2.x.301]、动量[2.x.302]和能量[2.x.303]的原始解变量，然后计算得出速度[2.x.304]、压力[2.x.305]、声速[2.x.306]，以及显示[2.x.307]的Schlieren图，如果它被启用。参见[2.x.308]中的另一个例子，我们创建了一个Schlieren图）。
*


* [1.x.141]
*
* 对于数量的解释，我们有标量密度、能量、压力、声速和Schlieren图，以及动量和速度的向量。
*


* [1.x.142]
*
* 关于必要的更新标志，我们只需要所有数量的值，但Schlieren图除外，它是基于密度梯度的。
*


* [1.x.143]
*
* 这个类的构造函数并不令人惊讶。我们设置了一个基于 "MPI_COMM_WORLD "通信器的并行三角形，一个具有 "dim+2 "分量的密度、动量和能量的矢量有限元，一个与底层有限元相同程度的高阶映射，并将时间和时间步长初始化为零。
*


* [1.x.144]
*
* 作为一个网格，本教程程序实现了两种选择，取决于全局变量`testcase`。对于分析变量（`testcase==0`），域是[2.x.309]，域的四周都有迪里希特边界条件（流入）。对于`testcase==1`，我们将域设置为矩形箱中的圆柱体，来自于Sch&auml;fer和Turek(1996)的不可压缩粘性流动的流过圆柱体测试案例。在这里，我们有更多种类的边界。通道左侧的流入部分是给定的流入类型，为此我们选择了一个恒定的流入轮廓，而我们在右侧设置了一个亚声速的流出。对于圆柱体周围的边界（边界ID等于2）以及通道壁（边界ID等于3），我们使用壁的边界类型，即无正态流。此外，对于三维圆柱体，我们还在垂直方向上增加了一个重力。有了基础网格（包括由[2.x.310]设置的流形），我们就可以执行指定数量的全局细化，从DoFHandler中创建未知编号，并将DoFHandler和Mapping对象交给EulerOperator的初始化。
*


* [1.x.145]

* 在下面，我们输出一些关于问题的统计数据。因为我们经常会出现相当多的单元格或自由度，所以我们希望用逗号来分隔每一组的三位数来打印它们。这可以通过 "locales "来实现，尽管这种工作方式并不特别直观。  [2.x.311]对此有稍微详细的解释。
*


* [1.x.146]
*
* 为了输出，我们首先让欧拉算子计算出数值结果的误差。更确切地说，对于分析解的情况，我们计算与分析结果的误差，而对于第二个测试情况，我们计算与密度和能量不变的背景场以及[2.x.312]方向上的速度不变的偏差。   
* 下一步是创建输出。这与[2.x.313]中的做法类似：我们让上面定义的后处理器控制大部分的输出，除了我们直接写的原始场。对于分析解的测试案例，我们还对分析解进行了另一次投影，并打印出该场和数值解之间的差异。一旦我们定义了所有要写的量，我们就建立输出的补丁。与[2.x.314]类似，我们通过设置适当的标志来创建一个高阶VTK输出，这使我们能够可视化高多项式度的场。最后，我们调用[2.x.315]函数，将结果写入给定的文件名。这个函数使用了特殊的MPI并行写设施，通常比其他大多数教程程序中使用的标准库的[2.x.316]变体对并行文件系统更加优化。`write_vtu_in_parallel()`函数的一个特别好的特点是，它可以将所有MPI行列的输出合并到一个文件中，使得没有必要有一个所有此类文件的中央记录（即 "pvtu "文件）。   
* 对于并行程序来说，查看单元格在处理器之间的划分往往是有启发的。为此，我们可以向[2.x.317]传递一个数字向量，其中包含与当前处理器拥有的活动单元一样多的条目；然后这些数字应该是拥有这些单元的处理器的等级。例如，这样一个向量可以从[2.x.318]中获得。另一方面，在每个MPI进程中，DataOut将只读取那些对应于本地拥有的单元的条目，这些条目当然都有相同的值：即当前进程的等级。矢量的其余条目中的内容实际上并不重要，因此我们可以用一个廉价的技巧逃脱。我们只是用当前MPI进程的等级来填补我们给[2.x.319]的向量的所有*值。关键是在每个进程上，只有对应于本地拥有的单元格的条目会被读取，而忽略其他条目中的（错误的）值。事实上，每个进程提交的向量中，正确的条目子集是正确的，这一点就足够了。
*


* [1.x.147]
*
* [2.x.320]函数将所有的碎片放在一起。它首先调用创建网格和设置数据结构的函数，然后初始化时间积分器和低存储积分器的两个临时向量。我们称这些向量为`rk_register_1`和`rk_register_2`，并使用第一个向量表示[2.x.321]，第二个向量表示[2.x.322]，在介绍中概述的Runge-Kutta方案的公式中。在我们开始时间循环之前，我们通过[2.x.323]函数计算时间步长。为了便于比较，我们将那里得到的结果与最小网格尺寸进行比较，并将它们打印到屏幕上。在本教程程序中，对于接近统一的声速和速度，预测的有效网格尺寸将是接近的，但如果缩放比例不同，它们可能会有所不同。
*


* [1.x.148]
*
* 现在我们准备开始时间循环，我们一直运行到时间达到预期的结束时间。每隔5个时间步骤，我们就计算一个新的时间步骤的估计值
*
* - 由于解决方案是非线性的，在模拟过程中调整数值是最有效的。如果Courant数选择得过于激进，模拟通常会在时间步长为NaN时爆炸，所以在这里很容易发现。有一点需要注意的是，由于不同的时间步长选择的相互作用，四舍五入的误差可能会传播到前几位数，从而导致略有不同的解决方案。为了降低这种敏感性，通常的做法是将时间步长四舍五入或截断到几位数，例如在这种情况下是3。如果当前时间接近规定的输出 "刻度 "值（如0.02），我们也会写出输出。在时间循环结束后，我们通过打印一些统计数据来总结计算，这主要由[2.x.324]函数完成。
*


* [1.x.149]
*
* main()函数并不令人惊讶，它遵循了以前所有MPI程序中的做法。当我们运行一个MPI程序时，我们需要调用`MPI_Init()`和`MPI_Finalize()`，我们通过[2.x.325]数据结构来完成。注意，我们只用MPI来运行程序，并将线程数设置为1。
*


* [1.x.150]
*[1.x.151][1.x.152]


*[1.x.153][1.x.154]


* 在有40个进程的机器上以默认设置运行该程序，产生以下输出。
* [1.x.155]
*
* 程序输出显示，所有的误差都很小。这是由于我们使用了一个相对较细的[2.x.326]单元的网格，并使用5度的多项式来求得一个平滑的解决方案。一个有趣的模式显示在时间步长上：虽然在时间5之前是0.0069，但在后来的时间里增加到0.0096。一旦涡流在声速之上有一些运动（因此传播速度更快），在时间5和6.5之间离开计算域，步长就会增加。在这之后，气流只是在同一方向上是均匀的，与之前均匀速度被涡旋覆盖的状态相比，气体的最大速度有所下降。我们的时间步长公式认识到了这种效应。
* 最后一块输出显示了关于程序各个部分时间的详细信息；它通过显示最快和最慢的处理器所花费的时间以及平均时间来分解这些信息。
*
* 总结显示，1283个时间步骤在1.02秒内完成（看所有MPI进程的平均时间），而11个文件的输出又花了0.96秒。将每个时间步骤分解成五个Runge-Kutta阶段，每次评估的计算时间为0.16毫秒。这种高性能是无矩阵评估器的典型表现，也是显式时间积分对隐式求解器非常有竞争力的原因，特别是对于大规模模拟。程序运行结束时的计算时间分类显示，[2.x.327]中的积分评估贡献了大约0.92秒，反质量矩阵的应用贡献了0.06秒。此外，对时间步长计算的运输速度的估计又贡献了0.05秒的计算时间。
* 如果我们再使用三个级别的全局细化和总共940万个DoF，最终的统计数据如下（对于修改后的Lax--Friedrichs通量，[2.x.328]，和同一系统的40个核心的双插槽Intel Xeon Gold 6230）。
* [1.x.156]
*
* 每个时间步长，解算器现在需要0.02秒，大约是147k未知数的小问题的25倍。鉴于该问题涉及64倍的未知数，计算时间的增加并不令人惊讶。由于我们也做了8倍的时间步骤，理论上计算时间应该增加512倍。实际增加的是205秒/1.02秒=202。这是因为由于通信开销的原因，小问题的规模不能充分利用40个核心。如果我们研究一下每个时间步长的操作细节，这一点就很清楚了。带有近邻通信的差分算子[2.x.329]的评估时间从0.92秒到127秒，也就是说，增加了138倍。另一方面，应用反质量矩阵和向量更新的成本，完全不需要在MPI进程之间通信，增加了1195倍。这一增长超过了512的理论系数，因为对于较大的尺寸，操作受限于RAM内存的带宽，而对于较小的尺寸，所有的向量都可以进入CPU的缓存。这些数字表明，质量矩阵评估和矢量更新部分几乎消耗了Runge--Kutta阶段的40%的时间。
*
* - 尽管使用了低存储量的Runge--Kutta积分器和合并矢量操作!尽管对[2.x.330]算子使用了过度积分。对于更简单的微分算子和更昂贵的时间积分器，花费在质量矩阵和矢量更新部分的比例也可以达到70%。如果我们以每秒处理的DoF和Runge--Kutta阶段计算一个吞吐量数字，我们得到[1.x.157]这个吞吐量数字非常高，因为简单地将一个向量复制到另一个向量的运行速度只有大约10,000 MDoFs/s。
* 如果我们进入下一个更大的尺寸，有3770万个DoFs，总体模拟时间为2196秒，其中1978秒用于分步。L_h算子的运行时间增加了9.3倍（1179秒对127秒），反质量矩阵和向量更新增加了10.3倍（797对77.5秒）。这种非最佳运行时间增长的原因可以追溯到给定硬件上的缓存效应（40MB的二级缓存和55MB的三级缓存）。虽然不是所有的相关数据都适合940万DoF的缓存（一个向量需要75MB，我们有三个向量加上MatrixFree中的一些额外数据），但还是有能力容纳一个半向量。考虑到现代的缓存比天真的最近使用的策略更复杂（在这种情况下，由于数据是以类似于流的方式使用的，我们几乎没有重复使用），我们可以假设，在940万DoF的情况下，确实有相当一部分数据可以从缓存中交付。对于更大的情况，即使有最佳的缓存，也只有不到10%的数据可以放入缓存中，而且会有相关的性能损失。
*

*[1.x.158][1.x.159] 。


*对于修改后的Lax--Friedrichs通量和测量动量变量的误差，我们得到以下收敛表（对于密度和能量变量，其速率是非常相似的）。
* [2.x.331]
* 如果我们改用Harten-Lax-van Leer通量，其结果如下。[2.x.332]
* 表格显示，我们对两种数值通量都得到了最佳[2.x.333]收敛率。对于[2.x.334]的Lax--Friedrichs通量，误差略小，但对于[2.x.335]的情况则相反；无论如何，在这个测试案例中的差异是相对小的。
* 对于[2.x.336]，我们在最细的网格上的两个通量都达到了[2.x.337]的舍入精度。还要注意的是，误差是绝对的，域长为[2.x.338]，所以相对误差低于[2.x.339]。HLL通量在最高度数上要好一些，这是由于Lax--Friedrichs通量的轻微不准确造成的。Lax--Friedrichs通量对离开域的溶液设置了一个Dirichletcondition，这导致了一个小的人工反射，这在Lax--Friedrichs通量中被强调了。除此之外，我们看到数值通量的影响是很小的，因为元素内部的多项式部分才是通量的主要驱动因素。当试图用高阶DG设置来接近更具挑战性的设置时，通量的有限影响也会产生影响。以[2.x.340]的参数和网格为例，一旦高质部分接近边界，我们在两种通量下都会得到振荡（这反过来会使密度变成负值，使溶液爆炸），这与低阶有限体积的情况相反（[2.x.341]）。因此，任何导致溶液中出现冲击的情况都需要某种形式的限制性或人工耗散。对于另一种选择，见[2.x.342]的教程程序。
*

*[1.x.166][1.x.167] 。


*对于通道中圆柱体周围流动的测试案例，我们需要将第一行代码改为
* [1.x.168]
* 这个测试案例从一个马赫数为0.31的恒定速度和恒定的初始密度的背景场开始；流动将不得不围绕一个圆柱体形式的障碍物。由于我们在圆柱体壁上施加了一个穿透条件，最初迎面撞上圆柱体的气流必须重新排列，这就产生了一个大的声波。下面的图片显示了在全局细化为5级的二维情况下，使用102,400个具有多项式5度的单元和1470万个自由度的所有4个求解变量在0.1、0.25、0.5和1.0时的压力情况（左上至右下）。在时间0.25时，声波已经到达顶壁和底壁并反射到内部。从下壁和上壁反射波的不同距离，我们可以看到Sch&auml;fer-Turek测试案例[2.x.343]所代表的轻微不对称性，圆柱体上方的空间比下方要大一些。在后来的时间里，画面更加混乱，到处都是许多声波。
* [2.x.344]
* 下一张图片显示了在时间1.0时，从通道入口向出口看，在相同的分辨率下，压力的高程图。
*
* -在这里，我们可以看到大量的反射。在图中，可以看到两种类型的波。较大振幅的波对应的是初始不连续性撞击墙壁时发生的各种反射，而与元素大小相似的小振幅波则对应的是数值伪影。它们起源于方案的有限分辨率，并在不连续点穿越高阶多项式的元素时出现。这种效应可以通过提高分辨率来治愈。除此以外，丰富的波浪结构是高阶DG方法的传输精度的结果。
* [2.x.345]
* 在2级全局细化和1,600个单元的情况下，40个MPI进程的网格和网格划分情况如下。
* [2.x.346]
* 当我们在40个核心上运行具有4级全局细化的代码时，我们得到以下输出。
* [1.x.169]
*
* 这里显示的各种数量的准则是对背景场（即初始条件）的偏差[2.x.347]、[2.x.348]和[2.x.349]。运行时间的分布总体上与前一个测试案例相似。唯一略有不同的是，与反质量矩阵和矢量更新相比，[2.x.350]中花费的时间比例较大。这是因为几何体是变形的，矩阵自由框架需要从内存中加载额外的几何体数组，这些数组在仿生网格情况下被压缩。
* 将全局细化的数量增加到5，输出就变成了。
* [1.x.170]
*
* 对性能的影响与分析性测试案例相似
*
* - 理论上，计算时间应该增加8倍，但我们实际上看到时间步骤增加了11倍（219.5秒对2450秒）。这可以追溯到缓存，小的情况下主要适合缓存。一个有趣的效果，是典型的混合了本地通信（积分[2.x.351]）和全局通信（运输速度的计算）的程序，有一些负载不平衡，可以通过查看分别遇到不同阶段的最小和最大时间的MPI等级来观察。排名0报告了 "rk时间步入总数 "部分的最快吞吐量。同时，对于 "计算传输速度 "部分，它似乎是最慢的，比平均水平慢2倍，与较快的等级相比，几乎是4倍。由于后者涉及全局通信，我们可以将这部分的缓慢归因于本地Runge--Kutta阶段在这个等级上进展更快，需要等到其他处理器赶上。然而，无矩阵框架在位于通道出口的affine和Cartesiancells上更快，因为MPI等级较低的单元被分配到这些单元。另一方面，报告Runga--Kutta阶段最高运行时间的等级32拥有靠近圆柱体的弯曲单元，对于这些单元不可能有数据压缩。为了提高吞吐量，我们可以在划分[2.x.352]对象时给不同的单元类型分配不同的权重，甚至可以测量几个时间步骤的运行时间，然后尝试重新平衡。
* 在346,000个Runge--Kutta阶段中，对于1470万DoFs的测试案例，每个Runge--Kutta阶段的吞吐量可以计算到2085 MDoFs/s，比上面报告的2360 MDoFs/s的笛卡尔网格吞吐量稍微慢一些。
* 最后，如果我们增加一个额外的细化，我们记录了以下输出。
* [1.x.171]
*
* "rk time stepping total "部分对应的是2010 MDoFs/s的吞吐量。执行139k时间步长的总体运行时间为20k秒（5.7小时），即每秒7个时间步长。
*
* - 对于有近6000万个未知数来说，这还不算太坏。通过在计算中添加更多的核心，可以实现更多的吞吐量。
*

* [1.x.172][1.x.173] 。


*将通道测试案例切换到3D，并进行3次全局细化，输出结果为
* [1.x.174]
*
* 物理学与二维案例相似，由于引力的作用，在z方向上有轻微的运动。在这种情况下，每个Runge--Kuttastage的吞吐量是[1.x.175] 。
* 由于[2.x.353]项的计算比较昂贵，所以吞吐量比二维情况下要低。这是由于 "度数+2 "点的过度积分和更大比例的面积分（更差的体积-表面比率）以及更昂贵的通量计算。如果我们只考虑反质量矩阵和矢量更新的部分，我们记录到等熵涡旋的2D案例的吞吐量为4857 MDoFs/s，有3770万个未知数，而3D案例的吞吐量为4535 MDoFs/s。性能是相似的，因为这两种情况实际上都受到内存带宽的限制。
* 如果我们进行四级全局细化，我们需要增加进程的数量以适应内存中的所有内容。
*
* - 在这种情况下，计算需要大约350GB的RAM内存。另外，通过增加额外的资源，完成35k个时间步长所需的时间也变得更加可以忍受。因此，我们使用了6个节点，每个节点有40个内核，从而形成了一个有240个MPI进程的计算。
* [1.x.176]
* 这个模拟有近20亿个未知数
*
这个模拟有将近20亿个未知数 * --确实是一个相当大的计算，但每个时间步长仍然只需要大约1.5秒。
*

*[1.x.177][1.x.178]


* 这里介绍的代码可以直接扩展到自适应网格，给定适当的指标来设置细化标志。在声波方程的背景下，类似求解器的大规模自适应性已经由[1.x.179]实现。然而，在目前的情况下，适应性的好处往往仅限于靠近声波起源的早期时间和效果，因为波最终会反射和衍射。这就导致了到处都是陡峭的梯度，类似于湍流，以及或多或少的全球精炼的网格。
* 另一个我们在结果部分没有讨论的主题是不同时间积分方案的比较。该程序提供了四种流动存储Runga--Kutta积分器的变体，每一种都有轻微不同的精度和稳定性行为。在这里实现的方案中，高阶方案提供了额外的精度，但在违反CFL条件之前，每级的步长效率略低。一个有趣的扩展是将这里提出的低存储变量与标准的Runge--Kutta积分器进行比较，或者使用与质量矩阵运算分开运行的矢量运算并比较性能。
*

*[1.x.180][1.x.181]


* 正如在介绍中所提到的，本程序中所采用的修改的Lax--Friedrichs通量和HLL通量只是欧拉方程文献中大量数值通量中的两个变种。一个例子是HLLC通量(Harten-Lax-van Leer-Contact)，它增加了HLL通量或Roe通量中缺少的稀散波的影响。正如介绍中所提到的，数值通量对高阶危险系数模型的影响是值得商榷的（与低阶离散化的情况不同）。
* 为了提高求解器的稳定性，一个相关的改进是也要考虑到空间积分项。上面使用的相当天真的实现方式的一个缺点是，原欧拉方程的能量守恒（在没有冲击的情况下）仅能维持到离散化误差。如果解决方案的分辨率不足，离散化误差会引起数值能量的增加，最终导致离散化的不稳定。这是因为欧拉方程中的项的不精确的数值积分，其中包含有理非线性和来自弯曲单元的高阶内容。摆脱这一困境的方法是所谓的倾斜对称公式，见[2.x.354]的简单变体。倾斜对称意味着在弱式中切换解[2.x.355]和检验函数[2.x.356]的作用，除了一些边界项外，产生原始量的精确负值。在离散设置中，挑战在于当积分只被近似计算时也要保持这种偏斜对称性（在连续情况下，偏斜对称性是部分积分的结果）。偏斜对称的数值方案平衡了保守形式的空间导数[2.x.357]和对某些[2.x.358]的对偶形式的贡献。准确的条款取决于方程和积分公式，在某些情况下，可以通过特殊的倾斜对称有限差分方案来理解。
* 要想开始，有兴趣的读者可以看看https://github.com/kronbichler/advection_miniapp，在那里用deal.II对一个简单的平流方程实现了歪斜对称DG公式。
* [1.x.182][1.x.183] 。
*

*正如介绍中提到的，欧拉方程的解随着马赫数的增加而产生冲击，这需要额外的机制来稳定该方案，例如限制器的形式。除了实际实施限制器或人工粘性方法外，主要的挑战是如何平衡计算，因为限制有问题的单元的振荡所涉及的额外计算会使它们比没有限制的普通DG单元更昂贵。此外，更好地处理不连续的额外数值通量也是一种选择。
* 超音速流动的一个必要条件是适当的边界条件。与介绍中讨论的并在程序中实现的亚音速流出边界不同，超音速流出边界的所有特征都是外在的，所以我们不想规定任何外部数据，[1.x.184] 。
* 在代码中，我们将简单地添加额外的语句
* [1.x.185]
* 在`local_apply_boundary_face()`函数中。
* [1.x.186][1.x.187] 。
*

* 当对欧拉解的兴趣主要在于声波的传播时，围绕着背景状态，即一个给定的密度、速度和能量（或压力）场，将欧拉方程线性化，只计算与这些场的变化，往往是有意义的。这就是航空声学的广泛领域的设定。即使有时对分辨率的要求大大降低，但由于线性化产生了额外的条款，实施起来也会更加复杂。从代码的角度来看，在算子评估中，我们还需要使代码具备线性化的状态。这一信息可以通过分析函数（根据正交点的位置进行评估）或通过类似于解决方案的矢量来提供。基于该向量，我们将创建一个额外的FEE评价对象，从它那里读取并提供正交点的场值。如果背景速度为零，密度为常数，线性化的欧拉方程就会进一步简化，可以等效地写成声波方程的形式。
* 在声音传播的背景下，一个挑战往往是边界条件的定义，因为计算域需要是有限的，而实际模拟往往跨越无限的（或至少大得多的）物理域。传统的Dirichlet或Neumann边界条件会引起声波的反射，最终传播到感兴趣的区域，破坏了解决方案。因此，各种非反射边界条件或海绵层的变体，通常以[1.x.188]的形式出现。
*
* - 在这里，溶液被阻尼而没有反射
*
* - 是常见的。
*

* [1.x.189][1.x.190] 。


* 本教程中介绍的求解器也可以通过添加粘性项扩展到可压缩的Navier--Stokes方程，如[2.x.360]中所述。为了尽量保持这里获得的性能，尽管有额外的椭圆项的成本，例如通过内部罚款方法，我们可以像[2.x.361]教程程序中那样，将基础从FE_DGQ切换到FE_DGQHermite。
*

*[1.x.191][1.x.192]。


* 在本教程中，我们使用了以面为中心的循环。在这里，单元和面的积分在不同的循环中处理，导致对结果向量的多次写入访问，这在现代硬件上是比较昂贵的，因为写入操作通常也会导致隐含的读操作。另一方面，以元素为中心的循环是处理一个单元并直接连续处理其所有的2D面。尽管这种循环意味着通量必须计算两次（对于一个内部面的每一面），但结果向量只需访问一次的事实可能是
*
* - 而事实上，所产生的算法是没有竞赛条件的，因此完全适用于共享内存。
*
* - 已经带来了性能上的提升。如果你对这些高级的话题感兴趣，你可以看看[2.x.362]，在那里我们对前面的教程进行了修改，以便我们可以使用这些功能。
*

* [1.x.193][1.x.194] [2.x.363] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-68_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28]
* [2.x.2]
* [1.x.29]
*[1.x.30][1.x.31]


*[1.x.32][1.x.33]


* 粒子在大量应用的数值模型中发挥着重要作用。粒子通常被用作无质量的追踪器，以显示瞬时流动的动态。它们也可以作为更复杂的有限元模型的一部分发挥固有的作用，如颗粒在单元（PIC）方法[2.x.3]，或者它们甚至可以用来模拟颗粒物质的运动，如离散元素法（DEM）[2.x.4] 。在DEM的情况下，所产生的模型不再与有限元方法有关，而只是导致了一个描述颗粒运动和它们碰撞动态的常微分方程系统。所有这些模型都可以用deal.II的粒子处理能力来建立。
* 在本步骤中，我们使用粒子作为无质量的追踪器来说明涡流的动态。由于粒子是无质量追踪器，每个粒子[2.x.5]的位置由以下的常微分方程（ODE）描述：[1.x.34
* 其中[2.x.6]是粒子[2.x.7]的位置，[2.x.8]是其位置的流速。在本步骤中，使用显式欧拉方法解决这个ODE。得到的方案是：[1.x.35] 。
* 其中[2.x.9]和[2.x.10]分别是粒子[2.x.11]在时间[2.x.12]和[2.x.13]的位置，[2.x.14]是时间步骤。在本步骤中，粒子位置的速度以两种不同的方式获得。
*
* - 通过评估粒子位置的速度函数。
*
* 通过在背景三角图上评估速度函数，并使用有限元支持，在粒子的位置进行内插。
* 第一种方法并不实用，因为速度剖面通常不是以分析方式知道的。第二种方法，基于对粒子位置的内插求解，完全模仿了现实计算流体动力学模拟中的做法，这也是我们在[2.x.15]中对粒子位置的有限元求解进行评估的方式。在这一步中，我们说明了这两种策略。
* 我们注意到，使用四阶Runge-Kutta方法或其他适当的方案对粒子的运动进行时间积分，可以获得更大的精度。  实施一个更先进的时间积分方案将是这一步骤的直接延伸。
*[1.x.36][1.x.37]
*

* 在deal.II中，[2.x.16]是非常简单和灵活的实体，可以用来建立PIC、DEM或任何类型的基于粒子的模型。粒子在现实空间中有一个位置，在它们所在的元素的参考空间中有一个位置，还有一个唯一的ID。在大多数情况下，包含粒子的模拟需要大量的粒子。因此，通过一个集合所有粒子的实体来处理所有的粒子变得很有意义。
* 默认情况下，粒子没有直径、质量或任何其他我们通常期望的物理粒子的物理属性。然而，通过ParticleHandler，粒子可以访问[2.x.18]这个PropertyPool是一个数组，可以用来存储与粒子相关的任意数量的属性。因此，用户可以建立他们自己的粒子解算器，并将所需的属性赋予粒子（例如，质量、电荷、直径、温度等）。在本教程中，它被用来存储流体速度的值和粒子所属的过程ID。
* [1.x.38][1.x.39] 。
*

* 尽管本步骤不是计算密集型的，但包括许多粒子的模拟可能对计算要求很高，需要并行化。本步骤展示了deal.II对粒子的分布式并行能力。
*
* - 在分布式三角形上生成粒子。
*
* - 在处理器之间交换离开本地域的粒子。
*
* - 负载平衡模拟，使每个处理器都有类似的计算负载。这些挑战和它们在deal.II中的解决方案已经在[2.x.19]中详细讨论过了，但我们将在下文中总结它们。
* 当然，还有一些关于简单设置使用粒子的代码的问题。这些问题在 [2.x.20] 中已经基本解决了。一些更高级的技术也将在 [2.x.21] 中讨论。
* [1.x.40][1.x.41] 。
*

* 以可扩展的方式生成分布式粒子并不简单，在找到它们所在的单元之前，必须首先确定它们所属的处理器。deal.II通过[2.x.22]命名空间提供了许多生成粒子的能力。  其中一些粒子生成器只在本地拥有的子域上创建粒子。例如，[2.x.23]在本地子域的每个单元内创建相同参考位置的粒子，[2.x.24]使用全局定义的概率密度函数来确定在本地生成粒子的数量和位置。
* 在其他情况下，如本步骤，粒子必须在单元格上的特定位置生成，而这些单元格可能只属于处理器的一个子集。在大多数情况下，粒子的插入只在有限的时间步数内完成，因此，不构成计算成本的很大一部分。对于这些情况，deal.II提供了方便的[2.x.25]，可以在全局范围内插入粒子，即使粒子不在启动创建粒子的调用的并行进程所拥有的单元中。生成器首先定位粒子所处的子域，确定它们位于哪个单元中，并在处理器之间交换必要的信息，以确保粒子以正确的属性被生成。因此，这种类型的粒子生成可能是通信密集型的。[2.x.26]和[2.x.27]分别使用三角法和相关DoFHandler或四分法的点来生成粒子。用于生成粒子的三角法可以是用于背景网格的同一三角法，在这种情况下，这些函数与上一段所述的[2.x.28]函数非常相似。然而，用于生成粒子的三角形也可以与背景网格的三角形不同（不匹配），这对于生成特定形状的粒子（如本例），或者在两个不同的计算网格之间传递信息（如[2.x.29]）是很有用的。  此外，[2.x.30]类提供了[2.x.31]函数，可以从任意点的矢量和边界盒的全局矢量中插入粒子。在本步骤中，我们在非匹配三角形上使用[2.x.32]函数来插入位于圆盘形状的位置上的粒子。
*[1.x.42][1.x.43]
*

* 当粒子在平行分布式计算中移动时，它们可能会离开本地拥有的子域，需要被转移到新的所有者进程中。这种情况可能以两种非常不同的方式出现。首先，如果先前拥有的进程知道丢失的粒子的新主人（例如，因为粒子从一个处理器的本地拥有的单元移动到一个分布式三角计算的相邻的幽灵单元），那么转移可以作为每个进程和新主人之间的点对点通信来有效处理。每当粒子被分类到新单元时，这种转移就会自动发生。第二，以前的所有者可能不知道粒子被转移到哪个进程。在这种情况下，粒子会被默认丢弃，因为在全局范围内搜索粒子的主人可能会很昂贵。  [2.x.33]展示了这样一个被丢弃的粒子如何仍然可以被收集、解释，并可能被用户重新插入。在本例中，我们通过在时间步骤上施加一个CFL准则来防止第二种情况，以确保粒子最多只能移动到本地进程的幽灵层，因此可以自动发送到邻近的进程。
*[1.x.44][1.x.45]
*

* 在使用粒子的并行分布式计算中出现的最后一个挑战是平衡计算负荷，即在网格上完成的工作，例如解决有限元问题，以及在粒子上完成的工作，例如移动粒子或计算粒子之间或粒子与网格之间的力。默认情况下，例如在[2.x.34]中，deal.II将背景网格尽可能均匀地分配给可用的进程，即平衡每个进程中的单元数量。然而，如果一些单元比其他单元拥有更多的粒子，或者如果一个单元的粒子比其他单元的粒子在计算上要昂贵得多，那么这个问题就不再有效地扩展了（关于我们认为的 "可扩展 "程序的讨论，见[2.x.35]"本术语表条目"）。因此，我们必须应用某种形式的 "负载平衡"，这意味着我们估计与每个单元及其粒子相关的计算负载。然后，重新划分网格时要考虑到这个综合的计算负荷，而不是简单地假设单元的数量[2.x.36] 。
* 在本节中，我们只讨论了分布式计算中针对粒子的挑战。粒子与有限元解决方案共享的并行挑战（并行输出，网格细化过程中的数据传输）可以用其他例子中已经讨论过的有限元问题的解决方案来解决。
*[1.x.46][1.x.47]
*

* 在本步骤中，我们使用粒子作为无质量的追踪器来说明一个特殊的涡流的动力学：Rayleigh--Kothe涡流。这种流动模式通常被用作界面跟踪方法（如流体体积和水平集方法）的复杂测试案例，因为它导致了流体的强烈旋转和拉长 [2.x.37] 。
* 这个Rayleigh-Kothe涡流的流函数[2.x.38]被定义为。
* [1.x.48]其中[2.x.39]是流动周期的一半。二维的速度曲线（[2.x.40]）为：[1.x.49] 。
*
* 该速度剖面在以下动画中得到说明。
* [1.x.50]
*
* 可以看出，由于[2.x.41]项的作用，这个速度会周期性地逆转，材料在每一个长度为[2.x.42]的周期后会结束在其起始位置。我们将精确地运行这个教程程序一个周期，并将最终的粒子位置与初始位置进行比较，以说明这一流动特性。这个例子使用测试案例产生了两个模型，它们对粒子的处理略有不同。第一个模型将精确的分析速度解作为每个粒子的速度。因此，在这个模型中，分配给粒子的速度是没有错误的，在给定的时间内，粒子位置与分析位置的任何偏差都是由于使用时间步进法精确求解粒子的运动方程的错误造成的。在第二个模型中，理论速度场首先被内插到一个有限元矢量空间中（以模拟速度是通过求解一个有限元问题得到的情况，与[2.x.43]中每个粒子的ODE取决于一个有限元解的方式相同）。然后在粒子的位置上对这个有限元 "解决方案 "进行评估，以解决其运动方程。这两种情况之间的差异允许评估所选择的有限元空间是否足够准确，以所选择的粒子平流方案的最佳收敛率来平流粒子，这个问题在实践中对确定组合算法的准确性很重要（例如，见[2.x.44]）。
*

* [1.x.51] [1.x.52]。
* [1.x.53] [1.x.54]。
*


*


* [1.x.55]
*
* 从下面的include文件中，我们导入了ParticleHandler类，该类允许你管理浮在[2.x.45]上的粒子集合（类型为[2.x.45]的对象，代表具有一些附加属性（如id）的点集合）。 命名空间Particles中的方法和类允许人们轻松实现Particle-In-Cell方法和分布式三角形的粒子追踪。
*


* [1.x.56]
*
* 我们导入粒子发生器，使我们能够插入粒子。在本步骤中，粒子是使用非匹配的超壳三角法进行全局插入的。
*


* [1.x.57]
*
* 由于粒子没有形成三角形，它们有自己特定的DataOut类，这将使我们能够把它们写成常用的平行vtu格式（或任何数量的其他文件格式）。
*


* [1.x.58]
*
* [1.x.59] [1.x.60]。


*
* 与[2.x.47]中的做法类似，我们设置了一个持有我们问题的所有参数的类，并从ParameterAcceptor类派生出来，以简化参数文件的管理和创建。   
* ParameterAcceptor范式要求所有的参数都可以被ParameterAcceptor方法写入。为了避免出现很难追踪的bug（比如写成`if (time = 0)`而不是`if(time == 0)`），我们在一个外部类中声明所有的参数，这个类在实际的`ParticleTracking`类之前被初始化，并将其作为`const`引用传递给主类。   
* 该类的构造函数负责该类的成员与ParameterHandler中的相应条目之间的连接。由于使用了[2.x.48]方法，这种连接是微不足道的，但要求这个类的所有成员都是可写的。
*


* [1.x.61]
*
* 该类主要由成员变量组成，描述了粒子跟踪模拟及其离散化的细节。下面的参数是关于输出应该写到哪里，速度的空间离散化（默认是[2.x.49]），时间步长和输出频率（在我们再次生成图形输出之前应该经过多少时间步长）。
*


* [1.x.62]
*
* 我们允许每一个网格都可以独立地被细化。在本教程中，流体网格上没有物理学的解析，其速度是分析计算的。
*


* [1.x.63]
*
* 还有一个任务就是声明我们在输入文件中可以接受哪些运行时参数。由于我们的参数数量非常有限，所有的参数都在同一章节中声明。
*


* [1.x.64]
*
* [1.x.65] [1.x.66]。


*
* 速度曲线是作为一个函数对象提供的。这个函数在这个例子中是硬编码的。
*


* [1.x.67]
*
* Rayleigh-Kothe顶点的速度曲线是随时间变化的。因此，必须从函数对象中收集模拟中的当前时间（t）。
*


* [1.x.68]
*
* [1.x.69] [1.x.70]。



* 我们现在准备介绍我们的教程程序的主类。
*


* [1.x.71]
*
* 这个函数负责在背景网格之上初始生成粒子。
*


* [1.x.72]
*
* 当速度剖面被内插到粒子的位置时，它必须首先用自由度来存储。因此，与其他并行情况一样（例如[2.x.50]），我们在背景网格上初始化自由度。
*


* [1.x.73]
*
* 在其中一个测试案例中，函数被映射到背景网格中，并使用有限元插值来计算粒子位置的速度。这个函数计算三角形的支持点处的函数值。
*


* [1.x.74]
*
* 接下来的两个函数分别负责对速度场在粒子位置插值或分析计算的情况下进行显式欧拉时间积分的步骤。
*


* [1.x.75]
*
* `cell_weight()`函数向三角计算表明在这个单元上预计会发生多少计算工作，因此需要对域进行划分，以便每个MPI等级收到大致相等的工作量（可能不是相等的单元数量）。虽然这个函数是从外部调用的，但它与这个类内部的相应信号相连，因此它可以是 "私有 "的。
*


* [1.x.76]
*
* 以下两个函数分别负责输出粒子的模拟结果和背景网格上的速度曲线。
*


* [1.x.77]
*
* 这个类的私有成员与其他并行处理.II的例子类似。参数被存储为`const`成员。值得注意的是，我们保留了`Vortex`类的成员，因为它的时间必须随着模拟的进行而被修改。
*


*


* [1.x.78]
*
* [1.x.79] [1.x.80]。



* [1.x.81] [1.x.82]。


*
* 构造函数和析构函数是相当微不足道的。它们与 [2.x.51] 中的做法非常相似。我们将我们想要工作的处理器设置为所有可用的机器（`MPI_COMM_WORLD`），并初始化 [2.x.52] 变量，只允许处理器0输出任何东西到标准输出。
*


*


* [1.x.83]
*
* [1.x.84] [1.x.85]。


*
* 这个函数是让我们动态平衡这个例子的计算负载的关键部分。该函数为每个单元赋予一个权重，代表该单元的计算工作。在这里，大部分的工作预计会发生在粒子上，因此这个函数的返回值（代表 "这个单元的工作"）是根据当前单元中的粒子数量来计算。该函数与三角形内部的cell_weight()信号相连，每一个单元将被调用一次，每当三角形在等级之间重新划分领域时（该连接是在该类的generate_particles()函数中创建的）。
*


* [1.x.86]
*
* 我们不给我们不拥有的细胞分配任何权重（即人工或幽灵细胞）。
*


* [1.x.87]
*
* 这决定了粒子工作与单元工作相比有多重要（默认情况下每个单元的权重为1000）。我们将每个粒子的权重设置得更高，以表明在这个例子中，粒子载荷是唯一一个对分配单元很重要的。这个数字的最佳值取决于应用，可以从0（廉价的粒子操作，昂贵的单元操作）到远远大于1000（昂贵的粒子操作，廉价的单元操作，就像本例中假定的那样）。
*


* [1.x.88]
*
* 这个例子没有使用自适应细化，因此每个单元都应该有`CELL_PERSIST`的状态。然而这个函数也可以用来在细化过程中分配负载，因此我们也考虑细化或粗化的单元。
*


* [1.x.89]
*
* [1.x.90] [1.x.91]。


*
* 这个函数生成示踪粒子和这些粒子演化的背景三角图。
*


* [1.x.92]
*
* 我们创建了一个超立方体三角形，并对其进行全局细化。这个三角形覆盖了粒子的全部运动轨迹。
*


* [1.x.93]
*
* 为了在重新划分三角形时考虑粒子，该算法需要知道三件事。
* 1.给每个单元分配多少权重（里面有多少粒子）；2.在运送数据之前如何包装粒子；3.在重新分区之后如何拆开粒子。     
* 我们将正确的函数附加到信号里面 [2.x.53] 这些信号将在每次调用repartition()函数时被调用。这些连接只需要创建一次，所以我们不妨在这个类的构造函数中设置它们，但为了这个例子，我们要把粒子相关的指令分组。
*


* [1.x.94]
*
* 这将初始化粒子所处的背景三角，以及粒子的属性数量。
*


* [1.x.95]
*
* 我们创建了一个粒子三角剖面，它只用于生成将用于插入粒子的点。这个三角形是一个偏离模拟域中心的超壳。这将被用来生成一个充满粒子的圆盘，这将使我们能够很容易地监测由于漩涡而产生的运动。
*


* [1.x.96]
*
* 我们为粒子发生器生成必要的边界盒。这些边界框是用来快速识别插入的粒子位于哪个进程的子域中，以及哪个单元拥有它。
*


* [1.x.97]

* 我们生成一个空的属性向量。一旦粒子生成，我们将把属性赋予它们。
*


* [1.x.98]
*
* 我们在单点正交的位置生成粒子。因此，在每个单元的中心点将生成一个粒子。
*


* [1.x.99]
*
* [1.x.100] [1.x.101]。


*
* 这个函数设置了用于速度插值的背景自由度，并分配了存储整个速度场解决方案的场向量。
*


* [1.x.102]
*
* 这个函数负责将涡流速度场插值到场矢量上。这可以通过使用[2.x.54]函数相当容易地实现。
*


* [1.x.103]
*
* [1.x.104] [1.x.105]。


*
* 我们使用一个分析定义的速度场来整合粒子轨迹。这证明了粒子的一个相对微不足道的用法。
*


* [1.x.106]
*
* 使用粒子迭代器在域中的所有粒子上循环运行
*


* [1.x.107]
*
* 我们用粒子的当前位置计算它们的速度。
*


* [1.x.108]
*
* 这将更新粒子的位置，并将旧位置设置为等于粒子的新位置。
*


* [1.x.109]
*
* 我们在粒子属性中存储了处理器ID（一个标量）和粒子速度（一个矢量）。在这个例子中，这样做纯粹是为了可视化的目的。
*


* [1.x.110]
*
* 与前面的函数不同，在这个函数中，我们通过将自由度处的速度场值插值到粒子的位置来积分粒子的运动轨迹。
*


* [1.x.111]
*
* 我们在所有的本地粒子上循环。虽然这可以直接通过循环所有的单元格来实现，但这将迫使我们循环许多不包含粒子的单元格。相反，我们在所有的粒子上循环，但是，我们得到粒子所在的单元格的参考，然后在该单元格内循环所有的粒子。这使我们能够从 "velocity_field "向量中收集一次速度值，并将其用于该单元中的所有粒子。
*


* [1.x.112]
*
* 接下来，通过评估粒子位置上的有限元解来计算粒子位置上的速度。这基本上是第19步中粒子平流功能的优化版本，但我们不是为每个单元创建正交对象和FEValues对象，而是用手进行评估，这在一定程度上更有效率，而且只对本教程重要，因为粒子工作是整个程序的主要成本。
*


* [1.x.113]
*
* 同样，我们在粒子属性中存储了粒子的速度和处理器的ID，用于可视化目的。
*


* [1.x.114]
*
* [1.x.115] [1.x.116]。


*
* 接下来的两个函数负责将粒子和背景网格用pvtu记录写入vtu。这可以确保在并行启动仿真时，仿真结果可以被可视化。
*


* [1.x.117]
*
* 将解决方案的数据附加到data_out对象上
*


* [1.x.118]
*
* [1.x.119] [1.x.120] 这个函数协调了整个模拟过程。它与其他时间相关的教程程序非常相似
*
* - 以[2.x.55]或[2.x.56]为例。注意，我们使用DiscreteTime类来监控时间、时间步长和[2.x.57]数。这个函数相对来说是比较简单的。
*


*


* [1.x.121]
*
* 我们通过在分析法和插值法的情况下做一个时间步长为0的显式欧拉迭代来设置粒子的初始属性。
*


* [1.x.122]
*
* 粒子是通过循环的方式随时间推移而平移的。
*


* [1.x.123]
*
* 在粒子被移动之后，有必要确定它们现在所在的单元。这可以通过调用[2.x.58]来实现。
*


* [1.x.124]
*
* [1.x.125] [1.x.126]。


*
* 代码的其余部分，即`main()`函数，是标准的。我们注意到，我们用分析速度和插值速度运行粒子跟踪，并产生两种结果
*


* [1.x.127]
* [1.x.128][1.x.129] 。


* 如果你没有在命令行上指定一个参数文件作为参数，程序将尝试默认读取文件 "parameters.prm"，并将执行代码。
* 在任何数量的核心上，模拟输出将看起来像。
* [1.x.130]
*
* 我们注意到，在默认情况下，仿真会以分析速度运行粒子跟踪2000次，然后从头开始，以相同的时间运行速度插值的粒子跟踪。每10次迭代都会写出结果。
*[1.x.131][1.x.132]
*

* 下面的动画显示了粒子在被流场吸引时的轨迹。我们看到，在流场的整个持续时间之后，粒子回到了它们的初始配置，这也是我们所期望的。
* [1.x.133]
*
*[1.x.134][1.x.135]
*

* 下面的动画显示了动态负载平衡的影响。我们清楚地看到，子域适应自己以平衡每个子域的粒子数量。然而，完美的负载平衡并没有达到，部分原因是由于背景网格的粗糙性。
* [1.x.136]
*
*

*[1.x.137][1.x.138]。


* 这个程序强调了在deal.II中处理粒子的一些主要能力，特别是它们用于分布式并行模拟的能力。然而，这个步骤可以以多种方式进行扩展。
*
* 高阶时间积分（例如使用Runge-Kutta 4方法）可以用来提高精度，或者在相同精度下允许更大的时间步长。
*
* - 完整的运动方程（含惯性）可以为粒子求解。在这种情况下，粒子需要有额外的属性，如它们的质量，如[2.x.59]，如果还想考虑与流体的相互作用，它们的直径。
*
* - 耦合到流动求解器。这一步可以直接与任何解决斯托克斯方程（[2.x.60]、[2.x.61]）或纳维-斯托克斯方程（例如[2.x.62]）的并行程序相连接。
*
* - 计算两个模型之间最终粒子位置的差异，可以量化插值误差对粒子运动的影响。
*

* [1.x.139][1.x.140][2.x.63]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-69_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31]
* [1.x.32]
* [2.x.3] [2.x.4] 桑迪亚国家实验室是由霍尼韦尔国际公司的全资子公司桑迪亚国家技术与工程解决方案有限公司根据DE-NA0003525号合同为美国能源部国家核安全局管理和运营的一个多任务实验室。本文件描述了客观的技术结果和分析。文件中可能表达的任何主观观点或意见不一定代表美国能源部或美国政府的观点。[2.x.5]
* [2.x.6] 本教程步骤实现了一个基于一阶精确的[1.x.33]，用于解决欧拉气体动力学方程[2.x.7]。因此，它主要是为教育目的而提出的。对于实际的研究计算，你可能要考虑探索相应的[1.x.35]，使用[1.x.36]技术，以及强保稳（SSP）时间积分，见[2.x.8] （[1.x.37]）。
* [2.x.9]
* [1.x.38][1.x.39][1.x.40]


* 本教程提出了一个解决可压缩欧拉方程的一阶方案，该方案基于三个要素：在有限元背景下对欧拉方程进行[1.x.41]型离散化；基于[1.x.42]局部波速上界的图粘性稳定；以及明确的时间步进。因此，本教程步骤中提出的想法和技术与[2.x.10]中使用的想法和技术有很大的不同，后者侧重于使用自动微分。从编程的角度来看，本教程将关注在大规模计算中发现的一些技术：混合线程-MPI并行化；有效的局部自由度编号；使用工作线程的并发后处理和结果的写出；以及检查点和重新启动。
* 应该指出的是，双曲守恒定律背景下的一阶方案需要太多的自由度来解决模拟流体的某些关键特征，因此，通常只作为高阶方案的基本构件 [2.x.11] 。然而，我们希望读者在进入完整的研究代码（如[2.x.12]中讨论的二阶方案）之前，仍然认为这个教程步骤是一个很好的起点（特别是在编程技术方面）。
*

*[1.x.43][1.x.44][1.x.45]


*可压缩的欧拉气体动力学方程被写成不保守的形式，如下。
* [1.x.46]
* 其中[2.x.13] ，和[2.x.14] ，以及[2.x.15]是间隔维。我们说，[2.x.16]是状态，[2.x.17]是系统的通量。在欧拉方程的情况下，状态由[2.x.18]给出：其中[2.x.19]表示密度，[2.x.20]是动量，而[2.x.21]是系统的总能量。系统的通量[2.x.22]被定义为
* [1.x.47]
*其中[2.x.23]是身份矩阵，[2.x.24]表示张量积。在这里，我们介绍了压力[2.x.25]，在一般情况下，它是由一个封闭式的状态方程定义的。在本教程中，我们将讨论限制在多暴发性气体的范畴内，对于这些气体，压力由以下公式给出
* [1.x.48]
*其中因子[2.x.26]表示[1.x.49]。
*

*[1.x.50][1.x.51]


* 双曲守恒定律，如
* [1.x.52]
*对解理论构成了重大挑战。一个明显的现象是，以变分形式重写方程和用解本身测试并不能导致能量估计，因为配对[2.x.27]（理解为[2.x.28]内积或对偶性配对）不能保证是负的。在这种情况下，诸如能量稳定性或[2.x.29]稳定性之类的概念（一般来说）是没有意义的。
* 历史上，为了加深对双曲守恒定律的理解而采取的最有成效的步骤是假设解决方案被正式定义为[2.x.30]，其中[2.x.31]是抛物线正则化的解决方案。
* [1.x.53]
* 这是因为在物理上[2.x.32]可以被理解为与流体的粘度有关，也就是说，一个表示以不同速度运动的相邻气体粒子对彼此施加的摩擦力的量。欧拉方程本身是在无摩擦的假设下推导出来的，但在物理上可以期望描述摩擦力或粘度消失的极限情况。）这种解决方案的全球存在和唯一性是一个开放的问题。然而，我们至少知道，如果这种粘度解决方案存在，它们必须满足所有[2.x.34]和[2.x.35]的约束条件，其中
* [1.x.55]
* 这里，[2.x.36]表示比熵。
* [1.x.56]
* 我们将把[2.x.37]称为欧拉方程的不变集。换句话说，一个状态[2.x.38]服从密度的正性，内能的正性，以及比熵的局部最小原则。这个条件是一类由精确（粘性）解满足的点状稳定性约束的简化版。我们所说的 "点 "是指该约束必须在域的每一点上得到满足，而不仅仅是在平均（积分，或高阶矩）意义上。
* 在数值逼近的背景下，违反这样的约束会产生可怕的后果：它几乎肯定会导致数值方案的灾难性失败，失去双曲性，以及总体上失去（离散）问题的良好处理性。这也意味着我们计算了一些不能从物理上解释的东西。(例如，我们该如何看待一个具有负密度的计算出的解？)在下文中，我们将制定一个方案，确保[2.x.39]的离散近似值保持在[2.x.40]中。
*

*[1.x.57][1.x.58]


* 根据[2.x.41]、[2.x.42]、[2.x.43]和[2.x.44]，在这一点上，可能会试图将欧拉方程的离散化建立在（半离散）变量公式上。
* [1.x.59]
* 这里，[2.x.45]是一个适当的有限元空间，[2.x.46]是一些线性稳定方法（可能辅以一些临时的冲击捕捉技术，例如见[2.x.47]的第五章和其中的参考文献）。在deal.II教程中描述的大多数时间相关离散化方法都是基于这样一种（半离散）的变分方法。从根本上说，从分析的角度来看，变分离散化被认为是提供某种全局（积分）稳定性的概念，也就是说，一个估计的形式是
* [1.x.60]
*成立，其中[2.x.48]可以代表[2.x.49]准则，或者更广泛地代表一些离散的（可能与网格有关）能量准则。自80年代中期以来，双曲守恒定律的变异离散化非常流行，特别是与SUPG型稳定化和/或上绕技术相结合（见[2.x.50]和[2.x.51]的早期工作）。它们已被证明是在亚声速无冲击体系和类似的良性情况下进行模拟的一些最佳方法。
* <! -- 特别是，教程[2.x.52]侧重于使用dG技术研究亚声速体系中的欧拉气体动力学方程。
*
* - >
* 然而，在跨音速和超音速体系中，以及冲击-流体力学应用中，使用变分方案可能是值得怀疑的。事实上，在写这篇文章的时候，大多数冲击-流体力学代码仍然坚定地以有限体积方法为基础。变分方案在这种极端状态下失败的主要原因是缺乏点可控性。这是因为[1.x.61]对积分量（如矩积分）的约束一般对解的点定性没有影响。虽然其中一些问题可以通过对正确的冲击捕捉方案的（永久）追逐而得到缓解，但类似有限差分和有限体积方案在许多方面仍有优势。
* 因此，在这一教程步骤中，我们偏离了变分方案。我们将提出一个完全代数化的表述（具有ollocation类型方案的味道），该表述在点上保留约束，即。
* [1.x.62]
* 与有限差分/体积方案相反，本步骤实现的方案最大限度地利用了有限元软件的基础设施，在任何空间维度的任何网格上都能工作，并且理论上保证始终工作，没有例外。这说明deal.II的使用范围远远超出了希尔伯特空间的变分方案，deal.II中的大量类、模块和命名空间都可以用于这种目的。
*

*[1.x.63][1.x.64]


* 让[2.x.53]成为标量值的有限维空间，由abasis[2.x.54]跨越，其中。  [2.x.55]和[2.x.56]是识别网格中每个标量自由度（DOF）的所有指数（非负整数）的集合。因此，标量有限元函数[2.x.57]可以写成[2.x.58]与[2.x.59] 。我们引入矢量值近似空间的符号 [2.x.60] 。设[2.x.61]，则可以写成[2.x.62]，其中[2.x.63]和[2.x.64]是标量值的形状函数。
* [2.x.65] 我们特意在符号中不使用矢量值有限元空间。矢量值有限元空间对于PDE系统（例如Navier-Stokes）的变分公式是很自然的。在这种情况下，必须计算的相互作用描述了[1.x.65]：通过对矢量值DoFHandler的适当重新编号（即用FESystem初始化），可以相对容易地计算块矩阵（为了推进解决方案而需要）。然而，在时间明确的搭配型方案（如有限差分和/或本教程中提出的方案）的背景下，必须计算的相互作用可以更好地描述为[1.x.66]（而不是在DOF之间）。此外，在我们的案例中，我们不解决线性方程，以推进解决方案。这使得在理论和/或实践中使用矢量值无限元空间的理由非常少。
* 我们将使用通常的拉格朗日有限元：让[2.x.66]表示所有支持点的集合（见[2.x.67] "thisglossary entry"），其中[2.x.68] 。那么每个索引[2.x.69]都能唯一地识别一个支持点[2.x.70]，以及ascalar-value形状函数[2.x.71] 。有了这个符号，我们可以将（显式时间步进）方案定义为。
* [1.x.67]
* 其中
*


*


*
* - [2.x.72]是块状质量矩阵
*


*


*
* - [2.x.73]是时间步长大小
*


*


*
* - [2.x.74]（注意[2.x.75]）是一个矢量值矩阵，被用来在弱意义上近似通量的发散。
*


*


*
* - [2.x.76]是包含与索引[2.x.77]耦合的所有自由度的邻接列表。换句话说，[2.x.78]包含行索引i的所有非零列索引。[2.x.79]也将被称为 "模版"。
*


*


*
* - [2.x.80]是针对与支持点[2.x.83]相关的状态[2.x.82]评估的双曲系统的通量[2.x.81] 。
*


*


*
* - [2.x.84] 如果[2.x.85]是所谓的[1.x.68]。图形粘度作为一个稳定项，它在某种程度上是[2.x.86]的离散对应物，出现在上述的粘度解的概念中。我们将把[2.x.87]的构造建立在最大局部波速[2.x.88]的估计上，稍后将详细解释。
*


*


*
* - 粘度矩阵的对角线项被定义为 [2.x.89] 。
*


*


*
* - [2.x.90]是[2.x.91]矩阵的归一化，它进入了近似黎曼求解器，我们用它来计算本地波速的近似值[2.x.92]。这将在下文中进一步解释）。
* [2.x.93]的定义远非易事，我们将推迟精确的定义，以便首先关注一些算法和实施问题。我们注意到
*


*


*
* - [2.x.94]和[2.x.95]不随时间变化（只要我们保持离散性不变）。因此，在所谓的[1.x.69]中对这些矩阵/向量进行一次组装并在每个时间步长中重复使用是有意义的。它们是我们所说的离线数据的一部分。
*


*


*
* - 在每个时间步骤中，我们必须评估[2.x.96]和[2.x.97]，这将构成大部分的计算成本。
* 考虑以下伪代码，说明在新的时间[2.x.99]计算解决方案[2.x.98]的可能的直接策略，给定时间[2.x.101]的已知状态[2.x.100] 。
* [1.x.70]
*
* 我们在这里注意到。
*
* - 这种 "装配 "不需要任何形式的正交或单元循环。
*
* - 这里[2.x.102]和[2.x.103]是一个全局矩阵和一个全局向量，分别包含所有向量[2.x.104]和所有状态[2.x.105]。
*
* - [2.x.106]、[2.x.107]和[2.x.108]是假设的实现，它们是收集（来自）或写入（进入）全局矩阵和向量。
*
* - 如果我们假设一个二维空间的笛卡尔网格，一阶多项式空间 [2.x.109] ，并且 [2.x.110] 是一个内部节点（即 [2.x.111] 不在域的边界上），那么。  [2.x.112]应该包含九个状态矢量元素（即与形状函数[2.x.113]相关的补丁/宏元素中的所有状态）。这是与通常的基于单元的循环的主要区别之一，在这种循环中，收集功能（在deal.II的情况下编码为FEValuesBase<dim, spacedim>.get_function_values()）只收集本地单元的值（只是补丁的一个子集）。
* 实际执行将在一个关键方面偏离上述代码：时间步长[2.x.114]必须在CFL条件下选择。
* [1.x.71]
*其中[2.x.115]是一个选定的常数。这将需要在实际执行上述更新之前，在一个单独的步骤中计算所有的[2.x.116]。但核心原则没有改变：我们不在单元格上循环，而是在稀疏图的所有边上循环。
* [2.x.117] 在有限元社区之外，在更广泛的CFD社区，遇到这种全代数方案（即没有双线性形式，没有单元循环，也没有正交）并不罕见。这类方案有丰富的应用历史，也被称为[1.x.72]或[1.x.73]有限元方案（例如，见[2.x.118]的历史概述）。然而，需要强调的是，该方案的代数结构（在本教程中介绍）和节点循环并不只是一个性能上的噱头。实际上，这个方案的结构是出于理论上的需要：该方案的点稳定性证明取决于该方案的特定代数结构。此外，不可能用单元环计算代数粘度[2.x.119]，因为它们非线性地依赖于跨越一个以上单元的信息（叠加不成立：将不同单元的贡献相加不会导致正确结果）。
*[1.x.74][1.x.75]
*

* 在本教程所考虑的例子中，我们使用了三种不同类型的边界条件：基本类边界条件（我们在域的左侧边界规定了一个状态），域的右侧边界的流出边界条件（也称为 "无 "边界条件），以及障碍物顶部、底部和表面的 "反射 "边界条件[2.x.120]（也称为 "滑动 "边界条件）。我们不会过多地讨论必要的和 "无为 "的边界条件，因为它们的实现相对容易，读者可以直接从（有记录的）源代码中获取实现。在这部分介绍中，我们将只关注 "反映 "的边界条件，这在某种程度上是比较棘手的。
* [2.x.121] 在写这篇文章的时候（2020年初），说双曲守恒定律系统的稳定边界条件的分析和实现都是一个开放的问题也不是没有道理的。对于变量公式的情况，稳定的边界条件是那些导致良好的（胁迫的）双线性形式。但对于一般的双曲守恒定律系统（以及本教程中使用的代数式），胁迫性作为稳定性的一个概念没有适用性和/或意义。在本教程中，我们将使用不变集的保存作为稳定性的主要概念，它（至少）保证了离散问题的良好处置性。
* 对于反射边界条件的情况，我们将按以下步骤进行。
*
* - 对于每一个时间步长，完全不满足边界条件的情况下。
*
* - 让[2.x.122]为我们要执行反射边界条件的那部分边界。在时间步骤结束时，我们在一个后处理步骤中强烈地执行反射边界条件，在这个步骤中我们执行投影
* [1.x.76]
* 移除[2.x.123]的法线部分。这是一个有点天真的想法，保留了PDE的一些基本属性，我们在下面解释。
* 毫无疑问，在求解抛物线或椭圆方程时，我们通常通过使它们成为近似空间[2.x.124]的一部分来强制执行必要的（类似于Dirichlet的）边界条件，并将自然的（例如Neumann）边界条件作为变量公式的一部分。我们也知道，边界条件的明确处理（在抛物线型PDEs的背景下）几乎肯定会导致灾难性的后果。然而，在非线性双曲方程的背景下，我们有。
*
* - 比较容易证明（对于反映边界条件的情况）边界条件的明确处理不仅是保守的，而且还能保证对所有[2.x.125]的属性[2.x.126]（良好处理）的保存。这也许是使用边界条件的显式执行的最重要的原因。
*
* 就我们所知：我们不知道有什么数学结果可以证明，在对近似空间直接执行边界条件或使用尼采惩罚方法（例如广泛用于非连续Galerkin方案）进行弱执行时，有可能保证所有[2.x.127]的特性。此外，其中一些传统的想法导致了相当严格的时间步长约束。
*
* - 有足够的数值证据表明，在CFL条件下，对Dirichlet-like边界条件的明确处理是稳定的，不会带来任何精度上的损失。
* 如果[2.x.129]代表欧拉方程，在整个边界上反映边界条件（即[2.x.130]），我们在空间和时间上进行积分[2.x.131]，我们将得到
* [1.x.77]
* 尽管我们不会在整个域中使用反射边界条件，但我们想知道我们对反射边界条件的实现与上面提到的守恒特性是一致的。特别是，如果我们在域的全部范围内使用投影[2.x.133]，可以保证以下离散质量平衡。
* [1.x.78]
*其中[2.x.134]是位于边界的节点上的压力。显然，[2.x.135]是[2.x.136]的离散对应物。我们省略了特征[2.x.137]的证明，但我们简要地提到，它取决于[2.x.139]中提供的[1.x.79][2.x.138]的定义。我们还注意到，这种反映边界条件的执行与最初在[2.x.140]中提出的不同。
*

* [1.x.80] [1.x.81]。
* [1.x.82] [1.x.83]。


*
* 包含文件的集合是相当标准的。最耐人寻味的部分是我们将完全依赖用于MPI并行化的deal.II数据结构，特别是通过[2.x.141]和[2.x.142]包括的[2.x.143]和[2.x.144] 。我们将使用非分布式的 [2.x.145] ( [2.x.146] ) 来存储 [2.x.147] 、 [2.x.148] 和 [2.x.149] 矩阵的局部部分，而不是 Trilinos 或 PETSc 特定的矩阵类。
*


* [1.x.84]
*
* 除了上述deal.II的具体内容外，我们还包括四个提升头文件。前两个是二进制文件，我们将用它来实现检查点和重启机制。
*


* [1.x.85]
*
* 最后两个头文件用于在整数区间内创建自定义迭代器范围。
*


* [1.x.86]

* 对于[2.x.150] [2.x.151] [2.x.152] [2.x.153]和[2.x.154]



* [1.x.87]
*
* [1.x.88] [1.x.89]。


*
* 我们开始实际的实现，先声明所有的类及其数据结构和方法。与之前的例子步骤相比，我们使用了更精细的概念、数据结构和参数封装到各个类中。因此，一个单一的类通常围绕着一个单一的数据结构（如[2.x.155]类中的Triangulation），或者一个单一的方法（如[2.x.157]类的[2.x.156]函数）。我们通常声明参数变量和抓取数据对象为 "私有"，并使其他类使用的方法和数据结构为 "公共"。
*


*

*
* [2.x.158] 一个更简洁的方法是用[1.x.90]来保护对所有数据结构的访问。为了简洁起见，我们不采用这种方法，不过。
*

*
* 我们还注意到，绝大多数的类都是从ParameterAcceptor派生的。这有利于将所有的全局参数纳入一个单一的（全局）ParameterHandler。关于从ParameterAcceptor继承作为全局订阅机制的更多解释可以在 [2.x.159] 中找到。
*


* [1.x.91]
*
* 我们首先定义一些[2.x.160]常量，用于整个教程步骤。这使得我们可以用一个助记符（如[2.x.161] ）而不是一个数值来指代边界类型。
*


*


* [1.x.92]
*
* [1.x.93] [1.x.94].
* [2.x.162]类包含所有关于问题的网格（三角形）和离散化（映射、有限元、正交）的数据结构。如前所述，我们使用ParameterAcceptor类来自动填充特定问题的参数，如几何信息（[2.x.163] 等）或来自参数文件的细化水平（[2.x.164] ）。这就要求我们把数据结构的初始化分成两个函数。我们在构造函数中初始化所有不依赖于参数的东西，并将网格的创建推迟到[2.x.165]方法，一旦所有参数通过[2.x.166]读入，就可以调用该方法。



* [1.x.95]
*
* [1.x.96] [1.x.97]。
* [2.x.167]类包含了离散化中几乎所有不随时间演变的组件，特别是DoFHandler、SparsityPattern、边界图、块状质量矩阵、[2.x.168]和[2.x.169]矩阵。这里，术语[1.x.98]指的是[2.x.170]的所有类成员都有明确定义的值，与当前时间步长无关。这意味着它们可以提前初始化（在[1.x.99]），并且不意味着在以后的任何时间步长中被修改。例如，稀疏模式不应该随着时间的推进而改变（我们在空间上不做任何形式的适应性）。同样地，包络质量矩阵的条目也不应该随着时间的推进而被修改。   
* 我们还计算并存储一个[2.x.171]，其中包含一个从边界自由度的[2.x.172]类型的全局索引到一个由法向量、边界ID和与自由度相关的位置组成的元组的映射。我们必须在这个类中计算和存储这些几何信息，因为我们在后面的代数循环中无法获得几何（或基于单元）的信息。   
*


* [2.x.173] 尽管这个类目前没有任何可以从参数文件中读入的参数，但我们还是从ParameterAcceptor派生出来，并遵循同样的习惯，为Discretization类提供一个[2.x.174] ) 方法。
*


* [1.x.100]
*
* [1.x.101] [1.x.102]。
* 这个类的成员函数是欧拉方程特有的实用函数和数据结构。
*


*
* - 类型别名[2.x.175]被用于状态[2.x.176]。
*


*
* - 类型别名 [2.x.177] 用于通量 [2.x.178] 。
*



* - [2.x.179]函数从状态向量[2.x.181]中提取[2.x.180]并存储在[2.x.182]中。
*



* - [2.x.183]函数从给定的状态向量[2.x.185]计算[2.x.184]。   
* 类成员 [2.x.186] , [2.x.187] 的目的从它们的名字就可以看出。我们还提供了一个函数 [2.x.188] ，用于计算上面提到的波速估计， [2.x.189] ，用于计算 [2.x.190] 矩阵。   
*

*
* [2.x.191] [2.x.192]宏扩展为一个（编译器特定的）pragma，确保在这个类中定义的相应函数总是内联的，也就是说，在每次调用该函数时，函数体都被放在原位，而不会产生调用（和代码指示）。这比[2.x.193]关键字更强，后者或多或少是对编译器的一个（温和的）建议，即程序员认为内联该函数是有益的。  [2.x.194]只应该在像这样的情况下很少使用，而且要谨慎使用，因为我们实际上知道（由于基准测试）内联有关的函数可以提高性能。   
* 最后，我们观察到这是本教程步骤中唯一一个与特定的 "物理学 "或 "双曲守恒定律"（在本例中为欧拉方程）相联系的类。所有其他的类主要是 "离散化 "类，与正在解决的特定物理学问题无关。
*


* [1.x.103]
*
* [1.x.104] [1.x.105]。
* [2.x.195]类的唯一公共数据属性是一个[2.x.196][2.x.197]，用于计算给定点和时间的初始状态。这个函数用于填充初始流场，以及在每个时间步长中明确设置迪里切特边界条件（在流入边界）。   
* 在这个例子的步骤中，我们简单地实现了一个均匀的流场，其方向和一维原始状态（密度、速度、压力）都是从参数文件中读取的。   
* 最好是一次性初始化这个类：初始化/设置参数并定义依赖于这些默认参数的类成员。然而，由于我们不知道参数的实际值，这在一般情况下是没有意义的，也是不安全的（我们希望有机制来检查输入参数的一致性）。我们没有定义另一个[2.x.198]方法在调用[2.x.199]后被调用（手动），而是为类成员[2.x.200]提供了一个 "实现"，当调用[2.x.201]时，每个继承自ParameterAceptor的类都会自动调用。
*


* [1.x.106]
*
* 我们声明一个私有的回调函数，它将与[2.x.202]信号连线。
*


* [1.x.107]
*
* [1.x.108] [1.x.109].
* 有了[2.x.203]类在手，我们现在可以实现上面讨论中介绍的显式时间步进方案。[2.x.204]类的主要方法是<code>make_one_step(vector_type &U, double t)</code>，它接受对状态向量[2.x.205]的引用（作为输入参数）计算更新的解决方案，将其存储在向量[2.x.206]中，并返回选择的[2.x.207]大小[2.x.208] 。   
* 另一个重要的方法是[2.x.209]，主要是为临时向量[2.x.210]分别设置适当的分区和稀疏模式。
*


* [1.x.110]
*
* [1.x.111] [1.x.112].
* 在其核心，Schlieren类实现了类成员 [2.x.211] 。这个类成员的主要目的是计算一个辅助的有限元场[2.x.212]，它在每个节点上由[1.x.113]定义，[2.x.213]原则上可以是任何标量。但在实践中，密度是一个自然的候选量，即[2.x.214] 。[1.x.114]后处理是一种标准的方法，用于增强可视化的对比度，其灵感来自实际的实验X射线和可视化的阴影技术。见[2.x.215]中另一个例子，我们创建了一个Schlieren图）。
*


* [1.x.115]
*
* [1.x.116] [1.x.117]。
* 现在，剩下的就是把[2.x.216],和[2.x.217]类中实现的方法连在一起。我们在一个单独的类[2.x.218]中做到这一点，该类包含每个类的一个对象，并在ParameterAcceptor类的帮助下再次读入一些参数。
*


* [1.x.118]
*
* [1.x.119] [1.x.120]。



* [1.x.121] [1.x.122]。


*
* 手头的第一个主要任务是典型的三合一，即网格生成、数据结构的设置和装配。在这个例子的步骤中，一个值得注意的创新是使用ParameterAcceptor类，我们用它来填充参数值：我们首先初始化ParameterAcceptor类，用一个字符串[2.x.219]来调用它的构造函数，表示参数文件中的正确分段。然后，在构造函数中，每个参数值都被初始化为一个合理的默认值，并通过调用[2.x.220]在ParameterAcceptor类中注册。
*


* [1.x.123]
*
* 注意，在前面的构造函数中，我们只把MPI通信器传给了[2.x.221]，但我们仍然没有初始化底层的几何体/网格。如前所述，我们必须将这项任务推迟到[2.x.222]函数，该函数在[2.x.223]函数用从参数文件中读取的最终值填充所有参数变量后被调用。   
* [2.x.224]函数是最后一个必须实现的类成员。它创建了实际的三角结构，这是一个基准配置，由一个带有盘状障碍物的通道组成，见 [2.x.225] 。我们通过修改[2.x.226]生成的网格来构建几何体。我们参考[2.x.227]，[2.x.228]和[2.x.229]来了解如何创建高级网格。我们首先创建4个临时的（非分布式的）粗略三角形，用[2.x.230]函数将其拼接起来。我们在[2.x.231]处将圆盘作为中心，直径为[2.x.232] 。通道的左下角有坐标( [2.x.233] ) ，右上角有( [2.x.234] , [2.x.235] ) 。
*


* [1.x.124]
*
* 我们必须修复目前位于[2.x.236] [2.x.237]的左边缘，必须将其移至[2.x.238] [2.x.239] 。作为最后一步，边界必须被着色，右边是[2.x.240]，[2.x.241]是上下外边界和障碍物。
*


*


* [1.x.125]
*
* [1.x.126] [1.x.127]。


*
* 在[2.x.242]的构造函数中，除了在初始化列表中初始化相应的类成员外，没有做太多的工作。
*


* [1.x.128]
*
* 现在我们可以初始化DoFHandler，为本地拥有的和本地相关的DOF提取IndexSet对象，并初始化一个[2.x.243]对象，这是分布式向量需要的。
*


* [1.x.129]
*
* [1.x.130] [1.x.131]。


*
* 我们现在可以为我们的矩阵创建稀疏模式了。有一些特殊的地方需要详细解释一下。我们避免使用分布式矩阵类（例如由Trilinos或PETSc提供的），而是依靠deal.II自己的SparseMatrix对象来存储所有矩阵的局部部分。这一设计决定的动机是：(a)我们实际上从未进行过矩阵-向量乘法，(b)我们总是可以在一个给定的MPI等级上专门组装矩阵的局部部分。相反，我们将计算非线性更新，同时迭代连通性模版的（局部）部分；这是deal.II自己的SparsityPattern专门为之优化的任务。     
* 不过，这种设计考虑有一个注意事项。让deal.II SparseMatrix类变得快速的是SparsityPattern中使用的[1.x.132]（见[2.x.244]）。不幸的是，这与全局分布式索引范围不相称，因为具有CSR的稀疏模式不能在索引范围内包含 "洞"。deal.II提供的分布式矩阵通过将全局索引范围转化为连续的局部索引范围来避免这一点。但这正是我们在迭代模版时想要避免的索引操作类型，因为它产生了可衡量的开销。     
* [2.x.245]类已经实现了从全局索引范围到连续的局部（每个MPI等级）索引范围的转换：我们不必重新发明车轮。我们只需要使用这种转换能力（一次，而且只有一次），以便为连续的索引范围创建一个 "本地 "稀疏模式 [2.x.246] [2.x.247] [2.x.248] 。这种能力可以通过[2.x.249]函数调用。一旦使用本地索引创建了稀疏模式，剩下要做的就是确保（在实现我们的散布和聚集辅助函数时）我们总是通过调用[2.x.250]来访问分布式向量的元素，这样我们就完全避免了索引转换，并完全使用本地索引进行操作。
*


*


* [1.x.133]
*
* 我们必须手工创建 "局部 "的稀疏模式。因此，我们在所有本地拥有的和重影的单元上进行循环（见 [2.x.251] GlossArtificialCell），并提取与单元DOF相关的（全局） [2.x.252] 并使用 [2.x.253] 重新编号。       
*

*
* [2.x.254] 在本地拥有的DOF的情况下，这种重新编号包括应用一个移位（即我们减去一个偏移量），现在它们将成为整数区间[2.x.255] [2.x.256] [2.x.257] 中的一个数字。然而，在重影道次的情况下（即不是本地拥有的），情况就完全不同了，因为与重影道次相关的全局指数（一般来说）不会是一个连续的整数集。
*


*


* [1.x.134]
*
* 这就结束了DoFHandler和SparseMatrix对象的设置。接下来，我们要组装各种矩阵。我们在一个匿名命名空间中定义了一些辅助函数和数据结构。
*


*


* [1.x.135]
*
* [2.x.258]类，将用于使用WorkStream组装离线数据矩阵。它充当一个容器：它只是一个结构，WorkStream在其中存储本地单元的贡献。请注意，它还包含一个类成员 [2.x.259] ，用于存储计算边界法线所需的局部贡献。
*


*


* [1.x.136]
*
* 接下来我们介绍一些辅助函数，它们都是关于读写矩阵和向量条目的。它们的动机主要是提供稍微有效的代码和 [1.x.137] 否则有些乏味的代码。
*

*
* 我们介绍的第一个函数 [2.x.260] ，将用于读取SparsityPattern迭代器 [2.x.261] 指向的条目所存储的值。该函数绕过了SparseMatrix接口中的一个小缺陷。SparsityPattern关注的是以CRS格式存储的稀疏矩阵的所有索引操作。因此，迭代器已经知道存储在SparseMatrix对象中的低级向量中相应矩阵条目的全局索引。由于SparseMatrix中缺乏直接用SparsityPattern迭代器访问该元素的接口，不幸的是我们必须创建一个临时的SparseMatrix迭代器。我们只需在[2.x.262]函数中隐藏这一点。
*


*


* [1.x.138]
*
* [2.x.263]助手是[2.x.264]的逆向操作：给定一个迭代器和一个值，它在矩阵中设置迭代器所指向的条目。
*


*


* [1.x.139]
*
* [2.x.265] : 我们注意到，[2.x.266] 。如果 [2.x.267] 则 [2.x.268] .这基本上意味着我们需要每个空间维度的一个矩阵来存储[2.x.269]向量。对于矩阵[2.x.270]也有类似的观察。[2.x.271]的目的是检索这些条目并将其存储到[2.x.272]中，以方便我们使用。
*


*


* [1.x.140]
*
* [2.x.273]（第一个接口）：这个第一个函数签名，有三个输入参数，将被用来检索矩阵的各个组成部分[2.x.274]。[2.x.275]和[2.x.276]的功能非常相同，但它们的背景不同：函数[2.x.277]不依赖迭代器（实际上知道指向的值），而是依赖条目的索引[2.x.278]，以便检索其实际值。我们应该期望[2.x.279]比[2.x.280]稍微贵一些。[2.x.281]的使用将限于计算代数粘度[2.x.282]的任务，即当[2.x.283]和[2.x.284]都位于边界的特殊情况。     
*

*
* [2.x.285] 读者应该知道，访问一个矩阵的任意[2.x.286]项（比如说Trilinos或PETSc矩阵）一般来说是很昂贵的，无法接受。这里是我们可能想要关注复杂度的地方：我们希望这个操作有恒定的复杂度，这就是目前使用deal.II矩阵的实现的情况。
*


*


* [1.x.141]
*
* [2.x.287]（第二个接口）：这第二个函数签名有两个输入参数，将用于收集节点[2.x.288]的状态，并作为[2.x.289]返回，以方便我们使用。
*


*


* [1.x.142]
*
* [2.x.290] ：这个函数有三个输入参数，第一个参数是指 "全局对象"（比如一个本地拥有的或本地相关的矢量），第二个参数可以是一个[2.x.291] ，最后一个参数代表全局对象的索引。这个函数主要用于将更新的节点值（存储为[2.x.292]）写入全局对象中。
*


*


* [1.x.143]

* 我们现在可以将存储在[2.x.293]中的所有矩阵集合起来：块状质量条目 [2.x.294] ，矢量值矩阵 [2.x.295] 和 [2.x.296] ，以及边界法线 [2.x.297] 。   
* 为了利用线程并行化，我们使用了[2.x.298]"多处理器的并行计算 "中详述的WorkStream方法来访问共享内存。按照惯例，这需要定义
*


*
* - 抓取数据（即进行计算所需的输入信息）：在这种情况下，它是[2.x.299] 。
*


*
* - 工作者：在我们的例子中，这是一个[2.x.300]函数，它实际上是根据从头数据计算本地（即当前单元）贡献。
*


*
* - 拷贝数据：一个包含所有本地汇编贡献的结构，在这里是[2.x.301] 。
*


*
* - 一个复制数据的例程：在这种情况下，它是[2.x.302]，负责将这些局部贡献实际复制到全局对象中（矩阵和/或矢量）。
* 下面的大部分行是用来定义工作器 [2.x.303] 和复制数据例程 [2.x.304] 的。关于WorkStream框架没有太多可说的，因为绝大多数想法在[2.x.305]、[2.x.306]和[2.x.307]等文件中都有合理的记载。   
* 最后，假设[2.x.308]是边界的一个支持点，（节点）法线定义为：。   
*


* [1.x.144]

* 我们将首先计算这个表达式的分母，并将其存储在[2.x.309]中。我们将在一个后置循环中对这些向量进行归一化处理。
*


*


* [1.x.145]

* 下面是WorkStream所需要的初始化划痕数据的内容
*


*


* [1.x.146]
*
* 我们以通常的方式计算凑合质量矩阵项[2.x.310]和向量[2.x.311]的局部贡献。
*


* [1.x.147]
*
* 现在我们要计算边界法线。请注意，除非该元素在域的边界上有面，否则下面的循环不会有什么作用。
*


* [1.x.148]
*
* 注意，"normal "将只代表来自形状函数phi_j的支持中的一个面的贡献。所以我们不能在这里对这个局部贡献进行归一化，我们必须 "原封不动 "地接受它，存储它并将它传递给复制数据的程序。正确的归一化需要在节点上增加一个循环。这在下面的复制函数中完成。
*


* [1.x.149]
*
* 最后，我们按照WorkStream的要求提供了一个copy_local_to_global函数
*


* [1.x.150]
*
* 此时我们已经完成了[2.x.312]和[2.x.313]的计算，但到目前为止，矩阵[2.x.314]只包含矩阵[2.x.315]的一个副本。这不是我们真正想要的：我们必须对其条目进行标准化。此外，我们还没有填充矩阵[2.x.316]的条目，存储在地图[2.x.317]中的向量也没有被规范化。     
* 原则上，这只是离线数据，过度优化它们的计算并没有什么意义，因为它们的成本会在我们将要使用的许多时间步骤中得到摊销。然而，计算/存储矩阵[2.x.318]的条目是说明线程并行节点循环的完美选择。
*


*
* - 我们要访问网格/稀疏图中的每个节点[2.x.319]。
*


*
* - 对于每一个这样的节点，我们要访问每一个[2.x.320]，以便[2.x.321] 。     
* 从代数的角度来看，这相当于：访问矩阵中的每一行，并对其中每一行在列上执行循环。节点循环是本教程步骤的一个核心主题（见介绍中的伪代码），它将一次又一次地重复。这就是为什么现在是介绍它们的恰当时机。     
* 我们有线程并行化能力[2.x.322]，在某种程度上比WorkStream框架更通用。特别是，[2.x.323]可以用于我们的节点循环。这个功能需要四个输入参数，我们详细解释（针对我们的线程并行节点循环的具体情况）。
*


*
* - 迭代器[2.x.324]指向一个行索引。
*


*
* - 迭代器[2.x.325]指向一个数字较高的行索引。
*


*
* - 函数[2.x.326]和[2.x.327]在前面两个子弹中定义的结束和开始迭代器所跨越的范围内定义了一个子范围）对该子范围内的每个迭代器应用一个操作。我们也可以把[2.x.328]称为 "工作者"。
*


*
* - Grainsize：每个线程处理的最小迭代器数量（在本例中代表行）。我们决定最小为4096行。     
* 这里的一个小注意事项是，提供给[2.x.329]和[2.x.330]的迭代器必须是随机访问迭代器：在内部，[2.x.332]将把[2.x.333]和[2.x.334]迭代器定义的范围分成子范围（我们希望能够以恒定的复杂性读取这些子范围的任何条目）。为了提供这样的迭代器，我们求助于[2.x.335]。
* 下面这段代码的大部分是用来定义 "工作者"[2.x.336]：即在子范围的每一行应用的操作。给定一个固定的[2.x.337]，我们要访问这一行的每一列/每一个条目。为了执行这样的列-循环，我们使用标准库中的[1.x.151]，其中。
*


*
* - [2.x.338]给我们一个迭代器，从行的第一列开始。
*


*
* - [2.x.339]是一个迭代器，指向该行的最后一列。
*


*
* - [2.x.340]要求的最后一个参数是应用于这种行的每个非零条目（这里是一个lambda表达式）的操作。     
* 我们注意到，[2.x.341]将对不相交的行集（子行）进行操作，我们的目标是写进这些行。由于我们要进行的操作的简单性质（法线的计算和存储，以及条目[2.x.342]的规范化），线程在试图写同一个条目时不会发生冲突（我们不需要一个调度器）。
*


* [1.x.152]
*
* 第一个列循环：我们计算并存储矩阵norm_matrix的条目，并将归一化的条目写入矩阵nij_matrix中。
*


* [1.x.153]
*
* 最后，我们对存储在[2.x.343]中的向量进行标准化处理。这个操作没有被线程并行化，因为它既不能说明任何重要的概念，也不能带来任何明显的速度提升。
*


* [1.x.154]
*
* 在这一点上，我们已经很好地完成了与离线数据有关的事情。
*


* [1.x.155] [1.x.156]。


*
* 在本节中，我们描述了[2.x.344]类的成员的实现。这里的大部分代码都是针对理想气体法的可压缩欧拉方程的。如果我们想把[2.x.345]重新用于不同的守恒定律（例如：浅水方程），那么这个类的大部分实现就必须改变。但是大多数其他的类（特别是那些定义循环结构的类）将保持不变。   
* 我们首先实现一些小的成员函数来计算[2.x.346]、[2.x.347]和系统的通量[2.x.348]。这些函数中的每一个的功能都可以从它们的名字中不言自明。
*


*


* [1.x.157]
*
* 现在我们讨论 [2.x.349] 的计算。黎曼问题的最大波速的尖锐上界的分析和推导是一个非常技术性的工作，我们不能在本教程中包括对它的高级讨论。在这部分文档中，我们将仅限于简述我们实现函数的主要功能，并指出具体的学术参考文献，以帮助（感兴趣的）读者追溯这些想法的来源（和适当的数学理由）。   
* 一般来说，获得最大波速的尖锐保证上界需要解决一个相当昂贵的标量非线性问题。这通常是用一个迭代求解器来完成的。为了简化本例中的表述，我们决定不包括这样的迭代方案。相反，我们将只是使用一个初始猜测作为最大波速的上限猜测。更确切地说，[2.x.350]的方程（2.11）（3.7）、（3.8）和（4.3）足以定义一个有保证的最大波速上界。这个估计值通过调用函数 [2.x.351] 返回。在其核心部分，这种上界的构建使用了所谓的中间压力的二重化近似 [2.x.352] ，例如，见公式（4.46），在 [2.x.353] 的第128页。   
* 由[2.x.354]返回的估计值保证是一个上界，它在一般情况下是相当尖锐的，而且总体上对我们的目的来说是足够的。然而，对于一些特定的情况（特别是当其中一个状态接近真空条件时），这样的估计将是过于悲观的。这就是为什么我们使用第二个估计来避免这种退化，它将被调用到函数 [2.x.355] 。这里最重要的函数是[2.x.356]，它取的是[2.x.357]和[2.x.358]所返回的估计值之间的最小值。   
* 我们再次开始定义几个辅助函数。   
* 第一个函数接收一个状态[2.x.359]和一个单位向量[2.x.360]，并计算单位向量方向上的[1.x.158]一维状态。
*


* [1.x.159]
*
*为此，我们必须将动量改为[2.x.361]，并且必须从总能量中减去垂直部分的动能。
*


* [1.x.160]
*
* 我们以[1.x.161]变量而不是保留量来返回一维状态。返回的数组包括密度 [2.x.362] 、速度 [2.x.363] 、压力 [2.x.364] 和局部音速 [2.x.365] 。
*


*


* [1.x.162]
*
* 在这一点上，我们还定义了两个小函数，用来返回一个双数的正负部分。
*


*


* [1.x.163]
*
* 接下来，我们需要两个局部文数，它们是以原始状态[2.x.366]和给定压力[2.x.367][2.x.368]公式（3.7）定义的。


* [1.x.164]
* 这里，[2.x.369]表示给定参数的正数部分。
*


*


* [1.x.165]
*
* 阿纳罗格 [2.x.370] 公式（3.8）。


* [1.x.166]

*


*


* [1.x.167]
*
* 剩下的就是计算从左和右原始状态计算出的[2.x.371]和[2.x.372]的最大值（[2.x.373] 公式（2.11）），其中[2.x.374]由[2.x.375] 公式（4.3）给出。
*


*


* [1.x.168]
*
* 我们计算出最大波速的第二个上界，一般来说，它不像二重化估计那样尖锐。但在接近真空的条件下，当二赖子近似值可能达到极端值时，它将拯救一切。


* [1.x.169]



* [2.x.376] 常数5.0乘以声速的最大值是[1.x.170]一个临时的常数，[1.x.171]一个调谐参数。它为任何 [2.x.377] 定义了一个上限。请不要玩弄它!
*


*


* [1.x.172]

* 下面是我们要调用的主函数，以便计算[2.x.378]。我们简单地计算两个最大的波速估计值并返回最小值。
*


*


* [1.x.173]
*
* 我们通过定义静态数组[2.x.379]来结束本节，这些静态数组包含描述我们的状态向量的组件名称的字符串。我们对维度一、二和三进行了模板特化，这在后面的DataOut中被用来命名相应的组件。
*


*


* [1.x.174]
*
* [1.x.175] [1.x.176]。


*
* 在我们讨论正向欧拉方案的实现之前，最后一个准备步骤是简单地实现`InitialValues`类。   
* 在构造函数中，我们用默认值初始化所有参数，为`ParameterAcceptor`类声明所有参数，并将[2.x.380]槽连接到相应的信号。   
* [2.x.381]槽将在调用[2.x.382]后从ParameterAceptor中调用 在这方面，它的使用适合于参数必须被后处理（在某种意义上）或必须检查参数之间的某些一致性条件的情况。
*


*


* [1.x.177]
*
* 到目前为止，[2.x.383]的构造函数已经为两个私有成员[2.x.384]定义了默认值，并将它们添加到参数列表中。但是我们还没有定义唯一一个我们真正关心的公共成员的实现，也就是[2.x.385]（我们将调用这个函数来实际评估网格节点的初始解）。在这个函数的顶部，我们必须确保提供的初始方向不是零向量。   
*


* [2.x.386] 正如所评论的，我们可以避免使用方法 [2.x.387] 并定义一个类成员 [2.x.388] ，以便定义 [2.x.389] 的实现。但为了说明问题，我们想在这里记录一种不同的方式，并使用ParameterAcceptor的回调信号。
*


*


* [1.x.178]
*
* 接下来，我们用一个计算均匀流场的lambda函数实现[2.x.390]函数对象。为此，我们必须将给定的原始1d状态（密度[2.x.391]、速度[2.x.392]和压力[2.x.393]）转换为保守的n维状态（密度[2.x.394]、动量[2.x.395]和总能量[2.x.396]）。
*


*


* [1.x.179]
*
* [1.x.180] [1.x.181]。


*
* [2.x.397]类的构造函数不包含任何令人惊讶的代码。
*


*


* [1.x.182]
*
* 在类成员 [2.x.398] 中，我们初始化临时向量 [2.x.399] 。向量[2.x.400]将用于在其内容与旧向量交换之前临时存储解决方案的更新。
*


*


* [1.x.183]

* 现在是实现前向欧拉步骤的时候了。给出一个在时间[2.x.402]的旧状态[2.x.401]的（可写引用），我们就地更新状态[2.x.403]并返回所选择的时间步长。我们首先声明一些对各种不同变量和数据结构的只读引用。我们这样做主要是为了有更短的变量名称（例如，[2.x.404]而不是[2.x.405] ）。
*


*


* [1.x.184]
*
* [1.x.185]:计算[2.x.406]图的粘性矩阵。     
* 必须强调的是，粘度矩阵必须是对称的，即[2.x.407] 。在这方面，我们在此注意到，[2.x.408]（或等同于[2.x.409]）只要[2.x.410]或[2.x.411]是位于远离边界的支持点。在这种情况下，我们可以通过构造检查出[2.x.412]，这保证了属性[2.x.413] 。     
* 然而，如果两个支持点[2.x.414]或[2.x.415]刚好都位于边界上，那么，等式[2.x.416]和[2.x.417]就不一定成立。解决这个难题的唯一数学上安全的方法是计算它们两个[2.x.418]和[2.x.419]，并取其最大值。     
* 总的来说，[2.x.420]的计算是相当昂贵的。为了节省一些计算时间，我们利用了粘度矩阵必须是对称的这一事实（如上所述）：我们只计算[2.x.421]的上三角条目，并将相应的条目复制到下三角的对应项。     
* 我们再次使用[2.x.422]进行线程并行的for循环。我们在讨论矩阵的组装[2.x.423]和上面[2.x.424]的归一化时介绍的几乎所有并行遍历的想法在这里又被用到了。     
* 我们再次定义了一个 "工作者 "函数[2.x.425]，计算列索引的子范围[i1, i2]的黏度[2.x.426]。
*


* [1.x.186]
*
* 对于一个给定的列索引i，我们遍历从[2.x.427]到[2.x.428]的稀疏模式的列。
*


* [1.x.187]

* 我们只计算[2.x.429]，如果[2.x.430]（上三角条目），随后将数值复制到[2.x.431]。
*


* [1.x.188]
*
* 如果两个支持点刚好都在边界上，我们也要计算[2.x.432]，然后取[2.x.433] 。在这之后，我们可以最终设定上三角和下三角的条目。
*


* [1.x.189]
*
* [1.x.190]:计算对角线条目 [2.x.434] 和 [2.x.435] 。
*

*
* 到目前为止，我们已经计算了矩阵[2.x.436]的所有非对角线条目。我们仍然需要填补其定义为[2.x.437]的对角线项。我们再次使用[2.x.438]来实现这一目的。在计算[2.x.439]s的同时，我们也确定了最大的可接受的时间步长，定义为[1.x.191] 注意[2.x.440]的操作本质上是全局的，它在所有节点上操作：首先我们必须在所有线程（特定节点的）上取最小值，然后我们必须在所有MPI进程上取最小值。在目前的实现中。
*


*
* - 我们将[2.x.441]（每个节点）存储为[1.x.192]。[2.x.442]的内部实现将在一个以上的线程试图同时读取和/或写入[2.x.443]时负责保护任何可能的竞赛条件。
*


*
* - 为了取所有MPI进程的最小值，我们使用了效用函数 [2.x.444] 。
*


*


* [1.x.193]
*
* on_subranges()将在每个线程上单独执行。因此，变量[2.x.445]被存储在线程本地。
*


*


* [1.x.194]
*
* 我们在对角线位置存储d_ij项的负和
*


* [1.x.195]

* 并计算最大的局部时间步长 [2.x.446] 。
*


* [1.x.196]
*
* [2.x.447] 包含为（线程局部）子范围计算的最大可能的时间步长。在这一点上，我们必须在所有线程上同步该值。这就是我们使用的[1.x.197] [1.x.198]更新机制。
*


* [1.x.199]
*
* 在所有线程完成后，我们可以简单地在所有MPI进程中同步该值。
*


*


* [1.x.200]
*
* 这是验证计算出的[2.x.448]确实是一个有效的浮点数的好地方。
*


* [1.x.201]
*
* [1.x.202]:执行更新。


*
* 在这一点上，我们已经计算了所有的粘性系数 [2.x.449] 并且我们知道最大的可接受的时间步长 [2.x.450] 。这意味着我们现在可以计算更新。
* [1.x.203]
* 这个更新公式与介绍中讨论的略有不同（在伪代码中）。然而，可以证明这两个公式是代数等价的（它们将产生相同的数值）。我们更倾向于这第二个公式，因为它具有自然的取消属性，可能有助于避免数字伪数的出现。
*


*


* [1.x.204]
*
* [1.x.205]:修复了边界状态。
*

*
* 作为正向欧拉方法的最后一步，我们必须修复所有的边界状态。正如在介绍中所讨论的，我们
*


*
* - 在时间上前进，完全不满足边界条件。
*


*
* - 在时间步骤结束时，在后处理步骤中强烈执行边界条件。     
* 在这里，我们计算校正[1.x.206]，它消除了[2.x.451]的法线成分。
*


*


* [1.x.207]
*
* 我们只对本地拥有的子集进行迭代。
*


* [1.x.208]
*
* 在自由滑移的边界上，我们去除动量的法向分量。
*


* [1.x.209]
*
* 在Dirichlet边界上，我们强烈地强制执行初始条件。
*


* [1.x.210]
*
* [1.x.211]:我们现在更新所有MPI行列的幽灵层，将临时向量与解决方案向量交换 [2.x.452] （将通过引用返回），并返回所选择的时间步长 [2.x.453] 。
*


*


* [1.x.212]
*
* [1.x.213] [1.x.214]。
* 在不同的时间间隔内，我们将输出解决方案的当前状态[2.x.454]以及所谓的Schlieren图。[2.x.455]类的构造函数同样不包含任何惊喜。我们只是提供默认值并注册两个参数。
*


*
* - schlieren_beta：是一个临时的正向放大系数，以增强可视化中的对比度。它的实际值是一个品味问题。
*


*
* - schlieren_index: 是一个整数，表示我们将使用状态[2.x.456]中的哪个组件来生成可视化。
*


*


* [1.x.215]
*
* 同样，[2.x.457]函数初始化了两个临时向量（[2.x.458] ）。
*


*


* [1.x.216]
*
* 我们现在讨论类成员[2.x.459]的实现，它基本上是取状态向量[2.x.460]的一个分量并计算该分量的Schlieren指标（Schlieren指标的公式可以在类的声明[2.x.461]之前找到）。我们首先注意到这个公式需要 "结点梯度" [2.x.462] 。然而，对于[2.x.463]有限元函数来说，梯度的节点值并没有定义。更一般地说，梯度的点值对[2.x.464]函数没有定义。我们可以使用最简单的技术来恢复节点的梯度，即加权平均法。
* [1.x.217]
* 其中[2.x.465]是形状函数[2.x.466]的支持，[2.x.467]是权重。权重可以是任何正函数，如[2.x.468]（这将允许我们恢复通常的均值概念）。但是像往常一样，我们的目标是尽可能多地重复使用离线数据。在这个意义上，最自然的权重选择是[2.x.469] 。将这种权重的选择和扩展[2.x.470]插入[2.x.471]中，我们得到:
* [1.x.218]
* 使用这最后一个公式，我们可以恢复平均的节点梯度，而不需要借助于任何形式的正交。这个想法与基于边缘的方案（或代数方案）的整体精神非常吻合，我们希望尽可能直接对矩阵和向量进行操作，尽量避免组装双线性形式、单元环、正交，或在输入参数（上一时间步的状态）与计算更新所需的实际矩阵和向量之间的任何其他中间结构/操作。   
* 第二件要注意的事情是，我们必须计算全局最小和最大 [2.x.472] 和 [2.x.473] 。按照在类成员[2.x.474]中用于计算时间步长的相同思路，我们将[2.x.475]和[2.x.476]定义为原子倍数，以便解决线程之间的任何冲突。像往常一样，我们使用[2.x.477]和[2.x.478]来寻找所有MPI进程中的全局最大/最小值。   
* 最后，不可能在所有节点上进行一次循环来计算Schlieren指标。整个操作需要在节点上进行两次循环。
*


*


*


*


*


*


*



* - 第一个循环计算[2.x.479]中所有[2.x.480]的网格，以及边界[2.x.481]和[2.x.482] 。
*


*
* - 第二个循环最后用公式计算Schlieren指标
* [1.x.219]
* 这意味着我们将不得不为每一个阶段定义两个工作者[2.x.483]。
*


*


* [1.x.220]
*
* 我们将当前MPI进程中的r_i_max和r_i_min定义为原子双数，以避免线程之间的竞赛条件。
*


* [1.x.221]
*
* 第一个循环：计算每个节点的平均梯度以及梯度的全局最大值和最小值。
*


* [1.x.222]
*
* 我们在自由滑移边界固定梯度r_i，类似于我们在正向欧拉步骤中固定边界状态的方式。这可以避免在自由滑移边界的Schlieren图中出现尖锐的、人为的梯度，这纯粹是一种外观上的选择。
*


*


* [1.x.223]
*
* 我们提醒读者，我们对节点梯度本身不感兴趣。我们只想得到它们的规范，以便计算Schlieren指标（用块状质量矩阵加权 [2.x.484] ）。
*


* [1.x.224]
*
* 我们将current_r_i_max和current_r_i_min（在当前子范围内）与r_i_max和r_i_min（对于当前MPI进程）进行比较，并在必要时进行更新。
*


*


* [1.x.225]
*
* 并在所有MPI进程中同步化[2.x.485]。
*


*


* [1.x.226]
*
* 第二个循环：我们现在有矢量[2.x.486]和标量[2.x.487]可供我们使用。这样我们就可以实际计算Schlieren指标了。
*


*


* [1.x.227]

* 最后，交换幽灵元素。
*


* [1.x.228]
*
* [1.x.229] [1.x.230]。
* 在实现了所有的类之后，现在是时候创建一个[2.x.488]、[2.x.489]和[2.x.490]的实例，并在一个循环中运行正向欧拉步骤。   
* 在[2.x.491]的构造函数中，我们现在初始化所有类的实例，并声明一些控制输出的参数。最值得注意的是，我们声明了一个布尔参数[2.x.492]，它将控制程序是否试图从中断的计算中重新启动。
*


*


* [1.x.231]
*
* 我们首先在匿名命名空间中实现一个辅助函数[2.x.493]，用于在终端输出带有一些漂亮格式的信息。
*


*


* [1.x.232]
*
* 有了[2.x.494]，现在是时候实现[2.x.495]了，它包含我们程序的主循环。
*


*


* [1.x.233]
*
* 我们开始读入参数并初始化所有对象。我们在这里注意到，对[2.x.496]的调用是从参数文件（其名称作为一个字符串参数给出）中读入所有参数。ParameterAcceptor处理一个全局的ParameterHandler，它被初始化为所有从ParameterAceptor派生的类实例的分节和参数声明。对初始化的调用进入了每个每个派生类的分节，并设置所有使用[2.x.497]添加的变量。
*


*


* [1.x.234]
*
* 接下来我们创建三角形，集合所有的矩阵，设置划痕空间，并初始化DataOut<dim>对象。
*


*


* [1.x.235]

* 我们将在变量 [2.x.498] 中存储当前的时间和状态。



*


* [1.x.236]
*
* [1.x.237] [1.x.238]。
* 默认情况下，布尔值[2.x.499]被设置为false，也就是说，下面的代码段不会被运行。然而，如果[2.x.500]我们表示我们确实有一个中断的计算，程序将通过从检查点文件中读入由[2.x.501], [2.x.502]组成的旧状态来重新启动。这些检查点文件将在下面讨论的[2.x.503]程序中创建。
*


*


* [1.x.239]
*
* 我们使用一个[2.x.504]来存储和读入检查点状态的内容。
*


*


* [1.x.240]
*
* [2.x.505] 遍历状态向量的所有分量 [2.x.506] 。我们依次读入组件的每一个条目，并在之后更新鬼魂层。
*


* [1.x.241]
*
*随着初始状态的建立，或中断状态的恢复，是时候进入主循环了。
*


*


* [1.x.242]
*
* 我们首先打印一个信息性的状态消息
*


*


* [1.x.243]

* 然后执行一个单一的前向欧拉步骤。注意状态向量[2.x.507]被就地更新，[2.x.508]返回所选择的步骤大小。
*


*


* [1.x.244]
*
* 后期处理、生成输出和写出当前状态是一项CPU和IO密集型的任务，我们不能在每一个时间步骤中都做。
*
* 特别是在显式时间步进中。因此，我们只在超过[2.x.510]设定的阈值时，通过调用[2.x.509]函数安排输出。
*


*


* [1.x.245]
*
* 我们等待任何剩余的后台输出线程完成，然后打印一个摘要并退出。
*


* [1.x.246]

* [2.x.511]将初始时间 "t "作为输入参数，并在[2.x.513]对象的帮助下填充一个状态向量[2.x.512]。
*


*


* [1.x.247]
*
* [2.x.514]的函数签名对于[2.x.515]来说不太合适。我们通过以下方式来解决这个问题：首先，创建一个lambda函数，对于一个给定的位置[2.x.516]只返回[2.x.517]的第1个分量的值。在ScalarFunctionFromFunctionObject包装器的帮助下，这个lambda又被转换为一个[2.x.518]。
*


*


* [1.x.248]
*
* [1.x.249] [1.x.250]
* 写出最终的vtk文件是一项相当密集的IO任务，会使主循环停滞一段时间。为了避免这种情况，我们使用了一个[1.x.251]的策略，即创建一个后台线程，在主循环被允许继续的情况下执行IO。为了使其发挥作用，我们必须注意两件事。
*


*
* - 在运行 [2.x.519] 线程之前，我们必须创建一个状态向量 [2.x.520] 的副本。我们把它存储在向量 [2.x.521] 中。
*


*
* - 我们必须避免在后台线程中进行任何MPI通信，否则程序可能会死锁。这意味着我们必须在工作线程之外运行后处理程序。
*


*


* [1.x.252]
*
* 如果设置了异步回写选项，我们会启动一个后台线程来执行所有的慢速IO到磁盘。在这种情况下，我们必须确保后台线程确实完成了运行。如果没有，我们必须等待它完成。我们用[1.x.253]启动上述背景线程，返回[1.x.254]对象。这个[2.x.522]对象包含了函数的返回值，在我们的例子中就是[2.x.523] 。
*


*


* [1.x.255]
*
* 在这一点上，我们制作了一份状态向量的副本，运行schlieren后处理器，并运行[2.x.524] 实际的输出代码是标准的。我们创建一个DataOut实例，附加所有我们想要输出的数据向量，然后调用[2.x.525]，但是有一个转折。为了在后台线程上执行异步IO，我们将DataOut<dim>对象创建为一个共享指针，传递给工作线程，以确保一旦我们退出这个函数，工作线程完成后，DataOut<dim>对象再次被销毁。
*


*


* [1.x.256]

* 接下来我们为后台线程创建一个lambda函数。我们 [1.x.257] [2.x.526] 指针以及输出函数的大部分参数的值，这样我们就可以在lambda函数中访问它们。
*


* [1.x.258]
*
* 我们通过做与我们讨论的[1.x.259]精确相反的操作来检查当前状态。
*


*


* [1.x.260]
*
* 如果设置了异步回写选项，我们就在[1.x.261]函数的帮助下启动一个新的后台线程。该函数返回一个[1.x.262]对象，我们可以用它来查询后台线程的状态。在这一点上，我们可以从[2.x.527]函数中返回，继续在主循环中进行时间步进
*
* - 该线程将在后台运行。
*


* [1.x.263]

* 最后是主函数。
*


*


* [1.x.264]
* [1.x.265][1.x.266][1.x.267] 。


* 在发布模式下，用默认参数运行程序，在4核机器上需要大约1分钟（带超线程）。
* [1.x.268]
*
* 一个明显的事实是，程序花了三分之二的执行时间计算图形粘度d_ij，大约三分之一的执行时间用于执行更新，其中计算flux [2.x.528] 是昂贵的操作。预设的默认分辨率约为37k个网格点，相当于二维的148k个空间自由度。解决方案的动画分层图看起来如下。
* [2.x.529]
* 很明显，一阶方法的37k个网格点还没有达到解决任何流动特征所需的分辨率。作为比较，下面是用二阶方法和大约9.5个网格点进行的 "参考 "计算（[1.x.269]）。
* [2.x.530]
* 因此，我们再给一阶方法一个机会，在一个小型计算服务器上用大约240万个网格点运行它。
* [1.x.270]
*
* 而结果如下。
* [2.x.531]
* 这大大改善了，当然，代价是在16个核心上运行了大约2个小时的代码。
*


* [1.x.271][1.x.272][1.x.273] 。


* 这里展示的程序实际上只是一阶精确的，如上文所讨论的。上面的图片说明了这带来了多少扩散，以及这个解决方案离真正解决我们所关心的特征还有多远。
* 这一点是可以解决的，但这将超出本教程*的内容。尽管如此，它还是值得展示通过添加二阶方案可以实现的效果。例如，这里有一段用[1.x.274]计算的视频，它显示了（用不同的颜色方案）对应于上述情况的2d模拟。
* [1.x.275]
*
* 这个模拟是用3800万个自由度（连续的[2.x.532]有限元）完成的，每一个解向量的分量都是如此。对于这类模拟来说，解决方案的精致细节是显著的，包括在障碍物后面的亚声速区域。
* 我们还可以相对容易地将其进一步扩展到三维情况。
* [1.x.276]
*
* 然而，解决这个问题变得很昂贵。仿真是以每个组件18.17亿个自由度（连续[2.x.533]有限元）完成的（总共90.9亿个空间自由度），在30,720个MPI等级上运行。该代码达到了每秒969万个网格点的平均吞吐量（每个CPU每秒0.04万个网格点）。前面和后面的墙显示了一个 "Schlieren图"：密度的梯度的大小在一个指数级上，从白色（低）到黑色（高）。所有其他切面和障碍物的表面都显示了白色（低）的涡度大小。
*
* - 黄色（中）。
*
* - 黄色（中）* - 黑色（高）的比例。(为了使视觉效果更好，各个剖面的比例已经调整过了)。


* [1.x.277][1.x.278] [2.x.534] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-70_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] , [2.x.3] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28]
* [2.x.4]
* [1.x.29]
* [2.x.5]
*

*[1.x.30][1.x.31]


*[1.x.32][1.x.33]


* 在本教程中，我们考虑了层流体系中的混合问题。这种问题在从化学工程到发电（如涡轮机械）的广泛的应用中出现。混合问题特别难以用数值解决，因为它们通常涉及一个容器（有固定的边界，可能还有复杂的几何形状，如挡板），由域[2.x.6]表示，和一个（或多个）浸入和旋转的叶轮（由域[2.x.7]表示）。我们想解决流动方程的域是两个域之间的（随时间变化）差异，即。[2.x.8] .
* 对于旋转叶轮，使用任意拉格朗日欧拉公式（其中流体域
*
* - 与网格一起!
*
* 是平滑变形的，以遵循浸入式固体的变形）是不可能的，除非只考虑小时间（即小的流体域变形）。如果想跟踪叶轮多次旋转时的流动变化，所产生的变形网格就会过于扭曲而无用。
* 在这种情况下，一个可行的替代策略是使用非匹配方法（类似于我们在[2.x.9]中所做的），即背景固定网格（可以在时间上进行局部细化以更好地捕捉固体运动）与旋转的独立网格相耦合。
* 为了保持与[2.x.10]中使用的相同符号，我们使用[2.x.11]来表示[2.x.12]中代表流体和叶轮容器的域，并且我们在[2.x.14]中使用[2.x.13]表示整个叶轮（当它的`spacedim'度量是不可忽略的，也就是说，当我们可以把它表示为维数`dim'等于`spacedim'的网格），薄叶轮的同维表示，或者只是整个叶轮的边界。
* 域[2.x.15]被嵌入到[2.x.16]（[2.x.17]）中，它是不匹配的：一般来说，它不与体积网格的任何特征对齐。我们在[2.x.18]上求解一个偏微分方程，通过一些惩罚技术对嵌入域[2.x.19]上的问题的求解执行一些条件。在当前情况下，条件是流体在[2.x.20]上各点的速度等于固体叶轮在该点的速度。
* 我们在此描述的技术在文献中使用了一个名称：[1.x.34]和[1.x.35]等。  其主要原理是两个网格的离散化保持完全独立。在本教程中，这种方法被用来求解由斯托克斯方程描述的粘性流体的运动，该流体被一个刚性的非变形叶轮搅动。
* 因此，[2.x.21]中求解的方程是蠕动流的斯托克斯方程（即[2.x.22]中的流动），并且在与叶轮相关的移动嵌入域*[2.x.23]上应用无滑动边界条件。然而，这个教程可以很容易地扩展到其他方程（例如，纳维-斯托克斯方程，线性弹性方程等）。它可以被看作是[2.x.24]的一个自然扩展，它可以通过MPI使用分布式并行计算架构解决大型问题。
* 然而，与[2.x.25]相反，[2.x.26]上的Dirichlet边界条件是弱加的，而不是通过使用Lagrange乘法器，并且我们集中于处理两个完全分布式三角计算的耦合（这种组合在[2.x.27]的实现中是不可能的）。
* 当人们想在嵌入域[2.x.28]上执行条件时，有两种有趣的情况发生。
*
* - 嵌入域[2.x.29]的几何维度`dim`与域[2.x.30]相同（`spacedim`），即[2.x.31]的spacedim维度不是零。在这种情况下，对[2.x.32]施加Dirichlet边界条件是通过体积惩罚完成的。如果施加的惩罚只取决于速度，这通常被称为[2.x.33]惩罚，而如果惩罚同时取决于速度及其梯度，则是[2.x.34]惩罚。[2.x.35]惩罚的情况与达西型方法非常相似。对[2.x.36]和[2.x.37]两种惩罚方法都进行了广泛的分析（例如，见[2.x.38]）。
*
* - 嵌入域[2.x.39]的内在维度`dim`小于[2.x.40]的维度（`spacedim`），因此其spacedim维度为零；例如，它是一条嵌入二维域的曲线，或嵌入三维域的面。当然，这在物理学上是不可能的，但是如果金属片的厚度可以忽略不计的话，我们可以把在流体中运动的非常薄的金属片视为本质上的低维。在这种情况下，边界条件通过应用[1.x.36]方法弱化地施加在[2.x.41]上（见[2.x.42] ）。
* 这两种方法都有非常相似的要求，并产生了非常相似的公式。因此，我们几乎以同样的方式对待它们。
* 在本教程中，我们对[2.x.43]的进一步细节不感兴趣：我们假设嵌入域的尺寸（`dim`）总是比嵌入域的尺寸（`spacedim`）小一个或相等。
*我们要解决以下微分问题：给定[2.x.45]上的充分无规则函数[2.x.46]，找到[2.x.47]的解。
* [1.x.37]

* 本教程的主要目的是展示如何使用惩罚方法将速度场条件[2.x.48]以弱的方式施加在非匹配的[2.x.49]上。关于斯托克斯问题的更广泛的讨论，包括体力、不同的边界条件和解决策略，可以在[2.x.50]中找到。
* 让我们首先考虑整个领域中的斯托克斯问题 [2.x.51] 。我们寻找一个速度场[2.x.52]和一个压力场[2.x.53]，满足斯托克斯方程的同质边界条件[2.x.54] 。
* 斯托克斯方程的弱形式是通过首先将其写成矢量形式得到的[1.x.38] 。
* 与矢量值测试函数[2.x.55]形成左面的点积，并在域[2.x.56]上进行积分，得出以下方程组：[1.x.39] 。
*这对所有测试函数[2.x.57]都必须成立。
*

*通过部分积分并利用[2.x.58]的边界条件，我们得到以下变分问题：[1.x.40]
*
*其中[2.x.59]代表[2.x.60]的标量积。这与[2.x.61]中使用的变异形式相同。
* 与[2.x.62]相反，我们没有对[2.x.63]的约束条件在[2.x.64]上进行强执行，而是通过惩罚项进行弱执行。
* 对这种弱的边界条件的分析取决于[2.x.65]的spacedim-dimensional度量是正的（如果`dim`等于`spacedim`）还是零（如果`dim`小于`spacedim`）。我们讨论这两种情况.
*

*[1.x.41][1.x.42]


* 在这种情况下，我们假设[2.x.66]是实际叶轮的边界，即嵌入二维域的封闭曲线或三维域的封闭表面。该方法的思路是考虑按照Nitsche方法，对[2.x.67]弱加迪里切特边界条件。这是通过在流体域上使用以下修改后的公式来实现的，其中没有对[2.x.68]上的测试函数施加强条件。
* [1.x.43]
*
* [2.x.69]上的积分是低维积分。可以证明（见[2.x.70]），存在一个正的常数[2.x.71]，所以如果[2.x.72]，边界的弱施加将是一致和稳定的。在[2.x.73]上的前两个附加积分（上述方程中的第二行）在通过部分积分后自然出现，当我们不假设[2.x.74]在[2.x.75]上为零。
* 上文等式中的第三行包含两个项，它们是为了确保弱形式的一致性而添加的，还有一个稳定项，它是为了执行边界条件，其误差与近似误差一致。一致性条款和稳定化条款被添加到实际边界数据的右手边 [2.x.76] 。
* 当[2.x.77]满足[2.x.79]上的条件[2.x.78]时，[2.x.80]上所有的一致性和稳定性积分都被抵消，剩下的就是通常的弱形式的斯托克斯流，也就是说，上述公式是一致的。
* 我们注意到，可以使用另一种（非对称的）公式。
* [1.x.44]
* 注意第三行和第四行第一项的不同符号。在这种情况下，稳定性和一致性条件成为[2.x.81] 。在对称情况下，[2.x.82]的值取决于[2.x.83]，一般选择[2.x.84]，[2.x.85]是衡量被整合面的大小，[2.x.86]是一个常数，以便[2.x.87] 。这就像人们通常用Nitschepenalty方法来强制执行Dirichlet边界条件那样。
* 另一方面，非对称方法与人们如何为非连续Galerkin方法的非对称内部惩罚方法（"NIPG "方法[2.x.88]）加强连续性有关。]。即使非对称情况在稳定参数的可能选择方面似乎更有优势，我们还是选择了对称分解，因为在这种情况下，可以证明对偶问题也是一致的，导致一个解决方案，不仅解决方案的能量准则以正确的顺序收敛，而且其[2.x.89]准则也是如此。此外，得到的矩阵仍然是对称的。
* 上述表述是在假设领域被精确离散化的情况下进行的。然而，如果叶轮的变形是一种刚体运动，就有可能人为地将斯托克斯问题的解决方案扩展到螺旋桨本身，因为刚体运动也是斯托克斯问题的解决方案。我们的想法是在[2.x.90]内解决同样的问题，在[2.x.91]上施加同样的边界条件，使用同样的惩罚技术，并用在[2.x.93]上全局连续的测试函数[2.x.92]来测试。
* 这导致了以下（中间）表述：[1.x.45] 。
* 其中跳跃项，用[2.x.94]表示，是相对于法向量[2.x.95]的一个固定方向计算的。2的系数出现在[2.x.96]前面，因为我们看到[2.x.97]的每一部分两次，一次来自流体内部，一次来自在其中移动的障碍物内部。对于[2.x.98]上的所有其他积分，我们对[2.x.99]的每一部分都访问了两次，但都是相反的符号，因此得到了跳跃项）。
* 这里我们注意到，与不连续的Galerkin方法不同，测试和试验函数在[2.x.100]上是连续的。此外，如果[2.x.101]不与单元边界对齐，所有的跳跃项也是零，因为一般来说，有限元函数空间在每个单元内都是平滑的，如果[2.x.102]只在有限的几个点上切过一个单元与它的边界相交，所有在[2.x.103]上的贡献，除了稳定化的贡献外，都可以从公式中忽略，结果形成以下最终形式的变分公式。
* [1.x.46]
*
* 在[2.x.104]中，约束条件的施加需要以拉格朗日乘数的形式增加新的变量。本教程程序不存在这种情况。然而，嵌入域上的速度矢量[2.x.105]不会与规定的速度[2.x.106]完全匹配，而只能达到与有限元方法的插值误差相同的数值误差。此外，正如在[2.x.107]中，我们仍然需要对当时的嵌入式网格进行积分，以构建必要的边界项，对其施加边界条件 [2.x.108] 。
*

*[1.x.47][1.x.48] 。


* 在这种情况下，[2.x.109]具有相同的维度，但是被嵌入到[2.x.110]中。在[2.x.111]惩罚的情况下，额外的惩罚项可以被解释为[2.x.112]中的达西项，结果是。
* [1.x.49]
*
* 这里，[2.x.113]上的积分只是部分体积上的积分。因此，[2.x.114]的惩罚包括增加一个体积项，约束流体的速度与[2.x.115]内刚体的速度保持一致。在这种情况下，[2.x.116]必须被选择得足够大，以确保[2.x.117]中的迪里希特边界条件得到充分尊重，但又不能太高，以保持系统矩阵的适当条件化。
* [2.x.118]的惩罚可以用类似的方式来构建，在惩罚中加入粘性成分，在[2.x.119]中阻尼速度梯度。
* [1.x.50]
*
* 注意[2.x.120]的惩罚（`dim`等于`spacedim`）和Nitsche的惩罚（`dim`等于`spacedim-1`）的结果是完全相同的数值实现，这要感谢deal.II的独立维度能力。
*

*[1.x.51][1.x.52]


* 在本教程中，嵌入网格[2.x.121]和嵌入网格都是用[2.x.122]来描述的。这两个三角计算可以通过GridGenerator命名空间中的函数来建立，也可以通过读取其他应用程序（例如GMSH，见[2.x.123]中的讨论）产生的网格文件来建立。这比之前在 [2.x.124] 中所做的略微更普遍。
* 不管是在 "dim=spacedim "还是 "dim<spacedim "的情况下，增加浸没边界方法，只是在系统矩阵和系统的右手边引入了额外的项，这些项是由对[2.x.125]的积分产生的。这并没有改变问题必须解决的变量的数量。因此，挑战与必须进行的积分有关 [2.x.126] 。
* 如同在有限元中一样，我们将这个积分分成来自用于解算[2.x.127]的三角形的所有单元的贡献，我们将[2.x.128]上的积分转化为其边界元素[2.x.129]上的积分，其中[2.x.130]是从[2.x.131]到[2.x.132]的映射，并使用正交公式计算出[2.x.133]上的积分。比如说。
* [1.x.53]
* 计算这个和是不容易的，因为我们必须评估[2.x.134]。一般来说，如果[2.x.135]和[2.x.136]没有对齐，那么[2.x.137]点相对于[2.x.138]是完全任意的，除非我们想出办法将[2.x.139]的所有基函数插在[2.x.140]上的一个任意点，否则我们无法计算出所需的积分。
*

*要评估[2.x.141]，需要采取以下步骤（如下图所示）。
*
* - 对于[2.x.143]中的给定单元[2.x.142]，计算实点[2.x.144]，其中[2.x.145]是用于[2.x.146]的积分的正交点之一。这是最容易的部分。[2.x.147]给了我们所有正交点的实空间位置。
*
* - 找到[2.x.148]中[2.x.149]所在的单元。我们将称这个元素为[2.x.150]。
*
* - 找到[2.x.151]内[2.x.152]的参考坐标。为此，我们需要将参考元素[2.x.154]转换为元素[2.x.155]：[2.x.156]的映射[2.x.153]的逆向。
*
* - 评估 [2.x.158] 网格在这一点 [2.x.159] 的基函数 [2.x.157] 。这也是比较简单的，使用FEValues。
*

* [2.x.160]
* 在[2.x.161]中，上述第二至第四步是通过依次调用来计算的。
*
* - [2.x.162]，然后是
*
* - [2.x.163] 我们然后
*
* - 构建一个自定义的正交公式，包含参考单元格中的点，然后
*
* 构建一个FEValues对象，使用给定的正交公式，并以第一步获得的单元格进行初始化。
* 尽管这种方法在目前的情况下是可行的，但它并不适合于使用分布式三角形的平行模拟。事实上，由于嵌入域[2.x.164]单元上的正交点的位置与嵌入三角形的位置不一致，而且[2.x.165]是不断移动的，这就需要将代表[2.x.166]的三角形完整地存储在所有处理器中。随着处理器数量和[2.x.167]中单元格数量的增加，这将导致内存方面的严重瓶颈。因此，在这一步骤中寻求一种替代策略。
*

*[1.x.54][1.x.55]


* 请记住，对于惩罚方法（[2.x.168]或[2.x.169]）和Nitsche方法，我们要计算的是由正交法近似的积分。也就是说，我们需要计算[1.x.56]，如果你跟随上面的讨论，那么你会记得[2.x.170]和[2.x.171]是定义在流体网格上的形状函数，唯一定义在实体网格上的东西是。[2.x.172]是一个实体单元上的正交点的位置，它是[2.x.173]的一部分，[2.x.174]是其雅各布系数的行列式，而[2.x.175]是相应的正交权重。
* 现在要意识到的重要部分是这样的。  [2.x.176]是正交公式的一个属性，不随时间变化。此外，[2.x.177]的雅各布矩阵本身随着固体障碍物在流体中的移动而变化，但由于固体被认为是不变形的（它只是平移和旋转，但不扩张），雅各布矩阵的行列式保持不变。因此，乘积[2.x.178]（我们通常用`JxW'表示）在每个正交点上保持不变。所以我们唯一需要跟踪的是位置[2.x.179]。
*
* - 但这些位置是随着实体域的速度而移动的。
* 换句话说，我们实际上根本不需要保持实体网格。我们所需要的只是位置[2.x.180由于这些属性都是附着在实体材料上的点属性（或点向量），它们可以被理想化为一组不相连的极小的 "粒子"，它们随着实体的运动携带所需的`JxW`信息。]），我们将在本教程中使用这一功能。
* 因此，这一步采取的方法如下。
*
* - 为域[2.x.182]创建一个[2.x.183] 。

* - 在[2.x.185]上的正交点位置创建[2.x.184] 。

* - 调用[2.x.186]函数，将粒子按照实体三角形分布在处理器上*。
*
* - 将 "JxW "值作为一个 "属性 "附加到每个[2.x.187]对象上。
* 这个结构的生成相对昂贵，但每次模拟必须只生成一次。一旦生成了[2.x.188]并将所需信息附加到粒子上，就可以利用粒子在ParticleHandler中被分组的事实，对[2.x.189]进行积分，使我们能够。
*
* - 在[2.x.190]中至少包含一个粒子的所有单元上循环操作
*
* - 在给定单元中的所有粒子上进行循环操作
*
* - 计算积分并填充全局矩阵。
* 由于[2.x.191]可以管理粒子从一个处理器到另一个处理器的交换，嵌入式三角剖分可以通过位移粒子来移动或变形。与这种位移相关的唯一约束是，粒子应该被位移的距离不大于一个单元的大小。这是因为这是[2.x.192]能够跟踪离开当前单元的粒子现在所处的单元的极限。
* 一旦整个问题（斯托克斯问题和浸没式边界定位）被集合起来，最终的鞍点问题将由一个迭代求解器来解决，应用于舒尔补体[2.x.193]（其构造例如在[2.x.194]中描述），我们使用LinearOperator类构建[2.x.195]。
*

*[1.x.57][1.x.58]


* 我们在这里解决的问题是对斯托克斯流的时间可逆性的证明。这在科学教育实验中经常用泰勒-库埃特流和染料液滴来说明，在流体以周期性的方式位移后，染料液滴又恢复到原来的形状。
* [1.x.59]
*
* 在这个问题中，一个非常粘稠的流体被一个叶轮的旋转所搅动，在二维中，叶轮是由一个矩形网格所模拟的。叶轮旋转了一定的圈数，之后流动被逆转，从而在相反的方向上进行同样的圈数。我们记得，由于斯托克斯方程是自关节的，蠕动流是可逆的。因此，如果叶轮运动在相反的方向上被逆转，流体应该回到其原来的位置。在本例中，我们通过插入一圈被动示踪粒子来说明这一点，这些粒子被流体吸入，并返回到原来的位置，从而证明了流动的时间可逆性。
*

*[1.x.60][1.x.61]


* 本教程程序使用了一些关于对流体内部的非匹配界面施加速度条件的技术。对于更多的背景材料，你可能想查一下以下参考资料。[2.x.196] , [2.x.197] , [2.x.198] , [2.x.199] , [2.x.200] 。
*

* [1.x.62] [1.x.63]。
* [1.x.64] [1.x.65] 其中大部分已经在其他地方介绍过了，我们只对新的部分进行评论。靠近顶部的开关允许在PETSc和Trilinos线性代数功能之间进行选择，与 [2.x.201] 和 [2.x.202] 中的开关类似。
*


*


* [1.x.66]
*
* 这些是关于 [2.x.203] 的唯一新的包含文件。在本教程中，固体和流体之间的非匹配耦合是通过一个中间数据结构来计算的，该结构可以跟踪固体的正交点在流体网格中的位置如何演变。这个数据结构需要跟踪描述实体域的每个单元上的正交点的位置，正交权重，以及可能的每个点的法向量，如果实体域是同维的。
*

*
* Deal.II在粒子命名空间中，通过ParticleHandler类提供了这些设施。ParticleHandler是一个允许你管理粒子集合的类（类型为[2.x.204]的对象，代表具有一些附加属性（例如，一个id）的点的集合，漂浮在[2.x.205]命名空间中的方法和类允许人们轻松实现Particle-In-Cell方法和分布式三角形上的粒子追踪。
*

*
* 我们 "滥用 "这个数据结构来存储嵌入周围流体网格中的实体正交点的位置信息，包括积分权重，以及可能的表面法线。我们之所以使用这个额外的数据结构，是因为实体网格和流体网格可能是不重叠的，如果我们使用两个独立的三角测量对象，则会在并行进程中独立分布。
*

*
* 为了耦合这两个问题，我们依靠ParticleHandler类，在每个粒子中存储固体正交点的位置（通常不与任何流体正交点对齐）、其重量以及耦合这两个问题可能需要的任何其他信息。然后这些位置与固体叶轮的（规定）速度一起传播。
*

*
* 实体正交点的所有权最初是从实体网格本身的MPI分区中继承的。这样产生的粒子后来通过ParticleHandler类的方法分配到流体网格中。这允许MPI进程之间透明地交换关于流体单元和实体正交点之间的重叠模式的信息。
*


* [1.x.67]
*
* 当生成网格时，我们允许从文件中读取它，如果deal.II已经建立了OpenCASCADE支持，我们也允许读取CAD文件，并将它们作为网格的流形描述符（见[2.x.206]对OpenCASCADE命名空间中的各种流形描述符的详细描述）。
*


* [1.x.68]
*
* [1.x.69] [1.x.70]。


*
* 与我们在[2.x.207]中所做的类似，我们建立了一个持有我们问题的所有参数的类，并从ParameterAcceptor类派生出来，以简化参数文件的管理和创建。   
* ParameterAcceptor范式要求所有的参数都可以被ParameterAcceptor方法写入。为了避免出现很难追踪的错误（比如写成`time = 0`而不是`time == 0`），我们在一个外部类中声明所有的参数，该类在实际的`StokesImmersedProblem`类之前初始化，并将其作为`const`引用传递给主类。   
* 该类的构造函数负责该类的成员与ParameterHandler中的相应条目之间的连接。由于使用了[2.x.208]方法，这种连接是微不足道的，但要求这个类的所有成员都是可写的。
*


* [1.x.71]
*
* 然而，由于这个类将作为一个 "const "引用传递给StokesImmersedProblem类，我们必须确保我们仍然可以在这里定义的Function类派生的对象中正确设置时间。为了做到这一点，我们声明[2.x.209]和[2.x.210]成员都是 "可变 "的，并定义以下的小辅助方法，将它们的时间设置为正确的值。
*


* [1.x.72]
*
* 该类的其余部分主要由描述模拟及其离散化细节的成员变量组成。下面的参数是关于输出应该在哪里，空间和时间离散化（默认是[2.x.211]Taylor-Hood离散化，该离散化对速度使用2度的多项式），以及在我们再次生成图形输出之前应该经过多少时间步长。
*


* [1.x.73]
*
* 我们允许每个网格独立地被细化。在本教程中，没有物理学在实体网格上进行解析，它的速度被作为一个基准点给出。然而，在本教程中加入一些弹性模型，并将其转化为一个完全成熟的FSI求解器是相对简单的。
*


* [1.x.74]
*
* 为了提供对流体领域的粗略描述，我们使用extract_rtree_level()方法，应用于流体三角形中每个局部拥有的单元的边界盒树。树的级别越高，提取的边界盒数量就越多，对流体领域的描述也就越准确。然而，大量的边界盒也意味着巨大的通信成本，因为边界盒的收集是由所有进程收集的。
*


* [1.x.75]
*
*方程中使用的唯一两个数值参数是流体的粘度，以及尼采公式中使用的惩罚项[2.x.212]。
*


* [1.x.76]
*
* 默认情况下，我们创建一个没有着色的hyper_cube，并且我们使用同质的Dirichlet边界条件。在这个集合中，我们存储了在设置边界条件时要使用的边界ID。
*


* [1.x.77]
*
* 我们在这里说明了从参数文件中创建三角形的另一种方法，使用方法[2.x.213]，该方法接收GridGenerator命名空间中的函数名称，其参数为一个字符串，代表参数的元组。     
* 在[2.x.214]类中详细解释了将参数从字符串解析成字符串的机制，该类用于将字符串翻译成大多数基本STL类型（向量、映射、元组）和基本deal.II类型（点、张量、BoundingBox等）。     
* 一般来说，可以用等级1的统一元素表示的对象（即[2.x.215] Point<dim>, [2.x.216] 等）是用逗号分隔的。额外的等级采取分号，允许你将字符串解析为[2.x.217]或例如[2.x.218]类型的对象，如`0.0, 0.1; 0.1, 0.2`。这个字符串可以被解释为两个Point对象的向量，或者一个双数向量的向量。     
* 当条目不统一时，如元组的情况，我们用冒号来分隔各个条目。例如，像`5: 0.1, 0.2`这样的字符串可以用来解析一个类型为[2.x.219] Point<2>>的对象或者一个[2.x.220] [2.x.221] 的对象。
* 在我们的例子中，大多数参数是点对象（代表中心、角、细分元素等）、整数值（细分的数量）、双倍值（半径、长度等）或布尔选项（如许多GridGenerator函数采取的`colorize`选项）。     
* 在下面的例子中，我们设置了合理的默认值，但这些值可以在运行时通过选择GridGenerator命名空间的任何其他支持的函数来改变。如果GridGenerator函数失败，本程序将把网格的名称解释为vtk网格文件名，把参数解释为从manifold_id到描述域的几何形状的CAD文件的映射。每个CAD文件都将被分析，并根据CAD文件本身的内容生成OpenCASCADE命名空间的Mifold。     
* 为了尽可能的通用，我们对每一个生成的网格都要这样做：流体网格、固体网格，还有也是用三角法生成的示踪粒子。
*


* [1.x.78]
*
* 同样地，我们允许不同的局部细化策略。特别是，我们限制了细化水平的最大数量，以控制流体网格的最小尺寸，并保证它与实体网格兼容。细化级数的最小值也得到了控制，以确保在大部分流动中具有足够的精度。此外，我们根据流体速度场的标准误差估计器进行局部细化。     
* 我们允许用户选择两种最常见的细化策略，即 "固定数 "或 "固定分数"，这些策略参考了[2.x.222]和[2.x.223]的方法。
* 细化可以每隔几步时间进行一次，而不是连续进行，我们通过`细化_频率`参数控制这个值。
*


* [1.x.79]
*
* 最后，以下两个函数对象被用来控制斯托克斯流的源项和我们移动固体体的角速度。在一个更现实的模拟中，固体速度或其变形将来自于固体域上的辅助问题的解决。在这个例子中，我们把这部分放在一边，只是在浸没的固体上沿Z轴施加一个固定的旋转速度场，由一个可以在参数文件中指定的函数控制。
*


* [1.x.80]
*
* 还有一项任务是声明我们在输入文件中可以接受哪些运行时参数。我们将这些参数分成不同的类别，把它们放在ParameterHandler类的不同部分。我们首先声明StokesImmersedProblem在全局范围内使用的所有全局参数。
*


* [1.x.81]
*
* 下一节是专门讨论用于创建各种网格的参数。我们将需要三种不同的三角形。流体网格 "用于定义流体领域，"固体网格 "用于定义固体领域，"粒子网格 "用于分布一些示踪粒子，这些粒子随速度平流，只作为被动示踪物使用。
*


* [1.x.82]
*
* 最后的任务是纠正右侧函数的默认尺寸，并定义一个有意义的默认角速度，而不是零。
*


* [1.x.83]
*
* 一旦角速度被提供为一个函数对象，我们就通过下面这个派生自函数类的类来重构点状实体速度。它通过假设实体以给定的角速度绕原点（或3D中的[2.x.224]轴）旋转，提供实体在给定位置的速度值。
*


* [1.x.84]
*
* 我们假设角速度是沿Z轴方向的，也就是说，我们把实际的角速度当作二维旋转来建模，而不考虑`spacedim`的实际值。
*


* [1.x.85]
*
* 同样，我们假设固体位置可以在每个时间步长中明确计算，利用角速度的知识。我们计算固体粒子的确切位置，假定固体的旋转量等于时间步长乘以在`p'点计算的角速度。
*


* [1.x.86]
*
* [1.x.87] [1.x.88]。



* 我们现在准备介绍我们的教程程序的主类。像往常一样，除了构造函数外，我们只留下一个公共入口点：`run()`方法。其他的都是 "私有 "的，并通过run方法本身进行访问。
*


* [1.x.89]
*
* 下一节包含了该类的`private`成员。第一个方法与之前的例子中的类似。然而，它不仅负责生成流体的网格，而且还负责生成固体的网格。第二个方法是计算最大的时间步长，保证每个粒子最多移动一个单元。这对于确保[2.x.225]能够找到粒子最终所在的单元是非常重要的，因为它只能从一个单元看向它的近邻（因为在并行设置中，每个MPI进程只知道它拥有的单元以及它们的近邻）。
*


* [1.x.90]
*
* 接下来的两个函数将初始化这个类中使用的[2.x.226]对象。我们有两个这样的对象。一个代表被动追踪器，用于绘制流体粒子的轨迹，而另一个代表固体的材料粒子，它们被放置在固体网格的正交点上。
*


* [1.x.91]
*
* 其余的设置分为两部分。以下两个函数中的第一个函数创建了每次模拟需要的所有对象，而另一个函数则设置了所有需要在每个细化步骤中重新初始化的对象。
*


* [1.x.92]
*
* 装配例程与其他斯托克斯装配例程非常相似，但Nitsche限制部分除外，它利用其中一个粒子处理程序在流体域的非匹配部分进行积分，对应于固体的位置。我们将这两部分分成两个独立的函数。
*


* [1.x.93]
*
* 其余的函数求解线性系统（看起来与[2.x.227]中的线性系统几乎相同），然后对解进行后处理。refine_and_transfer()方法仅在每一个`refinement_frequency`步骤中被调用，以适应网格，并确保所有在细化前的时间步骤中计算的场都能正确地转移到新的网格中。这包括矢量场，以及粒子信息。同样，我们每隔`output_frequency`步就会调用两个输出方法。
*


* [1.x.94]

* 然后让我们继续讨论该类的成员函数。第一个是处理从参数文件中读取的运行时参数。如前所述，我们通过使其成为一个`const`引用，确保我们不能从这个类中修改这个对象。
*


* [1.x.95]
*
* 然后还有MPI communicator对象，如果程序并行运行，我们将用它来让进程在网络上发送信息，还有`pcout`对象和定时器信息，也被[2.x.228]采用，例如。
*


* [1.x.96]
*
* 接下来是关于[2.x.229]的主要创新点之一。这里我们假设固体和流体都是完全分布的三角形。这使得问题可以扩展到非常大的自由度，代价是要沟通所有非匹配三角形之间的重叠区域。这一点特别棘手，因为我们没有对两个三角形的各个子域的相对位置或分布做出假设。特别是，我们假设每个进程只拥有 "solid_tria "的一部分，以及 "fluid_tria "的一部分，不一定在同一个物理区域，也不一定重叠。     
* 我们原则上可以尝试创建初始分区，使每个过程的子域在固体和流体区域之间重叠。然而，这种重叠在模拟过程中会被破坏，我们将不得不一次又一次地重新分配DoF。我们在本教程中采用的方法更加灵活，而且成本也不高。我们在模拟开始时进行两次全对全的通信，以交换每个处理器的几何占用信息（近似的）（通过包围盒的集合完成）。     
*这个信息被[2.x.230]类用来交换（使用某对某的通信模式）所有的粒子，因此每个进程都知道生活在它所拥有的流体子域所占区域上的粒子。     
*为了把重叠的区域联系起来，我们利用了ParticleHandler类中实现的设施。
*


* [1.x.97]
*
* 接下来是对使用中的有限元的描述，以及适当的正交公式和相应的DoFHandler对象。对于目前的实现，只有`fluid_fe`是真正必要的。为了完整起见，也为了便于扩展，我们还保留了`solid_fe`，但它被初始化为FE_Nothing有限元空间，也就是没有自由度的空间。     
* 我们将这两个有限元空间声明为[2.x.231]对象，而不是普通的成员变量，以便在`StokesImmersedProblemParameters'被初始化后生成它们。特别是，它们将在 "initial_setup() "方法中被初始化。
*


* [1.x.98]
*
* 与[2.x.232]中的做法类似，我们使用一个块状系统来处理问题的斯托克斯部分，并非常密切地遵循那里的做法。
*


* [1.x.99]
*
* 利用这种自由度的划分，我们就可以定义描述有关的线性系统所需的所有对象。
*


* [1.x.100]
*
* 让我们转到这个程序的粒子方面。有两个[2.x.233]对象用于耦合固体和流体，以及描述被动追踪器。在许多方面，这些对象的作用类似于离散化中使用的DoFHandler类，也就是说，它们提供了一个粒子的枚举，并允许查询每个粒子的信息。
*


* [1.x.101]
*
* 对于每个示踪粒子，我们需要计算其当前位置的速度场，并使用离散时间步进方案更新其位置。我们使用分布式线性代数对象来做这件事，这些对象存储了每个粒子的位置或速度的坐标。也就是说，这些向量有`tracer_particle_handler.n_global_particles()spacedim`项，我们将以一种方式来存储这些向量的一部分，以便在所有进程中进行分割。(隐含地，我们在这里假设每个粒子的`spacedim'坐标被存储在向量的连续条目中)。因此，我们需要确定每个向量条目的所有者是谁。我们将这个所有者设定为等于在时间[2.x.234]产生该粒子的进程。这个信息为每个进程存储在`locally_owned_tracer_particle_coordinates`索引集。     
* 一旦粒子被分配到与拥有粒子所在区域的进程相匹配，我们将需要从该进程读取相应的速度场的权限。我们通过填充一个只读的速度矢量场来实现这一点，该矢量场包含了幽灵项中的相关信息。这是通过`locally_relevant_tracer_particle_coordinates`索引集来实现的，该索引集记录了模拟过程中的变化情况，也就是说，它记录了当前进程拥有的粒子最终出现在哪里，以及谁拥有最终出现在我的子域的粒子。     
* 虽然这不是最有效的策略，但我们保持这种方式是为了说明事情在真正的流体-结构相互作用（FSI）问题上是如何运作的。如果一个粒子与一个特定的固体自由度相联系，我们就不能自由选择谁拥有它，我们必须把这个信息传达给周围的人。我们在此说明了这一点，并表明通信模式是点对点的，就算法的总成本而言可以忽略不计。     
* 然后，基于这些细分定义的向量被用来存储粒子的速度（只读，有幽灵条目）和它们的位移（读/写，没有幽灵条目）。
*


* [1.x.102]
*
* 本教程程序的关键点之一是两个独立的[2.x.235]对象之间的耦合，其中一个对象可能相对于另一个对象移动和变形（可能有很大的变形）。当流体和实体的三角形都是[2.x.236]类型时，每个进程只能访问这两个三角形中每个单元的局部拥有的部分。如上所述，一般来说，本地拥有的域是不重叠的。     
* 为了允许不重叠的[2.x.237]对象之间有效地交换信息，该库的一些算法要求用户提供三角形本地拥有部分所占区域的粗略描述，其形式是每个进程的轴对齐的边界盒集合，这些边界盒提供了域的本地拥有部分的完整覆盖。这种信息就可以用于这样的情况：人们需要向已知位置周围的单元格的所有者发送信息，而不知道这个所有者实际上是谁。但是，如果我们知道每个进程拥有的几何区域或体积的边界盒集合，那么我们就可以确定可能拥有该位置所在单元的所有进程的一个子集：即其边界盒包含该点的所有进程。与其向所有进程发送与该位置相关的信息，不如只向具有点对点通信基元的一小部分进程发送信息。你会注意到，这也允许典型的时间与内存的权衡：我们愿意存储的关于每个进程拥有的区域的数据越多
*
* - 以更精细的边界盒信息的形式
*
* 我们要执行的通信就越少）。)     
* 我们通过收集一个向量（长度为[2.x.238]的BoundingBox对象的向量）来构建这些信息。我们使用extract_rtree_level()函数填充这个向量，并允许用户选择要提取的树的哪一级。这个 "级别 "对应的是与边界框重叠的区域应该有多粗/多细。     
* 作为一个例子，这是extract_rtree_level()函数应用于一个二维超球，分布在三个过程中所提取的内容。每张图片中，绿色显示的是与每个进程上的三角形的本地所有单元相关的边界框，紫色显示的是从rtree中提取的边界框。     
* [2.x.239] [2.x.240] [2.x.241]。
* 我们将这些盒子存储在一个全局成员变量中，在每个细化步骤中都会更新。
*


* [1.x.103]
*
* [1.x.104] [1.x.105]。



* [1.x.106] [1.x.107]。


*
* 在构造函数中，我们创建了mpi_communicator，以及流体和实体的三角计算和dof_handler。使用mpi_communicator，构建ConditionalOStream和TimerOutput对象。
*


* [1.x.108]
*
* 为了生成网格，我们首先尝试使用deal.II GridGenerator命名空间中的函数，通过利用[2.x.242]如果这个函数失败，那么我们使用以下方法，名称被解释为文件名，参数被解释为从流形ID到CAD文件的映射，并使用OpenCASCADE命名空间设施转换为流形描述符。在顶部，我们把文件读成一个三角图。
*


* [1.x.109]
*
* 如果我们走到了这一步，那么Triangulation就已经被读取了，我们就可以给它附加正确的流形描述了。只有在deal.II支持OpenCASCADE的情况下，我们才会执行接下来的几行代码。对于地图中的每个条目，我们尝试打开相应的CAD文件，分析它，并根据其内容，选择一个[2.x.243]（如果CAD文件包含一个`TopoDS_Edge'或一个`TopoDS_Wire'）或一个[2.x.244]，如果文件包含一个面。请注意，如果CAD文件不包含单一的线、边或面，在生成Manifold时将会抛出一个断言。     
* 我们使用[2.x.245]类来为我们完成从字符串到歧管ID和文件名之间的映射的转换。
*


* [1.x.110]
*
* 现在我们检查一下这个 "形状 "中包含了多少个面。OpenCASCADE本质上是三维的，所以如果这个数字是零，我们就把它解释为线状流形，否则就解释为[2.x.246]在`spacedim`=3时，或[2.x.247]在`spacedim`=2时。
*


* [1.x.111]
*
* 我们使用这个技巧，因为[2.x.248]只在spacedim=3时实现。上面的检查确保了事情的实际运作是正确的。
*


* [1.x.112]
*
* 我们也允许基于单个NURBS补丁的二维空间的表面描述。要做到这一点，CAD文件必须包含一个单一的`TopoDS_Face`。
*


* [1.x.113]
*
* 现在让我们把事情放在一起，并制作所有必要的网格。如上所述，我们首先尝试在内部生成网格，如果失败了（即，如果我们最终进入了 "catch "子句），那么我们就继续使用上述函数。   
* 我们对流体和固体网格都重复这个模式。
*


* [1.x.114]
*
* [1.x.115] [1.x.116]。


*
* 一旦固体和流体网格被创建，我们就开始填充[2.x.249]对象。我们要处理的第一个对象是用来跟踪流体中的被动追踪器的对象。这些东西只是沿途传送，从某种意义上说，它们的位置并不重要：我们只是想用它们来查看流动被传送的位置。我们可以使用任何我们选择的方式来确定它们的初始位置。一个方便的方法是将初始位置创建为我们选择的形状的网格的顶点
*
* 这个选择由参数文件中的一个运行时参数决定。   
* 在这个实现中，我们使用FE_Q有限元空间的支持点来创建追踪器，这些支持点定义在一个临时网格上，然后被丢弃。在这个网格中，我们只保留与支撑点相关的[2.x.250]对象（存储在[2.x.251]类中）。   
* [2.x.252]类提供了插入一组粒子的可能性，这些粒子实际生活在活动过程所拥有的域的一部分。然而，在这种情况下，这个功能是不够的。作为任意网格（与流体网格不匹配）上FE_Q对象的本地拥有的支持点所生成的粒子没有理由位于流体网格的本地拥有的子域的同一物理区域。事实上，这种情况几乎不会发生，特别是由于我们要跟踪粒子本身的情况。   
* 在粒子入室方法（PIC）中，人们通常习惯于将粒子的所有权分配给粒子所在的过程。在本教程中，我们说明了一种不同的方法，如果想跟踪与粒子有关的信息，这种方法是有用的（例如，如果一个粒子与一个特定的自由度有关，而这个自由度是由一个特定的过程所拥有的，不一定是在任何特定时间拥有该粒子所在的流体单元的同一过程）。在这里使用的方法中，粒子的所有权在开始时被分配一次，每当原始所有者需要从拥有粒子所在单元的进程中获得信息时，就会发生一对一的通信。我们确保使用初始粒子分布来设置粒子的所有权，并在程序的整个执行过程中保持相同的所有权。   
*随着这个概述的结束，让我们看看这个函数做了什么。在顶部，我们创建了一个临时的三角形和DoFHandler对象，我们将从中获取初始粒子位置的节点位置。
*


* [1.x.117]
*
* 这就是事情开始变得复杂的地方。由于我们可能会在并行环境中运行这个程序，每个并行进程现在都会创建这些临时三角形和DoFHandlers。但是，在完全分布式三角形中，活动进程只知道本地拥有的单元，而不知道其他进程是如何分布自己的单元的。这对于上面创建的临时三角形以及我们想嵌入粒子的流体三角形都是如此。另一方面，一般来说，这两个三角形的局部已知部分不会重合。也就是说，我们将从临时网格的节点位置创建的粒子的位置是任意的，并且可能落在当前进程无法访问的流体三角结构的区域内（即流体领域中细胞是人工的区域）。为了了解将这些粒子发送给谁，我们需要对流体网格在处理器中的分布有一个（粗略的）概念。     
* 我们通过首先建立一个以本地拥有的单元为边界的盒子的索引树，然后提取该树的第一层之一，来构建这一信息。
*


* [1.x.118]
*
* 每个进程现在都有一个完全包围所有本地拥有的进程的边界框的集合（但可能与其他进程的边界框相重叠）。然后，我们在所有参与的进程之间交换这一信息，以便每个进程都知道所有其他进程的边界盒。     
* 有了这些知识，我们就可以将`tracer_particle_handler`初始化为流体网格，并从（临时）tracer particles triangulation的支持点生成粒子。这个函数调用使用了我们刚刚构建的`global_bounding_boxes`对象，以确定将位置来自`particles_dof_handler`的本地拥有部分的粒子发送到哪里。在这个调用结束时，每个粒子将被分配到正确的进程（即拥有粒子所在的流体单元的进程）。在这一点上，我们也将它们的数量输出到屏幕上。
*


* [1.x.119]
*
* 这样创建的每个粒子都有一个唯一的ID。在下面的算法中的某个时刻，我们将需要包含每个粒子的位置和速度信息的向量。这个向量的大小为`n_particles spacedim`，我们必须以一种方式来存储这个向量的元素，以便每个并行进程 "拥有 "那些对应于它所拥有的粒子坐标的元素。换句话说，我们必须在所有进程中划分0和`n_particles spacedim`之间的索引空间。我们可以通过查询`tracer_particle_handler`的本地相关粒子的ID来做到这一点，并构建所需的索引，将所有粒子的位置和速度存储在一个（平行分布的）矢量中，其中我们隐含地假设我们将每个位置或速度的坐标存储在`spacedim`连续的矢量元素中（这就是[2.x.253]函数的作用）。
*


* [1.x.120]
*
* 在模拟开始时，所有粒子都在它们的原始位置。当粒子移动时，它们可能会穿越到另一个进程所拥有的领域的某个部分。如果发生这种情况，当前的进程会正式保持对粒子的 "所有权"，但可能需要从粒子落地的进程中读取访问。我们将这一信息保存在另一个索引集中，该索引集存储了当前进程的子域中的所有粒子的索引，不管它们是否一直在这里。     
* 保持这个索引集使我们能够利用线性代数类来进行有关粒子位置和速度的所有通信。这模拟了在固体域中解决另一个问题的情况下会发生的情况（如在流体-结构相互作用中。在后一种情况下，实体域上的额外DOFs将被耦合到流体域中发生的情况。
*


* [1.x.121]
*
* 最后，我们确保在细化时，粒子被正确转移。在进行局部细化或粗化时，粒子会落在另一个单元中。原则上我们可以在细化后重新分配所有的粒子，然而这将是过于昂贵的。     
* [2.x.254]类有一种方法可以在细化时将信息从一个单元转移到它的子单元或它的父单元，而不需要重构整个数据结构。这是通过向三角结构注册两个回调函数来实现的。这些函数将在细化即将发生和刚刚发生时收到一个信号，并将以最小的计算成本将所有信息转移到新的细化网格中。
*


* [1.x.122]
*
* 与我们对被动追踪器所做的类似，我们接下来设置追踪实体网格正交点的粒子。这里的主要区别是，我们还想给每个粒子附加一个权重值（正交点的 "JxW "值），这样我们就可以在没有直接访问原始实体网格的情况下计算积分。   
* 这是通过利用[2.x.255]类的 "属性 "概念实现的。有可能（以一种有效的内存方式）在一个[2.x.257]对象内为每个[2.x.256]对象存储任意数量的`双`数。我们利用这种可能性来存储实体网格的正交点的JxW值。   
* 在我们的案例中，我们只需要为每个粒子存储一个属性：实体网格上的积分的JxW值。这将在构造时作为最后一个参数传递给solid_particle_handler对象。
*


* [1.x.123]
*
* 我们在本地生成的粒子数等于本地拥有的单元总数乘以每个单元中使用的正交点的数量。我们将所有这些点存储在一个向量中，并将其相应的属性存储在一个向量的向量中。
*


* [1.x.124]
*
* 我们以处理示踪粒子的同样方式进行，重新使用计算出的边界盒。然而，我们首先检查`global_fluid_bounding_boxes`对象是否已经被填充。这里当然应该是这样的，因为这个方法是在初始化示踪粒子的方法之后调用的。然而，我们要确保，如果将来有人决定（无论出于什么原因）先初始化实体粒子处理程序，或者只复制教程的这一部分，当事情没有按照预期进行时，会抛出一个有意义的异常。
* 由于我们已经存储了正交点的位置，我们可以使用这些位置来直接使用`solid_particle_handler`插入粒子，而不是通过[2.x.258]函数。
*


* [1.x.125]
*
* 和前面的函数一样，我们最后确保在细化时，粒子被正确转移。
*


* [1.x.126]
*
* [1.x.127] [1.x.128]。


*
* 我们设置了有限元空间和整个步骤中使用的正交公式。对于流体，我们使用Taylor-Hood元素（例如[2.x.259]）。由于我们没有解决固体领域的任何方程，所以产生了一个空的有限元空间。这个程序的一个自然扩展是解决流体结构的相互作用问题，这就要求`solid_fe`使用更有用的FiniteElement类。   
* 和其他许多函数一样，我们在这里存储了进行操作所需的时间。当前的函数将其时间信息放入一个标签为 "初始设置 "的部分。在不同的函数中对这个定时器进行了许多其他的调用。它们允许监测每个单独函数的绝对和相对成本，以确定瓶颈。
*


* [1.x.129]
*
* 我们接下来构建分布式块状矩阵和向量，用于解决问题中出现的线性方程。这个函数改编自[2.x.260]，我们参考这个步骤进行全面解释。
*


* [1.x.130]
*
* [1.x.131] [1.x.132]。



* 我们将系统矩阵、预处理矩阵和右手边组合起来。该代码改编自[2.x.261]，基本上是[2.x.262]的内容，如果你知道斯托克斯方程是什么样子的，就会觉得很标准。
*


* [1.x.133]
*
* 下面的方法是处理因对叶轮施加速度而产生的惩罚项。从某种意义上说，它是本教程的核心，但它相对简单。这里我们利用`solid_particle_handler`来计算Nitsche限制或嵌入域的惩罚。
*


* [1.x.134]
*
* 我们在所有的本地粒子上循环。虽然这可以直接通过循环所有的单元格来实现，但这将迫使我们循环许多不包含粒子的单元格。因此，我们对所有的粒子进行循环，但是，我们得到粒子所在的单元格的引用，然后对该单元格中的所有粒子进行循环。这使得我们能够跳过不包含粒子的单元格，但又能集合每个单元格的局部矩阵和rhs来应用Nitsche的限制。一旦我们完成了一个单元格上的所有粒子，我们就将`粒子`迭代器推进到当前单元格上的粒子的末端（这是`while`循环主体的最后一行）。
*


* [1.x.135]
*
* 我们从粒子本身得到一个通往粒子所在单元的迭代器。然后，我们可以像通常那样，在系统矩阵和右手边组装附加项。
*


* [1.x.136]
*
* 那么，让我们得到位于这个单元格上的单元格集合，并对它们进行迭代。从每个粒子中，我们收集该粒子的位置和参考位置，以及附加在该粒子上的额外信息。在本例中，这些信息是用于生成粒子的正交点的 "JxW"。         
*利用这些信息，我们可以将正交点的贡献加入到local_matrix和local_rhs中。我们可以利用每个粒子的参考位置，轻松地评估每个粒子位置上的形状函数值。
*


* [1.x.137]
*
* [1.x.138] [1.x.139]。


*
* 该函数用FGMRES求解线性系统，并对对角线块进行块状预处理和代数多重网格（AMG）方法。该预处理程序对[2.x.263]（即速度-速度）块应用V循环，对[2.x.264]块应用质量矩阵的CG（这是我们对舒尔补码的近似值：上面组装的压力质量矩阵）。
*


* [1.x.140]
*
* [1.x.141] [1.x.142]。


*
* 我们以一种完全标准的方式处理网格细化问题。
*


* [1.x.143]
*
* [1.x.144] [1.x.145]。


*
* 我们使用deal.II的标准并行功能在流体域上输出结果（速度和压力）。编写一个压缩的vtu文件，将所有处理器的信息聚集在一起。额外的".pvd "记录被写入，将物理时间与vtu文件联系起来。
*


* [1.x.146]
*
* 同样地，我们通过[2.x.265]对象将粒子（无论是来自实体还是追踪器）写成一个单一的压缩vtu文件。这个简单的对象不写作为 "属性 "附加到粒子上的额外信息，而只写它们的id
*
* - 但是，无论如何，我们并不关心这些粒子位置的 "JxW "值，所以我们可能想要可视化的信息都不会丢失。
*


* [1.x.147]
*
* [1.x.148] [1.x.149]。


*
* 这个函数现在协调了整个模拟。它与其他时间相关的教程程序非常相似
*
* - 以[2.x.266]或[2.x.267]为例。在开始的时候，我们会输出一些状态信息，也会把所有的当前参数保存到输出目录下的一个文件中，以便于重现。
*


* [1.x.150]
*
* 然后我们开始时间循环。我们在第一个循环中初始化模拟的所有元素
*


* [1.x.151]
*
* 在第一个时间步长后，我们在每个时间步长的开始时对固体体进行位移，以考虑到它已经移动的事实。
*


* [1.x.152]
*
* 为了更新系统的状态，我们首先插值示踪粒子位置的流体速度，并采用天真的显式欧拉方案，对无质量示踪粒子进行漂移。
*


* [1.x.153]
*
* 使用这些新的位置，我们就可以组装斯托克斯系统并解决它。
*


* [1.x.154]
*
* 在适当的频率下，我们再将固体粒子、示踪粒子和流体域的信息写入文件，以便进行可视化，并通过调整网格来结束时间步骤。
*


* [1.x.155]
*
* [1.x.156] [1.x.157]。


*
* 代码的其余部分，即`main()`函数，是标准的，但对输入参数文件的处理除外。我们允许用户指定一个可选的参数文件作为程序的参数。如果没有指定，我们就使用默认文件 "parameters.prm"，如果不存在，我们就创建这个文件。文件名首先被扫描为字符串 "23"，然后是 "3"。如果文件名包含字符串 "23"，问题类将分别以模板参数2和3进行实例化。如果只找到 "3 "这个字符串，那么两个模板参数都被设置为3，否则都被设置为2。
*

*
* 如果程序的调用没有任何命令行参数（即`argc==1`），那么我们就默认使用 "参数.prm"。
*


* [1.x.158]
* [1.x.159][1.x.160] 。


* 运行本程序的目录中包含一些样本参数文件，你可以用它们来重现本节中的结果。如果你没有在命令行上指定参数文件作为参数，程序将默认读取文件"`参数.prm`"，并执行二维版本的代码。正如在源代码的讨论中所解释的那样，如果你的文件名包含字符串 "23"，那么程序将运行一个三维的问题，其中有一个同维的沉浸实体。如果文件名中包含字符串 "3"，那么它将运行一个三维问题，其中浸入的实体同维度为零，否则它将运行一个二维问题，其中浸入的实体同维度为零。
* 不管具体的参数文件名是什么，如果指定的文件不存在，当你执行程序时，你会得到一个异常，即找不到这样的文件。
* [1.x.161]
*
* 然而，正如错误信息所指出的，触发该异常的代码也将生成指定的文件（"parameters.prm "在本例中），该文件仅仅包含该程序所关心的所有参数的默认值（根据文件名中是否包含字符串 "23 "或 "3"，为正确的尺寸和辅助尺寸）。通过检查默认参数文件，我们看到以下内容。
* [1.x.162]

* 如果你现在运行该程序，你会在参数`Output directory`（默认为当前目录）指定的目录中得到一个名为`parameters_22.prm`的文件，其中包含上述参数的简短版本（没有注释和文档），记录了运行程序时使用的所有参数。
* [1.x.163]
*
* 首先创建 "parameters.prm "文件（程序第一次运行时），然后创建 "output/parameters_22.prm "文件（每次用现有的输入文件运行程序时），其理由是你可能想把大多数参数保留为默认值，只修改其中的一小部分，同时仍然能够重新产生结果，检查具体模拟使用了哪些参数。一般来说，把用于模拟的参数文件和模拟输出一起保存起来是很好的科学做法，这样你就可以在以后的时间里重复相同的运行。
* 另一个原因是，输入文件可能只包含那些与默认值不同的参数。例如，你可以在这个教程程序中使用以下（完全有效的）参数文件。
* [1.x.164]
* 你可以用Q3/Q2 Taylor-Hood有限元运行程序，运行101步，使用Nitsche惩罚为 "10"，并保留所有其他参数的默认值。输出目录不仅包含这些参数，而且包含模拟中使用的所有参数的记录。你可以在生成的文件 "parameters_22.prm "中查看所有其他参数。
*

*[1.x.165][1.x.166]


* 缺省问题产生了一个同维度的零叶轮，由一个旋转的矩形网格组成，其中旋转是在一个方向上的半个时间单位，和在相反方向上的半个时间单位，恒定角速度等于[2.x.268]。因此，叶轮做了一半的旋转，然后返回到原来的位置。下面的动画显示了速度的大小，固体叶轮和示踪粒子的运动。
*

* [2.x.269]
* 在一个核心上，程序的输出将看起来像下面这样。
* [1.x.167]
*
* 你可能会注意到，组装耦合系统比组装斯托克斯部分更昂贵。这在很大程度上取决于用于应用Nitsche限制的高斯点（固体粒子）的数量。在目前的情况下，使用的示踪粒子的数量相对较少。
* 下面的影片显示了解决方案随时间变化的情况。
* [1.x.168]
*
* 这部电影显示了灰色的旋转障碍物（实际上是用足够大的点绘制的固体粒子的叠加，使它们重叠），浅色的[1.x.169]（包括在模拟过程中特定时间形成的角顶点），以及蓝色色调的示踪粒子。
* 仿真显示，在结束的时候，示踪粒子已经在某种程度上回到了它们原来的位置，尽管它们已经被流场扭曲了。下面的图片比较了粒子在一个时间单位的流动后的初始和最终位置。
* [2.x.270]
* 在这种情况下，我们看到在叶轮扫过的体积之外的示踪剂颗粒已经回到了非常接近它们的初始位置，而在扫过的体积内的颗粒则稍微变形了一些。这种变形是不实际的。它是由用于漂移粒子的显式欧拉方案引起的数值误差、由虚构领域引起的精度损失以及最后由斯托克方程的离散化误差造成的。前两个错误是造成这种变形的主要原因，它们可以通过使用更细的网格和更小的时间步长来缓解。
*

*[1.x.170][1.x.171]


* 为了玩一玩，我们将虚构的领域复杂化（取自https://grabcad.com/library/lungstors-blower-1），并在三个空间维度上运行一个共维度的一元模拟，使用以下"`参数_23.prm`"文件。
* [1.x.172]
*
*在这种情况下，定时输出有点不同。
* [1.x.173]
*
* 现在，求解器在三维空间中占用了大部分的求解时间，就运行时间而言，粒子运动和Nitsche装配仍然相对不重要。
*


* [1.x.174]

*

*[1.x.175][1.x.176][1.x.177]


* 目前的教程程序显示了流体和固体之间的单向耦合，其中固体运动是强加的（而不是求解的），并通过利用固体正交点的位置和权重在固体域中读取。
* 代码的结构已经允许人们通过利用在实体网格的正交点上读取流体速度值的可能性来实现双向的耦合。为了提高MPI通信模式的效率，我们应该在拥有创建正交点的单元的实体处理器上保持正交点的所有权。在当前的代码中，只需定义用于交换正交点信息的向量的IndexSet，使用实体分区而不是初始流体分区。
* 这使得本教程程序中使用的技术与教程[2.x.271]中提出的技术相结合，以解决具有分布式拉格朗日乘数的流体结构相互作用问题，关于[2.x.272]对象。
* 上面的时间显示，目前的预处理策略对Nitsche惩罚并不奏效，如果我们想针对更大的问题，我们应该想出一个更好的预处理方法。此外，应该实施一个检查点重启策略，以允许较长的模拟被中断和恢复，例如在[2.x.273]教程中就有这样的做法。
*

* [1.x.178][1.x.179] [2.x.274] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-7_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27]
*[1.x.28][1.x.29][1.x.30] 。


*在这个程序中，我们将主要考虑两个方面。[2.x.2] [2.x.3] 验证程序的正确性和生成收敛表； [2.x.4] 亥姆霍兹方程的非均质诺伊曼边界条件。[2.x.5] 除了这些主题，还将展示各种改进和技巧。
*

*[1.x.31][1.x.32]


* 可能从来没有一个简单的有限元程序从一开始就能工作。因此，有必要找到方法来验证一个计算出来的解是否正确。通常，这可以通过选择模拟的设置来完成，这样我们就可以知道准确的连续解，并评估连续解和计算的离散解之间的差异。如果这个差值以正确的收敛顺序收敛为零，这已经是一个很好的正确性指示，尽管可能还有其他的误差源存在，而这些误差对总误差的贡献很小，或者是更高的顺序。在有限元模拟的背景下，这种通过选择适当的右手边和边界条件来选择解决方案的技术通常被称为[1.x.33]。
* 在这个例子中，我们不会去研究系统软件验证的理论，这是一个非常复杂的问题。相反，我们将展示deal.II在这方面可以提供的工具。这基本上是围绕着一个单一的函数的功能，[2.x.6]这个函数计算一个给定的连续函数和一个有限元场在每个单元上的各种规范之间的差异。当然，像任何其他积分一样，我们只能用正交公式来评估这些规范；因此，正确的正交公式的选择对于准确评估误差至关重要。这一点对于[2.x.7]准则尤其适用，我们只在正交点评估数值解和精确解的最大偏差；那么就不应该尝试使用正交公式，其评估只发生在[超级收敛](https://en.wikipedia.org/wiki/Superconvergence)可能发生的点上，例如最低阶高斯正交公式的高斯点，对于该矩阵的装配中的积分是正确的（例如，对于线性元素，不要使用QGauss(2)正交公式）。事实上，这通常也是对其他规范的良好建议：如果你的正交点偶然被选在由于超级收敛而导致误差特别小的位置，那么计算出来的误差看起来会比实际情况小得多，甚至可能表明收敛阶数更高。因此，我们将选择一个不同的正交公式来整合这些误差准则，而不是用于组装线性系统。
* 函数[2.x.8]对三角形的每个单元[2.x.9]进行所需规范的评估，并返回一个持有每个单元数值的向量。从局部值中，我们可以得到全局误差。例如，如果所有单元[2.x.12]的元素[2.x.11]的向量[2.x.10]包含局部[2.x.13]准则[2.x.14]，那么[1.x.34]就是全局[2.x.15]误差[2.x.16] 。
* 在程序中，我们将展示如何评估和使用这些量，并在网格细化过程中监测它们的值。当然，我们必须选择手头的问题，以便我们能够明确地说明解决方案和它的导数，但由于我们要评估程序的正确性，这只是合理。如果我们知道程序对一个（或者，如果想真正确定：许多）特别选择的右手边产生了正确的解决方案，我们可以相当有信心，它也会对我们不知道确切数值的问题计算出正确的解决方案。
* 除了简单地计算这些数量之外，我们还将展示如何从这个程序生成的数据中生成漂亮的格式化表格，并自动计算收敛率等。此外，我们还将比较不同的网格细化策略。
*

*[1.x.35][1.x.36]


* 本例程序的第二个完全不相关的主题是使用非同质边界条件。这些条件包括在使用边界积分的变异形式中，我们必须在组装右手边的矢量时进行数值评估。
* 在我们进行编程之前，让我们简单看一下数学公式。我们要解决的方程是亥姆霍兹方程，"带有漂亮的符号"：[1.x.37]在与[2.x.18]的正方形[2.x.17]上，在边界[2.x.20]的部分[2.x.19]上由迪里希特边界条件[1.x.38]增加，在其余部分[2.x.21]上由诺伊曼条件[1.x.39]增加。我们说这个方程有 "好的符号"，因为算子[2.x.23]与同位[2.x.24]和[2.x.25]是一个正定算子；[1.x.40]是[2.x.26]，是建立时间-谐波过程的结果。如果[2.x.27]很大，算子就不是正定的，这就导致了各种问题，我们不需要在这里讨论。该算子也可能不是可逆的
*
* - 即方程没有唯一的解
*
如果[2.x.28]恰好是[2.x.29]的一个特征值，则该方程没有唯一的解 *）。)
* 因为我们想验证我们的数字解[2.x.30]的收敛性，我们需要一个设置，以便我们知道精确的解[2.x.31]。这就是 "人造解法 "的作用。为此，让我们选择一个函数[1.x.41]，其中指数的中心[2.x.32]为[2.x.33]、[2.x.34]和[2.x.35]，而半宽被设置为[2.x.36]。然后制造方法说：选择
* [1.x.42]
* 有了这个特殊的选择，我们就可以推断出原来问题的解决方案当然是[2.x.37]。换句话说，通过以特定的方式选择方程的右边和边界条件，我们已经为自己制造了一个我们知道其解决方案的问题。这使我们能够计算出我们的数字解决方案的误差。在下面的代码中，我们用[2.x.39]类来表示[2.x.38]，其他类将用来表示[2.x.40]和[2.x.41] 。
* 使用上述定义，我们可以陈述该方程的弱表述，其内容为：为所有测试函数[2.x.43]找到[2.x.42]，从而找到[1.x.43]。边际项[2.x.44]是通过部分积分和使用[2.x.45]对[2.x.46]和[2.x.47]对[2.x.48]出现的。因此，在离散公式中，我们用来建立全局矩阵和右手边向量的单元矩阵和向量看起来是这样的：[1.x.44] 。
* 由于域积分的生成已经在前面的例子中展示过多次，这里只对等高线积分的生成感兴趣。它的工作原理如下：对于域积分，我们有一个[2.x.49]类，它提供了形状值和梯度，以及雅各布行列式和其他信息，并指定了单元格中的正交点；同样，还有一个[2.x.50]类，为单元格面上的积分执行这些任务。我们向它提供一个流形的正交公式，该流形的维度比域的维度小一，以及我们想要进行积分的单元格和其表面的数字。然后，该类将计算该面的正交点的值、梯度、法向量、权重等，然后我们可以以与域积分相同的方式使用这些值。下面的程序显示了这样做的细节。
*

*[1.x.45][1.x.46]


* 除了上面概述的数学主题外，我们还想用这个程序来说明良好编程实践的一个方面，即命名空间的使用。在为deal.II库编程时，我们非常注意不要为类和全局函数使用过于通用的名称，例如[2.x.51]等。此外，我们把所有的东西都放在命名空间[2.x.52]里。但是当一个人写的应用程序不是给别人使用的时候，就不一定会注意这么多了。如果你遵循[2.x.53]到[2.x.54]的编程风格，这些函数最终会出现在全局命名空间中，不幸的是，很多其他东西也住在那里（基本上是C语言提供的所有东西，以及你通过头文件从操作系统得到的所有东西）。更糟糕的是，C语言的设计者在避免使用通用名称方面也不总是很小心；例如，符号<code>j1,jn</code>在C头文件中被定义（它们表示贝塞尔函数）。
* 为了避免不同函数或变量的名称发生冲突时产生的问题（通常会出现混乱的错误信息），好的做法是将你所做的一切放到[1.x.47]中。按照这种风格，我们将在程序的顶部打开一个名字空间[2.x.55]，将deal.II名字空间导入其中，将本程序特有的一切（除了[2.x.56]，它必须在全局名字空间中）放入其中，并且只在文件的底部关闭它。换句话说，这个程序的结构是这样的
* [1.x.48]
* 我们将在整个deal.II教程的剩余部分遵循这一方案。
*

* [1.x.49] [1.x.50]。
* [1.x.51] [1.x.52]。
*

*
* 这些第一个包含文件在以前的例子中都已经处理过了，所以我们不会再解释其中的内容。
*


* [1.x.53]
*
* 在这个例子中，我们将不使用DoFHandler类默认使用的编号方案，而是使用Cuthill-McKee算法重新编号。正如在[2.x.57]中已经解释过的，必要的函数被声明在以下文件中。
*


* [1.x.54]
*
* 然后我们将展示一个小技巧，我们可以确保对象在仍在使用时不会被删除。为此，deal.II有一个SmartPointer辅助类，它在这个文件中声明。
*


* [1.x.55]
*
* 接下来，我们要使用介绍中提到的函数[2.x.58]，我们要使用一个ConvergenceTable，在运行过程中收集所有重要的数据，并在最后以表格形式打印出来。这些数据来自于以下两个文件。
*


* [1.x.56]
*
* 最后，我们需要使用FEFaceValues类，它与FEValues类在同一个文件中声明。
*


* [1.x.57]
*
* 在我们继续实际执行之前的最后一步是打开一个命名空间[2.x.59]，我们将把所有的东西放进去，正如在介绍的最后所讨论的那样，并把命名空间[2.x.60]的成员导入其中。
*


* [1.x.58]
*
* [1.x.59] [1.x.60]。


*
* 在实现实际求解的类之前，我们首先声明和定义一些代表右手边和求解类的函数类。由于我们要将数值得到的解与精确的连续解进行比较，我们需要一个代表连续解的函数对象。另一方面，我们需要右手边的函数，而这个函数当然与解共享一些特征。为了减少如果我们必须同时改变两个类中的某些东西而产生的依赖性，我们将两个函数的共同特征移到一个基类中。   
* 解（正如介绍中所解释的，我们选择三个指数之和）和右手边的共同特征是：指数的数量，它们的中心，以及它们的半宽。我们在以下类别中声明它们。由于指数的数量是一个编译时的常数，我们使用一个固定长度的[2.x.61]来存储中心点。
*


* [1.x.61]
*
* 表示指数中心和宽度的变量刚刚被声明，现在我们还需要给它们赋值。在这里，我们可以展示另一个小小的模板魔法，即我们如何根据维度给这些变量分配不同的值。我们在程序中只使用2维的情况，但我们展示1维的情况是为了阐述一个有用的技术。   
* 首先，我们为1d情况下的中心赋值，我们将中心等距离地放在
*
* - /3，0，和1/3。这个定义的<code>template &lt;&gt;</code>头显示了一个明确的专业化。这意味着，这个变量属于一个模板，但我们不是向编译器提供一个模板，让它通过用一些具体的值来替代[2.x.62]来专门化一个具体的变量，而是自己提供一个专门化，在这个例子中是[2.x.63] 。如果编译器在模板参数等于1的地方看到对这个变量的引用，它就知道它不需要通过替换[2.x.64]从模板中生成这个变量，而是可以立即使用下面的定义。
*


* [1.x.62]

* 同样地，我们可以为[2.x.65]提供一个明确的专业化。我们将2d情况下的中心放置如下。
*


* [1.x.63]

* 还需要给指数的半宽指定一个值。我们希望对所有维度使用相同的值。在这种情况下，我们只需向编译器提供一个模板，它可以通过用一个具体的值替换[2.x.66]来生成一个具体的实例。
*


* [1.x.64]
*
* 在声明和定义了解和右手的特征之后，我们可以声明代表这两个的类。它们都代表连续函数，所以它们都派生于Function&lt;dim&gt;基类，而且它们也继承了SolutionBase类中定义的特征。   
* 实际的类是在下面声明的。请注意，为了计算数值解与连续解在L2和H1（半）规范下的误差，我们必须提供精确解的值和梯度。这比我们在以前的例子中所做的要多，在以前的例子中，我们所提供的只是一个或一列点的值。幸运的是，Function类也有用于梯度的虚拟函数，所以我们可以简单地重载Function基类中各自的虚拟成员函数。请注意，一个函数在[2.x.67]空间维度上的梯度是一个大小为[2.x.68]的向量，即一个秩为1、维度为[2.x.69]的张量。就像其他很多东西一样，该库提供了一个合适的类。这个类的一个新特点是，它明确地使用了张量对象，之前在 [2.x.70] 和 [2.x.71] 中作为中间词出现。张量是标量（等级为零的张量）、向量（等级为一的张量）和矩阵（等级为二的张量）以及高维对象的概括。张量类需要两个模板参数：张量等级和张量维度。例如，在这里我们使用等级为一的张量（向量），维度为[2.x.72]项）。虽然这比使用Vector的灵活性要差一些，但当编译时知道向量的长度时，编译器可以生成更快的代码。此外，指定一个秩为一、维数为[2.x.73]的张量，可以保证张量具有正确的形状（因为它是内置于对象本身的类型中的），所以编译器可以为我们抓住大多数与尺寸有关的错误。
*


* [1.x.65]
*
*精确解类的值和梯度的实际定义是根据它们的数学定义，不需要过多解释。   
* 唯一值得一提的是，如果我们访问依赖于模板的基类的元素（在本例中是SolutionBase&lt;dim&gt;的元素），那么C++语言就会强迫我们写[2.x.74] ，同样，基类的其他成员也是如此。如果基类不依赖模板，C++就不需要[2.x.75]的限定。这一点的原因很复杂，C++书籍会在[1.x.66]这句话下解释，在deal.II的FAQ中也有很长的描述。
*


* [1.x.67]

* 同样，这也是对解的梯度的计算。  为了从指数的贡献中积累梯度，我们分配了一个对象[2.x.76]，它表示秩[2.x.77]和维[2.x.78]的张量的数学量。它的默认构造函数将其设置为只包含零的向量，所以我们不需要明确关心它的初始化。   
* 请注意，我们也可以把对象的类型取为Point&lt;dim&gt;而不是Tensor&lt;1,dim&gt;。等级1的张量和点几乎是可以交换的，而且只有非常细微的数学含义不同。事实上，Point&lt;dim&gt;类是由Tensor&lt;1,dim&gt;类派生出来的，这就弥补了它们的相互交换能力。它们的主要区别在于它们在逻辑上的含义：点是空间中的点，比如我们要评估一个函数的位置（例如，见这个函数的第一个参数的类型）。另一方面，秩1的张量具有相同的变换属性，例如，当我们改变坐标系时，它们需要以某种方式旋转；然而，它们不具有点所具有的相同内涵，只是比坐标方向所跨越的空间更抽象的对象。事实上，梯度生活在 "对等 "空间中，因为它们的分量的维度不是长度，而是一个超过长度的维度）。
*


* [1.x.68]
*
* 对于梯度，注意它的方向是沿着（x-x_i），所以我们把这个距离向量的倍数加起来，其中的因子是由指数给出。
*


* [1.x.69]
*
* 除了代表精确解的函数外，我们还需要一个函数，在组装离散化的线性方程组时，我们可以用它作为右手。这可以通过下面的类和其函数的定义来完成。请注意，这里我们只需要函数的值，而不是它的梯度或高阶导数。
*


* [1.x.70]
*
* 右手边的值是由解的负拉普拉斯加上解本身给出的，因为我们想解决亥姆霍兹方程。
*


* [1.x.71]
*
* 第一个贡献是拉普拉斯。
*


* [1.x.72]

* 而第二个是解决方案本身。
*


* [1.x.73]
*
* [1.x.74] [1.x.75]。


*
* 然后我们需要一个做所有工作的类。除了它的名字，它的接口与前面的例子基本相同。   
* 其中一个区别是我们将在几种模式下使用这个类：用于不同的有限元，以及用于自适应和全局细化。全局细化还是自适应细化的决定是通过在类的顶部声明的枚举类型传达给该类的构造函数的。然后，构造函数接收一个有限元对象和细化模式作为参数。   
* 除了[2.x.79]函数外，其余的成员函数与之前一样。在解被计算出来后，我们对它进行一些分析，比如计算各种规范的误差。为了实现一些输出，它需要细化周期的编号，因此得到它作为参数。
*


* [1.x.76]

* 现在是这个类的数据元素。在我们在以前的例子中已经使用过的变量中，只有有限元对象不同。这个类的对象所操作的有限元被传递给这个类的构造函数。它必须存储一个指向有限元的指针，供成员函数使用。现在，对于本类来说，这没有什么大不了的，但由于我们想在这些程序中展示技术而不是解决方案，我们将在这里指出一个经常出现的问题
*
* - 当然也包括正确的解决方案。     
* 考虑以下在所有例子程序中出现的情况：我们有一个三角形对象，我们有一个有限元对象，我们还有一个DoFHandler类型的对象，它同时使用前两个对象。这三个对象的寿命与其他大多数对象相比都相当长：它们基本上是在程序开始时或外循环时设置的，并在最后被销毁。问题是：我们能否保证DoFHandler使用的两个对象的寿命至少与它们被使用的时间相同？这意味着DoFHandler必须对其他对象的销毁情况有一定的了解。     
* 我们将在这里展示库是如何设法发现对一个对象仍有活动的引用，并且从使用对象的角度来看，该对象仍然活着。基本上，该方法是沿着以下思路进行的：所有受到这种潜在危险的指针的对象都是来自于一个叫做Subscriptor的类。例如，Triangulation、DoFHandler和FiniteElement类的一个基类都派生于Subscriptor。后面这个类并没有提供太多的功能，但是它有一个内置的计数器，我们可以订阅这个计数器，因此这个类的名字就叫 "订阅器"。每当我们初始化一个指向该对象的指针时，我们可以增加它的使用计数器，而当我们移开指针或不再需要它时，我们再减少计数器。这样，我们就可以随时检查有多少个对象还在使用该对象。此外，该类需要知道一个指针，它可以用来告诉订阅对象它的无效性。     
* 如果一个从Subscriptor类派生出来的对象被销毁，它也必须调用Subscriptor类的析构函数。在这个析构器中，我们使用存储的指针告诉所有订阅对象关于该对象的失效。当对象出现在移动表达式的右侧时，也会发生同样的情况，也就是说，在操作后它将不再包含有效的内容。在试图访问被订阅的对象之前，订阅类被期望检查存储在其相应指针中的值。     
* 这正是SmartPointer类正在做的事情。它基本上就像一个指针一样，也就是说，它可以被取消引用，可以被分配给其他指针，等等。除此之外，当我们试图解除引用这个类所代表的指针时，它使用上面描述的机制来找出这个指针是否是悬空的。在这种情况下，会抛出一个异常。     
* 在本例程序中，我们希望保护有限元对象，避免因某种原因导致所指向的有限元在使用中被破坏的情况。因此，我们使用了一个指向有限元对象的SmartPointer；由于有限元对象在我们的计算中实际上从未改变，我们传递了一个const FiniteElement&lt;dim&gt; 作为SmartPointer类的模板参数。请注意，这样声明的指针是在构造求解对象时被分配的，并在销毁时被销毁，所以对有限元对象销毁的锁定贯穿了这个HelmholtzProblem对象的生命周期。
*


* [1.x.77]
*
* 倒数第二个变量存储了传递给构造函数的细化模式。由于它只在构造函数中设置，我们可以声明这个变量为常数，以避免有人不由自主地设置它（例如，在 "if "语句中，==偶然被写成=）。
*


* [1.x.78]
*
* 对于每个细化级别，一些数据（比如单元格的数量，或者数值解的L2误差）将被生成，并在之后打印出来。TableHandler可以用来收集所有这些数据，并在运行结束后以简单文本或LaTeX格式的表格输出。在这里，我们不仅使用TableHandler，还使用了派生类ConvergenceTable，它还可以评估收敛率。
*


* [1.x.79]
*
* [1.x.80] [1.x.81]。



* [1.x.82] [1.x.83]。


*
* 在这个类的构造函数中，我们只设置作为参数传递的变量，并将DoF处理程序对象与三角形（不过目前是空的）联系起来。
*


* [1.x.84]
*
* [1.x.85] [1.x.86]。


*
* 下面的函数设置了自由度、矩阵和向量的大小等。它的大部分功能在以前的例子中已经展示过了，唯一的区别是在第一次分配自由度后立即进行重新编号的步骤。   
* 只要你使用库中的一种算法，重编自由度并不难。它只需要一行代码。这方面的一些更多信息可以在 [2.x.80] 中找到。   
* 然而，请注意，当你对自由度进行重新编号时，你必须在分配自由度后立即进行，因为诸如悬空节点、稀疏模式等都取决于重新编号后的绝对数。   
* 我们在这里介绍重新编号的原因是，它是一个相对便宜的操作，但往往有一个有利的效果。虽然CG迭代本身与自由度的实际排序无关，但我们将使用SSOR作为一个预处理程序。SSOR会经过所有的自由度，并做一些取决于之前发生的操作；因此，SSOR操作并不独立于自由度的编号，而且众所周知，它的性能会通过使用重新编号技术得到改善。一个小实验表明，确实如此，例如，用这里使用的Q1程序进行自适应细化的第五个细化周期的CG迭代次数，在没有重编号的情况下为40次，而在重编号的情况下为36次。在这个程序的所有计算中，一般都可以观察到类似的节省。
*


* [1.x.87]
*
* [1.x.88] [1.x.89]。


*
* 为手头的问题组装方程组，主要是像以前的例子程序一样。然而，有些事情还是发生了变化，所以我们对这个函数进行了相当广泛的评论。   
* 在该函数的顶部，你会发现通常的各种变量声明。与以前的程序相比，重要的是我们希望解决的问题也是双二次元的，因此必须使用足够精确的正交公式。此外，我们需要计算面的积分，即[2.x.81]维的对象。那么，面的正交公式的声明就很直接了。
*


* [1.x.90]
*
* 然后我们需要能够评估正交点上形状函数的值、梯度等的对象。虽然看起来用一个对象来做域积分和面积分应该是可行的，但有一个微妙的区别，因为域积分的权重包括域中单元的度量，而面积分的正交需要低维流形中面的度量。在内部，这两个类都根植于一个共同的基类，它完成了大部分工作，并为域积分和面积分提供了相同的接口。     
* 对于亥姆霍兹方程的双线性形式的域积分，我们需要计算值和梯度，以及正交点的权重。此外，我们需要实细胞上的正交点（而不是单位细胞上的正交点）来评估右手边的函数。我们用来获取这些信息的对象是之前讨论过的FEValues类。     
* 对于面积分，我们只需要形状函数的值，以及权重。我们还需要实心单元上的法向量和正交点，因为我们要从精确解对象中确定Neumann值（见下文）。给我们提供这些信息的类被称为FEFaceValues。
*


* [1.x.91]

* 然后我们需要一些从以前的例子中已经知道的对象。一个表示右侧函数的对象，它在单元格上正交点的值，单元格矩阵和右侧，以及单元格上自由度的指数。     
* 请注意，我们将对右手边对象进行的操作只是查询数据，而绝不会改变对象。因此我们可以声明它 [2.x.82] 。
*


* [1.x.92]
*
* 最后我们定义了一个表示精确解函数的对象。我们将用它来计算边界上的诺伊曼值。通常情况下，我们当然会用一个单独的对象来计算，特别是由于精确解通常是未知的，而诺伊曼值是规定的。然而，我们将有点偷懒，使用我们已经有的信息。当然，现实生活中的程序会在这里采取其他方式。
*


* [1.x.93]
*
* 现在是所有单元格的主循环。这与以前的例子基本没有变化，所以我们只对有变化的地方进行评论。
*


* [1.x.94]
*
* 首先改变的是双线性形式。它现在包含来自亥姆霍兹方程的附加项。
*


* [1.x.95]
*
* 然后是右手边的第二项，即等高线积分。首先我们要找出这个单元格的面与边界部分Gamma2的交点是否为非零。为此，我们对所有面进行循环，检查其边界指示器是否等于[2.x.83]，这是我们在下面的[2.x.84]函数中为组成Gamma2的边界部分指定的值。(边界指示器的默认值是[2.x.85]，所以只有在我们明确设置的情况下，面的指示器才能等于[2.x.86]。)
*


* [1.x.96]
*
* 如果我们进入这里，那么我们已经找到了一个属于Gamma2的外部面。接下来，我们必须计算形状函数的值和其他数量，这些都是我们在计算轮廓积分时需要的。这是用[2.x.87]函数完成的，我们已经从FEValue类中知道了。
*


* [1.x.97]

* 然后我们可以通过对所有正交点的循环来进行积分。               
* 在每个正交点上，我们首先计算法线导数的值。我们使用精确解的梯度和从[2.x.88]对象中得到的当前正交点处的面的法向量来进行计算。然后用它来计算这个面对右手边的额外贡献。
*


* [1.x.98]
*
* 现在我们有了本单元的贡献，我们可以把它转移到全局矩阵和右手边的向量上，就像前面的例子一样。
*


* [1.x.99]

* 同样，对边界值的消除和处理也在前面显示过。     
* 但我们注意到，现在我们插值边界值的边界指标（用[2.x.89]的第二个参数表示）不再代表整个边界。相反，它是我们没有指定其他指标的那部分边界（见下文）。因此，边界上不属于Gamma1的自由度被排除在边界值的插值之外，就像我们希望的那样。
*


* [1.x.100]
*
* [1.x.101] [1.x.102]。


*
*解方程组的方法与之前相同。
*


* [1.x.103]
*
* [1.x.104] [1.x.105]。


*
* 现在是做网格细化的函数。根据传递给构造函数的细化模式，我们进行全局或适应性细化。   
* 全局细化很简单，所以没有什么可评论的。  在适应性细化的情况下，我们使用的函数和类与前面的例子程序相同。请注意，我们可以将诺伊曼边界与迪里切特边界区别对待，事实上在这里也应该这样做，因为我们在部分边界上有诺伊曼边界条件，但是由于我们在这里没有描述诺伊曼值的函数（我们只是在组装矩阵时从精确解中构造这些值），我们省略了这个细节，尽管以严格正确的方式做这些并不难添加。   
* 在开关的最后，我们有一个看起来稍微有点奇怪的默认情况：一个[2.x.90]的条件。由于[2.x.91]宏在条件为假的时候会引发一个错误，这意味着只要我们碰到这个语句，程序就会被中止。这是故意的。现在我们只实现了两种细化策略（全局性和适应性），但有人可能想增加第三种策略（例如，具有不同细化标准的适应性），并在决定细化模式的枚举中增加第三个成员。如果不是switch语句的默认情况，这个函数会简单地运行到结束而不做任何事情。这很可能不是原意。因此，在deal.II库中，你会发现一个防御性的编程技术，那就是总是有默认的中止案例，以确保在switch语句中列出案例时没有考虑的值最终被抓住，并迫使程序员添加代码来处理它们。我们还将在下面的其他地方使用同样的技术。
*


* [1.x.106]
*
* [1.x.107] [1.x.108]。


*
* 最后，我们希望在计算出解决方案后对其进行处理。为此，我们用各种（半）准则对误差进行积分，并生成表格，这些表格以后将用于以漂亮的格式显示对连续解的收敛情况。
*


* [1.x.109]
*
* 我们的第一个任务是计算误差准则。为了整合计算出的数值解和连续解之间的差异（由本文件顶部定义的Solution类描述），我们首先需要一个向量来保存每个单元的误差准则。由于16位数的精度对这些数量来说并不那么重要，我们通过使用[2.x.92]而不是[2.x.93]的值来节省一些内存。     
* 下一步是使用库中的一个函数，计算每个单元的L2准则的误差。  我们必须将DoF处理程序对象、保存数值解的节点值的向量、作为函数对象的连续解、它应将每个单元上的误差准则放入的向量、计算该准则的正交规则以及要使用的准则类型传递给它。这里，我们使用高斯公式，在每个空间方向上有三个点，并计算L2规范。     
* 最后，我们想得到全局L2规范。这当然可以通过对每个单元上的规范的平方求和，并取该值的平方根来得到。这相当于取每个单元上的规范向量的l2（小写[2.x.94]）规范。
*


* [1.x.110]
*
* 通过同样的程序，我们得到H1半正态。我们重新使用[2.x.95]矢量，因为在计算了上面的[2.x.96]变量之后，它不再被使用。全局[2.x.97]半正态误差的计算方法是：取每个单元的误差的平方之和，然后取它的平方根。
*
*--这种操作是由[2.x.98]方便地执行的。
*


* [1.x.111]

* 最后，我们计算出最大规范。当然，我们实际上不能计算域中误差总体*点的真正最大值，而只能计算有限的评价点上的最大值，为了方便起见，我们仍然称之为 "正交点"，并以正交类型的对象表示，尽管我们实际上没有进行任何积分。     
* 然后就是我们想在哪些点上精确地进行评估的问题。事实证明，我们得到的结果相当敏感地取决于所使用的 "正交 "点。还有一个超融合的问题。在某些网格上，对于多项式程度[2.x.99]，有限元解决方案在节点点以及Gauss-Lobatto点上特别精确，比随机选择的点要精确得多。(见[2.x.100]和第1.2节的讨论和参考文献，以了解更多这方面的信息)。换句话说，如果我们有兴趣找到最大的差值[2.x.101]，那么我们应该看一下[2.x.102]，这些点特别不属于这种 "特殊 "的点，而且我们特别不应该用`QGauss(fe->degree+1)`来定义我们的评估位置。相反，我们使用一个特殊的正交规则，该规则是通过梯形规则迭代有限元的度数乘以2再加上每个空间方向的1而得到的。注意，QIterated类的构造函数需要一个一维正交规则和一个数字，这个数字告诉它在每个空间方向上重复这个规则的频率。     
* 使用这个特殊的正交规则，我们就可以尝试找到每个单元的最大误差。最后，我们通过调用[2.x.103]来计算每个单元上的L无穷大误差的全局L无穷大误差。
*


* [1.x.112]
*
* 在所有这些错误被计算出来之后，我们终于写了一些输出。此外，我们通过指定列的键和值将重要的数据添加到TableHandler中。  注意，没有必要事先定义列的键值
*
* - 只需添加值即可，列将按照第一次添加值的顺序被引入到表中。
*


* [1.x.113]
*
* [1.x.114] [1.x.115]。


*
* 和以前的例子程序一样，[2.x.104]函数控制执行的流程。基本布局与以前的例子一样：在连续细化的网格上有一个外循环，在这个循环中首先是问题设置，组装线性系统，求解，和后处理。   
* 主循环的第一个任务是创建和细化网格。这和以前的例子一样，唯一的区别是我们想把边界的一部分标记为诺伊曼型，而不是迪里希型。   
*为此，我们将使用以下惯例。属于Gamma1的面将有边界指示器[2.x.105]（这是默认的，所以我们不需要明确设置），属于Gamma2的面将使用[2.x.106]作为边界指示器。  为了设置这些值，我们在所有单元格上循环，然后在给定单元格的所有面上循环，检查它是否是我们想用Gamma2表示的边界的一部分，如果是，则将其边界指示器设置为 [2.x.107] 。在本程序中，我们认为左边和底部的边界是Gamma2。我们通过询问一个面的中点的x或y坐标（即向量分量0和1）是否等于该边界的一部分来确定该面的边界。
*
* - ，我们必须给一些小的回旋余地，因为比较浮点数是不稳定的，这些浮点数在中间计算中会被舍去。   
* 值得注意的是，我们必须在这里对所有单元进行循环，而不仅仅是活动单元。原因是在细化时，新创建的面会继承其父面的边界指标。如果我们现在只设置活动面的边界指示器，粗化一些单元并在以后细化它们，它们将再次拥有我们没有修改的父单元的边界指示器，而不是我们想要的那个。因此，我们必须改变Gamma2上所有单元的面的边界指标，无论它们是否处于活动状态。另外，我们当然也可以在最粗的网格上完成这项工作（即在第一个细化步骤之前），之后再细化网格。
*


* [1.x.116]

* 接下来的步骤在以前的例子中已经知道了。这主要是每个有限元程序的基本设置。
*


* [1.x.117]
*
* 在这一连串的函数调用中，最后一步通常是对自己感兴趣的量的计算解进行评估。这是在下面的函数中完成的。由于该函数产生的输出显示了当前细化步骤的编号，因此我们将这个编号作为一个参数传递。
*


* [1.x.118]
*
* [1.x.119] [1.x.120]。


*
* 在最后一次迭代之后，我们在最好的网格上输出解决方案。这是用下面的语句序列完成的，我们在以前的例子中已经讨论过了。第一步是生成一个合适的文件名（在此称为[2.x.108]，因为我们希望以VTK格式输出数据；我们在下面的内容中加入前缀以区别于其他输出文件的文件名）。在这里，我们通过网格细化算法来增加名称，和上面一样，我们要确保在添加了另一种细化方法而没有通过下面的switch语句来处理时，我们会中止程序。
*


* [1.x.121]
*
* 我们用一个后缀来增加文件名，表示我们在计算中使用的有限元。为此，有限元基类将每个坐标变量中形状函数的最大多项式程度存储为一个变量[2.x.109]，我们在切换语句中使用（注意，双线性形状函数的多项式程度实际上是2，因为它们包含术语[2.x.110]；但是，每个坐标变量中的多项式程度仍然只有1）。我们再次使用同样的防御性编程技术来防止多项式阶数有意外值的情况，在switch语句的默认分支中使用[2.x.111]这个成语。
*


* [1.x.122]
*
* 一旦我们有了输出文件的基本名称，我们就会为VTK输出添加一个合适的扩展名，打开一个文件，并将解决方案的向量添加到将进行实际输出的对象中。
*


* [1.x.123]
*
* 现在像以前一样建立中间格式是下一步。我们在这里再介绍一下deal.II的一个特点。其背景如下：在这个函数的一些运行中，我们使用了双曲线有限元。然而，由于几乎所有的输出格式都只支持双线性数据，所以数据只写成了双线性，信息因此而丢失。  当然，我们不能改变图形程序接受其输入的格式，但我们可以用不同的方式来写数据，这样我们就能更接近于四次方近似中的信息。例如，我们可以把每个单元写成四个子单元，每个子单元都有双线数据，这样我们在三角图中的每个单元都有九个数据点。当然，图形程序显示的这些数据仍然只是双线性的，但至少我们又给出了一些我们拥有的信息。     
* 为了允许每个实际的单元格写一个以上的子单元，[2.x.112]函数接受一个参数（默认是[2.x.113]，这就是为什么你在以前的例子中没有看到这个参数）。这个参数表示每个空间方向的单元应被细分为多少个子单元来输出。例如，如果你给出[2.x.114]，这将导致2D中的4个单元和3D中的8个单元。对于二次元元素，每个空间方向的两个子单元显然是正确的选择，所以这就是我们所选择的。一般来说，对于多项式阶数的元素[2.x.115]细分，元素的顺序也是按上述方法确定的。     
* 有了这样生成的中间格式，我们就可以实际编写图形输出了。
*


* [1.x.124]
*
* [1.x.125] [1.x.126]。


*
* 在图形输出之后，我们还想从我们在 [2.x.116] 中做的误差计算中生成表格。在那里，我们用每个细化步骤的单元格数量以及不同规范的误差来填充一个表格对象。
*

*
* 为了使这些数据有更好的文本输出，人们可能想设置输出时写入数值的精度。我们使用3位数，这对错误规范来说通常是足够的。默认情况下，数据是以定点符号写入的。然而，对于人们希望看到的科学符号的列，另一个函数调用设置[2.x.117] ，导致数字的浮点表示。
*


* [1.x.127]
*
* 对于输出到LaTeX文件的表格，默认的列的标题是作为参数给[2.x.118]函数的键。要想拥有不同于默认的TeX标题，你可以通过以下函数调用来指定它们。注意，"\\"被编译器简化为"\"，因此真正的TeX标题是，例如，"[2.x.119] -error"。
*


* [1.x.128]
*
* 最后，表格中每一列的默认LaTeX格式是`c'（居中）。要指定一个不同的（如 "右"），可以使用以下函数。
*


* [1.x.129]
*
* 在这之后，我们终于可以把表写到标准输出流[2.x.120]（在多写了一行空行之后，使事情看起来更漂亮）。注意，文本格式的输出是非常简单的，而且标题可能不会直接打印在特定的列上面。
*


* [1.x.130]
*
* 该表也可以被写进LaTeX文件。  在调用 "latex filename "和例如 "xdvi filename "后，可以查看（很好的）格式化的表格，其中filename是我们现在要写入输出的文件名。我们构建文件名的方法和以前一样，但有一个不同的前缀 "error"。
*


* [1.x.131]
*
* [1.x.132] [1.x.133]。


*
* 在全局细化的情况下，可能会对输出收敛率感兴趣。这可以通过ConvergenceTable提供的比常规TableHandler的功能来实现。然而，我们只为全局细化做了这个工作，因为对于自适应细化来说，确定类似收敛顺序的东西是比较麻烦的。在此过程中，我们还展示了一些可以用表来做的其他事情。
*


* [1.x.134]
*
* 第一件事是，人们可以将单个的列组合在一起，形成所谓的超级列。从本质上讲，这些列保持不变，但被分组的那些列会得到一个贯穿于一个组中所有列的标题。例如，让我们把 "周期 "和 "单元格 "两列合并成一个名为 "n单元格 "的超级列。
*


* [1.x.135]
*
* 接下来，没有必要总是输出所有的列，或者按照它们在运行过程中最初添加的顺序。选择和重新排列列的工作方式如下（注意，这包括超级列）。
*


* [1.x.136]
*
* 对于在这之前发生在ConvergenceTable上的一切，使用一个简单的TableHandler就足够了。事实上，ConvergenceTable是由TableHandler派生出来的，但它提供了自动评估收敛率的额外功能。例如，下面是我们如何让表计算减少率和收敛率（收敛率是减少率的二进制对数）。
*


* [1.x.137]
*
* 这些函数的每一次调用都会产生一个额外的列，与原来的列（在我们的例子中是 "L2 "和 "H1 "列）合并成一个超级列。
*

*
* 最后，我们想再次写下这个收敛图，首先写到屏幕上，然后以LaTeX格式写到磁盘上。文件名也是如上构造。
*


* [1.x.138]
*
* 在进入[2.x.121]之前的最后一步是关闭命名空间[2.x.122]，我们已经把这个程序所需要的东西都放进了这个命名空间。
*


* [1.x.139]
*
* [1.x.140] [1.x.141]。


*
* 主函数主要和以前一样。唯一不同的是，我们要解三次，一次是Q1和适应性细化，一次是Q1元素和全局细化，一次是Q2元素和全局细化。
*

*
* 因为我们在下面为两个空间维度实例化了几个模板类，所以我们通过在函数的开头声明一个常数来表示空间维度的数量，使其更加通用。如果你想在1d或2d中运行程序，那么你只需要改变这个实例，而不是下面的所有用法。
*


* [1.x.142]
*
* 现在是对主类的三次调用。每个调用都被封锁在大括号中，以便在封锁结束后，在我们进入下一个运行之前销毁各自的对象（即有限元和HelmholtzProblem对象）。这就避免了变量名称的冲突，也确保了在三次运行中的一次结束后立即释放内存，而不是只在[2.x.123]块的末尾释放。
*


* [1.x.143]
* [1.x.144][1.x.145] 。



* 该程序产生两种输出。第一种是输出文件 [2.x.124] 、 [2.x.125] 和 [2.x.126] 。我们在这里以三维视图的形式展示后者。
*

* [2.x.127]



*

* 第二，程序不仅将表格写入磁盘，而且在运行时也写入屏幕。输出结果如下（记得标记为"[2.x.128]"的列实际上显示的是错误的[2.x.129][1.x.146]范围，而不是完整的[2.x.130]范围）。
*


* [1.x.147]

*

* 人们可以看到网格细化后的误差减少，对于进行全局细化的情况，也可以看到收敛率。可以清楚地看到Q1和Q2元素在[2.x.131]半规范下的线性和二次收敛率，以及[2.x.132]规范下的二次和三次收敛率。
*


*

* 最后，该程序还生成了LaTeX版本的表格（此处未显示），这些表格被写进了一个文件中，这样它就可以被复制粘贴到LaTeX文档中。
*

*[1.x.148][1.x.149]


* 我们在上面所展示的是如何在一些不同的规范中确定误差[2.x.133]的大小。我们这样做的主要原因是我们对测试我们的解决方案是否能转换*感兴趣。但是从工程的角度来看，这个问题往往更实际：我必须把我的网格做得多细才能使误差 "足够小"？换句话说，如果在上表中，[2.x.134]的半规范已经减少到`4.121e-03'，这是否足以让我们在蓝图上签字，宣布我们的数值模拟显示桥梁足够坚固？
* 在实践中，我们很少遇到这种情况，因为我通常不能在重要的情况下将数值解[2.x.135]与精确解[2.x.136]进行比较。
*
* - 如果我知道[2.x.137]，我就不必计算[2.x.138]。但是，即使我可以，一般要问的问题是。`4.121e-03`是什么*？解决方案会有物理单位，比如说公斤-米-平方，我在域上积分一个以上述单位为平方的函数，然后取其平方根。因此，如果领域是二维的，[2.x.139]的单位是公斤-米-立方。那么问题来了。[2.x.140]的单位是千克-米-立方吗？这取决于你要模拟的是什么。如果你是一个天文学家，习惯于以太阳质量为单位的质量和以光年为单位的距离，那么是的，这是一个小得惊人的数字。但如果你是做原子物理的，那就不是：这并不小，而且你的误差肯定也不够小；你需要一个更细的网格。
* 换句话说，当我们看这些数字的时候，我们通常需要与一个 "尺度 "进行比较。一种方法是不看绝对*误差[2.x.141]的任何规范，而是看
*相对*误差[2.x.142]。如果这个比率是[2.x.143]，那么你就知道，平均*来说，[2.x.144]和[2.x.145]之间的差异是0.001%。
*
* - 可能对工程而言足够小。
* 我们如何计算[2.x.146]？我们只需要做一个整体单元的积分循环，在这些单元上做正交点，然后把东西加起来，最后取平方根。但有一个更简单的方法经常使用。你可以调用
* [1.x.150]
* 这将计算出[2.x.147]。另外，如果你特别聪明，不喜欢创建 "零向量"，你可以用这个方法，如果网格不是太粗，那么就用[2.x.148]，我们可以通过调用[2.x.149]计算。
* [1.x.151]
* 在这两种情况下，我们只需要像在程序中一样，通过调用[1.x.152]将单元网格的向量合并为一个全局规范。
* [1.x.152]
*
*


*[1.x.153][1.x.154]


*[1.x.155][1.x.156]


* 继续运行具有高阶元素的程序（[2.x.150] , [2.x.151] , ...）。你会注意到，代码的几个部分的断言将被触发（例如，在为数据输出生成文件名时）。你可能必须解决这些问题，但要使程序正常工作应该不是很困难。
* [1.x.157][1.x.158] 。
*

* Q1或Q2更好吗？自适应细化和全局细化又如何呢？比较它们的一个（有些不公平，但很典型）指标是看误差与未知数的函数。
* 要看到这一点，创建一个对数风格的图，未知数在[2.x.152]轴上，[2.x.153]误差在[2.x.154]轴上。你可以为[2.x.155]和[2.x.156]添加参考线，并检查全局和适应性细化是否遵循这些参考线。如果我们做一个（并非完全不合理的）假设，即对于一个好的线性求解器，计算工作与未知数[2.x.157]的数量成正比，那么很明显，[2.x.158]的误差减少大大优于[2.x.159]形式的减少：也就是说，与使用全局细化相比，自适应细化以更少的计算工作给我们带来期望的误差水平。这不是一个特别令人惊讶的结论，但是值得在实践中检查这些假设。
* 当然，更公平的比较是在[2.x.160]轴上绘制运行时间（先切换到释放模式！）而不是未知数的数量。如果你通过对每个精炼步骤进行计时（例如，使用Timer类），将运行时间与未知数的数量作对比，你会发现线性求解器并不完美
*
* - 其运行时间的增长速度与线性系统的大小不成正比
*
* - 挑选一个更好的线性求解器可能适合于这种比较。
*

* [1.x.159][1.x.160] [2.x.161] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-71_0.txt
[0.x.0]*
 [2.x.0]
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32][1.x.33]
* [2.x.1]
* [1.x.34]


*[1.x.35][1.x.36]


* 本教程的目的很简单，就是介绍[自动](https://en.wikipedia.org/wiki/Automatic_differentiation)和[符号微分](https://en.wikipedia.org/wiki/Computer_algebra)（分别缩写为AD和SD）的基本原理。人们可以在源代码中描述一个函数[2.x.2]，并自动获得导数[2.x.3]（"Jacobian"）、[2.x.4]（"Hessian"）等的表示方法，而无需编写额外的代码行。这样做对解决非线性或优化问题很有帮助，因为人们只想在代码中描述非线性方程或目标函数，而不必同时提供它们的导数（对于解决非线性问题的牛顿方法或寻找最小化器来说，这是必要的）。
* 由于AD和SD工具在某种程度上独立于有限元和边界值问题，本教程将与你之前可能读过的其他教程不同。它将特别关注这些框架是如何工作的，以及它们背后的原理和思想，并将放弃在有限元模拟的直接背景下看待它们。
* 事实上，我们将研究两组不同的问题，它们的复杂程度大相径庭，但如果框架适当，就有足够的相似性，同样的AD和SD框架可以被利用。通过这些例子，我们的目的是建立起对使用AD和SD工具所需步骤的理解，以及它们之间的区别，并希望能找出它们可以立即用于改进或简化现有代码的地方。
* 你可能想知道AD和SD是什么，首先。好吧，这个问题很容易回答，但如果没有上下文，就没有很好的洞察力。我们不打算在这个介绍中涉及这个问题，而是将这个问题推迟到第一个介绍性的例子中，在这个例子中我们将列出关键点。作为补充，我们应该提到，这两个框架的核心理论在[2.x.5]模块中得到了广泛的讨论，所以在此无需重复。
* 由于我们必须选择一些*足够有趣的主题来研究和确定AD和SD可以有效使用的地方，在本教程的后半部分所涉及的主要问题是对一个耦合构成法的建模，特别是磁活性材料（具有滞后效应）。作为介绍的一种手段，在介绍的后面将介绍该类材料的一些基础理论。自然，这不是一个广泛受众感兴趣的领域（甚至不是一类材料）。因此，作者希望预先说明，这个理论和任何后续的推导都不能被认为是本教程的重点。相反，请记住从相对无害的构成法则描述中产生的问题的复杂性，以及我们可能(在边界值问题的背景下)需要从中推导出什么。我们将用这些构成法则在代表连续体点的水平上进行一些计算(所以，仍然在连续体力学领域)，并将产生一些基准结果，我们可以围绕这些结果对计算性能的主题进行最后讨论。
* 一旦我们有了可以建立进一步概念的基础，我们将看到如何在有限元(而不是连续体)水平上特别利用AD：这是一个在[2.x.6]以及[2.x.7]中涉及的主题。但在此之前，让我们花点时间想想为什么我们可能要考虑使用这些工具，以及它们可能给你带来什么好处。
*

*[1.x.37][1.x.38]


* 使用AD或SD的主要驱动力通常是，有一些情况需要进行区分，而且这样做有足够的挑战性，使使用外部工具来执行该特定任务的前景具有吸引力。对AD或SD最有用的情况进行了广泛的分类，包括（但可能不限于）以下几种情况。
*
* - [1.x.39] 对于一类新的问题，你正试图快速实现一个解决方案，并希望去除一些复杂的细节（在数学和代码本身的组织结构方面）。你可能愿意证明任何额外的计算成本是合理的，这将被重组你的代码或修改问题中引入一些复杂的非线性的部分的敏捷性所抵消，只需最小的努力。
*
* - [1.x.40]很可能有些问题恰好有一个非线性，对线性化或手工制定有极大的挑战。  如果有一个工具为你解决这个挑战，那么在大多数情况下，它是强大的、可靠的和准确的，可能会减轻实现某些问题的痛苦。这方面的例子包括[2.x.8]，我们解决的非线性PDE的导数并不难推导，但足够繁琐，人们必须注意用手来做，而且实现牛顿步骤的相应有限元公式需要的不仅仅是实现双线性形式一般需要的几行；[2.x.9]（我们实际上使用AD）是一个更极端的例子。
*
* - [1.x.41]对于表现出非线性响应的材料和模拟，准确的而不是只有近似的材料切线（机械工程师对材料定律的导数使用的术语）可能是收敛和发散行为之间的区别，特别是在高外部（或耦合）载荷下。  随着问题复杂性的增加，引入细微的（或者，也许不是那么细微的）错误的机会也在增加，这些错误会产生可预见的负面结果。  此外，通过验证实现是完全正确的，也有很多好处。例如，某些类别的问题已知会表现出不稳定性，因此，当你在非线性求解器（例如牛顿方法）中开始失去二次收敛时，那么这对研究者来说可能不是一个巨大的惊喜。然而，很难（如果不是不可能）区分以下两种收敛行为：一种是你接近不稳定的解时产生的收敛行为，另一种是你在材料或有限元线性化中出现了错误，并因此开始偏离最佳收敛路径。例如，拥有一种验证构成法线性化实现的正确性的方法，也许是你用来捕捉这种错误的唯一有意义的方法，假设你没有其他人来检查你的代码。  值得庆幸的是，通过一些战术性的编程，可以很直接地将代码结构化，以便重复使用，这样你就可以在生产代码中使用相同的类，并直接在例如单元测试框架中验证它们。
* 这个教程程序将有两个部分。一部分，我们只是用一组简单的例子来介绍deal.II中自动和符号微分支持的基本思想；另一部分，我们将其应用于一个现实的但更复杂的案例。对于后半部分，下一节将提供一些关于磁性机械材料的背景资料。
*
* 如果你只想了解什么是AD和SD，你可以跳过这一节，但如果你对如何将AD和SD应用于具体的情况感兴趣，你可能想读完这一节。
*

*[1.x.42][1.x.43] 。


*[1.x.44][1.x.45]


* 在介绍我们将用来建立磁活性聚合物模型的磁机械耦合材料法之前，我们将首先对这些构成法则必须遵守的突出的热力学进行非常简明的总结。这里总结的理论基础由Truesdell和Toupin[2.x.10]以及Coleman和Noll[2.x.11]详细描述，并遵循Holzapfel[2.x.12]提出的逻辑。
* 从热力学第一定律开始，并遵循一些技术假设，可以证明动能加内能率与外部资源提供给系统的功率之间的平衡由以下关系给出，该关系等同于左侧（任意）体积[2.x.13]中的能量变化率和右侧作用在该体积上的力之和：[1.x.46这里[2.x.14]代表总时间导数，[2.x.15]是在拉格朗日参考框架下测量的材料密度，[2.x.16]是材料速度，[2.x.17]是其加速度，[2.x.18]是每单位参考体积的内能，[2.x.19]是总皮奥拉应力张量，[2.x.20] 是变形梯度张量的时间速率，[2.x.21] 和 [2.x.22]分别是磁场矢量和磁感应强度（或磁通密度）矢量，[2.x.23]和[2.x.24]是电场矢量和电位移矢量，以及[2.x.25]和[2.x.26材料微分算子[2.x.27]，其中[2.x.28]是材料位置矢量。随着一些条款的重新排列，引用积分体积的任意性[2.x.29]，总的内能密度率[2.x.30]可以确定为[1.x.47]。总的内能不仅包括由于机械变形（第一项）、热通量和热源（第四项和第五项）而产生的贡献，还包括由于储存在磁场和电场本身的内在能量（分别为第二项和第三项）。
* 热力学第二定律，也被称为熵不平等原则，告诉我们某些热力学过程是不可逆的。在考虑了总熵和熵的输入率之后，可以得出克劳修斯-杜姆不等式。在局部形式下（以及在物质配置中），这读作[1.x.48]量[2.x.31]是绝对温度，[2.x.32]代表每单位参考体积的熵值。
* 用它来代替热力学第一定律结果中的[2.x.33]，我们现在有了这样的关系[1.x.49]，根据傅里叶定律，它告诉我们热量从高温区域流向低温，最后一项总是正的，可以忽略。在等温条件的假设下，电场不会以被认为是不可忽略的方式激发材料，那么这个耗散不等式就会减少为[1.x.53] 。
*[1.x.54][1.x.55] 。
*

*当考虑到表现出机械耗散行为的材料时，可以证明这可以通过用代表内部变量的额外参数来增加材料自由能密度函数来捕获耗散不等式[2.x.36] 。因此，我们把它写成[1.x.56]，其中[2.x.37]代表与第i个机械耗散（粘性）机制相关的内部变量（其作用类似于变形梯度的测量）。这是自然的参数化，是所考虑的平衡定律的结果。如果这样一类材料被纳入到有限元模型中，就会发现需要采用某种磁问题的表述，即磁矢量势表述。这有它自己的一套挑战，所以在可能的情况下，更简单的磁标量势公式可能被优先考虑。在这种情况下，磁性问题需要以磁场为参数 [2.x.40] 。为了进行这种重新参数化，我们执行最后的Legendre变换[1.x.57]。同时，我们可以利用材料框架差异的原则，以便用对称变形量来表达能量密度函数：[1.x.58]这两种变换的结果（撇开相当多的明确和隐藏的细节）使还原耗散质量的最终表达式为[1.x.59应力量[2.x.41]被称为Piola-Kirchhoff总应力张量，其能量共轭物[2.x.42]是右Cauchy-Green变形张量，[2.x.43]是与第i种机械耗散（粘性）机制相关的重新参数化的内部变量。
* 对能量密度函数的材料速率进行扩展，并对各种条款进行重新排列，结果是表达式[1.x.60]在这一点上，值得注意的是[偏导数](https://en.wikipedia.org/wiki/Partial_derivative) [2.x.44]的使用。这是一个重要的细节，对教程中的某个设计选择至关重要。简单提醒一下这意味着什么，多变量函数的偏导返回该函数相对于其中一个变量的导数，同时保持其他变量不变：[1.x.61]更具体到耗散不等式中的编码（用非常通用的自由能量密度函数[2.x.45]，其参数化有待正式确定），如果一个输入变量是另一个变量的函数，它也被保持不变，连锁规则不会进一步传播，而计算总衍生物将意味着明智地使用连锁规则。通过比较以下两个语句可以更好地理解这一点。
* [1.x.62]
*
* 回到问题的热力学，我们接下来利用数量[2.x.46]和[2.x.47]的任意性，通过应用科尔曼-诺尔程序[2.x.48], [2.x.49].这导致了动力学共轭数量的识别[1.x.63从耗散功率中剩下的项（即与机械耗散机制有关的项）来看，如果假定它们是相互独立的，那么，对于每个机制`i`，[1.x.64]这一约束必须通过自由能函数的适当选择以及仔细考虑的内部变量的演化规律来满足。
* 如果在结构模型中没有耗散机制（例如，如果要建模的材料是磁超弹性的），那么自由能密度函数[2.x.50]就会减少为储存能量密度函数，总应力和磁感应可以简化。
* [1.x.65]
*其中算子[2.x.51]表示总导数操作。
* 为了完整起见，应力张量和磁感应的线性化在四阶总参考弹性张量[2.x.52]、二阶磁静力张量[2.x.53]和三阶总参考磁弹性耦合张量[2.x.54]中得到体现。无论[2.x.55]和[2.x.56]的参数化如何，这些量可以通过以下方式计算
* [1.x.66]
* 对于速率依赖型材料的情况，这扩展为
* [1.x.67]
*而对于与速率无关的材料，线性化为
* [1.x.68]
* 它们之间的细微差别是在计算第一个导数时应用了一个偏导。我们将在后面看到这如何影响这个具体应用中AD与SD的选择。现在，我们将简单地介绍一下本教程中实施的两种具体材料。
*[1.x.69][1.x.70]
*

* 我们要考虑的第一种材料是受磁-超弹性构成规律支配的材料。这种材料对变形和浸入磁场都有反应，但表现出与时间或历史有关的行为（如通过粘性阻尼或磁滞的耗散，等等）。这种材料的存储能量密度函数*只在（当前）场变量方面进行参数化，而不是它们的时间导数或过去的值。
* 我们将选择能量密度函数，它既能捕捉到由于变形和磁化而储存在材料中的能量，也能捕捉到储存在磁场本身中的能量，它是[1.x.71]与[1.x.72]，对其而言，变量[2.x.57]（[2.x.58]是等级2的身份张量）代表空间维度，[2.x.59]是形变梯度张量。为了给[2.x.60]的各个组成部分提供一些简要的背景，前两个条款与（超弹性）Neohookean材料的存储能量密度函数非常相似。这里使用的东西和Neohookean材料之间的唯一区别是弹性剪切模量被磁场敏感的饱和函数[2.x.61]缩放（见[2.x.62]，公式29）。这个函数实际上会使材料在强磁场的存在下变硬。由于它是由一个sigmoid类型的函数控制的，剪切模量将渐进地收敛于指定的饱和剪切模量。还可以证明，[2.x.63]中的最后一项是磁场的储能密度函数（从第一原理推导出来的），由相对渗透率常数缩放。这个定义共同意味着材料是线性磁化的，也就是说，磁化矢量和磁场矢量是一致的。(这在以电流形式表示的磁能中当然不明显，但当磁感应和磁化从[2.x.64]中导出，并且所有磁场都以[2.x.65]的电流构型[2.x.66]表示时，这种相关性就变得很清楚了。)至于磁感应、应力张量和各种材料切线的具体细节，我们将把这些推迟到教程正文中介绍，其中定义了构成法的完整、无辅助的实施。
*[1.x.73][1.x.74]
*

*我们将制定的第二个材料是一个具有单一耗散机制`i`的磁-粘弹性材料。
* [1.x.75]
我们将考虑的自由能量密度函数*定义为*[1.x.75]，其中[1.x.76][1.x.77]和内部粘性变量的演化规律[1.x.78]。我们已经选择了能量的磁弹性部分[2.x.67]来匹配我们探索的第一个材料模型，所以这部分不需要进一步解释。至于粘性部分[2.x.68]，自由能的这一部分（与粘性变形张量的演化规律一起）取自[2.x.69]（通过[2.x.70]中描述的粘性饱和函数进行额外的缩放）。它是在一个热力学上一致的框架中得出的，其核心是对聚合物链在微观尺度上的运动进行建模。
* 选择隐式一阶逆向差分方案，那么[1.x.79]中的上标[2.x.71]表示该量是在当前的时间步长上取的，[2.x.72]表示在前一时间步长上取的量（即历史变量）。将条款重新排列，使当前时间的所有内部变量量都在方程的左侧，我们得到[1.x.80]，与[2.x.74]方程54相匹配。
*[1.x.81][1.x.82] 。
*

* 我们希望对我们制定的材料定律做一些有意义的事情*，因此将它们置于一些机械和磁载荷条件下是有意义的，这些条件在某种程度上代表了在应用或实验室环境中可能发现的一些条件。实现这一目标的方法之一是将这些构成法则嵌入到模拟设备的有限元模型中。但在这个例子中，我们将保持简单（毕竟我们的重点是自动和符号微分概念），并将找到一个简明的方法来忠实地复制一个行业标准的流变学实验，使用负载条件的分析表达。
* 我们要重现的流变学实验是一个理想化的实验室实验，它被用来描述磁活性聚合物的特性，详细内容见[2.x.75]（以及[2.x.76]，其中记录了它和真实世界的实验情况）。下面的图片提供了对问题设置的视觉描述。
* [2.x.77]
* 假设正在测试的是不可压缩的介质，并且通过样品厚度的变形曲线是线性的，那么在样品内的某个测量点[2.x.78]的位移，用径向坐标表示，就是
* [1.x.83]
*其中[2.x.79]和[2.x.80]是在[2.x.78]的半径。
*
* -和角度为
*
* 采样点，[2.x.81]是（恒定的）轴向变形，[2.x.82]是每单位长度上与时间有关的扭转角，将使用固定振幅[2.x.83]的无声重复振荡来规定。磁场是轴向排列的，即在[2.x.84]方向。
*这总结了我们需要全面描述流变样品内任何一点的理想化载荷的一切。我们将设置这样一个问题，即我们在这个样品中 "挑选 "一个有代表性的点，并使其在恒定的轴向变形（默认为压缩载荷）和恒定的轴向施加的磁场下受到谐波剪切变形的影响。我们将记录这时的应力和磁感应强度，并将数据输出到文件中进行后处理。尽管在这个特定的问题上没有必要，但我们也将计算切线。尽管在这个特定的工作中没有直接使用它们，但为了将构成法嵌入无限元模型（这项工作的一个可能的扩展），需要这些二次导数。因此，我们将利用这个机会，用辅助微分框架来检查我们的手工计算的正确性。
*[1.x.84][1.x.85]
*

*除了已经提到的[2.x.85]模块之外，以下是一些更详细讨论的参考文献
*
* - 磁力学，以及自动分化框架的某些方面。  [2.x.86] , [2.x.87] , 和
*
* - 使用AD和/或SD的有限元框架的自动化： [2.x.88] , [2.x.89] 。
* [2.x.90]
*

* [1.x.86] [1.x.87]。
* 我们首先包括所有必要的deal.II头文件和一些C++相关的文件。这第一个头文件将使我们能够访问一个数据结构，使我们能够在其中存储任意的数据。
*


* [1.x.88]
*
* 接下来是一些核心类，包括一个提供时间步进的实现。
*


* [1.x.89]
*
* 然后是一些标题，定义了一些有用的坐标变换和运动学关系，在非线性弹性中经常出现。
*


* [1.x.90]
*
* 以下两个标头提供了我们进行自动微分所需的所有功能，并使用了deal.II可以利用的符号计算机代数系统。所有自动微分和符号微分包装类的头文件，以及任何需要的辅助数据结构，都被收集在这些统一的头文件中。
*


* [1.x.91]
*
* 包括这个头文件允许我们有能力将输出写入文件流。
*


* [1.x.92]
*
* 按照惯例，整个教程程序被定义在它自己独特的命名空间内。
*


* [1.x.93]
*
* [1.x.94] [1.x.95]。


*
* 自动和象征性的区分有一些神奇和神秘的特质。尽管在一个项目中使用它们可以因多种原因而受益，但了解如何使用这些框架或如何利用它们的障碍可能会超过试图将它们（可靠地）整合到工作中的开发者的耐心。   
* 尽管作者希望能成功地说明这些工具如何能被集成到有限元建模的工作流程中，但最好还是先退一步，从基础开始。因此，一开始，我们先看看如何使用这两个框架来区分一个 "简单 "的数学函数，这样就可以牢固地建立和理解基本的操作（包括它们的顺序和功能），并使其复杂程度降到最低。在本教程的第二部分，我们将把这些基本原理付诸实践，并在此基础上进一步发展。   
* 伴随着对使用框架的算法步骤的描述，将有一个简化的观点，即这些框架可能*在后台做什么。这种描述在很大程度上是为了帮助理解，我们鼓励读者查看[2.x.91]模块文档，以获得对这些工具实际工作的更正式描述。   
*
* [1.x.96] [1.x.97]。
*


* [1.x.98]
*
* 为了使读者相信这些工具在实践中确实有用，让我们选择一个函数，用手计算分析导数并不难。只是它的复杂程度足以让你考虑是否真的要去做这个练习，也可能让你怀疑你是否完全确定你对其导数的计算和实现是正确的。当然，问题的关键在于，函数的微分在某种意义上是相对公式化的，应该是计算机所擅长的。
*
* - 如果我们能在现有的软件上建立起理解规则的软件，我们就不必费力地自己去做了。     
* 我们为此选择了双变量三角函数[2.x.92]。请注意，这个函数是以数字类型为模板的。这样做是因为我们经常（但并不总是）可以使用特殊的自动微分和符号类型作为实值或复值类型的落地替代，然后这些类型将执行一些基本的计算，例如评估一个函数值及其导数。我们将利用这一特性，确保我们只需要定义一次我们的函数，然后就可以在我们希望对其进行微分操作的任何情况下重新使用。
*


* [1.x.99]
*
* 我们没有立即揭示这个函数的导数，而是向前声明返回它们的函数，并将它们的定义推迟到后面。正如函数名称所暗示的，它们分别返回导数 [2.x.93] 。
*


* [1.x.100]

* [2.x.94] :



* [1.x.101]

* [2.x.95] :



* [1.x.102]

* [2.x.96] :



* [1.x.103]

* [2.x.97] :



* [1.x.104]

* 最后是[2.x.98] 。



* [1.x.105]
*
* [1.x.106] [1.x.107]。



* 首先，我们将使用AD作为工具，为我们自动计算导数。我们将用参数`x`和`y`来评估函数，并期望得到的值和所有的导数都能在给定的公差范围内匹配。
*


* [1.x.108]
*
* 我们的函数[2.x.99]是一个标量值函数，其参数代表代数计算或张量计算中遇到的典型输入变量。由于这个原因，[2.x.100]类是合适的包装类，可以用来做我们所需要的计算。(作为比较，如果函数参数代表有限元单元的自由度，我们会希望以不同的方式处理它们)。问题的空间维度是不相关的，因为我们没有矢量或张量值的参数需要容纳，所以`dim`模板参数被任意分配为1的值。 第二个模板参数规定了将使用哪个AD框架（deal.II支持几个外部AD框架），以及这个框架提供的基础数字类型将被使用。这个数字类型影响了微分运算的最大顺序，以及用于计算它们的基础算法。鉴于其模板性质，这个选择是一个编译时的决定，因为许多（但不是全部）AD库利用编译时的元编程，以有效的方式实现这些特殊的数字类型。第三个模板参数说明结果类型是什么；在我们的例子中，我们正在处理 "双"。
*


* [1.x.109]
*
* 我们有必要在我们的[2.x.101]类中预先登记函数[2.x.102]有多少个参数（我们将称之为 "独立变量"）。这些参数是`x`和`y`，所以显然有两个参数。
*


* [1.x.110]
*
* 我们现在有足够的信息来创建和初始化一个辅助类的实例。我们还可以得到具体的数字类型，它将在所有后续的计算中使用。这很有用，因为我们可以从这里开始通过引用这个类型来编写一切，如果我们想改变使用的框架，或者数字类型（例如，如果我们需要更多的差分运算），那么我们只需要调整`ADTypeCode`模板参数。
*


* [1.x.111]

* 下一步是在辅助类中注册自变量的数值。这样做是因为函数和它的导数将正好针对这些参数进行评估。由于我们以`{x,y}`的顺序注册它们，变量`x`将被分配到分量号`0`，而`y`将是分量号`1`。
*


*
* - 一个将在接下来几行中使用的细节。
*


* [1.x.112]
*
* 我们现在要求助手类向我们提供自变量及其自动差异化的表示。这些被称为 "敏感变量"，因为从现在开始，我们对组件`独立变量_ad`所做的任何操作都会被AD框架跟踪和记录，并且在我们要求计算它们的导数时，会被考虑。帮助器返回的是一个可自动微分的 "向量"，但是我们可以确定，第2个元素代表 "x"，第1个元素代表 "y"。为了完全确保这些变量的数字类型没有任何歧义，我们给所有的自动微分变量加上`ad'的后缀。
*


* [1.x.113]
*
* 我们可以立即将自变量的敏感表示法传递给我们的模板函数，计算出[2.x.103] 。这也会返回一个可自动微分的数字。
*


* [1.x.114]
*
* 所以现在要问的自然是，我们把这些特殊的`x_ad`和`y_ad`变量传递给函数`f`，而不是原来的`double`变量`x`和`y`，实际上计算了什么？换句话说，这一切与我们想要确定的导数的计算有什么关系？或者，更简洁地说。这个返回的`ADNumberType`对象有什么特别之处，使它有能力神奇地返回导数？       
* 从本质上讲，这可以*做的是以下几点。这个特殊的数字可以被看作是一个数据结构，它存储了函数值，以及规定的导数数量。对于一个期望有两个参数的一次可导数，它可能看起来像这样。       
* [2.x.104]
* 对于我们的自变量`x_ad`，`x_ad.value`的起始值将只是它的赋值（即这个变量所代表的实值）。导数`x_ad.derivatives[0]`将被初始化为`1'，因为`x'是第2个自变量和[2.x.105] 。导数`x.derivatives[1]`将被初始化为零，因为第一个自变量是`y`和[2.x.106] 。       
* 为了使函数导数有意义，我们必须假设这个函数不仅在分析意义上是可微的，而且在评估点`x,y`也是可微的。我们可以利用这两个假设：当我们在数学运算中使用这种数字类型时，AD框架可以*.
 重载操作（例如，`%operator+()`, `%operator*()`以及`%sin()`, `%exp()`, 等等），使返回的结果具有预期值。同时，它将通过对被重载的确切函数的了解和对连锁规则的严格应用来计算导数。因此，`%sin()`函数（其参数`a`本身是自变量`x`和`y`的函数）可能*被定义如下。       
* [2.x.107]
* 所有这些当然也可以用于二阶甚至高阶导数。       
* 所以现在很清楚，通过上述表示方法，"ADNumberType "携带了一些额外的数据，表示可微调函数相对于原始（敏感）自变量的各种导数。因此应该注意到，使用它们会产生计算开销（因为我们在做导数计算时要计算额外的函数），以及存储这些结果的内存开销。因此，规定的微分运算的级数最好保持在最低水平，以限制计算成本。例如，我们可以自己计算一阶导数，然后使用[2.x.108]辅助类来确定依赖函数集合的梯度，这将是原始标量函数的二阶导数。       
* 还值得注意的是，由于链式规则是无差别应用的，我们只看到计算的起点和终点`{x,y}`[2.x.109] `f(x,y)`，我们永远只能查询到`f`的总导数；部分导数（上例中的`a.导数[0]`和`a.导数[1]`）是中间值，对我们是隐藏的。
*

*
* 好的，既然我们现在至少对`f_ad`所代表的内容和它所编码的内容有了一定的了解，那么让我们把所有的东西都用到实际中去。为了获得那些隐藏的派生结果，我们将最终的结果注册到辅助类中。在这之后，我们不能再改变`f_ad`的值，也不能让这些变化反映在帮助者类返回的结果中。
*


* [1.x.117]
*
* 下一步是提取导数（特别是函数梯度和Hessian）。为此，我们首先创建一些临时的数据结构（结果类型为`double'）来存储导数（注意所有的导数都是一次性返回的，而不是单独返回）...
*


* [1.x.118]
*
* ... 然后我们要求助手类计算这些导数，以及函数值本身。就这样了。我们得到了我们想得到的一切。
*


* [1.x.119]
*
* 我们可以通过与分析解的比较来说服自己，AD框架是正确的。(或者，如果你像作者一样，你会反其道而行之，宁愿验证你对分析解的实现是正确的！)
*


* [1.x.120]
*
* 因为我们知道自变量的排序，我们知道梯度的哪个分量与哪个导数有关......。
*


* [1.x.121]

* ......对于Hessian也是如此。
*


* [1.x.122]

* 这真是太好了。在计算这个三角函数的二阶导数时并没有太多的工作。
*


* [1.x.123] [1.x.124]。


*
* 因为我们现在知道了让AD框架为我们计算这些导数需要多少 "执行工作"，让我们把它与手工计算并在几个独立的函数中实现的导数进行比较。
*


* 下面是[2.x.110]的两个一阶导数。
* [2.x.111]



* [1.x.125]
*
* [2.x.112]



* [1.x.126]

* 而这里是[2.x.113]的四个二阶导数。
* [2.x.114]



* [1.x.127]

* [2.x.115]



* [1.x.128]
*
* [2.x.116]（如预期，基于[施瓦茨定理]（https://en.wikipedia.org/wiki/Symmetry_of_second_derivatives））



* [1.x.129]
*
* [2.x.117]



* [1.x.130]
*
* 嗯......上面有很多地方我们可以引入错误，特别是在应用链式规则的时候。虽然它们不是银弹，但至少这些AD框架可以作为一个验证工具，确保我们没有犯任何错误（无论是计算还是实施），从而对我们的结果产生负面影响。
*

*
* 这个例子的重点当然是，我们可能选择了一个相对简单的函数[2.x.118]，我们可以手工验证AD框架计算的导数是否正确。但是AD框架并不关心这个函数是否简单。它可能是一个复杂得多的表达式，或者取决于两个以上的变量，它仍然能够计算出导数。
*
* 唯一的区别是，我们*不会再想出导数来验证AD框架的正确性。
*




*

*
* [1.x.131] [1.x.132]。


*
* 我们现在用符号微分法重复同样的练习。术语 "符号微分 "有点误导，因为微分只是计算机代数系统（CAS）（即符号框架）提供的一个工具。然而，在有限元建模和应用的背景下，它是CAS最常见的用途，因此将是我们关注的重点。再次，我们将提供参数值`x`和`y`，用来评估我们的函数[2.x.119]及其导数，以及测试返回结果正确性的公差。
*


* [1.x.133]
*
* 我们需要做的第一步是形成符号变量，代表我们希望对其进行微分的函数参数。同样，这些将是我们问题的独立变量，因此，从某种意义上说，它们是原始变量，对任何其他变量没有依赖性。我们通过初始化一个符号类型[2.x.120]来创建这些类型的（独立）变量，这个符号类型是对符号框架所使用的一组类的包装，有一个唯一的标识符。在这种情况下，这个标识符，一个[2.x.121]对于[2.x.122]的参数来说就是`"x"`，同样，对于[2.x.123]的依赖函数的参数来说就是`"y"。像以前一样，我们将用`sd`作为符号变量名称的后缀，这样我们就可以清楚地看到哪些变量是符号性的（而不是数字性的）。
*


* [1.x.134]
*
* 使用计算[2.x.124]的模板化函数，我们可以将这些独立变量作为参数传递给函数。返回的结果将是另一个符号类型，代表用于计算 [2.x.125] 的操作序列。
*


* [1.x.135]
*
* 在这一点上，打印出表达式`f_sd`是合法的，如果我们这样做的话 [2.x.126] 我们会看到`f(x,y) = cos(y/x)`打印到控制台。       
* 你可能会注意到，我们在构建符号函数`f_sd`时没有考虑到我们可能要如何使用它。与上面的AD方法相比，我们调用`f(x_sd, y_sd)`返回的不是函数`f`在某个特定点上的求值，而实际上是一个通用的、尚未确定的点上的求值的符号表示。这是使符号框架（CAS）不同于自动区分框架的关键点之一。每个变量`x_sd`和`y_sd`，甚至复合依赖函数`f_sd`，在某种意义上分别是数值的 "占位符 "和运算的组成。事实上，用于组成函数的各个组件也是占位符。操作序列被编码成一个树状的数据结构（概念上类似于[抽象语法树](https://en.wikipedia.org/wiki/Abstract_syntax_tree)）。       
* 一旦我们形成这些数据结构，我们就可以把我们可能想对它们进行的任何操作推迟到以后的某个时间。这些占位符中的每一个都代表了一些东西，但我们有机会在任何方便的时间点上定义或重新定义它们所代表的东西。因此，对于这个特定的问题，我们想把 "x "和 "y "与一些*数值（类型尚未确定）联系起来是有道理的，但我们可以在概念上（如果有道理的话）给 "y/x "这个比率赋值，而不是单独给 "x "和 "y "这些变量赋值。我们还可以将 "x "或 "y "与其他一些符号函数`g(a,b)`联系起来。这些操作中的任何一个都涉及到对所记录的操作树的操作，以及用其他东西替换树上的突出节点（以及该节点的子树）。这里的关键词是 "替换"，事实上，在[2.x.127]名称空间中，有许多函数的名称中都有这个词。       
* 这种能力使该框架完全通用。在有限元模拟的背景下，我们通常会对我们的符号类型进行的操作类型是函数组合、微分、替换（部分或完全）和评估（即符号类型转换为其数字对应物）。但如果你需要，一个CAS的能力往往不止这些。它可以形成函数的反导数（积分），对形成函数的表达式进行简化（例如，用[2.x.129]替换[2.x.128]；或者，更简单：如果函数做了像`1+2`这样的运算，CAS可以用`3`替换它），等等。变量所代表的表达式*是从函数[2.x.130]的实现方式中得到的，但CAS可以对其进行任何功能的处理。       
* 具体来说，为了计算因果函数相对于各个自变量的一阶导数的符号表示，我们使用[2.x.131]函数，自变量作为其参数。每次调用都会导致CAS通过组成`f_sd'的运算树，并对表达式树的每个节点进行相对于给定符号参数的微分。
*


* [1.x.137]
*
* 为了计算二阶导数的符号表示，我们只需对自变量的一阶导数进行微分。所以要计算高阶导数，我们首先需要计算低阶导数。由于调用 "differentiate() "的返回类型是一个表达式，我们原则上可以通过将两个调用连在一起，直接从标量上执行双倍微分。但是在这种特殊情况下，这是不需要的，因为我们手头有中间结果）。)
*


* [1.x.138]
*
* 使用语句[2.x.132]打印由CAS计算的第一和第二导数的表达式，得到以下输出。  [2.x.133] 这与前面介绍的这些导数的分析表达式相比，效果更好。
*

*
* 现在我们已经形成了函数及其导数的符号表达式，我们想用函数的主要参数`x`和`y`的数字值来评估它们。为了达到这个目的，我们构造了一个替代图*，它将符号值映射到它们的数字对应物上。
*


* [1.x.141]
*
* 这个过程的最后一步是将所有符号变量和操作转换为数值，并产生这个操作的数值结果。为了做到这一点，我们在上面已经提到的步骤中，将替换图与符号变量结合起来。"替换"。       
* 一旦我们把这个替换图传递给CAS，它就会把符号变量的每个实例（或者更一般的，子表达式）替换成它的数值对应物，然后把这些结果在操作树上传播，如果可能的话，简化树上的每个节点。如果运算树被简化为一个单一的值（即我们已经将所有的独立变量替换为它们的数字对应物），那么评估就完成了。       
* 由于C++的强类型特性，我们需要指示CAS将其对结果的表示转换为内在的数据类型（在这里是 "double"）。这就是 "评估 "步骤，通过模板类型我们定义了这个过程的返回类型。方便的是，如果我们确定我们已经进行了完整的替换，这两个步骤可以一次完成。
*


* [1.x.142]
*
* 我们可以对第一个导数做同样的处理......
*


* [1.x.143]
*
* ...和二阶导数。请注意，我们可以在这些操作中重复使用相同的替换图，因为我们希望对`x`和`y`的相同值评估所有这些函数。修改置换图中的值，就可以得到相同的符号表达式的评估结果，同时给自变量分配不同的值。我们也可以很高兴地让每个变量在一次中代表一个实值，在下一次中代表一个复值。
*


* [1.x.144]
*
* [1.x.145] [1.x.146]。


*
* 用来驱动这些初始例子的函数是直接的。我们将任意选择一些值来评估该函数（尽管知道`x = 0`是不允许的），然后将这些值传递给使用AD和SD框架的函数。
*


* [1.x.147]
*
* [1.x.148] [1.x.149]。


*
* 现在我们已经介绍了自动和符号分化背后的原理，我们将通过制定两个耦合的磁力学构成法将其付诸实施：一个是与速率无关的，另一个是表现出与速率有关的行为。   
* 正如你在介绍中记得的那样，我们将考虑的材料构成法比上面的简单例子要复杂得多。这不仅仅是因为我们将考虑的函数[2.x.134]的形式，而且特别是因为[2.x.135]不仅仅取决于两个标量变量，而是取决于一大堆张量*，每个张量都有几个组成部分。在某些情况下，这些是对称*张量，对于这些张量来说，只有一个分量子集实际上是独立的，我们必须考虑计算[2.x.136]这样的导数的实际意义，其中[2.x.137]是一个对称张量。希望这一切将在下面变得清晰。我们也将清楚地看到，用手做这些事情，最好的情况是极其*繁琐*，最差的情况是
乏味*，最糟糕的是，充满了难以发现的错误。
*


* [1.x.150]
*
* [1.x.151] [1.x.152]。


*
* 我们首先描述在能量函数的描述中出现的各种材料参数 [2.x.138] 。     
* ConstitutiveParameters类被用来保存这些数值。所有参数的值（包括构成参数和流变参数）都取自[2.x.139]，并给出了产生构成响应的值，该响应大致代表了真实的、实验室制造的磁活性聚合物，当然，这里使用的具体数值对本程序的目的没有影响。     
* 前四个构成参数分别代表
*


*
* - 弹性剪切模量 [2.x.140] 。
*


*
* - 磁饱和时的弹性剪切模量 [2.x.141] 。
*


*
* - 弹性剪切模量的饱和磁场强度[2.x.142] ，以及
*


*
* - 泊松比 [2.x.143] 。
*


* [1.x.153]
*
* 接下来的四个，只与速率相关的材料有关，是以下的参数
*


*
* - 粘弹性剪切模量 [2.x.144] 。
*


*
* - 磁饱和时的粘弹性剪切模量 [2.x.145] 。
*


*
* - 粘弹性剪切模量的饱和磁场强度[2.x.146] ，以及
*


*
* - 特征松弛时间 [2.x.147] 。
*


* [1.x.154]
*
* 最后一个参数是相对磁导率 [2.x.148] 。
*


* [1.x.155]
*
* 参数是通过ParameterAcceptor框架初始化的，这在 [2.x.149] 中有详细讨论。
*


* [1.x.156]
*
* [1.x.157] [1.x.158]。


*
* 因为我们将为同一类材料制定两种构成法，所以定义一个基类以确保它们有统一的接口是有意义的。     
* 该类的声明从构造函数开始，它将接受一组构成参数，这些参数与材料定律本身一起决定了材料的响应。
*


* [1.x.159]
*
* 与其随意计算和返回动力学变量或它们的线性化，我们将在一个方法中计算和存储这些值。然后这些缓存的结果将在请求时返回。我们将把为什么要这样做的精确解释推迟到以后的阶段。现在重要的是看到这个函数接受所有的场变量，即磁场矢量[2.x.150]和右Cauchy-Green形变张量[2.x.151]，以及时间离散器。除了[2.x.152]之外，这些都是计算材料响应所需的所有基本量。
*


* [1.x.160]
*
* 接下来的几个函数提供了探测材料响应的接口，由于受到施加的变形和磁载荷的影响。       
* 由于材料的类别可以用自由能来表示 [2.x.153] ，我们可以计算出...
*


* [1.x.161]
*
* ... 以及两个动力学量。
*


*
*-磁感应矢量[2.x.154] ，以及
*


*
* - 总的Piola-Kirchhoff应力张量[2.x.155] 。
*


* [1.x.162]
*
* ......以及动力学量的线性化，它们是
*


*
* - 磁静力切张量 [2.x.156] 。
*


*
* -总的参考磁弹性耦合张量[2.x.157] ，以及
*


*
* - 总的参考弹性正切张量 [2.x.158] 。
*


* [1.x.163]
*
* 我们还将定义一个方法，为这个类的实例提供一个机制，在进入下一个时间步长之前做任何额外的任务。同样，这样做的原因将在稍后变得清晰。
*


* [1.x.164]
*
* 在该类的 "保护 "部分，我们存储了一个对支配材料响应的构成参数实例的引用。为了方便，我们还定义了一些函数来返回各种构成参数（包括明确定义的，以及计算的）。       
* 与材料的弹性响应有关的参数依次是
*


*
* - 弹性剪切模量。
*


*
* - 饱和磁场下的弹性剪切模量。
*


*
* - 弹性剪切模量的饱和磁场强度。
*


*
* - 泊松比。
*


*
* - Lam&eacute;参数，以及
*


*
* - 体积模量。



* [1.x.165]
*
*与材料的弹性响应有关的参数依次为：。
*


*
* - 粘弹性剪切模量。
*


*
* - 磁饱和时的粘弹性剪切模量。
*


*
* - 粘弹性剪切模量的饱和磁场强度，以及
*


*
* - 特征松弛时间。



* [1.x.166]
*
*与材料的磁响应有关的参数依次为：。
*


*
* - 相对磁导率，和
*


*
* - 磁导率常数[2.x.159]（并不是真正的材料常数，而是一个普遍的常数，为了简单起见，我们在这里分组）。       
* 我们还将实现一个函数，从时间离散性中返回时间步长。
*


* [1.x.167]
*
* 在下文中，让我们从实现刚才定义的类的几个相对琐碎的成员函数开始。
*


* [1.x.168]

* [1.x.169] [1.x.170]。



* 我们将首先考虑一种非耗散性材料，即受磁超弹性构成法则支配的材料，在浸入磁场时表现出僵化。正如介绍中所述，这种材料的储能密度函数可能由[1.x.171]与[1.x.172]给出。
* 现在来看看实现这种行为的类。由于我们期望这个类能完全描述一种材料，我们将把它标记为 "最终"，这样继承树就在这里终止了。在类的顶部，我们定义了辅助类型，我们将在标量能量密度函数的AD计算中使用它。请注意，我们希望它能返回 "double "类型的值。我们还必须指定空间维度的数量，`dim'，以便建立矢量、张量和对称张量场与它们所含分量数量之间的联系。用于ADHelper类的具体的`ADTypeCode`将在实际使用该类的时候作为模板参数提供。
*


* [1.x.173]
*
* 由于基类的公共接口是纯 "虚拟 "的，这里我们将声明这个类将覆盖所有这些基类方法。
*


* [1.x.174]
*
* 在这个类的`private'部分，我们需要定义一些提取器，这些提取器将帮助我们设置自变量，随后得到与因变量相关的计算值。如果这个类是在有限元问题的背景下使用，那么这些提取器中的每一个都（很可能）与解场的一个分量的梯度有关（在这种情况下，位移和磁标势）。正如你现在可能推断的那样，这里 "C "表示右Cauchy-Green张量，"H "表示磁场向量。
*


* [1.x.175]
*
* 这是一个自动微分助手的实例，我们将设置它来进行与构成法有关的所有微分计算......
*


* [1.x.176]
*
* ... 以下三个成员变量将存储来自[2.x.160]的输出。[2.x.161]一次性返回关于所有场变量的导数，因此我们将保留完整的梯度向量和Hessian矩阵。我们将从中提取我们真正感兴趣的个别条目。
*


* [1.x.177]
*
* 在设置字段组件提取器时，对于它们的排序方式是完全任意的。但重要的是，这些提取器没有重叠的索引。这些提取器的组件总数定义了[2.x.162]需要跟踪的独立变量的数量，并且我们将对其进行导数。由此产生的数据结构[2.x.163]和[2.x.164]也必须有相应大小。一旦[2.x.165]被配置好（它的输入参数是[2.x.166]和[2.x.167]的组件总数），我们就可以直接询问它使用多少个独立变量。
*


* [1.x.178]
*
* 如前所述，由于自动微分库的工作方式，[2.x.168]将总是同时返回能量密度函数相对于所有场变量的导数。由于这个原因，在函数`get_B()`、`get_S()`等中计算导数是没有意义的，因为我们会做很多额外的计算，然后直接丢弃。因此，处理这个问题的最好方法是用一个单一的函数调用来完成所有的前期计算，然后我们在需要时提取存储的数据。这就是我们在 "update_internal_data() "方法中要做的。由于材料是与速度无关的，我们可以忽略DiscreteTime参数。
*


* [1.x.179]
*
* 因为我们在每个时间步骤中都会重复使用[2.x.169]数据结构，所以我们需要在使用前清除它的所有陈旧信息。
*


* [1.x.180]
*
* 下一步是设置所有字段组件的值。这些定义了 "点"，我们将围绕这个点计算函数梯度和它们的线性化。我们之前创建的提取器在[2.x.170]中提供了字段和注册表之间的关联。
*
* - 它们将被反复使用，以确保我们对哪个变量对应于`H'或`C'的哪个分量有正确的解释。
*


* [1.x.181]
*
* 现在我们已经完成了初始设置，我们可以检索我们的场的AD对应物。这些是真正的能量函数的独立变量，对用它们进行的计算是 "敏感 "的。请注意，AD数被视为一种特殊的数字类型，可以在许多模板化的类中使用（在这个例子中，作为Tensor和SymmetricTensor类的标量类型）。
*


* [1.x.182]
*
* 我们还可以在许多以标量类型为模板的函数中使用它们。因此，对于我们需要的这些中间值，我们可以进行张量运算和一些数学函数。由此产生的类型也将是一个自动可分的数字，它编码了这些函数中执行的操作。
*


* [1.x.183]
*
* 接下来我们将计算在磁场影响下导致剪切模量变化（增加）的比例函数......
*


* [1.x.184]
*
* ... 然后我们就可以定义材料的储能密度函数。我们将在后面看到，这个例子足够复杂，足以保证使用AD来，至少验证一个无辅助的实现。
*


* [1.x.185]
*
* 储存的能量密度函数实际上是这个问题的因变量，所以作为 "配置 "阶段的最后一步，我们用[2.x.171]登记其定义。
*


* [1.x.186]
*
* 最后，我们可以检索存储的能量密度函数的结果值，以及它相对于输入字段的梯度和Hessian，并将它们缓存起来。
*


* [1.x.187]
*
* 下面的几个函数可以查询[2.x.172]的存储值，并提取梯度向量和Hessian矩阵的所需成分。我们再次利用提取器来表达我们希望检索的总梯度向量和Hessian矩阵的哪些部分。它们只返回能量函数的导数，所以对于我们的动能变量的定义和它们的线性化，还需要进行一些操作来形成所需的结果。
*


* [1.x.188]
*
* 请注意，对于耦合项来说，提取器参数的顺序特别重要，因为它决定了提取方向性导数的顺序。因此，如果我们在调用`extract_hessian_component()`时颠倒了提取器的顺序，那么我们实际上是在检索[2.x.173]的一部分。
*


* [1.x.189]
*
* [1.x.190] [1.x.191]。



* 我们要考虑的第二个材料定律将是一个代表具有单一耗散机制的磁-粘弹性材料的定律。我们将考虑这样一种材料的自由能密度函数，定义为


* [1.x.192]
* 与[1.x.193][1.x.194]结合，内部粘性变量[1.x.195]的演化规律是用一阶后向差分近似法离散的。     
*再一次，让我们看看这在一个具体的类中是如何实现的。我们现在将利用SD方法，而不是前一个类中使用的AD框架。为了支持这一点，类的构造函数不仅接受[2.x.174]，而且还接受两个额外的变量，这些变量将用于初始化一个[2.x.175]我们将在后面给出更多的背景。
*


* [1.x.196]
*
* 和自动微分助手一样，[2.x.176]将一次性返回一个结果的集合。因此，为了只做一次，我们将利用与之前类似的方法，在`update_internal_data()`函数中做所有昂贵的计算，并将结果缓存起来供层提取。
*


* [1.x.197]
*
* 因为我们要处理的是一个与速率有关的材料，所以我们必须在适当的时候更新历史变量。这将是这个函数的目的。
*


* [1.x.198]
*
* 在该类的 "私有 "部分，我们要跟踪内部的粘性变形，所以下面两个（实值的、非符号的）成员变量分别持有
*


*
* - 内部变量时间步长的值（如果嵌入到非线性求解器框架中，则为牛顿步长），以及
*


*
* - 内部变量在前一个时间段的值。       
* (我们给这些变量贴上 "Q "的标签，以便于识别；在计算的海洋中，不一定容易区分`Cv`或`C_v`与`C`)。
*


* [1.x.199]
*
* 因为我们将使用符号类型，所以我们需要定义一些符号变量来与框架一起使用。(它们都以 "SD "为后缀，以方便区分符号类型或表达式与实值类型或标量。)这可以在前面做一次（甚至有可能作为 "静态 "变量），以尽量减少与创建这些变量相关的开销。为了实现通用编程的终极目标，我们甚至可以用符号来描述构成参数，可能*允许一个单一的类实例也可以用不同的输入来重复使用这些值。       
* 这些是代表弹性、粘性和磁性材料参数的符号标量（主要按照它们在[2.x.177]类中出现的相同顺序定义）。我们还存储了一个符号表达式，[2.x.178]，表示时间步长的大小）。)
*


* [1.x.200]
*
* 接下来我们定义一些代表独立场变量的张量符号变量，在此基础上对能量密度函数进行参数化。
*


* [1.x.201]

* 同样，我们也有内部粘性变量的符号表示（包括它的当前值和它在前一个时间段的值）。
*


* [1.x.202]
*
* 我们还应该存储从属表达式的定义。虽然我们只计算一次，但我们需要它们从下面声明的[2.x.179]中检索数据。此外，当序列化一个像这样的材料类时（不是作为本教程的一部分），我们要么需要把这些表达式也序列化，要么需要在重新加载时重建它们。
*


* [1.x.203]
*
* 接下来的变量是用于评估从属函数的优化器。更具体地说，它提供了加速评估符号从属表达式的可能性。这是一个重要的工具，因为对冗长表达式的本地评估（不使用加速方法，而是直接对符号表达式进行评估）会非常慢。[2.x.180]类提供了一种机制，可以将符号表达式树转化为另一种代码路径，例如，在各种从属表达式之间共享中间结果（意味着这些中间值每次评估只计算一次）和/或使用即时编译器编译代码（从而为评估步骤检索接近原生性能）。       
* 执行这种代码转换在计算上是非常昂贵的，所以我们存储了优化器，使其在每个类实例中只做一次。这也进一步促使我们决定将构成参数本身变成符号化。然后，我们可以在几种材料（当然是相同的能量函数）和潜在的多个连续体点（如果嵌入有限元模拟）中重复使用这个[2.x.181]的单一实例。       
* 正如模板参数所指定的，数值结果将是<tt>double</tt>类型。
*


* [1.x.204]
*
* 在评估阶段，我们必须将符号变量映射到它们的实值对应物。下一个方法将提供这个功能。       
* 这个类的最后一个方法将配置[2.x.182]。
*


* [1.x.205]
*
* 由于静止变形状态是材料被认为是完全松弛的状态，所以内部粘性变量用身份张量初始化，即 [2.x.183] 。代表构成参数、时间步长、场和内部变量的各种符号变量都有一个唯一的标识符。优化器被传递给两个参数，这两个参数声明了应该应用哪种优化（加速）技术，以及CAS应该采取哪些额外步骤来帮助提高评估期间的性能。
*


* [1.x.206]
*
* 替换图只是将以下所有数据配对在一起。
*


*
* - 构成参数（从基类中检索出的值）。
*


*
* - 时间步长（其值从时间离散器中获取）。
*


*
* - 字段值（其值由调用此[2.x.184]实例的外部函数规定），以及
*


*
* - 当前和以前的内部粘性变形（其值存储在该类实例中）。
*


* [1.x.207]
*
* 由于符号表达式的 "自然 "使用，配置[2.x.185]的大部分程序看起来与构建自动区分帮助器的程序非常相似。尽管如此，我们还是要再次详细说明这些步骤，以强调这两个框架的不同之处。     
* 该函数从符号编码变形梯度行列式的表达式开始（用右Cauchy-Green变形张量表示，即我们的主要场变量），以及[2.x.186]本身的逆。
*


* [1.x.208]
*
* 接下来是自由能密度函数的弹性部分的饱和函数的符号表示，然后是自由能密度函数的磁弹性贡献。这一切与我们之前看到的结构相同。
*


* [1.x.209]

* 此外，我们定义了磁-粘弹性对自由能密度函数的贡献。实现这一点所需的第一个成分是一个缩放函数，它将使粘性剪切模量在磁场的影响下发生变化（增加）（见[2.x.187] ，公式29）。此后，我们可以计算能量密度函数的耗散分量；其表达式见[2.x.188]（方程28），这是对[2.x.189]（方程46）中制定的能量密度函数的直接扩展。
*


* [1.x.210]
*
* 从这些构件中，我们就可以定义材料的总自由能密度函数。
*


* [1.x.211]
*
* 目前，对于CAS来说，变量[2.x.190]似乎是独立于[2.x.191]的，我们的张量符号表达式[2.x.192]只是有一个与之相关的标识符，没有任何东西将其与另一个张量符号表达式[2.x.193]联系起来。因此，相对于[2.x.194]的任何导数将忽略这种固有的依赖关系，正如我们从进化规律可以看出，实际上是[2.x.195] 。这意味着相对于 [2.x.197] 推导任何函数 [2.x.196] 将返回部分导数 [2.x.198] ，而不是总导数 [2.x.199] 。       
* 相比之下，在当前的AD库中，总导数总是被返回。这意味着对于这类材料模型来说，计算出的动力学变量是不正确的，这使得AD成为从能量密度函数推导出（连续点水平）这种耗散性材料的构成法的不正确工具。       
* 正是这种特定的控制水平描述了SD和AD框架之间的一个决定性的区别。在几行中，我们将操纵内部变量[2.x.200]的表达式，使其产生正确的线性化。
*

*
* 但是，首先，我们将计算动能变量的符号表达式，即磁感应矢量和Piola-Kirchhoff应力张量。执行微分的代码相当紧密地模仿了理论中的定义。
*


* [1.x.212]
*
* 因为下一步是对上述内容进行线性化，所以现在是告知CAS[2.x.201]对[2.x.202]的明确依赖性的适当时机，即说明[2.x.203] 。这意味着未来所有关于[2.x.204]的微分运算将考虑到这种依赖关系（即计算总导数）。换句话说，我们将转换一些表达式，使它们的内在参数化从[2.x.205]变为[2.x.206] 。       
* 为了做到这一点，我们考虑时间离散的演化规律。由此，我们有了内部变量在其历史方面的明确表达，以及主要的场变量。这就是它在这个表达式中描述的内容。
*


* [1.x.213]
*
* 接下来我们产生一个中间替换图，它将在一个表达式中找到[2.x.207]（我们的标识符）的每个实例，并用[2.x.208]中的完整表达式来替换它。
*


* [1.x.214]
*
* 我们可以对两个动力学变量进行这种替换，并立即将替换后的结果与场变量进行区分。(如果你愿意，这可以分成两个步骤，中间的结果储存在一个临时变量中。)同样，如果你忽略了替换所产生的 "复杂性"，这些使动能变量线性化并产生三个切向张量的调用与理论中所述的非常相似。
*


* [1.x.215]
*
* 现在我们需要告诉[2.x.209]我们需要提供哪些条目的数值，以便它能成功地进行计算。这些基本上是作为[2.x.210]必须评估的所有从属函数的输入参数。它们统称为问题的自变量、历史变量、时间步长和构成参数（因为我们没有将它们硬编码在能量密度函数中）。       
* 所以我们真正想要的是为它提供一个符号集合，可以用这种方式完成。  [2.x.211] 但这些实际上都已经被编码为替换图的键。这样做还意味着我们需要在两个地方（这里和构建替换图时）管理这些符号，这很烦人，而且如果这个材料类被修改或扩展，可能会出现错误。由于我们此时对数值不感兴趣，所以如果替代图中与每个键项相关的数值被填入无效的数据也没有关系。所以我们将简单地创建一个假的替换图，并从中提取符号。请注意，任何传递给[2.x.212]的替换图都必须至少包含这些符号的条目。
*


* [1.x.217]
*
* 然后，我们告知优化器我们想要计算哪些数值，在我们的情况下，这包括所有的因变量（即能量密度函数及其各种导数）。
*


* [1.x.218]
*
* 最后一步是最终确定优化器。通过这个调用，它将确定一个等价的代码路径，该路径将一次评估所有的依赖函数，但计算成本比直接评估符号表达式时要低。注意：这是一个昂贵的调用，所以我们希望尽可能少地执行它。我们在我们的类的构造函数中完成了这个任务，实现了每个类实例只被调用一次的目标。
*


* [1.x.219]
*
* 由于[2.x.213]的配置是在前面完成的，所以每次我们想计算动能变量或它们的线性化（导数）时，要做的事情就很少了。
*


* [1.x.220]
*
* 为了更新内部历史变量，我们首先需要计算一些基本量，这些量我们之前已经看到了。我们还可以向时间离散器询问用于从上一个时间步长迭代到当前时间步长的时间步长。
*


* [1.x.221]
*
* 现在我们可以更新（实值）内部粘性变形张量，根据演化规律给出的定义，结合选择的时间离散化方案。
*


* [1.x.222]
*
* 接下来，我们向优化器传递我们希望自变量、时间步长和（本调用隐含的）构成参数所代表的数字值。
*


* [1.x.223]
*
* 当进行这个下一个调用时，用于（数字）评估依赖函数的调用路径比字典替换更快。
*


* [1.x.224]
*
* 在调用了`update_internal_data()`之后，从优化器中提取数据就有效了。在进行评估时，我们需要从优化器中提取的数据的确切符号表达式。这意味着我们需要在优化器的生命周期内存储所有因变量的符号表达式（自然，输入变量也是如此）。
*


* [1.x.225]
*
* 当在时间上向前移动时，内部变量的 "当前 "状态瞬间定义了 "前一个 "时间步骤的状态。因此，我们记录历史变量的值，作为下一个时间步骤的 "过去值 "使用。
*


* [1.x.226]
*
* [1.x.227] [1.x.228]。


*
* 现在我们已经看到了AD和SD框架是如何在定义这些构成法则方面做得很轻松的，我们将用手来实现等价的类，以便进行验证，并对框架与本地实现进行一些初步的基准测试。     
* 以作者的理智为代价，下面记录的（希望是准确的）是动能变量及其切线的完整定义，以及一些中间计算。由于构成法则类的结构和设计已经在前面概述过了，我们将略过它，只是在 "update_internal_data() "方法的定义中对各阶段的计算进行划分。将导数计算（及其适度表达的变量名）与出现在类描述中的文档定义联系起来应该是很容易的。然而，我们将借此机会介绍两种实现构成法类的不同范式。第二种将比第一种提供更多的灵活性（从而使其更容易扩展，在作者看来），但要牺牲一些性能。
*


* [1.x.229] [1.x.230]。



* 如前所述，从储存的能量来看，对于这种磁弹性材料，定义为[1.x.231]与[1.x.232]，对应于磁感应矢量和总Piola-Kirchhoff应力张量的第一导数是[1.x.233] 。


* [1.x.234]
* 与 [1.x.235] [1.x.236] [1.x.237] [1.x.238] [1.x.239] 在上面的一个推导中使用对称算子[2.x.214]有助于确保所得到的四阶张量，由于[2.x.215]的对称性而持有小的对称性，仍然将二阶对称张量映射到二阶对称张量。参见SymmetricTensor类文档和[2.x.216]的介绍，并进一步解释在四阶张量的背景下对称性的含义。     
*每个运动学变量相对于其参数的线性化是[1.x.240]。


* [1.x.241]



* [1.x.242]
*与[1.x.243] [1.x.244] [1.x.245]。


* [1.x.246]
*
* 好吧，这很快就升级了
*
* - 尽管[2.x.217]和[2.x.218]的定义可能已经给出了一些提示，表明计算动能场和它们的线性化将需要一些努力，但很可能最终定义的复杂性比最初想象的要多一些。了解了我们现在所做的，也许可以说，我们真的不想计算这些函数相对于其参数的一、二次导数
*
* 不管我们在微积分课上表现如何，也不管我们是多么优秀的程序员。     
* 在最终实现这些的类方法定义中，我们以稍微不同的方式组成这些计算。一些中间步骤也被保留下来，以便从另一个角度说明如何系统地计算导数。此外，一些计算被分解得更少或更进一步，以重用一些中间值，并希望能帮助读者跟随导数的操作。
*


* [1.x.247]
*
* 对于这个类的更新方法，我们将简单地预先计算一个中间值的集合（用于函数求值、导数计算等），并 "手动 "安排它们的顺序，以使它们的重复使用最大化。这意味着我们必须自己管理，并决定哪些值必须在其他值之前计算，同时保持代码本身的某种秩序或结构的模样。这很有效，但也许有点乏味。它对类的未来扩展也没有太大的帮助，因为所有这些值都是这个单一方法的局部。     
* 有趣的是，这种预先计算在多个地方使用的中间表达式的基本技术有一个名字：[共同子表达式消除（CSE）]（https://en.wikipedia.org/wiki/Common_subexpression_elimination）。它是计算机代数系统使用的一种策略，当它们被赋予评估类似表达式的任务时，可以减少计算费用。
*


* [1.x.248]
*
* 磁弹性能的饱和函数。
*


* [1.x.249]
*
* 饱和函数的一阶导数，注意[2.x.219] 。
*


* [1.x.250]
*
* 饱和函数的二阶导数，注意到[2.x.220] 。
*


* [1.x.251]
*
*一些直接从场/运动学变量中获得的中间量。
*


* [1.x.252]
*
* 中间量的一阶导数。
*


* [1.x.253]
*
* 中间量的二阶导数。
*


* [1.x.254]
*
* 储存的能量密度函数。
*


* [1.x.255]
*
* 动能量。
*


* [1.x.256]
*
* 运动量的线性化。
*


* [1.x.257]
*
* [1.x.258] [1.x.259]。


*
* 如前所述，我们将考虑的具有一种耗散机制的磁涡流材料的自由能密度函数被定义为[1.x.260] [1.x.261] [1.x.262]，其中有[1.x.263] [1.x.264]和演变规律[1.x.265]，其本身是以[2.x.221] 为参数。根据设计，能量[2.x.222]的磁弹性部分与前面介绍的磁弹性材料的磁弹性部分是相同的。因此，对于源于这部分能量的各种贡献的导数，请参考前面的章节。我们将继续强调来自这些条款的具体贡献，用[2.x.223]对突出的条款进行上标，而来自磁弹性部分的贡献则用[2.x.224]进行上标。此外，阻尼项的磁饱和函数[2.x.225]与弹性项的形式相同（即[2.x.226]），因此其导数的结构与之前看到的相同；唯一的变化是三个构成参数，现在与粘性剪切模量[2.x.227]而不是弹性剪切模量[2.x.228]相关。     
* 对于这种磁-粘弹性材料，对应于磁感应矢量和总Piola-Kirchhoff应力张量的第一导数是[1.x.266] [1.x.267]，粘性贡献是[1.x.268] [1.x.269]，而[1.x.270]的时间分解进化律，[1.x.271]也将决定内部变量相对于场变量的线性化是如何构成。     
* 请注意，为了获得这种耗散材料的磁感应矢量和总Piola-Kirchhoff应力张量的正确*表达式，我们必须严格遵守应用Coleman-Noll程序的结果：我们必须对自由能密度函数进行部分导数*。
 的自由能密度函数与场变量的关系。对于我们的非耗散性磁弹性材料，取部分导数或总导数都会有同样的结果，所以之前没有必要提请你注意这一点）。该操作的关键部分是冻结内部变量[2.x.229]，同时计算[2.x.230]相对于[2.x.231]的导数。
*
* - 不考虑[2.x.232]对[2.x.233]的依赖性。当决定使用AD或SD来执行这项任务时，选择是明确的
*
* - 只有符号框架提供了这样的机制；如前所述，AD只能返回总导数，所以它不适合这个任务。     
* 总结一下，我们将介绍这种速度依赖的耦合材料的材料切线。两个动力学变量相对于其参数的线性化是[1.x.272] [1.x.273] [1.x.274]，其中粘性贡献的切线是[1.x.275] [1.x.276] 。


* [1.x.277]
*与[1.x.278]，从演化规律来看，[1.x.279]注意，只是[2.x.234]的最后一项包含了内部变量的切线。这个特殊演化规律的线性化是线性的。关于非线性演化定律的例子，这种线性化必须以迭代的方式求解，见[2.x.235] -Theiss2011a。
*


* [1.x.280]
*
* 一个用于存储所有中间计算的数据结构。我们很快就会准确地看到如何利用这一点，使我们实际进行计算的那部分代码变得干净和容易（嗯，至少更容易）遵循和维护。但是现在，我们可以说，它将允许我们把计算中间量的导数的代码部分从使用它们的地方移开。
*


* [1.x.281]
*
* 接下来的两个函数用于更新字段和内部变量的状态，在我们进行任何详细的计算之前会被调用。
*


* [1.x.282]
*
* 该类接口的其余部分专门用于计算自由能密度函数及其所有导数所需的组件的方法。
*

*
* 运动学的，或场的变量。
*


* [1.x.283]
*
* 饱和度函数的一般化表述，所需的构成参数作为参数传递给每个函数。
*


* [1.x.284]
*
* 饱和度函数的一阶导数的一般化表述，所需的构成参数作为参数传递给每个函数。
*


* [1.x.285]
*
* 饱和度函数二阶导数的一般化表述，所需的构成参数作为参数传递给每个函数。
*


* [1.x.286]
*
* 直接从场/运动学变量中获得的中间量。
*


* [1.x.287]
*
* 中间量的一阶导数。
*


* [1.x.288]
*
* 内部变量相对于场变量的导数。注意，我们只需要这个内部变量的导数，因为这个变量只是作为动力学变量线性化的一部分而被微分。
*


* [1.x.289]
*
* 中间量的二阶导数。
*


* [1.x.290]
*
* 记录应用的变形状态以及磁载荷。此后，根据新的变形状态更新内部（粘性）变量。
*


* [1.x.291]
*
*根据当前磁场获得弹性和粘性饱和函数的值...
*


* [1.x.292]
*
* ...以及它们的第一个导数...



* [1.x.293]
*
* ......和它们的二阶导数。
*


* [1.x.294]
*
* 中间量。请注意，由于我们是从一个缓存中获取这些值，而这个缓存的寿命比这个函数调用的寿命长，所以我们可以对结果进行别名，而不是从缓存中复制这个值。
*


* [1.x.295]
*
* 中间值的第一导数，以及内部变量相对于右Cauchy-Green变形张量的那个导数。
*


* [1.x.296]
*
* 中间值的二次导数。
*


* [1.x.297]
*
* 由于线性化的定义变得特别冗长，我们将把自由能密度函数分解为三个相加的部分。
*


*
* - 类似 "新胡克 "的术语。
*


*
* - 与速率有关的条款，以及
*


*
* - 类似于储存在磁场中的能量的术语。       
* 为了保持一致，这些贡献中的每一个都将被单独添加到我们想要计算的变量中，其顺序也是如此。       
* 所以，首先这是能量密度函数本身。
*


* [1.x.298]
*
* ......接着是磁感应矢量和Piola-Kirchhoff应力。
*


* [1.x.299]
*
* ......最后是由于动能变量的线性化而产生的切线。
*


* [1.x.300]
*
* 现在我们已经用完了存储在缓存中的所有临时变量，我们可以把它清除掉，以释放一些内存。
*


* [1.x.301]
*
* 接下来的几个函数实现了饱和度函数的广义表述，以及它的各种导数。
*


* [1.x.302]
*
* 一个比例函数，它将使剪切模量在磁场的影响下发生变化（增加）。
*


* [1.x.303]
*
* 缩放函数的一阶导数
*


* [1.x.304]
*
* 对于我们为这个材料类采用的缓存计算方法，所有计算的根基是场变量，以及不可改变的辅助数据，如构成参数和时间步长等。因此，我们需要以与其他变量不同的方式将它们输入缓存，因为它们是由类本身之外规定的输入。这个函数只是将它们从输入参数中直接添加到缓存中，并检查那里是否有相等的数据（我们希望每个时间步长或牛顿迭代只调用一次`update_internal_data()`方法）。
*


* [1.x.305]
*
* 为[2.x.236]设定值。
*


* [1.x.306]
*
* 为[2.x.237]设定值。
*


* [1.x.307]
*
* 之后，我们可以在任何时间点从缓存中获取它们。
*


* [1.x.308]
*
* 当我们需要主要变量时，保证它们在缓存中，我们不能从它们中计算出所有的中间值（无论是直接，还是间接）。     
* 如果缓存中还没有存储我们要找的值，那么我们就快速计算，把它存储在缓存中，然后返回刚刚存储在缓存中的值。这样我们就可以把它作为一个引用返回，避免复制对象。同样的道理也适用于复合函数可能依赖的任何值。换句话说，如果在我们目前感兴趣的计算之前有一个依赖链，那么在我们继续使用这些值之前，我们可以保证解决这些依赖关系。尽管从缓存中获取数据是有成本的，但 "已解决的依赖关系 "的概念可能足够方便，使其值得看一下这个额外的成本。如果这些材料定律被嵌入到有限元框架中，那么额外的成本甚至可能不会被注意到。
*


* [1.x.309]
*
* [1.x.310] [1.x.311]。


*
* [2.x.238]类是用来驱动数值实验的，这些实验将在我们已经实现了构成法则的耦合材料上进行。
*


* [1.x.312]
*
* 这些是要模拟的流变学试样的尺寸。它们，有效地，定义了我们的虚拟实验的测量点。
*


* [1.x.313]
*
*三个稳态载荷参数分别为
*


*
* - 轴向拉伸。
*


*
* - 剪切应变的振幅，以及
*


*
* - 轴向磁场强度。
*


* [1.x.314]

*此外，随时间变化的流变负载条件的参数是
*


*
* - 负载周期的频率。
*


*
* - 负载周期的数量，以及
*


*
* - 每个周期的离散时间步数。
*


* [1.x.315]
*
* 我们还声明了一些不言自明的参数，这些参数与用速率依赖型和速率非依赖型材料进行的实验产生的输出数据有关。
*


* [1.x.316]
*
* 接下来的几个函数计算实验的时间相关参数...
*


* [1.x.317]
*
* ......而下面两个则规定了任何时候的机械和磁力负荷......
*


* [1.x.318]
*
* ......而这最后一个是将实验的状态输出到控制台。
*


* [1.x.319]
*
*施加的磁场总是与流变仪转子的旋转轴对齐。
*


* [1.x.320]
*
* 应用的变形（梯度）是根据流变仪和样品的几何形状、采样点和实验参数计算出来的。根据介绍中记录的位移曲线，变形梯度可以用直角坐标表示为 [1.x.321] 。
*


* [1.x.322]
*
* [1.x.323] [1.x.324]。


*
* 这是驱动数值实验的函数。
*


* [1.x.325]
*
* 我们可以把手工实现的构成法，与用AD或SD得到的结果进行比较。通过这种方式，我们可以验证它们产生了相同的结果（这表明要么两种实现方式都有很大的可能性是正确的，要么就是它们都有相同的缺陷而不正确）。不管怎么说，这对完全自我实现的变体来说是个不错的理智检查，当检测到结果之间的差异时，当然可以作为一种调试策略）。)
*


* [1.x.326]
*
* 我们将把材料的构成响应输出到文件中进行后处理，所以在这里我们声明一个`stream`，它将作为这个输出的缓冲区。我们将使用一个简单的CSV格式来输出结果。
*


* [1.x.327]
*
* 使用DiscreteTime类，我们使用一个固定的时间步长来迭代每个时间段。
*


* [1.x.328]
*
* 我们获取并计算在这个时间步长中应用于材料的负载...
*


* [1.x.329]
*
* ...然后我们更新材料的状态...
*


* [1.x.330]
*
* ... 并测试两者之间的差异。
*


* [1.x.331]

* 接下来，我们要做的是收集一些结果来进行后处理。所有的数量都是在 "当前配置"（而不是 "参考配置"，所有由构成法则计算的数量都是在这个框架内）。
*


* [1.x.332]
*
* 最后，我们把应变应力和磁载荷历史输出到文件中。
*


* [1.x.333]
*
* [1.x.334] [1.x.335]。


*
* 这个驱动函数的目的是从文件中读取所有的参数，并在此基础上创建每个构成法则的代表性实例，并调用函数对其进行流变学实验。
*


* [1.x.336]
*
* 我们通过配置和运行实验开始实际工作，使用我们的速率无关的构成法。这里的自动可微调数类型是硬编码的，但是通过一些巧妙的模板设计，可以在运行时选择使用哪种框架（例如，通过参数文件选择）。我们将同时用完全手工实现的反面材料法进行实验，并检查它与我们的辅助实现的计算结果。
*


* [1.x.337]
*
* 接下来我们对与速率相关的构成法做同样的处理。如果SymEngine被设置为使用LLVM即时编译器，则默认选择最高性能的选项，该编译器（结合一些积极的编译标志）产生所有可用选项中最快的代码评估路径。作为后备措施，所谓的 "lambda "优化器（它只需要一个兼容C++11的编译器）将被选中。同时，我们将要求CAS进行普通子表达式的消除，以尽量减少评估过程中使用的中间计算的数量。我们将记录在SD实现的构造器内执行 "初始化 "步骤所需的时间，因为这是发生上述转换的地方。
*


* [1.x.338]
*
* [1.x.339] [1.x.340]。


*
* 主函数只调用两组要执行的例子的驱动函数。
*


* [1.x.341]
* [1.x.342][1.x.343] 。


*[1.x.344][1.x.345]


* 第一个探索性的例子产生了以下输出。经核实，所有三种实现方式产生的结果是相同的。
* [1.x.346]
*
* [1.x.347][1.x.348] 。
*

* 为了帮助总结虚拟实验本身的结果，下面是一些图表，显示了材料样品内选定位置的剪切应力，与剪切应变的关系图。这些图表显示了在三种不同磁载荷下的应力-应变曲线，以及（机械）载荷曲线的最后一个周期，当速率依赖型材料达到可重复的（"稳态"）反应时。这些类型的图表通常被称为[Lissajous图]（https://en.wikipedia.org/wiki/Lissajous_curve）。粘弹性材料的曲线所呈现的椭圆面积可以衡量材料耗散的能量大小，其椭圆度表示粘性反应相对于弹性反应的相位变化。
* [2.x.239]
* 我们不难看出，磁弹性材料的反应有一条与加载曲线相匹配的卸载曲线。
*
* 但在这里可以清楚地注意到，随着施加磁场的增加，曲线的梯度也在增加。沿着这条曲线任何一点的切线都与瞬时剪切模量有关，由于能量密度函数的定义方式，我们预计剪切模量会随着磁场强度的增加而增加。我们观察到磁-粘弹性材料的行为大致相同。由加载-卸载曲线追踪的椭圆的主轴有一个斜率，随着施加更大的磁负荷而增加。同时，材料耗散的能量也越多。
* 至于代码输出，这是打印到控制台的关于用磁弹性材料进行流变学实验的部分。
* [1.x.349]
*
* 这部分的输出涉及到用磁弹性材料进行的实验。
* [1.x.350]
*
* 计时器的输出也被发送到控制台，因此我们可以比较进行手工计算和辅助计算所需的时间，并对使用AD和SD框架的开销有一些了解。以下是使用AD框架的磁弹性实验的时间，基于Trilinos库的Sacado组件。
* [1.x.351]
* 关于使用自动微分进行的计算（作为提醒，这是使用Sacadolibrary结合动态前向自动微分类型进行的两级微分），我们注意到，辅助计算需要大约[2.x.240]的时间来计算所需的数量。这看起来确实是一个相当大的开销，但是，正如介绍中提到的，这是否可以接受完全是主观的，并且取决于具体情况：你是否更看重计算机的时间，而不是人的时间来做必要的导数手工计算，验证其正确性，实现它们，并验证实现的正确性？如果你开发的研究代码只会在相对较少的实验中运行，你可能更看重自己的时间。如果你开发的生产代码将在10,000核的集群上反复运行几个小时，你的考虑可能就不一样了。无论如何，AD方法的一个很好的特点是，当函数和类在标量类型上建模时，有 "滴入 "能力。这意味着开始使用它只需要最小的努力。
* 与此相反，使用实时（JIT）编译的符号代数实现的磁涡弹材料的时间表明，在初始化过程中付出一些不可忽视的代价，计算本身的执行效率要高得多。
* [1.x.352]
* 由于初始化阶段很可能只需要在每个线程中执行一次，这个初始的昂贵阶段可以通过重复使用单个[2.x.241]实例来抵消。尽管磁弹性构成法与磁弹性构成法相比，有更多的条款需要计算，但它在执行动能变量和切线的计算方面仍然快了一个数量级。而且，与使用缓存方案的手工计算变量相比，计算时间几乎相等。因此，尽管使用符号框架需要在如何实现和操作符号表达方面进行范式转换，但它可以提供AD框架所缺乏的良好性能和灵活性。
* 关于数据缓存的问题，事实上，与使用中间值进行的数值实验相比，磁弹性材料实现的价值缓存所增加的成本是在 "update_internal_data() "中花费的时间[2.x.242] 。下面是删除缓存数据结构后，为 "手工计算 "变体提取的时间比较的样本输出。
* [1.x.353]

* 通过一些小的调整，我们可以很容易地测试批量优化器的不同优化方案。因此，让我们比较一下与 "LLVM "批处理优化器设置相关的计算费用和其他选择。以下是 "lambda "优化方法的时间报告（保留使用CSE）。
* [1.x.354]
* 这里的主要观察是，与 "LLVM "方法相比，在 "辅助计算 "部分花费的时间要多出一个数量级。
* 最后，我们将测试 "字典 "替换与CSE的结合情况。字典替换只是在CAS框架内做了所有的评估，而没有对底层数据结构进行转换。在这种情况下，只有使用缓存中间结果的CSE才能提供任何 "加速"。考虑到这一点，下面是这个选择的结果。
* [1.x.355]
* 不用说，与其他两种方法相比，这些结果花了不少时间来产生。字典 "替换方法也许只适用于简单的表达式，或者当调用的数量足够少的时候。
*[1.x.356][1.x.357]
*

*也许你已经相信这些工具有一些优点，并且可以对你有直接的帮助或用途。现在明显的问题是使用哪一个。特别是在连续点层面上，你将使用这些框架来计算构成法则的导数，我们可以说以下几点。
*
* - 自动微分可能是进入辅助微分世界的最简单的切入点。
*
* - 鉴于构成框架有足够的通用实现，自动微分通常可以用来替代内在的标量类型，然后可以利用辅助类来计算一阶（以及可能的高阶）导数，只需付出最小的努力。
*
* 作为对上述观点的限定，作为一个 "落入式替代 "并不意味着你必须对这些数字所通过的算法不产生争议。有可能不经意间进行的操作，在进行区分时，会返回一个不正确的结果。  所以这绝对是一个人应该注意的事情。  一个具体的例子。当计算一个张量的特征值时，如果该张量是对角线的，那么得到结果的捷径就是直接返回对角线条目（从输入张量中提取的）。就计算特征值本身而言，这是完全正确的，但是不通过算法来计算非对角线张量的特征值会产生意想不到的副作用，即特征值看起来（对AD框架而言）是完全相互脱钩的，它们的交叉敏感度没有被编码在返回的结果中。在进行微分时，导数张量的许多条目将被丢失。为了解决这个问题，我们必须确保使用标准的特征值求解算法，这样返回的特征值对彼此的敏感度就会在结果中得到编码。
*
* - 涉及AD数字类型的计算可能很昂贵。随着微分运算顺序的增加，费用也会增加（有时是相当大的）。这可能会被周围操作的计算复杂性所缓解（例如线性求解），但最终还是要看具体问题。
*
* - AD被限制在只需要总导数的情况下。如果一个微分操作需要相对于自变量的偏导，那么使用它是不合适的。
*
* - 每个AD库都有自己的怪癖（说起来很悲哀，但根据作者的经验，是真的），所以可能需要一些试验和错误来找到合适的库和选择AD数来满足你的目的。这些 "怪癖 "的原因往往归结于库背后的整体理念（数据结构、模板元编程的使用等）以及导数计算的数学实现（例如，使用对数函数改变基础的结果操作可能限制了输入值的域
*
* - 当然，所有的细节都是对用户隐藏的）。)  此外，一个库可能比另一个库能更快地计算出所需的结果，所以在这方面进行一些初步探索可能是有益的。
*
* - 符号微分（嗯，一般来说，使用CAS）提供了最灵活的框架，可以进行辅助计算。
*
* - SD框架可以做AD框架所能做的一切，还有一个好处是可以对某些操作和运算的时间进行低级控制。
*
* - 表达式评估的加速是可能的，与一些手工实现相比，有可能导致SD框架接近原生的性能（当然，这种比较取决于整个程序设计），但代价是初始优化调用。
*
* - 巧妙地使用[2.x.243]可以最大限度地减少优化依赖表达式的昂贵调用的费用。  可以对[2.x.244]进行序列化，往往（但不一定）这个昂贵的调用可以做一次，然后在以后的模拟中重复使用。
*
* - 例如，如果两个或更多的材料法只因其材料参数而不同，那么只要这些材料参数被认为是象征性的，就可以在它们之间共享一个批量优化器。这意味着你可以 "区分一次，在许多情况下评估"。
*
* - SD框架可以部分地被用作标量类型的 "直接替换"，但是人们（至少）必须在它周围增加一些框架来执行值替换步骤，将符号类型转换为它们的数字对应物。
*
* - 在一些专门的算法中可能无法使用SD数字。  例如，如果一个算法的退出点或代码分支是基于（符号）输入参数应该采取的一些具体的数值，那么显然这是不可行的。我们要么重新实现专门针对SD数字类型的算法（有点不方便，但经常是可能的，因为[2.x.245]类支持条件反射），要么必须使用创造性的手段来解决这个具体问题（例如，引入一个符号表达式来表示这个算法返回的结果，如果在要使用它的上下文中是合理的，也许可以声明它是一个[符号函数]（https://dealii.org/developer/doxygen/deal.II/namespaceDifferentiation_1_1SD.html#a876041f6048705c7a8ad0855cdb1bd7a）。这以后可以用它的数值来替代，如果声明为符号函数，那么它的递延导数也可以作为替代的结果纳入计算中。)
*
* - 使用SD的最大缺点是，使用它需要一个范式的转变，人们必须以不同的方式来构建大多数问题，以便利用它的最大优势。仔细考虑如何使用和重用数据结构也是让它有效工作的关键）。这可能意味着，人们需要对它进行一番玩耍，并建立起对典型操作顺序的理解，以及每一步在操作基础数据方面的具体作用。如果人们有时间和意愿这样做，那么使用这个工具的好处可能是巨大的。
*[1.x.358][1.x.359]
*

*有几个合乎逻辑的方法可以扩展这个程序。
*
* - 也许最明显的扩展是实现和测试其他构成模型。  这仍然可以在磁-机械耦合问题的范围内进行，也许可以考虑替代能量函数的 "Neo-Hookean "型弹性部分，改变耗散能量的构成规律（及其相关的演化规律），或者包括磁滞效应或这些材料试图模拟的复合聚合物的破坏模型。
*
* - 当然，所实现的模型可以被修改或完全替换为专注于物理学其他方面的模型，如电活性聚合物、生物力学材料、弹塑性介质等。
*
* - 为粘弹性演化规律实施不同的时间分层方案。
*
* - 与其直接从能量密度函数推导出一切，不如使用[2.x.246]来直接线性化动力学量。  这将意味着只需要一个一次微分的自动微分的数字类型，而且肯定会大大改善性能。  这种方法也为耗散材料提供了机会，比如这里考虑的磁涡弹材料，可以与AD结合起来实现。这是因为线性化调用了因变量相对于场变量的总导数，这正是AD框架所能提供的。
*
* - 研究使用其他可自动微分的数字类型和框架（如ADOL-C）。由于每个AD库都有自己的实现，选择使用哪个库可能会导致性能的提高，而且在最不幸的情况下，计算会更加稳定。至少可以说，对于deal.II支持的AD库，结果的准确性应该基本不受这个决定的影响。
*
* - 在有限元模拟中嵌入这些构成法之一。
* 用较少的精力，可以考虑重新编写非线性问题求解器，比如在[2.x.247]中实现的使用AD或SDapproaches来计算牛顿矩阵的问题。事实上，这在[2.x.248]中已经完成。
*

* [1.x.360][1.x.361][2.x.249] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-72_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28]
* [2.x.3]
* [1.x.29]


*[1.x.30][1.x.31]


*[1.x.32][1.x.33]


* 这个程序解决的问题与[2.x.4]相同，即解决[最小表面方程](https://en.wikipedia.org/wiki/Minimal_surface)
* [1.x.34]
*
* 我们在那里发现的问题（见[1.x.35]部分）是，当想要使用牛顿迭代时，我们需要计算方程残差对解的导数[2.x.5]（这里，因为右手边是零，残差只是左手边的）。对于我们这里的方程，这是很麻烦的，但不是不可能的
*
* 但是我们可以很容易地想象出更复杂的方程，仅仅正确地实现残差本身就是一个挑战，更不用说为计算雅各布矩阵所需的导数而这样做了。我们将在这个程序中解决这个问题。使用在[2.x.6]中详细讨论过的自动微分技术，我们将想出一个办法，我们只需要实现残差就可以免费得到雅各布矩阵。
*事实上，我们甚至可以更进一步。在[2.x.7]中，我们只是把方程当作一个给定的东西，而最小表面方程实际上是最小化一个能量的产物。具体来说，最小表面方程是对应于能量最小化的欧拉-拉格朗日方程[1.x.36]，其中能量密度*由[1.x.37]给出，这就等于说我们要找到能量函数[1.x.38]的变化的静止点，因为这就是边界值问题的平衡解所在。
* 那么关键的一点是，也许，我们甚至不需要实现常数，但实现更简单的能量密度[2.x.8]实际上就足够了。
* 那么我们的目标是这样的。当使用牛顿迭代时，我们需要反复解决线性偏微分方程
* [1.x.39]
* 这样我们就可以计算出更新
* [1.x.40]
*与牛顿步骤的解决方案[2.x.9]。正如在[2.x.10]中所讨论的，我们可以用手计算导数[2.x.11]，并获得[1.x.41]。
* 因此，这就是这个程序的意义所在。它是关于可以帮助我们计算[2.x.12]的技术，而不必明确地实现它，或者提供[2.x.13]的实现或[2.x.14]的实现。更确切地说，我们将实现三种不同的方法，并在运行时间方面对它们进行比较，但也要注意
*
* - 也许更重要的是
*
* - 实现它们需要多少人力。
*
* - 在[2.x.15]中使用的方法来形成雅各布矩阵。
*
* - 从残差的实现中计算雅各布矩阵 [2.x.16] ，使用自动微分。
*
* - 从能量函数[2.x.17]的实现中计算残差和雅各布矩阵，同样使用自动微分。
* 对于这些方法中的第一个，与[2.x.18]相比，没有概念上的变化。
*

*[1.x.42][1.x.43] 。


* 对于第二种方法，让我们概述一下我们将如何利用自动微分来计算残差向量的线性化来处理这个问题。为此，让我们暂时改变一下符号，用[2.x.19]表示的不是微分方程的残差，而是事实上的残差向量*。
*
*--即离散的残差*。我们这样做是因为这就是我们
*当我们在一个给定的网格上对问题进行离散化时，我们实际上是这样做的。我们解决[2.x.20]问题，其中[2.x.21]是未知数的向量。
* 更确切地说，残差的[2.x.22]分量由[1.x.44]给出，其中[2.x.23] 。鉴于此，单元格[2.x.24]的贡献为[1.x.45]，其一阶泰勒展开为[1.x.46]，因此我们可以计算单元格[2.x.25]对雅各布矩阵[2.x.26]的贡献为[2.x.27] 。这里重要的一点是，在单元格[2.x.28]上，我们可以表示[1.x.47]为了清楚起见，我们用[2.x.29]和[2.x.30]作为计数索引，以明确它们彼此之间以及与[2.x.31]不同。因为在这个公式中，[2.x.32]只取决于系数[2.x.33]，我们可以通过[2.x.35]的自动微分，将导数[2.x.34]计算为矩阵。通过我们一直使用的相同论证，很明显[2.x.36]实际上并不取决于
*所有*未知数[2.x.37]，而只取决于[2.x.38]是住在单元格[2.x.39]上的形状函数的那些未知数，因此在实践中，我们将[2.x.40]和[2.x.41]限制在矢量和矩阵的那一部分，对应于本地*DoF指数，然后从本地单元格[2.x.42]分配到全球对象。
* 使用所有这些实现，然后的方法是在程序中实现[2.x.43]，并让自动微分机械从中计算导数[2.x.44]。
*

*[1.x.48][1.x.49]


*对于装配过程的最终实现，我们将比残差高一个层次：我们的整个线性系统将直接由支配这个边界值问题的物理学的能量函数决定。我们可以利用这样一个事实，即我们可以直接从局部贡献中计算域中的总能量，即[1.x.50]在离散设置中，这意味着在每个有限元上我们有[1.x.51]如果我们实现单元能量，这取决于场解，我们可以计算其第一个（离散）变化[1.x.52因此，从单元对总能量函数的贡献来看，只要我们能够提供局部能量的实现，我们就可以期待为我们生成近似的残差和切线贡献[2.x.45]。同样，由于本教程中使用的自动微分变量的设计，在实践中，这些对残差向量和正切矩阵贡献的近似值实际上是精确到机器精度的。
*

* [1.x.54] [1.x.55] 。
* 本教程的大部分内容是对[2.x.46]的完全复制。因此，为了简洁起见，并保持对这里实施的变化的关注，我们将只记录新的内容，并简单地指出哪些部分的代码是对以前内容的重复。
*



*
* [1.x.56] [1.x.57]。


*
* 本教程中包含了几个新的头文件。第一个是提供ParameterAcceptor类的声明。
*


* [1.x.58]
*
* 这是第二个，这是一个包罗万象的头，可以让我们在这个代码中加入自动区分（AD）功能。
*


* [1.x.59]
*
* 而接下来的三个则使用通用的[2.x.47]框架提供一些多线程能力。
*


* [1.x.60]
*
* 然后我们为这个程序打开一个命名空间，并将dealii命名空间的所有内容导入其中，就像以前的程序一样。
*


* [1.x.61]
*
* [1.x.62] [1.x.63]。


*
* 在本教程中，我们将实现三种不同的方法来组装线性系统。其中一个反映了最初在[2.x.48]中提供的手工实现，而另外两个使用Sacado自动微分库，该库作为Trilinos框架的一部分提供。   
* 为了方便在这三种实现之间进行切换，我们有这个非常基本的参数类，它只有两个可配置的选项。
*


* [1.x.64]
*
*为要使用的配方和相应的AD框架进行选择。
*



* - 制定 = 0 :无援助的实施（全手工线性化）。
*


*
* - 制定 = 1 : 有限元残差的自动线性化。
*


*
* - 配方 = 2 : 使用变量配方自动计算有限元残差和线性化。
*


* [1.x.65]
*
* 线性系统残差的最大可接受公差。我们将看到，一旦我们使用AD框架，装配时间就会变得很明显，所以我们将[2.x.49]中选择的公差提高了一个数量级。这样，计算就不会花费太长时间来完成。
*


* [1.x.66]
*
* [1.x.67] [1.x.68]。


*
* 该类模板与 [2.x.50] 中的模板基本相同。该类唯一的功能变化是：。
*


*
* - run()函数现在需要两个参数：一个是选择采用哪种装配方法，另一个是允许的最终残差的公差，以及
*


*
* - 现在有三个不同的装配函数，实现了装配线性系统的三种方法。我们将在后面提供关于这些的细节。
*


*


* [1.x.69]
*
* [1.x.70] [1.x.71]。


*
*应用于问题的边界条件没有变化。
*


* [1.x.72]
*
* [1.x.73] [1.x.74]。



* [1.x.75] [1.x.76]。


*
*对类的构造函数没有做任何修改。
*


* [1.x.77]
*
* [1.x.78] [1.x.79]。


*
* 设置类数据结构的函数没有任何变化，即DoFHandler、应用于问题的悬挂节点约束以及线性系统。
*


* [1.x.80]
*
* [1.x.81] [1.x.82]。



* [1.x.83] [1.x.84]。


*
* 汇编函数是本教程的有趣贡献。assemble_system_unassisted()方法实现了与[2.x.51]中详述的装配函数完全相同，但在这个例子中，我们使用[2.x.52]函数来多线程装配过程。这样做的原因很简单。当使用自动分化时，我们知道会有一些额外的计算开销产生。为了减轻这种性能损失，我们希望尽可能多地利用（容易获得的）计算资源。[2.x.53]的概念使这成为一个相对简单的任务。同时，为了公平比较，我们需要对在计算残差或其线性化时不使用任何援助的实现做同样的事情。([2.x.54]函数首先在[2.x.55]和[2.x.56]中讨论，如果你想阅读它的话。)   
* 实现多线程所需的步骤在这三个函数之间是相同的，所以我们将利用assemble_system_unassisted()函数作为一个机会来关注多线程本身。
*


* [1.x.85]

* [2.x.57]希望我们提供两个示范性的数据结构。第一个，`ScratchData`，是用来存储所有要在线程之间重复使用的大数据。`CopyData`将保存来自每个单元的对线性系统的贡献。这些独立的矩阵-向量对必须按顺序累积到全局线性系统中。由于我们不需要[2.x.58]和[2.x.59]类已经提供的任何东西，我们使用这些确切的类定义来解决我们的问题。请注意，我们只需要一个局部矩阵、局部右手向量和单元自由度索引向量的单个实例。
*
* - 因此[2.x.60]的三个模板参数都是`1`。
*


* [1.x.86]
*
* 我们还需要知道在装配过程中我们将使用什么类型的迭代器。为了简单起见，我们只要求编译器使用decltype()指定器为我们解决这个问题，知道我们将在由[2.x.61]拥有的活动单元上进行迭代。
*


* [1.x.87]
*
* 在这里，我们初始化典范的数据结构。因为我们知道我们需要计算形状函数梯度、加权雅各布和实空间中的四分位点的位置，所以我们把这些标志传给类的构造函数。
*


* [1.x.88]

* 现在我们定义一个lambda函数，它将对一个单元格进行装配。三个参数是那些将被[2.x.62]预期的参数，由于我们将传递给那个最终调用的参数。我们还捕获了[2.x.63]指针，这意味着我们将可以访问 "this"（即当前的`MinimalSurfaceProblem<dim>`）类实例，以及它的私有成员数据（因为lambda函数是在MinimalSurfaceProblem<dim>方法中定义的）。     
* 在函数的顶部，我们初始化依赖于正在进行工作的单元的数据结构。请注意，重新初始化的调用实际上返回了一个FEValues对象的实例，该对象被初始化并存储在`scratch_data`对象中（因此，被重复使用）。     
* 同样，我们从[2.x.64]提供的`copy_data`实例中获得本地矩阵、本地RHS向量和本地单元格DoF指数的别名。然后我们初始化单元格的DoF指数，因为我们知道本地矩阵和向量的大小已经正确。
*


* [1.x.89]
*
* 对于牛顿方法，我们需要在问题被线性化的那一点上获得解的梯度。       
* 一旦我们有了这个，我们就可以用通常的方法对这个单元进行装配。  与[2.x.65]的一个小区别是，我们使用了（相当方便的）基于范围的循环来迭代所有正交点和自由度。
*


* [1.x.90]
*
* [2.x.66]要求的第二个lambda函数是一个执行累积全局线性系统中的局部贡献的任务。这正是这个函数所做的，其实现的细节在之前已经看到过。需要认识的主要一点是，局部贡献被存储在传入该函数的`copy_data`实例中。这个`copy_data`在[2.x.67]对`cell_worker`的一些调用中已经被填充了数据。
*


* [1.x.91]
*
* 我们已经有了所有需要的函数定义，所以现在我们调用[2.x.68]来执行实际的装配。  我们传递一个标志作为最后的参数，说明我们只想对单元格进行装配。在内部，[2.x.69]将可用的工作分配给不同的线程，有效地利用当今几乎所有的处理器所提供的多核。
*


* [1.x.92]
*
* 最后，正如在 [2.x.70] 中所做的那样，我们从系统中移除悬空的节点，并对定义牛顿更新的线性系统应用零边界值 [2.x.71] 。
*


* [1.x.93]
*
* [1.x.94] [1.x.95]。


*
* 正如在介绍中所概述的，对于这第二种方法，我们需要做的是实现单元格[2.x.73]对残差向量的局部贡献[2.x.72]，然后让AD机器处理如何计算它的导数[2.x.74]。   
* 对于下面的内容，请记住，[1.x.96]中的[2.x.75] 。   
* 让我们看看这在实践中是如何实现的。
*


* [1.x.97]
*
* 我们将利用 [2.x.76] 中所示的技术，预先定义我们要使用的AD数据结构。在这种情况下，我们选择辅助类，它将使用Sacado向前自动微分类型自动计算有限元残差的线性化。这些数字类型可以只用来计算一阶导数。这正是我们想要的，因为我们知道我们将只对残差进行线性化，这意味着我们只需要计算一阶导数。计算的返回值将是`double`类型。     
* 我们还需要一个提取器来检索一些与问题的现场解决方案有关的数据。
*


* [1.x.98]
*
* 有了这个，让我们定义lambda函数，它将被用来计算单元格对雅各布矩阵和右手边的贡献。
*


* [1.x.99]
*
* 我们现在要创建并初始化一个AD辅助类的实例。要做到这一点，我们需要指定有多少个自变量和因变量。自变量将是我们的解向量所具有的局部自由度的数量，即离散化解向量[2.x.78]的每元素表示中的数字[2.x.77]，它表示每个有限元素有多少个解系数。在deal.II中，这等于[2.x.79]，自变量的数量将是我们将要形成的局部残差向量中的条目数。在这个特定的问题中（就像许多其他采用[标准Galerkin方法](https://en.wikipedia.org/wiki/Galerkin_method)的问题一样），局部求解系数的数量与局部残差方程的数量相符。
*


* [1.x.100]
*
* 接下来，我们将解的数值告知帮助器，即我们希望线性化的[2.x.80]的实际数值。由于这是在每个元素上单独进行的，我们必须从全局解决方案向量中提取解决方案的系数。换句话说，我们将所有这些系数[2.x.81]（其中[2.x.82]是一个局部自由度）定义为进入向量[2.x.83]（因果函数）计算的自变量。       
*然后我们得到了由自动可分的数字表示的自由度值的完整集合。对这些变量进行的操作从这一点开始被AD库跟踪，直到对象超出范围。所以正是这些变量[2.x.84][2.x.85]，我们将对其计算残差分录的导数。
*


* [1.x.101]
*
* 然后我们做一些特定问题的任务，首先是计算所有的值，（空间）梯度，以及基于 "敏感 "的AD自由度值的类似东西。在这个例子中，我们要检索每个正交点的解梯度。请注意，现在解梯度对自由度值很敏感，因为它们使用[2.x.86]作为标量类型，[2.x.87]矢量提供局部自由度值。
*


* [1.x.102]
*
* 我们声明的下一个变量将存储单元格残余向量贡献。这是相当不言自明的，除了一个[1.x.103]细节。请注意，向量中的每个条目都是手工初始化的，数值为0。这是一个[2.x.88]强烈推荐的[2.x.89]做法，因为一些AD库似乎没有安全地初始化这些数字类型的内部数据结构。不这样做可能会导致一些非常难以理解或检测的bug（感谢这个程序的作者出于一般的坏经验而提到这一点）。因此，出于谨慎考虑，值得明确地将初始值归零。在这之后，除了符号的改变，残差集看起来和我们之前看到的单元格RHS向量差不多。我们在所有正交点上循环，确保系数现在通过使用正确的`ADNumberType'来编码它对（敏感的）有限元DoF值的依赖性，最后我们组装残差向量的组件。为了完全清楚，有限元形状函数（及其梯度等）以及 "JxW "值仍然是标量值，但每个正交点的[2.x.90]和[2.x.91]是以独立变量计算的。
*


* [1.x.104]
*
* 一旦我们计算出完整的细胞残余向量，我们就可以把它注册到帮助类中。       
* 此后，我们在评估点计算残差值（基本上是从我们已经计算出来的东西中提取出真实的值）和它们的雅各布（每个残差分量相对于所有单元DoF的线性化）。为了组装成全局线性系统，我们必须尊重残差和RHS贡献之间的符号差异。对于牛顿方法，右手边的矢量需要等于负的*残差矢量。
*


* [1.x.105]
*
* 该函数的剩余部分等于我们之前的内容。
*


* [1.x.106]
*
* [1.x.107] [1.x.108]。


*
* 在这第三种方法中，我们将残差和雅各布作为局部能量函数[1.x.109]的第一和第二导数来计算，能量密度由[1.x.110]给出。
* 让我们再次看看这是如何做到的。
*


* [1.x.111]
*
* 在这个装配过程的实现中，我们选择了辅助类，它将使用嵌套的Sacado前向自动微分类型，自动计算残差及其从单元贡献到能量函数的线性化。所选的数字类型可以用来计算第一和第二导数。我们需要这样做，因为残差定义为势能对DoF值的敏感性（即其梯度）。然后我们需要将残差线性化，这意味着必须计算势能的二阶导数。你可能想把这与之前函数中使用的 "ADHelper "的定义进行比较，在那里我们使用了[2.x.92] 。
*


* [1.x.112]

* 然后让我们再次定义lambda函数，在一个单元格上进行积分。     
* 为了初始化一个辅助类的实例，我们现在只需要预先知道自变量的数量（即与元素解向量相关的自由度的数量）。这是因为由能量函数产生的二阶导数矩阵必然是平方的（而且，顺便说一下，也是对称的）。
*


* [1.x.113]
*
* 再一次，我们将所有的单元格DoFs值注册到帮助器中，然后提取这些值的 "敏感 "变体，这些变体将被用于后续的操作中，必须加以区分
*
* - 其中之一是计算解决方案的梯度。
*


* [1.x.114]
*
* 我们接下来创建一个变量来存储电池的总能量。我们再一次强调，我们明确地对这个值进行零初始化，从而确保这个起始值的数据的完整性。       
* 我们方法的目的是计算细胞总能量，这是内部（由于右手函数，通常是[2.x.93]中的线性）和外部能量的总和。在这种特殊情况下，我们没有外部能量（例如，来自源项或诺伊曼边界条件），所以我们将关注内部能量部分。       
*事实上，计算[2.x.94]几乎是微不足道的，只需要以下几行。
*


* [1.x.115]
*
* 在我们计算出这个单元的总能量后，我们将把它注册到帮助器上。  在此基础上，我们现在可以计算出所需的数量，即残差值和它们在评估点的雅各布系数。和以前一样，牛顿的右手边需要是残差的负数。
*


* [1.x.116]

* 和前两个函数一样，函数的其余部分和以前一样。
*


* [1.x.117]
*
* [1.x.118] [1.x.119]。


*
*解题函数与 [2.x.95] 中使用的相同。
*


* [1.x.120]
*
* [1.x.121] [1.x.122]。


*
* 自[2.x.96]以来，在网格细化程序和适应性网格之间的解决方案的转移方面没有任何变化。
*


* [1.x.123]
*
* [1.x.124] [1.x.125]。


*
* 边界条件的选择仍然与[2.x.97]相同.
*


* [1.x.126]
*
* [1.x.127] [1.x.128]。


*
*......正如在求解迭代过程中用来计算残差的函数一样。如果真的需要，我们可以用能量函数的微分来代替，但为了简单起见，我们在这里只是简单地复制我们在[2.x.98]中已有的内容。
*


* [1.x.129]
*
* [1.x.130] [1.x.131]。


*
* 非线性迭代程序的步长（或欠松系数）的选择仍然固定在[2.x.99]中选择和讨论的数值。
*


* [1.x.132]
*
* [1.x.133] [1.x.134]。


*
* 从`run()`调用的最后一个函数以图形形式输出当前的解决方案（和牛顿更新），作为VTU文件。它与以前的教程中所使用的完全相同。
*


* [1.x.135]
*
* [1.x.136] [1.x.137]。


*
* 在运行函数中，大部分内容与最初在 [2.x.100] 中实现的相同。唯一可以观察到的变化是，我们现在可以（通过参数文件）选择系统残余物的最终可接受的公差，并且我们可以选择我们希望利用的装配方法。为了使第二个选择明确，我们向控制台输出一些信息，表明选择。由于我们对比较三种方法中每一种的装配时间感兴趣，我们还添加了一个计时器，跟踪装配过程中所花费的时间。我们还跟踪了解决线性系统所需的时间，这样我们就可以将这些数字与代码中通常需要最长时间执行的部分进行对比。
*


* [1.x.138]
*
* [1.x.139] [1.x.140]。


*
* 最后是主函数。它遵循大多数其他主函数的方案，但有两个明显的例外。
*


*
* - 我们调用[2.x.101]，以便设置（通过一个隐藏的默认参数）使用多线程任务执行的线程数。
*


*
* - 我们还有几行专门用于读入或初始化用户定义的参数，这些参数将在程序执行过程中被考虑。
*


* [1.x.141]
* [1.x.142][1.x.143] 。


* 由于在[2.x.102]中首次分析的问题的物理学没有变化，所以没有什么可报告的。它们之间唯一明显的区别是，在默认情况下，这个程序只运行9个网格细化步骤（而[2.x.103]则执行11个细化步骤）。下面报告的所有时间都是在发布模式下获得的）。
* [1.x.144]
*
* 以下是手部线性化的输出（在2012年左右的四核八线程笔记本上计算）。
*
以下是手部线性化的输出结果（在2012年左右的四核八线程笔记本电脑上计算的 * - 但我们真正感兴趣的是不同实现方式之间的相对时间）。)
* [1.x.145]
* 而对于使用Sacado动态正向AD数字类型，以自动方式线性化残差的实现。
* [1.x.146]
* 最后，对于直接从能量函数（使用嵌套的萨卡多动态正向AD数）计算残差和其线性化的实现。
* [1.x.147]
*
* 很明显，交给自动区分框架执行的工作越多，在装配过程中花费的时间就越多。累计所有的细化步骤，使用一级自动微分导致在装配阶段花费了[2.x.104]的计算时间，与无辅助装配相比，而直接从能量函数推导出离散线性系统时，装配时间要长[2.x.105].毫不奇怪，解决线性系统的总体时间保持不变。对许多人来说，这可能意味着在生产代码中利用高阶微分（在有限元水平）会导致不可接受的开销，但在原型设计阶段可能仍然有用。因此，两者之间的一个很好的折衷办法可能是有限元残差的自动线性化，它以可衡量但也许不是不可接受的成本提供了很多便利。另外，我们可以考虑不在每一步中重新建立牛顿矩阵。
*
* --这个话题在[2.x.106]中进行了大量的深入探讨。
* 当然，在实践中，实际的开销在很大程度上取决于被评估的问题（例如，解中有多少成分，被微分的函数的性质是什么，等等）。因此，这里提出的确切结果应该仅在这个标量问题的背景下进行解释，当涉及到其他问题时，用户肯定需要进行一些初步调查。
*

*[1.x.148][1.x.149]


* 与[2.x.107]一样，有几个与自动区分有关的项目可以进一步评估。
*
* - 应调查其他AD框架的使用情况，展望其他实现方式可能提供性能优势。
*
* - 除了本教程中硬编码的数字类型外，还值得评估AD数字类型。关于在有限元水平上采用的两次可微分类型，混合微分模式（"RAD-FAD"）原则上应该比这里采用的单模式（"FAD-FAD"）类型更有计算效率。RAD-FAD类型没有被默认选择的原因是，在撰写本文时，在Sacado库中，它的实现仍然存在一些错误，导致内存泄漏。  这在[2.x.108]模块中有所记载。
*
* - 可能的情况是，使用降低精度的类型（即`float`）作为AD数字的标量类型，可以在装配时减少计算费用。使用 "float "作为矩阵和残差的数据类型不是不合理的，因为牛顿更新只是为了让我们更接近解决方案，而不是真正的*解决方案；因此，考虑使用降低精度的数据类型来计算这些更新，然后将这些更新累积到使用完整的 "双 "精度的解决方案向量中，是有意义的。
*
* - 在装配过程中可能减少资源的另一种方法是将AD的实现作为一个构成性模型。这类似于[2.x.109]中采用的方法，并将自动分化的起点推到计算链的上一级。这反过来意味着AD库跟踪的操作更少，从而降低了微分的成本（尽管我们会在每个单元的正交点进行微分）。
*
* - [2.x.110]是[2.x.111]的另一个变体，解决了问题的一个非常不同的部分：直线搜索以及是否有必要在每次非线性迭代中重新建立牛顿矩阵。鉴于上述结果表明，使用自动微分是有代价的，[2.x.112]中的技术有可能在一定程度上抵消这些代价。因此，将目前的程序与[2.x.113]中的技术结合起来是相当有趣的。对于生产代码来说，这肯定是个好办法。
*

* [1.x.150][1.x.151] [2.x.114] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-74_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22]
* [2.x.2]
* [1.x.23]


*[1.x.24][1.x.25][1.x.26]


* [1.x.27][1.x.28] 。
* 在本教程中，我们展示了FEInterfaceValues类的用法，该类是为集合不连续Galerkin（DG）方法产生的面项而设计的。FEInterfaceValues类提供了一种简单的方法来获得形状函数和跨单元面解的跳跃和平均。[2.x.3] [2.x.4] 泊松方程的SIPG方法，在[2.x.5]和[2.x.6]中已经使用过。   [2.x.7] 使用FEInterfaceValues组装面项，使用[2.x.8]组装系统矩阵，这与[2.x.9]类似。   [2.x.10] 使用误差估计器进行自适应网格细化。   [2.x.11] 两个测试案例：平滑函数的收敛测试和奇异解的适应性网格细化测试。[2.x.12]
*[1.x.29][1.x.30]
* 在这个例子中，我们考虑泊松方程[1.x.31]受边界条件[1.x.32]的影响。为了简单起见，我们假设扩散系数[2.x.13]是常数。注意，如果[2.x.14]是不连续的，我们在计算单元面上的跳跃项时需要考虑到这一点。
* 我们用[2.x.15]表示网格，[2.x.16]是一个网格单元。内部和边界面的集合分别用[2.x.17]和[2.x.18]表示。让[2.x.19]和[2.x.20]是共享一个面[2.x.21]的两个单元，[2.x.22]是[2.x.23]的外法向量。那么跳跃运算符由 "这里减去那里 "公式给出，[1.x.33]和平均运算符分别为[1.x.34]。请注意，当[2.x.24]时，我们定义[2.x.25]和[2.x.26]。使用SIPG的离散化由以下弱式给出（更多细节可以在[2.x.27]和其中的参考文献中找到）。
* [1.x.35]
*
*

* [1.x.36][1.x.37] 。
* 惩罚参数定义为 [2.x.28] ，其中 [2.x.29] 是与细胞面相关的局部长度尺度；这里我们选择细胞在面的法线方向上的长度近似值。[2.x.30] ，其中[2.x.31]是与面相邻的两个单元[2.x.32]，我们计算出[2.x.33]。
* 在上述公式中，[2.x.34]是惩罚常数。为了确保离散矫捷性，惩罚常数必须足够大[2.x.35]。人们对于应该使用文献中提出的哪个公式并没有真正的共识。(这与[2.x.36]的 "结果 "部分所讨论的情况相似。)人们可以直接选择一个大的常数，而其他选择可以是[2.x.37]或[2.x.38]的倍数。在本代码中，我们遵循 [2.x.39] 并使用 [2.x.40] 。
*

*[1.x.38][1.x.39]
* 在这个例子中，稍加修改，我们使用卡拉卡希安和帕斯卡尔的误差估计器[2.x.41][1.x.40]，其中
* [1.x.41]
* 这里我们用[2.x.42]代替[2.x.43]来表示[2.x.44]的跳跃项（[2.x.45]和[2.x.46]的第一个项）。
*为了计算这个估计值，在每个单元格[2.x.47]中我们计算
* [1.x.42]
* 然后每个单元的误差估计的平方是[1.x.43]，[2.x.48]的系数是由于整体误差估计器只包括每个内部面一次，所以每个单元的估计器对相邻的两个单元都以一半的系数来计算。注意我们计算[2.x.49]而不是[2.x.50]以简化实现。然后每个单元的误差估计方被存储在一个全局向量中，其[2.x.51]准则等于[2.x.52] 。
*[1.x.44][1.x.45] 。
* 在第一个测试问题中，我们使用二维的[2.x.53]的平滑制造解进行收敛测试
* [1.x.46]
* 和 [2.x.54] 。我们针对制造的解决方案计算误差并评估收敛率。
* 在第二个测试中，我们在二维的L形域[2.x.56]上选择了[2.x.55]。该解在极坐标中由[2.x.57]给出，它在原点有一个奇点。我们构建了一个误差估计器来检测有大误差的区域，根据这个估计器来自适应地细化网格。
*

* [1.x.47] [1.x.48]。
* 前面几个文件已经在前面的例子中讲过了，因此不再进一步评论。
*


* [1.x.49]
*
* 这里定义了不连续的有限元和FEInterfaceValues。
*


* [1.x.50]
*
* [1.x.51] [1.x.52] 这里我们定义了两个测试案例：平滑函数的收敛率和[2.x.58] 的l_singularity。
*


* [1.x.53]
*
*收敛性测试的平滑解。
*


* [1.x.54]
*
* 相应的平滑函数的右手边。
*


* [1.x.55]
*
* 对应于函数[2.x.59]的右手边，我们假设扩散系数[2.x.60] 。
*


* [1.x.56]
*
* [1.x.57] [1.x.58] 以下两个辅助函数分别用于计算一个面上的[2.x.61]和[2.x.62]的跳转项。
*


* [1.x.59]
*
* 这个函数计算惩罚 [2.x.63] 。
*


* [1.x.60]
*
* [1.x.61] [1.x.62] 在下文中，我们为 [2.x.64] 定义了 "复制 "对象，它与 [2.x.65] 基本上相同。注意，这里没有定义 "Scratch "对象，因为我们用[2.x.66]代替。("复制 "和 "抓取 "对象的使用在WorkStream命名空间文档中有广泛的解释。
*


* [1.x.63]
*
* [1.x.64] [1.x.65] 在这些准备工作之后，我们进行本程序的主类，称为`SIPGLaplace`。该类的整体结构与其他许多教程程序一样。主要的区别只出现在集合函数的实现上，因为我们使用FEInterfaceValues来集合面的条件。
*


* [1.x.66]
*
* 该类的其余成员用于以下方面。
*


*
* - 每个单元存储误差估计器平方和能量规范平方的矢量。
*


*
* - 在屏幕上打印收敛率和错误。
*


*
* - 扩散系数[2.x.67]被设置为1。
*


*
* - 存储要计算的测试案例的信息的成员。
*


* [1.x.67]
*
* 这里的构造函数将测试案例作为输入，然后确定正确的解决方案和右手边的类。其余的成员变量以明显的方式进行初始化。
*


* [1.x.68]
*
* [1.x.69] [1.x.70] 这里的装配功能与 [2.x.68] 和 [2.x.69] 中的相似。与手工装配不同的是，我们只需要专注于在每个单元格、每个边界面和每个内部面进行装配。单元和面的循环是由[2.x.70]自动处理的。
* 该函数首先定义了一个局部（lambda）函数，用于整合单元项。
*


* [1.x.71]
*
* 接下来，我们需要一个在边界上集合面积分的函数。
*


* [1.x.72]
*
* 最后，一个在内部面组装面积分的函数。为了重新初始化FEInterfaceValues，我们需要向FEInterfaceValues的reinit()函数传递单元格、面和子面指数（用于自适应细化）。
*


* [1.x.73]

* 下面的lambda函数就会将数据复制到全局矩阵和右手边。  虽然DG离散化中没有悬空节点约束，但我们定义了一个空的AffineConstraints对象，使我们可以使用[2.x.71]的功能。
*


* [1.x.74]
*
* 从内部面组件复制数据到全局矩阵。
*


* [1.x.75]
*
* 在定义了装配函数后，我们现在可以创建ScratchData和CopyData对象，并将它们与上面的lambda函数一起传递给[2.x.72]此外，我们需要指定我们要在内部面完全装配一次。
*


* [1.x.76]
*
* [1.x.77] [1.x.78] 以下两个函数完全是标准的，没有难度。
*


* [1.x.79]
*
* [1.x.80] [1.x.81] 这里的误差估计器的装配与全局矩阵和右前侧的装配很相似，可以由[2.x.73]框架处理。为了理解每个局部（lambda）函数的作用，首先回顾一下，局部单元残差的定义为 [2.x.74] 。
*


* [1.x.82]
*
* 接下来计算边界项 [2.x.75] 。
*


* [1.x.83]

* 最后是内部面孔条款[2.x.76] 。
*


* [1.x.84]
*
* 在计算了每个单元的局部贡献后，我们仍然需要一种方法将这些贡献复制到全局向量中，该向量将容纳所有单元的误差估计值。
*


* [1.x.85]
*
* 在所有这些设置之后，让我们来做实际的工作。我们调整向量的大小，将结果写入其中，然后用[2.x.77]函数驱动整个过程。
*


* [1.x.86]
*
* [1.x.87] [1.x.88] 接下来，我们用能量准则来评估准确性。这个功能类似于上面的误差估计器的集合。这里我们计算由[1.x.89]定义的能量准则的平方 因此，相应的误差是[1.x.90]
*


* [1.x.91]
*
* 组装 [2.x.78] 。
*


* [1.x.92]
*
* 组装 [2.x.79] 。
*


* [1.x.93]
*
* 组装 [2.x.80] 。
*


* [1.x.94]
*
* [1.x.95] [1.x.96]。



* [1.x.97]
*
* [1.x.98] [1.x.99] 我们分别计算[2.x.81]规范、[2.x.82]半规范和能量规范中的三个误差。这些误差将被打印到屏幕上，同时也被存储在一个表格中，该表格记录了这些误差是如何随着网格细化而衰减的，并且可以在程序的最后一步输出。
*


* [1.x.100]
*
* [1.x.101] [1.x.102]。



* [1.x.103]
*
* 在运行了我们所有的计算之后，让我们告诉收敛表如何格式化它的数据并将其输出到屏幕。
*


* [1.x.104]
*
* [1.x.105] [1.x.106] 下面的[2.x.83]函数与前面的例子也类似，不需要注释。
*


* [1.x.107]
* [1.x.108][1.x.109] 。


* 这个程序的输出包括控制台输出和vtu格式的解决方案。
* 在第一个测试案例中，当你运行该程序时，屏幕输出应该是以下样子。
* [1.x.110]
*
* 当使用多项式度数为3的光滑情况时，收敛表将看起来像这样。[2.x.84]
* 理论上，对于多项式度数[2.x.85]，在[2.x.86]规范和[2.x.87]半规范中的收敛顺序应该是[2.x.88]和[2.x.89]，分别。我们的数值结果与理论有很好的一致性。
* 在第二个测试案例中，当你运行程序时，屏幕输出应该是以下样子。
* [1.x.111]
*
* 下图提供了一个L型域上这个测试案例的误差与自由度数的对数图。为了解释它，让[2.x.90]为自由度数，那么在均匀细化的网格上，[2.x.91]是二维的[2.x.92]阶。结合前面的理论结果，我们可以看到，如果解足够光滑，我们可以预期[2.x.93]准则的误差为[2.x.94]阶，[2.x.95]半准则的误差为[2.x.96]。在自适应细化的网格上，如我们在第二个测试案例中使用的网格，会不会得到与[2.x.97]函数相同的行为，这不是一个先验的说法，但人们当然可以希望。事实上，从图中我们可以看出，带有自适应网格细化的SIPG产生了渐进式的那种希望的结果。
* [2.x.98]
* 此外，我们观察到误差估计值的下降速度几乎与能量准则和[2.x.99]半准则的误差相同，并且比[2.x.100]的误差低一阶。这表明它有能力预测具有较大误差的区域。
* 虽然本教程侧重于实现，但[2.x.101]教程程序以无矩阵求解技术在计算时间上实现了一个高效的大规模求解器。注意，[2.x.102]教程目前不能与含有悬空节点的网格一起工作，因为多网格界面矩阵不那么容易确定，但这只是deal.II中缺少一些界面，没有什么根本原因。
*

* [1.x.112][1.x.113][2.x.103]
* [0.x.1]

include/deal.II-translator/A-tutorial/step-75_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] , [2.x.3] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32]
* [2.x.4]
* [1.x.33]


*
* [2.x.5] 作为这个程序的先决条件，你需要安装p4estlibrary和Trilinos库。在[1.x.34]文件中描述了deal.IItogether与这些附加库的安装。
*


* [1.x.35][1.x.36][1.x.37] 。


* 在有限元背景下，更多的自由度通常会产生更精确的解决方案，但也需要更多的计算努力。
* 在以前的教程中，我们找到了通过将网格分辨率与解的复杂性进行局部调整来有效分布自由度的方法（自适应网格细化，[2.x.6] ）。如果我们不仅调整网格，而且还局部调整每个单元上的相关无限元素的多项式程度，这种方法就特别有效（hp-adaptation, [2.x.7] ）。
* 此外，分配更多的进程来同时运行你的程序，有助于在更短的时间内解决计算的工作量。根据你的机器的硬件架构，你的程序必须为所有进程都能访问相同的内存（共享内存，[2.x.8]），或者进程被托管在几个独立的节点上（分布式内存，[2.x.9]）这种情况做好准备。
* 在高性能计算领域，内存访问被证明是当前超级计算机的瓶颈。我们可以通过MatrixFree方法（[2.x.10]）在飞行中计算矩阵向量乘积的效果来避免完全存储矩阵。它们可用于几何多网格方法（[2.x.11]），也可用于多项式多网格方法，以极大地加快方程组的求解速度。
* 本教程结合所有这些特点，以最先进的方式介绍了如何解决一个简单的拉普拉斯问题：在具有分布式内存的机器上利用hp-adaptation和无矩阵混合多栅方法。
*

*[1.x.38][1.x.39]


* 对于有限元的并行应用，我们将网格划分为子域（又称域分解），并将其分配给进程。这种划分发生在deal.II的活动单元上，正如在[2.x.12]中演示的那样。在那里，每个单元都有相同的有限元和相同的自由度分配，以及大约相同的工作负荷。为了平衡所有进程的工作量，我们必须平衡所有参与进程中的单元数量。
* 有了hp自适应方法，情况就不一样了：有限元类型可能因单元而异，因此自由度的数量也不同。匹配单元的数量并不能产生均衡的工作量。在无矩阵的情况下，工作量可以假定为与每个过程的自由度数量成正比，因为在最好的情况下，只有源向量和目的向量需要被加载。
* 我们可以通过给每个单元分配权重来平衡工作量，这些权重与自由度的数量成正比，并在所有进程之间平衡所有权重的总和。给每个单元分配单独的权重可以用我们以后要用的[2.x.13]类来实现。
*

*[1.x.40][1.x.41]


* 使用hp自适应方法，我们不仅要决定哪些单元需要细化或粗化，而且还可以选择如何做：要么调整网格分辨率，要么调整有限元的多项式程度。
* 我们将再次根据当前解决方案的（后验）计算误差估计值来决定哪些单元需要调整，例如，使用KellyErrorEstimator。我们将同样决定如何适应（事后）计算的平滑度估计：大的多项式度数在解决方案的平滑部分效果最好，而细的网格分辨率在不规则部分是有利的。在[2.x.14]中，我们提出了根据傅里叶系数的衰减来计算光滑度估计。让我们利用这个机会，提出另一种遵循同样思路的方法，但采用Legendre系数。
* 我们将简要介绍这种新技术的思路，但为了简单起见，将其描述限于一维。假设[2.x.15]是一个定义在单元[2.x.16]上的有限元函数[1.x.42]，其中每个[2.x.17]是一个形状函数。我们可以在Legendre多项式[2.x.19]的基础上等效地表示[2.x.18]为[1.x.43]。我们的目标是在有限元系数[2.x.20]和Legendre系数[2.x.21]之间获得一个映射。我们将通过把问题写成[2.x.22]对[2.x.23]在Legendre基础上的投影来实现这一目标。每个系数[2.x.24]都可以通过[1.x.44]计算。根据结构，Legendre多项式在[2.x.25]的内积下是正交的。此外，我们假设它们已经被归一化，所以它们的内积可以写成[1.x.45]，其中[2.x.27]是Kronecker delta，[2.x.28]是[2.x.29]到[2.x.30]的映射的Jacobian，（在本教程中）假设它是常数（即，该映射必须是仿射）。
* 因此，结合所有这些假设，在Legendre基础上表达[2.x.31]的投影矩阵只是[2.x.32] 。
*
*也就是说，[2.x.33]乘以身份矩阵。让[2.x.34]成为从[2.x.35]到其参考单元[2.x.36]的映射。因此，投影系统中右侧的条目为：[1.x.46]回顾[2.x.37]的形状函数表示，我们可以把它写成[2.x.38]，其中[2.x.39]是具有条目[1.x.47]的基数变化矩阵，因此[2.x.40]的值可以写成[2.x.41]，通过在转换为参考坐标后将[2.x.44]的前部因式分解，独立写成[2.x.43]。因此，把这一切放在一起，投影问题可以写成[1.x.48]，可以简单地改写成[1.x.49]。
* 在这一点上，我们需要强调的是，大多数有限元应用都使用非结构化的网格，对于这些网格的映射几乎总是非线性的。换句话说：[2.x.45]在整个单元中是常数的假设对于一般的网格来说是不正确的。因此，对[2.x.46]的正确计算不仅要求我们为每一个单元计算相应的变换矩阵[2.x.47]，而且还要求我们在单元[2.x.48]上定义一组类似Legendre的正交函数，该单元可能有一个任意的和非常复杂的几何形状。尤其是第二部分，计算成本非常高。目前FESeries变换类的实现是依靠有一个恒定的Jacobian所带来的简化来提高性能，因此只对仿射映射产生正确的结果。除此之外，这种情况对本教程来说并不构成问题，因为我们只使用方形的单元。
* Eibner和Melenk[2.x.49]认为，当且仅当Legendre系数的绝对值随指数增加而呈指数衰减时，一个函数是解析的，即可以用幂级数表示[2.x.50]：[1.x.50]衰减率[2.x.51]可以解释为衡量该函数的平稳性。我们可以把它理解为对转换系数进行线性回归拟合的斜率：[1.x.51] 。
* 我们将对每个单元进行这种拟合[2.x.52]，以获得有限元近似的平滑度的局部估计。衰减率[2.x.53]将作为hp适应的决策指标。对于具有多项式程度[2.x.55]的单元[2.x.54]上的有限元，计算[2.x.56]的系数被证明是估计平滑度的合理选择。你可以在[2.x.57]中找到一个更详细的、与维度无关的描述。
* 以上所有内容已经在[2.x.58]类和[2.x.59]命名空间中实现。有了误差估计和平滑度指标，我们就剩下对单元格进行实际细化和粗化的标记。来自[2.x.60]和[2.x.61]命名空间的一些函数将在后面帮助我们完成这些工作。
*

*[1.x.52][1.x.53]


* 有限元矩阵通常是非常稀疏的。此外，hp-adaptive方法对应的矩阵每行的非零项数量变化很大。一些最先进的预处理程序，如[2.x.62]中使用的代数多重网格（AMG），在这些情况下表现很差。
* 因此，我们将依靠一个无矩阵的混合多网格预处理器。[2.x.63]已经证明了几何多网格方法与MatrixFree框架结合时的优越性。在hp-adaptive FEM上的应用需要一些额外的工作，因为一个单元的子女可能有不同的多项式度数。作为补救措施，我们首先对线性元素进行p松弛（类似于Mitchell[2.x.64]），然后以常规方式进行h松弛。在最粗的层次上，我们应用代数多网格解算器。p-multigrid、h-multigrid和AMG的结合使得该求解器成为一个混合多网格求解器。
* 我们将通过使用MGTransferGlobalCoarsening，在现有的全局粗化基础设施的帮助下，创建一个具有上述特殊要求的自定义混合多网格预处理器。
*

*[1.x.54][1.x.55]


* 对于椭圆方程，每个重入角通常都会调用奇点[2.x.65]。我们可以利用这种情况来测试我们的h-decision算法：在所有需要调整的单元上，我们倾向于在奇点附近采用精细的网格，而在其他地方则采用高的多项式程度。
* 作为在这些条件下要解决的最简单的椭圆问题，我们选择了L型域中的拉普拉斯方程，其重角在坐标系的原点。
* 为了能够确定实际误差，我们制造了一个有已知解的边界值问题。在上述领域中，拉普拉斯方程的解是，在极坐标中，[2.x.66] : [1.x.56] 。
* 另见[2.x.67]或[2.x.68] 。解决方案看起来如下。
* [2.x.69]
*


* [1.x.160][1.x.161][1.x.162] 。


*[1.x.163][1.x.164]


* deal.II库提供了多种策略来决定对单元的适应类型：要么调整网格分辨率，要么改变多项式程度。我们在本教程中只介绍了[1.x.165]策略，而[2.x.70]则展示了相同想法的[1.x.166]等值。
* 关于这些策略的概述，请参见[2.x.71]中的 "扩展的可能性 "一节，或相应的文档中的详细描述。
* 在那里，提到了另一个到目前为止还没有在任何教程中展示过的策略：基于[1.x.167]的策略。这个方法在并行分布式应用中的使用比其他方法更棘手，所以我们将强调与之相伴的挑战。我们需要有关细化标志的最终状态的信息，并且我们需要在细化的网格之间转移解决方案。对于前者，我们需要将[2.x.72]函数附加到[2.x.73]信号上，使其被称为[1.x.168]的[2.x.74]函数。在这个阶段，所有的精炼标志和未来的FE指数都被最终设定，并且可以对错误进行可靠的预测。预测的误差需要借助于[2.x.75]在精炼网格之间进行转移。
* 试着在本教程中实施这些策略之一，并观察结果的微妙变化。你会注意到，所有的策略都能识别出重心角附近的奇异点，并在这些区域进行[2.x.76]精化，而在体域中则倾向于[2.x.77]精化。这些策略的详细比较见[2.x.78]。
*

*[1.x.169][1.x.170]


* 本教程只关注无矩阵策略。然而，所有的hp-adaptivealgorithms在并行分布式环境中也可以使用基于矩阵的方法。
* 要创建一个系统矩阵，你可以使用[2.x.79]函数，或者使用类似于[2.x.81]的[2.x.80]函数，然后你可以像往常一样将系统矩阵传递给求解器。
* 你可以对基于矩阵和无矩阵实现的结果进行计时，量化加速，并说服自己哪个变量更快。
*

*[1.x.171][1.x.172]


* 为了简单起见，我们将自己限制在单一类型的粗网格求解器（带AMG的CG）、平滑器（带point Jacobi预处理的Chebyshev平滑器）以及多网格算法中的几何粗化方案（全局粗化）。请自由尝试其他方法，研究它们的性能和稳健性。
*

* [1.x.173][1.x.174] [2.x.82] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-76_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20]

* [2.x.2]
* [1.x.21]
* [1.x.22][1.x.23][1.x.24] 。


* 这个教程程序解决了流体动力学的欧拉方程，使用了一个显式时间积分器和无矩阵框架应用于空间的高阶非连续Galerkin离散化。这里使用的数值方法与[2.x.3]中使用的相同，但是，我们利用了不同的高级无矩阵技术，以达到更高的吞吐量。
* 本教程的两个主要特点是。
*
* - 使用MPI-3.0的共享内存特性和
*
* 使用以单元为中心的循环，它只允许向全局向量写入一次，因此，是使用共享内存的理想选择。
* 我们在本教程中讨论的其他主题是模板参数VectorizedArrayType的用法和好处（而不是简单地使用VectorizedArray<Number>），以及向MatrixFree循环传递lambdas的可能性。
* 关于数字的细节，我们可以参考 [2.x.4] 的文档。我们在这里只集中讨论主要的区别。
* [1.x.25][1.x.26] 。
*

*[1.x.27][1.x.28]


* 存在许多基于线程的共享内存库，如TBB、OpenMP或TaskFlow。将这些库集成到现有的MPI程序中，就可以使用共享内存。然而，这些库对程序员来说有一定的开销，因为所有可并行的代码部分都要根据所使用的库进行查找和转换，包括当第三方数值库，如迭代求解器包，只依赖MPI时的困难。
* 考虑到一个纯粹的MPI并行化的有限元应用，我们可以发现，使用共享内存的主要时间和内存优势来自于访问同一计算节点上的进程所拥有的解向量的部分，而不需要进行明确的复制和缓冲。
*[1.x.29][1.x.30]
*

* 一个新的MPI通信器[2.x.5]，由通信器[2.x.6]的进程组成，可以访问相同的共享内存，可以通过以下方式创建。
* [1.x.31]
*
* 下面的代码片断显示了简化的共享内存的分配程序，包括值类型[2.x.7]和大小[2.x.8]，以及如何查询属于同一共享内存域的进程的数据指针。
* [1.x.32]
*
* 一旦不再需要数据，窗口就必须被释放，这也会释放本地拥有的数据。
* [1.x.33]
*
* [1.x.34][1.x.35].
*

* 上一节提到的命令被整合到了[2.x.9]中，如果为reinit()-functions提供了一个可选的（第二）communicator，就可以用来分配共享内存。
* 例如，可以用一个分区器（包含全局通信器）和一个子通信器（包含同一计算节点上的进程）来设置一个向量。
* [1.x.36]

*本地拥有的值和幽灵值可以像往常一样被处理。然而，现在用户也可以读取共享内存邻居的值 viathe函数。
* [1.x.37]
*
* [1.x.38][1.x.39] 。
*

* 虽然[2.x.10]提供了分配共享内存的选项，并以协调的方式访问相邻进程的共享内存的值，但它实际上并没有利用共享内存本身的使用优势。
* 然而，MatrixFree基础设施做到了。
*
* - 一方面，在无矩阵循环[2.x.11][2.x.12]和[2.x.13]中，只有需要更新的幽灵值[2.x.14]被更新。来自共享内存邻居的幽灵值可以被直接访问，这使得缓冲，即把值复制到矢量的幽灵区域可能是多余的。  为了处理可能的竞赛条件，在MatrixFree中进行了必要的同步。在数值必须被缓冲的情况下，数值被直接从邻近的共享内存进程中复制，绕过了基于 [2.x.16] 和 [2.x.17] 的更昂贵的MPI操作。
*
* - 另一方面，像FEEvaluation和FEFaceEvaluation这样的类可以直接从共享内存中读取，所以在某些情况下，缓冲值确实是没有必要。
* 为了能够使用MatrixFree的共享内存能力，MatrixFree必须通过提供用户创建的子通信器进行适当的配置。
* [1.x.40]
*
*

*[1.x.41][1.x.42]


*[1.x.43][1.x.44]


* "以面为中心的循环"（简称FCL）访问单元和面（内部和边界的）的独立的循环。因此，每个实体只被访问一次，单元之间的通量只被评估一次。如何在[2.x.18]的帮助下，通过提供三个函数（一个用于单元积分，一个用于内部，一个用于边界面）来执行以面为中心的循环已经在[2.x.19]和[2.x.20]中提出。
* "以单元为中心的循环"（简称CCL或ECL（代表以元素为中心的循环），与此相反，处理一个单元并直接连续处理它的所有面（即访问所有面两次）。在文献[2.x.21]中，它们的好处已经很明显了，尽管这种循环意味着通量必须被计算两次（在一个内部面的每一侧）。CCL有两个主要优点。
*
* 一方面，在CCL的情况下，解向量中的条目正好被写回主内存一次，而在FCL的情况下，尽管单元和面的循环被高速缓存有效调度，但由于高速缓存容量的缺失，至少有一次。
*
* 另一方面，由于解向量的每个条目被精确地访问一次，在CCL的情况下，访问解向量时不需要线程之间的同步。在写入目标向量的过程中不存在竞赛条件，这使得CCL特别适合于共享内存并行化。
* 人们还应该注意到，尽管在CCL的情况下通量被计算了两次，但这并不自动转化为计算的加倍，因为已经插值到单元正交点的数值可以通过简单的一维插值插值到一个面。
*[1.x.45][1.x.46]
*

* 对于以单元为中心的循环实现，可以使用函数[2.x.22]，用户可以向其传递一个应该在每个单元执行的函数。
* 为了得到一个适当的函数，可以在[2.x.23]中传递，原则上可以转换/合并以下三个函数，它们可以被传递给[2.x.24]。
* [1.x.47]

* 以下列方式。
* [1.x.48]

* 应该注意的是，FEFaceEvaluation现在是用两个数字初始化的，即单元格号和本地面孔号。给出的例子只是强调了如何将以面为中心的循环转化为以单元为中心的循环，而且绝非高效，因为数据要从全局向量中多次读写，而且计算也要经常进行。下面，我们将讨论针对这些问题的高级技术。
* 为了能够使用[2.x.25]，必须启用[2.x.26]的下列标志。
* [1.x.49]
*
* 特别是，这些标志可以使内部数据结构为所有的单元面设置。
* 目前，deal.II中以单元为中心的循环只适用于均匀细化的网格，如果不应用约束条件（这是DG通常使用的标准情况）。
*

*[1.x.50][1.x.51]


* 上面的例子已经使用了lambdas，它被提供了无矩阵循环。下面的简短例子介绍了如何在使用类和指向其方法之一的指针的版本和使用lambdas的变量之间转换函数。
* 在下面的代码中，一个类和一个指向其方法之一的指针，应该被解释为单元格积分，被传递给[2.x.27]。
* [1.x.52]
*
* [1.x.53]
*
* 然而，也可以通过lambda函数传递匿名函数，其结果是一样的。
* [1.x.54]
*
* [1.x.55][1.x.56].
*

* VectorizedArray<Number>类是实现deal.II中无矩阵算法的高节点性能的关键组件。它是一个围绕Number类型的短向量[2.x.28]条目的封装类，并通过内在函数将算术操作映射到适当的单指令/多数据（SIMD）概念。矢量的长度可以通过[2.x.29]查询，其基础数字类型可以通过[2.x.30]查询。
* 在默认情况下（[2.x.31]），向量长度是在库的编译时设置的，以匹配给定的处理器架构所支持的最高值。然而，也可以指定第二个可选的模板参数作为[2.x.32]，明确控制特定指令集能力内的向量长度。下表列出了支持的向量长度的完整列表。
* [2.x.33]
* 这允许用户选择矢量长度/ISA，因此，在无矩阵运算器评估中一次处理的单元数，可能会减少对缓存的压力，这对于非常高的度数（和尺寸）来说是一个严重的问题。
* 一个可能的进一步原因是减少填充线的数量，以简化调试：而不是不得不看，例如8个单元，一个人可以专注于一个单元。
* VectorizedArray的接口也可以用任何有匹配接口的类型来代替。具体来说，这为deal.II准备了[2.x.34]类，它计划成为C++23标准的一部分。下表比较了deal.II特定的SIMD类和相应的C++23类。
*

* [2.x.35]


* [1.x.57] [1.x.58]。
* [1.x.59][1.x.60] 。
*

*
* 包括与[2.x.36]中相同的内容。
*


* [1.x.61]
*
* 一个新的包括，根据其边界ID对单元格进行分类。
*


* [1.x.62]
*
* 与 [2.x.37] 中的输入参数相同。
*


* [1.x.63]
*
* 这个参数指定了共享内存组的大小。目前，只有值1和[2.x.38]是可能的，这导致了内存功能可以被关闭或所有访问同一共享内存域的进程被分组。
*


* [1.x.64]
*
* 这里，数据结构的类型被选择为矢量化。在默认情况下，使用VectorizedArray<Number>，也就是说，在给定的硬件上使用最高的指令集架构扩展，有最大数量的向量通道。然而，人们可能会减少填充通道的数量，例如，通过编写[2.x.39]，只处理4个单元。
*


* [1.x.65]

* 以下参数没有改变。



* [1.x.66]
*
* 指定对性能研究有用的最大时间步骤数。
*


* [1.x.67]
*
* 从[2.x.40]复制的Runge-Kutta相关函数，并稍作修改，目的是尽量减少全局矢量访问。
*


* [1.x.68]
*
* 来自[2.x.41]的欧拉特定效用函数。
*


* [1.x.69]
*
* 来自 [2.x.42] 的通用实用函数。
*


* [1.x.70]
*
* [1.x.71] [1.x.72]。


*
* 来自[2.x.43]的欧拉算子，有一些变化，详见下文。
*


* [1.x.73]
*
* 包含子通信器的SubCommunicatorWrapper实例，我们需要将其传递给[2.x.44]，以便能够利用MPI-3.0的共享内存功能。
*


* [1.x.74]
*
* 新的构造函数，可以创建一个子通信器。用户可以通过全局参数group_size指定子通信器的大小。如果大小被设置为
*
- ，一个共享内存域的所有MPI进程将被合并为一个组。指定的大小对于MatrixFree的共享内存能力的好处是决定性的，因此，设置为[2.x.45]是一个合理的选择。通过设置，大小为[2.x.46]，用户明确地禁用了MatrixFree的MPI-3.0共享内存功能，而完全依赖MPI-2.0功能，如[2.x.47]和[2.x.48] 。
*


* [1.x.75]
*
* 新的析构器，负责释放子通信器。
*


* [1.x.76]
*
* 修改了reinit()函数，以设置MatrixFree中的内部数据结构，使其能被以单元为中心的循环所使用，并使用MPI-3.0的共享内存功能。
*


* [1.x.77]
*
* 对单元格进行分类，使所有的车道在每个面上都有相同的边界ID。这在严格意义上是不必要的，然而，允许在[2.x.49]中写出更简单的代码，而不需要屏蔽，因为它保证所有分组的单元格（在一个VectorizedArray中）必须对面也执行完全相同的操作。
*


* [1.x.78]
*
* 通过提供子通信器在MatrixFree中启用MPI-3.0共享内存功能。
*


* [1.x.79]
*
* 下面的函数做一个Runge--Kutta更新的整个阶段，并且是
*


*
* - 与稍加修改的设置一起
*
* - 本教程的核心与[2.x.50]相比。   
* 与[2.x.51]相比，我们不是依次执行平流步骤（使用[2.x.52]和反质量矩阵步骤（使用[2.x.53]），而是在[2.x.54]中一次性评估所有内容。 这个函数期望在每个本地拥有的（宏）单元上执行一个单一的函数作为参数，这样我们就需要在该单元的所有面上循环，自行执行需要的积分步骤。   
* 下面的函数在很大程度上包含了[2.x.55]中的下列函数的拷贝，所以这里跳过了与弱形式的评估有关的评论。
*



* - [2.x.56]




* - [2.x.57]




* - [2.x.58]




* - [2.x.59]



* [1.x.80]
*
* 通过调用[2.x.60]并提供一个包含单元、面和边界面积分效果的lambda来运行一个以单元为中心的循环。
*


* [1.x.81]
*
* 在所有单元格批次上循环。
*


* [1.x.82]
*
*从全局矢量中读取数值并计算正交点的数值。
*


* [1.x.83]
*
* 缓冲正交点的计算值，因为这些值在下一步被[2.x.61]所覆盖，然而，在后面的面积分中需要。
*


* [1.x.84]
*
* 在单元格正交点应用单元格积分。也可参见来自 [2.x.63] 的函数 [2.x.62] 。
*


* [1.x.85]
*
* 用正交点中的测试函数的梯度进行测试。我们跳过插值回到元素的支持点，因为我们首先收集单元正交点的所有贡献，只在最后一步进行插值。
*


* [1.x.86]
*
*在当前单元格的所有面上进行循环。
*


* [1.x.87]
*
* 确定当前面的边界ID。由于我们设置MatrixFree的方式是所有填充的车道都保证有相同的边界ID，我们可以选择第一个车道的边界ID。
*


* [1.x.88]
*
* 通过简单的一维插值，将单元格正交点的数值插到当前面的正交点上。
*


* [1.x.89]
*
* 检查该面是内部面还是边界面，并根据这一信息选择不同的编码路径。
*


* [1.x.90]
*
* 过程和内部面。以下几行代码是对[2.x.65]中[2.x.64]函数的复制。
*


* [1.x.91]
*
* 处理一个边界面。下面这几行代码是对[2.x.67]中[2.x.66]函数的复制。
*


* [1.x.92]
*
*通过正交评估与单元有关的局部积分，并通过简单的一维插值加入到单元贡献中。
*


* [1.x.93]
*
* 在单元格的正交点上应用反质量矩阵。也可参见来自 [2.x.69] 的函数 [2.x.68] 。
*


* [1.x.94]
*
* 将数值从配位空间转换到原始的高斯-洛巴托空间。



* [1.x.95]
*
*执行Runge-Kutta更新并将结果写回全局向量。
*


* [1.x.96]

* 从这里开始，[2.x.70]的代码没有改变。
*


* [1.x.97]
*[1.x.98][1.x.99]


* 在有40个进程的机器上以默认设置运行该程序，产生以下输出。
* [1.x.100]
*
* 以及以下视觉输出。
* [2.x.71]
* 作为参考，使用FCL的[2.x.72]的结果是。
* [1.x.101]
*
* 通过本教程中的修改，我们能够使Runge-Kutta阶段的速度提高27%。
* [1.x.102][1.x.103]。
*

* 这些算法很容易扩展到更高的维度：高维[1.x.104]是hyper.deal库的一部分。以单元为中心的循环扩展到局部细化的网格是比较复杂的。
*[1.x.105][1.x.106]。
*

* 本教程中提出的求解器也可以通过增加粘性项扩展到可压缩的Navier-Stokes方程，这也是[2.x.73]中建议的。为了尽量保持这里获得的性能，尽管椭圆项的额外成本，例如通过内部惩罚方法，该教程建议将基础从FE_DGQ切换到FE_DGQHermite，就像在[2.x.74]教程程序中一样。这种转换的理由是，在FE_DGQ的情况下，需要相邻单元的所有数值（即[2.x.75]层），而在FE_DGQHermite的情况下，只需要2层，这使得后者明显更适合于更高的程度。额外的层一方面要在通量计算过程中从主内存加载，另一方面要进行通信。使用本教程中介绍的共享内存能力，第二点可以在单个计算节点上消除，或者在混合环境下减少其影响。
*[1.x.107][1.x.108]
*

* 以单元为中心的循环可用于创建块状高斯-赛德尔预处理，在一个过程中是乘法的，在多个过程中是加法的。在通量计算过程中，这种类型的预处理程序与雅可比类型的预处理程序相反，使用的是来自相邻单元的最新值。下面的伪代码直观地说明了这一目标的实现方式。
* [1.x.109]
*
* 为此，我们可以利用MatrixFree的单元数据向量功能和VectorizedArray的基于范围的迭代功能。
* 请注意，在给定的例子中，我们处理了[2.x.76]个块，因为每个车道对应着一个块。如果一个矢量寄存器处理的所有块都被更新了，我们就认为块被更新了。在笛卡尔网格的情况下，这是一个合理的方法，然而，对于一般的非结构化网格，这种保守的方法可能会导致预处理程序的效率下降。通过明确减少[2.x.77]使用的通道数量来减少并行处理的单元可能会提高预处理器的质量，但代价是每次迭代可能会更昂贵。这种两难境地使我们看到了进一步的 "扩展可能性"：元素内的矢量化。
*

* [1.x.110][1.x.111] [2.x.78] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-77_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18]
* [2.x.2]
* [1.x.19] [2.x.3]
* [1.x.20][1.x.21][1.x.22] 。


* [2.x.4]程序解决了以下非线性方程描述的最小表面问题。
* [1.x.23]
* [2.x.5]使用的是牛顿方法，牛顿方法的工作原理是反复求解线性化*问题的更新[2.x.6] 。
*
* -称为 "搜索方向"
*
* -，计算 "步长"[2.x.7]，然后将它们结合起来，通过以下方式计算出解决方案的新猜想
* [1.x.24]
*
* 在[2.x.8]的讨论过程中，我们发现计算步长是很困难的，所以就用简单的选择来解决。总是选择 [2.x.9] 。这当然是没有效率的：我们知道，如果我们最终能够选择[2.x.10]，我们才能实现牛顿的二次收敛率，尽管我们可能不得不在最初的几个迭代中选择较小的步长，因为我们离得太远，无法使用这么长的步长。
* 因此，本程序的目标之一就是要解决这个问题。由于行搜索算法的实现并不完全是微不足道的，所以我们还是要做我们应该做的事情。从一个外部库中导入复杂的功能。为此，我们将利用deal.II与大型非线性求解器包之一的接口，即[SUNDIALS](https://computing.llnl.gov/projects/sundials)套件的[KINSOL](https://computing.llnl.gov/projects/sundials/kinsol)子包。SUNDIALS的核心是解决复杂的常微分方程（ODE）和微分代数方程（DAE）的软件包，deal.II接口通过SUNDIALS命名空间中的类来实现。特别是[2.x.11]和[2.x.12]类。但是，由于这是用隐式方法解决ODE和DAE的一个重要步骤，%SUNDIALS也有一个叫做KINSOL的非线性问题求解器，deal.II有一个以[2.x.13]类形式出现的接口。这就是我们要用来解决的问题。
* 但%SUNDIALS并不只是一个方便的方法，我们可以避免编写直线搜索算法。一般来说，非线性问题的解决是相当昂贵的，人们通常希望尽可能地节省计算时间。一个可以实现这个目标的方法是如下。[2.x.14]中的算法将问题离散化，然后在每次迭代中求解一个线性系统，其形式为
* [1.x.25]
* 其中[2.x.15]是使用当前节点值矢量[2.x.16]计算的残差矢量，[2.x.17]是其导数（称为 "雅各布"），而[2.x.18]是对应于上述函数[2.x.19]的更新矢量。[2.x.20]的构造已在[2.x.21]中作了详尽的讨论，在每次牛顿迭代中解决线性系统的方法也是如此。因此，让我们关注一下非线性求解过程的另一个方面。计算[2.x.22]是昂贵的，而组装矩阵[2.x.23]更是如此。我们是否真的需要在每次迭代中都这样做？事实证明，在许多应用中，这实际上是没有必要的。即使我们用近似值[2.x.25]代替[2.x.24]，这些方法通常也会收敛，并且解决了
* [1.x.26]
*代替，然后更新
* [1.x.27]
* 这可能需要多一两个迭代，因为我们的更新[2.x.26]没有[2.x.27]那么好，但它可能仍然是一个胜利，因为我们不必经常组装[2.x.28]。
* 对于[2.x.30]，我们想要什么样的近似[2.x.29]？理论上说，由于[2.x.31]收敛于精确解[2.x.32]，我们需要确保[2.x.33]需要收敛于[2.x.34]。特别是，由于[2.x.35]，一个有效的选择是[2.x.36]。但是，每一次，比如说，第五次迭代选择[2.x.38]，对于其他迭代，我们选择[2.x.39]等于最后计算的[2.x.40]。这就是我们要做的：我们将重新使用前一次迭代中的[2.x.41]，这可能又是我们在之前的迭代中使用的，[2.x.42]。
* 如果在求解[2.x.43]的线性系统时，我们不只是要组合一个矩阵，还要计算一个好的预处理程序，那么这个方案就变得更加有趣了。例如，如果我们通过SparseDirectUMFPACK类使用稀疏的LU分解，或者使用ageometric或代数多重网格。在这些情况下，我们也不必更新预处理程序，因为预处理程序的计算时间可能与最初组装矩阵的时间差不多，甚至更长。事实上，在这种思维模式下，我们也许应该考虑使用我们能想到的最好的*先决条件器，尽管它们的构建通常相当昂贵。我们希望通过将其应用于不止一个线性求解，来摊销计算该预处理程序的成本。
* 当然，最大的问题是。我们根据什么标准来决定我们是否可以摆脱基于先前计算的雅各布矩阵[2.x.45]的近似[2.x.46]步，或者我们是否需要
*
* - 至少在这次迭代中
*
* 这和直线搜索的问题一样，需要大量的代码来监控整个算法的收敛性。我们可以*自己实现这些东西，但我们也许不应该*。KINSOL已经为我们做了这些。它将告诉我们的代码何时要 "更新 "雅各布矩阵。
* 如果我们使用迭代求解器而不是上面提到的稀疏直接求解器，还有一个考虑。在求解更新[2.x.50]时，不仅可以用一些近似值[2.x.49]来代替[2.x.48]，而且还可以问是否有必要求解线性系统
* [1.x.28]
*高精确度。其思路是这样的。虽然我们目前的解决方案[2.x.51]离[2.x.52]还很远，但我们为什么要特别精确地解决这个线性系统？更新后的[2.x.53]很可能仍然离精确的解决方案很远，那么为什么要花很多时间来解决这个线性系统的精确性？这就是 "Eisenstat-Walker技巧"[2.x.54]等算法所依据的思维方式，在该算法中，人们被赋予一个公差，在迭代[2.x.55]中必须解决上述线性系统，这个公差取决于整个非线性求解器的进展。像以前一样，人们可以尝试自己实现这个，但是KINSOL已经为我们提供了这种信息
*
* 尽管我们不会在这个程序中使用它，因为我们使用的是直接求解器，不需要求解器的容忍度，只需要精确求解线性系统即可。
* 作为对所有这些考虑因素的总结，我们可以说以下几点。没有必要重新发明轮子。就像deal.II提供了大量的有限元功能一样，%SUNDIALS'KINSOL软件包提供了大量的非线性求解器功能，我们最好使用它。
*

*[1.x.29][1.x.30]


* KINSOL，像许多类似的软件包一样，以一种相当抽象的方式工作。它的核心是看到一个非线性问题，其形式为
* [1.x.31]
* 并构造一个迭代序列[2.x.56]，一般来说，这些迭代序列是与函数[2.x.57]返回的向量相同的长度。要做到这一点，它需要从用户那里得到一些东西。
*
* - 一种将给定的向量调整到正确大小的方法。
*
* - 对于一个给定的向量[2.x.58]，评估函数[2.x.59]的一种方法。这个函数通常被称为 "剩余 "操作，因为目标当然是找到一个点[2.x.60]，对于这个点[2.x.61]；如果[2.x.62]返回一个非零向量，那么这就是[1.x.32]（即 "剩余"，或任何 "剩余"）。做到这一点的函数本质上与[2.x.63]中右侧向量的计算相同，但有一个重要区别。  在那里，右手边表示残差的负数*，所以我们必须换一个符号。
*
* - 计算矩阵[2.x.64]的方法，如果这在当前迭代中是必要的，可能还有一个预处理程序或其他数据结构（例如，通过SparseDirectUMFPACK进行稀疏分解，如果我们选择用它来解决一个线性系统）。这个操作通常被称为 "设置 "操作。
*
* - 用最后计算的任何矩阵[2.x.66]来解决线性系统[2.x.65]的方法。这个操作一般会被称为 "求解 "操作。
* 所有这些操作都需要由[2.x.67]对象提供给KINSOL，这些对象接受适当的参数集，通常返回一个整数，表示成功（返回值为零）或失败（返回值为非零）。具体来说，我们要访问的对象是[2.x.68] [2.x.69] [2.x.70] 和 [2.x.71] 成员变量。在我们的实现中，我们将使用[lambda functions](https://en.cppreference.com/w/cpp/language/lambda)来实现这些 "回调"，反过来可以调用成员函数；KINSOL将在其内部算法认为有用时调用这些回调。
*

*[1.x.33][1.x.34]


* 本教程程序的大部分代码与[2.x.72]一样，我们将不对其进行详细评论。实际上只有一个方面需要注意，即如何在一方面给定一个向量[2.x.74]，另一方面给定一个向量[2.x.76]，计算[2.x.75]。乍一看，这似乎很简单：我们只需使用`assemble_system()`函数，在一种情况下扔掉所有处理矩阵的代码，在另一种情况下扔掉处理右手边的向量的代码。就这样。问题解决了。
* 但这并不十分简单。这是因为如果我们有非零的Dirichlet边界值，这两者就不是独立的，就像我们在这里一样。我们要解决的线性系统包含内部自由度和边界自由度，当从那些真正 "自由 "的自由度中消除这些自由度时，例如使用[2.x.77]，我们需要在组装右手边的向量时知道矩阵。
* 当然，这完全违背了原意。如果我们有能力的话，可以将矩阵组装起来。
如果我们可以不知道矩阵的话，就不要去组装。我们解决这个问题的方法如下。
*
* - 我们将解向量的起始猜测，[2.x.78]，设定为边界自由度已经有了正确的值。
*
* 这意味着所有的更新都可以对这些自由度进行零更新，我们可以建立残差向量[2.x.79]和雅各布矩阵[2.x.80]，对应于线性系统的解在这些向量分量中是零。对于这种特殊情况，矩阵和右手边向量的装配是独立的，可以分解成不同的函数。
* 这里有一个假设，即每当KINSOL要求一个带有（近似）Jacobian的线解器时，这将是为了更新[2.x.81]（其边界值为零），其倍数将被添加到解决方案（其已经具有右边界值）。  这可能不是真的，如果是的话，我们可能要重新考虑我们的方法。尽管如此，事实证明，在实践中，这正是KINSOL在使用牛顿方法时的做法，因此我们的方法是成功的。
*

* [1.x.35] [1.x.36]。
* [1.x.37][1.x.38] 。
*


* 这个程序开始时和其他大多数程序一样，有众所周知的包含文件。与[2.x.82]程序相比，我们在这里所做的大部分都是复制的，唯一不同的是包括头文件，我们从中导入了SparseDirectUMFPACK类和KINSOL的实际接口。
*


*


* [1.x.39]
*
* [1.x.40] [1.x.41]。


*
* 同样地，这个程序的主类基本上是 [2.x.83] 中的一个副本。然而，该类确实将雅各布（系统）矩阵的计算（以及使用直接求解器对其进行因式分解）和残差的计算分成了不同的函数，原因已在介绍中概述。出于同样的原因，该类也有一个指向雅各布矩阵因式分解的指针，该指针在我们每次更新雅各布矩阵时被重置。   
*（如果你想知道为什么程序对雅各布矩阵使用一个直接对象，而对因式分解使用一个指针。每次KINSOL要求更新雅各布矩阵时，我们可以简单地写`jacobian_matrix=0;`将其重置为一个空矩阵，然后我们可以再次填充。另一方面，SparseDirectUMFPACK类没有办法扔掉它的内容或者用新的因式分解来替换它，所以我们使用一个指针。我们只是扔掉整个对象，并在我们有新的雅各布矩阵需要分解时创建一个新的对象)。   
* 最后，该类有一个定时器变量，我们将用它来评估程序的不同部分需要多长时间，这样我们就可以评估KINSOL不重建矩阵及其因式分解的倾向是否有意义。我们将在下面的 "结果 "部分讨论这个问题。
*


* [1.x.42]
*
* [1.x.43] [1.x.44]。


*
* 实现边界值的类是对 [2.x.84] 的复制。
*


* [1.x.45]
*
* [1.x.46] [1.x.47]。



* [1.x.48] [1.x.49]。


*
* 以下几个函数也基本上是复制了[2.x.85]已经做的事情，因此没有什么可讨论的。
*


* [1.x.50]
*
* [1.x.51] [1.x.52]。


*
* 下面的函数负责对雅各布矩阵进行组装和因子化。该函数的前半部分实质上是[2.x.86]的`assemble_system()`函数，只是它没有处理同时形成右手边的向量（即残差），因为我们并不总是要同时做这些操作。   
* 我们把整个装配功能放在一个由大括号围起来的代码块中，这样我们就可以用一个[2.x.87]的变量来衡量在这个代码块中花费了多少时间，不包括在这个函数中发生的匹配的闭合括号`}`之后的一切。
*


* [1.x.53]
*
* 该函数的后半部分是对计算出的矩阵进行因子化。要做到这一点，我们首先创建一个新的SparseDirectUMFPACK对象，并将其分配给成员变量`jacobian_matrix_factorization'，同时销毁该指针之前指向的任何对象（如果有）。然后我们告诉该对象对雅各布系数进行分解。     
* 如上所述，我们把这段代码放在大括号里，用一个计时器来评估这部分程序所需的时间。     
*（严格来说，我们在这里完成后实际上已经不需要矩阵了，可以把矩阵对象扔掉。一个旨在提高内存效率的代码会这样做，并且只在这个函数中创建矩阵对象，而不是作为周围类的成员变量。我们在这里省略了这一步，因为使用与以前的教程程序相同的编码风格可以培养对通用风格的熟悉，并有助于使这些教程程序更容易阅读)。
*


* [1.x.54]
*
* [1.x.55] [1.x.56]。


*
* `assemble_system()`在[2.x.88]中用来做的第二部分是计算残差向量，也就是牛顿线性系统的右手向量。我们把这一点从前面的函数中分解出来，但如果你理解了[2.x.89]中`assemble_system()`的作用，下面的函数就会很容易理解。然而，重要的是，我们需要计算的残差不是围绕当前解向量线性化的，而是我们从KINSOL得到的任何东西。这对于诸如直线搜索的操作是必要的，我们想知道不同的[2.x.91]值的残差[2.x.90]是多少；在这些情况下，KINSOL只是给我们函数[2.x.92]的参数，然后我们在这一点上计算出残差[2.x.93]。   
* 该函数在最后打印出如此计算的残差的规范，作为我们跟踪程序进展的一种方式。
*


* [1.x.57]
*
* [1.x.58] [1.x.59]。


*
* 接下来是实现用雅各布矩阵解线性系统的函数。由于我们在建立矩阵时已经对矩阵进行了因式分解，所以解决一个线性系统的方法就是将逆矩阵应用于给定的右手边向量。这就是我们在这里使用的[2.x.94]函数的作用。在这之后，我们必须确保我们也能解决解向量中悬空节点的值，这就是使用[2.x.95]完成的。
* 该函数需要一个额外的，但未使用的参数`tolerance`，表示我们必须解决线性系统的精确程度。这个参数的含义在介绍中结合 "Eisenstat Walker技巧 "进行了讨论，但是由于我们使用的是直接解法而不是迭代解法，所以我们并没有利用这个机会来解决线性系统的不精确性。
*


* [1.x.60]
*
* [1.x.61] [1.x.62]。


*
* 以下三个函数又是[2.x.96]中的简单拷贝。
*


* [1.x.63]
*
* [1.x.64] [1.x.65]。


*
* 在这个程序中，唯一真正*有趣的函数是驱动整个算法的函数，即从一个粗略的网格开始，做一些网格细化循环，并在每个网格上使用KINSOL来寻找我们从这个网格上离散化得到的非线性代数方程的解。上面的`refine_mesh()`函数可以确保一个网格上的解被用作下一个网格的起始猜测。我们还使用一个TimerOutput对象来测量每个网格上的每一次操作所花费的时间，并在每个周期开始时重置该计时器。   
* 正如在介绍中所讨论的，没有必要特别精确地解决粗略网格上的问题，因为这些问题只会作为下一个网格的起始猜测来解决。因此，我们将对[2.x.98]个网格细化周期使用[2.x.97]的目标公差。   
* 所有这些都被编码在这个函数的第一部分。
*


* [1.x.66]
*
* 这就是有趣的开始。在顶部，我们创建了KINSOL求解器对象，并给它输入了一个对象，该对象编码了一些额外的细节（其中我们只改变了我们想要达到的非线性容限；但你可能想看看[2.x.99]类有哪些其他成员，并与它们一起玩）。
*


* [1.x.67]

* 然后我们要描述在介绍中已经提到的操作。从本质上讲，我们必须教KINSOL如何(i)将一个向量调整到正确的大小，(ii)计算残差向量，(iii)计算雅各布矩阵（期间我们还计算其因式分解），以及(iv)用雅各布矩阵解线性系统。           
* 所有这四项操作都由[2.x.100]类的成员变量表示，这些成员变量的类型是[2.x.101]，也就是说，它们是我们可以分配给一个函数的指针的对象，或者像我们在这里做的那样，一个 "lambda函数"，它接受相应的参数并返回相应的信息。按照惯例，KINSOL希望做一些不重要的事情的函数返回一个整数，其中0表示成功。事实证明，我们只用25行代码就可以完成所有这些工作。           
*（如果你不熟悉什么是 "lambda函数"，可以看看[2.x.102]或关于这个主题的[wikipedia页面]（https://en.wikipedia.org/wiki/Anonymous_function）。lambda函数的概念是，人们想用一组参数来定义一个函数，但(i)不使它成为一个命名的函数，因为通常情况下，该函数只在一个地方使用，似乎没有必要给它一个全局名称；(ii)该函数可以访问存在于定义它的地方的一些变量，包括成员变量。lambda函数的语法很笨拙，但最终还是相当有用的）。)           
* 在代码块的最后，我们告诉KINSOL去工作，解决我们的问题。从'residual'、'setup_jacobian'和'solve_jacobian_system'函数中调用的成员函数将向屏幕打印输出，使我们能够跟踪程序的进展。
*


* [1.x.68]
*
* 剩下的就只是内务整理了。将数据写到一个文件中，以便进行可视化，并显示收集到的时间摘要，以便我们可以解释每个操作花了多长时间，执行的频率如何，等等。
*


* [1.x.69]
*[1.x.70][1.x.71]


* 当运行该程序时，你得到的输出看起来像这样。
* [1.x.72]
*
* 这应该如何解释，最容易解释的是看第一张网的输出的前几行。
* [1.x.73]
* 发生的情况是这样的。
*
* - 在第一次残差计算中，KINSOL计算残差以查看是否已经达到了所需的公差。答案是否定的，所以它要求用户程序计算雅各布矩阵（然后该函数还通过SparseDirectUMFPACK对矩阵进行因子化）。
*
* - KINSOL然后指示我们用这个矩阵和之前计算的残差向量来解决一个形式为[2.x.103]的线性系统。
*
* - 然后是确定我们要在这个方向上走多远，也就是做线搜索。为此，KINSOL要求我们计算不同步长的残差向量 [2.x.104] 。对于上面的第一步，它在尝试了两次后找到了一个可接受的[2.x.106]，第二次则需要尝试三次。
*
* - 在找到一个合适的更新解[2.x.107]之后，这个过程被重复，只是现在KINSOL对当前的雅各布矩阵很满意，没有指示我们重新建立矩阵和它的因式分解，而是要求我们用同一个矩阵解决一个线性系统。
* 该程序还在每个网格细化周期结束时将解写到VTU文件中，它看起来如下。[2.x.108]
*

* 本计划的主要收获信息如下。
*
* - 该方案与我们在[2.x.109]中计算的方案相同，也就是说，%SUNDIALS的KINSOL包的接口确实做了它们应该做的。这不应该是一个惊喜，但重要的一点是，我们不需要自己花时间去实现高级非线性求解器所依据的复杂算法。
*
* - KINSOL能够避免各种操作，如重建雅各布矩阵，而这实际上是没有必要的。将上述输出中的线性求解次数与我们重建雅各布矩阵和计算其因式分解的次数相比较，应该可以清楚地看到，这在计算时间上带来了非常可观的节省，而我们无需实现决定何时需要重建这些信息的错综复杂的算法。
*[1.x.74][1.x.75][1.x.76]
*

* 除了我们在这里考虑的小问题，稀疏直接求解器需要太多的时间和内存。
*
* - 我们需要一个迭代求解器，就像我们在许多其他程序中使用的那样。然而，在目前的情况下，构建一个昂贵的预处理程序（例如，一个几何或代数多重网格方法）的权衡是不同的。由于我们可以在许多线性求解中重新使用相同的矩阵，我们也可以对预处理程序做同样的处理，与我们只在单个线性求解中使用预处理程序相比，在构建一个好的预处理程序上投入更多的工作更容易被证明。
* 但迭代求解器也提供了其他机会。例如（正如介绍中简要讨论的那样），只要我们离实际的解还很远，我们可能不需要在早期的非线性迭代中寻求高精度的解（小公差）。这就是那里提到的Eisenstat-Walker技巧的基础。
* KINSOL提供了做线性解的函数，有一个需要达到的目标公差。我们在上面的程序中忽略了它，因为我们使用的直接求解器不需要公差，而是精确地求解线性系统（当然是四舍五入），但迭代求解器可以利用这种信息。
*
* - 而且，事实上，应该如此。
*

* [1.x.77][1.x.78] [2.x.110] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-78_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21]
*[1.x.22][1.x.23][1.x.24] 。


* 布莱克-斯科尔斯方程是一个偏微分方程，有点超出了普通方案。它描述了一个 "欧罗巴 "股票期权的公平价格是多少。在不做过多解释的情况下，股票 "期权 "是一份可以从银行购买的合同，它允许我，但不要求我，在未来的固定时间[2.x.3]以固定的价格[2.x.2]购买特定的股票。那么，作为这种期权的买方要回答的问题是 "我认为这样的合约值多少钱？"，或者作为卖方 "我需要为这个合约收取多少钱？"，这既是合约在时间[2.x.5]前的函数[2.x.4]，也是股票价格的函数[2.x.6]。费舍尔-布莱克和迈伦-斯科尔斯在假设股票价格表现出随机的价格波动，具有一定的 "波动性 "和背景的指数价格增长（可以认为是通货膨胀率，随着时间的推移，所有的货币都会贬值）的情况下，得出了这种期权的公平价格的偏微分方程[2.x.7]。由于他们的工作，布莱克和斯科尔斯在1997年获得了诺贝尔经济科学奖，这也是第一个处理有人获得诺贝尔奖的问题的教程程序[2.x.8] 。
* 方程如下。
* [1.x.25]
* 其中
* [1.x.26]
*
* 我们应该这样理解这个方程，它是一个时间依赖的偏微分方程，其中一个 "空间 "变量 [2.x.9]是股票的价格，[2.x.10]是如果当时的股票价格是[2.x.12]时，期权的价格。
*[1.x.27][1.x.28] 。


* 这个方程有一些奇怪的地方，值得在讨论其数值解法之前讨论一下。首先，"空间 "域[2.x.13]是无界的，因此[2.x.14]的值也可以是无界的。这是因为股票价格可能有一个实际的上限，但不是一个概念上的。边界条件[2.x.15]和[2.x.16]可以被解释为如下。如果股票价格（今天或在[2.x.18]时）是[2.x.19]，那么允许我以价格[2.x.17]购买股票的期权的价值是多少？人们期望它是[2.x.20]加上一些通货膨胀的调整，或者，如果我们真的真正考虑[2.x.21]的巨大价值，我们可以忽略[2.x.22]，得出无限边界的边界值应该是上面所说的[2.x.23]的形式。
* 在实践中，对于我们使用有限元方法来解决这个问题，我们将需要约束[2.x.24]。由于这个方程描述的是价格，而谈论价格为负值是没有意义的，我们将设定[2.x.25]的下限为0。然后，对于上限，我们将选择一个非常大的数字，一个[2.x.26]不太可能达到的数字。我们称之为[2.x.27].因此，[2.x.28] 。
* 第二，在截断域之后，我们需要问在这个现在的有限边界上我们应该设置什么边界值。为了解决这个问题，我们使用 "放-叫 "奇偶性 [2.x.29] 。一个 "拉动期权 "是指我们被允许，但不是必须，在未来的某个时间[2.x.31]以价格[2.x.30]向某人出售*股票。这说明
* [1.x.29]
* 其中[2.x.32]是看涨期权的价值，[2.x.33]是投入期权的价值。由于我们期望[2.x.34]与[2.x.35]一样，这意味着
* [1.x.30]
* 我们可以用这个作为我们的有限点[2.x.36]的合理边界条件。
* Block-Scholes方程的第二个复杂问题是，我们得到的是一个最终条件，而不是一个初始条件。这是因为我们知道期权在[2.x.37]时的价值：如果[2.x.38]时的股票价格是[2.x.39]，那么我们就没有动力使用我们的期权买入价格[2.x.40]，因为我们可以在公开市场上以更低的价格买入该股票。所以[2.x.41]为[2.x.42]。另一方面，如果在[2.x.43]时我们有[2.x.44]，那么我们可以通过期权以[2.x.45]的价格买入股票，并立即在市场上以[2.x.46]的价格再次卖出，给我带来[2.x.47]的利润。换句话说，[2.x.48]换取[2.x.49]。因此，我们只知道结束时的[2.x.50]的价值*，而不知道初始时的价值
*
* 事实上，找出当前时间（通常认为是[2.x.51]）的公平价格就是解决这些方程的目的。
* 这意味着这不是一个在时间上向前提出的方程，而实际上是在时间上向后*。因此，通过改变变量[2.x.52]来反向解决这个问题是有意义的，现在[2.x.53]表示打击时间[2.x.54]之前的时间。
* 通过所有这些，我们最终得到了以下问题。
* [1.x.31]
*
* 从概念上讲，这是一个变量[2.x.55]的平流-扩散-反应问题：有一个二阶导数的扩散项，一个一阶导数的平流项，以及一个零阶反应项。但是，由于问题中的平流项，我们将不得不小心地进行网格细化和时间步长的选择。还有一个问题是，扩散项是以非保守形式写成的，因此按部分积分并不明显。这将在下一节中讨论。
*[1.x.32][1.x.33]
*

* 我们将使用IMEX方法解决这个问题。特别是，我们首先用theta方法进行时间离散，随后将为平流和扩散项选择不同的theta值。
* [1.x.34]
* 这里，[2.x.58]是时间步长。鉴于这种时间离散化，我们可以通过与测试函数相乘，然后通过部分积分来进行空间离散化。因为在这个方程中，有一些有趣的细节，由于这个方程中的平流和非平流项，这个过程将被详细解释。
* 因此，我们首先用测试函数相乘，[2.x.59] 。
* [1.x.35]
*
*

* 像往常一样，（1）变成了[2.x.60]，（4）变成了[2.x.61]，其中[2.x.62]，我们不仅用[2.x.63]表示函数[2.x.64]，还用离散化后的节点值向量表示，这是一种自由。
* 有趣的部分来自于（2）和（3）。
*

* 对于（2），我们有。
* [1.x.36]
*
* 这里有两个积分，或多或少都是一样的，区别在于积分前面的系数略有不同，以及V的时间步骤不同。因此，考虑一般的积分，我们将用部分积分的方法来解决。
* [1.x.37]
*
* 因此，在加入常数并将[2.x.65]换成[2.x.66]（如适用）后，我们得出以下（2）的结果。
* [1.x.38]
* 但是，由于矩阵[2.x.67]涉及一个平流项，我们将选择[2.x.68]。
*
* --换句话说，我们使用显式欧拉方法来处理平流问题。相反，由于矩阵[2.x.69]涉及扩散项，我们将选择[2.x.70]在那里
*
* - 即我们用二阶Crank-Nicolson方法来处理扩散问题。
* 因此，我们得出以下结果。
* [1.x.39]
*
* 现在，要处理（3）。为此，我们将再次通过考虑上述的一般情况来进行。
* [1.x.40]

* 因此，在加入常数并将[2.x.71]换成[2.x.72]（如适用）后，我们对（3）得出如下结果。
* [1.x.41]
* 与之前一样，我们将用[2.x.73]表示矩阵[2.x.74]，用[2.x.75]表示矩阵[2.x.76]。因此，我们对(3)得出以下结果。
* [1.x.42]
*
* 现在，把所有的东西放在一起，我们得到布莱克-斯科尔斯方程的以下离散形式。
* [1.x.43]
* 因此，我们总共有。
* [1.x.44]
*
* 像往常一样，我们可以把未知量写在左边，把已知量写在右边。这导致了在每个时间步长中必须解决的以下线性系统。
* [1.x.45]
*
*


*

*[1.x.46][1.x.47]
* 对于这个程序，我们将使用制造解决方案的方法（MMS）来测试它是否正确工作。这意味着我们将选择我们的解决方案是类似于 [2.x.77] 的某个函数。对于我们的案例，我们将使用。
* [1.x.48]
* 这意味着，使用我们的PDE，我们得出以下问题。
* [1.x.49]
* 其中，[2.x.78] .这个设置现在有方程本身和[2.x.79]处的边界条件的右手边，这是我们之前没有的，还有不符合实际情况的 "最终 "条件（或者，用[2.x.80]的时间 "初始条件"）。我们将以这样的方式在代码中实现这一点，以方便交换
*
* - 上述变化的引入只是为了能够使用一个制造的解决方案。
* 如果程序工作正常，那么它应该产生（**）作为解决方案。这确实意味着我们需要对我们的变异形式进行一些修改，以考虑到非零的右手边。
* 首先，我们定义如下。
* [1.x.50]
* 因此，我们得出了新的方程。
* [1.x.51]
*
* 然后我们按照上面的方法解决这个方程。
*

* [1.x.52] [1.x.53]。
* [1.x.54] [1.x.55]。



* 该程序以通常的包含文件开始，所有这些文件你现在应该都见过了。
*


* [1.x.56]
*
* 然后照例将这个程序的所有内容放入一个命名空间，并将deal.II命名空间导入我们将要工作的空间。我们还定义了一个标识符，以便在定义[2.x.81]时可以运行MMS代码。否则，该程序就会解决原来的问题。
*


* [1.x.57]
*
* [1.x.58] [1.x.59]。


*
* 本节为使用MMS进行测试时的已知解决方案创建一个类。这里我们使用[2.x.82]作为解决方案。我们需要包括求解方程和梯度，以便进行H1半正态计算。
*


* [1.x.60]
*
* [1.x.61] [1.x.62]。



* 在下面的类和函数中，我们实现了定义这个问题的右手边和边界值，为此我们需要函数对象。右手边的选择是在介绍的最后讨论的。   
* 首先，我们处理初始条件。
*


* [1.x.63]
*
* 接下来，我们处理左边的边界条件。
*


* [1.x.64]
*
* 然后，我们处理正确的边界条件。
*


* [1.x.65]

* 最后，我们处理右手边的问题。
*


* [1.x.66]
*
* [1.x.67] [1.x.68]。


*
* 下一块是这个程序的主类的声明。这与[2.x.83]的教程非常相似，只是做了一些修改。必须添加新的矩阵来计算A和B矩阵，以及介绍中提到的[2.x.84]向量。我们还定义了问题中使用的参数。
*


*


*


*


*


*


*


*
* - [2.x.85] ：空间领域的强加上限。这是允许的最大股票价格。
*


*
* - [2.x.86] ：时间域的上限。这就是期权到期的时间。
*


*
* - [2.x.87] ：股票价格的波动性./n
*


*
* - [2.x.88] ：无风险利率。
*


*
* - [2.x.89] ：买方在到期时可选择购买股票的约定价格。   
* 本程序与[2.x.90]之间的一些细微差别是创建了[2.x.91]，这在介绍中有所描述。然后，我们还需要存储当前时间，时间步长的大小，以及当前时间步长的数量。接下来，我们将把输出存储到[2.x.92]变量中，因为我们将把每个时间的解分层在上面，形成解流形。然后，我们有一个变量来存储当前的周期和我们在计算解决方案时将运行的周期数。循环是给定一个网格的一个完整的解决方案计算。我们在每个周期之间细化一次网格，以展示我们程序的收敛特性。最后，我们将收敛数据存储到一个收敛表中。   
* 就成员函数而言，我们有一个函数可以计算每个周期的收敛信息，称为[2.x.93] 。这就像在 [2.x.94] 中所做的那样。
*


* [1.x.69]
*
* [1.x.70] [1.x.71]。


*
* 现在，我们进入主类的实现。我们将为问题中使用的各种参数设置值。选择这些是因为它们是这些参数的相当正常的值。虽然股票价格在现实中没有上限（事实上是无限的），但我们施加了一个上限，即行权价格的两倍。选择两倍的行权价有点随意，但它足够大，可以看到解决方案的有趣部分。
*


* [1.x.72]
*
* [1.x.73] [1.x.74]。


*
* 下一个函数设置了DoFHandler对象，计算了约束条件，并将线性代数对象设置为正确的大小。我们还在这里通过调用库中的一个函数来计算质量矩阵。接下来我们将计算其他三个矩阵，因为这些矩阵需要 "手工 "计算。   
* 注意，时间步长在这里被初始化，因为计算时间步长需要成熟时间。
*


* [1.x.75]

* 下面是创建非常数系数的拉普拉斯矩阵的代码。这与介绍中的矩阵D相对应。这个非恒定系数在[2.x.95]变量中表示。
*


* [1.x.76]

* 现在我们将创建A矩阵。下面是创建矩阵A的代码，在介绍中已经讨论过。非恒定系数再次用[2.x.96]这个变量表示。
*


* [1.x.77]

* 最后我们将创建矩阵B。下面是创建矩阵B的代码，在介绍中已经讨论过。非恒定系数再次用[2.x.97]这个变量表示。
*


* [1.x.78]
*
* [1.x.79] [1.x.80]。


*
* 下一个函数是解决单个时间步长的实际线性系统的函数。这里唯一有趣的是，我们建立的矩阵是对称正定的，所以我们可以使用共轭梯度法。
*


* [1.x.81]
*
* [1.x.82] [1.x.83]。


*
* 这是一个简单的函数，用于将解决方案的碎片拼接起来。为此，我们在每个时间段创建一个新的层，然后添加该时间段的解决方案向量。然后，该函数使用 "build_patches "将其与旧的解决方案缝合在一起。
*


* [1.x.84]
*
* [1.x.85] [1.x.86]。


*
* 对于我们所做的全局细化来说，有一个函数是有些不必要的。之所以有这个函数，是为了允许以后有可能进行适应性细化。
*


* [1.x.87]
*
* [1.x.88] [1.x.89]。



* 这是我们计算收敛和误差数据的地方，以评估程序的有效性。在这里，我们计算[2.x.98]、[2.x.99]和[2.x.100]的准则。
*


* [1.x.90]
*
* [1.x.91] [1.x.92]。


*
* 接下来的部分是建立收敛和误差表。通过这个，我们需要设置如何输出在 [2.x.101] 期间计算的数据。首先，我们将创建标题并正确设置单元格。在这期间，我们还将规定结果的精度。然后，我们将把基于[2.x.102]、[2.x.103]和[2.x.104]规范的计算误差写到控制台和误差LaTeX文件中。
*


* [1.x.93]

* 接下来，我们将制作收敛表。我们将再次把这个写到控制台和收敛的LaTeX文件中。
*


* [1.x.94]
*
* [1.x.95] [1.x.96]。



* 现在我们进入了程序的主要驱动部分。在这里，我们完成了所有的工作，即通过时间步数的循环和每次计算解的向量。在这里的顶部，我们设置初始细化值，然后创建一个网格。然后我们对这个网格进行一次细化。接下来，我们设置了data_out_stack对象来存储我们的解决方案。最后，我们启动一个for循环来循环处理这些循环。这让我们为每一个连续的网格细化重新计算出一个解决方案。在每次迭代开始时，我们需要重新设置时间和时间步长。我们引入一个if语句来完成这个任务，因为我们不希望在第一次迭代时就这样做。
*


* [1.x.97]
*
* 接下来，我们运行主循环，该循环一直运行到超过成熟时间。我们首先计算方程的右边，这在导言中已经描述过。回顾一下，它包含术语[2.x.105] 。我们把这些项放到变量system_rhs中，借助于一个临时向量。
*


* [1.x.98]
*
* 第二块是计算源项的贡献。这对应于术语 [2.x.106] 。下面的代码调用[2.x.107]来计算向量[2.x.108]，在这里我们在评估之前设置右侧（源）函数的时间。这一切的结果最终都在forcing_terms变量中。
*


* [1.x.99]
*
* 接下来，我们将强迫项添加到来自时间步长的强迫项中，同时建立矩阵[2.x.109]，我们必须在每个时间步长中进行反转。这些操作的最后一块是消除线性系统中悬挂的节点约束自由度。
*


* [1.x.100]
*
* 在我们解决这个问题之前，还有一个操作需要做：边界值。为此，我们创建一个边界值对象，将适当的时间设置为当前时间步长的时间，并像以前多次那样对其进行评估。其结果也被用来在线性系统中设置正确的边界值。
*


* [1.x.101]
*
* 有了这些，我们要做的就是求解系统，在最后一个周期生成图形数据，并创建收敛表数据。
*


* [1.x.102]
*
* [1.x.103] [1.x.104]。


*
*走到这一步，这个程序的主函数又没有什么好讨论的了：它看起来就像自[2.x.110]以来的所有此类函数。
*


* [1.x.105]
* [1.x.106][1.x.107] 。


*
* 以下是该程序的输出。
* [1.x.108]
*
* 更有趣的是收敛表的输出。它们被输出到控制台，以及一个LaTeX文件中。收敛表显示在上面。在这里，你可以看到，相对于[2.x.112]-norm，解决方案的收敛率为[2.x.111]，相对于[2.x.114]-norm，解决方案的收敛率为[2.x.113]。
*

* 以下是解决方案的可视化。
* [2.x.115]
*

* [1.x.109][1.x.110] [2.x.116] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-79_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] , [2.x.2] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18][1.x.19][1.x.20][1.x.21][1.x.22][1.x.23][1.x.24][1.x.25][1.x.26][1.x.27][1.x.28][1.x.29][1.x.30][1.x.31][1.x.32]
*[1.x.33][1.x.34][1.x.35] 。


* 弹性介质的拓扑优化是一种用于优化承受某种载荷的结构的技术。理想情况下，我们希望通过选择一个放置材料的区域[2.x.3]，使放置在结构上的最大应力最小。换句话说，[1.x.36][1.x.37][1.x.38] 。
* 这里，[2.x.4]是由外力[2.x.5]引起的身体内的应力，为了简单起见，我们假设材料是线性弹性的，因此[2.x.6]是应力-应变张量，[2.x.7]是小变形应变作为位移的函数[2.x.8] 。
*
* - 关于线性弹性的更多信息，请参见[2.x.9]和[2.x.10]。在上面的表述中，[2.x.11]是我们愿意提供的建造物体的最大材料量。最后一个约束是与应力[2.x.12]和力[2.x.13]有关的偏微分方程，它只是稳态力的平衡。
* 也就是说，上面的无穷大准则造成了一个问题：作为材料位置的函数，这个目标函数必然是不可微分的，使得优化的前景相当暗淡。因此，生态优化的一个常见方法是通过优化一个相关的问题找到一个近似的解决方案：我们希望最小化应变能量。这是对物体因其变形而储存的势能的衡量，但也可以作为对结构上总变形的衡量。
* [1.x.39][1.x.40][1.x.41] 。
* 目标函数的值是用有限元方法计算的，其中的解决方案是位移。这被放置在一个非线性求解器的循环中，求解的矢量表示材料的位置。
* [1.x.42][1.x.43] 。
*

* 在实际操作中，我们只能建造一些物体，在这些物体中，材料要么存在，要么不存在，在任何给定的点上都是如此。
*
* 也就是说，我们会有一个指示函数[2.x.14]来描述材料填充的区域，并且我们想通过优化问题来找到它。在这种情况下，优化问题就变成了组合问题，而且解决起来非常昂贵。相反，我们使用一种叫做Solid Isotropic Material with Penalization，或SIMP的方法。  [2.x.15]
* SIMP方法是基于允许材料存在于密度[2.x.16]在0和1之间的位置的想法。密度为0表明材料不存在，它不是结构的一部分，而密度为1表明材料存在。0和1之间的值并不反映我们在现实世界中可以创造的设计，但允许我们将组合问题变成一个连续问题。然后我们看一下密度值[2.x.17]，约束条件是[2.x.18] 。最小值[2.x.19]，通常选择在[2.x.20]左右，避免了出现无限应变能量的可能性，但小到足以提供准确的结果。
* 这个 "密度 "对介质弹性的影响的直接应用是将介质的刚度张量[2.x.21]简单地乘以给定的密度，即[2.x.22]。然而，这种方法经常给出密度值离0和1都很远的最佳解决方案。做到这一点的简单而有效的方法是将刚度张量乘以密度，并将其提高到某个整数的惩罚参数[2.x.23]，这样[2.x.24]。这使得密度值离0或1更远的时候就没有效果了。已经证明，使用[2.x.25]足够高，可以产生'黑白'的解决方案：也就是说，我们得到的最佳解决方案中，材料要么存在，要么不存在于所有点。
* 更多的材料应该总是提供一个具有较低应变能量的结构，因此inequality约束可以被视为一个等式，其中使用的总体积是最大体积。
* 使用这种密度思想也使我们能够重新构建优化问题的体积约束。使用SIMP后，优化问题就变成了下面的情况。
* [1.x.44][1.x.45][1.x.46][1.x.47]最后一个约束条件，即线性动量的平衡（我们将称之为弹性方程），给出了一种在密度[2.x.28]的情况下找到[2.x.26]和[2.x.27]的方法。
*[1.x.48][1.x.49] 。
* 在与时间无关的极限中，弹性方程为[1.x.50]在我们关心的情况下，我们将假设介质具有线性材料响应，在这种情况下，我们有[1.x.51]在我们下面要做的一切中，我们将始终考虑位移场[2.x.29]作为唯一的解决变量，而不是考虑[2.x.30]和[2.x.31]作为解决变量（像在混合计算中那样）。
*此外，我们将假设材料是线性各向同性的，在这种情况下，应力-应变张量可以用Lam&eacute;参数[2.x.32]来表示，以便
* [1.x.52]
* 关于这种转换的原理，见[2.x.33]。
* 对目标函数进行部分积分，得到[1.x.53]，然后将线性弹性方程代入其中，得到[1.x.54]，因为我们假设没有体力，这进一步简化为[1.x.55]，这是我们从这一点出发考虑的管理方程的最终形式。
*[1.x.56][1.x.57]。
*

* 通常情况下，拓扑优化问题的解决方案是依赖于网格的，因此该问题是不成立的。这是因为随着网格的进一步细化，往往会形成分形结构。随着网格分辨率的提高，最优解通常会获得越来越小的结构。对于这个问题，有一些竞争性的解决方法，但对于一阶优化来说，最流行的是灵敏度滤波器，而二阶优化方法则倾向于使用密度滤波器。
* 由于滤波器会影响应变能量（即目标函数）的梯度和Hessian，滤波器的选择对问题的解决有影响。作为二阶方法的一部分，密度滤波器的工作原理是引入一个未经过滤的密度，我们称之为[2.x.34]，然后要求密度是未经过滤的密度的卷积：[1.x.58]这里，[2.x.35]是一个算子，因此[2.x.36]是[2.x.37]在[2.x.38]周围地区的某种平均值。
*
* -即，它是[2.x.39]的平滑版本。
* 这可以防止棋盘游戏；过滤器的半径允许用户为我们寻找的最佳结构定义一个有效的最小光束宽度。
* [2.x.40]
*

* 这些图片表明，我们在这里发现的情况与在其他关于该主题的出版物[2.x.41]中通常看到的情况是一致的。也许更有趣的是，其结果看起来像一座桁架桥（除了我们在桁架的顶部施加负载，而不是像真正的桁架桥那样在底部施加负载，类似于 "甲板桁架 "桥），这表明几个世纪以来一直用于建桥的设计确实是基于我们现在可以证明在某种意义上是最佳的想法。
*

*[1.x.203][1.x.204]


* 上面显示的结果花了大约75次迭代才找到，考虑到每次迭代中解决大型线性系统的费用，这是很值得关注的。从演化过程来看，收敛过程确实有快速发生的时候，也有缓慢发生的时候。我们认为这是由于在何时和如何减少边界值方面缺乏精确性，以及我们对优点函数的选择不够理想。在未来，用LOQO障碍更新代替单调还原，以及用MarkovFilter代替优点函数将大大减少必要的迭代次数。
* 障碍物的减少在收敛的中间阶段最为敏感，这是有问题的，因为我们似乎需要它快速减少，然后缓慢减少，然后又快速减少。
* 其次，这里使用的线性求解器只是基于SparseDirectUMFPACK类的稀疏直接求解器。这在小问题上效果还不错，但是上面详述的优化问题的表述有相当多的变量，因此线性问题不仅大，而且在很多行中有很多非零项，即使在总体上仍然相对粗糙的网格上也是如此。因此，解算器的时间在计算中占主导地位，必须采用更复杂的方法来解决这个线性系统。
*

* [1.x.205][1.x.206] [2.x.42] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-8_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17]
*[1.x.18][1.x.19][1.x.20] 。


*
* 在现实生活中，大多数偏微分方程实际上是方程组。因此，解通常是向量值的。deal.II库支持这类问题（见[2.x.2]模块中的大量文档），我们将表明，这大多是相当简单的。唯一比较复杂的问题是在组装矩阵和右手边，但这些也很容易理解。
* [2.x.3]
* 它们是拉普拉斯方程的扩展，有一个矢量值的解，描述了一个受力的刚体在每个空间方向的位移。当然，这个力也是矢量值的，也就是说，在每一个点上，它都有一个方向和一个绝对值。
* 人们可以用多种方式来写弹性方程。其中[2.x.4]是每一点的向量值位移，[2.x.5]是力，[2.x.6]是一个等级4的张量（即，它有四个索引），编码应力-应变关系。
*
* 本质上，它代表了[1.x.23]中的Hookes定律，将位移与力联系起来。  在许多情况下，如果我们想模拟的物体的变形是由不同的材料组成的，[2.x.7]将取决于[2.x.8]。
* 虽然上述方程的形式是正确的，但这并不是它们通常的推导方式。事实上，位移的梯度[2.x.9]（一个矩阵）没有物理意义，而它的对称版本[1.x.24]却有，通常被称为 "应变"。这里和下文中，[2.x.10] 。我们还将使用[1.x.25]，即只要同一指数在方程中出现两次，就意味着对该指数求和；但是，我们将不区分上下指数。）有了这个应变的定义，弹性方程就读作[1.x.26]，你可以认为这是拉普拉斯方程对矢量值问题的更自然的概括。首先显示的形式等同于这种形式，因为张量[2.x.11]具有某些对称性，即[2.x.12]，因此[2.x.13]。
* 当然，我们也可以把这些方程写成组件形式：[1.x.27] 。
* 在许多情况下，我们知道所考虑的材料是各向异性的，在这种情况下，通过引入两个系数[2.x.14]和[2.x.15]，系数张量减少为[1.x.28] 。
* 然后，弹性方程可以改写成更简单的形式：[1.x.29]，各自的双线性形式是[1.x.30]，或者也可以把第一项写成分量的和：[1.x.31] 。
*[2.x.16]如上所述，如果位移很小，我们可以假设[1.x.32]有效，上述方程一般被认为是对三维物体位移的正确描述。在这种情况下，上面的指数[2.x.17]都在集合[2.x.18]上运行（或者，在C++源中，在[2.x.19]上）。然而，按照目前的情况，程序是在二维运行的，虽然上面的方程在这种情况下也有数学意义，但它们只能描述一个真正的二维实体。特别是，它们不是对[2.x.20]方向上无限大的体的横截面的适当描述；这与其他许多二维方程相反，这些方程可以通过假设体在[2.x.22]方向上有无限大的范围和解函数不依赖于[2.x.23]坐标而得到。另一方面，也有二维弹性模型的方程；例如，见维基百科关于[1.x.33]、[1.x.34]和[1.x.35]的文章。
* 但让我们回到最初的问题。我们如何为这样一个方程组装矩阵？在[2.x.24]模块的文档中给出了一个很长的答案，其中有许多不同的选择。从历史上看，下面显示的解决方案是该库早期唯一可用的方案。事实证明，它也是最快的。另一方面，如果百分之几的计算时间并不重要，还有比下面讨论的更简单、更直观的方法来组装线性系统，但这些方法直到本教程首次编写后几年才可用；如果你对它们感兴趣，可以看看[2.x.25]模块。
* 让我们回到如何组装线性系统的问题上来。我们首先需要了解一些关于在矢量值有限元情况下形状函数如何工作的知识。基本上，这归结为以下几点：让[2.x.26]为标量有限元的形状函数数量，我们在此基础上建立矢量元素（例如，我们将对矢量值有限元的每个分量使用双线性函数，所以标量有限元是[2.x.27]元素，我们在以前的例子中已经使用过，而在两个空间维度中使用[2.x.28]）。此外，让[2.x.29]成为矢量元素的形状函数的数量；在两个空间维度中，我们需要[2.x.30]矢量的每个分量的形状函数，所以[2.x.31]。然后，矢量元素的[2.x.32]个形状函数具有[1.x.36]的形式，其中[2.x.33]是[2.x.34]个单位矢量，[2.x.35]是告诉我们[2.x.36]的哪个分量是非零的函数（对于每个矢量形状函数，只有一个分量是非零，其他都是零）。  [2.x.37]描述了形状函数的空间依赖性，它被认为是标量元素的第[2.x.38]个形状函数。当然，虽然[2.x.39]的范围是[2.x.40]，但函数[2.x.41]和[2.x.42]的范围分别是[2.x.43]（在二维）和[2.x.44]。
* 例如（尽管这个形状函数的顺序并不保证，你也不应该依赖它），下面的布局可以被库使用：[1.x.37] 。
* 在这里[1.x.38][1.x.39]。
* 除了非常罕见的情况，你不需要知道标量元素的哪个形状函数[2.x.45]属于矢量元素的一个形状函数[2.x.46]。因此，让我们定义[1.x.40]，我们可以把向量形状函数写成[1.x.41]，现在你可以安全地忘记函数[2.x.47]，至少在这个例子程序的其余部分。
* 现在使用这个矢量形状函数，我们可以将离散的有限元解写成[1.x.42]，标量系数[2.x.48]。如果我们定义一个模拟函数[2.x.49]作为测试函数，我们可以把离散问题写成如下。寻找系数[2.x.50]，以便[1.x.43]。
* 如果我们把双线性形式的定义和[2.x.51]和[2.x.52]的表示插入这个公式：[1.x.44]
* 我们注意到，在这里和下文中，指数[2.x.53]在空间方向上运行，即[2.x.54] ，而指数[2.x.55]在自由度上运行。
* 因此，单元格[2.x.56]上的局部刚度矩阵有以下条目：[1.x.45]，其中[2.x.57]现在是局部自由度，因此[2.x.58].在这些公式中，我们总是取矢量形状函数[2.x.59]的一些分量，当然，它们是如下给出的（见其定义）：[1.x.46]，克朗克符号[2.x.60] 。由于这个原因，我们可以删除一些对[2.x.61]和[2.x.62]的和：[1.x.47] 。
*
* 同样地，单元格[2.x.63]对右手边矢量的贡献是[1.x.48] 。
*
* 这就是我们将实现局部刚度矩阵和右侧向量的形式。
* 作为最后的说明：在[2.x.64]示例程序中，我们将重新审视这里提出的弹性问题，并将展示如何在一个计算机集群上并行解决它。由此产生的程序将能够以更高的精度解决这个问题，而且如果需要的话，效率更高。此外，在[2.x.65]，[2.x.66]"[2.x.67]"，以及其他一些后来的教程程序中，我们将回顾一些矢量值问题，并展示一些技术，这些技术可能使其更容易实际通过上面显示的所有东西，与[2.x.68]等。
*

* [1.x.49] [1.x.50]。
* [1.x.51] [1.x.52]。
*

*
* 像往常一样，前几个include文件已经是众所周知的了，所以我们不会对它们作进一步评论。
*


* [1.x.53]
*
* 在这个例子中，我们需要矢量值的有限元。对这些的支持可以在下面的include文件中找到。
*


* [1.x.54]
*
* 我们将从常规的Q1元素中组成矢量值的有限元素，这些元素可以在这里找到，像往常一样。
*


* [1.x.55]
*
* 这又是C++。
*


* [1.x.56]

* 最后一步和以前的程序一样。特别是，就像在[2.x.69]中一样，我们把这个程序所特有的一切都打包到一个自己的命名空间中。
*


* [1.x.57]
*
* [1.x.58] [1.x.59]。


*
* 主类除了名字之外，与[2.x.70]的例子相比几乎没有变化。   
* 唯一的变化是为[2.x.71]变量使用了一个不同的类。我们现在使用的不是FE_Q这样的具体的有限元类，而是一个更通用的类，FESystem。事实上，FESystem本身并不是一个真正的有限元，因为它没有实现自己的形状函数。相反，它是一个可以用来将其他几个元素堆叠在一起形成一个矢量值的有限元的类。在我们的例子中，我们将组成[2.x.72]对象的矢量值元素，如下所示，在这个类的构造函数中。
*


* [1.x.60]
*
* [1.x.61] [1.x.62]。


*
* 在进入主类的实现之前，我们声明并定义描述右手边的函数。这一次，右手边是向量值，就像解决方案一样，所以我们将更详细地描述为此所需的变化。   
* 为了防止出现返回向量先前没有被设置为正确大小的情况，我们对这种情况进行了测试，否则将在函数的开始部分抛出一个异常。请注意，强制要求输出参数已经具有正确的大小是deal.II中的一个惯例，并且几乎在所有地方都强制执行。原因是，否则我们将不得不在函数开始时检查，并可能改变输出向量的大小。这很昂贵，而且几乎总是不必要的（对函数的第一次调用会将向量设置为正确的大小，随后的调用只需要做多余的检查）。此外，如果我们不能依赖向量已经具有正确大小的假设，那么检查和可能调整向量大小的操作是不能被删除的；这与Assert调用是相通的，如果程序在优化模式下编译，Assert调用是完全被删除的。   
* 同样，如果由于某种意外，有人试图在只有一个空间维度的情况下编译和运行程序（在这种情况下，弹性方程没有什么意义，因为它们还原为普通的拉普拉斯方程），我们在第二个断言中终止程序。然而，该程序在三维空间中也能正常工作。
*


* [1.x.63]
*
* 该函数的其余部分实现了计算力值。我们将使用一个位于(0.5,0)和(-0.5,0)点周围的两个小圆圈（或球体，在3D中）的X方向的恒定（单位）力，以及位于原点周围的Y方向的力；在3D中，这些中心的Z分量也是零。     
* 为此，让我们首先定义两个对象来表示这些区域的中心。请注意，在构建点对象时，所有的分量都被设置为零。
*


* [1.x.64]
*
* 如果[2.x.73]处于围绕这些点之一的半径为0.2的圆（球）中，那么将X方向的力设置为1，否则为0。
*


* [1.x.65]
*
* 同样地，如果[2.x.74]在原点附近，那么将y力设置为1，否则为0。
*


* [1.x.66]
*
* [1.x.67] [1.x.68]。



* [1.x.69] [1.x.70]。


*
* 以下是主类的构造函数。如前所述，我们想构造一个由多个标量有限元组成的矢量值有限元（即，我们想构造矢量值元素，使其每个矢量分量由一个标量元素的形状函数组成）。当然，我们想堆积在一起的标量有限元的数量等于解函数的分量数量，由于我们考虑每个空间方向的位移，所以是[2.x.75]。FESystem类可以处理这个问题：我们传递给它我们想组成系统的有限元，以及它的重复频率。
*


*


* [1.x.71]
*
* 事实上，FESystem类还有几个构造函数，可以进行更复杂的操作，而不仅仅是将几个相同类型的标量有限元堆叠在一起，我们将在后面的例子中了解这些可能性。
*



*
* [1.x.72] [1.x.73]。


*
* 设置方程组与[2.x.76]例子中使用的函数相同。DoFHandler类和这里使用的所有其他类都完全知道我们要使用的有限元是矢量值的，并照顾到了有限元本身的矢量值性。(事实上，他们不知道，但这不需要困扰你：因为他们只需要知道每个顶点、直线和单元有多少个自由度，而且他们不问这些自由度代表什么，即考虑的有限元是矢量值的，还是例如在每个顶点有几个自由度的标量Hermite元)。
*


* [1.x.74]
*
* [1.x.75] [1.x.76]。


*
* 这个程序中最大的变化是创建矩阵和右手边，因为它们是取决于问题的。我们将一步一步地完成这个过程[2.x.77]，因为它比以前的例子要复杂一些。   
* 然而，这个函数的前几部分和以前一样：设置一个合适的正交公式，为我们使用的（矢量值的）有限元以及正交对象初始化一个FEValues对象，并声明一些辅助数组。此外，我们还声明了永远相同的两个缩写。  [2.x.78] 和 [2.x.79] 。每个单元的自由度数量，我们现在显然是从组成的有限元中询问，而不是从底层的标量Q1元中询问。这里，它是[2.x.80]乘以Q1元素的每个单元的自由度数，尽管这不是我们需要关心的明确知识。
*


* [1.x.77]
*
* 正如前面的例子所示，我们需要一个地方来存储一个单元上所有正交点的系数值。在目前的情况下，我们有两个系数，lambda和mu。
*


* [1.x.78]
*
* 好吧，我们也可以省略上面的两个数组，因为我们将对lambda和mu使用常数系数，可以这样声明。它们都代表函数总是返回常量值1.0。尽管我们可以在矩阵的组合中省略各自的系数，但为了演示，我们在这里使用它们。
*


* [1.x.79]
*
* 和上面的两个常量函数一样，我们将在每个单元格只调用一次函数right_hand_side，以使事情更简单。
*


* [1.x.80]
*
* 现在我们可以开始对所有单元格进行循环。
*


* [1.x.81]

* 接下来我们得到正交点的系数值。同样，对于右手边的情况也是如此。
*


* [1.x.82]
*
* 然后把局部刚度矩阵的条目和右手边的向量组合起来。这几乎是一对一地遵循本例介绍中描述的模式。  在位的几个评论之一是，我们可以计算数字[2.x.81] ，即使用下面的[2.x.83]函数调用形状函数[2.x.82]的唯一非零向量分量的索引。         
*（通过访问[2.x.85]函数返回值的[2.x.84]变量，你可能已经猜到其中有更多的内容。事实上，该函数返回一个[2.x.86]int，无符号int[2.x.87]，其中第一个元素是[2.x.88]，第二个元素是介绍中也指出的值[2.x.89]，即这个形状函数在这个组件中所有非零的形状函数中的索引，即介绍中的字典[2.x.90]。不过，这不是我们通常感兴趣的数字）。)         
* 有了这些知识，我们就可以把局部矩阵的贡献集合起来。
*


* [1.x.83]
*
* 第一个项是[2.x.91] 。注意，[2.x.92]返回正交点q_point处第i个形状函数的唯一非零分量的梯度。梯度的分量[2.x.93]是第i个形状函数的唯一非零向量分量相对于comp(i)th坐标的导数，由附加的括号访问。
*


* [1.x.84]
*
* 第二个项是[2.x.94] 。我们不需要访问梯度的具体分量，因为我们只需要计算两个梯度的标量乘积，其中<tt>operator*</tt>的重载版本负责，就像以前的例子一样。                         
* 注意，通过使用<tt>?:</tt>操作符，我们只在<tt>component_i</tt>等于<tt>component_j</tt>的情况下才这样做，否则会加上一个零（编译器会将其优化掉）。
*


* [1.x.85]
*
* 组装右手边也和介绍中讨论的一样。
*


* [1.x.86]
*
* 从局部自由度转移到全局矩阵和右手向量并不取决于所考虑的方程，因此与之前所有的例子相同。
*


* [1.x.87]
*
* [1.x.88] [1.x.89]。


*
* 解算器并不关心方程组的来源，只要它保持正定和对称（这是使用CG解算器的要求），而该系统确实是这样的。因此，我们不需要改变任何东西。
*


* [1.x.90]
*
* [1.x.91] [1.x.92]。


*
* 对网格进行细化的函数与[2.x.95]的例子相同。正交公式再次适应于线性元素。请注意，误差估计器默认情况下是将从有限元解的所有分量中得到的估计值相加，也就是说，它使用所有方向的位移，权重相同。如果我们希望网格只适应x方向的位移，我们可以给函数传递一个额外的参数，告诉它这样做，而不考虑其他所有方向的位移作为误差指标。然而，对于目前的问题，似乎应该考虑所有的位移成分，而且权重相同。
*


* [1.x.93]
*
* [1.x.94] [1.x.95]。


*
* 输出的情况与前面的例子中已经显示过的差不多了。唯一的区别是，求解函数是矢量值的。DataOut类会自动处理这个问题，但我们必须给求解向量的每个分量一个不同的名字。   
* 要做到这一点，[2.x.96]函数需要一个字符串的向量。由于分量的数量与我们工作的维数相同，我们使用下面的[2.x.97]语句。   
* 我们注意到，一些图形程序对变量名称中允许的字符有限制。因此，deal.II只支持所有程序都支持的这些字符的最小子集。基本上，这些字符是字母、数字、下划线和其他一些字符，但特别是没有空格和减号/横线。否则该库将抛出一个异常，至少在调试模式下是这样。   
* 在列出了1d、2d和3d的情况后，如果我们遇到一个我们没有考虑到的情况，让程序死亡是一种很好的风格。记住，如果第一个参数中的条件不满足，Assert宏就会产生一个异常。当然，条件[2.x.98]永远不可能被满足，所以只要程序运行到默认语句，就会中止。
*


* [1.x.96]
*
* 在为解向量的不同组成部分设置了名称之后，我们可以将解向量添加到计划输出的数据向量列表中。请注意，下面的函数需要一个字符串向量作为第二个参数，而我们在以前所有例子中使用的函数在那里接受一个字符串。(事实上，我们之前使用的函数会将单个字符串转换成只有一个元素的向量，并将其转发给另一个函数)。
*


* [1.x.97]
*
* [1.x.98] [1.x.99]。


*
* 例如，[2.x.99]函数所做的事情与[2.x.100]中相同。这一次，我们使用平方[-1,1]^d作为域，并在开始第一次迭代之前对其进行全局细化。   
* 细化的原因有点意外：我们使用QGauss正交公式，在每个方向上都有两个点用于整合右手边；这意味着每个单元上有四个正交点（在二维）。如果我们只对初始网格进行一次全局细化，那么在域上每个方向上就只有四个正交点。然而，右侧函数被选择为相当局部的，在这种情况下，纯属偶然，恰好所有的正交点都位于右侧函数为零的点上（用数学术语来说，正交点恰好在右侧函数的[1.x.100]之外的点上）。这样一来，用正交计算的右手向量将只包含零（尽管如果我们完全用积分来计算右手向量，它当然会是非零的），方程组的解就是零向量，即一个处处为零的有限元函数。从某种意义上说，我们不应该对这种情况的发生感到惊讶，因为我们选择了一个完全不适合手头问题的初始网格。   
* 不幸的是，如果离散解是常数，那么KellyErrorEstimator类计算的误差指标对每个单元来说也是零，对[2.x.101]的调用将不会标记任何单元进行细化（如果每个单元的指示误差是零，为什么要这样做？因此，下一次迭代中的网格也将只由四个单元组成，同样的问题再次发生。   
* 结论需要是：虽然我们当然不会选择非常适合准确解决问题的初始网格，但我们至少必须选择它，使它有机会捕捉到解决方案的重要特征。在这种情况下，它需要能够看到右手边的情况。因此，我们进行了四次全局细化。当然，任何更大数量的全局细化步骤也是可行的）。
*


* [1.x.101]
*
* [1.x.102] [1.x.103]。



* 在上面最后一行关闭了[2.x.102]的命名空间后，下面是程序的主要功能，又和[2.x.103]中一模一样（当然，除了改变了类名）。
*


* [1.x.104]
* [1.x.105][1.x.106] 。



* 关于这个程序的结果，除了它们看起来很好之外，没有什么可说的。所有图片都是用VisIt从程序写入磁盘的输出文件中制作的。前两张图片显示了[2.x.104]-和[2.x.105]-位移的标量分量。
* [2.x.106]
*

* 你可以清楚地看到[2.x.107]--围绕[2.x.108]和[2.x.109]的位移，以及[2.x.110]--原点的位移的来源。
* 人们经常想做的是将位移显示为一个矢量场，也就是说，每个点的矢量都能说明位移的方向和大小。不幸的是，这就有点复杂了。为了理解这一点，请记住，我们刚刚将有限元定义为两个分量的集合（在[2.x.111]维度）。我们没有说过这不仅仅是一个压力和一个浓度（两个标量），而是说这两个分量实际上是一个向量值的量的一部分，即位移。如果没有这方面的知识，DataOut类就会假定我们打印的所有单个变量都是分离卡尔，而VisIt和Paraview就会忠实地假定它确实是这样的。换句话说，一旦我们把数据写成标量，这些程序中就没有任何东西可以让我们把这两个标量字段粘贴在一起作为一个向量字段。我们必须从根本上解决这个问题，即在 [2.x.112] 中。我们不会在这里这样做，而是让读者参考[2.x.113]程序，在那里我们展示了如何在一个更普遍的情况下这样做。尽管如此，我们还是忍不住要生成数据，以显示如果按照[2.x.114]中讨论的方式实施，会是什么样子。矢量场看起来是这样的（VisIt和Paraview随机选择几百个顶点来绘制矢量；从每个顶点绘制矢量会使图片无法阅读）。
* [2.x.115]


* 我们注意到，人们可能直观地期望解决方案围绕[2.x.116]-和[2.x.117]-轴对称，因为[2.x.118]-和[2.x.119]-力相对于这些轴是对称的。然而，作为一个矢量的力不是对称的，因此也不是解决方案。
*

* [1.x.107][1.x.108] [2.x.120] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/step-9_0.txt
[0.x.0]*
 [2.x.0]
* 本教程依赖于 [2.x.1] 。
* [1.x.0][1.x.1][1.x.2][1.x.3][1.x.4][1.x.5][1.x.6][1.x.7][1.x.8][1.x.9][1.x.10][1.x.11][1.x.12][1.x.13][1.x.14][1.x.15][1.x.16][1.x.17][1.x.18]
*[1.x.19][1.x.20][1.x.21] 。



* 在这个例子中，我们的目的如下。[2.x.2] [2.x.3] 解决平流方程 [2.x.4] ； [2.x.5] 显示如果我们有一台多处理器机器，我们如何使用多线程来快速获得结果； [2.x.6] 开发一个简单的细化标准。[2.x.7]虽然第二个目标很难在不参考代码的情况下进行一般性描述，但我们将在下文中讨论其他两个目标。多线程的使用将在程序中的相关地方进行详细说明。然而，我们将遵循[2.x.8]"多处理器访问共享内存的并行计算 "文档模块中详述的关于WorkStream方法的一般讨论。
*

*[1.x.22][1.x.23]


* 在本例程序中，我们要对平流方程[1.x.24]的解进行数值近似，其中[2.x.9]是描述平流方向和速度的矢量场（如果[2.x.10]，可能取决于空间变量），[2.x.11]是一个源函数，[2.x.12]是解。该方程描述的物理过程是一个给定的流场[2.x.13]，另一种物质随着流场被输送，其密度或浓度由[2.x.14]给出。该方程不包含这第二种物质在其载体物质内的扩散，但有源参数。
* 很明显，在流入处，上述方程需要用边界条件来加强：[1.x.25]其中[2.x.15]描述了边界的流入部分，并由[1.x.26]和[2.x.16]定义为在[2.x.17]点的域的外向法线。这个定义非常直观，因为[2.x.18]指向外部，如果传输方向[2.x.20]指向内部，即流入边界，那么与[2.x.19]的标量乘积只能是负数。数学理论指出，我们必须不在边界的流出部分设置任何边界条件。
* 不幸的是，上述方程不能以稳定的方式用标准的有限元方法来解决。问题是，这个方程的解在垂直于传输方向上的规则性不足：虽然它们沿 "风场"[2.x.21]定义的流线是光滑的，但它们在垂直于这个方向上可能是不连续的。这很容易理解：方程[2.x.22]的意思实质上就是[1.x.27]。但该方程对垂直方向的导数没有影响，因此，如果[2.x.23]在流入边界的某一点上不连续，那么这个不连续就会沿着从该边界点开始的风场流线传播。这些不连续导致了数值不稳定，使得通过标准的连续有限元离散化获得稳定的解是不可能的。
* 解决这一难题的标准方法是[2.x.24]"流线-上风-彼得罗夫-加勒金"[2.x.25]（SUPG）方法，有时也称为流线扩散法。该方法的一个很好的解释可以在 [2.x.26] 中找到。从形式上看，这种方法取代了我们从强形式推导出微分方程的弱形式的步骤。我们不是用测试函数[2.x.27]乘以方程并在域上积分，而是乘以[2.x.28]，其中[2.x.29]是在（局部）网格宽度[2.x.30]范围内选择的一个参数；通过设置[2.x.31]通常可以获得良好的结果。]。(为什么这被称为 "流线扩散 "将在下面解释；目前，让我们简单地认为这是我们获得稳定的离散公式的方式。)这里[2.x.32]的值要足够小，以便我们不会引入过多的扩散，但又要足够大，以使结果问题得到良好解决。
* 使用上面定义的测试函数，问题的初始弱形式将要求找到一个函数[2.x.33]，以便对于所有的测试函数[2.x.34]，我们有[1.x.28]然而，我们希望将流入的边界条件[2.x.35]弱地纳入这个问题，这可以通过要求除上述方程外，对于所有生活在边界上且来自合适的测试空间的测试函数[2.x.36]，我们也有[1.x.29]来实现。事实证明，一个合适的检验函数空间恰好是[2.x.37]乘以我们已经用于域内微分方程的检验空间中的函数[2.x.38]的痕迹。因此，我们要求对于所有的测试函数[2.x.39]，我们有[1.x.30]，在不试图进行论证的情况下（请再次参阅关于一般的有限元方法，特别是流线扩散方法的文献），我们可以将微分方程和边界值的方程结合在我们稳定化问题的以下弱化表述中：找到一个离散函数[2.x.40]，使得对于所有离散测试函数[2.x.41]，持有[1.x.31]
*

* 人们会认为这导致了一个系统矩阵被倒置的形式[1.x.32]与基函数[2.x.42]。  然而，这是每一个数值分析师至少会遇到一次的问题（包括作者）：我们在这里扩展了解决方案[2.x.43]，但如果我们这样做，我们将不得不解决[1.x.33]问题，其中[2.x.44]是扩展系数的矢量，也就是说，我们必须解决我们可能天真的预期的转置问题。
* 这是我们在[2.x.45]的介绍中提出的一个观点。在那里，我们认为，为了避免这种问题，我们应该养成习惯，总是用测试函数相乘[1.x.34]，而不是从右边获得正确的矩阵。为了获得我们需要的线性系统的形式，最好是将弱式改写为[1.x.35]，然后获得[1.x.36]作为系统矩阵。我们将在程序中组装这个矩阵。
*

*[1.x.37][1.x.38]


* 看一下上面提到的双线性形式，我们看到离散解必须满足一个方程，其中弱形式的左手边有一个域项[1.x.39]，如果我们把它拆开，则是[1.x.40]的形式。如果我们想看看这个方程的强形式会对应什么，我们需要对第二个项进行积分。这就产生了下面的公式，为了简单起见，我们暂时忽略边界项：[1.x.41]让我们暂时假设风场[2.x.46]是无发散的，即[2.x.47] 。然后将乘积法则应用于右边方括号内的项的导数，并利用发散性将得到以下结果：[1.x.42]这意味着方程的强形式将是这样的：[1.x.43]现在要认识到的是，[2.x.48]是方向[2.x.50][2.x.51]的[2.x.49]的导数。因此，如果我们用[2.x.52]来表示（就像我们经常用[2.x.53]来表示边界处法线方向的导数一样），那么方程的强形式就是[1.x.44]。换句话说，测试函数的不寻常选择相当于在强形式中增加了一个项，对应于风场[2.x.54]方向的二阶（即扩散）微分算子，即在 "流线方向"。更全面的说明还必须探讨测试函数对边界值的影响，以及为什么有必要对右手边也使用相同的测试函数，但上面的讨论可能会使人明白该方法的 "流线扩散 "名称的由来。
*

*[1.x.45][1.x.46]


* "Galerkin方法 "是指用测试函数[2.x.55]乘以方程（然后对[2.x.56]进行积分）来获得弱公式，其中函数[2.x.57]与解决方案[2.x.58]来自同一空间（尽管可能具有不同的边界值）。但这并不是严格必要的。我们也可以设想从不同的函数集中选择测试函数，只要这个不同的函数集具有与原始函数集 "同样多的维度"，这样我们最终就能得到与自由度一样多的独立方程（在无限维的情况下，所有这些都需要适当的定义）。利用这种可能性的方法（即以不同的方式选择测试函数集和解集）被称为 "Petrov-Galerkin "方法。在目前的情况下，测试函数的形式都是[2.x.59]，其中[2.x.60]是来自解集。
*

*[1.x.47][1.x.48] 。


* [上风方法](https://en.wikipedia.org/wiki/Upwind_scheme)在推导对流方程的稳定方案方面有着悠久的历史。一般来说，这个想法是，我们不是在 "这里 "看一个函数，而是在 "上游 "或 "上风 "的一小段距离上看它，也就是说，"这里 "的信息最初来自哪里。这可能建议不要考虑[2.x.61]，而是考虑[2.x.62]这样的东西。或者，在整合之后，我们可以评估[2.x.63]，而考虑[2.x.64]的下游部分。  [2.x.65] .由于各种原因，这将是很麻烦的。首先，如果[2.x.67]恰好在[2.x.68]之外，我们将不得不定义[2.x.66]应该是什么；其次，数值计算积分将更加困难，因为我们不再在同一正交点评估[2.x.69]和[2.x.70]。但由于我们假设[2.x.71]很小，我们可以做一个Taylore扩展：[1.x.49]这个测试函数的形式现在应该看起来很熟悉。
*

*[1.x.50][1.x.51]


* 由于得到的矩阵不再是对称正定的，我们不能使用通常的共轭梯度方法（在SolverCG类中实现）来解决这个系统。相反，我们使用GMRES（GeneralizedMinimum RESidual）方法（在SolverGMRES中实现），它适用于我们这里的那种问题。
*

*[1.x.52][1.x.53]


* 对于我们将在本教程中解决的问题，我们使用以下领域和函数（在[2.x.72]空间维度）：[1.x.54] 。
* 对于[2.x.73]，我们扩展了[2.x.74]和[2.x.75]，只是将上面显示的最后一个组件再重复一次。
*有了这些，下面的评论是有必要的。[2.x.76] [2.x.77] 平流场[2.x.78]将解决方案大致以对角线方向从左下角传输到右上角，但叠加了一个蠕动结构。[2.x.79] 右手边在流入边界条件产生的场中加入了左下角的一个小球，该小球被沿途传送。[2.x.80] 流入边界条件施加了一个加权的正弦结构，与流场一起被传送。由于[2.x.81]在边界上，加权项不会变得非常大。[2.x.82]
*

*[1.x.55][1.x.56]


* 在以前所有的自适应细化的例子中，我们使用了Kelly等人首先开发的误差估计器，该估计器为每个单元[2.x.83]分配了以下指标：[1.x.57]其中[2.x.84]表示跨越单元[2.x.86]的一个面的法向导数的跳跃。可以看出，这个误差指标使用的是次导数的离散类似物，由单元大小的一个幂加权，这个幂是根据这里假定使用的线性元素调整的：[1.x.58]它本身与能量准则中的误差大小有关。
* 在目前的情况下，这个误差指标的问题是，它假定精确的解决方案拥有二次导数。在某些情况下，这对拉普拉斯问题的解来说已经是个问题了，尽管大多数问题都允许在[2.x.87]中求解。如果解只在[2.x.88]中，那么二阶导数在域的某些部分（低维）将是奇异的，在网格细化下，误差指标不会减少。因此，该算法将不断细化这些部分周围的单元，即细化为点或线（在2d中）。
* 然而，对于目前的情况，解通常不在[2.x.89]中（这种缺失的规律性不是拉普拉斯方程那样的特殊情况），所以上述的错误指标并不真正适用。因此，我们将开发一个基于梯度的离散近似的指标。尽管梯度常常不存在，但这是我们唯一可用的标准，至少在我们使用连续元素的情况下是如此。首先，我们注意到，给定两个单元[2.x.90]、[2.x.91]，其中心由矢量[2.x.92]连接，我们可以对函数[2.x.93]的方向导数做如下近似：[1.x.59]其中[2.x.94]和[2.x.95]表示在各自单元中心评估的[2.x.96]。现在我们将上述近似值乘以[2.x.97]，并对[2.x.99]的所有邻居[2.x.98]求和：[1.x.60]如果连接[2.x.100]和其邻居的向量[2.x.101]横跨整个空间（即大致为：[2.x.102] 在所有方向上都有邻居），那么左侧表达式中括号内的项就形成了一个方阵，我们可以通过反转来获得[2.x.103]在[2.x.104]上的近似值：[1.x.61]我们将用[2.x.105]来表示右侧的近似值，我们将使用以下数量作为细化标准：[1.x.62]这是受以下（不严格的）论证的启发：[1.x.63]
*
*

* [1.x.64] [1.x.65]。
* 就像以前的例子一样，我们必须包括几个文件，其中的含义已经讨论过了。
*


* [1.x.66]

* 下面两个文件提供了多线程程序的类和信息。在第一个中，声明了我们需要做并行装配的类和函数（即[2.x.106]命名空间）。第二个文件有一个类MultithreadInfo，可以用来查询系统中的处理器数量，这在决定启动多少个并行线程时往往很有用。
*


* [1.x.67]

* 下一个新的include文件声明了一个基类[2.x.107]，与[2.x.108]类不一样，但不同的是[2.x.109]返回一个张量而不是一个标量。
*


* [1.x.68]
*
* 这是C++，因为我们想把一些输出写到磁盘上。
*


* [1.x.69]

* 最后一步和以前的程序一样。
*


* [1.x.70]
*
* [1.x.71] [1.x.72]。


*
* 接下来我们声明一个描述平流场的类。当然，这是一个矢量场，有多少分量就有多少空间维度。现在我们可以使用一个从[2.x.110]基类派生出来的类，就像我们在以前的例子中对边界值和系数所做的那样，但是在库中还有另一种可能性，即一个描述张量值函数的基类。这比重写[2.x.111]知道多个函数成分的方法更方便：到最后我们需要一个张量，所以我们不妨直接使用一个返回张量的类。
*


* [1.x.73]
*
* 在前面的例子中，我们已经在几个地方使用了抛出异常的断言。然而，我们还没有看到如何声明这种异常。这可以通过以下方式实现。
*


* [1.x.74]
*
* 语法可能看起来有点奇怪，但很合理。其格式基本如下：使用其中一个宏的名字 [2.x.112] 表示异常对象应接受的额外参数的数量。在本例中，由于我们想在两个向量的大小不同时抛出异常，我们需要两个参数，所以我们使用 [2.x.113] 。第一个参数描述了异常的名称，而后面的参数则声明了参数的数据类型。最后一个参数是一连串的输出指令，这些指令将被输送到 [2.x.114] 对象中，因此出现了奇怪的格式，前面有 [2.x.115] 操作符之类的。注意，我们可以通过使用名称 [2.x.117] 来访问在构造时（即在 [2.x.116] 调用中）传递给异常的参数，其中 [2.x.118] 是通过使用相应的宏 [2.x.119] 来定义的参数数量。     
* 要了解预处理器如何将这个宏扩展为实际代码，请参考异常类的文档。简而言之，这个宏调用声明并定义了一个继承自ExceptionBase的类 [2.x.120] ，它实现了所有必要的错误输出功能。
*


* [1.x.75]

* 下面两个函数实现了上面描述的接口。第一个函数简单地实现了导言中描述的函数，而第二个函数使用了同样的技巧来避免调用虚函数，这在前面的例子程序中已经介绍过了。注意第二个函数中对参数的正确大小的检查，这种检查应该始终存在于这类函数中；根据我们的经验，许多甚至大多数编程错误都是由不正确的初始化数组、不兼容的函数参数等造成的；像本例中那样使用断言可以消除许多这样的问题。
*


* [1.x.76]
*
* 除了平流场，我们还需要两个描述源项（ [2.x.121] ）和边界值的函数。如介绍中所述，源是一个源点附近的常数函数，我们用常数静态变量[2.x.122]表示。我们使用与我们在[2.x.123]示例程序中所示相同的模板技巧来设置这个中心的值。其余的很简单，之前已经展示过了。
*


* [1.x.77]

* 这里唯一的新东西是我们检查[2.x.124]参数的值。由于这是一个标量函数，很明显，只有当所需分量的索引为0时才有意义，所以我们断言这确实是这样的情况。  [2.x.125]是一个全局预定义的异常（可能是最经常使用的异常，因此我们让它成为全局的，而不是某个类的局部），它接受三个参数：超出允许范围的索引，有效范围的第一个元素和超过最后一个的元素（即又是C++标准库中经常使用的半开区间）。
*


* [1.x.78]
*
* 最后为边界值，这只是从[2.x.126]基类派生的另一个类。
*


* [1.x.79]
*
* [1.x.80] [1.x.81]。



* 这里是这个程序的主类。它和以前的例子中的主类非常相似，所以我们再次只评论其中的区别。
*


* [1.x.82]

* 下一组函数将被用来组装矩阵。然而，与前面的例子不同，[2.x.127]函数不会自己做这些工作，而是将实际的装配工作委托给辅助函数 [2.x.128] 和 [2.x.129] 。其理由是，矩阵组装可以很好地并行化，因为每个单元上的局部贡献的计算完全独立于其他单元，我们只需要在将一个单元的贡献添加到全局矩阵中时进行同步。     
* 我们在这里选择的并行化策略是文档中[2.x.130]模块中详细提到的可能性之一。具体来说，我们将使用那里讨论的WorkStream方法。由于这个模块有很多文档，我们不会在这里重复设计选择的理由（例如，如果你读完上面提到的模块，你会明白[2.x.131]和[2.x.132]结构的目的是什么）。相反，我们将只讨论具体的实现。     
* 如果你阅读了上面提到的页面，你会发现为了使汇编并行化，我们需要两个数据结构
*
* - 一个是对应于我们在局部集成过程中需要的数据（"scratch data"，即我们只需要作为临时存储的东西），另一个是将局部集成的信息传递给函数，然后将局部贡献添加到全局矩阵的相应元素中。其中前者通常包含FEValues和FEFaceValues对象，而后者则有局部矩阵、局部右手边，以及关于哪些自由度生活在我们正在组装局部贡献的单元上的信息。有了这些信息，以下内容应该是相对不言自明的。
*


* [1.x.83]
*
* FEValues和FEFaceValues是很昂贵的设置对象，所以我们把它们包含在scratch对象中，以便尽可能多的数据在单元格之间被重复使用。
*


* [1.x.84]
*
* 我们还存储了一些向量，我们将在每个单元格上填充数值。在通常情况下，设置这些对象是很便宜的；但是，它们需要内存分配，这在多线程的应用程序中可能是很昂贵的。因此，我们把它们保存在这里，这样在一个单元格上的计算就不需要新的分配。
*


* [1.x.85]

* 最后，我们需要描述问题数据的对象。
*


* [1.x.86]
*
* 下面的函数又和以前的例子一样，后面的变量也是一样的。
*


* [1.x.87]
*
* [1.x.88] [1.x.89]。


*
* 现在，最后，这里有一个类，它将计算每个单元上的梯度的差分近似值，并以网格大小的幂数来衡量，如介绍中所述。这个类是库中[2.x.133]类的一个简单版本，它使用类似的技术来获得有限元场的梯度的有限差分近似值，或者更高一级的导数。   
* 该类有一个公共的静态函数[2.x.134]，被调用来计算误差指标的向量，还有一些私有函数，在所有活动单元上做实际工作。在库的其他部分，我们遵循一个非正式的惯例，使用浮点数向量作为误差指标，而不是常见的双数向量，因为对于估计值来说，额外的精度是没有必要的。   
* 除了这两个函数，该类还声明了两个异常，当一个单元在每个空间方向上都没有邻居时（在这种情况下，介绍中描述的矩阵将是奇异的，不能被倒置），而另一个异常用于更常见的函数参数无效的情况，即一个大小错误的向量。   
* 还有两点意见：首先，这个类没有非静态成员函数或变量，所以这不是一个真正的类，而是起到了C++中[2.x.135]的作用。我们选择类而不是命名空间的原因是，这样我们可以声明一些私有的函数。如果在命名空间的头文件中声明一些函数，并在实现文件中实现这些函数和其他函数，这也可以用命名空间来实现。没有在头文件中声明的函数仍然在名字空间中，但不能从外部调用。然而，由于我们这里只有一个文件，在目前的情况下不可能隐藏函数。   
* 第二个意见是，维度模板参数是附在函数上的，而不是附在类本身。这样，你就不必像其他大多数情况下那样自己指定模板参数，而是编译器可以从作为第一个参数传递的DoFHandler对象的尺寸中自己计算出它的值。   
* 在开始实施之前，让我们也来评论一下并行化策略。我们已经在上面这个程序的主类的声明中介绍了使用WorkStream概念的必要框架。我们将在这里再次使用它。在当前情况下，这意味着我们必须定义[2.x.136] [2.x.137]抓取和复制对象的类，[2.x.138] [2.x.139]一个在一个单元上进行局部计算的函数，以及[2.x.140] [2.x.141]一个将局部结果复制到全局对象的函数。[2.x.142] [2.x.143] 鉴于这个总体框架，我们将稍微偏离它。特别是，WorkStream一般是为以下情况而发明的：在一个单元上的每个局部计算[1.x.90]到一个全局对象上
*
* - 例如，在组装线性系统时，我们将局部贡献添加到全局矩阵和右手边。WorkStream的设计是为了处理多个线程试图同时进行这种添加的潜在冲突，因此必须提供一些方法来确保每次只有一个线程可以做这个。然而，这里的情况略有不同：我们单独计算每个单元的贡献，但随后我们需要做的是将它们放入每个单元独有的输出向量中的一个元素。因此，不存在来自两个单元的写操作可能发生冲突的风险，也没有必要使用WorkStream的复杂机制来避免冲突的写操作。因此，我们要做的就是这样。我们仍然需要一个持有例如 FEValues 对象的 scratch 对象。但是，我们只创建一个假的、空的拷贝数据结构。同样，我们确实需要计算本地贡献的函数，但由于它已经可以把结果放到最终位置，我们不需要一个从本地到全球的拷贝函数，而是给[2.x.144]函数一个空函数对象
*
* - 相当于一个NULL函数指针。
*


* [1.x.91]
*
* [1.x.92] [1.x.93]。



*
* 现在是主类的实现。构造函数、析构函数和函数[2.x.145]遵循之前使用的模式，所以我们不需要对这三个函数进行评论。
*


* [1.x.94]
*
* 在下面的函数中，矩阵和右手边被组装起来。正如上面主类的文档所述，它自己并不做这个，而是委托给接下来的函数，利用了 [2.x.146] 中讨论的WorkStream概念。   
* 如果你看了[2.x.147]模块，你会发现并行组装并不需要大量的额外代码，只要你努力描述从头开始和复制数据对象是什么，如果你为本地组装和从本地贡献到全局对象的复制操作定义了合适的函数。完成这些工作后，下面将完成所有繁重的工作，使这些操作在你的系统中有多少个内核的多线程上都能完成。
*


* [1.x.95]
*
* 如上所述，我们需要有抓取对象来进行局部贡献的并行计算。这些对象包含FEValues和FEFaceValues对象（以及一些数组），因此我们需要有构造函数和复制构造函数，以便我们能够创建它们。对于单元项，我们需要形状函数的值和梯度、正交点以确定给定点的源密度和平流场，以及正交点的权重乘以这些点的雅各布系数的行列式。相反，对于边界积分，我们不需要梯度，而是需要单元的法向量。这决定了我们必须将哪些更新标志传递给类的成员的构造函数。
*


* [1.x.96]
*
* 现在，这就是做实际工作的函数。它与以前的例子程序中的[2.x.148]函数没有什么不同，所以我们将再次只评论其中的差异。数学上的东西紧跟我们在介绍中所说的。   
* 不过，这里有一些值得一提的地方。首先，我们把FEValues和FEFaceValues对象移到ScratchData对象中。我们之所以这样做，是因为每次进入这个函数时，我们都要简单地创建一个。
*
*--即在每个单元格上。现在发现，FEValues类的编写目标很明确，就是将所有从单元格到单元格保持不变的东西都移到对象的构造中，每当我们移到一个新的单元格时，只在[2.x.149]做尽可能少的工作。这意味着在这个函数中创建这种新的对象将是非常昂贵的，因为我们必须为每一个单元做这件事
*
* 这正是我们想用FEValues类来避免的事情。相反，我们所做的是在抓取对象中只创建一次（或少数几次），然后尽可能多地重复使用它。   
* 这就引出了一个问题：我们在这个函数中创建的其他对象，与它的使用相比，其创建成本很高。事实上，在函数的顶部，我们声明了各种各样的对象。[2.x.150] , [2.x.151]的创建成本并不高，所以这里没有什么危害。然而，在创建[2.x.152]和下面类似的变量时，分配内存通常会花费大量的时间，而只是访问我们存储在其中的（临时）值。因此，这些将是移入[2.x.153]类的候选者。我们将把这作为一个练习。
*


* [1.x.97]
*
* 我们定义了一些缩略语，以避免不必要的长行。
*


* [1.x.98]
*
* 我们声明单元格矩阵和单元格右侧...
*


* [1.x.99]
*
* ... 一个数组，用于保存我们目前正在处理的单元格的自由度的全局索引...
*


* [1.x.100]
*
* ... 然后初始化 [2.x.154] 对象...
*


* [1.x.101]
*
* ... 获得正交点的右手边和平流方向的数值...
*


* [1.x.102]
*
* ... 设置流线扩散参数的值，如介绍中所述...
*


* [1.x.103]
*
* ......并按照上面所讨论的那样，把对系统矩阵和右手边的局部贡献集合起来。
*


* [1.x.104]
*
* 别名AssemblyScratchData对象，以防止行数过长。
*


* [1.x.105]
*
* 除了我们现在建立的单元项，本问题的双线性形式还包含域的边界上的项。因此，我们必须检查这个单元的任何一个面是否在域的边界上，如果是，也要把这个面的贡献集合起来。当然，双线性形式只包含来自边界[2.x.155]部分的贡献，但要找出本单元某个面的某一部分是否属于流入边界，我们必须有关于正交点的确切位置和该点的流动方向的信息；我们使用FEFaceValues对象获得这些信息，只在主循环中决定某个正交点是否位于流入边界。
*


* [1.x.106]
*
* 好的，当前单元的这个面是在域的边界上。就像我们在以前的例子中和上面使用的通常的FEValues对象一样，我们必须为现在的面重新初始化FEFaceValues对象。
*


* [1.x.107]
*
* 对于手头的正交点，我们要求提供流入函数的值和流动方向。
*


* [1.x.108]
*
* 现在在所有正交点上循环，看看这个面是在边界的流入部分还是流出部分。法向量指向单元外：由于这个面在边界上，法向量指向域外，所以如果平流方向指向域内，它与法向量的标量积一定是负的（要知道为什么这是真的，请考虑使用余弦的标量积定义）。
*


* [1.x.109]
*
* 如果该面是流入边界的一部分，那么计算该面对全局矩阵和右手边的贡献，使用从FEFaceValues对象获得的值和在介绍中讨论的公式。
*


* [1.x.110]
*
* 复制程序需要的最后一条信息是这个单元上自由度的全局索引，所以我们最后把它们写到本地数组中。
*


* [1.x.111]
*
* 我们需要写的第二个函数是将前一个函数计算出的本地贡献（并放入AssemblyCopyData对象中）复制到全局矩阵和右边的矢量对象中。这基本上就是我们在每个单元上装配东西时，一直作为最后一块代码的东西。因此，下面的内容应该是很明显的。
*


* [1.x.112]

* 这里是线性求解程序。由于系统不再像以前的例子那样是对称正定的，我们不能再使用共轭梯度法。相反，我们使用了一个更通用的解算器，不依赖于矩阵的任何特殊属性：GMRES方法。GMRES和共轭梯度法一样，需要一个合适的预处理程序：我们在这里使用雅可比预处理程序，它对这个问题足够好。
*


* [1.x.113]
*
* 下面的函数根据介绍中描述的数量来细化网格。各自的计算是在 [2.x.156] 类中进行的。
*


* [1.x.114]
*
* 这个函数与第6步中的函数类似，但由于我们使用的是高阶有限元，所以我们以不同的方式保存解决方案。像VisIt和Paraview这样的可视化程序通常只能理解与节点相关的数据：它们不能绘制五度基函数，这导致我们计算的解的图片非常不准确。为了解决这个问题，我们为每个单元保存了多个[2.x.157]补丁[2.x.158]：在二维中，我们为每个单元在VTU文件中保存64个双线性 "单元"，在三维中，我们保存512个。最终的结果是，可视化程序将使用立方体基础函数的片状线性插值：这捕捉到了解决方案的细节，并且在大多数屏幕分辨率下，看起来很平滑。我们在一个单独的步骤中保存网格，没有额外的补丁，这样我们就有了细胞面的视觉表现。   
* 9.1版的deal.II获得了写高阶多项式的能力（即为我们的逐项二元解写逐项二元可视化数据）VTK和VTU输出：然而，并非所有最新版本的ParaView和Viscit（截至2018年）都能读取这种格式，所以我们在这里使用更古老、更通用（但效率较低）的方法。
*


* [1.x.115]
*
* VTU输出可能很昂贵，无论是计算还是写入磁盘。这里我们要求ZLib，一个压缩库，以最大限度地提高吞吐量的方式来压缩数据。
*


* [1.x.116]
*
* ... 如同主循环（设置
*
* -解决
*
* - 精炼），除了循环次数和初始网格之外。
*


* [1.x.117]
*
* [1.x.118] [1.x.119]。


*
* 现在是对[2.x.159]类的实现。让我们从定义[2.x.160]类的构造函数开始，该函数被[2.x.161]使用。
*


* [1.x.120]
*
* 我们分配一个向量来容纳一个单元的所有活动邻居的迭代器。我们保留活动邻居的最大数量，以避免以后的重新分配。请注意这个活动邻居的最大数量是如何计算出来的。
*


* [1.x.121]

* 接下来是对[2.x.162]类的实现。第一个函数除了将工作委托给另一个函数外，并没有做什么，但在顶部有一点设置。   
* 在开始工作之前，我们要检查写入结果的向量是否有正确的大小。在编程中，忘记在调用地点正确确定参数大小的错误是很常见的。因为没有抓住这些错误所造成的损失往往是微妙的（例如，内存中某个地方的数据损坏，或者是无法重现的结果），所以非常值得努力去检查这些东西。
*


* [1.x.122]
*
* 这里有一个函数，通过计算梯度的有限差分近似值来估计局部误差。该函数首先计算当前单元的活动邻居列表，然后为每个邻居计算介绍中描述的数量。之所以有这样的顺序，是因为在局部细化网格的情况下，要找到一个给定的邻居不是一蹴而就的事情。原则上，一个优化的实现可以在一个步骤中找到邻域和取决于它们的量，而不是先建立一个邻域列表，然后在第二步中找到它们的贡献，但是我们很乐意将此作为一个练习。正如之前所讨论的，传递给[2.x.163]的工作函数在 "scratch "对象上工作，该对象保留所有的临时对象。这样，我们就不需要在每次为给定单元调用工作的函数内创建和初始化那些昂贵的对象了。这样的参数被作为第二个参数传递。第三个参数将是一个 "copy-data "对象（更多信息见[2.x.164]），但我们在这里实际上没有使用这些对象。由于[2.x.165]坚持传递三个参数，我们声明这个函数有三个参数，但简单地忽略了最后一个参数。   
*（从美学角度看，这是不令人满意的。它可以通过使用一个匿名（lambda）函数来避免。如果你允许的话，让我们在这里展示一下如何做。首先，假设我们已经声明这个函数只接受两个参数，省略了未使用的最后一个参数。现在，[2.x.166]仍然想用三个参数来调用这个函数，所以我们需要找到一种方法来 "忘记 "调用中的第三个参数。简单地像上面那样把指针传给[2.x.167]这个函数并不能做到这一点
*
* - 编译器会抱怨说，一个声明为有两个参数的函数被调用时有三个参数。然而，我们可以通过将以下内容作为第三个参数传递给[2.x.168] [2.x.169]来做到这一点，这并不比下面实现的解决方案好多少：要么例程本身必须带三个参数，要么它必须被带三个参数的东西所包裹。我们不使用这种方法，因为在开始时添加未使用的参数更简单。   
* 现在说说细节。
*


* [1.x.124]
*
* 我们需要为张量[2.x.170]提供空间，它是Y向量的外积之和。
*


* [1.x.125]
*
* 首先初始化[2.x.171]对象，以及[2.x.172]张量。
*


* [1.x.126]
*
* 现在，在我们继续之前，我们首先计算当前单元的所有活动邻居的列表。我们首先在所有面上进行循环，看看那里的邻居是否是活跃的，如果它与本单元在同一层次或更粗一级，就会出现这种情况（注意，一个邻居只能比本单元粗一次，因为在deal.II中我们只允许在一个面上有一个最大的细化的差异）。另外，邻居也可能在同一级别，并被进一步细化；然后我们必须找到它的哪些子单元紧挨着现在的单元，并选择这些子单元（注意，如果一个活动单元的邻居的子单元紧挨着这个活动单元，由于上面提到的一个细化规则，它本身也需要是活动的）。     
* 在一个空间维度上，情况略有不同，因为在那里不存在单精化规则：相邻的活动单元可以在任意多的精化级别上有所不同。在这种情况下，计算变得有点困难，但我们将在下面解释。     
* 在开始对当前单元的所有邻域进行循环之前，我们当然要清除存储活动邻域的迭代器的阵列。
*


* [1.x.127]
*
* 首先定义面的迭代器和邻居的缩写
*


* [1.x.128]
*
* 然后检查该邻居是否是活动的。如果是，那么它就在同一层或更粗的一层（如果我们不是在1D中），而且我们在任何情况下都对它感兴趣。
*


* [1.x.129]
*
* 如果邻居没有活动，那么就检查它的子女。
*


* [1.x.130]
*
* 要找到与本单元相邻的子单元，如果我们在本单元的左边（n==0），就依次去找其右边的子单元，如果我们在右边（n==1），就依次去找左边的子单元，直到找到一个活动单元。
*


* [1.x.131]
*
* 由于这使用了一些非微妙的几何直觉，我们可能想检查一下我们是否做对了，也就是说，检查我们找到的单元格的邻居是否确实是我们目前正在处理的单元格。像这样的检查通常是有用的，并且经常发现像上面这一行的算法（不由自主地交换[2.x.173]或类似的算法是很简单的）和库中的错误（上面的算法所依据的假设可能是错误的，记录错误，或者由于库中的错误而被违反）。原则上，我们可以在程序运行一段时间后删除这种检查，但是无论如何，留下它来检查库中或上述算法中的变化可能是一件好事。                   
* 请注意，如果这个检查失败了，那么这肯定是一个无法恢复的错误，而且很可能被称为内部错误。因此，我们使用一个预定义的异常类来抛出这里。
*


* [1.x.132]
*
* 如果检查成功，我们就把刚刚发现的活动邻居推到我们保留的堆栈中。
*


* [1.x.133]
*
* 如果我们不在1d中，我们收集所有 "在 "当前面的子面后面的邻居子，然后继续前进。
*


* [1.x.134]
*
* 好了，现在我们有了所有的邻居，让我们开始对他们每个人进行计算。首先，我们做一些预备工作：找出本单元的中心和这一点上的解。后者是以正交点的函数值向量的形式得到的，当然，正交点只有一个。同样地，中心的位置是实空间中第一个（也是唯一的）正交点的位置。
*


* [1.x.135]
*
* 现在在所有活动邻居中循环，收集我们需要的数据。
*


* [1.x.136]
*
* 然后得到邻接单元的中心和该点的有限元函数的值。注意，为了这个信息，我们必须重新初始化邻近单元的[2.x.174]对象。
*


* [1.x.137]
*
* 计算连接两个单元中心的向量[2.x.175]。注意，与介绍不同，我们用[2.x.176]表示归一化的差分向量，因为这是计算中到处使用的数量。
*


* [1.x.138]

* 然后把这个单元格对Y矩阵的贡献加起来......
*


* [1.x.139]
*
* ... 并更新差额商数之和。
*


* [1.x.140]
*
* 如果现在，在收集了来自邻居的所有信息后，我们可以确定当前单元的梯度的近似值，那么我们需要经过跨越整个空间的向量[2.x.177]，否则我们就不会有梯度的所有成分。这是由矩阵的可倒置性表明的。     
* 如果矩阵不可逆，那么本单元的活动邻居数量不足。与之前所有的情况（我们提出了异常）相比，这不是一个编程错误：这是一个运行时错误，即使在调试模式下运行良好，也会在优化模式下发生，所以在优化模式下尝试捕捉这个错误是合理的。对于这种情况，有一个[2.x.178]宏：它像[2.x.179]宏一样检查条件，但不仅仅是在调试模式下；然后输出一个错误信息，但不是像[2.x.180]宏那样中止程序，而是使用C++的[2.x.181]命令抛出异常。这样一来，人们就有可能捕捉到这个错误，并采取合理的应对措施。其中一个措施是全局性地细化网格，因为如果初始网格的每个单元都至少被细化过一次，就不会出现方向不足的情况。
*


* [1.x.141]
*
* 另一方面，如果矩阵是可反转的，那么就反转它，用它乘以其他数量，然后用这个数量和正确的网格宽度的幂来计算估计误差。
*


* [1.x.142]

* 这个函数的最后一部分是把我们刚刚计算出来的内容写入输出向量的元素中。这个向量的地址已经存储在scratch数据对象中，我们所要做的就是知道如何在这个向量中获得正确的元素
*
* 但我们可以问一下我们所在的单元格是第多少个活动单元格，这样做。
*


* [1.x.143]
*
* [1.x.144] [1.x.145]。


*
* [2.x.182]函数与前面的例子类似。主要区别是我们使用MultithreadInfo来设置最大的线程数（更多信息请参见文档模块[2.x.183] "多处理器访问共享内存的并行计算"）。使用的线程数是环境变量DEAL_II_NUM_THREADS和 [2.x.184] 的参数中的最小值。如果没有给 [2.x.185] 的值，则使用英特尔线程构建块（TBB）库的默认值。如果省略了对 [2.x.186] 的调用，线程的数量将由 TBB 选择，与 DEAL_II_NUM_THREADS无关。
*


* [1.x.146]
* [1.x.147][1.x.148] 。



* 这个程序的结果并不特别引人注目。它们由控制台输出、一些网格文件和每个网格的解决方案组成。首先是控制台的输出。
* [1.x.149]
*
* 相当多的单元格被用在最精细的层面上，以解决解决方案的特征。下面是第四和第十个网格。[2.x.187]和第四和第十个解决方案。[2.x.188]以及放大的网格和解决方案。[2.x.189]
* 解决方案是由从左、下边界到右上方的蠕动对流场所产生的部分，以及由左下角的源所产生的部分，以及其结果也是沿途传输的。上面显示的网格很适合解决这些特征。图中的比较表明，即使我们使用的是高阶近似，我们仍然需要自适应的网格细化来完全解决摆动的问题。
*

* [1.x.150][1.x.151][2.x.190] 。
* [0.x.1]

include/deal.II-translator/A-tutorial/tutorial_0.txt
[0.x.0]*
  [2.x.0]
* 初次接触deal.II？你可能想从教程[2.x.1]开始，一直到[2.x.2] 。在这一点上，你可以探索你感兴趣的功能，看看下面列出的大量程序。
* 交易.II教程包含了一系列的程序，每个程序都或多或少地建立在以前的程序之上，这些程序展示了库的各个方面。每个这样的例子都有以下结构。  [2.x.3] [2.x.4] [1.x.0] 程序的作用，包括数学模型，以及哪些编程技术是新的。    [2.x.5] [1.x.1] 广泛记录的源代码清单。    [2.x.6] [1.x.2] 程序的输出，包括注释和解释。    [2.x.7] [1.x.3] 剥去所有注释的源代码。  [2.x.8] 你可以浏览现有的教程程序[2.x.9] [2.x.10] 作为[1.x.4][1.x.5]，它显示了每个教程程序的主要概念是如何建立在以前的程序之上的（尽管每个程序也可能使用其他程序的次要部分，但没有特别的
* 在图中连接）。)    [2.x.11]如同[1.x.6][1.x.7]，提供每个程序的简短概要。    [2.x.12]或[1.x.8][1.x.9]。  [2.x.13]
* 这些程序在你本地deal.II安装的[2.x.14]目录下。在编译库本身之后，如果你进入其中一个教程目录，你可以通过输入 [2.x.15] 来配置程序，并使用 [2.x.16] 运行它。后面的命令也会编译程序，如果还没有完成的话。不同目录中的CMakeLists.txt文件是基于[1.x.10]的。
*

*
* [2.x.17] 一些教程的程序也共同组成了[1.x.11]。比起构成教程的程序，更多的，通常是更复杂的，但不太完善的，基于deal.II的程序也可以在 [2.x.18] 中找到。
*

* [1.x.12] [2.x.19] TutorialConnectionGraph [1.x.13]。
* 下图显示了教程程序之间的联系，以及它们的主要组成部分是如何相互建立的。点击任何一个方框都可以进入其中一个程序。如果你将鼠标指针悬停在一个方框上，就会出现该程序的简要描述。


* [1.x.14]
* [1.x.15]<br />


* [1.x.16]
* [1.x.17] [1.x.18]
* [2.x.20]


* [1.x.19] [1.x.20]
* [1.x.21][1.x.22] [2.x.21] [1.x.23][1.x.24] [2.x.22] [1.x.25][1.x.26] [2.x.23]


* [1.x.27][1.x.28] [2.x.24] 。



* [1.x.29][1.x.30] [2.x.25] 。



* [1.x.31][1.x.32] [2.x.26] 。
* [0.x.1]


