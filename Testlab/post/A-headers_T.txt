include/deal.II-translator/A-headers/automatic_and_symbolic_differentiation_0.txt
[0.x.0]*



* [2.x.0]


*
* [2.x.1]对自动和符号微分。
* 下面我们将非常简要地介绍什么是自动微分和符号微分，这些计算/数字方案有哪些变化，以及它们是如何被整合到deal.II的框架中的。所有这些方案的目的是在不想手工计算的情况下自动计算函数的导数或其近似值。常见的例子是，在有限元背景下，人们想解决一个非线性问题，要求一些残差[2.x.2]，其中[2.x.3]是一个复杂的函数，需要进行微分以应用牛顿方法；以及人们得到一个与参数有关的问题[2.x.4] 并希望对参数[2.x.5]形成导数的情况，例如，为了优化[2.x.6]的输出函数，或为了进行[2.x.7]的敏感性分析。我们应该把[2.x.8]看作是设计参数：例如，机翼的宽度或形状，选择用来建造物体的材料的硬度系数，发送到设备的功率，发送到燃烧器的气体的化学成分。在所有这些情况下，人们应该把[2.x.9]和[2.x.10]看作是[1.x.0]，并且繁琐地加以区分
*
* - 至少在手工操作时是这样。[2.x.11]中显示了一个相对简单的非线性问题的案例，它已经突出了手工计算导数的繁琐。然而，在现实中，人们可能会想到诸如化学反应流等问题，其中流体方程的系数，如密度和粘度，强烈地、非线性地依赖于流体在每一点的化学成分、温度和压力；化学物种根据反应系数相互反应，而反应系数也非线性地、复杂地依赖于化学成分、温度和压力。在许多情况下，所有这些系数的精确公式可能要花几行字才能写出来，可能包括几个非线性项的指数和（谐波或几何）平均值，和/或可能包含数据点之间的表格查询和内插。仅仅把这些项写对就已经很困难了；计算这些项的导数在大多数应用中是不切实际的，在现实中是不可能写对的。如果没有计算机的帮助，更高一级的导数就更不可能做到。自动或符号微分是解决这个问题的一个方法。我们只需要实现一次计算这些系数的输入的函数，就可以得到（正确的！）导数，而不需要进一步的编码工作（尽管在运行时、编译时或两者都有不可忽略的计算成本）。
*



*
* [2.x.12] auto_diff_1 自动微分法
* [1.x.1] （通常也被称为算法微分），是一种数字方法，可以用来 "自动 "计算函数对一个或多个输入变量的一阶，或许还有高阶导数。虽然这需要一定的计算成本，但使用这种工具的好处可能是巨大的。如果使用得当，通常复杂的函数的导数可以被计算得非常精确。尽管这些框架所能达到的确切精度在很大程度上取决于它们的基础数学公式，但一些实现方式的计算精度与机器精度相当。请注意，这与经典的数值微分（例如，通过在不同的点上对一个函数进行评估，使用有限差分近似）不同，后者的精度取决于扰动的大小以及所选择的有限差分方案；这些方法的误差要明显大于表述良好的自动微分方法。
* 那么，在有限元背景下使用自动微分的三个实际例子将是
*


*
* - 快速建立一个新的非线性公式的原型，而不需要手工计算线性化本身。
*


*
* - 在复杂的多物理学框架内自动线性化有限元残差加法形成，以及



*
* - 验证用户对基于单元的计算（如残差）和基于连续点的计算（如非线性构成法的切线）的线性化实施。
* 有相当多的自动微分数字的实现方法。它们主要分为两大类，即 [2.x.13] 源代码转换 [2.x.14] 和 [2.x.15] 操作符重载 [2.x.16] 。第一种方法是根据一些输入函数生成新的、可编译的代码，当执行时，返回输入函数的导数。第二种方法是利用<tt>C++</tt>操作符定义的能力，为自定义类的类型进行重载。因此，一个代表这样一个可自动微分的数字的类，在对它进行每一次数学运算后，原则上可以评估和跟踪它的值以及它的方向性导数。由于专门实现[2.x.17]源代码转换[2.x.18]方法的库共同描述了高度专业化的工具，作为函数预处理器使用，它们在deal.II本身没有直接支持。然而，后者代表了专门的数字类型，可以通过在适当的环境中使用模板元编程来支持。鉴于上面的例子，这意味着FEValues类（和朋友），以及Tensor和SymmetricTensor类应该支持用这些专门的数字进行计算。理论上，整个程序都可以被做成可微调的。例如，这在解决方案对输入参数的敏感性分析中可能是有用的。然而，到目前为止，这还没有被测试过）。)
* 基于[2.x.19]运算符重载[2.x.20]的专门框架的实现通常分为三类之一。在每一类中，一些定制的数据类代表了被评估函数的浮点值和它的导数，由
*


*
* - 利用[2.x.21]对偶[2.x.22]/[2.x.23]复杂步骤[2.x.24]/[2.x.25]超对偶[2.x.26]公式（有时也称为[2.x.27]无磁带[2.x.28]方法）。
*


*
* - 那些利用[2.x.29]拍打[2.x.30]的策略，以及
*


*
* - 那些通过[2.x.31]表达式模板[2.x.32]使用的编译时优化。
* 为了初步了解这些不同的实现方式在实践中可能是什么样的，我们对这些方法做了如下的一般性总结。
*


*
* - 上面列出的前两种[2.x.33]无龙头[2.x.34]方法（对偶数和复数步法）使用截断泰勒级数的某种变化，以及对扰动参数定义的特殊选择，用基于有限差分的方法来计算函数导数。双重 "数构成了在函数值被评估时同时计算的累积方向导数；在复数步法中，虚值有效地起到了这个作用。扰动参数的选择决定了方案的数值质量，例如泰勒方案截断的影响；对偶数在其一阶导数中不包含任何高阶项，而对于复数阶方法，这些存在的高阶项被忽略了。可以证明，这两种方法都不受减法取消误差的影响，而且在其有限差分方案中，它们在数值上对为数值扰动选择的内部[2.x.35]大小不敏感。因此，对偶数方法产生精确的一阶导数，而复数步骤近似法则不能。然而，对偶数的标准实现不能产生精确的二阶导数值。超对偶数对这一想法有不同的看法，数字以类似于四元数的形式表示（即带有额外的非实数成分），导数由泰勒级数所有四个成分的高阶截断来计算。其结果是，通过适当的实现，第一和第二导数都可以准确计算出来。
*



* - 使用[2.x.36]磁带[2.x.37]方法，选择一个指定的代码子区域，对该区域所有用活动（标记）输入变量执行的操作进行跟踪并记录在一个被称为磁带的数据结构中。在磁带区域结束时，可以通过用不同的输入变量集 "重放 "磁带来重新评估所记录的函数，而不是直接重新计算该函数。假设录音区域代表一个平滑的函数，那么该函数的任意高阶导数可以通过参考跟踪和存储在磁带上的代码路径来计算。    例如，这可以通过对感兴趣点周围的函数进行评估来实现）。有一些策略可以处理这样的情况：在被评估的点上，所录取的函数是不平滑的，或者它不是分析的。此外，我们可能需要考虑分支函数的情况，即磁带不再是连续的，而是在不同的评估路径上分叉，而这是由于最初记录的输入。
*


*
* - 基于[1.x.2]的方法利用了由抽象语法树（AST）构建的计算图（在这种情况下是[1.x.3]），该图从其输入值中解析出函数输出。    树上最外层的叶子代表独立变量或常数，并由单数运算符转换，由二进制运算符连接（在最简单的情况下）。因此，在编译时，对函数输入进行的操作是已知的，与此相关的导数操作也可以同时使用众所周知的计算运算导数的规则（如加减法下导数的关联性、乘积规则和连锁规则）来定义。这个运算器返回的编译输出类型不需要是通用的，而是可以根据DAG顶点上给该特定运算器的特定输入（可能携带微分历史）进行专业化。通过这种方式，可以为用于评估依赖函数的每个中间结果的非常专门的个别操作生成一套编译时优化的指令。
* 当然，这些方法中的每一种都有其优点和缺点，对于要解决的特定问题，其中一种可能比另一种更合适。由于上述实施细节（以及其他未讨论的细节）可能对用户是隐藏的，因此了解使用这些 "黑盒子 "自动差分数字中的任何一个的影响、运行时间成本和潜在的限制可能仍然很重要。
* 除了所提供的链接文章外，用于提供这里所提供的细节的资源包括。
*


* [1.x.4]

*


* [1.x.5]
*
* # ###利用链式定律
* 在最实际的意义上，上述任何一类都是利用链式规则来计算复合函数的总导数。为了执行这个动作，它们通常使用两种机制中的一种来计算导数，具体是
*


*
* - [2.x.38]正向模式[2.x.39]（或[2.x.40]正向积累[2.x.41]）自动分化，或
*


*
* - [2.x.42]反向模式[2.x.43]（或[2.x.44]反向积累[2.x.45]）自动差分。
* 值得注意的是，[2.x.46]最优雅各布积算[2.x.47]，执行一组最小的计算，位于这两种极限情况之间。它对一般复合函数的计算仍然是图论中的一个公开问题。
* 借助于下面的图表（它和一些列出的细节由这个[1.x.6]提供），让我们思考一下函数[2.x.48]及其导数的计算的代表性。
* [2.x.49] [2.x.50] </div> [2.x.51] [2.x.52] </div> </div>
* 具体来说，我们将简要介绍什么是正向和反向的自动差分。请注意，在图中，沿着文字图形的边缘是函数 [2.x.53] 相对于 [2.x.54] -个变量的定向导数，用符号 [2.x.55] 表示。在这个例子中，用于呈现函数值及其方向导数的具体计算方法在[1.x.7]中列出。对于第二个说明性例子，我们请感兴趣的读者参考[1.x.8]。
* 首先考虑任何复合函数[2.x.56]，这里表示为有两个独立变量，可以剖析为其基本函数[1.x.9]的组合。 如前所述，如果每个原始运算[2.x.57]都是平滑的和可微的，那么可以普遍采用链式规则来计算[2.x.58]的总导数，即[2.x.59]。区分 "正向 "和 "反向 "模式的是链规的评估方式，但最终都是计算总导数[1.x.10] 。
* 在正向模式下，链式规则是自然地从 "内向外 "计算的。因此自变量是固定的，每个子函数[2.x.60]被递归计算，其结果作为输入返回给父函数。使用圆括号封装和固定操作顺序，这意味着我们计算[1.x.11] 前向扫频的计算复杂性与输入函数的计算复杂性成正比。然而，对于每一个需要计算的方向性导数，都需要对计算图进行一次扫频。
* 在反向模式下，链式规则的计算有点不自然地从 "外向内 "进行。因变量的值首先被计算和固定，然后前面的微分运算被评估并与之前的结果从左到右连续相乘。同样，如果我们用括号封装和固定运算顺序，这意味着反向计算是由[1.x.12]进行的。中间值[2.x.61]被称为[2.x.62]邻接[2.x.63]，必须在计算图被遍历时计算和储存。然而，对于每个从属标量函数来说，计算图的一次扫描就能一次性呈现所有的方向性导数。
* 总的来说，每种模式的效率是由独立（输入）变量和从属（输出）变量的数量决定的。如果输出的数量大大超过输入，那么可以证明正向模式比反向模式的效率更高。反之，当输入变量的数量大大超过输出变量的数量时，也是如此。这一点可以用来帮助告知哪种数字类型最适合于使用自动微分进行的哪组操作。例如，在许多需要计算二阶导数的应用中，结合反向和正向模式是合适的。前者通常用于计算第一导数，后者用于计算第二导数。
*

*
* [2.x.64] auto_diff_1_1 支持的自动区分库
* 我们目前有以下数字类型和组合的验证实现。
*


*


*
* - 录音的ADOL-C（理论上是可微分的，但将实现多达二阶导数的内部驱动）。
*


*


*
* - 无带子的ADOL-C（一旦可区分）。
*


*


*
* - 使用表达式模板进行动态内存分配的前向模式Sacado（一旦可区分）。
*


*


*
* - 使用表达式模板的嵌套正向模式Sacado（可两次微分）。
*


*


*
* - 反向模式的萨卡多（一旦可微调）。
*


*


*
* - 嵌套的反向和动态分配的正向模式Sacado（两次可微分，但结果是内存泄漏，在[2.x.65]中描述的
* 注意，在上面，"动态内存分配 "是指在编译时不需要指定独立变量的数量。
* [1.x.13]中的
*


* [1.x.14]
*
*提供了对其有带和无带实现的原则性见解，以及如何将ADOL-C纳入用户代码中。为了解ADOL-C的实现，以及如何在数字代码中使用它的可能性，一些进一步的有用资源包括。
*


* [1.x.15]



* [1.x.16]



* [1.x.17]



* [1.x.18]
*
* 同样，为了解Sacado数字类型的实现（特别是表达式模板的使用和利用），选择了一些有用的资源，包括：*。
*


* [1.x.19]



* [1.x.20]



* [1.x.21]
*
* 正向和反向模式的Sacado数字的实现是相当复杂的。从Trilinos 12.12开始，数学运算的实现涉及大量的预处理指令和宏编程。因此，代码可能难以理解，而且这些类也不存在有意义的配套文档。因此，理解这些数字的原理实现的有用资源可以在[1.x.22]中找到，它概述了一个不使用表达式模板的正向模式自动差分数字的参考（尽管据说效率很低）实现。虽然没有明确说明，但[2.x.66]类似乎是按照双数的精神实现的）。
*

*
* [2.x.67] auto_diff_1_2 自动微分是如何集成到deal.II的？
* 由于每个自动分化库的接口都有很大的不同，所以在不久的将来会建立一个统一的内部接口来连接每个数字。目标将是让一些驱动类（提供核心功能，以后将在下一节介绍）有一个一致的机制与不同的自动区分库互动。具体来说，它们需要能够正确地初始化和最终确定将被解释为公式的因变量和自变量的数据。
* 实现支持的自动差分数字的接口的文件摘要如下。
*


*
* - ad_drivers.h:提供作为内部支持的自动区分库接口的驱动的类。这些在内部被用作我们提供的帮助类的中介。
*


*
* - ad_helpers.h:提供了一系列的类来帮助在一些不同的情况下进行自动区分。这些详见 [2.x.68] 。
*


*
* - ad_number_types.h:引入了一个枚举（称为类型代码），用于驱动类将支持的可自动区分的数字组合。   下面将讨论使用这种有点限制性的机制的理由。
*


*
* - ad_number_traits.h:声明一些为每个自动区分库和/或数字类型专用的内部类。这些随后被用来通过NumberTraits和ADNumberTraits类提供一个统一的接口，这些类在整个驱动中被广泛使用。我们还提供了一些机制来轻松查询这些数字的选择属性，即一些类型特征。
*


*
* - adolc_math.h:对ADOL-C数学运算的扩展，使这些数字在整个库中得到一致使用。
*


*
* - adolc_number_types.h:实现内部类，定义我们如何使用ADOL-C数字。
*


*
* - adolc_product_types.h:定义了一些乘积和标量类型，允许与Tensor和SymmetricTensor类一起使用ADOL-C数字。
*


*
* - sacado_math.h:对Sacado数学运算的扩展，使这些数字在整个库中被一致使用。
*


*
* - sacado_number_types.h:实现内部类，定义我们如何使用支持的Sacado数字。
*


*
* - sacado_product_types.h:定义了一些乘积和标量类型，允许与Tensor和SymmetricTensor类一起使用支持的Sacado数。
* 通过对每个支持的数字类型使用类型代码，我们人为地限制了可以在库中使用的可自动区分的数字类型。这种设计选择是由于确保每个数字类型被正确初始化，以及所有嵌套（模板化）类型的组合对库中执行的所有操作保持有效并不是一件小事。此外，库中还有一些冗长的函数，这些函数是为支持的数字类型而实例化的，并且有内部检查，只有在使用库所知道的可自动区分的数字时才会满足。这再次确保了所有计算的完整性得到维护。最后，使用一个简单的枚举作为类模板参数，最终使得在生产代码中切换使用的类型变得非常容易，几乎不需要对用户代码进行进一步的修改。
* [2.x.69] auto_diff_1_3 自动分化库的用户接口
* deal.II库为我们支持的自动区分库提供了一个统一的接口。到目前为止，已经为以下情况开发了帮助类。
*


*
* - 设计用于在正交点水平（或任何一般连续点）操作的类。



*


*


*
* - [2.x.70] %一个标量值函数的微分。       一个典型的用途是直接从应变能量函数中开发构成法。在[2.x.71]中给出了这种确切使用情况的一个例子。
*


*


*


*
* - [2.x.72] %对矢量值函数进行微分。       这可用于构成法的运动变量的线性化，或协助解决局部内部变量的进化方程。
*


*
* - 设计用于在细胞水平上操作的类。
*


*


*


*
* - [2.x.73] %标量值能量函数的微分，如可能产生于变分公式。这个类别的一个例子是在 [2.x.74] 中使用的。
*


*


*


*
* - [2.x.75] 矢量值的有限元残差的差异化，导致其一致的线性化。  [2.x.76]也提供了一个关于如何使用这个类的演示。
* 当然，用户也可以自己管理初始化和导数计算。
* 关于如何使用ADOL-C的最新例子可以在以下文献中找到
*


*
* - 他们的[1.x.23]。
*


*
* - 他们的[1.x.24]，和
*


*
* - 我们的[1.x.25]。
* 而对于萨卡多来说，说明性的例子可以在下面找到
*


*
* - 他们的[1.x.26]。
*


*
* - 一个[1.x.27]，和
*


*
* - 我们的[1.x.28]。
*



*
* [2.x.77] symb_diff_1 符号表达式和微分法
* [1.x.29]就其设计和使用而言，与自动微分完全不同。任何符号库的基础都是一个计算机代数系统（CAS），它实现了一种语言和一系列的算法来操作符号（或 "类字符串"）表达。从哲学的角度来看，这与手工进行代数运算的方式最为相似。
* 为了帮助更好地区分符号微分和自动微分等数值方法，让我们考虑一个非常简单的例子。假设函数 [2.x.78] ，其中 [2.x.79] 和 [2.x.80] 是相互独立的变量。通过应用连锁法则，这个函数的导数只是 [2.x.81] 和 [2.x.82] 。这些正是你在定义符号变量`x`和`y`，定义符号表达式`f = pow(2x+1, y)`并计算导数`diff(f, x)`和`diff(f, y)`后从CAS得到的结果。在这一点上，没有假设`x'和`y'代表什么；它们以后可能被解释为普通（标量）数、复数或其他一些幂函数和自然对数函数被定义好的东西。很明显，这意味着也没有关于哪一点来评估表达式或其导数的假设。我们可以很容易地将[2.x.83]的表达式在[2.x.84]处评估，然后再在不重新计算导数表达式本身的情况下，在[2.x.85]处评估。事实上，任何符号变量或表达式的解释，以及变量之间的相互依赖关系，都可以在它们的操作过程中的任何时候被定义或重新定义；这导致了计算的灵活性，这是自动差分所不能比拟的。例如，我们可以执行永久替换[2.x.86]，然后针对[2.x.88]的几个不同值重新计算[2.x.87]。我们也可以事后表达`x`和`y`之间的相互依赖关系，如[2.x.89] 。对于这种情况，这意味着最初计算的导数[2.x.90]和[2.x.91]真正代表了部分导数而不是总导数。当然，如果在计算导数[2.x.92]和[2.x.93]之前明确定义了这样的相互依赖关系，那么这可能对应于总导数（这也是自动差分在这个例子中唯一能够实现的结果）。
* 由于复杂的CAS构成了符号操作的基础，操作类型不一定只限于微分，而是可能跨越与离散微分计算、纯数学主题等相关的操作范围。[1.x.30]库的文档给出了大量的例子，突出了一个成熟的CAS的能力。通过[2.x.94]类和[2.x.95]命名空间中的相关函数，我们为高性能的[1.x.31]符号操作库提供了一个封装，它具有丰富的运算符重载和一致的界面，使其易于使用且 "自然"。事实上，在许多情况下，这个类可以作为算术类型的 "滴入 "替代品，将操作从数字性质转变为符号性质；当类在底层数字类型上被模板化时，这就变得特别容易。由于专注于PDEs的数值模拟，在deal.II中暴露的CAS功能主要集中在符号表达式的创建、操作和微分上。
* 对SymEngine功能的方便包装主要集中在仅涉及基于字典（即让人联想到 "基于字符串 "的东西）的操作。尽管SymEngine以一种有效的方式执行这些操作，但它们仍然是已知的计算昂贵的，特别是当这些操作是在大的表达式上执行时。因此，应该预计到在生产代码中使用时，执行微分、符号替换等[2.x.96]的代码部分的性能可能是一个限制因素。因此，deal.II提供了一个接口，通过[2.x.97]类（本身经常利用SymEngine提供的功能）加速对冗长的符号表达的评估。特别是，[2.x.98]同时使用常见的子表达式消除（CSE）等方法来优化符号表达式的集合，以及通过使用自定义生成的[2.x.99]或使用LLVM JIT编译器来生成高性能代码路径来评估这些表达式。[2.x.100]类的用法在[2.x.101]中有所例证。
* 作为最后的说明，必须认识到deal.II目前实现的支持符号库的接口还有很大的缺陷。目前实现的功能水平有效地限制了符号代数在传统使用情况下的使用（即标量和张量代数，因为可能对定义构成关系或复杂函数作为边界条件或源项的应用有用）。事实上，[2.x.102]展示了如何使用它来实现具有挑战性的构成模型。在未来，我们还将本着与[2.x.103]命名空间相同的精神，实现类来协助执行装配操作。
* 实现支持的符号可微调数的接口的文件摘要如下。
*


*
* - symengine_math.h:数学运算的实现，使实现符号表达式的类在整个库和用户代码中的使用一致。   它为标准命名空间中的许多数学函数提供对应的定义。
*


*
* - symengine_number_traits.h:提供一些机制来轻松查询符号数的选择属性，即一些类型特征。
*


*
* - symengine_number_types.h:[2.x.104]类的实现，可用于表示标量符号变量、标量符号表达式等。   这个表达式类被赋予了一整套重载的运算符，用于SymEngine库所支持的所有数学和逻辑运算，并且被认为在数值建模的背景下是有用的。
*


*
* - symengine_optimizer.h:[2.x.105]类的实现，可用于使用各种技术加速（在某些情况下，显著）符号表达式的评估。
*


*
* - symengine_product_types.h:定义了一些积和标量类型，允许与Tensor和SymmetricTensor类一起使用符号表达式。
*


*
* - symengine_scalar_operations.h:定义了许多可以对标量符号表达式或变量进行的操作。   这包括（但不限于）创建标量符号，对标量进行微分，以及在标量表达式中进行符号替换。
*


*
* - symengine_tensor_operations.h:定义了可以对符号表达式或变量的张量进行的众多操作。   这包括（但不限于）创建符号的张量，对符号的张量进行微分，对符号的张量进行微分，以及在张量表达式中进行符号替换。
*


*
* - symengine_types.h。为一些在符号计算范围内常用的类型提供别名。
*


*
* - symengine_utilities.h:提供一些在符号计算范围内有用的实用函数。


* [0.x.1]

include/deal.II-translator/A-headers/c++_0.txt
[0.x.0]*



* [2.x.0]
* 从9.0版本开始，deal.II需要一个至少支持[1.x.0]的编译器。作为其中的一部分，deal.II内部实现中的许多地方现在都在使用C++11中才引入的功能。 也就是说，deal.II也有一些函数和类，使其使用C++11的功能更容易。
* 一个例子是对C++11[1.x.1]的支持。基于deal.II的代码通常有许多类似的循环。


* [1.x.2]
* 使用C++11的基于范围的for循环，你现在可以这样写。


* [1.x.3]
* 这依赖于诸如[2.x.1]和DoF处理类中的等价函数，[2.x.2] [2.x.3] 这些函数的变体为所有单元格（不仅仅是活动单元格）和单个层次上的单元格提供迭代器范围。
* 库中还有许多其他的函数，允许习惯性的使用基于范围的for循环。例子有[2.x.4] [2.x.5] [2.x.6]等许多。
* C++11还引入了[constexpr](https://en.cppreference.com/w/cpp/language/constexpr)变量和函数的概念。定义为 "constexpr "的变量是在程序编译过程中计算出来的常量值，因此其初始化的运行时间成本为零。此外，`constexpr`常量有正确定义的生命期，完全避免了所谓的 "静态初始化顺序惨败"。%函数可以被标记为 "constexpr"，表明如果它们的输入参数是常量表达式，它们可以产生编译时常量返回值。此外，至少有一个`constexpr`构造函数的类可以被初始化为`constexpr`。
* 作为一个例子，由于构造函数[2.x.7] array_type &)是`constexpr`，我们可以在编译时用一个数组初始化一个张量，如：。


* [1.x.4]
* 在这里，A的内容没有被存储在堆栈中。相反，它们在编译时被初始化并插入到可执行程序的`.data`部分。程序可以在运行时使用这些值，而无需花费时间进行初始化。初始化张量可以用一句话来简化。


* [1.x.5]
* 一些函数如determinant()被指定为`constexpr`，但它们需要具有C++14能力的编译器。因此，这个函数在内部被声明为。


* [1.x.6]
* 如果有一个支持C++14的编译器，宏[2.x.8]简化为`constexpr`。否则，对于旧的编译器，它完全忽略了DEAL_II_CONSTEXPR。因此，在较新的编译器中，用户可以编写


* [1.x.7]
* 假设`A`是用`constexpr`指定器声明的。这个例子显示了使用`constexpr`的性能收益，因为这里我们在编译时进行了一个具有[2.x.9]复杂性的操作，避免了任何运行时的成本。


* [0.x.1]*
 deal.II目前只需要一个符合C++11的编译器，但有一些来自C++14标准的函数和类，在编译器只支持C++11的情况下也很容易提供。 这些都收集在当前的命名空间中。
* 最明显的例子是[1.x.8]函数，它可以说是一个疏忽，因为它没有被包含在C++11中（鉴于C++11中有[1.x.9]）。
* 在这个命名空间中还有其他一些小的补充，使我们在这一点上已经可以使用C++14的特性，尽管我们不需要一个符合C++14的编译器。
*

*
* [2.x.10] 如果使用的编译器确实支持C++14，那么这个命名空间的内容只是从命名空间`std`导入的类和函数。也就是说，我们回到了编译器提供的内容，而不是我们自己的实现。


* [0.x.2]*
 deal.II目前只需要一个符合C++11的编译器，但有一些来自C++17标准的函数和类，在编译器只支持C++11的情况下也很容易提供。 这些都收集在当前的命名空间。
* 最显著的例子是[1.x.10]类，它从C++17标准开始被引入到C++中。
* 在这个命名空间中还有其他一些小的补充，使我们在这一点上已经可以使用C++17的特性，尽管我们不需要一个符合C++17的编译器。
*

*
* [2.x.11] 如果使用的编译器确实支持C++17，那么这个命名空间的内容只是从命名空间`std`导入的类和函数。也就是说，我们回到了编译器提供的东西，而不是我们自己的实现。


* [0.x.3]*
 deal.II目前只需要一个符合C++11的编译器，但有一些来自C++20标准的函数和类，在编译器只支持C++11的情况下也很容易提供。 这些都收集在当前的命名空间中。
* 一个例子是[1.x.11]类，它从C++20标准开始被引入到C++中。它被用作[2.x.12][2.x.13]和[2.x.14]等函数的返回类型，以支持基于范围的for循环（参见[2.x.15]中基于范围的for循环的例子，以及上述函数的文档）。
* 在这个命名空间中还有其他一些小的补充，使我们在这一点上已经可以使用C++20的特性，尽管我们不需要一个兼容C++20的编译器。
*

*
* [2.x.16] 如果使用的编译器确实支持C++20，那么这个命名空间的内容只是从命名空间`std`导入的类和函数。也就是说，我们回到了编译器提供的内容，而不是我们自己的实现。


* [0.x.4]

include/deal.II-translator/A-headers/coding_conventions_0.txt
[0.x.0]*
  [2.x.0]
* 在整个deal.II中，我们努力保持我们的编程风格和我们提供的界面种类尽可能的一致。为此，我们采用了一套编码惯例，并尽可能地加以遵守。它们有两个部分：风格问题，以及我们称之为 "防御性编程 "的东西，后者是试图让我们的代码帮助我们发现错误。  在阅读它们的时候，重要的是要记住，风格并不是神赐予的，也不是比任何其他的惯例都要好；它们的目的只是为了使deal.II尽可能的统一。统一性减少了我们产生的错误的数量，因为我们可以，例如，总是假设输入参数在函数调用的输出参数之前。它们也简化了代码的阅读，因为有些东西通过查看代码的写法就已经很清楚了，而不需要去查找某些东西的确切定义。
* [1.x.0]
* [2.x.1] deal.II使用[2.x.2] 6.0来规范缩进。Astyle文件提供在
* [1.x.1]

* [2.x.3] 在提交之前，你应该运行
* [1.x.2]
* 在你的每一个文件上。这将确保缩进符合本页面中列出的风格指南。
* 这是很麻烦的。因此，更容易的是，你可以直接运行
* [1.x.3]
* 在你设置的编译库的任何目录中，对所有最近被修改的源文件进行缩进。如果你想确保所有提交的缩进都是正确的，你可能想设置一个提交后钩子。一种方法是将[2.x.4]复制到[2.x.5]，并确保其可执行。
* 如果你工作的系统安装了不止一个版本的[2.x.6]（或者它不在路径中），你应该将上述[2.x.7]命令改为
* [1.x.4]
*以指向正确的可执行文件。[2.x.8]
* [1.x.5]
* [2.x.9] [2.x.10] %返回某物数量（单元数、自由度等）的函数应以 [2.x.11] 开始。例如。   [2.x.12]
* [2.x.13] %设置位或标志的函数应以 [2.x.14] 开始；清除位或标志的函数应以 [2.x.15] 命名。  例子。  [2.x.16]
* [2.x.17] 应使用传统的逻辑运算符，而不是它们的英文等价物（即，使用[2.x.18]而不是[2.x.19] ）。
* [2.x.20] 在实现文件中，在每个函数之后，希望有三个空行，以使可读性更好。一个空行出现在函数中，用于对代码块进行分组，因为两个空行不足以明显地区分出代码属于两个不同的函数。[2.x.21]
* [2.x.22] 每当一个整数变量只能承担非负值，它就被标记为无符号。这同样适用于只能返回正值或零值的函数。例子。  [2.x.23]
* [2.x.24] 每当一个函数的参数不会被改变，它就应该被标记为const，即使是通过值传递。一般来说，我们将输入参数标记为const。这有助于作为一个额外的文档工具来澄清参数的意图（输入、输出或两者），并让编译器在这样的参数被改变时发出警告，这往往是不由自主的或糟糕的风格。[2.x.25]
* [2.x.26] 每当一个函数不改变嵌入类/对象的任何成员变量时，它就应该被标记为const。[2.x.27]
* [2.x.28] %函数和变量名称不能只由一个或两个字母组成，除非该变量是一个纯粹的计数索引。[2.x.29]
* [2.x.30] 类型别名（ [2.x.31] -declarations）优于 [2.x.32] -declarations。[2.x.33]
* [2.x.34] 使用GeometryInfo中的几何信息来获取每个单元的面数、每个单元的子数、与面3相邻的子单元的子指数等，而不是像 [2.x.35] 、 [2.x.36] 和 [2.x.37] 那样直接写进代码。这减少了出错的可能性，提高了代码的可读性。[2.x.38]
* [2.x.39] 类声明的布局如下：首先是公共函数块，从构造函数开始，然后是解构函数。如果有公共成员变量，这些变量必须出现在构造函数之前。只有当公有变量是常量（特别是静态和常量）或不可避免时，才应使用公有变量。   [2.x.40] 在公共成员之后，应列出受保护成员，最后是私有成员。顺序如上：先是变量，然后是函数。   [2.x.41] 异常应在公共部分的末尾声明，然后再开始非公共部分。   [2.x.42] 对于既不是[2.x.43]的成员变量，我们不使用C++11风格的类成员初始化；即，代替
* [1.x.6]
*写
* [1.x.7]
* [2.x.44]
* [2.x.45] 如果一个函数有输入和输出参数，通常输入参数应在输出参数之前，除非有充分的理由改变这个顺序。最常见的原因是带有默认值的输入参数的尾部。
* [2.x.47] 异常用于%内部参数检查和通过Assert宏进行一致性检查。像C++语言那样的异常处理（ [2.x.48] ，并使用AssertThrow宏）用于处理运行时的错误（如I/O故障），在任何情况下都必须开启，而不仅仅是在调试模式下。[2.x.49]
* [2.x.50] 有时通过使用几个非成员函数来实现一个类是有意义的，这些非成员函数不是公共接口的一部分，而且只在当前源文件中被调用。这样的自由函数应该放在一个内部命名空间中，其结构如下。
* [1.x.8]
* 其中[2.x.51]是调用类的名称。
* [2.x.52] 类、命名空间和类型一般使用大写字母来表示词的开头（例如TriaIterator）&mdash；有时也称为[1.x.9][1.x.10]&mdash；而函数和变量使用小写字母和下划线来分隔单词。  唯一的例外是Triangulation和DoFHandler中的迭代器别名（命名为cell_iterator、active_line_iterator等），以使其与标准库容器类的联系清晰。[2.x.53]
* [2.x.54] 对于有多个模板参数的类，维度通常放在数据类型指定器之前，即我们使用Point<dim,number>而不是Point<number,dim>。
* [2.x.55] 在deal.II中，有几个地方我们在头文件中使用正向声明。这样做的原因是，当我们只需要将某个类型标记为某个函数的参数时，不使用头文件，希望可以提高编译速度。在deal.II中使用的惯例是，如果我们需要的只是一个类型名称，那么这个类型可以在我们需要的头文件中向前声明；如果一个函数（或成员函数）可以返回一个值，那么这个值的类型声明应该可以得到（通过包括必要的头文件）。例如，[2.x.56]包括[2.x.57]，这样就可以写出类似[2.x.58]的东西，而不需要明确包括声明[2.x.59]所返回对象类型的头文件。
* [2.x.60] 每个类都必须有至少200页的文档；-)[2.x.61]
* [2.x.62]
*

* [1.x.11]
* [2.x.63] deal.II中的大多数类和函数是模板化的。这就带来了一个问题：如果有的话，这些对象是如何以及在哪里被实例化的。在整个deal.II中，我们采用了以下惯例。[2.x.64]
* [2.x.65]
* [2.x.66] 如果我们可以列举出所有可能的模板参数（例如，维度只能是1、2或3），那么一个函数模板就会进入[2.x.67]文件，我们明确地将所有可能性实例化。用户不会有任何需要看到这些函数模板，因为他们无论如何都不想为其他模板参数实例化这些函数。  [2.x.68]
* [2.x.69] 如果我们不能列举所有可能的模板参数（例如，vectortypes
*
* 因为用户可能想定义他们自己的向量种类），但至少知道一些常见的使用情况，那么该函数将被放入一个[2.x.70]文件中，并为所有常见的参数实例化函数。对于几乎所有的用户来说，这样做就可以了
*
* - 他们只使用我们已经实例化的（向量、矩阵......）类型，对他们来说，[2.x.71]文件不会有任何意义。这也不会减慢他们的编译速度，因为他们看到的东西都会包括[2.x.72]文件。但是定义了自己的（向量、矩阵......）类型的用户可以通过包括[2.x.73]文件，用自己的用户定义的类型实例化模板函数。
* [2.x.74] 最后，如果我们不能事先假定模板参数将采取哪些值（例如，任何从Subscriptor派生的类都可以作为参数），函数的定义将在头文件的底部提供声明。这些定义应该用<code>\#ifndefDOXYGEN ...\#以防止Doxygen发现它们。[2.x.75]
* [2.x.76]
* [2.x.77] 对于前两种情况，实例化指令被定义在[2.x.78]文件中。它们由一个叫做expand_instantiations的二进制文件处理（由[2.x.79]构建），参数根据你的配置通过cmake动态定义（见构建目录中的[2.x.80]）。正是这些[2.x.81]文件最终被包含在相应的[2.x.82]文件中。  [2.x.83]
*

* [1.x.12]
* [2.x.84] 防御性编程是我们经常使用的一个术语，当我们在谈论写代码的时候，要考虑到错误会发生。在这里，错误有两种方式：第一，我自己在写函数时可能犯错；第二，别人在调用我的函数时可能犯错。不管是哪种情况，我都希望我的代码写得(i)尽可能不出错，(ii)编译器已经可以发现一些错误，(iii)剩下的错误相对容易发现，比如说因为程序中止了。因此，防御性编程是一组使这些目标更有可能实现的策略。[2.x.85]
* [2.x.86] 随着时间的推移，我们已经学会了一些这方面的技术，其中一些我们在此列出。[2.x.87] [2.x.88] [1.x.13] 人们总是用错误或无意义的参数调用函数。作为典型的例子，考虑一个微不足道的向量加法的实现。
* [1.x.14]
* 虽然正确，但如果两个向量的大小不一样，这个函数就会陷入困境。你认为用不同大小的向量来调用这个函数是愚蠢的？是的，当然是这样的。但这种情况经常发生：人们忘记重新初始化一个向量，或者它在不同的函数中被重置，等等。这种情况时有发生。所以，如果你遇到这种不幸运的情况，可能要花很长时间才能弄清楚发生了什么，因为你很可能只是读取了未初始化的内存，或者也许你正在向[2.x.89]向量实际上并不拥有的内存写入。  这两种情况都不会导致程序的立即终止，但你可能会在以后的时间里出现随机错误。如果程序只是在这里立即停止，那就容易多了。下面的实现正是这样做的。
* [1.x.15]
* [2.x.90] 宏确保条件在运行时为真，否则会打印一个包含由第二个参数编码的信息的字符串，并中止程序。这样，当你写一个新的程序恰好调用这个函数时，你会马上知道你的错误，并有机会修复它，而不需要认真调试什么。   [2.x.91]作为一般准则，每当你实现一个新的函数时，要考虑[1.x.16]上的参数，即该函数对每一个参数或它们的组合期望是什么。  然后为所有这些先决条件写断言。在某些情况下，这可能是半打断言，但请记住，每个断言都是一个潜在的错误，已经通过琐碎的手段发现。   [2.x.92] 最后，让我们说说断言当然是昂贵的：当你把一个程序与库的调试版本链接时，它们可能会使程序慢3或5倍。但是如果你考虑到你的[1.x.17]开发时间，快速发现错误的能力可能远远超过你等待程序完成的时间。此外，在优化模式下，对Assert宏的调用被从程序中移除（你可能只在知道在调试模式下一切运行正常后才使用。优化后的库比调试后的库快3-5倍，但代价是更难发现错误。   [2.x.93]
* [2.x.94] [1.x.18] 如果一个函数计算出一些非微不足道的东西，那么代码中可能有一个错误。为了找到这些，可以使用后置条件：就像你对输入参数的有用值有一定的了解一样，你对可能的返回值也有一定的了解。例如，一个计算向量规范的函数希望规范是正的。你可以把它写成这样。
* [1.x.19]
* 这个函数太简单了，无法真正证明这个断言的正确性，但是想象一下计算的长度，你就可以看到这个断言是如何帮助你确保（或[1.x.20]）自己不犯错误的。请注意，人们可以争辩说，一旦我们运行了若干次程序，发现条件从未被触发，就应该删除这个断言。但最好还是把它留在原处：它为未来（和读者）编码了你对该函数的了解；如果有人出现，用更有效的算法取代了该函数的实现，断言可以帮助确保该函数继续做它应该做的事。   [2.x.95]
* [2.x.96] [1.x.21] 类似地，如果你有一个复杂的算法，使用断言来确保你对正在发生的事情的心理模型与确实的事实相符。例如，假设你正在编写一个函数，以确保网格尺寸不会在本地发生太大的变化。你最终可能会得到如下的代码。
* [1.x.22]
* 导致我们进入else-branch的条件可能很复杂，虽然我们认为我们到达这里的唯一可能性是邻居在边界上，这可能是真的，但在我们的实现中可能存在一个bug。也可能是我们的思维出现了错误，或者有人在同一个函数中改变了上面的代码而忘记了这里的问题，或者在库中一个完全不同的位置的改变使得这个假设站不住脚。在所有这些情况下，我们的断言的明确陈述可以确保这些问题被轻易发现。   [2.x.97]
* [2.x.98] [1.x.23] 传统的C语言要求在函数的开头声明变量，即使它们只在下面进一步使用。这就导致了我们可以想象在1d代码中出现这样的代码。
* [1.x.24]
* 问题是，如果声明和初始化之间的代码又长又复杂，你不可能在一页纸上查到一个变量的类型是什么，它的值可能是什么。事实上，甚至可能不太清楚该变量是否被用于初始化，或者它是否被意外地留在了未初始化状态。   [2.x.99] 一个更好的方法是这样做的。
* [1.x.25]
* 这使得变量的类型更加清晰，而且事实上它只在初始化时使用。此外，如果有人想阅读代码，看看这个变量实际上在做什么，在最内层的作用域中声明和初始化它，使这项任务更容易：我们不必在声明之外向上寻找它，也不必在当前作用域的末端向下寻找，因为这是变量死亡的地方。   [2.x.100] 作为最后的说明，很明显，你只能对完全生活在堆栈中的变量做这种事情，而不需要在堆上分配内存。在deal.II中，这只适用于像[2.x.101]等内置类型，以及点和张量类。其他的东西都有像[2.x.102]这样的成员变量，这需要内存分配&mdash；你不想在循环内声明这些，至少在循环被频繁遍历的情况下。   [2.x.103]
* [2.x.104] [1.x.26] 继续上面的例子，注意在大多数情况下，我们不会再改变如此初始化的变量。换句话说，如果是这种情况，我们不妨把事情写成如下。
* [1.x.27]
* 通过标记变量为常量，我们可以确保我们不会意外地改变它。例如，编译器可以捕获这样的代码。
* [1.x.28]
* 这很可能是指[2.x.105]而不是一个赋值。通过将该变量标记为常量，编译器就会告诉我们这个错误。也许同样重要的是，代码的人类读者不需要再往下看，变量的值是否真的在声明和使用之间的某个地方被改变了&mdash；如果它被标记为const，就不可能了。   [2.x.106]
* [2.x.107] [1.x.29] 对于函数参数，本质上也是如此。如果你不打算改变一个变量（这通常是输入参数的情况），那么就把它标记为常量。例如，下面这个函数应该把它的参数作为一个常数。
* [1.x.30]
* 这里，用户调用[2.x.108] ，例如。真的没有理由这个函数要改变[2.x.109]这个参数的值&mdash；所以把它标记为常量：这既可以帮助代码的读者理解这是一个函数的输入参数，我们不需要在下面搜索它是否被改变过，又可以帮助编译器在我们不小心改变了这个值时帮助我们找到bug。[2.x.110]
*


* [0.x.1]

include/deal.II-translator/A-headers/concepts_0.txt
[0.x.0]*



* [2.x.0]
* 有时对一个对象的类型施加约束而不要求它属于一个特定的继承层次是有用的。这些通常在C++社区中被称为[2.x.1]概念[2.x.2]。本模块列出了deal.II中常用的概念，并对其意图进行了简要描述。在deal.II中列出类型的约束条件的惯例是在模板中提供概念的名称作为[2.x.3]：例如，矢量的类型取决于底层字段的类型，因此它被定义为模板。


* [1.x.0]
* 这里的重点是，你正在创建一个可以存储[2.x.4]类型元素的向量，但这上面有一些基本假设。例如，deal.II Vector类并不打算仅仅作为一个集合使用（与[2.x.5]不同），而是定义了向量空间的操作，如向量的加法，或向量的规范。因此，用户可以为[2.x.6]指定的数据类型必须满足某些条件（即，它必须符合或 "模拟 "一个 "概念"）。具体来说，该类型必须表示代表数学上称为 "场 "的元素的对象（你可以认为是，嗯，"数字"：我们可以加、乘、除、取绝对值的东西，等等）。概念的意义在于描述[2.x.7]一个类型必须满足哪些条件[2.x.8]才能在特定的环境中成为有效的模板参数。
* 本页描述了在整个deal.II中使用的一些概念的这些条件。具体来说，在上面的例子中，下面讨论的[2.x.9]"数字概念 "描述了可以作为向量类的参数的类型。
*概念作为C++的语言扩展已经被提议了很久了。它们将允许我们描述一个类或函数具有某些属性，以便成为一个合格的模板参数。例如，它允许我们在C++代码中表达，例如，[2.x.10]的第一个参数必须有一个代表实际网格的类型。
*
* - 目前我们只能用文字来描述，见下文。使用C++的概念将允许我们在代码中描述这一点，并且试图用一个对象作为第一参数来调用这样一个函数，但实际上它不是一个网格，这将产生一个编译器错误，使不匹配的情况变得清晰。
* 不幸的是，这些对C++的建议从未进入任何官方的C++标准；然而，它们被建议用于C++20。一旦我们的绝大多数用户拥有支持这一标准的编译器，我们可能会开始使用它们。
* 关于这个主题的更多信息可以在[1.x.1]找到。
*

* [2.x.11]
* <dt class="concepts"> [2.x.12] ConceptDoFHandlerType [1.x.2]</dt>。
* [2.x.13] deal.II包括DoFHandler和[2.x.14]这两个管理网格上自由度的对象。虽然两者没有任何继承关系，但它们足够相似，许多函数只需要类似于DoFHandler的东西就能正常工作。  [2.x.15]
* <dt class="concepts"> [2.x.16] ConceptMatrixType [1.x.3]</dt>。
* [2.x.17] deal.II中的许多函数和类需要一个知道如何计算矩阵-向量积（成员函数 [2.x.18] ）、转置矩阵-向量积（成员函数 [2.x.19] ）以及 "乘法和加法 "等效物的对象 [2.x.20] 。有些函数只需要[2.x.21]，但如果模板需要MatrixType参数的话，一个对象应该实现所有四个成员函数。编写满足这些条件的类是很常见的，所以编写LinearOperator类是为了让事情变得更简单；更多信息请参见 [2.x.22] 。
* 对[2.x.23]的一种看法是，假装它是一个具有如下签名的基类（这几乎就是SparseMatrix提供的接口）。
*


* [1.x.4]
*
* C++中的模板函数不能是虚拟的（这是deal.II中不使用这种方法的主要原因），所以用继承的方式实现这个接口是行不通的，但这仍然是思考这个模板概念的一个好方法。人们可以使用LinearOperator类来实现[2.x.24]，而不是手动实现它们。  [2.x.25]
* <dt class="concepts"> [2.x.26] ConceptMeshType [1.x.5]</dt>。
* [2.x.27] 网格可以被认为是顶点和连接点的数组，但一个更有成效的观点是将它们视为[1.x.6]。在C++中，集合通常被称为[1.x.7]（典型的容器是[2.x.28][2.x.29]等），它们的特点是能够对集合中的元素进行迭代。<tt>MeshType</tt>概念是指任何定义了适当方法（如[2.x.30]和<tt>typedefs</tt>（如[2.x.31]）的容器，用于管理单元的集合。
* Triangulation、DoFHandler和[2.x.32]的实例都可以被视为单元格的容器。事实上，这些类的公共接口中最重要的部分仅仅由获得其元素的迭代器的能力组成。由于接口的这些部分是通用的，也就是说，这些函数在所有的类中都有相同的名字，所以可以编写一些操作，这些操作实际上并不关心它们是在三角化还是在DoF处理对象上工作。例如，在GridTools命名空间中就有大量的例子，强调了网格和DoF处理程序都可以简单地被视为单元格的集合（容器）这一抽象的力量。
* 另一方面，网格是不同于[2.x.33]或[2.x.34]的非标准容器，因为它们可以以多种方式被切分。例如，我们可以在活动单元的子集上迭代，也可以在所有单元上迭代；同样，单元被组织成层次，我们可以只为一个层次上的单元获得迭代器范围。然而，一般来说，所有实现单元格容器概念的类都使用相同的函数名称来提供相同的功能。
* 可以用任何一个类来调用的函数通过接受一个模板参数来表示，例如


* [1.x.8]
*或


* [1.x.9]
* 满足这个概念的类被统称为 [2.x.35] 网格类 [2.x.36] 。<tt>MeshType</tt>的确切定义在很大程度上依赖于库的内部结构，但它可以被概括为具有以下属性的任何类。  [2.x.37] [2.x.38] 一个名为<tt>typedef</tt>的<tt>active_cell_iterator</tt>。    [2.x.39] [2.x.40] 一个<tt>get_triangulation()</tt>方法，返回单元格集合的基础几何描述（Triangulation类之一）的引用。如果网格恰好是一个Triangulation，那么网格只是返回一个对其本身的引用。    [2.x.41] [2.x.42] 一个方法<tt>begin_active()</tt>，返回一个指向第一个活动单元的迭代器。    [2.x.43] [2.x.44] 一个静态成员值<tt>dimension</tt>，包含对象所处的维度。    [2.x.45] [2.x.46] 一个静态成员值<tt>space_dimension</tt>，包含对象的维度（例如，一个2D表面在3D环境中会有<tt>space_dimension = 2</tt>）。    [2.x.47] [2.x.48] [2.x.49]。
* <dt class="concepts"> [2.x.50] ConceptNumber [1.x.10]</dt>。
* [2.x.51] 这个概念描述了作为向量或矩阵条目有意义的标量，这通常是场元素的一些有限精度的近似。典型的例子是[2.x.52]和[2.x.53]的浮点类型[2.x.54]在很多地方也是如此。  [2.x.55]
* <dt class="concepts"> [2.x.56] ConceptPolynomialType [1.x.11]</dt>。
* [2.x.57] 更多信息见[2.x.58]中的描述。在某些情况下，任何满足类似于接口的


* [1.x.12]
*
*为了实现有限元的目的，可将其视为多项式。  [2.x.59]
* <dt class="concepts"> [2.x.60] ConceptPreconditionerType [1.x.13]</dt>。
* [2.x.61] 这基本上是[2.x.62]的同义词，但通常只要求定义[2.x.63]。大多数时候，定义[2.x.64]是不必要的。人们应该认为[2.x.65]是将线性算子的逆运算应用于向量的一些近似值，而不是线性算子对向量的作用，用于预处理器类。  [2.x.66]
* <dt class="concepts"> [2.x.67] ConceptRelaxationType [1.x.14]</dt>。
* [2.x.68] 这是一个能够对多网格方法进行放松的对象。我们可以认为满足这个约束的对象具有以下接口以及[2.x.69] "MatrixType "所要求的约束。


* [1.x.15]
* 其中这两个成员函数执行平滑方案的一个步骤（或这种步骤的转置）。换句话说，这些函数执行的操作是[2.x.70] 和 [2.x.71] 。  [2.x.72]
* <dt class="concepts"> [2.x.73] ConceptSparsityPatternType [1.x.16]</dt>。
* [2.x.74] 几乎所有的函数（除了[2.x.75]这个明显的例外）都以稀疏性模式为参数，可以采用常规的SparsityPattern或DynamicSparsityPattern，甚至是块状稀疏性模式之一。更多信息见 [2.x.76] 。  [2.x.77]
* <dt class="concepts"> [2.x.78] ConceptStreamType [1.x.17]</dt>。
* [2.x.79] 在C++中派生新的流类，众所周知是很困难的。为了解决这个问题，一些函数接受一个定义了[2.x.80]的参数，这样就可以轻松地输出到任何一种输出流。  [2.x.81]
* <dt class="concepts"> [2.x.82] ConceptVectorType [1.x.18]</dt>。
* [2.x.83] deal.II支持许多不同的向量类，包括与其他库的向量的绑定。这些与标准库中的向量类似（即它们定义了 [2.x.84] , [2.x.85] ），但也定义了像 [2.x.86] 这样的数字操作。VectorType的一些例子包括Vector, [2.x.87] 和 BlockVector。  [2.x.88]
* [2.x.89]


* [0.x.1]

include/deal.II-translator/A-headers/constraints_0.txt
[0.x.0]*



* [2.x.0]


* [2.x.1]
* 本模块处理自由度的约束问题。处理约束的中心类是AffineConstraints类。
* 约束通常来自几个方面，例如。
*


*
* - 如果你有迪里希特型边界条件，[2.x.2]，通常通过要求边界上的自由度有特定的值来执行，例如[2.x.3]，如果边界条件[2.x.4]要求自由度12位置的有限元解[2.x.5]有42值。这样的约束是由那些接受AffineConstraints参数的[2.x.6]函数版本产生的（尽管也有其他处理Dirichlet条件的方法，使用[2.x.7]见例如[2.x.8]和[2.x.9] ）。
*


*
* - 如果你有边界条件，设定了解决方案的某一部分数值，例如没有法向通量，[2.x.10]（如发生在流动问题中，由[2.x.11]函数处理）或规定的切向分量，[2.x.12]（如发生在电磁问题中，由[2.x.13]函数处理）。对于前一种情况，例如，设想我们在法线矢量具有[2.x.14]形式的顶点，在这个顶点的流场的[2.x.15]-、[2.x.16]-和[2.x.17]分量与自由度12、28和40相关。那么无正态流条件意味着我们需要有条件 [2.x.18] 。   规定的切向分量会导致类似的约束，尽管右手边经常有一些东西。
*


*
* - 如果你有悬挂节点约束，例如在这样的网格中。         [2.x.19] 我们假设右下角的两个红色自由度之一是[2.x.20]，其左右两边的黄色邻居是[2.x.21]和[2.x.22] 。那么，要求有限元函数是连续的，就相当于要求[2.x.23] 。类似的情况发生在hp自适应有限元方法的背景下。   例如，当在网格的两个标记单元上使用Q1和Q2元素（即使用FE_Q(1)和FE_Q(2)）时 [2.x.24] 有三个约束：首先 [2.x.25] ，然后 [2.x.26] ，最后是身份 [2.x.27] 。即使所有的单元格都使用相同的有限元，也会出现类似的约束条件作为悬挂节点。在所有这些情况下，你将使用[2.x.28]函数来计算这种约束。
*


*
* - 其他线性约束，例如，当你试图为一个问题施加某个平均值时，否则就没有唯一的解决方案。在[2.x.29]的教程程序中给出了这样一个例子。
* 在所有这些例子中，对自由度的约束是线性的，而且可能是不均匀的。换句话说，它们总是具有 [2.x.30] 的形式。处理存储和使用这些约束的deal.II类是AffineConstraints。
*

* [1.x.0]
* 在建立全局系统矩阵和右手边时，可以不考虑约束条件，即简单地在单元上循环，将局部贡献加入全局矩阵和右手边对象。为了进行实际计算，你必须对线性系统进行 "浓缩"：消除受约束的自由度并将适当的值分配给无约束的自由度。这改变了有限元计算中使用的稀疏矩阵的稀疏模式，因此是一个相当昂贵的操作。事情的一般方案是，你建立你的系统，使用[2.x.31]函数消除（浓缩）约束节点，然后你解决剩余的系统，最后你使用[2.x.32]函数从无约束节点的值中计算出约束节点的值。请注意，[2.x.33]函数适用于线性系统的矩阵和右手边，而[2.x.34]函数则适用于解向量。
* 这种先建立线性系统，再消除约束自由度的方案效率很低，如果约束条件多，矩阵满，即特别是对3d和/或高阶或hp-finite元素，则是一个瓶颈。此外，它不可能在一个进程可能无法接触到矩阵元素的情况下实现%的并行计算。因此，我们提供了建立线性系统的第二种方法，使用下面讨论的[2.x.35]和[2.x.36]函数。得到的线性系统与调用[2.x.37]函数后得到的线性系统是等价的。
*

*
* [2.x.38] 这两种应用约束的方式都是将矩阵对角线的值设置为与矩阵中其他项相同大小的[1.x.1]项。因此，你需要设置你的问题，使描述主要矩阵贡献的弱形式不是[1.x.2]。否则，像CG这样的迭代求解器会崩溃，或者像GMRES那样慢得多。
*

*
* [2.x.39] 虽然这两种方式是[1.x.3]，即通过任何一种方式计算的线性系统的解是相同的，但线性系统本身不一定具有相同的矩阵和右侧向量条目。具体来说，由于我们计算的方式不同，对应于受限自由度的矩阵对角线和右手边条目可能不同；但是，它们总是以这样的方式选择，即线性系统的解是相同的。
* [1.x.4]
* 如上所述，使用约束条件的第一种方式是在不考虑约束条件的情况下建立线性系统，然后将其 "浓缩 "掉。浓缩一个矩阵分四个步骤进行。
*


*
* - 首先是建立稀疏模式（例如，使用[2.x.40]）。
*



* - 那么浓缩矩阵的稀疏模式是由原始稀疏模式和约束条件组成的。
*


*
* - 第三，全局矩阵的组装。
*


*
* - 第四，矩阵最终被浓缩。
* 在浓缩过程中，我们实际上没有改变稀疏模式、矩阵和向量的行数或列数。相反，凝结函数将非零条目添加到矩阵的稀疏模式中（其中有受限节点），矩阵的凝结过程将产生额外的非零元素。在浓缩过程本身中，受约束的行和列被分配到无约束节点的行和列中。受约束的自由度保持原位。为了不干扰求解过程，这些行和列用零和主对角线上的一个适当的正值来填充（我们选择其他对角线元素大小的平均值，以确保新的对角线条目具有与其他条目相同的大小顺序；这保留了矩阵的缩放特性）。右手边的相应数值被设置为零。这样一来，受约束的节点在方程组求解时将始终得到零值，并且不会再与其他节点耦合。
* 与创建一个新的、更小的矩阵相比，保留矩阵中的条目有一个好处，即只需要一个矩阵和稀疏模式，因此需要的内存更少。此外，浓缩过程的成本较低，因为不是所有的而是只有矩阵中的受限值必须被复制。另一方面，求解过程将花费更长的时间，因为矩阵向量的乘法会在受约束的行中产生乘以零的结果。此外，矢量的大小更大，对于那些使用较大数量的辅助矢量的迭代求解方法（例如使用显式正交程序的方法）来说，会导致更多的内存消耗。尽管如此，这个过程由于其较低的内存消耗而更有效率。
* 浓缩函数存在于不同的参数类型中。SparsityPattern, SparseMatrix 和 BlockSparseMatrix。请注意，对于[2.x.41]类型的参数或其他PETSc或Trilinos矩阵封装类，没有任何版本。这是因为相对来说，要得到PETSc矩阵的稀疏结构的表示，并有效地修改它们是很困难的；这一点尤其适用于矩阵实际分布在一个计算机集群中的情况。如果你想使用PETSc/Trilinos矩阵，你可以复制一个已经浓缩的deal.II矩阵，或者以已经浓缩的形式组装PETSc/Trilinos矩阵，见下面的讨论。
*

* [1.x.5]
* 浓缩向量的工作原理与上面描述的矩阵的工作原理完全相同。请注意，缩合是一个等价的操作，也就是说，对一个向量或矩阵做一次以上的缩合操作与只做一次的结果相同：一旦一个对象被缩合，进一步的缩合操作就不会再改变它了。
* 与矩阵凝结函数相反，矢量凝结函数存在于PETSc和Trilinos矢量的变体中。然而，使用它们通常很昂贵，应该避免。你应该使用与上述相同的技术来避免使用它们。
*

* [1.x.6]
* 有时，人们希望在一个线性系统建立之后，根本就避免对它进行显式凝结。想这样做有两个主要原因。
* [2.x.42] [2.x.43] 缩合是一个昂贵的操作，特别是当有许多约束条件和/或矩阵有许多非零项时。对于三维或高多项式程度的计算，以及hp-finite element方法来说，这两种情况都很典型，例如见[2.x.44] "hp-paper"。这是hp教程程序中讨论的情况，[2.x.45] step_27 " [2.x.46] "，以及[2.x.47] 和 [2.x.48] " [2.x.49] "。
* [2.x.50] 你使用的矩阵可能没有[2.x.51]函数（例如，PETSc和Trilinos封装类就是这种情况，我们无法访问矩阵的底层表示，因此无法有效地实现[2.x.52]操作）。这种情况在 [2.x.53] 、 [2.x.54] 、 [2.x.55] 和 [2.x.56] 中讨论。  [2.x.57]
* 在这种情况下，一种可能性是在将局部条目转移到全局矩阵和向量的时刻就将其分配到最终目的地，同样在最初设置的时候就在浓缩的形式中建立一个稀疏的模式。
* AffineConstraints类也为这些操作提供了支持。例如，[2.x.58]函数将非零条目添加到一个稀疏模式对象中。它不仅添加了一个给定的条目，而且还添加了所有的条目，如果当前的条目对应于以后要消除的受限自由度，我们就必须写到这些条目。类似地，在将局部贡献复制到全局矩阵或向量时，可以使用[2.x.59]函数直接分配向量和矩阵中的条目。这些调用使得后续调用[2.x.60]变得没有必要。关于它们的使用例子，请看上面提到的教程程序。
* 注意，尽管它们的名字描述了函数的真正作用，[2.x.61]函数必须应用于矩阵和右手边的向量，而下面讨论的[2.x.62]函数则应用于求解线性系统后的向量。
*

* [1.x.7]
* 在求解浓缩方程组后，解向量必须被 "分配"：通过调用[2.x.63]对原始线性系统的修改，导致一个线性系统对所有无约束的自由度都能正确求解，但对有约束的自由度的值却没有定义。为了得到这些自由度的正确值，你需要将无约束的值也 "分配 "给它们的有约束的同事。这是由[2.x.64]函数完成的。分布的操作在某种意义上撤销了凝结过程，但应该注意的是，它不是逆向操作。基本上，分布将受约束的节点的值设置为从约束中计算出来的值，给定的是无约束的节点的值加上可能的不均匀性。
*

* [1.x.8]
* 如果一些约束线有不均匀性（如果约束来自于不均匀边界条件的实现，这就是典型的情况），情况就会比仅仅由于悬挂节点的约束更复杂一些。这是因为消除矩阵中的非对角线值会在向量中消除的行中产生贡献。这意味着，不均匀性只能用同时作用于矩阵和向量的函数来处理。这意味着，如果在没有任何矩阵的情况下调用相应的凝结函数（或者如果矩阵之前已经被凝结过），所有的不均匀性都会被忽略。
* 使用AffineConstraints类来实现Dirichlet边界条件在[2.x.65]教程程序中讨论。另一个利用AffineConstraints的例子是 [2.x.66] 。这里的情况要复杂一些，因为我们有一些不在边界上的约束。在创建AffineConstraints对象后，有两种方法来应用不均匀约束。
* 第一种方法。
*


*
* - 将[2.x.67]函数应用于系统矩阵和右侧，参数use_inhomogeneities_for_rhs = false（即默认）。
*


*
* - 使用[2.x.68]函数将不均匀约束部分的解设为零（或者从等于零的解矢量开始）。
*


*
* - 解决()线性系统
*


*
* - 将[2.x.69]应用于解决方案中
* 第二种方法。
*


*
* - 使用参数use_inhomogeneities_for_rhs = true的[2.x.70]函数，并将其应用于系统矩阵和右手方
*


*
* - 将解的有关分量设置为不均匀的约束值（例如使用[2.x.71]）。
*


*
* - 解决()线性系统
*


*
* - 根据求解器现在你必须对解应用[2.x.72]函数，因为求解器可以改变解中的约束值。对于一个基于Krylov的求解器来说，这应该不是严格意义上的需要，但是仍然有可能在不均匀值和解的值之间存在机器精度的差异，而且如果你有额外的约束，例如来自悬挂节点的约束，你可能无论如何都想调用[2.x.73]。
* 当然，这两种方法都导致了相同的最终答案，但方式不同。使用第一种方法（即在[2.x.74]中使用[2.x.75]时，我们建立的线性系统在所有那些自由度受到约束的地方，右手边的条目都是零，在这些线的矩阵对角线上有一些正值。因此，线性系统的解向量对于不均匀约束的自由度会有一个零值，我们需要调用[2.x.76]来给这些自由度以正确的非零值。
* 另一方面，在第二种方法中，对于不均匀约束自由度的矩阵对角线元素和相应的右手边条目，使线性系统的解已经具有正确的值（例如，如果约束条件是[2.x.77]，那么如果矩阵除了对角线条目外是空的，则行[2.x.78]，而[2.x.79]，这样[2.x.80]的解必须如愿满足[2.x.81]）。因此，我们不需要在求解后调用[2.x.82]来修复解的不均匀约束成分，尽管这样做也无妨。
* 还有一个问题，即采取哪种方法，以及为什么我们需要将第一种方法中的解向量的值设为零。这两个问题的答案都与迭代求解器解决线性系统的方式有关。为此，考虑到我们通常在残差下降到右手边法线的某个分数以下时停止迭代，或者说，在初始残差的某个分数以下时停止迭代。现在考虑这个问题。
*


*
* - 在第一种方法中，受限自由度的右手边条目为零，也就是说，右手边的准则实际上只包括我们关心的那些部分。另一方面，如果我们从一个解向量开始，而这个解向量在受约束的条目中不为零，那么初始残差就会非常大，因为目前解向量中的值与线性系统的解（在这些部分中为零）不匹配。   因此，如果我们一旦将初始残差减少了某一系数就停止迭代，那么我们可能在一次迭代后就达到了阈值，因为受限自由度被迭代求解器在一次迭代中就解决了。如果初始残差是由这些自由度主导的，那么我们在第一步就看到了急剧的减少，尽管在这短短的一次迭代中我们在线性系统的其余部分并没有真正取得什么进展。我们可以通过以下方式来避免这个问题：一旦残差的规范达到[1.x.9]的某个分数就停止迭代，或者我们可以将解的成分设置为零（从而减少初始残差），然后迭代直到达到[1.x.10]的某个分数。
*


*
* - 在第二种方法中，如果迭代中的起始向量为零，我们会遇到同样的问题，因为此时残差可能被受限自由度所支配，其值与我们在解中希望的值不一致。我们可以通过调用[2.x.83][1.x.11]求解线性系统（必要时在求解后再进行第二次），将解向量的相应元素设置为正确的值，从而再次规避这个问题。
* 除了这些考虑，考虑我们有[2.x.84]这种不均匀约束的情况，例如，从[2.x.85]形式的悬挂节点约束，其中[2.x.86]本身被边界值约束到[2.x.87] 。在这种情况下，AffineConstraints容器当然不能找出[2.x.88]的最终值，因此，不能正确设置解向量的第三分量。因此，第二种方法将不起作用，你应该采取第一种方法。
*

* [1.x.12]
*有些情况下，自由度受到不止一种方式的约束，有时是相互冲突的方式。例如，考虑下面的情况。      [2.x.89] 这里，蓝色标记的自由度[2.x.90]是一个悬挂节点。如果我们使用三线有限元，即FE_Q(1)，那么它将带有约束条件 [2.x.91] 。另一方面，它在边界上，如果我们施加了边界条件[2.x.92]，那么我们将有约束[2.x.93]，其中[2.x.94]是这个自由度位置上的边界函数[2.x.95]的值。
*那么，哪一个会赢？或者说：哪一个[1.x.13]赢？这个问题没有好的答案。
*


*
* - 如果悬挂的节点约束是最终执行的约束，那么对于一般的边界函数，所得到的解不再满足边界条件 [2.x.96] 。
*


*
* - 如果反其道而行之，在这一点上，解决方案将不满足悬挂节点的约束，因此将不满足所选元素的规则性属性（例如，尽管使用[2.x.97]元素，但将不连续）。
*


*
*-如果你考虑弯曲的边界，情况就会变得完全没有希望，因为那时边的中点（即悬挂的节点）一般不在母边上。因此，无论两个竞争约束的优先级如何，解决方案都不会是[2.x.98]符合要求的。如果悬空节点约束获胜，那么解决方案将既不符合要求，也没有正确的边界值。换句话说，"正确 "的解决方案是什么并不完全清楚。在大多数情况下，这并不重要：无论是哪种情况，由不符合性或不正确的边界值引入的误差最差也会与离散化的整体误差处于同一等级。
* 也就是说，如果你知道你想要的是什么，你应该怎么做。
*


*
* - 如果你想让悬挂的节点约束获胜，那么首先通过[2.x.99]函数建立这些约束。   然后用[2.x.100]将边界值插值到同一个AffineConstraints对象中。如果后一个函数遇到一个已经被约束的边界节点，它将简单地忽略这个节点的边界值，不触及约束。
*



* - 如果你想让边界值约束获胜，就像上面那样建立悬空节点约束，并使用这些约束用[2.x.101]函数来组装矩阵（或者，另一种方法是组装矩阵，然后对其使用[2.x.102]）。在第二步，使用[2.x.103]函数返回[2.x.104]，并将其作为[2.x.105]的输入，将边界节点设置为正确的值。
* 两种行为也可以通过建立两个独立的AffineConstraints对象，并以特定的第二个参数调用[2.x.106]函数来实现。
*

* [1.x.14]
* 有时候，直接压缩或消除线性方程组中的约束是不可取的，也是不可能的。特别是如果没有底层矩阵对象可以被压缩（或在装配过程中照顾到约束）。如果系统是由LinearOperator描述的，通常就是这种情况。
* 在这种情况下，我们可以用修改后的系统[1.x.15]代替[1]（M. S. Shephard.作为直接刚度装配过程的一部分，通过变换应用的线性多点约束。[1.x.16] 20(11):2107-2112, 1985).
* 这里，[2.x.107]是一个给定的（无约束的）系统矩阵，对于它，我们只假设可以应用于一个向量，但不一定可以访问单个矩阵条目。  [2.x.108]是线性方程组[2.x.109]的相应右手边。矩阵[2.x.110]描述了存储在AffineConstraints对象中的线性约束的同质部分，向量[2.x.111]是相应的不均匀性的向量。更确切地说，应用于向量[2.x.113]的[2.x.112]操作是[1.x.17]的操作。最后，[2.x.114]表示约束自由度子空间上的身份。
* 然后通过分配约束条件来恢复服从这些约束的[2.x.115]的相应解。  [2.x.116] .
* 整个系统可以通过以下代码片段来设置和解决。


* [1.x.18]



* [0.x.1]

include/deal.II-translator/A-headers/cuda_0.txt
[0.x.0]*



* [2.x.0]
* 本模块中的类涉及到使用CUDA在GPU上运行的功能描述。


* [0.x.1]

include/deal.II-translator/A-headers/distributed_0.txt
[0.x.0]*



* [2.x.0]


* [2.x.1]



* [2.x.2] 集群。
* [2.x.3]
* [1.x.0]
* deal.II除了在[2.x.4]模块中讨论的共享内存机器内的并行化之外，还可以使用通过MPI连接的多台机器来并行化计算。基本上有两种方法可以利用多部机器。
*


*
* - 每台机器都在本地保存整个网格和DoF处理程序，但每台机器上只保存全局矩阵、稀疏模式和解向量的一部分。
*


*
* - 网格和自由度处理程序也是分布式的，也就是说，每个处理器只存储一部分单元和自由度。没有一个处理器知道整个网格、矩阵或解决方案，事实上，在这种模式下解决的问题通常非常大（比如，一亿到几十亿自由度），没有一个处理器可以或应该存储哪怕一个解决方案矢量。
* 这两个选项中的第一个相对简单，因为人们在有限元程序中想做的大部分事情仍然以基本相同的方式工作，而且处理分布式矩阵、向量和线性求解器是很好的外部库，如Trilinos或PETSc，可以使事情看起来与在本地提供的一切几乎完全一样。这种并行化模式的使用在教程程序[2.x.5]和[2.x.6]中作了解释，这里不再详细讨论。
* 真正的分布式网格的使用要复杂得多，因为它改变了一些可以用deal.II三角计算、DoF处理程序等完成的事情，或者使之成为不可能。本模块以离地面50000英尺的有利位置记录了这些问题，而不涉及太多的细节。下面描述的所有算法都在命名空间[2.x.7]的类和函数中实现。
* 在使用MPI的并行计算中，一个重要的方面是，对矩阵和向量元素的写访问需要在操作结束后和使用对象前（例如从读取）调用compress（）。也请参见 [2.x.8] 。
* [1.x.1]
* 本命名空间中使用的算法的完整讨论，以及这里使用的许多术语的彻底描述，可以在[2.x.9] "分布式计算论文 "中找到。特别是，该论文表明，本模块讨论的方法可以扩展到数千个处理器和远远超过10亿个自由度。这篇论文还给出了许多术语的简明定义，这些术语在这里和图书馆的其他地方使用，与分布式计算有关。  [2.x.10]教程程序展示了该命名空间的类和方法在拉普拉斯方程上的应用，而[2.x.11]则是针对一个矢量值问题。  [2.x.12]将[2.x.13]程序扩展到大规模并行计算，从而解释了这里讨论的主题在更复杂应用中的使用。
* 关于我们认为的 "可扩展 "程序的讨论，见[2.x.14]"本词汇表条目"。
*

* [1.x.2]
* 在%并行%分布模式下，每个处理器上的[2.x.15]类型的对象只存储一个单元的子集。特别是，全局网格可以被认为是分解的，因此每个MPI进程 "拥有 "一些单元。然后，每个进程在本地存储的网格正是由它所拥有的那些单元组成，以及它在本地拥有的单元周围的一层[2.x.16]GlossGhostCell "幽灵单元"，还有一些我们称之为[2.x.17]的 "人工 "单元。后者是确保每个处理器拥有一个拥有所有粗略级别单元的网格，并且尊重相邻单元不能相差超过一个细化级别的不变性。下面的图片显示了这样一个网格，%分布在四个处理器上，以及每个处理器在本地存储的单元的集合。
* [2.x.18]
* 单元的颜色是基于[2.x.19]的 "子域ID"，它标识了哪个处理器拥有一个单元：绿松石色代表处理器0，绿色代表处理器1，黄色代表处理器2，红色代表处理器3。可以看出，每个进程在自己的单元格周围都有一层幽灵单元格，这些单元格被正确地用子域ID着色，子域ID标识了拥有这些单元格的处理器。还要注意每个处理器是如何存储一些人工单元的，用蓝色表示，它们的存在只是为了确保每个处理器知道所有的粗网格单元，并且网格具有2:1的细化属性；然而，在这些人工单元所占据的区域，处理器不知道那里的网格到底有多细，因为这些区域是由其他处理器所拥有的。因此，我们将开发的所有算法只能在本地拥有的单元上运行，如果有必要，也可以在幽灵单元上运行；试图访问任何人工单元上的数据很可能是一个错误。注意，我们可以通过测试<code>cell- [2.x.20] == triangulation.local_owned_subdomain()</code>来确定我们是否拥有一个单元。
* 这里需要考虑的 "真正的 "网格是由每个进程所拥有的单元组成的联合体，即由绿松石、绿色、黄色和红色区域的重叠所产生的网格，不考虑蓝色区域。
*

*
* [2.x.21] 这个 "真实 "的网格被分解成由每个进程存储的碎片，由[1.x.3]库提供。 p4est将完整的网格存储在一个叫做平行森林的分布式数据结构中（因此得名）。平行森林由四叉树（2D）或八叉树（3D）组成，这些树起源于每个粗略的网格单元，代表了从父单元到其四个（2D）或八个（3D）子单元的细化结构。在内部，这个平行森林由一个单元的（分布式）线性阵列表示，对应于每个树的深度优先遍历，然后每个进程存储这个单元的线性阵列的一个连续部分。这就导致了如上图所示的分区，从这个意义上说，它们不是最佳的，因为它们不能使子域之间的接口长度最小化（因此也不能使通信量最小化），但在实践中却非常好，可以用超快的算法进行操作。   因此，以这种方式存储和操作单元的效率往往超过了通信的优化损失。   这种划分方法产生的各个子域有时也可能由不相连的部分组成，如右上图所示）。然而，可以证明每个子域最多包括两个不相连的部分；见C. Burstedde, J. Holke, T. Isaac: "Bounds on the number of discontinuities of Morton-type space-filling curves", [1.x.4], 2017.)


* [1.x.5]
* DoFHandler类建立在Triangulation类的基础上，但它可以检测到每当我们实际使用[2.x.22]类型的对象作为三角形。在这种情况下，它为存在于全局网格上的所有自由度分配全局%数，但每个处理器将只知道那些定义在本地相关单元上的自由度（即本地拥有的单元或者是幽灵单元）。在内部，该算法的工作原理是：循环浏览我们本地拥有的所有单元，并为定义在这些单元上的自由度分配DoF指数，在不同处理器拥有的子域界面上的自由度，不属于邻近的处理器。然后，所有处理器交换他们本地拥有的自由度，并以这样的方式转移他们自己的指数，即所有子域上的每个自由度都由一个介于0和[2.x.23]之间的指数唯一识别（这个函数返回全局自由度的数量，在所有处理器上累积）。请注意，在这一步之后，每个进程拥有的自由度形成了一个连续的范围，例如，可以通过[2.x.24]返回的连续索引集得到。 在为所有自由度分配了唯一的索引之后，[2.x.25]函数就会在所有幽灵单元上循环，并与邻近的处理器进行通信，以确保这些幽灵单元上的自由度的全局索引与邻居分配给它们的索引一致。
*通过这个方案，我们可以确保我们本地拥有的每个单元以及所有的幽灵单元都可以被要求产生定义在它们身上的自由度的全局正确指数。然而，要求人造单元上的自由度很可能不会有什么好结果，因为这些单元没有任何信息（事实上，甚至不知道这些单元是否在全局网格上是活跃的，或被进一步细化）。
* 像往常一样，自由度在被列举后可以被重新编号，使用命名空间DoFRenumbering中的函数。
*

* [1.x.6]
* 在处理非常多的处理器时，人们很快就会了解到一件事，那就是不能在每个处理器上存储每个自由度的信息，即使这些信息是 "这个自由度不在这里"。这方面的一个例子是，我们可以为一个有[2.x.26]行的（压缩）稀疏模式创建一个对象，但我们只填充那些对应于[2.x.27]本地拥有的自由度的行。原因很简单：为了举例，我们假设我们有10亿个自由度，分布在100个处理器上；如果我们甚至在这个稀疏模式中每行只持有16个字节（无论我们是否拥有相应的自由度），即使每一行都是空的，我们也需要16GB的对象。当然，只有1000万行是不空的，为此我们需要160MB，再加上存储非零条目的实际列索引所需的东西。假设我们有一个中等复杂的问题，每行有50个条目，我们为每个条目存储价值4个字节的列索引，那么我们需要为1000万行中的每一行存储216个字节，以对应我们拥有的自由度，总共2.16GB。而我们不拥有的9.9亿行，每行需要16字节，共计15.840GB。很明显，如果我们使用更多的处理器，这个比例也不会变得更好。
* 解决这个问题的方法是只对线性系统中我们拥有的部分使用任何内存，或者出于其他原因需要。对于所有其他部分，我们必须知道它们的存在，但我们不能设置我们数据结构的任何部分。为此，存在一个叫做IndexSet的类，它表示我们所关心的一组索引，我们可能要为其分配内存。稀疏模式、约束矩阵、矩阵和向量的数据结构可以用这些IndexSet对象进行初始化，以真正只关心那些与索引集中的索引相对应的行或条目，而不关心所有其他的索引。然后这些对象会询问集合中存在多少个索引，为每个索引分配内存（例如初始化稀疏模式的一行的数据结构），当你想访问全局自由度[2.x.28]的数据时，你会被重定向到用索引[2.x.30]调用[2.x.29]的结果，而不是。访问[2.x.32]为假的元素[2.x.31]的数据将产生一个错误。
* 剩下的问题是如何确定与我们在每个处理器上需要担心的自由度相对应的指数集。为此，你可以使用[2.x.33]函数来获取一个处理器拥有的所有指数。注意，这是定义在本地拥有的单元上的自由度的一个子集（因为两个不同子域之间的界面上的一些自由度可能被邻居拥有）。这个定义在我们拥有的单元上的自由度集合可以通过函数[2.x.34]得到。 最后，有时我们需要本地拥有的子域以及相邻的幽灵单元上所有自由度的集合。这个信息由[2.x.35]函数提供。
*

* [1.x.7]
* 一个典型的并行应用要处理两种不同类型的并行向量：带有鬼魂元素的向量（也叫鬼魂向量）和没有鬼魂元素的向量。  这两种类型通常可以由同一数据类型表示，但当然也有不同的向量类型可以分别表示这两种类型：例如[2.x.36] [2.x.37]和建立在这些之上的BlockVector对象）。你可以在[2.x.38]"关于重影向量的词汇表条目 "中找到关于区分这些类型的向量的讨论。
* 从使用的角度来看，重影向量通常用于数据输出、后处理、误差估计、积分中的输入。这是因为在这些操作中，人们通常不仅需要访问[2.x.39]"本地拥有的道夫"，还需要访问[2.x.40]"本地活动的道夫"，有时还需要访问[2.x.41]"本地相关的道夫"，而它们的值可能不会存储在需要它们的处理器上的非鬼魂向量中。上面列出的操作也只需要对向量进行只读访问，因此在这些情况下，幽灵向量是可以使用的。
* 另一方面，没有鬼魂项的向量在其他所有地方都可以使用，如组装、求解或任何其他形式的操作。这些通常是只写的操作，因此不需要对可能被另一个处理器拥有的向量元素进行读取访问。
* 你可以使用operator=在有鬼魂元素和无鬼魂元素的向量之间进行复制（你可以在[2.x.42], [2.x.43] , 和 [2.x.44] 中看到）。
*

* [1.x.8]
* 在写这篇文章的时候，唯一能够处理刚才解释的情况的类是DynamicSparsityPattern。该函数的一个版本[2.x.45]存在，它接受一个IndexSet参数，指示要为疏散模式的哪些行分配内存。换句话说，创建这样一个对象是安全的，它将报告其大小为10亿，但实际上只存储了索引集有多少个元素的行。然后你可以使用通常的函数[2.x.46]来建立疏散模式，该模式是在网格的本地拥有的部分进行装配而产生的。产生的对象可以用来初始化PETSc或Trilinos矩阵，这些矩阵通过完全分布式存储支持非常大的对象尺寸。然后，该矩阵可以通过只在当前处理器所拥有的单元上进行循环来进行组装。
* 唯一需要注意的是，稀疏性需要存储哪些自由度的条目。从本质上讲，这些是我们在组装时可能在矩阵中存储的值。很明显，这些肯定是本地活动的自由度（它们生活在我们本地拥有的单元上），但是通过约束，也有可能写到位于幽灵单元上的条目。因此，你需要在初始化稀疏模式时传递来自[2.x.47]的索引集。
*

* [1.x.9]
* 在创建稀疏模式以及组装线性系统时，我们需要知道自由度的约束，例如由悬挂节点或边界条件导致的约束。像动态稀疏模式类一样，AffineConstraints容器在构造时也可以接受一个IndexSet，这个IndexSet指示在可能非常多的自由度中它应该实际存储哪些约束。与稀疏模式不同的是，这些自由度现在只是我们在组装时本地处理的自由度，即那些由[2.x.48]返回的自由度（本地拥有的自由度的超集）。
* 然而，在有些情况下，更复杂的约束会出现在有限元程序中。一个例子是在[2.x.49]的适应性计算中，自由度可以针对其他自由度进行约束，而这些自由度本身也被约束。在这样的情况下，为了完全解决这个约束链，只存储局部活动自由度的约束可能是不够的，可能还需要有局部相关自由度的约束可用。在这种情况下，AffineConstraints对象需要用由[2.x.50]产生的IndexSet进行初始化。
* 一般来说，如果你碰巧没有在每个处理器上存储所有必要的约束条件，你的程序将继续做一些事情：你将只是生成错误的矩阵条目，但程序不会中止。这与稀疏模式的情况相反：在那里，如果传递给DynamicSparsityPattern的IndexSet表明它应该存储太少的矩阵行，那么当你试图向不存在的矩阵条目写入时，程序会中止，或者矩阵类会默默地分配更多的内存来容纳它们。因此，在指明存储哪些约束条件时，谨慎行事是很有用的，使用[2.x.51]的结果而不是[2.x.52] 。这也是可以承受的，因为局部相关自由度的集合只比局部活动自由度的集合稍大一些。我们在[2.x.53]、[2.x.54]和[2.x.55]中选择了这种策略。
*

* [1.x.10]
* 和其他一切一样，你只能对本地处理器拥有的单元格进行后处理。DataOut和KellyErrorEstimator类自动做到了这一点：它们只对本地拥有的单元格进行操作，不需要做任何特别的事情。至少对于大型计算来说，也没有办法在一台机器上合并所有这些本地计算的结果，也就是说，每个处理器必须是自给的。例如，每个处理器必须生成自己的并行输出文件，而这些文件必须由一个能够处理多个输入文件的程序进行可视化处理，而不是在生成一个单一的输出文件之前将调用DataOut的结果合并到一个处理器。后者可以实现，例如，使用[2.x.56]和[2.x.57]函数。
* 这些考虑同样适用于所有其他的后处理动作：例如，虽然有可能通过在本地进行计算并将产生的单个数字处理器累积为整个通信的单个数字来计算全局能量耗散率，但如果每个处理器产生的数据量很大，一般来说是不可能做到这一点。
* 然而，对于后处理有一个特别的考虑：无论你在一个处理器拥有的每个单元上做什么，你至少需要访问在这些单元上活跃的所有那些解向量的值（即访问所有[1.x.11]的集合，用[2.x.58]《分布式计算论文》的语言），这是这个处理器实际拥有的自由度的超集（因为它可能不拥有自己的单元和其他处理器拥有的那些单元之间界面上的所有自由度）。然而，有时你需要更多的信息：例如，为了计算KellyErrorIndicator的结果，我们需要评估当前和邻近单元的界面上的梯度；后者可能为其他处理器所拥有，所以我们也需要这些自由度。因此，一般来说，人们需要获得所有自由度为[1.x.12]的解值。另一方面，我们可以用于并行线性代数的两个包（PETSc和Trilinos）以及[2.x.59]都将向量细分为每个处理器拥有的块和存储在其他处理器的块。因此，要对东西进行后处理意味着我们必须告诉PETSc或Trilinos，它也应该导入[1.x.13]，即除了我们本地拥有的向量之外，还应该导入解向量的其他向量元素。对于重影向量，这可以通过使用以分布式向量为参数的operator=来实现。


* [0.x.1]*
   一个命名空间，用于支持%分布式内存机器上的%并行计算的类和函数。参见[2.x.60]分布式模块，以了解该命名空间提供的设施的概况。    
* [2.x.61]
* [0.x.2]

include/deal.II-translator/A-headers/dofs_0.txt
[0.x.0]*



* [2.x.0]
* 本模块将与处理自由度有关的类和命名空间分组。该组的中心类是DoFHandler类：它建立在三角形和有限元类之上，并根据有限元对象所描述的有限元空间的要求在三角形的每个单元上分配自由度。DoFHandler类还有其他变体，如[2.x.1]，对更特殊的情况做类似的事情。
* DoFHandler对象与FiniteElement（或[2.x.2]中的[2.x.3]）类型的对象一起使用，以列举该特定有限元的三角结构中存在的所有自由度。因此，网格、有限元和DoF处理程序对象的组合可以被认为是提供了一个[1.x.0]的有限元空间：网格提供了定义基函数的位置；有限元描述了存在哪些种类的基函数；DoF处理程序对象提供了基的枚举，也就是说，它提供了空间的具体结构，因此我们可以通过系数向量来描述这个有限维空间的函数。
* DoFHandlers扩展了Triangulation对象（以及[2.x.4]网格模块中的其他类），因为它们也提供了迭代器，在所有单元格、面或其他构成三角形的几何对象上运行。这些迭代器是从三角形迭代器派生出来的，因此提供了同样的功能，但它们也提供了额外的功能。例如，它们允许查询与当前单元相关的自由度的索引。请注意，DoFHandler类来自Triangulation[1.x.1]，尽管它们使用Triangulation对象；原因是可以有一个以上的DoFHandler对象对同一个Triangulation对象工作。
* 除了DoF处理程序类之外，这个模块还拥有一些在应用程序中不常用的辅助类，以及三个与DoFHandler类的数据结构没有直接联系的类。其中第一个是AffineConstraints类，用于存储和处理与悬挂节点相关的约束。其次，DoFRenumbering命名空间提供了可以重新排序自由度的函数；在它的函数中，有在下游方向排序自由度的函数，例如，有以使相关矩阵的带宽最小化的方式排序自由度。最后，DoFTools命名空间提供了各种处理自由度的算法。
* 从总体上看，这个模块的各个部分与库的其他部分相互作用。


* [1.x.2]


* [0.x.1]

include/deal.II-translator/A-headers/exceptions_0.txt
[0.x.0]*



* [2.x.0]
* 该模块包含在deal.II的异常机制中使用的类。
* [1.x.0]
* 异常有两种不同的使用方式。  [2.x.1]
* [2.x.2] 静态断言。这些是只在调试模式下启用的检查，而不是在发布（或优化，生产）模式下。在deal.II中，静态断言通常用于检查函数的参数是否满足某些属性，内部数据结构是否一致，以及类似的断言。例如，静态断言用于确保两个相加的向量具有相同的组件数量
*
* - 其他的一切反正都没有任何意义。
* 这种检查是由[2.x.3]宏在库中的几千个地方进行的。另外，从[2.x.4]开始的几个教程程序显示了如何做到这一点。
* 如果一个静态断言被违反了，异常机制会产生一个异常类型，指出到底是什么出了问题，显示适当的信息，包括检测到问题的确切位置，然后中止程序
*
* - 如果你试图添加两个不同长度的向量，在程序中没有什么可以应对的情况，你必须去修正程序代码来代替。一般来说，甚至没有理由使用通常的C++异常机制来[2.x.5]一个异常对象，因为在这种情况下，更高一级的函数没有办法纠正这种情况，并以一种有用的方式处理它
*
* - 并不是程序收到了坏的数据；程序只是出现了错误，人们无法智能地解决这个问题。
* （有时将[2.x.6]宏的行为从中止程序改为抛出异常是很有用的。另一方面，异常不允许从类的析构器中传播出去。   为此，有一个叫做 [2.x.7] 的宏的变体，可以在析构器中使用。这些用例将在本页面下面进一步讨论)。
*

* [2.x.8] 动态断言。这些用于检查依赖于外部事物的条件，这些外部事物可能在一次程序运行中与下一次不同，例如，一个输出文件是否可以被写入。
* 这些是不应该被静态检查的东西，因为不能保证在调试模式下满足条件的程序，在随后的发布模式下也会满足该条件。
*
* - 换句话说，只在调试模式下检查这些情况是不够的。
* 相反，我们必须在程序的执行过程中每次都要检查这些情况。在deal.II中，这是用[2.x.10]、[2.x.11]和以下教程中介绍的[2.x.9]宏来完成的。该宏检查一个条件，如果违反了，就使用C++ [2.x.12]机制抛出一个本模块中声明的类型之一的异常。由于这些是运行时异常，这就给了程序捕捉异常的机会，例如，将输出写入一个可写文件。  [2.x.13]
*

* [1.x.1]
* <tt>deal.II</tt>中的错误处理机制通常以两种方式使用。  第一种是只在调试模式下使用错误检查，对没有经过全面测试的程序很有用。当程序不再显示错误时，可以关闭错误处理，并以此获得更好的性能，因为在库中对错误的检查是相当频繁的（典型的速度提升是4倍！）。这种异常生成模式对于内部一致性检查是最有用的，比如范围检查或函数参数的有效性检查。这种类型的错误通常是编程错误，程序终止时应该有尽可能详细的信息，包括异常产生的位置和原因。
* 第二种模式是用于错误检查，这种检查应该始终处于开启状态，比如I/O错误、内存请求失败等等。关掉这个模式没有什么意义，因为这种错误同样可能发生在经过测试和未经测试的程序中。这类异常不会终止程序，而是以<tt>C++</tt>的方式抛出异常，允许程序捕捉它们并最终做一些处理。由于在异常不能被正确处理的情况下，打印出一些信息可能是有用的，所以额外的信息会像第一种模式一样被传递。后者使得有必要提供一系列的宏，将这些额外的信息输入到异常类中；原则上，这可以由程序员自己每次手工完成，但由于这些信息可以自动获得，所以为此提供了一个宏。
* 这两种模式都使用异常类，除了<tt>C++</tt>标准的[2.x.14]类之外，它们还需要有特殊的功能。  这样的类是由以下几行代码声明的。
* [1.x.2]
*
* 这声明了一个名为<tt>ExcDomain</tt>的异常类，它有两个变量作为附加信息（默认命名为<tt>arg1</tt>和<tt>arg2</tt>），它输出给定的序列（它被附加到一个[2.x.15]变量的名称上，因此有奇怪的语法）。还有其他<tt>DeclExceptionN</tt>宏，用于有更多或没有参数的异常类。按照惯例，所有异常类的名字都是以<tt>Exc...</tt>开头的，而且大多数都是在本地声明的，以用于它要使用的类（少数非常频繁的异常也是在StandardExceptions命名空间中声明的，在任何地方都可以使用）。在全局范围内声明异常是可能的，但是会污染全局命名空间，可读性较差，而且大多数时候是不必要的。
* 由于异常类在两种错误检查模式下的声明方式相同，所以可以使用通过<tt>DeclExceptionN(...)</tt>宏系列声明的异常来进行静态和动态检查。
*

* [1.x.3]
* 要使用异常机制进行调试模式的错误检查，请在你的源代码中写下类似以下的行。
* [1.x.4]
* 通过宏扩展，它基本上做了以下工作（尽管实际的代码稍微复杂一些）。
* [1.x.5]
* 也就是说，只有当预处理器变量<tt>DEBUG</tt>被设置，并且违反了给定的条件（在这种情况下<tt>n < dim</tt>），它才会发出错误。
* 如果异常是用<tt>DeclException0 (...)</tt>宏来声明的，也就是说，没有任何附加参数，那么它的名字就必须用括号给出。  <tt>Assert (i>m, ExcSomewhat());</tt>
* [1.x.6]
* 如果设置了<tt>DEBUG</tt>预处理器指令，调用<tt>Assert (cond, exc);</tt>基本上会被预处理器转换为以下序列。
* [1.x.7]
*
* （注意，函数名称和确切的调用序列可能会随着时间的推移而改变，但一般原则是不变的）。也就是说，如果给定的条件被违反，那么发生异常的文件和行以及条件本身和异常对象的调用序列就会被传递给[2.x.16]函数。此外，一个由<tt>exc</tt>给出的对象被创建（这通常是一个未命名的对象，如<tt>ExcDomain(n, dim)</tt>类的<tt>ExcDomain</tt>）并被转移到这个函数。
* <tt>__PRETTY_FUNCTION__</tt>是一些编译器定义的宏，给出了函数的名称。如果使用的是另一个编译器，如果编译器为我们提供了这个函数，我们就尝试将其设置为合理的函数，否则就<tt>"（不可用）"</tt>。
* 在<tt>issue_error_noreturn</tt>中，通过调用set_fields()函数，将给定的数据转移到<tt>exc</tt>对象中；之后，程序要么被中止（关于异常的信息被打印到deallog），要么抛出异常。<tt>Assert</tt>宏做了第一条路径（打印和中止）；<tt>AssertThrow</tt>做了第二条（抛出）。这种行为与本文前面对静态和动态断言的描述是一致的。如果能从操作系统中获得，输出也可能包含堆栈跟踪，以显示错误发生的位置。[2.x.17]的几个程序显示了一个典型的输出。
* 如果预处理器变量<tt>DEBUG</tt>没有设置，那么<tt>Assert</tt>宏就会扩展为<tt>{}</tt>。
* 有时，除了程序流不应该到达某个点之外，没有其他有用的异常条件，例如，<tt>switch</tt>语句的<tt>default</tt>部分。在这种情况下，通过下面的结构引发异常。
* [1.x.8]
* 参见[2.x.18]和其他几个教程程序中对该结构的使用。
* 如上所述，一旦对<tt>Assert</tt>的调用失败，程序就会终止。然而，有一种情况我们不想这样做，即当一个C++异常被激活时。发生这种情况的通常情况是，有人通过<tt>AssertThrow</tt>机制抛出一个异常（见下文），在堆栈被解开的同时，导致堆栈框架上面的其他对象被破坏。如果其他对象引用了被销毁的对象，一些析构器会通过<tt>Assert</tt>引发一个异常。如果我们当时中止程序，我们只会看到一个对象被销毁的消息，而这个对象仍然被某个地方引用，但我们永远不会看到触发这个异常的原始异常。(你可以在调试器中通过在函数<tt>__throw</tt>上设置断点来看到它，但你不能从程序本身看到它。)在这种情况下，我们使用一个C++标准库函数来检测另一个活动异常的存在，并且不终止程序，以允许抛出的异常传播到某个可以显示其信息的地方。
* 由于一个失败的断言导致一连串的其他断言是很常见的，我们只打印第一个消息。如果程序被中止了，那就没有问题。如果不是这样（因为一个C++的异常是有效的），就只显示第一条，并显示一条关于被抑制的后续信息的信息。
*

* [1.x.9]
* C++有一种机制来表明发生了一些特殊情况：可以由<tt>throw</tt>语句触发的异常和由<tt>catch</tt>子句捕获的异常，例如见https://en.wikipedia.org/wiki/C%2B%2B#Exception_handling 和 http://www.cplusplus.com/doc/tutorial/exceptions/ 。
* 在一些基本的层面上，典型的C++异常是一个对象被放置在一些特殊的地方，然后函数通过一个特殊的返回路径退出当前的范围（例如，当前的函数）。  这往往足以说明是什么问题触发了异常，但更多的时候，如果能得到更多的信息就更好了：例如，问题发生在代码的哪一行，或者代码想写进稀疏矩阵的哪个不存在的条目。
* 因此，deal.II中的动态断言对这种机制进行了一些扩展。  通常情况下，人们会通过以下代码引发一个异常，例如
* [1.x.10]
* 然后用语句来捕获它
* [1.x.11]
* [2.x.19]是一个标准的<tt>C++</tt>类，为异常提供了基本的功能，比如虚拟函数<tt>what()</tt>，它返回异常本身的一些信息。如果一个异常不能被正确处理，这些信息是很有用的，在这种情况下，应该尽可能地打印出精确的描述。
* 这里的问题是，要想从<tt>what()</tt>中获得重要而有用的信息，就必须在我们的异常类中重载这个函数，并在异常类中调用带有额外参数的<tt>throw</tt>操作符。首先，重载<tt>what</tt>函数是使用<tt>DeclExceptionN</tt>宏来完成的，但是把正确的信息，也就是上面解释的<tt>Assert</tt>扩展，如果想每次都写下来，需要做一些工作。
* [1.x.12]
*
* 为此，我们发明了宏<tt>AssertThrow</tt>。它所做的工作主要与<tt>Assert</tt>宏相同，但它并不中止程序；相反，它抛出一个异常，如上所示。使用模式是
* [1.x.13]
*
* 要检查的条件被纳入宏中，以允许将被违反的条件作为一个字符串传递。<tt>AssertThrow</tt>宏的扩展不受<tt>DEBUG</tt>预处理器变量的影响。
*

* [1.x.14]
* 有一整个系列的<tt>DeclExceptionX</tt>宏，其中<tt>X</tt>将被附加参数的数量所取代（目前是0到5）。  这些宏被用来以如下方式声明异常类。
* [1.x.15]
* 第一个参数表示要创建的异常类的名称。  接下来的参数是参数的类型（这里有两种类型，与<tt>DeclExceptionX</tt>中的<tt>X</tt>相对应），最后是输出序列，你可以用它来打印附加信息。
* 输出序列的语法有点奇怪，但一旦你看到这个宏是如何定义的，就会明白了（同样是示意性的，实际的函数名称和定义可能会随着时间的推移而改变，并有所不同）。
* [1.x.16]
*
* 如果按照指定的方式声明，你以后就可以按照以下方式使用这个异常类。
* [1.x.17]
* 而如果条件失败的话，输出结果将是
* [1.x.18]
*
* 显然对于<tt>DeclException0(name)</tt>宏，不允许有任何类型，也不允许有任何输出序列。
*

* [1.x.19]
* [2.x.20]宏的默认实现，如上所述，将关于到底出了什么问题的详细信息打印到屏幕上，然后中止程序。终止程序是很有用的，因为它可以轻松地找到出错的地方
*
* - 包括我们如何到达那个地方的所有信息
*
* - 通过在调试器中运行该程序。
* 另一方面，在有些情况下，中止程序可能是不可取的，我们需要以一种更优雅的方式退出程序
*
* - 即使在这些情况下，我们真的没有什么可以做的，仍然可以产生一个有意义的结果。一个例子是，如果一个deal.II程序是在一个更大的软件框架中运行一个模块。例如，想想这样一种情况：deal.II程序计算的流场与一些优化程序提供的一组输入变量相对应：如果外部的优化器提供了一个负的密度作为输入（一个可能要通过[2.x.21]检查的条件，那么这显然是没有意义的，流解器不能产生一个有意义的答案；但它应该很好地告诉优化器，而不是直接中止整个过程（优化器和流解器）。
* 为此，我们可以调用[2.x.22]，将[2.x.23]所做的事情从中止程序转换为与[2.x.24]基本相同，即使用C++[2.x.25]机制来引发一个异常。然后这个异常可以在更高层次上被捕获
*
* 例如，在位于流解算器之上的优化例程中，然后可以决定它要对这种情况做什么。
* 这一切都很好，但是C++不允许在类的析构器中或在当前从调用栈中更高的析构器中调用的函数中抛出异常。为此，有一个单独的宏，[2.x.26]，可以在析构器中使用。它的作用就像[2.x.27]通常做的那样
*
* - 特别是，它只检查调试模式下的条件
*
* - 但它对[2.x.28]的影响是免疫的，它只会中止程序，而不会抛出异常。
*

* [2.x.29] Wolfgang Bangerth, 1998-2017年


* [0.x.1]

include/deal.II-translator/A-headers/fe_0.txt
[0.x.0]*



* [2.x.0]
* 所有与形状函数和对形状函数的访问有关的类。  这涉及到有限元的实际值。关于自由度的编号请参考 [2.x.1] 的模块。
* 本模块的类和函数分为几个子组，在上面列出的各自子模块中讨论。此外，FETools类提供了提供有限元素、元素间变换等信息的函数。
* 从总体上看，这个模块的各个部分与库中的各种其他部分相互作用。


* [1.x.0]


* [0.x.1]*



* [2.x.2]
* 这个子模块的成员描述了有限元类的实现机制，而没有实际实现一个具体的元素。例如，FiniteElement基类声明了派生类如果要描述一个有限元空间所必须实现的虚拟函数。同样地，FiniteElementData持有描述有限元特征的某些数值的变量，例如每个顶点、线或面的自由度数。
* 另一方面，像FE_Poly和FE_PolyTensor这样的类是高级抽象。它们描述了建立在单元格上的形状函数的多项式描述之上的有限元。从它们派生出来的类只需要提供一个特定的多项式的描述，而有限元就是从这个描述中建立的。例如，实现通常的拉格朗日元素的FE_Q类使用FE_Poly基类来生成有限元，为它提供一组拉格朗日插值多项式，对应于插值点的等距细分。
* 最后，FESystem类用于处理矢量值问题。在这里，人们可能想把一些标量（或者也是矢量值）基元耦合在一起，形成矢量值算子的联合有限元。例如，对于三维Navier-Stokes流动，人们可能希望用三个Q1元素来表示速度的三个分量，用一个片状常数Q0元素来表示压力。FESystem类可以用来将这四个基本元素组合成一个具有4个矢量分量的单一矢量值元素。[2.x.3]、[2.x.4]和[2.x.5]教程程序介绍了该类在矢量值弹性（Lam&eacute;）方程的使用。  [2.x.6]讨论了一个混合拉普拉斯离散化，也使用了矢量值元素。
*


* [2.x.7]


* [0.x.2]*



* [2.x.8]
* 本模块中的类在人们想要组装矩阵或矢量时使用。它们将有限元、正交对象和映射联系起来：有限元类描述单元格上的有限元空间（即单位线段、正方形或立方体<tt>[0,1]^d</tt>），正交类描述正交点的位置和它们的权重，映射类描述如何将一个点从单元格映射到实数单元并返回。由于积分发生在实单元上的正交点，需要知道它们的位置以及这些点的有限元形状函数的值和梯度。FEValues类可以协调获得这些信息。对于面的积分（例如边界上的积分，或者单元间的界面），FEFaceValues类提供了与FEValues类对单元类似的功能。最后，FESubfaceValues类提供了在面的一部分进行积分的可能性，如果相邻的单元被细化，并且目前的单元只与相邻的单元共享其面的一部分。如果使用矢量值元素，FEValues和相关的类允许访问所有的矢量组件；如果想挑选单个组件，有一些提取器类可以使这个任务更简单，如[2.x.9]模块中所述。
* 这一组的最后一个成员，UpdateFlags枚举，是作为一种优化使用的：与其让FEValues类计算与一个单元上给定的有限元有关的每一个可能的数据，你必须预先指定你真正感兴趣的信息。UpdateFlags枚举用于提供符号名称，表示您希望FEValues类计算的内容。
* 从[2.x.11]开始，所有这些类都在[2.x.10]的 "教程程序 "中使用，并且在那里有详细的描述。
* FEValues类和朋友们的实际工作很复杂，因为它必须是通用的，但又是有效的。[2.x.12]的页面试图对其工作原理做一个概述。
* 从总体上看，这个模块的各个部分与库的其他部分相互作用。


* [1.x.1]



* [2.x.13]


* [0.x.3]*



* [2.x.14]
* 这里的类描述了有限元空间，如最简单的Q1（双/三线）空间，以及高阶拉格朗日空间Qp，但也有更专业的空间，如Nedelec或Raviart-Thomas空间。具体的实现是由抽象的FiniteElement基类派生的。
* 本质上，这些类必须实现的函数提供了查询单元格上某一点的形状函数的值或导数的能力。为了在整合矩阵和右手条目中发挥作用，我们必须有能力将这些形状函数和梯度映射到实际单元中。这是由Mapping基类（见[2.x.15]）和FEValues类（见[2.x.16]）共同派生的类来完成的。
* [1.x.2]
* deal.II提供了两种不同类型的向量值元素。首先，有一组真正的矢量元素，通常通过以下事实来区分，即每个矢量分量由一组不同的各向异性多项式组成。这些元素通常与微分形式相关。目前，它们是
* [2.x.17] [2.x.18] FE_ABF [2.x.19] FE_BDM, FE_DGBDM [2.x.20] FE_Nedelec, FE_DGNedelec [2.x.21] FE_RaviartThomas, FE_DGRaviartThomas [2.x.22] 。
* 另外，deal.II提供了一种机制，可以从现有的标量或矢量元素中创建一个矢量元素。FESystem类负责这个工作：它本身并不描述形状函数，而是从其他有限元对象中组装一个矢量值的有限元。这个功能在[2.x.23], [2.x.24]和之后的其他教程程序中有所描述。
*

*
* [2.x.25] FE_PolyTensor类提供了对矢量值元素的实现支持。通常情况下，一个新的向量元素应该派生自这个类。
* [1.x.3]
* 对于每个符合任何弱可微函数空间的有限元，如[1.x.4]或[1.x.5]，我们可以通过简单地将顶点、边或面的所有自由度分配到单元的内部来定义一个类似的DG空间。这要从拓扑学的角度来理解。这种自由度的插值算子仍然会在边界上。  虽然没有这样做，但我们提供了很多这样的元素，加上那些没有符合要求的对应元素，比如FE_DGP。以下是当前DG元素的列表。  [2.x.26] [2.x.27] 标量。FE_DGP, FE_DGQ [2.x.28] 标量，不同的形状函数。FE_DGPMonomial, FE_DGPNonparametric, FE_DGQArbitraryNodes [2.x.29] 矢量值的。  FE_DGBDM, FE_DGNedelec, FE_DGRaviartThomas [2.x.30]
*

*
* [2.x.31] FE_DGVector类支持向量值DG元素的实现，其方式是只需要提供向量多项式空间。由此派生的实际类只需要实现一个构造函数和 [2.x.32] 。
*
* [2.x.33]


* [0.x.4]*



* [2.x.34]
* 本模块中的类用于从单位坐标映射到真实单元格的坐标。最常见的是，人们使用MappingQ1类，它提供了一个Q1（双线/三线）映射（即对通常的Q1元素来说是一个等价的映射）。然而，还有其他一些实现高阶映射的类，以提供曲线元素。这些在[2.x.35]和[2.x.36]的教程程序中讨论。
* MappingQ1Eulerian类是对MappingQ1类的扩展，它接受一个描述域的每个位置的位移场的向量。这在欧拉计算中使用，不需要在每个时间步长后实际移动顶点。
* 此外，MappingC1类提供了一个计算域的边界，这个边界不仅是弯曲的，而且在边界上两个单元之间的界面上有一个连续的导数。
* 最后，MappingCartesian类是对砖形且边缘与坐标轴平行的元素的优化。
* 从总体上看，这个模块的各个部分与库的其他各种部分相互作用。


* [1.x.6]



* [2.x.37]


* [0.x.5]

include/deal.II-translator/A-headers/fe_vs_mapping_vs_fevalues_0.txt
[0.x.0]*



* [2.x.0]
* [1.x.0]
* 大多数人只创建一次有限元（以及可能的映射）对象，但实际上从未调用过任何成员函数
*
* - 他们只是通过FEValues接口使用它们进行装配。大多数人唯一的其他互动是通过读取[2.x.1]变量，但这也只是在构造时设置的。换句话说，人们从来没有观察到FiniteElement或Mapping对象实际上是[1.x.1]的东西。
*
* - 而这完全是设计好的。
* 因此，本文档是为那些对编写有限元或映射类感兴趣，并想了解FEValues如何工作以及与FiniteElement和Mapping类互动的人准备的。在下文中，我们将不对FEValues（作用于单元）、FEFaceValues（作用于面）和FESubfaceValues（作用于单元的面的子女）进行区分，因为它们在概念上都是一样的。因此，在下面的文字中，"FEValues "这个术语将被普遍用于所有这三个类。
*

* [1.x.2]
* 在详细介绍数据和控制流之前，让我们定义哪个类负责提供什么样的信息。
* [1.x.3]
* FEValues是一个抽象的概念，它来自于这样的观察：人们在有限元代码中所做的几乎所有事情都只需要在正交点评估有限元的形状函数。例如，可以用正交[1.x.5]对[1.x.4]形式的积分进行逼近，但在想要生成图形输出时也同样有效：在那里我们只需要知道网格顶点的有限元场的值，这也可以写成在正交点评估一切
*
* - 这些正交点就是单元的顶点（例如由QTrapez提供）。
* FEValues的作用是为用户提供形状函数的值，以及它们的梯度，等等，在正交点。一些几何信息也是如此，例如，正交点的法向量。为此，它在FEValuesBase基类中提供了大量的成员函数，允许用户查询有关形状函数和几何信息的所有信息，但仅限于FEValues对象被初始化的正交点。
* FEValues本身并不实际计算这些信息。它实际上只是提供了一个存储信息的地方，然后协调映射和有限元类之间的互动，让它们计算所要求的信息并将结果存储在FEValues提供的位置。
* 最后，请记住，FEValues可以提供一系列令人难以置信的信息，但几乎所有的信息在任何情况下都是不必要的。例如，为了计算上述积分，不需要知道形状函数的二阶导数，也不需要知道正交点的法向量。为此，FEValues在与Mapping和FiniteElement类的交互中使用UpdateFlags来确定实际需要计算的内容。这在 [2.x.2] 中有稍微详细的讨论。
*

* [1.x.6]
* 映射（即从映射基类派生的类）负责与从参考（单位）单元 [2.x.3] 到每个实际单元 [2.x.4] 的映射有关的一切。这是由一个映射函数[2.x.5]促成的。因此，映射类实现了一些接口，允许评估 [2.x.6] 从参考单元向前映射点 [2.x.7] 到 [2.x.8] ，并使用 [2.x.9] 从实际单元向后映射到参考单元。映射提供的其他常见操作是将向量（你可以认为是连接到参考单元上的点[2.x.10]并指向某些方向的向量）映射到真实单元上的等效向量。例如，这就是我们需要对形状函数的梯度所做的工作：这些是定义在参考单元上的向量，我们需要将这些梯度映射到实数单元上 [2.x.11] 。类似的操作也可以为矩阵（等级为2的张量，而不是等级为1的向量）和高阶张量定义。
* 许多这样的映射不仅需要映射[2.x.12]本身，还需要这个映射的梯度，通常被称为雅各布[2.x.13]，以及高阶导数。
* 由于FEValues只需要在正交点评估这些东西，所以映射一般不需要提供在[1.x.7]点评估的能力。相反，正如我们将在下面看到的，它们将被初始化为使用在参考单元上定义的一组正交点，然后为一个特定的单元 "重新初始化"，然后所有进一步的操作将只需要在真实单元上的这些正交点评估[2.x.14]。
* 映射类具有双重作用：(i)计算几何信息（如法向量、雅各布定理等），并将其放入数据结构中，FEValues可以将其提供给用户；(ii)提供有限元所需的支持，将形状函数及其导数从参考单元映射到实际单元。
*

* [1.x.8]
* 有限元类（即从FiniteElement派生的类）负责在参考单元上定义其形状函数、导数和许多其他方面，但也负责在实际单元上计算映射值和导数（显然是在映射对象的帮助下）。在目前的讨论中，只有后一个角色是重要的。
* 与映射一样，这里对我们来说重要的是有限元类可以在给定的正交点上提供这些信息，并且它们可以将计算的信息放入FEValues提供的结构中，然后FEValues的成员函数可以通过FEValuesBase中的成员函数将其传递给用户。
*

* [1.x.9]
* 假设用户想要计算形状函数的梯度，比如说计算上面的积分。然后他们会通过给出update_gradients标志来初始化一个FEValues对象（从[2.x.15]开始，基本上每个教程程序都会这样做）。这表明用户希望FEValues对象能够提供真实单元上形状函数的梯度，但没有表示希望得到任何其他信息。
* 然后，FEValues将首先找出映射对象和有限元对象之间的实际需求，以实现这一目标。这在运行FEValues构造函数时已经发生了。因为映射不依赖于有限元（尽管后者依赖于前者），FEValues首先通过[2.x.16]询问有限元需要哪些[1.x.10]的信息来实现用户的请求。例如，如果有限元是FE_Q类型，那么它将确定为了计算实单元[2.x.17]上形状函数的梯度，它需要计算参考单元上形状函数的梯度（这是它自己可以做到的，不需要任何外部帮助），但是这些参考梯度必须在每个正交点上乘以映射的雅各布系数的逆值[2.x.18]。这个乘法通常被称为[1.x.11]，因此FE_Q的[2.x.19]函数的实现（在中间类FE_Poly中提供）将同时返回原始的update_gradients标志以及update_covariant_transformation。
* 在第二步中，FEValues对象将调用映射中的相应函数，[2.x.20]以确定提供update_gradients和update_covariant_transformation的要求。前者不在映射的范围内，所以被忽略了。后者通常需要先计算雅各布矩阵[2.x.21]，一个典型的映射类将通过在列表中添加 update_contravariant_transformation 来表示。
*

* [1.x.12]
* 此时，FEValues对象已经找出了一套完整的标志，表明大家要计算什么来满足用户的要求。下一步，仍然是在构建FEValues对象的过程中，源于这样的认识：许多东西可以预先计算一次，然后在我们每次移动到一个真正的单元时重复使用。一个例子是，为了计算真实单元上形状函数的梯度，我们需要知道参考单元上形状函数的梯度（在参考单元上的正交点），而且这些梯度总是相同的：每次我们访问一个新单元时，这些值都会保持不变，所以每次都重新计算它们是低效的。对于一些映射类所计算的一些信息也可以提出类似的论点。
* 因此，FEValues对象同时初始化了映射和它所指向的有限元对象，使用正交对象和上一节所述的最后一组更新标志来计算。这个初始化包括预先计算这些类在给定更新标志集后可以预先计算的内容，然后存储这些信息供以后使用。
* 然后问题来了：在哪里存储这些信息。在实践中，我们不希望将这些信息存储在映射或有限元对象本身，因为这意味着（i）一次只能有一个FEValues对象使用任何给定的映射或有限元对象，以及（ii）这些对象不能在多线程环境下使用。
* 相反，该方法是这样的。
*



* - FEValues调用[2.x.22]（以及FEFaceValues调用[2.x.23]和FESubfaceValues调用[2.x.24]，带有正交对象和最后一组更新标志。从Mapping派生出来的类中的这些函数的实现将分配一个从[2.x.25]派生出来的类型的对象，在那里他们基本上可以存储他们认为有用的任何东西，以便以后重新使用。  [2.x.26]本身实际上并没有提供任何重要的成员变量，但真正留给派生类的是他们认为在这个时候他们可以有效地预先计算和存储的东西。如果一个映射没有什么需要预先计算的（或者映射类的作者很懒，不想考虑什么可能被预先计算），那么这样的类将简单地从[2.x.27]中派生出它自己的InternalData对象，而没有实际添加任何成员变量。
* 这样产生的对象就会被返回到FEValues中的调用站点，并由FEValues对象存储。以后每当FEValues对象想要从映射中获得任何信息时，它都会被交还，从而为映射对象提供了读取其先前存储的数据的能力。
*


*
* - 其次，FEValues也调用[2.x.28]（FEFaceValues调用[2.x.29]，FESubfaceValues调用[2.x.30]，再次调用正交对象和最后一组更新标志。这些函数的作用与它们在映射中的对应函数基本相同，而且这样初始化的对象，这次是源自[2.x.31]的类型，每当FEValues对象在以后的时间里想要从有限元对象那里得到一些东西时，总是会被反馈给有限元。
* 这种方法允许我们同时从多个FEValues对象中使用有限元和映射对象，也可能同时从多个线程中使用。重点是，有限元或映射对象的每个用户都会持有他们自己的、唯一的、从[2.x.32]函数返回的对象，而且所有发生的事情都发生在这些对象上，而不是映射或有限元对象本身的成员变量上。
*

* [1.x.13]
* 之前的所有步骤都发生在创建FEValues对象的时候。到此为止，我们所做的都是设置数据结构，但从用户的角度来看，到目前为止还没有计算出任何有用的东西。这只发生在 [2.x.33] 在具体单元格上被调用时 [2.x.34] 。
* 然后FEValues所做的事情是，按照这个顺序。
*


*
* - FEValues计算出该单元是否是调用了[2.x.35]的前一个单元的平移或其他类似的简单转换。这个结果存储在[2.x.36]对象中，然后将被传递给映射和有限元，以潜在地简化一些计算。例如，如果当前单元只是前一个单元的平移，那么就不需要重新计算映射的雅各布矩阵[2.x.37]（或其逆），因为它将与前一个单元相同。
*


*
* - 接下来，[2.x.38]调用[2.x.39]（显然，FEFaceValues调用[2.x.40]，FESSubfaceValues调用[2.x.41] 这个函数的参数包括我们被要求访问的单元格（或面，或子面），以及上面的单元格相似性参数，对我们之前从[2.x.42]获得的对象的引用，以及对[2.x.43]类型的对象的引用，映射应该把它的结果写入其中。特别是，它需要计算之前由更新标志指定的所有映射相关信息，然后将它们写进输出对象。   在输出对象中，映射需要填充的字段的例子是JxW值的计算、雅各布矩阵及其反值的计算，以及单元格（如果dim小于spacedim）和面的法向量。
*


*
* - 最后，[2.x.44]调用[2.x.45]（显然，FEFaceValues调用[2.x.46]，FESSubfaceValues调用[2.x.47] 这个函数的参数包括我们被要求访问的单元格（或面，或子面），以及上面的单元格相似性参数，对我们之前从[2.x.48]获得的对象的引用，以及对[2.x.49]类型的对象的引用，映射应该将其结果写入其中。
* 除了这些，[2.x.50]函数还接收对正在使用的映射对象的引用，以及我们之前从[2.x.52]中收到的[2.x.51]对象。原因是，通常，有限元希望将形状函数的值或梯度从参考单元映射到实际单元，而这些映射由各种[2.x.53]函数提供便利
*
* - 这都需要对FEValues对象先前从映射中获得的内部对象的引用。这可能最好是通过查看实际代码来理解，在[2.x.54]中可以找到一个简单而有启发性的例子，该函数适用于一般标量、多项式有限元基。
* 与映射一样，[2.x.55]函数然后使用它们之前在构建FEValues对象时计算的任何信息（即当它调用[2.x.56]时，使用这个和映射中的函数来计算更新标志所指定的任何请求。
* 这一切完成后，我们终于可以向FEValues的所有者提供对最初通过更新标志要求的字段的访问。
*


* [2.x.57]


* [0.x.1]

include/deal.II-translator/A-headers/functions_0.txt
[0.x.0]*



* [2.x.0]
* 函数在deal.II中被用于不同的地方，例如用来描述边界条件、方程中的系数、强制项或精确解。由于方程的封闭式表达式通常很难作为函数参数传递，deal.II使用函数基类来描述这些对象。基本上，这个基类的接口要求派生类实现返回一个或一列特定位置的函数值的能力，以及可能的（如果需要）函数的梯度或二次导数。有了这个，函数对象就可以被像[2.x.1][2.x.2]这样的算法和其他函数所使用。
* 有些函数是反复需要的，因此已经在deal.II中提供。这包括一个具有常数值的函数；一个在任何地方都为零的函数，或者一个只有一个向量分量具有特定值而所有其他分量为零的向量值函数。在函数命名空间中还定义了一些更专门的函数。
*

* [1.x.0]
* 对于时间相关的计算，边界条件和/或右手边的函数也可能随时间变化。由于在一个给定的时间步长，人们通常只对函数的空间依赖性感兴趣，如果必须向所有使用函数对象的方法传递一个时间变量的值，那就很尴尬了。例如，[2.x.3]函数将不得不接受一个时间参数，当它想查询边界函数在特定时间步长的值时，它可以使用这个参数。然而，如果我们考虑的是一个静止的问题，它也必须这样做，因为在这个问题上没有类似时间变量的东西。
* 为了规避这个问题，函数对象总是只被认为是空间函数。然而，Function类是由FunctionTime基类派生出来的，如果有必要的话，它可以存储一个时间变量的值。这样，人们可以定义一个作为空间函数的函数对象，但在内部可以通过引用一个特定的时间来实现。在上面的例子中，在把函数对象交给[2.x.4]方法之前，人们会把它的时间设置为现在的时间步长。
*

* [1.x.1]
* 函数类是最常用的，但有时人们需要一个函数，其值是张量，而不是标量。TensorFunction模板可以为你做到这一点。除了返回类型外，该接口与函数类的接口基本相同。


* [0.x.1]

include/deal.II-translator/A-headers/geodynamics_0.txt
[0.x.0]*
* [2.x.0]
* deal.II的[2.x.1]"教程 "包含一组程序，它们共同构成了地球动力学示范套件。这些程序的想法是利用地球动力学的应用来演示高级有限元软件的技术，也就是对固体地球过程的研究。通过这样做，这些程序应该为解决实际地球动力学问题的更专业的专用程序提供一个基础，例如作为研究生或博士后工作的一部分。下面将对这些计划的动机进行更深入的讨论。
* 目前，地球动力学测试套件包含以下程序。

* - [2.x.2] : 弹性
*
* - [2.x.3] : 一个%平行弹性求解器
*
* - [2.x.4] : 多孔介质流
*
* - [2.x.5] : 通过多孔介质的多相流动
*
* - [2.x.6] :斯托克斯流
*
* - [2.x.7] : 热对流（Boussinesq流动

* - [2.x.8] ：用于地幔对流的%平行布西尼克解算器
* 其中一些程序是根据加州理工学院的合同开发的，得到了美国国家科学基金会EAR-0426271号奖的支持，这是资助[1.x.0]计划的第一笔拨款。接受者Wolfgang Bangerth对这一支持来源表示衷心感谢。
*

* [1.x.1]
* 自适应网格细化（AMR）长期以来一直被认为是一项关键技术，它可以帮助精确和有效地解决一些地球动力学应用的数值问题。它在地球动力学界已经讨论了好几年，并且自CIG成立以来一直是其任务清单上的一个议题。然而，到目前为止，在这个方向上发生的事情还比较少。直到最近，才有了在地球动力学中使用AMR的尝试。CIG于2007年10月在Boulder举办了一次关于AMR技术的研讨会；George Biros、Omar Ghattas、Mike Gurnis和ShijieZhong小组之间的合作目前正在开发一个%并行的自适应地幔对流处理器；deal.II的一些主要开发者最终开发了用于模拟地幔对流的[1.x.2]，现在已经是相当成熟和广泛使用的代码。
* AMR技术在地球动力学中应用缓慢的原因之一是最初的障碍比较大：代码必须提供数据结构和算法来处理自适应网格，有限元必须能够处理悬挂节点，等等。要做到这一点，在足够的通用性下，有限元程序要增加几万行代码，对于普通学生来说，在学位论文的时间范围内是无法做到的。另一方面，有一些库提供了基础代码，支持AMR的应用可以在此基础上迅速建立。当然，deal.II正是提供了这种基础。
* 地球动力学测试套件的目标是为与地球动力学相关的各种主题编写程序。继续保持现有教程程序的风格
*
* - 一个广泛的介绍，解释一个应用的背景和形式，以及在其解决方案中使用的数值方案的概念；整个代码中的详细评论，解释实施细节；以及一个显示数值结果的部分
*
* - 我们打算将所产生的程序作为解决模型问题的有据可查的应用程序来提供。特别是，它们旨在实现以下目标。[2.x.9] [2.x.10] [1.x.3] 现有的deal.II教程已被证明是一个很好的起点，可供研究生和研究人员快速开发自己的应用程序。通过提供已经接近目标应用的程序，通常可以很快获得第一个结果，既保持了开发过程中最初的热情，也允许将研究时间用于实现特定的应用行为，而不是将几个月的工作用于支持AMR的基本基础代码。
* 支持这一观点的事实是，尽管有[1.x.4]介绍了用deal.II获得的结果，但我们知道只有相对较少的应用是用deal.II从头开始建立的；所有其他的应用都是从某个教程程序的修改开始的。
* [2.x.11] [1.x.5] 我们建议编写的教程程序将为学生和研究人员提供当前数值技术的参考实现，如AMR、高阶元素、复杂的线性和非线性求解器、稳定技术等。提供这些作为其他人进一步开发的起点，也将有助于实现在现代数值算法方面培训新一代地球动力学家的目标。
* [2.x.12] [1.x.6] 在deal.II中，用另一个方程扩展一组方程是相当简单的，例如，一个额外的平流量作为右手边或在一个系数中进入现有方程。由于应用通常使用封锁的矩阵，而不是用一个大矩阵代替所有东西的方法，所以为增强方程找到合适的线性求解器也不复杂。因此，deal.II是一个很好的工具，可以尝试更复杂的问题公式，或更完整的模型及其对解的准确性的影响。
* [2.x.13] [1.x.7] deal.II提供了许多可互换的组件，允许快速建立有限元种类和顺序、稳定技术或线性求解器的原型。例如，通常只需要改变几行代码就可以用高阶元素取代低阶元素。通过这种方式，尝试高阶元素、不同的块消除求解器或不同的稳定技术变得相对简单。反过来，这可能有助于在计算求解时间和数值解的准确性方面对应用进行基准测试。
* 本模块中的应用将已经过正确性的基准测试。现有的教程程序通常采用更简单而不是更复杂的求解器方案进行阐述，但经常建议采用更复杂的方案，包括在附录中提示如何实现这些方案。
* [2.x.14] [1.x.8] deal.II的快速原型能力也可能有助于在deal.II适用的程序规模上确定最佳算法，然后在可以在更大规模的机器上运行的专用程序中实现这种特定的算法（没有能力轻易改变它）。例如，一个建立在deal.II上的小型地幔对流代码可以用来确定二阶元素是否对这个目的有用（例如，见[2.x.15]中所示的结果）。如果是这样，那么人们就可以在更大的代码中使用这种知识，比如上面提到的ASPECT代码。[2.x.16]
*


* [0.x.1]

include/deal.II-translator/A-headers/geometry_and_primitives_0.txt
[0.x.0]*



* [2.x.0]
* 本组包含一些作为几何基元或其他数学对象的基元的类。例如，Tensor [2.x.1] 类提供了等级为[2.x.2]的空间维度的张量。同样地，SymmetricTensor提供了对称的张量。
* 在几何学上，点类是deal.II库中所有几何描述的基础。它表示[2.x.3]维空间中的一个几何点。我们可以把一个点看作是一个坐标为[2.x.4]的矢量，它连接着原点和那个特定的点；因此，点类是从秩1的张量（即矢量）派生出来的，但与任意张量相比，点具有空间中点的特殊内涵，因此具有一些额外的属性。
* 在deal.II中，网格是由线段、四边形或六面体（取决于空间维度）构建的。GeometryInfo类用于描述这些基本对象在单位空间中的属性（即对于单位线、单位方和单位立方）。它提供了静态数据成员，表示每个单元的顶点数量、每个面的线，或者顶点的位置。这种抽象允许编写的应用程序大多独立于实际的空间维度：所有顶点的循环只是从0到[2.x.5]，而不是从0到4（在2D）或0到8（在3D）。这样一来，程序在2D和3D中都是正确的，人们可以通过重新编译在不同的空间维度上运行程序，而不必改变代码的很大一部分。这些与维度无关的编程技术在前几个教程程序中得到了广泛的讨论，并在整个交易中得到应用。


* [0.x.1]

include/deal.II-translator/A-headers/global_dof_index_0.txt
[0.x.0]*
  [2.x.0]
* deal.II可以被配置为使用64位的自由度指数，而不是通常的无符号整数，在目前大多数系统上默认为32位。这是必要的，因为我们希望能够解决超过40亿个未知数的问题（32位无符号整数所能表示的极限）。同时，我们不想不分青红皂白地将deal.II中的所有整数替换成64位版本，因为这将增加许多地方的内存使用，我们在这些地方表示的数量肯定不会超过40亿。
* 我们为这些指数定义的数据类型是[2.x.1]，以保持代码库的大部分不受[2.x.2]的影响。如果deal.II被正常配置，这种类型是[2.x.3]，但如果提供正确的标志，可以切换到[2.x.4]（见ReadMe文件）。本页旨在澄清何时必须使用[2.x.5]，何时可以使用普通无符号整数。
* [2.x.6]
* <dt class="glossary"> [2.x.7] GlobalDoFIndexBlockIndices [1.x.0]</dt> [2.x.8] 块的数量是一个无符号的int，因为这个数字预计会很低，即小于四亿。然而，块的大小是一个[2.x.9]，因为每个块可以是任意的大。  [2.x.10]
* <dt class=" glossary"> [2.x.11] GlobalDoFIndexCell [1.x.1]</dt> [2.x.12] 单元的ID是不唯一的。不同细化程度的单元和/或不同处理器上的单元可以有相同的ID。因此，所有与单元相关的数据都可以是无符号的int，因为在一个处理器上，一个网格级别，肯定不会有超过40亿的单元。  [2.x.13]
* <dt class=" glossary"> [2.x.14] GlobalDoFIndexDoFHandler [1.x.2]</dt> [2.x.15] 每个自由度的ID在并行计算中是唯一的。因此，自由度是 [2.x.16] [2.x.17] 。
* <dt class=" glossary"> [2.x.18] GlobalDoFIndexFullMatrix [1.x.3]</dt> [2.x.19] 行和列的数量是[2.x.20]，即使不期望有人会创建一个有这么多条目的FullMatrix。然而，AffineConstraints类的一些方法是以矩阵类型为模板的，因此，FullMatrix的大小必须与SparseMatrix的大小为同一类型。  [2.x.21]
* <dt class=" glossary"> [2.x.22] GlobalDoFIndexSparseMatrix [1.x.4]</dt> [2.x.23] SparseMatrix的大小可以是任意大的，可以想象，在单个节点上有足够的内存，可以生成一个超过40亿行或列的矩阵。因此，采用了[2.x.24]。然而，即使对于我们现在可以解决的大型复杂问题，期望稀疏矩阵中的非零条目数超过40亿是不合理的。因此，我们仍然使用无符号int，例如，[2.x.25]和类似的函数。  [2.x.26]
* [2.x.27]


* [0.x.1]

include/deal.II-translator/A-headers/glossary_0.txt
[0.x.0]*
  [2.x.0]
* 本词汇表解释了一些在deal.II的类文件中经常使用的术语。词汇表通常只给出了一个特定概念的微观观点；如果你对大局感到困惑，那么也值得参考[2.x.1]页上的类的总体概述。
* [2.x.2]
* <dt class="glossary"> [2.x.3] GlossActive [1.x.0]</dt> [2.x.4] 如果一个单元格、面或边没有被进一步细化，即没有子代，那么它被定义为[1.x.1]。一旦一个单元、面或边成为父级，它就不再活跃。除非使用多网格算法，否则活动单元是唯一携带自由度的单元。  [2.x.5]


*
* <dt class="glossary"> [2.x.6] GlossArtificialCell [1.x.2]</dt> [2.x.7] 如果一个网格使用[2.x.8]类分布在多个MPI进程中，每个处理器只存储自己拥有的单元，其他处理器拥有的一层相邻的单元（称为[2.x.9] "幽灵单元"），所有粗粒度的单元，以及所有为维持相邻单元必须最多有一个细化级别这一不变量所需的单元。存储在每个进程上的不属于该进程且不属于幽灵单元的单元被称为 "人工单元"，对于这些单元，谓词[2.x.10]返回真。人工单元被保证存在于全局分布的网格中，但它们可能在其他处理器上被进一步细化。更多信息请参见[2.x.11] "分布式计算论文"。
* 人工单元的概念对于在每个处理器上存储整个网格的三角计算没有意义，即[2.x.12] 类。  [2.x.13]
*

* <dt class=" glossary"> [2.x.14] GlossBlockLA [1.x.3]</dt>。
* [2.x.15] 将一个矩阵或向量作为单个块的集合来处理往往很方便。例如，在[2.x.16]（和其他教程程序）中，我们要考虑全局线性系统[2.x.17]的形式[1.x.4] 。
* 其中[2.x.18]分别是速度和压力自由度的值，[2.x.19]是速度空间上的质量矩阵，[2.x.20]对应于负发散算子，[2.x.21]是其转置，对应于负梯度。
* 使用这种分解为块的方法，人们可以定义基于方程组中存在的单个算子（例如，在[2.x.22]的情况下，Schur补码）的预处理程序，而不是整个矩阵。实质上，块被用来反映线性代数中PDE系统的结构，特别是允许对具有多个解决方案组件的问题进行模块化求解。另一方面，矩阵和右手边的向量也可以作为一个单元来处理，这在线性系统的装配过程中是很方便的，例如，当人们可能不想对各个组件进行区分时，或者对于不关心块结构的外Krylov空间求解器（例如，如果只有预处理程序需要块结构）。
* 将矩阵和向量分割成块是由BlockSparseMatrix、BlockVector和相关类支持的。参见[2.x.23]模块中对各种线性代数类的概述。这些对象呈现出两个接口：一个使对象看起来像一个具有全局索引操作的矩阵或向量，另一个使对象看起来像一个可以被单独处理的子块的集合。根据上下文，人们可能希望使用一个或另一个接口。
* 通常，人们通过将构成物理量组的自由度（例如所有速度）归入线性系统的各个块来定义矩阵或向量的子结构。这在下面关于[2.x.24]"块（有限元）"的词汇条中有更详细的定义。  [2.x.25]
*

* <dt class="glossary"> [2.x.26] GlossBlock [1.x.5]</dt> [2.x.27] [1.x.6] 块是[2.x.28] "组件 "的概括，它们将人们希望共同考虑的矢量值有限元的一个或多个组件组合在一起。人们经常想这样做，以定义与作用于向量值解的微分算子（部分）结构相对应的算子，如[2.x.29]中的Schur补充求解器，或[2.x.30]的块状求解器和预处理器。
* 对于离散化的目的，块是更好的概念，因为并不总是能够解决一个解决方案的各个组成部分。特别是对于非[2.x.31]GlossPrimitive的 "原始 "元素来说，就是这种情况。以使用FE_RaviartThomas元素的混合拉普拉斯系统的解为例（见[2.x.32]）。在那里，第一个<tt>dim</tt>分量是方向性速度。由于形状函数是这些的线性组合，这些<tt>dim</tt>分量只构成一个单一的块。另一方面，压力变量是标量，将构成第二个块，但在<tt>dim+1</tt>st分量中。
* 每个块的最小尺寸由底层有限元决定（对于标量元素，一个块由一个分量组成，但以FE_RaviartThomas为例，一个块由<tt>dim</tt>分量组成）。然而，几个这样的最小块可以随意组合成用户定义的块，并根据应用情况进行组合。例如，对于[1.x.7]<sub>2</sub><sup>[1.x.8]</sup>-[1.x.9]<sub>1</sub>（Taylor-Hood）Stokes元素，有[1.x.10]+1个组件，原则上每个组件可以形成自己的块。但我们通常更感兴趣的是只有两个块，其中一个由所有的速度矢量分量组成（即这个块将有[1.x.11]分量），另一个只有一个压力分量。
* [1.x.12] deal.II有许多不同的有限元类，它们都是从FiniteElement基类派生出来的（见[2.x.33] "有限元类模块"）。除了一个例外，无论它们是标量还是矢量值，它们都定义了一个单一的块：有限元通过其[2.x.34]函数定义的所有矢量分量构成一个单一的块，即[2.x.35]返回一个。
* 例外的是FESystem类，它采取多个较简单的元素，并将它们连接成较复杂的元素。因此，它可以有一个以上的块。一个FESystem有多少个块，就有多少个基础元素乘以它们的倍数（参见FESystem的构造函数来理解这个说法）。换句话说，它并不关心每个基础元素有多少个块，因此，你可以通过创建对象产生一个只有两个块的斯托克斯元素


* [1.x.13]
* 另一方面，我们可以用dim+1块产生一个类似的对象，使用


* [1.x.14]
* 除了块的数量外，这两个对象在所有实际用途上都是一样的，但是。
* [1.x.15] 虽然我们在上面用矢量值解函数的矢量分量（或者，等同于用矢量值有限元空间）来定义块，但有限元的每个形状函数都是一个或另一个块的一部分。因此，我们可以将定义在DoFHandler上的所有自由度划分为各个块。由于默认情况下DoFHandler类以一种或多或少的随机方式列举自由度，你首先要调用[2.x.36]函数以确保所有对应于单个块的自由度被连续列举。
* 如果你这样做，你自然也会将矩阵和向量划分为块（见[2.x.37]"块（线性代数）"）。  在大多数情况下，当你将矩阵或向量细分为块时，你的做法是为有限元（即在大多数实际情况下，FESystem对象）定义的每个块创建一个块。然而，不必如此：[2.x.38]函数允许将几个向量分量或有限元块归入同一个逻辑块（例如，见[2.x.39]" [2.x.40]"或[2.x.41]教程程序，而不是[2.x.42]）。因此，利用这一特性，我们可以实现同样的结果，即把矩阵细分为[2.x.43]块，把向量细分为2块，对于上述创建斯托克斯元素的第二种方式，使用一个额外的参数，就像我们使用第一种创建有两个块的斯托克斯元素的方式一样，马上就能实现。
* 关于这个主题的更多信息可以在FESystem的文档中找到，[2.x.44]模块和其中参考的教程程序。
* [1.x.16] 许多函数允许你将其操作限制在某些矢量分量或块上。例如，插值边界值的函数就是这种情况：人们可能只想插值有限元场的速度块的边界值，而不想插值压力块。这样做的方法是给这类函数传递一个BlockMask参数，见[2.x.45]"本词汇表的block mask条目"。  [2.x.46]
*

* <dt class="glossary"> [2.x.47] GlossBlockMask [1.x.17]</dt
* [2.x.48] 就像人们可以认为元素是由物理矢量分量（见[2.x.49]）或逻辑块（见[2.x.50]）组成的一样，经常需要为不打算在有限元空间的[1.x.18]块上运行的操作选择一组此类块。使用BlockMask类来选择要操作的块。
* 块掩码的工作方式与构件掩码基本相同，包括BlockMask类与ComponentMask类有类似的语义。参见[2.x.51]"关于组件掩码的词汇表条目 "以获得更多信息。
*

*
* [2.x.52] 虽然组件和块为具有多个向量分量的有限元提供了两种交替但同样有效的观点，但事实上，在整个库中，你可以传递ComponentMask参数而不是BlockMask参数的地方要多得多。幸运的是，一个可以转换为另一个，使用的语法[2.x.53]是BlockMask类型的一个变量。换句话说，如果你有一个块掩码，但需要调用一个只接受组件掩码的函数，可以用这种语法来获得必要的组件掩码。
* [1.x.19] 块掩码通常是通过要求有限元从某些选定的矢量分量中生成块掩码来创建的，使用这样的代码，我们创建的掩码只表示斯托克斯元的速度分量（见[2.x.54] ）。


* [1.x.20]
* 结果是一个区块掩码，在1d以及2d和3d中，其值为[2.x.55] 。同样地，使用


* [1.x.21]
*在任何维度上都会产生一个掩码[2.x.56]。
* 然而，请注意，如果我们以下列方式定义有限元。


* [1.x.22]
*那么代码


* [1.x.23]
*将产生一个块掩码，在2d中具有元素[2.x.57]，因为该元素具有[2.x.58]成分和同样多的块。参见[2.x.59]"本词汇表的块条目 "中关于块具体代表什么的讨论。  [2.x.60]
*

* <dt class="glossary"> [2.x.61] GlossBoundaryForm [1.x.24]</dt
* [2.x.62] 对于二维空间中的二维三角，边界形式是一个定义在面的向量。它是单元格表面上坐标向量的图像的向量乘积。它是一个对表面的法线矢量，指向外侧，具有表面元素的长度。
* 一个更普遍的定义是（至少到这个矢量的长度为止），它正是考虑分项积分时必须的那个矢量，即形式为[2.x.63]的等式。使用这个定义也解释了在嵌入空间[2.x.65]的维数[2.x.64]的域（和相应的三角形）的情况下，这个向量应该是什么：在这种情况下，边界形式仍然是一个定义在三角形面上的向量；它与边界的所有切线方向正交，并且在域的切线平面内。请注意，这与情况[2.x.66]是兼容的，因为那里的切平面是整个空间[2.x.67] 。
* 在任何一种情况下，矢量的长度都等于参考面到当前单元面的变换行列式。  [2.x.68]


* <dt class=" glossary"> [2.x.69] GlossBoundaryIndicator [1.x.25]</dt>。
* [2.x.70] 在Triangulation对象中，边界的每一部分都可以与一个唯一的数字（类型为[2.x.71]，用于确定哪种边界条件将被应用到边界的特定部分。边界是由单元格的面组成的，在三维中，是这些面的边缘。
* 默认情况下，一个网格的所有边界指标都是零，除非你从一个网格文件中读取，并特别将其设置为不同的内容，或者你使用了命名空间GridGenerator中的一个网格生成函数，该函数有一个[2.x.72]"着色 "选项。一个典型的将部分边界指示器设置为其他东西的代码会是这样的，这里将所有位于 [2.x.73] 的面的边界指示器设置为42。


* [1.x.26]
* 这调用了函数[2.x.74] 在3D中，可能也适合调用[2.x.75]来代替每个选定的面。要查询某个特定面或边的边界指标，请使用[2.x.76]。
* DoFTools和VectorTools命名空间中的许多函数都需要参数来指定边界的哪一部分，而且它们特别提到了boundary_ids。例如[2.x.77] [2.x.78] [2.x.79] 和 [2.x.80] [2.x.81] 。
*

*
* [2.x.82] 边界指标在网格细化时从母面和边继承到子面。关于边界指示器的更多信息，也在三角形类的文档中的一个部分介绍。
*

*
* [2.x.83] 对于[2.x.84]类型的平行三角形，仅在开始时设置一次边界指标是不够的。参见[2.x.85]的类文件中关于这个主题的长篇讨论。  [2.x.86]
*

* <dt class="glossary"> [2.x.87] GlossCoarseMesh [1.x.27]</dt> [2.x.88] deal.II中的 "粗网格 "是一个三角形对象，它只由未被细化的单元组成，也就是说，在这个网格中没有单元是另一个单元的孩子。这通常是deal.II中最初构建三角形的方式，例如，使用命名空间GridGenerator中的（大部分）函数，GridIn类中的函数，或者直接使用函数[2.x.89] 当然，我们可以在这样的网格上进行计算，但大多数时候（例如，参见几乎所有的教程程序），我们首先要全局地细化粗略的网格（使用[2.x.90]或自适应地细化（在这种情况下，首先计算一个细化准则，然后计算命名空间GridRefinement中的一个函数，最后调用[2.x.91]），然后网格就不再是 "粗网格"，而是 "细化网格"。
* 在某些情况下，我们也使用 "三角形的粗略网格 "这一短语，它指的是三角形开始时的单元集，即所有目前[2.x.92]三角形的 "活动单元 "都是通过网格细化得到的。当然，一些粗略的网格单元也可能是活跃的，如果它们从未被细化的话）。
* 三角形对象以[1.x.28]的方式存储单元：特别是，粗网格的所有单元都在零层。他们的子单元（如果我们在粗网格上执行[2.x.93]）将在第一层，等等。三角形的粗网格（在上一段的意义上）正好由三角形的零级单元组成。(它们是否处于活动状态(即没有子代)或已被细化，对这个定义并不重要)。
* 大多数deal.II中的三角形类都存储了整个粗网格和至少一些细化的单元。([2.x.94]和[2.x.95]类实际上都存储了整个网格的[1.x.29]个单元，而其他一些类如[2.x.96]在并行计算的每个进程中只存储了[2.x.97]个 "活动单元 "的[1.x.30]个。)在这些情况下，人们可以查询所有粗略网格单元的三角结构。其他三角剖分类（例如，[2.x.98]只存储部分粗网格。这种情况也请参见[2.x.99]"粗网格单元ID的概念"。  [2.x.100]
*

* <dt class="glossary"> [2.x.101] GlossCoarseCellId [1.x.31]</dt> [2.x.102] 大多数deal.II中的三角形类，特别是[2.x.103] [2.x.104] 和 [2.x.105] 在并行计算的每个进程中存储三角形的整个[2.x.106] "粗略网格"。另一方面，其他类别则不是这样，特别是[2.x.107]，它是为粗略网格太大而不能存储在每个进程中，需要进行分区的情况而设计。
* 在这些情况下，在算法中经常需要唯一地引用一个粗略的网格单元。因为当前进程中的三角剖分对象实际上并没有存储整个粗网格，所以我们需要为每个粗网格单元设置一个全局唯一的标识符，这个标识符与本地存储的三角剖分零级中的索引无关。这个全局唯一的ID被称为 "粗略单元ID"。它可以通过以下函数调用来访问
* [1.x.32]
* 其中`triangulation`是指向零级单元的迭代器`coarse_cell`所属的三角结构。这里，`coarse_cell->index()`返回该单元在其细化层次中的索引（见[2.x.108] 这是一个介于零和并行计算中当前进程上存储的粗网格单元数量之间的数字；它唯一地标识了该并行进程上的一个单元，但不同的并行进程可能对位于不同坐标的不同单元使用该索引。
* 对于那些在每个进程上存储所有粗略网格单元的类，[2.x.109]只是返回可能的参数值的排列组合。在最简单的情况下，例如对于一个顺序的或并行的共享三角形，该函数实际上将简单地返回参数的值。对于其他情况，如[2.x.110]，粗略单元ID的排序与粗略单元索引的排序不一样。最后，对于诸如[2.x.111]这样的类，该函数返回全局唯一的ID，它来自一个更大的可能指数集，而不是实际存储在当前进程上的粗放单元的指数。  [2.x.112]
*

* <dt class="glossary"> [2.x.113] GlossColorization [1.x.33]</dt> [2.x.114] [2.x.115] Colorization [2.x.116] 是用不同的标签标记三角图的某些部分的过程。颜色[2.x.117]一词的使用来自制图学，即通过给地图上的国家分配不同的颜色，使它们在视觉上相互区别。使用相同的术语[2.x.119]着色[2.x.120]在数学中很常见，尽管我们给不同的区域分配整数而不是色调。交易.II将两个过程称为着色。
* [2.x.121] [2.x.122] GridGenerator命名空间中的大多数函数都采取一个可选的参数 [2.x.123] 。这个参数控制边界的不同部分是否会被分配不同的 [2.x.124] "边界指标"。   一些函数也会分配不同的 [2.x.125] "材料指标"。[2.x.126] [2.x.127] 函数[2.x.128]计算一个三角形的分解（更确切地说，是一个迭代器的范围）。没有两个相邻的单元被赋予相同的颜色。[2.x.129] [2.x.130] [2.x.131]。
*

* <dt class=" glossary"> [2.x.132] GlossComponent [1.x.34]</dt>。
* [2.x.133] 当考虑方程组时，其中的解不仅仅是一个单一的标量函数，我们说我们有一个[1.x.35]与一个[1.x.36]。例如，在[2.x.134]中考虑的弹性方程的矢量解是[2.x.135]，由三个坐标方向上的位移组成。然后，该解决方案有三个元素。同样，[2.x.136]中考虑的三维斯托克斯方程有四个元素。  [2.x.137] .我们在交易二中称矢量值解的元素为[1.x.37]。为了得到良好的解决，对于解有[2.x.138]个元素，需要有[2.x.139]个偏微分方程来描述它们。这个概念在[2.x.140]模块中讨论得很详细。
* 在有限元程序中，人们经常想解决这个矢量值解决方案的单个元素（组件），或组件的集合。例如，我们在[2.x.141]中做了大量的工作，在[2.x.142]"处理矢量值问题 "模块中也提供了大量的文档。如果你只考虑偏微分方程（而不是其离散化），那么[1.x.38]的概念是自然的。
* 另一方面，当谈论有限元和自由度时，[1.x.39]并不总是正确的概念，因为组件并不总是可以单独处理。特别是，[2.x.143]"非原始有限元 "就是这种情况。同样，人们也不一定总是[1.x.40]处理单个分量，而是处理分量的集合&mdash；例如，所有速度分量在一起，并与斯托克斯系统中的压力分开，而不进一步将速度分割成其单个分量。在这两种情况下，正确的概念是[2.x.144]"块 "的概念。  由于每个分量，如果可以单独处理，也是一个块，所以用块的方式思考，往往是更好的策略。
* 对于一个给定的有限元，可以使用[2.x.145]函数查询组件的数量，可以使用[2.x.146]找出对于一个给定的有限元形状函数，哪些向量组件是非零的。 形状函数的各个组件的值和梯度（如果元素是原始的）可以使用参考单元上的[2.x.147]和[2.x.148]函数查询。[2.x.149]和[2.x.150]函数在实数单元上做同样的事情。也请参见FiniteElement和FEValues类的文档。
* [1.x.41] 许多函数允许你将其操作限制在某些向量组件或块上。例如，插值边界值的函数就是这种情况：人们可能只想插值一个有限元场的速度分量的边界值，而不想插值压力分量。这样做的方法是给这类函数传递一个ComponentMask参数，见[2.x.151]"本词汇表的组件掩码条目"。  [2.x.152]
*

* <dt class="glossary"> [2.x.153] GlossComponentMask [1.x.42]</dt>。
* [2.x.154] 当使用矢量值元素（见[2.x.155]）来解决方程组时，人们经常希望将一些操作限制在只有某些解决变量。例如，在求解斯托克斯方程时，人们可能希望只插值速度分量的边界值而不插值压力。在deal.II中，这通常是通过传递函数a[1.x.43]完成的。分量掩码总是被指定为ComponentMask对象，我们可以把它看作一个数组，其条目数与有限元的分量一样多（例如，在Stokes情况下，有[2.x.156]个分量），每个条目要么为真，要么为假。在这个例子中，我们只想插值斯托克斯系统的速度分量的边界值，那么这个分量掩码将是[2.x.157]，在3D中表示不应设置压力变量的边界值（解决方案中的最后一个[2.x.158]矢量分量。
* 有许多函数采取这样的分量掩码，例如[2.x.159] [2.x.160] [2.x.161] 等。在某些情况下，有多个具有这些名称的函数，但只有其中一些具有分量掩码参数。
* [1.x.44] 许多函数，接受一个已经默认构建的分量掩码对象，表示[1.x.45]，也就是说，就像向量有正确的长度，并且只填充了[2.x.162]值。原因是默认初始化的对象可以使用代码片断[2.x.163]来构建到位，因此可以在函数签名中作为默认参数使用。
* 换句话说，ComponentMask对象可以处于两种状态中的一种。它们可以被一个非零长度的布尔运算向量初始化；在这种情况下，它们代表一个特定长度的掩码，其中一些元素可能是真，另一些可能是假。或者，ComponentMask可能已经被默认初始化了（使用默认构造函数），在这种情况下，它代表了一个长度不确定的数组（即适合这种情况的长度），其中[1.x.46]为真。
* [1.x.47] 分量掩码通常是通过要求有限元从某些选定的分量中生成一个分量掩码来创建的，使用这样的代码，我们创建一个掩码，只表示斯托克斯元的速度分量（见[2.x.164] ）。


* [1.x.48]
* 结果是一个组件掩码，在2d中，它的值是 [2.x.165] 。同样地，使用


* [1.x.49]
* 在2d中会产生一个掩码[2.x.166]。当然，在3D中，结果将是[2.x.167] 。
*


* [2.x.168] 正如我们可以认为组成元素是由[2.x.169] "组件 "或[2.x.170] "块 "组成的，有组件掩码（由ComponentMask类代表）和[2.x.171] "块掩码"（由BlockMask类代表）。FiniteElement类有在这两种对象之间进行转换的函数。
*

*
* [2.x.172] 并非所有的组件掩码都有意义。例如，如果你有一个2D的FE_RaviartThomas对象，那么有一个[2.x.173]形式的元件掩码是没有任何意义的，因为你试图选择一个有限元的单个矢量元件，其中每个形状函数都有[2.x.174]和[2.x.175]速度。从本质上讲，虽然你当然可以创建这样的分量掩码，但你对它无能为力。  [2.x.176]
*

*
* <dt class="glossary"> [2.x.177] GlossCompress [1.x.50]</td> </td
* [2.x.178] 对于%并行计算，deal.II使用PETScWrappers和TrilinosWrappers命名空间中定义的向量和矩阵类。当使用MPI在%parallel中运行程序时，这些类只在当前处理器上存储一定数量的行或元素，而向量或矩阵的其余部分则存储在属于我们MPI宇宙的其他处理器上。当你组装线性系统时，这就出现了一定的问题：我们向矩阵和右手边的向量添加元素，这些元素可能在本地存储，也可能不在。有时，我们也可能只想[1.x.51]一个元素，而不是向其添加。
* PETSc和Trilinos都允许添加或设置没有本地存储的元素。在这种情况下，他们将我们想要存储或添加的值写入缓存，我们需要调用其中一个函数 [2.x.179] [2.x.180] [2.x.181] 或 [2.x.182] ，然后将缓存中的值运送到拥有应该被添加或写入的元素的MPI进程。由于MPI模型只允许从发送方发起通信（也就是说，它不是一个远程过程调用），这些函数是集体的，也就是说，它们需要被所有处理器调用。
* 然而，有一个障碍：PETSc和Trilinos都需要知道这些[2.x.183]函数调用的操作是适用于添加元素还是设置元素。  在某些情况下，并不是所有的处理器都在添加元素，例如，当使用一个非常[2.x.184]的 "粗略（初始）网格 "时，一个处理器并不拥有任何单元。出于这个原因，compress()需要一个VectorOperation类型的参数，它可以是::%add，或者::%insert。从7.3版本开始，这个参数对向量和矩阵是必须的。
* 简而言之，你需要在以下情况下调用compress()（而且只在这些情况下，虽然在其他情况下调用compress()只是花费一些性能）。
* 1.在你的矩阵和向量的汇编循环结束时。如果你直接写条目或者使用[2.x.185] 使用[2.x.186]，就需要这样做。
* 2.当你完成了对矩阵/向量中单个元素的设置，然后再进行其他操作（向元素添加，其他操作如缩放、求解、读取等）。使用[2.x.187]。
* 3.和2.一样，但用于向单个元素加值。使用 [2.x.188] 。
* 所有其他的操作，如缩放或添加向量，赋值，调用deal.II（VectorTools，AffineConstraints，...）或求解器都不需要调用compress()。  [2.x.189]
*

*
* [2.x.190] 压缩是一个只适用于向量的操作，其元素在一个并行的MPI宇宙中被一个且唯一的处理器拥有。它不适用于 [2.x.191] "有幽灵元素的向量"。
*

* <dt class=" glossary"> [2.x.192] GlossConcept [1.x.52]</dt>。
* [2.x.193] 在deal.II中，有几个地方我们要求模板中的类型与某个接口相匹配或以某种方式行事：这种约束在C++中被称为[2.x.194] 概念[2.x.195]。更多信息请参见[2.x.196]中的讨论和deal.II中的概念列表。  [2.x.197]
*

* <dt class="glossary"> [2.x.198] GlossDimension [1.x.53]</td> </dt
* [2.x.199] deal.II中的许多类和函数有两个模板参数，[2.x.200]和[2.x.201] 一个例子是基本的Triangulation类。


* [1.x.54]
* 在所有这些上下文中，你看到`dim`和`spacedim`被引用，这些参数有以下含义。
* [2.x.202] [2.x.203] [2.x.204] 表示网格的维度。例如，一个由线段组成的网格是一维的，因此对应于`dim==1`。由四边形组成的网格为`dim==2`，六面体的网格为`dim==3`。[2.x.205]
* [2.x.206] [2.x.207] 表示这种网格所在空间的维度。一般来说，一维网格生活在一维空间中，同样，二维和三维网格也是如此，它们将二维和三维领域细分。因此，[2.x.208] spacedim模板参数的默认值等于[2.x.209]，但情况并不一定如此。例如，我们可能想解决地球表面的沉积物迁移方程。在这种情况下，域是地球的二维表面（`dim==2`），它生活在三维坐标系中（`spacedim==3`）。[2.x.210] [2.x.211]。
* 更一般地说，deal.II可以用来解决嵌入高维空间的[1.x.55]上的偏微分方程。换句话说，这两个模板参数需要满足`dim <= spacedim'，尽管在许多应用中，我们只需满足`dim == spacedim'。
* 按照几何学的惯例，我们说 "二维 "被定义为`spacedim-dim`。换句话说，一个由四边形组成的三角形，其坐标是三维的（我们将使用`Triangulation<2,3>`对象）具有 "codimension one"。
* 这两个参数不一样的使用例子显示在 [2.x.212] , [2.x.213] , [2.x.214] 。  [2.x.215]
*

* <dt class="glossary"> [2.x.216] GlossDoF [1.x.56]</dt>。
* [2.x.217] 术语 "自由度"（通常缩写为 "DoF"）在有限元界通常用来表示两个略有不同但相关的事情。首先是我们想把有限元解表示为形状函数的线性组合，形式为 [2.x.218] 。这里，[2.x.219]是一个膨胀系数的向量。因为我们还不知道它们的值（我们将计算它们作为线性或非线性系统的解），它们被称为 "未知数 "或 "自由度"。该术语的第二个含义可以解释如下。对有限元问题的数学描述通常是说，我们正在寻找一个满足某些方程组的有限维函数[2.x.220]（例如，[2.x.221]的所有测试函数[2.x.222]）。换句话说，我们在这里说的是，解决方案需要位于某个空间 [2.x.223] 中。然而，为了在计算机上实际解决这个问题，我们需要选择这个空间的一个基；这就是我们在上面用系数[2.x.226]展开[2.x.225]时使用的形状函数[2.x.224]的集合。当然，空间[2.x.227]的基数有很多，但我们将特别选择由传统上在网格单元上局部定义的有限元函数描述的基数。在这种情况下描述 "自由度 "需要我们简单地 [1.x.57] 空间的基函数 [2.x.228] 。对于[2.x.229]元素，这意味着简单地以某种方式列举网格的顶点，但对于更高的元素，还必须列举与网格的边、面或单元内部有关的形状函数。提供这种列举[2.x.230]的基础函数的类被称为DoFHandler。  列举自由度的过程在deal.II中被称为 "分配DoF"。  [2.x.231]
* <dt class=" glossary"> [2.x.232] GlossDirectionFlag [1.x.58]</dt>。
* [2.x.233] [1.x.59]用于嵌入高维空间的三角形中，表示单元的方向，并使流形具有方向性。它使用[2.x.234]进行访问，并在创建三角化时由三角化类进行设置。你可以使用[2.x.235]函数来改变一个三角形的所有方向标志。
* 这个标志对于像这样的情况是必须的：假设我们有一个嵌入二维空间的一维网格。
* [2.x.236]
* 在一维空间的一维网格中，我们总是可以确保一个单元的左边顶点的位置比右边顶点的位置的值要小。然而，如果我们将网格嵌入到一个高维空间中，我们就不能再这样做了。例如，上面的网格中的单元格可以用下面的顶点集来描述。<code>(0,1), (1,2), (3,2), (4,3), (4,5) </code>。(作为附带说明，注意这里我们有顶点
*
* - 例如，顶点2
*
* - 是一个以上的单元的右端点）。)如果我们把每个单元的法线定义为与连接线的第一个顶点和第二个顶点的矢量垂直的单位矢量，那么我们最终会得到如下图所示。
* [2.x.237]
* 换句话说，这个一维流形是没有方向的。我们原则上可以在创建这样的网格时恢复顶点的顺序（尽管有很好的理由不这样做，例如，这个网格可能是由提取二维网格的表面网格产生的，而我们希望保留每个线段的顶点顺序，因为它们目前与二维单元的面的顶点顺序一致）。在deal.II中选择的另一种策略是简单地与每个单元关联，法线应该是该单元的左边还是右边的法线。在上面的例子中，五个单元格的标志将是<code>true, true, false, false, true</code>。根据每个单元格上的标志值，将右法线乘以正负1，就可以得到一组为流形定位的法线向量。
* 类似的问题发生在三个空间维度的二维网格上。我们注意到，如果二维流形不可定向，就不可能找到一致的方向标志；目前deal.II不支持这种流形。  [2.x.238]
*

* <dt class=" glossary"> [2.x.239] GlossDistorted [1.x.60]</dt>。
* [2.x.240] [1.x.61]是指从参考单元到实数单元的映射有一个雅各布系数，其行列式在单元的某处为非正值。通常情况下，我们只在单元格的顶点检查这个行列式的符号。函数[2.x.241]可以计算这些顶点的行列式。
* 举例来说，如果所有的行列式都是大致相等的数值，并且在[2.x.242]的顺序上，那么这个单元格就是好的形状。例如，一个正方形单元或面的行列式等于[2.x.243]，而一个强剪切的平行四边形的行列式则小得多。同样地，一个边长很不相等的单元格会有差异很大的行列式。反之，一个被夹住的单元，其中两个或多个顶点的位置被折叠成一个点，在这个位置的行列式为零。最后，一个倒置或扭曲的单元，其中两个顶点的位置是失序的，将有负的行列式。
* 下面两张图片显示了2D和3D的一个完好的单元，一个捏合的单元和一个扭曲的单元。
* [2.x.244]
* [2.x.245]
* 扭曲的细胞可以以两种不同的方式出现。原始的[2.x.246]"粗略网格 "可能已经包含了这样的单元，或者它们可能是由于移动或扭曲了一个相对较大的网格而产生的。
* 如果在创建三角网格时给出适当的标志，那么由GridGenerator和GridIn中的各种函数调用的函数[2.x.247]（但也可以由用户代码调用，见[2.x.248]和[2.x.249]末尾的例子]，将通过抛出一个类型为[2.x.250]的异常来提示创建带有变形单元的粗略网格。 如果你不打算在这些单元上装配任何东西，创建带有变形单元（尤其是塌陷/针状单元）的网格是合法的。例如，考虑这样一种情况：人们想模拟一种有液体填充的裂缝的弹性材料的行为，如一个储油罐。如果压力变得太大，裂缝就会被关闭
*
* 而离散裂缝体积的单元被折叠成零体积。只要你不在这些单元上进行积分来模拟流体的行为（如果裂缝的体积为零，就不存在任何流体），这样的网格是完全合法的。因此，[2.x.251]不是简单地中止程序，而是抛出一个异常，其中包含一个被扭曲的单元的列表；这个异常可以被捕获，如果你认为你可以忽略这个条件，你可以通过对捕获的异常不做任何反应。
* 函数[2.x.252]在某些情况下，可以通过移动具有未扭曲父单元的扭曲子单元的顶点来修复精化网格上的扭曲单元。
* 请注意，Triangulation类默认不测试是否存在扭曲的单元，因为确定一个单元是否扭曲并不是一个便宜的操作。如果你想让Triangulation对象测试单元格的变形，你需要在创建对象时通过传递适当的标志来指定这一点。  [2.x.253]
*

* <dt class="glossary"> [2.x.254] distributed_paper [1.x.62]</dt
* [2.x.255] "分布式计算论文 "是W. Bangerth, C. Burstedde, T. Heister和M. Kronbichler的一篇论文，题为 "大规模并行通用有限元代码的算法和数据结构"，描述了deal.II中%并行分布式计算的实现，即不仅像[2.x.256]中的线性系统被分割到不同机器的计算，还包括三角计算和DoFHandler对象。实质上，它是 [2.x.257] 命名空间和 [2.x.258] 中所用技术的指南。
* 该论文的完整参考资料如下。


* [1.x.63]
*
* 对于大规模的%并行计算，deal.II建立在[1.x.64]库的基础上。如果你使用这个功能，也请引用他们网站上列出的p4est论文。  [2.x.259]


* <dt class="glossary"> [2.x.260] GlossFaceOrientation [1.x.65]</dt> [2.x.261] 在三角测量中，通过应用右手边规则（x,y），可以从面的方向推导出面的法向量。
*
-> 法线）。)  我们注意到，在2D的标准方向中，面0和面2的法线指向单元格，面1和面3的法线指向外部。在3D中，面0、2和4的法线指向单元格内，而面1、3和5的法线指向外面。这些信息同样可以从[2.x.262]中查询到。
* 然而，事实证明，大量的三维网格不能满足这个约定。这是由于一个单元的面的约定已经暗示了相邻单元的东西，因为它们共享一个共同的面，对第一个单元的固定也固定了两个单元的相对面的法向量。很容易构建单元格循环的案例，对于这些案例，我们无法为所有面找到与该约定一致的方向。
* 由于这个原因，上述惯例只是我们所说的[2.x.263]标准方向[2.x.264] ...II实际上允许3d中的面具有标准方向，或者其相反的方向，在这种情况下，构成单元格的线会有还原的顺序，法向量会有相反的方向。你可以通过调用<tt>cell->face_orientation(face_no)</tt>来询问一个单元是否有标准方向：如果结果是[2.x.265]，那么这个面有标准方向，否则它的法向量就会指向另一个方向。在应用程序中，你需要这个信息的地方其实并不多，但库中有几个地方用到了这个。注意，在2D中，结果总是[2.x.266]。然而，虽然2D中的每个面总是在标准方向上，但你有时可以指定一些东西来假设不是这样的；一个例子是函数[2.x.267]。
* 还有两个描述面的方向的标志：face_flip和face_rotation。这些的一些文档存在于GeometryInfo类中。[2.x.268]函数中给出了它们在用户代码中的使用实例。  [2.x.269]
*

* <dt class="glossary"> [2.x.270] GlossGeneralizedSupport [1.x.66]</dt> [2.x.271] "Generalized support points"，顾名思义，是[2.x.272] "support points "的泛化。后者是用来描述一个有限元在个别点（"支持点"）上的简单[1.x.67]值。如果我们称这些点为[2.x.273]（其中帽子表示这些点定义在参考单元上[2.x.274]），那么人们通常以这样的方式定义形状函数[2.x.275]，即[1.x.68][2.x.276]只是在支持点评估函数，即[2.x.277]，并且选择基础以便[2.x.278] 其中[2.x.279] 是Kronecker三角函数。这就导致了常见的[2.x.280]"拉格朗日元素"。
*（在矢量值的情况下，除了支持点[2.x.281]外，唯一需要提供的其他信息是[1.x.69] [2.x.282]第1个节点函数对应的，因此[2.x.284] 。
* 另一方面，还有其他种类的元素不是这样定义的。例如，对于最低阶的Raviart-Thomas元素（见FE_RaviartThomas类），节点函数评估的不是一个具有[2.x.285]分量的矢量值有限元函数的各个分量，而是这个矢量的[1.x.70]。  [2.x.286] ，其中[2.x.287]是[2.x.288]所在的单元格面的法向量。换句话说，当在[2.x.290]处评估时，节点函数是[2.x.289]组件的[1.x.71]。类似的事情也发生在BDM、ABF和Nedelec元素上（见FE_BDM、FE_ABF、FE_Nedelec类）。
* 在这些情况下，元素没有 [1.x.72] ，因为它不是纯粹的插值；但是，在定义形状函数时，仍然涉及某种插值，因为节点函数仍然需要在特殊点上进行点评估 [2.x.291] 。在这些情况下，我们称这些点为[1.x.73]。
* 最后，还有一些元素仍然不适合这个方案。例如，一些层次化的基函数（例如，见FE_Q_Hierarchical元素）的定义是这样的：节点函数是有限元函数的[1.x.74]，2d的[2.x.292]，同样，3d的[2.x.293]是形状函数[2.x.294]描述的矩的顺序。其他一些元素使用边或面的矩。在所有这些情况下，节点函数根本不是通过插值定义的，那么这些元素既没有支持点，也没有广义支持点。  [2.x.295]
*

* <dt class="glossary"> [2.x.296] geometry_paper [1.x.75]</dt> [2.x.297] "geometry paper "是L. Heltai, W. Bangerth, M. Kronbichler, and A. Mola的一篇论文，题目是 "在有限元计算中使用精确几何信息"，描述deal.II如何描述域的几何信息。特别是，它讨论了Manifold类所基于的算法基础，以及它需要为网格细化、法向量的计算和其他许多几何学进入有限元计算的地方提供什么样的信息。
* 这篇论文目前可在arXiv网站https://arxiv.org/abs/1910.09824。这篇论文的完整参考资料如下。


* [1.x.76]
* [2.x.298]


* <dt class="glossary"> [2.x.299] GlossGhostCell [1.x.77]</dt> [2.x.300] 如果一个网格使用[2.x.301]类分布在多个MPI进程中，每个处理器只存储自己拥有的单元，其他处理器拥有的一层相邻单元，所有[2.x.302] "粗略级单元"，以及所有为维持相邻单元必须最多不同一个细化级别这一不变式所必须的单元。存储在每个进程上的不属于该进程但与该进程拥有的单元相邻的单元被称为 "幽灵单元"，对于这些单元，谓词[2.x.303]返回真。幽灵单元被保证存在于全局分布的网格中，也就是说，这些单元实际上被另一个进程所拥有，并且在那里没有被进一步细化。更多信息请参见[2.x.304] "分布式计算论文"。
* 幽灵单元层由所有与任何本地拥有的单元相邻的面、边或顶点的单元组成，这些单元本身并不是本地拥有的。换句话说，幽灵细胞完全包围了本地拥有的细胞的子域（当然，域的边界除外）。
* 幽灵单元的概念对于在每个处理器上存储整个网格的三角计算没有意义，即三角计算和[2.x.305]类。  [2.x.306]
*

* <dt class="glossary"> [2.x.307] GlossGhostedVector [1.x.78]</dt> [2.x.308] 在并行计算中，向量一般有两种情况：没有和有鬼魂元素。没有鬼魂元素的向量在处理器之间唯一地划分了向量元素：每个向量条目正好有一个处理器拥有它，而且这个处理器是唯一存储这个条目的值的。换句话说，如果零号处理器存储了一个向量的0...49号元素，一号处理器存储了50...99号元素，那么一号处理器访问这个向量的42号元素就不走运了：它没有被存储在这里，也无法评估其值。这将导致一个断言。
* 另一方面，在很多情况下，我们需要知道不属于本地的向量元素，例如在本地拥有的单元上评估解决方案（见[2.x.309]），其中一个自由度位于我们不属于本地的单元的接口处（在这种情况下，它必须是[2.x.310]"幽灵单元"），而邻近的单元可能是所有者
*
*--换句话说，自由度不是[2.x.311]"本地拥有"，而只是[2.x.312]"本地活动的自由度"。这种自由度的值通常存储在拥有该自由度的机器上，因此，在当前机器上将无法访问。
* 因为人们经常需要这些值，所以有第二种矢量，通常称为 "幽灵矢量"。幽灵向量在每个处理器上存储一些元素，而该处理器不是所有者。对于这样的向量，你可以读取你当前所在的处理器所存储的那些元素，但你不能写入这些元素，因为要做到这一点，需要将新的值传播给所有其他拥有这个值副本的处理器（这些处理器的列表可能是当前处理器不知道的，也没有办法有效地找到）。因为你不能写进重影向量，所以初始化这样一个向量的唯一方法是通过从一个非重影向量的赋值。这意味着我们必须从其他处理器中导入那些我们想在本地存储的元素。
* 幽灵向量的实际存储方式在并行向量的各种实现中是不同的。对于PETSc（以及相应的[2.x.313]类），重影向量存储的元素与非重影向量相同，另外还有一些由其他处理器拥有的额外元素。换句话说，每个元素在所有的处理器中都有一个明确的所有者，那些当前处理器存储但不拥有的元素（即 "幽灵元素"）只是其他地方的主值的镜像。
*
* - 因此，被称为 "幽灵"。[2.x.314]类也是这种情况。
* 另一方面，在Trilinos中（因此在[2.x.315]中，鬼魂向量仅仅是元素分布重叠的平行向量的一个视图。幽灵化的 "Trilinos向量本身不知道哪些条目是幽灵化的，哪些是局部拥有的。事实上，一个重影向量甚至可能不会存储所有非重影向量在当前处理器上会存储的元素。因此，对于Trilinos向量来说，不存在我们在非鬼魂情况下（或在PETSc情况下）所拥有的向量元素的 "所有者 "的概念，"鬼魂元素 "这个名字可能有误导性，因为在这个观点中，我们在本地可用的每个元素可能也会被存储在其他地方，但即使是这样，本地元素也不是一个主要位置的镜像值，因为每个元素没有所有者。
*


* [2.x.316] [2.x.317] 文档模块提供了不同种类的向量通常用于何处的简要概述。  [2.x.318]
*

* <dt class="glossary"> [2.x.319] hp_paper [1.x.79]</dt> [2.x.320] "hp-paper "是W. Bangerth和O. Kayser-Herold的一篇论文，题目是 "hp有限元软件的数据结构和要求"，它描述了在实现deal.II的hp-framework时使用的许多算法和数据结构。特别是，它总结了许多使用连续元素的%hp-有限元必须考虑的棘手问题。
* 这篇论文的完整参考资料如下。


* [1.x.80]
* 它可以从[1.x.81]中获得，也可以参见[1.x.82]了解详情。
* 那篇论文中显示的数字例子是用稍加修改的 [2.x.321] 版本生成的。与该教程程序的主要区别是，该程序中的各种操作都是为该论文计时的，以比较不同的选项，并表明[2.x.322]方法确实不是那么昂贵。  [2.x.323]
*

* <dt class="glossary"> [2.x.324] GlossInterpolation [1.x.83]</dt> [2.x.325] 用有限元插值的目的是计算一个代表有限元函数的系数向量，使得原始函数的[2.x.326]"节点值 "和有限元函数重合。因此，插值过程包括对给定函数[1.x.85]的所有[2.x.327]"节点函数"[1.x.84]进行评估，并将结果作为条目[1.x.86]存储在系数向量中。  [2.x.328]


* <dt class="glossary"> [2.x.329] GlossLagrange [1.x.87]</dt> [2.x.330] 基于拉格朗日插值的有限元在 [2.x.331] "支持点"。  [2.x.332]
*

* <dt class="glossary"> [2.x.333] GlossLocallyOwnedCell [1.x.88]</dt> [2.x.334] 当使用分布式网格时，这个概念标识了所有单元的一个子集，见[2.x.335]模块。在这样的网格中，每个单元正好被一个处理器所拥有。本地拥有的是那些由当前处理器拥有的。
* 并行计算中的每个处理器都有一个覆盖整个领域的三角形，该三角形由本地拥有的单元、[2.x.336]"幽灵单元 "和[2.x.337]"人工单元 "组成。  [2.x.338]
*

* <dt class="glossary"> [2.x.339] GlossLocallyOwnedDof [1.x.89]</dt> [2.x.340] 当使用分布式网格时，这个概念标识了所有自由度的一个子集，见[2.x.341]模块。  本地拥有的自由度生活在本地拥有的单元上。由于自由度只属于一个处理器，不同处理器所拥有的单元之间的接口上的自由度可能属于一个或另一个处理器，所以并非本地拥有的单元上的所有自由度也是本地拥有的自由度。
* 本地拥有的自由度是[2.x.342]"本地活动自由度 "的一个子集。  [2.x.343]
*

* <dt class="glossary"> [2.x.344] GlossLocallyActiveDof [1.x.90]</dt> [2.x.345] 这个概念在使用分布式网格时识别所有自由度的子集，见[2.x.346] 模块。  本地活动的自由度是那些生活在本地拥有的单元上的自由度。因此，在不同处理器拥有的单元之间的界面上的自由度属于一个以上处理器的本地活动自由度集合。
* 本地活动自由度是[2.x.347]"本地拥有的自由度 "的超集和[2.x.348]"本地相关自由度 "的子集。  [2.x.349]
*

* <dt class="glossary"> [2.x.350] GlossLocallyRelevantDof [1.x.91]</dt> [2.x.351] 当使用分布式网格时，这个概念确定了所有自由度的一个子集，见[2.x.352]模块。  本地相关的自由度是那些生活在本地拥有的或幽灵单元上的自由度。因此，它们可能被不同的处理器所拥有。
* 本地相关自由度是[2.x.353]"本地活动自由度 "的超集。  [2.x.354]
*

* <dt class="glossary"> [2.x.355] GlossManifoldIndicator [1.x.92]</td> </td
* [2.x.356] 构成三角网格的每个对象（单元格、面、边等），都与一个唯一的编号（类型为[2.x.357]，用于识别网格细化时哪个流形对象负责生成新点。
* 默认情况下，一个网格的所有流形指标都被设置为[2.x.358]。一个典型的代码将一个对象上的流形指标设置为其他内容，看起来像这样，这里将所有中心的[2.x.359]分量小于0的单元的流形指标设置为42。
*


* [1.x.93]
*
* 这里我们调用函数[2.x.360]。也可以用调用[2.x.361]来代替，以递归地设置每个面（和边，如果是3D）的流形标识。要查询某个特定对象边缘的流形指标，请使用[2.x.362]。
* 上面的代码只是设置了Triangulation的特定部分的流形指标，但它本身并没有改变Triangulation类在网格细化中对待这个对象的方式。为此，你需要调用[2.x.363]来将流形对象与特定的流形指标联系起来。这允许Triangulation对象使用不同的方法来寻找单元格、面或边上的新点进行细化；默认情况下，所有面和边都使用FlatManifold对象。
*

*
* [2.x.364] 在网格细化时，流形指标会从父类继承到子类。关于流形指示器的更多信息，也在Triangulation类的文档部分以及[2.x.365] "流形文档模块 "中介绍。歧管指标在 [2.x.366] 和 [2.x.367] 中使用。  [2.x.368]
* [2.x.369] [2.x.370] "关于歧管的模块"
*

* <dt class="glossary"> [2.x.371] GlossMaterialId [1.x.94]</dt> [2.x.372] 三角形的每个单元都有一个叫做 "材料ID "的属性。它通常用于具有异质系数的问题，以确定一个单元在域的哪一部分，因此，系数应该在这个特定的单元上具有哪个值。在实践中，一个单元的材料ID通常用于识别哪些单元属于域的特定部分，例如，当你有不同的材料（钢铁、混凝土、木材），但都属于同一个域。在组装双线性表格的过程中，我们通常会查询与某一单元相关的材料ID，并使用它来确定（例如，通过表格查询，或一连串的if-else语句）该单元的正确材料系数是多少。
* 这个材料ID可以在构建三角形时设置（通过CellData数据结构），也可以在之后通过使用单元格迭代器设置。关于这个功能的典型使用，请看[2.x.373]的教程程序。GridGenerator命名空间的函数通常将所有单元的材料ID设置为0。当通过GridIn类读取三角图时，不同的输入文件格式有不同的约定，但通常是明确指定材料ID，如果没有，则GridIn简单地将其设置为零。因为一个单元的材料是与域的特定区域相关的，所以材料ID在网格细化时由子单元从其父单元继承。
* 材料ID的设置和查询使用[2.x.374] [2.x.375] 和 [2.x.376] 函数。  [2.x.377]
*

* <dt class="glossary"> [2.x.378] GlossMPICommunicator [1.x.95]</dt> [2.x.379] 在消息传递接口（MPI）的语言中，通信器可以被认为是一个邮件系统，允许向邮件系统的其他成员发送信息。在每个通信器中，每个[2.x.380]"进程 "都有一个[2.x.381]"等级"（相当于门牌号），允许识别消息的发送方和接收方。不可能通过一个通信器向不属于这个通信器/邮件服务的接收者发送消息。
* 当通过命令行调用启动一个并行程序时，如


* [1.x.96]
*（或者在你的集群上使用的批处理提交系统中使用的等价物）MPI系统启动32份[2.x.382]的可执行文件。其中每个都可以访问[2.x.383]通信器，然后由所有32个处理器组成，每个都有自己的等级。这个MPI宇宙中的一个进程子集后来可以同意创建其他通信器，只允许在一个进程子集之间进行通信。  [2.x.384]
*

* <dt class="glossary"> [2.x.385] GlossMPIProcess [1.x.97]</dt> [2.x.386] 在分布式内存机器上运行并行作业时，人们几乎总是使用MPI。在那里，一个命令行调用，如


* [1.x.98]
*（或在你的集群上使用的批处理提交系统中使用的等价物）启动32份[2.x.387]的可执行文件。其中一些实际上可能在同一台机器上运行，但一般来说，它们将在不同的机器上运行，不能直接访问对方的内存空间。
* 在消息传递接口（MPI）的语言中，在（可能是不同的）机器上运行的同一可执行文件的每个副本被称为[1.x.99]。所有并行运行的进程的集合被称为 "MPI宇宙"，并由 [2.x.388] "MPI通信器" [2.x.389] 识别。
* 每个进程只能立即访问其自身内存空间中的对象。一个进程不能从其他进程的内存中读取或写入。因此，进程可以通信的唯一方式是互相发送消息。也就是说（正如在[2.x.390]的介绍中所解释的那样），人们通常会调用更高级别的MPI函数，而作为通信器一部分的所有进程都参与其中。一个例子是计算一组整数的总和，每个进程提供总和的一个项。  [2.x.391]
*

<dt class="glossary"> [2.x.392] GlossMPIRank [1.x.100]</dt> [2.x.393] 在消息传递接口（MPI）的语言中，[2.x.394]"MPI进程 "的[1.x.101]是该进程在当前作为一个并行作业运行的所有进程的集合[2.x.395]中的编号。更正确地说，它是[2.x.396]"MPI通信器 "中的数字，该通信器将所有进程的一个子集与一个并行作业组合在一起（其中[2.x.397]只是表示[1.x.102]的进程集）。
* 在每个通信器中，每个进程都有一个独特的等级，与所有其他进程的等级不同，可以在MPI通信调用中识别一个接收方或发送方。在一个处理器上运行的每个进程都可以通过调用[2.x.398]查询自己在通信器中的等级。 参与通信器的进程总数（即通信器的[1.x.103]）可以通过调用[2.x.399][2.x.400]获得。
*

* <dt class="glossary"> [2.x.401] mg_paper [1.x.104]</dt> [2.x.402] "multigrid paper "是B. Janssen和G. Kanschat的一篇论文，题为 "Adaptive Multilevel Methods with Local Smoothing for H1- and Hcurl-Conforming High Order Finite Element Methods"，它描述了在实现deal.II的多网格框架时所用的许多算法和数据结构。它是实现[2.x.403]中用于多网格方法的类的基础。
* 本文的完整参考资料如下。


* [1.x.105]
* 论文见[1.x.106]，更多细节见[1.x.107]。  [2.x.404]
*

* <dt class=" glossary"> [2.x.405] GlossNodes [1.x.108]</dt>。
* [2.x.406] 习惯上将有限元定义为一个三联体 [2.x.407] 其中
*


*
* - [2.x.408]是单元格，在deal.II中这总是一个线段、四边形或六面体。
*


*
* - [2.x.409]是一个有限维空间，例如，从[2.x.410]"参考单元 "映射到[2.x.411]的多项式空间。
*


*
* - [2.x.412]是 "节点函数 "的集合，即函数[2.x.413] 。[2.x.414]的维度必须等于节点函数的数量。有了这个定义，我们可以定义局部函数空间的基础，即一组 "形状函数"[2.x.415]，要求[2.x.416]，其中[2.x.417]是克朗克三角。
* 这种对有限元的定义有几个优点，涉及分析和实施。对于分析来说，它意味着与某些空间[2.x.418]的一致性，例如连续性，是由节点函数决定的。在deal.II中，它有助于大大简化像FE_RaviartThomas这样的复杂元素的实现。
* 节点函数的例子是[2.x.419]"支持点 "中的值和关于Legendre多项式的矩。例子。
* [2.x.420]
* 如上所述，有限元的构造允许编写描述有限元的代码，只需提供一个多项式空间（无需给它任何特定的基础）。
*
* - 任何方便的都是完全足够的）和节点函数。例如，在[2.x.421]函数中就用到了这一点。  [2.x.422]
*

* <dt class="glossary"> [2.x.423] GlossParallelScaling [1.x.113]</dt> [2.x.424] 当我们说一个并行程序可以 "扩展 "时，我们的意思是，如果我们让它解决的问题变大，程序不会变得过于缓慢（或占用过多的内存），如果我们保持问题大小不变但增加处理它的处理器（或内核）数量，运行时间和内存消耗将按比例减少。
* 更具体地说，想想一个问题，其大小由一个数字[2.x.425]给出（可以是单元格的数量，未知数的数量，或其他一些指示性的数量，如解决它所需的CPU周期的数量），对于这个问题，你有[2.x.426]个处理器可用于解决。在一个理想的世界里，这个程序需要的运行时间是[2.x.427]，这意味着我们可以通过提供更多的处理器将运行时间减少到任何想要的值。同样，为了使程序具有可扩展性，其总体内存消耗需要为[2.x.428]，在每个参与的进程上需要为[2.x.429]，这再次意味着我们可以通过提供足够多的处理器，将任何问题纳入计算机附加在每个处理器上的固定内存量。
* 对于可扩展性的实际评估，我们经常区分 "强 "和 "弱 "可扩展性。这些评估渐进式的声明，如[2.x.430]极限中的运行时间[2.x.431]和/或[2.x.432] 。具体来说，当我们说一个程序是 "强可扩展性 "时，我们的意思是，如果我们有一个固定大小的问题[2.x.433]，那么我们可以通过向该问题投掷更多的处理器来减少运行时间和内存消耗（在每个处理器上）与[2.x.434]成反比。特别是，强可扩展性意味着，如果我们提供两倍的处理器，那么每个进程的运行时间和内存消耗都将减少2倍。换句话说，通过提供越来越多的处理器，我们可以越来越快地解决[1.x.114]的问题。
* 相反，"弱可扩展性 "是指如果我们将问题大小[2.x.435]增加一个固定的系数，并将可用于解决问题的处理器[2.x.436]的数量增加相同的系数，那么整体运行时间（以及每个处理器的内存消耗）保持不变。换句话说，我们可以通过提供越来越多的处理器，在相同的壁时钟时间内解决[1.x.115]。
* 在这个理论意义上，没有一个程序是真正可扩展的。相反，一旦[2.x.437]或[2.x.438]的增长超过一定的限度，所有的程序就不再具有可扩展性。因此，我们经常说 "程序可以扩展到4000个核心"，或者 "程序可以扩展到100,000,000个未知数 "这样的话。程序不能无限制扩展的原因有很多；这些都可以通过查看（相对简单的）[2.x.439]教程程序来说明。
*


*
* - 序列部分。许多程序都有不能或不能并行化的代码部分，也就是说，一个处理器必须做一定的、固定的工作量，不会因为周围总共有[2.x.440]个处理器而减少。在[2.x.441]中，生成图形输出时就是这种情况：一个处理器为整个问题创建图形输出，也就是说，它需要做[2.x.442]工作。这意味着这个函数的运行时间为[2.x.443]，而不考虑[2.x.444]，因此整个程序将无法达到[2.x.445]的运行时间，而是有一个可以描述为[2.x.446]的运行时间，其中第一项来自可扩展的操作，如组装线性系统，而后者来自在进程0上生成图形输出。如果[2.x.447]足够小，那么程序可能看起来对小数量的处理器具有强扩展性，但最终强扩展性将停止。此外，程序也不能弱扩展，因为在以相同的速度增加处理器数量[2.x.449]的同时，增加问题的大小[2.x.448]并不能保持这一个函数的运行时间不变。
*


*
* - 重复的数据结构。在 [2.x.450] 中，每个处理器存储整个网格。也就是说，每个处理器都要存储一个大小为 [2.x.451] 的数据结构，而不考虑 [2.x.452] 。最终，如果我们使问题的大小足够大，即使我们增加处理器的数量，这也会溢出每个处理器的内存空间。因此，很明显，这种复制的数据结构可以防止程序弱速扩展。   但它也阻止了程序的强扩展，因为为了创建一个大小为[2.x.453]的对象，至少要写到[2.x.454]的内存位置，要花费[2.x.455]的CPU时间。因此，如果我们提供越来越多的处理器，整个算法的一个组成部分不会表现为[2.x.456]。
*


*
* - 通信。仅举一个例子，如果你想计算一个向量的[2.x.457]常数，而所有MPI进程都存储了一些条目，那么每个进程都需要计算其自身条目的平方之和（这需要[2.x.458]时间，因此可以完美扩展），但随后每个进程都需要将其部分之和发送到一个进程，将它们全部相加并取平方根。在最好的情况下，发送一个包含单个数字的信息需要恒定的时间，而不考虑进程的总体数量。因此，同样地，每一个做通信的程序都不能强势扩展，因为程序中有些部分的CPU时间要求并不随着你为固定规模分配的处理器数量而减少 [2.x.459] 。在现实中，情况实际上更糟糕：参与一个通信步骤的进程越多，一般来说需要的时间就越长，例如，因为要把所有人的贡献加起来的那个进程必须把所有的东西加起来，需要 [2.x.461] 时间。换句话说，CPU的时间[1.x.116]与进程的数量有关，因此不仅阻止了程序的强扩展，而且也阻止了弱扩展。实际上，MPI库并不通过将每个消息发送到一个进程，然后将所有的东西加起来来实现[2.x.462]规范；相反，它们在树上做成对的减少，而不是像[2.x.463]那样增长运行时间，而是像[2.x.464]那样，以发送更多消息为代价。尽管如此，根本的一点是，当你增加更多的处理器时，运行时间将以[2.x.465]的方式增长，而不管操作的实际实现方式如何，因此它不能扩展。)
* 这些以及其他阻碍程序完美扩展的原因可以在[1.x.117][1.x.118]中总结出来，即如果程序整体工作的一部分[2.x.466]可以并行化，即可以在[2.x.468]时间内运行，而程序工作的一部分[2.x.469]不能并行化（即。它包括只有一个进程可以做的工作，例如在[2.x.470]中生成图形输出；或者每个进程都必须以复制的方式执行，例如将带有本地贡献的消息发送到一个专门的进程进行积累），那么程序的总体运行时间将是


* [1.x.119]
* 因此，你得到的 "加速"，即你的程序在[2.x.471]处理器上的运行速度与在单个进程上运行程序相比的系数（假设这是可能的），将是


* [1.x.120]
* 如果[2.x.472]，对所有实际存在的程序来说都是如此，那么[2.x.473]就是[2.x.474]，这意味着有一个点，在这个点上，在问题上投入更多的处理器不会再有任何明显的回报。
* 在实践中，重要的是[1.x.121]或[1.x.122]或[1.x.123]一个程序的规模。对于deal.II，经验表明，在大多数具有合理快速网络的集群上，人们可以解决多达几十亿个未知数的问题，最多有几千个处理器，而每个进程的未知数则在40,000到100,000之间。最后一个数字是最相关的：如果你有一个问题，例如[2.x.475]未知数，那么在1000-2500个处理器上解决它是有意义的，因为每个进程处理的自由度数量保持在40000以上。因此，每个进程都有足够的工作要做，所以[2.x.476]的通信时间并不占优势。但是用1万或10万个处理器来解决这样的问题是没有意义的，因为这些处理器的每个局部问题都变得非常小，以至于它们大部分时间都在等待通信，而不是在做自己部分的工作。  [2.x.477]
* <dt class="glossary"> [2.x.478] GlossPeriodicConstraints [1.x.124]</dt> [2.x.479] 周期性边界条件经常在只有部分物理相关域被建模时使用。人们假设解决方案只是在被认为是周期性的边界上周期性地继续。在deal.II中，通过[2.x.480]和[2.x.481]支持这一点。一旦使用[2.x.482]，还必须调用[2.x.483]以确保所有进程知道周期性边界两边的三角化的相关部分。一个典型的分布式三角剖分的过程是。
*


*
* - 创建一个网格
*


*
* - 使用[2.x.484]（三角法）收集周期面
*


*
* - 使用[2.x.485]将周期性信息添加到网格中。
*


*
* - 使用 [2.x.486] (DoFHandler) 收集周期性面孔
*


*
* - 使用 [2.x.487] 添加周期性约束。
* 这方面的一个例子可以在 [2.x.488] 中找到。  [2.x.489]
*

* <dt class="glossary"> [2.x.490] GlossPrimitive [1.x.125]</dt> [2.x.491] 如果一个有限元素（由其形状函数描述）存在一个从形状函数数到矢量[2.x.492] GlossComponent "分量 "的唯一关系，那么它就是基元。这意味着，如果一个元素是原始的，那么矢量值元素的每个形状函数正好有一个非零分量。这尤其包括所有标量元素以及通过FESystem类从其他基元（例如标量）元素组装的矢量值元素，如[2.x.493]、[2.x.494]、[2.x.495]和其他一些元素所示。另一方面，[2.x.496]和[2.x.497]中使用的FE_RaviartThomas类或FE_Nedelec类提供了非原始有限元，因为在那里，每个矢量值形状函数可能有几个非零分量。  [2.x.498]


* <dt class="glossary"> [2.x.499] GlossReferenceCell [1.x.126]</dt> [2.x.500] 超立方体[0,1]<sup>dim</sup>，所有参数化的有限元形状函数都在其上定义。参考单元的许多属性由GeometryInfo类描述。  [2.x.501]


* <dt class="glossary"> [2.x.502] GlossSerialization [1.x.127]</dt>。
* [2.x.503] 术语 "序列化 "指的是将一个对象的状态写入一个流中，然后再检索它的过程。一个典型的用例是将程序的状态保存到磁盘上，以便以后可能的复活，通常是在长期运行的计算的检查点/重启策略的背景下，或者在不是很可靠的计算机上（例如，在非常大的集群上，个别节点偶尔会出现故障，然后导致整个MPI作业的中断）。在这两种情况下，人们希望偶尔保存程序的状态，以便在失败时，可以在那个点重新启动，而不是从头开始运行。
* deal.II通过实现[1.x.128]库的必要接口，实现了序列化设施。关于如何保存和恢复对象的例子见那里。  [2.x.504]
*

* <dt class="glossary"> [2.x.505] GlossShape [1.x.129]</dt> [2.x.506] 有限元基函数对单个网格单元的限制。  [2.x.507]
*

* <dt class="glossary"> [2.x.508] GlossSubdomainId [1.x.130]</dt> [2.x.509] 三角形的每个单元都有一个叫做 "subdomain id "的属性，可以通过[2.x.510]这样的调用进行查询，例如可以通过[2.x.511] 进行设置。(这些调用分别解析为[2.x.512]和[2.x.513]。)虽然原则上这个属性可以被应用程序认为有用的任何方式使用（它只是一个与每个单元相关的整数，可以表示你想要的任何东西），至少对于以%并行方式运行的程序，它通常表示 "拥有 "这个单元的处理器的[2.x.514] "MPI等级"。
* 对于基于MPI并行化的程序，但每个处理器都存储整个三角形（例如，[2.x.515]和[2.x.516]，但不是[2.x.517]），子域ID通过划分网格分配给单元，然后每个MPI进程只对它 "拥有 "的单元工作，即。属于处理器拥有的子域（传统上，这是子域id的情况，其数值与MPI通信器中MPI进程的等级一致）。分区通常使用[2.x.518]函数完成，但也可以使用任何其他方法来完成。(另外，[2.x.519]类可以用类似的方法自动划分网格)。
* 另一方面，对于使用MPI并行化的程序，但网格是使用[2.x.520]类持有分布在几个处理器上的，单元的子域id是与拥有该单元的处理器绑定的。换句话说，查询一个单元的子域id可以告诉你这个单元是否被当前的处理器所拥有（即如果<code>cell- [2.x.521] == [2.x.522] 或者被其他处理器所拥有。在%并行分布的情况下，子域ID只被分配给当前处理器拥有的单元以及紧邻的[2.x.523]"幽灵单元"。更远的单元被保留在每个处理器上，以确保每个MPI进程都能访问完整的[2.x.524]"粗网格"，并确保相邻的单元最多相差一个细化级别这一不变性。这些单元被称为 "人工"（见[2.x.525]"这里"），具有特殊的子域id值[2.x.526]。
* 除了常规的子域id，还有第二套密切相关的标志，与每个单元相关。"水平子域id"。这些标志不仅存在于活动单元，而且事实上存在于网格层次结构中的每个单元。它们的含义完全类似于常规的子域id，但它们是由[2.x.527]和[2.x.528]函数读写的。  [2.x.529]
*

* <dt class="glossary"> [2.x.530] GlossSupport [1.x.131]</dt> [2.x.531] 根据定义，支持点是那些 [2.x.532] ，使得对于形状函数 [2.x.533] 持有 [2.x.534] 。因此，有限元插值可以由支持点中的值唯一地定义。
*拉格朗日元素填充由[2.x.535]访问的矢量，这样函数[2.x.536]返回<tt>真</tt>。当然，这些支持点是在[2.x.537]的 "参考单元 "上。  然后，可以使用FEValues（与Mapping结合使用）来访问实际网格单元上的支持点。
*


* [2.x.538] [2.x.539] "支持点 "的概念仅限于基于Lagrange插值的有限元族。对于一个更普遍的概念，见[2.x.540]"广义支持点"。  [2.x.541]
*

* <dt class="glossary"> [2.x.542] GlossTargetComponent [1.x.132]</dt> [2.x.543] 当向量和矩阵被按分量分组到块中时，通常希望将几个原始分量收集到一个块中。例如，这可能是将斯托克斯系统的速度分组为一个单一的块。  [2.x.544]
*

* <dt class="glossary"> [2.x.545] GlossUnitCell [1.x.133]</dt> [2.x.546] 见[2.x.547] "参考单元"。  [2.x.548]
*

* <dt class="glossary"> [2.x.549] GlossUnitSupport [1.x.134]</dt> [2.x.550] 这些是参考单元上的[2.x.551]"支持点"，定义在FiniteElement中。例如，1d中通常的Q1元素在<tt>x=0</tt>和<tt>x=1</tt>有支持点（类似地，在更高维度的单位正方形或立方体的顶点上）。另一方面，高阶拉格朗日元素的单位支持点也在单位线、正方形或立方体的内部。  [2.x.552]


* <dt class="glossary"> [2.x.553] GlossUserFlags [1.x.135]</dt> [2.x.554] 一个三角图为用户标志提供每行、四边形等一个比特。   这个字段可以像所有其他数据一样使用迭代器进行访问，使用的语法是
* [1.x.136]
* 通常情况下，如果一个算法走过所有的单元，并且需要另一个单元，例如邻居，是否已经被处理过的信息，那么这个用户标志就会被使用。同样，它也可以用来标记边界上的面、四边形或线，对它们已经进行了一些操作。后者通常是有用的，因为一个循环，如
* [1.x.137]
*不止一次地遇到一些边界线。因此，人们会在循环的主体中设置该行的用户标志，并且只有在用户标志先前没有被设置的情况下才会进入主体。有一些额外的函数可以通过迭代器接口访问；更多信息请参见TriaAccessor类。请注意，没有用户标志可以与顶点相关联；然而，由于顶点是连续编号的，这可以很容易地在用户代码中使用一个bools矢量来模拟。
* 有两个函数，[2.x.555]和[2.x.556]可以从一个流或一个bools向量中写入和读取这些标志。与[2.x.557]和[2.x.558]不同的是，这两个函数存储和读取所有使用过的线、四边形等的标志，即不仅是活动的标志。
* 如果你想存储更多具体的用户标志，你可以使用函数[2.x.559]和[2.x.560]，对四边形等也是如此。
* 至于细化和粗化标志，这些函数有两个版本，一个是从流中读/写，一个是从<tt>向量中读/写 [2.x.561] 后者用于临时存储标志，而第一个用于将其存储在文件中。
* 在使用前用[2.x.562]函数清除用户标志是很好的做法，因为经常需要在多个函数中使用这些标志。如果在调用一个需要这些标志的函数时，这些标志可能还在使用中，那么这个函数应该按照上述方法保存和恢复这些标志。
*
* [2.x.563] 如果需要在单元格、行或面中存储更多的信息，而不仅仅是一个布尔标志，那么请参见[2.x.564] "用户数据"。  [2.x.565]
*

* <dt class="glossary"> [2.x.566] GlossUserData [1.x.138]</dt> [2.x.567] 就像[2.x.568]"用户标志 "一样，Triangulation类为每条线、四边形和六边形提供一个字段，在其中存储比单个布尔标志更具描述性的数据。这被称为 "用户数据"，可以在其中存储的数据是一个无符号整数或一个空指针。两者都是用来索引到一个更大的数组中，该数组包含了应用程序想要附加到网格实体的更详细的数据。
* 用户数据的存储和检索方式如下。
* [1.x.139]
* 同样地，有函数[2.x.569]用来设置指针，[2.x.570]和[2.x.571]用来检索索引和指针。要清除所有的用户索引或指针，请使用 [2.x.572] 与标志一样，有一些函数允许保存和恢复用户数据，可以是网格层次结构的所有实体，也可以是线、四边形或六边形的单独数据。有一些额外的函数可以通过迭代器接口访问；更多信息请参见TriaAccessor类。
*
* [2.x.573] 用户指针和用户索引被存储在同一个地方。为了避免不必要的转换，Triangulation会检查其中哪一个正在使用，并且不允许访问另一个，直到[2.x.574]被调用。
*
* [2.x.575] 关于[2.x.576]指针的类型安全缺失的常规警告显然在这里得到了体现；类型的正确性等的责任完全在于指针的使用者。  [2.x.577]
*

* <dt class="glossary"> [2.x.578] workstream_paper [1.x.140]</dt> [2.x.579] "WorkStream paper "是B. Turcksin、M. Kronbichler和W. Bangerth的一篇论文，讨论了WorkStream的设计和实现。WorkStream的核心是一种设计模式，即在有限元代码中反复使用的东西，因此，可以通用地实现。特别是，本文阐述了这种模式的动机，然后提出了实现它的不同方法。它还比较了不同实现方式的性能。
* 本文的完整参考资料如下。


* [1.x.141]
* 它可以从[1.x.142]中获得，详细情况也见[1.x.143]。  [2.x.580]
*

* <dt class="glossary"> [2.x.581] GlossZOrder [1.x.144]</dt> [2.x.582] 单元的 "Z顺序 "描述了一个单元被遍历的顺序。
* 默认情况下，如果你在deal.II中的所有单元上写一个循环，单元将按照较粗的单元（即从[2.x.583]"粗网格 "单元中以较少的细化步骤获得的单元）在较细的单元（即以较多的细化步骤获得的单元）之前的顺序进行遍历。在每个细化层中，单元的遍历顺序与它们被创建的顺序有关；然而，从本质上讲，这个顺序最好被认为是 "未指定的"：你将以某种顺序访问一个给定细化层中的每个单元一次，但你不应该对这个顺序做任何假设。
* 因为单元格的创建顺序会影响到单元格的顺序，所以对于两个相同的网格，你遍历单元格的顺序可能会发生变化。例如，想想一个有两个单元的1d（粗）网格。如果你先精炼其中的第一个单元，然后再精炼另一个单元，那么你将以不同的顺序遍历精炼层1上的四个单元，而不是先精炼第二个粗单元，再精炼第一个粗单元。
* 这种顺序对于几乎所有的应用都是完全实用的，因为在大多数情况下，以何种顺序遍历单元实际上并不重要。此外，它允许使用导致特别低的高速缓存失误频率的数据结构，因此对高性能计算应用来说是有效的。
* 另一方面，在某些情况下，人们希望以特定的、可重复的顺序遍历单元，这只取决于网格本身，而不是其创建历史或任何其他看似任意的设计决定。Z顺序 "是实现这一目标的方法之一。
* 为了解释Z顺序的概念，考虑下面的网格序列（每个单元使用 "level.index "符号进行编号，其中 "level "是指从[2.x.584]"粗略网格 "单元到特定单元所需的细化数量，"index "是该单元在特定细化级别中的索引）。
* [2.x.585] [2.x.586] [2.x.587] [2.x.588]。
* 注意第2层的单元格是如何按照它们被创建的顺序排列的。这并不总是如此：如果中间有单元格被移除，那么新创建的单元格就会填上这样产生的洞）。
* 那么deal.II遍历细胞的 "自然 "顺序将是0.0
*
-> 1.0
*
-> 1.1
*
-> 1.2
*
-> 1.3
*
-> 2.0
*
-> 2.1
*
-> 2.2
*
-> 2.3
*
-> 2.4

-> 2.5
*
-> 2.6
*
-> (如果你只想遍历[2.x.589]的 "活动单元"，那么就省略这个列表中所有有子单元的单元。)  这可以被认为是对数字 "level.index "的 "lexicographic "排序，但由于每个级别内的索引没有被很好地定义，这不是一个特别有用的概念。另外，我们也可以把它看作是对应于这个网格的树的一个可能的广度优先遍历，它代表了单元格之间的父子关系。
* [2.x.590]
* 另一方面，Z顺序对应于树的一个特定的深度优先的遍历。即：从一个单元格开始，如果它有孩子，那么就遍历这些单元格的孩子；只要一个孩子有孩子，这个规则就递归应用。
* 对于上面给定的网格，这产生了以下的顺序。0.0
*
-> 1.0
*
-> 2.4
*


*


*
-> 2.5
*
-> 2.6
*
-> 2.7
*
-> 1.1
*
-> 1.2
*
-> 1.3

-> 1.4
*
-> 2.0
*
-> 2.1
*
-> 2.2
*
-> (同样，如果你只关心活动单元，那么就把0.0、1.0和1.3从这个列表中删除。)因为单元格的子代顺序是明确定义的（相对于每一层内的单元格顺序），这种 "分层 "遍历是有意义的，尤其是独立于一个三角形的历史。
* 在实践中，它很容易使用递归函数来实现。
* [1.x.145]
* 这个函数然后被调用如下。
* [1.x.146]
*
* 最后，作为对术语 "Z "顺序的解释：如果你按照这种分层方式出现的顺序画一条穿过所有单元格的线，那么它在每个精炼的单元格上看起来就像一个左-右倒置的Z。事实上，这样定义的曲线可以被认为是一条空间填充曲线，有时也被称为 "莫顿排序"，见https://en.wikipedia.org/wiki/Z-order_curve 。  [2.x.591]



* [2.x.592]


* [0.x.1]

include/deal.II-translator/A-headers/grid_0.txt
[0.x.0]*



* [2.x.0]
* 这个模块将与网格的拓扑结构和几何形状有关的函数和类归类。一个网格可以被认为是一个单元的集合；如果网格被细化了（可能是以一种自适应的方式），那么这个集合就会被分组为一个细化等级的层次结构。除了单元之外，构成三角形的几何对象是单元的面（在三维中是单元的边）以及单元的顶点。请注意，我们有些滥用[1.x.0]这个词，因为deal.II只实现了由线性、四边形和六面体单元组成的三角形，三角形和四面体不被支持。
* 这个单元的集合由Triangulation类和派生类（如[2.x.1]和[2.x.2]）管理，它在内存中保存相关的数据，并提供接口来查询。你想在单元格上做的大多数事情都是在所有单元格上循环进行的。为此，Triangulation类提供了迭代器的概念（见[2.x.3]）：虽然实现方式不同，但它们的行为类似于单元格或面的指针，可以查询到单元格的几何属性以及相邻单元格或单元格的面等信息。
* 值得注意的是，Triangulation类只存储几何（即顶点和单元的位置）和网格的拓扑结构（即哪些单元是其他单元的邻居，等等）。它与网格上可能定义的有限元或自由度没有关系。这些功能由DoFHandler类（见[2.x.4]模块）执行，该类获得有限元空间的描述，并分配和管理顶点、面或单元的自由度，如有限元类所描述的。这种分离使得多个DoFHandler类可以同时在同一个网格上工作。
* 在整个计划中，deal.II中的三角计算与库中的各种其他部分交互。


* [1.x.1]
* [1.x.2]
* 有三种方法来创建网格。  [2.x.5] [2.x.6] 由GridGenerator类创建； [2.x.7] 从文件读取； [2.x.8] 手工创建。  [2.x.9]
* 对于第一种情况，GridGenerator类提供的函数可以自动生成最简单和最常见的几何图形。例如，矩形（或砖形）几何体以及圆形、球形或圆柱形都可以用这个类中的函数生成。大多数的教程程序都使用这种机制。
* 其次，可以使用GridIn类从输入文件中读入一些不同格式的网格。使用这个类，可以读取几万或十万个单元的网格，尽管这并不推荐：自适应有限元方法的威力只有在初始网格尽可能粗的情况下才能发挥出来，而且还有空间进行一系列的自适应细化步骤。如果初始网格已经太细了，那么在自适应网格细化能够发挥很大作用之前，就会耗尽内存或计算时间。尽管如此，GridIn类可以用于复杂的几何形状，或者用于与其他程序进行比较或交互，这些程序在网格上进行计算，然后通过这个类进行交换。 [2.x.10]教程程序展示了如何使用GridIn类。
* 第三种方式是手工创建网格，通过建立一个数据结构来描述三角形的顶点和单元。这种方法在中等复杂度的情况下非常有用，即无需借助网格生成器就可以手工建立网格，但该领域不属于GridIn类已经支持的领域。在这个方法中，所构建的数据结构被交给三角化类的create_triangulation()函数。[2.x.11]的教程程序展示了如何做到这一点。
*

* [1.x.3]
* 网格可以被写入一些不同格式的输出文件中。如果这涉及到在这个网格上获得的仿真结果，那么这将使用DataOut类（在[2.x.12]模块中有更详细的描述）来完成。另一方面，如果只需要将网格的几何结构和拓扑结构写入文件，GridOut类可以为你做到这一点。
*

* [1.x.4]
* GridTool类提供了各种作用于网格的功能。例如，这包括移动节点，拉伸或旋转整个三角形，计算域的直径，或将其细分为大致相同大小的块，以便进行并行计算。
* GridRefinement类实现了一系列的网格细化算法，基于给定的细化指标给其成员函数。
*

* [1.x.5]
* 除了上述内容外，本模块中还有相当数量的类只用于网格处理的内部数据结构中。它们一般都在内部命名空间，而不是为了在应用程序代码中使用。
*

* [2.x.13] Wolfgang Bangerth，1998-2006年


* [0.x.1]

include/deal.II-translator/A-headers/hp_0.txt
[0.x.0]*



* [2.x.0]
* 与hp-finite元素有关的类和函数。[2.x.1] 教程中概述了如何使用该命名空间中的类。[2.x.2]中给出了一个稍显奇特的应用。
* hp-命名空间实现了在deal.II中用于hp-framework的算法和数据结构。[2.x.3] "hp-paper "中给出了关于这些算法如何工作以及使用何种数据结构的细节概述。


* [0.x.1]*



* [2.x.4]
* 在hp-finite element方法的实现中，每个单元可能有不同的有限元与之关联。为了处理这个问题，[2.x.5]必须有一整套与之相关的有限元类。这个概念由[2.x.6]类代表。这种类型的对象作为容器，容纳了一整套的有限元对象。我们不在每个单元上存储指向有限元对象的指针，而只为每个单元存储一个索引，该索引标识了该单元应该使用的集合中的有限元对象。与给定单元相关的DoFHandler对象可以根据单元使用的有限元为每个单元分配自由度。
* 在单元上积分项时也会出现类似的情况：人们可能希望对不同的有限元使用不同的正交公式。例如，在我们使用Q1元素的单元上，QGauss(2)对象（即每个空间方向上有两个点的正交公式）可能就足够了，但在另一个使用Q3元素的单元上，这将导致积分不足，我们应该使用QGauss(4)公式。就像上面一样，存在一个类[2.x.7]，作为正交公式的集合。
* 最后，人们可能希望对具有不同阶数的单元的边界逼近使用不同阶数的有限元。[2.x.8]类允许这样做。
* 所有这三个类， [2.x.9] [2.x.10] 和 [2.x.11] 类，实现了与 [2.x.12] 非常相似的接口。它们有函数 [2.x.13] 来添加有限元、正交公式或映射到集合。他们有一个[2.x.14]函数，允许检索对集合中某个给定元素的引用。他们还有一个[2.x.15]函数可以返回集合中元素的数量。一些类，特别是持有有限元对象的类，也实现了其他特定的功能。
* 相似性超出了接口的范围。当向集合中添加一个元素时，所有的类都会创建一个参数的副本。这样就可以把一个临时对象传递给添加元素的函数。例如，下面的工作。


* [1.x.0]

* 这样一来，人们就可以把多项式度数为1到4的元素添加到集合中。没有必要保留所添加的对象：集合会对其进行复制，它不仅存储了一个指向给定有限元对象的指针。这个观察同样适用于其他集合类。
* 习惯上，在一个hp-finite element程序中，人们保留了具有相同数量元素的有限元和正交公式集合，一个集合中的每个元素都与另一个集合中的元素相匹配。这不是必须的，但它常常使编码变得简单得多。如果使用映射的集合，对[2.x.16]对象也是如此。
* 每当在hp-finite element程序中考虑p-adaptivity时，需要建立一个有限元的层次结构，以确定细化的后续有限元和粗化的前面的有限元。通常，这种层次结构考虑了有限元空间的嵌套方式：例如，[2.x.17]元素描述了[2.x.18]元素的一个子空间，因此进行[2.x.19]细化通常意味着使用更大（更精确）的有限元空间。换句话说，有限元的层次结构是通过考虑集合中的一些元素是其他元素的子空间还是超空间来建立的。
* 默认情况下，我们假设有限元是根据其多项式程度以升序存储的。如果元素的顺序不同，需要通过[2.x.20]成员函数向集合提供相应的层次结构。
*


* [2.x.21]


* [0.x.2]*
 一个用于实现hp-finite元素特定算法和数据结构的命名空间。
*


* [2.x.22]


* [0.x.3]

include/deal.II-translator/A-headers/instantiations_0.txt
[0.x.0]*
  [2.x.0]
* 复杂的类和函数模板的实例化在编译时间和磁盘空间方面都很昂贵。因此，我们尽可能地将模板的声明和实现分开，并确保只有在必要时才由编译器读取其实现。
* <tt>deal.II</tt>中的模板类可以分为三类，取决于可能的不同实例的数量。这三类将在下文中讨论。
*



*
* [2.x.1] Inst1 已知和固定数量的实例化
* 这些是具有模板参数的类，其值非常容易预测。典型的原型是


* [1.x.0]
*
* 在这里，我们在设计库的时候有少量的实例 ( [2.x.2] ) 已知。因此，这个类的成员函数被定义在源文件目录下的<tt>.cc</tt>文件中，我们在源文件中明确地将这些已知值实例化为模板。
* 从应用程序的角度来看，你实际看到的只是模板的声明。成员函数的实际实例化发生在库中，并且是在你编译库的时候完成的，而不是在你编译应用程序代码的时候。
* 对于这些类，为新的参数增加实例化需要改变库。然而，这很少需要，当然，除非你不满足于只在1d、2d或3d中计算。
*



*
* [2.x.3] Inst1a 可用实例
* 如果模板参数是<tt>dim</tt>，如果没有其他信息，可用的实例是为<tt>dim=1,2,3</tt>。
* 还有一些类的情况（不取决于空间维度），只支持一定的、少量的模板参数，并在库中提供显式实例。特别是，这包括所有在标量底层存储值类型上进行模板化的线性代数类：我们只支持 [2.x.4] ，以及在某些情况下支持 [2.x.5] 和 [2.x.6] 。
*



*
* [2.x.7] Inst2 一些实例化，其中大部分是已知的
* 这些是通常有少量实例的类模板，但可能需要额外的实例。因此，在库中提供了一组最可能的参数的实例化，但在一个特殊的头文件中提供了模板的实现，以便在有人想对一个未预见的参数进行实例化时，可以访问它。
* 这方面的典型例子是一些线性代数类，它们将向量类型作为模板参数。例如，它们将在库中被实例化为[2.x.8], [2.x.9], 和[2.x.10]。然而，它们也可以与其他矢量类型一起使用，如[2.x.11]和[2.x.12]，只要它们满足某些接口，包括不属于库的但可能在应用程序中定义的矢量类型。在这种情况下，应用程序可以通过手工实例化这些模板，如下一节所述。
*



*
* [2.x.13] Inst2c 创建新实例
* 从你的源文件中选择一个来提供所需的实例。假设你想让头文件<tt>XXXX</tt>中定义的类模板<tt>XX.h</tt>，用模板参数<tt>long double</tt>来实例化。那么，你的文件应该包含以下几行


* [1.x.1]

*



*
* [2.x.14] Inst2p提供的实例
* 与[2.x.15]节中的类一样，库中提供的实例通常以类似于这样的形式列在该类的文档中。


* [1.x.2]

*



*
* [2.x.16] Inst3 许多未知的实例
* 这些类，不存在合理的预先确定的实例集。因此，所有的成员定义都包含在头文件中，并在需要的地方被实例化。  一个例子是SmartPointer类模板，它几乎可以与任何模板参数一起使用。


* [0.x.1]

include/deal.II-translator/A-headers/integrators_0.txt
[0.x.0]*



* [2.x.0]
* 一个命名空间和函数的集合，简化了有限元空间上的表格和双线性表格的编码。这里收集了两个不同目的的函数：MeshWorker中对有限元网格的抽象积分，以及LocalIntegrators中对具体问题的单元和面项的积分的实际实现。
*

*
* [2.x.1] 关于编码惯例、类之间的关系以及实现细节的文档可以在本模块的命名空间文档中找到。
* [1.x.0]
* 当我们在有限元空间上积分一个函数或一个函数时，积分循环的结构总是相同的。我们有3到5个嵌套循环，从外到内。  [2.x.2] [2.x.3] 在所有单元上循环 [2.x.4] 可选择在所有面上循环以计算通量 [2.x.5] 在单元/面的所有正交点上循环 [2.x.6] 可选择在所有试验函数上循环以计算形式 [2.x.7] 可选择在所有试验函数上循环以计算双线性形式 [2.x.8]
* 这些循环自然分为两类，即计算单元和面的贡献（循环3到5），以及对网格对象的外循环，通常被称为 [2.x.9] 装配 [2.x.10] 。
* 在deal.II中对外循环的支持可以在命名空间MeshWorker中找到（见那里的文档）。为了支持单元和面的贡献（从现在开始称为局部贡献），deal.II提供了FEValuesBase和其派生类。虽然外循环是通用的（数据类型除外），但局部贡献的计算却取决于问题。因此，这里不可能有通用算法。不过，我们可以为此目的定义一个函数的通用接口，并提供一个本地积分器库供应用中使用。这些集合在命名空间LocalIntegrators中。


* [0.x.1]

include/deal.II-translator/A-headers/io_0.txt
[0.x.0]*



* [2.x.0]
* 这个模块收集了用于读写网格和数据的类。有两个子模块分别用于这些操作。


* [0.x.1]*



* [2.x.1]
* deal.II可以读取许多不同格式的网格。然而，它们都被限制在所谓的 "粗略的网格 "上，即没有细化层次，特别是没有悬挂节点的网格。GridIn类详细描述了支持哪些格式。
*此外，deal.II可以使用DataOutReader读取中间图形格式。这种格式被用作与模拟相关的数据之间的中间步骤，由DataOutBase类（或通过更多的派生类在 `ref输出模块'中描述）写入。DataOutReader类将这些数据读回来，然后它可以被转换为可视化程序支持的任何一种数据格式。
* 最后，ParameterHandler和MultipleParameterLoop类（以及相关的Patterns命名空间）被用来处理描述程序运行时参数的参数文件，这些参数不想在程序源中硬编码。
*

* [1.x.0]
* PathSearch类是输入处理中的一个辅助类。它被用来在一个目录列表中寻找一个文件，就像unix系统在[2.x.2]环境变量中列出的目录中寻找可执行文件一样。
*


* [2.x.3]


* [0.x.2]*



* [2.x.4]
* deal.II生成三种类型的输出：它可以将三角图/网格写成几种网格阅读器（包括deal.II本身的阅读器）可以理解的格式，它还可以创建用于数据可视化的输出。最后，它能以图形格式输出矩阵。
*

* [1.x.1]
* deal.II通过DataOutBase类支持大量流行的可视化格式，如OpenDX、gmv或gnuplot程序所使用的格式。支持的格式的完整列表列在DataOutBase类的文档中。
* DataOutBase类只负责在一些不同的可视化格式中实际写入一些中间格式。这个中间格式是由直接或间接从DataOutBase派生的类生成的。例如，DataOut类最常被用来从一个三角形、一个DoFHandler对象（将一个特定的有限元类与三角形联系起来）和一个或多个数据向量生成这种中间格式。DataOut类从每个单元创建中间数据，随后由DataOutBase类以某种最终格式写入。几乎所有的例子程序，从[2.x.5]开始，都使用这种方法来生成输出。
* DataOutFaces类是另一种从模拟数据创建中间格式的方法。然而，它不是从三角形的每个单元创建可视化数据，而是只为位于表面上的单元的所有面创建信息（尽管该类有一种方法可以覆盖选择哪些面应该被生成输出）。虽然这在2D中可能不是特别有趣（这些面只是线段），但在3D中，如果人们真正想知道的是域的形状或曲面上的一个变量的值，这往往是有帮助的。使用DataOutFaces类可以节省生成和存储所有内部单元的数据的工作，这对大型三维模拟来说是非常昂贵的。
* 第三个类，DataOutRotation类，允许采取一个二维模拟，并通过围绕给定的轴旋转二维领域来生成三维数据。这对于使用旋转对称性的模拟的可视化非常有用，例如，一个圆柱体。
* 最后，DataOutStack类允许在时空域中对与时间有关的模拟数据进行可视化：它收集每个时间步骤的结果，并在最后将所有这些信息一次性输出为一个时空文件。
*

* [1.x.2]
* Meshes，没有任何与之相关的数据向量，也可以用多种格式写入。这是通过GridOut类完成的，该类的文档中列出了支持的格式。
* 一些教程程序，特别是[2.x.6]、[2.x.7]、[2.x.8]、[2.x.9]、[2.x.10] b和[2.x.11]演示了GridOut类的使用。
*

* [1.x.3]
* 通过MatrixOut类，deal.II还可以以彩色或天际线图的形式给出矩阵的图形可视化。MatrixOut类使用DataOutBase进行输出。因此，矩阵可以用后一类支持的所有格式进行可视化。
*


* [2.x.12]


* [0.x.3]*



* [2.x.13]
* 除了提供图形输出格式的类（见[2.x.14]输出模块），deal.II还有一些类，以多种方式促进文本输出。它们被收集在本模块中。更多细节请参见这些类的文档。
*


* [2.x.15]


* [0.x.4]

include/deal.II-translator/A-headers/iterators_0.txt
[0.x.0]*



* [2.x.0] [2.x.1]。
* deal.II有几个类，在概念上被理解为meshes。除了明显的Triangulation之外，这些类还有，例如，DoFHandler和[2.x.2] 所有这些类都定义了一组迭代器，允许用户遍历整个网格，即构成网格的单元格、面、边等的集合，或其中的一部分。这些迭代器在某种意义上都是由TriaIteratorclass派生出来的。
* 基本上，TriaIterator的模板签名是
* [1.x.0]
*
* 从概念上讲，这个类型代表了类似于指向由[2.x.3]类所代表的对象的指针的东西。  通常情况下，你不会直接使用实际的类名，而是采用网状类所提供的一个类型定义，如<code>typename [2.x.4] 在进入这个问题之前，让我们先讨论一下迭代器的概念，然后再深入研究访问器的作用。
* 在C++中，迭代器就像指针一样，使用<tt>operator ++</tt>增加到最近的元素，使用<tt>operator减少到之前的元素。
*
* - </tt>。我们也可以用加法运算符<tt>it=it+n</tt>来跳转<tt>n</tt>元素，并相应地将一些元素向后移动。此外，按照标准模板库的传统，网格提供了成员函数<tt>begin()</tt>和<tt>end()</tt>，分别提供一个集合的第一个元素和一个超前的迭代器。由于有许多不同的迭代器可用，实际上有一整个系列的这类函数，比如<tt>begin_active()</tt>, <tt>begin_face()</tt>，等等。
* 就C++标准中定义的迭代器概念而言，deal.II网格迭代器是双向迭代器：它们可以被递增和递减，但是像<tt>it=it+n</tt>这样的操作需要的计算时间与<tt>n</tt>成正比，因为它被实现为一个<tt>n</tt>单独单位的递增序列。请注意，这与下一个更专业的迭代器概念，即随机访问迭代器形成了对比，对任意对象的访问只需要恒定时间，而不是线性时间。
*

*
* [2.x.5] IteratorsAndSets 迭代器作为指向对象集合的指针
* 如上所述，deal.II中的迭代器可以被认为是对构成网格的对象进行整体迭代。(这些对象是线、四边形和六边形，并由作为模板参数的Accessor类的类型表示给迭代器)。这表明我们可以将三角形视为单元格和其他对象的集合，这些单元格和其他对象通过某种数据结构联系在一起，就像链接列表是以线性方式连接对象的数据结构一样。
* 交易二中的三角形确实可以用这种方式来考虑。特别是，它们使用规则树之林的计算概念来存储它们的数据。这可以理解为如下几点。考虑到粗网格的单元有根；然后，如果这些粗网格的一个单元被细化，它将有2<sup>dim</sup>子，而这些子又可以，但不一定要有自己的2<sup>dim</sup>子，等等。这意味着，粗网中的每个细胞都可以被认为是二叉树（1d）、四叉树（2d）或八叉树（3d）的根。这些从粗网格单元中产生的树的集合构成了完整描述三角形的森林，包括所有的活动和非活动单元。特别是，活动单元是树中那些没有后代的终端节点，即没有进一步细化的单元。相应地，非活动单元对应于树中没有后裔的节点，即被进一步细化的单元。
* 三角形包含线（每个线可能有2个孩子）、四边形（每个四边形可能有4个孩子）和六边形（每个六边形没有或有8个孩子）的森林。根据维度的不同，这些对象也被称为单元或面。
* 迭代器在这种森林的元素上循环。通常的迭代器在森林的所有节点上循环，而活动迭代器以相同的顺序在元素上循环，但跳过所有非活动条目，因此只访问终端节点（即活动单元、面等）。遍历森林中的元素有很多方法，例如广度优先或深度优先。根据用于存储森林的数据结构的类型，有些方法比其他方法更有效。目前，在deal.II中，迭代器遍历森林的方式是广度优先。也就是说，迭代器首先访问粗网格的所有元素（单元格、面等），然后再转到直属层的所有元素，即粗网格对象的直属子节点；之后是粗网格的子节点，以此类推。然而，必须注意的是，程序不应该依赖这种特定的树形遍历顺序：这被认为是一个实现细节，可以在不同的版本之间改变，即使我们认为这在目前是一个不太可能的选择。
*

*
* [2.x.6] 迭代器的区别 不同种类的迭代器
* 迭代器有两个属性：它们指向什么（即Accessor模板参数的类型），以及它们所迭代的集合的确切定义。一般来说，迭代器总是被声明为
* [1.x.1]
*
* 这里，<tt>Kind</tt>决定了一个访问器需要有什么属性才能被这个迭代器访问（或者省略）。比如说。
* [1.x.2]
* 迭代所有构成网格的Accessor类型的对象（例如所有的单元格，无论它们是否被进一步细化并有子代），而
* [1.x.3]
* 因此，主动迭代器操作的是普通迭代器所操作的对象的一个子集，即那些拥有主动属性的对象。请注意，这与我们操作的对象的种类无关：所有有效的访问器类都必须为迭代器类提供一个方法来找出它们是否是活动的。
*（为了完整起见，让我们提到还有第三种迭代器。"rawiterators "也会遍历三角形中未使用的对象，但出于效率的考虑还是会被分配。用户代码不应该使用rawiterators，它们只为库的内部目的而存在）。)
* 一个对象是否处于活动状态可以被认为是一个 "谓词"：一个不是真就是假的属性。过滤的迭代器可以用来限制现有迭代器的范围。例如，你可以想象在那些[2.x.7]"活动单元 "的子集上进行迭代，这些单元的用户标志被设置或属于某个子域（对于一个给定的对象，这两个属性都是真或假）。
* 这是通过使用一个FilteredIterator&lt;BaseIterator&gt;类型的对象实现的，其中BaseIterator通常是上面讨论的标准迭代器之一。
* FilteredIterator在其构造函数中得到了一个额外的谓词，并将跳过所有该谓词评估为<tt>false</tt>的对象。在命名空间IteratorFilters中可以找到已经实现的谓词的集合。
*

*
* [2.x.8] 迭代器循环 迭代对象
* 所有相同类型的迭代器和迭代相同类型的几何对象都以相同的顺序遍历网格。以这个代码为例。
* [1.x.4]
*
* 这里，所有的迭代器总是指向同一个网格单元，即使<tt>DoFHandler</tt>和<tt>Triangulation</tt>是非常不同的类，即使DoFHandler处理的是不同的有限元：它们都以相同的顺序访问单元，区别只在于Accessor。如上所述，迭代器遍历对象森林的顺序实际上是明确的，但是应用程序不应该假定任何这样的顺序，而应该考虑这是库的实现细节。
* 与上面的例子相对应，在下面的片段中，迭代器遍历活动对象的顺序对所有迭代器都是一样的，与前面的例子不同的是，这里我们只考虑活动单元。
* [1.x.5]
*
*


* [2.x.9] IteratorsAccessors 访问器
* 迭代器就像指针一样：它们可以被递增和递减，但它们实际上是很笨的。它们的神奇之处在于它们指向一些有用的对象，在这里是指访问器。对于指针来说，它们指向的是一个存储了一些数据的实际对象。另一方面，deal.II迭代器，当被解除引用时，并不返回对一个实际对象的引用，而是返回一个知道如何获取代表单元格的数据的对象。一般来说，这个对象本身并不存储单元格的顶点或其邻居是什么。然而，它知道如何从Triangulation类为描述网格而设置的数组、表格和列表中获取这类信息。
* 访问表征一个单元的数据总是通过Accessor完成的，即表达式[2.x.10]允许访问这个Accessor的[1.x.6]属性。你可以从迭代器中查询的属性的例子有
* [1.x.7]
*
* 由于对迭代器的解引用产生了访问器对象，这些调用是Tomember函数 [2.x.11] , [2.x.12] 等。这些函数依次从存储这些数据的各种数据结构中找出相关的数据。这实际上是如何做到的，以及使用什么数据结构，并不是交易.II中应用的作者真正关心的。特别是，通过隐藏实际的数据结构，我们能够以一种有效的方式存储数据，而不一定是以一种使应用程序编写者容易访问或理解的方式。
*

*
* [2.x.13] IteratorsTypedefs 访问器的种类
* 根据你要访问的数据种类，有不同的访问器类。
*
* - TriaAccessor类为你提供数据，识别构成三角形的单元、面、线、四边形和六边形的几何属性，以及父子关系。
*
* - CellAccessor类是从TriaAccessor类派生出来的，用于对象具有完整维度的情况，即是一个单元，而不是例如一个单元的边界线。在这种情况下，关于一个网格的拓扑连接的额外信息可以从一个访问器中获得，比如请求指向一个单元的邻居的迭代器。
*
* - DoFAccessor类可以让你访问与单元格、面等相关的自由度信息；它对DoFHandler和[2.x.14]对象都是如此。请注意，DoFAccessor类派生于TriaAccessor或CellAccessor（取决于DoFAccessor是否指向全维度的对象），因此能够提供比其基类更高的信息集。此外，DoFAccessor类有两种风格，一种是访问细胞层面的自由度，另一种是访问活动细胞的活动度。
*
* - DoFCellAccessor类与DoFCellAccessor的目的和关系与CellAccessor与TriaAccessor的目的和关系相同。
* 除了查找成员文档，你通常不需要处理上面列出的实际类名。相反，我们使用由网格类Triangulation、DoFHandler和[2.x.15]提供的类型定义，以及生成此类对象的函数。
* <table border=1> <tr> <th>Class</th> <th>cell_iterator type</th> <th>function call</th> </tr> <tr> <th>Triangulation</th> <td>typename [2.x.16] [2.x.17] </tr> <tr> <th>DoFHandler</th> <td>typename [2.x.18] [2.x.19] </tr> <tr> [2.x.20] <td>typename [2.x.21] [2.x.22] </tr></table>
* Triangulation类支持用<tt>typename [2.x.23] 在单元格面之间进行迭代，该类型由[2.x.24] 返回。
* 活动迭代器有以下属性。
* <table border=1> <tr> <th>Class</th> <th>cell_iterator type</th> <th>function call</th> </tr> <tr> <th>Triangulation</th> <td>typename [2.x.25] [2.x.26] </tr> <tr> <th>DoFHandler</th> <td>typename [2.x.27] [2.x.28] </tr> <tr> [2.x.29] <td>typename [2.x.30] [2.x.31] </tr></table>
* Triangulation类也支持用<tt>typename [2.x.32] 遍历活动单元面，这是由[2.x.33] 返回的类型。
* 除了这些作用于单元和面的类型和调用（取决于维度的逻辑概念：一个单元在2D中是一个四边形，但在3D中是一个六面体），还有相应的类型和调用，如[2.x.34]，作用于独立于维度的几何对象line, quad, and hex。这些调用，就像上面那些调用一样，以活动和非活动的形式存在。
* 所有Mesh类中的类型定义都是在[2.x.34]中说明的。
*
* - [2.x.35] [2.x.36] 和 [2.x.37] 三角形迭代器的类。
*
* - 用于DoFHandler和[2.x.38]迭代器的[1.x.8]、[1.x.9]、[1.x.10]类。
* [2.x.39] IteratorAccessorInternals 迭代器和访问器的内部结构
* 迭代器，就像指针一样，就像它们指向一个实际的对象一样，但实际上它们所做的只是在被引用时返回一个访问器。访问器对象包含状态，也就是说，它知道它所代表的对象，例如，通过存储它属于哪个三角形，以及单元格中的级别和索引。因此，它能够访问与它所代表的单元（或面，或边）相对应的数据。
* 有一个过去-末端指针的表示，由TriaAccessor类中的成员变量[2.x.40]的特殊值表示。如果[2.x.41] [2.x.42] =0，那么该对象是有效的；如果[2.x.43] ==-1，那么该迭代器指向了终点；在所有其他情况下，该迭代器被认为是无效的。你可以通过调用[2.x.44] 函数来检查。
* 当向后运行时，过端迭代器也可用于比较迭代器与开始前的值。指向向量两端的迭代器之间是没有区别的。
* 单元的存储是基于层次结构的，因此上面提到的结构是有用的。然而，面不是按层次组织的，低维度的对象的访问器没有[2.x.45]成员变量。
*


* [2.x.46]
* [0.x.1]*



* [2.x.47]


* [2.x.48]


* [0.x.2]

include/deal.II-translator/A-headers/lac_0.txt
[0.x.0]*



* [2.x.0]
* 本模块包含涉及线性代数的类，即那些与矩阵、向量和线性系统的解有关的类。
* 各组类的描述可以在子模块中找到。
* 实现线性代数功能的文件在[2.x.1]子目录中，是[2.x.2]L[2.x.3]inear[2.x.4]A[2.x.5]lgebra[2.x.6]C[2.x.7]lasses的缩写。


* [0.x.1]

include/deal.II-translator/A-headers/laoperators_0.txt
[0.x.0]*



* [2.x.0]
* [1.x.0]
* deal.II包括支持以一种非常普遍的方式来描述线性变换。这是用LinearOperator类来完成的，就像[2.x.1]"MatrixType概念 "一样，它为[1.x.1]向量上的线性操作定义了一个最小的接口。
*


* [1.x.2]
*
* 因此，这样的对象可以作为所有[2.x.2]"迭代求解器 "类中的矩阵对象，或者作为[2.x.3]"预处理器 "使用。
* LinearOperator类的最大优势在于它为复杂的矩阵-向量操作提供了语法糖。作为一个例子，考虑操作 [2.x.4] ，其中 [2.x.5] 、 [2.x.6] 和 [2.x.7] 表示（可能不同的）稀疏矩阵对象。为了构造一个LinearOperator [2.x.8]，当应用于一个向量时执行上述计算，我们可以写道。


* [1.x.3]
* 现在，[2.x.9]可以作为一个矩阵对象用于进一步的计算。
* linear_operator()函数可以用来将一个普通的矩阵或预处理对象包装成一个LinearOperator。线性算子可以用transpose_operator()进行转置，或者通过使用inverse_operator()与迭代求解器一起进行反转。
* 对于LinearOperator类型的对象，所有的向量空间操作，即加减法、标量乘法和组合（兼容的线性算子）都被实现。


* [1.x.4]
*
* block_operator()和block_diagonal_operator()提供了对单个线性算子的进一步封装，使其成为封锁的线性算子变体。
* [2.x.10] 教程中有一个关于LinearOperator类的详细使用例子。
*

*
* [2.x.11] 如下所述，当使用LinearOperator作为[2.x.12]时，会在幕后生成PackagedOperation类实例。因此，用户程序必须包括这两个类的头文件才能编译成功。为了更容易决定在什么情况下包含哪些头文件，并防止隐藏的与模板相关的编译器错误，所有与LinearOperator相关的头文件都被归入了`<deal.II/lac/linear_operator_tools.h>`头文件。
* [1.x.5]
* 通过[2.x.13]将LinearOperator对象应用于一个向量，会产生一个PackagedOperation对象来存储这个计算。
* PackagedOperation类允许对涉及向量和线性运算符的表达式进行懒惰的评估。这是通过存储计算表达式来实现的，只有当对象被隐含地转换为向量对象，或者[2.x.14]（或[2.x.15]被手动调用时才执行计算。这就避免了不必要的中间结果的临时存储。
* 作为一个例子，考虑多个向量的相加。


* [1.x.6]
* 转换PackagedOperation <code>a + b
*
* - c + d</code>到一个向量的结果是，代码相当于以下代码


* [1.x.7]
* 这避免了任何中间存储。作为第二个例子（涉及一个LinearOperator对象），考虑计算一个残差 [2.x.16] 。
*


* [1.x.8]
* 这里，表达式<code>b
*
* - op_a x</code>的结果又是一个PackagedOperation类型的对象，它存储了应该使用两个向量和线性运算符执行的[1.x.9]。将表达式转换为矢量（就像这里发生的对矢量[2.x.17]的赋值一样），执行计算（见下面的注释）。
*

*
* [2.x.18] 计算表达式的懒惰评估必然涉及对底层向量和矩阵对象的引用。例如，创建一个[2.x.19]对象


* [1.x.10]
* 存储残差的计算表达式，引用向量 [2.x.20] 。在这一点上，它不进行任何计算。特别是，如果[2.x.21]或[2.x.22]被改变[1.x.11]，[2.x.23]的创建，每一个后续的表达式的评估都用新的值进行。


* [1.x.12]
* 因此，作为一种保障，如果你想马上计算一个表达式的结果，总是明确地在左边使用一个向量类型（而不是[2.x.24] ）。


* [1.x.13]

*


* [2.x.25] [2.x.26] 教程中有一个PackagedOperation类的详细使用例子。
*

*
* [2.x.27] LinearOperator的许多用例导致中间表达式需要一个PackagedOperation。为了一次性包含所有必要的头文件，可以考虑使用


* [1.x.14]

*




* [2.x.28]


* [2.x.29]


* [0.x.1]

include/deal.II-translator/A-headers/main_0.txt
[0.x.0]*
  [2.x.0]
* 这是deal.II类和函数文档的主要起始页。关于其他方面的文档，如构建系统，可以在其他地方找到。此外，还有[1.x.0]。
* deal.II库中的许多类可以被分组为模块（见[1.x.1]或本页面顶部菜单中的相应条目）。这些模块围绕着任何有限元程序的构建块而形成。下面的点击图给出了deal.II中主要类组的交互方式的概要，下面有更详细的描述（灰色方框表示可选的外部库的子集，灰色椭圆表示可选的外部应用程序的子集，deal.II可以与之交互）。
*


* [1.x.2]
* 这些组在教程程序中都有涉及，在[2.x.1]中首先概述了它们的组合方式。下面是这个组的分类指南，以及与每个组有关的文档链接。
* [2.x.2] [2.x.3] [1.x.3]。三角形是单元及其低维边界对象的集合。单元是参考超立方体[0,1]<sup>dim</sup>在[2.x.4]模块中的适当映射下的图像。
* 三角化存储了网格的几何和拓扑属性：单元如何连接以及它们的顶点在哪里。三角化不知道任何关于你可能想在这个网格上使用的有限元的信息，三角化甚至不知道任何关于其单元形状的信息：在2D中它只知道一个单元有4个面（线）和4个顶点（在3D中它有6个面（四边形）、12条线和8个顶点），但其他的一切都由映射类来定义。
* 三角形的属性和数据几乎都是通过所有单元的循环来查询的，可能还会查询每个单元的所有面。因此，关于网格的大部分知识都隐藏在[2.x.5]迭代器的后面，即类似指针的结构，可以从一个单元迭代到下一个单元，并且可以询问它目前指向的单元的信息。
* 描述三角形和单元格的类位于[2.x.6]模块中，并有相关文档。迭代器在[2.x.7]模块中描述。
* [2.x.8] [1.x.4]:矩阵描述了单元格的形状，更广泛地说，描述了要解决方程的领域的几何形状。它们使用微分几何的语言。更多信息可以在 [2.x.9] 中找到。
* [2.x.10] [1.x.5] 。有限元类描述了定义在单元格上的有限元空间的属性。这包括，例如，有多少自由度位于顶点，在线上，或在单元的内部。除此之外，有限元类当然还必须提供单元格上各点的单个形状函数的值和梯度。
* 有限元类在[2.x.11]模块中描述。
* [2.x.12] [1.x.6]:与有限元一样，正交对象是在单元格上定义的。它们只描述单元格上正交点的位置，以及其上正交点的权重。
* 描述特定正交公式的类的文档可以在[2.x.13]模块中找到。
* [2.x.14] [1.x.7]: %DoFHandler对象是三角形和有限元的汇合点：有限元类描述了每个顶点、线条或单元需要多少自由度，DoFHandler类分配了这个空间，使三角形的每个顶点、线条或单元有正确的数量。它也给它们一个全局的编号。
* 一个不同的观点是这样的。网格和有限元描述了我们寻求离散解的有限维空间[2.x.15]的抽象属性，而%DoFHandler类列举了这个空间的具体基础，因此我们可以通过一个有序的系数集[2.x.17]来表示离散解。
* 就像三角化对象一样，对DoFHandlers的大多数操作都是通过在所有单元上循环，并对每个单元或其中的一个子集进行操作。因此，这两个类的接口相当相似：它们允许获得第一个和最后一个单元（或面，或线等）的迭代器，并通过这些迭代器提供信息。从这些迭代器中可以得到的信息是已经可以从三角形迭代器中得到的几何和拓扑信息（它们实际上是派生类），以及诸如当前单元上的自由度的全局数字。我们也可以要求一个迭代器从一个数据向量中提取与当前单元格上的自由度相对应的值，该向量存储了与三角形相关的所有自由度的值。
* 值得注意的是，就像三角剖分一样，DoFHandler类不知道任何关于从单元格到其单个单元格的映射。它也不知道对应于它所管理的自由度的形状函数：它所知道的是，例如，每个顶点有2个自由度，每个单元格内部有4个。除了它们存在的事实之外，它们的具体细节与DoFHandler类无关。
* DoFHandler类及其关联物在[2.x.18] dofs模块中描述。此外，还有一些专门的版本可以处理多级和hp-discretizations。这些都在[2.x.19]和[2.x.20]模块中描述。有限元方法经常意味着对自由度的约束，例如对悬挂节点或适用边界条件的节点的约束；处理这种约束在[2.x.21]模块中描述。
* [2.x.22] [1.x.8]。有限元程序的下一步是，人们希望利用有限元的形状函数和正交规则定义的正交点，计算三角形的每个单元上的矩阵和右手条目或其他数量。为此，有必要将形状函数、正交点和正交权重从单元格映射到三角形的每个单元。这不是由映射和派生类直接完成的，而是由映射和派生类来促进的：它们描述了如何将点从单位空间映射到实空间并返回，以及提供这个导数的梯度和雅各布决定因素。
* 这些类都在[2.x.23]模块中描述。
* [2.x.24] [1.x.9]。下一步是实际取一个有限元，在映射到实数单元时，在正交公式定义的点上评估其形状函数及其梯度。这就是FEValues类和兄弟姐妹的领域：从某种意义上说，它们提供了一个有限元函数空间的点式视图。
* 这似乎有局限性：在数学分析中，我们总是以单元或单元面的积分来写公式，涉及到有限元形状函数。因此，人们会认为有必要将有限元空间描述为连续空间。然而，在实践中，这是没有必要的：在实际计算中，所有的积分都被使用正交公式的近似值所取代，因此真正需要的是在域内有限数量的给定位置评估形状函数的能力。FEValues类正是提供了这种信息。给定有限元、正交和映射对象，它们计算连续函数空间（相对于离散的，而不是相对于不连续的）对离散的点的限制。
* 有许多对象可以做到这一点。FEValues用于对单元格进行评估，FEFaceValues用于对单元格的面进行评估，FESubfaceValues用于对单元格的部分面进行评估。所有这些类都在[2.x.25]模块中描述。
* [2.x.26] [1.x.10]。如果知道如何使用FEValues和朋友们评估单个单元上的形状函数的值和梯度，并且知道如何使用DoFHandler迭代器获得单元上自由度的全局数，那么下一步就是使用问题的双线性形式来组合线性系统的系统矩阵（和右手边）。然后我们将从这个线性系统中确定我们问题的解决方案。
* 要做到这一点，我们需要有存储和管理矩阵和向量条目的类。deal.II为此提供了一整套的类，以及与其他提供类似功能的软件包的接口。这方面的文档可以在[2.x.27]模块中找到。
* [2.x.28] [1.x.11]:为了确定一个有限维度的线性方程组的解，人们需要线性求解器。在有限元应用中，它们经常是迭代式的，但有时也可能要使用直接或稀疏的直接求解器。deal.II有相当多的此类求解器。它们被记录在[2.x.29]模块中。
* [2.x.30] [1.x.12]。最后，一旦在给定的三角形上获得了有限元问题的解，人们往往希望用可视化程序对其进行后处理。这个库本身并不做可视化处理，而是生成各种图形格式的输出文件，这些格式可以被广泛使用的可视化工具所理解。
* 在[2.x.31]输出模块中给出了关于这样做的类的描述。  [2.x.32]
* 此外，deal.II还有一些超越这里所列举的类组。它们涉及到上面介绍的层次结构中更细化的概念，或者涉及到诸如处理输入和输出这样的切身问题，这些问题不一定专门针对有限元程序，但也出现在那里。这些类都列在类和命名空间的视图中，可以从本页顶部的菜单栏中找到，并且也被分组为自己的模块（见本页顶部的[1.x.13]）。
* 我们提供了Doxygen标签文件，供那些想把应用程序的文档直接链接到deal.II在线文档的用户使用。该标签文件在[1.x.14]。对于deal.II的每个版本，它都驻留在Doxygen参考文档的正上方的目录中。为了使用这个标签文件，你必须把它下载到一个Doxygen可以找到的地方。之后，在你的Doxygen选项文件中找到[2.x.33]这个键，然后写一些类似于<pre> TAGFILES = deal.tag=http://www.dealii.org/X.Y.Z/doxygen/deal.II </pre> 其中[2.x.34]指的是你要链接的版本。请确保你使用匹配的标签文件。理论上，你也可以针对deal.II的发展中的修订版进行链接，但你必须担心，如果deal.II的结构发生变化，你的链接可能会变得无效。


* [0.x.1]

include/deal.II-translator/A-headers/manifold_0.txt
[0.x.0]*



* [2.x.0]
* [1.x.0]
* 本模块中的类涉及到流形的描述，在流形中，一个三角形所描述的域生活在其中。这种流形描述在一些情况下是必要的。
* [2.x.1]
* [2.x.2] 网格细化。每当一个单元被细化时，有必要在三角网中引入新的顶点。在最简单的情况下，我们假设构成三角网的对象是直线段、双线性曲面或三线性体。然后，下一个顶点被简单地放到旧顶点的中间（这里的 "中间 "是指先前存在的顶点位置的一个合适的平均值）。这是Triangulation类的默认行为，并由FlatManifold类描述。
* 另一方面，如果处理弯曲的几何体，或者需要在某些方向上进行更密集细化的几何体，这并不是合适的做法。因此，从Manifold基类派生的类描述了一个域的几何形状。然后，我们可以使用[2.x.3]函数将一个从该基类派生的类对象附加到三角形对象上，并将其与manifold_id相关联（见[2.x.4]使用[2.x.5]函数将此manifold_id用于三角形的单元、面或边上，这些单元、面或边应由该manifold描述，然后三角形将询问manifold对象在网格细化时应将新顶点定位在哪里。已经有几个类支持最常见的几何形状，例如，CylindricalManifold或PolarManifold，它们分别代表以圆柱坐标或极坐标描述空间时获得的几何形状。默认情况下，所有使用GridGenerator命名空间中的函数生成的弯曲几何体都会将正确的Manifold对象附加到域的弯曲部分。
* [2.x.6] 集成。当使用高阶有限元方法时，经常需要使用边界的曲线近似，而不是直线近似来计算单元项（如单元对线性系统的矩阵和右手边的贡献）。这种曲线元素的实际实现发生在Mapping类中（见[2.x.7]模块），然而它从这里描述的类中获得关于域的边界信息。当然，在整合边界项时也是如此（例如，不均匀的诺伊曼边界条件）。
* [2.x.8] 非零维的域。在Triangulation被嵌入高维空间的情况下，即只要Triangulation类的第二个模板参数被明确指定且大于第一个模板参数（例子见[2.x.9]），流形描述对象不仅可以作为描述域的边界的几何形状的工具，而且可以作为描述域本身的工具，以防域是一个事实上是弯曲的流形。在这种情况下，人们可以使用[2.x.10]函数来指示在细化曲线时，或在使用高阶映射计算积分时，应使用何种流形描述。
* [2.x.11] 许多其他的例子，以及在deal.II中实现的许多理论基础，在[2.x.12] "几何学论文 "中提供。
* 在deal.II中，流形被看作是一个点的集合，同时还有一个点与点之间距离的概念（在流形上）。新的点通常是通过在流形上提供一个局部坐标系来获得的，识别局部坐标系中的现有点（使用局部地图将其拉回，以获得其局部坐标），通过现有点的加权和找到局部坐标系中的新点，并将该点在实空间中转换回来（使用局部地图将其向前推）。实现这一机制的主要类是ChartManifold类，这也是用户可能为复杂的几何形状而重载的类。
* 虽然这个过程在大多数感兴趣的情况下是非琐碎的，但对于大多数琐碎的几何体，如圆柱体、球体或壳体，deal.II提供了合理的实现。更复杂的例子可以用[2.x.13]和[2.x.14]中的技术来描述。
* 从总体上看，这个模块的类与库中的其他各种部分相互作用。


* [1.x.1]


* [1.x.2]
* [2.x.15]已经提供了一个处理曲面几何体的简单例子，尽管那里没有详细说明。默认情况下，GridGenerator中的函数会在需要时将流形附加到网格上。在下面的每个代码片段中，我们都会调用[2.x.16]来移除这些流形，并在例子本身中处理所有的流形附件，以使流形选择的影响清晰。
* 考虑一下那里显示的[2.x.17]函数的这个小变化，我们只是简单地将[1.x.3]单元格细化了几次。


* [1.x.4]
* 这段代码导致了一个看起来像这样的网格。
* [2.x.18]
* 我们的意图是要得到一个类似于环形的网格。然而，由于我们没有对三角形进行描述，所发生的情况是，我们从我们告诉[2.x.19]要创建的圆周方向的10个粗单元开始，然后每个单元被全局细化3次。每次细化都需要一个新的顶点，它被放在现有顶点的中间，而不考虑我们可能的意图（但在代码中忽略了描述）。
* 这很容易补救。考虑一下这段代码。


* [1.x.5]
* 这个代码更好，产生了以下的网格。
* [2.x.20]
* 这个网格看起来更好，它忠实地再现了域的圆形内边界和外边界。然而，仍然可以在切线上发现20个结点。它们是由于每次细化单元时，内部线的新顶点只是被放置在现有线的中间（边界线的处理方式不同，因为我们附加了一个流形对象）。在有10个单元的第一次细化中，我们得到了改进的点，因为根据下面关于混合不同流形的描述，两个外部边界都提供了一个弯曲的描述。换句话说，第一次细化后的新点最终出现在可能处于直线的几何中间的地方，但不在围绕中心的圆上。
* 这一点可以通过分配流形描述来弥补，不仅是沿边界的线，还有径向的线和单元（反过来，这些线会继承到网格细化后产生的新线）。这正是[2.x.21]的默认做法。为了演示，我们禁用默认的Manifold行为，然后手动复制它。


* [1.x.6]
* 这导致了以下的网状结构。
* [2.x.22]
* 那么，这有什么关系呢？毕竟，最后两个网格描述的是完全相同的领域，而且我们知道，无论选择什么样的单元，只要最大的单元的直径为零，在网格细化后，我们就能得到正确的解。
* 这个问题有两个答案。首先，求解偏微分方程到一定精度的数值努力通常取决于单元格的[1.x.7]，因为[2.x.24]形式的误差估计中的常数[2.x.23]取决于所有单元格中最小周长与最大内含圆的半径的最大比率等因素（对于三角形；或者对于其他类型的单元格的适当概括）。因此，创建具有尽可能好的单元的网格是值得的。可以说，对于上面所示的网格来说，这并不是一个问题，但有时却是一个问题。例如，考虑一下下面的代码和网格。


* [1.x.8]
*
* [2.x.25]
* 这里，我们在开始时只创建了三个圆周单元，并对它们进行细化，得到了所示的网格。很明显，尽管第一次细化将新的点放在中间，但我们有长宽比不好的单元。
* 如果我们进一步推动，从半径0.8和1.0之间的更薄的圆周的粗略网格开始，并且只有三个单元（这在这里可能是不合适的，因为我们知道这是不够的，但对于在网格生成器中生成的复杂几何形状来说，可能也是不可能避免的），我们观察到以下情况。
*


* [1.x.9]
*
* [2.x.26]
* 这个网格在细化后既没有正确的几何形状，也没有所有单元的正面积，这对于有限元方法的工作是必要的。然而，即使从这样一个不合适的网格开始，我们也可以通过使用上述相同的代码，不仅给边界，而且给内部单元和边缘附加一个合适的几何描述，使事情顺利进行。


* [1.x.10]
*
* [2.x.27]
* 在这最后一个例子中，我们终于让GridGenerator完成了它的工作，我们保留了默认的流形配置，即每个单元和面都是SphericalManifold。
* 在这里，即使从一个初始的、选择不当的网格开始，也保留了我们的能力，可以充分地将网格细化为一个对我们有利的网格。这个例子可能是在这里制造的，但它是相关的，例如在[2.x.28]产生的3D背景下（见这个函数的文档）。它也与[2.x.29]"关于扭曲细胞的词汇条目 "中讨论的案例有关。
* [2.x.30] [2.x.31] "关于流形指标的词汇条目"。
* [1.x.11]
* 在现实应用中，经常发生需要将不同的流形描述结合起来的情况。最简单的情况是，一个曲面描述只适用于边界，而不适用于计算域的内部。一个球的流形描述也属于这种情况，因为它需要将圆形部分的球形流形与域中心的直角描述结合起来，而球形流形在这里是无效的。
* 一般来说，在deal.II中混合不同的流形描述的过程是通过所谓的transfinite插值实现的。它在二维中的公式，例如，在[1.x.12]上有描述。给定图表上的一个点[2.x.32]，该点在实空间中的图像由以下公式给出


* [1.x.13]
* 其中[2.x.33]表示限定图像空间的四个顶点，[2.x.34]是描述单元格线条的四条曲线。
* 如果我们想根据流形找到单元格的中心（这也是在细化网格时使用的），图表是单元格[2.x.35]，我们想在点[2.x.36]上评估这个公式。在这种情况下，[2.x.37]是下层面的中点位置（在deal.II的排序中以2为索引），它是由自己的流形衍生出来的，[2.x.38]是上层面的中点位置（在deal.II中以3为索引），[2.x.39]是左边面的中点（以0为索引），而[2.x.40]是右边面的中点。在这个公式中，面中的四个中点的权重相当于[2.x.41]，四个顶点的权重相当于[2.x.42]。这些权重乍一看很奇怪，因为顶点的权重是负的，但这个机制是我们想要的。如果一个单元格在两个相对的面上有弯曲的描述，但在另外两个面上有直线，顶点中[2.x.43]的负权重与径向的两条直线的中心平衡，得到权重[2.x.44]。因此，在曲线方向的两个中心点上取平均值，正好把新点放在中间。
* 在三个空间维度上，面的中点的权重为[2.x.45]，线的中点的权重为[2.x.46]，顶点的权重为[2.x.47]，再次平衡了不同的实体。如果一个单元格的所有周围都是直的，那么这个公式就简化为八个顶点中每个顶点的明显权重[2.x.48]。
* 在MappingQGeneric类中，通过评估各自Gauss-Lobatto点的边界曲线[2.x.49]并将其与上述公式相结合，实现了这一概念对曲线单元的多项式表示的支持点的泛化，即Gauss-Lobatto正交的节点。这些权重已经被验证为产生最佳收敛率 [2.x.50] ，也适用于非常高的多项式度数，例如 [2.x.51] 。
* 在文献中，也使用了其他的边界描述。在9.0版本之前，deal.II使用了一种叫做拉普拉斯平滑的东西，其中应用于圆周上的节点以获得内部节点的位置的权重是通过解决单位元素上的拉普拉斯方程来确定的。然而，这导致边界层接近于曲线描述，即从单元到实心单元的映射的高导数的奇异性。
* 如果从弯曲的边界描述到内部的直线描述的过渡做错了，通常不可能达到高阶收敛率。例如，单个单元内的拉普拉斯平滑会导致从参考单元到实数单元的映射的第四导数出现奇点，将边界处单元的收敛率限制在3（如果在二维测量全局L2误差，则为3.5）。其他更粗糙的策略，比如完全忽略两个不同流形的存在，只是简单地计算直坐标系中高阶映射的附加点，会导致更差的收敛率。另一方面，目前在deal.II中的实现，在这方面已经得到了广泛的验证，应该表现得很好。
* 将曲线边界表示与平面内部表示相混合的不良策略显然也反映了网格质量。例如，在上述只有3个圆周单元的情况下，导致以下的网格是用拉普拉斯流形平滑，而不是像deal.II中实现的从边界插值。
* [2.x.52]
* 为了使用一个更实际的例子，考虑对一个球的细化，在球面上附加一个SphericalManifold。拉普拉斯类型的平滑给出了以下相当差的网格。
* [2.x.53]
* 如果我们改用从转折插值得到的权重，情况就会有很大的改善。
* [2.x.54]
* 当然，我们可以通过将TransfiniteInterpolationManifold应用于整个域（除了连接SphericalManifold的边界）来得到更好的网格，如该类中的数字所示，但原则上，在deal.II中实现的网格平滑已经和单从边界描述得到的一样好。
*


* [2.x.55] [2.x.56] Luca Heltai, 2013, Martin Kronbichler, 2017


* [0.x.1]

include/deal.II-translator/A-headers/matrices_0.txt
[0.x.0]*



* [2.x.0]
* deal.II带有许多不同的矩阵类，是为使用矩阵的各种目的而定制的。例如，有完整的矩阵、使用不同存储方案的稀疏矩阵、由单个块组成的矩阵，以及作为其他线性代数类接口实现的矩阵。在可能的情况下，所有这些实现都共享一个共同的接口，该接口至少包含编写迭代线性求解器所需的操作（见[2.x.1]），但也包含从矩阵中读取和写入的元素访问。
* 这个模块被分成了不同的部分。  [2.x.2] "基本矩阵 "包含所有实际存储条目的矩阵类。  [2.x.3] "派生矩阵"，另一方面，只使用基本矩阵，但对它们实现了某些操作。例如，TransposeMatrix提供了一个矩阵向量乘法，就像底层矩阵被转置了一样，而实际上并没有存储转置的矩阵。
* [2.x.4]也是矩阵类，因为它们对向量进行线性运算。
*


* [2.x.5]


* [0.x.1]*



* [2.x.6]
* 这些是由deal.II提供的实际矩阵类。可以在其中存储数值并检索它们。此外，它们还提供了线性求解器所需的全部接口（见[2.x.7] ）。
* 在这组矩阵中，有完整的矩阵、不同的稀疏矩阵和块状矩阵。此外，其他线性代数库（例如PETScWrappers）的接口中的一些类是矩阵。
* 大多数deal.II稀疏矩阵类与它们的稀疏度模式分开，以使存储具有相同稀疏度模式的几个矩阵更有效率。更多信息见[2.x.8]。
*


* [2.x.9]


* [0.x.2]*



* [2.x.10]
* 这些矩阵是建立在基本矩阵之上的。它们使用[2.x.11]"MatrixType概念 "所定义的接口进行特殊操作。
*


* [2.x.12]


* [0.x.3]

include/deal.II-translator/A-headers/matrixfree_0.txt
[0.x.0]*



* [2.x.0]
* 本模块描述了deal.II中的无矩阵基础设施。以下是deal.II中主要的类群与无矩阵基础设施互动的概要，可点击图表，下面有更详细的描述。
*


* [1.x.0]
* 从本质上讲，FEEvaluation类在MatrixFree的数据存储之上提供的框架是一个专门的运算符评估框架。它目前只与库中提供的具有特殊结构的元素子集兼容，即那些基础可以被描述为一维多项式的张量乘积的元素。这为向量条目和正交点的值或梯度之间的有效转换提供了机会，这种技术被称为和因子化。这种技术起源于谱元界，由Orszag在1980年的工作开始。虽然这种技术最初不过是一种装配向量（或矩阵）的特殊技术，比通用车辆FEValues更快，但它的效率使得在迭代求解器中使用这些积分设施直接评估矩阵-向量产品成为可能，而不是先装配一个矩阵，然后用这个矩阵做矩阵-向量产品。这一步最初是非直观的，与许多人在数学和计算机科学教育中所接受的教育相违背，包括大多数deal.II的开发者，因为一次又一次地重新计算积分，而不是使用预先计算的数据，似乎是一种浪费。然而，正如教程程序[2.x.1]、[2.x.2]、[2.x.3]、[2.x.4]和[2.x.5]所示，这些概念在现代计算机架构上通常比传统算法更出色。
*有利于无矩阵计算的两个主要原因如下。  [2.x.6] [2.x.7] 无矩阵方法跳过了大的全局稀疏矩阵的存储，并在飞行中计算基础的弱形式。由于内存传输，即从RAM内存中读取数据的速度，是基于矩阵的计算的瓶颈，而不是使用这些数据所做的实际算术，因此，一个读取数据较少的无矩阵评估，即使做了较多的计算，也会有优势。这个概念是建立在计算机架构的一个趋势之上的，这个趋势最好的描述就是[1.x.1]，说的是计算性能比内存性能增长得更快。因此，一定程度的算术运算基本上是免费的，而且这个份额在过去20年里变得更大。除了在显式时间积分中的经典使用外，它还使这种激进的算法转换成为迭代求解器的矩阵-向量积的无矩阵实现。当然，实现必须是高效的，而且不能有多余的计算量，以使其在总体上获胜。deal.II库使用SIMD矢量化和基于多项式程度模板的高度优化内核来实现这一目标。为了提供一个视角，二次元FE_Q的稀疏矩阵-向量乘积曾经与2005-2007年左右设计的处理器（如奔腾4或AMD Opteron Barcelona，每个芯片有2-4个内核）上的无矩阵实现速度相当。到2018年，无矩阵评估的速度大约是8倍（在英特尔Skylake服务器上测量，14个核心）。  [2.x.8] 无矩阵方法随着度数的增加，每个自由度的复杂度更好，这是由于和因子化的原因。对于无矩阵方案来说，每个自由度的工作随着[2.x.9]度的增加而增加，而对于基于矩阵的方法来说，它随着[2.x.11]度的增加而增加。这使高阶方案具有优势。在无矩阵评估中一个特别好的特点是[2.x.12]项经常占主导地位，所以看起来高阶方法在评估时间上和低阶方法一样快，当他们有相同的自由度数量时。对于deal.II中的实现，最佳吞吐量通常是在3到6的多项式度数之间实现的。  [2.x.13]
* 总而言之，无矩阵计算是高阶元素（高阶意味着除了线性形状函数之外的一切）的方法，并用于显式时间步进（[2.x.14]）或迭代求解器，其中也可以用无矩阵的方式进行预处理，正如[2.x.15]和[2.x.16]教程程序中所展示的。
* [1.x.2]
* 顶层接口由FEEvaluation类提供，其中还包含了对不同用例的广泛描述。
* [1.x.3]
* FEEvaluation类派生于FEEvaluationAccess类，后者又继承于FEEvaluationBase。FEEvaluation类本身不仅对维度、分量的数量和数字类型（如双数或浮点数）进行模板化，而且对多项式程度和每个空间方向上的正交点数量进行模板化。这些信息用于将和分解中的循环长度传递给各自的内核（见`tensor_product_kernels.h`和`evaluation_kernels.h`）并确保最佳效率。所有访问向量或提供访问单个正交点的数据字段的方法都继承自FEEvaluationAccess。
* FEEvaluationAccess类的动机是允许根据分量的多少，对内插解字段的值和梯度访问进行专业化。而基类FEEvaluationBase将梯度作为一个 "张量<1,n_components,张量<1,dim,矢量数组<Number>>"返回，外张量经过组件，内张量经过梯度的`dim'组件。对于一个标量场，即`n_components=1'，我们可以跳过外张量，简单地使用`Tensor<1,dim,VectorizedArray<Number>'作为梯度类型。同样地，对于一个`n_components=dim'的系统，梯度的适当格式是`Tensor<2,dim,VectorizedArray<Number>'。
* [1.x.4]
* 面积分，如连续有限元中的不均匀诺伊曼条件或一大类非连续Galerkin方案，除了单元积分外，还需要评估面的正交点上的量。面评价的设施大多与FEEvaluation共享，即FEFaceEvaluation也继承自FEEvaluationAccess。所有关于自由度和形状函数的数据字段都可以重复使用，后者是因为所有信息都由一维形状数据组成。然而，关于映射数据，由于数据是 "structdim=dim-1 "的，所以使用了一个特殊化。因此，FEEvaluationAccess和FEEvaluationBase被赋予一个模板参数`is_face`，以分别持有指向单元和面的映射信息的指针。除了用[2.x.17]访问函数值或用[2.x.18]访问梯度外，面评估器还可以用[2.x.19]访问法向量和一个专门的字段[2.x.20]，返回解场对面的法向导数。这个量被计算为梯度（在实空间）乘以法向量。梯度和法向量的组合是许多（简单的）二阶椭圆方程的典型特征，例如用内部惩罚法对拉普拉斯进行离散化。如果不需要单独的梯度，联合操作大大减少了数据访问，因为每个正交点只需要`dim`数据条目`normal Jacobian`，而单独访问时需要`dim^2`字段的Jacobian和`dim`字段的normal。
* 计算面积分的一个重要优化是考虑必须访问的矢量数据量，以评估面的积分。例如，想想FE_DGQ的情况，即拉格朗日多项式，其部分节点在元素边界上。对于函数值的评估，只有[2.x.21]自由度通过非零基函数做出贡献，而其余的[2.x.22]基函数在该边界上评估为零。由于矢量访问是无矩阵计算的瓶颈之一，对矢量的访问应该限制在有趣的条目上。为了实现这种设置，方法[2.x.23]（和[2.x.24]的积分等价物）将矢量访问与插值到正交点相结合。存在两种特殊情况，包括前面提到的 "非零 "值的情况，它被存储为字段[2.x.25]。对于在一个面上只有选定数量的基函数的值和第一导数评估为非零的情况，也可以有类似的属性。相关的元素类型是FE_DGQHermite，决定存储在属性[2.x.26]中，是否可以使用这样的优化内核的决定是在[2.x.27]和[2.x.28]中自动做出的。为每个积分任务做这个决定似乎效率不高，但最终这是一个单一的`if`语句（条件跳跃），对于现代CPU来说很容易预测，因为决定在一个积分循环中总是相同。(人们只需支付一定程度上增加的编译时间，因为编译器需要为所有路径生成代码，虽然)。
* [1.x.5]
*由FEEvaluation和FEFaceEvaluation执行的任务可以分成三类。[1.x.6]，[1.x.7]，和[1.x.8]。这种分割反映在MatrixFree所包含的主要数据字段上，分别用[2.x.29][2.x.30]和[2.x.31]表示这三个类别。它们的设计原则和内部布局在以下几个小节中描述。
* 所有这些数据结构坚持的主要界面是，集成任务被分解成一个单元或面的范围，人们可以通过一个整数索引来索引。单元积分、面内积分和边界积分的整数范围的信息是由类[2.x.32]使用数据字段`cell_partition_data`、`face_partition_data`和`boundary_partition_data`提供。这个类还包含了用于使用线程并行调度任务的索引子范围的信息，以及在`{cell,face,boundary}_partition_data`内对索引范围的分组，用于交错单元和面的积分，这样对单元和面的积分的向量项的访问就会重新使用已经在缓存中的数据。
* [1.x.9]
* DoFInfo类的主要目的是提供矢量访问函数[2.x.33]和[2.x.34]所消耗的索引，这些索引布置如下。  [2.x.35] [2.x.36] 指数存储在MPI本地索引空间中，以实现直接的数组访问，而不是将全局索引转换为本地索引。后者绝对不利于性能。[2.x.37] [2.x.38] 指数被存储在一个叫做[2.x.39]的字段中，这是一个长索引数组。以[1.x.10]为单位的访问粒度由辅助字段[2.x.40]控制，它类似于压缩矩阵存储中的行开始索引。该方案支持可变长度，因为我们支持hp-adaptivity和由于主索引阵列中包含的约束而产生的索引间接性。由于单元格上的矢量化，访问粒度最初会以[1.x.11]为单位。然而，我们必须能够同时访问单个单元，例如，对于面的积分，面的批次一般与单元的批次不同，因此访问不是线性的。此外，如果我们为每个单独的组件提供一个[1.x.12]，那么对多组件系统的支持就变得透明了。因此，`row_starts`字段的长度为[2.x.41] [2.x.42] [2.x.43] 在一个多基元的系统中，组件之间的转换由四个变量控制 [2.x.44] [2.x.45] int> n_components`（每个基元的组件）， [2.x.46] [2.x.47] int> start_components`（从基元到唯一组件编号的转换）， [2.x.48] [2.x.49] int> component_to_base_index`（从唯一元件编号到基数索引的翻译），以及 [2.x.50] [2.x.51] int>> component_dof_indices_offset`（特定元件的自由度范围在一个单元上的全部自由度列表中的偏移）。[2.x.52] [2.x.53] [2.x.54]。
* [2.x.55] 在hp-adaptive计算中提取FE指数的信息。[2.x.56] [2.x.57] 关于 "第一次访问 "特定向量条目的信息，该信息用于在第一次访问目标向量之前不久将其清零的[2.x.58]。这被用来避免向整个向量写零，从而破坏了数据位置性。[2.x.59] [2.x.60].
* [2.x.61]中数据结构的设置是在[2.x.62]中完成的，在这里我们首先假设了一个非常一般的有限元布局，无论是连续的还是不连续的元素，并且我们解决了由于悬挂节点而产生的约束。这个初始步骤是在单元的原始排序中完成的。在后面的阶段，这些单元一般会被重新排列，以反映我们在最终循环中通过单元的顺序，我们也会在DoF指数中寻找可以利用的模式，如单元内连续的指数范围。这种重新排序是为了实现与MPI的通信和计算的重叠（如果启用的话），并在单元格上形成更好的具有矢量化的批次组。指数的数据存储在这个最终的顺序中是线性的，安排在[2.x.63]。
* 因为存储索引的数据量是不可忽略的，所以对于携带更多结构的特殊配置，减少数据量是值得的。一个例子是FE_DGQ的情况，每个单元的一个索引就足以描述其所有的自由度，其他的则是连续的顺序。类[2.x.64]包含一个特殊的向量数组[2.x.65]，每个单元包含一个数字。由于单元和面的积分使用不同的访问模式，而且这种特殊情况下的数据很小，我们最好存储3个这样的向量，一个用于装饰为`内部'的面（索引0），一个用于装饰为`外部'的面（索引1），一个用于单元（索引2），而不是通过[2.x.66]使用定向。 DoFInfo中有一系列额外的特殊存储格式可用。关于在deal.II中实现的选项及其动机，我们参考该结构的文档[2.x.67]。
* 最后，DoFInfo类还持有一个共享指针，描述向量的并行分区。由于[2.x.68]的限制，传递给[2.x.69]函数的单个DoFHandler对象内的索引必须在每个MPI进程中是连续的，也就是说，本地范围必须最多包括一个块。除了基本的分区器，该类还提供了一组更严格的索引集，只涉及所有鬼魂索引的一个子集，被添加到向量的鬼魂范围。这些交换模式被设计为与通过[2.x.70]的减少索引访问相结合，例如。
* MatrixFree类支持多个DoFHandler对象，以传递给[2.x.71]函数。对于这些DoFHandler对象中的每一个，都会创建一个单独的[2.x.72]对象。在MatrixFree中，我们存储了一个[2.x.73]的[2.x.74]对象来说明这一事实。
* [1.x.13]
* 一维形状函数在一维正交点上的评估被存储在[2.x.75]类中 更确切地说，我们保存了所有的函数值、梯度和豫备值。此外，面的形状函数的值和导数，即单位区间的0和1点，也被存储。对于悬空节点上的面积分，相邻两个单元中较粗的单元必须对数值进行插值，而不是插值到完整的正交点，而只是插值到一个子面（评估点要么按比例调整为[0，1/2]，要么为[1/2，1]）。这种情况由数据字段`values_within_subface`、`gradients_within_subface`和`hessians_within_subface`处理。这个数据结构也会检查形状函数相对于参考单元中心的对称性（在这种情况下，会应用所谓的偶数变换，进一步减少计算量）。
* [1.x.14]
* 评估的几何信息存储在[2.x.76]类中 与[2.x.77]类类似，在一个MatrixFree实例中可以有多种变体，在这种情况下是基于多个正交公式。此外，单元格和面的单独数据被存储。由于涉及到更多的逻辑，而且字段之间有协同作用，字段的[2.x.78]被保存在[2.x.79]中。单个字段是[2.x.80]类型的，保存有反雅各布系数、JxW值、法向量、法向量乘反雅各布系数的数组（对于[2.x.81]实空间的正交点，以及参考元素上的正交点。我们使用一个辅助索引数组，指向每个单元的数据起点，即雅各布、JxW值和法向量的`data_index_offsets`字段，以及正交点的`quadrature_point_offsets`。这种偏移使HP-adaptivity的字段长度可变，类似于DoFInfo的做法，但它也使我们称之为[1.x.15]的东西得以实现。为了减少数据访问，我们检测单元格的简单几何形状，其中雅各布系数在一个单元格内是恒定的，或者也是跨单元格的，使用[2.x.82] 。
* [2.x.83] [2.x.84] 笛卡尔单元是指雅各布系数为对角线且在单元的每个正交点上相同的单元。每个单元只需要存储一个字段。由于单元内的相似性，我们还检查了当前处理器上所有单元的雅各布系数相同的其他单元批。这可以进一步减少内存访问。由于一般情况下的JxW值存储的是雅各布系数乘以正交权重，但我们只想为笛卡尔单元保留一个字段，所以我们在笛卡尔情况下误用了[1.x.16]这个名字，只存储了雅各布系数的行列式，没有正交权重。因此，在[2.x.85]和类似的情况下，我们需要注意，因为我们仍然必须乘以权重。  [2.x.86] 平行单元在整个单元内有恒定的雅各布系数，所以每个单元只需要存储一个字段。由于单元内的相似性，我们还检查了当前处理器上所有单元的雅各布系数相同的其他单元批。由于一般情况下的JxW值存储的是雅各布系数乘以正交权重，但我们只想为一个仿生单元保留一个字段，所以我们在仿生情况下滥用了[1.x.17]这个名字，就像在笛卡尔情况下一样，只存储雅各布系数的行列式，而不存储正交权重。因此，在[2.x.87]和类似的情况下，我们需要注意，因为我们仍然必须乘以权重。  [2.x.88]在面孔上，我们可以有这样的特殊情况：当JxW值不同时，法向量在所有正交点都是相同的。这种情况适用于平坦的面孔。为了减少数据访问，我们在[2.x.89]中保留了这个作为压缩索引的第三个选项。与笛卡尔和仿射的情况相反，在数组中只保留一个字段，扁平面为所有正交点保留一个单独的条目（保留一个索引字段`data_index_offsets`），但只访问第一个字。  [2.x.90] 一般类型的索引是指没有发现压缩的单元或面。在这种情况下，我们也不寻找在一个以上的单元上找到相同图案的机会，尽管这种情况可能存在，比如对于挤压的网格。这种搜索操作是基于使用自定义浮点比较器`FPArrayComparator`将数据插入到[2.x.91]中，当每个单元使用单一数据字段时，效率足够高。然而，如果对所有单元的所有正交点（有许多不同的情况）进行，它将是相当昂贵的。  [2.x.92]
* [2.x.93]的实现被分成了单元格和面的部分，所以这两个部分可以很容易地被分开持有。让代码读起来有点尴尬的是，我们需要从FEValues对象中完成的原始标量评估中把几个对象批在一起，我们需要识别重复的数据字段，而且我们需要用[2.x.94]对笛卡尔和仿射的情况在几个单元中定义压缩。
* [2.x.95]的数据计算部分除了明显的MPI并行化外，还通过任务来并行化。每个处理器在一个子范围内计算信息，然后数据最终被复制到一个单一的组合数据域中。
* [1.x.18]
* 目前MatrixFree中的面积分方案为所有的面建立了一个独立的任务列表，而不是明确地通过一个单元的`2*dim`面。这样做的好处是一个面的所有信息只需要处理一次。典型的DG方法计算的数字通量是保守的，也就是说，从面的两边看都是一样的，无论什么信息离开一个单元都必须正好再次进入邻居的单元。有了这个方案，它们必须只被计算一次。同时，这也确保了几何信息也必须只被加载一次。一个可能的缺点是，基于面的独立编号方法使得基于线程的并行变得比基于单元的方法复杂得多，因为在这种方法中，只有当前单元的信息被写入，而邻居的信息只被读取）。
* 由于面是独立于单元的，它们得到了自己的矢量布局。从一批面孔来看，不管是什么连续的一批细胞都会被交织在一起，这是面孔的本质（在这里我们只把细胞内有相同面孔索引的面孔放在一起，以此类推）。脸部循环的设置，在文件`脸部_设置_内部.h`中完成，试图提供至少部分类似于单元格补丁的脸部批次，以增加数据的定位性。沿着这些思路，在典型的[2.x.96]情况下，面的工作也与单元的工作交错进行，也就是说，函数调用中返回的`cell_range'和`face_range'参数通常很短。
* 因为所有来自两边的积分都是一次性执行的，所以出现了一个问题，即在子域边界的两个处理器中哪一个被分配到一个面。本模块的作者进行了大量的实验，发现应用于自由度存储的方案，即把所有可能重叠的项目分配给一个处理器，是相当不平衡的，面的数量最多有20%的差异。为了提高性能，在`face_setup_internal.h`中实现了一个平衡的方案，将每对处理器之间的所有接口分成两块，一块由一个处理器完成，另一块由另一个处理器完成。尽管这增加了通过MPI发送的消息的数量，但这是值得的，因为负载变得更加平衡。另外，当本地问题的规模为100,000 DoFs（三维）时，消息相当大，约为5-50kB。在这种消息大小下，延迟通常小于吞吐量。
* 脸部数据默认不被初始化，但必须由[2.x.97]中的脸部更新标志触发，即`mapping_update_flags_inner_faces`或`mapping_update_flags_boundary_faces`设置为与`update_default`不同的值。
* [1.x.19]
* MatrixFree类支持两种类型的实体的循环。第一种，从2012年开始在deal.II主分支上可用，是只执行单元积分，使用三个`cell_loop`函数中的一个，该函数需要一个指向单元操作的函数指针。第二种设置，在2018年引入，是一个循环，也可以执行面和/或边界积分，简单地称为`loop`。这需要三个函数指针，分别解决单元工作、内面工作和边界面工作。
* 除了以适当的方式安排工作外，该循环还执行两个任务。  [2.x.98] [2.x.99] 对`src`和`dst`向量进行数据交换，分别调用`update_ghost_values()`和[2.x.100]。如果各自的标志[2.x.101]被设置为 "true"（默认），那么交换可以以异步的方式进行，与不需要远程处理器数据的单元的工作重叠。  [2.x.102] 使用相应的标志将`dst`向量归零。在循环内这样做的好处是，循环知道向量中的哪些条目（首先）被单元格和面的循环中的一些子ranges触及。因此，它可以将向量逐个归零，以确保我们不需要两次访问向量条目（一次归零，一次添加贡献）。这似乎是一个微小的优化，但事实上运算符的评估可以非常快，简单地将一个向量归零就可以花费运算符评估时间的20%左右，所以这确实是值得努力的由于这个参数有一些实验性，DoFInfo类保留了一个静态变量[2.x.103]，在这里可以调整（如果有人认为其他东西会更好，例如因为未来的计算机看起来和2018年推出这个参数时不同）。  [2.x.104]
* 最后，[2.x.105]函数还需要一个参数来传递面积分的数据访问类型，由结构[2.x.106]描述，以减少处理器之间需要交换的数据量。不幸的是，目前还没有办法将这些信息传达给[2.x.107]，这些信息在FEFaceEvaluation内部通过评估类型（值和/或梯度）和底层形状函数的组合获得，以避免在第二个地方手动设置这类信息。


* [0.x.1]

include/deal.II-translator/A-headers/memory_0.txt
[0.x.0]*



* [2.x.0]
* 本组有一些用于内存处理的基本类和命名空间。Subscriptor和SmartPointer类用于计数内存处理，也就是说，每当SmartPointer被设置为指向一个对象时，它就会增加该对象中的一个计数器；当指针被设置为指向其他地方时，它又会减少。这样一来，人们总是知道一个对象还有多少用户。虽然这本身很少有用，但如果一个对象被销毁，而某个地方的指针仍然指向它，它就会被用来产生一个异常，因为在以后的时间里通过该指针的任何访问都会导致访问无效的内存区域。
* 与此相反，MemoryConsumption命名空间提供的函数可以用来确定对象的内存消耗。对于一些简单的类，比如标准库的容器，它直接确定它们需要多少内存（或者至少给出一个估计值）。对于deal.II类，它使用大多数类有的[2.x.1]成员函数。
*


* [2.x.2]


* [0.x.1]

include/deal.II-translator/A-headers/mesh_worker_0.txt
[0.x.0]*



* [2.x.0]
* 一组类和函数的集合，简化了对所有单元和面的循环编码。该模块的所有类和函数都在MeshWorker命名空间中，其中也包含了使用文档。
*


* [2.x.1]


* [0.x.1]

include/deal.II-translator/A-headers/mg_0.txt
[0.x.0]*



* [2.x.0]
* 与多栅格算法有关的类。
* 实现多网格方案的主要类是Multigrid，其功能是 [2.x.1] 它使用以下抽象类来执行多网格循环。
* [2.x.2] [2.x.3] MGMatrixBase包含水平矩阵，在[2.x.4] [2.x.5] MGCoarseGridBase是最粗层次上的求解器。  [2.x.6] MGSmootherBase在每个层次上进行平滑处理。  [2.x.7] MGTransferBase组织层次间的转移。  [2.x.8]
* 此外，还有一个PreconditionMG类，它是Multigrid的一个封装器，具有deal.II [2.x.9] Preconditioners的标准接口。PreconditionMG也使用继承自MGTransferBase的类，例如MGTransferPrebuilt，它使用[2.x.10]和[2.x.11]，在全局向量和水平向量之间进行转移。
* 最后，我们有几个辅助类，即MGLevelObject，它在每个层次上存储一个对象*。
* 关于如何使用这一功能，请参见[2.x.12] 、[2.x.13] b和[2.x.14] 示例程序。
* [1.x.0]
* 在自适应细化网格上使用多网格方法比使用常规细化方法涉及更多的基础设施。首先，为了保持最佳的复杂度，我们需要决定如何在每个层次上进行平滑处理。为此，我们必须在多级分解的意义上定义什么是级。
* 首先，我们定义多网格意义上的一个层次是由网格层次结构中某一层次的所有单元构成的。因此，某一级的平滑只限于由这一级或更细的单元组成的子域。这通常被称为局部平滑。这种定义的优点是，多网格方案的层次矩阵可以通过遍历某一层次的所有单元而轻松组装起来，而且这些层次矩阵不包含悬空节点。
* 这种分解的缺点是，我们需要额外的矩阵来处理细化边上出现的问题。此外，根据方法是连续的（因此在细化边缘有自由度）还是不连续的（在细化边缘采用通量矩阵），处理方法是不同的。虽然这些矩阵很小，但我们必须把它们集合起来，并通知多棱镜方法。


* [0.x.1]*
 这个命名空间包含了在我们知道在局部细化和块系统的背景下需要什么之后，对多层次支持的重新实现。
*


* [2.x.15]


* [0.x.2]

include/deal.II-translator/A-headers/multithreading_0.txt
[0.x.0]*



* [2.x.0]


* [2.x.1]



* [2.x.2] 机器。参见详细的文档和[2.x.3]"目录"，下面是该模块成员的冗长列表。
* [2.x.4]
* 在具有多个处理器（或多核处理器）的机器上，以%并行方式运行计算的几个部分往往是有利的。例如，我们可以有几个线程在%并行运行，每个线程组装三角形的一个子集的单元格矩阵，然后将它们写入全局矩阵。由于组装矩阵通常是一个昂贵的操作，这经常导致在多处理器机器上显著节省计算时间。
* 通过Threads命名空间中的函数和类，deal.II支持在共享内存（SMP）机器上以%并行方式运行操作。MultithreadInfo类允许查询系统的某些属性，如CPU的数量。这些用于%并行计算的设施将在下文中描述。[2.x.5]、[2.x.6]、[2.x.7]、[2.x.8]、[2.x.9]和[2.x.10]的教程程序也展示了它们在实践中的使用，其中从[2.x.11]开始的程序采用了更现代的做事风格，基本上我们描述[1.x.0]可以用%parallel完成，而旧的教程程序描述[1.x.1]事必须用%parallel完成。
* 另一方面，在分布式内存机器（即集群）上运行的程序需要一个建立在MPI和PETSc或Trilinos之上的不同编程模型。这在 [2.x.12] , [2.x.13] 和 [2.x.14] 示例程序中有所描述。
* [2.x.15] MTToC [2.x.16] 。


* [2.x.17] MTTasks [1.x.3] 。
* 在共享内存机器上并行的传统观点是将程序分解成[1.x.4]，即以%并行的方式运行程序的不同部分[1.x.5]（如果你的机器上的线程多于处理器内核，操作系统会在将执行切换到另一个线程之前短暂地轮流运行每个线程，从而模拟线程并发运行）。下面描述了deal.II的线程设施（见[2.x.18] "基于线程的并行性"），但我们首先想讨论一个通常比线程更合适的抽象。[1.x.6].
* 任务本质上是一个程序的各个部分。其中一些任务是独立的，而另一些任务则依赖于之前的任务，要先完成。举例来说，考虑一下大多数教程程序所具有的[2.x.19]函数的一部分的典型布局。


* [1.x.7]

* 这里，每个操作都需要大量的计算。但要注意的是，并不是所有的操作都相互依赖：显然我们不能在1之前运行语句2-4，4需要等待语句2和3的完成。但语句2和3是独立的：它们可以以任何顺序运行，或以%并行方式运行。实质上，我们已经确定了四个[1.x.8]，其中一些是相互依赖的，而其他是独立的。在目前的例子中，任务被识别为单独的C++语句，但往往它们更普遍地与整个代码块相吻合。
* 这里的重点是这样的。如果我们想使用线程来利用任务2和3的独立性，我们将启动两个线程，并在自己的线程上运行任务2和3；然后我们将等待这两个线程完成（一个称为 "加入线程 "的操作），并继续执行语句4。实现这一目标的代码是这样的（实际的语法在下面有更详细的解释）。


* [1.x.9]
*
* 但如果你的电脑只有一个处理器核心，或者我们有两个处理器核心，但已经有一个不同的程序部分在与上面的代码%并行运行，那该怎么办？在这种情况下，上面的代码仍然会启动新的线程，但程序不会运行得更快，因为没有额外的计算资源可用；相反，程序会运行得更慢，因为线程必须被创建和销毁，而且操作系统必须将线程安排到超额的计算资源上。
* 一个更好的方案是识别独立的任务，然后把它们交给一个调度器，把任务映射到可用的计算资源上。这样一来，例如，程序可以在每个处理器核心启动一个线程，然后让线程在任务上工作。任务将运行到完成，而不是同时进行，避免了中断线程运行不同线程的开销。在这个模型中，如果有两个处理器核，上面的任务2和3将以%的速度并行运行；如果只有一个处理器核，调度器将首先完全执行任务2，然后再做任务3，或者反过来。这个模型能够更有效地执行，特别是如果有大量的任务可供执行，例如见下面[2.x.20]节 "任务的抽象 "中的讨论。工作流"。从本质上讲，任务是对需要完成的任务的高级描述，而线程是实现这些任务如何完成的低级方式。在许多其他情况下，能够使用高层次的描述可以找到有效的低层次实现；在这种情况下，在程序中使用任务而不是线程往往是值得的。
* deal.II本身并没有实现对线程的任务调度。为此，我们使用了[1.x.10]，并为此提供了简单的封装器。TBB抽象了如何启动或停止线程、在单个线程上启动任务等细节，并提供了可以在许多不同系统中移植的接口。
*

*
* [2.x.21] MTUsing [1.x.11]。
* 理想情况下，启动任务（以及类似的线程）的语法，对于上面的例子，应该是这样的。


* [1.x.12]
* 换句话说，我们希望通过简单地在调用前加上一个关键字（比如这里的[2.x.22]，线程的关键字类似[2.x.23]）来表明函数调用应该在一个单独的任务上运行。前缀的调用将返回一个任务的句柄，我们可以用它来等待任务的完成，也可以用它来查询被调用函数的返回值（除非它是空的，就像这里一样）。
* 由于C++不支持创建新的关键字，我们必须要有一点创造性。所选择的方式是引入一个函数[2.x.24]，该函数将调用的函数以及调用的参数作为参数。[2.x.25]函数被重载，以适应没有、1个、2个和最多9个参数的函数启动任务。在deal.II中，这些函数生活在Threads命名空间中。因此，我们上面尝试做的实际代码看起来是这样的。


* [1.x.13]
*
* 同样，如果我们想在不同的任务上调用一个成员函数，我们可以通过指定调用函数的对象作为函数指针后的第一个参数来实现。


* [1.x.14]
* 在这里，首先注意我们如何传递对象[2.x.26]（即[2.x.27]会看到），好像它是函数的第一个参数。其次，注意我们如何通过调用[2.x.28]在单独的任务上获取函数返回的值，这个函数意味着等待任务的完成，也就是说，最后一行完全相当于


* [1.x.15]
*
* 还要注意，如果[2.x.29]想启动自己的任务，也是完全有效的。


* [1.x.16]
* 这里，我们让[2.x.30]计算其返回值为[2.x.31] 。如果有足够的CPU资源，那么加法的两个部分以及[2.x.32]中的其他东西都将以%的速度并行运行。如果没有，那么我们最终会在其中一个需要返回值的地方阻塞，从而释放出必要的CPU资源来运行所有这些生成的任务来完成。
*

* 在许多情况下，比如上面概述的[2.x.33]函数的介绍性例子，人们可以确定几个独立的作业，它们可以作为任务运行，但必须等待所有的作业在一个点上完成。我们可以通过存储所有[2.x.34]调用的返回对象，并对其中每一个调用[2.x.35]来做到这一点。一个更简单的方法是将所有这些任务对象放入一个[2.x.36]对象中，并一次性地等待所有的任务。然后，代码会是这样的。


* [1.x.17]

*

* [2.x.37] MTHow [1.x.18] 。
* 任务如何调度运行的确切细节是deal.II用于任务的Threading Building Blocks（TBB）库的内部%。TBB的文档对任务如何被安排到线程中给出了详细的描述，但对实际使用多少个线程却没有提及。然而，一个合理的猜测是，假设TBB创建的线程数与系统中的处理器核心数一样多。这样，它就能充分利用整个系统，而不会有太多的线程让操作系统不得不定期中断，以便其他线程能在可用的处理器核心上运行。
*那么问题来了，TBB调度器接受任务并让线程执行它们。线程完全执行任务，也就是说，TBB调度器不会中途中断一个任务，让另一个任务取得一些中途的进展。这确保了缓存总是热的，例如，避免了抢占式中断的开销。
* 缺点是，只有当线程真正在做一些事情时，CPU核心才会被充分利用，这意味着（i）必须有足够的任务可用，以及（ii）这些任务真正在做一些事情。请注意，这两个条件都必须满足；特别是，这意味着，如果我们已经确定了足够数量的任务，但如果其中一些任务踌躇不前，例如，因为一个任务正在向磁盘写入数据（这个过程中，CPU经常需要等待磁盘完成交易）或正在等待输入，那么CPU内核就没有得到充分利用。其他情况是，任务在其他外部事件上阻塞，例如通过突扰器与其他任务或线程同步。在这种情况下，调度器会让一个任务在一个线程上运行，但并没有注意到这个线程并没有完全利用CPU核心。
* 在这样的情况下，[1.x.19]创建一个新的线程（见下文[2.x.38]"基于线程的并行性"）是有意义的，操作系统可以在他们等待外部事物时将其搁置，并让不同的线程（例如运行TBB调度的任务的线程）同时使用CPU。
*

* [2.x.39] MTSimpleLoops [1.x.20]。
* 有些循环在数据上的执行体是完全独立的，因此可以以%并行方式执行。TBB库不是先验地将循环分割成固定数量的块并在任务或线程上执行，而是使用以下概念：循环迭代的范围被分割成一定数量的子范围（例如CPU核数的2或3倍），并平均分配给线程；然后线程执行子范围，如果它们完成了工作，就从其他线程那里偷取整个或部分子范围以保持忙碌。这样一来，即使不是每个循环迭代都需要同样多的工作，或者一些CPU核心因为操作系统中断了其他工作而落后，工作也是平衡的。
* TBB库的原语有点笨拙，所以deal.II为最经常使用的操作提供了包装例程。最简单的一个类似于[2.x.40]的做法：它需要一个或多个范围的输入运算符，一个输出迭代器和一个函数对象。一个典型的[2.x.41]的实现会是这样的。


* [1.x.21]
*
* 在很多情况下，[2.x.42]没有状态，因此我们可以将这个循环分成几个子范围，如上文所解释的。因此，deal.II有一组函数[2.x.43]，看起来和上面的函数一样，但它们是以%parallel的方式进行工作的（对于接受一个、两个或更多参数的函数对象，有几个版本有一个、两个和更多的输入迭代器）。调用这些函数的唯一区别是，它们需要一个额外的最后一个参数，表示[2.x.44]的子范围的最小尺寸；它应该足够大，这样我们就不会在调度子范围到处理器上花费更多的时间，但又足够小，处理器可以有效地进行负载平衡。一个经验法则似乎是，如果执行一个子程序需要少于2000条指令，那么这个子程序就太小了。
* 如何使用这些函数的一个例子是向量操作，如[2.x.45]中的加法，所有三个对象都是Vector<Number>类型。


* [1.x.22]
*
* 在这个例子中，我们用一个[1.x.23]来构建一个函数对象，它接受两个参数并返回两个参数的和。当我们想把向量[2.x.46]和[2.x.47]的各个元素相加，并把两者之和写入[2.x.48]的元素中时，这正是我们需要的东西。我们在这里得到的函数对象完全为编译器所知，当它展开[2.x.49]所产生的循环时，就像我们以其明显的形式写出的循环一样。


* [1.x.24]
*
* 还要注意的是，我们已经确保没有任何一个CPU能得到整个循环中小于1000次迭代的那块（除非整个范围更小）。
*

* [2.x.50] MTComplexLoops [1.x.25]。
* 如果在每个迭代中进行的操作不需要大量的设置成本，并且可以被编译器内联，那么上一节所示的方案是有效的。[1.x.26]正是这种类型，从而消除了调用外部函数的开销。然而，在有些情况下，在每个迭代中调用一些对象或函数是低效的。
*这种情况的一个例子是稀疏矩阵-向量乘法。如果你知道数据是如何以压缩行格式存储的，比如在SparseMatrix类中，那么一个矩阵-向量乘积函数看起来是这样的。


* [1.x.27]
* 在for循环中，我们计算矩阵的某一行与右侧向量[2.x.51]的点积，并将其写入[2.x.52]向量的相应元素中。通过利用[1.x.28]行的元素跟随当前行[1.x.29]的元素，使代码更加有效，也就是说，在循环体的开始，我们不必重新设置指向每一行的值和列数的指针。
* 使用上面的[2.x.53]函数，原则上我们可以把这段代码写成如下。


* [1.x.30]
* 注意我们如何使用[2.x.54]来[1.x.31]某些参数给[2.x.55]函数，留下一个参数，从而使[2.x.56]函数认为传递的函数参数是单值的。还要注意的是，我们需要把源向量和目的向量作为（const）引用，以防止[2.x.57]按值传递它们（意味着对[2.x.58]的拷贝和把结果写入[2.x.59]的临时拷贝，这都不是我们想要的）。最后，注意到一个矩阵的最小200行的粒度，应该由单个CPU核心来处理。
* 问题是，虽然这样做是正确的，但效率不高：我们必须在循环的每个迭代中设置[2.x.60]变量。此外，由于现在每一行要调用的函数对象不再是简单的[1.x.32]，在循环的每一次迭代中都有一个隐含的函数调用，包括参数传递。
* 一个更有效的方法是让TBB将原始范围分割成子范围，然后不是在循环的每个元素上调用目标函数，而是在整个范围上调用。这一点由[2.x.61]函数提供便利。


* [1.x.33]
* 这里，我们在每个元素至少200个的子范围上调用[2.x.62]函数，这样初始设置成本就可以摊销。
* 一个相关的操作是当元素上的循环各自产生一个结果，然后必须累积起来（除了数字的加法之外，其他的减少操作也可以）。一个例子是形成矩阵规范[2.x.63]（如果[2.x.64]是正定的，它才是真正的规范，但我们暂时假设它是）。对于稀疏矩阵来说，一个顺序的实现会是这样的。


* [1.x.34]
*
* 如果我们能把这个操作分成几个子行，每个子行都计算自己的那部分规范的平方，把各个子行的结果加在一起，然后取结果的平方根，那就更好了。这就是[2.x.65]函数所做的（注意，你必须指定结果类型作为模板参数，而且像往常一样，最后一个参数是可以在单个CPU核上调度的外循环元素的最小数量）。


* [1.x.35]

*

* [2.x.66] MTWorkStream [1.x.36]。
* 在介绍中所示的例子中，我们已经确定了一些可以作为独立任务运行的函数。理想情况下，这个任务的数量要大于CPU核心的数量（以保持它们的忙碌），但也不要过于庞大（以免数百万的任务淹没调度器，然后不得不分配给2或4个核心，例如）。然而，在有些情况下，我们有几千甚至几百万个相对独立的作业：例如，在网格的每个单元上组装对全局线性系统的局部贡献；在每个单元上评估误差估计器；或者在每个单元上对计算的数据进行后处理，这些都属于这一类。这些情况可以用我们称之为WorkStream的软件设计模式来处理。在下文中，我们将介绍这种模式的原理及其实现；更多的细节以及用它可以实现的加速的例子在[2.x.67]"WorkStream论文 "中给出。
* 像这样的代码可以这样写。


* [1.x.37]
* 在一个大的网格上，可能有一百万个单元，这会产生大量的任务；虽然它会让所有的CPU核忙上一阵子，但首先创建这么多的任务，对它们进行调度，然后等待它们，这样的开销可能不会导致高效的代码。一个更好的策略是，如果调度器能够以某种方式表明它有可用的资源，在这一点上，我们将给它提供另一个新创建的任务，我们将这样做，直到我们的任务用完，并且所创建的任务已经被工作。
* 这基本上就是[2.x.68]函数所做的。你给它一个迭代器范围，它可以从中抽取对象进行工作（在上面的例子中，它是由[2.x.69]到[2.x.70]给出的区间），以及一个对每个项目进行工作的函数（函数[2.x.71]）和一个对象，如果它是一个成员函数。
* 在下文中，让我们阐述一下为什么WorkStream命名空间中的函数会以这种方式实现的理由。关于其实现的更多信息可以在[2.x.72]"WorkStream文件 "中找到。要看到WorkStream类在类似上述任务中的实际应用，请看[2.x.73]、[2.x.74]、[2.x.75]、[2.x.76]、[2.x.77]或[2.x.78]的教程程序。
* 首先，考虑到上面的简单描述，那么[2.x.79]函数的写法可以是这样的（注意，这并不是很正确的语法，下面会介绍）。


* [1.x.38]
*
* 然而，这至少有三个问题。[2.x.80] [2.x.81] 首先，让我们看一下[2.x.82]函数可能的样子。


* [1.x.39]
*
* 这里的问题是，几个任务，每个都在运行[2.x.83]，可能会试图写入对象[2.x.84] [1.x.40]。这可以通过使用[2.x.85]的显式同步来避免，例如，看起来像这样。


* [1.x.41]
*
* 通过使mutex成为静态变量，它在全局范围内只存在一次（即对所有可能在%parallel中运行的任务都存在一次），并且只有一个任务可以进入由mutex上的acquisition/release调用保护的区域。顺便说一句，写这段代码的更好方法是这样的，确保即使在抛出异常的情况下也能释放mutex，而且不需要记住写对[2.x.86]的调用。


* [1.x.42]
* 在这里，从ScopedLock被创建到它被销毁，在代码块结束时，mutex一直被锁定。
* 请注意，尽管我们现在避免了多个线程可能向同一个对象写入的竞赛条件，但这段代码的效率并不高：在多核机器上，mutexes是很昂贵的，而且我们还在某些时候阻塞了线程，这对于任务来说是低效的，正如上文[2.x.87]"调度任务如何工作以及基于任务的编程何时不高效 "一节中所解释的。
* [2.x.88] 第二个正确性问题是，即使我们使用mutex锁定全局矩阵和右手边的对象，我们也是以一种或多或少的随机顺序这样做的：虽然任务是按照我们正常遍历单元格的顺序创建的，但不能保证当我们到了要把局部复制到全局贡献的时候，顺序仍然是我们按顺序计算的那样。换句话说，我们可能会把单元格1的贡献加在单元格0的贡献之前。这看起来无害，因为加法是交换和关联的，但事实上，如果用浮点运算，就不是这样了。  [2.x.89]
*
* - 以[2.x.90]为例（因为[2.x.91]在浮点运算中，使用双精度）。
* 结果是，最终出现在全局矩阵和右手边的确切数值会很接近，但可能会因任务完成的顺序不同而有接近四舍五入的差异。这不是一个理想的结果，因为这样的结果是不可复制的。
* 因此，WorkStream类的设计方式是使用两个函数：[2.x.92]计算本地贡献并将其存储在某个地方（我们接下来会讨论这个问题），第二个函数，例如[2.x.93]，将每个单元的计算结果复制到全局对象。在WorkStream类中实现的技巧是：(i)[2.x.94]永远不会以%并行方式运行超过一次，所以我们不需要通过互斥来同步执行，(ii)它在单元格上的运行顺序与它们在迭代器范围内出现的顺序完全相同，也就是说，我们以同样的方式将元素加入全局矩阵中[1.x.43]。
* 我们现在只需要讨论[2.x.95]如何向[2.x.96]传达它所计算的内容。这样做的方法是使用一个持有所有临时数据的对象。


* [1.x.44]
*
* 这种工作方式是，我们创建一个样本[2.x.97]对象，工作流对象将在每个以%并行方式运行的任务中复制一次。对于每个任务，这个对象将首先被传递给以%并行方式运行的[2.x.98]的几个实例中的一个，该实例将在单个单元上获得的数据填入该对象，然后再传递给顺序运行的[2.x.99]，将数据复制到全局对象中。当然，在实践中，如果我们有数以百万计的单元，我们不会产生数以百万计的[2.x.100]对象；相反，我们在这些对象被[2.x.101]使用后进行回收，并将其送回[2.x.102]的另一个实例；这意味着我们实际创建的此类对象的数量是调度器使用的线程数的一小部分，通常与系统中的CPU核数量相当。
* [2.x.103] 最后一个值得解决的问题是，按照上面[2.x.104]函数的写法，我们在每次调用该函数时都要创建和销毁一个FEValues对象，也就是说，为三角形中的每个单元创建一次。这是一个非常昂贵的操作，因为FEValues类试图在其构造函数中做大量的工作，试图减少我们对每个单元的操作数量（即增加[2.x.105]中的常数来初始化这样一个对象，以减少在三角形的[2.x.108]单元上调用[2.x.106]操作的常数）。在每个单元上创建和销毁一个FEValues对象会使这种努力失效。
* 避免这种情况的方法是将FEValues对象放入第二个结构中，该结构将保存从头开始的数据，并在构造函数中初始化它。


* [1.x.45]
* 然后在组装函数中使用这个FEValues对象。


* [1.x.46]
* 就像[2.x.109]结构一样，我们将创建一个[2.x.110]的样本对象，并将其传递给工作流对象，后者将根据需要多次复制它。为了使其发挥作用，[2.x.111]结构需要是可复制的。由于FEValues对象相当复杂，不能隐式复制，我们为[2.x.112]结构提供了我们自己的复制构造函数。
* 同样的方法，把东西放到[2.x.113]数据结构中，应该用于所有昂贵的构造。这尤其适用于所有在构造时需要分配内存的东西；例如，如果一个函数的值需要在正交点进行评估，那么这就很昂贵。


* [1.x.47]
*而这是一个更便宜的方法。


* [1.x.48]
*
* [2.x.114]
* 作为最后一点。如果由于某种原因，我的汇编器和复制器函数不符合上述分别有三个和一个参数的签名，怎么办？这也不是什么问题。WorkStream 命名空间提供了 [2.x.115] 函数的两个版本：一个是接收一个对象和两个成员函数的地址，另一个是简单地接收两个函数对象，可以分别用三个和一个参数调用。所以，换句话说，下面的两个调用是完全相同的。


* [1.x.49]
* 注意[2.x.116]是如何通过将成员函数绑定到[2.x.117]对象上产生一个需要三个参数的函数对象。  [2.x.118]是第一个、第二个和第三个参数的占位符，可以在以后指定。换句话说，例如，如果 [2.x.119] 是第一次调用 [2.x.120] 的结果，那么调用 <code>p(cell, scratch_data, per_task_data)</code> 将导致执行 [2.x.121] ，即 [2.x.122] 已经将对象绑定到函数指针上，但为以后留下了三个参数。
* 同样地，让我们假设[2.x.123]在一个非线性、时间依赖性问题的求解器中具有如下签名。


* [1.x.50]
* 因为WorkStream希望能够只用三个参数来调用worker函数，第一个参数是迭代器，第二个和第三个参数是ScratchData和PerTaskData对象，所以我们需要向它传递以下内容。


* [1.x.51]
* 这里，我们将对象、线性化点参数和当前时间参数绑定到函数中，然后再交给 [2.x.124] [2.x.125] 将简单地用单元格和scratch以及每个任务对象调用函数，这些对象将在 [2.x.126] 和 [2.x.127] 指示的位置被填入。
* 上面显示的[2.x.128]函数有一些细化。例如，人们可能会意识到，只有在复制-本地到全局的函数比本地装配函数快得多的情况下，上面的基本想法才能扩展，因为前者必须按顺序运行。这种限制只能通过安排更多的并行工作来改善。这就导致了这样一个概念：通过记录哪些写操作相互冲突，为我们工作的单元格（或更广泛的迭代器）的图形着色。因此，有一个[2.x.129]的第三个版本，它不只是取一个迭代器的范围，而是取一个由可以同时工作的元素组成的向量。这个概念在[2.x.130]的 "WorkStream论文 "中得到了非常详细的解释，同时还有常见例子的性能评估。
*

* [2.x.131] MTTaskSynchronization [1.x.52]。
* 任务是强大的，但它们确实有其局限性：为了使事情变得高效，任务调度器从不自己中断任务。除了调用[2.x.132]函数来等待另一个任务完成的情况外，任务调度器总是将一个任务运行到完成。缺点是，调度器看不到一个任务是否真的在空转，例如，如果它在等待其他事情发生（文件IO完成，来自键盘的输入等）。在这样的情况下，任务调度器原则上可以运行一个不同的任务，但由于它不知道任务在做什么，所以它不知道。因此，那些确实在等待外部事件发生的函数不适合做任务，应该使用线程（见下文）。
* 然而，在有些情况下，任务不仅是对工作的一种糟糕的抽象，而且实际上可以不使用。原则上，任务不能通过使用mutex或条件变量与其他任务同步（参见[2.x.133]和[2.x.134]类）。原因是，如果任务A需要等待任务B完成某件事情，那么只有在保证任务B最终能够运行并完成任务的情况下，这才会奏效。现在想象一下，你有2个处理器，任务A1和A2目前正在运行；我们假设他们已经排好了任务B1和B2的队列，现在正用一个突变器等待这些排队的任务完成（部分）工作。由于机器只有两个处理器，任务调度器只有在A1或A2完成后才会启动B1或B2
*
* 但这并没有发生，因为它们是使用操作系统资源（mutex）而不是任务调度器资源在等待。结果是一个死锁。
* 底线是，任务不能使用互斥或条件变量来与其他任务同步。如果任务之间的通信是必要的，你需要使用线程，因为操作系统确保所有线程最终都能运行，与线程的总数无关。然而，请注意，如果你只在每个任务上分别使用一个[2.x.135]来保护对任务可能写入的变量的访问，那么情况就不一样了：这种对mutexes的使用是可以的；任务可能只是不想等待另一个任务做什么。
*

* [2.x.136] MTThreads [1.x.53] 。
* 尽管任务是一种更高层次的描述事物的方式，但有些情况是不适合用任务的（关于其中一些情况的讨论，见上文[2.x.137]"调度任务是如何进行的以及基于任务的编程在什么情况下是无效的"）。一般来说，不能完全利用CPU的工作不适合任务，而适合线程。
* 在这样的情况下，你可以采用显式启动线程，而不是任务，使用的语法与上面基本相同。例如，如果你的应用程序中有一个生成图形输出的函数，然后估计误差，为自适应网格方案的下一次迭代细化网格，它可以是这样的。


* [1.x.54]
*
* 在这里，[2.x.138]启动了给定的函数，该函数在一个新的线程上向输出文件写入数据，该线程可以与其他一切并行运行：在与[2.x.139]函数并行的%，[2.x.140]函数将在一个单独的线程上运行。这种执行是独立于负责任务的调度器的，但这并不是一个问题，因为向文件写入大量数据并不会让CPU非常忙碌。
* 创建线程的工作方式与任务基本相同，即你可以用[2.x.141]来等待一个线程的终止，用[2.x.142]来查询一个已完成的线程的返回值，你可以将线程分组到一个[2.x.143]对象中，等待所有线程的完成。
*

* [2.x.144] MTTaskThreads [1.x.55] 如前所述，deal.II没有实现向线程调度任务，甚至没有启动线程本身。TBB库在决定使用多少个线程方面做得很好，他们不建议明确设置线程的数量。然而，在大型对称多处理（SMP）机器上，特别是那些有资源/任务管理器的机器，或者在对某些部分内存的访问是可能的，但对远处的处理器来说非常昂贵的系统上（例如，非常大的NUMA SMP机器），可能有必要明确设置线程数，以防止TBB使用过多的CPU。另一个用例是，如果你在一台机器上运行多个MPI作业，并且每个作业只应使用可用处理器内核的一个子集。
* 明确设置线程数是通过在调用其他可能创建线程的函数之前调用[2.x.145]来完成的。在实践中，它应该是你在 [2.x.146] 中首先调用的函数之一。
* 如果你用MPI运行你的程序，那么你可以使用MPI_InitFinalize类的构造函数的可选第三个参数来实现相同的目标。
*

*
* [2.x.147] deal.II内部有一小部分地方也明确使用了基于线程的并行性，例如用于运行需要等待输入或输出发生的后台任务，因此不会消耗太多的CPU时间。这种线程不在TBB任务调度器的控制下运行，因此不受上述程序的影响。在某些情况下，deal.II也会调用BLAS库，它有时也可能启动自己的线程。你将不得不查阅你的BLAS安装文档，以确定如何为这些操作设置线程数。


* [0.x.1]

include/deal.II-translator/A-headers/namespace_dealii_0.txt
[0.x.0]*
 这是deal.II中的所有内容都在其中的命名空间。为了避免在每个类和函数的调用前加上名字空间的名字，因此[2.x.0]在代码的顶部有一个[2.x.1]。
* 在整个文档中，为了简洁起见，名字空间的前缀被抑制了。


* [0.x.1]

include/deal.II-translator/A-headers/numerical_algorithms_0.txt
[0.x.0]*



* [2.x.0]
* 这个模块将一系列不同的类组合在一起，这些类通常在库中所有的基本三角形、DoFHandler和有限元类之上实现某种数值算法。它们之间一般是没有联系的。
* 一些类，如DerivativeApproximation、KellyErrorEstimator和SolutionTransfer，作用于已经得到的解，并计算前两种情况下的派生量，或者帮助将一组向量从一个网格转移到另一个网格。
* 命名空间MatrixCreator、MatrixTools和VectorTools提供了各种各样的服务，如创建拉普拉斯矩阵、将一个函数投影或内插到目前的有限元空间上，等等。  与DoFTools和FETools函数的不同之处在于，它们对向量（即给定三角上的有限元函数空间的成员）进行工作，或者帮助创建它。另一方面，DoFTools函数只作用于给定的DoFHandler对象而不参考数据向量，FETools对象一般与有限元类一起工作，但同样没有任何相关的数据向量。


* [0.x.1]

include/deal.II-translator/A-headers/parallel_0.txt
[0.x.0]*



* [2.x.0]



* [2.x.1]
* 本模块包含关于%并行计算的信息。它又分为 [2.x.2] 和 [2.x.3] 两部分。


* [0.x.1]*
 一个命名空间，我们在其中定义类和算法，处理当deal.II被配置为使用多线程时在共享内存机器上的%并行运行（见[2.x.4] ），以及在%分布式内存机器上的%并行运行（见[2.x.5] ）。
*


* [2.x.6] [2.x.7] Wolfgang Bangerth, 2008, 2009


* [0.x.2]

include/deal.II-translator/A-headers/petsc_0.txt
[0.x.0]*



* [2.x.0]
* 本模块中的类是PETSc库所提供的功能的封装器。它们提供了一个现代的面向对象的接口，与 deal.II 中其他线性代数类的接口兼容。本组中的所有类和函数都驻留在一个命名空间中 [2.x.1] 。
* 这些类只有在配置deal.II时检测到PETSc安装时才可用。请参考README文件以了解更多相关细节。
* [2.x.2] Wolfgang Bangerth, 2004
*


* [2.x.3]


* [0.x.1]

include/deal.II-translator/A-headers/physics_0.txt
[0.x.0]*



* [2.x.0]


*
* [2.x.1]与连续体物理学、物理场和材料有关的课程。


* [0.x.1]*
 命名空间和实用程序的集合，以协助定义、构建和操作与物理场和材料有关的数据。


* [0.x.2]*
   减少张量的顺序的符号，有效地将它们存储在某种一致的压缩存储模式中。一个例子是将[2.x.2]等级2的对称张量的6个独立分量存储为一个有6个分量的向量，然后将等级4的对称[2.x.3]张量的36个独立元素（当应用于一个对称等级2张量时，会产生另一个对称等级2张量）表示为一个[2.x.4]矩阵。     尽管这种表示张量的方法最常与四阶弹性张量的有效存储联系在一起，但随着它的泛化，它具有更广泛的适用性。这种表示方法在物理学、材料科学和有限元文献中也很常见。     张量符号有几种变化，每一种结构都略有不同。各种形式的张量符号之间的主要区别是对压缩张量的各种元素所规定的权重。   这个[1.x.0]对这个主题有一些进一步的一般见解。    
* [2.x.5] [2.x.6] Jean-Paul Pelteret, 2017
* [0.x.3]*
  一组操作，以协助张量从参考到空间配置的转换，反之亦然。  这些类型的转换通常用于以第二种配置重新表达在一种配置中测量或计算的数量。
* [1.x.1]
* 我们将对坐标[2.x.7]、变换[2.x.8]、微分算子[2.x.9]和变形梯度[2.x.10]使用与命名空间[2.x.11]相同的符号。
* 作为符号的另一点，我们将遵循Holzapfel（2007）的做法，将前推变换表示为[2.x.12]，后拉变换表示为[2.x.13] 。  我们还将使用注释[2.x.14]来表示张量[2.x.15]是反变量张量，[2.x.16]表示它是协变的。换句话说，这些索引实际上并不改变张量，它们只是表明某个张量的[1.x.2]对象。
*
* [2.x.17] 对于这些变换，除非另有说明，我们将严格假定变换后的张量的所有指数来自一个坐标系；也就是说，它们不是多点张量（如弹性中的皮奥拉应力）。
*
* [2.x.18]
* [2.x.19] Jean-Paul Pelteret, Andrew McBride, 2016
* [0.x.4]*
   这个命名空间提供了一个符合（非线性）弹性中使用的标准符号的定义集合。     [1.x.3] 这个符号的参考文献包括：。  
* [1.x.4]
* 为方便起见，我们将预先定义一些常用的参考张量和操作。   考虑到参考（材料）配置中的位置向量[2.x.20]，点[2.x.21]通过非线性图[1.x.5]被转换为当前（空间）配置中的点[2.x.22]，其中[2.x.23]代表位移向量。   由此我们可以计算出变形梯度张量为[1.x.6]，其中微分算子[2.x.24]被定义为[2.x.25]，[2.x.26]是身份张量。     最后，两个普通张量算子由[2.x.27]和[2.x.28]算子表示。它们分别代表对内部张量指数的单缩和双缩。   向量和二阶张量用粗体字突出，而四阶张量则用卡列字体表示。     我们可以把四阶张量看作是将二阶张量（矩阵）映射到自己身上的线性运算符，其方式与矩阵将向量映射到向量上一样。   为了给已实现的类成员和函数提供一些背景，考虑对具有特殊属性的张量进行以下基本操作。     如果我们把一般的二阶张量表示为[2.x.29]，那么一般的四阶单位张量[2.x.30]和[2.x.31]由[1.x.7]定义，或者用表记法表示为[1.x.8]，克朗克三角采用其共同定义。   请注意，[2.x.32] 。     然后我们用[1.x.9]定义对称和偏斜对称的四阶单位张量，这样[1.x.10] identity_tensor()返回的四阶对称张量是[2.x.33] 。      [2.x.34] Jean-Paul Pelteret, Andrew McBride, 2016年
* [2.x.35]
* [0.x.5]

include/deal.II-translator/A-headers/polynomials_0.txt
[0.x.0]*



* [2.x.0]
* 本模块将定义某些多项式函数家族的类归类。特别是，这包括等距支持点的拉格朗日插值多项式和它们在更高维度上的张量乘积，但也包括更奇特的如Brezzi-Douglas-Marini或Raviart-Thomas空间。


* [0.x.1]

include/deal.II-translator/A-headers/preconditioners_0.txt
[0.x.0]*



* [2.x.0]
* [1.x.0]
* 先决条件是用来加速线性系统的迭代求解的。典型的前置条件是Jacobi、Gauss-Seidel或SSOR，但该库也支持更复杂的前置条件，如Vanka或不完全LU分解（ILU）。此外，稀疏直接求解器在可用的情况下也可以作为预处理器使用。
* 广义上讲，预处理器是一种运算器，它与矩阵相乘以改善条件。其想法是，经过预处理的系统[1.x.1]比原始系统[1.x.2]更容易解决。这到底意味着什么，取决于矩阵的结构，在此不能作一般性讨论。对于对称的正定矩阵[1.x.3]和[1.x.4]，这意味着[1.x.5]的光谱条件数（最大和最小特征值的商）比[1.x.6]的要小得多。
* 在最简单的例子中，Richardson迭代，在SolverRichardson中实现，预处理迭代看起来像[1.x.7]。 因此，预处理相当于对残差应用一个线性算子，因此，预处理器[1.x.8]的动作被实现为<tt>vmult()</tt>。deal.II中需要预处理器的模板用[2.x.1]"预处理器类型概念 "来表示。在实践中，我们通常可以将任何定义了[2.x.2]的矩阵类对象作为一个预处理程序。本模块中的所有预处理类都实现了这个接口。
* 当用于Krylov空间方法时，由该方法决定是用[1.x.9]替换[1.x.10]的乘法（例如SolverBicgstab），还是做更复杂的事情。例如，SolverCG使用[1.x.11]来定义内积，这就是为什么它需要一个对称的正定算子[1.x.12]的原因。
* [1.x.13]
* 许多预处理程序依赖于加法拆分[1.x.14]为两个矩阵。在这种情况下，上述Richardson方法的迭代步骤可以简化为[1.x.15]，从而完全避免了与[1.x.16]的乘法。我们把以这种方式将前一个迭代[1.x.17]映射到下一个迭代的算子称为放松算子。它们的通用接口由[2.x.3]"松弛类型概念 "给出。本模块中名字以<tt>Relaxation</tt>开头的类实现了这个接口，还有预处理器PreconditionJacobi、PreconditionSOR、PreconditionBlockJacobi、PreconditionBlockSOR和PreconditionBlockSSOR。
* [1.x.18]
* 在这一节中，我们讨论了预设条件器通常必须提供的接口，以便在deal.II库内工作。
* [1.x.19]
* 为了能够存储在容器中，所有的预处理程序都有一个没有参数的构造函数。由于这通常会产生一个无用的对象，所有的预处理程序都有一个函数


* [1.x.20]
*
* 这个函数接收要预处理的矩阵以及其他所需的参数，并设置预处理程序的内部结构。
* [1.x.21]
* 一些预处理程序，如SOR和Jacobi，在被用作预处理程序之前，早已作为迭代求解器使用。因此，它们同时满足[2.x.4] "MatrixType "和[2.x.5] "RelaxationType "概念。
*


* [2.x.6]


* [2.x.7]


* [0.x.1]

include/deal.II-translator/A-headers/quadrature_0.txt
[0.x.0]*



* [2.x.0]
* 本模块包含基类正交以及由deal.II提供的正交公式。正交公式提供了两个基本数据：单元格[0,1]^d上的正交点的位置，以及每个正交点的权重。
* 由于deal.II使用四边形和六面体，几乎所有的正交公式都是作为定义在单位区间[0,1]上的一维正交公式的张量产物产生的，这使得它们在高维情况下的定义几乎是微不足道的。然而，通过QAnisotropic类，该库也允许各向异性的张量产品（一个坐标方向上的正交点比另一个方向上的多），以及定义不是张量产品的正交公式。
* 从总体上看，这个模块的类与库中的其他各种部分相互作用。


* [1.x.0]


* [1.x.1]
* 正交公式除其他用途外，还可用于积分矩阵条目和右手边矢量的分量。为此，定义在单元格上的正交点必须被映射到实数单元格上的相应位置，并且权重必须乘以雅各布的行列式。这一步是由派生自Mapping基类的类来完成的，尽管这通常是隐藏的，因为如果没有提供特定的映射，库的许多部分会退回到使用MappingQ1类型的对象。
* 下一步是评估形状函数和它们在这些位置的梯度。虽然从FiniteElement基类派生出来的类提供了对单元格上形状函数的描述，但在正交点上的实际评估以及将其与从映射中获得的信息结合起来的工作是由FEValues类及其关联者完成的。因此，从本质上讲，FEValues类是对有限元空间（由FiniteElement类定义）的视图，在正交点（由正交类提供）上进行评估，并映射到真实空间（而不是单元空间）的单元内的位置（由Mapping类提供映射）。
* FEValues类作为副产品，提供了映射到实数单元的正交点的位置，也可用于其他用途。例如，这可以用来在这些点上评估一个右手边的函数。
*

* [1.x.2]
* QIterated类用于从现有的正交公式中构造一个迭代的正交公式，从而在不增加阶数的情况下提高公式的精度。例如，通过对点在0和1、权重为1/2和1/2的梯形规则进行两次迭代，我们可以得到一个点在0、1/2和1、权重分别为1/4、1/2和1/4的正交公式。这个公式是通过将正交公式分别投射到子区间[0,1/2]和[1/2,1]上，然后将左边区间的右端点与右边区间的左端点合并得到的。以同样的方式，所有的一维正交公式都可以被迭代。高维迭代公式是作为一维迭代公式的张量积产生的。
*

* [1.x.3]
* 高维的通常正交公式产生的张量产品在每个方向上都是相等的，而QAnisotropic类产生的张量产品在每个方向上可能是不同的公式。
*

* [1.x.4]
* QProjector类本身实际上不是正交规则，但它提供了在高维单元表面计算正交公式的函数。
* 本模块中的所有其他类实际上实现了不同顺序和其他特征的正交规则。
*

* [1.x.5]
* 该类用于根据标识正交公式的字符串生成一个正交对象。这在希望在输入文件中指定某个正交公式，而不是在程序中硬编码的情况下很有用。


* [0.x.1]

include/deal.II-translator/A-headers/reordering_0.txt
[0.x.0]*



* [2.x.0]


*
* [2.x.1] 对象。
* [1.x.0]
* 在deal.II中的三角形有一个特殊的结构，即不仅有单元，而且有面，在三维中还有边，它们都是自己的对象。面和边都有独特的方向，而且它们相对于相邻的单元也有特定的方向。因此，在两个空间维度中分隔两个单元的线不仅有一个方向，而且相对于与第一条线相邻的两个四边形的其他线，它也必须有一个明确的方向。同样的定义也适用于三维单元和分隔它们的物体（线、四边形）。
* 例如，在二维空间中，一个四边形由四条线组成，这些线有一个方向，根据定义是这样的。


* [1.x.1]
* 现在，两个相邻的单元格必须有一个顶点编号，使公边的方向相同。例如，以下两个四边形


* [1.x.2]
*可以用顶点编号<tt>(0 1 3 4)</tt>和<tt>(1 2 4 5)</tt>来描述，因为从两个单元格看，中间线会得到方向<tt>1->4</tt>。  编号<tt>(0 1 3 4)</tt>和<tt>(5 4 2 1)</tt>将是不允许的，因为左边的四边形会给公共线以<tt>1->4</tt>的方向，而右边的会想用<tt>4->1</tt>，导致歧义的产生。
* 作为附带说明，我们注意到，如果人们采纳了拥有面的方向是有用的这一观点，那么如上所示的一个单元的四个面的方向几乎是必要的。特别是，不可能使它们的方向代表（逆）时针的意义，因为那样的话，我们就不能为下面的三块细胞找到一个有效的方向。


* [1.x.3]
*（读者需要尝试找到一个符合要求的线方向的选择；很快就会发现不可能存在这样的东西，即使我们允许可能存在同时具有顺时针和逆时针方向的线的单元。
* 有人可能会说，对面和边的唯一方向的定义，以及相对于它们所约束的单元格的方向的定义，是deal.II的一个错误特征。事实上，这使得阅读由网格生成器创建的网格变得相当困难，因为它们在生成输出时通常不会遵循这些惯例。另一方面，有很好的理由引入这些约定，因为它们在很多情况下可以使编程变得更简单，导致一些计算速度的提高，因为我们可以在很多地方避免昂贵的检查，因为面的方向是已知的，假设它是由三角法保证的。
* 本课的目的是为一组给定的单元格找到一个排序，使生成的三角形满足上述的所有要求。为此，我们将首先展示一些例子，说明为什么这是一个困难的问题，然后开发找到这种重新排序的算法。请注意，该算法是在一组CellData对象上操作的，这些对象是用来向三角剖分类描述一个网格的。例如，这些对象是由GridIn类在从输入文件读入网格时生成的。
* 作为第一节的最后一个问题：对于一个给定的领域细分为单元格，是否能保证面的这种方向总是存在？下面描述的2d的线性复杂度算法也证明了2d的答案是肯定的。对于3D，答案是否定的（这也强调了使用这种方向可能是一种
*
*--不幸的是无法治愈的
*
* - 交易二的错误特征）。)一个简单的三维反例说明了这一点：取一串三维单元并将其弯曲成一个环形。由于单元中的对立线需要有相同的方向，所以对它们有一个简单的排序，例如所有的线都是径向向外，切向顺时针，和轴向向上的。然而，如果在连接细胞串的两端之前，将细胞串扭转180度，那么就不可能再有这样的方向，这一点可以很容易地检查出来。实际上，有些网格不能用于deal.II。为了克服这个问题，引入了[2.x.2]、[2.x.3]标志。有了这些标志，就有可能处理所有的纯六面体网格。然而，为了减少可能的bug的影响，还是应该尝试对网格进行重新排序。只有当这个程序失败时，才应该使用原始的连接信息。
*

* [1.x.4]
* 如前所述，对单元格的顶点列表进行重新排序，从而得到的网格并不是一个微不足道的问题。特别是，只看一个单元格的邻域往往是不够的，它不能在不违反上述要求的情况下被添加到其他单元格的集合中。我们将展示两个例子，这一点很明显。
* 第一个这样的例子是下面的，我们将称之为 "最后的四个单元格"，因为这四个单元格靠近每一行三个垂直单元格的右端（在下面的图片中，我们只显示了左边的这样一列三个单元格，但是我们将指出如果我们延长这个列表会发生什么）。


* [1.x.5]
* 假设你在左侧边界的单元格中对顶点进行了编号，从而诱导出以下线条方向。


* [1.x.6]
* 例如，这可以通过使用索引<tt>（0 1 3 4）</tt>，<tt>（3 4 6 7）</tt>，<tt>（6 7 9 10）</tt>来完成。现在，你将找不到一种方法来给出正确的单元格的指数，而又不对某条线或其他线引入歧义，或者不违反每个单元格内必须有一个顶点，两条线都从这个顶点出发，而相邻的两条线都指向这个顶点。
* 在这种情况下，解决方案是对三个左边单元格中的一个重新编号，例如，通过对左上角单元格的编号<tt>(9 6 10 7)</tt>来恢复顶点7和10之间的线的意义。


* [1.x.7]
*
* 这里的重点是：假设我们想把网格向左延长，像这样。


* [1.x.8]
* 然后我们会遇到和上面一样的问题，如果我们把左边的单元格统一排序，从而迫使我们把一个单元格（就是上面我们可以排序为<tt>(9 6 7 10)</tt>的那个单元格）的排序还原。然而，由于相反的线必须有相同的方向，这又会迫使我们旋转它左边的单元格，然后再旋转左边的单元格，如此反复，直到我们到达网格的左端。因此，这是一个我们必须追溯到第一列的三个单元的例子，以找到一个一致的排序，如果我们最初是均匀地排序。
* 作为第二个例子，请考虑下面这个简单的网格，其中单元格的编号顺序很重要。


* [1.x.9]
* 我们在这里只指出了相关顶点的数字。假设用户通过顶点指数<tt>0 1 3 2</tt>和<tt>6 7 5 4</tt>给单元格0和1。那么，如果我们按照这个方向，为这两个单元格创建线条后的网格会是这样的。


* [1.x.10]
* 现在，由于相反的线必须指向同一方向，我们只能将单元格2到N-1添加到单元格1，使所有垂直线都指向下方。然而，我们不能向任何方向添加单元格N，因为它将有两条不指向同一方向的相反线。我们必须旋转0号或1号单元格，以便能够添加所有其他单元格，从而满足交易.II三角形的要求。
* 这两个例子说明，如果我们在某个方向上添加了一定数量的单元格，而在添加下一个单元格时又不能不引入已经在另一个方向上添加的面，那么只旋转我们未能添加的单元格附近的单元格可能是不够的。可能有必要回到很远的地方，旋转很久以前就已经输入的单元。
*

* [1.x.11]
* 从上面的例子可以看出，如果我们遇到一个不能被添加到已经输入的单元格中的单元格，我们通常不能指出哪个单元格是罪魁祸首，必须以不同的方向输入。此外，即使我们知道哪个单元格，也可能有大量的单元格不再适合于网格，我们也必须找到不同的方向（在上面的第二个例子中，如果我们旋转了单元格1，那么我们也必须旋转单元格1到N-1）。
* 解决这个问题的蛮力方法如下：如果单元格N不能被添加，那么就尝试旋转单元格N-1。如果我们不能再旋转单元格N-1，那么就尝试旋转单元格N-2，并尝试用单元格N-1的所有方向添加单元格N。以此类推。在算法上，我们可以用一个树状结构来表示，节点N有多少个子节点N+1的可能方向，就有多少个子节点（在两个空间维度上，有四个方向，每个单元可以由其四个顶点构建。例如，如果顶点指数是<tt>(0 1 3 2)</tt>，那么四个可能性是<tt>(0 1 3 2)</tt>，<tt>(1 3 2 0)</tt>，<tt>(3 2 0 1)</tt>，和<tt>(2 0 1 3)</tt>）。)当添加一个又一个单元格时，我们以深度优先（pre-order）的方式遍历这个树。当我们遇到从根（单元格0）到叶（最后一个单元格）的路径不允许时（也就是说，通过树的路径所编码的单元格的方向不能导致有效的三角形），我们必须追踪并尝试通过树的另一条路径。
* 当然，在实践中，我们并不是沿着每条路径走到最后一个节点，然后找出一条路径是否导致了有效的三角结构，而是使用一个归纳论证：如果对于所有先前添加的单元格，三角结构是有效的，那么我们可以通过检查进入当前单元格是否会引入任何具有非唯一方向的面，来找出一条穿过树的路径是否可以产生有效的三角结构；如果是这样，那么我们可以停止跟踪这一点以下的所有路径并立即追踪回去。
* 尽管如此，已经很明显的是，这棵树在两个空间维度上有[2.x.4]个叶子，因为每个[2.x.5]个单元可以在四个方向上添加。这些节点中的大部分可以被迅速丢弃，因为首先第一个单元格的方向是不相关的，其次如果我们添加的一个单元格的邻居已经被添加了，那么已经只剩下两个可能的方向了，所以我们要做的检查总数直到我们找到一个有效的方式，明显小于[2.x.6] 。然而，该算法在时间上仍然是指数级的，在内存上是线性的（我们只需要以已经添加的单元格的方向堆栈的形式来存储当前路径的信息）。
* 事实上，上面的两个例子表明，指数估计并不是悲观的：我们确实要追踪到那里的一个最开始的单元格，以找到一个以一致方式添加所有单元格的方法。
* 这种令人沮丧的情况因以下事实而大为改善：我们有一种用于2D的替代算法，在运行时间上总是线性的（由德克萨斯大学TICAM的迈克尔-安德森在2003年发现并实现），而对于3D，我们可以找到一种算法，在实践中通常只在时间和内存上是大致线性的。我们将在下文中描述这些算法。完整的描述和理论分析见 [2.x.7] 。
*

* [1.x.12]
*该算法使用了这样一个事实：一个单元格的相对面需要有相同的方向。所以你从一条任意的线开始，选择一个方向。那么对面的面的方向就已经固定了。然后去看我们已经固定的两个面对面的两个单元格：对它们来说，一个面已经固定了，所以我们也可以固定对面的面。继续这样做。最终，我们对一连串的单元格进行了这样的处理。然后从一个已经有两个固定面的单元格中抽取一个非固定面，再做一遍。
* 更详细地说，这个算法最好用一个例子来说明。我们考虑下面的网格。


* [1.x.13]
* 首先选择一个单元格（本例中为（0,1,3,4））。单元的一个侧面被任意地定向（3->4）。这个方向的选择然后在网格中传播，跨越边和元素。(0->1), (6->7)和(9->10)。这涉及到边跳和面跳，给出了一个以圆点显示的穿过网格的路径。


* [1.x.14]
* 然后对所选元素的其他面重复这一过程，对网格的更多面进行定向。


* [1.x.15]
* 一旦一个元素被完全定向，就不需要再考虑了。这些元素在图中用o来填充。然后我们转到下一个元素。


* [1.x.16]
* 重复这样做可以得到


* [1.x.17]
* 而最终的导向网是


* [1.x.18]
* 很明显，这个算法的运行时间是线性的，因为它对每个面只精确地接触一次。
* 刚才在二维情况下描述的算法在这个类中对二维和（通用形式）三维都有实现。三维情况下，使用片状而不是单元格串来工作。如果网格是可定向的，那么该算法能够在线性时间内完成其工作；如果它是不可定向的，那么它也会在线性时间内中止。
* 这两种算法在论文 "On orienting edges of unstructured two- and three-dimensional meshes "中描述，R. Agelek, M. Anderson, W. Bangerth, W. L. Barth, ACM Transactions on Mathematical Software, vol. 44, article 5, 2017。预印本可作为[1.x.19]使用。
*

* [1.x.20]
* 在实现上述算法之前（最初由Michael Anderson在2002年实现，由Wolfgang Bangerth在2016年根据[2.x.8]中的工作重新实现），我们使用了一个最初由Wolfgang Bangerth在2000年实现的分支和切割算法。虽然它不再被使用，但这里是它的工作原理，以及为什么它不总是对大网格有效，因为它的运行时间在糟糕的情况下可能是指数级的。
* 第一个观察结果是，虽然有反例，但问题通常是局部的。例如，在上面提到的第二个例子中，如果我们对单元格进行了编号，使相邻的单元格具有相似的单元格号，那么需要的回溯量就会大大减少。因此，在算法的实施过程中，第一步是以Cuthill-McKee的方式对单元格进行重新编号：从邻居数量最少的单元格开始，给它分配单元格编号为0。然后找到这个单元格的所有邻居，再给它们分配连续的数字。然后找到它们尚未被编号的邻居，给它们编号，以此类推。从图形上看，这意味着找到连续远离初始单元的单元区，并以这种前行的方式为它们编号。这已经大大改善了问题的局部性，从而减少了必要的回溯量。
* 第二点是，我们可以使用一些方法来修剪树，这通常会导致所有单元的有效方向非常快。
* 第一个方法是基于这样的观察：如果我们不能插入一个编号为N的单元格，那么这可能不是由于单元格N-1造成的，除非N-1是N的直接邻居。原因很明显：单元格M的选择方向只能影响添加单元格N的可能性，如果它是一个直接邻居，或者如果有一连串的单元格在M之后被添加并且连接单元格M和N。反过来说，如果我们不能添加单元格N，那么就没有必要追踪到单元格N-1，但我们可以追踪到单元格索引最大且已经被添加的N的邻居。
* 不幸的是，如果不谨慎应用，这种方法可能无法产生一个有效的树的路径。考虑以下情况，最初是从BAMG程序自动生成的950个单元的网格中提取的（这个程序通常生成的网格是相当不平衡的，通常有许多
*
* - 有时是10个或更多
*
* - 一个顶点的邻居，并且在最初的算法中暴露了一些问题；还要注意的是，这个例子是在2D中，我们现在有上面描述的更好的算法，但同样的观察也适用于3D）。)


* [1.x.21]
* 请注意，中间有一个洞。现在假设用户用顶点数字<tt>2 3 6 7</tt>来描述第一个单元格0，用<tt>15 14 11 10</tt>来描述单元格5，并假设单元格1、2、3、4的编号是可以在初始旋转中加入5。所有其他的单元格都以通常的方式进行编号，即从左下角开始，逆时针计数。鉴于对单元格的这种描述，算法将从零单元格开始，一个接一个地添加单元格，直到第六个。然后情况会是这样的。


* [1.x.22]
* 现在来看看第7个单元格，我们看到它的顶部和底部的两条相对的线有不同的方向；因此，我们将发现没有任何方向的第7个单元格可以在不违反三角形的一致性的情况下被添加。根据上述规则，我们回到索引最大的邻居，也就是单元格6，但由于它的底线是向右的，它的顶线也一定是向右的，所以我们无法找到单元格6的方向，从而使7符合三角形。然后，如果我们已经完成了单元格6的所有可能的方向，我们再追踪到6的最大索引的邻居，并且已经被添加了。然而，我们知道0号单元格的方向不可能是重要的，所以我们得出结论，没有任何可能的方法来确定给定单元格的所有线条的方向，使它们满足deal.II三角形的要求。我们知道这是不可能的，所以会导致抛出一个异常。
* 这个例子的底线是，当我们看了所有可能的单元格6的方向时，我们找不到一个可以添加单元格7的方向，然后决定追踪回单元格0，我们甚至没有尝试转动单元格5，之后添加单元格7就很简单了。因此，必须修改上述算法：如果我们未能在任何方向上添加一个单元格，我们只允许追踪回已经添加的那个邻居，其单元格索引最大。如果我们进一步追踪，因为我们已经用尽了所有可能的方向，但可以添加细胞（即我们追踪，因为另一个细胞，更远的地方不能添加，不管我们现在考虑的细胞的方向），那么我们不允许追踪到它的一个邻居，但必须只追踪一个细胞指数。
* 第二种修剪树的方法是，通常我们不能添加一个新的单元，因为它的一个已经被添加的邻居的方向是错误的。因此，如果我们可以尝试旋转其中一个邻居（当然要确保旋转该邻居不违反三角形的一致性），以允许现在的单元被添加。
* 第一种方法可以解释为在方向树上一次回溯不止一步，而转动一个邻居则意味着跳到树上一个完全不同的地方。对于这两种方法，人们可以找到论据，认为它们永远不会错过有效的路径，反正只跳过无效的路径。
* 这两种方法已经被证明是非常有效的。我们已经能够读取非常大的网格（几万个单元）而不需要回溯很多。特别是，我们发现找到单元格排序的时间与单元格的数量呈线性关系，而且重新排序的时间通常比从文件中读取数据所需的时间小得多（例如一个数量级），同时也比使用[2.x.9]函数从这些数据中实际生成三角图所需的时间小。
*


* [2.x.10]


* [0.x.1]

include/deal.II-translator/A-headers/simplex_0.txt
[0.x.0]*



* [2.x.0]



* [2.x.1]
* deal.II中的Simplex和混合网格仍然是实验性的，也就是正在进行的工作。该库的大部分内容已经被移植到能够操作这种网格上。然而，仍有许多函数需要被概括。通过查看 "test/simplex "文件夹中的测试，你可以对移植的功能有一个很好的概述。在下文中，我们提供了两个非常基本的例子来入门，并提供一些实现细节。
*

*
* [2.x.2] simplex_reference_example_simplex 示例：simplex网格
* 下面的代码显示了如何处理单纯x网格。
* [2.x.3]
*

*
* [2.x.4] simplex_reference_example_mixed 示例：混合网格
* 下面的代码显示了如何处理混合网格的工作。
* [2.x.5]
*

*
* [2.x.6] simplex_reference_cells 参考单元
* 在二维中，我们提供三角形和四边形，在三维中的可能方向如下。
* [2.x.7] [2.x.8] </div> [2.x.9] [2.x.10] </div> </div>
* 在三维中，四面体、金字塔、楔形和六面体都可以使用。
* [2.x.11] [2.x.12] </div> </div>
* [2.x.13] [2.x.14] </div
* [2.x.15] [2.x.16] </div
* [2.x.17] [2.x.18] </div> </div>
* 一个三维参考单元的每个表面由二维参考单元组成。枚举其顶点和线的编号的文件在右列给出。
*


* [0.x.1]

include/deal.II-translator/A-headers/slepc_0.txt
[0.x.0]*



* [2.x.0]
* 本模块中的类是对SLEPc库所提供的功能的封装。本组中的所有类和函数都驻留在一个命名空间中 [2.x.1] 。
* 只有在配置deal.II时检测到SLEPc安装和PETSc安装时，这些类才可用。请参考README文件以了解更多相关细节。
* [2.x.2] Toby D. Young, 2011



* [2.x.3]


* [0.x.1]

include/deal.II-translator/A-headers/solvers_0.txt
[0.x.0]*



* [2.x.0]
* 这个模块将迭代和直接求解器、特征值求解器和一些控制类组合在一起。所有这些类都对deal.II中定义的[2.x.1]"矩阵 "和[2.x.2]"矢量类 "的对象进行操作。
* 为了正常工作，将矩阵和向量类作为模板参数的求解器要求这些类满足某种最小的接口，可以从求解器内部使用。对于迭代求解器，这个接口被定义在求解器类中。此外，求解器使用从SolverControl类派生出来的类的对象进行控制（例如其派生类ReductionControl），以确定最大的迭代次数或所需的公差。
* 如果在配置过程中检测到（见ReadMe文件），一些稀疏的直接求解器也被支持。
*


* [2.x.3]


* [0.x.1]

include/deal.II-translator/A-headers/sparsity_0.txt
[0.x.0]*



* [2.x.0]
* 几乎所有的有限元公式都会导致矩阵的 "稀疏"，即每行的非零元素数量(i)与矩阵的整体大小相比相对较小，并且(ii)被一个固定的数字所限制，如果网格被细化，这个数字不会增长。在这种情况下，不存储矩阵的[1.x.0]元素，而只存储那些实际（或可能）为非零的元素会更有效。这需要为每一行存储非零项的列索引（我们称之为 "稀疏模式"），以及这些非零项的实际值。在实践中，有时会出现一些非零值实际上为零的情况。稀疏模式和稀疏矩阵只打算为[1.x.1]非零的条目提供空间，而且是在我们还不知道这些条目最终会有什么值的时候这样做；如果一个系数或单元格恰好有特定的值，它们可能会有一个零值）。)
* 在deal.II中，稀疏模式通常与实际的稀疏矩阵分开（除了SparseMatrixEZ类和一些来自外部库接口的类，如PETSc）。原因是人们经常有几个共享相同稀疏模式的矩阵；例子包括时间步进方案所需的刚度和质量矩阵，或者广义特征值问题的左手和右手矩阵。因此，如果它们中的每一个都必须单独存储它们的稀疏性模式，那将是一种浪费。
* 因此，deal.II具有矩阵类所建立的稀疏模式类。有两组主要的稀疏模式类，如下所述。
*

* [1.x.2]
* deal.II中的主要稀疏矩阵类，SparseMatrix，只为每个矩阵条目存储一个值，但不存储这些条目的位置。为此，它依赖于从与该矩阵相关的稀疏模式对象中获得的信息。这个稀疏性模式对象必须是SparsityPattern类型的。
* 因为矩阵是大的对象，而且改变它们的成本相对较高，所以SparsityPattern对象的构建分为两个阶段：首先，在一个 "动态 "阶段，分配期望在其上构建的矩阵有非零条目的位置；在第二个 "静态 "阶段，这些非零位置的表示被 "压缩 "成通常的压缩稀疏行（CSR）格式。在这之后，不能再添加新的非零位置。只有在压缩之后才能将稀疏模式与矩阵联系起来，因为后者需要前者的高效压缩数据格式。在动态阶段建立一个稀疏模式经常发生在[2.x.1]函数中。虽然这看起来是一个限制，但首先建立一个稀疏模式，然后只在先前分配的位置写入矩阵，这通常不是一个重要的问题，因为在有限元代码中，通常很清楚矩阵中哪些元素可能是非零的，哪些肯定是零的。
* 这种两阶段生成稀疏模式的优点是，当它实际用于矩阵时，有一个非常有效的格式。特别是，条目的位置被存储在一个线性数组中，允许快速访问，对具有深层次缓存的现代CPU类型很友好。因此，静态SparsityPattern类是deal.II的主SparseMatrix类可以工作的唯一对象。
* 静态稀疏模式的主要缺点是，它们的有效构造需要合理地猜测每一行最大可能有多少条目。在实际构建过程中，例如在[2.x.2]函数中，最多只能分配到之前所说的那么多条目。这是一个问题，因为通常很难估计每行的最大条目数。因此，一个常见的策略是首先建立和中间的稀疏模式，在构建稀疏模式的过程中使用效率较低的存储方案，然后直接复制到静态的、压缩的形式。大多数教程程序都是这样做的，从[2.x.3]开始（也可参见，例如[2.x.4]，[2.x.5]，和[2.x.6]教程程序）。
*

* [1.x.3]
* 如上所述，要获得一个稀疏模式的每一行的最大条目数的良好估计往往很复杂。因此，任何试图用不好的估计来分配一个普通的SparsityPattern的做法都需要大量的内存，几乎所有的内存都不会被使用，在压缩时被取消分配。
* 为了避免这种情况，deal.II包含一个名为DynamicSparsityPattern的 "动态 "或 "压缩 "稀疏性模式，它只分配必要的内存来容纳当前添加的条目。虽然这比上面提到的最坏情况下的行为节省了很多内存，但它需要使用效率较低的存储方案来插入元素，而且频繁分配内存往往也需要大量计算时间。然而，避免过多的内存分配的权衡是无法避免的。
*该类通常以如下方式使用


* [1.x.4]
*
* 中间的、压缩的稀疏模式被直接复制到最终静态模式的 "压缩 "形式中。
* [1.x.5]
* BlockDynamicSparsityPattern类实现了一个用于构造块矩阵的动态稀疏模式数组。更多信息见文档和[2.x.7]。
*


* [2.x.8]


* [0.x.1]

include/deal.II-translator/A-headers/trilinos_0.txt
[0.x.0]*



* [2.x.0]
* 本模块中的类是对Trilinos库所提供的功能的封装。它们提供了一个现代面向对象的接口，与deal.II中其他线性代数类的接口兼容。本组中的所有类和函数都驻留在一个命名空间中[2.x.1] 。
* 这些类只有在配置deal.II时检测到有Trilinos安装时才可用。请参考README文件以了解更多相关细节。
* [2.x.2] Martin Kronbichler, Wolfgang Bangerth, 2008
*


* [2.x.3]


* [0.x.1]

include/deal.II-translator/A-headers/update_flags_0.txt
[0.x.0]*



* [2.x.0]
* [1.x.0]
* 为了计算单个单元对全局矩阵和右手边的局部贡献，我们通常采用两种技术。
*


*
* - 首先，积分从实际单元[2.x.1]转换到单位/参考单元[2.x.2] 。例如，对于拉普拉斯方程，我们将[1.x.1]转换为[1.x.2]，其中帽子表示参考坐标，而[2.x.3]是映射[2.x.5]的雅各布[2.x.4] 。
*


*
* - 第二，这个积分然后通过正交法进行近似。这就产生了公式[1.x.3]，其中[2.x.6]表示正交点的索引，[2.x.7]其在参考单元上的位置，以及[2.x.8]其重量。
* 为了在应用程序代码中评估这样的表达式，我们必须访问三种不同的对象：描述参考单元上正交点的位置[2.x.9]和权重[2.x.10]的正交对象；描述单元上形状函数梯度[2.x.11]的有限元对象；以及提供雅各布系数和其行列式的映射对象。处理所有这些对象会很麻烦而且容易出错。
* 另一方面，这三种对象几乎总是一起出现，事实上，除了一起使用正交、有限元或映射对象，deal.II的应用代码很少对它们做任何事情。由于这个原因，deal.II使用FEValues抽象，结合了形状函数、实际网格单元的几何信息和参考单元的正交规则。在构建时，它在上述三个类别中各取一个对象。之后，它可以为一个具体的网格单元 "重新初始化"，然后提供映射的正交点和权重，映射的形状函数值和导数，以及从参考单元到实际网格单元转换的一些属性。
* 由于任何这些值的计算都是潜在的昂贵的（例如，当使用高阶元素的高阶映射时），FEValues类只计算它被明确要求的值。为此，它在构建时需要一个UpdateFlags类型的标志列表，指定每次访问一个单元时应该更新哪些数量。在上面的例子中，你想要实数单元上形状函数的梯度，这由标志 [2.x.12] 编码，以及雅各布系数的行列式乘以正交权重的乘积，这用术语 [2.x.13] 记忆性地编码了。因为这些标志是由整数中的单比特表示的，产生一个[1.x.4]相当于在一个整数中设置多个比特，这是用操作[2.x.14]来促进的（换句话说，也许有点混乱，操作[2.x.15]操作[1.x.5]，操作[2.x.16]是由表达[2.x.17][1.x.6] 单位-整数-该操作 [2.x.18] 为了使操作更便宜，FEValues和它所依赖的映射和有限元对象实际上只计算你在更新标志中指定的那些信息（加上一些计算指定内容所需的信息，见下文），而不是可能在一个单元上计算的所有信息。这种优化使得在单元格上进行迭代装配的成本大大降低，但这也意味着我们应该注意提供尽可能少的标志集。
* 此外，一旦你传递了一组你想要的标志，填充FEValues数据字段的函数就能够区分必须在每个单元上重新计算的值（例如映射梯度）和单元间不发生变化的量（例如不同单元上同一正交点的通常[2.x.19]有限元的形状函数值；但是这一特性对于Raviart-Thomas元素的形状函数不成立，它必须随本地单元旋转）。这允许进一步优化底层装配的计算。
*

* [1.x.7]
* 假设你想计算如上所示的拉普拉斯矩阵。在这种情况下，你需要指定[2.x.20]标志（用于[2.x.21]）和[2.x.22]标志（用于计算[2.x.23] ）。然而，在内部，有限元要求计算完整的雅各布矩阵的逆，[2.x.24]（而不仅仅是矩阵的行列式），为了计算雅各布矩阵的逆，还需要先计算雅各布矩阵。
* 由于这些是对用户不重要的要求，所以没有必要在用户代码中指定。相反，给定一组更新标志，FEValues对象首先询问有限元对象需要计算哪些信息，以满足用户在更新标志中提供的要求。因此，有限元对象可以向更新标志添加其他标志（例如，在上面的例子中，FE_Q对象将向列表中添加[2.x.25]，因为这是从[2.x.26]到[2.x.27]的必要转换）。有了这些更新的标志，FEValues就会通过调用[2.x.28]来询问映射是否也要在列表中添加更多的标志，以满足用户和有限元对象的需要（这种先询问有限元，再询问映射的程序不需要迭代，因为映射从来不需要有限元类计算的信息，而有限元类通常需要映射计算的信息）。使用这个最终的列表，FEValues对象然后要求有限元对象和映射对象都创建临时结构，将一些可以一次性计算的临时信息存储到其中，这些标志将在以后我们访问的每个单元上重新计算数据时使用。
*

* [1.x.8]
*如上所述，我们现在已经确定了满足用户所需信息的最后一套东西，这些信息是由他们提供的更新标志所传达的。然后，这些信息通常会在随后的整合循环中对用户代码访问的每个单元进行查询。
* 鉴于许多映射或有限元类的计算都是潜在的昂贵的，FEValues采用了一个系统，鼓励映射和有限元对象预先计算那些无需参考具体单元就能计算的信息，并在要求访问网格的特定单元时利用这些信息。一个例子是，普通FE_Q元素的形状函数的值是在参考单元上定义的，而实际单元上的值正好是参考单元上的值
*
* 因此，没有必要对每个单元格的形状函数进行评估，只需在开始时进行一次评估，将数值存储在某个地方，当访问一个具体的单元格时，只需将这些数值从临时位置复制到输出结构中即可。(但是请注意，这是FE_Q元素所特有的：如果我们使用FE_RaviartThomas元素就不是这样了，因为在那里，计算一个单元上的形状函数值需要知道映射的Jacobian，这取决于我们访问的单元的几何形状；因此，对于这个元素，简单地复制预先计算的信息并不足以评估特定单元上的形状函数值。)
* 为了适应这种结构，映射和有限元类都可以在内部将更新标志分成两组，通常被称为[2.x.29]（尽管这些名称没有出现在任何公共接口中）。前者包含所有那些在FEValues对象开始与映射或有限元交互时可以预先计算一次的信息，而后者则包含那些对应于需要在每个单元上计算的标志。例如，如果[2.x.30]，那么FE_Q类将设置[2.x.31]和[2.x.32]，而Raviart-Thomas元素将以相反的方式进行。
* 这些标志集的目的是相互排斥的。另一方面，没有任何东西可以为映射或有限元类之外的东西提供这种分解。
*
* - 它是一个纯粹的内部分解。
*

* [1.x.9]
* 如上所述，数据在两个不同的时间被计算：一次是在开始时在参考单元格上，另一次是每当我们移动到一个实际单元格时。接下来将讨论每个步骤所涉及的函数。
*

* [1.x.10]
* 在我们还没有访问第一个真实单元之前，计算参考单元的数据是一个两步的过程。首先，FEValues、FEFaceValues和FESubfaceValues的构造函数分别需要让Mapping和FiniteElement对象建立内部数据结构。这些结构在以下意义上是内部的：FEValues对象要求有限元和映射对象各创建一个[2.x.33]和[2.x.34]类型的对象；如果实际的有限元和映射类希望存储一些超出这些基类已经提供的数据，实际上可以创建衍生类型的对象。这其中涉及的函数有 [2.x.35] [2.x.36] [2.x.37] [2.x.38] [2.x.39] [2.x.40] [2.x.41] [2.x.42] 。
* 然后，FEValues对象接管了这些对象的所有权，并将在FEValues对象的生命周期结束时销毁它们。之后，FEValues对象要求FiniteElement和Mapping对象向这些InternalDataBase对象中填充与参考单元上可以和需要计算的内容有关的数据。这是在这些函数中完成的。  [2.x.43] [2.x.44] [2.x.45] [2.x.46] [2.x.47]。
*

* [1.x.11]
* 一旦初始化结束，我们调用[2.x.48][2.x.49]或[2.x.50]来移动到一个具体的单元或面，我们需要计算 "update_each "的各种数据。这是在以下函数中完成的。  [2.x.51] [2.x.52] 调用[2.x.53] 然后[2.x.54] [2.x.55] 调用[2.x.56] 然后[2.x.57] [2.x.58] 调用[2.x.59] 然后[2.x.60] [2.x.61] 。
* 这是计算存储在[2.x.62]和[2.x.63]对象中的FEValues实际数据字段的地方。这些函数首先调用Mapping中的函数，这样，有限元所需的所有映射数据都可以得到。然后，调用FiniteElement函数。
*


* [2.x.64]


* [0.x.1]

include/deal.II-translator/A-headers/utilities_0.txt
[0.x.0]*



* [2.x.0]
* 这个模块简单地收集了一些函数和类，为那些通常与有限元程序没有太大关系，但恰好也需要的任务提供了通用工具。


* [0.x.1]*



* [2.x.1]
* 这里有几个简单的类，有助于存储和查看数据。例如，Table模板不仅允许使用对象的数组（为此可能要使用[2.x.2]类），而且还允许使用任意对象的二维（矩形）表，以及高阶类似物，直到具有（目前）七个索引的表。
* 类似地，VectorSlice函数是一个基元，它接收任何具有类似于矢量的接口的东西（例如deal.II Vector或[2.x.3]类），并对其呈现一个视图，就好像它本身是一个矢量。
*


* [2.x.4]


* [0.x.2]

include/deal.II-translator/A-headers/vector_memory_0.txt
[0.x.0]*



* [2.x.0]
* 这个模块将一些类分组，用来避免在迭代过程中反复分配和解配向量。这些方法都使用基类VectorMemory的一个对象来获取它们的辅助向量。
* 关于这个话题的一些讨论可以在[2.x.1]中关于InverseMatrix类的讨论中找到。
*


* [2.x.2]


* [0.x.1]

include/deal.II-translator/A-headers/vectors_0.txt
[0.x.0]*



* [2.x.0]
* 在这里，我们列出了所有满足[2.x.1]概念的类，它们可能被用于线性求解器（见[2.x.2] ）和矩阵-向量操作。
*


* [2.x.3]


* [0.x.1]

include/deal.II-translator/A-headers/vector_valued_0.txt
[0.x.0]*



* [2.x.0]


* 矢量值问题是偏微分方程的系统。这些问题的解变量不是一个标量函数，而是一个矢量值函数或一组函数。这包括，例如。  2.x.1] [2.x.2] [2.x.3]、[2.x.4]和[2.x.5]中讨论的弹性方程，其解是每一点的向量值位移。    2.x.6] 在[2.x.7]和[2.x.8]中讨论的混合拉普拉斯方程及其扩展，其解是每一点的标量压力和矢量速度。    [2.x.9] 在[2.x.10]中讨论的斯托克斯方程及其扩展，以及[2.x.11]，其中的解也是每一点的标量压力和矢量速度。    [2.x.12] 由实部和虚部组成的复值解，例如在 [2.x.13] 中讨论。  [2.x.14]
* 本页概述了如何在deal.II中轻松实现此类矢量值问题。特别是，它解释了FESystem类的用法，它允许我们为偏微分系统编写代码，就像我们为单个方程编写代码一样。
* [2.x.15]
* [2.x.16]
*

*
* [2.x.17] VVExamples [1.x.1]。
* 系统地处理向量值问题的方式与标量问题没有根本的不同：首先，我们需要一个考虑到所有解变量的问题的弱（变）式。在我们这样做之后，生成系统矩阵和求解线性系统遵循我们已经习惯的大纲。
* [1.x.2]
* 让我们以[2.x.18]中的弹性问题为例，甚至通过选择[2.x.19]和[2.x.20]来简化它以突出重要的概念。因此，让我们考虑下面的弱表述：找到[2.x.21]，使所有[2.x.22]都持有[1.x.3] 这里，[1.x.4]表示由[2.x.23]定义的对称梯度，冒号表示两个等级为2的张量的双重收缩（Frobenius内部积）。这种双线性形式看起来确实非常像 [2.x.24] 中泊松问题的双线性形式。唯一的区别是 [2.x.25] [2.x.26] 我们用对称梯度替换了梯度算子；这实际上不是一个重大的区别，如果你用 [2.x.28] 替换 [2.x.27] ，这里说的一切都是真的。事实上，让我们这样做来简化讨论。[1.x.5]但请注意，这个系统并不十分令人兴奋，因为我们可以分别解决[1.x.6]的三个组成部分。
* [2.x.29] 现在的试验和测试函数来自空间[2.x.30]，它可以被视为标量空间[2.x.31]的三份副本。而这正是我们将在下面使用FESystem来实现这个空间的方法。  [2.x.32]
* 但现在，让我们再仔细看看这个系统。首先，让我们利用[1.x.7]=([1.x.8]<sub>1</sub>, [1.x.9]<sub>2</sub>, [1.x.10]<sub>3</sub>)<sup>T</sup>和[1.x.11]相应。然后，我们可以把坐标中的简化方程写成[1.x.12]。 我们看到，这只是拉普拉斯的双线性形式的三份拷贝，一份应用于每个分量（这是与[2.x.33]的表述更令人兴奋的地方，我们想推导出一个也适用于该表述的框架）。我们可以通过选择特殊的测试函数使这个弱形式再次成为微分方程组：首先，选择[1.x.13]=（[1.x.14]<sub>1</sub>,0,0）<sup>T</sup>，然后[1.x.15]=（0，[1.x.16]<sub>2</sub>,0)<sup>T</sup>, 最后[1.x.17]=(0,0,[1.x.18]<sub>3</sub>)<sup>T</sup>. 将这些结果写在彼此下面，我们得到系统[1.x.19]，我们使用标准内积符号 [2.x.34] 。对我们的理解很重要的是，我们要记住，后一种形式作为PDE系统完全等同于双线性形式的原始定义[1.x.20]([1.x.21],[1.x.22])，它并不立即表现出这种系统结构。最后，让我们写出具有对称梯度的弹性方程[1.x.23]的完整系统。[1.x.24] 非常正式地，如果我们相信算子值矩阵，我们可以将其改写为[1.x.25]<sup>T</sup>[1.x.26] = [1.x.27]<sup>T</sup>[1.x.28] 或 [1.x.29] 的形式。
*[1.x.30] 现在，让我们考虑一个更复杂的例子，即[2.x.35]中讨论的三维混合拉普拉斯方程：[1.x.31]
*
*这里，我们有四个解分量：标量压力[2.x.36]和有三个矢量分量的矢量值速度[2.x.37]。请注意，作为与前一个例子的重要区别，向量空间[1.x.32]并不仅仅是三个相同空间的简单复制/。
* 对于这个问题和其他矢量问题，获得弱式或变式的系统方法是，首先将其视为一个问题，其中运算符和解变量以矢量和矩阵形式书写。对于这个例子，这将读作：[1.x.33] 。
*
* 这就清楚地表明，解[1.x.34]有四个分量。
* 确实有四个成分。我们注意到，如果我们同时改变矩阵运算符的列，我们可以改变解的成分[2.x.38]和[2.x.39]在[2.x.40]里面的顺序。
* 接下来，我们需要考虑测试函数 [2.x.41] 。我们要将方程的两边都与它们相乘，然后对[2.x.42]进行积分。结果应该是一个标量的相等。我们可以通过选择[2.x.43]来实现这一点，因为[1.x.35]也是矢量值的。
*
* 将矩阵-向量方程与测试函数从左边相乘是很方便的，因为这样我们以后会自动得到正确的矩阵（在线性系统中，矩阵也是从右边与解变量相乘的，而不是从左边），而如果我们从右边相乘，那么这样汇集的矩阵就是我们真正想要的矩阵的转置。
* 考虑到这一点，让我们乘以[2.x.44]并进行积分，得到以下方程，该方程对所有测试函数[2.x.45]必须成立：[1.x.36]
* 或者等同于：[1.x.37] 。
*
*
* 我们通过对第二项的部分积分得到最终形式：[1.x.38] 。
*
* 正是这种形式，我们以后将用于将离散的弱形式组装成一个矩阵和一个右手边的向量：在这种形式中，我们有解和测试函数[2.x.46]，每个函数都由一些向量分量组成，我们可以提取。
*

* [2.x.47] VVFEs[1.x.39] 。
* 一旦我们确定了双线性形式和函数设置，我们就需要找到一种方法来描述矢量值有限元空间，并从中提取解和检验函数。这就是FESystem类的作用：它由较简单的空间组成矢量值的有限元空间。在弹性问题的例子中，我们需要同一元素的[2.x.48]份，例如


* [1.x.40]
* 这将产生一个维度为[2.x.49]的向量估值空间，其中每个分量都是FE_Q类型的连续双线性元素。它将有[2.x.50]倍于相应的FE_Q的基函数，这些基函数中的每一个都是FE_Q的基函数，被提升到矢量的一个分量中。
* 对于混合拉普拉斯，情况更为复杂。首先，我们必须确定一对离散空间 [2.x.51] 。一种选择是稳定的Raviart-Thomas对


* [1.x.41]
* 这个系统中的第一个元素已经是一个维度为[2.x.52]的矢量值元素，而第二个元素是一个普通的标量元素。
* 除了使用稳定的Raviart-Thomas对之外，我们还可以考虑混合拉普拉斯的稳定公式，例如LDG方法。在这里，我们可以选择使用相同的空间来计算速度分量和压力，即


* [1.x.42]
* 这个系统只是有[2.x.53]个相同的不连续元素的相等拷贝，这并没有真正反映系统的结构。因此，我们倾向于


* [1.x.43]
* 这里，我们有一个由两个元素组成的系统，一个是矢量值，一个是标量值，很像与[2.x.54]。事实上，在许多代码中，这两个可以互换。这个元素也允许我们很容易地切换到速度的低阶近似的LDG方法，即


* [1.x.44]
* 必须指出的是，这个元素不同于


* [1.x.45]
* 虽然构造函数的调用与[2.x.55]非常相似，但结果实际上更像[2.x.56]，因为这个元素产生[2.x.57]的独立组件。下面是对产生的FESystem对象的更详细的比较。
* [1.x.46]
* FESystem有一些内部变量，反映了构造函数所设置的内部结构。然后这些也可以被应用程序用来给矩阵组装和线性代数提供结构。我们在下表中给出了上述例子中这些变量的名称和值。<table border="1"> <tr><th>系统元素</th> [2.x.58] [2.x.59] [2.x.60] </tr> <tr><td>[2.x.61] </td><td>1</td> </tr> <tr><td>[2.x.62] </td><td>2</td> </tr> <tr><td> [2.x.63] </td><td>2</td> </tr> <tr><td> [2.x.64] </td><td>1</td> </tr> <tr><td> [2.x.65] </td><td>2</tr> </table>
*从这个表中可以看出，FES系统反映了[2.x.66]和[2.x.67]情况下微分方程组的很多结构，因为我们有一个矢量值和一个标量变量。另一方面，卷积元素没有这种结构，我们必须在组装系统时以某种方式重构它，如下所述。
* 在这一点上，需要注意的是，两个FES系统对象的嵌套可以给整个FES系统带来更丰富的结构，而不仅仅是将它们串联起来。这种结构可以被应用程序所利用，但不是自动的。
* [2.x.68] VVAssembling [1.x.47] 下一步是对线性系统进行组装。对于标量问题的简单情况，如何做到这一点已经在许多教程程序中显示出来，首先是 [2.x.69] 。在这里，我们将展示如何对矢量问题进行处理。对应于上述弱式的不同特征和创建的不同系统元素，我们有几个选择，概述如下。
* 整个概念可能最好的解释是通过展示一个例子，说明如何组装一个单元对上述混合拉普拉斯方程的弱形式的局部贡献。
* [1.x.48] 这基本上是[2.x.70]的做法。


* [1.x.49]
*
* 所以这里是发生了什么。  [2.x.71] [2.x.72] 我们做的第一件事是声明 "抽取器"（见FEValuesExtractors命名空间）。这些对象除了存储矢量值有限元的哪些分量构成单一的标量分量或秩1的张量（即我们所说的 "物理矢量"，总是由[2.x.73]分量组成）外，没有什么作用。在这里，我们声明一个对象，表示由[2.x.74]分量组成的速度，从零分量开始，以及压力的提取器，它是位置[2.x.75]的标量分量。
* [2.x.76] 然后我们对所有单元、形状函数和正交点进行常规循环。在最内部的循环中，我们计算一对形状函数对全局矩阵和右手向量的局部贡献。回顾一下，根据形状函数[2.x.77]：[1.x.50]，单元格对双线性形式的贡献（即忽略边界条款）看起来如下
*而实施起来则是这样的。       
* [1.x.51]
* 相似之处是相当明显的。
* [2.x.78] 基本上，上述代码中发生的情况是这样的：当你执行 [2.x.79] 时，会创建一个所谓的 "视图"，即一个与完整的FEValues对象不同的对象，它不代表有限元的所有组件，而只代表提取器对象 [2.x.80] 或 [2.x.81] 所代表的那（些）组件。
* [2.x.82] 然后可以向这些视图询问关于这些单独组件的信息。例如，当你写[2.x.83]时，你会得到[2.x.84]第1个形状函数[2.x.85]在[2.x.86]第1个正交点的压力分量的值。因为提取器[2.x.87]代表一个标量分量，运算器[2.x.88]的结果是一个标量数。另一方面，调用[2.x.89]将产生整组[2.x.90]分量的值，其类型为[2.x.91] 。
* [2.x.92] 其他可以用视图做的事情是要求提取器所描述的特定形状函数的分量的梯度。例如，[2.x.93]表示标量压力分量的梯度，其类型为[2.x.94]，而速度分量的梯度，[2.x.95]为[2.x.96]，即一个由条目[2.x.98]组成的矩阵[2.x.97] 。最后，标量和矢量视图都可以询问二阶导数（"Hessians"），矢量视图可以询问对称梯度，定义为 [2.x.99] 以及分歧 [2.x.100] 。  [2.x.101] 其他使用提取器和视图的例子见教程程序 [2.x.102] , [2.x.103] , [2.x.104] 和其他几个程序。
*


* [2.x.105] 在目前的背景下，当我们谈论一个矢量时（例如在提取上面的速度分量时），我们指的是物理学上使用的这个词：它有[2.x.106]分量，在坐标系变换下以特定方式表现出来。例子包括速度场或位移场。这与数学中使用 "矢量 "一词的方式相反（以及我们在库中的其他上下文中使用这个词的方式，例如在矢量类中），在那里它真正代表了一个数字的集合。后者的一个例子是火焰中化学物种浓度的集合；然而，这些实际上只是标量变量的集合，因为如果坐标系被旋转，它们不会改变，不像速度矢量的分量，因此，这个[2.x.107]类不应该被用于这种情况。
*

* [2.x.108] VVAlternative [1.x.52]。
* 在有些情况下，我们可以利用所使用的有限元的知识，对矩阵或右手边向量的装配进行一些优化。例如，考虑我们在 [2.x.109] 中首先关注的弹性方程的双线性形式。
* [1.x.53]
* 这里，[2.x.110]是一个具有[2.x.111]分量的向量函数，[2.x.112]是相应的测试函数，[2.x.113]是材料参数。鉴于我们上面的讨论，实现这种双线性形式的明显方法如下，使用一个提取器对象，将有限元的所有[2.x.114]分量解释为单一矢量，而不是不相交的标量分量。
*


* [1.x.54]

* 现在，这不是[2.x.115]中使用的代码。事实上，如果在该程序中实现的代码之上使用上述代码，它的运行速度会慢8%左右。通过仔细研究双线性形式，它可以得到改善（将惩罚降低到大约4%）。事实上，我们可以将其转换为：[1.x.55] 。
*其中[2.x.116]是对称的梯度。在第二至最后一步，我们用任意张量[2.x.117]和对称张量[2.x.118]之间的标量积等于前者的对称部分与第二张量的标量积。使用上面讨论的技术，实现这一点的明显方法是这样的。
*


* [1.x.56]
*
* 那么，如果同样，这不是我们在[2.x.119]中使用的代码，我们在那里做什么？答案取决于我们使用的有限元。在[2.x.120]中，我们使用以下元素。


* [1.x.57]
* 换句话说，我们使用的有限元由同一标量元素的[2.x.121]份组成。这就是我们所说的[2.x.122]"原始 "元素：一个可能是矢量值的元素，但每个形状函数正好有一个非零成分。换句话说：如果一个位移形状函数的[2.x.123]-分量是非零的，那么[2.x.124]-和[2.x.125]-分量必须是零，其他分量也是如此。这意味着基于形状函数的衍生量也继承了这种稀疏性。例如：矢量值形状函数[2.x.127]的发散[2.x.126]在本例中是[2.x.128]、[2.x.129]或[2.x.130]，因为[2.x.131]中正好有一个是非零。知道这一点意味着我们可以节省一些计算，如果我们要做这些计算，只会产生零的加法。
* 类似地，如果一个形状函数只有一个分量是非零的，那么它的梯度[2.x.132]就只有一行是非零。这对于像[2.x.133]这样的术语意味着什么，其中两个张量之间的标量积被定义为[2.x.134]，即只有当两个张量的非零项在同一行时，该术语才是非零的，这意味着两个形状函数必须在同一位置有其单一非零分量。
* 如果我们使用这种知识，那么我们可以在第一步避免计算梯度张量，如果我们可以预先确定它们的标量乘积将是非零的，在第二步避免建立整个张量，只得到它的非零分量，在最后一步简化标量乘积，只考虑一个非零行的索引[2.x.135]，而不是乘以和增加零。
* 这一切的载体是确定哪个向量分量将是非零的能力。这个信息是由[2.x.136]函数提供的。在 [2.x.137] 中详细解释了用它可以做什么，使用上面的例子。
*

* [2.x.138] VVBlockSolvers [1.x.58]。
* 使用如上所示的技术，对于一个矢量值问题，组装线性系统，即矩阵和右手边，并不特别复杂。然而，然后它还必须被解决。这就比较复杂了。直观地说，我们可以只把矩阵作为一个整体来考虑。对于大多数问题，这个矩阵不会是确定的（除了特殊情况，如[2.x.139]和[2.x.140]中涉及的弹性方程）。它通常也不是对称的。这类相当普遍的矩阵给迭代求解器带来了问题：由于缺乏结构特性，无法使用最有效的方法和预处理器。虽然可以做到这一点，但求解过程往往比必要的要慢。
*这个问题的答案是利用问题的结构。例如，对于上面讨论的混合拉普拉斯方程，算子的形式是[1.x.59] 。
*
* 如果这种结构也能在线性系统中恢复，那就更好了。例如，在离散化之后，我们希望有一个具有以下块状结构的矩阵：[1.x.60]
* 其中[2.x.141]代表离散化身份算子[2.x.142]产生的质量矩阵，[2.x.143]是梯度算子的等价物。
* 然而，在默认情况下，这并不是发生的情况。相反，deal.II以一种相当随机的方式给自由度分配%的数字。因此，如果你用自由度的值组成一个向量，就不会像[1.x.61]那样整齐地排列在一个向量中。
* 相反，它将是一个排列组合，与速度和压力相对应的自由度的%数混合在一起。因此，系统矩阵也不会有上面提到的漂亮结构，而是有相同的排列组合或行和列。
* 现在需要的是重新列举自由度，使速度在前，压力在后。这可以用[2.x.144]函数来完成，在[2.x.145]" [2.x.146]", [2.x.147], [2.x.148], 和[2.x.149]" [2.x.150]"中解释。在这之后，至少自由度被正确划分了。
* 但之后我们仍然要利用它，也就是说，我们必须拿出一个使用该结构的求解器。例如，在[2.x.151]中，我们对线性系统[1.x.62]做了一个块消除。
* 当然，这个系统的含义是[1.x.63] 。
*
* 因此，如果我们用第一个方程乘以[2.x.152]，再从结果中减去第二个方程，我们就得到[1.x.64] 。
*
* 这是一个现在只包含压力变量的方程。如果我们能解决这个问题，我们可以在第二步用[1.x.65]来解决速度问题。
*
* 这样做的好处是，我们要解决的矩阵[2.x.153]和[2.x.154]都是对称的和正定的，而不是我们之前的大整数矩阵。
* 像这样的求解器是如何实现的，在[2.x.155]step_20 " [2.x.156]"、[2.x.157]和其他一些教程程序中有更详细的解释。我们在这里想指出的是，我们现在需要一种方法来提取矩阵或向量的某些部分：如果我们要将，比如说，解向量的[2.x.158]部分与全局矩阵的[2.x.159]部分相乘，那么我们需要有一种方法来访问整体的这些部分。
* 这就是BlockVector、BlockSparseMatrix和类似的类的用处。为了所有的实际目的，那么可以作为常规的向量或稀疏矩阵使用，也就是说，它们提供元素访问，提供常规的向量操作，并实现例如矩阵-向量的乘法。换句话说，组装矩阵和右手边的工作方式与非块版本完全相同。也就是说，在内部，它们以 "块 "的形式存储向量和矩阵的元素；例如，BlockVector类不是使用一个大数组，而是将其存储为一组数组，每个数组我们称之为一个块。这样做的好处是，虽然整个东西可以作为一个向量使用，但人们也可以访问一个单独的块，然后，它又是一个具有所有向量操作的向量。
* 为了说明如何做到这一点，让我们考虑上面要解决的第二个方程[2.x.160]。这可以通过以下类似于我们在[2.x.161]中的序列来实现。


* [1.x.66]
*
* 这里发生的事情是，我们分配了一个临时向量，其元素数与解向量的第一块，即速度分量[2.x.162]相同。然后我们将这个临时向量设置为等于矩阵的[2.x.163]块，即[2.x.164]，乘以解决方案的分量1，即之前计算的压力[2.x.165]。结果乘以[2.x.166]，右手边的0分量[2.x.167]被添加到其中。现在的临时向量包含 [2.x.168] 。剩下的代码片段只是解决了一个线性系统，[2.x.169]为右手边，全局矩阵的[2.x.170]块，即[2.x.171] 。因此，以这种方式使用块状向量和矩阵，我们可以很容易地编写相当复杂的求解器，利用线性系统的块状结构。
*


* [2.x.172] VVExtracting [1.x.67]。
* 一旦计算出一个解决方案，往往需要在正交点上进行评估，例如为下一次牛顿迭代评估非线性残差，为误差估计器评估有限元残差，或者为时间相关问题的下一个时间步骤计算右手边。
* 这样做的方法是再次使用FEValues对象来评估正交点的形状函数，并且用这些来评估有限元函数的值。对于上面的混合拉普拉斯问题的例子，请考虑解算后的以下代码。


* [1.x.68]
*
* 在这之后，变量[2.x.173]是一个长度等于我们初始化FEValues对象的正交点数量的向量列表；每个向量都有[2.x.174]元素，包含[2.x.175]速度的值和正交点的一个压力。
* 我们可以用这些值来构建其他的东西，如残差。然而，这个构造有点尴尬。首先，我们有一个[2.x.176]s，这看起来总是很奇怪。它也是低效的，因为它意味着为外向量以及所有内向量分配动态内存。其次，也许我们只对速度感兴趣，例如，在第二阶段解决一个平流问题（例如，在[2.x.177]或[2.x.178]中）。在这种情况下，我们必须像这样手工提取这些值。


* [1.x.69]
* 注意我们如何从[2.x.179]（它只是一个矢量元素的集合）转换为[2.x.180]，因为速度是一个由[2.x.181]元素表征的量，在坐标系的旋转下具有某些变换特性。
* 这段代码可以用下面这样的代码写得更优雅、更有效。


* [1.x.70]
*
* 结果，我们在这里马上得到了速度，而且是正确的数据类型（因为我们已经用提取器描述了有限元的第一个[2.x.182]分量属于一起，形成一个张量）。这段代码也更有效率：它需要更少的动态内存分配，因为张量类将其成分作为成员变量而不是在堆上分配，而且我们节省了周期，因为我们甚至不需要费力计算正交点上的压力变量值。另一方面，如果我们只对压力而不是速度感兴趣，那么下面提取标量值的代码就可以了。


* [1.x.71]
*
* 在类似情况下，有时需要解的梯度或二阶导数，或者个别标量或矢量分量的梯度或二阶导数。为了获得解的所有分量的梯度，函数[2.x.183]和[2.x.184]相当于上面使用的函数[2.x.185]。
* 同样，要提取标量分量的梯度，[2.x.186]和[2.x.187]就可以完成这项工作。对于矢量（张量）值的量，有函数[2.x.188]和[2.x.189]，此外还有[2.x.190]和[2.x.191] 。
* 此外，在只需要解的拉普拉斯（即豫备的轨迹）的情况下，还有一个捷径，可用于标量和矢量值的问题，如[2.x.192]和[2.x.193] 。
*

* [2.x.194] VVOutput [1.x.72]。
* 如上所述，一个FESystem对象可能持有多个向量组件，但它并不清楚这些组件的实际含义。作为一个例子，以对象


* [1.x.73]
* 它有[2.x.195]个矢量分量，但它们是什么意思？它们是速度矢量的[2.x.196]分量加上一个压力吗？它们是压力加上[2.x.197]速度分量吗？还是它们是一个标量的集合？
* 关键是，FESystem类并不关心。元素的[1.x.74]含义是由后来使用该元素的人决定的，例如在组装线性表格时，或者在下一个牛顿步骤中为线性化系统提取数据解决方案组件时。几乎在所有情况下，这种解释都发生在需要它的地方。
* 然而，有一种情况是必须明确的，那就是在生成图形输出时。原因是许多用于可视化的文件格式希望表示矢量的数据（如速度、位移等）与标量（压力、密度等）分开存储，而且通常没有办法在可视化程序中把一堆标量分组为一个矢量场。
* 为了实现这一点，我们需要让DataOut类和朋友们知道FESystem的哪些成分形成了向量（有[2.x.198]成分），哪些是标量。例如，这在[2.x.199]中显示，我们产生的输出如下。


* [1.x.75]
* 换句话说，我们在这里创建了一个[2.x.200]元素的数组，在这个数组中，我们存储了有限元中哪些元素是向量，哪些是标量；这个数组被填充了[2.x.201]的副本和[2.x.203]的一个尾部元素。然后，该数组被作为一个额外的参数给到[2.x.204]，以解释如何解释给定解向量中的数据。像VisIt和Paraview这样的可视化程序将提供显示这些[2.x.205]组件的矢量场，而不是单个标量场。
*




* [2.x.206]


* [0.x.1]

