[0.x.0]*
     Implementation of a type with which to store the level of an accessor     object. We only need it for the case that <tt>structdim == dim</tt>.     Otherwise, an empty object is sufficient.    
* [0.x.1]*
         Default constructor.        
* [0.x.2]*
         Dummy constructor. Only level zero is allowed.        
* [0.x.3]*
         Dummy conversion operator. Returns level zero.        
* [0.x.4]*
     Implementation of a type with which to store the level of an accessor     object. We only need it for the case that <tt>structdim == dim</tt>.     Otherwise, an empty object is sufficient.    
* [0.x.5]*
 A namespace that contains exception classes used by the accessor classes.

* 
* [0.x.6]*
  
*  [2.x.0]   
* [0.x.7]*
   The cell is not an    [2.x.1]  "active"   cell, but it already has children. Some operations, like setting   refinement flags or accessing degrees of freedom are only possible on   active cells.    
*  [2.x.2]   
* [0.x.8]*
   Trying to access the children of a cell which is in fact active.    
*  [2.x.3]   
* [0.x.9]*
   Trying to access the parent of a cell which is in the coarsest level of   the triangulation.    
*  [2.x.4]   
* [0.x.10]*
  
*  [2.x.5]   
* [0.x.11]*
  
*  [2.x.6]   
* [0.x.12]*
  
*  [2.x.7]   
* [0.x.13]*
  
*  [2.x.8]   
* [0.x.14]*
  
*  [2.x.9]   
* [0.x.15]*
   You are trying to access the level of a face, but faces have no inherent   level. The level of a face can only be determined by the level of an   adjacent face, which in turn implies that a face can have several levels.    
*  [2.x.10]   
* [0.x.16]*
   You are trying to get the periodic neighbor for a face, which does not   have a periodic neighbor. For more information on this, refer to    [2.x.11]  "entry for periodic boundaries".  
*  [2.x.12]   
* [0.x.17]*
  
*  [2.x.13]   
* [0.x.18]*
 A base class for the accessor classes used by TriaRawIterator and derived classes.
*  This class offers only the basic functionality required by the iterators (stores the necessary data members, offers comparison operators and the like), but has no functionality to actually dereference data. This is done in the derived classes.
*  In the implementation, the behavior of this class differs between the cases where <tt>structdim==dim</tt> (cells of a mesh) and <tt>structdim&lt;dim</tt> (faces and edges). For the latter, #present_level is always equal to zero and the constructors may not receive a positive value there. For cells, any level is possible, but only those within the range of the levels of the Triangulation are reasonable. Furthermore, the function objects() returns either the container with all cells on the same level or the container with all objects of this dimension (<tt>structdim&lt;dim</tt>).
*  Some internals of this class are discussed in  [2.x.14] .
* 

* 
*  [2.x.15] 

* 
*  [2.x.16] 

* 
* [0.x.19]*
   Dimension of the space the object represented by this accessor lives in.   For example, if this accessor represents a quad that is part of a two-   dimensional surface in four-dimensional space, then this value is four.  
* [0.x.20]*
   Dimensionality of the object that the thing represented by this accessor   is part of. For example, if this accessor represents a line that is part   of a hexahedron, then this value will be three.  
* [0.x.21]*
   Dimensionality of the current object represented by this accessor. For   example, if it is line (irrespective of whether it is part of a quad or   hex, and what dimension we are in), then this value equals 1.  
* [0.x.22]*
   Copy operator. These operators are usually used in a context like   <tt>iterator a,b;a=*b;</tt>. Presumably, the intent here is to copy the   object pointed to   by  [2.x.17]  to the object pointed to by  [2.x.18]  However, the result of   dereferencing an iterator is not an object but an accessor; consequently,   this operation is not useful for iterators on triangulations.   Consequently, this operator is declared as deleted and can not be used.  
* [0.x.23]*
   Declare the data type that this accessor class expects to get passed from   the iterator classes. Since the pure triangulation iterators need no   additional data, this data type is  [2.x.19]   
* [0.x.24]*
   Constructor. Protected, thus only callable from friend classes.  
* [0.x.25]*
   Copy constructor. Creates an object with exactly the same data.  
* [0.x.26]*
   Copy operator. Since this is only called from iterators, do not return   anything, since the iterator will return itself.     This method is protected, since it is only to be called from the iterator   class.  
* [0.x.27]*
   Copy operator. Creates an object with exactly the same data.  
* [0.x.28]*
   Comparison operator for accessors. This operator is used when comparing   iterators into objects of a triangulation, for example when putting   them into a  [2.x.20]      If #structure_dimension is less than #dimension, we simply compare the   index of such an object because faces and edges do not have levels. If   #structure_dimension equals #dimension, we compare the level first, and   the index only if levels are equal.  
* [0.x.29]*
   Compare for equality.  
* [0.x.30]*
   Compare for inequality.  
* [0.x.31]*
    [2.x.21]  Advancement of iterators  
* [0.x.32]*
    [2.x.22]   
* [0.x.33]*
   This operator advances the iterator to the next element.     For  [2.x.23]  only: The next element is next on this level if there are   more. If the present element is the last on this level, the first on the   next level is accessed.  
* [0.x.34]*
   This operator moves the iterator to the previous element.     For  [2.x.24]  only: The previous element is previous on this level if   <tt>index>0</tt>. If the present element is the first on this level, the   last on the previous level is accessed.  
* [0.x.35]*
    [2.x.25]   
* [0.x.36]*
   Access to the other objects of a Triangulation with same dimension.  
* [0.x.37]*
   Data type to be used for passing parameters from iterators to the   accessor classes in a unified way, no matter what the type of number of   these parameters is.  
* [0.x.38]*
    [2.x.26]  Iterator address and state  
* [0.x.39]*
    [2.x.27]   
* [0.x.40]*
   For cells, this function returns the level within the mesh hierarchy at   which this cell is located. For all other objects, the function returns   zero.    
*  [2.x.28]  Within a Triangulation object, cells are uniquely identified by a   pair  [2.x.29]  where the former is the cell's   refinement level and the latter is the index of the cell within this   refinement level (the former being what this function returns).   Consequently, there may be multiple cells on different refinement levels   but with the same index within their level. Contrary to this, if the   current object corresponds to a face or edge, then the object is uniquely   identified solely by its index as faces and edges do not have a   refinement level. For these objects, the current function always returns   zero as the level.  
* [0.x.41]*
   Return the index of the element presently pointed to on the present   level.     Within a Triangulation object, cells are uniquely identified by a pair    [2.x.30]  where the former is the cell's refinement   level and the latter is the index of the cell within this refinement   level (the latter being what this function returns). Consequently, there   may be multiple cells on different refinement levels but with the same   index within their level. Contrary to this, if the current object   corresponds to a face or edge, then the object is uniquely identified   solely by its index as faces and edges do not have a refinement level.    
*  [2.x.31]  The indices objects returned by this function are not a contiguous   set of numbers on each level: going from cell to cell, some of the   indices in a level may be unused.    
*  [2.x.32]  If the triangulation is actually of type    [2.x.33]  then the indices are relatively only   to that part of the distributed triangulation that is stored on the   current processor. In other words, cells living in the partitions of the   triangulation stored on different processors may have the same index even   if they refer to the same cell, and the may have different indices even   if they do refer to the same cell (e.g., if a cell is owned by one   processor but is a ghost cell on another).  
* [0.x.42]*
   Return the state of the iterator.  For the different states an accessor   can be in, refer to the TriaRawIterator documentation.  
* [0.x.43]*
   Return a reference to the triangulation which the object pointed to by this   class belongs to.  
* [0.x.44]*
    [2.x.34]   
* [0.x.45]*
   The level if this is a cell (<tt>structdim==dim</tt>). Else, contains   zero.  
* [0.x.46]*
   Used to store the index of the element presently pointed to on the level   presently used.  
* [0.x.47]*
   Pointer to the triangulation which we act on.  
* [0.x.48]*
 A class that represents accessor objects to iterators that don't make sense such as quad iterators in on 1d meshes.  This class can not be used to create objects (it will in fact throw an exception if this should ever be attempted but it sometimes allows code to be written in a simpler way in a dimension independent way. For example, it allows to write code that works on quad iterators that is dimension independent
* 
*  -  i.e., also compiles in 1d
* 
*  -  because quad iterators (via the current class) exist and are syntactically correct. You can not expect, however, to ever create an actual object of one of these iterators in 1d, meaning you need to expect to wrap the code block in which you use quad iterators into something like  [2.x.35] 
* 
*  -  which makes eminent sense anyway.
*  This class provides the minimal interface necessary for Accessor classes to interact with Iterator classes. However, this is only for syntactic correctness, none of the functions do anything but generate errors.
* 

* 
*  [2.x.36] 

* 
* [0.x.49]*
   Propagate alias from base class to this class.  
* [0.x.50]*
   Constructor.  This class is used for iterators that do not make   sense in a given dimension, for example quads for 1d meshes. Consequently,   while the creation of such objects is syntactically valid, they make no   semantic sense, and we generate an exception when such an object is   actually generated.  
* [0.x.51]*
   Copy constructor.  This class is used for iterators that do not make   sense in a given dimension, for example quads for 1d meshes. Consequently,   while the creation of such objects is syntactically valid, they make no   semantic sense, and we generate an exception when such an object is   actually generated.  
* [0.x.52]*
   Conversion from other accessors to the current invalid one. This of   course also leads to a run-time error.  
* [0.x.53]*
   Dummy copy operation.  
* [0.x.54]*
   Dummy comparison operators.  
* [0.x.55]*
   Dummy operators to make things compile. Does nothing.  
* [0.x.56]*
   Dummy function representing whether the accessor points to a used or an   unused object.  
* [0.x.57]*
   Dummy function representing whether the accessor points to an object that   has children.  
* [0.x.58]*
   Dummy function that always returns  [2.x.37]   
* [0.x.59]*
   Dummy function that always returns  [2.x.38]   
* [0.x.60]*
   Dummy function that always throws.  
* [0.x.61]*
   Dummy function that always throws.  
* [0.x.62]*
   Dummy function to extract vertices. Returns the origin.  
* [0.x.63]*
   Dummy function to extract lines. Returns a default-constructed line   iterator.  
* [0.x.64]*
   Dummy function to extract quads. Returns a default-constructed quad   iterator.  
* [0.x.65]*
 A class that provides access to objects in a triangulation such as its vertices, sub-objects, children, geometric information, etc. This class represents objects of dimension  [2.x.39]  (i.e. 1 for lines, 2 for quads, 3 for hexes) in a triangulation of dimensionality  [2.x.40]  (i.e. 1 for a triangulation of lines, 2 for a triangulation of quads, and 3 for a triangulation of hexes) that is embedded in a space of dimensionality  [2.x.41]  (for  [2.x.42]  the triangulation represents a domain in  [2.x.43] , for  [2.x.44]  the triangulation is of a manifold embedded in a higher dimensional space).
*  There is a specialization of this class for the case where  [2.x.45]  equals zero, i.e., for vertices of a triangulation.
* 

* 
*  [2.x.46] 

* 
* [0.x.66]*
   Propagate alias from base class to this class.  
* [0.x.67]*
   Constructor.  
* [0.x.68]*
   The copy constructor is not deleted but copied constructed elements should   not be modified, also the comments to the copy assignment operator.  
* [0.x.69]*
   Move constructor.  
* [0.x.70]*
   Conversion constructor. This constructor exists to make certain   constructs simpler to write in dimension independent code. For example,   it allows assigning a face iterator to a line iterator, an operation that   is useful in 2d but doesn't make any sense in 3d. The constructor here   exists for the purpose of making the code conform to C++ but it will   unconditionally abort; in other words, assigning a face iterator to a   line iterator is better put into an if-statement that checks that the   dimension is two, and assign to a quad iterator in 3d (an operator that,   without this constructor would be illegal if we happen to compile for   2d).  
* [0.x.71]*
   Another conversion operator between objects that don't make sense, just   like the previous one.  
* [0.x.72]*
   Copy operator. These operators are usually used in a context like   <tt>iterator a,b;a=*b;</tt>. Presumably, the intent here is to copy the   object pointed to   by  [2.x.47]  to the object pointed to by  [2.x.48]  However, the result of   dereferencing an iterator is not an object but an accessor; consequently,   this operation is not useful for iterators on triangulations.   Consequently, this operator is declared as deleted and can not be used.  
* [0.x.73]*
   Move assignment operator. Moving is allowed.  
* [0.x.74]*
   Defaulted destructor.  
* [0.x.75]*
   Test for the element being used or not.  The return value is  [2.x.49]  for   all iterators that are either normal iterators or active iterators, only   raw iterators can return  [2.x.50]  Since raw iterators are only used in   the interiors of the library, you will not usually need this function.  
* [0.x.76]*
    [2.x.51]  Accessing sub-objects  
* [0.x.77]*
    [2.x.52]   
* [0.x.78]*
   Pointer to the  [2.x.53]  vertex bounding this object. Throw an exception if    [2.x.54] .  
* [0.x.79]*
   Return the global index of i-th vertex of the current object. The   convention regarding the numbering of vertices is laid down in the   documentation of the GeometryInfo class.     Note that the returned value is only the index of the geometrical vertex.   It has nothing to do with possible degrees of freedom associated with it.   For this, see the  [2.x.55]  functions.    
*  [2.x.56]  Despite the name, the index returned here is only global in the   sense that it is specific to a particular Triangulation object or, in the   case the triangulation is actually of type    [2.x.57]  specific to that part of the   distributed triangulation stored on the current processor.  
* [0.x.80]*
   Return a reference to the  [2.x.58]  vertex. The reference is not const,   i.e., it is possible to call this function on the left hand side of an   assignment, thereby moving the vertex of a cell within the triangulation.   Of course, doing so requires that you ensure that the new location of the   vertex remains useful
* 
*  -  for example, avoiding inverted or otherwise   distorted (see also    [2.x.59]  "this glossary entry").    
*  [2.x.60]  When a cell is refined, its children inherit the position of the   vertex positions of those vertices they share with the mother cell (plus   the locations of the new vertices on edges, faces, and cell interiors   that are created for the new child cells). If the vertex of a cell is   moved, this implies that its children will also use these new locations.   On the other hand, imagine a 2d situation where you have one cell that is   refined (with four children) and then you move the central vertex   connecting all four children. If you coarsen these four children again to   the mother cell, then the location of the moved vertex is lost and if, in   a later step, you refine the mother cell again, the then again new vertex   will be placed again at the same position as the first time around
* 
*  -    i.e., not at the location you had previously moved it to.    
*  [2.x.61]  The behavior described above is relevant if you have a    [2.x.62]  object. There, refining a mesh   always involves a re-partitioning. In other words, vertices of locally   owned cells (see    [2.x.63]  "this glossary entry")   that you may have moved to a different location on one processor may be   moved to a different processor upon mesh refinement (even if these   particular cells were not refined) which will re-create their position   based on the position of the coarse cells they previously had, not based   on the position these vertices had on the processor that previously owned   them. In other words, in parallel computations, you will probably have to   move nodes explicitly after every mesh refinement because vertex   positions may or may not be preserved across the re-partitioning that   accompanies mesh refinement.  
* [0.x.81]*
   Pointer to the  [2.x.64]  line bounding this object.  
* [0.x.82]*
   Line index of the  [2.x.65]  line bounding this object.     Implemented only for <tt>structdim>1</tt>, otherwise an exception   generated.  
* [0.x.83]*
   Pointer to the  [2.x.66]  quad bounding this object.  
* [0.x.84]*
   Quad index of the  [2.x.67]  quad bounding this object.     Implemented only for <tt>structdim>2</tt>, otherwise an exception   generated.  
* [0.x.85]*
    [2.x.68]   
* [0.x.86]*
    [2.x.69]  Orientation of sub-objects  
* [0.x.87]*
    [2.x.70]   
* [0.x.88]*
   Return whether the face with index  [2.x.71]  has its normal pointing in the   standard direction ( [2.x.72]  or whether it is the opposite ( [2.x.73]    Which is the standard direction is documented with the GeometryInfo   class. In 1d and 2d, this is always  [2.x.74]  but in 3d it may be   different, see the respective discussion in the documentation of the   GeometryInfo class.     This function is really only for internal use in the library unless you   absolutely know what this is all about.  
* [0.x.89]*
   Return whether the face with index  [2.x.75]  is rotated by 180 degrees ( [2.x.76]    true) or not ( [2.x.77]  In 1d and 2d, this is always  [2.x.78]  but in   3d it may be different, see the respective discussion in the   documentation of the GeometryInfo class.     This function is really only for internal use in the library unless you   absolutely know what this is all about.  
* [0.x.90]*
   Return whether the face with index  [2.x.79]  is rotated by 90 degrees ( [2.x.80]    true) or not ( [2.x.81]  In 1d and 2d, this is always  [2.x.82]  but in   3d it may be different, see the respective discussion in the   documentation of the GeometryInfo class.     This function is really only for internal use in the library unless you   absolutely know what this is all about.  
* [0.x.91]*
   Return whether the line with index  [2.x.83]  is oriented in standard   direction.  [2.x.84]  indicates, that the line is oriented from vertex 0 to   vertex 1, whereas it is the other way around otherwise. In 1d and 2d,   this is always  [2.x.85]  but in 3d it may be different, see the respective   discussion in the documentation of the GeometryInfo class.     This function is really only for internal use in the library unless you   absolutely know what this is all about.     This function queries  [2.x.86]   
* [0.x.92]*
    [2.x.87]   
* [0.x.93]*
    [2.x.88]  Accessing children  
* [0.x.94]*
    [2.x.89]   
* [0.x.95]*
   Test whether the object has children.  
* [0.x.96]*
   Return the number of immediate children of this object. The number of   children of an unrefined cell is zero.  
* [0.x.97]*
    [2.x.90]  Use n_active_descendants() instead.  
* [0.x.98]*
   Compute and return the number of active descendants of this objects. For   example, if all of the eight children of a hex are further refined   isotropically exactly once, the returned number will be 64, not 80.     If the present cell is not refined, one is returned.     If one considers a triangulation as a forest where the root of each tree   are the coarse mesh cells and nodes have descendants (the children of a   cell), then this function returns the number of terminal nodes in the   sub-tree originating from the current object; consequently, if the   current object is not further refined, the answer is one.  
* [0.x.99]*
   Return the number of times that this object is refined. Note that not all   its children are refined that often (which is why we prepend  [2.x.91]    the returned number is rather the maximum number of refinement in any   branch of children of this object.     For example, if this object is refined, and one of its children is   refined exactly one more time, then <tt>max_refinement_depth</tt> should   return 2.     If this object is not refined (i.e. it is active), then the return value   is zero.  
* [0.x.100]*
   Return an iterator to the  [2.x.92]  child.  
* [0.x.101]*
   Return the child number of  [2.x.93]  on the current cell. This is the   inverse function of  [2.x.94]   
* [0.x.102]*
   Return an iterator to that object that is identical to the ith child for   isotropic refinement. If the current object is refined isotropically,   then the returned object is the ith child. If the current object is   refined anisotropically, the returned child may in fact be a grandchild   of the object, or may not exist at all (in which case an exception is   generated).  
* [0.x.103]*
   Return the RefinementCase of this cell.  
* [0.x.104]*
   Index of the  [2.x.95]  child. The level of the child is one higher than that   of the present cell, if the children of a cell are accessed. The children   of faces have no level. If the child does not exist,
* 
*  -  is returned.  
* [0.x.105]*
   Index of the  [2.x.96]  isotropic child. See the isotropic_child() function   for a definition of this concept.  If the child does not exist,
* 
*  -  is   returned.  
* [0.x.106]*
    [2.x.97]   
* [0.x.107]*
    [2.x.98]  Dealing with boundary indicators  
* [0.x.108]*
    [2.x.99]   
* [0.x.109]*
   Return the boundary indicator of this object.     If the return value is the special value    [2.x.100]  then this object is in the interior   of the domain.      [2.x.101]     [2.x.102]  "Glossary entry on boundary indicators"  
* [0.x.110]*
   Set the boundary indicator of the current object. The same applies as for   the boundary_id() function.     This function only sets the boundary object of the current object itself,   not the indicators of the ones that bound it. For example, in 3d, if this   function is called on a face, then the boundary indicator of the 4 edges   that bound the face remain unchanged. If you want to set the boundary   indicators of face and edges at the same time, use the   set_all_boundary_ids() function. You can see the result of not using the   correct function in the results section of  [2.x.103] .      [2.x.104]  You should never set the boundary indicator of an interior face   (a face not at the boundary of the domain), or set the boundary   indicator of an exterior face to  [2.x.105]  (this   value is reserved for another purpose). Algorithms may not work or   produce very confusing results if boundary cells have a boundary   indicator of  [2.x.106]  or if interior cells have   boundary indicators other than  [2.x.107]    Unfortunately, the current object has no means of finding out whether it   really is at the boundary of the domain and so cannot determine whether   the value you are trying to set makes sense under the current   circumstances.    
*  [2.x.108]       [2.x.109]     [2.x.110]  "Glossary entry on boundary indicators"  
* [0.x.111]*
   Do as set_boundary_id() but also set the boundary indicators of the   objects that bound the current object. For example, in 3d, if   set_boundary_id() is called on a face, then the boundary indicator of the   4 edges that bound the face remain unchanged. In contrast, if you call   the current function, the boundary indicators of face and edges are all   set to the given value.     This function is useful if you set boundary indicators of faces in 3d (in   2d, the function does the same as set_boundary_id()) and you do so   because you want a curved boundary object to represent the part of the   boundary that corresponds to the current face. In that case, the   Triangulation class needs to figure out where to put new vertices upon   mesh refinement, and higher order Mapping objects also need to figure out   where new interpolation points for a curved boundary approximation should   be. In either case, the two classes first determine where interpolation   points on the edges of a boundary face should be, asking the boundary   object, before asking the boundary object for the interpolation points   corresponding to the interior of the boundary face. For this to work   properly, it is not sufficient to have set the boundary indicator for the   face alone, but you also need to set the boundary indicators of the edges   that bound the face. This function does all of this at once. You can see   the result of not using the correct function in the results section of    [2.x.111] .    
*  [2.x.112]       [2.x.113]     [2.x.114]  "Glossary entry on boundary indicators"  
* [0.x.112]*
   Return whether this object is at the boundary. Obviously, the use of this   function is only possible for <tt>dim [2.x.115]  however, for   <tt>dim==structdim</tt>, an object is a cell and the CellAccessor class   offers another possibility to determine whether a cell is at the boundary   or not.  
* [0.x.113]*
   Return a constant reference to the manifold object used for this object.     As explained in the    [2.x.116]    module, the process involved in finding the appropriate manifold   description involves querying both the manifold or boundary   indicators. See there for more information.  
* [0.x.114]*
    [2.x.117]   
* [0.x.115]*
    [2.x.118]  Dealing with manifold indicators  
* [0.x.116]*
    [2.x.119]   
* [0.x.117]*
   Return the manifold indicator of this object.     If the return value is the special value  [2.x.120]  then   this object is associated with a standard Cartesian Manifold Description.      [2.x.121]     [2.x.122]  "Glossary entry on manifold indicators"  
* [0.x.118]*
   Set the manifold indicator.  The same applies as for the   <tt>manifold_id()</tt> function.     Note that it only sets the manifold object of the current object itself,   not the indicators of the ones that bound it, nor of its children. For   example, in 3d, if this function is called on a face, then the manifold   indicator of the 4 edges that bound the face remain unchanged. If you   want to set the manifold indicators of face, edges and all children at   the same time, use the set_all_manifold_ids() function.      
*  [2.x.123]       [2.x.124]     [2.x.125]  "Glossary entry on manifold indicators"  
* [0.x.119]*
   Do as set_manifold_id() but also set the manifold indicators of the   objects that bound the current object. For example, in 3d, if   set_manifold_id() is called on a face, then the manifold indicator of the   4 edges that bound the face remain unchanged. On the other hand, the   manifold indicators of face and edges are all set at the same time using   the current function.    
*  [2.x.126]       [2.x.127]     [2.x.128]  "Glossary entry on manifold indicators"  
* [0.x.120]*
    [2.x.129]   
* [0.x.121]*
    [2.x.130]  User data  
* [0.x.122]*
    [2.x.131]   
* [0.x.123]*
   Read the user flag. See    [2.x.132]    for more information.  
* [0.x.124]*
   Set the user flag. See    [2.x.133]    for more information.  
* [0.x.125]*
   Clear the user flag. See    [2.x.134]    for more information.  
* [0.x.126]*
   Set the user flag for this and all descendants. See    [2.x.135]    for more information.  
* [0.x.127]*
   Clear the user flag for this and all descendants. See    [2.x.136]    for more information.  
* [0.x.128]*
   Reset the user data to zero, independent if pointer or index. See    [2.x.137]    for more information.  
* [0.x.129]*
   Set the user pointer to  [2.x.138]     
*  [2.x.139]  User pointers and user indices are mutually exclusive. Therefore,   you can only use one of them, unless you call    [2.x.140]  in between.     See    [2.x.141]    for more information.  
* [0.x.130]*
   Reset the user pointer to a  [2.x.142]  pointer. See    [2.x.143]    for more information.  
* [0.x.131]*
   Access the value of the user pointer. It is in the responsibility of the   user to make sure that the pointer points to something useful. You should   use the new style cast operator to maintain a minimum of type safety,   e.g.    
*  [2.x.144]  User pointers and user indices are mutually exclusive. Therefore,   you can only use one of them, unless you call    [2.x.145]  in between. <tt>A  a=static_cast<A*>(cell->user_pointer());</tt>.     See    [2.x.146]    for more information.  
* [0.x.132]*
   Set the user pointer of this object and all its children to the given   value. This is useful for example if all cells of a certain subdomain, or   all faces of a certain part of the boundary should have user pointers   pointing to objects describing this part of the domain or boundary.     Note that the user pointer is not inherited under mesh refinement, so   after mesh refinement there might be cells or faces that don't have user   pointers pointing to the describing object. In this case, simply loop   over all the elements of the coarsest level that has this information,   and use this function to recursively set the user pointer of all finer   levels of the triangulation.    
*  [2.x.147]  User pointers and user indices are mutually exclusive. Therefore,   you can only use one of them, unless you call    [2.x.148]  in between.     See    [2.x.149]    for more information.  
* [0.x.133]*
   Clear the user pointer of this object and all of its descendants. The   same holds as said for the recursively_set_user_pointer() function. See    [2.x.150]    for more information.  
* [0.x.134]*
   Set the user index to  [2.x.151]     
*  [2.x.152]  User pointers and user indices are mutually exclusive. Therefore,   you can only use one of them, unless you call    [2.x.153]  in between. See    [2.x.154]    for more information.  
* [0.x.135]*
   Reset the user index to 0. See    [2.x.155]    for more information.  
* [0.x.136]*
   Access the value of the user index.    
*  [2.x.156]  User pointers and user indices are mutually exclusive. Therefore,   you can only use one of them, unless you call    [2.x.157]  in between.     See    [2.x.158]    for more information.  
* [0.x.137]*
   Set the user index of this object and all its children.     Note that the user index is not inherited under mesh refinement, so after   mesh refinement there might be cells or faces that don't have the   expected user indices. In this case, simply loop over all the elements of   the coarsest level that has this information, and use this function to   recursively set the user index of all finer levels of the triangulation.    
*  [2.x.159]  User pointers and user indices are mutually exclusive. Therefore,   you can only use one of them, unless you call    [2.x.160]  in between.     See    [2.x.161]    for more information.  
* [0.x.138]*
   Clear the user index of this object and all of its descendants. The same   holds as said for the recursively_set_user_index() function.     See    [2.x.162]    for more information.  
* [0.x.139]*
    [2.x.163]   
* [0.x.140]*
    [2.x.164]  Geometric information about an object  
* [0.x.141]*
    [2.x.165]   
* [0.x.142]*
   Diameter of the object.     The diameter of an object is computed to be the largest diagonal of the   current object. If this object is a quadrilateral, then there are two   such diagonal, and if it is a hexahedron, then there are four diagonals   that connect "opposite" points. For triangles and tetrahedra, the function   simply returns the length of the longest edge.     The situation is more difficult for wedges and pyramids: For wedges, we   return the length of the longest diagonal of the three quadrilateral faces   or the longest edge length of the two triangular faces. For pyramids,   the same principle is applied.     In all of these cases, this definition of "diameter" is   not necessarily the true diameter in the sense of the largest distance   between points inside the object. Indeed, one can often construct objects   for which it is not, though these are generally quite deformed compared to   the reference shape. Furthermore, for objects that may use higher order   mappings, one may have bulging faces that also create trouble for   computing an exact representation of the diameter of the object. That said,   the definition used above is completely sufficient for most computations.  
* [0.x.143]*
   Return a pair of Point and double corresponding to the center and   the radius of a reasonably small enclosing ball of the object.     The function implements Ritter's O(n) algorithm to get a reasonably   small enclosing ball around the vertices of the object.   The initial guess for the enclosing ball is taken to be the ball   which contains the largest diagonal of the object as its diameter.   Starting from such an initial guess, the algorithm tests whether all   the vertices of the object (except the vertices of the largest diagonal)   are geometrically within the ball.   If any vertex (v) is found to be geometrically outside the ball,   a new iterate of the ball is constructed by shifting its center and   increasing the radius so as to geometrically enclose both the previous   ball and the vertex (v). The algorithm terminates when all the vertices   are geometrically inside the ball.     If a vertex (v) is geometrically inside a particular iterate of the ball,   then it will continue to be so in the subsequent iterates of   the ball (this is true \a by \a construction).    
*  [2.x.166]  This function assumes d-linear mapping from the reference cell.     [1.x.0] and   [Ritter 1990]  
* [0.x.144]*
   Return the smallest bounding box that encloses the object.     Notice that this method is not aware of any mapping you may be using to   do your computations. If you are using a mapping object that modifies the   position of the vertices, like MappingQEulerian, or MappingFEField, then   you should call the function  [2.x.167]  instead.  
* [0.x.145]*
   Length of an object in the direction of the given axis, specified in the   local coordinate system. See the documentation of GeometryInfo for the   meaning and enumeration of the local axes.     Note that the "length" of an object can be interpreted in a variety of   ways. Here, we choose it as the maximal length of any of the edges of the   object that are parallel to the chosen axis on the reference cell.  
* [0.x.146]*
   Return the minimal distance between any two vertices.  
* [0.x.147]*
   Return a point belonging to the Manifold<dim,spacedim> where this object   lives, given its parametric coordinates on the reference  [2.x.168]    cell. This function queries the underlying manifold object, and can be   used to obtain the exact geometrical location of arbitrary points on this   object.     Notice that the argument  [2.x.169]  are the coordinates on the    [2.x.170] reference cell [2.x.171] , given in reference coordinates. In other words,   the argument provides a weighting between the different vertices. For   example, for lines, calling this function with argument Point<1>(.5), is   equivalent to asking the line for its center.  
* [0.x.148]*
   This function computes a fast approximate transformation from the real to   the unit cell by inversion of an affine approximation of the  [2.x.172] -linear   function from the reference  [2.x.173] -dimensional cell.     The affine approximation of the unit to real cell mapping is found by a   least squares fit of an affine function to the  [2.x.174]  vertices of the   present object. For any valid mesh cell whose geometry is not degenerate,   this operation results in a unique affine mapping. Thus, this function   will return a finite result for all given input points, even in cases   where the actual transformation by an actual bi-/trilinear or higher   order mapping might be singular. Besides only approximating the mapping   from the vertex points, this function also ignores the attached manifold   descriptions. The result is only exact in case the transformation from   the unit to the real cell is indeed affine, such as in one dimension or   for Cartesian and affine (parallelogram) meshes in 2D/3D.     For exact transformations to the unit cell, use    [2.x.175]     
*  [2.x.176]  If dim<spacedim we first project p onto the plane.  
* [0.x.149]*
   Center of the object. The center of an object is defined to be the   average of the locations of the vertices, which is also where a  [2.x.177]    mapping would map the center of the reference cell. However, you can also   ask this function to instead return the average of the vertices as   computed by the underlying Manifold object associated with the current   object, by setting to true the optional parameter  [2.x.178]    Manifolds would then typically pull back the coordinates of the vertices   to a reference domain (not necessarily the reference cell), compute the   average there, and then push forward the coordinates of the averaged   point to the physical space again; the resulting point is guaranteed to   lie within the manifold, even if the manifold is curved.     When the object uses a different manifold description as its surrounding,   like when part of the bounding objects of this TriaAccessor use a   non-flat manifold description but the object itself is flat, the result   given by the  [2.x.179]  function may not be accurate enough,   even when parameter  [2.x.180]  is set to true. If you find this   to be case, than you can further refine the computation of the center by   setting to true the second additional parameter  [2.x.181]    interpolate_from_surrounding. This computes the location of the center by   a so-called transfinite interpolation from the center of all the bounding   objects. For a 2D object, it puts a weight of  [2.x.182]  on each of   the four surrounding lines and a weight  [2.x.183]  on the four   vertices. This corresponds to a linear interpolation between the   descriptions of the four faces, subtracting the contribution of the   vertices that is added twice when coming through both lines adjacent to   the vertex. In 3D, the weights for faces are  [2.x.184] , the   weights for lines are  [2.x.185] , and the weights for vertices are    [2.x.186] . For further information, also confer to the   TransfiniteInterpolationManifold class that is able to not only apply   this beneficial description to a single cell but all children of a coarse   cell.  
* [0.x.150]*
   Return the barycenter (also called centroid)   of the object. The barycenter for an object  [2.x.187]    of dimension  [2.x.188]  in  [2.x.189]  space dimensions is given by the  [2.x.190] -dimensional   vector  [2.x.191]  defined by   [1.x.1]   where the measure of the object is given by   [1.x.2]   This function assumes that  [2.x.192]  is mapped by a  [2.x.193] -linear function from   the reference  [2.x.194] -dimensional cell. Then the integrals above can be   pulled back to the reference cell and evaluated exactly (if through   lengthy and, compared to the center() function, expensive computations).  
* [0.x.151]*
   Compute the dim-dimensional measure of the object. For a dim-dimensional   cell in dim-dimensional space, this equals its volume. On the other hand,   for a 2d cell in 3d space, or if the current object pointed to is a 2d   face of a 3d cell in 3d space, then the function computes the area the   object occupies. For a one-dimensional object, return its length.     The function only computes the measure of cells, faces or edges assumed   to be represented by (bi-/tri-)linear mappings. In other words, it only   takes into account the locations of the vertices that bound the current   object but not how the interior of the object may actually be mapped. In   most simple cases, this is exactly what you want. However, for objects   that are not "straight", e.g. 2d cells embedded in 3d space as part of a   triangulation of a curved domain, two-dimensional faces of 3d cells that   are not just parallelograms, or for faces that are at the boundary of a   domain that is not just bounded by straight line segments or planes, this   function only computes the dim-dimensional measure of a (bi-/tri-)linear   interpolation of the "real" object as defined by the manifold or boundary   object describing the real geometry of the object in question. If you   want to consider the "real" geometry, you will need to compute the   measure by integrating a function equal to one over the object, which   after applying quadrature equals the summing the JxW values returned by   the FEValues or FEFaceValues object you will want to use for the   integral.  
* [0.x.152]*
   Return true if the current object is a translation of the given argument.    
*  [2.x.195]  For the purpose of a triangulation, cells, faces, etc are only   characterized by their vertices. The current function therefore only   compares the locations of vertices. For many practical applications,   however, it is not only the vertices that determine whether one cell is a   translation of another, but also how the cell is mapped from the   reference cell to its location in real space. For example, if we are   using higher order mappings, then not only do the vertices have to be   translations of each other, but also the points along edges. In these   questions, therefore, it would be appropriate to ask the mapping, not the   current function, whether two objects are translations of each other.  
* [0.x.153]*
   Reference cell type of the current object.  
* [0.x.154]*
   Number of vertices.  
* [0.x.155]*
   Number of lines.  
* [0.x.156]*
   Number of faces.    
*  [2.x.196]  Only implemented for cells (dim==spacedim).  
* [0.x.157]*
   Return an object that can be thought of as an array containing all indices   from zero to n_vertices().  
* [0.x.158]*
   Return an object that can be thought of as an array containing all indices   from zero to n_lines().  
* [0.x.159]*
   Return an object that can be thought of as an array containing all indices   from zero to n_faces().    
*  [2.x.197]  Only implemented for cells (dim==spacedim).  
* [0.x.160]*
    [2.x.198]   
* [0.x.161]*
   Like set_boundary_id but without checking for internal faces or invalid   ids.  
* [0.x.162]*
   Set the indices of those objects that bound the current   object. For example, if the current object represents a cell,   then the argument denotes the indices of the faces that bound the   cell. If the current object represents a line, the argument   denotes the indices of the vertices that bound it. And so on.  
* [0.x.163]*
   The same as above but for `unsigned int`.  
* [0.x.164]*
   Set the flag indicating, what  [2.x.199]  will   return.     It is only possible to set the line_orientation of faces in 3d (i.e.    [2.x.200] ).  
* [0.x.165]*
   Set whether the quad with index  [2.x.201]  has its normal pointing in the   standard direction ( [2.x.202]  or whether it is the opposite ( [2.x.203]    Which is the standard direction is documented with the GeometryInfo   class.     This function is only for internal use in the library. Setting this flag   to any other value than the one that the triangulation has already set is   bound to bring you disaster.  
* [0.x.166]*
   Set the flag indicating, what  [2.x.204]  will return.     It is only possible to set the face_orientation of cells in 3d (i.e.    [2.x.205] ).  
* [0.x.167]*
   Set the flag indicating, what  [2.x.206]  will return.     It is only possible to set the face_orientation of cells in 3d (i.e.    [2.x.207] ).  
* [0.x.168]*
   Set the  [2.x.208]  flag. Only for internal use in the library.  
* [0.x.169]*
   Clear the  [2.x.209]  flag. Only for internal use in the library.  
* [0.x.170]*
   Set the  [2.x.210]  this TriaObject is refined with. Not   defined for <tt>structdim=1</tt> as lines are always refined resulting in   2 children lines (isotropic refinement).     You should know quite exactly what you are doing if you touch this   function. It is exclusively for internal use in the library.  
* [0.x.171]*
   Clear the RefinementCase<dim> of this TriaObject, i.e. reset it to    [2.x.211]      You should know quite exactly what you are doing if you touch this   function. It is exclusively for internal use in the library.  
* [0.x.172]*
   Set the index of the ith child. Since the children come at least in   pairs, we need to store the index of only every second child, i.e. of the   even numbered children. Make sure, that the index of child i=0 is set   first. Calling this function for odd numbered children is not allowed.  
* [0.x.173]*
   Clear the child field, i.e. set it to a value which indicates that this   cell has no children.  
* [0.x.174]*
 This class is a specialization of <code>TriaAccessor<structdim, dim, spacedim></code> for the case that  [2.x.212]  is zero. This class represents vertices in a triangulation of dimensionality  [2.x.213]  (i.e. 1 for a triangulation of lines, 2 for a triangulation of quads, and 3 for a triangulation of hexes) that is embedded in a space of dimensionality  [2.x.214]  (for  [2.x.215]  the triangulation represents a domain in  [2.x.216] , for  [2.x.217]  the triangulation is of a manifold embedded in a higher dimensional space).
*  There is a further specialization of this class for the case that  [2.x.218]  equals one, i.e., for vertices of a one-dimensional triangulation, since in that case vertices are also faces.
* 

* 
*  [2.x.219] 

* 
* [0.x.175]*
   Dimension of the space the object represented by this accessor lives in.   For example, if this accessor represents a quad that is part of a two-   dimensional surface in four-dimensional space, then this value is four.  
* [0.x.176]*
   Dimensionality of the object that the thing represented by this accessor   is part of. For example, if this accessor represents a line that is part   of a hexahedron, then this value will be three.  
* [0.x.177]*
   Dimensionality of the current object represented by this accessor. For   example, if it is line (irrespective of whether it is part of a quad or   hex, and what dimension we are in), then this value equals 1.  
* [0.x.178]*
   Pointer to internal data.  
* [0.x.179]*
   Constructor. The second argument is the global index of the vertex we   point to.  
* [0.x.180]*
   Constructor. This constructor exists in order to maintain interface   compatibility with the other accessor classes.  [2.x.220]  can be used to   set the global index of the vertex we point to.  
* [0.x.181]*
   Constructor. Should never be called and thus produces an error.  
* [0.x.182]*
   Constructor. Should never be called and thus produces an error.  
* [0.x.183]*
   Return the state of the iterator.  
* [0.x.184]*
   Level of this object. Vertices have no level, so this function always   returns zero.  
* [0.x.185]*
   Index of this object. Returns the global index of the vertex this object   points to.  
* [0.x.186]*
   Return a reference to the triangulation which the object pointed to by this   class belongs to.  
* [0.x.187]*
    [2.x.221]  Advancement of iterators  
* [0.x.188]*
    [2.x.222]   
* [0.x.189]*
   This operator advances the iterator to the next element.  
* [0.x.190]*
   This operator moves the iterator to the previous element.  
* [0.x.191]*
   Compare for equality.  
* [0.x.192]*
   Compare for inequality.  
* [0.x.193]*
    [2.x.223]   
* [0.x.194]*
    [2.x.224]  Accessing sub-objects  
* [0.x.195]*
    [2.x.225]   
* [0.x.196]*
   Return the global index of i-th vertex of the current object. If  [2.x.226]  is   zero, this returns the index of the current point to which this object   refers. Otherwise, it throws an exception.     Note that the returned value is only the index of the geometrical vertex.   It has nothing to do with possible degrees of freedom associated with it.   For this, see the  [2.x.227]  functions.    
*  [2.x.228]  Despite the name, the index returned here is only global in the   sense that it is specific to a particular Triangulation object or, in the   case the triangulation is actually of type    [2.x.229]  specific to that part of the   distributed triangulation stored on the current processor.  
* [0.x.197]*
   Return a reference to the  [2.x.230]  vertex. If i is zero, this returns a   reference to the current point to which this object refers. Otherwise, it   throws an exception.  
* [0.x.198]*
   Pointer to the  [2.x.231]  line bounding this object. Will point to an invalid   object.  
* [0.x.199]*
   Line index of the  [2.x.232]  line bounding this object. Throws an exception.  
* [0.x.200]*
   Pointer to the  [2.x.233]  quad bounding this object.  
* [0.x.201]*
   Quad index of the  [2.x.234]  quad bounding this object. Throws an exception.  
* [0.x.202]*
    [2.x.235]   
* [0.x.203]*
    [2.x.236]  Geometric information about an object  
* [0.x.204]*
    [2.x.237]   
* [0.x.205]*
   Diameter of the object. This function always returns zero.  
* [0.x.206]*
   Length of an object in the direction of the given axis, specified in the   local coordinate system. See the documentation of GeometryInfo for the   meaning and enumeration of the local axes.     This function always returns zero.  
* [0.x.207]*
   Return the center of this object, which of course coincides with the   location of the vertex this object refers to. The parameters  [2.x.238]    respect_manifold and  [2.x.239]  are not used. They   are there to provide the same interface as    [2.x.240] .  
* [0.x.208]*
   Compute the dim-dimensional measure of the object. For a dim-dimensional   cell in dim-dimensional space, this equals its volume. On the other hand,   for a 2d cell in 3d space, or if the current object pointed to is a 2d   face of a 3d cell in 3d space, then the function computes the area the   object occupies. For a one-dimensional object, return its length. For a   zero-dimensional object, return zero.  
* [0.x.209]*
    [2.x.241]   
* [0.x.210]*
    [2.x.242]  Orientation of sub-objects  
* [0.x.211]*
    [2.x.243]   
* [0.x.212]*
  
*  [2.x.244]   
* [0.x.213]*
  
*  [2.x.245]   
* [0.x.214]*
  
*  [2.x.246]   
* [0.x.215]*
  
*  [2.x.247]   
* [0.x.216]*
    [2.x.248]   
* [0.x.217]*
    [2.x.249]  Accessing children  
* [0.x.218]*
    [2.x.250]   
* [0.x.219]*
   Test whether the object has children. Always false.  
* [0.x.220]*
   Return the number of immediate children of this object. This is always   zero.  
* [0.x.221]*
   Compute and return the number of active descendants of this objects.   Always zero.  
* [0.x.222]*
    [2.x.251]  Use n_active_descendants() instead.  
* [0.x.223]*
   Return the number of times that this object is refined. Always 0.  
* [0.x.224]*
  
*  [2.x.252]   
* [0.x.225]*
  
*  [2.x.253]   
* [0.x.226]*
  
*  [2.x.254]   
* [0.x.227]*
   Always return no refinement.  
* [0.x.228]*
  
*  [2.x.255] 
* 
*  -   
* [0.x.229]*
  
*  [2.x.256] 
* 
*  -   
* [0.x.230]*
    [2.x.257]   
* [0.x.231]*
   Return whether the vertex pointed to here is used.  
* [0.x.232]*
   Copy operator. Since this is only called from iterators, do not return   anything, since the iterator will return itself.     This method is protected, since it is only to be called from the iterator   class.  
* [0.x.233]*
   Comparison operator for accessors. This operator is used when comparing   iterators into objects of a triangulation, for example when putting   them into a  [2.x.258]      This operator simply compares the global index of the vertex the   current object points to.  
* [0.x.234]*
   Pointer to the triangulation we operate on.  
* [0.x.235]*
   The global vertex index of the vertex this object corresponds to.  
* [0.x.236]*
 This class is a specialization of <code>TriaAccessor<structdim, dim, spacedim></code> for the case that  [2.x.259]  is zero and  [2.x.260]  is one. This class represents vertices in a one-dimensional triangulation that is embedded in a space of dimensionality  [2.x.261]  (for  [2.x.262]  the triangulation represents a domain in  [2.x.263] , for  [2.x.264]  the triangulation is of a manifold embedded in a higher dimensional space).
*  The current specialization of the TriaAccessor<0,dim,spacedim> class for vertices of a one-dimensional triangulation exists since in the  [2.x.265]  == 1 case vertices are also faces.
* 

* 
*  [2.x.266] 

* 
* [0.x.237]*
   Dimension of the space the object represented by this accessor lives in.   For example, if this accessor represents a quad that is part of a two-   dimensional surface in four-dimensional space, then this value is four.  
* [0.x.238]*
   Dimensionality of the object that the thing represented by this accessor   is part of. For example, if this accessor represents a line that is part   of a hexahedron, then this value will be three.  
* [0.x.239]*
   Dimensionality of the current object represented by this accessor. For   example, if it is line (irrespective of whether it is part of a quad or   hex, and what dimension we are in), then this value equals 1.  
* [0.x.240]*
   Pointer to internal data.  
* [0.x.241]*
   Whether the vertex represented here is at the left end of the domain, the   right end, or in the interior.  
* [0.x.242]*
     Left vertex.    
* [0.x.243]*
     Interior vertex.    
* [0.x.244]*
     Right vertex.    
* [0.x.245]*
   Constructor.     Since there is no mapping from vertices to cells, an accessor object for   a point has no way to figure out whether it is at the boundary of the   domain or not. Consequently, the second argument must be passed by the   object that generates this accessor
* 
*  -  e.g. a 1d cell that can figure out   whether its left or right vertex are at the boundary.     The third argument is the global index of the vertex we point to.  
* [0.x.246]*
   Constructor. This constructor exists in order to maintain interface   compatibility with the other accessor classes. However, it doesn't do   anything useful here and so may not actually be called.  
* [0.x.247]*
   Constructor. Should never be called and thus produces an error.  
* [0.x.248]*
   Constructor. Should never be called and thus produces an error.  
* [0.x.249]*
   Copy operator. Since this is only called from iterators, do not return   anything, since the iterator will return itself.  
* [0.x.250]*
   Return the state of the iterator. Since an iterator to points can not be   incremented or decremented, its state remains constant, and in particular   equal to  [2.x.267]   
* [0.x.251]*
   Level of this object. Vertices have no level, so this function always   returns zero.  
* [0.x.252]*
   Index of this object. Returns the global index of the vertex this object   points to.  
* [0.x.253]*
   Return a reference to the triangulation which the object pointed to by this   class belongs to.  
* [0.x.254]*
    [2.x.268]  Advancement of iterators  
* [0.x.255]*
    [2.x.269]   
* [0.x.256]*
   This operator advances the iterator to the next element. For points, this   operation is not defined, so you can't iterate over point iterators.  
* [0.x.257]*
   This operator moves the iterator to the previous element. For points,   this operation is not defined, so you can't iterate over point iterators.  
* [0.x.258]*
   Compare for equality.  
* [0.x.259]*
   Compare for inequality.  
* [0.x.260]*
   Comparison operator for accessors. This operator is used when comparing   iterators into objects of a triangulation, for example when putting   them into a  [2.x.270]      This operator simply compares the global index of the vertex the   current object points to.  
* [0.x.261]*
    [2.x.271]   
* [0.x.262]*
    [2.x.272]  Accessing sub-objects  
* [0.x.263]*
    [2.x.273]   
* [0.x.264]*
   Return the global index of i-th vertex of the current object. If i is   zero, this returns the index of the current point to which this object   refers. Otherwise, it throws an exception.     Note that the returned value is only the index of the geometrical vertex.   It has nothing to do with possible degrees of freedom associated with it.   For this, see the  [2.x.274]  functions.    
*  [2.x.275]  Despite the name, the index returned here is only global in the   sense that it is specific to a particular Triangulation object or, in the   case the triangulation is actually of type    [2.x.276]  specific to that part of the   distributed triangulation stored on the current processor.  
* [0.x.265]*
   Return a reference to the  [2.x.277]  vertex. If i is zero, this returns a   reference to the current point to which this object refers. Otherwise, it   throws an exception.  
* [0.x.266]*
   Return the center of this object, which of course coincides with the   location of the vertex this object refers to.  
* [0.x.267]*
   Pointer to the  [2.x.278]  line bounding this object. Will point to an invalid   object.  
* [0.x.268]*
   Line index of the  [2.x.279]  line bounding this object.     Implemented only for <tt>structdim>1</tt>, otherwise an exception   generated.  
* [0.x.269]*
   Pointer to the  [2.x.280]  quad bounding this object.  
* [0.x.270]*
   Quad index of the  [2.x.281]  quad bounding this object.     Implemented only for <tt>structdim>2</tt>, otherwise an exception   generated.  
* [0.x.271]*
    [2.x.282]   
* [0.x.272]*
   Return whether this point is at the boundary of the one-dimensional   triangulation we deal with here.  
* [0.x.273]*
   Return the boundary indicator of this object. The convention for one   dimensional triangulations is that left end vertices (of each line   segment from which the triangulation may be constructed) have boundary   indicator zero, and right end vertices have boundary indicator one,   unless explicitly set differently.     If the return value is the special value    [2.x.283]  then this object is in the interior   of the domain.      [2.x.284]     [2.x.285]  "Glossary entry on boundary indicators"  
* [0.x.274]*
   Return a constant reference to the manifold object used for this object.  
* [0.x.275]*
   Return the manifold indicator of this object.      [2.x.286]     [2.x.287]  "Glossary entry on manifold indicators"  
* [0.x.276]*
    [2.x.288]  Orientation of sub-objects  
* [0.x.277]*
    [2.x.289]   
* [0.x.278]*
  
*  [2.x.290]   
* [0.x.279]*
  
*  [2.x.291]   
* [0.x.280]*
  
*  [2.x.292]   
* [0.x.281]*
  
*  [2.x.293]   
* [0.x.282]*
    [2.x.294]   
* [0.x.283]*
    [2.x.295]  Accessing children  
* [0.x.284]*
    [2.x.296]   
* [0.x.285]*
   Test whether the object has children. Always false.  
* [0.x.286]*
   Return the number of immediate children of this object.This is always   zero in dimension 0.  
* [0.x.287]*
   Compute and return the number of active descendants of this objects.   Always zero.  
* [0.x.288]*
    [2.x.297]  Use n_active_descendants() instead.  
* [0.x.289]*
   Return the number of times that this object is refined. Always 0.  
* [0.x.290]*
  
*  [2.x.298]   
* [0.x.291]*
  
*  [2.x.299]   
* [0.x.292]*
  
*  [2.x.300]   
* [0.x.293]*
   Always return no refinement.  
* [0.x.294]*
  
*  [2.x.301] 
* 
*  -   
* [0.x.295]*
  
*  [2.x.302] 
* 
*  -   
* [0.x.296]*
    [2.x.303]   
* [0.x.297]*
    [2.x.304]  Dealing with boundary indicators  
* [0.x.298]*
    [2.x.305]   
* [0.x.299]*
   Set the boundary indicator. The same applies as for the   <tt>boundary_id()</tt> function.      [2.x.306]  You should never set the boundary indicator of an interior face   (a face not at the boundary of the domain), or set the boundary   indicator of an exterior face to  [2.x.307]  (this   value is reserved for another purpose). Algorithms may not work or   produce very confusing results if boundary cells have a boundary   indicator of  [2.x.308]  or if interior cells have   boundary indicators other than  [2.x.309]    Unfortunately, the current object has no means of finding out whether it   really is at the boundary of the domain and so cannot determine whether   the value you are trying to set makes sense under the current   circumstances.    
*  [2.x.310]       [2.x.311]     [2.x.312]  "Glossary entry on boundary indicators"  
* [0.x.300]*
   Set the manifold indicator of this vertex. This does nothing so far since   manifolds are only used to refine and map objects, but vertices are not   refined and the mapping is trivial. This function is here only to allow   dimension independent programming.  
* [0.x.301]*
   Set the boundary indicator of this object and all of its lower-   dimensional sub-objects.  Since this object only represents a single   vertex, there are no lower-dimensional object and this function is   equivalent to calling set_boundary_id() with the same argument.    
*  [2.x.313]       [2.x.314]     [2.x.315]  "Glossary entry on boundary indicators"  
* [0.x.302]*
   Set the manifold indicator of this object and all of its lower-   dimensional sub-objects.  Since this object only represents a single   vertex, there are no lower-dimensional object and this function is   equivalent to calling set_manifold_id() with the same argument.    
*  [2.x.316]       [2.x.317]     [2.x.318]  "Glossary entry on manifold indicators"  
* [0.x.303]*
    [2.x.319]   
* [0.x.304]*
   Return whether the vertex pointed to here is used.  
* [0.x.305]*
   Reference cell type of the current object.  
* [0.x.306]*
   Number of vertices.  
* [0.x.307]*
   Number of lines.  
* [0.x.308]*
   Return an object that can be thought of as an array containing all indices   from zero to n_vertices().  
* [0.x.309]*
   Return an object that can be thought of as an array containing all indices   from zero to n_lines().  
* [0.x.310]*
   Pointer to the triangulation we operate on.  
* [0.x.311]*
   Whether this is a left end, right end, or interior vertex. This   information is provided by the cell at the time of creation.  
* [0.x.312]*
   The global vertex index of the vertex this object corresponds to.  
* [0.x.313]*
 This class allows access to a cell: a line in one dimension, a quad in two dimension, etc.
*  The following refers to any dimension:
*  This class allows access to a <tt>cell</tt>, which is a line in 1D and a quad in 2D. Cells have more functionality than lines or quads by themselves, for example they can be flagged for refinement, they have neighbors, they have the possibility to check whether they are at the boundary etc. This class offers access to all this data.
* 

* 
*  [2.x.320] 

* 
*  [2.x.321] 

* 
* [0.x.314]*
   Propagate the AccessorData type into the present class.  
* [0.x.315]*
   Define the type of the container this is part of.  
* [0.x.316]*
    [2.x.322]  Constructors  
* [0.x.317]*
    [2.x.323]   
* [0.x.318]*
   Constructor.  
* [0.x.319]*
   Copy constructor.  
* [0.x.320]*
   Conversion constructor. This constructor exists to make certain   constructs simpler to write in dimension independent code. For example,   it allows assigning a face iterator to a line iterator, an operation that   is useful in 2d but doesn't make any sense in 3d. The constructor here   exists for the purpose of making the code conform to C++ but it will   unconditionally abort; in other words, assigning a face iterator to a   line iterator is better put into an if-statement that checks that the   dimension is two, and assign to a quad iterator in 3d (an operator that,   without this constructor would be illegal if we happen to compile for   2d).  
* [0.x.321]*
   Another conversion operator between objects that don't make sense, just   like the previous one.  
* [0.x.322]*
   Copy constructor.  
* [0.x.323]*
   Move constructor.  
* [0.x.324]*
   Destructor.  
* [0.x.325]*
   Copy operator. These operators are usually used in a context like   <tt>iterator a,b;a=*b;</tt>. Presumably, the intent here is to copy the   object pointed to   by  [2.x.324]  to the object pointed to by  [2.x.325]  However, the result of   dereferencing an iterator is not an object but an accessor; consequently,   this operation is not useful for iterators on triangulations.   Consequently, this operator is declared as deleted and can not be used.  
* [0.x.326]*
   Move assignment operator.  
* [0.x.327]*
    [2.x.326]   
* [0.x.328]*
    [2.x.327]  Accessing sub-objects and neighbors  
* [0.x.329]*
    [2.x.328]   
* [0.x.330]*
   Return a pointer to the  [2.x.329]  child. Overloaded version which returns a   more reasonable iterator class.  
* [0.x.331]*
   Return an array of iterators to all children of this cell.  
* [0.x.332]*
   Return an iterator to the  [2.x.330]  face of this cell.  
* [0.x.333]*
   Return the face number of  [2.x.331]  on the current cell. This is the   inverse function of  [2.x.332]   
* [0.x.334]*
   Return an array of iterators to all faces of this cell.  
* [0.x.335]*
   Return the (global) index of the  [2.x.333]  face of this cell.    
*  [2.x.334]  Despite the name, the index returned here is only global in the   sense that it is specific to a particular Triangulation object or, in the   case the triangulation is actually of type    [2.x.335]  specific to that part of the   distributed triangulation stored on the current processor.  
* [0.x.336]*
   Return an iterator to that cell that neighbors the present cell on the   given face and subface number.     To succeed, the present cell must not be further refined, and the   neighbor on the given face must be further refined exactly once; the   returned cell is then a child of that neighbor.     The function may not be called in 1d, since there we have no subfaces.   The implementation of this function is rather straightforward in 2d, by   first determining which face of the neighbor cell the present cell is   bordering on (this is what the  [2.x.336]  function does),   and then asking  [2.x.337]  for the index of   the child.     However, the situation is more complicated in 3d, since there faces may   have more than one orientation, and we have to use  [2.x.338]     [2.x.339]  and  [2.x.340]  for both this and the neighbor cell to   figure out which cell we want to have.     This can lead to surprising results: if we are sitting on a cell and are   asking for a cell behind subface <tt>sf</tt>, then this means that we are   considering the subface for the face in the natural direction for the   present cell. However, if the face as seen from this cell has   <tt>face_orientation()==false</tt>, then the child of the face that   separates the present cell from the neighboring cell's child is not   necessarily the  [2.x.341]  child of the face of this cell. This is so   because the  [2.x.342]  on a cell corresponds to the subface with   respect to the intrinsic ordering of the present cell, whereas children   of face iterators are computed with respect to the intrinsic ordering of   faces; these two orderings are only identical if the face orientation is    [2.x.343]  and reversed otherwise.     Similarly, effects of <tt>face_flip()==true</tt> and   <tt>face_rotation()==true()</tt>, both of which indicate a non-standard   face have to be considered.     Fortunately, this is only very rarely of concern, since usually one   simply wishes to loop over all finer neighbors at a given face of an   active cell. Only in the process of refinement of a Triangulation we want   to set neighbor information for both our child cells and the neighbor's   children. Since we can respect orientation of faces from our current cell   in that case, we do NOT respect face_orientation, face_flip and   face_rotation of the present cell within this function, i.e. the returned   neighbor's child is behind subface  [2.x.344]  concerning the intrinsic   ordering of the given face.  
* [0.x.337]*
   Return an iterator to the neighboring cell on the other side of the face   with number  [2.x.345]  If the neighbor does not exist,   i.e., if the face with number  [2.x.346]  of the current object is at the boundary, then   an invalid iterator is returned.     Consequently, the index  [2.x.347]  must be less than n_faces().     The neighbor of a cell has at most the same level as this cell. For   example, consider the following situation:    [2.x.348]    Here, if you are on the top right cell and you ask for its left neighbor   (which is, according to the conventions spelled out in the GeometryInfo   class, its [1.x.3] neighbor), then you will get the mother cell of   the four small cells at the top left. In other words, the cell you get as   neighbor has the same refinement level as the one you're on right now   (the top right one) and it may have children.     On the other hand, if you were at the top right cell of the four small   cells at the top left, and you asked for the right neighbor (which is   associated with index  [2.x.349] ), then you would get the large   cell at the top right which in this case has a lower refinement level and   no children of its own.  
* [0.x.338]*
   Return the cell index of the neighboring cell on the other side of the face   with index  [2.x.350]  If the neighbor does not exist, this function returns
* 
*  - .     This function is equivalent to <tt>cell->neighbor(face_no)->index()</tt>.   See neighbor() for more details.  
* [0.x.339]*
   Return the level of the neighboring cell on the other side of the face with   number  [2.x.351]  If the neighbor does not exist, this function returns
* 
*  - .     This function is equivalent to `cell->neighbor(face_no)->level()`.   See neighbor() for more details.  
* [0.x.340]*
   Return the how-many'th neighbor this cell is of   <tt>cell->neighbor(face_no)</tt>, i.e. return  [2.x.352]  such that   <tt>cell->neighbor(face_no)->neighbor(other_face_no)==cell</tt>. This   function is the right one if you want to know how to get back from a   neighbor to the present cell.     Note that this operation is only useful if the neighbor is not coarser   than the present cell. If the neighbor is coarser this function throws an   exception. Use the  [2.x.353]  function in that case.  
* [0.x.341]*
   Return, whether the neighbor is coarser then the present cell. This is   important in case of anisotropic refinement where this information does   not depend on the levels of the cells.     Note, that in an anisotropic setting, a cell can only be coarser than   another one at a given face, not on a general basis. The face of the   finer cell is contained in the corresponding face of the coarser cell,   the finer face is either a child or a grandchild of the coarser face.  
* [0.x.342]*
   This function is a generalization of the  [2.x.354]  function   for the case of a coarser neighbor. It returns a pair of numbers, face_no   and subface_no, with the following property, if the neighbor is not   refined: <tt>cell->neighbor(neighbor)->neighbor_child_on_subface(face_no,   subface_no)==cell</tt>. In 3D, a coarser neighbor can still be refined.   In that case subface_no denotes the child index of the neighbors face   that relates to our face:   <tt>cell->neighbor(neighbor)->face(face_no)->child(subface_no)==cell->face(neighbor)</tt>.   This case in 3d and how it can happen is discussed in the introduction of   the  [2.x.355]  tutorial program.     This function is impossible for <tt>dim==1</tt>.  
* [0.x.343]*
   This function is a generalization of the  [2.x.356]  and the    [2.x.357]  functions. It checks whether the neighbor   is coarser or not and calls the respective function. In both cases, only   the face_no is returned.  
* [0.x.344]*
   Compatibility interface with DoFCellAccessor. Always returns  [2.x.358]   
* [0.x.345]*
    [2.x.359]   
* [0.x.346]*
    [2.x.360]  Dealing with periodic neighbors  
* [0.x.347]*
    [2.x.361]   
* [0.x.348]*
   If the cell has a periodic neighbor at its  [2.x.362]  ith face, this function   returns true, otherwise, the returned value is false.  
* [0.x.349]*
   For a cell with its  [2.x.363]  ith face at a periodic boundary,   see    [2.x.364]  "the entry for periodic boundaries",   this function returns an iterator to the cell on the other side   of the periodic boundary. If there is no periodic boundary at the  [2.x.365]  ith   face, an exception will be thrown.   In order to avoid running into an exception, check the result of   has_periodic_neighbor() for the  [2.x.366]  ith face prior to using this function.   The behavior of periodic_neighbor() is similar to neighbor(), in   the sense that the returned cell has at most the same level of refinement   as the current cell. On distributed meshes, by calling    [2.x.367]    we can make sure that the element on the other side of the periodic   boundary exists in this rank as a ghost cell or a locally owned cell.  
* [0.x.350]*
   For a cell whose  [2.x.368]  ith face is not at a boundary, this function returns   the same result as neighbor(). If the  [2.x.369]  ith face is at a periodic boundary   this function returns the same result as periodic_neighbor(). If neither of   the aforementioned conditions are met, i.e. the  [2.x.370]  ith face is on a   nonperiodic boundary, an exception will be thrown.  
* [0.x.351]*
   Return an iterator to the periodic neighbor of the cell at a given   face and subface number. The general guidelines for using this function   is similar to the function neighbor_child_on_subface(). The   implementation of this function is consistent with   periodic_neighbor_of_coarser_periodic_neighbor(). For instance,   assume that we are sitting on a cell named  [2.x.371]  cell1, whose neighbor behind   the  [2.x.372]  ith face is one level coarser. Let us name this coarser neighbor    [2.x.373]  cell2. Then, by calling   periodic_neighbor_of_coarser_periodic_neighbor(), from  [2.x.374]  cell1, we get   a  [2.x.375]  face_num and a  [2.x.376]  subface_num. Now, if we call   periodic_neighbor_child_on_subface() from cell2, with the above face_num   and subface_num, we get an iterator to  [2.x.377]  cell1.  
* [0.x.352]*
   This function is a generalization of   periodic_neighbor_of_periodic_neighbor()   for those cells which have a coarser periodic neighbor. The returned   pair of numbers can be used in periodic_neighbor_child_on_subface()   to get back to the current cell. In other words, the following   assertion should be true, for a cell with coarser periodic neighbor:   cell->periodic_neighbor(i)->periodic_neighbor_child_on_subface(face_no,   subface_no)==cell  
* [0.x.353]*
   This function returns the index of the periodic neighbor at the    [2.x.378]  ith face of the current cell. If there is no periodic neighbor   at the given face, the returned value is
* 
*  - .  
* [0.x.354]*
   This function returns the level of the periodic neighbor at the    [2.x.379]  ith face of the current cell. If there is no periodic neighbor   at the given face, the returned value is
* 
*  - .  
* [0.x.355]*
   For a cell with a periodic neighbor at its  [2.x.380]  ith face, this function   returns the face number of that periodic neighbor such that the   current cell is the periodic neighbor of that neighbor. In other words   the following assertion holds for those cells which have a periodic   neighbor with the same or a higher level of refinement as the current   cell:    [2.x.381]  {cell->periodic_neighbor(i)->       periodic_neighbor(cell->periodic_neighbor_of_periodic_neighbor(i))==cell}   For the cells with a coarser periodic neighbor, one should use   periodic_neighbor_of_coarser_periodic_neighbor() and   periodic_neighbor_child_on_subface()   to get back to the current cell.  
* [0.x.356]*
   If a cell has a periodic neighbor at its  [2.x.382]  ith face, this function   returns the face number of the periodic neighbor, which is connected   to the  [2.x.383]  ith face of this cell.  
* [0.x.357]*
   This function returns true if the element on the other side of the   periodic boundary is coarser and returns false otherwise. The   implementation allows this function to work in the case of   anisotropic refinement.  
* [0.x.358]*
    [2.x.384]   
* [0.x.359]*
    [2.x.385]  Dealing with boundary indicators  
* [0.x.360]*
    [2.x.386]   
* [0.x.361]*
   Return whether the  [2.x.387]  vertex or face (depending on the dimension) is   part of the boundary. This is true, if the  [2.x.388]  neighbor does not   exist.  
* [0.x.362]*
   Return whether the cell is at the boundary. Being at the boundary is   defined by one face being on the boundary. Note that this does not catch   cases where only one vertex of a quad or of a hex is at the boundary, or   where only one line of a hex is at the boundary while the interiors of   all faces are in the interior of the domain. For the latter case, the  [2.x.389]    has_boundary_lines function is the right one to ask.  
* [0.x.363]*
   This is a slight variation to the  [2.x.390]  function: for 1 and 2   dimensions, it is equivalent, for three dimensions it returns whether at   least one of the 12 lines of the hexahedron is at a boundary. This, of   course, includes the case where a whole face is at the boundary, but also   some other cases.  
* [0.x.364]*
    [2.x.391]   
* [0.x.365]*
    [2.x.392]  Dealing with refinement indicators  
* [0.x.366]*
    [2.x.393]   
* [0.x.367]*
   Return the  [2.x.394]  this cell was flagged to be refined   with.  The return value of this function can be compared to a bool to   check if this cell is flagged for any kind of refinement. For example, if   you have previously called cell->set_refine_flag() for a cell, then you   will enter the 'if' block in the following snippet:    
* [1.x.4]
*   
* [0.x.368]*
   Flag the cell pointed to for refinement. This function is only allowed   for active cells. Keeping the default value for  [2.x.395]  will mark   this cell for isotropic refinement.     If you choose anisotropic refinement, for example by passing as argument   one of the flags  [2.x.396]   [2.x.397]     [2.x.398]  or a combination of these, then keep in mind   that refining in x-, y-, or z-direction happens with regard to the    [2.x.399] local [2.x.400]  coordinate system of the cell. In other words, these   flags determine which edges and faces of the cell will be cut into new   edges and faces. On the other hand, this process is independent of   how the cell is oriented within the  [2.x.401] global [2.x.402]  coordinate system,   and you should not assume any particular orientation of the cell's   local coordinate system within the global coordinate system of the   space it lives in.  
* [0.x.369]*
   Clear the refinement flag.  
* [0.x.370]*
   Modify the refinement flag of the cell to ensure (at least) the given   refinement case  [2.x.403]  at face <tt>face_no</tt>, taking   into account orientation, flip and rotation of the face. Return, whether   the refinement flag had to be modified. This function is only allowed for   active cells.  
* [0.x.371]*
   Modify the refinement flag of the cell to ensure that line   <tt>face_no</tt> will be refined. Return, whether the refinement flag had   to be modified. This function is only allowed for active cells.  
* [0.x.372]*
   Return the SubfaceCase of face <tt>face_no</tt>. Note that this is not   identical to asking <tt>cell->face(face_no)->refinement_case()</tt> since   the latter returns a RefinementCase<dim-1> and thus only considers one   (anisotropic) refinement, whereas this function considers the complete   refinement situation including possible refinement of the face's   children. This function may only be called for active cells in 2d and 3d.  
* [0.x.373]*
   Return whether the coarsen flag is set or not.  
* [0.x.374]*
   Flag the cell pointed to for coarsening. This function is only allowed   for active cells.  
* [0.x.375]*
   Clear the coarsen flag.  
* [0.x.376]*
    [2.x.404]   
* [0.x.377]*
    [2.x.405]  Dealing with material indicators  
* [0.x.378]*
    [2.x.406]   
* [0.x.379]*
   Return the material id of this cell.     For a typical use of this function, see the    [2.x.407]  " [2.x.408] "   tutorial program.     See the    [2.x.409]  "glossary"   for more information.  
* [0.x.380]*
   Set the material id of this cell.     For a typical use of this function, see the    [2.x.410]  " [2.x.411] "   tutorial program.     See the    [2.x.412]  "glossary"   for more information.  
* [0.x.381]*
   Set the material id of this cell and all its children (and grand-   children, and so on) to the given value.     See the    [2.x.413]  "glossary"   for more information.  
* [0.x.382]*
    [2.x.414]   
* [0.x.383]*
    [2.x.415]  Dealing with subdomain indicators  
* [0.x.384]*
    [2.x.416]   
* [0.x.385]*
   Return the subdomain id of this cell.     See the    [2.x.417]  "glossary"   for more information.    
*  [2.x.418]  The subdomain of a cell is a property only defined for active   cells, i.e., cells that are not further refined. Consequently, you can   only call this function if the cell it refers to has no children. For   multigrid methods in parallel, it is also important to know which   processor owns non-active cells, and for this you can call   level_subdomain_id().  
* [0.x.386]*
   Set the subdomain id of this cell.     See the    [2.x.419]  "glossary"   for more information. This function should not be called if you use a    [2.x.420]  object.    
*  [2.x.421]  The subdomain of a cell is a property only defined for active   cells, i.e., cells that are not further refined. Consequently, you can   only call this function if the cell it refers to has no children. For   multigrid methods in parallel, it is also important to know which   processor owns non-active cells, and for this you can call   level_subdomain_id().  
* [0.x.387]*
   Get the level subdomain id of this cell. This is used for parallel   multigrid where not only the global mesh (consisting of the active cells)   is partitioned among processors, but also the individual levels of the   hierarchy of recursively refined cells that make up the mesh. In   other words, the level subdomain id is a property that is also defined   for non-active cells if a multigrid hierarchy is used.  
* [0.x.388]*
   Set the level subdomain id of this cell. This is used for parallel   multigrid.  
* [0.x.389]*
   Set the subdomain id of this cell (if it is active) or all its terminal   children (and grand-children, and so on, as long as they have no children   of their own) to the given value. Since the subdomain id is a concept   that is only defined for cells that are active (i.e., have no children of   their own), this function only sets the subdomain ids for all children   and grand children of this cell that are actually active, skipping   intermediate child cells.     See the    [2.x.422]  "glossary"   for more information. This function should not be called if you use a    [2.x.423]  object since there the subdomain id   is implicitly defined by which processor you're on.  
* [0.x.390]*
    [2.x.424]   
* [0.x.391]*
   Return a globally unique cell index for the current cell,   assuming it is not artificial. The value is identical to   active_cell_index() if the cell is part of a serial   triangulation.     In the context of parallel triangulations, locally-owned cells   are enumerated contiguously within each subdomain of the   mesh. This ensures that the index returned by this function can   be used as the index into vectors with a total of    [2.x.425]  entries, and for which   every process stores a contiguous part.  If such a cell-data   vector has been set up with    [2.x.426]    the index returned by this function can then be used to access   the correct vector entry.  
* [0.x.392]*
   Return a globally unique index for a non-artificial level cell.    
*  [2.x.427]  Similar to global_active_cell_index().  
* [0.x.393]*
    [2.x.428]  Dealing with codim 1 cell orientation  
* [0.x.394]*
    [2.x.429]   
* [0.x.395]*
   Return the orientation of this cell.     For the meaning of this flag, see    [2.x.430] .  
* [0.x.396]*
   Return the how many-th active cell the current cell is (assuming the   current cell is indeed active). This is useful, for example, if you are   accessing the elements of a vector with as many entries as there are   active cells. Such vectors are used for estimating the error on each cell   of a triangulation, for specifying refinement criteria passed to the   functions in GridRefinement, and for generating cell-wise output.     The function throws an exception if the current cell is not active.    
*  [2.x.431]  If the triangulation this function is called on is of type    [2.x.432]  then active cells may be locally   owned, ghost cells, or artificial (see    [2.x.433] ,    [2.x.434] ,   and    [2.x.435] ).   This function counts over all of them, including ghost and artificial   active cells. This implies that the index returned by this function   uniquely identifies a cell within the triangulation on a single   processor, but does not uniquely identify the cell among the (parts of   the) triangulation that is shared among processors. If you would like to   identify active cells across processors, you need to consider the CellId   of a cell returned by  [2.x.436]   
* [0.x.397]*
   Return the index of the parent of this cell within the level of the   triangulation to which the parent cell belongs. The level of the parent   is of course one lower than that of the present cell. If the parent does   not exist (i.e., if the object is at the coarsest level of the mesh   hierarchy), an exception is generated.  
* [0.x.398]*
   Return an iterator to the parent. If the parent does not exist (i.e., if   the object is at the coarsest level of the mesh hierarchy), an exception   is generated.  
* [0.x.399]*
    [2.x.437]   
* [0.x.400]*
    [2.x.438]  Other functions  
* [0.x.401]*
    [2.x.439]   
* [0.x.402]*
   Test that the cell has no children (this is the criterion for whether a   cell is called "active").     See the    [2.x.440]  "glossary"   for more information.  
* [0.x.403]*
   Return whether this cell is owned by the current processor or is owned by   another processor. The function always returns true if applied to an   object of type  [2.x.441]  but may yield false if the   triangulation is of type  [2.x.442]      See the    [2.x.443]  "glossary"   and the    [2.x.444]    module for more information.      [2.x.445]  The returned value is equal to <code>!is_ghost() &&   !is_artificial()</code>.    
*  [2.x.446]  Whether a cell is a ghost cell, artificial, or is locally owned or   is a property that only pertains to cells that are active. Consequently,   you can only call this function if the cell it refers to has no children.  
* [0.x.404]*
   Return true if either the Triangulation is not distributed or if   level_subdomain_id() is equal to the id of the current processor.  
* [0.x.405]*
   Return whether this cell exists in the global mesh but (i) is owned by   another processor, i.e. has a subdomain_id different from the one the   current processor owns and (ii) is adjacent to a cell owned by the   current processor.     This function only makes sense if the triangulation used is of kind    [2.x.447]  In all other cases, the returned   value is always false.     See the    [2.x.448]  "glossary"   and the    [2.x.449]    module for more information.      [2.x.450]  The returned value is equal to <code>!is_locally_owned() &&   !is_artificial()</code>.    
*  [2.x.451]  Whether a cell is a ghost cell, artificial, or is locally owned or   is a property that only pertains to cells that are active. Consequently,   you can only call this function if the cell it refers to has no children.  
* [0.x.406]*
   Return whether this cell is artificial, i.e. it isn't one of the cells   owned by the current processor, and it also doesn't border on one. As a   consequence, it exists in the mesh to ensure that each processor has all   coarse mesh cells and that the 2:1 ratio of neighboring cells is   maintained, but it is not one of the cells we should work on on the   current processor. In particular, there is no guarantee that this cell   isn't, in fact, further refined on one of the other processors.     This function only makes sense if the triangulation used is of kind    [2.x.452]  In all other cases, the returned   value is always false.     See the    [2.x.453]  "glossary"   and the    [2.x.454]    module for more information.      [2.x.455]  The returned value is equal to <code>!is_ghost() &&   !is_locally_owned()</code>.    
*  [2.x.456]  Whether a cell is a ghost cell, artificial, or is locally owned is   a property that only pertains to cells that are active. Consequently, you   can only call this function if the cell it refers to has no children.  
* [0.x.407]*
   Test whether the point  [2.x.457]  is inside this cell. Points on the boundary   are counted as being inside the cell.     Note that this function assumes that the mapping between unit cell and   real cell is (bi-, tri-)linear, i.e. that faces in 2d and edges in 3d are   straight lines. If you have higher order transformations, results may be   different as to whether a point is in- or outside the cell in real space.     In case of codim>0, the point is first projected to the manifold where   the cell is embedded and then check if this projection is inside the   cell.  
* [0.x.408]*
   Set the neighbor  [2.x.458]  of this cell to the cell pointed to by  [2.x.459]      This function shouldn't really be public (but needs to for various   reasons in order not to make a long list of functions friends): it   modifies internal data structures and may leave things. Do not use it   from application codes.  
* [0.x.409]*
   Return a unique ID for the current cell. This ID is constructed from the   path in the hierarchy from the coarse father cell and works correctly in   parallel computations using objects of type    [2.x.460]  This function is therefore useful   in providing a unique identifier for cells (active or not) that also   works for parallel triangulations. See the documentation of the CellId   class for more information.    
*  [2.x.461]  This operation takes O(level) time to compute. In most practical   cases, the number of levels of a triangulation will depend   logarithmically on the number of cells in the triangulation.  
* [0.x.410]*
   The same as  [2.x.462]  but also taking a Mapping class.  
* [0.x.411]*
    [2.x.463]   
* [0.x.412]*
  
*  [2.x.464]   
* [0.x.413]*
  
*  [2.x.465]   
* [0.x.414]*
  
*  [2.x.466]   
* [0.x.415]*
   This function assumes that the neighbor is not coarser than the current   cell. In this case it returns the neighbor_of_neighbor() value. If,   however, the neighbor is coarser this function returns an    [2.x.467] .     This function is not for public use. Use the function   neighbor_of_neighbor() instead which throws an exception if called for a   coarser neighbor. If neighbor is indeed coarser (you get to know this by   e.g. the neighbor_is_coarser() function) then the   neighbor_of_coarser_neighbor() function should be call. If you'd like to   know only the  [2.x.468]  which is required to get back from the   neighbor to the present cell then simply use the neighbor_face_no()   function which can be used for coarser as well as non-coarser neighbors.  
* [0.x.416]*
   As for any codim>0 we can use a similar code and c++ does not allow   partial templates. we use this auxiliary function that is then called   from point_inside.  
* [0.x.417]*
   Set the active cell index of a cell. This is done at the end of   refinement.  
* [0.x.418]*
   Set global active cell index for a cell.  
* [0.x.419]*
   Set global level cell index for a level cell.  
* [0.x.420]*
   Set the parent of a cell.  
* [0.x.421]*
   Set the orientation of this cell.     For the meaning of this flag, see    [2.x.469] .  
* [0.x.422]