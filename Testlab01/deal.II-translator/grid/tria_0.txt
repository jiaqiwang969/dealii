[0.x.0]*
     Forward declaration of a class into which we put much of the     implementation of the Triangulation class. See the .cc file for more     information.    
* [0.x.1]*
   A namespace for classes internal to the triangulation classes and   helpers.  
* [0.x.2]*
     Cache class used to store the number of used and active elements (lines     or quads etc) within the levels of a triangulation. This is only the     declaration of the template, concrete instantiations are below.         In the old days, whenever one wanted to access one of these numbers,     one had to perform a loop over all lines, e.g., and count the elements     until we hit the end iterator. This is time consuming and since access     to the number of lines etc is a rather frequent operation, this was not     an optimal solution.    
* [0.x.3]*
     Cache class used to store the number of used and active elements (lines     or quads etc) within the levels of a triangulation. This specialization     stores the numbers of lines.         In the old days, whenever one wanted to access one of these numbers,     one had to perform a loop over all lines, e.g., and count the elements     until we hit the end iterator. This is time consuming and since access     to the number of lines etc is a rather frequent operation, this was not     an optimal solution.    
* [0.x.4]*
       The number of levels on which we have used objects.      
* [0.x.5]*
       Number of used lines in the whole triangulation.      
* [0.x.6]*
       Array holding the number of used lines on each level.      
* [0.x.7]*
       Number of active lines in the whole triangulation.      
* [0.x.8]*
       Array holding the number of active lines on each level.      
* [0.x.9]*
       Constructor. Set values to zero by default.      
* [0.x.10]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.11]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.12]*
     Cache class used to store the number of used and active elements (lines     or quads etc) within the levels of a triangulation. This specialization     stores the numbers of quads. Due to the inheritance from the base class     NumberCache<1>, the numbers of lines are also within this class.         In the old days, whenever one wanted to access one of these numbers,     one had to perform a loop over all lines, e.g., and count the elements     until we hit the end iterator. This is time consuming and since access     to the number of lines etc is a rather frequent operation, this was not     an optimal solution.    
* [0.x.13]*
       Number of used quads in the whole triangulation.      
* [0.x.14]*
       Array holding the number of used quads on each level.      
* [0.x.15]*
       Number of active quads in the whole triangulation.      
* [0.x.16]*
       Array holding the number of active quads on each level.      
* [0.x.17]*
       Constructor. Set values to zero by default.      
* [0.x.18]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.19]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.20]*
     Cache class used to store the number of used and active elements (lines     or quads etc) within the levels of a triangulation. This specialization     stores the numbers of hexes. Due to the inheritance from the base class     NumberCache<2>, the numbers of lines and quads are also within this     class.         In the old days, whenever one wanted to access one of these numbers,     one had to perform a loop over all lines, e.g., and count the elements     until we hit the end . This is time consuming and since access to the     number of lines etc is a rather frequent operation, this was not an     optimal solution.    
* [0.x.21]*
       Number of used hexes in the whole triangulation.      
* [0.x.22]*
       Array holding the number of used hexes on each level.      
* [0.x.23]*
       Number of active hexes in the whole triangulation.      
* [0.x.24]*
       Array holding the number of active hexes on each level.      
* [0.x.25]*
       Constructor. Set values to zero by default.      
* [0.x.26]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.27]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.28]*
 A triangulation is a collection of cells that, jointly, cover the domain on which one typically wants to solve a partial differential equation. This domain, and the mesh that covers it, represents a  [2.x.0] 
* 
*  - imensional manifold and lives in  [2.x.1]  spatial dimensions, where  [2.x.2]  and  [2.x.3]  are the template arguments of this class. (If  [2.x.4]  is not specified, it takes the default value `spacedim=dim`.)
*  Thus, for example, an object of type  [2.x.5]  (or simply  [2.x.6]  Triangulation<1> since  [2.x.7]  by default) is used to represent and handle the usual one-dimensional triangulation used in the finite element method (so, segments on a straight line). On the other hand, objects such as  [2.x.8]  or  [2.x.9]  (that are associated with curves in 2D or surfaces in 3D) are the ones one wants to use in the boundary element method.
*  The name of the class is mostly hierarchical and is not meant to imply that a Triangulation can only consist of triangles. Instead, triangulations consist of line segments in 1d (i.e., if `dim==1`), and of three-dimensional cells (if `dim==3`). Moreover, historically, deal.II only supported quadrilaterals (cells with four vertices: deformed rectangles) in 2d and hexahedra (cells with six sides and eight vertices that are deformed boxes), neither of which are triangles. In other words, the term "triangulation" in the deal.II language is synonymous with "mesh" and is to be understood separate from its linguistic origin.
*  This class is written to be as independent of the dimension as possible (thus the complex construction of the  [2.x.10]  classes) to allow code-sharing, to allow reducing the need to mirror changes in the code for one dimension to the code for other dimensions. Nonetheless, some of the functions are dependent of the dimension and there only exist specialized versions for distinct dimensions.
*  This class satisfies the  [2.x.11]  "MeshType concept" requirements.
*  [1.x.0]
*  The actual data structure of a Triangulation object is rather complex and quite inconvenient if one attempted to operate on it directly, since data is spread over quite a lot of arrays and other places. However, there are ways powerful enough to work on these data structures without knowing their exact relations. deal.II uses class local alias (see below) to make things as easy and dimension independent as possible.
*  The Triangulation class provides iterators which enable looping over all cells without knowing the exact representation used to describe them. For more information see the documentation of <tt>TriaIterator</tt>. Their names are alias imported from the Iterators class (thus making them local types to this class) and are as follows:
*   [2.x.12]   [2.x.13]  <tt>cell_iterator</tt>: loop over all cells used in the Triangulation  [2.x.14]  <tt>active_cell_iterator</tt>: loop over all active cells  [2.x.15] 
*  For <tt>dim==1</tt>, these iterators are mapped as follows: 
* [1.x.1]
*  while for  [2.x.16]  we have the additional face iterator: 
* [1.x.2]
* 
*  By using the cell iterators, you can write code independent of the spatial dimension. The same applies for substructure iterators, where a substructure is defined as a face of a cell. The face of a cell is a vertex in 1D and a line in 2D; however, vertices are handled in a different way and therefore lines have no faces.
*  The Triangulation class offers functions like begin_active() which gives you an iterator to the first active cell. There are quite a lot of functions returning iterators. Take a look at the class doc to get an overview.
*  Usage of these iterators is similar to usage of standard container iterators. Some examples taken from the Triangulation source code follow (notice that in the last two examples the template parameter  [2.x.17]  has been omitted, so it takes the default value  [2.x.18] ).
*   [2.x.19]   [2.x.20]   [2.x.21] Counting the number of cells on a specific level [2.x.22]    
* [1.x.3]
*  Another way, which uses  [2.x.23]  would be to write   
* [1.x.4]
* 
*   [2.x.24]   [2.x.25] Refining all cells of a triangulation [2.x.26]    
* [1.x.5]
*   [2.x.27] 
* 

*  [1.x.6]
*  Usage of a Triangulation is mainly done through the use of iterators. An example probably shows best how to use it:

* 
* [1.x.7]
* 
* 

*  [1.x.8]
*  There are several possibilities to create a triangulation:  [2.x.28]   [2.x.29]  The most common domains, such as hypercubes (i.e. lines, squares, cubes, etc), hyper-balls (circles, balls, ...) and some other, more weird domains such as the L-shape region and higher dimensional generalizations and others, are provided by the GridGenerator class which takes a triangulation and fills it by a division of the required domain.
*   [2.x.30]  Reading in a triangulation: By using an object of the GridIn class, you can read in fairly general triangulations. See there for more information. The mentioned class uses the interface described directly below to transfer the data into the triangulation.
*   [2.x.31]  Explicitly creating a triangulation: you can create a triangulation by providing a list of vertices and a list of cells. Each such cell consists of a vector storing the indices of the vertices of this cell in the vertex list. To see how this works, you can take a look at the  [2.x.32]  functions. The appropriate function to be called is create_triangulation().
*  Creating the hierarchical information needed for this library from cells storing only vertex information can be quite a complex task.  For example in 2D, we have to create lines between vertices (but only once, though there are two cells which link these two vertices) and we have to create neighborhood information. Grids being read in should therefore not be too large, reading refined grids would be inefficient (although there is technically no problem in reading grids with several 10.000 or 100.000 cells; the library can handle this without much problems). Apart from the performance aspect, refined grids do not lend too well to multigrid algorithms, since solving on the coarsest level is expensive. It is wiser in any case to read in a grid as coarse as possible and then do the needed refinement steps.
*  It is your duty to guarantee that cells have the correct orientation. To guarantee this, in the input vector keeping the cell list, the vertex indices for each cell have to be in a defined order, see the documentation of GeometryInfo<dim>. In one dimension, the first vertex index must refer to that vertex with the lower coordinate value. In 2D and 3D, the corresponding conditions are not easy to verify and no full attempt to do so is made. If you violate this condition, you may end up with matrix entries having the wrong sign (clockwise vertex numbering, which results in a negative area element) of with wrong matrix elements (twisted quadrilaterals, i.e. two vertices interchanged; this results in a wrong area element).
*  There are more subtle conditions which must be imposed upon the vertex numbering within cells. They do not only hold for the data read from an UCD or any other input file, but also for the data passed to create_triangulation(). See the documentation for the GridIn class for more details on this, and above all to the GridReordering class that explains many of the problems and an algorithm to reorder cells such that they satisfy the conditions outlined above.
*   [2.x.33]  Copying a triangulation: when computing on time dependent meshes or when using adaptive refinement, you will often want to create a new triangulation to be the same as another one. This is facilitated by the  [2.x.34]  copy_triangulation function.
*  It is guaranteed that vertex, line or cell numbers in the two triangulations are the same and that two iterators walking on the two triangulations visit matching cells if they are incremented in parallel. It may be conceivable to implement a clean-up in the copy operation, which eliminates holes of unused memory, re-joins scattered data and so on. In principle this would be a useful operation but guaranteeing some parallelism in the two triangulations seems more important since usually data will have to be transferred between the grids.  [2.x.35] 
*  Finally, there is a special function for folks who like bad grids: distort_random(). It moves all the vertices in the grid a bit around by a random value, leaving behind a distorted mesh. Note that you should apply this function to the final mesh, since refinement smoothes the mesh a bit.
*  The function will make sure that vertices on restricted faces (hanging nodes) will end up in the correct place, i.e. in the middle of the two other vertices of the mother line, and the analogue in higher space dimensions (vertices on the boundary are not corrected, so don't distort boundary vertices in more than two space dimension, i.e. in dimensions where boundary vertices can be hanging nodes). Applying the algorithm has another drawback related to the placement of cells, however: the children of a cell will not occupy the same region of the domain as the mother cell does. While this is the usual behavior with cells at the boundary, here you may get into trouble when using multigrid algorithms or when transferring solutions from coarse to fine grids and back. In general, the use of this function is only safe if you only use the most refined level of the triangulation for computations.
* 

* 
*  [1.x.9]
*  Refinement of a triangulation may be done through several ways. The most low-level way is directly through iterators: let  [2.x.36]  be an iterator to an active cell (i.e. the cell pointed to has no children), then the function call <tt>i->set_refine_flag()</tt> marks the respective cell for refinement. Marking non-active cells results in an error.
*  After all the cells you wanted to mark for refinement, call execute_coarsening_and_refinement() to actually perform the refinement. This function itself first calls the  [2.x.37]  function to regularize the resulting triangulation: since a face between two adjacent cells may only be subdivided once (i.e. the levels of two adjacent cells may differ by one at most; it is not possible to have a cell refined twice while the neighboring one is not refined), some additional cells are flagged for refinement to smooth the grid. This enlarges the number of resulting cells but makes the grid more regular, thus leading to better approximation properties and, above all, making the handling of data structures and algorithms much easier. To be honest, this is mostly an algorithmic step than one needed by the finite element method.
*  To coarsen a grid, the same way as above is possible by using <tt>i->set_coarsen_flag</tt> and calling execute_coarsening_and_refinement().
*  The reason for first coarsening, then refining is that the refinement usually adds some additional cells to keep the triangulation regular and thus satisfies all refinement requests, while the coarsening does not delete cells not requested for; therefore the refinement will often revert some effects of coarsening while the opposite is not true. The stated order of coarsening before refinement will thus normally lead to a result closer to the intended one.
*  Marking cells for refinement 'by hand' through iterators is one way to produce a new grid, especially if you know what kind of grid you are looking for, e.g. if you want to have a grid successively refined towards the boundary or always at the center (see the example programs, they do exactly these things). There are more advanced functions, however, which are more suitable for automatic generation of hierarchical grids in the context of a posteriori error estimation and adaptive finite elements. These functions can be found in the GridRefinement class.
* 

*  [1.x.10]
*  Some degradation of approximation properties has been observed for grids which are too unstructured. Therefore, prepare_coarsening_and_refinement() which is automatically called by execute_coarsening_and_refinement() can do some smoothing of the triangulation. Note that mesh smoothing is only done for two or more space dimensions, no smoothing is available at present for one spatial dimension. In the following, let <tt>execute_*</tt> stand for execute_coarsening_and_refinement().
*  For the purpose of smoothing, the Triangulation constructor takes an argument specifying whether a smoothing step shall be performed on the grid each time <tt>execute_*</tt> is called. The default is that such a step not be done, since this results in additional cells being produced, which may not be necessary in all cases. If switched on, calling <tt>execute_*</tt> results in flagging additional cells for refinement to avoid vertices as the ones mentioned. The algorithms for both regularization and smoothing of triangulations are described below in the section on technical issues. The reason why this parameter must be given to the constructor rather than to <tt>execute_*</tt> is that it would result in algorithmic problems if you called <tt>execute_*</tt> once without and once with smoothing, since then in some refinement steps would need to be refined twice.
*  The parameter taken by the constructor is an integer which may be composed bitwise by the constants defined in the enum #MeshSmoothing (see there for the possibilities).
* 

* 
*  [2.x.38]  While it is possible to pass all of the flags in #MeshSmoothing to objects of type  [2.x.39]  it is not always possible to honor all of these smoothing options if they would require knowledge of refinement/coarsening flags on cells not locally owned by this processor. As a consequence, for some of these flags, the ultimate number of cells of the parallel triangulation may depend on the number of processors into which it is partitioned.
* 

*  [1.x.11]
*  Each cell, face or edge stores information denoting the material or the part of the boundary that an object belongs to. The material id of a cell is typically used to identify which cells belong to a particular part of the domain, e.g., when you have different materials (steel, concrete, wood) that are all part of the same domain. One would then usually query the material id associated with a cell during assembly of the bilinear form, and use it to determine (e.g., by table lookup, or a sequence of if-else statements) what the correct material coefficients would be for that cell. See also  [2.x.40]  "this glossary entry".
*  This material_id may be set upon construction of a triangulation (through the CellData data structure), or later through use of cell iterators. For a typical use of this functionality, see the  [2.x.41]  tutorial program. The functions of the GridGenerator namespace typically set the material ID of all cells to zero. When reading a triangulation through the GridIn class, different input file formats have different conventions, but typically either explicitly specify the material id, or if they don't, then GridIn simply sets them to zero. Because the material of a cell is intended to pertain to a particular region of the domain, material ids are inherited by child cells from their parent upon mesh refinement.
*  Boundary indicators on lower dimensional objects (these have no material id) indicate the number of a boundary component. The weak formulation of the partial differential equation may have different boundary conditions on different parts of the boundary. The boundary indicator can be used in creating the matrix or the right hand side vector to indicate these different parts of the model (this use is like the material id of cells). Boundary indicators may be in the range from zero to  [2.x.42]  The value  [2.x.43]  is reserved to denote interior lines (in 2D) and interior lines and quads (in 3D), which do not have a boundary indicator. This way, a program can easily determine, whether such an object is at the boundary or not. Material indicators may be in the range from zero to  [2.x.44] 
*  Lines in two dimensions and quads in three dimensions inherit their boundary indicator to their children upon refinement. You should therefore make sure that if you have different boundary parts, the different parts are separated by a vertex (in 2D) or a line (in 3D) such that each boundary line or quad has a unique boundary indicator.
*  By default (unless otherwise specified during creation of a triangulation), all parts of the boundary have boundary indicator zero. As a historical wart, this isn't true for 1d meshes, however: For these, leftmost vertices have boundary indicator zero while rightmost vertices have boundary indicator one. In either case, the boundary indicator of a face can be changed using a call of the kind  [2.x.45] .
*   [2.x.46]   [2.x.47]  "Glossary entry on boundary indicators"
* 

*  [1.x.12]
*  It is possible to reconstruct a grid from its refinement history, which can be stored and loaded through the  [2.x.48]  and  [2.x.49]  load_refine_flags functions. Normally, the code will look like this:  
* [1.x.13]
* 
*  If you want to re-create the grid from the stored information, you write:  
* [1.x.14]
* 
*  The same scheme is employed for coarsening and the coarsening flags.
*  You may write other information to the output file between different sets of refinement information, as long as you read it upon re-creation of the grid. You should make sure that the other information in the new triangulation which is to be created from the saved flags, matches that of the old triangulation, for example the smoothing level; if not, the cells actually created from the flags may be other ones, since smoothing adds additional cells, but their number may be depending on the smoothing level.
*  There actually are two sets of <tt>save_*_flags</tt> and <tt>load_*_flags</tt> functions. One takes a stream as argument and reads/writes the information from/to the stream, thus enabling storing flags to files. The other set takes an argument of type <tt>vector<bool></tt>. This enables the user to temporarily store some flags, e.g. if another function needs them, and restore them afterwards.
* 

*  [1.x.15]
*  A triangulation offers one bit per line, quad, etc for user flags. This field can be accessed as all other data using iterators. Normally, this user flag is used if an algorithm walks over all cells and needs information whether another cell, e.g. a neighbor, has already been processed. See  [2.x.50]  "the glossary for more information".
*  There is another set of user data, which can be either an <tt>unsigned int</tt> or a <tt>void</tt>, for each line, quad, etc. You can access these through the functions listed under <tt>User data</tt> in the accessor classes. Again, see  [2.x.51]  "the glossary for more information".
*  The value of these user indices or pointers is  [2.x.52]  by default. Note that the pointers are not inherited to children upon refinement. Still, after a remeshing they are available on all cells, where they were set on the previous mesh.
*  The usual warning about the missing type safety of  [2.x.53]  pointers are obviously in place here; responsibility for correctness of types etc lies entirely with the user of the pointer.
* 

* 
*  [2.x.54]  User pointers and user indices are stored in the same place. In order to avoid unwanted conversions, Triangulation checks which one of them is in use and does not allow access to the other one, until clear_user_data() has been called.
* 

*  [1.x.16]
*  deal.II implements all geometries (curved and otherwise) with classes inheriting from Manifold; see the documentation of Manifold,  [2.x.55] , or the  [2.x.56]  module for examples and a complete description of the algorithms. By default, all cells in a Triangulation have a flat geometry, meaning that all lines in the Triangulation are assumed to be straight. If a cell has a manifold_id that is not equal to  [2.x.57]  then the Triangulation uses the associated Manifold object for computations on that cell (e.g., cell refinement). Here is a quick example, taken from the implementation of  [2.x.58]  that sets up a polar grid:
* 

* 
* [1.x.17]
* 
*  This will set up a grid where the boundary lines will be refined by performing calculations in polar coordinates. When the mesh is refined the cells adjacent to the boundary will use this new line midpoint (as well as the other three midpoints and original cell vertices) to calculate the cell midpoint with a transfinite interpolation: this propagates the curved boundary into the interior in a smooth way. It is possible to generate a better grid (which interpolates across all cells between two different Manifold descriptions, instead of just going one cell at a time) by using TransfiniteInterpolationManifold; see the documentation of that class for more information.
*  You should take note of one caveat: if you have concave boundaries, you must make sure that a new boundary vertex does not lie too much inside the cell which is to be refined. The reason is that the center vertex is placed at the point which is a weighted average of the vertices of the original cell, new face midpoints, and (in 3D) new line midpoints. Therefore if your new boundary vertex is too near the center of the old quadrilateral or hexahedron, the distance to the midpoint vertex will become too small, thus generating distorted cells. This issue is discussed extensively in  [2.x.59]  "distorted cells".
*  [1.x.18]
*  There are cases where one object would like to know whenever a triangulation is being refined, copied, or modified in a number of other ways. This could of course be achieved if, in your user code, you tell every such object whenever you are about to refine the triangulation, but this will get tedious and is error prone. The Triangulation class implements a more elegant way to achieve this: signals.
*  In essence, a signal is an object (a member of the Triangulation class) that another object can connect to. A connection is in essence that the connecting object passes a function object taking a certain number and kind of arguments. Whenever the owner of the signal wants to indicate a certain kind of event, it 'triggers' the signal, which in turn means that all connections of the signal are triggered: in other word, the function objects are executed and can take the action that is necessary.
*  As a simple example, the following code will print something to the output every time the triangulation has just been refined:  
* [1.x.19]
*  This code will produce output twice, once for each refinement cycle.
*  A more interesting application would be the following, akin to what the FEValues class does. This class stores a pointer to a triangulation and also an iterator to the cell last handled (so that it can compare the current cell with the previous one and, for example, decide that there is no need to re-compute the Jacobian matrix if the new cell is a simple translation of the previous one). However, whenever the triangulation is modified, the iterator to the previously handled cell needs to be invalidated since it now no longer points to any useful cell (or, at the very least, points to something that may not necessarily resemble the cells previously handled). The code would look something like this (the real code has some more error checking and has to handle the case that subsequent cells might actually belong to different triangulation, but that is of no concern to us here):

* 
* [1.x.20]
*  Here, whenever the triangulation is refined, it triggers the post- refinement signal which calls the function object attached to it. This function object is the member function  [2.x.60]  where we have bound the single argument (the  [2.x.61]  pointer of a member function that otherwise takes no arguments) to the  [2.x.62]  pointer of the FEValues object. Note how here there is no need for the code that owns the triangulation and the FEValues object to inform the latter if the former is refined. (In practice, the function would want to connect to some of the other signals that the triangulation offers as well, in particular to creation and deletion signals.)
*  The Triangulation class has a variety of signals that indicate different actions by which the triangulation can modify itself and potentially require follow-up action elsewhere. Please refer to  [2.x.63]  for details.
*  [1.x.21]
*  Like many other classes in deal.II, the Triangulation class can stream its contents to an archive using BOOST's serialization facilities. The data so stored can later be retrieved again from the archive to restore the contents of this object. This facility is frequently used to save the state of a program to disk for possible later resurrection, often in the context of checkpoint/restart strategies for long running computations or on computers that aren't very reliable (e.g. on very large clusters where individual nodes occasionally fail and then bring down an entire MPI job).
*  For technical reasons, writing and restoring a Triangulation object is not trivial. The primary reason is that unlike many other objects, triangulations rely on many other objects to which they store pointers or with which they interface; for example, triangulations store pointers to objects describing boundaries and manifolds, and they have signals that store pointers to other objects so they can be notified of changes in the triangulation (see the section on signals in this introduction). Since these objects are owned by the user space (for example the user can create a custom manifold object), they may not be serializable. So in cases like this,  [2.x.64]  can store a reference to an object instead of the pointer, but the reference will never be satisfied at write time because the object pointed to is not serialized. Clearly, at load time,  [2.x.65]  will not know where to let the pointer point to because it never gets to re-create the object originally pointed to.
*  For these reasons, saving a triangulation to an archive does not store all information, but only certain parts. More specifically, the information that is stored is everything that defines the mesh such as vertex locations, vertex indices, how vertices are connected to cells, boundary indicators, subdomain ids, material ids, etc. On the other hand, the following information is not stored:
* 

* 
* 

* 
* 

* 
* 
*  - signals
* 

* 
* 

* 
* 

* 
* 
*  - pointers to Manifold objects previously set using      [2.x.66] 
*  On the other hand, since these are objects that are usually set in user code, they can typically easily be set again in that part of your code in which you re-load triangulations.
*  In a sense, this approach to serialization means that re-loading a triangulation is more akin to calling the  [2.x.67]  function and filling it with some additional content, as that function also does not touch the signals and Manifold objects that belong to this triangulation. In keeping with this analogy, the  [2.x.68]  function also triggers the same kinds of signal as  [2.x.69] 
* 

*  [1.x.22]
*  [1.x.23]
*  We chose an inductive point of view: since upon creation of the triangulation all cells are on the same level, all regularity assumptions regarding the maximum difference in level of cells sharing a common face, edge or vertex hold. Since we use the regularization and smoothing in each step of the mesh history, when coming to the point of refining it further the assumptions also hold.
*  The regularization and smoothing is done in the  [2.x.70]  prepare_coarsening_and_refinement function, which is called by  [2.x.71]  execute_coarsening_and_refinement at the very beginning.  It decides which additional cells to flag for refinement by looking at the old grid and the refinement flags for each cell.
*   [2.x.72]   [2.x.73]   [2.x.74] Regularization: [2.x.75]  The algorithm walks over all cells checking whether the present cell is flagged for refinement and a neighbor of the present cell is refined once less than the present one. If so, flag the neighbor for refinement. Because of the induction above, there may be no neighbor with level two less than the present one.
*  The neighbor thus flagged for refinement may induce more cells which need to be refined. However, such cells which need additional refinement always are on one level lower than the present one, so we can get away with only one sweep over all cells if we do the loop in the reverse way, starting with those on the highest level. This way, we may flag additional cells on lower levels, but if these induce more refinement needed, this is performed later on when we visit them in out backward running loop.
*   [2.x.76]   [2.x.77] Smoothing: [2.x.78]   [2.x.79]   [2.x.80]   [2.x.81]  First a list is set up which stores for each vertex the highest level one of the adjacent cells belongs to. Now, since we did smoothing in the previous refinement steps also, each cell may only have vertices with levels at most one greater than the level of the present cell.
*  However, if we store the level plus one for cells marked for refinement, we may end up with cells which have vertices of level two greater than the cells level. We need to refine this cell also, and need thus also update the levels of its vertices. This itself may lead to cells needing refinement, but these are on lower levels, as above, which is why we may do all kinds of additional flagging in one loop only.
*   [2.x.82]   [2.x.83]  For each cell we count the number of neighbors which are refined or flagged for refinement. If this exceeds the number of neighbors which are not refined and not flagged for refinement, then the current cell is flagged for refinement. Since this may lead to cells on the same level which also will need refinement, we will need additional loops of regularization and smoothing over all cells until nothing changes any more.
*   [2.x.84]  <tt>eliminate_refined_*_islands</tt>: This one does much the same as the above one, but for coarsening. If a cell is flagged for refinement or if all of its children are active and if the number of neighbors which are either active and not flagged for refinement, or not active but all children flagged for coarsening equals the total number of neighbors, then this cell's children are flagged for coarsening or (if this cell was flagged for refinement) the refine flag is cleared.
*  For a description of the distinction between the two versions of the flag see above in the section about mesh smoothing in the general part of this classes description.
*  The same applies as above: several loops may be necessary.  [2.x.85]   [2.x.86] 
*  Regularization and smoothing are a bit complementary in that we check whether we need to set additional refinement flags when being on a cell flagged for refinement (regularization) or on a cell not flagged for refinement. This makes readable programming easier.
*  All the described algorithms apply only for more than one space dimension, since for one dimension no restrictions apply. It may be necessary to apply some smoothing for multigrid algorithms, but this has to be decided upon later.
* 

*  [1.x.24]
*  It seems impossible to preserve  [2.x.87]  of a triangulation through iterator usage. Thus, if you declare pointers to a  [2.x.88]  triangulation object, you should be well aware that you might involuntarily alter the data stored in the triangulation.
* 

* 
*  [2.x.89] 

* 
* [0.x.29]*
   An internal alias to make the definition of the iterator classes   simpler.  
* [0.x.30]*
   Declare some symbolic names for mesh smoothing algorithms. The meaning of   these flags is documented in the Triangulation class.  
* [0.x.31]*
     No mesh smoothing at all, except that meshes have to remain one-     irregular.    
* [0.x.32]*
     It can be shown, that degradation of approximation occurs if the     triangulation contains vertices which are member of cells with levels     differing by more than one. One such example is the following:          [2.x.90]          It would seem that in two space dimensions, the maximum jump in levels     between cells sharing a common vertex is two (as in the example above).     However, this is not true if more than four cells meet at a vertex. It     is not uncommon that a      [2.x.91]  "coarse (initial) mesh" contains vertices at which     six or even eight cells meet, when small features of the domain have to     be resolved even on the coarsest mesh. In that case, the maximum     difference in levels is three or four, respectively. The problem gets     even worse in three space dimensions.         Looking at an interpolation of the second derivative of the finite     element solution (assuming bilinear finite elements), one sees that the     numerical solution is almost totally wrong, compared with the true     second derivative. Indeed, on regular meshes, there exist sharp     estimations that the H<sup>2</sup>-error is only of order one, so we     should not be surprised; however, the numerical solution may show a     value for the second derivative which may be a factor of ten away from     the true value. These problems are located on the small cell adjacent     to the center vertex, where cells of non-subsequent levels meet, as     well as on the upper and right neighbor of this cell (but with a less     degree of deviation from the true value).         If the smoothing indicator given to the constructor contains the bit     for #limit_level_difference_at_vertices, situations as the above one     are eliminated by also marking the upper right cell for refinement.         In case of anisotropic refinement, the level of a cell is not linked to     the refinement of a cell as directly as in case of isotropic     refinement. Furthermore, a cell can be strongly refined in one     direction and not or at least much less refined in another. Therefore,     it is very difficult to decide, which cases should be excluded from the     refinement process. As a consequence, when using anisotropic     refinement, the #limit_level_difference_at_vertices flag must not be     set. On the other hand, the implementation of multigrid methods in     deal.II requires that this bit be set.    
* [0.x.33]*
     Single cells which are not refined and are surrounded by cells which     are refined usually also lead to a sharp decline in approximation     properties locally. The reason is that the nodes on the faces between     unrefined and refined cells are not real degrees of freedom but carry     constraints. The patch without additional degrees of freedom is thus     significantly larger then the unrefined cell itself. If in the     parameter passed to the constructor the bit for     #eliminate_unrefined_islands is set, all cells which are not flagged     for refinement but which are surrounded by more refined cells than     unrefined cells are flagged for refinement. Cells which are not yet     refined but flagged for that are accounted for the number of refined     neighbors. Cells on the boundary are not accounted for at all. An     unrefined island is, by this definition also a cell which (in 2D) is     surrounded by three refined cells and one unrefined one, or one     surrounded by two refined cells, one unrefined one and is at the     boundary on one side. It is thus not a true island, as the name of the     flag may indicate. However, no better name came to mind to the author     by now.    
* [0.x.34]*
     A triangulation of patch level 1 consists of patches, i.e. of cells     that are refined once. This flag ensures that a mesh of patch level 1     is still of patch level 1 after coarsening and refinement. It is,     however, the user's responsibility to ensure that the mesh is of patch     level 1 before calling      [2.x.92]  the first time. The     easiest way to achieve this is by calling global_refine(1) straight     after creation of the triangulation.  It follows that if at least one     of the children of a cell is or will be refined than all children need     to be refined. If the #patch_level_1 flag is set, than the flags     #eliminate_unrefined_islands, #eliminate_refined_inner_islands and     #eliminate_refined_boundary_islands will be ignored as they will be     fulfilled automatically.    
* [0.x.35]*
     Each      [2.x.93]  "coarse grid"     cell is refined at least once,     i.e., the triangulation     might have active cells on level 1 but not on level 0. This flag     ensures that a mesh which has coarsest_level_1 has still     coarsest_level_1 after coarsening and refinement. It is, however, the     user's responsibility to ensure that the mesh has coarsest_level_1     before calling execute_coarsening_and_refinement the first time. The     easiest way to achieve this is by calling global_refine(1) straight     after creation of the triangulation. It follows that active cells on     level 1 may not be coarsened.         The main use of this flag is to ensure that each cell has at least one     neighbor in each coordinate direction (i.e. each cell has at least a     left or right, and at least an upper or lower neighbor in 2d). This is     a necessary precondition for some algorithms that compute finite     differences between cells. The DerivativeApproximation class is one of     these algorithms that require that a triangulation is coarsest_level_1     unless all cells already have at least one neighbor in each coordinate     direction on the coarsest level.    
* [0.x.36]*
     This flag is not included in  [2.x.94]  The flag is     concerned with the following case: consider the case that an unrefined     and a refined cell share a common face and that one of the children of     the refined cell along the common face is flagged for further     refinement. In that case, the resulting mesh would have more than one     hanging node along one or more of the edges of the triangulation, a     situation that is not allowed. Consequently, in order to perform the     refinement, the coarser of the two original cells is also going to be     refined.         However, in many cases it is sufficient to refine the coarser of the     two original cells in an anisotropic way to avoid the case of multiple     hanging vertices on a single edge. Doing only the minimal anisotropic     refinement can save cells and degrees of freedom. By specifying this     flag, the library can produce these anisotropic refinements.         The flag is not included by default since it may lead to     anisotropically refined meshes even though no cell has ever been     refined anisotropically explicitly by a user command. This surprising     fact may lead to programs that do the wrong thing since they are not     written for the additional cases that can happen with anisotropic     meshes, see the discussion in the introduction to  [2.x.95] .    
* [0.x.37]*
     This algorithm seeks for isolated cells which are refined or flagged     for refinement. This definition is unlike that for     #eliminate_unrefined_islands, which would mean that an island is     defined as a cell which is refined but more of its neighbors are not     refined than are refined. For example, in 2D, a cell's refinement would     be reverted if at most one of its neighbors is also refined (or refined     but flagged for coarsening).         The reason for the change in definition of an island is, that this     option would be a bit dangerous, since if you consider a chain of     refined cells (e.g. along a kink in the solution), the cells at the two     ends would be coarsened, after which the next outermost cells would     need to be coarsened. Therefore, only one loop of flagging cells like     this could be done to avoid eating up the whole chain of refined cells     (`chain reaction'...).         This algorithm also takes into account cells which are not actually     refined but are flagged for refinement. If necessary, it takes away the     refinement flag.         Actually there are two versions of this flag,     #eliminate_refined_inner_islands and     #eliminate_refined_boundary_islands. The first eliminates islands     defined by the definition above which are in the interior of the     domain, while the second eliminates only those islands if the cell is     at the boundary. The reason for this split of flags is that one often     wants to eliminate such islands in the interior while those at the     boundary may well be wanted, for example if one refines the mesh     according to a criterion associated with a boundary integral or if one     has rough boundary data.    
* [0.x.38]*
     The result of this flag is very similar to     #eliminate_refined_inner_islands. See the documentation there.    
* [0.x.39]*
     This flag prevents the occurrence of unrefined islands. In more detail:     It prohibits the coarsening of a cell if 'most of the neighbors' will     be refined after the step.    
* [0.x.40]*
     This flag sums up all smoothing algorithms which may be performed upon     refinement by flagging some more cells for refinement.    
* [0.x.41]*
     This flag sums up all smoothing algorithms which may be performed upon     coarsening by flagging some more cells for coarsening.    
* [0.x.42]*
     This flag includes all the above ones (therefore combines all     smoothing algorithms implemented), with the exception of anisotropic     smoothing.    
* [0.x.43]*
   An alias that is used to identify cell iterators. The concept of   iterators is discussed at length in the    [2.x.96]  "iterators documentation module".     The current alias identifies cells in a triangulation. The TriaIterator   class works like a pointer that when you dereference it yields an object   of type CellAccessor. CellAccessor is a class that identifies properties   that are specific to cells in a triangulation, but it is derived (and   consequently inherits) from TriaAccessor that describes what you can ask   of more general objects (lines, faces, as well as cells) in a   triangulation.    
*  [2.x.97]   
* [0.x.44]*
   The same as above to allow the usage of the "MeshType concept" also   on the refinement levels.  
* [0.x.45]*
   An alias that is used to identify    [2.x.98]  "active cell iterators".   The concept of iterators is discussed at length in the    [2.x.99]  "iterators documentation module".     The current alias identifies active cells in a triangulation. The   TriaActiveIterator class works like a pointer to active objects that when   you dereference it yields an object of type CellAccessor. CellAccessor is   a class that identifies properties that are specific to cells in a   triangulation, but it is derived (and consequently inherits) from   TriaAccessor that describes what you can ask of more general objects   (lines, faces, as well as cells) in a triangulation.    
*  [2.x.100]   
* [0.x.46]*
   An alias that is used to identify iterators that point to faces.   The concept of iterators is discussed at length in the    [2.x.101]  "iterators documentation module".     The current alias identifies faces in a triangulation. The   TriaIterator class works like a pointer to objects that when   you dereference it yields an object of type TriaAccessor, i.e.,   class that can be used to query geometric properties of faces   such as their vertices, their area, etc.    
*  [2.x.102]   
* [0.x.47]*
   An alias that is used to identify iterators that point to active faces,   i.e., to faces that have no children. Active faces must be faces of at   least one active cell.     Other than the "active" qualification, this alias is identical to the    [2.x.103]  alias. In particular, dereferencing either yields   the same kind of object.    
*  [2.x.104]   
* [0.x.48]*
   An alias that defines an iterator type to iterate over   vertices of a mesh.  The concept of iterators is discussed at   length in the    [2.x.105]  "iterators documentation module".    
*  [2.x.106]   
* [0.x.49]*
   An alias that defines an iterator type to iterate over   vertices of a mesh.  The concept of iterators is discussed at   length in the    [2.x.107]  "iterators documentation module".     This alias is in fact identical to the  [2.x.108]  alias   above since all vertices in a mesh are active (i.e., are a vertex of   an active cell).    
*  [2.x.109]   
* [0.x.50]*
   An alias that defines an iterator over the (one-dimensional) lines   of a mesh. In one-dimensional meshes, these are the cells of the mesh,   whereas in two-dimensional meshes the lines are the faces of cells.    
*  [2.x.110]   
* [0.x.51]*
   An alias that allows iterating over the [1.x.25] lines, i.e.,   that subset of lines that have no children. In one-dimensional meshes,   these are the cells of the mesh, whereas in two-dimensional   meshes the lines are the faces of cells.     In two- or three-dimensional meshes, lines without children (i.e.,   the active lines) are part of at least one active cell. Each such line may   additionally be a child of a line of a coarser cell adjacent to a cell   that is active. (This coarser neighbor would then also be active.)    
*  [2.x.111]   
* [0.x.52]*
   An alias that defines an iterator over the (two-dimensional) quads   of a mesh. In two-dimensional meshes, these are the cells of the mesh,   whereas in three-dimensional meshes the quads are the faces of cells.    
*  [2.x.112]   
* [0.x.53]*
   An alias that allows iterating over the [1.x.26] quads, i.e.,   that subset of quads that have no children. In two-dimensional meshes,   these are the cells of the mesh, whereas in three-dimensional   meshes the quads are the faces of cells.     In three-dimensional meshes, quads without children (i.e.,   the active quads) are faces of at least one active cell. Each such quad may   additionally be a child of a quad face of a coarser cell adjacent to a cell   that is active. (This coarser neighbor would then also be active.)    
*  [2.x.113]   
* [0.x.54]*
   An alias that defines an iterator over the (three-dimensional) hexes   of a mesh. This iterator only makes sense in three-dimensional meshes,   where hexes are the cells of the mesh.    
*  [2.x.114]   
* [0.x.55]*
   An alias that allows iterating over the [1.x.27] hexes of a mesh.   This iterator only makes sense in three-dimensional meshes,   where hexes are the cells of the mesh. Consequently, in these   three-dimensional meshes, this iterator is equivalent to the    [2.x.115]  alias.    
*  [2.x.116]   
* [0.x.56]*
   A structure that is used as an exception object by the   create_triangulation() function to indicate which cells among the coarse   mesh cells are inverted or severely distorted (see the entry on    [2.x.117]  "distorted cells"   in the glossary).     Objects of this kind are thrown by the create_triangulation() and   execute_coarsening_and_refinement() functions, and they can be caught in   user code if this condition is to be ignored. Note, however, that such   exceptions are only produced if the necessity for this check was   indicated when calling the constructor of the Triangulation class.     A cell is called [1.x.28] if the determinant of the Jacobian of   the mapping from reference cell to real cell is negative at least at one   vertex. This computation is done using the    [2.x.118]  function.  
* [0.x.57]*
     Destructor. Empty, but needed for the sake of exception specification,     since the base class has this exception specification and the     automatically generated destructor would have a different one due to     member objects.    
* [0.x.58]*
     A list of those cells among the coarse mesh cells that are deformed or     whose children are deformed.    
* [0.x.59]*
   Make the dimension available in function templates.  
* [0.x.60]*
   Make the space-dimension available in function templates.  
* [0.x.61]*
   Create an empty triangulation. Do not create any cells.      [2.x.119]  smooth_grid Determines the level of smoothness of the mesh size   function that should be enforced upon mesh refinement.      [2.x.120]  check_for_distorted_cells Determines whether the triangulation   should check whether any of the cells that are created by   create_triangulation() or execute_coarsening_and_refinement() are   distorted (see    [2.x.121]  "distorted cells").   If set, these two functions may throw an exception if they encounter   distorted cells.  
* [0.x.62]*
   Copy constructor.     You should really use the  [2.x.122]  function, so this   constructor is deleted. The reason for this is   that we may want to use triangulation objects in collections. However,   C++ containers require that the objects stored in them are copyable, so   we need to provide a copy constructor. On the other hand, copying   triangulations is so expensive that we do not want such objects copied by   accident, for example in compiler-generated temporary objects. By   defining a copy constructor but throwing an error, we satisfy the formal   requirements of containers, but at the same time disallow actual copies.   Finally, through the exception, one easily finds the places where code   has to be changed to avoid copies.  
* [0.x.63]*
   Move constructor.     Create a new triangulation by stealing the internal data of another   triangulation.  
* [0.x.64]*
   Move assignment operator.  
* [0.x.65]*
   Delete the object and all levels of the hierarchy.  
* [0.x.66]*
   Reset this triangulation into a virgin state by deleting all data.     Note that this operation is only allowed if no subscriptions to this   object exist any more, such as DoFHandler objects using it.  
* [0.x.67]*
   Return MPI communicator used by this triangulation. In the case of   a serial Triangulation object, MPI_COMM_SELF is returned.  
* [0.x.68]*
   Set the mesh smoothing to  [2.x.123]  This overrides the   MeshSmoothing given to the constructor. It is allowed to call this   function only if the triangulation is empty.  
* [0.x.69]*
   Return the mesh smoothing requirements that are obeyed.  
* [0.x.70]*
   Assign a manifold object to a certain part of the triangulation. If   an object with manifold number  [2.x.124]  is refined, this object is used   to find the location of new vertices (see the results section of  [2.x.125]    for a more in-depth discussion of this, with examples).  It is also used   for non-linear (i.e.: non-Q1) transformations of cells to the unit cell   in shape function calculations.     A copy of  [2.x.126]  is created using   Manifold<dim,  [2.x.127]  and stored internally.     It is possible to remove or replace a Manifold object during the   lifetime of a non-empty triangulation. Usually, this is done before the   first refinement and is dangerous afterwards. Removal of a manifold   object is done by reset_manifold(). This operation then replaces the   manifold object given before by a straight manifold approximation.    
*  [2.x.128]       [2.x.129]     [2.x.130]  "Glossary entry on manifold indicators"  
* [0.x.71]*
   Reset those parts of the triangulation with the given    [2.x.131]  to use a FlatManifold object. This is the   default state of a non-curved triangulation, and undoes   assignment of a different Manifold object by the function    [2.x.132]     
*  [2.x.133]       [2.x.134]     [2.x.135]  "Glossary entry on manifold indicators"  
* [0.x.72]*
   Reset all parts of the triangulation, regardless of their   manifold_id, to use a FlatManifold object. This undoes assignment   of all Manifold objects by the function    [2.x.136]     
*  [2.x.137]       [2.x.138]     [2.x.139]  "Glossary entry on manifold indicators"  
* [0.x.73]*
   Set the manifold_id of all cells and faces to the given argument.    
*  [2.x.140]       [2.x.141]     [2.x.142]  "Glossary entry on manifold indicators"  
* [0.x.74]*
   Set the manifold_id of all boundary faces to the given argument.    
*  [2.x.143]       [2.x.144]     [2.x.145]  "Glossary entry on manifold indicators"  
* [0.x.75]*
   Set the manifold_id of all boundary faces and edges with given   boundary_id  [2.x.146]  to the given manifold_id  [2.x.147]     
*  [2.x.148]       [2.x.149]     [2.x.150]  "Glossary entry on manifold indicators"  
* [0.x.76]*
   Return a constant reference to a Manifold object used for this   triangulation.  [2.x.151]  is the same as in set_manifold().    
*  [2.x.152]  If no manifold could be found, the default flat manifold is returned.    
*  [2.x.153]       [2.x.154]     [2.x.155]  "Glossary entry on manifold indicators"  
* [0.x.77]*
   Return a vector containing all boundary indicators assigned to boundary   faces of active cells of this Triangulation object. Note, that each   boundary indicator is reported only once. The size of the return vector   will represent the number of different indicators (which is greater or   equal one).    
*  [2.x.156]       [2.x.157]     [2.x.158]  "Glossary entry on boundary indicators"  
* [0.x.78]*
   Return a vector containing all manifold indicators assigned to the   objects of the active cells of this Triangulation. Note, that each   manifold indicator is reported only once. The size of the return vector   will represent the number of different indicators (which is greater or   equal one).    
*  [2.x.159]       [2.x.160]     [2.x.161]  "Glossary entry on manifold indicators"  
* [0.x.79]*
   Copy  [2.x.162]  to this triangulation. This operation is not cheap, so   you should be careful with using this. We do not implement this function   as a copy constructor, since it makes it easier to maintain collections   of triangulations if you can assign them values later on.     Keep in mind that this function also copies the pointer to the boundary   descriptor previously set by the  [2.x.163]  function. You must   therefore also guarantee that the Manifold objects describing the boundary   have a lifetime at least as long as the copied triangulation.     This triangulation must be empty beforehand.     The function is made  [2.x.164]  since some derived classes might want to   disable or extend the functionality of this function.    
*  [2.x.165]  Calling this function triggers the 'copy' signal on other_tria, i.e.   the triangulation being copied [1.x.29].  It also triggers the   'create' signal of the current triangulation. See the section on signals   in the general documentation for more information.    
*  [2.x.166]  The list of connections to signals is not copied from the old to   the new triangulation since these connections were established to monitor   how the old triangulation changes, not how any triangulation it may be   copied to changes.  
* [0.x.80]*
   Create a triangulation from a list of vertices and a list of cells, each   of the latter being a list of <tt>1<<dim</tt> vertex indices. The   triangulation must be empty upon calling this function and the cell list   should be useful (connected domain, etc.). The result of calling this   function is a    [2.x.167]  "coarse mesh".     Material data for the cells is given within the  [2.x.168]  array, while   boundary information is given in the  [2.x.169]  field.     The numbering of vertices within the  [2.x.170]  array is subject to some   constraints; see the general class documentation for this.     For conditions when this function can generate a valid triangulation, see   the documentation of this class, and the GridIn and GridReordering class.     If the  [2.x.171]  flag was specified upon   creation of this object, at the very end of its operation, the current   function walks over all cells and verifies that none of the cells is   deformed (see the entry on    [2.x.172]  "distorted cells"   in the glossary), where we call a cell deformed if the determinant of the   Jacobian of the mapping from reference cell to real cell is negative at   least at one of the vertices (this computation is done using the    [2.x.173]  function). If there are   deformed cells, this function throws an exception of kind   DistortedCellList. Since this happens after all data structures have been   set up, you can catch and ignore this exception if you know what you do
* 

* 
* 

* 
* 

* 
* 
*  -  for example, it may be that the determinant is zero (indicating that   you have collapsed edges in a cell) but that this is ok because you   didn't intend to integrate on this cell anyway. On the other hand,   deformed cells are often a sign of a mesh that is too coarse to resolve   the geometry of the domain, and in this case ignoring the exception is   probably unwise.    
*  [2.x.174]  This function is used in  [2.x.175]  and  [2.x.176] .    
*  [2.x.177]  This function triggers the "create" signal after doing its work. See   the section on signals in the general documentation of this class. For   example as a consequence of this, all DoFHandler objects connected to   this triangulation will be reinitialized via  [2.x.178]     
*  [2.x.179]  The check for distorted cells is only done if dim==spacedim, as   otherwise cells can legitimately be twisted if the manifold they describe   is twisted.  
* [0.x.81]*
   Create a triangulation from the provided    [2.x.180]     
*  [2.x.181]  Don't forget to attach the manifolds with set_manifold() before     calling this function if manifolds are needed.    
*  [2.x.182]  The namespace  [2.x.183]  contains functions     to create  [2.x.184]       [2.x.185]  construction_data The data needed for this process.  
* [0.x.82]*
   For backward compatibility, only. This function takes the cell data in   the ordering as requested by deal.II versions up to 5.2, converts it to   the new (lexicographic) ordering and calls create_triangulation().    
*  [2.x.186]  This function internally calls create_triangulation and therefore   can throw the same exception as the other function.  
* [0.x.83]*
   Revert or flip the direction_flags of a dim<spacedim triangulation, see    [2.x.187] .     This function throws an exception if dim equals spacedim.  
* [0.x.84]*
    [2.x.188]  Mesh refinement    [2.x.189]   
* [0.x.85]*
   Flag all active cells for refinement.  This will refine all cells of all   levels which are not already refined (i.e. only cells are refined which   do not yet have children). The cells are only flagged, not refined, thus   you have the chance to save the refinement flags.  
* [0.x.86]*
   Refine all cells  [2.x.190]  times. In other words, in each one of   the  [2.x.191]  iterations, loop over all cells and refine each cell   uniformly into  [2.x.192]  children. In practice, this   function repeats the following operations  [2.x.193]  times: call   set_all_refine_flags() followed by   execute_coarsening_and_refinement(). The end result is that the   number of cells increases by a factor of    [2.x.194] .     The execute_coarsening_and_refinement() function called in this   loop may throw an exception if it creates cells that are   distorted (see its documentation for an explanation). This   exception will be propagated through this function if that   happens, and you may not get the actual number of refinement   steps in that case.    
*  [2.x.195]  This function triggers the pre- and post-refinement signals before   and after doing each individual refinement cycle (i.e. more than once if   `times > 1`) . See the section on signals in the general documentation of   this class.  
* [0.x.87]*
   Coarsen all cells the given number of times.     In each of one of the  [2.x.196]  iterations, all cells will be marked for   coarsening. If an active cell is already on the coarsest level, it will   be ignored.    
*  [2.x.197]  This function triggers the pre- and post-refinement signals before   and after doing each individual coarsening cycle (i.e. more than once if   `times > 1`) . See the section on signals in the general documentation of   this class.  
* [0.x.88]*
   Execute both refinement and coarsening of the triangulation.     The function resets all refinement and coarsening flags to false. It uses   the user flags for internal purposes. They will therefore be overwritten   by undefined content.     To allow user programs to fix up these cells if that is desired, this   function after completing all other work may throw an exception of type   DistortedCellList that contains a list of those cells that have been   refined and have at least one child that is distorted. The function does   not create such an exception if no cells have created distorted children.   Note that for the check for distorted cells to happen, the    [2.x.198]  flag has to be specified upon   creation of a triangulation object.     See the general docs for more information.    
*  [2.x.199]  This function triggers the pre- and post-refinement signals before   and after doing its work. See the section on signals in the general   documentation of this class.    
*  [2.x.200]  If the boundary description is sufficiently irregular, it can   happen that some of the children produced by mesh refinement are   distorted (see the extensive discussion on    [2.x.201]  "distorted cells").    
*  [2.x.202]  This function is <tt>virtual</tt> to allow derived classes to   insert hooks, such as saving refinement flags and the like (see e.g. the   PersistentTriangulation class).  
* [0.x.89]*
   Do both preparation for refinement and coarsening as well as mesh   smoothing.     Regarding the refinement process it fixes the closure of the refinement   in <tt>dim>=2</tt> (make sure that no two cells are adjacent with a   refinement level differing with more than one), etc.  It performs some   mesh smoothing if the according flag was given to the constructor of this   class.  The function returns whether additional cells have been flagged   for refinement.     See the general doc of this class for more information on smoothing upon   refinement.     Regarding the coarsening part, flagging and deflagging cells in   preparation of the actual coarsening step are done. This includes   deleting coarsen flags from cells which may not be deleted (e.g. because   one neighbor is more refined than the cell), doing some smoothing, etc.     The effect is that only those cells are flagged for coarsening which will   actually be coarsened. This includes the fact that all flagged cells   belong to parent cells of which all children are flagged.     The function returns whether some cells' flagging has been changed in the   process.     This function uses the user flags, so store them if you still need them   afterwards.  
* [0.x.90]    [2.x.203]   
* [0.x.91]*
    [2.x.204]  Keeping up with what happens to a triangulation    [2.x.205]   
* [0.x.92]*
   Used to inform functions in derived classes how the cell with the given   cell_iterator is going to change. Note that this may me different than   the refine_flag() and coarsen_flag() in the cell_iterator in parallel   calculations because of refinement constraints that this machine does not   see.  
* [0.x.93]*
     The cell will not be refined or coarsened and might or might not move     to a different processor.    
* [0.x.94]*
     The cell will be or was refined.    
* [0.x.95]*
     The children of this cell will be or were coarsened into this cell.    
* [0.x.96]*
     Invalid status. Will not occur for the user.    
* [0.x.97]*
   A structure used to accumulate the results of the cell_weights slot   functions below. It takes an iterator range and returns the sum of   values.  
* [0.x.98]*
   A structure that has  [2.x.206]  objects for a number of actions that a   triangulation can do to itself. Please refer to the "Getting notice when   a triangulation changes" section in the general documentation of the   Triangulation class for more information and examples.     For documentation on signals, see   http://www.boost.org/doc/libs/release/libs/signals2 .  
* [0.x.99]*
     This signal is triggered whenever the      [2.x.207]  or      [2.x.208]  is called. This signal is also     triggered when loading a triangulation from an archive via      [2.x.209]     
* [0.x.100]*
     This signal is triggered at the beginning of execution of the      [2.x.210]  function (which is     itself called by other functions such as  [2.x.211]      ). At the time this signal is triggered, the triangulation is still     unchanged.    
* [0.x.101]*
     This signal is triggered at the end of execution of the      [2.x.212]  function when the     triangulation has reached its final state.    
* [0.x.102]*
     This signal is triggered at the beginning of execution of the      [2.x.213]  and      [2.x.214]  functions. At the time this     signal is triggered, the triangulation is still unchanged.    
* [0.x.103]*
     This signal is triggered when a function in deal.II moves the grid     points of a mesh, e.g.  [2.x.215]  Unfortunately,     modification of a vertex in user code through      [2.x.216]  cannot be detected by this     method.    
* [0.x.104]*
     This signal is triggered for each cell that is going to be coarsened.        
*  [2.x.217]  This signal is triggered with the immediate parent cell of a set     of active cells as argument. The children of this parent cell will     subsequently be coarsened away.    
* [0.x.105]*
     This signal is triggered for each cell that just has been refined.        
*  [2.x.218]  The signal parameter  [2.x.219]  corresponds to the immediate parent     cell of a set of newly created active cells.    
* [0.x.106]*
     This signal is triggered whenever the triangulation owning the signal     is copied by another triangulation using      [2.x.220]  (i.e. it is triggered on the     [1.x.30] triangulation, but the new one is passed as an argument).    
* [0.x.107]*
     This signal is triggered whenever the  [2.x.221]  function     is called and in the destructor of the triangulation. This signal is     also triggered when loading a triangulation from an archive via      [2.x.222]  as the previous content of the triangulation is     first destroyed.         The signal is triggered before the data structures of the     triangulation are destroyed. In other words, the functions     attached to this signal get a last look at the triangulation,     for example to save information stored as part of the     triangulation.    
* [0.x.108]*
     This is a catch-all signal that is triggered whenever the create,     post_refinement, or clear signals are triggered. In effect, it can be     used to indicate to an object connected to the signal that the     triangulation has been changed, whatever the exact cause of the change.        
*  [2.x.223]  The cell-level signals  [2.x.224]  and  [2.x.225]      post_refinement_on_cell are not connected to this signal.    
* [0.x.109]*
     This signal is triggered for each cell during every automatic or manual     repartitioning. This signal is somewhat special in that it is only     triggered for distributed parallel calculations and only if functions     are connected to it. It is intended to allow a weighted repartitioning     of the domain to balance the computational load across processes in a     different way than balancing the number of cells. Any connected     function is expected to take an iterator to a cell, and a CellStatus     argument that indicates whether this cell is going to be refined,     coarsened or left untouched (see the documentation of the CellStatus     enum for more information). The function is expected to return an     unsigned integer, which is interpreted as the additional computational     load of this cell. If this cell is going to be coarsened, the signal is     called for the parent cell and you need to provide the weight of the     future parent cell. If this cell is going to be refined the function     should return a weight, which will be equally assigned to every future     child cell of the current cell. As a reference a value of 1000 is added     for every cell to the total weight. This means a signal return value of     1000 (resulting in a weight of 2000) means that it is twice as     expensive for a process to handle this particular cell. If several     functions are connected to this signal, their return values will be     summed to calculate the final weight.         This function is used in  [2.x.226] .    
* [0.x.110]*
     This signal is triggered at the beginning of execution of the      [2.x.227]      function (which is     itself called by other functions such as  [2.x.228]      ). At the time this signal is triggered, the triangulation is still     unchanged. This signal     is different from the pre_refinement signal, because in the parallel     distributed case the pre_refinement signal is triggered multiple times     without a way to distinguish the last signal call.    
* [0.x.111]*
     This signal is triggered during execution of the      [2.x.229]      function. At the time this signal is triggered, the p4est oracle has been     refined and the cell relations have been updated. The triangulation is     unchanged otherwise, and the p4est oracle has not yet been repartitioned.    
* [0.x.112]*
     This signal is triggered at the end of execution of the      [2.x.230]      function when the triangulation has reached its final state. This signal     is different from the post_refinement signal, because in the parallel     distributed case the post_refinement signal is triggered multiple times     without a way to distinguish the last signal call.    
* [0.x.113]*
     This signal is triggered at the beginning of execution of the      [2.x.231]  function. At the time     this signal is triggered, the triangulation is still unchanged.        
*  [2.x.232]  The  [2.x.233]  function is     also called by  [2.x.234]  Thus, the     pre_distributed_repartition signal will be triggered after the     pre_distributed_load one.    
* [0.x.114]*
     This signal is triggered at the end of execution of the      [2.x.235]      function when the triangulation has reached its final state.    
* [0.x.115]*
     This signal is triggered at the beginning of execution of the      [2.x.236]      function. At the time this signal is triggered, the triangulation     is still unchanged.    
* [0.x.116]*
     This signal is triggered at the end of execution of the      [2.x.237]      function when the triangulation has reached its final state.    
* [0.x.117]*
     This signal is triggered at the beginning of execution of the      [2.x.238]      function. At the time this signal is triggered, the triangulation     is still unchanged.    
* [0.x.118]*
     This signal is triggered at the end of execution of the      [2.x.239]      function when the triangulation has reached its final state.    
* [0.x.119]*
   Signals for the various actions that a triangulation can do to itself.  
* [0.x.120]    [2.x.240]   
* [0.x.121]*
    [2.x.241]  History of a triangulation    [2.x.242]   
* [0.x.122]*
   Save the addresses of the cells which are flagged for refinement to  [2.x.243]    out.  For usage, read the general documentation for this class.  
* [0.x.123]*
   Same as above, but store the flags to a bitvector rather than to a file.  
* [0.x.124]*
   Read the information stored by  [2.x.244]   
* [0.x.125]*
   Read the information stored by  [2.x.245]   
* [0.x.126]*
   Analogue to  [2.x.246]   
* [0.x.127]*
   Same as above, but store the flags to a bitvector rather than to a file.  
* [0.x.128]*
   Analogue to  [2.x.247]   
* [0.x.129]*
   Analogue to  [2.x.248]   
* [0.x.130]*
   Return whether this triangulation has ever undergone anisotropic (as   opposed to only isotropic) refinement.  
* [0.x.131]    [2.x.249]   
* [0.x.132]*
    [2.x.250]  User data    [2.x.251]   
* [0.x.133]*
   Clear all user flags.  See also    [2.x.252] .  
* [0.x.134]*
   Save all user flags. See the general documentation for this class and the   documentation for the  [2.x.253]  for more details.  See also    [2.x.254] .  
* [0.x.135]*
   Same as above, but store the flags to a bitvector rather than to a file.   The output vector is resized if necessary.  See also    [2.x.255] .  
* [0.x.136]*
   Read the information stored by  [2.x.256]   See also    [2.x.257] .  
* [0.x.137]*
   Read the information stored by  [2.x.258]   See also    [2.x.259] .  
* [0.x.138]*
   Clear all user flags on lines.  See also    [2.x.260] .  
* [0.x.139]*
   Save the user flags on lines.  See also    [2.x.261] .  
* [0.x.140]*
   Same as above, but store the flags to a bitvector rather than to a file.   The output vector is resized if necessary.  See also    [2.x.262] .  
* [0.x.141]*
   Load the user flags located on lines.  See also    [2.x.263] .  
* [0.x.142]*
   Load the user flags located on lines.  See also    [2.x.264] .  
* [0.x.143]*
   Clear all user flags on quads.  See also    [2.x.265] .  
* [0.x.144]*
   Save the user flags on quads.  See also    [2.x.266] .  
* [0.x.145]*
   Same as above, but store the flags to a bitvector rather than to a file.   The output vector is resized if necessary.  See also    [2.x.267] .  
* [0.x.146]*
   Load the user flags located on quads.  See also    [2.x.268] .  
* [0.x.147]*
   Load the user flags located on quads.  See also    [2.x.269] .  
* [0.x.148]*
   Clear all user flags on quads.  See also    [2.x.270] .  
* [0.x.149]*
   Save the user flags on hexs.  See also    [2.x.271] .  
* [0.x.150]*
   Same as above, but store the flags to a bitvector rather than to a file.   The output vector is resized if necessary.  See also    [2.x.272] .  
* [0.x.151]*
   Load the user flags located on hexs.  See also    [2.x.273] .  
* [0.x.152]*
   Load the user flags located on hexs.  See also    [2.x.274] .  
* [0.x.153]*
   Clear all user pointers and indices and allow the use of both for next   access.  See also    [2.x.275] .  
* [0.x.154]*
   Save all user indices. The output vector is resized if necessary. See   also    [2.x.276] .  
* [0.x.155]*
   Read the information stored by save_user_indices().  See also    [2.x.277] .  
* [0.x.156]*
   Save all user pointers. The output vector is resized if necessary.  See   also    [2.x.278] .  
* [0.x.157]*
   Read the information stored by save_user_pointers().  See also    [2.x.279] .  
* [0.x.158]*
   Save the user indices on lines. The output vector is resized if   necessary.  See also    [2.x.280] .  
* [0.x.159]*
   Load the user indices located on lines.  See also    [2.x.281] .  
* [0.x.160]*
   Save the user indices on quads. The output vector is resized if   necessary.  See also    [2.x.282] .  
* [0.x.161]*
   Load the user indices located on quads.  See also    [2.x.283] .  
* [0.x.162]*
   Save the user indices on hexes. The output vector is resized if   necessary.  See also    [2.x.284] .  
* [0.x.163]*
   Load the user indices located on hexs.  See also    [2.x.285] .  
* [0.x.164]*
   Save the user indices on lines. The output vector is resized if   necessary.  See also    [2.x.286] .  
* [0.x.165]*
   Load the user pointers located on lines.  See also    [2.x.287] .  
* [0.x.166]*
   Save the user pointers on quads. The output vector is resized if   necessary.  See also    [2.x.288] .  
* [0.x.167]*
   Load the user pointers located on quads.  See also    [2.x.289] .  
* [0.x.168]*
   Save the user pointers on hexes. The output vector is resized if   necessary.  See also    [2.x.290] .  
* [0.x.169]*
   Load the user pointers located on hexs.  See also    [2.x.291] .  
* [0.x.170]    [2.x.292]   
* [0.x.171]*
    [2.x.293]  Cell iterator functions    [2.x.294]   
* [0.x.172]*
   Iterator to the first used cell on level  [2.x.295]     
*  [2.x.296]  The given  [2.x.297]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.298]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.31] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.299]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.300]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.173]*
   Iterator to the first active cell on level  [2.x.301]  If the given level   does not contain any active cells (i.e., all cells on this level are   further refined, then this function returns    [2.x.302]  so that loops of the kind  
* [1.x.32]
*    have zero iterations, as may be expected if there are no active cells on   this level.    
*  [2.x.303]  The given  [2.x.304]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.305]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.33] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.306]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.307]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.174]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states.  
* [0.x.175]*
   Return an iterator which is the first iterator not on level. If  [2.x.308]    is the last level, then this returns <tt>end()</tt>.    
*  [2.x.309]  The given  [2.x.310]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.311]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.34] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.312]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.313]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.176]*
   Return an active iterator which is the first active iterator not on the   given level. If  [2.x.314]  is the last level, then this returns   <tt>end()</tt>.    
*  [2.x.315]  The given  [2.x.316]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.317]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.35] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.318]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.319]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.177]*
   Return an iterator pointing to the last used cell.  
* [0.x.178]*
   Return an iterator pointing to the last active cell.  
* [0.x.179]*
   Return an iterator to a cell of this Triangulation object constructed from   an independent CellId object.     If the given argument corresponds to a valid cell in this triangulation,   this operation will always succeed for sequential triangulations where the   current processor stores all cells that are part of the triangulation. On   the other hand, if this is a parallel triangulation, then the current   processor may not actually know about this cell. In this case, this   operation will succeed for locally relevant cells, but may not for   artificial cells that are less refined on the current processor.  
* [0.x.180]*
    [2.x.320]  Cell iterator functions returning ranges of iterators  
* [0.x.181]*
   Return an iterator range that contains all cells (active or not) that   make up this triangulation. Such a range is useful to initialize range-   based for loops as supported by C++11. See the example in the   documentation of active_cell_iterators().      [2.x.321]  The half open range  [2.x.322]     
*  [2.x.323]   
* [0.x.182]*
   Return an iterator range that contains all active cells that make up this   triangulation. Such a range is useful to initialize range-based for loops   as supported by C++11, see also    [2.x.324]  "C++11 standard".     Range-based for loops are useful in that they require much less code than   traditional loops (see [1.x.36] for a discussion of how they work). An   example is that without range-based for loops, one often writes code such   as the following (assuming for a moment that our goal is setting the user   flag on every active cell):  
* [1.x.37]
*    Using C++11's range-based for loops, this is now entirely equivalent to   the following:  
* [1.x.38]
*       [2.x.325]  The half open range <code>[this->begin_active(),   this->end())</code>    
*  [2.x.326]   
* [0.x.183]*
   Return an iterator range that contains all cells (active or not) that   make up the given level of this triangulation. Such a range is useful to   initialize range-based for loops as supported by C++11. See the example   in the documentation of active_cell_iterators().      [2.x.327]  level A given level in the refinement hierarchy of this   triangulation.    [2.x.328]  The half open range <code>[this->begin(level),   this->end(level))</code>      [2.x.329]  level must be less than this->n_levels().    
*  [2.x.330]   
* [0.x.184]*
   Return an iterator range that contains all active cells that make up the   given level of this triangulation. Such a range is useful to initialize   range-based for loops as supported by C++11. See the example in the   documentation of active_cell_iterators().      [2.x.331]  level A given level in the refinement hierarchy of this   triangulation.    [2.x.332]  The half open range <code>[this->begin_active(level),   this->end(level))</code>      [2.x.333]  level must be less than this->n_levels().    
*  [2.x.334]   
* [0.x.185]    [2.x.335]   
* [0.x.186]*
    [2.x.336]  Face iterator functions    [2.x.337]   
* [0.x.187]*
   Iterator to the first used face.  
* [0.x.188]*
   Iterator to the first active face.  
* [0.x.189]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states.  
* [0.x.190]*
   Return an iterator range that contains all active faces that make up this   triangulation. This function is the face version of    [2.x.338]  and allows one to write code   like, e.g.,    
* [1.x.39]
*       [2.x.339]  The half open range <code>[this->begin_active_face(),   this->end_face())</code>    
*  [2.x.340]   
* [0.x.191]    [2.x.341]   
* [0.x.192]*
    [2.x.342]  Vertex iterator functions    [2.x.343]   
* [0.x.193]*
   Iterator to the first used vertex. This function can only be used if dim   is not one.  
* [0.x.194]*
   Iterator to the first active vertex. Because all vertices are active,   begin_vertex() and begin_active_vertex() return the same vertex. This   function can only be used if dim is not one.  
* [0.x.195]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states. This function can only   be used if dim is not one.  
* [0.x.196]    [2.x.344]   
* [0.x.197]*
    [2.x.345]  Information about the triangulation    [2.x.346]   
* [0.x.198]*
   In the following, most functions are provided in two versions, with and   without an argument describing the level. The versions with this argument   are only applicable for objects describing the cells of the present   triangulation. For example: in 2D <tt>n_lines(level)</tt> cannot be   called, only <tt>n_lines()</tt>, as lines are faces in 2D and therefore   have no level.  
* [0.x.199]*
   Return the total number of used lines, active or not.  
* [0.x.200]*
   Return the total number of used lines, active or not on level  [2.x.347]   
* [0.x.201]*
   Return the total number of active lines.  
* [0.x.202]*
   Return the total number of active lines, on level  [2.x.348]   
* [0.x.203]*
   Return the total number of used quads, active or not.  
* [0.x.204]*
   Return the total number of used quads, active or not on level  [2.x.349]   
* [0.x.205]*
   Return the total number of active quads, active or not.  
* [0.x.206]*
   Return the total number of active quads, active or not on level  [2.x.350]   
* [0.x.207]*
   Return the total number of used hexahedra, active or not.  
* [0.x.208]*
   Return the total number of used hexahedra, active or not on level  [2.x.351]    level.  
* [0.x.209]*
   Return the total number of active hexahedra, active or not.  
* [0.x.210]*
   Return the total number of active hexahedra, active or not on level  [2.x.352]    level.  
* [0.x.211]*
   Return the total number of used cells, active or not.  Maps to   <tt>n_lines()</tt> in one space dimension and so on.  
* [0.x.212]*
   Return the total number of used cells, active or not, on level  [2.x.353]    Maps to <tt>n_lines(level)</tt> in one space dimension and so on.  
* [0.x.213]*
   Return the total number of active cells. Maps to   <tt>n_active_lines()</tt> in one space dimension and so on.  
* [0.x.214]*
   Return the total number of active cells. For the current class, this is   the same as n_active_cells(). However, the function may be overloaded in   derived classes (e.g., in  [2.x.354]  where it   may return a value greater than the number of active cells reported by   the triangulation object on the current processor.  
* [0.x.215]*
   Return the total number of active cells on level  [2.x.355]   Maps to   <tt>n_active_lines(level)</tt> in one space dimension and so on.  
* [0.x.216]*
   Return the total number of used faces, active or not.  In 2D, the result   equals n_lines(), in 3D it equals n_quads(), while in 1D it equals   the number of used vertices.  
* [0.x.217]*
   Return the total number of active faces.  In 2D, the result equals   n_active_lines(), in 3D it equals n_active_quads(), while in 1D it equals   the number of used vertices.  
* [0.x.218]*
   Return the number of levels in this triangulation.    
*  [2.x.356]  Internally, triangulations store data in levels, and there may be   more levels in this data structure than one may think
* 
*  -  for example,   imagine a triangulation that we just got by coarsening the highest level   so that it was completely depopulated. That level is not removed, since   it will most likely be repopulated soon by the next refinement process.   As a consequence, if you happened to run through raw cell iterators   (which you can't do as a user of this class, but can internally), then   the number of objects in the levels hierarchy is larger than the level of   the most refined cell plus one. On the other hand, since this is rarely   what a user of this class cares about, the function really just returns   the level of the most refined active cell plus one. (The plus one is   because in a coarse, unrefined mesh, all cells have level zero
* 
*  -  making   the number of levels equal to one.)  
* [0.x.219]*
   Return the number of levels in use. This function is equivalent to   n_levels() for a serial Triangulation, but gives the maximum of   n_levels() over all processors for a  [2.x.357]    and therefore can be larger than n_levels().  
* [0.x.220]*
   Return true if the triangulation has hanging nodes.     The function is made virtual since the result can be interpreted in   different ways, depending on whether the triangulation lives only on a   single processor, or may be distributed as done in the    [2.x.358]  class (see there for a description   of what the function is supposed to do in the parallel context).  
* [0.x.221]*
   Return the total number of vertices.  Some of them may not be used, which   usually happens upon coarsening of a triangulation when some vertices are   discarded, but we do not want to renumber the remaining ones, leading to   holes in the numbers of used vertices.  You can get the number of used   vertices using  [2.x.359]  function.  
* [0.x.222]*
   Return a constant reference to all the vertices present in this   triangulation. Note that not necessarily all vertices in this array are   actually used; for example, if you coarsen a mesh, then some vertices are   deleted, but their positions in this array are unchanged as the indices   of vertices are only allocated once. You can find out about which   vertices are actually used by the function get_used_vertices().  
* [0.x.223]*
   Return the number of vertices that are presently in use, i.e. belong to   at least one used element.  
* [0.x.224]*
   Return  [2.x.360]  if the vertex with this  [2.x.361]  is used.  
* [0.x.225]*
   Return a constant reference to the array of  [2.x.362]  indicating whether   an entry in the vertex array is used or not.  
* [0.x.226]*
   Return the maximum number of cells meeting at a common vertex. Since this   number is an invariant under refinement, only the cells on the coarsest   level are considered. The operation is thus reasonably fast. The   invariance is only true for sufficiently many cells in the coarsest   triangulation (e.g. for a single cell one would be returned), so a   minimum of four is returned in two dimensions, 8 in three dimensions,   etc, which is how many cells meet if the triangulation is refined.     In one space dimension, two is returned.  
* [0.x.227]*
   This function always returns  [2.x.363]  but is there for   compatibility with the derived  [2.x.364]    class. For distributed parallel triangulations this function returns the   subdomain id of those cells that are owned by the current processor.  
* [0.x.228]*
   Return a reference to the current object.     This doesn't seem to be very useful but allows to write code that can   access the underlying triangulation for anything that satisfies the    [2.x.365]  "MeshType concept"   (which may not only be a triangulation, but also a DoFHandler, for   example).  
* [0.x.229]*
   Return a reference to the current object. This is the const-version of   the previous function.  
* [0.x.230]    [2.x.366]   
* [0.x.231]*
    [2.x.367]  Internal information about the number of objects    [2.x.368]   
* [0.x.232]*
   Total number of lines, used or unused.    
*  [2.x.369]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.233]*
   Number of lines, used or unused, on the given level.    
*  [2.x.370]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.234]*
   Total number of quads, used or unused.    
*  [2.x.371]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.235]*
   Number of quads, used or unused, on the given level.    
*  [2.x.372]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.236]*
   Number of hexs, used or unused, on the given level.    
*  [2.x.373]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.237]*
   Number of cells, used or unused, on the given level.    
*  [2.x.374]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.238]*
   Return the total number of faces, used or not. In 2d, the result equals   n_raw_lines(), in 3d it equals n_raw_quads(), while in 1D it equals   the number of vertices.    
*  [2.x.375]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.239]    [2.x.376]   
* [0.x.240]*
   Determine an estimate for the memory consumption (in bytes) of this   object.     This function is made virtual, since a triangulation object might be   accessed through a pointer to this base class, even if the actual object   is a derived class.  
* [0.x.241]*
   Write the data of this object to a stream for the purpose of   serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).    
*  [2.x.377]  This function does not save [1.x.40] member variables of the   current triangulation. Rather, only certain kinds of information are   stored. For more information see the general documentation of this class.  
* [0.x.242]*
   Read the data of this object from a stream for the purpose of   serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).   Throw away the previous content.    
*  [2.x.378]  This function does not reset [1.x.41] member variables of the   current triangulation to the ones of the triangulation that was   previously stored to an archive. Rather, only certain kinds of   information are loaded. For more information see the general   documentation of this class.    
*  [2.x.379]  This function calls the  [2.x.380]  function and   consequently triggers the "clear" signal. After loading all data from the   archive, it then triggers the "create" signal. For more information on   signals, see the general documentation of this class.  
* [0.x.243]*
   Declare the (coarse) face pairs given in the argument of this function as   periodic. This way it is possible to obtain neighbors across periodic   boundaries.     The vector can be filled by the function    [2.x.381]      For more information on periodic boundary conditions see    [2.x.382]   [2.x.383]    and  [2.x.384] .    
*  [2.x.385]  Before this function can be used the Triangulation has to be   initialized and must not be refined.  
* [0.x.244]*
   Return the periodic_face_map.  
* [0.x.245]*
   Return vector filled with the used reference-cell types of this   triangulation.  
* [0.x.246]*
   Indicate if the triangulation only consists of hypercube-like cells, i.e.,   lines, quadrilaterals, or hexahedra.  
* [0.x.247]*
   Write and read the data of this object from a stream for the purpose   of serialization. using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.248]*
    [2.x.386]  Exceptions    [2.x.387]   
* [0.x.249]*
   Exception    
*  [2.x.388]   
* [0.x.250]*
   The function raising this exception can only operate on an empty   Triangulation, i.e., a Triangulation without grid cells.    
*  [2.x.389]   
* [0.x.251]*
   Trying to re-read a grid, an error occurred.    
*  [2.x.390]   
* [0.x.252]*
   Exception  
*  [2.x.391]   
* [0.x.253]*
   The triangulation level you accessed is empty.    
*  [2.x.392]   
* [0.x.254]*
   Exception    
*  [2.x.393]   
* [0.x.255]*
   Exception     Requested boundary_id not found    
*  [2.x.394]   
* [0.x.256]*
   Exception    
*  [2.x.395]   
* [0.x.257]    [2.x.396]   
* [0.x.258]*
   Do some smoothing in the process of refining the triangulation. See the   general doc of this class for more information about this.  
* [0.x.259]*
   Vector caching all reference-cell types of the given triangulation   (also in the distributed case).  
* [0.x.260]*
   Write a bool vector to the given stream, writing a pre- and a postfix   magic number. The vector is written in an almost binary format, i.e. the   bool flags are packed but the data is written as ASCII text.     The flags are stored in a binary format: for each  [2.x.397]  a  [2.x.398]  bit is   stored, a  [2.x.399]  bit otherwise.  The bits are stored as <tt>unsigned   char</tt>, thus avoiding endianness. They are written to  [2.x.400]  in plain   text, thus amounting to 3.6 bits in the output per bits in the input on   the average. Other information (magic numbers and number of elements of   the input vector) is stored as plain text as well. The format should   therefore be interplatform compatible.  
* [0.x.261]*
   Re-read a vector of bools previously written by  [2.x.401]  and   compare with the magic numbers.  
* [0.x.262]*
   Recreate information about periodic neighbors from   periodic_face_pairs_level_0.  
* [0.x.263]*
   Update the internal reference_cells vector.  
* [0.x.264]*
   Policy with the Triangulation-specific tasks related to creation,   refinement, and coarsening.  
* [0.x.265]*
   If add_periodicity() is called, this variable stores the given periodic   face pairs on level 0 for later access during the identification of ghost   cells for the multigrid hierarchy and for setting up the   periodic_face_map.  
* [0.x.266]*
   If add_periodicity() is called, this variable stores the active periodic   face pairs.  
* [0.x.267]*
    [2.x.402]  Cell iterator functions for internal use    [2.x.403]   
* [0.x.268]*
   Declare a number of iterator types for raw iterators, i.e., iterators   that also iterate over holes in the list of cells left by cells that have   been coarsened away in previous mesh refinement cycles.     Since users should never have to access these internal properties of how   we store data, these iterator types are made private.  
* [0.x.269]*
   Iterator to the first cell, used or not, on level  [2.x.404]  If a level   has no cells, a past-the-end iterator is returned.  
* [0.x.270]*
   Return a raw iterator which is the first iterator not on level. If  [2.x.405]    level is the last level, then this returns <tt>end()</tt>.  
* [0.x.271]    [2.x.406]   
* [0.x.272]*
    [2.x.407]  Line iterator functions for internal use    [2.x.408]   
* [0.x.273]*
   Iterator to the first line, used or not, on level  [2.x.409]  If a level   has no lines, a past-the-end iterator is returned.  If lines are no   cells, i.e. for  [2.x.410]  no  [2.x.411]  argument must be given.  The same   applies for all the other functions above, of course.  
* [0.x.274]*
   Iterator to the first used line on level  [2.x.412]     
*  [2.x.413]  The given  [2.x.414]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.415]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.42] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.416]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.417]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.275]*
   Iterator to the first active line on level  [2.x.418]     
*  [2.x.419]  The given  [2.x.420]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.421]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.43] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.422]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.423]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.276]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states.  
* [0.x.277]    [2.x.424]   
* [0.x.278]*
    [2.x.425]  Quad iterator functions for internal use    [2.x.426]   
* [0.x.279]*
   Iterator to the first quad, used or not, on the given level. If a level   has no quads, a past-the-end iterator is returned.  If quads are no   cells, i.e. for  [2.x.427]  no level argument must be given.    
*  [2.x.428]  The given  [2.x.429]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.430]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.44] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.431]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.432]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.280]*
   Iterator to the first used quad on level  [2.x.433]     
*  [2.x.434]  The given  [2.x.435]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.436]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.45] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.437]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.438]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.281]*
   Iterator to the first active quad on level  [2.x.439]     
*  [2.x.440]  The given  [2.x.441]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.442]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.46] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.443]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.444]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.282]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states.  
* [0.x.283]    [2.x.445]   
* [0.x.284]*
    [2.x.446]  Hex iterator functions for internal use    [2.x.447]   
* [0.x.285]*
   Iterator to the first hex, used or not, on level  [2.x.448]  If a level has   no hexes, a past-the-end iterator is returned.    
*  [2.x.449]  The given  [2.x.450]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.451]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.47] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.452]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.453]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.286]*
   Iterator to the first used hex on level  [2.x.454]     
*  [2.x.455]  The given  [2.x.456]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.457]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.48] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.458]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.459]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.287]*
   Iterator to the first active hex on level  [2.x.460]     
*  [2.x.461]  The given  [2.x.462]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.463]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.49] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.464]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.465]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.288]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states.  
* [0.x.289]    [2.x.466]   
* [0.x.290]*
   The (public) function clear() will only work when the triangulation is   not subscribed to by other users. The clear_despite_subscriptions()   function now allows the triangulation being cleared even when there are   subscriptions.     Make sure, you know what you do, when calling this function, as its use   is reasonable in very rare cases, only. For example, when the   subscriptions were for the initially empty Triangulation and the   Triangulation object wants to release its memory before throwing an   assertion due to input errors (e.g. in the create_triangulation()   function).  
* [0.x.291]*
   Reset triangulation policy.  
* [0.x.292]*
   For all cells, set the active cell indices so that active cells know the   how many-th active cell they are, and all other cells have an invalid   value. This function is called after mesh creation, refinement, and   serialization.  
* [0.x.293]*
   Reset global cell ids and globale level cell ids.  
* [0.x.294]*
   Reset cache for the cells' vertex indices.  
* [0.x.295]*
   Refine all cells on all levels which were previously flagged for   refinement.     Note, that this function uses the <tt>line->user_flags</tt> for   <tt>dim=2,3</tt> and the <tt>quad->user_flags</tt> for <tt>dim=3</tt>.     The function returns a list of cells that have produced children that   satisfy the criteria of    [2.x.467]  "distorted cells"   if the  [2.x.468]  flag was specified upon   creation of this object, at  
* [0.x.296]*
   Coarsen all cells which were flagged for coarsening, or rather: delete   all children of those cells of which all child cells are flagged for   coarsening and several other constraints hold (see the general doc of   this class).  
* [0.x.297]*
   Make sure that either all or none of the children of a cell are tagged   for coarsening.  
* [0.x.298]*
   Translate the unique id of a coarse cell to its index. See the glossary   entry on    [2.x.469]  "coarse cell IDs"   for more information.    
*  [2.x.470]  For serial and shared triangulation both id and index are the same.         For distributed triangulations setting both might differ, since the         id might correspond to a global id and the index to a local id.      [2.x.471]  coarse_cell_id Unique id of the coarse cell.    [2.x.472]  Index of the coarse cell within the current triangulation.  
* [0.x.299]*
   Translate the index of coarse cell to its unique id. See the glossary   entry on    [2.x.473]  "coarse cell IDs"   for more information.    
*  [2.x.474]  See the note of the method   coarse_cell_id_to_coarse_cell_index().      [2.x.475]  coarse_cell_index Index of the coarse cell.    [2.x.476]  Id of the coarse cell.  
* [0.x.300]*
   Array of pointers pointing to the objects storing the cell data on the   different levels.  
* [0.x.301]*
   Pointer to the faces of the triangulation. In 1d this contains nothing,   in 2D it contains data concerning lines and in 3D quads and lines.  All   of these have no level and are therefore treated separately.  
* [0.x.302]*
   Array of the vertices of this triangulation.  
* [0.x.303]*
   Array storing a bit-pattern which vertices are used.  
* [0.x.304]*
   Collection of manifold objects. We store only objects, which are not of   type FlatManifold.  
* [0.x.305]*
   Flag indicating whether anisotropic refinement took place.  
* [0.x.306]*
   A flag that determines whether we are to check for distorted cells upon   creation and refinement of a mesh.  
* [0.x.307]*
   Cache to hold the numbers of lines, quads, hexes, etc. These numbers are   set at the end of the refinement and coarsening functions and enable   faster access later on. In the old days, whenever one wanted to access   one of these numbers, one had to perform a loop over all lines, e.g., and   count the elements until we hit the end iterator. This is time consuming   and since access to the number of lines etc is a rather frequent   operation, this was not an optimal solution.  
* [0.x.308]*
   A map that relates the number of a boundary vertex to the boundary   indicator. This field is only used in 1d. We have this field because we   store boundary indicator information with faces in 2d and higher where we   have space in the structures that store data for faces, but in 1d there   is no such space for faces.     The field is declared as a pointer for a rather mundane reason: all other   fields of this class that can be modified by the TriaAccessor hierarchy   are pointers, and so these accessor classes store a const pointer to the   triangulation. We could no longer do so for TriaAccessor<0,1,spacedim> if   this field (that can be modified by  [2.x.477]  were   not a pointer.  
* [0.x.309]*
   A map that relates the number of a boundary vertex to the manifold   indicator. This field is only used in 1d. We have this field because we   store manifold indicator information with faces in 2d and higher where we   have space in the structures that store data for faces, but in 1d there   is no such space for faces.    
*  [2.x.478]  Manifold objects are pretty useless for points since they are   neither refined nor are their interiors mapped. We nevertheless allow   storing manifold ids for points to be consistent in dimension-independent   programs.     The field is declared as a pointer for a rather mundane reason: all other   fields of this class that can be modified by the TriaAccessor hierarchy   are pointers, and so these accessor classes store a const pointer to the   triangulation. We could no longer do so for TriaAccessor<0,1,spacedim> if   this field (that can be modified by  [2.x.479]  were   not a pointer.  
* [0.x.310]