[0.x.0]*
 This namespace is a collection of algorithms working on triangulations, such as shifting or rotating triangulations, but also finding a cell that contains a given point. See the descriptions of the individual functions for more information.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
    [2.x.1]  Information about meshes and cells  
* [0.x.2]*
   Return the diameter of a triangulation. The diameter is computed using   only the vertices, i.e. if the diameter should be larger than the maximal   distance between boundary vertices due to a higher order mapping, then   this function will not catch this.  
* [0.x.3]*
   Compute the volume (i.e. the dim-dimensional measure) of the   triangulation. We compute the measure using the integral  [2.x.2]  where  [2.x.3]  are the cells of the given triangulation. The integral   is approximated via quadrature for which we need the mapping argument.     If the triangulation is a dim-dimensional one embedded in a higher   dimensional space of dimension spacedim, then the value returned is the   dim-dimensional measure. For example, for a two-dimensional triangulation   in three-dimensional space, the value returned is the area of the surface   so described. (This obviously makes sense since the spacedim-dimensional   measure of a dim-dimensional triangulation would always be zero if dim  [2.x.4]    spacedim.     This function also works for objects of type    [2.x.5]  in which case the function is a   collective operation.      [2.x.6]  tria The triangulation.    [2.x.7]  mapping An optional argument used to denote the mapping that   should be used when describing whether cells are bounded by straight or   curved faces. The default is to use a  [2.x.8]  mapping, which corresponds to   straight lines bounding the cells.    [2.x.9]  The dim-dimensional measure of the domain described by the   triangulation, as discussed above.  
* [0.x.4]*
   Return an approximation of the diameter of the smallest active cell of a   triangulation. See  [2.x.10]  for an example of use of this function.     Notice that, even if you pass a non-trivial mapping, the returned value is   computed only using information on the vertices of the triangulation,   possibly transformed by the mapping. While this is accurate most of the   times, it may fail to give the correct result when the triangulation   contains very distorted cells.  
* [0.x.5]*
   Return an approximation of the diameter of the largest active cell of a   triangulation.     Notice that, even if you pass a non-trivial mapping to this function, the   returned value is computed only using information on the vertices of the   triangulation, possibly transformed by the mapping. While this is accurate   most of the times, it may fail to give the correct result when the   triangulation contains very distorted cells.  
* [0.x.6]*
   Given a list of vertices (typically obtained using    [2.x.11]  as the first, and a list of vertex indices   that characterize a single cell as the second argument, return the   measure (area, volume) of this cell. If this is a real cell, then you can   get the same result using  [2.x.12] , but this   function also works for cells that do not exist except that you make it   up by naming its vertices from the list.      [2.x.13]  Use the more general function which takes an ArrayView instead.  
* [0.x.7]*
   Given a list of vertices (typically obtained using    [2.x.14]  as the first, and a list of vertex indices   that characterize a single cell as the second argument, return the   measure (area, volume) of this cell. If this is a real cell, then you can   get the same result using  [2.x.15] , but this   function also works for cells that do not exist except that you make it   up by naming its vertices from the list.     The parameter  [2.x.16]  is expected to have    [2.x.17]  entries. A  [2.x.18]  is implicitly   convertible to an ArrayView, so it can be passed directly. See the   ArrayView class for more information.    
*  [2.x.19]  This function is only implemented for codimension zero objects.  
* [0.x.8]*
   This function computes an affine approximation of the map from the unit   coordinates to the real coordinates of the form  [2.x.20]  by a least squares fit of this affine function to the    [2.x.21]  vertices representing a quadrilateral or hexahedral cell   in `spacedim` dimensions. The result is returned as a pair with the   matrix [1.x.0] as the first argument and the vector [1.x.1] describing   distance of the plane to the origin.     For any valid mesh cell whose geometry is not degenerate, this operation   results in a unique affine mapping, even in cases where the actual   transformation by a bi-/trilinear or higher order mapping might be   singular. The result is exact in case the transformation from the unit to   the real cell is indeed affine, such as in one dimension or for Cartesian   and affine (parallelogram) meshes in 2D/3D.     This approximation is underlying the function    [2.x.22]  function.     For exact transformations to the unit cell, use    [2.x.23]   
* [0.x.9]*
   Computes an aspect ratio measure for all locally-owned active cells and   fills a vector with one entry per cell, given a  [2.x.24]  and    [2.x.25]  The size of the vector that is returned equals the number of   active cells. The vector contains zero for non locally-owned cells. The   aspect ratio of a cell is defined as the ratio of the maximum to minimum   singular value of the Jacobian, taking the maximum over all quadrature   points of a quadrature rule specified via  [2.x.26]  For example, for   the special case of rectangular elements in 2d with dimensions  [2.x.27]  and  [2.x.28]    ( [2.x.29] ), this function returns the usual aspect ratio definition    [2.x.30] . The above definition using singular values is a generalization to   arbitrarily deformed elements. This function is intended to be used for    [2.x.31]  space dimensions, but it can also be used for  [2.x.32]  returning a   value of 1.    
*  [2.x.33]  Inverted elements do not throw an exception. Instead, a value of inf   is written into the vector in case of inverted elements.    
*  [2.x.34]  Make sure to use enough quadrature points for a precise calculation   of the aspect ratio in case of deformed elements.    
*  [2.x.35]  In parallel computations the return value will have the length   n_active_cells but the aspect ratio is only computed for the cells that   are locally owned and placed at index  [2.x.36]    respectively. All other values are set to 0.  
* [0.x.10]*
   Computes the maximum aspect ratio by taking the maximum over all cells.    
*  [2.x.37]  When running in parallel with a Triangulation that supports MPI,   this is a collective call and the return value is the maximum over all   processors.  
* [0.x.11]*
   Compute the smallest box containing the entire triangulation.     If the input triangulation is a  [2.x.38]    then each processor will compute a bounding box enclosing all locally   owned, ghost, and artificial cells. In the case of a domain without curved   boundaries, these bounding boxes will all agree between processors because   the union of the areas occupied by artificial and ghost cells equals the   union of the areas occupied by the cells that other processors own.   However, if the domain has curved boundaries, this is no longer the case.   The bounding box returned may be appropriate for the current processor,   but different from the bounding boxes computed on other processors.  
* [0.x.12]*
   Return the point on the geometrical object  [2.x.39]  closest to the given   point  [2.x.40]  For example, if  [2.x.41]  is a one-dimensional line   or edge, then the returned point will be a point on the geodesic that   connects the vertices as the manifold associated with the object sees it   (i.e., the geometric line may be curved if it lives in a higher   dimensional space). If the iterator points to a quadrilateral in a higher   dimensional space, then the returned point lies within the convex hull of   the vertices of the quad as seen by the associated manifold.    
*  [2.x.42]  This projection is usually not well-posed since there may be   multiple points on the object that minimize the distance. The algorithm   used in this function is robust (and the output is guaranteed to be on   the given  [2.x.43]  but may only provide a few correct digits if the   object has high curvature. If your manifold supports it then the   specialized function  [2.x.44]  may perform better.  
* [0.x.13]*
   Return the arrays that define the coarse mesh of a Triangulation. This   function is the inverse of  [2.x.45]      The return value is a tuple with the vector of vertices, the vector of   cells, and a SubCellData structure. The latter contains additional   information about faces and lines.     This function is useful in cases where one needs to deconstruct a   Triangulation or manipulate the numbering of the vertices in some way: an   example is  [2.x.46]   
* [0.x.14]*
    [2.x.47]  Functions supporting the creation of meshes  
* [0.x.15]*
   Remove vertices that are not referenced by any of the cells. This   function is called by all  [2.x.48]  functions to eliminate   vertices that are listed in the input files but are not used by the cells   in the input file. While these vertices should not be in the input from   the beginning, they sometimes are, most often when some cells have been   removed by hand without wanting to update the vertex lists, as they might   be lengthy.     This function is called by all  [2.x.49]  functions as the   triangulation class requires them to be called with used vertices only.   This is so, since the vertices are copied verbatim by that class, so we   have to eliminate unused vertices beforehand.     Not implemented for the codimension one case.  
* [0.x.16]*
   Remove vertices that are duplicated, due to the input of a structured   grid, for example. If these vertices are not removed, the faces bounded   by these vertices become part of the boundary, even if they are in the   interior of the mesh.     This function is called by some  [2.x.50]  functions. Only   the vertices with indices in  [2.x.51]  are tested for   equality. This speeds up the algorithm, which is, for worst-case hyper   cube geometries  [2.x.52]  in 2D and  [2.x.53]  in 3D: quite slow.   However, if you wish to consider all vertices, simply pass an empty   vector. In that case, the function fills  [2.x.54]  with all   vertices.     Two vertices are considered equal if their difference in each coordinate   direction is less than  [2.x.55]   
* [0.x.17]*
   Grids generated by grid generators may have an orientation of cells which   is the inverse of the orientation required by deal.II.     In 2d and 3d this function checks whether all cells have negative or   positive measure/volume. In the former case, all cells are inverted. It   does nothing in 1d.     The inversion of cells might also work when only a subset of all cells   have negative volume. However, grids consisting of a mixture of negative   and positively oriented cells are very likely to be broken. Therefore, an   exception is thrown, in case cells are not uniformly oriented.    
*  [2.x.56]  This function should be called before  [2.x.57]       [2.x.58]  all_vertices The vertices of the mesh.    [2.x.59]  cells The array of CellData objects that describe the mesh's topology.  
* [0.x.18]*
   Given a vector of CellData objects describing a mesh, reorder their   vertices so that all lines are consistently oriented.     The expectations on orientation and a discussion of this function are   available in the  [2.x.60]  "reordering module".      [2.x.61]  cells The array of CellData objects that describe the mesh's topology.  
* [0.x.19]*
    [2.x.62]  Rotating, stretching and otherwise transforming meshes  
* [0.x.20]*
   Transform the vertices of the given triangulation by applying the   function object provided as first argument to all its vertices.     The transformation given as argument is used to transform each vertex.   Its respective type has to offer a function-like syntax, i.e. the   predicate is either an object of a type that has an <tt>operator()</tt>,   or it is a pointer to the function. In either case, argument and return   value have to be of type <tt>Point [2.x.63]     
*  [2.x.64]  The transformations that make sense to use with this function     should have a Jacobian with a positive determinant. For example,     rotation, shearing, stretching, or scaling all satisfy this (though     there is no requirement that the transformation used actually is     linear, as all of these examples are). On the other hand, reflections     or inversions have a negative determinant of the Jacobian. The     current function has no way of asserting a positive determinant     of the Jacobian, but if you happen to use such a transformation,     the result will be a triangulation in which cells have a negative     volume.    
*  [2.x.65]  If you are using a  [2.x.66]  you will   have hanging nodes in your local Triangulation even if your "global" mesh   has no hanging nodes. This will cause issues with wrong positioning of   hanging nodes in ghost cells if you call the current functions: The   vertices of all locally owned cells will be correct, but the vertices of   some ghost cells may not. This means that computations like   KellyErrorEstimator may give wrong answers.    
*  [2.x.67]  This function is in general not compatible with manifolds attached   to the triangulation. For example, in order to refine the grid (using   manifolds) after the grid transformation, you have to make sure that   the original manifold is still valid for the transformed geometry. This   does not hold in general, and it is necessary to clear the manifold and   attach a new one for the transformed geometry in these cases.   If you want to perform refinements according to the original   manifold description attached to the triangulation, you should first do   the refinements, subsequently deactivate all manifolds, and finally call   the transform() function. The result is a triangulation with correctly   transformed vertices, but otherwise straight-sided elements. The   following procedure is recommended  
* [1.x.2]
*      This function is used in the "Possibilities for extensions" section of    [2.x.68] . It is also used in  [2.x.69]  and  [2.x.70] .  
* [0.x.21]*
   Shift each vertex of the triangulation by the given shift vector. This   function uses the transform() function above, so the requirements on the   triangulation stated there hold for this function as well.  
* [0.x.22]*
   Rotate all vertices of the given two-dimensional triangulation in   counter-clockwise sense around the origin of the coordinate system by the   given angle (given in radians, rather than degrees). This function uses   the transform() function above, so the requirements on the triangulation   stated there hold for this function as well.    
*  [2.x.71]  This function is only supported for dim=2.  
* [0.x.23]*
   Rotate all vertices of the given  [2.x.72]  in counter-clockwise   direction around the axis with the given index. Otherwise like the   function above.      [2.x.73]  angle Angle in radians to rotate the Triangulation by.    [2.x.74]  axis Index of the coordinate axis to rotate around, keeping   that coordinate fixed (0=x axis, 1=y axis, 2=z axis).    [2.x.75]  triangulation The Triangulation object to rotate.    
*  [2.x.76]  Implemented for dim=1, 2, and 3.  
* [0.x.24]*
   Transform the given triangulation smoothly to a different domain where,   typically, each of the vertices at the boundary of the triangulation is   mapped to the corresponding points in the  [2.x.77]  map.     The unknown displacement field  [2.x.78]  in direction  [2.x.79]  is   obtained from the minimization problem [1.x.3]   subject to prescribed constraints. The minimizer is obtained by solving the   Laplace equation of the dim components of a displacement field that maps   the current   domain into one described by  [2.x.80]  . Linear finite elements with   four Gaussian quadrature points in each direction are used. The difference   between the vertex positions specified in  [2.x.81]  and their current   value in  [2.x.82]  therefore represents the prescribed values of this   displacement field at the boundary of the domain, or more precisely at all   of those locations for which  [2.x.83]  provides values (which may be   at part of the boundary, or even in the interior of the domain). The   function then evaluates this displacement field at each unconstrained   vertex and uses it to place the mapped vertex where the displacement   field locates it. Because the solution of the Laplace equation is smooth,   this guarantees a smooth mapping from the old domain to the new one.      [2.x.84]  new_points The locations where a subset of the existing   vertices are to be placed. Typically, this would be a map from the vertex   indices of all nodes on the boundary to their new locations, thus   completely specifying the geometry of the mapped domain. However, it may   also include interior points if necessary and it does not need to include   all boundary vertices (although you then lose control over the exact   shape of the mapped domain).      [2.x.85]  tria The Triangulation object. This object is changed in-   place, i.e., the previous locations of vertices are overwritten.      [2.x.86]  coefficient An optional coefficient for the Laplace problem.   Larger values make cells less prone to deformation (effectively   increasing their stiffness). The coefficient is evaluated in the   coordinate system of the old, undeformed configuration of the   triangulation as input, i.e., before the transformation is applied.   Should this function be provided, sensible results can only be expected   if all coefficients are positive.      [2.x.87]  solve_for_absolute_positions If set to  [2.x.88] , the   minimization problem is formulated with respect to the final vertex   positions as opposed to their displacement. The two formulations are   equivalent for   the homogeneous problem (default value of  [2.x.89]  but they   result in very different mesh motion otherwise. Since in most cases one   will be using a non-constant coefficient in displacement formulation, the   default value of this parameter is  [2.x.90] .    
*  [2.x.91]  This function is not currently implemented for the 1d case.  
* [0.x.25]*
   Return a  [2.x.92]  with all vertices of faces located in the boundary      [2.x.93]  tria The Triangulation object.  
* [0.x.26]*
   Scale the entire triangulation by the given factor. To preserve the   orientation of the triangulation, the factor must be positive.     This function uses the transform() function above, so the requirements on   the triangulation stated there hold for this function as well.  
* [0.x.27]*
   Distort the given triangulation by randomly moving around all the   vertices of the grid.  The direction of movement of each vertex is   random, while the length of the shift vector has a value of  [2.x.94]    times the minimal length of the active edges adjacent to this vertex.   Note that  [2.x.95]  should obviously be well below <tt>0.5</tt>.     If  [2.x.96]  is set to  [2.x.97]  (which is the default), then   boundary vertices are not moved.      [2.x.98]  is used for the initialization of the random engine. Its   default value initializes the engine with the same state as in   previous versions of deal.II.  
* [0.x.28]*
   Remove hanging nodes from a grid. If the  [2.x.99]  parameter is set   to  [2.x.100]  (default) this function detects cells with hanging nodes and   refines the neighbours in the direction that removes hanging nodes.   If the  [2.x.101]  parameter is set   to  [2.x.102]  the neighbours refinement is made in each directions.   In order to remove all hanging nodes this procedure has to be repeated:   this could require a large number of iterations.   To avoid this a max number ( [2.x.103]  of iteration is provided.     Consider the following grid:    [2.x.104]       [2.x.105]  ==  [2.x.106]  would return:    [2.x.107]       [2.x.108]  ==  [2.x.109]  would return:    [2.x.110]       [2.x.111]  tria Triangulation to refine.      [2.x.112]  isotropic If true refine cells in each directions, otherwise   (default value) refine the cell in the direction that removes hanging node.      [2.x.113]  max_iterations At each step only closest cells to hanging nodes   are refined. The code may require a lot of iterations to remove all   hanging nodes.  [2.x.114]  is the maximum number of iteration   allowed. If  [2.x.115]  ==  [2.x.116]  this   function continues refining until there are no hanging nodes.    
*  [2.x.117]  In the case of parallel codes, this function should be combined   with  [2.x.118]   
* [0.x.29]*
   Refine a mesh anisotropically such that the resulting mesh is composed by   cells with maximum ratio between dimensions less than  [2.x.119]    This procedure requires an algorithm that may not terminate. Consequently,   it is possible to set a maximum number of iterations through the    [2.x.120]  parameter.     Starting from a cell like this:    [2.x.121]      This function would return:    [2.x.122]       [2.x.123]  tria Triangulation to refine.      [2.x.124]  max_ratio Maximum value allowed among the ratio between   the dimensions of each cell.      [2.x.125]  max_iterations Maximum number of iterations allowed.    
*  [2.x.126]  In the case of parallel codes, this function should be combined   with  [2.x.127]  and    [2.x.128]   
* [0.x.30]*
   Analyze the boundary cells of a mesh, and if one cell is found at   a corner position (with dim adjacent faces on the boundary), and its   dim-dimensional angle fraction exceeds  [2.x.129]    refine globally once, and replace the children of such cell   with children where the corner is no longer offending the given angle   fraction.     If no boundary cells exist with two adjacent faces on the boundary, then   the triangulation is left untouched. If instead we do have cells with dim   adjacent faces on the boundary, then the fraction between the   dim-dimensional   solid angle and dim*pi/2 is checked against the parameter  [2.x.130]    If it is higher, the grid is refined once, and the children of the   offending cell are replaced with some cells that instead respect the limit.   After this process the triangulation is flattened, and all Manifold objects   are restored as they were in the original triangulation.     An example is given by the following mesh, obtained by attaching a   SphericalManifold to a mesh generated using  [2.x.131]     
* [1.x.4]
*       [2.x.132]      The four cells that were originally the corners of a square will give you   some troubles during computations, as the jacobian of the transformation   from the reference cell to those cells will go to zero, affecting the error   constants of the finite element estimates.     Those cells have a corner with an angle that is very close to 180 degrees,   i.e., an angle fraction very close to one.     The same code, adding a call to regularize_corner_cells:  
* [1.x.5]
*    generates a mesh that has a much better behavior w.r.t. the jacobian of   the Mapping:      [2.x.133]      This mesh is very similar to the one obtained by  [2.x.134]    However, using  [2.x.135]  one has the freedom to   choose when to apply the regularization, i.e., one could in principle first   refine a few times, and then call the regularize_corner_cells function:    
* [1.x.6]
*      This generates the following mesh:      [2.x.136]      The function is currently implemented only for dim = 2 and   will throw an exception if called with dim = 3.      [2.x.137]  tria Triangulation to regularize.      [2.x.138]  limit_angle_fraction Maximum ratio of angle or solid   angle that is allowed for a corner element in the mesh.  
* [0.x.31]*
    [2.x.139]  Finding cells and vertices of a triangulation  
* [0.x.32]*
   Given a Triangulation's  [2.x.140]  and a list of  [2.x.141]  call   find_active_cell_around_point() on each element of  [2.x.142]  and return    [2.x.143]  reference positions  [2.x.144]  and a mapping  [2.x.145]  from local   to global indices into  [2.x.146]  .      [2.x.147]  cache The triangulation's  [2.x.148]  .    [2.x.149]  points The point's vector.    [2.x.150]  cell_hint (optional) A cell iterator for a cell which likely   contains the first point of  [2.x.151]       [2.x.152]  A tuple containing the following information:
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.153]  : A vector of all the cells containing at least one of     the  [2.x.154]  .
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.155]  : A vector of vectors of points.  [2.x.156]  contains     the reference positions of all points that fall within the cell  [2.x.157]  .
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.158]  : A vector of vectors of integers, containing the mapping between     local numbering in  [2.x.159]  , and global index in  [2.x.160]  .     If  [2.x.161]  and  [2.x.162]  are the only two points that fall in  [2.x.163]    then  [2.x.164]  and  [2.x.165]  are the reference positions of    [2.x.166]  and  [2.x.167]  in  [2.x.168]  and  [2.x.169]  = a,    [2.x.170]  = b. The function    [2.x.171]    returns  [2.x.172]      The algorithm builds an rtree of  [2.x.173]  to sort them spatially, before   attempting to call find_active_cell_around_point().    
*  [2.x.174]  This function is not implemented for the codimension one case (<tt>spacedim != dim</tt>).    
*  [2.x.175]  If a point is not found inside the mesh, or is lying inside an   artificial cell of a  [2.x.176]  the point is silently   ignored. If you want to infer for which points the search failed, use the   function compute_point_locations_try_all() that also returns a vector of   indices indicating the points for which the search failed.    
*  [2.x.177]  The actual return type of this function, i.e., the type referenced   above as  [2.x.178]  is  
* [1.x.7]
*    The type is abbreviated in the online documentation to improve readability   of this page.    
*  [2.x.179]  This function optimizes the search by making use of    [2.x.180]  which either returns   a cached rtree or builds and stores one. Building an rtree might hinder   the performance if the function is called only once on few points.  
* [0.x.33]*
   This function is similar to  [2.x.181]    but while compute_point_locations() silently ignores all points for which   find_active_cell_around_point() fails, this function also returns a   vector containing the indices of the points for which   find_active_cell_around_point() failed.      [2.x.182]  A tuple containing four elements; the first three   are documented in  [2.x.183]    The last element of the  [2.x.184]  contains the   indices of points which are neither found inside the mesh   nor lie in artificial cells. The  [2.x.185]  equals the   following tuple type:  
* [1.x.8]
*     
*  [2.x.186]  This function is not implemented for the codimension one case (<tt>spacedim != dim</tt>).    
*  [2.x.187]  This function optimizes the search by making use of    [2.x.188]  which either returns   a cached rtree or builds and stores one. Building an rtree might hinder   the performance if the function is called only once on few points.     For a more detailed documentation see    [2.x.189]   
* [0.x.34]*
   Given a  [2.x.190]  and a list of    [2.x.191]  for each process, find the points lying on the locally   owned part of the mesh and compute the quadrature rules for them.   Distributed compute point locations is a function similar to    [2.x.192]  but working for    [2.x.193]  objects and, unlike its serial version, also   for a distributed triangulation (see  [2.x.194]       [2.x.195]  cache a  [2.x.196]  object    [2.x.197]  local_points the array of points owned by the current process.   Every process can have a different array of points which can be empty and   not contained within the locally owned part of the triangulation    [2.x.198]  global_bboxes a vector of vectors of bounding boxes; it   describes the locally owned part of the mesh for each process. The bounding   boxes describing which part of the mesh is locally owned by process with   rank rk are contained in global_bboxes[rk]. The local description can be   obtained from  [2.x.199]  then the   global one can be obtained using either    [2.x.200]  or  [2.x.201]     [2.x.202]  tolerance Tolerance in terms of unit cell coordinates. Depending     on the problem, it might be necessary to adjust the tolerance in order     to be able to identify a cell. Floating     point arithmetic implies that a point will, in general, not lie exactly     on a vertex, edge, or face. In either case, it is not predictable which     of the cells adjacent to a vertex or an edge/face this function returns.     Consequently, algorithms that call this function need to take into     account that the returned cell will only contain the point approximately.    [2.x.203]  A tuple containing the quadrature information     The elements of the output tuple are:
* 

* 
* 

* 
* 

* 
* 
*  - cells : a vector of all cells containing at least one point.
* 

* 
* 

* 
* 

* 
* 
*  - qpoints : a vector of vector of points; containing in  [2.x.204]      the reference positions of all points that fall within the cell  [2.x.205]  .
* 

* 
* 

* 
* 

* 
* 
*  - maps : a vector of vector of integers, containing the mapping between    the numbering in qpoints (previous element of the tuple), and the vector    of local points of the process owning the points.
* 

* 
* 

* 
* 

* 
* 
*  - points : a vector of vector of points.  [2.x.206]  is the point in the    real space corresponding.    to  [2.x.207]  . Notice  [2.x.208]  are the points lying on the locally    owned part of the mesh; thus these can be either copies of  [2.x.209]     or points received from other processes i.e. local_points for other   processes
* 

* 
* 

* 
* 

* 
* 
*  - owners : a vector of vectors;  [2.x.210]  contains the rank of    the process owning the point[i][j] (previous element of the tuple).     The function uses the triangulation's mpi communicator: for this reason it   throws an assert error if the Triangulation is not derived from    [2.x.211]  .     In a serial execution the first three elements of the tuple are the same   as in  [2.x.212]  .     Note: this function is a collective operation.    
*  [2.x.213]  The actual return type of this function, i.e., the type referenced   above as  [2.x.214]  is  
* [1.x.9]
*    The type is abbreviated in the online documentation to improve readability   of this page.  
* [0.x.35]*
     Data structure returned by      [2.x.215]  It provides     information to perform  [2.x.216]      and to set up the communication pattern within      [2.x.217]         
*  [2.x.218]  The name of the fields are chosen with        [2.x.219]  in mind. Here, quantities are       computed at specified arbitrary positioned points (and even on remote       processes in the MPI universe) cell by cell and these values are sent       to requesting processes, which receive the result and resort the       result according to the points.    
* [0.x.36]*
       Information of each point on sending/evaluation side. The elements of       the tuple are as follows: 0) cell level and index, 1) rank of the       owning process, 2) local index of the owning process, 3) reference       position, 4) real position, 5) permutation index within a send buffer.      
* [0.x.37]*
       Ranks to send to.      
* [0.x.38]*
       Pointers of ranges within a send buffer to be sent to the ranks       specified by send_ranks. The size of the send buffer is given       by send_ptrs.back().      
* [0.x.39]*
       Information of each received data value. The elements of the tuple are       as follows: 0) rank of sender, 1) local index, 2) enumeration index.            
*  [2.x.220]  The vector is sorted according to 1), 0), 2).            
*  [2.x.221]  To each point multiple data values might be associated to. This         might be the case if a point coincides with a geometric entity (e.g.,         vertex) that is shared by multiple cells.      
* [0.x.40]*
       Ranks from where data is received.      
* [0.x.41]*
       Pointers of ranges within a receive buffer that are filled by ranks       specified by recv_ranks. The size of the receive buffer is given by       recv_ptrs.back().      
* [0.x.42]*
     A function that fills DistributedComputePointLocationsInternal.     If the input argument  [2.x.222]  is set to false only     the fields needed by      [2.x.223]  are filled.     If the input argument is set to true additional data structures are     set up to be able to setup the communication pattern within      [2.x.224]     
* [0.x.43]*
   Return a map `vertex index
* 
-> Point<spacedim>` containing the used   vertices of the given `container`. The key of the returned map (i.e.,   the first element of the pair above) is the global index in the   triangulation, whereas the value of each pair is the physical   location of the corresponding vertex. The used vertices are obtained by   looping over all cells,   and querying for each cell where its vertices are through the (optional)   `mapping` argument.     In serial Triangulation objects and  [2.x.225]    objects, the size of the returned map   equals  [2.x.226]  (not  [2.x.227]    Note that in  [2.x.228]  objects, only vertices in   locally owned cells and ghost cells are returned, as for all other vertices   their real location might not be known (e.g. for distributed computations   using MappingQEulerian).     If you use the default `mapping`, the returned map satisfies the following   equality:    
* [1.x.10]
*      Notice that the above is not satisfied for mappings that change the   location of vertices, like MappingQEulerian.      [2.x.229]  "MeshType concept".    [2.x.230]  container The container to extract vertices from.    [2.x.231]  mapping The mapping to use to compute the points locations.  
* [0.x.44]*
   Find and return the index of the closest vertex to a given point in the   map of vertices passed as the first argument.      [2.x.232]  vertices A map of index->vertex, as returned by           [2.x.233]     [2.x.234]  p The target point.    [2.x.235]  The index of the vertex that is closest to the target point `p`.  
* [0.x.45]*
   Find and return the index of the used vertex (or marked vertex) in a   given mesh that is located closest to a given point.     This function uses the locations of vertices as stored in the   triangulation. This is usually sufficient, unless you are using a Mapping   that moves the vertices around (for example, MappingQEulerian). In this   case, you should call the function with the same name and with an   additional Mapping argument.      [2.x.236]  mesh A variable of a type that satisfies the requirements of the    [2.x.237]  "MeshType concept".    [2.x.238]  p The point for which we want to find the closest vertex.    [2.x.239]  marked_vertices An array of bools indicating which   vertices of  [2.x.240]  will be considered within the search   as the potentially closest vertex. On receiving a non-empty    [2.x.241]  the function will   only search among  [2.x.242]  for the closest vertex.   The size of this array should be equal to the value returned by    [2.x.243]  for the triangulation underlying the given mesh   (as opposed to the value returned by  [2.x.244]     [2.x.245]  The index of the closest vertex found.  
* [0.x.46]*
   Find and return the index of the used vertex (or marked vertex) in a   given mesh that is located closest to a given point. Use the given   mapping to compute the actual location of the vertices.     If the Mapping does not modify the position of the mesh vertices (like,   for example, MappingQEulerian does), then this function is equivalent to   the one with the same name, and without the `mapping` argument.      [2.x.246]  mapping A mapping used to compute the vertex locations    [2.x.247]  mesh A variable of a type that satisfies the requirements of the    [2.x.248]  "MeshType concept".    [2.x.249]  p The point for which we want to find the closest vertex.    [2.x.250]  marked_vertices An array of bools indicating which   vertices of  [2.x.251]  will be considered within the search   as the potentially closest vertex. On receiving a non-empty    [2.x.252]  the function will   only search among  [2.x.253]  for the closest vertex.   The size of this array should be equal to the value returned by    [2.x.254]  for the triangulation underlying the given mesh   (as opposed to the value returned by  [2.x.255]     [2.x.256]  The index of the closest vertex found.  
* [0.x.47]*
   Find and return a vector of iterators to active cells that surround a   given vertex with index  [2.x.257]      For locally refined grids, the vertex itself might not be a vertex of all   adjacent cells that are returned. However, it will always be either a   vertex of a cell or be a hanging node located on a face or an edge of it.      [2.x.258]  container A variable of a type that satisfies the requirements of   the    [2.x.259]  "MeshType concept".    [2.x.260]  vertex_index The index of the vertex for which we try to find   adjacent cells.    [2.x.261]  A vector of cells that lie adjacent to the given vertex.    
*  [2.x.262]  It isn't entirely clear at this time whether the function does the   right thing with anisotropically refined meshes. It needs to be checked   for this case.  
* [0.x.48]*
   Find an active non-artificial cell that surrounds a given point  [2.x.263]  The return type   is a pair of an iterator to the active cell along with the unit cell   coordinates of the point.     The algorithm used in this function proceeds by first looking for the   vertex located closest to the given point, see    [2.x.264]  Secondly, all adjacent cells to this   vertex are found in the mesh, see    [2.x.265]  Lastly, for each of these   cells, the function tests whether the point is inside. This check is   performed using the given  [2.x.266]  argument to determine whether cells   have straight or curved boundaries.     If a point lies on the boundary of two or more cells, then the algorithm   tries to identify the cell that is of highest refinement level.     If the point requested does not lie in a locally-owned or ghost cell,   then this function will return the (invalid) MeshType<dim,  [2.x.267]    iterator. This case can be handled similarly to the various  [2.x.268]    and  [2.x.269]  functions.      [2.x.270]  mapping The mapping used to determine whether the given point is     inside a given cell.    [2.x.271]  mesh A variable of a type that satisfies the requirements of the      [2.x.272]  "MeshType concept".    [2.x.273]  p The point for which we want to find the surrounding cell.    [2.x.274]  marked_vertices An array of `bool`s indicating whether an     entry in the vertex array should be considered     (and the others must be ignored) as the potentially     closest vertex to the specified point. On specifying a non-default      [2.x.275]  find_closest_vertex() would     only search among  [2.x.276]  for the closest vertex.     The size of this array should be equal to n_vertices() of the     triangulation (as opposed to n_used_vertices() ). The motivation of using      [2.x.277]  is to cut down the search space of vertices if one has     a priori knowledge of a collection of vertices that the point of interest     may be close to.    [2.x.278]  tolerance Tolerance in terms of unit cell coordinates. Depending     on the problem, it might be necessary to adjust the tolerance in order     to be able to identify a cell. Floating     point arithmetic implies that a point will, in general, not lie exactly     on a vertex, edge, or face. In either case, it is not predictable which     of the cells adjacent to a vertex or an edge/face this function returns.     Consequently, algorithms that call this function need to take into     account that the returned cell will only contain the point approximately.      [2.x.279]  A pair of an iterators into the mesh that points to the   surrounding cell, and of the unit cell coordinates of that point. This   local position might be located slightly outside an actual unit cell,   due to numerical roundoff. Therefore, the point returned by this function   should be projected onto the unit cell, using    [2.x.280]   This is not automatically performed   by the algorithm. The returned cell can be a locally-owned cell or a   ghost cell (but not an artificial cell). The returned cell might be a   ghost cell even if the given point is a vertex of a locally owned cell.   The reason behind is that this is the only way to guarantee that all   processors that participate in a parallel triangulation will agree which   cell contains a point. For example, if two processors come together   at one vertex and the function is called with this vertex, then one   processor will return a locally owned cell and the other one a ghost cell.  
* [0.x.49]*
   A version of the above function that assumes straight boundaries and   as a consequence simply calls the above function using MappingQ1 for   the mapping argument.      [2.x.281]  An iterator into the mesh that points to the surrounding cell.  
* [0.x.50]*
   Another version where we use that mapping on a given   cell that corresponds to the active finite element index of that cell.   This is obviously only useful for hp-problems, since the active finite   element index for all other DoF handlers is always zero.  
* [0.x.51]*
   Finding an active non-artificial cell around a point can be very expensive   in terms of computational costs. This function aims at providing a fast   version of the above functions by using a space-tree to speed up the   geometry search.      [2.x.282]  cache Object with information about the space-tree of a triangulation,   see  [2.x.283]     [2.x.284]  p The point for which we want to find the surrounding cell.    [2.x.285]  cell_hint Gives a hint for the geometry search, which is beneficial   if a-priori knowledge is available regarding the cell on which the point   may likely be located. A typical use case would be that this search has   to be done for an array of points that are close to each other and where   the adjacent cell of the previous point is a good hint for the next point   in the array.    [2.x.286]  marked_vertices See above.    [2.x.287]  tolerance See above.       The following code example shows how to use this function:    
* [1.x.11]
*   
* [0.x.52]*
   A version of the previous function that exploits an already existing   map between vertices and cells (constructed using the function    [2.x.288]  a map of vertex_to_cell_centers (obtained   through  [2.x.289]  and   optionally an RTree constructed from the used vertices of the   Triangulation.    
*  [2.x.290]  All of these structures can be queried from a    [2.x.291]  object. Note, however, that in this case MeshType   has to be Triangulation, so that it might be more appropriate to directly   call the function above with argument `cache` in this case.  
* [0.x.53]*
   As compared to the functions above, this function identifies all active   non-artificial cells around a point for a given tolerance level `tolerance`   in terms of unit coordinates. Given a first cell with reference coordinates   as parameter    [2.x.292]  e.g. obtained by one of the functions above, all   corresponding neighboring cells with points in unit coordinates are also   identified.     This function is useful e.g. for discontinuous function spaces where, for   the case the given point `p` lies on a vertex, edge or face, several   cells might hold independent values of the solution that get combined in   some way in a user code.     This function is used as follows  
* [1.x.12]
*   
* [0.x.54]*
   A variant of the previous function that internally calls one of the   functions find_active_cell_around_point() to obtain a first cell, and   subsequently adds all other active non-artificial cells by calling the   function find_all_active_cells_around_point() above.  
* [0.x.55]*
   Return a list of all descendants of the given cell that are active. For   example, if the current cell is once refined but none of its children are   any further refined, then the returned list will contain all its   children.     If the current cell is already active, then the returned list is empty   (because the cell has no children that may be active).      [2.x.293]  MeshType A type that satisfies the requirements of the    [2.x.294]  "MeshType concept".    [2.x.295]  cell An iterator pointing to a cell of the mesh.    [2.x.296]  A list of active descendants of the given cell    
*  [2.x.297]  Since in C++ the MeshType template argument can not be deduced from   a function call, you will have to specify it after the function name, as   for example in  
* [1.x.13]
*   
* [0.x.56]*
   Extract the active cells around a given cell  [2.x.298]  and return them in   the vector  [2.x.299]  These neighbors are specifically the   [1.x.14] neighbors of a cell or, if that neighbor is further   refined, its active children that border on that face. On the other   hand, the neighbors returned do not include cells that lie, for   example, diagonally opposite to a vertex but are not face neighbors   themselves. (In 3d, it also does not include cells that are   adjacent to one of the edges of the current cell, but are not   face neighbors.)      [2.x.300]  MeshType A type that satisfies the requirements of the    [2.x.301]  "MeshType concept".    [2.x.302]  cell An iterator pointing to a cell of the mesh.    [2.x.303]  active_neighbors A list of active descendants of the given   cell    
*  [2.x.304]  Since in C++ the MeshType template argument can not be deduced from   a function call, you will have to specify it after the function name, as   for example in  
* [1.x.15]
*   
* [0.x.57]*
   Extract and return the active cell layer around a subdomain (set of   active cells) in the  [2.x.305]  (i.e. those that share a common set of   vertices with the subdomain but are not a part of it). Here, the   "subdomain" consists of exactly all of those cells for which the  [2.x.306]    predicate returns  [2.x.307]      An example of a custom predicate is one that checks for a given material   id  
* [1.x.16]
*    and we can then extract the layer of cells around this material with the   following call:  
* [1.x.17]
*      Predicates that are frequently useful can be found in namespace   IteratorFilters. For example, it is possible to extract a layer   of cells around all of those cells with a given material id,  
* [1.x.18]
*    or around all cells with one of a set of active FE indices for a DoFHandler   with hp-capabilities  
* [1.x.19]
*    Note that in the last two examples we ensure that the predicate returns   true only for locally owned cells. This means that the halo layer will   not contain any artificial cells.      [2.x.308]  MeshType A type that satisfies the requirements of the    [2.x.309]  "MeshType concept".    [2.x.310]  mesh A mesh (i.e. objects of type Triangulation or DoFHandler).    [2.x.311]  predicate A function  (or object of a type with an operator())   defining the subdomain around which the halo layer is to be extracted. It   is a function that takes in an active cell and returns a boolean.    [2.x.312]  A list of active cells sharing at least one common vertex with   the predicated subdomain.  
* [0.x.58]*
   Extract and return the cell layer around a subdomain (set of   cells) on a specified level of the  [2.x.313]  (i.e. those cells on   that level that share a common set of vertices with the subdomain   but are not a part of it). Here, the "subdomain" consists of exactly   all of those cells for which the  [2.x.314]  returns  [2.x.315]   
* [0.x.59]*
   Extract and return ghost cells which are the active cell layer around all   locally owned cells. This is most relevant for    [2.x.316]  where it will return a subset of all   ghost cells on a processor, but for  [2.x.317]    this will return all the ghost cells.      [2.x.318]  MeshType A type that satisfies the requirements of the    [2.x.319]  "MeshType concept".    [2.x.320]  mesh A mesh (i.e. objects of type Triangulation or DoFHandler).    [2.x.321]  A list of ghost cells  
* [0.x.60]*
   Extract and return the set of active cells within a geometric distance of    [2.x.322]  around a subdomain (set of active cells) in the  [2.x.323]    Here, the "subdomain" consists of exactly all of   those cells for which the  [2.x.324]  returns  [2.x.325]      The function first computes the cells that form the 'surface' of the   subdomain that consists of all of the active cells for which the predicate   is true. Using compute_bounding_box(), a bounding box is   computed for this subdomain and extended by  [2.x.326]  These   cells are called interior subdomain boundary cells.   The active cells with all of their vertices outside the extended   bounding box are ignored.   The cells that are inside the extended bounding box are then checked for   their proximity to the interior subdomain boundary cells. This implies   checking the distance between a pair of arbitrarily oriented cells,   which is not trivial in general. To simplify this, the algorithm checks   the distance between the two enclosing spheres of the cells.   This will definitely result in slightly more cells being marked but   also greatly simplifies the arithmetic complexity of the algorithm.      [2.x.327]    The image shows a mesh generated by subdivided_hyper_rectangle(). The cells   are marked using three different colors. If the grey colored cells in the   image are the cells for which the predicate is true, then the function   compute_active_cell_layer_within_distance() will return a set of cell   iterators corresponding to the cells colored in red.   The red colored cells are the active cells that are within a given   distance to the grey colored cells.      [2.x.328]  MeshType A type that satisfies the requirements of the    [2.x.329]  "MeshType concept".    [2.x.330]  mesh A mesh (i.e. objects of type Triangulation or DoFHandler).    [2.x.331]  predicate A function  (or object of a type with an operator())   defining the subdomain around which the halo layer is to be extracted. It   is a function that takes in an active cell and returns a boolean.    [2.x.332]  layer_thickness specifies the geometric distance within   which the function searches for active cells from the predicate domain.   If the minimal distance between the enclosing sphere of the an   active cell and the enclosing sphere of any of the cells for which   the  [2.x.333]  returns  [2.x.334]  is less than  [2.x.335]    then the active cell is an \a active_cell_within_distance.    [2.x.336]  A list of active cells within a given geometric distance    [2.x.337]  from the set of active cells for which the  [2.x.338]    returns  [2.x.339]      See compute_active_cell_halo_layer().  
* [0.x.61]*
   Extract and return a set of ghost cells which are within a    [2.x.340]  around all locally owned cells.   This is most relevant for  [2.x.341]    where it will return a subset of all ghost cells on a process, but for    [2.x.342]  this will return all the ghost cells.   All the cells for the  [2.x.343]  class that   are not owned by the current processor can be considered as ghost cells;   in particular, they do not only form a single layer of cells around the   locally owned ones.      [2.x.344]  MeshType A type that satisfies the requirements of the    [2.x.345]  "MeshType concept".    [2.x.346]  mesh A mesh (i.e. objects of type Triangulation or DoFHandler).    [2.x.347]  layer_thickness specifies the geometric distance within   which the function searches for active cells from the locally owned cells.    [2.x.348]  A subset of ghost cells within a given geometric distance of  [2.x.349]    layer_thickness from the locally owned cells of a current process.     Also see compute_ghost_cell_halo_layer() and   compute_active_cell_layer_within_distance().  
* [0.x.62]*
   Compute and return a bounding box, defined through a pair of points   bottom left and top right, that surrounds a subdomain of the  [2.x.350]    Here, the "subdomain" consists of exactly all of those   active cells for which the  [2.x.351]  returns  [2.x.352]      For a description of how  [2.x.353]  works,   see compute_active_cell_halo_layer().    
*  [2.x.354]  This function was written before the BoundingBox class was invented.     Consequently, it returns a pair of points, rather than a BoundingBox   object as one may expect. However, BoundingBox has a conversion constructor   from pairs of points, so the result of this function can still be assigned   to a BoundingBox object.  
* [0.x.63]*
   Compute a collection of bounding boxes so that all active cells for which   the given predicate is true, are completely enclosed in at least one of the   bounding boxes. Notice the cover is only guaranteed to contain all these   active cells but it's not necessarily exact i.e. it can include a bigger   area than their union.     For each cell at a given refinement level containing active cells for which  [2.x.355]  is true,   the function creates a bounding box of its children for which  [2.x.356]  is true.     This results in a cover of all active cells for which  [2.x.357]  is true; the parameters    [2.x.358]  and  [2.x.359]  are used to reduce the number of cells at a computational cost and   covering a bigger n-dimensional volume.     The parameters to control the algorithm are:
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.360]  : the property of the cells to enclose e.g.  [2.x.361]  .    The predicate is tested only on active cells.
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.362]  : it defines the level at which the initial bounding box are created. The refinement    should be set to a coarse refinement level. A bounding box is created for   each active cell at coarser    level than  [2.x.363]  if  [2.x.364]  is higher than the number of levels of the    triangulation an exception is thrown.
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.365]  : This flag allows for box merging and, by default, is false. The algorithm has a cost of    O(N^2) where N is the number of the bounding boxes created from the   refinement level; for this reason, if    the flag is set to true, make sure to choose wisely a coarse enough  [2.x.366] 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.367]  : the maximum number of bounding boxes to compute. If more are created the smaller ones are    merged with neighbors. By default after merging the boxes which can be   expressed as a single one no more boxes are merged. See the    [2.x.368]  () function for details.    Notice only neighboring cells are merged (see the  [2.x.369]   function in bounding box class): if    the target number of bounding boxes max_boxes can't be reached by merging   neighbors an exception is thrown     The following image describes an example of the algorithm with  [2.x.370]  = 2,  [2.x.371]  = true   and  [2.x.372]  = 1. The cells with the property predicate are in red, the area of a bounding box is   slightly orange.    [2.x.373] 
* 

* 
* 

* 
* 

* 
* 
*  - 1. In black we can see the cells of the current level.
* 

* 
* 

* 
* 

* 
* 
*  - 2. For each cell containing the red area a bounding box is created: by   default these are returned.
* 

* 
* 

* 
* 

* 
* 
*  - 3. Because  [2.x.374]  = true the number of bounding boxes is reduced while not changing the cover.    If  [2.x.375]  was left as default or bigger than 1 these two boxes would be returned.
* 

* 
* 

* 
* 

* 
* 
*  - 4. Because  [2.x.376]  = 1 the smallest bounding box is merged to the bigger one.   Notice it is important to choose the parameters wisely. For instance,  [2.x.377]  = false and    [2.x.378]  = 1 returns the very same bounding box but with a   fraction of the computational cost.     This function does not take into account the curvature of cells and thus it   is not suited for handling curved geometry: the mapping is assumed to be   linear.  
* [0.x.64]*
   Given an array of points, use the global bounding box description obtained   using  [2.x.379]  to guess, for each of   them, which process might own it.      [2.x.380]  global_bboxes Vector of bounding boxes describing the portion of    mesh with a property for each process.    [2.x.381]  points Array of points to test.      [2.x.382]  A tuple containing the following information:
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A vector indicized with ranks of processes. For each rank it contains     a vector of the indices of points it might own.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A map from the index  [2.x.383]  of the point in  [2.x.384]      to the rank of the owner.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A map from the index  [2.x.385]  of the point in  [2.x.386]      to the ranks of the guessed owners.    
*  [2.x.387]  The actual return type of this function, i.e., the type referenced   above as  [2.x.388]  is  
* [1.x.20]
*    The type is abbreviated in the online documentation to improve readability   of this page.  
* [0.x.65]*
   Given a covering rtree (see  [2.x.389]  and an   array of points, find a superset of processes which, individually,   may own the cell containing the points.     For further details see  [2.x.390]  here only   different input/output types are reported:      [2.x.391]  covering_rtree RTRee which enables us to identify which   process(es) in a parallel computation may own the cell that   surrounds a given point.      [2.x.392]  points A vector of points to consider.      [2.x.393]  A tuple containing the following information:
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A map indexed by processor ranks. For each rank it contains     a vector of the indices of points it might own.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A map from the index  [2.x.394]  of the point in  [2.x.395]      to the rank of the owner; these are points for which a single possible     owner was found.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A map from the index  [2.x.396]  of the point in  [2.x.397]      to the ranks of the guessed owners; these are points for which multiple     possible owners were found.    
*  [2.x.398]  The actual return type of this function, i.e., the type referenced   above as  [2.x.399]  is  
* [1.x.21]
*    The type is abbreviated in the online documentation to improve readability   of this page.  
* [0.x.66]*
   Return the adjacent cells of all the vertices. If a vertex is also a   hanging node, the associated coarse cell is also returned. The vertices   are ordered by the vertex index. This is the number returned by the   function  [2.x.400] . Notice that only the indices   marked in the array returned by    [2.x.401]  are used.  
* [0.x.67]*
   Return a vector of normalized tensors for each vertex-cell combination of   the output of  [2.x.402]  (which is expected as input   parameter for this function). Each tensor represents a geometric vector   from the vertex to the respective cell center.     An assertion will be thrown if the size of the input vector is not equal to   the number of vertices of the triangulation.     result[v][c] is a unit Tensor for vertex index v, indicating the direction   of the center of the c-th cell with respect to the vertex v.  
* [0.x.68]*
   Return the local vertex index of cell  [2.x.403]  that is closest to   the given location  [2.x.404]  The location of the vertices is extracted   from the (optional)  [2.x.405]  argument, to guarantee that the correct   answer is returned when the underlying mapping modifies the position of the   vertices.  
* [0.x.69]*
   Compute a globally unique index for each vertex and hanging node   associated with a locally owned active cell. The vertices of a ghost cell   that are hanging nodes of a locally owned cells have a global index.   However, the other vertices of the cells that do not [1.x.22] an   active cell do not have a global index on this processor.     The key of the map is the local index of the vertex and the value is the   global index. The indices need to be recomputed after refinement or   coarsening and may be different.  
* [0.x.70]*
   Return the highest value among ratios between extents in each of the   coordinate directions of a  [2.x.406]  Moreover, return the dimension   relative to the highest elongation.      [2.x.407]  cell an iterator pointing to the cell.      [2.x.408]   A  [2.x.409]  int, double> such that the  [2.x.410]  value   is the dimension of the highest elongation and the  [2.x.411]  value is the   ratio among the dimensions of the  [2.x.412]   
* [0.x.71]*
    [2.x.413]  Partitions and subdomains of triangulations  
* [0.x.72]*
   Produce a sparsity pattern in which nonzero entries indicate that two   cells are connected via a common face. The diagonal entries of the   sparsity pattern are also set.     The rows and columns refer to the cells as they are traversed in their   natural order using cell iterators.  
* [0.x.73]*
   Produce a sparsity pattern in which nonzero entries indicate that two   cells are connected via a common vertex. The diagonal entries of the   sparsity pattern are also set.     The rows and columns refer to the cells as they are traversed in their   natural order using cell iterators.  
* [0.x.74]*
   Produce a sparsity pattern for a given level mesh in which nonzero entries   indicate that two cells are connected via a common vertex. The diagonal   entries of the sparsity pattern are also set.     The rows and columns refer to the cells as they are traversed in their   natural order using cell iterators.  
* [0.x.75]*
   Use graph partitioner to partition the active cells making up the entire   domain. After calling this function, the subdomain ids of all active cells   will have values   between zero and  [2.x.414]  You can access the subdomain id of a cell by using   <tt>cell- [2.x.415]      Use the third argument to select between partitioning algorithms provided   by METIS or ZOLTAN. METIS is the default partitioner.     If deal.II was not installed with ZOLTAN or METIS, this function will   generate an error   when corresponding partition method is chosen, unless  [2.x.416]  is one.   I.e., you can write a program so that it runs in the single-processor   single-partition case without packages installed, and only requires them   installed when multiple partitions are required.    
*  [2.x.417]  If the  [2.x.418]  signal has been attached to the  [2.x.419]    then this will be used and passed to the partitioner.  
* [0.x.76]*
   This function performs the same operation as the one above, except that   it takes into consideration a specific set of  [2.x.420]  which allow the   partitioner to balance the graph while taking into consideration the   computational effort expended on each cell.    
*  [2.x.421]  If the  [2.x.422]  vector is empty, then no weighting is taken   into consideration. If not then the size of this vector must equal to the   number of active cells in the triangulation.  
* [0.x.77]*
   This function does the same as the previous one, i.e. it partitions a   triangulation using a partitioning algorithm into a number of subdomains   identified by the  [2.x.423]  flag.     The difference to the previous function is the second argument, a   sparsity pattern that represents the connectivity pattern between cells.     While the function above builds it directly from the triangulation by   considering which cells neighbor each other, this function can take a   more refined connectivity graph. The sparsity pattern needs to be of size    [2.x.424] , where  [2.x.425]  is the number of active cells in the   triangulation. If the sparsity pattern contains an entry at position    [2.x.426] , then this means that cells  [2.x.427]  and  [2.x.428]  (in the order in which   they are traversed by active cell iterators) are to be considered   connected; partitioning algorithm will then try to partition the domain in   such a way that (i) the subdomains are of roughly equal size, and (ii) a   minimal number of connections are broken.     This function is mainly useful in cases where connections between cells   exist that are not present in the triangulation alone (otherwise the   previous function would be the simpler one to use). Such connections may   include that certain parts of the boundary of a domain are coupled   through symmetric boundary conditions or integrals (e.g. friction contact   between the two sides of a crack in the domain), or if a numerical scheme   is used that not only connects immediate neighbors but a larger   neighborhood of cells (e.g. when solving integral equations).     In addition, this function may be useful in cases where the default   sparsity pattern is not entirely sufficient. This can happen because the   default is to just consider face neighbors, not neighboring cells that   are connected by edges or vertices. While the latter couple when using   continuous finite elements, they are typically still closely connected in   the neighborship graph, and partitioning algorithm   will not usually cut important connections in this case. However, if there   are vertices in the mesh where many cells (many more than the common 4 or 6   in 2d and 3d, respectively) come together, then there will be a significant   number of cells that are connected across a vertex, but several degrees   removed in the connectivity graph built only using face neighbors. In a   case like this, partitioning algorithm may sometimes make bad decisions and   you may want to build your own connectivity graph.    
*  [2.x.429]  If the  [2.x.430]  signal has been attached to the  [2.x.431]    then this will be used and passed to the partitioner.  
* [0.x.78]*
   This function performs the same operation as the one above, except that   it takes into consideration a specific set of  [2.x.432]  which allow the   partitioner to balance the graph while taking into consideration the   computational effort expended on each cell.    
*  [2.x.433]  If the  [2.x.434]  vector is empty, then no weighting is taken   into consideration. If not then the size of this vector must equal to the   number of active cells in the triangulation.  
* [0.x.79]*
   Generates a partitioning of the active cells making up the entire domain   using the same partitioning scheme as in the p4est library if the flag    [2.x.435]  is set to true (default behavior of this function).   After calling this function, the subdomain ids of all active cells will   have values between zero and  [2.x.436]  You can access the   subdomain id of a cell by using <tt>cell- [2.x.437]     
*  [2.x.438]  If the flag  [2.x.439]  is set to false, children of a         cell might be placed on different processors even though they are all         active, which is an assumption made by p4est. By relaxing this, we         can create partitions owning a single cell (also for refined         meshes).  
* [0.x.80]*
   Partitions the cells of a multigrid hierarchy by assigning level subdomain   ids using the "youngest child" rule, that is, each cell in the hierarchy is   owned by the processor who owns its left most child in the forest, and   active cells have the same subdomain id and level subdomain id. You can   access the level subdomain id of a cell by using   <tt>cell- [2.x.440]      Note: This function assumes that the active cells have already been   partitioned.  
* [0.x.81]*
   This function allows to ask for the owning subdomain of cells identified by   CellId objects that do not have to exist on the current process.    
*  [2.x.441]  This function has not been implemented yet for      [2.x.442]   
* [0.x.82]*
   For each active cell, return in the output array to which subdomain (as   given by the <tt>cell->subdomain_id()</tt> function) it belongs. The   output array is supposed to have the right size already when calling this   function.     This function returns the association of each cell with one subdomain. If   you are looking for the association of each  [2.x.443]  DoF with a subdomain, use   the  [2.x.444]  function.  
* [0.x.83]*
   Count how many cells are uniquely associated with the given  [2.x.445]    index.     This function may return zero if there are no cells with the given  [2.x.446]    subdomain index. This can happen, for example, if you try to partition a   coarse mesh into more partitions (one for each processor) than there are   cells in the mesh.     This function returns the number of cells associated with one subdomain.   If you are looking for the association of  [2.x.447]  DoFs with this subdomain,   use the  [2.x.448]    function.  
* [0.x.84]*
   For a triangulation, return a mask that represents which of its vertices   are "owned" by the current process in the same way as we talk about   locally owned cells or degrees of freedom (see    [2.x.449]    and    [2.x.450] ).   For the purpose of this function, we define a locally owned vertex as   follows: a vertex is owned by that processor with the smallest subdomain   id (which equals the MPI rank of that processor) among all owners of   cells adjacent to this vertex. In other words, vertices that are in the   interior of a partition of the triangulation are owned by the owner of   this partition; for vertices that lie on the boundary between two or more   partitions, the owner is the processor with the least subdomain_id among   all adjacent subdomains.     For sequential triangulations (as opposed to, for example,    [2.x.451]  every user vertex is of course   owned by the current processor, i.e., the function returns    [2.x.452]  For parallel triangulations, the   returned mask is a subset of what  [2.x.453]    returns.      [2.x.454]  triangulation The triangulation of which the function evaluates   which vertices are locally owned.    [2.x.455]  The subset of vertices, as described above. The length of the   returned array equals Triangulation.n_vertices() and may, consequently,   be larger than  [2.x.456]   
* [0.x.85]*
    [2.x.457]  Comparing different meshes  
* [0.x.86]*
   Given two meshes (i.e. objects of type Triangulation or DoFHandler) that   are based on the same coarse mesh, this function figures out a set of cells   that are matched between the two meshes and where at most one of the meshes   is more refined on this cell. In other words, it finds the smallest cells   that are common to both meshes, and that together completely cover the   domain.     This function is useful, for example, in time-dependent or nonlinear   application, where one has to integrate a solution defined on one mesh   (e.g., the one from the previous time step or nonlinear iteration)   against the shape functions of another mesh (the next time step, the next   nonlinear iteration). If, for example, the new mesh is finer, then one   has to obtain the solution on the coarse mesh (mesh_1) and interpolate it   to the children of the corresponding cell of mesh_2. Conversely, if the   new mesh is coarser, one has to express the coarse cell shape function by   a linear combination of fine cell shape functions. In either case, one   needs to loop over the finest cells that are common to both   triangulations. This function returns a list of pairs of matching   iterators to cells in the two meshes that can be used to this end.     Note that the list of these iterators is not necessarily ordered, and   does also not necessarily coincide with the order in which cells are   traversed in one, or both, of the meshes given as arguments.      [2.x.458]  MeshType A type that satisfies the requirements of the    [2.x.459]  "MeshType concept".    
*  [2.x.460]  This function can only be used with    [2.x.461]  when both meshes use the same   Triangulation since, with a distributed Triangulation, not all cells are   stored locally, so the resulting list may not cover the entire domain.  
* [0.x.87]*
   Return true if the two triangulations are based on the same coarse mesh.   This is determined by checking whether they have the same number of cells   on the coarsest level, and then checking that they have the same   vertices.     The two meshes may have different refinement histories beyond the coarse   mesh.  
* [0.x.88]*
   The same function as above, but working on arguments of type DoFHandler.   This function is provided to allow calling have_same_coarse_mesh for all   types of containers representing triangulations or the classes built on   triangulations.      [2.x.462]  MeshType A type that satisfies the requirements of the    [2.x.463]  "MeshType concept".  
* [0.x.89]*
    [2.x.464]  Dealing with distorted cells  
* [0.x.90]*
   Given a triangulation and a list of cells whose children have become   distorted as a result of mesh refinement, try to fix these cells up by   moving the center node around.     The function returns a list of cells with distorted children that   couldn't be fixed up for whatever reason. The returned list is therefore   a subset of the input argument.     For a definition of the concept of distorted cells, see the    [2.x.465]  "glossary entry".   The first argument passed to the current function is typically the   exception thrown by the  [2.x.466]    function.  
* [0.x.91]*
    [2.x.467]  Extracting and creating patches of cells     These functions extract and create patches of cells surrounding a single   cell, and creating triangulation out of them.  
* [0.x.92]*
   This function returns a list of all the active neighbor cells of the   given, active cell.  Here, a neighbor is defined as one having at least   part of a face in common with the given cell, but not edge (in 3d) or   vertex neighbors (in 2d and 3d).     The first element of the returned list is the cell provided as argument.   The remaining ones are neighbors: The function loops over all faces of   that given cell and checks if that face is not on the boundary of the   domain. Then, if the neighbor cell does not have any children (i.e., it   is either at the same refinement level as the current cell, or coarser)   then this neighbor cell is added to the list of cells. Otherwise, if the   neighbor cell is refined and therefore has children, then this function   loops over all subfaces of current face adds the neighbors behind these   sub-faces to the list to be returned.      [2.x.468]  MeshType A type that satisfies the requirements of the    [2.x.469]  "MeshType concept".   In C++, the compiler can not determine  [2.x.470]  from the   function call. You need to specify it as an explicit template argument   following the function name.    [2.x.471]  cell An iterator pointing to a cell of the mesh.    [2.x.472]  A list of active cells that form the patch around the given cell    
*  [2.x.473]  Patches are often used in defining error estimators that require   the solution of a local problem on the patch surrounding each of the   cells of the mesh. This also requires manipulating the degrees of freedom   associated with the cells of a patch. To this end, there are further   functions working on patches in namespace DoFTools.    
*  [2.x.474]  In the context of a parallel distributed computation, it only makes   sense to call this function on locally owned cells. This is because the   neighbors of locally owned cells are either locally owned themselves, or   ghost cells. For both, we know that these are in fact the real cells of   the complete, parallel triangulation. We can also query the degrees of   freedom on these.  
* [0.x.93]*
   This function takes a vector of active cells (hereafter named  [2.x.475]    patch_cells) as input argument, and returns a vector of their parent   cells with the coarsest common level of refinement. In other words, find   that set of cells living at the same refinement level so that all cells   in the input vector are children of the cells in the set, or are in the   set itself.      [2.x.476]  Container In C++, the compiler can not determine the type of    [2.x.477]  from the function call. You need to specify it as   an explicit template argument following the function name. This type has   to satisfy the requirements of a mesh container (see    [2.x.478] ).      [2.x.479]  patch_cells A vector of active cells for which this function   finds the parents at the coarsest common level. This vector of cells   typically results from calling the function    [2.x.480]     [2.x.481]  A list of cells with the coarsest common level of refinement of   the input cells.  
* [0.x.94]*
   This function constructs a Triangulation (named  [2.x.482]    from a given vector of active cells. This vector (which we think of the   cells corresponding to a "patch") contains active cells that are part of   an existing global Triangulation. The goal of this function is to build a   local Triangulation that contains only the active cells given in  [2.x.483]    (and potentially a minimum number of additional cells required to form a   valid Triangulation). The function also returns a map that allows to   identify the cells in the output Triangulation and corresponding cells in   the input list.     The function copies the location of vertices of cells from the cells of the   source triangulation to the triangulation that is built from the list of   patch cells.  This adds support for triangulations which have been   perturbed or smoothed in some manner which makes the triangulation   deviate from the standard deal.II refinement strategy of placing new   vertices at midpoints of faces or edges.     The operation implemented by this function is frequently used in the   definition of error estimators that need to solve "local" problems on   each cell and its neighbors. A similar construction is necessary in the   definition of the Clement interpolation operator in which one needs to   solve a local problem on all cells within the support of a shape   function. This function then builds a complete Triangulation from a list   of cells that make up such a patch; one can then later attach a   DoFHandler to such a Triangulation.     If the list of input cells contains only cells at the same refinement   level, then the output Triangulation simply consists of a Triangulation   containing only exactly these patch cells. On the other hand, if the   input cells live on different refinement levels, i.e., the Triangulation   of which they are part is adaptively refined, then the construction of   the output Triangulation is not so simple because the coarsest level of a   Triangulation can not contain hanging nodes. Rather, we first have to   find the common refinement level of all input cells, along with their   common parents (see  [2.x.484]    build a Triangulation from those, and then adaptively refine it so that   the input cells all also exist in the output Triangulation.     A consequence of this procedure is that the output Triangulation may   contain more active cells than the ones that exist in the input vector.   On the other hand, one typically wants to solve the local problem not on   the entire output Triangulation, but only on those cells of it that   correspond to cells in the input list.  In this case, a user typically   wants to assign degrees of freedom only on cells that are part of the   "patch", and somehow ignore those excessive cells. The current function   supports this common requirement by setting the user flag for the cells   in the output Triangulation that match with cells in the input list.   Cells which are not part of the original patch will not have their  [2.x.485]    user_flag set; we can then avoid assigning degrees of freedom using the   FE_Nothing<dim> element.      [2.x.486]  Container In C++, the compiler can not determine the type of    [2.x.487]  from the function call. You need to specify it as   an explicit template argument following the function name. This type that   satisfies the requirements of a mesh container (see    [2.x.488] ).      [2.x.489]  patch A vector of active cells from a common triangulation.   These cells may or may not all be at the same refinement level.    [2.x.490]  local_triangulation A triangulation whose active cells   correspond to the given vector of active cells in  [2.x.491]     [2.x.492]  patch_to_global_tria_map A map between the local   triangulation which is built as explained above, and the cell iterators   in the input list.  
* [0.x.95]*
   This function runs through the degrees of freedom defined by the   DoFHandler and for each dof constructs a vector of   active_cell_iterators representing the cells of support of the associated   basis element at that degree of freedom. This function was originally   designed for the implementation of local projections, for instance the   Clement interpolant, in conjunction with other local patch functions like    [2.x.493]      DoFHandler's built on top of Triangulation or    [2.x.494]  are supported and handled   appropriately.     The result is the patch of cells representing the support of the basis   element associated to the degree of freedom.  For instance using an FE_Q   finite element, we obtain the standard patch of cells touching the degree   of freedom and then add other cells that take care of possible hanging node   constraints.  Using a FE_DGQ finite element, the degrees of freedom are   logically considered to be "interior" to the cells so the patch would   consist exclusively of the single cell on which the degree of freedom is   located.      [2.x.495]  dof_handler The DoFHandler which could be built on a   Triangulation or a  [2.x.496]  with a finite   element that has degrees of freedom that are logically associated to a   vertex, line, quad, or hex.    [2.x.497]  A map from the global_dof_index of   degrees of freedom on locally relevant cells to vectors containing    [2.x.498]  of cells in the support of the basis   function at that degree of freedom.  
* [0.x.96]*
    [2.x.499]  Dealing with periodic domains  
* [0.x.97]*
   Data type that provides all information necessary to create periodicity   constraints and a periodic p4est forest with respect to two 'periodic'   cell faces.  
* [0.x.98]*
     The cells associated with the two 'periodic' faces.    
* [0.x.99]*
     The local face indices (with respect to the specified cells) of the two     'periodic' faces.    
* [0.x.100]*
     The relative orientation of the first face with respect to the second     face as described in orthogonal_equality() and      [2.x.500]  (and stored as a bitset).    
* [0.x.101]*
     A  [2.x.501]   [2.x.502]   [2.x.503]  rotation matrix that describes how vector     valued DoFs of the first face should be modified prior to constraining     to the DoFs of the second face.         The rotation matrix is used in  [2.x.504]      by applying the rotation to all vector valued blocks listed in the     parameter  [2.x.505]  of the finite element space. For     more details see  [2.x.506]  and the     glossary      [2.x.507]  "glossary entry on periodic conditions".    
* [0.x.102]*
   An orthogonal equality test for faces.      [2.x.508]  and  [2.x.509]  are considered equal, if a one to one matching   between its vertices can be achieved via an orthogonal equality relation.     Here, two vertices <tt>v_1</tt> and <tt>v_2</tt> are considered equal, if    [2.x.510]  is parallel to the unit vector in unit   direction  [2.x.511]  If the parameter  [2.x.512]  is a reference to a   spacedim x spacedim matrix,  [2.x.513]  is set to  [2.x.514]  otherwise  [2.x.515]  is the   identity matrix.     If the matching was successful, the _relative_ orientation of  [2.x.516]    with respect to  [2.x.517]  is returned in the bitset  [2.x.518]  where  
* [1.x.23]
*      In 2D <tt>face_orientation</tt> is always <tt>true</tt>,   <tt>face_rotation</tt> is always <tt>false</tt>, and face_flip has the   meaning of <tt>line_flip</tt>. More precisely in 3d:     <tt>face_orientation</tt>: <tt>true</tt> if  [2.x.519]  and  [2.x.520]  have   the same orientation. Otherwise, the vertex indices of  [2.x.521]  match the   vertex indices of  [2.x.522]  in the following manner:    
* [1.x.24]
*      <tt>face_flip</tt>: <tt>true</tt> if the matched vertices are rotated by   180 degrees:    
* [1.x.25]
*      <tt>face_rotation</tt>: <tt>true</tt> if the matched vertices are rotated   by 90 degrees counterclockwise:    
* [1.x.26]
*      and any combination of that... More information on the topic can be found   in the    [2.x.523]  "glossary"   article.  
* [0.x.103]*
   Same function as above, but doesn't return the actual orientation  
* [0.x.104]*
   This function will collect periodic face pairs on the coarsest mesh level   of the given  [2.x.524]  (a Triangulation or DoFHandler) and add them to the   vector  [2.x.525]  leaving the original contents intact.     Define a 'first' boundary as all boundary faces having boundary_id  [2.x.526]    b_id1 and a 'second' boundary consisting of all faces belonging to  [2.x.527]    b_id2.     This function tries to match all faces belonging to the first boundary   with faces belonging to the second boundary with the help of   orthogonal_equality().     The bitset that is returned inside of PeriodicFacePair encodes the   _relative_ orientation of the first face with respect to the second face,   see the documentation of orthogonal_equality() for further details.     The  [2.x.528]  refers to the space direction in which periodicity is   enforced. When matching periodic faces this vector component is ignored.     The  [2.x.529]  is a vector tangential to the faces that is added to the   location of vertices of the 'first' boundary when attempting to match   them to the corresponding vertices of the 'second' boundary. This can be   used to implement conditions such as  [2.x.530] .     Optionally, a  [2.x.531]  rotation  [2.x.532]  can be specified that   describes how vector valued DoFs of the first face should be modified   prior to constraining to the DoFs of the second face. The  [2.x.533]  is   used in two places. First,  [2.x.534]  will be supplied to   orthogonal_equality() and used for matching faces: Two vertices  [2.x.535]  and    [2.x.536]  match if  [2.x.537]  is parallel   to the unit vector in unit direction  [2.x.538]  (For more details see    [2.x.539]  the glossary    [2.x.540]  "glossary entry on periodic conditions"   and  [2.x.541] ). Second,  [2.x.542]  will be stored in the PeriodicFacePair   collection  [2.x.543]  for further use.      [2.x.544]  MeshType A type that satisfies the requirements of the    [2.x.545]  "MeshType concept".    
*  [2.x.546]  The created  [2.x.547]  can be used in    [2.x.548]  and in    [2.x.549]  to enforce   periodicity algebraically.    
*  [2.x.550]  Because elements will be added to  [2.x.551]  (and existing   entries will be preserved), it is possible to call this function several   times with different boundary ids to generate a vector with all periodic   pairs.    
*  [2.x.552]  Since the periodic face pairs are found on the coarsest mesh level,   it is necessary to ensure that the coarsest level faces have the correct   boundary indicators set. In general, this means that one must first set   all boundary indicators on the coarse grid before performing any global   or local grid refinement.  
* [0.x.105]*
   This compatibility version of collect_periodic_faces() only works on   grids with cells in    [2.x.553]  "standard orientation".     Instead of defining a 'first' and 'second' boundary with the help of two   boundary_ids this function defines a 'left' boundary as all faces with   local face index  [2.x.554]  and boundary indicator  [2.x.555]    and, similarly, a 'right' boundary consisting of all face with local face   index  [2.x.556]  and boundary indicator  [2.x.557]  Faces   with coordinates only differing in the  [2.x.558]  component are   identified.     This function will collect periodic face pairs on the coarsest mesh level   and add them to  [2.x.559]  leaving the original contents intact.     See above function for further details.    
*  [2.x.560]  This version of collect_periodic_faces() will not work on   meshes with cells not in    [2.x.561]  "standard orientation".  
* [0.x.106]*
    [2.x.562]  Dealing with boundary and manifold ids  
* [0.x.107]*
   Copy boundary ids to manifold ids on faces and edges at the boundary. The   default manifold_id for new Triangulation objects is    [2.x.563]  This function copies the boundary_ids of   the boundary faces and edges to the manifold_ids of the same faces and   edges, allowing the user to change the boundary_ids and use them for   boundary conditions regardless of the geometry, which will use   manifold_ids to create new points. Only active cells will be iterated   over. This is a function you'd typically call when there is only one   active level on your Triangulation. Mesh refinement will then inherit   these indicators to child cells, faces, and edges.     The optional parameter  [2.x.564]  indicates whether this   function should reset the boundary_ids of boundary faces and edges to its   default value 0 after copying its value to the manifold_id. By default,   boundary_ids are left untouched.    
*  [2.x.565]     [2.x.566]  boundary  
* [0.x.108]*
   Map the given boundary ids to the given manifold ids on faces and   edges at the boundary.     This function copies the boundary ids of the boundary faces and   edges that are present in the parameter  [2.x.567]  to   the corresponding manifold id in  [2.x.568]  of the same   faces and edges.     If the optional parameter  [2.x.569]  is non empty,   each boundary id in  [2.x.570]  is replaced with the   corresponding boundary id in  [2.x.571]      An exception is thrown if the size of the input vectors do not   match. If a boundary id indicated in  [2.x.572]  is not   present in the triangulation, it is simply ignored during the   process.    
*  [2.x.573]     [2.x.574]  boundary  
* [0.x.109]*
   Copy material ids to manifold ids. The default manifold_id for new   Triangulation objects is  [2.x.575]  When refinements   occurs, the Triangulation asks where to locate new points to the   underlying manifold.     When reading a Triangulation from a supported input format, typical   information that can be stored in a file are boundary conditions for   boundary faces (which we store in the boundary_id of the faces), material   types for cells (which we store in the material_id of the cells) and in   some cases subdomain ids for cells (which we store in the subdomain_id of   the cell).     If you read one of these grids into a Triangulation, you might still want   to use the material_id specified in the input file as a manifold_id   description. In this case you can associate a Manifold object to internal   cells, and this object will be used by the Triangulation to query   Manifold objects for new points. This function iterates over active cells   and copies the material_ids to the manifold_ids.     The optional parameter  [2.x.576]  indicates whether this   function should also set the manifold_ids of the faces (both for internal   faces and for faces on the boundary). If set to true, then each face will   get a manifold_id equal to the minimum of the surrounding manifold_ids,   ensuring that a unique manifold id is selected for each face of the   Triangulation. By default, face manifold_ids are not computed.    
*  [2.x.577]   
* [0.x.110]*
   Propagate manifold indicators associated with the cells of the   Triangulation  [2.x.578]  to their co-dimension one and two objects.     This function sets the  [2.x.579]  of faces and edges (both on the   interior and on the boundary) to the value returned by the    [2.x.580]  method, called with the set of   manifold indicators of the cells that share the same face or edge.     By default, the  [2.x.581]  returns    [2.x.582]  when the set has size greater than one (i.e.,   when it is not possible to decide what manifold indicator a face or edge   should have according to the manifold indicators of the adjacent cells)   and it returns the manifold indicator contained in the set when it has   dimension one (i.e., when all adjacent cells and faces have the same   manifold indicator).     The parameter  [2.x.583]  allows you to specify   what to do when a face or an edge already has a manifold indicator   different from  [2.x.584]  If the flag is  [2.x.585]  the edge   or face will maintain its original manifold indicator.   If it is  [2.x.586]  then also the manifold indicator of these faces and edges   is set according to the return value of the  [2.x.587]   
* [0.x.111]*
   Exchange arbitrary data of type  [2.x.588]  provided by the function   objects from locally owned cells to ghost cells on other processors.     After this call, you typically will have received data from  [2.x.589]  on   every ghost cell as it was given by  [2.x.590]  on the owning processor.   Whether you do or do not receive information to  [2.x.591]  on a given   ghost cell depends on whether the  [2.x.592]  function decided that   something needs to be sent. It does so using the  [2.x.593]    mechanism: if the  [2.x.594]  return object of the  [2.x.595]    function is empty, then this implies that no data has to be sent for   the locally owned cell it was called on. In that case,  [2.x.596]  will   also not be called on the ghost cell that corresponds to it on the   receiving side. On the other hand, if the  [2.x.597]  object is   not empty, then the data stored within it will be sent to the received   and the  [2.x.598]  function called with it.      [2.x.599]  DataType The type of the data to be communicated. It is assumed     to be serializable by  [2.x.600]  In many cases, this     data type can not be deduced by the compiler, e.g., if you provide     lambda functions for the second and third argument     to this function. In this case, you have to explicitly specify     the  [2.x.601]  as a template argument to the function call.    [2.x.602]  MeshType The type of  [2.x.603]       [2.x.604]  mesh A variable of a type that satisfies the requirements of the    [2.x.605]  "MeshType concept".    [2.x.606]  pack The function that will be called on each locally owned cell     that is a ghost cell somewhere else. As mentioned above, the function     may return a regular data object of type  [2.x.607]  to indicate     that data should be sent, or an empty      [2.x.608]  to indicate that nothing has     to be sent for this cell.    [2.x.609]  unpack The function that will be called for each ghost cell     for which data was sent, i.e., for which the  [2.x.610]  function     on the sending side returned a non-empty  [2.x.611]  object.     The  [2.x.612]  function is then called with the data sent by the     processor that owns that cell.    [2.x.613]  cell_filter Only cells are communicated where this filter function returns     the value `true`. In the default case, the function returns true on all   cells and thus, all relevant cells are communicated.     [1.x.27]     Here is an example that shows how this function is to be used   in a concrete context. It is taken from the code that makes   sure that the  [2.x.614]  (a single unsigned integer) is   transported from locally owned cells where one can set it in   DoFHandler objects with hp-capabilities, to the corresponding ghost cells   on other processors to ensure that one can query the right value also on   those processors:  
* [1.x.28]
*      You will notice that the  [2.x.615]  lambda function returns an `unsigned int`,   not a  [2.x.616]  int>`. The former converts   automatically to the latter, implying that data will always be transported   to the other processor.     (In reality, the  [2.x.617]  function needs to be a bit more   complicated because it is not allowed to call    [2.x.618]  on ghost cells. Rather, the    [2.x.619]  function directly accesses internal data structures. But   you get the idea
* 
*  -  the code could, just as well, have exchanged   material ids, user indices, boundary indicators, or any kind of other   data with similar calls as the ones above.)  
* [0.x.112]*
   Exchange arbitrary data of type  [2.x.620]  provided by the function   objects from locally owned level cells to ghost level cells on other   processes.     In addition to the parameters of exchange_cell_data_to_ghosts(), this   function allows to provide a  [2.x.621]  function, which can be used to only   communicate marked cells. In the default case, all relevant cells are   communicated.  
* [0.x.113] Exchange with all processors of the MPI communicator  [2.x.622]  the vector of bounding   boxes  [2.x.623]      This function is meant to exchange bounding boxes describing the locally   owned cells in a distributed triangulation obtained with the function    [2.x.624]  .     The output vector's size is the number of processes of the MPI   communicator:   its i-th entry contains the vector  [2.x.625]  of the i-th process.  
* [0.x.114]*
   In this collective operation each process provides a vector   of bounding boxes and a communicator.   All these vectors are gathered on each of the processes,   organized in a search tree which, and then returned.     The idea is that the vector of bounding boxes describes a   relevant property of the computations on each process   individually, which could also be of use to other processes. An   example would be if the input vector of bounding boxes   corresponded to a covering of the locally owned partition of a   mesh (see    [2.x.626] )   of a    [2.x.627]  object. While these may   overlap the bounding boxes of other processes, finding which   process owns the cell that encloses a given point is vastly   easier if the process trying to figure this out has a list of   bounding boxes for each of the other processes at hand.     The returned search tree object is an r-tree with packing   algorithm, which is provided by boost library. See   https://www.boost.org/doc/libs/1_67_0/libs/geometry/doc/html/geometry/spatial_indexes/introduction.html   for more information.     In the returned tree, each node contains a pair of elements:   the first being a bounding box,   the second being the rank of the process whose local description   contains the bounding box.    
*  [2.x.628]  This function is a collective operation.  
* [0.x.115]*
   Collect for a given triangulation all locally relevant vertices that   coincide due to periodicity.     Coinciding vertices are put into a group, e.g.: [1, 25, 51], which is   labeled by an arbitrary element from it, e.g.: "1". All coinciding vertices   store the label to its group, so that they can quickly access all the   coinciding vertices in that group: e.g.: 51
* 
->  "1"
* 
-> [1, 25, 51]      [2.x.629]  tria Triangulation.    [2.x.630]  coinciding_vertex_groups A map of equivalence classes (of               coinciding vertices) labeled by an arbitrary element from them.               Vertices not coinciding are ignored.    [2.x.631]  vertex_to_coinciding_vertex_group Map of a vertex to the label               of a group of coinciding vertices. Vertices not contained in               this vector are not coinciding with any other vertex.  
* [0.x.116]*
   Return a map that, for each vertex, lists all the processes whose   subdomains are adjacent to that vertex.      [2.x.632]  tria Triangulation.  
* [0.x.117]*
   A structure that allows the transfer of cell data of type  [2.x.633]  from one processor   to another. It corresponds to a packed buffer that stores a vector of   CellId and a vector of type  [2.x.634]      This class facilitates the transfer by providing the save/load functions   that are able to pack up the vector of CellId's and the associated   data of type  [2.x.635]  into a stream.     Type  [2.x.636]  is assumed to be serializable by  [2.x.637]  (for   example  [2.x.638] ).  
* [0.x.118]*
     A vector to store IDs of cells to be transferred.    
* [0.x.119]*
     A vector of cell data to be transferred.    
* [0.x.120]*
     Write the data of this object to a stream for the purpose of     serialization using the [BOOST serialization     library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)          [2.x.639]  The user is responsible to keep the size of  [2.x.640]      equal to the size as  [2.x.641]  .    
* [0.x.121]*
     Read the data of this object from a stream for the purpose of     serialization using the [BOOST serialization     library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).     Throw away the previous content.    
* [0.x.122]*
     Read or write the data of this object to or from a stream for the     purpose of serialization using the [BOOST serialization     library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).    
* [0.x.123]*
   An implementation of the marching-square (2D) and marching-cube algorithm   for creating data structures (vectors of Point and CellData) to   create a linear/bilinear surface mesh on the iso line/contour of a   scalar field.     To improve the approximation of the iso line/contour and the resulting   linear surface mesh, one increases the number of subdivision so that the   algorithm is not run on a cell but on subcells with vertex values having   been interpolated from the cell values.    
*  [2.x.642]  The resulting mesh will contain lines in 2D and triangles in 3D.    
*  [2.x.643]  The resulting mesh will not be of high quality, since it might     contain cells with very small diameters if the mesh is cut close to a     vertex.  
* [0.x.124]*
     Value type of vector.    
* [0.x.125]*
     Constructor.    
* [0.x.126]*
     Process all locally-owned cells and fill  [2.x.644]  and  [2.x.645]  for all     cells that are cut.    
* [0.x.127]*
     Process the provided cell and fill  [2.x.646]  and  [2.x.647]  for all cells     that are cut.        
*  [2.x.648]  The resulting vectors are empty if the cell is not cut.    
* [0.x.128]*
     Internal function to create a quadrature rule with n_subdivisions+1     equally-positioned quadrature points.    
* [0.x.129]*
     Process a cell.    
* [0.x.130]*
     Process a sub-cell (2D).        
*  [2.x.649]  Subcells with saddle points are ignored. Please increase the number       of subdivisions in this case.    
* [0.x.131]*
     Process a sub-cell (3D).    
* [0.x.132]*
     Number of subdivisions each cell is subdivided into in each direction to     improve the approximation.    
* [0.x.133]*
     Absolute tolerance specifying the minimum distance between a vertex and     the cut point so that a line is considered cut.    
* [0.x.134]*
     FEValues used internally and set up with a quadrature rule with the     correct number of subdivisions.    
* [0.x.135]*
    [2.x.650]  Exceptions  
* [0.x.136]*
   Exception  
* [0.x.137]*
   Exception  
* [0.x.138]*
   Exception  
* [0.x.139]*
   Exception  
* [0.x.140]*
   Exception  
* [0.x.141]*
 An exception that is thrown whenever the edges of a mesh are not orientable.
* 

* 
*  [2.x.651]  for backwards compatibility with the old GridReordering class this exception is not in the GridTools namespace.
* 

* 
*  [2.x.652] 

* 
* [0.x.142]*
       The method  [2.x.653]  requires taking derivatives       along the surface of a simplex. In general these cannot be       approximated with finite differences but special differences of the       form                 df/dx_i
* 
*  - df/dx_j              [2.x.654] can [2.x.655]  be approximated. This  [2.x.656]  just stores       the two derivatives approximated by the stencil (in the case of the       example above  [2.x.657] ).      
* [0.x.143]*
       Standard second-order approximation to the first derivative with a       two-point centered scheme. This is used below in a 1D Newton method.      
* [0.x.144]*
       Standard second-order approximation to the second derivative with a       three-point centered scheme. This is used below in a 1D Newton method.      
* [0.x.145]*
       Fourth order approximation of the derivative                 df/dx_i
* 
*  - df/dx_j             where  [2.x.658]  are specified by  [2.x.659]        cross_derivative. The derivative approximation is at  [2.x.660]  with a       step size of  [2.x.661]  and function  [2.x.662]       
* [0.x.146]*
       The optimization algorithm used in  [2.x.663]  is       essentially a gradient descent method. This function computes entries       in the gradient of the objective function; see the description in the       comments inside  [2.x.664]  for more information.      
* [0.x.147]*
       Project onto a d-linear object. This is more accurate than the       general algorithm in project_to_object but only works for geometries       described by linear, bilinear, or trilinear mappings.      
* [0.x.148]