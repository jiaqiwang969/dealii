[0.x.0]*
 Within this namespace, we define several structures that are used to describe flags that can be given to grid output routines to modify the default outfit of the grids written into a file. See the different subclasses and the documentation of the GridOut class for more details.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Flags for grid output in OpenDX format.    
*  [2.x.1]   
* [0.x.2]*
     Write cells.    
* [0.x.3]*
     Write faces.    
* [0.x.4]*
     Write field with diameters.    
* [0.x.5]*
     Write field with area/volume.    
* [0.x.6]*
     Write all faces, including interior faces. If <tt>false</tt>, only     boundary faces are written.    
* [0.x.7]*
     Constructor.    
* [0.x.8]*
     Declare parameters in ParameterHandler.    
* [0.x.9]*
     Parse parameters of ParameterHandler.    
* [0.x.10]*
   Flags describing the details of output in MSH format.    
*  [2.x.2]   
* [0.x.11]*
     When writing a mesh, write boundary faces explicitly if their boundary     indicator is not the default boundary indicator, which is zero.  This     is necessary if you later want to re-read the grid and want to get the     same boundary indicators for the different parts of the boundary of the     triangulation.         It is not necessary if you only want to write the triangulation to view     or print it.         Default:  [2.x.3]     
* [0.x.12]*
     When writing a mesh, write boundary lines explicitly if their boundary     indicator is not the default boundary indicator, which is zero.  This     is necessary if you later want to re-read the grid and want to get the     same boundary indicators for the different parts of the boundary of the     triangulation.         It is not necessary if you only want to write the triangulation to view     or print it.         This is used only if <tt>dim==3</tt>, and ignored in all other cases.         Default:  [2.x.4]     
* [0.x.13]*
     Constructor.    
* [0.x.14]*
     Declare parameters in ParameterHandler.    
* [0.x.15]*
     Parse parameters of ParameterHandler.    
* [0.x.16]*
   Flags describing the details of output in UCD format.    
*  [2.x.5]   
* [0.x.17]*
     Write a comment at the beginning of the file stating the date of     creation and some other data.  While this is supported by the UCD     format (and the AVS program), some other programs get confused by this,     so the default is to not write a preamble. However, a preamble can be     written using this flag.         Default:  [2.x.6] .    
* [0.x.18]*
     When writing a mesh, write boundary faces explicitly if their boundary     indicator is not the default boundary indicator, which is zero.  This     is necessary if you later want to re-read the grid and want to get the     same boundary indicators for the different parts of the boundary of the     triangulation.         It is not necessary if you only want to write the triangulation to view     or print it.         Default:  [2.x.7]     
* [0.x.19]*
     When writing a mesh, write boundary lines explicitly if their boundary     indicator is not the default boundary indicator, which is zero.  This     is necessary if you later want to re-read the grid and want to get the     same boundary indicators for the different parts of the boundary of the     triangulation.         It is not necessary if you only want to write the triangulation to view     or print it.         This directive is ignored if <tt>dim!=3</tt>.         Default:  [2.x.8]     
* [0.x.20]*
     Constructor.    
* [0.x.21]*
     Declare parameters in ParameterHandler.    
* [0.x.22]*
     Parse parameters of ParameterHandler.    
* [0.x.23]*
   Flags describing the details of output in GNUPLOT format.    
*  [2.x.9]   
* [0.x.24]*
     Write the number of each cell into the output file before starting with     the lines it is composed of, as a comment. This might be useful if you     want to find out details about the grid, for example the position of     cells of which you know the number. It enlarges the size of the output     significantly, however.         Default:  [2.x.10]     
* [0.x.25]*
     Number of points,  [2.x.11] excluding [2.x.12]  the vertices, to plot on curved     lines. Since GNUPLOT can only plot straight lines, setting this number     to a value greater than zero (4 or 5 is usually enough for refined     grids) makes the plot look curved even though it is not.    
* [0.x.26]*
     Boolean indicating whether or not interior lines should be plotted with     <tt>n_extra_curved_line_points</tt> line segments.    
* [0.x.27]*
     Flag. If true then, when writing <tt>spacedim = 3</tt> output, write     <tt>2*n_extra_curved_line_points</tt> extra lines on boundary faces.         Setting this option has no effect when <tt>spacedim = 2</tt> since, in     that case, boundary faces are lines and outputting additional lines     does not make sense.        
*  [2.x.13]  This is not yet implemented for the <tt>dim = 2</tt> case. For     backwards compatibility, however, this will not raise a runtime error.    
* [0.x.28]*
     Constructor.    
* [0.x.29]*
     Declare parameters in ParameterHandler.    
* [0.x.30]*
     Parse parameters of ParameterHandler.    
* [0.x.31]*
   Flags describing the details of output for encapsulated postscript.  In   this structure, the flags common to all dimensions are listed. Flags   which are specific to one space dimension only are listed in derived   classes.     By default, the size of the picture is scaled such that the width equals   300 units.    
*  [2.x.14]   
* [0.x.32]*
     Enum denoting the possibilities whether the scaling should be done such     that the given  [2.x.15]  equals the width or the height of the resulting     picture.    
* [0.x.33]*
       Scale with the width.      
* [0.x.34]*
       Scale with the height.      
* [0.x.35]*
     See above. Default is  [2.x.16]     
* [0.x.36]*
     Width or height of the output as given in postscript units This usually     is given by the strange unit 1/72 inch. Whether this is height or width     is specified by the flag  [2.x.17]          Default is 300.    
* [0.x.37]*
     Width of a line in postscript units. Default is 0.5.    
* [0.x.38]*
     Should lines with a set  [2.x.18]  be drawn in a different color     (red)?  See      [2.x.19]      for information about user flags.    
* [0.x.39]*
     The number of points on a boundary face that are plotted in addition to     the vertices of the face.         This number is only used if the mapping used is not simply the standard      [2.x.20]  mapping (i.e., an object of kind MappingQGeneric(1)) that may     describe edges of cells as curved and that will then be approximated     using line segments with a number of intermediate points as described     by the current variable.    
* [0.x.40]*
     Should lines be colored according to their refinement level? This     overrides color_lines_on_user_flag for all levels except level 0.     Colors are: level 0: black, other levels: rainbow scale from blue to     red.    
* [0.x.41]*
     Constructor.    
* [0.x.42]*
     Declare parameters in ParameterHandler.    
* [0.x.43]*
     Parse parameters of ParameterHandler.    
* [0.x.44]*
   Flags describing the details of output for encapsulated postscript for   all dimensions not explicitly specialized below. Some flags that are   common to all dimensions are listed in the base class.     This class does not actually exist, we only here declare the general   template and declare explicit specializations below.    
*  [2.x.21]   
* [0.x.45]*
   Flags specific to the output of grids in one space dimensions.    
*  [2.x.22]   
* [0.x.46]*
     Constructor.    
* [0.x.47]*
     Declare parameters in ParameterHandler.    
* [0.x.48]*
     Parse parameters of ParameterHandler.    
* [0.x.49]*
   Flags specific to the output of grids in two space dimensions.    
*  [2.x.23]   
* [0.x.50]*
     If this flag is set, then we place the number of the cell into the     middle of each cell. The default value is to not do this.         The format of the cell number written is <tt>level.index</tt>, or     simply  [2.x.24]  depending on the value of the following flag.    
* [0.x.51]*
     If the cell numbers shall be written, using the above flag, then the     value of this flag determines whether the format shall be     <tt>level.index</tt>, or simply  [2.x.25]  If  [2.x.26]  the first format     is taken. Default is  [2.x.27]          The flag has obviously no effect if  [2.x.28]  is  [2.x.29]     
* [0.x.52]*
     Vertex numbers can be written onto the vertices. This is controlled by     the following flag. Default is  [2.x.30]     
* [0.x.53]*
     Constructor.    
* [0.x.54]*
     Declare parameters in ParameterHandler.    
* [0.x.55]*
     Parse parameters of ParameterHandler.    
* [0.x.56]*
   Flags specific to the output of grids in three space dimensions.    
*  [2.x.31]   
* [0.x.57]*
     Angle of the line origin-viewer against the z-axis in degrees.         Default is the Gnuplot-default of 60.    
* [0.x.58]*
     Angle by which the viewers position projected onto the x-y-plane is     rotated around the z-axis, in positive sense when viewed from above.     The unit are degrees, and zero equals a position above or below the     negative y-axis.         Default is the Gnuplot-default of 30.    
* [0.x.59]*
     Constructor.    
* [0.x.60]*
     Declare parameters in ParameterHandler.    
* [0.x.61]*
     Parse parameters of ParameterHandler.    
* [0.x.62]*
   Flags for XFig output.    
*  [2.x.32]   
* [0.x.63]*
     Draw boundary lines. Default is true.    
* [0.x.64]*
     An enum used for deciding which field is used for coloring the cells.    
* [0.x.65]*
     Code level to depth. Default is true. If false, color depends on     material or boundary id.         Depth of the object is 900-level, if this value is true.    
* [0.x.66]*
     Additional points for curved boundaries. Default is none.    
* [0.x.67]*
     Scaling of graph. The default is a unit length of one inch.    
* [0.x.68]*
     Offset of the graph. Before scaling, the coordinates are shifted by     this value. Default is zero in each direction.    
* [0.x.69]*
     Style for filling cells. Default is solid fill (20). This value is     forwarded unchanged into the corresponding field <tt>fill_style</tt> of     the polyline object of XFig.    
* [0.x.70]*
     Style for drawing border lines of polygons. Defaults to solid (0) and     is forwarded to XFig.    
* [0.x.71]*
     Thickness of border lines of polygons. Default is 1.         Set this to zero to avoid border lines for very fine meshes.    
* [0.x.72]*
     Style for drawing lines at the boundary. Defaults to solid (0).    
* [0.x.73]*
     Thickness of boundary lines. Default is 3.    
* [0.x.74]*
     Constructor.    
* [0.x.75]*
     Declare parameters in ParameterHandler.    
* [0.x.76]*
     Parse parameters of ParameterHandler.    
* [0.x.77]*
   Flags controlling SVG output.     The figure below is a zoomed-in illustration of what the SVG flags are   capable of producing. These exact settings are the same as those used   in the test  [2.x.33]  with the addition   of the flag  [2.x.34]  .      [2.x.35]     
*  [2.x.36]   
* [0.x.78]*
      Height of the plot in SVG units, computed from width if zero. Defaults      to 1000.    
* [0.x.79]*
      The width of the plot. Computed automatically from height if zero      (default).    
* [0.x.80]*
      Thickness of the lines between cells.    
* [0.x.81]*
     Thickness of lines at the boundary.    
* [0.x.82]*
      Margin around the plotted area.    
* [0.x.83]*
     An `enum` describing all possible background styles.    
* [0.x.84]*
       Use transparent value of SVG.      
* [0.x.85]*
       Use white background.      
* [0.x.86]*
       Use a gradient from white (top) to steelblue (bottom), and add date       and time plus a deal.II logo. Automatically draws a margin.      
* [0.x.87]*
     The style used for the background of the mesh.    
* [0.x.88]*
     The azimuth angle measured from ??? in degrees. Default is 0.    
* [0.x.89]*
     The angle from vertically above the xy-plane. Default is 0.    
* [0.x.90]*
     Cell coloring.    
* [0.x.91]*
     The factor determining the vertical distance between levels (default =     0.3.    
* [0.x.92]*
     Scaling of the font for cell annotations. Defaults to 1.    
* [0.x.93]*
     Write level number into each cell. Defaults to false.    
* [0.x.94]*
     Write cell index into each cell. Defaults to false.    
* [0.x.95]*
     Write material id of each cell. Defaults to false.    
* [0.x.96]*
     Write subdomain id of each cell. Defaults to false.    
* [0.x.97]*
     Write level subdomain id of each cell. Defaults to false.    
* [0.x.98]*
     Write boundary id of each boundary face in a circle on the     corresponding boundary edge. Defaults to false.         Note: Depending on the choice of image viewer, the boundary id     labels may not appear to be centered in the circle.    
* [0.x.99]*
     Draw a colorbar next to the plotted grid with respect to the chosen     coloring of the cells.    
* [0.x.100]*
     Draw a legend next to the plotted grid, explaining the label of the     cells.    
* [0.x.101]*
     Constructor.    
* [0.x.102]*
   Flags for grid output in MathGL format.    
*  [2.x.37]   
* [0.x.103]*
     Constructor.    
* [0.x.104]*
     Draw a bounding box around the graph.    
* [0.x.105]*
     Declare parameters in ParameterHandler.    
* [0.x.106]*
     Parse parameters of ParameterHandler.    
* [0.x.107]*
   Flags for grid output in Vtk format. These flags are the same as those   declared in  [2.x.38]     
*  [2.x.39]   
* [0.x.108]*
     Default constructor.    
* [0.x.109]*
     Output cells.    
* [0.x.110]*
     Output faces.    
* [0.x.111]*
     Output co-faces/edges.    
* [0.x.112]*
     Output only faces/co-faces that differ from the default settings     (e.g boundary_id).    
* [0.x.113]*
   Flags for grid output in Vtu format. These flags are the same as those   declared in  [2.x.40]  with the addition of a flag that   determines if you want to add a entry in the vtu file (which is really   a xml file) containing the entire serialization of the triangulation.    
*  [2.x.41]   
* [0.x.114]*
     Add to the vtu file also the serialized triangulation.    
* [0.x.115]*
 This class provides a means to output a triangulation to a file in different formats. See the enum  [2.x.42]  for a list of formats and the corresponding output function names.
*  Usage is simple: either you use the direct form

* 
* [1.x.0]
*  if you know which format you want to have, or if you want the format to be a runtime parameter, you can write

* 
* [1.x.1]
*  The function <tt>get_output_format_names()</tt> provides a list of possible names of output formats in a string that is understandable by the ParameterHandler class.
*  Note that here, we have created an unnamed object of type GridOut and called one of its <tt>write_*</tt> functions. This looks like as if the respective function could really be made  [2.x.43]  This was not done in order to allow for parameters to be passed to the different output functions in a way compatible with the scheme of allowing the right output format to be selected at run-time through the generic  [2.x.44]  function.
*  In order to explain this, consider each function had one or more additional parameters giving the details of output, for example position of the spectator for 3d meshed, line thicknesses, etc. While this would allow each output function any flexibility it needs, it would not allow us to use the generic function  [2.x.45]  which is given a parameter determining the output format, since it is impractical to give it a list of parameters for each and every output format supported which it may then pass on to the respective output function.
*  Rather, we have chosen to let each object of this class GridOut have a set of parameters for each supported output format. These are collected in structures  [2.x.46]   [2.x.47]  etc declared in the GridOutFlags namespace, and you can set your preferred flags like this:

* 
* [1.x.2]
*  The respective output function then use the so-set flags. By default, they are set to reasonable values as described above and in the documentation of the different flags structures. Resetting the flags can be done by calling <tt>grid_out.set_flags  [2.x.48]  since the default constructor of each of the flags structures sets the parameters to their initial values.
*  The advantage of this approach is that it is possible to change the flags of one or more output formats according to your needs and later use the generic  [2.x.49]  function; the actual output function then called will use the flags as set before.
*  Note that some of the structures describing the flags of the different output formats are empty since the respective format does not support any flags. The structure and the  [2.x.50]  function are provided anyway. Note also that some of the structures may differ between the dimensions supported by this class; they then have a template parameter, as usual.
* 

* 
*  [2.x.51] 

* 
*  [2.x.52] 

* 
* [0.x.116]*
   Declaration of a name for each of the different output formats. These are   used by the generic output function write() to determine the actual   output format.  
* [0.x.117]*
   Constructor.  
* [0.x.118]*
   Write triangulation in OpenDX format.     Cells or faces are written together with their level and their material   id or boundary indicator, resp.     Not implemented for the codimension one case.  
* [0.x.119]*
   Write the triangulation in the gnuplot format.     In GNUPLOT format, each cell is written as a sequence of its confining   lines. Apart from the coordinates of the lines' end points, the level and   the material of the cell are appended to each line of output. Therefore,   if you let GNUPLOT draw a 2d grid as a 3d plot, you will see more refined   cells being raised against cells with less refinement.  Also, if you draw   a cut through a 3d grid, you can extrude the refinement level in the   direction orthogonal to the cut plane. The same can be done with the   material id, which is plotted after the level.     A more useful application of this feature is the following: if you use   the GNUPLOT command (for a 2d grid here)  
* [1.x.3]
*    then the whole x- and y-range will be plotted, i.e. the whole grid, but   only those lines with a z-value between 2.5 and 3.5. Since the z-values   were chosen to be the level to which a cell belongs, this results in a   plot of those cells only that belong to level 3 in this example. This   way, it is easy to produce plots of the different levels of grid.      [2.x.53]  is a pointer to a mapping used for the transformation of cells   at the boundary. If zero, then use standard Q1 mapping.     Names and values of additional flags controlling the output can be found   in the documentation of the  [2.x.54]  class, which also   describes some caveats for the codimension one case.  
* [0.x.120]*
   Write the triangulation in the msh format.     Msh is the format used by %Gmsh and it is described in the %Gmsh user's   guide. Besides the usual output of the grid only, you can decide through   additional flags (see below, and the documentation of the    [2.x.55]  class) whether boundary faces with non-zero boundary   indicator shall be written to the file explicitly. This is useful, if you   want to re-read the grid later on, since <tt>deal.II</tt> sets the   boundary indicator to zero by default; therefore, to obtain the same   triangulation as before, you have to specify faces with differing   boundary indicators explicitly, which is done by this flag.     Names and values of further flags controlling the output can be found in   the documentation of the  [2.x.56]  class.     Works also in the codimension one case.  
* [0.x.121]*
   Write the triangulation in any format supported by gmsh API.     Gmsh API allows writing its output in several formats through their C++   API. This function translates a Triangulation object into a gmsh collection   of entities and calls the  [2.x.57]  method with the filename passed as   argument. This method generates a different entity for each unique pair of   non default manifold id and boundary id, and writes a gmsh physical group   for each unique combination, allowing you to read back the triangulation   using the  [2.x.58]  method that takes a string as argument.     In particular, all cell objects with non default boundary id or non   default manifold id are grouped in a unique physical tag, whose name   contains the boundary and manifold indicators. The names are constructed   using  [2.x.59]  applied to a  [2.x.60]  int>`   where the keys are either `MaterialID`, `BoundaryID`, or `ManifoldID`,   i.e., a cell with material id 1, and manifold id 3 would be grouped in a   physical tag (whose numbering is not specified), named   `MaterialID:1, ManifoldID:3`.     For example, calling the method with a hyper ball grid refined once,   would results in the following physical tags defined in the output file:  
* [1.x.4]
*      The special boundary id `-1` is used to indicate internal boundaries. The   internal boundaries must be specified whenever it is necessary to specify   a non-flat manifold id.  
* [0.x.122]*
   Write the triangulation in the ucd format.     UCD (unstructured cell data) is the format used by AVS and some other   programs. It is described in the AVS developer's guide. Besides the usual   output of the grid only, you can decide through additional flags (see   below, and the documentation of the  [2.x.61]  class) whether   boundary faces with non-zero boundary indicator shall be written to the   file explicitly. This is useful, if you want to re-read the grid later   on, since <tt>deal.II</tt> sets the boundary indicator to zero by   default; therefore, to obtain the same triangulation as before, you have   to specify faces with differing boundary indicators explicitly, which is   done by this flag.     Names and values of further flags controlling the output can be found in   the documentation of the  [2.x.62]  class.     Works also for the codimension one case.  
* [0.x.123]*
   Write the triangulation in the encapsulated postscript format.     In this format, each line of the triangulation is written separately. We   scale the picture such that either x-values or y-values range between   zero and a fixed size. The other axis is scaled by the same factor. Which   axis is taken to compute the scale and the size of the box it shall fit   into is determined by the output flags (see below, and the documentation   of the  [2.x.63]  class).     The bounding box is close to the triangulation on all four sides, without   an extra frame. The line width is chosen to be 0.5 by default, but can be   changed. The line width is to be compared with the extension of the   picture, of which the default is 300.     The flag  [2.x.64]  allows to draw lines with the  [2.x.65]    user_flag set to be drawn in red. The colors black and red are defined as    [2.x.66]  and  [2.x.67]  in the preamble of the output file and can be changed there   according to need.      [2.x.68]  is a pointer to a mapping used for the transformation of cells   at the boundary. If zero, then use standard Q1 mapping.     Names and values of additional flags controlling the output can be found   in the documentation of the  [2.x.69]  class. Especially the   viewpoint for three dimensional grids is of importance here.     Not implemented for the codimension one case.  
* [0.x.124]*
   Write two-dimensional XFig-file.     This function writes all grid cells as polygons and optionally boundary   lines. Several parameters can be adjusted by the XFigFlags control   object.     If levels are coded to depth, the complete grid hierarchy is plotted with   fine cells before their parents. This way, levels can be switched on and   off in xfig by selecting levels.     Polygons are either at depth 900-level or at 900+ [2.x.70]    depending on the flag  [2.x.71]  Accordingly, boundary edges are at   depth 800-level or at 800+ [2.x.72]  Therefore, boundary edges are   always in front of cells.     Not implemented for the codimension one case.  
* [0.x.125]*
   Write the triangulation in the SVG format.     SVG (Scalable Vector Graphics) is an XML-based vector image format   developed and maintained by the World Wide Web Consortium (W3C). This   function conforms to the latest specification SVG 1.1, released on August   16, 2011.     The cells of the triangulation are written as polygons with additional   lines at the boundary of the triangulation. A coloring of the cells is   further possible in order to visualize a certain property of the cells   such as their level or material id. A colorbar can be drawn to encode the   chosen coloring.  Moreover, a cell label can be added, showing level   index, etc. Indeed, by using the set_flags() with an appropriately   generated object of type  [2.x.73]  many aspects of how and   what is being visualized by this function can be customized.    
*  [2.x.74]  This function is currently only implemented for two-dimensional   grids in two space dimensions.  
* [0.x.126]*
   Declaration of the same function as above for all other dimensions and   space dimensions. This function is not currently implemented and is only   declared to exist to support dimension independent programming.  
* [0.x.127]*
   Write triangulation in MathGL script format. To interpret this file a   version of MathGL>=2.0.0 is required.     To get a handle on the resultant MathGL script within a graphical   environment an interpreter is needed. A suggestion to start with is    [2.x.75]    can interpret and display small-to-medium MathGL scripts in a graphical   window and enables conversion to other formats such as EPS, PNG, JPG,   SVG, as well as view/display animations. Some minor editing, such as   modifying the lighting or alpha channels, can also be done.    
*  [2.x.76]  Not implemented for the codimension one case.  
* [0.x.128]*
   Write triangulation in VTK format. This function writes a   UNSTRUCTURED_GRID file, that contains the following VTK cell types:   VTK_HEXAHEDRON, VTK_QUAD, and VTK_LINE, depending on the template   dimension.     In three dimensions, this function writes a file that contains
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - VTK_HEXAHEDRON cell types, containing the cell information of the     Triangulation
* 

* 
* 

* 
* 

* 
* 
*  - VTK_QUAD cell types, containing all boundary faces with non-zero     boundary ids, and all faces with non-flat manifold ids
* 

* 
* 

* 
* 

* 
* 
*  - VTK_LINE cell types, containing all boundary edges with non-zero     boundary ids, and all edges with non-flat manifold ids     In two dimensions:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - VTK_QUAD cell types, containing the cell information of the     Triangulation
* 

* 
* 

* 
* 

* 
* 
*  - VTK_LINE cell types, containing all boundary faces with non-zero     boundary ids, and all faces with non-flat manifold ids     In one dimension
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - VTK_LINE cell types, containing the cell information of the     Triangulation     The output file will contain two CELL_DATA sections, `MaterialID` and   `ManifoldID`, recording for each VTK cell type the material or boundary id,   and the manifold. See the   [VTK file format](http://www.vtk.org/VTK/img/file-formats.pdf)   documentation for an explanation of the generated output.     The companion  [2.x.77]  function can be used to read VTK files   generated with this method.  
* [0.x.129]*
   Write triangulation in VTU format.     Due to the way this function writes data to the output stream,   the resulting output files correspond to a faithful representation   of the mesh in that all cells are visible for visualization. In general,   the data is not in a format that allows reading this file in again   through the GridIn class. This is because every vertex of the mesh is   duplicated as many times as there are adjacent cells. In other words,   every cell has its own, separate set of vertices that are at the   same location as the vertices of other cells, but are separately   numbered.     In order to create a file that can be read with the GridIn class,   the flag  [2.x.78]  must be set to true. In   this case, the generated vtu file will contain the triangulation in a xml   section which is ignored by general vtu readers.  
* [0.x.130]*
   Write triangulation in VTU format for each processor, and add a .pvtu file   for visualization in VisIt or Paraview that describes the collection of VTU   files as all part of the same simulation. The output is in the form   <tt>filename_without_extension.proc000*.vtu</tt> where is   0,1,...,n_proc-1 and <tt>filename_without_extension.pvtu</tt>. The input   <tt>view_levels</tt> can be set as true to view each level of a multilevel   method. The input <tt>include_artificial</tt> can be set as true to view   the artificial cells for each processor. Each .vtu and .pvtu file will have   the attributes subdomain, level_subdomain, level, and proc_writing. The   level value can be used to separate the image into the view of the grid on   each level of a multilevel method and the proc_writing value can be used to   separate the image into each processor's owned and ghost cells. This is   accomplished by applying the "warp by scalar" filter in paraview to each of   the values. After opening the .pvtu file of a mesh where the input   <tt>view_levels</tt> is set to true, select the "warp by scalar"   filter. For the "Scalars" input select <tt>proc_writing</tt> and for the   "Normal" input enter in 1 0 0, then click Apply. Next select the "warp by   scalar" filter again. For the "Scalars" input select <tt>level</tt> and for   the "Normal" input enter in 0 1 0, then click Apply. This will give you the   following image.    [2.x.79]    If the <tt>view_levels</tt> remains at false, thereby only giving the mesh   for the active level, it is enough to separate the image into the views   written by different processors. This is shown in the following image where   the <tt>include_artificial</tt> input is set as true.    [2.x.80]    Note: Depending on the size of the mesh you may need to increase the "Scale   Factor" input so that each piece does not overlap.  
* [0.x.131]*
   Write grid to  [2.x.81]  according to the given data format. This function   simply calls the appropriate <tt>write_*</tt> function.  
* [0.x.132]*
   Write mesh in default format set by ParameterHandler.  
* [0.x.133]*
   Set flags for DX output  
* [0.x.134]*
   Set flags for %Gmsh output  
* [0.x.135]*
   Set flags for UCD output  
* [0.x.136]*
   Set flags for GNUPLOT output  
* [0.x.137]*
   Set flags for EPS output of a one-dimensional triangulation  
* [0.x.138]*
   Set flags for EPS output of a two-dimensional triangulation  
* [0.x.139]*
   Set flags for EPS output of a three-dimensional triangulation  
* [0.x.140]*
   Set flags for EPS output of a three-dimensional triangulation  
* [0.x.141]*
   Set flags for SVG output  
* [0.x.142]*
   Set flags for MathGL output  
* [0.x.143]*
   Set flags for VTK output  
* [0.x.144]*
   Set flags for VTU output  
* [0.x.145]*
   Provide a function that can tell us which suffix a given output format   usually has. For example, it defines the following mappings:    [2.x.82]     [2.x.83]   [2.x.84]  <tt>.dx</tt>    [2.x.85]   [2.x.86]  <tt>.gnuplot</tt>    [2.x.87]   [2.x.88]  <tt>.inp</tt>    [2.x.89]   [2.x.90]  <tt>.eps</tt>.    [2.x.91]    Similar mappings are provided for all implemented formats.     Since this function does not need data from this object, it is static and   can thus be called without creating an object of this class.  
* [0.x.146]*
   Default suffix for the default output format selected through   ParameterHandler.  
* [0.x.147]*
   Return the  [2.x.92]  value corresponding to the given string. If   the string does not match any known format, an exception is thrown.     Since this function does not need data from this object, it is static and   can thus be called without creating an object of this class. Its main   purpose is to allow a program to use any implemented output format   without the need to extend the program's parser each time a new format is   implemented.     To get a list of presently available format names, e.g. to give it to the   ParameterHandler class, use the function get_output_format_names().  
* [0.x.148]*
   Return a list of implemented output formats. The different names are   separated by vertical bar signs (<tt>`|'</tt>) as used by the   ParameterHandler classes.  
* [0.x.149]*
   Declare parameters in ParameterHandler.  
* [0.x.150]*
   Parse parameters of ParameterHandler.  
* [0.x.151]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.152]*
   Exception  
* [0.x.153]*
   The default output format, set by a ParameterHandler.  
* [0.x.154]*
   Flags for OpenDX output.  
* [0.x.155]*
   Flags for %Gmsh output. Can be changed by using the set_flags(const    [2.x.93]  function.  
* [0.x.156]*
   Flags for UCD output. Can be changed by using the set_flags(const    [2.x.94]  function.  
* [0.x.157]*
   Flags to be used upon output of GNUPLOT data. Can be changed by using the   set_flags(const  [2.x.95]  function.  
* [0.x.158]*
   Flags to be used upon output of EPS data in one space dimension. Can be   changed by using the set_flags(const  [2.x.96]  function.  
* [0.x.159]*
   Flags to be used upon output of EPS data in two space dimensions. Can be   changed by using the  [2.x.97]  function.  
* [0.x.160]*
   Flags to be used upon output of EPS data in three space dimensions. Can   be changed by using the  [2.x.98]  function.  
* [0.x.161]*
   Flags used for XFig output.  
* [0.x.162]*
   Flags used for Svg output.  
* [0.x.163]*
   Flags for MathGL output.  
* [0.x.164]*
   Flags for VTK output.  
* [0.x.165]*
   Flags for VTU output.  
* [0.x.166]*
   Write the grid information about faces to  [2.x.99]  Only those faces are   printed which are on the boundary and which have a boundary indicator not   equal to zero, since the latter is the default for boundary faces.     Since, in %Gmsh, geometric elements are continuously numbered, this   function requires a parameter  [2.x.100]  providing the next   geometric element number. This index should have a numerical value equal   to one more than the index previously used to write a geometric element   to  [2.x.101]       [2.x.102]  The next unused geometric element index.      [2.x.103]   [2.x.104]  should be (at least) one larger than the   current number of triangulation elements (lines, cells, faces) that have   been written to  [2.x.105]  %Gmsh will not load the saved file correctly if   there are repeated indices.     This function unfortunately can not be included in the regular  [2.x.106]    write_msh function, since it needs special treatment for the case   <tt>dim==1</tt>, in which case the face iterators are <tt>void*</tt>'s   and lack the member functions which are called. We would not actually   call these functions, but the compiler would complain anyway when   compiling the function for <tt>dim==1</tt>. Bad luck.  
* [0.x.167]*
   Declaration of the specialization of above function for 1d. Does nothing.  
* [0.x.168]*
   Declaration of the specialization of above function for 1d, 2sd. Does   nothing.  
* [0.x.169]*
   Write the grid information about lines to  [2.x.107]  Only those lines are   printed which are on the boundary and which have a boundary indicator not   equal to zero, since the latter is the default for boundary faces.     Since, in %Gmsh, geometric elements are continuously numbered, this   function requires a parameter  [2.x.108]  providing the next   geometric element number. This index should have a numerical value equal   to one more than the index previously used to write a geometric element   to  [2.x.109]       [2.x.110]  The next unused geometric element index.      [2.x.111]   [2.x.112]  should be (at least) one larger than the   current number of triangulation elements (lines, cells, faces) that have   been written to  [2.x.113]  %Gmsh will not load the saved file correctly if   there are repeated indices.     This function unfortunately can not be included in the regular  [2.x.114]    write_msh function, since it needs special treatment for the case   <tt>dim==1</tt> and <tt>dim==2</tt>, in which case the edge iterators are   <tt>void*</tt>'s and lack the member functions which are called. We would   not actually call these functions, but the compiler would complain anyway   when compiling the function for <tt>dim==1/2</tt>. Bad luck.  
* [0.x.170]*
   Declaration of the specialization of above function for 1d. Does nothing.  
* [0.x.171]*
   Declaration of the specialization of above function for 1d, 2sd. Does   nothing.  
* [0.x.172]*
   Declaration of the specialization of above function for 1d, 3sd. Does   nothing.  
* [0.x.173]*
   Declaration of the specialization of above function for 2d. Does nothing.  
* [0.x.174]*
   Declaration of the specialization of above function for 2d, 3sd. Does   nothing.  
* [0.x.175]*
   Write the grid information about faces to  [2.x.115]  Only those faces are   printed which are on the boundary and which have a boundary indicator not   equal to zero, since the latter is the default for boundary faces.     Since (in the UCD format) geometric elements are continuously numbered,   this function requires a parameter  [2.x.116]  providing the   next geometric element number. This index should have a numerical value   equal to one more than the index previously used to write a geometric   element to  [2.x.117]       [2.x.118]  The next unused geometric element index.      [2.x.119]   [2.x.120]  should be (at least) one larger than the   current number of triangulation elements (lines, cells, faces) that have   been written to  [2.x.121]  Visualization programs may not load the saved   file correctly if there are repeated indices.     This function unfortunately can not be included in the regular  [2.x.122]    write_ucd function, since it needs special treatment for the case   <tt>dim==1</tt>, in which case the face iterators are <tt>void*</tt>'s   and lack the member functions which are called. We would not actually   call these functions, but the compiler would complain anyway when   compiling the function for <tt>dim==1</tt>. Bad luck.  
* [0.x.176]*
   Declaration of the specialization of above function for 1d. Does nothing.  
* [0.x.177]*
   Declaration of the specialization of above function for 1d, 2sd. Does   nothing.  
* [0.x.178]*
   Write the grid information about lines to  [2.x.123]  Only those lines are   printed which are on the boundary and which have a boundary indicator not   equal to zero, since the latter is the default for boundary lines.     Since (in the UCD format) geometric elements are continuously numbered,   this function requires a parameter  [2.x.124]  providing the   next geometric element number. This index should have a numerical value   equal to one more than the index previously used to write a geometric   element to  [2.x.125]       [2.x.126]  The next unused geometric element index.      [2.x.127]   [2.x.128]  should be (at least) one larger than the   current number of triangulation elements (lines, cells, faces) that have   been written to  [2.x.129]  Visualization programs may not load the saved   file correctly if there are repeated indices.     This function unfortunately can not be included in the regular  [2.x.130]    write_ucd function, since it needs special treatment for the case   <tt>dim==1/2</tt>, in which case the edge iterators are <tt>void*</tt>'s   and lack the member functions which are called. We would not actually   call these functions, but the compiler would complain anyway when   compiling the function for <tt>dim==1/2</tt>. Bad luck.  
* [0.x.179]*
   Declaration of the specialization of above function for 1d. Does nothing.  
* [0.x.180]*
   Declaration of the specialization of above function for 1d, 2sd. Does   nothing.  
* [0.x.181]*
   Declaration of the specialization of above function for 1d, 3sd. Does   nothing.  
* [0.x.182]*
   Declaration of the specialization of above function for 2d. Does nothing.  
* [0.x.183]*
   Declaration of the specialization of above function for 2d, 3sd. Does   nothing.  
* [0.x.184]*
   Return the number of faces in the triangulation which have a boundary   indicator not equal to zero. Only these faces are explicitly printed in   the <tt>write_*</tt> functions; all faces with indicator    [2.x.131]  are interior ones and an indicator   with value zero for faces at the boundary  are considered default.     This function always returns an empty list in one dimension.     The reason for this function is the same as for write_ucd_faces(). See   there for more information.  
* [0.x.185]*
   Declaration of the specialization of above function for 1d. Simply   returns zero.  
* [0.x.186]*
   Declaration of the specialization of above function for 1d, 2sd. Simply   returns zero.  
* [0.x.187]*
   Declaration of the specialization of above function for 1d, 3sd. Simply   returns zero.  
* [0.x.188]*
   Return the number of lines in the triangulation which have a boundary   indicator not equal to zero. Only these lines are explicitly printed in   the <tt>write_*</tt> functions; all lines with indicator    [2.x.132]  are interior ones and an indicator   with value zero for faces at the boundary are considered default.     This function always returns an empty list in one and two dimensions.     The reason for this function is the same as for write_ucd_faces(). See   there for more information.  
* [0.x.189]*
   Declaration of the specialization of above function for 1d. Simply   returns zero.  
* [0.x.190]*
   Declaration of the specialization of above function for 1d, 2sd. Simply   returns zero.  
* [0.x.191]*
   Declaration of the specialization of above function for 1d, 3sd. Simply   returns zero.  
* [0.x.192]*
   Declaration of the specialization of above function for 2d. Simply   returns zero.  
* [0.x.193]*
   Declaration of the specialization of above function for 2d, 3sd. Simply   returns zero.  
* [0.x.194]