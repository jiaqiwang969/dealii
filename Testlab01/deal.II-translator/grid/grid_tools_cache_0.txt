[0.x.0]*
   A class that caches computationally intensive information about a   Triangulation.     This class attaches a signal to the Triangulation passed at construction   time to keep track about refinement changes, and allows the user to query   some of the data structures constructed using functions in the GridTools   namespace which are computed only once, and then cached inside this class   for faster access whenever the triangulation has not changed.     Notice that this class only notices if the underlying Triangulation has   changed due to a  [2.x.0]  signal being   triggered.     If the triangulation changes for other reasons, for example because you   use it in conjunction with a MappingQEulerian object that sees the   vertices through its own transformation, or because you manually change   some vertex locations, then some of the structures in this class become   obsolete, and you will have to mark them as outdated, by calling the   method mark_for_update() manually.  
* [0.x.1]*
     Constructor.         If you provide the optional `mapping` argument, then this is used     whenever a mapping is required.          [2.x.1]  tria The triangulation for which to store information      [2.x.2]  mapping The mapping to use when computing cached objects    
* [0.x.2]*
     Destructor.    
* [0.x.3]*
     Make sure that the objects marked for update are recomputed during     subsequent calls to the `get_*` functions defined in this class.         Notice that no work is performed when you call this function. The actual     data structures are computed the next time you call the corresponding     `get_*` method.          [2.x.3]  flags What to mark for update    
* [0.x.4]*
     Return the cached vertex_to_cell_map as computed by      [2.x.4]     
* [0.x.5]*
     Return the cached vertex_to_cell_centers_directions as computed by      [2.x.5]     
* [0.x.6]*
     Return the cached map of used vertices, as computed by      [2.x.6]     
* [0.x.7]*
     Return the cached RTree object for the vertices, constructed using the     used vertices of the triangulation.    
* [0.x.8]*
     Return the cached RTree object of the cell bounding boxes, constructed     using the active cell iterators of the stored triangulation. For      [2.x.7]  objects, this function will return     also the bounding boxes of ghost and artificial cells.    
* [0.x.9]*
     Return the cached RTree object of bounding boxes containing locally owned     active cells, constructed using the active cell iterators of the stored     triangulation.         In contrast to the previous function, this function builds the RTree     using only the locally owned cells, i.e., not including ghost or     artificial cells. The two functions return the same result in serial     computations.    
* [0.x.10]*
     Returns the vector of set of integer containing the subdomain id     to which each vertex is connected to. This feature is used extensively     in the particle_handler to detect on which processors ghost particles     must be built.    
* [0.x.11]*
     Return a reference to the stored triangulation.    
* [0.x.12]*
     Return a reference to the stored mapping.    
* [0.x.13]*
     This function returns an object that allows identifying     which process(es) in a parallel computation may own the     cell that surrounds a given point. The elements of this     object
* 
*  -  an Rtree
* 
*  -  are pairs of bounding boxes denoting     areas that cover all or parts of the local portion of a     parallel triangulation, and an unsigned int representing     the process or subdomain that owns the cells falling within the given     bounding box.         Given a point on a  [2.x.8]  this tree     allows to identify one, or few candidate processes, for     which the point lies on a locally owned cell.         Constructing or updating the rtree requires a call to      [2.x.9]  which exchanges     bounding boxes between all processes using      [2.x.10]  a collective operation.     Therefore this function must be called by all processes     at the same time.         The local bounding boxes are constructed by extracting the     specified  [2.x.11]  from the rtree object returned by the     get_locally_owned_cell_bounding_boxes_rtree(). Notice that  [2.x.12]      in this context does not refer to the level of the triangulation, but     refer to the level of the RTree object (see, e.g.,     https://en.wikipedia.org/wiki/R-tree).    
* [0.x.14]*
     Keep track of what needs to be updated next.    
* [0.x.15]*
     A pointer to the Triangulation.    
* [0.x.16]*
     Mapping to use when computing on the Triangulation.    
* [0.x.17]*
     Store vertex to cell map information, as generated by      [2.x.13]     
* [0.x.18]*
     Store vertex to cell center directions, as generated by      [2.x.14]     
* [0.x.19]*
     A collection of rtree objects covering the whole mesh.         Each entry of the map is constructed from the function     extract_rtree_level() applied to the rtree returned by the function     get_locally_owned_cell_bounding_boxes_rtree(), with the specified level     in input.    
* [0.x.20]*
     Store the used vertices of the Triangulation, as generated by      [2.x.15]     
* [0.x.21]*
     Store an RTree object, containing the used vertices of the triangulation.    
* [0.x.22]*
     Store an RTree object, containing the bounding boxes of the cells of the     triangulation.    
* [0.x.23]*
     Store an RTree object, containing the bounding boxes of the locally owned     cells of the triangulation.    
* [0.x.24]*
     Store an  [2.x.16]  of  [2.x.17]  of integer containing the id of all     subdomain to which a vertex is connected to.    
* [0.x.25]*
     Storage for the status of the triangulation signal.    
* [0.x.26]