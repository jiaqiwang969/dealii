[0.x.0]*
    [2.x.0]  Assembling of right hand sides  
* [0.x.1]*
   Create a right hand side vector for a point source at point  [2.x.1]  In   other words, it creates a vector  [2.x.2]  so that  [2.x.3]  where  [2.x.4]  are the shape functions   described by  [2.x.5]  and  [2.x.6]  is the point at which the delta   function is located. Prior content of the given  [2.x.7]    vector is deleted. This function is for the case of a scalar finite   element.     This function is typically used in one of these two contexts:
* 

* 
* 

* 
* 

* 
* 
*  - Let's say you want to solve the same kind of problems many times     over, with different values for right hand sides or coefficients,     and then evaluate the solution at the same point every time. You     could do this by calling  [2.x.8]  after each     solve, or you could realize that to evaluate the solution  [2.x.9]      at a point  [2.x.10] , you could rearrange operations like this:    
* [1.x.0]
*      with the vector as defined above. In other words, point evaluation     can be achieved with just a single vector-vector product, and the     vector  [2.x.11]  can be computed once and for all and reused     for each solve, without having to go through the mesh every time     to find out which cell (and where in the cell) the point  [2.x.12]  is     located.
* 

* 
* 

* 
* 

* 
* 
*  - This function is also useful if you wanted to compute the Green's     function for the problem you are solving. This is because the     Green's function  [2.x.13]  is defined by    
* [1.x.1]
*      where  [2.x.14]  is the differential operator of your problem. The discrete     version then requires computing the right hand side vector      [2.x.15] , which is exactly     the vector computed by the current function.     While maybe not relevant for documenting [1.x.2] this   function does, it may be interesting to note that delta functions   do not exist in reality, and consequently, using this function   does not model any real situation. This is, because no real   object is able to focus an infinite force density at an   infinitesimally small part of the domain (rather, all real   devices will spread out the force over a finite area); nor is it   possible to measure values at individual points (but all   measurements will somehow be averaged over small areas). Only if   this area is so small that it cannot be resolved by any mesh does   it make sense to model the situation in a way that uses a delta   function with the same overall force or sensitivity. On the other   hand, a situation that is probably more fruitfully simulated with   a delta function is the electric potential of a point source; in   this case, the solution is known to have a logarithmic   singularity (in 2d) or a  [2.x.16]  singularity (in 3d),   neither of which is bounded.     Mathematically, the use of delta functions typically leads to exact   solutions to which the numerically obtained, approximate solution does   not converge. This is because, taking the Laplace equation as an example,   the error between exact and numerical solution can be bounded by the   expression  
* [1.x.3]
*    but when using a delta function on the right hand side, the term    [2.x.17]  is not finite. This can be seen   by using the a-priori bound for solutions of the Laplace equation    [2.x.18]  that states that  [2.x.19] .   When using a delta function as right hand side,  [2.x.20] ,   one would need to take the  [2.x.21]  norm of a delta function, which   however is not finite because  [2.x.22] .     The consequence of all of this is that the exact solution of the   Laplace equation with a delta function on the right hand side
* 
*  -    i.e., the [1.x.4]
* 
*  -  has a singularity at  [2.x.23]  that   is so strong that it cannot be resolved by a finite element   solution, and consequently finite element approximations do not   converge towards the exact solution in any of the usual norms.     All of this is also the case for all of the other usual second-order   partial differential equations in dimensions two or higher. (Because   in dimension two and higher,  [2.x.24]  functions are not necessarily   continuous, and consequently the delta function is not in the dual   space  [2.x.25] .)  
* [0.x.2]*
   Like the previous function, but for hp-objects.  
* [0.x.3]*
   Call the create_point_source_vector() function, see above, with   an implied default  [2.x.26]  mapping object.     Note that if your DoFHandler uses any active FE index other than zero, then   you need to call the function above that provides a mapping object for each   active FE index.  
* [0.x.4]*
   Create a right hand side vector for a point source at point  [2.x.27]  This   variation of the function is meant for vector-valued problems with   exactly dim components (it will also work for problems with more than dim   components, and in this case simply consider only the first dim   components of the shape functions). It computes a right hand side that   corresponds to a forcing function that is equal to a delta function times   a given direction. In other words, it creates a vector  [2.x.28]  so that  [2.x.29] . Note here that    [2.x.30]  is a vector-valued function.  [2.x.31]  is the given direction   of the source term  [2.x.32]  and corresponds to the  [2.x.33]    direction argument to be passed to this function.     Prior content of the given  [2.x.34]  vector is deleted.     See the discussion of the first create_point_source_vector() variant for   more on the use of delta functions.  
* [0.x.5]*
   Like the previous function, but for hp-objects.  
* [0.x.6]*
   Call the create_point_source_vector() function for vector-valued finite   elements, see above, with an implied default  [2.x.35]  mapping object.     Note that if your DoFHandler uses any active FE index other than zero, then   you need to call the function above that provides a mapping object for each   active FE index.  
* [0.x.7]*
    [2.x.36]  Evaluation of functions and errors  
* [0.x.8]*
   Point error evaluation. Find the first cell containing the given point   and compute the difference of a (possibly vector-valued) finite element   function and a continuous function (with as many vector components as the   finite element) at this point.     This is a wrapper function using a Q1-mapping for cell boundaries to call   the other point_difference() function.    
*  [2.x.37]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.38]  is thrown.  
* [0.x.9]*
   Point error evaluation. Find the first cell containing the given point   and compute the difference of a (possibly vector-valued) finite element   function and a continuous function (with as many vector components as the   finite element) at this point.     Compared with the other function of the same name, this function uses an   arbitrary mapping to evaluate the difference.    
*  [2.x.39]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.40]  is thrown.  
* [0.x.10]*
   Evaluate a possibly vector-valued finite element function defined by the   given DoFHandler and nodal vector  [2.x.41]  at the given point  [2.x.42]    point, and return the (vector) value of this function through the last   argument.     This function uses a  [2.x.43] -mapping for the cell the point is evaluated   in. If you need to evaluate using a different mapping (for example when   using curved boundaries), use the point_difference() function that takes   a mapping.     This function is not particularly cheap. This is because it first   needs to find which cell a given point is in, then find the point   on the reference cell that matches the given evaluation point,   and then evaluate the shape functions there. You probably do not   want to use this function to evaluate the solution at [1.x.5]   points. For this kind of application, the FEFieldFunction class   offers at least some optimizations. On the other hand, if you   want to evaluate [1.x.6] at the same point, you may   want to look at the  [2.x.44]    function.    
*  [2.x.45]  If the cell in which the point is found is not locally owned, an     exception of type  [2.x.46]  is thrown.    
*  [2.x.47]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the value of the finite element field either     here or there, depending on which cell the point is found in. This     does not matter (to within the same tolerance) if the finite element     field is continuous. On the other hand, if the finite element in use     is [1.x.7] continuous, then you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.11]*
   Same as above for hp.    
*  [2.x.48]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.49]  is thrown.    
*  [2.x.50]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the value of the finite element field either     here or there, depending on which cell the point is found in. This     does not matter (to within the same tolerance) if the finite element     field is continuous. On the other hand, if the finite element in use     is [1.x.8] continuous, then you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.12]*
   Evaluate a scalar finite element function defined by the given DoFHandler   and nodal vector  [2.x.51]  at the given point  [2.x.52]  and return   the value of this function.     This function uses a Q1-mapping for the cell the point is evaluated   in. If you need to evaluate using a different mapping (for example when   using curved boundaries), use the point_difference() function that takes   a mapping.     This function is not particularly cheap. This is because it first   needs to find which cell a given point is in, then find the point   on the reference cell that matches the given evaluation point,   and then evaluate the shape functions there. You probably do not   want to use this function to evaluate the solution at [1.x.9]   points. For this kind of application, the FEFieldFunction class   offers at least some optimizations. On the other hand, if you   want to evaluate [1.x.10] at the same point, you may   want to look at the  [2.x.53]    function.     This function is used in the "Possibilities for extensions" part of the   results section of    [2.x.54]  " [2.x.55] ".    
*  [2.x.56]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.57]  is thrown.    
*  [2.x.58]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the value of the finite element field either     here or there, depending on which cell the point is found in. This     does not matter (to within the same tolerance) if the finite element     field is continuous. On the other hand, if the finite element in use     is [1.x.11] continuous, then you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.13]*
   Same as above for hp.    
*  [2.x.59]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.60]  is thrown.    
*  [2.x.61]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the value of the finite element field either     here or there, depending on which cell the point is found in. This     does not matter (to within the same tolerance) if the finite element     field is continuous. On the other hand, if the finite element in use     is [1.x.12] continuous, then you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.14]*
   Evaluate a possibly vector-valued finite element function defined by the   given DoFHandler and nodal vector  [2.x.62]  at the given point  [2.x.63]    point, and return the (vector) value of this function through the last   argument.     Compared with the other function of the same name, this function uses an   arbitrary mapping to evaluate the point value.     This function is not particularly cheap. This is because it first   needs to find which cell a given point is in, then find the point   on the reference cell that matches the given evaluation point,   and then evaluate the shape functions there. You probably do not   want to use this function to evaluate the solution at [1.x.13]   points. For this kind of application, the FEFieldFunction class   offers at least some optimizations. On the other hand, if you   want to evaluate [1.x.14] at the same point, you may   want to look at the  [2.x.64]    function.    
*  [2.x.65]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.66]  is thrown.    
*  [2.x.67]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the value of the finite element field either     here or there, depending on which cell the point is found in. This     does not matter (to within the same tolerance) if the finite element     field is continuous. On the other hand, if the finite element in use     is [1.x.15] continuous, then you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.15]*
   Same as above for hp.    
*  [2.x.68]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.69]  is thrown.    
*  [2.x.70]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the value of the finite element field either     here or there, depending on which cell the point is found in. This     does not matter (to within the same tolerance) if the finite element     field is continuous. On the other hand, if the finite element in use     is [1.x.16] continuous, then you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.16]*
   Evaluate a scalar finite element function defined by the given DoFHandler   and nodal vector  [2.x.71]  at the given point  [2.x.72]  and return   the value of this function.     Compared with the other function of the same name, this function uses an   arbitrary mapping to evaluate the difference.     This function is not particularly cheap. This is because it first   needs to find which cell a given point is in, then find the point   on the reference cell that matches the given evaluation point,   and then evaluate the shape functions there. You probably do not   want to use this function to evaluate the solution at [1.x.17]   points. For this kind of application, the FEFieldFunction class   offers at least some optimizations. On the other hand, if you   want to evaluate [1.x.18] at the same point, you may   want to look at the  [2.x.73]    function.    
*  [2.x.74]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.75]  is thrown.    
*  [2.x.76]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the value of the finite element field either     here or there, depending on which cell the point is found in. This     does not matter (to within the same tolerance) if the finite element     field is continuous. On the other hand, if the finite element in use     is [1.x.19] continuous, then you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.17]*
   Same as above for hp.    
*  [2.x.77]  If the cell in which the point is found is not locally owned, an   exception of type  [2.x.78]  is thrown.    
*  [2.x.79]  This function needs to find the cell within which a point lies,     and this can only be done up to a certain numerical tolerance of course.     Consequently, for points that are on, or close to, the boundary of     a cell, you may get the value of the finite element field either     here or there, depending on which cell the point is found in. This     does not matter (to within the same tolerance) if the finite element     field is continuous. On the other hand, if the finite element in use     is [1.x.20] continuous, then you will get unpredictable values for     points on or close to the boundary of the cell, as one would expect     when trying to evaluate point values of discontinuous functions.  
* [0.x.18]