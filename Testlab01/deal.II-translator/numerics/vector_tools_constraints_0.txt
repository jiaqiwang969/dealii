[0.x.0]*
    [2.x.0]  Interpolation and projection  
* [0.x.1]*
   This function computes the constraints that correspond to boundary   conditions of the form  [2.x.1] ,   i.e., normal flux constraints where  [2.x.2]  is a vector-valued solution   variable and  [2.x.3]  is a prescribed vector field whose normal   component we want to be equal to the normal component of the solution.   These conditions have exactly the form handled by the   AffineConstraints class, in that they relate a [1.x.0] of boundary degrees of freedom to a corresponding   value (the inhomogeneity of the constraint). Consequently, the current   function creates a list of constraints that are written into an   AffineConstraints container. This object may already have some   content, for example from hanging node constraints, that remains   untouched. These constraints have to be applied to the linear system   like any other such constraints, i.e., you have to condense the linear   system with the constraints before solving, and you have to distribute   the solution vector afterwards.     This function treats a more general case than    [2.x.4]  (which can only handle   the case where  [2.x.5] , and is used in    [2.x.6]  and  [2.x.7] ). However, because everything that would apply   to that function also applies as a special case to the current   function, the following discussion is relevant to both.    
*  [2.x.8]  This function doesn't make much sense in 1d, so it throws an     exception if  [2.x.9]  equals one.       [1.x.1]     The second argument of this function denotes the first vector component   in the finite element that corresponds to the vector function that you   want to constrain. For example, if we were solving a Stokes equation in   2d and the finite element had components  [2.x.10] , then  [2.x.11]    first_vector_component needs to be zero if you intend to constraint   the vector  [2.x.12] .   On the other hand, if we solved the   Maxwell equations in 3d and the finite element has components    [2.x.13]  and we want the boundary condition  [2.x.14] , then  [2.x.15]    would be 3. Vectors are implicitly assumed to have exactly    [2.x.16]  components that are ordered in the same way as we   usually order the coordinate directions, i.e.  [2.x.17] -,  [2.x.18] -, and finally    [2.x.19] -component. The function assumes, but can't check, that the vector   components in the range    [2.x.20]  come   from the same base finite element. For example, in the Stokes example   above, it would not make sense to use a    [2.x.21]    (note that the first velocity vector component is a  [2.x.22]  element,   whereas all the other ones are  [2.x.23]  elements) as there would be points   on the boundary where the  [2.x.24] -velocity is defined but no corresponding    [2.x.25] - or  [2.x.26] -velocities.     The third argument denotes the set of boundary indicators on which the   boundary condition is to be enforced. Note that, as explained below, this   is one of the few functions where it makes a difference where we call the   function multiple times with only one boundary indicator, or whether we   call the function once with the whole set of boundary indicators at once.     Argument four ( [2.x.27]  describes the boundary function  [2.x.28]  for each boundary id. The function  [2.x.29]    is used on boundary with id  [2.x.30]  taken from the set  [2.x.31]    Each function in  [2.x.32]  is expected to have  [2.x.33]    components, which are used independent of  [2.x.34]      The mapping argument is used to compute the boundary points at which the   function needs to request the normal vector  [2.x.35]  from the boundary   description.    
*  [2.x.36]  When combining adaptively refined meshes with hanging node   constraints and boundary conditions like from the current function within   one AffineConstraints object, the hanging node constraints should always   be set first, and then the boundary conditions since boundary conditions   are not set in the second operation on degrees of freedom that are   already constrained. This makes sure that the discretization remains   conforming as is needed. See the discussion on conflicting constraints in   the module on    [2.x.37] .       [1.x.2]     Computing these constraints requires some smarts. The main question   revolves around the question what the normal vector is. Consider the   following situation:      [2.x.38]      Here, we have two cells that use a bilinear mapping (i.e.,   MappingQGeneric(1)). Consequently, for each of the cells, the normal   vector is perpendicular to the straight edge. If the two edges at the top   and right are meant to approximate a curved boundary (as indicated by the   dashed line), then neither of the two computed normal vectors are equal   to the exact normal vector (though they approximate it as the mesh is   refined further). What is worse, if we constrain  [2.x.39]  at the common vertex with the normal vector   from both cells, then we constrain the vector  [2.x.40]  with respect to   two linearly independent vectors; consequently, the constraint would be    [2.x.41]  at this point (i.e. [1.x.3] components of the   vector), which is not what we wanted.     To deal with this situation, the algorithm works in the following way: at   each point where we want to constrain  [2.x.42] , we first collect all   normal vectors that adjacent cells might compute at this point. We then   do not constrain  [2.x.43]  for   [1.x.4] of these normal vectors but only for the [1.x.5] of   the normal vectors. In the example above, we therefore record only a   single constraint  [2.x.44] , where  [2.x.45]  is the average of the two indicated   normal vectors.     Unfortunately, this is not quite enough. Consider the situation here:      [2.x.46]      If again the top and right edges approximate a curved boundary, and the   left boundary a separate boundary (for example straight) so that the   exact boundary has indeed a corner at the top left vertex, then the above   construction would not work: here, we indeed want the constraint that    [2.x.47]  at this point (because the normal velocities with respect to   both the left normal as well as the top normal vector should be zero),   not that the velocity in the direction of the average normal vector is   zero.     Consequently, we use the following heuristic to determine whether all   normal vectors computed at one point are to be averaged: if two normal   vectors for the same point are computed on [1.x.6] cells, then   they are to be averaged. This covers the first example above. If they are   computed from the same cell, then the fact that they are different is   considered indication that they come from different parts of the boundary   that might be joined by a real corner, and must not be averaged.     There is one problem with this scheme. If, for example, the same domain   we have considered above, is discretized with the following mesh, then we   get into trouble:      [2.x.48]      Here, the algorithm assumes that the boundary does not have a corner at   the point where faces  [2.x.49]  and  [2.x.50]  join because at that point there are   two different normal vectors computed from different cells. If you intend   for there to be a corner of the exact boundary at this point, the only   way to deal with this is to assign the two parts of the boundary   different boundary indicators and call this function twice, once for each   boundary indicators; doing so will yield only one normal vector at this   point per invocation (because we consider only one boundary part at a   time), with the result that the normal vectors will not be averaged. This   situation also needs to be taken into account when using this function   around reentrant corners on Cartesian meshes. If normal-flux boundary   conditions are to be enforced on non-Cartesian meshes around reentrant   corners, one may even get cycles in the constraints as one will in   general constrain different components from the two sides. In that case,   set a no-slip constraint on the reentrant vertex first.       [1.x.7]     The situation is more complicated in 3d. Consider the following case   where we want to compute the constraints at the marked vertex:      [2.x.51]      Here, we get four different normal vectors, one from each of the four   faces that meet at the vertex. Even though they may form a complete set   of vectors, it is not our intent to constrain all components of the   vector field at this point. Rather, we would like to still allow   tangential flow, where the term "tangential" has to be suitably defined.     In a case like this, the algorithm proceeds as follows: for each cell   that has computed two tangential vectors at this point, we compute the   unconstrained direction as the outer product of the two tangential   vectors (if necessary multiplied by minus one). We then average these   tangential vectors. Finally, we compute constraints for the two   directions perpendicular to this averaged tangential direction.     There are cases where one cell contributes two tangential directions and   another one only one; for example, this would happen if both top and   front faces of the left cell belong to the boundary selected whereas only   the top face of the right cell belongs to it, maybe indicating that the   entire front part of the domain is a smooth manifold whereas the top   really forms two separate manifolds that meet in a ridge, and that   normal-flux boundary conditions are only desired on the front manifold   and the right one on top. In cases like these, it's difficult to define   what should happen. The current implementation simply ignores the one   contribution from the cell that only contributes one normal vector. In   the example shown, this is acceptable because the normal vector for the   front face of the left cell is the same as the normal vector provided by   the front face of the right cell (the surface is planar) but it would be   a problem if the front manifold would be curved. Regardless, it is   unclear how one would proceed in this case and ignoring the single cell   is likely the best one can do.       [1.x.8]     Because it makes for good pictures, here are two images of vector fields   on a circle and on a sphere to which the constraints computed by this   function have been applied (for illustration purposes, we enforce zero   normal flux, which can more easily be computed using    [2.x.52]  as this must   lead to a [1.x.9] vector field):      [2.x.53]      The vectors fields are not physically reasonable but the tangentiality   constraint is clearly enforced. The fact that the vector fields are zero   at some points on the boundary is an artifact of the way it is created,   it is not constrained to be zero at these points.    
*  [2.x.54]       [2.x.55]     [2.x.56]  "Glossary entry on boundary indicators"  
* [0.x.2]*
   This function does the same as the   compute_nonzero_normal_flux_constraints() function (see there for more   information), but for the simpler case of homogeneous normal-flux   constraints, i.e., for imposing the condition    [2.x.57] . This function is used in  [2.x.58]  and  [2.x.59] .    
*  [2.x.60]       [2.x.61]     [2.x.62]  "Glossary entry on boundary indicators"  
* [0.x.3]*
   Compute the constraints that correspond to boundary conditions of the   form  [2.x.63] , i.e., tangential   flow constraints where  [2.x.64]  is a vector-valued solution   variable and  [2.x.65]  is prescribed vector field whose tangential   component(s) we want to be equal to the tangential component(s) of the   solution. This function constrains exactly those dim-1 vector-valued   components that are left unconstrained by    [2.x.66]  and leaves the one   component unconstrained that is constrained by that function.    
*  [2.x.67]       [2.x.68]     [2.x.69]  "Glossary entry on boundary indicators"  
* [0.x.4]*
   Same as above for homogeneous tangential-flux constraints.    
*  [2.x.70]       [2.x.71]     [2.x.72]  "Glossary entry on boundary indicators"  
* [0.x.5]