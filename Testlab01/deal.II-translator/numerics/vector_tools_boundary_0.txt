[0.x.0]*
    [2.x.0]  Interpolation and projection  
* [0.x.1]*
   Compute constraints on the solution that corresponds to the imposition   of Dirichlet boundary conditions.  This function creates a map of   degrees of freedom subject to Dirichlet boundary conditions and the   corresponding values to be assigned to them, by interpolation around the   boundary. For each degree of freedom at the boundary, if its index   already exists in  [2.x.1]  then its boundary value will be   overwritten, otherwise a new entry with proper index and boundary value   for this degree of freedom will be inserted into  [2.x.2]      The parameter  [2.x.3]  provides a list of boundary indicators to   be handled by this function and corresponding boundary value functions.   The keys of this map correspond to the number  [2.x.4]  of the face.    [2.x.5]  is an illegal value for this key since   it is reserved for interior faces. For an example of how to use this   argument with a non-empty map, see the  [2.x.6]  tutorial program.     The flags in the last parameter,  [2.x.7]  denote which   components of the finite element space shall be interpolated. If it is   left as specified by the default value (i.e. an empty array), all   components are interpolated. If it is different from the default value,   it is assumed that the number of entries equals the number of components   in the boundary functions and the finite element, and those components in   the given boundary function will be used for which the respective flag   was set in the component mask. See also    [2.x.8] .   As an example, assume that you are solving the Stokes equations in 2d,   with variables  [2.x.9]  and that you only want to interpolate boundary   values for the velocity, then the component mask should correspond to    [2.x.10] .    
*  [2.x.11]  Whether a component mask has been specified or not, the number of   components of the functions in  [2.x.12]  must match that of the   finite element used by  [2.x.13]  In other words, for the example above, you   need to provide a Function object that has 3 components (the two   velocities and the pressure), even though you are only interested in the   first two of them. interpolate_boundary_values() will then call this   function to obtain a vector of 3 values at each interpolation point but   only take the first two and discard the third. In other words, you are   free to return whatever you like in the third component of the vector   returned by  [2.x.14]  but the Function object must state   that it has 3 components.     If the finite element used has shape functions that are non-zero in more   than one component (in deal.II speak: they are non-primitive), then these   components can presently not be used for interpolating boundary values.   Thus, the elements in the component mask corresponding to the components   of these non-primitive shape functions must be  [2.x.15]      See the general documentation of this namespace for more information.    
*  [2.x.16]  When solving a partial differential equation with boundary     conditions  [2.x.17]  (or onparts* of the boundary),     then this boundary condition is in general not satisfiable exactly     using finite elements in the form  [2.x.18] . That is     because the function  [2.x.19]  is generally not a polynomial, whereas      [2.x.20] is* a polynomial on each face of the     mesh that is located at the boundary. In other words, it is in     general not possible toimpose* such boundary condition; what one    can* do, however, is to impose       [1.x.0]     where  [2.x.21]  is a function that equals  [2.x.22]  at each node     of the finite element space located on the boundary, and is piecewise     polynomial in between. In other words,  [2.x.23]  is an    interpolation operator* and  [2.x.24]  are the     interpolated boundary values
* 
*  -  thus the name. The use of      [2.x.25]  instead of  [2.x.26]  as boundary values imposes     an additional error (in the same spirit as using quadrature introduces     an additional error compared to being able to compute the integrals of     the weak form exactly). In most cases, this additional error is of the     same order as the other error terms in the finite element method,     though there are some subtle differences when measuring the error in     the  [2.x.27]  norm. For some details, see  [2.x.28]  .    
*  [2.x.29]  An alternative to using the interpolant,       [1.x.1]     is to use theprojection* of the boundary values  [2.x.30]  onto the     finite element space on the boundary:       [1.x.2]     The projection is available using the project_boundary_values()     function. Using the projection may have some theoretical advantages     (see again  [2.x.31] ) but has the practical disadvantage     that computing the projection is far more expensive than computing     the interpolation because the latter can be done one face at a time     whereas the projection requires the solution of a problem on the entire     boundary. On the other hand, interpolation is only possible for     "nodal" finite element spaces (such as FE_Q, but not     FE_Q_Hierarchical), whereas the projection is always possible.  
* [0.x.2]*
   Like the previous function, but take a mapping collection to go with   DoFHandler objects with hp-capabilities.  
* [0.x.3]*
   Same function as above, but taking only one pair of boundary indicator   and corresponding boundary function. The same comments apply as for the   previous function, in particular about the use of the component mask and   the requires size of the function object.      [2.x.32]     [2.x.33]  "Glossary entry on boundary indicators"  
* [0.x.4]*
   Like the previous function, but take a mapping collection to go with   DoFHandler objects with hp-capabilities.  
* [0.x.5]*
   Call the other interpolate_boundary_values() function, see above, with   <tt>mapping=MappingQGeneric [2.x.34]  The same comments   apply as for the previous function, in particular about the use of the   component mask and the requires size of the function object.      [2.x.35]     [2.x.36]  "Glossary entry on boundary indicators"  
* [0.x.6]*
   Call the other interpolate_boundary_values() function, see above, with   <tt>mapping=MappingQGeneric [2.x.37]  The same comments   apply as for the previous function, in particular about the use of the   component mask and the requires size of the function object.  
* [0.x.7]*
   Insert the (algebraic) constraints due to Dirichlet boundary conditions   into a AffineConstraints  [2.x.38]  This function identifies the   degrees of freedom subject to Dirichlet boundary conditions, adds them to   the list of constrained DoFs in  [2.x.39]  and sets the respective   inhomogeneity to the value interpolated around the boundary. If this   routine encounters a DoF that already is constrained (for instance by a   hanging node constraint, see below, or any other type of constraint, e.g.   from periodic boundary conditions), the old setting of the constraint   (dofs the entry is constrained to, inhomogeneities) is kept and nothing   happens.    
*  [2.x.40]  When combining adaptively refined meshes with hanging node   constraints and boundary conditions like from the current function within   one AffineConstraints object, the hanging node constraints should always   be set first, and then the boundary conditions since boundary conditions   are not set in the second operation on degrees of freedom that are   already constrained. This makes sure that the discretization remains   conforming as is needed. See the discussion on conflicting constraints in   the module on    [2.x.41] .     This function is fundamentally equivalent to the ones above except that it   puts its results into an AffineConstraint object rather than a  [2.x.42]    See the functions above for more comments.    
*  [2.x.43]   
* [0.x.8]*
   Like the previous function, but take a mapping collection to go with   DoFHandler objects with hp-capabilities.  
* [0.x.9]*
   Same function as above, but taking only one pair of boundary indicator   and corresponding boundary function. The same comments apply as for the   previous function, in particular about the use of the component mask and   the requires size of the function object.    
*  [2.x.44]       [2.x.45]     [2.x.46]  "Glossary entry on boundary indicators"  
* [0.x.10]*
   Like the previous function, but take a mapping collection to go with   DoFHandler objects with hp-capabilities.  
* [0.x.11]*
   Call the other interpolate_boundary_values() function, see above, with   <tt>mapping=MappingQGeneric [2.x.47]  The same comments   apply as for the previous function, in particular about the use of the   component mask and the requires size of the function object.    
*  [2.x.48]       [2.x.49]     [2.x.50]  "Glossary entry on boundary indicators"  
* [0.x.12]*
   Call the other interpolate_boundary_values() function, see above, with   <tt>mapping=MappingQGeneric [2.x.51]  The same comments   apply as for the previous function, in particular about the use of the   component mask and the requires size of the function object.    
*  [2.x.52]   
* [0.x.13]*
   Project a function or a set of functions to the boundary of the domain.   In other words, compute the solution of the following problem: Find  [2.x.53]  (where  [2.x.54]  is the finite element space represented by the   DoFHandler argument of this function) so that  
* [1.x.3]
*    where  [2.x.55] ,  [2.x.56] ,  [2.x.57]  is the set of indices and  [2.x.58]  the   corresponding boundary functions represented in the function map argument    [2.x.59]  to this function, and the integrals are evaluated by   quadrature. This problem has a non-unique solution in the interior, but   it is well defined for the degrees of freedom on the part of the   boundary,  [2.x.60] , for which we do the integration. The values of    [2.x.61] , i.e., the nodal values of the degrees of freedom of this   function along the boundary, are then what is computed by this function.     In case this function is used with  [2.x.62]  conforming finite element   space, the solution of a different problem is computed, namely: Find    [2.x.63]  so that  
* [1.x.4]
*    where  [2.x.64]  is an outward normal vector.     This function throws an exception if used with  [2.x.65]  conforming   elements, so the project_boundary_values_curl_conforming_l2() should be   used instead.      [2.x.66]  mapping The mapping that will be used in the transformations   necessary to integrate along the boundary.    [2.x.67]  dof The DoFHandler that describes the finite element space and   the numbering of degrees of freedom.    [2.x.68]  boundary_functions A map from boundary indicators to pointers   to functions that describe the desired values on those parts of the   boundary marked with this boundary indicator (see    [2.x.69]  "Boundary indicator").   The projection happens on only those parts of the boundary whose   indicators are represented in this map.    [2.x.70]  q The face quadrature used in the integration necessary to   compute the mass matrix and right hand side of the projection.    [2.x.71]  boundary_values The result of this function. It is a map   containing all indices of degrees of freedom at the boundary (as covered   by the boundary parts in  [2.x.72]  and the computed dof   value for this degree of freedom. For each degree of freedom at the   boundary, if its index already exists in  [2.x.73]  then its   boundary value will be overwritten, otherwise a new entry with proper   index and boundary value for this degree of freedom will be inserted into    [2.x.74]     [2.x.75]  component_mapping It is sometimes convenient to project a   vector-valued function onto only parts of a finite element space (for   example, to project a function with  [2.x.76]  components onto the   velocity components of a  [2.x.77]  component DoFHandler for a   Stokes problem). To allow for this, this argument allows components to be   remapped. If the vector is not empty, it has to have one entry for each   vector component of the finite element used in  [2.x.78]  This entry is the   component number in  [2.x.79]  that should be used for this   component in  [2.x.80]  By default, no remapping is applied.    
*  [2.x.81]  Using theprojection* rather than theinterpolation* of     boundary values makes relatively little difference in     practice. That said, it is far more computationally expensive     to compute projections because the require the solution of a     problem that couples all unknowns on the boundary, whereas     interpolation works on one face at a time. On the other hand,     interpolation is only possible for "nodal" finite element     spaces (such as FE_Q, but not FE_Q_Hierarchical), whereas the     projection is always possible. (For some more theoretical     considerations, see the documentation of the first     interpolate_boundary_values() function above.)  
* [0.x.14]*
   Call the project_boundary_values() function, see above, with   <tt>mapping=MappingQGeneric [2.x.82]   
* [0.x.15]*
   Same as above, but with hp-capabilities.  
* [0.x.16]*
   Call the project_boundary_values() function, see above, with   <tt>mapping=MappingQGeneric [2.x.83]   
* [0.x.17]*
   Project a function to the boundary of the domain, using the given   quadrature formula for the faces. This function identifies the degrees of   freedom subject to Dirichlet boundary conditions, adds them to the list   of constrained DoFs in  [2.x.84]  and sets the respective   inhomogeneity to the value resulting from the projection operation. If   this routine encounters a DoF that already is constrained (for instance   by a hanging node constraint, see below, or any other type of constraint,   e.g. from periodic boundary conditions), the old setting of the   constraint (dofs the entry is constrained to, inhomogeneities) is kept   and nothing happens.    
*  [2.x.85]  When combining adaptively refined meshes with hanging node   constraints and boundary conditions like from the current function within   one AffineConstraints object, the hanging node constraints should always   be set first, and then the boundary conditions since boundary conditions   are not set in the second operation on degrees of freedom that are   already constrained. This makes sure that the discretization remains   conforming as is needed. See the discussion on conflicting constraints in   the module on    [2.x.86] .     If  [2.x.87]  is empty, it is assumed that the number of   components of  [2.x.88]  matches that of the finite element   used by  [2.x.89]      In 1d, projection equals interpolation. Therefore,   interpolate_boundary_values is called.      [2.x.90]   [2.x.91]  if the components in  [2.x.92]  and    [2.x.93]  do not coincide, this vector allows them to be remapped. If the   vector is not empty, it has to have one entry for each component in  [2.x.94]    dof. This entry is the component number in  [2.x.95]  that   should be used for this component in  [2.x.96]  By default, no remapping is   applied.    
*  [2.x.97]   
* [0.x.18]*
   Call the project_boundary_values() function, see above, with   <tt>mapping=MappingQGeneric [2.x.98]     
*  [2.x.99]   
* [0.x.19]*
   This function is an updated version of the   project_boundary_values_curl_conforming function. The intention is to fix   a problem when using the previous function in conjunction with non-   rectangular geometries (i.e. elements with non-rectangular faces). The   L2-projection method used has been taken from the paper "Electromagnetic   scattering simulation using an H (curl) conforming hp-finite element   method in three dimensions" by PD Ledger, K Morgan and O Hassan ( Int. J.   Num. Meth. Fluids, Volume 53, Issue 8, pages 1267-1296).     This function will compute constraints that correspond to Dirichlet   boundary conditions of the form    [2.x.100]  i.e. the tangential   components of  [2.x.101]  and  [2.x.102]  shall coincide.     [1.x.5]     To compute the constraints we use a projection method based upon the   paper mentioned above. In 2D this is done in a single stage for the edge-   based shape functions, regardless of the order of the finite element. In   3D this is done in two stages, edges first and then faces.     For each cell, each edge,  [2.x.103] , is projected by solving the linear system    [2.x.104]  where  [2.x.105]  is the vector of constraints on degrees of freedom on the   edge and      [2.x.106]       [2.x.107]      with  [2.x.108]  the  [2.x.109]  shape function and  [2.x.110]  the tangent   vector.     Once all edge constraints,  [2.x.111] , have been computed, we may compute the   face constraints in a similar fashion, taking into account the residuals   from the edges.     For each face on the cell,  [2.x.112] , we solve the linear system  [2.x.113]  where    [2.x.114]  is the vector of constraints on degrees of freedom on the face and      [2.x.115]       [2.x.116]      and  [2.x.117] ,   the edge residual.     The resulting constraints are then given in the solutions  [2.x.118]  and  [2.x.119] .     If the AffineConstraints  [2.x.120]  contained values or other   constraints before, the new ones are added or the old ones overwritten,   if a node of the boundary part to be used was already in the list of   constraints. This is handled by using inhomogeneous constraints. Please   note that when combining adaptive meshes and this kind of constraints,   the Dirichlet conditions should be set first, and then completed by   hanging node constraints, in order to make sure that the discretization   remains consistent. See the discussion on conflicting constraints in the   module on    [2.x.121] .     [1.x.6]     This function is explicitly for use with FE_Nedelec elements, or with   FESystem elements which contain FE_Nedelec elements. It will throw an   exception if called with any other finite element. The user must ensure   that FESystem elements are correctly setup when using this function as   this check not possible in this case.     The second argument of this function denotes the first vector component   of the finite element which corresponds to the vector function that you   wish to constrain. For example, if we are solving Maxwell's equations in   3D and have components  [2.x.122]  and we want the   boundary conditions  [2.x.123] , then  [2.x.124]    first_vector_component would be 3. The  [2.x.125]  must return 6   components in this example, with the first 3 corresponding to  [2.x.126]    and the second 3 corresponding to  [2.x.127] . Vectors are implicitly   assumed to have exactly  [2.x.128]  components that are ordered in   the same way as we usually order the coordinate directions, i.e.  [2.x.129] -,    [2.x.130] -, and finally  [2.x.131] -component.     The parameter  [2.x.132]  corresponds to the number  [2.x.133]    boundary_id of the face.  [2.x.134]  is an illegal   value, since it is reserved for interior faces.     The last argument is denoted to compute the normal vector  [2.x.135]  at   the boundary points.      
*  [2.x.136]       [2.x.137]     [2.x.138]  "Glossary entry on boundary indicators"  
* [0.x.20]*
   hp-namespace version of project_boundary_values_curl_conforming_l2   (above).    
*  [2.x.139]   
* [0.x.21]*
   Compute constraints that correspond to boundary conditions of the form    [2.x.140] , i.e. the normal components of the   solution  [2.x.141]  and a given  [2.x.142]  shall coincide. The function  [2.x.143]  is given by    [2.x.144]  and the resulting constraints are added to  [2.x.145]    constraints for faces with boundary indicator  [2.x.146]      This function is explicitly written to use with the FE_RaviartThomas   elements. Thus it throws an exception, if it is called with other finite   elements.     If the AffineConstraints object  [2.x.147]  contained values or other   constraints before, the new ones are added or the old ones overwritten,   if a node of the boundary part to be used was already in the list of   constraints. This is handled by using inhomogeneous constraints. Please   note that when combining adaptive meshes and this kind of constraints,   the Dirichlet conditions should be set first, and then completed by   hanging node constraints, in order to make sure that the discretization   remains consistent. See the discussion on conflicting constraints in the   module on    [2.x.148] .     The argument  [2.x.149]  denotes the first vector component   in the finite element that corresponds to the vector function  [2.x.150]    that you want to constrain. Vectors are implicitly assumed to have   exactly  [2.x.151]  components that are ordered in the same way as   we usually order the coordinate directions, i.e.,  [2.x.152] -,  [2.x.153] -, and finally    [2.x.154] -component.     The parameter  [2.x.155]  corresponds to the  [2.x.156]  of   the faces where the boundary conditions are applied.    [2.x.157]  is an illegal value, since it is   reserved for interior faces. The  [2.x.158]  is used to compute the normal   vector  [2.x.159]  at the boundary points.     [1.x.7]     To compute the constraints we use interpolation operator proposed in   Brezzi, Fortin (Mixed and Hybrid Finite Element Methods, Springer, 1991)   on every face located at the boundary.    
*  [2.x.160]       [2.x.161]     [2.x.162]  "Glossary entry on boundary indicators"  
* [0.x.22]*
   Same as above for the hp-namespace.    
*  [2.x.163]       [2.x.164]     [2.x.165]  "Glossary entry on boundary indicators"  
* [0.x.23]