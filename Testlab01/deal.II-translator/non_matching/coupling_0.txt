[0.x.0]*
 A namespace for functions offering tools to handle two meshes with no alignment requirements.
*  Typically these functions allow for computations on the real-space intersection between the two meshes e.g. surface integrals and construction of coupling matrices.

* 
* [0.x.1]*
   Create a coupling sparsity pattern for non-matching, overlapping grids.     Given two non-matching triangulations, representing the domains  [2.x.0]    and  [2.x.1] , with  [2.x.2] , and two finite element spaces    [2.x.3]  and  [2.x.4] , compute the sparsity pattern that would be   necessary to assemble the matrix   [1.x.0]   where  [2.x.5]  is the finite element space associated with the   `space_dh` passed to this function (or part of it, if specified in   `space_comps`), while  [2.x.6]  is the finite element space associated with   the `immersed_dh` passed to this function (or part of it, if specified in   `immersed_comps`).     The `sparsity` is filled by locating the position of quadrature points   (obtained by the reference quadrature `quad`) defined on elements of  [2.x.7]    with respect to the embedding triangulation  [2.x.8] . For each overlapping   cell, the entries corresponding to `space_comps` in `space_dh` and   `immersed_comps` in `immersed_dh` are added to the sparsity pattern.     The `space_comps` and `immersed_comps` masks are assumed to be ordered in   the same way: the first component of `space_comps` will couple with the   first component of `immersed_comps`, the second with the second, and so   on. If one of the two masks has more non-zero than the other, then the   excess components will be ignored.     If the domain  [2.x.9]  does not fall within  [2.x.10] , an exception will be   thrown by the algorithm that computes the quadrature point locations. In   particular, notice that this function only makes sens for `dim1` lower or   equal than `dim0`. A static assert guards that this is actually the case.     For both spaces, it is possible to specify a custom Mapping, which   defaults to StaticMappingQ1 for both.     This function will also work in parallel, provided that the immersed   triangulation is of type  [2.x.11]    An exception is thrown if you use an immersed    [2.x.12]      See the tutorial program  [2.x.13]  for an example on how to use this   function.  
* [0.x.2]*
   Same as above, but takes an additional  [2.x.14]  object, instead of   creating one internally. In this version of the function, the parameter  [2.x.15]    space_mapping cannot be specified, since it is taken from the  [2.x.16]    parameter.  
* [0.x.3]*
   Create a coupling mass matrix for non-matching, overlapping grids.     Given two non-matching triangulations, representing the domains  [2.x.17]    and  [2.x.18] , with  [2.x.19] , and two finite element spaces    [2.x.20]  and  [2.x.21] , compute the coupling matrix   [1.x.1]   where  [2.x.22]  is the finite element space associated with the   `space_dh` passed to this function (or part of it, if specified in   `space_comps`), while  [2.x.23]  is the finite element space associated with   the `immersed_dh` passed to this function (or part of it, if specified in   `immersed_comps`).     The corresponding sparsity patterns can be computed by calling the   make_coupling_sparsity_pattern function. The elements of the matrix are   computed by locating the position of quadrature points defined on elements   of  [2.x.24]  with respect to the embedding triangulation  [2.x.25] .     The `space_comps` and `immersed_comps` masks are assumed to be ordered in   the same way: the first component of `space_comps` will couple with the   first component of `immersed_comps`, the second with the second, and so   on. If one of the two masks has more non-zero entries non-zero than the   other, then the excess components will be ignored.     If the domain  [2.x.26]  does not fall within  [2.x.27] , an exception will be   thrown by the algorithm that computes the quadrature point locations. In   particular, notice that this function only makes sense for `dim1` lower or   equal than `dim0`. A static assert guards that this is actually the case.     For both spaces, it is possible to specify a custom Mapping, which   defaults to StaticMappingQ1 for both.     This function will also work in parallel, provided that the immersed   triangulation is of type  [2.x.28]    An exception is thrown if you use an immersed    [2.x.29]      See the tutorial program  [2.x.30]  for an example on how to use this   function.  
* [0.x.4]*
   Same as above, but takes an additional  [2.x.31]  object, instead of   creating one internally. In this version of the function, the parameter  [2.x.32]    space_mapping cannot specified, since it is taken from the  [2.x.33]    parameter.  
* [0.x.5]*
   Create a coupling sparsity pattern for non-matching independent grids,   using a convolution kernel with compact support of radius epsilon.     Given two non-matching triangulations, representing the domains  [2.x.34]    and  [2.x.35] , both embedded in  [2.x.36] , and two finite element   spaces  [2.x.37]  and  [2.x.38] , compute the sparsity pattern that   would be necessary to assemble the matrix     [1.x.2]     where  [2.x.39]  is the finite element space associated with the    [2.x.40]  passed to this function (or part of it, if specified in    [2.x.41]  while  [2.x.42]  is the finite element space associated   with the  [2.x.43]  passed to this function (or part of it, if specified   in  [2.x.44]  and  [2.x.45]  is a function derived from   CutOffFunctionBase with compact support included in a ball of radius    [2.x.46] .     The  [2.x.47]  and  [2.x.48]  masks are assumed to be ordered in   the same way: the first component of  [2.x.49]  will couple with the   first component of  [2.x.50]  the second with the second, and so   on. If one of the two masks has more active components than the other, then   the excess components will be ignored.     For both spaces, it is possible to specify a custom Mapping, which   defaults to StaticMappingQ1 for both.     This function will also work in parallel, provided that at least one of the   triangulations is of type  [2.x.51]    An exception is thrown if both triagnulations are of type    [2.x.52]      This function assumes that the convolution has support contained in a box   of radius  [2.x.53]  If epsilon is set to zero, then we assume that the   kernel is the Dirac delta distribution, and the call is forwarded to the   method in this namespace with the same name, that does not take an epsilon   as input (but a quadrature formula  [2.x.54]  is required). In this case, more   restrictive conditions are required on the two spaces. See the   documentation of the other create_coupling_sparsity_pattern() function.  
* [0.x.6]*
   Create a coupling mass matrix for non-matching independent grids,   using a convolution kernel with compact support.     Given two non-matching triangulations, representing the domains    [2.x.55]  and  [2.x.56] , both embedded in  [2.x.57] , and two finite   element spaces  [2.x.58]  and    [2.x.59] , compute the matrix     [1.x.3]     where  [2.x.60]  is the finite element space associated with the    [2.x.61]  passed to this function (or part of it, if specified in    [2.x.62]  while  [2.x.63]  is the finite element space associated   with the  [2.x.64]  passed to this function (or part of it, if specified   in  [2.x.65]  and  [2.x.66]  is a function derived from   CutOffFunctionBase with compact support included in a ball of radius    [2.x.67] .     The corresponding sparsity patterns can be computed by calling the   make_coupling_sparsity_pattern() function.     The  [2.x.68]  and  [2.x.69]  masks are assumed to be ordered in   the same way: the first component of  [2.x.70]  will couple with the   first component of  [2.x.71]  the second with the second, and so   on. If one of the two masks has more active components than the other, then   the excess components will be ignored.     For both spaces, it is possible to specify a custom Mapping, which   defaults to StaticMappingQ1 for both.     This function will also work in parallel, provided that one of the two   triangulations is of type  [2.x.72]    An exception is thrown if both triangulations are of type    [2.x.73]      The parameter  [2.x.74]  is used to set the size of the cut-off function   used to compute the convolution. If epsilon is set to zero, then we assume   that the kernel is the Dirac delta distribution, and the call is forwarded   to the method in this namespace with the same name, that does not take an   epsilon as input.  
* [0.x.7]