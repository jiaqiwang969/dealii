[0.x.0]     Default value of the face_has_flux_coupling parameter of     make_flux_sparsity_pattern. Defined here (instead of using a default     lambda in the parameter list) to avoid a bug in gcc where the same lambda     gets defined multiple times.    
* [0.x.1]*
 This is a collection of functions operating on, and manipulating the numbers of degrees of freedom. The documentation of the member functions will provide more information, but for functions that exist in multiple versions, there are sections in this global documentation stating some commonalities.
*  [1.x.0]
*  When assembling system matrices, the entries are usually of the form  [2.x.0] , where  [2.x.1]  is a bilinear functional, often an integral. When using sparse matrices, we therefore only need to reserve space for those  [2.x.2]  only, which are nonzero, which is the same as to say that the basis functions  [2.x.3]  and  [2.x.4]  have a nonempty intersection of their support. Since the support of basis functions is bound only on cells on which they are located or to which they are adjacent, to determine the sparsity pattern it is sufficient to loop over all cells and connect all basis functions on each cell with all other basis functions on that cell.  There may be finite elements for which not all basis functions on a cell connect with each other, but no use of this case is made since no examples where this occurs are known to the author.
* 

*  [1.x.1]
*  When projecting the traces of functions to the boundary or parts thereof, one needs to build matrices and vectors that act only on those degrees of freedom that are located on the boundary, rather than on all degrees of freedom. One could do that by simply building matrices in which the entries for all interior DoFs are zero, but such matrices are always very rank deficient and not very practical to work with.
*  What is needed instead in this case is a numbering of the boundary degrees of freedom, i.e. we should enumerate all the degrees of freedom that are sitting on the boundary, and exclude all other (interior) degrees of freedom. The map_dof_to_boundary_indices() function does exactly this: it provides a vector with as many entries as there are degrees of freedom on the whole domain, with each entry being the number in the numbering of the boundary or  [2.x.5]  if the dof is not on the boundary.
*  With this vector, one can get, for any given degree of freedom, a unique number among those DoFs that sit on the boundary; or, if your DoF was interior to the domain, the result would be  [2.x.6]  We need this mapping, for example, to build the mass matrix on the boundary (for this, see make_boundary_sparsity_pattern() function, the corresponding section below, as well as the MatrixCreator namespace documentation).
*  Actually, there are two map_dof_to_boundary_indices() functions, one producing a numbering for all boundary degrees of freedom and one producing a numbering for only parts of the boundary, namely those parts for which the boundary indicator is listed in a set of indicators given to the function. The latter case is needed if, for example, we would only want to project the boundary values for the Dirichlet part of the boundary. You then give the function a list of boundary indicators referring to Dirichlet parts on which the projection is to be performed. The parts of the boundary on which you want to project need not be contiguous; however, it is not guaranteed that the indices of each of the boundary parts are continuous, i.e. the indices of degrees of freedom on different parts may be intermixed.
*  Degrees of freedom on the boundary but not on one of the specified boundary parts are given the index  [2.x.7]  as if they were in the interior. If no boundary indicator was given or if no face of a cell has a boundary indicator contained in the given list, the vector of new indices consists solely of  [2.x.8] 
*  (As a side note, for corner cases: The question what a degree of freedom on the boundary is, is not so easy.  It should really be a degree of freedom of which the respective basis function has nonzero values on the boundary. At least for Lagrange elements this definition is equal to the statement that the off-point, or what deal.II calls support_point, of the shape function, i.e. the point where the function assumes its nominal value (for Lagrange elements this is the point where it has the function value 1), is located on the boundary. We do not check this directly, the criterion is rather defined through the information the finite element class gives: the FiniteElement class defines the numbers of basis functions per vertex, per line, and so on and the basis functions are numbered after this information; a basis function is to be considered to be on the face of a cell (and thus on the boundary if the cell is at the boundary) according to it belonging to a vertex, line, etc but not to the interior of the cell. The finite element uses the same cell-wise numbering so that we can say that if a degree of freedom was numbered as one of the dofs on lines, we assume that it is located on the line. Where the off-point actually is, is a secret of the finite element (well, you can ask it, but we don't do it here) and not relevant in this context.)
* 

*  [1.x.2]
*  In some cases, one wants to only work with DoFs that sit on the boundary. One application is, for example, if rather than interpolating non- homogeneous boundary values, one would like to project them. For this, we need two things: a way to identify nodes that are located on (parts of) the boundary, and a way to build matrices out of only degrees of freedom that are on the boundary (i.e. much smaller matrices, in which we do not even build the large zero block that stems from the fact that most degrees of freedom have no support on the boundary of the domain). The first of these tasks is done by the map_dof_to_boundary_indices() function (described above).
*  The second part requires us first to build a sparsity pattern for the couplings between boundary nodes, and then to actually build the components of this matrix. While actually computing the entries of these small boundary matrices is discussed in the MatrixCreator namespace, the creation of the sparsity pattern is done by the create_boundary_sparsity_pattern() function. For its work, it needs to have a numbering of all those degrees of freedom that are on those parts of the boundary that we are interested in. You can get this from the map_dof_to_boundary_indices() function. It then builds the sparsity pattern corresponding to integrals like  [2.x.9] , where  [2.x.10]  and  [2.x.11]  are indices into the matrix, and  [2.x.12]  is the global DoF number of a degree of freedom sitting on a boundary (i.e.,  [2.x.13]  is the inverse of the mapping returned by map_dof_to_boundary_indices() function).
* 

* 

* 
*  [2.x.14] 

* 
* [0.x.2]*
   The flags used in tables by certain <tt>make_*_pattern</tt> functions to   describe whether two components of the solution couple in the bilinear   forms corresponding to cell or face terms. An example of using these   flags is shown in the introduction of  [2.x.15] .     In the descriptions of the individual elements below, remember that these   flags are used as elements of tables of size  [2.x.16]    times  [2.x.17]  where each element indicates whether   two components do or do not couple.  
* [0.x.3]*
     Two components do not couple.    
* [0.x.4]*
     Two components do couple.    
* [0.x.5]*
     Two components couple only if their shape functions are both nonzero on     a given face. This flag is only used when computing integrals over     faces of cells, e.g., in  [2.x.18]      Use  [2.x.19]  in general cases where gradients etc. occur on face     integrals.    
* [0.x.6]*
    [2.x.20]  DoF couplings    [2.x.21]   
* [0.x.7]*
   Map a coupling table from the user friendly organization by components to   the organization by blocks.     The return vector will be initialized to the correct length inside this   function.  
* [0.x.8]*
   Given a finite element and a table how the vector components of it couple   with each other, compute and return a table that describes how the   individual shape functions couple with each other.  
* [0.x.9]*
   Same function as above for a collection of finite elements, returning a   collection of tables.     The function currently treats  [2.x.22]  the same as    [2.x.23]  .  
* [0.x.10]*
    [2.x.24]   
* [0.x.11]*
    [2.x.25]  Sparsity pattern generation    [2.x.26]   
* [0.x.12]*
   Compute which entries of a matrix built on the given  [2.x.27]  may   possibly be nonzero, and create a sparsity pattern object that represents   these nonzero locations.     This function computes the possible positions of non-zero entries in the   global system matrix by [1.x.3] which entries one would write   to during the actual assembly of a matrix. For this, the function assumes   that each finite element basis function is non-zero on a cell only if its   degree of freedom is associated with the interior, a face, an edge or a   vertex of this cell.  As a result, a matrix entry  [2.x.28]  that is   computed from two basis functions  [2.x.29]  and  [2.x.30]  with   (global) indices  [2.x.31]  and  [2.x.32]  (for example, using a bilinear form    [2.x.33] ) can be non-zero only if these shape   functions correspond to degrees of freedom that are defined on at least   one common cell. Therefore, this function just loops over all cells,   figures out the global indices of all degrees of freedom, and presumes   that all matrix entries that couple any of these indices will result in a   nonzero matrix entry. These will then be added to the sparsity pattern.   As this process of generating the sparsity pattern does not take into   account the equation to be solved later on, the resulting sparsity   pattern is symmetric.     This algorithm makes no distinction between shape functions on each cell,   i.e., it simply couples all degrees of freedom on a cell with all other   degrees of freedom on a cell. This is often the case, and always a safe   assumption. However, if you know something about the structure of your   operator and that it does not couple certain shape functions with certain   test functions, then you can get a sparser sparsity pattern by calling a   variant of the current function described below that allows to specify   which vector components couple with which other vector components.     The method described above lives on the assumption that coupling between   degrees of freedom only happens if shape functions overlap on at least   one cell. This is the case with most usual finite element formulations   involving conforming elements. However, for formulations such as the   Discontinuous Galerkin finite element method, the bilinear form contains   terms on interfaces between cells that couple shape functions that live   on one cell with shape functions that live on a neighboring cell. The   current function would not see these couplings, and would consequently   not allocate entries in the sparsity pattern. You would then get into   trouble during matrix assembly because you try to write into matrix   entries for which no space has been allocated in the sparsity pattern.   This can be avoided by calling the  [2.x.34]    function instead, which takes into account coupling between degrees of   freedom on neighboring cells.     There are other situations where bilinear forms contain non-local terms,   for example in treating integral equations. These require different   methods for building the sparsity patterns that depend on the exact   formulation of the problem. You will have to do this yourself then.      [2.x.35]  dof_handler The DoFHandler object that describes which degrees   of freedom live on which cells.      [2.x.36]  sparsity_pattern The sparsity pattern to be filled with   entries.      [2.x.37]  constraints The process for generating entries described above   is purely local to each cell. Consequently, the sparsity pattern does   not provide for matrix entries that will only be written into during   the elimination of hanging nodes or other constraints. They have to be   taken care of by a subsequent call to  [2.x.38]    Alternatively, the constraints on degrees of freedom can already be   taken into account at the time of creating the sparsity pattern. For   this, pass the AffineConstraints object as the third argument to the   current function. No call to  [2.x.39]  is then   necessary. This process is explained in  [2.x.40] ,  [2.x.41] , and other   tutorial programs.      [2.x.42]  keep_constrained_dofs In case the constraints are already   taken care of in this function by passing in a AffineConstraints object,   it is possible to abandon some off-diagonal entries in the sparsity   pattern if these entries will also not be written into during the actual   assembly of the matrix this sparsity pattern later serves. Specifically,   when using an assembly method that uses    [2.x.43]  no entries will ever be   written into those matrix rows or columns that correspond to constrained   degrees of freedom. In such cases, you can set the argument  [2.x.44]    keep_constrained_dofs to  [2.x.45]  to avoid allocating these entries in   the sparsity pattern.      [2.x.46]  subdomain_id If specified, the sparsity pattern is built only   on cells that have a subdomain_id equal to the given argument. This is   useful in parallel contexts where the matrix and sparsity pattern (for   example a  [2.x.47]  may be distributed and not   every MPI process needs to build the entire sparsity pattern; in that   case, it is sufficient if every process only builds that part of the   sparsity pattern that corresponds to the subdomain_id for which it is   responsible. This feature is used in  [2.x.48] . (This argument is not   usually needed for objects of type  [2.x.49]    because the current function only loops over locally owned cells anyway;   thus, this argument typically only makes sense if you want to use the   subdomain_id for anything other than indicating which processor owns a   cell, for example which geometric component of the domain a cell belongs   to.)    
*  [2.x.50]  The actual type of the sparsity pattern may be SparsityPattern,   DynamicSparsityPattern, BlockSparsityPattern,   BlockDynamicSparsityPattern, or any other class that satisfies similar   requirements. It is assumed that the size of the sparsity pattern matches   the number of degrees of freedom and that enough unused nonzero entries   are left to fill the sparsity pattern if the sparsity pattern is of   "static" kind (see    [2.x.51]    for more information on what this means). The nonzero entries generated   by this function are added to possible previous content of the object,   i.e., previously added entries are not removed.    
*  [2.x.52]  If the sparsity pattern is represented by an object of type   SparsityPattern (as opposed to, for example, DynamicSparsityPattern), you   need to remember using  [2.x.53]  after generating the   pattern.    
*  [2.x.54]   
* [0.x.13]*
   Compute which entries of a matrix built on the given  [2.x.55]  may   possibly be nonzero, and create a sparsity pattern object that represents   these nonzero locations.     This function is a simple variation on the previous   make_sparsity_pattern() function (see there for a description of all of   the common arguments), but it provides functionality for vector finite   elements that allows to be more specific about which variables couple in   which equation.     For example, if you wanted to solve the Stokes equations,    
* [1.x.4]
*      in two space dimensions, using stable Q2/Q1 mixed elements (using the   FESystem class), then you don't want all degrees of freedom to couple in   each equation. More specifically, in the first equation, only  [2.x.56]  and    [2.x.57]  appear; in the second equation, only  [2.x.58]  and  [2.x.59]  appear; and in the   third equation, only  [2.x.60]  and  [2.x.61]  appear. (Note that this discussion   only talks about vector components of the solution variable and the   different equation, and has nothing to do with degrees of freedom, or in   fact with any kind of discretization.) We can describe this by the   following pattern of "couplings":     [1.x.5]     where "1" indicates that two variables (i.e., vector components of the   FESystem) couple in the respective equation, and a "0" means no coupling.   These zeros imply that upon discretization via a standard finite element   formulation, we will not write entries into the matrix that, for example,   couple pressure test functions with pressure shape functions (and similar   for the other zeros above). It is then a waste to allocate memory for   these entries in the matrix and the sparsity pattern, and you can avoid   this by creating a mask such as the one above that describes this to the   (current) function that computes the sparsity pattern. As stated above,   the mask shown above refers to components of the composed FESystem,   rather than to degrees of freedom or shape functions.     This function is designed to accept a coupling pattern, like the one   shown above, through the  [2.x.62]  parameter, which contains values of   type #Coupling. It builds the matrix structure just like the previous   function, but does not create matrix elements if not specified by the   coupling pattern. If the couplings are symmetric, then so will be the   resulting sparsity pattern.     There is a complication if some or all of the shape functions of the   finite element in use are non-zero in more than one component (in deal.II   speak: they are    [2.x.63]  "non-primitive finite elements").   In this case, the coupling element corresponding to the first non-zero   component is taken and additional ones for this component are ignored.    
*  [2.x.64]   
* [0.x.14]*
   Construct a sparsity pattern that allows coupling degrees of freedom on   two different but related meshes.     The idea is that if the two given DoFHandler objects correspond to two   different meshes (and potentially to different finite elements used on   these cells), but that if the two triangulations they are based on are   derived from the same coarse mesh through hierarchical refinement, then   one may set up a problem where one would like to test shape functions   from one mesh against the shape functions from another mesh. In   particular, this means that shape functions from a cell on the first mesh   are tested against those on the second cell that are located on the   corresponding cell; this correspondence is something that the   IntergridMap class can determine.     This function then constructs a sparsity pattern for which the degrees of   freedom that represent the rows come from the first given DoFHandler,   whereas the ones that correspond to columns come from the second   DoFHandler.  
* [0.x.15]*
   Compute which entries of a matrix built on the given  [2.x.65]  may   possibly be nonzero, and create a sparsity pattern object that represents   these nonzero locations. This function is a variation of the   make_sparsity_pattern() functions above in that it assumes that the   bilinear form you want to use to generate the matrix also contains terms   that integrate over the [1.x.6] between cells (i.e., it contains   "fluxes" between cells, explaining the name of the function).     This function is useful for Discontinuous Galerkin methods where the   standard make_sparsity_pattern() function would only create nonzero   entries for all degrees of freedom on one cell coupling to all other   degrees of freedom on the same cell; however, in DG methods, all or some   degrees of freedom on each cell also couple to the degrees of freedom on   other cells connected to the current one by a common face. The current   function also creates the nonzero entries in the matrix resulting from   these additional couplings. In other words, this function computes a   strict super-set of nonzero entries compared to the work done by   make_sparsity_pattern().      [2.x.66]  dof_handler The DoFHandler object that describes which degrees   of freedom live on which cells.      [2.x.67]  sparsity_pattern The sparsity pattern to be filled with   entries.    
*  [2.x.68]  The actual type of the sparsity pattern may be SparsityPattern,   DynamicSparsityPattern, BlockSparsityPattern,   BlockDynamicSparsityPattern, or any other class that satisfies similar   requirements. It is assumed that the size of the sparsity pattern matches   the number of degrees of freedom and that enough unused nonzero entries   are left to fill the sparsity pattern if the sparsity pattern is of   "static" kind (see    [2.x.69]    for more information on what this means). The nonzero entries generated   by this function are added to possible previous content of the object,   i.e., previously added entries are not removed.    
*  [2.x.70]  If the sparsity pattern is represented by an object of type   SparsityPattern (as opposed to, for example, DynamicSparsityPattern), you   need to remember using  [2.x.71]  after generating the   pattern.    
*  [2.x.72]   
* [0.x.16]*
   This function does essentially the same as the other   make_flux_sparsity_pattern() function but allows the specification of a   number of additional arguments. These carry the same meaning as discussed   in the first make_sparsity_pattern() function above.    
*  [2.x.73]   
* [0.x.17]*
   This function does essentially the same as the other   make_flux_sparsity_pattern() function but allows the specification of   coupling matrices that state which components of the solution variable   couple in each of the equations you are discretizing. This works in   complete analogy as discussed in the second make_sparsity_pattern()   function above.     In fact, this function takes two such masks, one describing which   variables couple with each other in the cell integrals that make up your   bilinear form, and which variables couple with each other in the face   integrals. If you passed masks consisting of only 1s to both of these,   then you would get the same sparsity pattern as if you had called the   first of the make_sparsity_pattern() functions above. By setting some of   the entries of these masks to zeros, you can get a sparser sparsity   pattern.    
*  [2.x.74]   
* [0.x.18]*
   This function does essentially the same as the previous   make_flux_sparsity_pattern() function but allows the application of an   AffineConstraints object. This is useful in the case where some   components of a finite element are continuous and some discontinuous,   allowing constraints to be imposed on the continuous part while also   building the flux terms needed for the discontinuous part.     The optional  [2.x.75]  can be used to specify on which   faces flux couplings occur. This allows for creating a sparser pattern when   using a bilinear form where flux terms only appear on a subset of the faces   in the triangulation. By default flux couplings are added over all internal   faces.  [2.x.76]  should be a function that takes an   active_cell_iterator and a face index and should return true if there is a   flux coupling over the face. When using the  [2.x.77]  we could,   for example, use    
* [1.x.7]
*   
* [0.x.19]*
   Create the sparsity pattern for boundary matrices. See the general   documentation of this class for more information.     The function does essentially what the other make_sparsity_pattern()   functions do, but assumes that the bilinear form that is used to build   the matrix does not consist of domain integrals, but only of integrals   over the boundary of the domain.  
* [0.x.20]*
   This function is a variation of the previous   make_boundary_sparsity_pattern() function in which we assume that the   boundary integrals that will give rise to the matrix extends only over   those parts of the boundary whose boundary indicators are listed in the    [2.x.78]  argument to this function.     This function could have been written by passing a  [2.x.79]  of boundary_id   numbers. However, most of the functions throughout deal.II dealing with   boundary indicators take a mapping of boundary indicators and the   corresponding boundary function, i.e., a  [2.x.80]  const   Function<spacedim,number>*> argument. Correspondingly, this function does   the same, though the actual boundary function is ignored here.   (Consequently, if you don't have any such boundary functions, just create a   map with the boundary indicators you want and set the function pointers to   null pointers).  
* [0.x.21]*
    [2.x.81]   
* [0.x.22]*
    [2.x.82]  Hanging nodes and other constraints    [2.x.83]   
* [0.x.23]*
   Compute the constraints resulting from the presence of hanging nodes.   Hanging nodes are best explained using a small picture:      [2.x.84]      In order to make a finite element function globally continuous, we have   to make sure that the dark red nodes have values that are compatible with   the adjacent yellow nodes, so that the function has no jump when coming   from the small cells to the large one at the top right. We therefore have   to add conditions that constrain those "hanging nodes".     The object into which these are inserted is later used to condense the   global system matrix and right hand side, and to extend the solution   vectors from the true degrees of freedom also to the constraint nodes.   This function is explained in detail in the    [2.x.85]  " [2.x.86] "   tutorial program and is used in almost all following programs as well.     This function does not clear the AffineConstraints object before use, in   order to allow adding constraints from different sources to the same   object. You therefore need to make sure it contains only constraints you   still want; otherwise call the  [2.x.87]  function.   Since this function does not check if it would add cycles in    [2.x.88]  it is recommended to call this function prior to other   functions that constrain DoFs with respect to others such as   make_periodicity_constraints().   This function does not close the object since you may want to   enter other constraints later on yourself.     Using a DoFHandler with hp-capabilities, we consider constraints due to   different finite elements used on two sides of a face between cells as   hanging nodes as well. In other words, in hp-mode, this function computes   all constraints due to differing mesh sizes (h) or polynomial degrees (p)   between adjacent cells.    
*  [2.x.89]   
* [0.x.24]*
   This function is used when different variables in a problem are   discretized on different grids, where one grid is strictly coarser than   the other. An example are optimization problems where the control   variable is often discretized on a coarser mesh than the state variable.     The function's result can be stated as follows mathematically: Let  [2.x.90]  and  [2.x.91]  be two meshes where  [2.x.92]  results from    [2.x.93]  strictly by refining or leaving alone the cells of  [2.x.94] . Using the same finite element on both, there are function spaces    [2.x.95]  and  [2.x.96]  associated with these meshes. Then every   function  [2.x.97]  can of course also be represented exactly   in  [2.x.98]  since by construction  [2.x.99] .   However, not every function in  [2.x.100]  can be expressed as a linear   combination of the shape functions of  [2.x.101] . The functions that   can be represented lie in a homogeneous subspace of  [2.x.102]  (namely,    [2.x.103] , of course) and this subspace can be represented by a linear   constraint of the form  [2.x.104]  where  [2.x.105]  is the vector of nodal values of   functions  [2.x.106] . In other words, every function  [2.x.107]  that also satisfies  [2.x.108]  automatically satisfies  [2.x.109] . This function computes the matrix    [2.x.110]  in the form of a AffineConstraints object.     The construction of these constraints is done as follows: for each of the   degrees of freedom (i.e. shape functions) on the coarse grid, we compute   its representation on the fine grid, i.e. how the linear combination of   shape functions on the fine grid looks like that resembles the shape   function on the coarse grid. From this information, we can then compute   the constraints which have to hold if a solution of a linear equation on   the fine grid shall be representable on the coarse grid. The exact   algorithm how these constraints can be computed is rather complicated and   is best understood by reading the source code, which contains many   comments.     The use of this function is as follows: it accepts as parameters two DoF   Handlers, the first of which refers to the coarse grid and the second of   which is the fine grid. On both, a finite element is represented by the   DoF handler objects, which will usually have several vector components,   which may belong to different base elements. The second and fourth   parameter of this function therefore state which vector component on the   coarse grid shall be used to restrict the stated component on the fine   grid. The finite element used for the respective components on the two   grids needs to be the same. An example may clarify this: consider an   optimization problem with controls  [2.x.111]  discretized on a coarse mesh and a   state variable  [2.x.112]  (and corresponding Lagrange multiplier  [2.x.113] )   discretized on the fine mesh. These are discretized using piecewise   constant discontinuous, continuous linear, and continuous linear   elements, respectively. Only the parameter  [2.x.114]  is represented on the   coarse grid, thus the DoFHandler object on the coarse grid represents   only one variable, discretized using piecewise constant discontinuous   elements. Then, the parameter denoting the vector component on the coarse   grid would be zero (the only possible choice, since the variable on the   coarse grid is scalar). If the ordering of variables in the fine mesh   FESystem is  [2.x.115] , then the fourth argument of the function   corresponding to the vector component would be one (corresponding to the   variable  [2.x.116] ; zero would be  [2.x.117] , two would be  [2.x.118] ).     The function also requires an object of type IntergridMap representing   how to get from the coarse mesh cells to the corresponding cells on the   fine mesh. This could in principle be generated by the function itself   from the two DoFHandler objects, but since it is probably available   anyway in programs that use different meshes, the function simply takes   it as an argument.     The computed constraints are entered into a variable of type   AffineConstraints; previous contents are not deleted.  
* [0.x.25]*
   This function generates a matrix such that when a vector of data with as   many elements as there are degrees of freedom of this component on the   coarse grid is multiplied to this matrix, we obtain a vector with as many   elements as there are global degrees of freedom on the fine grid. All the   elements of the other vector components of the finite element fields on   the fine grid are not touched.     Triangulation of the fine grid can be distributed. When called in   parallel, each process has to have a copy of the coarse grid. In this   case, function returns transfer representation for a set of locally owned   cells.     The output of this function is a compressed format that can be used to   construct corresponding sparse transfer matrix.  
* [0.x.26]*
    [2.x.119]   
* [0.x.27]*
    [2.x.120]  Periodic boundary conditions    [2.x.121]   
* [0.x.28]*
   Insert the (algebraic) constraints due to periodic boundary conditions   into an AffineConstraints object  [2.x.122]      Given a pair of not necessarily active boundary faces  [2.x.123]  and  [2.x.124]    face_2, this functions constrains all DoFs associated with the boundary   described by  [2.x.125]  to the respective DoFs of the boundary described   by  [2.x.126]  More precisely:     If  [2.x.127]  and  [2.x.128]  are both active faces it adds the DoFs of  [2.x.129]    face_1 to the list of constrained DoFs in  [2.x.130]  and adds   entries to constrain them to the corresponding values of the DoFs on  [2.x.131]    face_2. This happens on a purely algebraic level, meaning, the global DoF   with (local face) index <tt>i</tt> on  [2.x.132]  gets constraint to the   DoF with (local face) index <tt>i</tt> on  [2.x.133]  (possibly corrected   for orientation, see below).     Otherwise, if  [2.x.134]  and  [2.x.135]  are not active faces, this function   loops recursively over the children of  [2.x.136]  and  [2.x.137]  If only   one of the two faces is active, then we recursively iterate over the   children of the non-active ones and make sure that the solution function   on the refined side equals that on the non-refined face in much the same   way as we enforce hanging node constraints at places where differently   refined cells come together. (However, unlike hanging nodes, we do not   enforce the requirement that there be only a difference of one refinement   level between the two sides of the domain you would like to be periodic).     This routine only constrains DoFs that are not already constrained. If   this routine encounters a DoF that already is constrained (for instance   by Dirichlet boundary conditions), the old setting of the constraint   (dofs the entry is constrained to, inhomogeneities) is kept and nothing   happens.     The flags in the  [2.x.138]  (see    [2.x.139] )   denote which components of the finite element space shall be constrained   with periodic boundary conditions. If it is left as specified by the   default value all components are constrained. If it is different from the   default value, it is assumed that the number of entries equals the number   of components of the finite element. This can be used to enforce   periodicity in only one variable in a system of equations.      [2.x.140]   [2.x.141]  and  [2.x.142]  describe an   orientation that should be applied to  [2.x.143]  prior to matching and   constraining DoFs. This has nothing to do with the actual orientation of   the given faces in their respective cells (which for boundary faces is   always the default) but instead how you want to see periodicity to be   enforced. For example, by using these flags, you can enforce a condition   of the kind  [2.x.144]  (i.e., a Moebius band) or in 3d a twisted   torus. More precisely, these flags match local face DoF indices in the   following manner:     In 2d: <tt>face_orientation</tt> must always be <tt>true</tt>,   <tt>face_rotation</tt> is always <tt>false</tt>, and face_flip has the   meaning of <tt>line_flip</tt>; this implies e.g. for <tt>Q1</tt>:    
* [1.x.8]
*      And similarly for the case of Q1 in 3d:    
* [1.x.9]
*      Optionally a matrix  [2.x.145]  along with a  [2.x.146]   [2.x.147]    first_vector_components can be specified that describes how DoFs on  [2.x.148]    face_1 should be modified prior to constraining to the DoFs of  [2.x.149]    Here, two declarations are possible: If the  [2.x.150]   [2.x.151]    first_vector_components is non empty the matrix is interpreted as a  [2.x.152]    dim  [2.x.153]   [2.x.154]  rotation matrix that is applied to all vector valued   blocks listed in  [2.x.155]  of the FESystem. If  [2.x.156]    first_vector_components is empty the matrix is interpreted as an   interpolation matrix with size no_face_dofs  [2.x.157]  no_face_dofs.     This function makes sure that identity constraints don't create cycles   in  [2.x.158]       [2.x.159]  can be used to implement Bloch periodic conditions   (a.k.a. phase shift periodic conditions) of the form    [2.x.160]    where  [2.x.161]  is periodic with the same periodicity as the crystal lattice and    [2.x.162]  is the wavevector, see   [https://en.wikipedia.org/wiki/Bloch_wave](https://en.wikipedia.org/wiki/Bloch_wave).   The solution at  [2.x.163]  is equal to the solution at  [2.x.164]  times    [2.x.165]  For example, if the solution at  [2.x.166]  is    [2.x.167]  and  [2.x.168]  is the corresponding point on  [2.x.169]  then   the solution at  [2.x.170]  should be    [2.x.171] . This condition can be   implemented using    [2.x.172] .     Detailed information can be found in the see    [2.x.173]  "Glossary entry on periodic boundary conditions".  
* [0.x.29]*
   Insert the (algebraic) constraints due to periodic boundary conditions   into an AffineConstraints object  [2.x.174]      This is the main high level interface for above low level variant of   make_periodicity_constraints(). It takes a  [2.x.175]   [2.x.176]    as argument and applies above make_periodicity_constraints() on each   entry.  [2.x.177]  can be created by    [2.x.178]     
*  [2.x.179]  For DoFHandler objects that are built on a    [2.x.180]  object    [2.x.181]  has to be called   before calling this function..      [2.x.182]     [2.x.183]  "Glossary entry on periodic boundary conditions"   and  [2.x.184]  for further information.  
* [0.x.30]*
   The same as above.      [2.x.185]  Use the function that takes dim and spacedim as template     argument.  
* [0.x.31]*
   Insert the (algebraic) constraints due to periodic boundary conditions   into a AffineConstraints  [2.x.186]      This function serves as a high level interface for the   make_periodicity_constraints() function.     Define a 'first' boundary as all boundary faces having boundary_id  [2.x.187]    b_id1 and a 'second' boundary consisting of all faces belonging to  [2.x.188]    b_id2.     This function tries to match all faces belonging to the first boundary   with faces belonging to the second boundary with the help of   orthogonal_equality(). More precisely, faces with coordinates only   differing in the  [2.x.189]  component are identified.     If this matching is successful it constrains all DoFs associated with the   'first' boundary to the respective DoFs of the 'second' boundary   respecting the relative orientation of the two faces.    
*  [2.x.190]  This function is a convenience wrapper. It internally calls    [2.x.191]  with the supplied parameters and   feeds the output to above make_periodicity_constraints() variant. If you   need more functionality use  [2.x.192]  directly.      [2.x.193]     [2.x.194]  "Glossary entry on periodic boundary conditions"   for further information.  
* [0.x.32]*
   This compatibility version of make_periodicity_constraints only works on   grids with cells in    [2.x.195]  "standard orientation".     Instead of defining a 'first' and 'second' boundary with the help of two   boundary_ids this function defines a 'left' boundary as all faces with   local face index  [2.x.196]  and boundary indicator  [2.x.197]    and, similarly, a 'right' boundary consisting of all face with local face   index  [2.x.198]  and boundary indicator  [2.x.199]  Faces with   coordinates only differing in the  [2.x.200]  component are identified.    
*  [2.x.201]  This version of make_periodicity_constraints  will not work on   meshes with cells not in    [2.x.202]  "standard orientation".    
*  [2.x.203]  This function is a convenience wrapper. It internally calls    [2.x.204]  with the supplied parameters and   feeds the output to above make_periodicity_constraints() variant. If you   need more functionality use  [2.x.205]  directly.      [2.x.206]     [2.x.207]  "Glossary entry on periodic boundary conditions"   for further information.  
* [0.x.33]*
    [2.x.208]   
* [0.x.34]*
    [2.x.209]  Identifying subsets of degrees of freedom with particular properties    [2.x.210]   
* [0.x.35]*
   Return an IndexSet describing all dofs that will be constrained by   interface constraints, i.e. all hanging nodes.     In case of a  [2.x.211]  or a    [2.x.212]  only locally relevant dofs are   considered.  
* [0.x.36]*
   Extract the (locally owned) indices of the degrees of freedom belonging to   certain vector components of a vector-valued finite element. The    [2.x.213]  defines which components or blocks of an FESystem or   vector-valued element are to be extracted   from the DoFHandler  [2.x.214]  The entries in the output object then   correspond to degrees of freedom belonging to these   components.     If the finite element under consideration is not primitive, i.e., some or   all of its shape functions are non-zero in more than one vector component   (which holds, for example, for FE_Nedelec or FE_RaviartThomas elements),   then shape functions cannot be associated with a single vector component.   In this case, if  [2.x.215] one [2.x.216]  shape vector component of this element is   flagged in  [2.x.217]  (see    [2.x.218] ),   then this is equivalent to selecting  [2.x.219] all [2.x.220]  vector components   corresponding to this non-primitive base element.      [2.x.221]  dof_handler The DoFHandler whose enumerated degrees of freedom     are to be filtered by this function.    [2.x.222]  component_mask A mask that states which components you want     to select. The size of this mask must be compatible with the number of     components in the FiniteElement used by the  [2.x.223]  See      [2.x.224]  "the glossary entry on component masks"     for more information.    [2.x.225]  An IndexSet object that will contain exactly those entries that     (i) correspond to degrees of freedom selected by the mask above, and     (ii) are locally owned. The size of the index set is equal to the global     number of degrees of freedom. Note that the resulting object is always     a subset of what  [2.x.226]  returns.  
* [0.x.37]*
   This function is the equivalent to the  [2.x.227]  functions   above except that the selection of which degrees of freedom to extract is   not done based on components (see    [2.x.228] )   but instead based on whether they are part of a particular block (see    [2.x.229] ).   Consequently, the second argument is not a ComponentMask but a BlockMask   object.      [2.x.230]  dof_handler The DoFHandler whose enumerated degrees of freedom     are to be filtered by this function.    [2.x.231]  block_mask A mask that states which blocks you want     to select. The size of this mask must be compatible with the number of     blocks in the FiniteElement used by the  [2.x.232]  See      [2.x.233]  "the glossary entry on block masks"     for more information.    [2.x.234]  An IndexSet object that will contain exactly those entries that     (i) correspond to degrees of freedom selected by the mask above, and     (ii) are locally owned. The size of the index set is equal to the global     number of degrees of freedom. Note that the resulting object is always     a subset of what  [2.x.235]  returns.  
* [0.x.38]*
   Do the same thing as the corresponding extract_dofs() function for one   level of a multi-grid DoF numbering.  
* [0.x.39]*
   Do the same thing as the corresponding extract_dofs() function for one   level of a multi-grid DoF numbering.  
* [0.x.40]*
   Extract all degrees of freedom which are at the boundary and belong to   specified components of the solution. The function returns its results in   the last non-default-valued parameter which contains  [2.x.236]  if a degree   of freedom is at the boundary and belongs to one of the selected   components, and  [2.x.237]  otherwise.     By specifying the  [2.x.238]  variable, you can select which boundary   indicators the faces have to have on which the degrees of freedom are   located that shall be extracted. If it is an empty list, then all   boundary indicators are accepted.     The size of  [2.x.239]  (see    [2.x.240] )   shall equal the number of components in the finite element used by  [2.x.241]    dof. The size of  [2.x.242]  shall equal   <tt>dof_handler.n_dofs()</tt>. Previous contents of this array are   overwritten.     Using the usual convention, if a shape function is non-zero in more than   one component (i.e. it is non-primitive), then the element in the   component mask is used that corresponds to the first non-zero components.   Elements in the mask corresponding to later components are ignored.      [2.x.243]  This function will not work for DoFHandler objects that are built   on a  [2.x.244]  object. The reasons is that the   output argument  [2.x.245]  has to have a length equal to [1.x.10]   global degrees of freedom. Consequently, this does not scale to very   large problems, and this is also why the function is deprecated. If you   need the functionality of this function for   parallel triangulations, then you need to use the other    [2.x.246]  function that returns its information   via an IndexSet object.      [2.x.247]  dof_handler The object that describes which degrees of freedom   live on which cell.    [2.x.248]  component_mask A mask denoting the vector components of the   finite element that should be considered (see also    [2.x.249] ).    [2.x.250]  selected_dofs A vector of booleans that is returned and for   which   an element will be  [2.x.251]  if the corresponding index is a   degree of freedom that is located on the   boundary (and correspond to the selected vector components and boundary   indicators, depending on the values of the  [2.x.252]  and  [2.x.253]    boundary_ids arguments).    [2.x.254]  boundary_ids If empty, this function extracts the indices of the   degrees of freedom for all parts of the boundary. If it is a non- empty   list, then the function only considers boundary faces with the boundary   indicators listed in this argument.      [2.x.255]     [2.x.256]  "Glossary entry on boundary indicators"  
* [0.x.41]*
   Extract all degrees of freedom which are at the boundary and belong to   specified components of the solution. The function returns its results in   the form of an IndexSet that contains those entries that correspond to   these selected degrees of freedom, i.e., which are at the boundary and   belong to one of the selected components.     By specifying the  [2.x.257]  variable, you can select which boundary   indicators the faces have to have on which the degrees of freedom are   located that shall be extracted. If it is an empty list (the default), then   all boundary indicators are accepted.     This function is used in  [2.x.258]  and  [2.x.259] , for example.    
*  [2.x.260]  If the DoFHandler object is defined on a   parallel Triangulation object, then the computed index set   will contain only those degrees of freedom on the boundary that belong to   the locally relevant set (see    [2.x.261]  "locally relevant DoFs"), i.e., the function   only considers faces of locally owned and ghost cells, but not of   artificial cells.      [2.x.262]  dof_handler The object that describes which degrees of freedom   live on which cell.    [2.x.263]  component_mask A mask denoting the vector components of the   finite element that should be considered (see also    [2.x.264] ). If left at the default, the component mask   indicates that all vector components of the finite element should be   considered.    [2.x.265]  boundary_ids If empty, this function extracts the indices of the   degrees of freedom for all parts of the boundary. If it is a non-empty   list, then the function only considers boundary faces with the boundary   indicators listed in this argument.    [2.x.266]  The IndexSet object that   will contain the indices of degrees of freedom that are located on the   boundary (and correspond to the selected vector components and boundary   indicators, depending on the values of the  [2.x.267]  and  [2.x.268]    boundary_ids arguments).      [2.x.269]     [2.x.270]  "Glossary entry on boundary indicators"  
* [0.x.42]*
   The same as the previous function, except that it returns its information   via the third argument.      [2.x.271]  Use the previous function instead.  
* [0.x.43]*
   This function is similar to the extract_boundary_dofs() function but it   extracts those degrees of freedom whose shape functions are nonzero on at   least part of the selected boundary. For continuous elements, this is   exactly the set of shape functions whose degrees of freedom are defined   on boundary faces. On the other hand, if the finite element in used is a   discontinuous element, all degrees of freedom are defined in the inside   of cells and consequently none would be boundary degrees of freedom.   Several of those would have shape functions that are nonzero on the   boundary, however. This function therefore extracts all those for which   the  [2.x.272]  function says that it is nonzero   on any face on one of the selected boundary parts.      [2.x.273]     [2.x.274]  "Glossary entry on boundary indicators"  
* [0.x.44]*
   Extract all indices of shape functions such that their support is entirely   contained within the cells for which the  [2.x.275]  is  [2.x.276] .   The result is returned as an IndexSet.     Consider the following FE space where predicate returns  [2.x.277]    for all cells on the left half of the domain:      [2.x.278]      This functions will return the union of all DoF indices on those cells   minus DoF 11, 13, 2 and 0; the result will be <code>[9,10], 12,   [14,38]</code>. In the image above the returned DoFs are separated from the   rest by the red line     Essentially, the question this functions answers is the following:   Given a subdomain with associated DoFs, what is the largest subset of   these DoFs that are allowed to be non-zero such that after calling    [2.x.279]  the resulting solution vector will have   support only within the given domain. Here,  [2.x.280]  is the   AffineConstraints container containing hanging nodes constraints.     In case of  [2.x.281]   [2.x.282]  will be called   only for locally owned and ghost cells. The resulting index set may contain   DoFs that are associated with the locally owned or ghost cells, but are not   owned by the current MPI core.  
* [0.x.45]*
   Extract a vector that represents the constant modes of the DoFHandler for   the components chosen by <tt>component_mask</tt> (see    [2.x.283] ).   The constant modes on a discretization are the null space of a Laplace   operator on the selected components with Neumann boundary conditions   applied. The null space is a necessary ingredient for obtaining a good   AMG preconditioner when using the class    [2.x.284]   Since the ML AMG package only works   on algebraic properties of the respective matrix, it has no chance to   detect whether the matrix comes from a scalar or a vector valued problem.   However, a near null space supplies exactly the needed information about   the components placement of vector components within the matrix. The null   space (or rather, the constant modes) is provided by the finite element   underlying the given DoFHandler and for most elements, the null space   will consist of as many vectors as there are true arguments in   <tt>component_mask</tt> (see    [2.x.285] ),   each of which will be one in one vector component and zero in all others.   However, the representation of the constant function for e.g. FE_DGP is   different (the first component on each element one, all other components   zero), and some scalar elements may even have two constant modes   (FE_Q_DG0). Therefore, we store this object in a vector of vectors, where   the outer vector contains the collection of the actual constant modes on   the DoFHandler. Each inner vector has as many components as there are   (locally owned) degrees of freedom in the selected components. Note that   any matrix associated with this null space must have been constructed   using the same <tt>component_mask</tt> argument, since the numbering of   DoFs is done relative to the selected dofs, not to all dofs.     The main reason for this program is the use of the null space with the   AMG preconditioner.  
* [0.x.46]*
    [2.x.286]  Parallelization and domain decomposition    [2.x.287]   
* [0.x.47]*
   Flag all those degrees of freedom which are on cells with the given   subdomain id. Note that DoFs on faces can belong to cells with differing   subdomain ids, so the sets of flagged degrees of freedom are not mutually   exclusive for different subdomain ids.     If you want to get a unique association of degree of freedom with   subdomains, use the  [2.x.288]  function.  
* [0.x.48]*
   Extract the set of global DoF indices that are active on the current   DoFHandler. For regular DoFHandlers, these are all DoF indices, but for   DoFHandler objects built on  [2.x.289]  this set   is a superset of  [2.x.290]  and contains all DoF   indices that live on all locally owned cells (including on the interface   to ghost cells). However, it does not contain the DoF indices that are   exclusively defined on ghost or artificial cells (see    [2.x.291]  "the glossary").     The degrees of freedom identified by this function equal those obtained   from the dof_indices_with_subdomain_association() function when called   with the locally owned subdomain id.  
* [0.x.49]*
   Same function as above but for a certain (multigrid-)level.   This function returns all DoF indices that live on   all locally owned cells (including on the interface to ghost cells) on the   given level.  
* [0.x.50]*
   Extract the set of global DoF indices that are active on the current   DoFHandler. For regular DoFHandlers, these are all DoF indices, but for   DoFHandler objects built on  [2.x.292]  this set   is the union of  [2.x.293]  and the DoF indices on   all ghost cells. In essence, it is the DoF indices on all cells that are   not artificial (see    [2.x.294]  "the glossary").  
* [0.x.51]*
   Extract the set of locally owned DoF indices for each component within the   mask that are owned by the current  processor. For components disabled by   the mask, an empty IndexSet is returned. For a scalar DoFHandler built on a   sequential triangulation, the return vector contains a single complete   IndexSet with all DoF indices. If the mask contains all components (which   also corresponds to the default value), then the union of the returned   index sets equlas what  [2.x.295]  returns.  
* [0.x.52]*
   For each processor, determine the set of locally owned degrees of freedom   as an IndexSet. This function then returns a vector of index sets, where   the vector has size equal to the number of MPI processes that participate   in the DoF handler object.     The function can be used for objects of type  [2.x.296]  or    [2.x.297]  It will not work for objects of type    [2.x.298]  since for such triangulations we do   not have information about all cells of the triangulation available   locally, and consequently can not say anything definitive about the   degrees of freedom active on other processors' locally owned cells.  
* [0.x.53]*
     For each processor, determine the set of locally relevant degrees of   freedom as an IndexSet. This function then returns a vector of index   sets, where the vector has size equal to the number of MPI processes that   participate in the DoF handler object.     The function can be used for objects of type  [2.x.299]  or    [2.x.300]  It will not work for objects of type    [2.x.301]  since for such triangulations we do   not have information about all cells of the triangulation available   locally, and consequently can not say anything definitive about the   degrees of freedom active on other processors' locally owned cells.  
* [0.x.54]*
   Same as extract_locally_relevant_dofs() but for multigrid DoFs for the   given  [2.x.302]   
* [0.x.55]*
   For each degree of freedom, return in the output array to which subdomain   (as given by the <tt>cell->subdomain_id()</tt> function) it belongs. The   output array is supposed to have the right size already when calling this   function.     Note that degrees of freedom associated with faces, edges, and vertices   may be associated with multiple subdomains if they are sitting on   partition boundaries. In these cases, we assign them to the process with   the smaller subdomain id. This may lead to different numbers of degrees   of freedom in partitions, even if the number of cells is perfectly   equidistributed. While this is regrettable, it is not a problem in   practice since the number of degrees of freedom on partition boundaries   is asymptotically vanishing as we refine the mesh as long as the number   of partitions is kept constant.     This function returns the association of each DoF with one subdomain. If   you are looking for the association of each  [2.x.303]  cell with a subdomain,   either query the <tt>cell->subdomain_id()</tt> function, or use the    [2.x.304]  function.     Note that this function is of questionable use for DoFHandler objects   built on  [2.x.305]  since in that case   ownership of individual degrees of freedom by MPI processes is controlled   by the DoF handler object, not based on some geometric algorithm in   conjunction with subdomain id. In particular, the degrees of freedom   identified by the functions in this namespace as associated with a   subdomain are not the same the DoFHandler class identifies as those it   owns.  
* [0.x.56]*
   Count how many degrees of freedom are uniquely associated with the given    [2.x.306]  index.     Note that there may be rare cases where cells with the given  [2.x.307]    index exist, but none of its degrees of freedom are actually associated   with it. In that case, the returned value will be zero.     This function will generate an exception if there are no cells with the   given  [2.x.308]  index.     This function returns the number of DoFs associated with one subdomain.   If you are looking for the association of  [2.x.309]  cells with this subdomain,   use the  [2.x.310]    function.     Note that this function is of questionable use for DoFHandler objects   built on  [2.x.311]  since in that case   ownership of individual degrees of freedom by MPI processes is controlled   by the DoF handler object, not based on some geometric algorithm in   conjunction with subdomain id. In particular, the degrees of freedom   identified by the functions in this namespace as associated with a   subdomain are not the same the DoFHandler class identifies as those it   owns.  
* [0.x.57]*
   Count how many degrees of freedom are uniquely associated with the given    [2.x.312]  index.     This function does what the previous one does except that it splits the   result among the vector components of the finite element in use by the   DoFHandler object. The last argument (which must have a length equal to   the number of vector components) will therefore store how many degrees of   freedom of each vector component are associated with the given subdomain.     Note that this function is of questionable use for DoFHandler objects   built on  [2.x.313]  since in that case   ownership of individual degrees of freedom by MPI processes is controlled   by the DoF handler object, not based on some geometric algorithm in   conjunction with subdomain id. In particular, the degrees of freedom   identified by the functions in this namespace as associated with a   subdomain are not the same the DoFHandler class identifies as those it   owns.  
* [0.x.58]*
   Return a set of indices that denotes the degrees of freedom that live on   the given subdomain, i.e. that are on cells owned by the current   processor. Note that this includes the ones that this subdomain "owns"   (i.e. the ones for which get_subdomain_association() returns a value   equal to the subdomain given here and that are selected by the    [2.x.314]  function) but also all of those that sit   on the boundary between the given subdomain and other subdomain. In   essence, degrees of freedom that sit on boundaries between subdomain will   be in the index sets returned by this function for more than one   subdomain.     Note that this function is of questionable use for DoFHandler objects   built on  [2.x.315]  since in that case   ownership of individual degrees of freedom by MPI processes is controlled   by the DoF handler object, not based on some geometric algorithm in   conjunction with subdomain id. In particular, the degrees of freedom   identified by the functions in this namespace as associated with a   subdomain are not the same the DoFHandler class identifies as those it   owns.  
* [0.x.59]*
    [2.x.316]  DoF indices on patches of cells     Create structures containing a large set of degrees of freedom for small   patches of cells. The resulting objects can be used in RelaxationBlockSOR   and related classes to implement Schwarz preconditioners and smoothers,   where the subdomains consist of small numbers of cells only.  
* [0.x.60]*
   Return the set of degrees of freedom that live on a set of cells (i.e., a   patch) described by the argument.     Patches are often used in defining error estimators that require the   solution of a local problem on the patch surrounding each of the cells of   the mesh. You can get a list of cells that form the patch around a given   cell using  [2.x.317]  While    [2.x.318]  can be used to determine the size of   these local problems, so that one can assemble the local system and then   solve it, it is still necessary to provide a mapping between the global   indices of the degrees of freedom that live on the patch and a local   enumeration. This function provides such a local enumeration by returning   the set of degrees of freedom that live on the patch.     Since this set is returned in the form of a  [2.x.319]  one can also   think of it as a mapping  
* [1.x.11]
*    where  [2.x.320]  is an index into the returned vector (i.e., a the   [1.x.12] index of a degree of freedom on the patch) and    [2.x.321]  is the global index of a degree of freedom   located on the patch. The array returned has size equal to    [2.x.322]     
*  [2.x.323]  The array returned is sorted by global DoF index. Consequently, if   one considers the index into this array a local DoF index, then the local   system that results retains the block structure of the global system.      [2.x.324]  patch A collection of cells within an object of type   DoFHandler<dim,  [2.x.325]       [2.x.326]  A list of those global degrees of freedom located on the patch,   as defined above.    
*  [2.x.327]  In the context of a parallel distributed computation, it only makes   sense to call this function on patches around locally owned cells. This   is because the neighbors of locally owned cells are either locally owned   themselves, or ghost cells. For both, we know that these are in fact the   real cells of the complete, parallel triangulation. We can also query the   degrees of freedom on these. In other words, this function can only work   if all cells in the patch are either locally owned or ghost cells.  
* [0.x.61]*
   The same as above.      [2.x.328]  Use the function that takes dim and spacedim as template     argument.  
* [0.x.62]*
   Creates a sparsity pattern, which lists   the degrees of freedom associated to each cell on the given   level. This pattern can be used in RelaxationBlock classes as   block list for additive and multiplicative Schwarz methods.     The row index in this pattern is the cell index resulting from   standard iteration through a level of the Triangulation. For a    [2.x.329]  only locally owned cells   are entered.     The sparsity pattern is resized in this function to contain as   many rows as there are locally owned cells on a given level, as   many columns as there are degrees of freedom on this level.     <tt>selected_dofs</tt> is a vector indexed by the local degrees   of freedom on a cell. If it is used, only such dofs are entered   into the block list which are selected. This allows for instance   the exclusion of components or of dofs on the boundary.  
* [0.x.63]*
   Create an incidence matrix that for every vertex on a given level of a   multilevel DoFHandler flags which degrees of freedom are associated with   the adjacent cells. This data structure is a matrix with as many rows as   there are vertices on a given level, as many columns as there are degrees   of freedom on this level, and entries that are either true or false. This   data structure is conveniently represented by a SparsityPattern object.   The sparsity pattern may be empty when entering this function and will be   reinitialized to the correct size.     The function has some boolean arguments (listed below) controlling   details of the generated patches. The default settings are those for   Arnold-Falk-Winther type smoothers for divergence and curl conforming   finite elements with essential boundary conditions. Other applications   are possible, in particular changing <tt>boundary_patches</tt> for non-   essential boundary conditions.     This function returns the <tt>vertex_mapping</tt>,   that contains the mapping from the vertex indices to the block indices   of the <tt>block_list</tt>. For vertices that do not lead to a vertex   patch, the entry in <tt>vertex_mapping</tt> contains the value   <tt>invalid_unsigned_int</tt>. If <tt>invert_vertex_mapping</tt> is set to   <tt>true</tt>, then the <tt>vertex_mapping</tt> is inverted such that it   contains the mapping from the block indices to the corresponding vertex   indices.      [2.x.330]  <tt>block_list</tt>: the SparsityPattern into which the patches will   be stored.      [2.x.331]  <tt>dof_handler</tt>: the multilevel dof handler providing the   topology operated on.      [2.x.332]  <tt>interior_dofs_only</tt>: for each patch of cells around a   vertex, collect only the interior degrees of freedom of the patch and   disregard those on the boundary of the patch. This is for instance the   setting for smoothers of Arnold-Falk-Winther type.      [2.x.333]  <tt>boundary_patches</tt>: include patches around vertices at the   boundary of the domain. If not, only patches around interior vertices   will be generated.      [2.x.334]  <tt>level_boundary_patches</tt>: same for refinement edges towards   coarser cells.      [2.x.335]  <tt>single_cell_patches</tt>: if not true, patches containing a   single cell are eliminated.      [2.x.336]  <tt>invert_vertex_mapping</tt>: if true, then the return value   contains one vertex index for each block; if false, then the return value   contains one block index or <tt>invalid_unsigned_int</tt> for each vertex.  
* [0.x.64]*
   Same as above but allows boundary dofs on blocks to be excluded   individually.     This is helpful if you want to use, for example, Taylor Hood elements as   it allows you to not include the boundary DoFs for the velocity block on   the patches while also letting you include the boundary DoFs for the   pressure block.     For each patch of cells around a vertex, collect all of the interior   degrees of freedom of the patch and disregard those on the boundary of   the patch if the boolean value for the corresponding block in the   BlockMask of  [2.x.337]  is false.  
* [0.x.65]*
   Create an incidence matrix that for every cell on a given level of a   multilevel DoFHandler flags which degrees of freedom are associated with   children of this cell. This data structure is conveniently represented by   a SparsityPattern object.     The function thus creates a sparsity pattern which in each row (with rows   corresponding to the cells on this level) lists the degrees of freedom   associated to the cells that are the children of this cell. The DoF   indices used here are level dof indices of a multilevel hierarchy, i.e.,   they may be associated with children that are not themselves active. The   sparsity pattern may be empty when entering this function and will be   reinitialized to the correct size.     The function has some boolean arguments (listed below) controlling   details of the generated patches. The default settings are those for   Arnold-Falk-Winther type smoothers for divergence and curl conforming   finite elements with essential boundary conditions. Other applications   are possible, in particular changing <tt>boundary_dofs</tt> for non-   essential boundary conditions.      [2.x.338]  <tt>block_list</tt>: the SparsityPattern into which the patches will   be stored.      [2.x.339]  <tt>dof_handler</tt>: The multilevel dof handler providing the   topology operated on.      [2.x.340]  <tt>interior_dofs_only</tt>: for each patch of cells around a   vertex, collect only the interior degrees of freedom of the patch and   disregard those on the boundary of the patch. This is for instance the   setting for smoothers of Arnold-Falk-Winther type.      [2.x.341]  <tt>boundary_dofs</tt>: include degrees of freedom, which would have   excluded by <tt>interior_dofs_only</tt>, but are lying on the boundary of   the domain, and thus need smoothing. This parameter has no effect if   <tt>interior_dofs_only</tt> is false.  
* [0.x.66]*
   Create a block list with only a single patch, which in turn contains all   degrees of freedom on the given level.     This function is mostly a closure on level 0 for functions like   make_child_patches() and make_vertex_patches(), which may produce an   empty patch list.      [2.x.342]  <tt>block_list</tt>: the SparsityPattern into which the patches will   be stored.      [2.x.343]  <tt>dof_handler</tt>: The multilevel dof handler providing the   topology operated on.      [2.x.344]  <tt>level</tt> The grid level used for building the list.      [2.x.345]  <tt>interior_dofs_only</tt>: if true, exclude degrees of freedom on   the boundary of the domain.  
* [0.x.67]*
    [2.x.346]   
* [0.x.68]*
    [2.x.347]  Counting degrees of freedom and related functions    [2.x.348]   
* [0.x.69]*
   Count how many degrees of freedom out of the total number belong to each   component. If the number of components the finite element has is one   (i.e. you only have one scalar variable), then the number in this   component obviously equals the total number of degrees of freedom.   Otherwise, the sum of the DoFs in all the components needs to equal the   total number.     However, the last statement does not hold true if the finite element is   not primitive, i.e. some or all of its shape functions are non-zero in   more than one vector component. This applies, for example, to the Nedelec   or Raviart-Thomas elements. In this case, a degree of freedom is counted   in each component in which it is non-zero, so that the sum mentioned   above is greater than the total number of degrees of freedom.     This behavior can be switched off by the optional parameter   <tt>vector_valued_once</tt>. If this is <tt>true</tt>, the number of   components of a nonprimitive vector valued element is collected only in   the first component. All other components will have a count of zero.     The additional optional argument  [2.x.349]  allows for a re-   sorting and grouping of components. To this end, it contains for each   component the component number it shall be counted as. Having the same   number entered several times sums up several components as the same. One   of the applications of this argument is when you want to form block   matrices and vectors, but want to pack several components into the same   block (for example, when you have  [2.x.350]  velocities and one pressure, to   put all velocities into one block, and the pressure into another).     The result is returned in  [2.x.351]  Note that the size of  [2.x.352]    dofs_per_component needs to be enough to hold all the indices specified   in  [2.x.353]  If this is not the case, an assertion is thrown.   The indices not targeted by target_components are left untouched.  
* [0.x.70]*
   Count the degrees of freedom in each block. This function is similar to   count_dofs_per_component(), with the difference that the counting is done   by blocks. See    [2.x.354]  "blocks"   in the glossary for details. Again the vectors are assumed to have the   correct size before calling this function. If this is not the case, an   assertion is thrown.     This function is used in the  [2.x.355] ,  [2.x.356] , and  [2.x.357]  tutorial   programs, among others.      [2.x.358]  The dofs_per_block variable has as many components as the finite   element used by the dof_handler argument has blocks, or alternatively as   many blocks as are enumerated in the target_blocks argument if given.  
* [0.x.71]*
   For each active cell of a DoFHandler, extract the active finite element   index and fill the vector given as second argument. This vector is assumed   to have as many entries as there are active cells.     For DoFHandler objects without hp-capabilities given as first argument, the   returned vector will consist of only zeros, indicating that all cells use   the same finite element. In hp-mode, the values may be different, though.  
* [0.x.72]*
   Count how many degrees of freedom live on a set of cells (i.e., a patch)   described by the argument.     Patches are often used in defining error estimators that require the   solution of a local problem on the patch surrounding each of the cells of   the mesh. You can get a list of cells that form the patch around a given   cell using  [2.x.359]  This function is then   useful in setting up the size of the linear system used to solve the   local problem on the patch around a cell. The function    [2.x.360]  will then help to make the connection   between global degrees of freedom and the local ones.      [2.x.361]  patch A collection of cells within an object of type   DoFHandler<dim, spacedim>      [2.x.362]  The number of degrees of freedom associated with the cells of   this patch.    
*  [2.x.363]  In the context of a parallel distributed computation, it only makes   sense to call this function on patches around locally owned cells. This   is because the neighbors of locally owned cells are either locally owned   themselves, or ghost cells. For both, we know that these are in fact the   real cells of the complete, parallel triangulation. We can also query the   degrees of freedom on these. In other words, this function can only work   if all cells in the patch are either locally owned or ghost cells.  
* [0.x.73]*
   The same as above.      [2.x.364]  Use the function that takes dim and spacedim as template     argument.  
* [0.x.74]*
    [2.x.365]   
* [0.x.75]*
    [2.x.366]  Functions that return different DoF mappings    [2.x.367]   
* [0.x.76]*
   Create a mapping from degree of freedom indices to the index of that   degree of freedom on the boundary. After this operation,   <tt>mapping[dof]</tt> gives the index of the degree of freedom with   global number  [2.x.368]  in the list of degrees of freedom on the boundary.   If the degree of freedom requested is not on the boundary, the value of   <tt>mapping[dof]</tt> is  [2.x.369]  This function is   mainly used when setting up matrices and vectors on the boundary from the   trial functions, which have global numbers, while the matrices and vectors   use numbers of the trial functions local to the boundary.     Prior content of  [2.x.370]  is deleted.  
* [0.x.77]*
   Same as the previous function, except that only those parts of the   boundary are considered for which the boundary indicator is listed in the   second argument.     See the general doc of this class for more information.      [2.x.371]     [2.x.372]  "Glossary entry on boundary indicators"  
* [0.x.78]*
   Return a list of support points (see this    [2.x.373]  "glossary entry")   for all the degrees of freedom handled by this DoF handler object. This   function, of course, only works if the finite element object used by the   DoF handler object actually provides support points, i.e. no edge   elements or the like. Otherwise, an exception is thrown.      [2.x.374]  The given array must have a length of as many elements as there are   degrees of freedom.    
*  [2.x.375]  The precondition to this function that the output argument needs to   have size equal to the total number of degrees of freedom makes this   function unsuitable for the case that the given DoFHandler object derives   from a  [2.x.376]  object (or any of the classes derived   from  [2.x.377]  Consequently, this function will produce   an error if called with such a DoFHandler.      [2.x.378]  mapping The mapping from the reference cell to the real cell on   which DoFs are defined.    [2.x.379]  dof_handler The object that describes which DoF indices live on   which cell of the triangulation.    [2.x.380]  support_points A vector that stores the corresponding   location of the dofs in real space coordinates. Previous content of this   object is deleted in this function.    [2.x.381]  mask An optional component mask that restricts the   components from which the support points are extracted.  
* [0.x.79]*
   Same as the previous function but for the hp-case.  
* [0.x.80]*
   This function is a version of the above map_dofs_to_support_points   function that doesn't simply return a vector of support points (see this    [2.x.382]  "glossary entry")   with one entry for each global degree of freedom, but instead a map that   maps from the DoFs index to its location. The point of this function is   that it is also usable in cases where the DoFHandler is based on a    [2.x.383]  object (or any of the classes derived from    [2.x.384]  In such cases, each   processor will not be able to determine the support point location of all   DoFs, and worse no processor may be able to hold a vector that would   contain the locations of all DoFs even if they were known. As a   consequence, this function constructs a map from those DoFs for which we   can know the locations (namely, those DoFs that are locally relevant (see    [2.x.385]  "locally relevant DoFs")   to their locations.     For non-distributed triangulations, the map returned as  [2.x.386]    is of course dense, i.e., every DoF is to be found in it.      [2.x.387]  mapping The mapping from the reference cell to the real cell on   which DoFs are defined.    [2.x.388]  dof_handler The object that describes which DoF indices live on   which cell of the triangulation.    [2.x.389]  support_points A map that for every locally relevant DoF   index contains the corresponding location in real space coordinates.   Previous content of this object is deleted in this function.    [2.x.390]  mask An optional component mask that restricts the   components from which the support points are extracted.  
* [0.x.81]*
   Same as the previous function but for the hp-case.  
* [0.x.82]*
   This is the opposite function to the one above. It generates a map where   the keys are the support points of the degrees of freedom, while the   values are the DoF indices. For a definition of support points, see this    [2.x.391]  "glossary entry".     Since there is no natural order in the space of points (except for the 1d   case), you have to provide a map with an explicitly specified comparator   object. This function is therefore templatized on the comparator object.   Previous content of the map object is deleted in this function.     Just as with the function above, it is assumed that the finite element in   use here actually supports the notion of support points of all its   components.      [2.x.392]  This function should generate a multimap, rather than just a map,   since several dofs may be located at the same support point. Currently,   only the last value in the map returned by map_dofs_to_support_points() for   each point will be returned.  
* [0.x.83]*
    [2.x.393]   
* [0.x.84]*
    [2.x.394]  Miscellaneous    [2.x.395]   
* [0.x.85]*
   Take a vector of values which live on cells (e.g. an error per cell) and   distribute it to the dofs in such a way that a finite element field   results, which can then be further processed, e.g. for output. You should   note that the resulting field will not be continuous at hanging nodes.   This can, however, easily be arranged by calling the appropriate  [2.x.396]    distribute function of an AffineConstraints object created for this   DoFHandler object, after the vector has been fully assembled.     It is assumed that the number of elements in  [2.x.397]  equals the   number of active cells and that the number of elements in  [2.x.398]    equals <tt>dof_handler.n_dofs()</tt>.     Note that the input vector may be a vector of any data type as long as it   is convertible to  [2.x.399]   The output vector, being a data vector on a   DoF handler, always consists of elements of type  [2.x.400]      In case the finite element used by this DoFHandler consists of more than   one component, you need to specify which component in the output vector   should be used to store the finite element field in; the default is zero   (no other value is allowed if the finite element consists only of one   component). All other components of the vector remain untouched, i.e.   their contents are not changed.     This function cannot be used if the finite element in use has shape   functions that are non-zero in more than one vector component (in deal.II   speak: they are non-primitive).  
* [0.x.86]*
   Generate text output readable by gnuplot with point data based on the   given map  [2.x.401]   For each support point location, a string   label containing a list of all DoFs from the map is generated.  The map   can be generated with a call to map_dofs_to_support_points() and is useful   to visualize location and global numbering of unknowns.     An example for the format of each line in the output is:  
* [1.x.13]
*    where x, y, and z (present only in corresponding dimension) are the   coordinates of the support point, followed by a list of DoF numbers.     The points with labels can be plotted as follows in gnuplot:  
* [1.x.14]
*      Examples (this also includes the grid written separately using GridOut):    [2.x.402]      To generate the mesh and the support point information in a   single gnuplot file, use code similar to  
* [1.x.15]
*    and from within gnuplot execute the following command:  
* [1.x.16]
*      Alternatively, the following gnuplot script will generate a png file when   executed as <tt>gnuplot gnuplot.gpl</tt> on the command line:  
* [1.x.17]
*   
* [0.x.87]*
   Add constraints to  [2.x.403]  corresponding to   enforcing a zero boundary condition on the given boundary indicator.     This function constrains all degrees of freedom on the given part of the   boundary.     A variant of this function with different arguments is used in  [2.x.404] .      [2.x.405]  dof The DoFHandler to work on.    [2.x.406]  boundary_id The indicator of that part of the boundary for which   constraints should be computed. If this number equals    [2.x.407]  then all boundaries of the domain will be   treated.    [2.x.408]  zero_boundary_constraints The constraint object into which the   constraints will be written. The new constraints due to zero boundary   values will simply be added, preserving any other constraints previously   present. However, this will only work if the previous content of that   object consists of constraints on degrees of freedom that are not located   on the boundary treated here. If there are previously existing   constraints for degrees of freedom located on the boundary, then this   would constitute a conflict. See the    [2.x.409]    module for handling the case where there are conflicting constraints on   individual degrees of freedom.    [2.x.410]  component_mask An optional component mask that restricts the   functionality of this function to a subset of an FESystem. For non-    [2.x.411]  "primitive"   shape functions, any degree of freedom is affected that belongs to a   shape function where at least one of its nonzero components is affected   by the component mask (see    [2.x.412] ).   If this argument is omitted, all components of the finite element with   degrees of freedom at the boundary will be considered.    
*  [2.x.413]       [2.x.414]     [2.x.415]  "Glossary entry on boundary indicators"  
* [0.x.88]*
   Do the same as the previous function, except do it for all parts of the   boundary, not just those with a particular boundary indicator. This   function is then equivalent to calling the previous one with    [2.x.416]  as second argument.     This function is used in  [2.x.417] , for example.    
*  [2.x.418]   
* [0.x.89]*
    [2.x.419]   
* [0.x.90]*
    [2.x.420]  Exceptions    [2.x.421]   
* [0.x.91]*
    [2.x.422]  Write description    
*  [2.x.423]   
* [0.x.92]*
    [2.x.424]  Write description    
*  [2.x.425]   
* [0.x.93]*
    [2.x.426]  Write description     Exception  
*  [2.x.427]   
* [0.x.94]*
   The DoFHandler was not initialized with a finite element. Please call    [2.x.428]  first.    
*  [2.x.429]   
* [0.x.95]*
    [2.x.430]  Write description    
*  [2.x.431]   
* [0.x.96]*
    [2.x.432]   
* [0.x.97]*
   Operator computing the maximum coupling out of two.      [2.x.433]  DoFTools  
* [0.x.98]*
   Operator computing the maximum coupling out of two.      [2.x.434]  DoFTools  
* [0.x.99]