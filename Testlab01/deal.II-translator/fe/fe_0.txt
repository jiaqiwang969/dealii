[0.x.0]*
 This is the base class for finite elements in arbitrary dimensions. It declares the interface both in terms of member variables and public member functions through which properties of a concrete implementation of a finite element can be accessed. This interface generally consists of a number of groups of variables and functions that can roughly be delineated as follows:
* 

* 
* 
*  - Basic information about the finite element, such as the number of degrees of freedom per vertex, edge, or cell. This kind of data is stored in the FiniteElementData base class. (Though the  [2.x.0]  member function also falls into this category.)
* 

* 
* 
*  - A description of the shape functions and their derivatives on the reference cell  [2.x.1] , if an element is indeed defined by mapping shape functions from the reference cell to an actual cell.
* 

* 
* 
*  - Matrices (and functions that access them) that describe how an element's shape functions related to those on parent or child cells (restriction or prolongation) or neighboring cells (for hanging node constraints), as well as to other finite element spaces defined on the same cell (e.g., when doing  [2.x.2]  refinement).
* 

* 
* 
*  - %Functions that describe the properties of individual shape functions, for example which  [2.x.3]  "vector components" of a  [2.x.4]  "vector-valued finite element's" shape function is nonzero, or whether an element is  [2.x.5]  "primitive".
* 

* 
* 
*  - For elements that are interpolatory, such as the common  [2.x.6]  Lagrange elements, data that describes where their  [2.x.7]  "support points" are located.
* 

* 
* 
*  - %Functions that define the interface to the FEValues class that is almost always used to access finite element shape functions from user code.
*  The following sections discuss many of these concepts in more detail, and outline strategies by which concrete implementations of a finite element can provide the details necessary for a complete description of a finite element space.
*  As a general rule, there are three ways by which derived classes provide this information:
* 

* 
* 
*  - A number of fields that are generally easy to compute and that are initialized by the constructor of this class (or the constructor of the FiniteElementData base class) and derived classes therefore have to compute in the process of calling this class's constructor. This is, specifically, the case for the basic information and parts of the descriptive information about shape functions mentioned above.
* 

* 
* 
*  - Some common matrices that are widely used in the library and for which this class provides protected member variables that the constructors of derived classes need to fill. The purpose of providing these matrices in this class is that (i) they are frequently used, and (ii) they are expensive to compute. Consequently, it makes sense to only compute them once, rather than every time they are used. In most cases, the constructor of the current class already sets them to their correct size, and derived classes therefore only have to fill them. Examples of this include the matrices that relate the shape functions on one cell to the shape functions on neighbors, children, and parents.
* 

* 
* 
*  - Uncommon information, or information that depends on specific input arguments, and that needs to be implemented by derived classes. For these, this base class only declares abstract virtual member functions and derived classes then have to implement them. Examples of this category would include the functions that compute values and derivatives of shape functions on the reference cell for which it is not possible to tabulate values because there are infinitely many points at which one may want to evaluate them. In some cases, derived classes may choose to simply not implement [1.x.0] possible interfaces (or may not [1.x.1] have a complete implementation); for uncommon functions, there is then often a member function derived classes can overload that describes whether a particular feature is implemented. An example is whether an element implements the information necessary to use it in the  [2.x.8]  finite element context (see  [2.x.9]  "hp-finite element support").
* 

*  [1.x.2]
*  Finite element classes have to define a large number of different properties describing  a finite element space. The following subsections describe some nomenclature that will be used in the documentation below.
*  [1.x.3]
*   [2.x.10]  "Vector-valued finite element" are elements used for systems of partial differential equations. Oftentimes, they are composed via the FESystem class (which is itself derived from the current class), but there are also non-composed elements that have multiple components (for example the FE_Nedelec and FE_RaviartThomas classes, among others). For any of these vector valued elements, individual shape functions may be nonzero in one or several  [2.x.11]  "components" of the vector valued function. If the element is  [2.x.12]  "primitive", there is indeed a single component with a nonzero entry for each shape function. This component can be determined using the  [2.x.13]  function.
*  On the other hand, if there is at least one shape function that is nonzero in more than one vector component, then we call the entire element "non- primitive". The  [2.x.14]  can then be used to determine which vector components of a shape function are nonzero. The number of nonzero components of a shape function is returned by  [2.x.15]  Whether a shape function is non-primitive can be queried by  [2.x.16] 
*  Oftentimes, one may want to split linear system into blocks so that they reflect the structure of the underlying operator. This is typically not done based on vector components, but based on the use of  [2.x.17]  "blocks", and the result is then used to substructure objects of type BlockVector, BlockSparseMatrix, BlockMatrixArray, and so on. If you use non-primitive elements, you cannot determine the block number by  [2.x.18]  Instead, you can use  [2.x.19]  The number of blocks of a finite element can be determined by  [2.x.20] 
*  To better illustrate these concepts, let's consider the following example of the multi-component system

* 
* [1.x.4]
*  with  [2.x.21] . The resulting finite element has 3 components: two that come from the quadratic element and one from the linear element. If, for example, this system were used to discretize a problem in fluid dynamics then one could think of the first two components representing a vector-valued velocity field whereas the last one corresponds to the scalar pressure field. Without degree-of-freedom (DoF) renumbering this finite element will produce the following distribution of local DoFs:
*   [2.x.22] 
*  Using the two functions  [2.x.23]  and  [2.x.24]  one can get the following information for each degree-of-freedom "i":

* 
* [1.x.5]
*  which will result in:
*  | DoF    | Component  | Base element | Shape function within base | Multiplicity | | :----: | :--------: | :----------: | :------------------------: | :----------: | |      0 |          0 |            0 |                          0 |            0 | |      1 |          1 |            0 |                          0 |            1 | |      2 |          2 |            1 |                          0 |            0 | |      3 |          0 |            0 |                          1 |            0 | |      4 |          1 |            0 |                          1 |            1 | |      5 |          2 |            1 |                          1 |            0 | |      6 |          0 |            0 |                          2 |            0 | |      7 |          1 |            0 |                          2 |            1 | |      8 |          2 |            1 |                          2 |            0 | |      9 |          0 |            0 |                          3 |            0 | |     10 |          1 |            0 |                          3 |            1 | |     11 |          2 |            1 |                          3 |            0 | |     12 |          0 |            0 |                          4 |            0 | |     13 |          1 |            0 |                          4 |            1 | |     14 |          0 |            0 |                          5 |            0 | |     15 |          1 |            0 |                          5 |            1 | |     16 |          0 |            0 |                          6 |            0 | |     17 |          1 |            0 |                          6 |            1 | |     18 |          0 |            0 |                          7 |            0 | |     19 |          1 |            0 |                          7 |            1 | |     20 |          0 |            0 |                          8 |            0 | |     21 |          1 |            0 |                          8 |            1 |
*  What we see is the following: there are a total of 22 degrees-of-freedom on this element with components ranging from 0 to 2. Each DoF corresponds to one of the two base elements used to build FESystem :  [2.x.25]  or  [2.x.26] . Since FE_Q are primitive elements, we have a total of 9 distinct scalar-valued shape functions for the quadratic element and 4 for the linear element. Finally, for DoFs corresponding to the first base element multiplicity is either zero or one, meaning that we use the same scalar valued  [2.x.27]  for both  [2.x.28]  and  [2.x.29]  components of the velocity field  [2.x.30] . For DoFs corresponding to the second base element multiplicity is zero.
*  [1.x.6]
*  Finite elements are frequently defined by defining a polynomial space and a set of dual functionals. If these functionals involve point evaluations, then the element is "interpolatory" and it is possible to interpolate an arbitrary (but sufficiently smooth) function onto the finite element space by evaluating it at these points. We call these points "support points".
*  Most finite elements are defined by mapping from the reference cell to a concrete cell. Consequently, the support points are then defined on the reference ("unit") cell, see  [2.x.31]  "this glossary entry". The support points on a concrete cell can then be computed by mapping the unit support points, using the Mapping class interface and derived classes, typically via the FEValues class.
*  A typical code snippet to do so would look as follows:

* 
* [1.x.7]
* 
*  Alternatively, the points can be transformed one-by-one:

* 
* [1.x.8]
* 
* 

* 
*  [2.x.32]  Finite elements' implementation of the get_unit_support_points() function returns these points in the same order as shape functions. As a consequence, the quadrature points accessed above are also ordered in this way. The order of shape functions is typically documented in the class documentation of the various finite element classes.
* 

*  [1.x.9]
*  The following sections provide some more guidance for implementing concrete finite element spaces in derived classes. This includes information that depends on the dimension for which you want to provide something, followed by a list of tools helping to generate information in concrete cases.
*  It is important to note that there is a number of intermediate classes that can do a lot of what is necessary for a complete description of finite element spaces. For example, the FE_Poly, FE_PolyTensor, and FE_PolyFace classes in essence build a complete finite element space if you only provide them with an abstract description of the polynomial space upon which you want to build an element. Using these intermediate classes typically makes implementing finite element descriptions vastly simpler.
*  As a general rule, if you want to implement an element, you will likely want to look at the implementation of other, similar elements first. Since many of the more complicated pieces of a finite element interface have to do with how they interact with mappings, quadrature, and the FEValues class, you will also want to read through the  [2.x.33]  documentation module.
* 

*  [1.x.10]
*  In one space dimension (i.e., for  [2.x.34]  and any value of  [2.x.35] ), finite element classes implementing the interface of the current base class need only set the #restriction and #prolongation matrices that describe the interpolation of the finite element space on one cell to that of its parent cell, and to that on its children, respectively. The constructor of the current class in one dimension presets the #interface_constraints matrix (used to describe hanging node constraints at the interface between cells of different refinement levels) to have size zero because there are no hanging nodes in 1d.
*  [1.x.11]
*  In addition to the fields discussed above for 1D, a constraint matrix is needed to describe hanging node constraints if the finite element has degrees of freedom located on edges or vertices. These constraints are represented by an  [2.x.36] -matrix #interface_constraints, where [1.x.12] is the number of degrees of freedom on the refined side without the corner vertices (those dofs on the middle vertex plus those on the two lines), and [1.x.13] is that of the unrefined side (those dofs on the two vertices plus those on the line). The matrix is thus a rectangular one. The  [2.x.37]  size of the #interface_constraints matrix can also be accessed through the interface_constraints_size() function.
*  The mapping of the dofs onto the indices of the matrix on the unrefined side is as follows: let  [2.x.38]  be the number of dofs on a vertex,  [2.x.39]  that on a line, then  [2.x.40]  refers to the dofs on vertex zero of the unrefined line,  [2.x.41]  to those on vertex one,  [2.x.42]  to those on the line.
*  Similarly,  [2.x.43]  refers to the dofs on the middle vertex of the refined side (vertex one of child line zero, vertex zero of child line one),  [2.x.44]  refers to the dofs on child line zero,  [2.x.45]  refers to the dofs on child line one.  Please note that we do not need to reserve space for the dofs on the end vertices of the refined lines, since these must be mapped one-to-one to the appropriate dofs of the vertices of the unrefined line.
*  Through this construction, the degrees of freedom on the child faces are constrained to the degrees of freedom on the parent face. The information so provided is typically consumed by the  [2.x.46]  function.
* 

* 
*  [2.x.47]  The hanging node constraints described by these matrices are only relevant to the case where the same finite element space is used on neighboring (but differently refined) cells. The case that the finite element spaces on different sides of a face are different, i.e., the  [2.x.48]  case (see  [2.x.49]  "hp-finite element support") is handled by separate functions. See the  [2.x.50]  and  [2.x.51]  functions.
* 

*  [1.x.14]
*  For the interface constraints, the 3d case is similar to the 2d case. The numbering for the indices  [2.x.52]  on the mother face is obvious and keeps to the usual numbering of degrees of freedom on quadrilaterals.
*  The numbering of the degrees of freedom on the interior of the refined faces for the index  [2.x.53]  is as follows: let  [2.x.54]  and  [2.x.55]  be as above, and  [2.x.56]  be the number of degrees of freedom per quadrilateral (and therefore per face), then  [2.x.57]  denote the dofs on the vertex at the center,  [2.x.58]  for the dofs on the vertices at the center of the bounding lines of the quadrilateral,  [2.x.59]  are for the degrees of freedom on the four lines connecting the center vertex to the outer boundary of the mother face,  [2.x.60]  for the degrees of freedom on the small lines surrounding the quad, and  [2.x.61]  for the dofs on the four child faces. Note the direction of the lines at the boundary of the quads, as shown below.
*  The order of the twelve lines and the four child faces can be extracted from the following sketch, where the overall order of the different dof groups is depicted:

* 
* [1.x.15]
*  The numbering of vertices and lines, as well as the numbering of children within a line is consistent with the one described in Triangulation. Therefore, this numbering is seen from the outside and inside, respectively, depending on the face.
*  The three-dimensional case has a few pitfalls available for derived classes that want to implement constraint matrices. Consider the following case:

* 
* [1.x.16]
*  Now assume that we want to refine cell 2. We will end up with two faces with hanging nodes, namely the faces between cells 1 and 2, as well as between cells 2 and 3. Constraints have to be applied to the degrees of freedom on both these faces. The problem is that there is now an edge (the top right one of cell 2) which is part of both faces. The hanging node(s) on this edge are therefore constrained twice, once from both faces. To be meaningful, these constraints of course have to be consistent: both faces have to constrain the hanging nodes on the edge to the same nodes on the coarse edge (and only on the edge, as there can then be no constraints to nodes on the rest of the face), and they have to do so with the same weights. This is sometimes tricky since the nodes on the edge may have different local numbers.
*  For the constraint matrix this means the following: if a degree of freedom on one edge of a face is constrained by some other nodes on the same edge with some weights, then the weights have to be exactly the same as those for constrained nodes on the three other edges with respect to the corresponding nodes on these edges. If this isn't the case, you will get into trouble with the AffineConstraints class that is the primary consumer of the constraint information: while that class is able to handle constraints that are entered more than once (as is necessary for the case above), it insists that the weights are exactly the same.
*  Using this scheme, child face degrees of freedom are constrained against parent face degrees of freedom that contain those on the edges of the parent face; it is possible that some of them are in turn constrained themselves, leading to longer chains of constraints that the AffineConstraints class will eventually have to sort out. (The constraints described above are used by the  [2.x.62]  function that constructs an AffineConstraints object.) However, this is of no concern for the FiniteElement and derived classes since they only act locally on one cell and its immediate neighbor, and do not see the bigger picture. The  [2.x.63]  details how such chains are handled in practice.
* 

*  [1.x.17]
*  Construction of a finite element and computation of the matrices described above is often a tedious task, in particular if it has to be performed for several dimensions. Most of this work can be avoided by using the intermediate classes already mentioned above (e.g., FE_Poly, FE_PolyTensor, etc). Other tasks can be automated by some of the functions in namespace FETools.
*  [1.x.18]
*  First, it may already be difficult to compute the basis of shape functions for arbitrary order and dimension. On the other hand, if the  [2.x.64]  "node values" are given, then the duality relation between node functionals and basis functions defines the basis. As a result, the shape function space may be defined from a set of linearly independent functions, such that the actual finite element basis is computed from linear combinations of them. The coefficients of these combinations are determined by the duality of node values and form a matrix.
*  Using this matrix allows the construction of the basis of shape functions in two steps.  [2.x.65] 
*   [2.x.66] Define the space of shape functions using an arbitrary basis [1.x.19] and compute the matrix [1.x.20] of node functionals [1.x.21] applied to these basis functions, such that its entries are [1.x.22].
*   [2.x.67] Compute the basis [1.x.23] of the finite element shape function space by applying [1.x.24] to the basis [1.x.25].  [2.x.68] 
*  The matrix [1.x.26] may be computed with  [2.x.69]  This function relies on the existence of #generalized_support_points and  [2.x.70]  (see the  [2.x.71]  "glossary entry on generalized support points" for more information). With this, one can then use the following piece of code in the constructor of a class derived from FiniteElement to compute the  [2.x.72]  matrix:

* 
* [1.x.27]
*  Don't forget to make sure that #unit_support_points or #generalized_support_points are initialized before this!
*  [1.x.28]
*  Once you have shape functions, you can define matrices that transfer data from one cell to its children or the other way around. This is a common operation in multigrid, of course, but is also used when interpolating the solution from one mesh to another after mesh refinement, as well as in the definition of some error estimators.
*  To define the prolongation matrices, i.e., those matrices that describe the transfer of a finite element field from one cell to its children, implementations of finite elements can either fill the #prolongation array by hand, or can call  [2.x.73] 
*  In the latter case, all that is required is the following piece of code:

* 
* [1.x.29]
*  As in this example, prolongation is almost always implemented via embedding, i.e., the nodal values of the function on the children may be different from the nodal values of the function on the parent cell, but as a function of  [2.x.74] , the finite element field on the child is the same as on the parent.
* 

*  [1.x.30]
*  The opposite operation, restricting a finite element function defined on the children to the parent cell is typically implemented by interpolating the finite element function on the children to the nodal values of the parent cell. In deal.II, the restriction operation is implemented as a loop over the children of a cell that each apply a matrix to the vector of unknowns on that child cell (these matrices are stored in #restriction and are accessed by get_restriction_matrix()). The operation that then needs to be implemented turns out to be surprisingly difficult to describe, but is instructive to describe because it also defines the meaning of the #restriction_is_additive_flags array (accessed via the restriction_is_additive() function).
*  To give a concrete example, assume we use a  [2.x.75]  element in 1d, and that on each of the parent and child cells degrees of freedom are (locally and globally) numbered as follows:

* 
* [1.x.31]
*  Then we want the restriction operation to take the value of the zeroth DoF on child 0 as the value of the zeroth DoF on the parent, and take the value of the first DoF on child 1 as the value of the first DoF on the parent. Ideally, we would like to write this follows [1.x.32] where  [2.x.76]  and  [2.x.77] . Writing the requested operation like this would here be possible by choosing [1.x.33] However, this approach already fails if we go to a  [2.x.78]  element with the following degrees of freedom:

* 
* [1.x.34]
*  Writing things as the sum over matrix operations as above would not easily work because we have to add nonzero values to  [2.x.79]  twice, once for each child.
*  Consequently, restriction is typically implemented as a [1.x.35] operation. I.e., we first compute the individual restrictions from each child, [1.x.36] and then compute the values of  [2.x.80]  with the following code:

* 
* [1.x.37]
*  In other words, each nonzero element of  [2.x.81]  [1.x.38], rather than adds to the corresponding element of  [2.x.82] . This typically also implies that the restriction matrices from two different cells should agree on a value for coarse degrees of freedom that they both want to touch (otherwise the result would depend on the order in which we loop over children, which would be unreasonable because the order of children is an otherwise arbitrary convention). For example, in the example above, the restriction matrices will be [1.x.39] and the compatibility condition is the  [2.x.83]  because they both indicate that  [2.x.84]  should be set to one times  [2.x.85]  and  [2.x.86] .
*  Unfortunately, not all finite elements allow to write the restriction operation in this way. For example, for the piecewise constant FE_DGQ(0) element, the value of the finite element field on the parent cell can not be determined by interpolation from the children. Rather, the only reasonable choice is to take it as the [1.x.40] value between the children
* 
*  -  so we are back to the sum operation, rather than the concatenation. Further thought shows that whether restriction should be additive or not is a property of the individual shape function, not of the finite element as a whole. Consequently, the  [2.x.87]  function returns whether a particular shape function should act via concatenation (a return value of  [2.x.88]  or via addition (return value of  [2.x.89]  and the correct code for the overall operation is then as follows (and as, in fact, implemented in  [2.x.90] 

* 
* [1.x.41]
* 
* 

*  [1.x.42]
*  Constraint matrices can be computed semi-automatically using  [2.x.91]  This function computes the representation of the coarse mesh functions by fine mesh functions for each child of a face separately. These matrices must be convoluted into a single rectangular constraint matrix, eliminating degrees of freedom on common vertices and edges as well as on the coarse grid vertices. See the discussion above for details of this numbering.
* 

* 
*  [2.x.92] 

* 
* [0.x.1]*
   The dimension of the image space, corresponding to Triangulation.  
* [0.x.2]*
   A base class for internal data that derived finite element classes may   wish to store.     The class is used as follows: Whenever an FEValues (or FEFaceValues or   FESubfaceValues) object is initialized, it requests that the finite   element it is associated with creates an object of a class derived from   the current one here. This is done via each derived class's    [2.x.93]  function. This object is then passed to the    [2.x.94]   [2.x.95]    and  [2.x.96]  functions as a constant   object. The intent of these objects is so that finite element classes can   pre-compute information once at the beginning (in the call to    [2.x.97]  call) that can then be used on each cell that   is subsequently visited. An example for this is the values of shape   functions at the quadrature point of the reference cell, which remain the   same no matter the cell visited, and that can therefore be computed once   at the beginning and reused later on.     Because only derived classes can know what they can pre-compute, each   derived class that wants to store information computed once at the   beginning, needs to derive its own InternalData class from this class,   and return an object of the derived type through its get_data() function.  
* [0.x.3]*
     Constructor. Sets update_flags to  [2.x.98]  and  [2.x.99]      to  [2.x.100]     
* [0.x.4]*
     Destructor. Made virtual to allow polymorphism.    
* [0.x.5]*
     Copy construction is forbidden.    
* [0.x.6]*
     A set of update flags specifying the kind of information that an     implementation of the FiniteElement interface needs to compute on each     cell or face, i.e., in  [2.x.101]  and friends.         This set of flags is stored here by implementations of      [2.x.102]   [2.x.103]  or      [2.x.104]  and is that subset of the update     flags passed to those functions that require re-computation on every     cell. (The subset of the flags corresponding to information that can be     computed once and for all already at the time of the call to      [2.x.105] 
* 
*  -  or an implementation of that interface
* 
*  -      need not be stored here because it has already been taken care of.)    
* [0.x.7]*
     Return an estimate (in bytes) for the memory consumption of this object.    
* [0.x.8]*
   Constructor: initialize the fields of this base class of all finite   elements.      [2.x.106]  fe_data An object that stores identifying (typically integral)   information about the element to be constructed. In particular, this   object will contain data such as the number of degrees of freedom per   cell (and per vertex, line, etc), the number of vector components, etc.   This argument is used to initialize the base class of the current object   under construction.    [2.x.107]  restriction_is_additive_flags A vector of size    [2.x.108]  (or of size one, see below) that for each   shape function states whether the shape function is additive or not. The   meaning of these flags is described in the section on restriction   matrices in the general documentation of this class.    [2.x.109]  nonzero_components A vector of size  [2.x.110]    (or of size one, see below) that for each shape function provides a   ComponentMask (of size  [2.x.111] ) that   indicates in which vector components this shape function is nonzero   (after mapping the shape function to the real cell). For "primitive"   shape functions, this component mask will have a single entry (see    [2.x.112]    for more information about primitive elements). On the other hand, for   elements such as the Raviart-Thomas or Nedelec elements, shape functions   are nonzero in more than one vector component (after mapping to the real   cell) and the given component mask will contain more than one entry. (For   these two elements, all entries will in fact be set, but this would not   be the case if you couple a FE_RaviartThomas and a FE_Nedelec together   into a FESystem.)      [2.x.113]   [2.x.114] ,   or  [2.x.115] . In the latter   case, the array is simply interpreted as having size    [2.x.116]  where each element has the same value as the   single element given.      [2.x.117]   [2.x.118] , or    [2.x.119] . In the latter case, the   array is simply interpreted as having size  [2.x.120]    where each element equals the component mask provided in the single   element given.  
* [0.x.9]*
   Move constructor.  
* [0.x.10]*
   Copy constructor.  
* [0.x.11]*
   Virtual destructor. Makes sure that pointers to this class are deleted   properly.  
* [0.x.12]*
   Creates information for creating a FESystem with this class as   base element and with multiplicity  [2.x.121]  In particular,   the return type of this function can be used in the constructor   for a FESystem object.   This function calls clone() and hence creates a copy of the   current object.  
* [0.x.13]*
   A sort of virtual copy constructor, this function returns a copy of   the finite element object. Derived classes need to override the function   here in this base class and return an object of the same type as the   derived class.     Some places in the library, for   example the constructors of FESystem as well as the  [2.x.122]    class, need to make copies of finite elements without knowing their exact   type. They do so through this function.  
* [0.x.14]*
   Return a string that uniquely identifies a finite element. The general   convention is that this is the class name, followed by the dimension in   angle brackets, and the polynomial degree and whatever else is necessary   in parentheses. For example, <tt>FE_Q<2>(3)</tt> is the value returned   for a cubic element in 2d.     Systems of elements have their own naming convention, see the FESystem   class.  
* [0.x.15]*
   This operator returns a reference to the present object if the argument   given equals to zero. While this does not seem particularly useful, it is   helpful in writing code that works with both ::DoFHandler and the hp-   version  [2.x.123]  since one can then write code like this:  
* [1.x.43]
*      This code doesn't work in both situations without the present operator   because  [2.x.124]  returns a finite element, whereas    [2.x.125]  returns a collection of finite elements that   doesn't offer a  [2.x.126]  member variable: one first has   to select which finite element to work on, which is done using the   operator[]. Fortunately,  [2.x.127]  also works   for non-hp-classes and simply returns zero in that case. The present   operator[] accepts this zero argument, by returning the finite element   with index zero within its collection (that, of course, consists only of   the present finite element anyway).      [2.x.128]  With  [2.x.129]  and the deprecation of the    [2.x.130]  class, there is no more use of this operator.  
* [0.x.16]*
    [2.x.131]  Shape function access    [2.x.132]   
* [0.x.17]*
   Return the value of the  [2.x.133]  shape function at the point  [2.x.134]   [2.x.135]  is   a point on the reference element. If the finite element is vector-valued,   then return the value of the only non-zero component of the vector value   of this shape function. If the shape function has more than one non-zero   component (which we refer to with the term non-primitive), then derived   classes implementing this function should throw an exception of type   ExcShapeFunctionNotPrimitive. In that case, use the   shape_value_component() function.     Implementations of this function should throw an exception of type   ExcUnitShapeValuesDoNotExist if the shape functions of the FiniteElement   under consideration depend on the shape of the cell in real space, i.e.,   if the shape functions are not defined by mapping from the reference   cell. Some non-conforming elements are defined this way, as is the   FE_DGPNonparametric class, to name just one example.     The default implementation of this virtual function does exactly this,   i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist.  
* [0.x.18]*
   Just like for shape_value(), but this function will be called when the   shape function has more than one non-zero vector component. In that case,   this function should return the value of the  [2.x.136]  vector   component of the  [2.x.137]  shape function at point  [2.x.138]   
* [0.x.19]*
   Return the gradient of the  [2.x.139]  shape function at the point  [2.x.140]   [2.x.141]    is a point on the reference element, and likewise the gradient is the   gradient on the unit cell with respect to unit cell coordinates. If the   finite element is vector-valued, then return the value of the only non-   zero component of the vector value of this shape function. If the shape   function has more than one non-zero component (which we refer to with the   term non-primitive), then derived classes implementing this function   should throw an exception of type ExcShapeFunctionNotPrimitive. In that   case, use the shape_grad_component() function.     Implementations of this function should throw an exception of type   ExcUnitShapeValuesDoNotExist if the shape functions of the FiniteElement   under consideration depend on the shape of the cell in real space, i.e.,   if the shape functions are not defined by mapping from the reference   cell. Some non-conforming elements are defined this way, as is the   FE_DGPNonparametric class, to name just one example.     The default implementation of this virtual function does exactly this,   i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist.  
* [0.x.20]*
   Just like for shape_grad(), but this function will be called when the   shape function has more than one non-zero vector component. In that case,   this function should return the gradient of the  [2.x.142]  vector   component of the  [2.x.143]  shape function at point  [2.x.144]   
* [0.x.21]*
   Return the tensor of second derivatives of the  [2.x.145]  shape function at   point  [2.x.146]  on the unit cell. The derivatives are derivatives on the unit   cell with respect to unit cell coordinates. If the finite element is   vector-valued, then return the value of the only non-zero component of   the vector value of this shape function. If the shape function has more   than one non-zero component (which we refer to with the term non-   primitive), then derived classes implementing this function should throw   an exception of type ExcShapeFunctionNotPrimitive. In that case, use the   shape_grad_grad_component() function.     Implementations of this function should throw an exception of type   ExcUnitShapeValuesDoNotExist if the shape functions of the FiniteElement   under consideration depend on the shape of the cell in real space, i.e.,   if the shape functions are not defined by mapping from the reference   cell. Some non-conforming elements are defined this way, as is the   FE_DGPNonparametric class, to name just one example.     The default implementation of this virtual function does exactly this,   i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist.  
* [0.x.22]*
   Just like for shape_grad_grad(), but this function will be called when   the shape function has more than one non-zero vector component. In that   case, this function should return the gradient of the  [2.x.147]    vector component of the  [2.x.148]  shape function at point  [2.x.149]   
* [0.x.23]*
   Return the tensor of third derivatives of the  [2.x.150]  shape function at   point  [2.x.151]  on the unit cell. The derivatives are derivatives on the unit   cell with respect to unit cell coordinates. If the finite element is   vector-valued, then return the value of the only non-zero component of   the vector value of this shape function. If the shape function has more   than one non-zero component (which we refer to with the term non-   primitive), then derived classes implementing this function should throw   an exception of type ExcShapeFunctionNotPrimitive. In that case, use the   shape_3rd_derivative_component() function.     Implementations of this function should throw an exception of type   ExcUnitShapeValuesDoNotExist if the shape functions of the FiniteElement   under consideration depend on the shape of the cell in real space, i.e.,   if the shape functions are not defined by mapping from the reference   cell. Some non-conforming elements are defined this way, as is the   FE_DGPNonparametric class, to name just one example.     The default implementation of this virtual function does exactly this,   i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist.  
* [0.x.24]*
   Just like for shape_3rd_derivative(), but this function will be called   when the shape function has more than one non-zero vector component. In   that case, this function should return the gradient of the  [2.x.152]    th vector component of the  [2.x.153]  shape function at point  [2.x.154]   
* [0.x.25]*
   Return the tensor of fourth derivatives of the  [2.x.155]  shape function at   point  [2.x.156]  on the unit cell. The derivatives are derivatives on the unit   cell with respect to unit cell coordinates. If the finite element is   vector-valued, then return the value of the only non-zero component of   the vector value of this shape function. If the shape function has more   than one non-zero component (which we refer to with the term non-   primitive), then derived classes implementing this function should throw   an exception of type ExcShapeFunctionNotPrimitive. In that case, use the   shape_4th_derivative_component() function.     Implementations of this function should throw an exception of type   ExcUnitShapeValuesDoNotExist if the shape functions of the FiniteElement   under consideration depend on the shape of the cell in real space, i.e.,   if the shape functions are not defined by mapping from the reference   cell. Some non-conforming elements are defined this way, as is the   FE_DGPNonparametric class, to name just one example.     The default implementation of this virtual function does exactly this,   i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist.  
* [0.x.26]*
   Just like for shape_4th_derivative(), but this function will be called   when the shape function has more than one non-zero vector component. In   that case, this function should return the gradient of the  [2.x.157]    th vector component of the  [2.x.158]  shape function at point  [2.x.159]   
* [0.x.27]*
   This function returns  [2.x.160]  if the shape function  [2.x.161]  has   non-zero function values somewhere on the face  [2.x.162]  The   function is typically used to determine whether some matrix elements   resulting from face integrals can be assumed to be zero and may therefore   be omitted from integration.     A default implementation is provided in this base class which always   returns  [2.x.163]  This is the safe way to go.  
* [0.x.28]*
    [2.x.164]  Transfer and constraint matrices    [2.x.165]   
* [0.x.29]*
   Return the matrix that describes restricting a finite element field from   the given  [2.x.166]  (as obtained by the given  [2.x.167]  to the   parent cell. The interpretation of the returned matrix depends on what   restriction_is_additive() returns for each shape function.     Row and column indices are related to coarse grid and fine grid spaces,   respectively, consistent with the definition of the associated operator.     If projection matrices are not implemented in the derived finite element   class, this function aborts with an exception of type    [2.x.168]  You can check whether this would happen   by first calling the restriction_is_implemented() or the   isotropic_restriction_is_implemented() function.  
* [0.x.30]*
   Prolongation/embedding matrix between grids.     The identity operator from a coarse grid space into a fine grid space   (where both spaces are identified as functions defined on the parent and   child cells) is associated with a matrix  [2.x.169]  that maps the corresponding   representations of these functions in terms of their nodal values. The   restriction of this matrix  [2.x.170]  to a single child cell is returned   here.     The matrix  [2.x.171]  is the concatenation, not the sum of the cell matrices  [2.x.172]    P_i. That is, if the same non-zero entry <tt>j,k</tt> exists in two   different child matrices  [2.x.173]  the value should be the same in both   matrices and it is copied into the matrix  [2.x.174]  only once.     Row and column indices are related to fine grid and coarse grid spaces,   respectively, consistent with the definition of the associated operator.     These matrices are used by routines assembling the prolongation matrix   for multi-level methods.  Upon assembling the transfer matrix between   cells using this matrix array, zero elements in the prolongation matrix   are discarded and will not fill up the transfer matrix.     If prolongation matrices are not implemented in the derived finite   element class, this function aborts with an exception of type    [2.x.175]  You can check whether this would happen   by first calling the prolongation_is_implemented() or the   isotropic_prolongation_is_implemented() function.  
* [0.x.31]*
   Return whether this element implements its prolongation matrices. The   return value also indicates whether a call to the   get_prolongation_matrix() function will generate an error or not.     Note, that this function returns  [2.x.176]  only if the   prolongation matrices of the isotropic and all anisotropic refinement   cases are implemented. If you are interested in the prolongation matrices   for isotropic refinement only, use the   isotropic_prolongation_is_implemented function instead.     This function is mostly here in order to allow us to write more efficient   test programs which we run on all kinds of weird elements, and for which   we simply need to exclude certain tests in case something is not   implemented. It will in general probably not be a great help in   applications, since there is not much one can do if one needs these   features and they are not implemented. This function could be used to   check whether a call to <tt>get_prolongation_matrix()</tt> will succeed;   however, one then still needs to cope with the lack of information this   just expresses.  
* [0.x.32]*
   Return whether this element implements its prolongation matrices for   isotropic children. The return value also indicates whether a call to the    [2.x.177]  function will generate an error or not.     This function is mostly here in order to allow us to write more efficient   test programs which we run on all kinds of weird elements, and for which   we simply need to exclude certain tests in case something is not   implemented. It will in general probably not be a great help in   applications, since there is not much one can do if one needs these   features and they are not implemented. This function could be used to   check whether a call to <tt>get_prolongation_matrix()</tt> will succeed;   however, one then still needs to cope with the lack of information this   just expresses.  
* [0.x.33]*
   Return whether this element implements its restriction matrices. The   return value also indicates whether a call to the   get_restriction_matrix() function will generate an error or not.     Note, that this function returns  [2.x.178]  only if the   restriction matrices of the isotropic and all anisotropic refinement   cases are implemented. If you are interested in the restriction matrices   for isotropic refinement only, use the   isotropic_restriction_is_implemented() function instead.     This function is mostly here in order to allow us to write more efficient   test programs which we run on all kinds of weird elements, and for which   we simply need to exclude certain tests in case something is not   implemented. It will in general probably not be a great help in   applications, since there is not much one can do if one needs these   features and they are not implemented. This function could be used to   check whether a call to <tt>get_restriction_matrix()</tt> will succeed;   however, one then still needs to cope with the lack of information this   just expresses.  
* [0.x.34]*
   Return whether this element implements its restriction matrices for   isotropic children. The return value also indicates whether a call to the   get_restriction_matrix() function will generate an error or not.     This function is mostly here in order to allow us to write more efficient   test programs which we run on all kinds of weird elements, and for which   we simply need to exclude certain tests in case something is not   implemented. It will in general probably not be a great help in   applications, since there is not much one can do if one needs these   features and they are not implemented. This function could be used to   check whether a call to <tt>get_restriction_matrix()</tt> will succeed;   however, one then still needs to cope with the lack of information this   just expresses.  
* [0.x.35]*
   Access the #restriction_is_additive_flags field. See the discussion about   restriction matrices in the general class documentation for more   information.     The index must be between zero and the number of shape functions of this   element.  
* [0.x.36]*
   Return a read only reference to the matrix that describes the constraints   at the interface between a refined and an unrefined cell.     Some finite elements do not (yet) implement hanging node constraints. If   this is the case, then this function will generate an exception, since no   useful return value can be generated. If you should have a way to live   with this, then you might want to use the constraints_are_implemented()   function to check up front whether this function will succeed or generate   the exception.  
* [0.x.37]*
   Return whether this element implements its hanging node constraints. The   return value also indicates whether a call to the constraints() function   will generate an error or not.     This function is mostly here in order to allow us to write more efficient   test programs which we run on all kinds of weird elements, and for which   we simply need to exclude certain tests in case hanging node constraints   are not implemented. It will in general probably not be a great help in   applications, since there is not much one can do if one needs hanging   node constraints and they are not implemented. This function could be   used to check whether a call to <tt>constraints()</tt> will succeed;   however, one then still needs to cope with the lack of information this   just expresses.  
* [0.x.38]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".  That   means, the element properly implements the get_face_interpolation_matrix   and get_subface_interpolation_matrix methods. Therefore the return value   also indicates whether a call to the get_face_interpolation_matrix()   method and the get_subface_interpolation_matrix() method will generate an   error or not.     Currently the main purpose of this function is to allow the   make_hanging_node_constraints method to decide whether the new   procedures, which are supposed to work in the hp-framework can be used,   or if the old well verified but not hp-capable functions should be used.   Once the transition to the new scheme for computing the interface   constraints is complete, this function will be superfluous and will   probably go away.     Derived classes should implement this function accordingly. The default   assumption is that a finite element does not provide hp-capable face   interpolation, and the default implementation therefore returns  [2.x.179]   
* [0.x.39]*
   Return the matrix interpolating from the given finite element to the   present one. The size of the matrix is then #dofs_per_cell times   <tt>source.#dofs_per_cell</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type   ExcInterpolationNotImplemented.  
* [0.x.40]*
    [2.x.180]  Functions to support hp    [2.x.181]   
* [0.x.41]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.#dofs_per_face</tt> times <tt>this->#dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type   ExcInterpolationNotImplemented.  
* [0.x.42]*
   Return the matrix interpolating from a face of one element to the   subface of the neighboring element.  The size of the matrix is then   <tt>source.#dofs_per_face</tt> times <tt>this->#dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type   ExcInterpolationNotImplemented.  
* [0.x.43]*
    [2.x.182]  Functions to support hp-    [2.x.183]   
* [0.x.44]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.184]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.  
* [0.x.45]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.  
* [0.x.46]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on quads.  
* [0.x.47]*
   Return whether this element dominates another one given as argument    [2.x.185]  whether it is the other way around, whether neither dominates,   or if either could dominate. The  [2.x.186]  parameter describes the codimension   of the investigated subspace and specifies that it is subject to this   comparison. For example, if `codim==0` then this function compares which   element dominates at the cell level. If `codim==1`, then the elements are   compared at faces, i.e., the comparison happens between the function spaces   of the two finite elements as restricted to a face. Larger values of   `codim` work correspondingly.     For a definition of domination, see  [2.x.187]    and in particular the    [2.x.188]  "hp-paper".  
* [0.x.48]*
   Comparison operator.     The implementation in the current class checks for equality of the   following pieces of information between the current object and the one   given as argument, in this order:
* 

* 
* 

* 
* 

* 
* 
*  - the dynamic type (i.e., the type of the most derived class) of the     current object and of the given object,
* 

* 
* 

* 
* 

* 
* 
*  - the name returned by get_name(),
* 

* 
* 

* 
* 

* 
* 
*  - as all of the fields in FiniteElementData,
* 

* 
* 

* 
* 

* 
* 
*  - constraint matrices.     This covers most cases where elements can differ, but there are   cases of derived elements that are different and for which the   current function still returns  [2.x.189]  For these cases, derived   classes should overload this function.    
*  [2.x.190]  This operator specifically does not check the following     member variables of the current class:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - restriction matrices,
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - prolongation matrices of this object and the argument.    This is because these member variables may be initialized only    on demand by derived classes, rather than being available immediately.    Consequently, comparing these members would not only be costly because    these are generally big arrays, but also because their computation may    be expensive. On the other hand, derived classes for which these    arrays may differ for two objects even though the above list compares    as equal, will probably want to implement their own operator==()    anyway.  
* [0.x.49]*
   Non-equality comparison operator. Defined in terms of the equality   comparison operator.  
* [0.x.50]*
    [2.x.191]  Index computations    [2.x.192]   
* [0.x.51]*
   Compute vector component and index of this shape function within the   shape functions corresponding to this component from the index of a shape   function within this finite element.     If the element is scalar, then the component is always zero, and the   index within this component is equal to the overall index.     If the shape function referenced has more than one non-zero component,   then it cannot be associated with one vector component, and an exception   of type ExcShapeFunctionNotPrimitive will be raised.     Note that if the element is composed of other (base) elements, and a base   element has more than one component but all its shape functions are   primitive (i.e. are non-zero in only one component), then this mapping   contains valid information. However, the index of a shape function of   this element within one component (i.e. the second number of the   respective entry of this array) does not indicate the index of the   respective shape function within the base element (since that has more   than one vector-component). For this information, refer to the   #system_to_base_table field and the system_to_base_index() function.     See the class description above for an example of how this function is   typically used.     The use of this function is explained extensively in the  [2.x.193]  and    [2.x.194]  " [2.x.195] "   tutorial programs as well as in the    [2.x.196]    module.  
* [0.x.52]*
   Compute the shape function for the given vector component and index.     If the element is scalar, then the component must be zero, and the index   within this component is equal to the overall index.     This is the opposite operation from the system_to_component_index()   function.  
* [0.x.53]*
   Same as system_to_component_index(), but do it for shape functions and   their indices on a face. The range of allowed indices is therefore   0..#dofs_per_face.     You will rarely need this function in application programs, since almost   all application codes only need to deal with cell indices, not face   indices. The function is mainly there for use inside the library.  
* [0.x.54]*
   For faces with non-standard face_orientation in 3D, the dofs on faces   (quads) have to be permuted in order to be combined with the correct   shape functions. Given a local dof  [2.x.197]  on a quad, return the local   index, if the face has non-standard face_orientation, face_flip or   face_rotation. In 2D and 1D there is no need for permutation and   consequently an exception is thrown.  
* [0.x.55]*
   Given an index in the natural ordering of indices on a face, return the   index of the same degree of freedom on the cell.     To explain the concept, consider the case where we would like to know   whether a degree of freedom on a face, for example as part of an FESystem   element, is primitive. Unfortunately, the is_primitive() function in the   FiniteElement class takes a cell index, so we would need to find the cell   index of the shape function that corresponds to the present face index.   This function does that.     Code implementing this would then look like this:  
* [1.x.44]
*    The function takes additional arguments that account for the fact that   actual faces can be in their standard ordering with respect to the cell   under consideration, or can be flipped, oriented, etc.      [2.x.198]  face_dof_index The index of the degree of freedom on a face. This   index must be between zero and dofs_per_face.    [2.x.199]  face The number of the face this degree of freedom lives on. This   number must be between zero and  [2.x.200]     [2.x.201]  face_orientation One part of the description of the orientation of   the face. See    [2.x.202] .    [2.x.203]  face_flip One part of the description of the orientation of the   face. See    [2.x.204] .    [2.x.205]  face_rotation One part of the description of the orientation of   the face. See    [2.x.206] .    [2.x.207]  The index of this degree of freedom within the set of degrees of   freedom on the entire cell. The returned value will be between zero and   dofs_per_cell.    
*  [2.x.208]  This function exists in this class because that is where it was   first implemented. However, it can't really work in the most general case   without knowing what element we have. The reason is that when a face is   flipped or rotated, we also need to know whether we need to swap the   degrees of freedom on this face, or whether they are immune from this.   For this, consider the situation of a  [2.x.209]  element in 2d. If face_flip   is true, then we need to consider the two degrees of freedom on the edge   in reverse order. On the other hand, if the element were a  [2.x.210] , then   because the two degrees of freedom on this edge belong to different   vector components, they should not be considered in reverse order. What   all of this shows is that the function can't work if there are more than   one degree of freedom per line or quad, and that in these cases the   function will throw an exception pointing out that this functionality   will need to be provided by a derived class that knows what degrees of   freedom actually represent.  
* [0.x.56]*
   For lines with non-standard line_orientation in 3D, the dofs on lines   have to be permuted in order to be combined with the correct shape   functions. Given a local dof  [2.x.211]  on a line, return the local index,   if the line has non-standard line_orientation. In 2D and 1D there is no   need for permutation, so the given index is simply returned.  
* [0.x.57]*
   Return in which of the vector components of this finite element the  [2.x.212]    ith shape function is non-zero. The length of the returned array is equal   to the number of vector components of this element.     For most finite element spaces, the result of this function will be a   vector with exactly one element being  [2.x.213]  since for most spaces the   individual vector components are independent. In that case, the component   with the single zero is also the first element of what   system_to_component_index() returns.     Only for those spaces that couple the components, for example to make a   shape function divergence free, will there be more than one  [2.x.214]    entry.  Elements for which this is true are called non-primitive (see    [2.x.215] ).  
* [0.x.58]*
   Return in how many vector components the  [2.x.216]  shape function is non-   zero. This value equals the number of entries equal to  [2.x.217]  in the   result of the get_nonzero_components() function.     For most finite element spaces, the result will be equal to one. It is   not equal to one only for those ansatz spaces for which vector-valued   shape functions couple the individual components, for example in order to   make them divergence-free.  
* [0.x.59]*
   Return whether the entire finite element is primitive, in the sense that   all its shape functions are primitive. If the finite element is scalar,   then this is always the case.     Since this is an extremely common operation, the result is cached and   returned by this function.  
* [0.x.60]*
   Return whether the  [2.x.218]  shape function is primitive in the sense that   the shape function is non-zero in only one vector component. Non-   primitive shape functions would then, for example, be those of divergence   free ansatz spaces, in which the individual vector components are   coupled.     The result of the function is  [2.x.219]  if and only if the result of   <tt>n_nonzero_components(i)</tt> is equal to one.  
* [0.x.61]*
   Number of base elements in a mixed discretization.     Note that even for vector valued finite elements, the number of   components needs not coincide with the number of base elements, since   they may be reused. For example, if you create a FESystem with three   identical finite element classes by using the constructor that takes one   finite element and a multiplicity, then the number of base elements is   still one, although the number of components of the finite element is   equal to the multiplicity.  
* [0.x.62]*
   Access to base element objects. If the element is atomic, then    [2.x.220]  is  [2.x.221]   
* [0.x.63]*
   This index denotes how often the base element  [2.x.222]  is used in a   composed element. If the element is atomic, then the result is always   equal to one. See the documentation for the n_base_elements() function   for more details.  
* [0.x.64]*
   Return a reference to a contained finite element that matches the   components   selected by the given ComponentMask  [2.x.223]      For an arbitrarily nested FESystem, this function returns the inner-most   FiniteElement that matches the given mask. The method fails if the  [2.x.224]    does not exactly match one of the contained finite elements. It is most   useful if the current object is an FESystem, as the return value can   only be  [2.x.225]  in all other cases.     Note that the returned object can be an FESystem if the   mask matches it but not any of the contained objects.     Let us illustrate the function with the an FESystem  [2.x.226]  with 7 components:  
* [1.x.45]
*      The following table lists all possible component masks you can use:    [2.x.227]   
* [0.x.65]*
   Return a reference to a contained finite element that matches the   components    [2.x.228]  components starting at component with index    [2.x.229]      See the other get_sub_fe() function above for more details.  
* [0.x.66]*
   Return for shape function  [2.x.230]  the base element it belongs to, the   number of the copy of this base element (which is between zero and the   multiplicity of this element), and the index of this shape function   within this base element.     If the element is not composed of others, then base and instance are   always zero, and the index is equal to the number of the shape function.   If the element is composed of single instances of other elements (i.e.   all with multiplicity one) all of which are scalar, then base values and   dof indices within this element are equal to the   #system_to_component_table. It differs only in case the element is   composed of other elements and at least one of them is vector-valued   itself.     See the class documentation above for an example of how this function is   typically used.     This function returns valid values also in the case of vector-valued   (i.e. non-primitive) shape functions, in contrast to the   system_to_component_index() function.  
* [0.x.67]*
   Same as system_to_base_index(), but for degrees of freedom located on a   face. The range of allowed indices is therefore 0..#dofs_per_face.     You will rarely need this function in application programs, since almost   all application codes only need to deal with cell indices, not face   indices. The function is mainly there for use inside the library.  
* [0.x.68]*
   Given a base element number, return the first block of a BlockVector it   would generate.  
* [0.x.69]*
   For each vector component, return which base element implements this   component and which vector component in this base element this is. This   information is only of interest for vector-valued finite elements which   are composed of several sub-elements. In that case, one may want to   obtain information about the element implementing a certain vector   component, which can be done using this function and the    [2.x.231]  function.     If this is a scalar finite element, then the return value is always equal   to a pair of zeros.  
* [0.x.70]*
   Return the base element for this block and the number of the copy of the   base element.  
* [0.x.71]*
   The vector block and the index inside the block for this shape function.  
* [0.x.72]*
   The vector block for this component.  
* [0.x.73]*
    [2.x.232]  Component and block matrices    [2.x.233]   
* [0.x.74]*
   Return a component mask with as many elements as this object has vector   components and of which exactly the one component is true that   corresponds to the given argument. See    [2.x.234]  "the glossary"   for more information.      [2.x.235]  scalar An object that represents a single scalar vector component   of this finite element.    [2.x.236]  A component mask that is false in all components except for the   one that corresponds to the argument.  
* [0.x.75]*
   Return a component mask with as many elements as this object has vector   components and of which exactly the  [2.x.237]  components are true   that correspond to the given argument. See    [2.x.238]  "the glossary"   for more information.      [2.x.239]  vector An object that represents dim vector components of this   finite element.    [2.x.240]  A component mask that is false in all components except for the   ones that corresponds to the argument.  
* [0.x.76]*
   Return a component mask with as many elements as this object has vector   components and of which exactly the  [2.x.241]  components   are true that correspond to the given argument. See    [2.x.242]  "the glossary"   for more information.      [2.x.243]  sym_tensor An object that represents dim*(dim+1)/2 components of   this finite element that are jointly to be interpreted as forming a   symmetric tensor.    [2.x.244]  A component mask that is false in all components except for the   ones that corresponds to the argument.  
* [0.x.77]*
   Given a block mask (see    [2.x.245]  "this glossary entry"),   produce a component mask (see    [2.x.246]  "this glossary entry")   that represents the components that correspond to the blocks selected in   the input argument. This is essentially a conversion operator from   BlockMask to ComponentMask.      [2.x.247]  block_mask The mask that selects individual blocks of the finite   element    [2.x.248]  A mask that selects those components corresponding to the   selected blocks of the input argument.  
* [0.x.78]*
   Return a block mask with as many elements as this object has blocks and   of which exactly the one component is true that corresponds to the given   argument. See    [2.x.249]  "the glossary"   for more information.    
*  [2.x.250]  This function will only succeed if the scalar referenced by the   argument encompasses a complete block. In other words, if, for example,   you pass an extractor for the single  [2.x.251]  velocity and this object   represents an FE_RaviartThomas object, then the single scalar object you   selected is part of a larger block and consequently there is no block   mask that would represent it. The function will then produce an   exception.      [2.x.252]  scalar An object that represents a single scalar vector component   of this finite element.    [2.x.253]  A component mask that is false in all components except for the   one that corresponds to the argument.  
* [0.x.79]*
   Return a component mask with as many elements as this object has vector   components and of which exactly the  [2.x.254]  components are true   that correspond to the given argument. See    [2.x.255]  "the glossary"   for more information.    
*  [2.x.256]  The same caveat applies as to the version of the function above:   The extractor object passed as argument must be so that it corresponds to   full blocks and does not split blocks of this element.      [2.x.257]  vector An object that represents dim vector components of this   finite element.    [2.x.258]  A component mask that is false in all components except for the   ones that corresponds to the argument.  
* [0.x.80]*
   Return a component mask with as many elements as this object has vector   components and of which exactly the  [2.x.259]  components   are true that correspond to the given argument. See    [2.x.260]  "the glossary"   for more information.    
*  [2.x.261]  The same caveat applies as to the version of the function above:   The extractor object passed as argument must be so that it corresponds to   full blocks and does not split blocks of this element.      [2.x.262]  sym_tensor An object that represents dim*(dim+1)/2 components of   this finite element that are jointly to be interpreted as forming a   symmetric tensor.    [2.x.263]  A component mask that is false in all components except for the   ones that corresponds to the argument.  
* [0.x.81]*
   Given a component mask (see    [2.x.264]  "this glossary entry"),   produce a block mask (see    [2.x.265]  "this glossary entry")   that represents the blocks that correspond to the components selected in   the input argument. This is essentially a conversion operator from   ComponentMask to BlockMask.    
*  [2.x.266]  This function will only succeed if the components referenced by the   argument encompasses complete blocks. In other words, if, for example,   you pass an component mask for the single  [2.x.267]  velocity and this object   represents an FE_RaviartThomas object, then the single component you   selected is part of a larger block and consequently there is no block   mask that would represent it. The function will then produce an   exception.      [2.x.268]  component_mask The mask that selects individual components of the   finite element    [2.x.269]  A mask that selects those blocks corresponding to the selected   blocks of the input argument.  
* [0.x.82]*
   Return a list of constant modes of the element. The number of rows in   the resulting table depends on the elements in use. For standard   elements, the table has as many rows as there are components in the   element and dofs_per_cell columns. To each component of the finite   element, the row in the returned table contains a basis representation of   the constant function 1 on the element. However, there are some scalar   elements where there is more than one constant mode, e.g. the element   FE_Q_DG0.     In order to match the constant modes to the actual components in the   element, the returned data structure also returns a vector with as many   components as there are constant modes on the element that contains the   component number.  
* [0.x.83]*
    [2.x.270]  Support points and interpolation    [2.x.271]   
* [0.x.84]*
   Return the support points of the trial functions on the unit cell, if the   derived finite element defines them.  Finite elements that allow some   kind of interpolation operation usually have support points. On the other   hand, elements that define their degrees of freedom by, for example,   moments on faces, or as derivatives, don't have support points. In that   case, the returned field is empty.     If the finite element defines support points, then their number equals   the number of degrees of freedom of the element.  The order of points in   the array matches that returned by the <tt>cell->get_dof_indices</tt>   function.     See the class documentation for details on support points.    
*  [2.x.272]  Finite elements' implementation of this function returns these   points in the same order as shape functions. The order of shape functions   is typically documented in the class documentation of the various finite   element classes. In particular, shape functions (and consequently the   mapped quadrature points discussed in the class documentation of this   class) will then traverse first those shape functions located on   vertices, then on lines, then on quads, etc.    
*  [2.x.273]  If this element implements support points, then it will return one   such point per shape function. Since multiple shape functions may be   defined at the same location, the support points returned here may be   duplicated. An example would be an element of the kind    [2.x.274]  for which each support point would   appear three times in the returned array.  
* [0.x.85]*
   Return whether a finite element has defined support points. If the result   is true, then a call to the get_unit_support_points() yields a non-empty   array.     The result may be false if an element is not defined by interpolating   shape functions, for example by P-elements on quadrilaterals. It will   usually only be true if the element constructs its shape functions by the   requirement that they be one at a certain point and zero at all the   points associated with the other shape functions.     In composed elements (i.e. for the FESystem class), the result will be   true if all the base elements have defined support points. FE_Nothing   is a special case in FESystems, because it has 0 support points and   has_support_points() is false, but an FESystem containing an FE_Nothing   among other elements will return true.  
* [0.x.86]*
   Return the position of the support point of the  [2.x.275]  shape   function. If it does not exist, raise an exception.     The default implementation simply returns the respective element from the   array you get from get_unit_support_points(), but derived elements may   overload this function. In particular, note that the FESystem class   overloads it so that it can return the support points of individual base   elements, if not all the base elements define support points. In this   way, you can still ask for certain support points, even if   get_unit_support_points() only returns an empty array.  
* [0.x.87]*
   Return the support points of the trial functions on the unit face, if the   derived finite element defines some.  Finite elements that allow some   kind of interpolation operation usually have support points. On the other   hand, elements that define their degrees of freedom by, for example,   moments on faces, or as derivatives, don't have support points. In that   case, the returned field is empty     Note that elements that have support points need not necessarily have   some on the faces, even if the interpolation points are located   physically on a face. For example, the discontinuous elements have   interpolation points on the vertices, and for higher degree elements also   on the faces, but they are not defined to be on faces since in that case   degrees of freedom from both sides of a face (or from all adjacent   elements to a vertex) would be identified with each other, which is not   what we would like to have). Logically, these degrees of freedom are   therefore defined to belong to the cell, rather than the face or vertex.   In that case, the returned element would therefore have length zero.     If the finite element defines support points, then their number equals   the number of degrees of freedom on the face (#dofs_per_face). The order   of points in the array matches that returned by the   <tt>cell->face(face)->get_dof_indices</tt> function.     See the class documentation for details on support points.  
* [0.x.88]*
   Return whether a finite element has defined support points on faces. If   the result is true, then a call to the get_unit_face_support_points()   yields a non-empty vector.     For more information, see the documentation for the has_support_points()   function.  
* [0.x.89]*
   The function corresponding to the unit_support_point() function, but for   faces. See there for more information.  
* [0.x.90]*
   Return a vector of generalized support points.    
*  [2.x.276]  The vector returned by this function is always a minimal set of  unique* support points. This is in contrast to the behavior of   get_unit_support_points() that returns a repeated list of unit support   points for an FESystem of numerous (Lagrangian) base elements.     See the    [2.x.277]  "glossary entry on generalized support points"   for more information.  
* [0.x.91]*
   Return whether a finite element has defined generalized support   points. If the result is true, then a call to the   get_generalized_support_points() yields a non-empty vector.     See the    [2.x.278]  "glossary entry on generalized support points"   for more information.  
* [0.x.92]*
   For a given degree of freedom, return whether it is logically associated   with a vertex, line, quad or hex.     For instance, for continuous finite elements this coincides with the   lowest dimensional object the support point of the degree of freedom lies   on. To give an example, for  [2.x.279]  elements in 3d, every degree of freedom   is defined by a shape function that we get by interpolating using support   points that lie on the vertices of the cell. The support of these points   of course extends to all edges connected to this vertex, as well as the   adjacent faces and the cell interior, but we say that logically the   degree of freedom is associated with the vertex as this is the lowest-   dimensional object it is associated with. Likewise, for  [2.x.280]  elements in   3d, the degrees of freedom with support points at edge midpoints would   yield a value of  [2.x.281]  from this function, whereas   those on the centers of faces in 3d would return  [2.x.282]      To make this more formal, the kind of object returned by this function   represents the object so that the support of the shape function   corresponding to the degree of freedom, (i.e., that part of the domain   where the function "lives") is the union of all of the cells sharing this   object. To return to the example above, for  [2.x.283]  in 3d, the shape   function with support point at an edge midpoint has support on all cells   that share the edge and not only the cells that share the adjacent faces,   and consequently the function will return  [2.x.284]      On the other hand, for discontinuous elements of type  [2.x.285] , a degree   of freedom associated with an interpolation polynomial that has its   support point physically located at a line bounding a cell, but is   nonzero only on one cell. Consequently, it is logically associated with   the interior of that cell (i.e., with a  [2.x.286]  in 2d and   a  [2.x.287]  in 3d).      [2.x.288]  cell_dof_index The index of a shape function or degree of   freedom. This index must be in the range  [2.x.289] .    
*  [2.x.290]  The integer value of the object returned by this function equals   the dimensionality of the object it describes, and can consequently be   used in generic programming paradigms. For example, if a degree of   freedom is associated with a vertex, then this function returns    [2.x.291]  which has a numeric value of zero (the   dimensionality of a vertex).  
* [0.x.93]*
   Given the values of a function  [2.x.292]  at the (generalized)   support points of the reference cell, this function then computes what   the nodal values of the element are, i.e.,  [2.x.293] , where  [2.x.294]    are the node functionals of the element   (see also    [2.x.295]  "Node values or node functionals").   The values  [2.x.296]  are then the expansion coefficients   for the shape functions of the finite element function that   [1.x.46] the given function  [2.x.297] , i.e.,    [2.x.298]  is the finite element interpolant of  [2.x.299]  with the current element.   The operation described here is used, for example, in the    [2.x.300]  function.     In more detail, let us assume that the generalized support points   (see    [2.x.301]  "this glossary entry"   ) of the current   element are  [2.x.302]  and that the node functionals associated   with the current element are  [2.x.303] . Then, the fact that the   element is based on generalized support points, implies that if we   apply  [2.x.304]  to a (possibly vector-valued) finite element function    [2.x.305] , the result must have the form    [2.x.306] 
* 
*  -  in other words,   the value of the node functional  [2.x.307]  applied to  [2.x.308]  [1.x.47]   depends on the [1.x.48] and not   on values anywhere else, or integrals of  [2.x.309] , or any other kind   of information.     The exact form of  [2.x.310]  depends on the element. For example, for scalar    [2.x.311]  "Lagrange elements",   we have that in fact    [2.x.312] . If you combine multiple   scalar Lagrange elements via an FESystem object, then    [2.x.313]  where  [2.x.314]    is the result of the  [2.x.315]    function's return value's first component. In these two cases,    [2.x.316]  is therefore simply the identity (in the scalar case) or a   function that selects a particular vector component of its argument.   On the other hand, for Raviart-Thomas elements, one would have that    [2.x.317]  where  [2.x.318]    is the normal vector of the face at which the shape function is   defined.     Given all of this, what this function does is the following: If you   input a list of values of a function  [2.x.319]  at all generalized   support points (where each value is in fact a vector of values with   as many components as the element has), then this function returns   a vector of values obtained by applying the node functionals to   these values. In other words, if you pass in    [2.x.320]  then you   will get out a vector    [2.x.321]  where  [2.x.322]  equals  [2.x.323]       [2.x.324]  support_point_values An array of size  [2.x.325]      (which equals the number of points the get_generalized_support_points()     function will return) where each element is a vector with as many entries     as the element has vector components. This array should contain     the values of a function at the generalized support points of the     current element.    [2.x.326]  nodal_values An array of size  [2.x.327]  that contains     the node functionals of the element applied to the given function.    
*  [2.x.328]  It is safe to call this function for (transformed) values on the   real cell only for elements with trivial MappingKind. For all other   elements (for example for H(curl), or H(div) conforming elements)   vector values have to be transformed to the reference cell first.    
*  [2.x.329]  Given what the function is supposed to do, the function clearly   can only work for elements that actually implement (generalized) support   points. Elements that do not have generalized support points
* 
*  -  e.g.,   elements whose nodal functionals evaluate integrals or moments of   functions (such as FE_Q_Hierarchical)
* 
*  -  can in general not make   sense of the operation that is required for this function. They   consequently may not implement it.  
* [0.x.94]*
   Determine an estimate for the memory consumption (in bytes) of this   object.     This function is made virtual, since finite element objects are usually   accessed through pointers to their base class, rather than the class   itself.  
* [0.x.95]*
   Exception    
*  [2.x.330]   
* [0.x.96]*
   Exception    
*  [2.x.331]   
* [0.x.97]*
   Exception    
*  [2.x.332]   
* [0.x.98]*
   Attempt to access support points of a finite element that is not   Lagrangian.    
*  [2.x.333]   
* [0.x.99]*
   Attempt to access embedding matrices of a finite element that did not   implement these matrices.    
*  [2.x.334]   
* [0.x.100]*
   Attempt to access restriction matrices of a finite element that did not   implement these matrices.     Exception  
*  [2.x.335]   
* [0.x.101]*
   Exception  
*  [2.x.336]   
* [0.x.102]*
   Exception  
*  [2.x.337]   
* [0.x.103]*
   Reinit the vectors of restriction and prolongation matrices to the right   sizes: For every refinement case, except for    [2.x.338]  and for every child of that refinement   case the space of one restriction and prolongation matrix is allocated,   see the documentation of the restriction and prolongation vectors for   more detail on the actual vector sizes.      [2.x.339]  isotropic_restriction_only only the restriction matrices required   for isotropic refinement are reinited to the right size.    [2.x.340]  isotropic_prolongation_only only the prolongation matrices   required for isotropic refinement are reinited to the right size.  
* [0.x.104]*
   Vector of projection matrices. See get_restriction_matrix() above. The   constructor initializes these matrices to zero dimensions, which can be   changed by derived classes implementing them.     Note, that  [2.x.341]  includes   the restriction matrix of child  [2.x.342]  for the RefinementCase    [2.x.343]    instead of  [2.x.344]  as for    [2.x.345]  there are no restriction matrices   available.  
* [0.x.105]*
   Vector of embedding matrices. See <tt>get_prolongation_matrix()</tt>   above. The constructor initializes these matrices to zero dimensions,   which can be changed by derived classes implementing them.     Note, that  [2.x.346]  includes   the prolongation matrix of child  [2.x.347]  for the   RefinementCase  [2.x.348] . Here, we use    [2.x.349]  as   for  [2.x.350]  there are no prolongation matrices   available.  
* [0.x.106]*
   Specify the constraints which the dofs on the two sides of a cell   interface underlie if the line connects two cells of which one is refined   once.     For further details see the general description of the derived class.     This field is obviously useless in one dimension and has there a zero   size.  
* [0.x.107]*
   List of support points on the unit cell, in case the finite element has   any. The constructor leaves this field empty, derived classes may write   in some contents.     Finite elements that allow some kind of interpolation operation usually   have support points. On the other hand, elements that define their   degrees of freedom by, for example, moments on faces, or as derivatives,   don't have support points. In that case, this field remains empty.  
* [0.x.108]*
   Same for the faces. See the description of the   get_unit_face_support_points() function for a discussion of what   contributes a face support point.  
* [0.x.109]*
   Support points used for interpolation functions of non-Lagrangian   elements.  
* [0.x.110]*
   Face support points used for interpolation functions of non-Lagrangian   elements.  
* [0.x.111]*
   For faces with non-standard face_orientation in 3D, the dofs on faces   (quads) have to be permuted in order to be combined with the correct   shape functions. Given a local dof  [2.x.351]  on a quad, return the shift   in the local index, if the face has non-standard face_orientation, i.e.    [2.x.352] . In 2D and 1D there is no need   for permutation so the vector is empty. In 3D it has the size of  [2.x.353] , where 8 is the number of orientations, a face   can be in (all combinations of the three bool flags face_orientation,   face_flip and face_rotation).     The constructor of this class fills this table with zeros, i.e.,   no permutation at all. Derived finite element classes have to   fill this Table with the correct values.  
* [0.x.112]*
   For lines with non-standard line_orientation in 3D, the dofs on lines   have to be permuted in order to be combined with the correct shape   functions. Given a local dof  [2.x.354]  on a line, return the shift in the   local index, if the line has non-standard line_orientation, i.e.    [2.x.355] . In 2D and 1D there is no need   for permutation so the vector is empty. In 3D it has the size of   #dofs_per_line.     The constructor of this class fills this table with zeros, i.e.,   no permutation at all. Derived finite element classes have to   fill this vector with the correct values.  
* [0.x.113]*
   Store what system_to_component_index() will return.  
* [0.x.114]*
   Map between linear dofs and component dofs on face. This is filled with   default values in the constructor, but derived classes will have to   overwrite the information if necessary.     By component, we mean the vector component, not the base element. The   information thus makes only sense if a shape function is non-zero in only   one component.  
* [0.x.115]*
   For each shape function, store to which base element and which instance   of this base element (in case its multiplicity is greater than one) it   belongs, and its index within this base element. If the element is not   composed of others, then base and instance are always zero, and the index   is equal to the number of the shape function. If the element is composed   of single instances of other elements (i.e. all with multiplicity one)   all of which are scalar, then base values and dof indices within this   element are equal to the #system_to_component_table. It differs only in   case the element is composed of other elements and at least one of them   is vector-valued itself.     This array has valid values also in the case of vector-valued (i.e. non-   primitive) shape functions, in contrast to the   #system_to_component_table.  
* [0.x.116]*
   Likewise for the indices on faces.  
* [0.x.117]*
   For each base element, store the number of blocks generated by the base   and the first block in a block vector it will generate.  
* [0.x.118]*
   The base element establishing a component.     For each component number <tt>c</tt>, the entries have the following   meaning:  [2.x.356]  <dt><tt>table[c].first.first</tt></dt>  [2.x.357] Number of the   base element for <tt>c</tt>. This is the index you can pass to   base_element(). [2.x.358]  <dt><tt>table[c].first.second</tt></dt>    [2.x.359] Component within the base element for <tt>c</tt>. This value is   between 0 and the n_components() of this base element. [2.x.360]    <dt><tt>table[c].second</tt></dt>  [2.x.361] Index of the multiple of the base   element that contains <tt>c</tt>. This value is between 0 and the   element_multiplicity() of this base element. [2.x.362]   [2.x.363]      This variable is set to the correct size by the constructor of this   class, but needs to be initialized by derived classes, unless its size is   one and the only entry is a zero, which is the case for scalar elements.   In that case, the initialization by the base class is sufficient.    
*  [2.x.364]  This table is filled by  [2.x.365]   
* [0.x.119]*
   A flag determining whether restriction matrices are to be concatenated or   summed up. See the discussion about restriction matrices in the general   class documentation for more information.  
* [0.x.120]*
   For each shape function, give a vector of bools (with size equal to the   number of vector components which this finite element has) indicating in   which component each of these shape functions is non-zero.     For primitive elements, there is only one non-zero component.  
* [0.x.121]*
   This array holds how many values in the respective entry of the   #nonzero_components element are non-zero. The array is thus a short-cut   to allow faster access to this information than if we had to count the   non-zero entries upon each request for this information. The field is   initialized in the constructor of this class.  
* [0.x.122]*
   Store whether all shape functions are primitive. Since finding this out   is a very common operation, we cache the result, i.e. compute the value   in the constructor for simpler access.  
* [0.x.123]*
   Return the size of interface constraint matrices. Since this is needed in   every derived finite element class when initializing their size, it is   placed into this function, to avoid having to recompute the dimension-   dependent size of these matrices each time.     Note that some elements do not implement the interface constraints for   certain polynomial degrees. In this case, this function still returns the   size these matrices should have when implemented, but the actual matrices   are empty.  
* [0.x.124]*
   Given the pattern of nonzero components for each shape function, compute   for each entry how many components are non-zero for each shape function.   This function is used in the constructor of this class.  
* [0.x.125]*
   Given a set of update flags, compute which other quantities [1.x.49]   need to be computed in order to satisfy the request by the given flags.   Then return the combination of the original set of flags and those just   computed.     As an example, if  [2.x.366]  contains update_gradients a finite   element class will typically require the computation of the inverse of   the Jacobian matrix in order to rotate the gradient of shape functions on   the reference cell to the real cell. It would then return not just   update_gradients, but also update_covariant_transformation, the flag that   makes the mapping class produce the inverse of the Jacobian matrix.     An extensive discussion of the interaction between this function and   FEValues can be found in the    [2.x.367]    documentation module.      [2.x.368]  UpdateFlags  
* [0.x.126]*
   Create an internal data object and return a pointer to it of which the   caller of this function then assumes ownership. This object will then be   passed to the  [2.x.369]  every time the finite   element shape functions and their derivatives are evaluated on a concrete   cell. The object created here is therefore used by derived classes as a   place for scratch objects that are used in evaluating shape functions, as   well as to store information that can be pre-computed once and re-used on   every cell (e.g., for evaluating the values and gradients of shape   functions on the reference cell, for later re-use when transforming these   values to a concrete cell).     This function is the first one called in the process of initializing a   FEValues object for a given mapping and finite element object. The   returned object will later be passed to  [2.x.370]    for a concrete cell, which will itself place its output into an object of   type  [2.x.371]  Since   there may be data that can already be computed in its [1.x.50] form on   the reference cell, this function also receives a reference to the    [2.x.372]  object as its   last argument. This output argument is guaranteed to always be the same one   when used with the InternalDataBase object returned by this function. In   other words, the subdivision of scratch data and final data in the returned   object and the  [2.x.373]  object is as follows: If data can be pre-   computed on the reference cell in the exact form in which it will later   be needed on a concrete cell, then this function should already emplace   it in the  [2.x.374]  object. An example are the values of shape   functions at quadrature points for the usual Lagrange elements which on a   concrete cell are identical to the ones on the reference cell. On the   other hand, if some data can be pre-computed to make computations on a   concrete cell [1.x.51], then it should be put into the returned   object for later re-use in a derive class's implementation of    [2.x.375]  An example are the gradients of shape   functions on the reference cell for Lagrange elements: to compute the   gradients of the shape functions on a concrete cell, one has to multiply   the gradients on the reference cell by the inverse of the Jacobian of the   mapping; consequently, we cannot already compute the gradients on a   concrete cell at the time the current function is called, but we can at   least pre-compute the gradients on the reference cell, and store it in   the object returned.     An extensive discussion of the interaction between this function and   FEValues can be found in the    [2.x.376]    documentation module. See also the documentation of the InternalDataBase   class.      [2.x.377]  update_flags A set of UpdateFlags values that describe what   kind of information the FEValues object requests the finite element to   compute. This set of flags may also include information that the finite   element can not compute, e.g., flags that pertain to data produced by the   mapping. An implementation of this function needs to set up all data   fields in the returned object that are necessary to produce the finite-   element related data specified by these flags, and may already pre-   compute part of this information as discussed above. Elements may want to   store these update flags (or a subset of these flags) in    [2.x.378]  so they know at the time when    [2.x.379]  is called what they are supposed to   compute    [2.x.380]  mapping A reference to the mapping used for computing values   and derivatives of shape functions.    [2.x.381]  quadrature A reference to the object that describes where the   shape functions should be evaluated.    [2.x.382]  output_data A reference to the object that FEValues will use   in conjunction with the object returned here and where an implementation   of  [2.x.383]  will place the requested information.   This allows the current function to already pre-compute pieces of   information that can be computed on the reference cell, as discussed   above. FEValues guarantees that this output object and the object   returned by the current function will always be used together.    [2.x.384]  A pointer to an object of a type derived from InternalDataBase   and that derived classes can use to store scratch data that can be pre-   computed, or for scratch arrays that then only need to be allocated once.   The calling site assumes ownership of this object and will delete it when   it is no longer necessary.  
* [0.x.127]*
   Like get_data(), but return an object that will later be used for   evaluating shape function information at quadrature points on faces of   cells. The object will then be used in calls to implementations of    [2.x.385]  See the documentation of get_data()   for more information.     The default implementation of this function converts the face quadrature   into a cell quadrature with appropriate quadrature point locations, and   with that calls the get_data() function above that has to be implemented   in derived classes.      [2.x.386]  update_flags A set of UpdateFlags values that describe what   kind of information the FEValues object requests the finite element to   compute. This set of flags may also include information that the finite   element can not compute, e.g., flags that pertain to data produced by the   mapping. An implementation of this function needs to set up all data   fields in the returned object that are necessary to produce the finite-   element related data specified by these flags, and may already pre-   compute part of this information as discussed above. Elements may want to   store these update flags (or a subset of these flags) in    [2.x.387]  so they know at the time when    [2.x.388]  is called what they are supposed to   compute    [2.x.389]  mapping A reference to the mapping used for computing values   and derivatives of shape functions.    [2.x.390]  quadrature A reference to the object that describes where the   shape functions should be evaluated.    [2.x.391]  output_data A reference to the object that FEValues will use   in conjunction with the object returned here and where an implementation   of  [2.x.392]  will place the requested   information. This allows the current function to already pre-compute   pieces of information that can be computed on the reference cell, as   discussed above. FEValues guarantees that this output object and the   object returned by the current function will always be used together.    [2.x.393]  A pointer to an object of a type derived from InternalDataBase   and that derived classes can use to store scratch data that can be pre-   computed, or for scratch arrays that then only need to be allocated once.   The calling site assumes ownership of this object and will delete it when   it is no longer necessary.  
* [0.x.128]*
    [2.x.394]  Use the version taking a  [2.x.395]  argument.  
* [0.x.129]*
   Like get_data(), but return an object that will later be used for   evaluating shape function information at quadrature points on children of   faces of cells. The object will then be used in calls to implementations   of  [2.x.396]  See the documentation of   get_data() for more information.     The default implementation of this function converts the face quadrature   into a cell quadrature with appropriate quadrature point locations, and   with that calls the get_data() function above that has to be implemented   in derived classes.      [2.x.397]  update_flags A set of UpdateFlags values that describe what   kind of information the FEValues object requests the finite element to   compute. This set of flags may also include information that the finite   element can not compute, e.g., flags that pertain to data produced by the   mapping. An implementation of this function needs to set up all data   fields in the returned object that are necessary to produce the finite-   element related data specified by these flags, and may already pre-   compute part of this information as discussed above. Elements may want to   store these update flags (or a subset of these flags) in    [2.x.398]  so they know at the time when    [2.x.399]  is called what they are supposed   to compute    [2.x.400]  mapping A reference to the mapping used for computing values   and derivatives of shape functions.    [2.x.401]  quadrature A reference to the object that describes where the   shape functions should be evaluated.    [2.x.402]  output_data A reference to the object that FEValues will use   in conjunction with the object returned here and where an implementation   of  [2.x.403]  will place the requested   information. This allows the current function to already pre-compute   pieces of information that can be computed on the reference cell, as   discussed above. FEValues guarantees that this output object and the   object returned by the current function will always be used together.    [2.x.404]  A pointer to an object of a type derived from InternalDataBase   and that derived classes can use to store scratch data that can be pre-   computed, or for scratch arrays that then only need to be allocated once.   The calling site assumes ownership of this object and will delete it when   it is no longer necessary.  
* [0.x.130]*
   Compute information about the shape functions on the cell denoted by the   first argument. Derived classes will have to implement this function   based on the kind of element they represent. It is called by    [2.x.405]      Conceptually, this function evaluates shape functions and their   derivatives at the quadrature points represented by the mapped locations   of those described by the quadrature argument to this function. In many   cases, computing derivatives of shape functions (and in some cases also   computing values of shape functions) requires making use of the mapping   from the reference to the real cell; this information can either be taken   from the  [2.x.406]  object that has been filled for the current cell   before this function is called, or by calling the member functions of a   Mapping object with the  [2.x.407]  object that also corresponds   to the current cell.     The information computed by this function is used to fill the various   member variables of the output argument of this function. Which of the   member variables of that structure should be filled is determined by the   update flags stored in the  [2.x.408]    field of the object passed to this function. These flags are typically   set by  [2.x.409]   [2.x.410]  and    [2.x.411]  (or, more specifically, implementations   of these functions in derived classes).     An extensive discussion of the interaction between this function and   FEValues can be found in the    [2.x.412]    documentation module.      [2.x.413]  cell The cell of the triangulation for which this function is   to compute a mapping from the reference cell to.    [2.x.414]  cell_similarity Whether or not the cell given as first   argument is simply a translation, rotation, etc of the cell for which   this function was called the most recent time. This information is   computed simply by matching the vertices (as stored by the Triangulation)   between the previous and the current cell. The value passed here may be   modified by implementations of this function and should then be returned   (see the discussion of the return value of this function).    [2.x.415]  quadrature A reference to the quadrature formula in use for   the current evaluation. This quadrature object is the same as the one   used when creating the  [2.x.416]  object. The current object is   then responsible for evaluating shape functions at the mapped locations   of the quadrature points represented by this object.    [2.x.417]  mapping A reference to the mapping object used to map from the   reference cell to the current cell. This object was used to compute the   information in the  [2.x.418]  object before the current function was   called. It is also the mapping object that created the  [2.x.419]    mapping_internal object via  [2.x.420]  You will need the   reference to this mapping object most often to call  [2.x.421]    to transform gradients and higher derivatives from the reference to the   current cell.    [2.x.422]  mapping_internal An object specific to the mapping object.   What the mapping chooses to store in there is of no relevance to the   current function, but you may have to pass a reference to this object to   certain functions of the Mapping class (e.g.,  [2.x.423]  if   you need to call them from the current function.    [2.x.424]  mapping_data The output object into which the    [2.x.425]  function wrote the mapping information   corresponding to the current cell. This includes, for example, Jacobians   of the mapping that may be of relevance to the current function, as well   as other information that  [2.x.426]  requested from the mapping.    [2.x.427]  fe_internal A reference to an object previously created by   get_data() and that may be used to store information the mapping can   compute once on the reference cell. See the documentation of the    [2.x.428]  class for an extensive description of the   purpose of these objects.    [2.x.429]  output_data A reference to an object whose member variables   should be computed. Not all of the members of this argument need to be   filled; which ones need to be filled is determined by the update flags   stored inside the  [2.x.430]  object.    
*  [2.x.431]  FEValues ensures that this function is always called with the same   pair of  [2.x.432]  and  [2.x.433]  objects. In other words, if an   implementation of this function knows that it has written a piece of data   into the output argument in a previous call, then there is no need to   copy it there again in a later call if the implementation knows that this   is the same value.  
* [0.x.131]*
   This function is the equivalent to  [2.x.434]  but   for faces of cells. See there for an extensive discussion of its purpose.   It is called by  [2.x.435]       [2.x.436]  cell The cell of the triangulation for which this function is   to compute a mapping from the reference cell to.    [2.x.437]  face_no The number of the face we are currently considering,   indexed among the faces of the cell specified by the previous argument.    [2.x.438]  quadrature A reference to the quadrature formula in use for   the current evaluation. This quadrature object is the same as the one   used when creating the  [2.x.439]  object. The current object is   then responsible for evaluating shape functions at the mapped locations   of the quadrature points represented by this object.    [2.x.440]  mapping A reference to the mapping object used to map from the   reference cell to the current cell. This object was used to compute the   information in the  [2.x.441]  object before the current function was   called. It is also the mapping object that created the  [2.x.442]    mapping_internal object via  [2.x.443]  You will need the   reference to this mapping object most often to call  [2.x.444]    to transform gradients and higher derivatives from the reference to the   current cell.    [2.x.445]  mapping_internal An object specific to the mapping object.   What the mapping chooses to store in there is of no relevance to the   current function, but you may have to pass a reference to this object to   certain functions of the Mapping class (e.g.,  [2.x.446]  if   you need to call them from the current function.    [2.x.447]  mapping_data The output object into which the    [2.x.448]  function wrote the mapping information   corresponding to the current cell. This includes, for example, Jacobians   of the mapping that may be of relevance to the current function, as well   as other information that  [2.x.449]  requested from the mapping.    [2.x.450]  fe_internal A reference to an object previously created by   get_data() and that may be used to store information the mapping can   compute once on the reference cell. See the documentation of the    [2.x.451]  class for an extensive description of the   purpose of these objects.    [2.x.452]  output_data A reference to an object whose member variables   should be computed. Not all of the members of this argument need to be   filled; which ones need to be filled is determined by the update flags   stored inside the  [2.x.453]  object.  
* [0.x.132]*
    [2.x.454]  Use the version taking a  [2.x.455]  argument.  
* [0.x.133]*
   This function is the equivalent to  [2.x.456]  but   for the children of faces of cells. See there for an extensive discussion   of its purpose. It is called by  [2.x.457]       [2.x.458]  cell The cell of the triangulation for which this function is   to compute a mapping from the reference cell to.    [2.x.459]  face_no The number of the face we are currently considering,   indexed among the faces of the cell specified by the previous argument.    [2.x.460]  sub_no The number of the subface, i.e., the number of the   child of a face, that we are currently considering, indexed among the   children of the face specified by the previous argument.    [2.x.461]  quadrature A reference to the quadrature formula in use for   the current evaluation. This quadrature object is the same as the one   used when creating the  [2.x.462]  object. The current object is   then responsible for evaluating shape functions at the mapped locations   of the quadrature points represented by this object.    [2.x.463]  mapping A reference to the mapping object used to map from the   reference cell to the current cell. This object was used to compute the   information in the  [2.x.464]  object before the current function was   called. It is also the mapping object that created the  [2.x.465]    mapping_internal object via  [2.x.466]  You will need the   reference to this mapping object most often to call  [2.x.467]    to transform gradients and higher derivatives from the reference to the   current cell.    [2.x.468]  mapping_internal An object specific to the mapping object.   What the mapping chooses to store in there is of no relevance to the   current function, but you may have to pass a reference to this object to   certain functions of the Mapping class (e.g.,  [2.x.469]  if   you need to call them from the current function.    [2.x.470]  mapping_data The output object into which the    [2.x.471]  function wrote the mapping information   corresponding to the current cell. This includes, for example, Jacobians   of the mapping that may be of relevance to the current function, as well   as other information that  [2.x.472]  requested from the mapping.    [2.x.473]  fe_internal A reference to an object previously created by   get_data() and that may be used to store information the mapping can   compute once on the reference cell. See the documentation of the    [2.x.474]  class for an extensive description of the   purpose of these objects.    [2.x.475]  output_data A reference to an object whose member variables   should be computed. Not all of the members of this argument need to be   filled; which ones need to be filled is determined by the update flags   stored inside the  [2.x.476]  object.  
* [0.x.134]