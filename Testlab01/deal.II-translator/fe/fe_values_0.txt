[0.x.0]*
   A class whose specialization is used to define what type the curl of a   vector valued function corresponds to.  
* [0.x.1]*
   A class whose specialization is used to define what type the curl of a   vector valued function corresponds to.     In 1d, the curl is a scalar.  
* [0.x.2]*
   A class whose specialization is used to define what type the curl of a   vector valued function corresponds to.     In 2d, the curl is a scalar.  
* [0.x.3]*
   A class whose specialization is used to define what type the curl of a   vector valued function corresponds to.     In 3d, the curl is a vector.  
* [0.x.4]*
 A namespace for "views" on a FEValues, FEFaceValues, or FESubfaceValues object. A view represents only a certain part of the whole: whereas the FEValues object represents [1.x.0] values, gradients, or second derivatives of all components of a vector-valued element, views restrict the attention to only a single component or a subset of components. You typically get objects of classes defined in this namespace by applying FEValuesExtractors objects to a FEValues, FEFaceValues or FESubfaceValues objects using the square bracket operator.
*  There are classes that present views for single scalar components, vector components consisting of  [2.x.0]  elements, and symmetric second order tensor components consisting of  [2.x.1]  elements
*  See the description of the  [2.x.2]  module for examples how to use the features of this namespace.
* 

* 
*  [2.x.3] 

* 
* [0.x.5]*
   A class representing a view to a single scalar component of a possibly   vector-valued finite element. Views are discussed in the    [2.x.4]    module.     You get an object of this type if you apply a  [2.x.5]    to an FEValues, FEFaceValues or FESubfaceValues object.    
*  [2.x.6]   
* [0.x.6]*
     An alias for the data type of values of the view this class     represents. Since we deal with a single components, the value type is a     scalar double.    
* [0.x.7]*
     An alias for the type of gradients of the view this class represents.     Here, for a scalar component of the finite element, the gradient is a      [2.x.7] .    
* [0.x.8]*
     An alias for the type of second derivatives of the view this class     represents. Here, for a scalar component of the finite element, the     Hessian is a  [2.x.8] .    
* [0.x.9]*
     An alias for the type of third derivatives of the view this class     represents. Here, for a scalar component of the finite element, the     Third derivative is a  [2.x.9] .    
* [0.x.10]*
     An alias for the data type of the product of a  [2.x.10]  and the     values of the view this class provides. This is the data type of     scalar components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.11]     
* [0.x.11]*
     An alias for the data type of the product of a  [2.x.12]  and the     gradients of the view this class provides. This is the data type of     scalar components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.13]     
* [0.x.12]*
     An alias for the data type of the product of a  [2.x.14]  and the     laplacians of the view this class provides. This is the data type of     scalar components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.15]     
* [0.x.13]*
     An alias for the data type of the product of a  [2.x.16]  and the     hessians of the view this class provides. This is the data type of     scalar components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.17]     
* [0.x.14]*
     An alias for the data type of the product of a  [2.x.18]  and the     third derivatives of the view this class provides. This is the data type     of scalar components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.19]     
* [0.x.15]*
     A struct that provides the output type for the product of the value     and derivatives of basis functions of the Scalar view and any  [2.x.20]  type.          [2.x.21]  Use the types defined in the surrounding class instead.    
* [0.x.16]*
       An alias for the data type of the product of a  [2.x.22]  and the       values of the view the Scalar class.      
* [0.x.17]*
       An alias for the data type of the product of a  [2.x.23]  and the       gradients of the view the Scalar class.      
* [0.x.18]*
       An alias for the data type of the product of a  [2.x.24]  and the       laplacians of the view the Scalar class.      
* [0.x.19]*
       An alias for the data type of the product of a  [2.x.25]  and the       hessians of the view the Scalar class.      
* [0.x.20]*
       An alias for the data type of the product of a  [2.x.26]  and the       third derivatives of the view the Scalar class.      
* [0.x.21]*
     A structure where for each shape function we pre-compute a bunch of     data that will make later accesses much cheaper.    
* [0.x.22]*
       For each shape function, store whether the selected vector component       may be nonzero. For primitive shape functions we know for sure       whether a certain scalar component of a given shape function is       nonzero, whereas for non-primitive shape functions this may not be       entirely clear (e.g. for RT elements it depends on the shape of a       cell).      
* [0.x.23]*
       For each shape function, store the row index within the shape_values,       shape_gradients, and shape_hessians tables (the column index is the       quadrature point index). If the shape function is primitive, then we       can get this information from the shape_function_to_row_table of the       FEValues object; otherwise, we have to work a bit harder to compute       this information.      
* [0.x.24]*
     Default constructor. Creates an invalid object.    
* [0.x.25]*
     Constructor for an object that represents a single scalar component of     a FEValuesBase object (or of one of the classes derived from     FEValuesBase).    
* [0.x.26]*
     Copy constructor. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.27]*
     Move constructor.    
* [0.x.28]*
     Destructor.    
* [0.x.29]*
     Copy operator. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.30]*
     Move assignment operator.    
* [0.x.31]*
     Return the value of the vector component selected by this view, for the     shape function and quadrature point selected by the arguments.          [2.x.27]  shape_function Number of the shape function to be evaluated.     Note that this number runs from zero to dofs_per_cell, even in the case     of an FEFaceValues or FESubfaceValues object.          [2.x.28]  q_point Number of the quadrature point at which function is to     be evaluated.          [2.x.29]     
* [0.x.32]*
     Return the gradient (a tensor of rank 1) of the vector component     selected by this view, for the shape function and quadrature point     selected by the arguments.        
*  [2.x.30]  The meaning of the arguments is as documented for the value()     function.          [2.x.31]     
* [0.x.33]*
     Return the Hessian (the tensor of rank 2 of all second derivatives) of     the vector component selected by this view, for the shape function and     quadrature point selected by the arguments.        
*  [2.x.32]  The meaning of the arguments is as documented for the value()     function.          [2.x.33]     
* [0.x.34]*
     Return the tensor of rank 3 of all third derivatives of the vector     component selected by this view, for the shape function and quadrature     point selected by the arguments.        
*  [2.x.34]  The meaning of the arguments is as documented for the value()     function.          [2.x.35]     
* [0.x.35]*
     Return the values of the selected scalar component of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.36]  function but it only works on the     selected scalar component.         The data type stored by the output vector must be what you get when you     multiply the values of shape functions (i.e.,  [2.x.37]  times the     type used to store the values of the unknowns  [2.x.38]  of your finite     element vector  [2.x.39]  (represented by the  [2.x.40]  argument).          [2.x.41]     
* [0.x.36]*
     Same as above, but using a vector of local degree-of-freedom values. In     other words, instead of extracting the nodal values of the degrees of     freedom located on the current cell from a global vector associated with     a DoFHandler object (as the function above does), this function instead     takes these local nodal values through its first argument. A typical     way to obtain such a vector is by calling code such as    
* [1.x.1]
*      (See  [2.x.42]  for more information on this     function.) The point of the current function is then that one could     modify these local values first, for example by applying a limiter     or by ensuring that all nodal values are positive, before evaluating     the finite element field that corresponds to these local values on the     current cell. Another application is where one wants to postprocess     the solution on a cell into a different finite element space on every     cell, without actually creating a corresponding DoFHandler
* 
*  -  in that     case, all one would compute is a local representation of that     postprocessed function, characterized by its nodal values; this function     then allows the evaluation of that representation at quadrature points.          [2.x.43]  dof_values A vector of local nodal values. This vector must       have a length equal to number of DoFs on the current cell, and must       be ordered in the same order as degrees of freedom are numbered on       the reference cell.          [2.x.44]  values A vector of values of the given finite element field,       at the quadrature points on the current object.          [2.x.45]  InputVector The  [2.x.46]  type must allow creation       of an ArrayView object from it; this is satisfied by the        [2.x.47]  class, among others.    
* [0.x.37]*
     Return the gradients of the selected scalar component of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.48]  function but it only works on the     selected scalar component.         The data type stored by the output vector must be what you get when you     multiply the gradients of shape functions (i.e.,  [2.x.49]      times the type used to store the values of the unknowns  [2.x.50]  of your     finite element vector  [2.x.51]  (represented by the  [2.x.52]  argument).          [2.x.53]     
* [0.x.38]*
     This function relates to get_function_gradients() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.39]*
     Return the Hessians of the selected scalar component of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.54]  function but it only works on the     selected scalar component.         The data type stored by the output vector must be what you get when you     multiply the Hessians of shape functions (i.e.,  [2.x.55]  times     the type used to store the values of the unknowns  [2.x.56]  of your finite     element vector  [2.x.57]  (represented by the  [2.x.58]  argument).          [2.x.59]     
* [0.x.40]*
     This function relates to get_function_hessians() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.41]*
     Return the Laplacians of the selected scalar component of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called. The     Laplacians are the trace of the Hessians.         This function is the equivalent of the      [2.x.60]  function but it only works on the     selected scalar component.         The data type stored by the output vector must be what you get when you     multiply the Laplacians of shape functions (i.e.,  [2.x.61]  times     the type used to store the values of the unknowns  [2.x.62]  of your finite     element vector  [2.x.63]  (represented by the  [2.x.64]  argument).          [2.x.65]     
* [0.x.42]*
     This function relates to get_function_laplacians() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.43]*
     Return the third derivatives of the selected scalar component of the     finite element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.66]  function but it only works     on the selected scalar component.         The data type stored by the output vector must be what you get when you     multiply the third derivatives of shape functions (i.e.,  [2.x.67]      third_derivative_type) times the type used to store the values of the     unknowns  [2.x.68]  of your finite element vector  [2.x.69]  (represented by the  [2.x.70]      fe_function argument).          [2.x.71]     
* [0.x.44]*
     This function relates to get_function_third_derivatives() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.45]*
     A pointer to the FEValuesBase object we operate on.    
* [0.x.46]*
     The single scalar component this view represents of the FEValuesBase     object.    
* [0.x.47]*
     Store the data about shape functions.    
* [0.x.48]*
   A class representing a view to a set of  [2.x.72]  components   forming a vector part of a vector-valued finite element. Views are   discussed in the    [2.x.73]    module.     Note that in the current context, a vector is meant in the sense physics   uses it: it has  [2.x.74]  components that behave in specific   ways under coordinate system transformations. Examples include velocity   or displacement fields. This is opposed to how mathematics uses the word   "vector" (and how we use this word in other contexts in the library, for   example in the Vector class), where it really stands for a collection of   numbers. An example of this latter use of the word could be the set of   concentrations of chemical species in a flame; however, these are really   just a collection of scalar variables, since they do not change if the   coordinate system is rotated, unlike the components of a velocity vector,   and consequently, this class should not be used for this context.     This class allows to query the value, gradient and divergence of   (components of) shape functions and solutions representing vectors. The   gradient of a vector  [2.x.75]  is defined as  [2.x.76] .     You get an object of this type if you apply a  [2.x.77]    to an FEValues, FEFaceValues or FESubfaceValues object.    
*  [2.x.78]   
* [0.x.49]*
     An alias for the data type of values of the view this class     represents. Since we deal with a set of  [2.x.79]  components,     the value type is a Tensor<1,spacedim>.    
* [0.x.50]*
     An alias for the type of gradients of the view this class represents.     Here, for a set of  [2.x.80]  components of the finite element,     the gradient is a  [2.x.81] .         See the general documentation of this class for how exactly the     gradient of a vector is defined.    
* [0.x.51]*
     An alias for the type of symmetrized gradients of the view this class     represents. Here, for a set of  [2.x.82]  components of the     finite element, the symmetrized gradient is a      [2.x.83] .         The symmetric gradient of a vector field  [2.x.84]  is defined as      [2.x.85] .    
* [0.x.52]*
     An alias for the type of the divergence of the view this class     represents. Here, for a set of  [2.x.86]  components of the     finite element, the divergence of course is a scalar.    
* [0.x.53]*
     An alias for the type of the curl of the view this class represents.     Here, for a set of  [2.x.87]  components of the finite     element, the curl is a  [2.x.88] . For      [2.x.89] .    
* [0.x.54]*
     An alias for the type of second derivatives of the view this class     represents. Here, for a set of  [2.x.90]  components of the     finite element, the Hessian is a  [2.x.91] .    
* [0.x.55]*
     An alias for the type of third derivatives of the view this class     represents. Here, for a set of  [2.x.92]  components of the     finite element, the third derivative is a  [2.x.93] .    
* [0.x.56]*
     An alias for the data type of the product of a  [2.x.94]  and the     values of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.95]     
* [0.x.57]*
     An alias for the data type of the product of a  [2.x.96]  and the     gradients of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.97]     
* [0.x.58]*
     An alias for the data type of the product of a  [2.x.98]  and the     symmetric gradients of the view this class provides. This is the data     type of vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.99]     
* [0.x.59]*
     An alias for the data type of the product of a  [2.x.100]  and the     divergences of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.101]     
* [0.x.60]*
     An alias for the data type of the product of a  [2.x.102]  and the     laplacians of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.103]     
* [0.x.61]*
     An alias for the data type of the product of a  [2.x.104]  and the     curls of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.105]     
* [0.x.62]*
     An alias for the data type of the product of a  [2.x.106]  and the     hessians of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.107]     
* [0.x.63]*
     An alias for the data type of the product of a  [2.x.108]  and the     third derivatives of the view this class provides. This is the data type     of vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.109]     
* [0.x.64]*
     A struct that provides the output type for the product of the value     and derivatives of basis functions of the Vector view and any  [2.x.110]  type.          [2.x.111]  Use the types defined in the surrounding class instead.    
* [0.x.65]*
       An alias for the data type of the product of a  [2.x.112]  and the       values of the view the Vector class.      
* [0.x.66]*
       An alias for the data type of the product of a  [2.x.113]  and the       gradients of the view the Vector class.      
* [0.x.67]*
       An alias for the data type of the product of a  [2.x.114]  and the       symmetric gradients of the view the Vector class.      
* [0.x.68]*
       An alias for the data type of the product of a  [2.x.115]  and the       divergences of the view the Vector class.      
* [0.x.69]*
       An alias for the data type of the product of a  [2.x.116]  and the       laplacians of the view the Vector class.      
* [0.x.70]*
       An alias for the data type of the product of a  [2.x.117]  and the       curls of the view the Vector class.      
* [0.x.71]*
       An alias for the data type of the product of a  [2.x.118]  and the       hessians of the view the Vector class.      
* [0.x.72]*
       An alias for the data type of the product of a  [2.x.119]  and the       third derivatives of the view the Vector class.      
* [0.x.73]*
     A structure where for each shape function we pre-compute a bunch of     data that will make later accesses much cheaper.    
* [0.x.74]*
       For each pair (shape function,component within vector), store whether       the selected vector component may be nonzero. For primitive shape       functions we know for sure whether a certain scalar component of a       given shape function is nonzero, whereas for non-primitive shape       functions this may not be entirely clear (e.g. for RT elements it       depends on the shape of a cell).      
* [0.x.75]*
       For each pair (shape function, component within vector), store the       row index within the shape_values, shape_gradients, and       shape_hessians tables (the column index is the quadrature point       index). If the shape function is primitive, then we can get this       information from the shape_function_to_row_table of the FEValues       object; otherwise, we have to work a bit harder to compute this       information.      
* [0.x.76]*
       For each shape function say the following: if only a single entry in       is_nonzero_shape_function_component for this shape function is       nonzero, then store the corresponding value of row_index and       single_nonzero_component_index represents the index between 0 and dim       for which it is attained. If multiple components are nonzero, then       store
* 
*  - . If no components are nonzero then store
* 
*  - .      
* [0.x.77]*
     Default constructor. Creates an invalid object.    
* [0.x.78]*
     Constructor for an object that represents dim components of a     FEValuesBase object (or of one of the classes derived from     FEValuesBase), representing a vector-valued variable.         The second argument denotes the index of the first component of the     selected vector.    
* [0.x.79]*
     Copy constructor. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.80]*
     Move constuctor.    
* [0.x.81]*
     Destructor.    
* [0.x.82]*
     Copy operator. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.83]*
     Move assignment operator.    
* [0.x.84]*
     Return the value of the vector components selected by this view, for     the shape function and quadrature point selected by the arguments.     Here, since the view represents a vector-valued part of the FEValues     object with  [2.x.120]  components, the return type is a tensor of     rank 1 with  [2.x.121]  components.          [2.x.122]  shape_function Number of the shape function to be evaluated.     Note that this number runs from zero to dofs_per_cell, even in the case     of an FEFaceValues or FESubfaceValues object.          [2.x.123]  q_point Number of the quadrature point at which function is to     be evaluated.          [2.x.124]     
* [0.x.85]*
     Return the gradient (a tensor of rank 2) of the vector component     selected by this view, for the shape function and quadrature point     selected by the arguments.         See the general documentation of this class for how exactly the     gradient of a vector is defined.        
*  [2.x.125]  The meaning of the arguments is as documented for the value()     function.          [2.x.126]     
* [0.x.86]*
     Return the symmetric gradient (a symmetric tensor of rank 2) of the     vector component selected by this view, for the shape function and     quadrature point selected by the arguments.         The symmetric gradient is defined as  [2.x.127] , where  [2.x.128]  represents the      [2.x.129]  components selected from the FEValuesBase object, and      [2.x.130]  is the location of the  [2.x.131] -th quadrature point.        
*  [2.x.132]  The meaning of the arguments is as documented for the value()     function.          [2.x.133]     
* [0.x.87]*
     Return the scalar divergence of the vector components selected by this     view, for the shape function and quadrature point selected by the     arguments.        
*  [2.x.134]  The meaning of the arguments is as documented for the value()     function.          [2.x.135]     
* [0.x.88]*
     Return the vector curl of the vector components selected by this view,     for the shape function and quadrature point selected by the arguments.     For 1d this function does not make any sense. Thus it is not     implemented for  [2.x.136] .  In 2d the curl is defined as     [1.x.2]
*      whereas in 3d it is given by     [1.x.3]
*         
*  [2.x.137]  The meaning of the arguments is as documented for the value()     function.          [2.x.138]     
* [0.x.89]*
     Return the Hessian (the tensor of rank 2 of all second derivatives) of     the vector components selected by this view, for the shape function and     quadrature point selected by the arguments.        
*  [2.x.139]  The meaning of the arguments is as documented for the value()     function.          [2.x.140]     
* [0.x.90]*
     Return the tensor of rank 3 of all third derivatives of the vector     components selected by this view, for the shape function and quadrature     point selected by the arguments.        
*  [2.x.141]  The meaning of the arguments is as documented for the value()     function.          [2.x.142]     
* [0.x.91]*
     Return the values of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.143]  function but it only works on the     selected vector components.         The data type stored by the output vector must be what you get when you     multiply the values of shape functions (i.e.,  [2.x.144]  times the     type used to store the values of the unknowns  [2.x.145]  of your finite     element vector  [2.x.146]  (represented by the  [2.x.147]  argument).          [2.x.148]     
* [0.x.92]*
     Same as above, but using a vector of local degree-of-freedom values. In     other words, instead of extracting the nodal values of the degrees of     freedom located on the current cell from a global vector associated with     a DoFHandler object (as the function above does), this function instead     takes these local nodal values through its first argument. A typical     way to obtain such a vector is by calling code such as    
* [1.x.4]
*      (See  [2.x.149]  for more information on this     function.) The point of the current function is then that one could     modify these local values first, for example by applying a limiter     or by ensuring that all nodal values are positive, before evaluating     the finite element field that corresponds to these local values on the     current cell. Another application is where one wants to postprocess     the solution on a cell into a different finite element space on every     cell, without actually creating a corresponding DoFHandler
* 
*  -  in that     case, all one would compute is a local representation of that     postprocessed function, characterized by its nodal values; this function     then allows the evaluation of that representation at quadrature points.          [2.x.150]  dof_values A vector of local nodal values. This vector must       have a length equal to number of DoFs on the current cell, and must       be ordered in the same order as degrees of freedom are numbered on       the reference cell.          [2.x.151]  values A vector of values of the given finite element field,       at the quadrature points on the current object.          [2.x.152]  InputVector The  [2.x.153]  type must allow creation       of an ArrayView object from it; this is satisfied by the        [2.x.154]  class, among others.    
* [0.x.93]*
     Return the gradients of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.155]  function but it only works on the     selected vector components.         The data type stored by the output vector must be what you get when you     multiply the gradients of shape functions (i.e.,  [2.x.156]      times the type used to store the values of the unknowns  [2.x.157]  of your     finite element vector  [2.x.158]  (represented by the  [2.x.159]  argument).          [2.x.160]     
* [0.x.94]*
     This function relates to get_function_gradients() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.95]*
     Return the symmetrized gradients of the selected vector components of     the finite element function characterized by <tt>fe_function</tt> at     the quadrature points of the cell, face or subface selected the last     time the <tt>reinit</tt> function of the FEValues object was called.         The symmetric gradient of a vector field  [2.x.161]  is defined as      [2.x.162] .        
*  [2.x.163]  There is no equivalent function such as      [2.x.164]  in the FEValues classes     but the information can be obtained from      [2.x.165]  of course.         The data type stored by the output vector must be what you get when you     multiply the symmetric gradients of shape functions (i.e.,  [2.x.166]      symmetric_gradient_type) times the type used to store the values of the     unknowns  [2.x.167]  of your finite element vector  [2.x.168]  (represented by the  [2.x.169]      fe_function argument).          [2.x.170]     
* [0.x.96]*
     This function relates to get_function_symmetric_gradients() in the same     way as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.97]*
     Return the divergence of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         There is no equivalent function such as      [2.x.171]  in the FEValues classes but the     information can be obtained from  [2.x.172]      of course.         The data type stored by the output vector must be what you get when you     multiply the divergences of shape functions (i.e.,  [2.x.173]      times the type used to store the values of the unknowns  [2.x.174]  of your     finite element vector  [2.x.175]  (represented by the  [2.x.176]  argument).          [2.x.177]     
* [0.x.98]*
     This function relates to get_function_divergences() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.99]*
     Return the curl of the selected vector components of the finite element     function characterized by <tt>fe_function</tt> at the quadrature points     of the cell, face or subface selected the last time the <tt>reinit</tt>     function of the FEValues object was called.         There is no equivalent function such as      [2.x.178]  in the FEValues classes but the     information can be obtained from  [2.x.179]      of course.         The data type stored by the output vector must be what you get when you     multiply the curls of shape functions (i.e.,  [2.x.180]  times the     type used to store the values of the unknowns  [2.x.181]  of your finite     element vector  [2.x.182]  (represented by the  [2.x.183]  argument).          [2.x.184]     
* [0.x.100]*
     This function relates to get_function_curls() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.101]*
     Return the Hessians of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.185]  function but it only works on the     selected vector components.         The data type stored by the output vector must be what you get when you     multiply the Hessians of shape functions (i.e.,  [2.x.186]  times     the type used to store the values of the unknowns  [2.x.187]  of your finite     element vector  [2.x.188]  (represented by the  [2.x.189]  argument).          [2.x.190]     
* [0.x.102]*
     This function relates to get_function_hessians() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.103]*
     Return the Laplacians of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called. The     Laplacians are the trace of the Hessians.         This function is the equivalent of the      [2.x.191]  function but it only works on the     selected vector components.         The data type stored by the output vector must be what you get when you     multiply the Laplacians of shape functions (i.e.,  [2.x.192]      times the type used to store the values of the unknowns  [2.x.193]  of your     finite element vector  [2.x.194]  (represented by the  [2.x.195]  argument).          [2.x.196]     
* [0.x.104]*
     This function relates to get_function_laplacians() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.105]*
     Return the third derivatives of the selected scalar component of the     finite element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.197]  function but it only works     on the selected scalar component.         The data type stored by the output vector must be what you get when you     multiply the third derivatives of shape functions (i.e.,  [2.x.198]      third_derivative_type) times the type used to store the values of the     unknowns  [2.x.199]  of your finite element vector  [2.x.200]  (represented by the  [2.x.201]      fe_function argument).          [2.x.202]     
* [0.x.106]*
     This function relates to get_function_third_derivatives() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.107]*
     A pointer to the FEValuesBase object we operate on.    
* [0.x.108]*
     The first component of the vector this view represents of the     FEValuesBase object.    
* [0.x.109]*
     Store the data about shape functions.    
* [0.x.110]*
   A class representing a view to a set of  [2.x.203]    components forming a symmetric second-order tensor from a vector-valued   finite element. Views are discussed in the    [2.x.204]    module.     This class allows to query the value and divergence of (components of)   shape functions and solutions representing symmetric tensors. The   divergence of a symmetric tensor  [2.x.205]  is defined   as  [2.x.206] , which due to the symmetry of the tensor is also  [2.x.207] .  In other words, it due to   the symmetry of  [2.x.208]  it does not matter whether we apply the nabla   operator by row or by column to get the divergence.     You get an object of this type if you apply a    [2.x.209]  to an FEValues, FEFaceValues or   FESubfaceValues object.    
*  [2.x.210]   
* [0.x.111]*
     An alias for the data type of values of the view this class     represents. Since we deal with a set of  [2.x.211]      components (i.e. the unique components of a symmetric second-order     tensor), the value type is a SymmetricTensor<2,spacedim>.    
* [0.x.112]*
     An alias for the type of the divergence of the view this class     represents. Here, for a set of  [2.x.212]  unique     components of the finite element representing a symmetric second-order     tensor, the divergence of course is a  [2.x.213] .         See the general discussion of this class for a definition of the     divergence.    
* [0.x.113]*
     An alias for the data type of the product of a  [2.x.214]  and the     values of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.215]     
* [0.x.114]*
     An alias for the data type of the product of a  [2.x.216]  and the     divergences of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.217]     
* [0.x.115]*
     A struct that provides the output type for the product of the value     and derivatives of basis functions of the SymmetricTensor view and any  [2.x.218]  type.          [2.x.219]  Use the types defined in the surrounding class instead.    
* [0.x.116]*
       An alias for the data type of the product of a  [2.x.220]  and the       values of the view the SymmetricTensor class.      
* [0.x.117]*
       An alias for the data type of the product of a  [2.x.221]  and the       divergences of the view the SymmetricTensor class.      
* [0.x.118]*
     A structure where for each shape function we pre-compute a bunch of     data that will make later accesses much cheaper.    
* [0.x.119]*
       For each pair (shape function,component within vector), store whether       the selected vector component may be nonzero. For primitive shape       functions we know for sure whether a certain scalar component of a       given shape function is nonzero, whereas for non-primitive shape       functions this may not be entirely clear (e.g. for RT elements it       depends on the shape of a cell).      
* [0.x.120]*
       For each pair (shape function, component within vector), store the       row index within the shape_values, shape_gradients, and       shape_hessians tables (the column index is the quadrature point       index). If the shape function is primitive, then we can get this       information from the shape_function_to_row_table of the FEValues       object; otherwise, we have to work a bit harder to compute this       information.      
* [0.x.121]*
       For each shape function say the following: if only a single entry in       is_nonzero_shape_function_component for this shape function is       nonzero, then store the corresponding value of row_index and       single_nonzero_component_index represents the index between 0 and       (dim^2 + dim)/2 for which it is attained. If multiple components are       nonzero, then store
* 
*  - . If no components are nonzero then store
* 
*  - .      
* [0.x.122]*
       Index of the  [2.x.222]  .      
* [0.x.123]*
     Default constructor. Creates an invalid object.    
* [0.x.124]*
     Constructor for an object that represents <code>(dim*dim +     dim)/2</code> components of a FEValuesBase object (or of one of the     classes derived from FEValuesBase), representing the unique components     comprising a symmetric second- order tensor valued variable.         The second argument denotes the index of the first component of the     selected symmetric second order tensor.    
* [0.x.125]*
     Copy constructor. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.126]*
     Move constructor.    
* [0.x.127]*
     Copy operator. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.128]*
     Move assignment operator.    
* [0.x.129]*
     Return the value of the vector components selected by this view, for     the shape function and quadrature point selected by the arguments.     Here, since the view represents a vector-valued part of the FEValues     object with  [2.x.223]  components (the unique     components of a symmetric second-order tensor), the return type is a     symmetric tensor of rank 2.          [2.x.224]  shape_function Number of the shape function to be evaluated.     Note that this number runs from zero to dofs_per_cell, even in the case     of an FEFaceValues or FESubfaceValues object.          [2.x.225]  q_point Number of the quadrature point at which function is to     be evaluated.          [2.x.226]     
* [0.x.130]*
     Return the vector divergence of the vector components selected by this     view, for the shape function and quadrature point selected by the     arguments.         See the general discussion of this class for a definition of the     divergence.        
*  [2.x.227]  The meaning of the arguments is as documented for the value()     function.          [2.x.228]     
* [0.x.131]*
     Return the values of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.229]  function but it only works on the     selected vector components.         The data type stored by the output vector must be what you get when you     multiply the values of shape functions (i.e.,  [2.x.230]  times the     type used to store the values of the unknowns  [2.x.231]  of your finite     element vector  [2.x.232]  (represented by the  [2.x.233]  argument).          [2.x.234]     
* [0.x.132]*
     Same as above, but using a vector of local degree-of-freedom values. In     other words, instead of extracting the nodal values of the degrees of     freedom located on the current cell from a global vector associated with     a DoFHandler object (as the function above does), this function instead     takes these local nodal values through its first argument. A typical     way to obtain such a vector is by calling code such as    
* [1.x.5]
*      (See  [2.x.235]  for more information on this     function.) The point of the current function is then that one could     modify these local values first, for example by applying a limiter     or by ensuring that all nodal values are positive, before evaluating     the finite element field that corresponds to these local values on the     current cell. Another application is where one wants to postprocess     the solution on a cell into a different finite element space on every     cell, without actually creating a corresponding DoFHandler
* 
*  -  in that     case, all one would compute is a local representation of that     postprocessed function, characterized by its nodal values; this function     then allows the evaluation of that representation at quadrature points.          [2.x.236]  dof_values A vector of local nodal values. This vector must       have a length equal to number of DoFs on the current cell, and must       be ordered in the same order as degrees of freedom are numbered on       the reference cell.          [2.x.237]  values A vector of values of the given finite element field,       at the quadrature points on the current object.          [2.x.238]  InputVector The  [2.x.239]  type must allow creation       of an ArrayView object from it; this is satisfied by the        [2.x.240]  class, among others.    
* [0.x.133]*
     Return the divergence of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         There is no equivalent function such as      [2.x.241]  in the FEValues classes but the     information can be obtained from  [2.x.242]      of course.         See the general discussion of this class for a definition of the     divergence.         The data type stored by the output vector must be what you get when you     multiply the divergences of shape functions (i.e.,  [2.x.243]      times the type used to store the values of the unknowns  [2.x.244]  of your     finite element vector  [2.x.245]  (represented by the  [2.x.246]  argument).          [2.x.247]     
* [0.x.134]*
     This function relates to get_function_divergences() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.135]*
     A pointer to the FEValuesBase object we operate on.    
* [0.x.136]*
     The first component of the vector this view represents of the     FEValuesBase object.    
* [0.x.137]*
     Store the data about shape functions.    
* [0.x.138]*
   A class representing a view to a set of  [2.x.248]  components   forming a second-order tensor from a vector-valued finite element. Views   are discussed in the    [2.x.249]    module.     This class allows to query the value, gradient and divergence of   (components of) shape functions and solutions representing tensors. The   divergence of a tensor  [2.x.250]  is defined as  [2.x.251] , whereas   its gradient is  [2.x.252] .     You get an object of this type if you apply a  [2.x.253]    to an FEValues, FEFaceValues or FESubfaceValues object.    
*  [2.x.254]   
* [0.x.139]*
     Data type for what you get when you apply an extractor of this kind to     a vector-valued finite element.    
* [0.x.140]*
     Data type for taking the divergence of a tensor: a vector.    
* [0.x.141]*
     Data type for taking the gradient of a second order tensor: a third order     tensor.    
* [0.x.142]*
     An alias for the data type of the product of a  [2.x.255]  and the     values of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.256]     
* [0.x.143]*
     An alias for the data type of the product of a  [2.x.257]  and the     divergences of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.258]     
* [0.x.144]*
     An alias for the data type of the product of a  [2.x.259]  and the     gradient of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.260]     
* [0.x.145]*
     A struct that provides the output type for the product of the value     and derivatives of basis functions of the Tensor view and any  [2.x.261]  type.          [2.x.262]  Use the types defined in the surrounding class instead.    
* [0.x.146]*
       An alias for the data type of the product of a  [2.x.263]  and the       values of the view the Tensor class.      
* [0.x.147]*
       An alias for the data type of the product of a  [2.x.264]  and the       divergences of the view the Tensor class.      
* [0.x.148]*
       An alias for the data type of the product of a  [2.x.265]  and the       gradient of the view the Tensor class.      
* [0.x.149]*
     A structure where for each shape function we pre-compute a bunch of     data that will make later accesses much cheaper.    
* [0.x.150]*
       For each pair (shape function,component within vector), store whether       the selected vector component may be nonzero. For primitive shape       functions we know for sure whether a certain scalar component of a       given shape function is nonzero, whereas for non-primitive shape       functions this may not be entirely clear (e.g. for RT elements it       depends on the shape of a cell).      
* [0.x.151]*
       For each pair (shape function, component within vector), store the       row index within the shape_values, shape_gradients, and       shape_hessians tables (the column index is the quadrature point       index). If the shape function is primitive, then we can get this       information from the shape_function_to_row_table of the FEValues       object; otherwise, we have to work a bit harder to compute this       information.      
* [0.x.152]*
       For each shape function say the following: if only a single entry in       is_nonzero_shape_function_component for this shape function is       nonzero, then store the corresponding value of row_index and       single_nonzero_component_index represents the index between 0 and       (dim^2) for which it is attained. If multiple components are nonzero,       then store
* 
*  - . If no components are nonzero then store
* 
*  - .      
* [0.x.153]*
       Index of the  [2.x.266]  .      
* [0.x.154]*
     Default constructor. Creates an invalid object.    
* [0.x.155]*
     Copy constructor. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.156]*
     Move constructor.    
* [0.x.157]*
     Destructor.    
* [0.x.158]*
     Constructor for an object that represents  [2.x.267]      components of a FEValuesBase object (or of one of the classes derived     from FEValuesBase), representing the unique components comprising a     second-order tensor valued variable.         The second argument denotes the index of the first component of the     selected symmetric second order tensor.    
* [0.x.159]*
     Copy operator. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.160]*
     Move assignment operator.    
* [0.x.161]*
     Return the value of the vector components selected by this view, for     the shape function and quadrature point selected by the arguments.     Here, since the view represents a vector-valued part of the FEValues     object with  [2.x.268]  components (the unique components of     a second-order tensor), the return type is a tensor of rank 2.          [2.x.269]  shape_function Number of the shape function to be evaluated.     Note that this number runs from zero to dofs_per_cell, even in the case     of an FEFaceValues or FESubfaceValues object.          [2.x.270]  q_point Number of the quadrature point at which function is to     be evaluated.          [2.x.271]     
* [0.x.162]*
     Return the vector divergence of the vector components selected by this     view, for the shape function and quadrature point selected by the     arguments.         See the general discussion of this class for a definition of the     divergence.        
*  [2.x.272]  The meaning of the arguments is as documented for the value()     function.          [2.x.273]     
* [0.x.163]*
     Return the gradient (3-rd order tensor) of the vector components selected     by this view, for the shape function and quadrature point selected by the     arguments.         See the general discussion of this class for a definition of the     gradient.        
*  [2.x.274]  The meaning of the arguments is as documented for the value()     function.          [2.x.275]     
* [0.x.164]*
     Return the values of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.276]  function but it only works on the     selected vector components.         The data type stored by the output vector must be what you get when you     multiply the values of shape functions (i.e.,  [2.x.277]  times the     type used to store the values of the unknowns  [2.x.278]  of your finite     element vector  [2.x.279]  (represented by the  [2.x.280]  argument).          [2.x.281]     
* [0.x.165]*
     Same as above, but using a vector of local degree-of-freedom values. In     other words, instead of extracting the nodal values of the degrees of     freedom located on the current cell from a global vector associated with     a DoFHandler object (as the function above does), this function instead     takes these local nodal values through its first argument. A typical     way to obtain such a vector is by calling code such as    
* [1.x.6]
*      (See  [2.x.282]  for more information on this     function.) The point of the current function is then that one could     modify these local values first, for example by applying a limiter     or by ensuring that all nodal values are positive, before evaluating     the finite element field that corresponds to these local values on the     current cell. Another application is where one wants to postprocess     the solution on a cell into a different finite element space on every     cell, without actually creating a corresponding DoFHandler
* 
*  -  in that     case, all one would compute is a local representation of that     postprocessed function, characterized by its nodal values; this function     then allows the evaluation of that representation at quadrature points.          [2.x.283]  dof_values A vector of local nodal values. This vector must       have a length equal to number of DoFs on the current cell, and must       be ordered in the same order as degrees of freedom are numbered on       the reference cell.          [2.x.284]  values A vector of values of the given finite element field,       at the quadrature points on the current object.          [2.x.285]  InputVector The  [2.x.286]  type must allow creation       of an ArrayView object from it; this is satisfied by the        [2.x.287]  class, among others.    
* [0.x.166]*
     Return the divergence of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         There is no equivalent function such as      [2.x.288]  in the FEValues classes but the     information can be obtained from  [2.x.289]      of course.         See the general discussion of this class for a definition of the     divergence.         The data type stored by the output vector must be what you get when you     multiply the divergences of shape functions (i.e.,  [2.x.290]      times the type used to store the values of the unknowns  [2.x.291]  of your     finite element vector  [2.x.292]  (represented by the  [2.x.293]  argument).          [2.x.294]     
* [0.x.167]*
     This function relates to get_function_divergences() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.168]*
     Return the gradient of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         See the general discussion of this class for a definition of the     gradient.         The data type stored by the output vector must be what you get when you     multiply the gradients of shape functions (i.e.,  [2.x.295]      times the type used to store the values of the unknowns  [2.x.296]  of your     finite element vector  [2.x.297]  (represented by the  [2.x.298]  argument).          [2.x.299]     
* [0.x.169]*
     This function relates to get_function_gradients() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.170]*
     A pointer to the FEValuesBase object we operate on.    
* [0.x.171]*
     The first component of the vector this view represents of the     FEValuesBase object.    
* [0.x.172]*
     Store the data about shape functions.    
* [0.x.173]*
     A class whose specialization is used to define what FEValuesViews     object corresponds to the given FEValuesExtractors object.    
* [0.x.174]*
     A class whose specialization is used to define what FEValuesViews     object corresponds to the given FEValuesExtractors object.         When using  [2.x.300]  the corresponding view is an      [2.x.301]  spacedim>.    
* [0.x.175]*
     A class whose specialization is used to define what FEValuesViews     object corresponds to the given FEValuesExtractors object.         When using  [2.x.302]  the corresponding view is an      [2.x.303]  spacedim>.    
* [0.x.176]*
     A class whose specialization is used to define what FEValuesViews     object corresponds to the given FEValuesExtractors object.         When using  [2.x.304]  the corresponding view is an      [2.x.305]  dim, spacedim>.    
* [0.x.177]*
     A class whose specialization is used to define what FEValuesViews     object corresponds to the given FEValuesExtractors object.         When using  [2.x.306]  the corresponding     view is an  [2.x.307]  dim, spacedim>.    
* [0.x.178]*
     A class objects of which store a collection of  [2.x.308]       [2.x.309]  etc object. The FEValuesBase class uses it to     generate all possible Views classes upon construction time; we do this     at construction time since the Views classes cache some information and     are therefore relatively expensive to create.    
* [0.x.179]*
       Caches for scalar and vector, and symmetric second-order tensor       valued views.      
* [0.x.180]*
       Constructor.      
* [0.x.181]*
   A templated alias that associates to a given Extractor class   the corresponding view in FEValuesViews.  
* [0.x.182]*
 FEValues, FEFaceValues and FESubfaceValues objects are interfaces to finite element and mapping classes on the one hand side, to cells and quadrature rules on the other side. They allow to evaluate values or derivatives of shape functions at the quadrature points of a quadrature formula when projected by a mapping from the unit cell onto a cell in real space. The reason for this abstraction is possible optimization: Depending on the type of finite element and mapping, some values can be computed once on the unit cell. Others must be computed on each cell, but maybe computation of several values at the same time offers ways for optimization. Since this interplay may be complex and depends on the actual finite element, it cannot be left to the applications programmer.
*  FEValues, FEFaceValues and FESubfaceValues provide only data handling: computations are left to objects of type Mapping and FiniteElement. These provide functions <tt>get_*_data</tt> and <tt>fill_*_values</tt> which are called by the constructor and <tt>reinit</tt> functions of <tt>FEValues*</tt>, respectively.
*  [1.x.7]
*  Usually, an object of <tt>FEValues*</tt> is used in integration loops over all cells of a triangulation (or faces of cells). To take full advantage of the optimization features, it should be constructed before the loop so that information that does not depend on the location and shape of cells can be computed once and for all (this includes, for example, the values of shape functions at quadrature points for the most common elements: we can evaluate them on the unit cell and they will be the same when mapped to the real cell). Then, in the loop over all cells, it must be re-initialized for each grid cell to compute that part of the information that changes depending on the actual cell (for example, the gradient of shape functions equals the gradient on the unit cell
* 
*  -  which can be computed once and for all
* 
*  -  times the Jacobian matrix of the mapping between unit and real cell, which needs to be recomputed for each cell).
*  A typical piece of code, adding up local contributions to the Laplace matrix looks like this:
* 

* 
* [1.x.8]
* 
*  The individual functions used here are described below. Note that by design, the order of quadrature points used inside the FEValues object is the same as defined by the quadrature formula passed to the constructor of the FEValues object above.
*  [1.x.9]
*  The functions of this class fall into different categories:  [2.x.310]   [2.x.311]  shape_value(), shape_grad(), etc: return one of the values of this object at a time. These functions are inlined, so this is the suggested access to all finite element values. There should be no loss in performance with an optimizing compiler. If the finite element is vector valued, then these functions return the only non-zero component of the requested shape function. However, some finite elements have shape functions that have more than one non-zero component (we call them non-"primitive"), and in this case this set of functions will throw an exception since they cannot generate a useful result. Rather, use the next set of functions.
*   [2.x.312]  shape_value_component(), shape_grad_component(), etc: This is the same set of functions as above, except that for vector valued finite elements they return only one vector component. This is useful for elements of which shape functions have more than one non-zero component, since then the above functions cannot be used, and you have to walk over all (or only the non- zero) components of the shape function using this set of functions.
*   [2.x.313]  get_function_values(), get_function_gradients(), etc.: Compute a finite element function or its derivative in quadrature points.
*   [2.x.314]  reinit: initialize the FEValues object for a certain cell. This function is not in the present class but only in the derived classes and has a variable call syntax. See the docs for the derived classes for more information.  [2.x.315] 
* 

*  [1.x.10]
*  The mechanisms by which this class work are discussed on the page on  [2.x.316]  "Update flags" and about the  [2.x.317]  "How Mapping, FiniteElement, and FEValues work together".
* 

* 

* 
*  [2.x.318] 

* 
* [0.x.183]*
   Dimension in which this object operates.  
* [0.x.184]*
   Dimension of the space in which this object operates.  
* [0.x.185]*
   Number of quadrature points of the current object. Its value is   initialized by the value of max_n_quadrature_points and is updated,   e.g., if  [2.x.319]  is called for a new cell/face.    
*  [2.x.320]  The default value equals to the value of max_n_quadrature_points.  
* [0.x.186]*
   Maximum number of quadrature points. This value might be different from   n_quadrature_points, e.g., if a QCollection with different face quadrature   rules has been passed to initialize FEFaceValues.     This is mostly useful to initialize arrays to allocate the maximum amount   of memory that may be used when re-sizing later on to a the current   number of quadrature points given by n_quadrature_points.  
* [0.x.187]*
   Number of shape functions per cell. If we use this base class to evaluate   a finite element on faces of cells, this is still the number of degrees   of freedom per cell, not per face.  
* [0.x.188]*
   Constructor. Set up the array sizes with <tt>n_q_points</tt> quadrature   points, <tt>dofs_per_cell</tt> trial functions per cell and with the   given pattern to update the fields when the <tt>reinit</tt> function of   the derived classes is called. The fields themselves are not set up, this   must happen in the constructor of the derived class.  
* [0.x.189]*
   The copy assignment is deleted since objects of this class are not   copyable.  
* [0.x.190]*
   The copy constructor is deleted since objects of this class are not   copyable.  
* [0.x.191]*
   Destructor.  
* [0.x.192]*
   Value of a shape function at a quadrature point on the cell, face or   subface selected the last time the <tt>reinit</tt> function of the   derived class was called.     If the shape function is vector-valued, then this returns the only non-   zero component. If the shape function has more than one non-zero   component (i.e. it is not primitive), then throw an exception of type   ExcShapeFunctionNotPrimitive. In that case, use the   shape_value_component() function.      [2.x.321]  function_no Number of the shape function to be evaluated. Note   that this number runs from zero to dofs_per_cell, even in the case of an   FEFaceValues or FESubfaceValues object.      [2.x.322]  point_no Number of the quadrature point at which function is to be   evaluated      [2.x.323]   
* [0.x.193]*
   Compute one vector component of the value of a shape function at a   quadrature point. If the finite element is scalar, then only component   zero is allowed and the return value equals that of the shape_value()   function. If the finite element is vector valued but all shape functions   are primitive (i.e. they are non-zero in only one component), then the   value returned by shape_value() equals that of this function for exactly   one component. This function is therefore only of greater interest if the   shape function is not primitive, but then it is necessary since the other   function cannot be used.      [2.x.324]  function_no Number of the shape function to be evaluated.      [2.x.325]  point_no Number of the quadrature point at which function is to be   evaluated.      [2.x.326]  component vector component to be evaluated.      [2.x.327]   
* [0.x.194]*
   Compute the gradient of the <tt>function_no</tt>th shape function at the   <tt>quadrature_point</tt>th quadrature point with respect to real cell   coordinates.  If you want to get the derivative in one of the coordinate   directions, use the appropriate function of the Tensor class to extract   one component of the Tensor returned by this function. Since only a   reference to the gradient's value is returned, there should be no major   performance drawback.     If the shape function is vector-valued, then this returns the only non-   zero component. If the shape function has more than one non-zero   component (i.e. it is not primitive), then it will throw an exception of   type ExcShapeFunctionNotPrimitive. In that case, use the   shape_grad_component() function.     The same holds for the arguments of this function as for the   shape_value() function.      [2.x.328]  function_no Number of the shape function to be evaluated.      [2.x.329]  quadrature_point Number of the quadrature point at which function   is to be evaluated.      [2.x.330]   
* [0.x.195]*
   Return one vector component of the gradient of a shape function at a   quadrature point. If the finite element is scalar, then only component   zero is allowed and the return value equals that of the shape_grad()   function. If the finite element is vector valued but all shape functions   are primitive (i.e. they are non-zero in only one component), then the   value returned by shape_grad() equals that of this function for exactly   one component. This function is therefore only of greater interest if the   shape function is not primitive, but then it is necessary since the other   function cannot be used.     The same holds for the arguments of this function as for the   shape_value_component() function.      [2.x.331]   
* [0.x.196]*
   Second derivatives of the <tt>function_no</tt>th shape function at the   <tt>point_no</tt>th quadrature point with respect to real cell   coordinates. If you want to get the derivatives in one of the coordinate   directions, use the appropriate function of the Tensor class to extract   one component. Since only a reference to the hessian values is returned,   there should be no major performance drawback.     If the shape function is vector-valued, then this returns the only non-   zero component. If the shape function has more than one non-zero   component (i.e. it is not primitive), then throw an exception of type   ExcShapeFunctionNotPrimitive. In that case, use the   shape_hessian_component() function.     The same holds for the arguments of this function as for the   shape_value() function.      [2.x.332]   
* [0.x.197]*
   Return one vector component of the hessian of a shape function at a   quadrature point. If the finite element is scalar, then only component   zero is allowed and the return value equals that of the shape_hessian()   function. If the finite element is vector valued but all shape functions   are primitive (i.e. they are non-zero in only one component), then the   value returned by shape_hessian() equals that of this function for   exactly one component. This function is therefore only of greater   interest if the shape function is not primitive, but then it is necessary   since the other function cannot be used.     The same holds for the arguments of this function as for the   shape_value_component() function.      [2.x.333]   
* [0.x.198]*
   Third derivatives of the <tt>function_no</tt>th shape function at the   <tt>point_no</tt>th quadrature point with respect to real cell   coordinates. If you want to get the 3rd derivatives in one of the   coordinate directions, use the appropriate function of the Tensor class   to extract one component. Since only a reference to the 3rd derivative   values is returned, there should be no major performance drawback.     If the shape function is vector-valued, then this returns the only non-   zero component. If the shape function has more than one non-zero   component (i.e. it is not primitive), then throw an exception of type   ExcShapeFunctionNotPrimitive. In that case, use the   shape_3rdderivative_component() function.     The same holds for the arguments of this function as for the   shape_value() function.      [2.x.334]   
* [0.x.199]*
   Return one vector component of the third derivative of a shape function   at a quadrature point. If the finite element is scalar, then only   component zero is allowed and the return value equals that of the   shape_3rdderivative() function. If the finite element is vector valued   but all shape functions are primitive (i.e. they are non-zero in only one   component), then the value returned by shape_3rdderivative() equals that   of this function for exactly one component. This function is therefore   only of greater interest if the shape function is not primitive, but then   it is necessary since the other function cannot be used.     The same holds for the arguments of this function as for the   shape_value_component() function.      [2.x.335]   
* [0.x.200]*
   Return the values of a finite element function restricted to the current   cell, face or subface selected the last time the <tt>reinit</tt> function   of the derived class was called, at the quadrature points.     If the present cell is not active then values are interpolated to the   current cell and point values are computed from that.     This function may only be used if the finite element in use is a scalar   one, i.e. has only one vector component.  To get values of multi-   component elements, there is another get_function_values() below,   returning a vector of vectors of results.      [2.x.336]  fe_function A vector of values that describes (globally) the   finite element function that this function should evaluate at the   quadrature points of the current cell.      [2.x.337]  values The values of the function specified by fe_function at   the quadrature points of the current cell.  The object is assume to   already have the correct size. The data type stored by this output vector   must be what you get when you multiply the values of shape function times   the type used to store the values of the unknowns  [2.x.338]  of your finite   element vector  [2.x.339]  (represented by the  [2.x.340]  argument). This   happens to be equal to the type of the elements of the solution vector.      [2.x.341]   [2.x.342]  will contain the value of the field   described by fe_function at the  [2.x.343] th quadrature point.    
*  [2.x.344]  The actual data type of the input vector may be either a   Vector&lt;T&gt;, BlockVector&lt;T&gt;, or one of the PETSc or Trilinos   vector wrapper classes. It represents a global vector of DoF values   associated with the DoFHandler object with which this FEValues object was   last initialized.      [2.x.345]   
* [0.x.201]*
   This function does the same as the other get_function_values(), but   applied to multi-component (vector-valued) elements. The meaning of the   arguments is as explained there.      [2.x.346]   [2.x.347]  is a vector of values of the field described   by fe_function at the  [2.x.348] th quadrature point. The size of the vector   accessed by  [2.x.349]  equals the number of components of the   finite element, i.e.  [2.x.350]  returns the value of the    [2.x.351] th vector component at the  [2.x.352] th quadrature point.      [2.x.353]   
* [0.x.202]*
   Generate function values from an arbitrary vector. This function   does in essence the same as the first function of this name above,   except that it does not make the assumption that the input vector   corresponds to a DoFHandler that describes the unknowns of a finite   element field (and for which we would then assume that   `fe_function.size() == dof_handler.n_dofs()`). Rather, the nodal   values corresponding to the current cell are elements of an otherwise   arbitrary vector, and these elements are indexed by the second   argument to this function. What the rest of the `fe_function` input   argument corresponds to is of no consequence to this function.     Given this, the function above corresponds to passing `fe_function`   as first argument to the current function, and using the   `local_dof_indices` array that results from the following call as   second argument to the current function:  
* [1.x.11]
*    (See  [2.x.354]  for more information.)     Likewise, the function above is equivalent to calling  
* [1.x.12]
*    and then calling the current function with `local_dof_values` as   first argument, and an array with indices `{0,...,fe.dofs_per_cell-1}`   as second argument.     The point of the current function is that one sometimes wants to   evaluate finite element functions at quadrature points with nodal   values that are not stored in a global vector
* 
*  -  for example, one could   modify these local values first, such as by applying a limiter   or by ensuring that all nodal values are positive, before evaluating   the finite element field that corresponds to these local values on the   current cell. Another application is where one wants to postprocess   the solution on a cell into a different finite element space on every   cell, without actually creating a corresponding DoFHandler
* 
*  -  in that   case, all one would compute is a local representation of that   postprocessed function, characterized by its nodal values; this function   then allows the evaluation of that representation at quadrature points.      [2.x.355]  fe_function A vector of nodal values. This vector can have     an arbitrary size, as long as all elements index by `indices` can     actually be accessed.      [2.x.356]  indices A vector of indices into `fe_function`. This vector     must have length equal to the number of degrees of freedom on the     current cell, and must identify elements in `fe_function` in the     order in which degrees of freedom are indexed on the reference cell.      [2.x.357]  values A vector of values of the given finite element field,     at the quadrature points on the current object.      [2.x.358]   
* [0.x.203]*
   Generate vector function values from an arbitrary vector.     This function corresponds to the previous one, just for the vector-valued   case.      [2.x.359]   
* [0.x.204]*
   Generate vector function values from an arbitrary vector. This   function is similar to the previous one, but the `indices`   vector may also be a multiple of the number of dofs per   cell. Then, the vectors in <tt>value</tt> should allow for the same   multiple of the components of the finite element.     Depending on the value of the last argument, the outer vector of   <tt>values</tt> has either the length of the quadrature rule   (<tt>quadrature_points_fastest == false</tt>) or the length of components   to be filled <tt>quadrature_points_fastest == true</tt>. If <tt>p</tt> is   the current quadrature point number and <tt>i</tt> is the vector   component of the solution desired, the access to <tt>values</tt> is   <tt>values[p][i]</tt> if <tt>quadrature_points_fastest == false</tt>, and   <tt>values[i][p]</tt> otherwise.     Since this function allows for fairly general combinations of argument   sizes, be aware that the checks on the arguments may not detect errors.      [2.x.360]   
* [0.x.205]*
   Compute the gradients of a finite element at the quadrature points of a   cell. This function is the equivalent of the corresponding   get_function_values() function (see there for more information) but   evaluates the finite element field's gradient instead of its value.     This function may only be used if the finite element in use is a scalar   one, i.e. has only one vector component. There is a corresponding   function of the same name for vector-valued finite elements.      [2.x.361]  fe_function A vector of values that describes (globally) the   finite element function that this function should evaluate at the   quadrature points of the current cell.      [2.x.362]  gradients The gradients of the function specified by   fe_function at the quadrature points of the current cell.  The gradients   are computed in real space (as opposed to on the unit cell).  The object   is assume to already have the correct size. The data type stored by this   output vector must be what you get when you multiply the gradients of   shape function times the type used to store the values of the unknowns    [2.x.363]  of your finite element vector  [2.x.364]  (represented by the  [2.x.365]    fe_function argument).      [2.x.366]   [2.x.367]  will contain the gradient of the field   described by fe_function at the  [2.x.368] th quadrature point.    [2.x.369]  represents the derivative in coordinate   direction  [2.x.370]  at quadrature point  [2.x.371] .    
*  [2.x.372]  The actual data type of the input vector may be either a   Vector&lt;T&gt;, BlockVector&lt;T&gt;, or one of the PETSc or Trilinos   vector wrapper classes. It represents a global vector of DoF values   associated with the DoFHandler object with which this FEValues object was   last initialized.      [2.x.373]   
* [0.x.206]*
   This function does the same as the other get_function_gradients(), but   applied to multi-component (vector-valued) elements. The meaning of the   arguments is as explained there.      [2.x.374]   [2.x.375]  is a vector of gradients of the field   described by fe_function at the  [2.x.376] th quadrature point. The size of the   vector accessed by  [2.x.377]  equals the number of   components of the finite element, i.e.  [2.x.378]    returns the gradient of the  [2.x.379] th vector component at the  [2.x.380] th   quadrature point. Consequently,  [2.x.381]  is the   derivative in coordinate direction  [2.x.382]  of the  [2.x.383] th vector component of   the vector field at quadrature point  [2.x.384]  of the current cell.      [2.x.385]   
* [0.x.207]*
   This function relates to the first of the get_function_gradients() function   above in the same way as the get_function_values() with similar arguments   relates to the first of the get_function_values() functions. See there for   more information.      [2.x.386]   
* [0.x.208]*
   This function relates to the first of the get_function_gradients() function   above in the same way as the get_function_values() with similar arguments   relates to the first of the get_function_values() functions. See there for   more information.      [2.x.387]   
* [0.x.209]*
   Compute the tensor of second derivatives of a finite element at the   quadrature points of a cell. This function is the equivalent of the   corresponding get_function_values() function (see there for more   information) but evaluates the finite element field's second derivatives   instead of its value.     This function may only be used if the finite element in use is a scalar   one, i.e. has only one vector component. There is a corresponding   function of the same name for vector-valued finite elements.      [2.x.388]  fe_function A vector of values that describes (globally) the   finite element function that this function should evaluate at the   quadrature points of the current cell.      [2.x.389]  hessians The Hessians of the function specified by   fe_function at the quadrature points of the current cell.  The Hessians   are computed in real space (as opposed to on the unit cell).  The object   is assume to already have the correct size. The data type stored by this   output vector must be what you get when you multiply the Hessians of   shape function times the type used to store the values of the unknowns    [2.x.390]  of your finite element vector  [2.x.391]  (represented by the  [2.x.392]    fe_function argument).      [2.x.393]   [2.x.394]  will contain the Hessian of the field   described by fe_function at the  [2.x.395] th quadrature point.    [2.x.396]  represents the  [2.x.397] th component of the   matrix of second derivatives at quadrature point  [2.x.398] .    
*  [2.x.399]  The actual data type of the input vector may be either a   Vector&lt;T&gt;, BlockVector&lt;T&gt;, or one of the PETSc or Trilinos   vector wrapper classes. It represents a global vector of DoF values   associated with the DoFHandler object with which this FEValues object was   last initialized.      [2.x.400]   
* [0.x.210]*
   This function does the same as the other get_function_hessians(), but   applied to multi-component (vector-valued) elements. The meaning of the   arguments is as explained there.      [2.x.401]   [2.x.402]  is a vector of Hessians of the field   described by fe_function at the  [2.x.403] th quadrature point. The size of the   vector accessed by  [2.x.404]  equals the number of   components of the finite element, i.e.  [2.x.405]    returns the Hessian of the  [2.x.406] th vector component at the  [2.x.407] th quadrature   point. Consequently,  [2.x.408]  is the  [2.x.409] th   component of the matrix of second derivatives of the  [2.x.410] th vector   component of the vector field at quadrature point  [2.x.411]  of the current   cell.      [2.x.412]   
* [0.x.211]*
   This function relates to the first of the get_function_hessians() function   above in the same way as the get_function_values() with similar arguments   relates to the first of the get_function_values() functions. See there for   more information.      [2.x.413]   
* [0.x.212]*
   This function relates to the first of the get_function_hessians() function   above in the same way as the get_function_values() with similar arguments   relates to the first of the get_function_values() functions. See there for   more information.      [2.x.414]   
* [0.x.213]*
   Compute the (scalar) Laplacian (i.e. the trace of the tensor of second   derivatives) of a finite element at the quadrature points of a cell. This   function is the equivalent of the corresponding get_function_values()   function (see there for more information) but evaluates the finite   element field's second derivatives instead of its value.     This function may only be used if the finite element in use is a scalar   one, i.e. has only one vector component. There is a corresponding   function of the same name for vector-valued finite elements.      [2.x.415]  fe_function A vector of values that describes (globally) the   finite element function that this function should evaluate at the   quadrature points of the current cell.      [2.x.416]  laplacians The Laplacians of the function specified by   fe_function at the quadrature points of the current cell.  The Laplacians   are computed in real space (as opposed to on the unit cell).  The object   is assume to already have the correct size. The data type stored by this   output vector must be what you get when you multiply the Laplacians of   shape function times the type used to store the values of the unknowns    [2.x.417]  of your finite element vector  [2.x.418]  (represented by the  [2.x.419]    fe_function argument). This happens to be equal to the type of the   elements of the input vector.      [2.x.420]   [2.x.421]  will contain the Laplacian of the field   described by fe_function at the  [2.x.422] th quadrature point.      [2.x.423]  For each component of the output vector, there holds    [2.x.424] , where <tt>hessians</tt>   would be the output of the get_function_hessians() function.    
*  [2.x.425]  The actual data type of the input vector may be either a   Vector&lt;T&gt;, BlockVector&lt;T&gt;, or one of the PETSc or Trilinos   vector wrapper classes. It represents a global vector of DoF values   associated with the DoFHandler object with which this FEValues object was   last initialized.      [2.x.426]   
* [0.x.214]*
   This function does the same as the other get_function_laplacians(), but   applied to multi-component (vector-valued) elements. The meaning of the   arguments is as explained there.      [2.x.427]   [2.x.428]  is a vector of Laplacians of the field   described by fe_function at the  [2.x.429] th quadrature point. The size of the   vector accessed by  [2.x.430]  equals the number of   components of the finite element, i.e.  [2.x.431]    returns the Laplacian of the  [2.x.432] th vector component at the  [2.x.433] th   quadrature point.      [2.x.434]  For each component of the output vector, there holds    [2.x.435] , where   <tt>hessians</tt> would be the output of the get_function_hessians()   function.      [2.x.436]   
* [0.x.215]*
   This function relates to the first of the get_function_laplacians()   function above in the same way as the get_function_values() with similar   arguments relates to the first of the get_function_values() functions. See   there for more information.      [2.x.437]   
* [0.x.216]*
   This function relates to the first of the get_function_laplacians()   function above in the same way as the get_function_values() with similar   arguments relates to the first of the get_function_values() functions. See   there for more information.      [2.x.438]   
* [0.x.217]*
   This function relates to the first of the get_function_laplacians()   function above in the same way as the get_function_values() with similar   arguments relates to the first of the get_function_values() functions. See   there for more information.      [2.x.439]   
* [0.x.218]*
   Compute the tensor of third derivatives of a finite element at the   quadrature points of a cell. This function is the equivalent of the   corresponding get_function_values() function (see there for more   information) but evaluates the finite element field's third derivatives   instead of its value.     This function may only be used if the finite element in use is a scalar   one, i.e. has only one vector component. There is a corresponding   function of the same name for vector-valued finite elements.      [2.x.440]  fe_function A vector of values that describes (globally) the   finite element function that this function should evaluate at the   quadrature points of the current cell.      [2.x.441]  third_derivatives The third derivatives of the function   specified by fe_function at the quadrature points of the current cell.   The third derivatives are computed in real space (as opposed to on the   unit cell).  The object is assumed to already have the correct size. The   data type stored by this output vector must be what you get when you   multiply the third derivatives of shape function times the type used to   store the values of the unknowns  [2.x.442]  of your finite element vector  [2.x.443]    (represented by the  [2.x.444]  argument).      [2.x.445]   [2.x.446]  will contain the third   derivatives of the field described by fe_function at the  [2.x.447] th quadrature   point.  [2.x.448]  represents the    [2.x.449] th component of the 3rd order tensor of third derivatives at   quadrature point  [2.x.450] .    
*  [2.x.451]  The actual data type of the input vector may be either a   Vector&lt;T&gt;, BlockVector&lt;T&gt;, or one of the PETSc or Trilinos   vector wrapper classes. It represents a global vector of DoF values   associated with the DoFHandler object with which this FEValues object was   last initialized.      [2.x.452]   
* [0.x.219]*
   This function does the same as the other   get_function_third_derivatives(), but applied to multi-component (vector-   valued) elements. The meaning of the arguments is as explained there.      [2.x.453]   [2.x.454]  is a vector of third derivatives   of the field described by fe_function at the  [2.x.455] th quadrature point. The   size of the vector accessed by  [2.x.456]  equals   the number of components of the finite element, i.e.    [2.x.457]  returns the third derivative of the    [2.x.458] th vector component at the  [2.x.459] th quadrature point. Consequently,    [2.x.460]  is the  [2.x.461] th   component of the tensor of third derivatives of the  [2.x.462] th vector   component of the vector field at quadrature point  [2.x.463]  of the current   cell.      [2.x.464]   
* [0.x.220]*
   This function relates to the first of the get_function_third_derivatives()   function above in the same way as the get_function_values() with similar   arguments relates to the first of the get_function_values() functions. See   there for more information.      [2.x.465]   
* [0.x.221]*
   This function relates to the first of the get_function_third_derivatives()   function above in the same way as the get_function_values() with similar   arguments relates to the first of the get_function_values() functions. See   there for more information.      [2.x.466]   
* [0.x.222]*
   Return an object that can be thought of as an array containing all   indices from zero (inclusive) to `dofs_per_cell` (exclusive). This allows   one to write code using range-based `for` loops of the following kind:  
* [1.x.13]
*    Here, we are looping over all degrees of freedom on all cells, with   `i` and `j` taking on all valid indices for cell degrees of freedom, as   defined by the finite element passed to `fe_values`.  
* [0.x.223]*
   Return an object that can be thought of as an array containing all   indices from  [2.x.467]  (inclusive) to `dofs_per_cell` (exclusive).   This allows one to write code using range-based `for` loops of the   following kind:  
* [1.x.14]
*    Here, we are looping over all local degrees of freedom on all cells, with   `i` taking on all valid indices for cell degrees of freedom, as   defined by the finite element passed to `fe_values`, and `j` taking   on a specified subset of `i`'s range, starting at `i` itself and ending at   the number of cell degrees of freedom. In this way, we can construct the   upper half and the diagonal of a stiffness matrix contribution (assuming it   is symmetric, and that only one half of it needs to be computed), for   example.    
*  [2.x.468]  If the  [2.x.469]  is equal to the number of DoFs in the cell,   then the returned index range is empty.  
* [0.x.224]*
   Return an object that can be thought of as an array containing all   indices from zero (inclusive) to  [2.x.470]  (inclusive). This allows   one to write code using range-based `for` loops of the following kind:  
* [1.x.15]
*    Here, we are looping over all local degrees of freedom on all cells, with   `i` taking on all valid indices for cell degrees of freedom, as   defined by the finite element passed to `fe_values`, and `j` taking   on a specified subset of `i`'s range, starting at zero and ending at   `i` itself. In this way, we can construct the lower half and the   diagonal of a stiffness matrix contribution (assuming it is symmetric, and   that only one half of it needs to be computed), for example.    
*  [2.x.471]  If the  [2.x.472]  is equal to zero, then the returned index   range is empty.  
* [0.x.225]*
   Return an object that can be thought of as an array containing all   indices from zero to `n_quadrature_points`. This allows to write code   using range-based `for` loops of the following kind:  
* [1.x.16]
*    Here, we are looping over all quadrature points on all cells, with   `q_point` taking on all valid indices for quadrature points, as defined   by the quadrature rule passed to `fe_values`.      [2.x.473]  CPP11  
* [0.x.226]*
   Position of the <tt>q</tt>th quadrature point in real space.      [2.x.474]   
* [0.x.227]*
   Return a reference to the vector of quadrature points in real space.      [2.x.475]   
* [0.x.228]*
   Mapped quadrature weight. If this object refers to a volume evaluation   (i.e. the derived class is of type FEValues), then this is the Jacobi   determinant times the weight of the<tt>i</tt>th unit quadrature point.     For surface evaluations (i.e. classes FEFaceValues or FESubfaceValues),   it is the mapped surface element times the weight of the quadrature   point.     You can think of the quantity returned by this function as the volume or   surface element  [2.x.476]  in the integral that we implement here by   quadrature.      [2.x.477]   
* [0.x.229]*
   Return a reference to the array holding the values returned by JxW().  
* [0.x.230]*
   Return the Jacobian of the transformation at the specified quadrature   point, i.e.   [2.x.478]       [2.x.479]   
* [0.x.231]*
   Return a reference to the array holding the values returned by   jacobian().      [2.x.480]   
* [0.x.232]*
   Return the second derivative of the transformation from unit to real   cell, i.e. the first derivative of the Jacobian, at the specified   quadrature point, i.e.  [2.x.481] .      [2.x.482]   
* [0.x.233]*
   Return a reference to the array holding the values returned by   jacobian_grads().      [2.x.483]   
* [0.x.234]*
   Return the second derivative of the transformation from unit to real   cell, i.e. the first derivative of the Jacobian, at the specified   quadrature point, pushed forward to the real cell coordinates, i.e.    [2.x.484] .      [2.x.485]   
* [0.x.235]*
   Return a reference to the array holding the values returned by   jacobian_pushed_forward_grads().      [2.x.486]   
* [0.x.236]*
   Return the third derivative of the transformation from unit to real cell,   i.e. the second derivative of the Jacobian, at the specified quadrature   point, i.e.  [2.x.487] .      [2.x.488]   
* [0.x.237]*
   Return a reference to the array holding the values returned by   jacobian_2nd_derivatives().      [2.x.489]   
* [0.x.238]*
   Return the third derivative of the transformation from unit to real cell,   i.e. the second derivative of the Jacobian, at the specified quadrature   point, pushed forward to the real cell coordinates, i.e.    [2.x.490] .      [2.x.491]   
* [0.x.239]*
   Return a reference to the array holding the values returned by   jacobian_pushed_forward_2nd_derivatives().      [2.x.492]   
* [0.x.240]*
   Return the fourth derivative of the transformation from unit to real   cell, i.e. the third derivative of the Jacobian, at the specified   quadrature point, i.e.  [2.x.493] .      [2.x.494]   
* [0.x.241]*
   Return a reference to the array holding the values returned by   jacobian_3rd_derivatives().      [2.x.495]   
* [0.x.242]*
   Return the fourth derivative of the transformation from unit to real   cell, i.e. the third derivative of the Jacobian, at the specified   quadrature point, pushed forward to the real cell coordinates, i.e.    [2.x.496] .      [2.x.497]   
* [0.x.243]*
   Return a reference to the array holding the values returned by   jacobian_pushed_forward_3rd_derivatives().      [2.x.498]   
* [0.x.244]*
   Return the inverse Jacobian of the transformation at the specified   quadrature point, i.e.   [2.x.499]       [2.x.500]   
* [0.x.245]*
   Return a reference to the array holding the values returned by   inverse_jacobian().      [2.x.501]   
* [0.x.246]*
   Return the normal vector at a quadrature point. If you call this   function for a face (i.e., when using a FEFaceValues or FESubfaceValues   object), then this function returns the outward normal vector to   the cell at the <tt>i</tt>th quadrature point of the face.     In contrast, if you call this function for a cell of codimension one   (i.e., when using a `FEValues<dim,spacedim>` object with   `spacedim>dim`), then this function returns the normal vector to the   cell
* 
*  -  in other words, an approximation to the normal vector to the   manifold in which the triangulation is embedded. There are of   course two normal directions to a manifold in that case, and this   function returns the "up" direction as induced by the numbering of the   vertices.     The length of the vector is normalized to one.      [2.x.502]   
* [0.x.247]*
   Return the normal vectors at all quadrature points represented by   this object. See the normal_vector() function for what the normal   vectors represent.      [2.x.503]   
* [0.x.248]*
   Create a view of the current FEValues object that represents a particular   scalar component of the possibly vector-valued finite element. The   concept of views is explained in the documentation of the namespace   FEValuesViews and in particular in the    [2.x.504]    module.  
* [0.x.249]*
   Create a view of the current FEValues object that represents a set of    [2.x.505]  scalar components (i.e. a vector) of the vector-valued   finite element. The concept of views is explained in the documentation of   the namespace FEValuesViews and in particular in the    [2.x.506]    module.  
* [0.x.250]*
   Create a view of the current FEValues object that represents a set of    [2.x.507]  scalar components (i.e. a symmetric 2nd   order tensor) of the vector-valued finite element. The concept of views   is explained in the documentation of the namespace FEValuesViews and in   particular in the    [2.x.508]    module.  
* [0.x.251]*
   Create a view of the current FEValues object that represents a set of    [2.x.509]  scalar components (i.e. a 2nd order tensor) of the   vector-valued finite element. The concept of views is explained in the   documentation of the namespace FEValuesViews and in particular in the    [2.x.510]    module.  
* [0.x.252]*
   Constant reference to the selected mapping object.  
* [0.x.253]*
   Constant reference to the selected finite element object.  
* [0.x.254]*
   Return the update flags set for this object.  
* [0.x.255]*
   Return a triangulation iterator to the current cell.  
* [0.x.256]*
   Return the relation of the current cell to the previous cell. This allows   re-use of some cell data (like local matrices for equations with constant   coefficients) if the result is  [2.x.511]   
* [0.x.257]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.258]*
   This exception is thrown if FEValuesBase is asked to return the value of   a field which was not required by the UpdateFlags for this FEValuesBase.    
*  [2.x.512]   
* [0.x.259]*
   Mismatch between the FEValues FiniteElement and   cell->get_dof_handler().get_fe()    
*  [2.x.513]   
* [0.x.260]*
   A given shape function is not primitive, but it needs to be.    
*  [2.x.514]   
* [0.x.261]*
   The given FiniteElement is not a primitive element, see    [2.x.515]     
*  [2.x.516]   
* [0.x.262]*
   Objects of the FEValues class need to store an iterator   to the present cell in order to be able to extract the values of the   degrees of freedom on this cell in the get_function_values() and assorted   functions. On the other hand, this class should also work for different   iterators, as long as they have the same interface to extract the DoF   values (i.e., for example, they need to have a  [2.x.517]    get_interpolated_dof_values function).     This calls for a common base class of iterator classes, and making the   functions we need here  [2.x.518]  On the other hand, this is the only   place in the library where we need this, and introducing a base class of   iterators and making a function virtual penalizes  [2.x.519] all [2.x.520]  users of   the iterators, which are basically intended as very fast accessor   functions. So we do not want to do this. Rather, what we do here is   making the functions we need virtual only for use with  [2.x.521] this   class [2.x.522] . The idea is the following: have a common base class which   declares some pure virtual functions, and for each possible iterator   type, we have a derived class which stores the iterator to the cell and   implements these functions. Since the iterator classes have the same   interface, we can make the derived classes a template, templatized on the   iterator type.     This way, the use of virtual functions is restricted to only this class,   and other users of iterators do not have to bear the negative effects.    
*  [2.x.523]  This class is an example of the   [1.x.17] design pattern.  
* [0.x.263]*
   Forward declaration of classes derived from CellIteratorBase. Their   definition and implementation is given in the .cc file.  
* [0.x.264]*
   Store the cell selected last time the reinit() function was called.  This   is necessary for the <tt>get_function_*</tt> functions as well as the   functions of same name in the extractor classes.  
* [0.x.265]*
   A signal connection we use to ensure we get informed whenever the   triangulation changes by refinement. We need to know about that because   it invalidates all cell iterators and, as part of that, the   'present_cell' iterator we keep around between subsequent calls to   reinit() in order to compute the cell similarity.  
* [0.x.266]*
   A signal connection we use to ensure we get informed whenever the   triangulation changes by mesh transformations. We need to know about that   because it invalidates all cell iterators and, as part of that, the   'present_cell' iterator we keep around between subsequent calls to   reinit() in order to compute the cell similarity.  
* [0.x.267]*
   A function that is connected to the triangulation in order to reset the   stored 'present_cell' iterator to an invalid one whenever the   triangulation is changed and the iterator consequently becomes invalid.  
* [0.x.268]*
   This function is called by the various reinit() functions in derived   classes. Given the cell indicated by the argument, test whether we have   to throw away the previously stored present_cell argument because it   would require us to compare cells from different triangulations. In   checking all this, also make sure that we have tria_listener connected to   the triangulation to which we will set present_cell right after calling   this function.  
* [0.x.269]*
   A pointer to the mapping object associated with this FEValues object.  
* [0.x.270]*
   A pointer to the internal data object of mapping, obtained from    [2.x.524]   [2.x.525]  or    [2.x.526]   
* [0.x.271]*
   An object into which the  [2.x.527]  and similar functions   place their output.  
* [0.x.272]*
   A pointer to the finite element object associated with this FEValues   object.  
* [0.x.273]*
   A pointer to the internal data object of finite element, obtained from    [2.x.528]   [2.x.529]  or    [2.x.530]   
* [0.x.274]*
   An object into which the  [2.x.531]  and similar   functions place their output.  
* [0.x.275]*
   Original update flags handed to the constructor of FEValues.  
* [0.x.276]*
   Initialize some update flags. Called from the  [2.x.532]  functions of   derived classes, which are in turn called from their constructors.     Basically, this function finds out using the finite element and mapping   object already stored which flags need to be set to compute everything   the user wants, as expressed through the flags passed as argument.  
* [0.x.277]*
   An enum variable that can store different states of the current cell in   comparison to the previously visited cell. If wanted, additional states   can be checked here and used in one of the methods used during reinit.  
* [0.x.278]*
   A function that checks whether the new cell is similar to the one   previously used. Then, a significant amount of the data can be reused,   e.g. the derivatives of the basis functions in real space, shape_grad.  
* [0.x.279]*
   A cache for all possible FEValuesViews objects.  
* [0.x.280]*
 Finite element evaluated in quadrature points of a cell.
*  This function implements the initialization routines for FEValuesBase, if values in quadrature points of a cell are needed. For further documentation see this class.
* 

* 
*  [2.x.533] 

* 
* [0.x.281]*
   Dimension of the object over which we integrate. For the present class,   this is equal to  [2.x.534] .  
* [0.x.282]*
   Constructor. Gets cell independent data from mapping and finite element   objects, matching the quadrature rule and update flags.  
* [0.x.283]*
   Like the function above, but taking a collection of quadrature rules.    
*  [2.x.535]  We require, in contrast to FEFaceValues, that the number of quadrature     rules in the collection is one.  
* [0.x.284]*
   Constructor. This constructor is equivalent to the other one except that   it makes the object use a  [2.x.536]  mapping (i.e., an object of type   MappingQGeneric(1)) implicitly.  
* [0.x.285]*
   Like the function above, but taking a collection of quadrature rules.    
*  [2.x.537]  We require, in contrast to FEFaceValues, that the number of quadrature     rules in the collection is one.  
* [0.x.286]*
   Reinitialize the gradients, Jacobi determinants, etc for the given cell   of type "iterator into a DoFHandler object", and the finite element   associated with this object. It is assumed that the finite element used   by the given cell is also the one used by this FEValues object.  
* [0.x.287]*
   Reinitialize the gradients, Jacobi determinants, etc for the given cell   of type "iterator into a Triangulation object", and the given finite   element. Since iterators into triangulation alone only convey information   about the geometry of a cell, but not about degrees of freedom possibly   associated with this cell, you will not be able to call some functions of   this class if they need information about degrees of freedom. These   functions are, above all, the   <tt>get_function_value/gradients/hessians/laplacians/third_derivatives</tt>   functions. If you want to call these functions, you have to call the  [2.x.538]    reinit variants that take iterators into DoFHandler or other DoF handler   type objects.  
* [0.x.288]*
   Return a reference to the copy of the quadrature formula stored by this   object.  
* [0.x.289]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.290]*
   Return a reference to this very object.     Though it seems that it is not very useful, this function is there to   provide capability to the  [2.x.539]  class, in which case it provides   the FEValues object for the present cell (remember that for hp-finite   elements, the actual FE object used may change from cell to cell, so we   also need different FEValues objects for different cells; once you   reinitialize the  [2.x.540]  object for a specific cell, it retrieves   the FEValues object for the FE on that cell and returns it through a   function of the same name as this one; this function here therefore only   provides the same interface so that one can templatize on FEValues and    [2.x.541]   
* [0.x.291]*
   Store a copy of the quadrature formula here.  
* [0.x.292]*
   Do work common to the two constructors.  
* [0.x.293]*
   The reinit() functions do only that part of the work that requires   knowledge of the type of iterator. After setting present_cell(), they   pass on to this function, which does the real work, and which is   independent of the actual type of the cell iterator.  
* [0.x.294]*
 Extend the interface of FEValuesBase to values that only make sense when evaluating something on the surface of a cell. All the data that is available in the interior of cells is also available here.
*  See FEValuesBase
* 

* 
*  [2.x.542] 

* 
* [0.x.295]*
   Dimension of the object over which we integrate. For the present class,   this is equal to  [2.x.543] .  
* [0.x.296]*
   Constructor. Call the constructor of the base class and set up the arrays   of this class with the right sizes.  Actually filling these arrays is a   duty of the derived class's constructors.      [2.x.544]  is the number of faces or subfaces that this   object is to store. The actual number depends on the derived class, for   FEFaceValues it is <tt>2*dim</tt>, while for the FESubfaceValues class it   is <tt>2*dim*(1<<(dim-1))</tt>, i.e. the number of faces times the number   of subfaces per face.  
* [0.x.297]*
   Like the function above, but taking a collection of quadrature rules. This   allows to assign each face a different quadrature rule. In the case that   the collection only contains a single face quadrature, this quadrature   rule is use on all faces.  
* [0.x.298]*
   Boundary form of the transformation of the cell at the <tt>i</tt>th   quadrature point.  See    [2.x.545] .      [2.x.546]   
* [0.x.299]*
   Return the list of outward normal vectors times the Jacobian of the   surface mapping.      [2.x.547]   
* [0.x.300]*
   Return the index of the face selected the last time the reinit() function   was called.  
* [0.x.301]*
   Return a reference to the copy of the quadrature formula stored by this   object.  
* [0.x.302]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.303]*
   Number of the face selected the last time the reinit() function was   called.  
* [0.x.304]*
   Index of the face selected the last time the reinit() function was   called.  
* [0.x.305]*
   Store a copy of the quadrature formula here.  
* [0.x.306]*
 Finite element evaluated in quadrature points on a face.
*  This class adds the functionality of FEFaceValuesBase to FEValues; see there for more documentation.
*  Since finite element functions and their derivatives may be discontinuous at cell boundaries, there is no restriction of this function to a mesh face. But, there are limits of these values approaching the face from either of the neighboring cells.
* 

* 
*  [2.x.548] 

* 
* [0.x.307]*
   Dimension in which this object operates.  
* [0.x.308]*
   Dimension of the object over which we integrate. For the present class,   this is equal to  [2.x.549] .  
* [0.x.309]*
   Constructor. Gets cell independent data from mapping and finite element   objects, matching the quadrature rule and update flags.  
* [0.x.310]*
   Like the function above, but taking a collection of quadrature rules. This   allows to assign each face a different quadrature rule. In the case that   the collection only contains a single face quadrature, this quadrature   rule is use on all faces.  
* [0.x.311]*
   Constructor. This constructor is equivalent to the other one except that   it makes the object use a  [2.x.550]  mapping (i.e., an object of type   MappingQGeneric(1)) implicitly.  
* [0.x.312]*
   Like the function above, but taking a collection of quadrature rules. This   allows to assign each face a different quadrature rule. In the case that   the collection only contains a single face quadrature, this quadrature   rule is use on all faces.  
* [0.x.313]*
   Reinitialize the gradients, Jacobi determinants, etc for the face with   number  [2.x.551]  of  [2.x.552]  and the given finite element.  
* [0.x.314]*
   Reinitialize the gradients, Jacobi determinants, etc for face  [2.x.553]    and cell  [2.x.554]     
*  [2.x.555]   [2.x.556]  must be one of  [2.x.557]  face iterators.  
* [0.x.315]*
   Reinitialize the gradients, Jacobi determinants, etc for the given face   on a given cell of type "iterator into a Triangulation object", and the   given finite element. Since iterators into a triangulation alone only   convey information about the geometry of a cell, but not about degrees of   freedom possibly associated with this cell, you will not be able to call   some functions of this class if they need information about degrees of   freedom. These functions are, above all, the   <tt>get_function_value/gradients/hessians/third_derivatives</tt>   functions. If you want to call these functions, you have to call the  [2.x.558]    reinit variants that take iterators into DoFHandler or other DoF handler   type objects.  
* [0.x.316]   Reinitialize the gradients, Jacobi determinants, etc for the given face   on a given cell of type "iterator into a Triangulation object", and the   given finite element. Since iterators into a triangulation alone only   convey information about the geometry of a cell, but not about degrees of   freedom possibly associated with this cell, you will not be able to call   some functions of this class if they need information about degrees of   freedom. These functions are, above all, the   <tt>get_function_value/gradients/hessians/third_derivatives</tt>   functions. If you want to call these functions, you have to call the  [2.x.559]    reinit variants that take iterators into DoFHandler or other DoF handler   type objects.    
*  [2.x.560]   [2.x.561]  must be one of  [2.x.562]  face iterators.  
* [0.x.317]*
   Return a reference to this very object.     Though it seems that it is not very useful, this function is there to   provide capability to the  [2.x.563]  class, in which case it provides   the FEValues object for the present cell (remember that for hp-finite   elements, the actual FE object used may change from cell to cell, so we   also need different FEValues objects for different cells; once you   reinitialize the  [2.x.564]  object for a specific cell, it retrieves   the FEValues object for the FE on that cell and returns it through a   function of the same name as this one; this function here therefore only   provides the same interface so that one can templatize on FEValues and    [2.x.565]   
* [0.x.318]*
   Do work common to the two constructors.  
* [0.x.319]*
   The reinit() functions do only that part of the work that requires   knowledge of the type of iterator. After setting present_cell(), they   pass on to this function, which does the real work, and which is   independent of the actual type of the cell iterator.  
* [0.x.320]*
 Finite element evaluated in quadrature points on a face.
*  This class adds the functionality of FEFaceValuesBase to FEValues; see there for more documentation.
*  This class is used for faces lying on a refinement edge. In this case, the neighboring cell is refined. To be able to compute differences between interior and exterior function values, the refinement of the neighboring cell must be simulated on this cell. This is achieved by applying a quadrature rule that simulates the refinement. The resulting data fields are split up to reflect the refinement structure of the neighbor: a subface number corresponds to the number of the child of the neighboring face.
* 

* 
*  [2.x.566] 

* 
* [0.x.321]*
   Dimension in which this object operates.  
* [0.x.322]*
   Dimension of the space in which this object operates.  
* [0.x.323]*
   Dimension of the object over which we integrate. For the present class,   this is equal to  [2.x.567] .  
* [0.x.324]*
   Constructor. Gets cell independent data from mapping and finite element   objects, matching the quadrature rule and update flags.  
* [0.x.325]*
   Like the function above, but taking a collection of quadrature rules.    
*  [2.x.568]  We require, in contrast to FEFaceValues, that the number of quadrature     rules in the collection is one.  
* [0.x.326]*
   Constructor. This constructor is equivalent to the other one except that   it makes the object use a  [2.x.569]  mapping (i.e., an object of type   MappingQGeneric(1)) implicitly.  
* [0.x.327]*
   Like the function above, but taking a collection of quadrature rules.    
*  [2.x.570]  We require, in contrast to FEFaceValues, that the number of quadrature     rules in the collection is one.  
* [0.x.328]*
   Reinitialize the gradients, Jacobi determinants, etc for the given cell   of type "iterator into a DoFHandler object", and the finite element   associated with this object. It is assumed that the finite element used   by the given cell is also the one used by this FESubfaceValues object.  
* [0.x.329]*
   Alternative reinitialization function that takes, as arguments, iterators   to the face and subface instead of their numbers.  
* [0.x.330]*
   Reinitialize the gradients, Jacobi determinants, etc for the given   subface on a given cell of type "iterator into a Triangulation object", and   the given finite element. Since iterators into a triangulation alone only   convey information about the geometry of a cell, but not about degrees of   freedom possibly associated with this cell, you will not be able to call   some functions of this class if they need information about degrees of   freedom. These functions are, above all, the   <tt>get_function_value/gradients/hessians/third_derivatives</tt>   functions. If you want to call these functions, you have to call the  [2.x.571]    reinit variants that take iterators into DoFHandler or other DoF handler   type objects.  
* [0.x.331]*
   Reinitialize the gradients, Jacobi determinants, etc for the given   subface on a given cell of type "iterator into a Triangulation object", and   the given finite element. Since iterators into a triangulation alone only   convey information about the geometry of a cell, but not about degrees of   freedom possibly associated with this cell, you will not be able to call   some functions of this class if they need information about degrees of   freedom. These functions are, above all, the   <tt>get_function_value/gradients/hessians/third_derivatives</tt>   functions. If you want to call these functions, you have to call the  [2.x.572]    reinit variants that take iterators into DoFHandler or other DoF handler   type objects.     This does the same thing as the previous function but takes iterators   instead of numbers as arguments.    
*  [2.x.573]   [2.x.574]  and  [2.x.575]  must correspond to a face (and a subface of   that face) of  [2.x.576]   
* [0.x.332]*
   Return a reference to this very object.     Though it seems that it is not very useful, this function is there to   provide capability to the  [2.x.577]  class, in which case it provides   the FEValues object for the present cell (remember that for hp-finite   elements, the actual FE object used may change from cell to cell, so we   also need different FEValues objects for different cells; once you   reinitialize the  [2.x.578]  object for a specific cell, it retrieves   the FEValues object for the FE on that cell and returns it through a   function of the same name as this one; this function here therefore only   provides the same interface so that one can templatize on FEValues and    [2.x.579]   
* [0.x.333]*
    [2.x.580]  Document this    
*  [2.x.581]   
* [0.x.334]*
    [2.x.582]  Document this    
*  [2.x.583]   
* [0.x.335]*
   Do work common to the two constructors.  
* [0.x.336]*
   The reinit() functions do only that part of the work that requires   knowledge of the type of iterator. After setting present_cell(), they   pass on to this function, which does the real work, and which is   independent of the actual type of the cell iterator.  
* [0.x.337]*
     Return the symmetrized version of a tensor whose n'th row equals the     second argument, with all other rows equal to zero.    
* [0.x.338]