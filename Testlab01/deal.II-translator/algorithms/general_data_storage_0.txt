[0.x.0]*
 This class facilitates the storage of any general data. It offers a mechanism to store any amount of data, of any type, which is then made accessible by an identifier string.
*  When using this class, please cite
* 

* 
* [1.x.0]
* 

* 
* [0.x.1]*
   Default constructor.  
* [0.x.2]*
   Copy constructor.  
* [0.x.3]*
   Move constructor.  
* [0.x.4]*
   Number of objects stored by this class instance.  
* [0.x.5]*
   Merge the contents of  [2.x.0]  with this object.  
* [0.x.6]*
   Print the contents of the internal cache to the  [2.x.1]      Each key and value pair in the  [2.x.2]  map are printed on an   individual line, with the  [2.x.3]  key listed first   followed by the demangled <tt>type_id</tt> of the associated mapped   type.  
* [0.x.7]*
   Clear all data stored in this class instance.     When you call this function, it destroys all objects you asked to be stored   as copies, and it forgets about the references to data you asked to store   by reference. As a consequence, you are now free to destroy the objects to   which references were stored at whatever time you want
* 
*  -  before or after   the current `GeneralDataStorage` object is destroyed.     To clarify this point, consider the following small example:    
* [1.x.1]
*      In the code above, the  [2.x.4]   object has a longer scope than   <tt>some_number</tt>. By the time we fetch the <tt>"value"</tt> from    [2.x.5]  , the reference to  [2.x.6]  is no longer valid.     Similarly, for data copied into a GeneralDataStorage object one should   consider the scope under which it remains valid:    
* [1.x.2]
*      Similar to the first example, we must be conscious of the fact that the   copies of any  [2.x.7]  stored by  [2.x.8]  only remains valid while the   GeneralDataStorage instance in which it is stored is alive.     Furthermore, as elucidated in the last example, the copy of the   class instance (owned by GeneralDataStorage) that is being pointed to   is no longer alive when the reset() function is called, or when it is   removed via a call to remove_object_with_name().    
* [1.x.3]
*   
* [0.x.8]*
    [2.x.9]  Data storage and access  
* [0.x.9]*
   Store internally a copy of the given object. The copied object is   owned by this class, and is accessible via reference through the   get_object_with_name() method.     This function ensures that no  [2.x.10]  with the given  [2.x.11]  is   already stored by this class instance.  
* [0.x.10]*
   Store internally a copy of the given object. The copied object is   owned by this class, and is accessible via reference through the   get_object_with_name() method.     This function does not perform any checks to ensure that the  [2.x.12]    with the given  [2.x.13]  is already stored by this class instance. If the    [2.x.14]  does in fact point to existing data, then this is overwritten.  
* [0.x.11]*
   Add a reference to an already existing object. The object is not   owned by this class, and the user has to guarantee that the   referenced object lives longer than this class instance. The stored   reference is accessible through the get_object_with_name() method.     This function ensures that no  [2.x.15]  with the given  [2.x.16]  is   already stored by this class instance.  
* [0.x.12]*
   Add a reference to an already existing object. The object is not   owned by this class, and the user has to guarantee that the   referenced object lives longer than this class instance. The stored   reference is accessible through the get_object_with_name() method.     This function does not perform any checks to ensure that the  [2.x.17]    with the given  [2.x.18]  is already stored by this class instance. If the    [2.x.19]  does in fact point to existing data, then this is overwritten.  
* [0.x.13]*
   Return a reference to the object with given name. If the object does   not exist, then the input  [2.x.20]  will be used to construct an object   of the given  [2.x.21]  and a reference to this new object then be returned.     A copy of an object of type  [2.x.22]  , which is owned by this class   instance, is generated by calling its constructor with the given set of   arguments. For this function, the  [2.x.23]  are passed as   <tt>lvalue</tt> references.  
* [0.x.14]*
   Return a reference to the object with given name. If the object does   not exist, then the input  [2.x.24]  will be used to construct an object   of the given  [2.x.25]  and a reference to this new object then be returned.     Same as above for a single argument.  
* [0.x.15]*
   Return a reference to the object with given name. If the object does   not exist, then the input  [2.x.26]  will be used to construct an object   of the given  [2.x.27]  and a reference to this new object then be returned.     A copy of an object of type  [2.x.28]  , which is owned by this class   instance, is generated by calling its constructor with the given set of   arguments. In contrast to the previous function of the same name, for   this function the  [2.x.29]  are passed as <tt>rvalue</tt> references.  
* [0.x.16]*
   Return a reference to the object with given name. If the object does   not exist, then the input  [2.x.30]  will be used to construct an object   of the given  [2.x.31]  and a reference to this new object then be returned.     Same as above for a single argument.  
* [0.x.17]*
   Same as above for default constructors.  
* [0.x.18]*
   Return a reference to the object with given name.     This function throws an exception if either an object with the given name   is not stored in this class, or if the object with the given name is   neither of the exact specified  [2.x.32]  nor a pointer to the  [2.x.33]   
* [0.x.19]*
   Return a constant reference to the object with the given name.     This function throws an exception if either an object with the given name   is not stored in this class, or if the object with the given name is   neither of the exact specified  [2.x.34]  nor a pointer to the  [2.x.35]   
* [0.x.20]*
   Find out if we store an object with given name.  
* [0.x.21]*
   Remove the object with given name.  
* [0.x.22]*
   An entry with this name does not exist in the internal  [2.x.36]  map.  
* [0.x.23]*
   An entry with this name does not exist in the internal  [2.x.37]  map.  
* [0.x.24]*
   The requested type and the stored type are different.  
* [0.x.25]*
   Arbitrary user data, identified by a string.  
* [0.x.26]