[0.x.0]*
   Control class for timestepping schemes. Its main task is determining the   size of the next time step and the according point in the time interval.   Additionally, it controls writing the solution to a file.     The size of the next time step is determined as follows:    [2.x.0]     [2.x.1]  According to the strategy, the step size is tentatively added to the   current time.    [2.x.2]  If the resulting time exceeds the final time of the interval, the   step size is reduced in order to meet this time.    [2.x.3]  If the resulting time is below the final time by just a fraction of   the step size, the step size is increased in order to meet this time.    [2.x.4]  The resulting step size is used from the current time.    [2.x.5]      The variable  [2.x.6]  can be used to control the amount of output   generated by the timestepping scheme.    
*  [2.x.7]  Many of the features of this class are available in DiscreteTime   with a more modern interface and better programming guarantees. Consider   using DiscreteTime instead of TimestepControl.  
* [0.x.1]*
     Constructor setting default values    
* [0.x.2]*
     Declare the control parameters for parameter handler.    
* [0.x.3]*
     Read the control parameters from a parameter handler.         This function also calls restart() to reset all other internal     parameters of this class to their appropriate values based on     the parameters just read.    
* [0.x.4]*
     Return the left end of the time interval.    
* [0.x.5]*
     Return the right end of the time interval. The control mechanism     ensures that the final time step ends at this point.    
* [0.x.6]*
     Return the tolerance value controlling the time steps.    
* [0.x.7]*
     Return the size of the current time step.    
* [0.x.8]*
     Return the current time.    
* [0.x.9]*
     Compute the size of the next step and return true if it differs from     the current step size. Advance the current time by the new step size.    
* [0.x.10]*
     Set start value.    
* [0.x.11]*
     Set final time value.    
* [0.x.12]*
     Set tolerance    
* [0.x.13]*
     Set size of the first step. This may be overwritten by the time     stepping strategy.          [2.x.8]  step The size of the first step, which may be overwritten by     the time stepping strategy.    
* [0.x.14]*
     Set size of the maximum step size.    
* [0.x.15]*
     Set now() equal to start(). Initialize step() and print() to their     initial values.    
* [0.x.16]*
     Return true if this timestep should be written to disk.    
* [0.x.17]*
     The beginning of the time interval.    
* [0.x.18]*
    The end of the time interval.    
* [0.x.19]*
     The tolerance value controlling the time steps.    
* [0.x.20]*
     The size of the first step.    
* [0.x.21]*
     The maximum step size.    
* [0.x.22]*
     The minimum step size.    
* [0.x.23]*
     The size of the current time step. This may differ from  [2.x.9]  if     we aim at  [2.x.10]     
* [0.x.24]*
     The size of the current time step determined by the strategy. This may     differ from  [2.x.11]  if we aim at  [2.x.12]     
* [0.x.25]*
     The current time.    
* [0.x.26]*
     Determines the approximate time interval between generated outputs.     If negative, output will be generated at all time steps.    
* [0.x.27]*
     If current time exceeds this value, it is time to generate the output.    
* [0.x.28]