[0.x.0]*
     This struct contains all the information we need to store about each of     the global entries (global_row): are they obtained directly by some local     entry (local_row) or some constraints (constraint_position). This is not     directly used in the user code, but accessed via the GlobalRowsFromLocal.         The actions performed here correspond to reshaping the constraint     information from global degrees of freedom to local ones (i.e.,     cell-related DoFs), and also transforming the constraint information from     compressed row storage (each local dof that is constrained has a list of     constraint entries associated to it) into compressed column storage based     on the cell-related DoFs (we have a list of global degrees of freedom,     and to each we have a list of local rows where the entries come from). To     increase the speed, we additionally store whether an entry is generated     directly from the local degrees of freedom or whether it comes from a     constraint.    
* [0.x.1]*
     This class represents a cache for constraints that are encountered on a     local level. The functionality is similar to      [2.x.0]  > >, but tuned so that     frequent memory allocation for each entry is avoided. The data is put     into a  [2.x.1]  > and the row length is kept     fixed at row_length. Both the number of rows and the row length can     change is this structure is filled. In that case, the data is     rearranged. This is not directly used in the user code, but accessed     via the GlobalRowsFromLocal.    
* [0.x.2]*
     A data structure that collects all the global rows from a local     contribution (cell) and their origin (direct/constraint). This     is basically a vector consisting of "Distributing" structs     using access via the DataCache. The structure provides some     specialized sort and insert functions.         In case there are no constraints, this is basically a list of pairs     `<uint,uint>` with the first index being the global index and the second     index the local index. The list is sorted with respect to the global     index.         In case there are constraints, a global dof might get a contribution also     because it gets data from a constrained dof. This means that a global dof     might also have indirect contributions from a local dof via a constraint,     besides the direct ones.         The actions performed here correspond to reshaping the constraint     information from global degrees of freedom to local ones (i.e.,     cell-related DoFs), and also transforming the constraint information from     compressed row storage (each local dof that is constrained has a list of     constraint entries associated to it) into compressed column storage based     on the cell-related DoFs (we have a list of global degrees of freedom,     and to each we have a list of local rows where the entries come from). To     increase the speed, we additionally store whether an entry is generated     directly from the local degrees of freedom or whether it comes from a     constraint.    
* [0.x.3]*
       Constructor.      
* [0.x.4]*
       Return the number of global indices in the struct.      
* [0.x.5]*
       Return the number of constraints that are associated to the       counter_index-th entry in the list.      
* [0.x.6]*
       Return the global row of the counter_index-th entry in the list.      
* [0.x.7]*
       Return the global row of the counter_index-th entry in the list.      
* [0.x.8]*
       Return the local row in the cell matrix associated with the       counter_index-th entry in the list. Return invalid_size_type for       constrained rows.      
* [0.x.9]*
       Return a reference instead of the value as in the function above.      
* [0.x.10]*
       Return the local row in the cell matrix associated with the       counter_index-th entry in the list in the index_in_constraint-th       position of constraints.      
* [0.x.11]*
       Return the value of the constraint in the counter_index-th entry in       the list in the index_in_constraint-th position of constraints.      
* [0.x.12]*
       Return whether there is one row with indirect contributions (i.e.,       there has been at least one constraint with non-trivial       ConstraintLine).      
* [0.x.13]*
       Append an entry that is constrained. This means that there is one less       nontrivial row.      
* [0.x.14]*
       Return the number of constrained dofs in the structure. Constrained       dofs do not contribute directly to the matrix, but are needed in order       to set matrix diagonals and resolve inhomogeneities.      
* [0.x.15]*
       Return the number of constrained dofs in the structure that have an       inhomogeneity.      
* [0.x.16]*
       This function tells the structure that the ith constraint is       inhomogeneous. inhomogeneous constraints contribute to right hand       sides, so to have fast access to them, put them before homogeneous       constraints.      
* [0.x.17]*
       The local row where constraint number i was detected, to find that row       easily when the GlobalRowsToLocal has been set up.      
* [0.x.18]*
       A vector that contains all the global ids and the corresponding local       ids as well as a pointer to that data where we store how to resolve       constraints.      
* [0.x.19]*
       A data structure that holds the actual data from the constraints.      
* [0.x.20]*
       A number that states how many rows there are, constraints       disregarded.      
* [0.x.21]*
       A number that represents the number of rows with       inhomogeneous constraints.      
* [0.x.22]*
     Scratch data that is used during calls to distribute_local_to_global and     add_entries_local_to_global. In order to avoid frequent memory     allocation, we keep the data alive from one call to the next in a static     variable. Since we want to allow for different number types in matrices,     this is a template.         Since each thread gets its private version of scratch data out of a     ThreadLocalStorage, no conflicting access can occur. For this to be     valid, we need to make sure that no call within     distribute_local_to_global is made that by itself can spawn tasks.     Otherwise, we might end up in a situation where several threads fight for     the data.         Access to the scratch data is only through an accessor class which     handles the access as well as marks the data as used.    
* [0.x.23]*
       Constructor, does nothing.      
* [0.x.24]*
       Copy constructor, does nothing      
* [0.x.25]*
       Stores whether the data is currently in use.      
* [0.x.26]*
       Temporary array for column indices      
* [0.x.27]*
       Temporary array for column values      
* [0.x.28]*
       Temporary array for block start indices      
* [0.x.29]*
       Temporary array for vector indices      
* [0.x.30]*
       Temporary array for vector values      
* [0.x.31]*
       Data array for reorder row/column indices.      
* [0.x.32]*
       Data array for reorder row/column indices.      
* [0.x.33]*
 This class implements dealing with linear (possibly inhomogeneous) constraints on degrees of freedom. The concept and origin of such constraints is extensively described in the  [2.x.2]  module. The class is meant to deal with a limited number of constraints relative to the total number of degrees of freedom, for example a few per cent up to maybe 30 per cent; and with a linear combination of [1.x.0] other degrees of freedom where [1.x.1] is also relatively small (no larger than at most around the average number of entries per row of a linear system). It is  [2.x.3] not [2.x.4]  meant to describe full rank linear systems.
*  The algorithms used in the implementation of this class are described in some detail in the  [2.x.5]  "hp-paper". There is also a significant amount of documentation on how to use this class in the  [2.x.6]  module.
* 

*  [1.x.2]
*  Each "line" in objects of this class corresponds to one constrained degree of freedom, with the number of the line being [1.x.3], entered by using add_line() or add_lines(). The entries in this line are pairs of the form ([1.x.4],[1.x.5]), which are added by add_entry() or add_entries(). The organization is essentially a SparsityPattern, but with only a few lines containing nonzero elements, and  therefore no data wasted on the others. For each line, which has been added by the mechanism above, an elimination of the constrained degree of freedom of the form [1.x.6] is performed, where [1.x.7] is optional and set by set_inhomogeneity(). Thus, if a constraint is formulated for instance as a zero mean value of several degrees of freedom, one of the degrees has to be chosen to be eliminated.
*  Note that the constraints are linear in the [1.x.8], and that there might be a constant (non-homogeneous) term in the constraint. This is exactly the form we need for hanging node constraints, where we need to constrain one degree of freedom in terms of others. There are other conditions of this form possible, for example for implementing mean value conditions as is done in the  [2.x.7]  tutorial program. The name of the class stems from the fact that these constraints can be represented in matrix form as [1.x.9] [1.x.10] = [1.x.11], and this object then describes the matrix [1.x.12] and the vector [1.x.13]. The most frequent way to create/fill objects of this type is using the  [2.x.8]  function. The use of these objects is first explained in  [2.x.9] .
*  Objects of the present type are organized in lines (rows), but only those lines are stored where constraints are present. New constraints are added by adding new lines using the add_line() function, and then populating it using the add_entry() function to a given line, or add_entries() to add more than one entry at a time. The right hand side element, if nonzero, can be set using the set_inhomogeneity() function. After all constraints have been added, you need to call close(), which compresses the storage format and sorts the entries.
* 

* 
*  [2.x.10]  Many of the algorithms this class implements are discussed in the  [2.x.11] . The algorithms are also related to those shown in [1.x.14], with the difference that the algorithms shown there completely eliminated constrained degrees of freedom, whereas we usually keep them as part of the linear system.
* 

* 
*  [2.x.12] 

* 
*  [2.x.13] 

* 
* [0.x.34]*
   Declare the type for container size.  
* [0.x.35]*
   An enum that describes what should happen if the two AffineConstraints   objects involved in a call to the merge() function happen to have   constraints on the same degrees of freedom.  
* [0.x.36]*
     Throw an exception if the two objects concerned have conflicting     constraints on the same degree of freedom.    
* [0.x.37]*
     In an operation  [2.x.14]  and      [2.x.15]  have constraints on the same degree of freedom, take     the one from  [2.x.16] .    
* [0.x.38]*
     In an operation  [2.x.17]  and      [2.x.18]  have constraints on the same degree of freedom, take     the one from  [2.x.19] .    
* [0.x.39]*
   Constructor. The supplied IndexSet defines which indices might be   constrained inside this AffineConstraints container. In a calculation   with a DoFHandler object based on  [2.x.20]    or  [2.x.21]  one should use the set of locally   relevant dofs (see    [2.x.22] ).     The given IndexSet allows the AffineConstraints container to save   memory by just not caring about degrees of freedom that are not of   importance to the current processor. Alternatively, if no such   IndexSet is provided, internal data structures for [1.x.15] possible   indices will be created, leading to memory consumption on every   processor that is proportional to the [1.x.16] size of the   problem, not just proportional to the size of the portion of the   overall problem that is handled by the current processor.  
* [0.x.40]*
   Copy constructor  
* [0.x.41]*
   Move constructor  
* [0.x.42]*
   Copy operator. Like for many other large objects, this operator   is deleted to avoid its inadvertent use in places such as   accidentally declaring a  [2.x.23]  object as a   function argument by value, rather than by reference.     However, you can use the copy_from() function to explicitly   copy AffineConstraints objects.  
* [0.x.43]*
   Move assignment operator  
* [0.x.44]*
   Copy the given object to the current one.     This function exists because  [2.x.24]  is explicitly   disabled.  
* [0.x.45]*
   clear() the AffineConstraints object and supply an IndexSet with lines   that may be constrained. This function is only relevant in the   distributed case to supply a different IndexSet. Otherwise this routine   is equivalent to calling clear(). See the constructor for details.  
* [0.x.46]*
   Determines if we can store a constraint for the given  [2.x.25]  This   routine only matters in the distributed case and checks if the IndexSet   allows storage of this line. Always returns true if not in the   distributed case.  
* [0.x.47]*
   Return the index set describing locally relevant lines if any are   present. Note that if no local lines were given, this represents an empty   IndexSet, whereas otherwise it contains the global problem size and the   local range.  
* [0.x.48]*
   This function copies the content of  [2.x.26]  with DoFs that are   element of the IndexSet  [2.x.27]  Elements that are not present in the   IndexSet are ignored. All DoFs will be transformed to local index space   of the filter, both the constrained DoFs and the other DoFs these entries   are constrained to. The local index space of the filter is a contiguous   numbering of all (global) DoFs that are elements in the filter.     If, for example, the filter represents the range <tt>[10,20)</tt>, and   the constraints object  [2.x.28]  includes the global indices   <tt>{7,13,14}</tt>, the indices <tt>{3,4}</tt> are added to the calling   constraints object (since 13 and 14 are elements in the filter and element   13 is the fourth element in the index, and 14 is the fifth).     This function provides an easy way to create a AffineConstraints for   certain vector components in a vector-valued problem from a full   AffineConstraints, i.e. extracting a diagonal subblock from a larger   AffineConstraints. The block is specified by the IndexSet argument.  
* [0.x.49]*
    [2.x.29]  Adding constraints    [2.x.30]   
* [0.x.50]*
   Add a new line to the matrix. If the line already exists, then the   function simply returns without doing anything.  
* [0.x.51]*
   Call the first add_line() function for every index  [2.x.31]  for   which  [2.x.32]  is true.     This function essentially exists to allow adding several constraints of   the form [1.x.17]=0 all at once, where the set of indices   [1.x.18] for which these constraints should be added are given by the   argument of this function. On the other hand, just as if the single-   argument add_line() function were called repeatedly, the constraints can   later be modified to include linear dependencies using the add_entry()   function as well as inhomogeneities using set_inhomogeneity().  
* [0.x.52]*
   Call the first add_line() function for every index  [2.x.33]  that   appears in the argument.     This function essentially exists to allow adding several constraints of   the form [1.x.19]=0 all at once, where the set of indices   [1.x.20] for which these constraints should be added are given by the   argument of this function. On the other hand, just as if the single-   argument add_line() function were called repeatedly, the constraints can   later be modified to include linear dependencies using the add_entry()   function as well as inhomogeneities using set_inhomogeneity().  
* [0.x.53]*
   Call the first add_line() function for every index  [2.x.34]  that   appears in the argument.     This function essentially exists to allow adding several constraints of   the form [1.x.21]=0 all at once, where the set of indices   [1.x.22] for which these constraints should be added are given by the   argument of this function. On the other hand, just as if the single-   argument add_line() function were called repeatedly, the constraints can   later be modified to include linear dependencies using the add_entry()   function as well as inhomogeneities using set_inhomogeneity().  
* [0.x.54]*
   Add an entry to a given line. In other words, this function adds   a term  [2.x.35]  to the constraints for the  [2.x.36] th degree of freedom.     If an entry with the same indices as the one this function call denotes   already exists, then this function simply returns provided that the value   of the entry is the same. Thus, it does no harm to enter a constraint   twice.      [2.x.37]  constrained_dof_index The index  [2.x.38]  of the degree of freedom     that is being constrained.    [2.x.39]  column The index  [2.x.40]  of the degree of freedom being entered     into the constraint for degree of freedom  [2.x.41] .    [2.x.42]  weight The factor  [2.x.43]  that multiplies  [2.x.44] .  
* [0.x.55]*
   Add a whole series of entries, denoted by pairs of column indices and   weight values, to a line of constraints. This function is equivalent to   calling the preceding function several times, but is faster.  
* [0.x.56]*
   Set an inhomogeneity to the constraint for a degree of freedom. In other   words, it adds a constant  [2.x.45]  to the constraint for degree of freedom    [2.x.46] . For this to work, you need to call add_line() first for the given   degree of freedom.      [2.x.47]  constrained_dof_index The index  [2.x.48]  of the degree of freedom     that is being constrained.    [2.x.49]  value The right hand side value  [2.x.50]  for the constraint on     the degree of freedom  [2.x.51] .  
* [0.x.57]*
   Close the filling of entries. Since the lines of a matrix of this type   are usually filled in an arbitrary order and since we do not want to use   associative constrainers to store the lines, we need to sort the lines   and within the lines the columns before usage of the matrix. This is done   through this function.     Also, zero entries are discarded, since they are not needed.     After closing, no more entries are accepted. If the object was already   closed, then this function returns immediately.     This function also resolves chains of constraints. For example, degree of   freedom 13 may be constrained to  [2.x.52]    while degree of freedom 7 is itself constrained as  [2.x.53] . Then, the resolution will be that  [2.x.54] . Note, however, that   cycles in this graph of constraints are not allowed, i.e., for example    [2.x.55]  may not itself be constrained, directly or indirectly, to  [2.x.56]    again.  
* [0.x.58]*
   Merge the constraints represented by the object given as argument into   the constraints represented by this object. Both objects may or may not   be closed (by having their function close() called before). If this   object was closed before, then it will be closed afterwards as well.   Note, however, that if the other argument is closed, then merging may be   significantly faster.     Using the default value of the second arguments, the constraints in each   of the two objects (the old one represented by this object and the   argument) may not refer to the same degree of freedom, i.e. a degree of   freedom that is constrained in one object may not be constrained in the   second. If this is nevertheless the case, an exception is thrown.   However, this behavior can be changed by providing a different value for   the second argument.     By default, merging two AffineConstraints objects that are initialized   with different IndexSet objects is not allowed.   This behavior can be altered by setting  [2.x.57]    appropriately.     Merging a AffineConstraints that is initialized with an IndexSet   and one that is not initialized with an IndexSet is not yet implemented.  
* [0.x.59]*
   Shift all entries of this matrix down  [2.x.58]  rows and over  [2.x.59]    columns. If this object is initialized with an IndexSet, local_lines are   shifted as well.     This function is useful if you are building block matrices, where all   blocks are built by the same DoFHandler object, i.e. the matrix size is   larger than the number of degrees of freedom. Since several matrix rows   and columns correspond to the same degrees of freedom, you'd generate   several constraint objects, then shift them, and finally merge() them   together again.  
* [0.x.60]*
   Clear all entries of this matrix. Reset the flag determining whether new   entries are accepted or not.     This function may be called also on objects which are empty or already   cleared.  
* [0.x.61]*
    [2.x.60]   
* [0.x.62]*
    [2.x.61]  Querying constraints    [2.x.62]   
* [0.x.63]*
   Return number of constraints stored in this matrix.  
* [0.x.64]*
   Return whether the degree of freedom with number  [2.x.63]  is a   constrained one.     Note that if close() was called before, then this function is   significantly faster, since then the constrained degrees of freedom are   sorted and we can do a binary search, while before close() was called, we   have to perform a linear search through all entries.  
* [0.x.65]*
   Return whether the dof is constrained, and whether it is constrained to   only one other degree of freedom with weight one. The function therefore   returns whether the degree of freedom would simply be eliminated in favor   of exactly one other degree of freedom.     The function returns  [2.x.64]  if either the degree of freedom is not   constrained at all, or if it is constrained to more than one other degree   of freedom, or if it is constrained to only one degree of freedom but   with a weight different from one.  
* [0.x.66]*
   Return whether the two given degrees of freedom are linked by an equality   constraint that either constrains index1 to be so that    [2.x.65]  or constrains index2 so that    [2.x.66] .  
* [0.x.67]*
   Return the maximum number of other dofs that one dof is constrained to.   For example, in 2d a hanging node is constrained only to its two   neighbors, so the returned value would be 2. However, for higher order   elements and/or higher dimensions, or other types of constraints, this   number is no more obvious.     The name indicates that within the system matrix, references to a   constrained node are indirected to the nodes it is constrained to.  
* [0.x.68]*
   Return <tt>true</tt> in case the dof is constrained and there is a non-   trivial inhomogeneous values set to the dof.  
* [0.x.69]*
   Return <tt>false</tt> if all constraints in the AffineConstraints are   homogeneous ones, and <tt>true</tt> if there is at least one   inhomogeneity.  
* [0.x.70]*
   Return a pointer to the vector of entries if a line is constrained,   and a zero pointer in case the dof is not constrained.  
* [0.x.71]*
   Return the value of the inhomogeneity stored in the constrained dof  [2.x.67]    line_n. Unconstrained dofs also return a zero value.  
* [0.x.72]*
   Print the constraints represented by the current object to the   given stream.     For each constraint of the form   [1.x.23]   this function will write a sequence of lines that look like this:  
* [1.x.24]
*    The last line is only shown if the inhomogeneity (here: 2.75) is   nonzero.     A block of lines such as the one above is repeated for each   constrained degree of freedom.  
* [0.x.73]*
   Write the graph of constraints in 'dot' format. 'dot' is a program that   can take a list of nodes and produce a graphical representation of the   graph of constrained degrees of freedom and the degrees of freedom they   are constrained to.     The output of this function can be used as input to the 'dot' program   that can convert the graph into a graphical representation in postscript,   png, xfig, and a number of other formats.     This function exists mostly for debugging purposes.  
* [0.x.74]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.75]*
   Add the constraint indices associated to the indices in the given vector.   After a call to this function, the indices vector contains the initial   elements and all the associated constrained indices. This function sorts   the elements and suppresses duplicates.  
* [0.x.76]*
    [2.x.68]   
* [0.x.77]*
    [2.x.69]  Eliminating constraints from linear systems after their creation    [2.x.70]   
* [0.x.78]*
   Condense a sparsity pattern. The name of the function mimics the name of   the function we use to condense linear systems, but it is a bit of a   misnomer for the current context. This is because in the context of   linear systems, we eliminate certain rows and columns of the linear   system, i.e., we "reduce" or "condense" the linear system. On the other   hand, in the current context, the functions does not remove nonzero   entries from the sparsity pattern. Rather, it adds those nonzero entry   locations to the sparsity pattern that will later be needed for the   process of condensation of constrained degrees of freedom from a linear   system.     Since this function adds new nonzero entries to the sparsity pattern, the   given sparsity pattern must not be compressed. The current object must be   closed. The sparsity pattern is compressed at the end of the function.  
* [0.x.79]*
   Same function as above, but condenses square block sparsity patterns.  
* [0.x.80]*
   Same function as above, but condenses square compressed sparsity   patterns.  
* [0.x.81]*
   Same function as above, but condenses square compressed sparsity   patterns.  
* [0.x.82]*
   Condense a given matrix, i.e., eliminate the rows and columns of the   matrix that correspond to constrained degrees of freedom.     See the general documentation of this class for more detailed   information.  
* [0.x.83]*
   Same function as above, but condenses square block sparse matrices.  
* [0.x.84]*
   Condense the given vector in-place. The  [2.x.71]  may be a   Vector<float>, Vector<number>, BlockVector<tt><...></tt>, a PETSc or   Trilinos vector wrapper class, or any other type having the same   interface. Note that this function does not take any inhomogeneity into   account and throws an exception in case there are any inhomogeneities.   Use the function using both a matrix and vector for that case.    
*  [2.x.72]  This function does not work for MPI vectors. Use condense() with   two vector arguments instead.  
* [0.x.85]*
   The function copies and condenses values from  [2.x.73]  into  [2.x.74]    output. In a serial code it is equivalent to calling condense (vec). If   called in parallel,  [2.x.75]  is supposed to contain ghost elements   while  [2.x.76]  should not.  
* [0.x.86]*
   Condense a given matrix and a given vector by eliminating rows and   columns of the linear system that correspond to constrained degrees of   freedom. The sparsity pattern associated with the matrix needs to be   condensed and compressed.  This function is the appropriate choice for   applying inhomogeneous constraints.     The current object must be closed to call this function.     See the general documentation of this class for more detailed   information.  
* [0.x.87]*
   Same function as above, but condenses square block sparse matrices and   vectors.  
* [0.x.88]*
   Set the values of all constrained DoFs in a vector to zero.  The  [2.x.77]    VectorType may be a Vector<float>, Vector<number>,   BlockVector<tt><...></tt>, a PETSc or Trilinos vector wrapper class, or   any other type having the same interface.  
* [0.x.89]*
    [2.x.78]   
* [0.x.90]*
    [2.x.79]  Eliminating constraints from linear systems during their creation    [2.x.80]   
* [0.x.91]*
   This function takes a vector of local contributions ( [2.x.81]    corresponding to the degrees of freedom indices given in  [2.x.82]    local_dof_indices and distributes them to the global vector. In other   words, this function implements a   [scatter   operation](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)).   In most   cases, these local contributions will be the result of an integration   over a cell or face of a cell. However, as long as  [2.x.83]  and  [2.x.84]    local_dof_indices have the same number of elements, this function is   happy with whatever it is given.     In contrast to the similar function in the DoFAccessor class, this   function also takes care of constraints, i.e. if one of the elements of    [2.x.85]  belongs to a constrained node, then rather than   writing the corresponding element of  [2.x.86]  into  [2.x.87]    global_vector, the element is distributed to the entries in the global   vector to which this particular degree of freedom is constrained.     Thus, by using this function to distribute local contributions to the   global object, one saves the call to the condense function after the   vectors and matrices are fully assembled. On the other hand, by   consequence, the function does not only write into the entries enumerated   by the  [2.x.88]  array, but also (possibly) others as   necessary.     Note that this function will apply all constraints as if they were   homogeneous. For correctly setting inhomogeneous constraints, use the   similar function with a matrix argument or the function with both matrix   and vector arguments.    
*  [2.x.89]  This function in itself is thread-safe, i.e., it works properly   also when several threads call it simultaneously. However, the function   call is only thread-safe if the underlying global vector allows for   simultaneous access and the access is not to rows with the same global   index at the same time. This needs to be made sure from the caller's   site. There is no locking mechanism inside this method to prevent data   races.      [2.x.90]  local_vector Vector of local contributions.    [2.x.91]  local_dof_indices Local degrees of freedom indices   corresponding to the vector of local contributions.    [2.x.92]   global_vector The global vector to which all local   contributions will be added.  
* [0.x.92]*
   This function takes a vector of local contributions ( [2.x.93]    corresponding to the degrees of freedom indices given in  [2.x.94]    local_dof_indices and distributes them to the global vector. In other   words, this function implements a   [scatter   operation](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)).   In most   cases, these local contributions will be the result of an integration   over a cell or face of a cell. However, as long as  [2.x.95]  and  [2.x.96]    local_dof_indices have the same number of elements, this function is   happy with whatever it is given.     In contrast to the similar function in the DoFAccessor class, this   function also takes care of constraints, i.e. if one of the elements of    [2.x.97]  belongs to a constrained node, then rather than   writing the corresponding element of  [2.x.98]  into  [2.x.99]    global_vector, the element is distributed to the entries in the global   vector to which this particular degree of freedom is constrained.     Thus, by using this function to distribute local contributions to the   global object, one saves the call to the condense function after the   vectors and matrices are fully assembled. On the other hand, by   consequence, the function does not only write into the entries enumerated   by the  [2.x.100]  array, but also (possibly) others as   necessary. This includes writing into diagonal elements of the matrix if   the corresponding degree of freedom is constrained.     The fourth argument <tt>local_matrix</tt> is intended to be used in case   one wants to apply inhomogeneous constraints on the vector only. Such a   situation could be where one wants to assemble of a right hand side   vector on a problem with inhomogeneous constraints, but the global matrix   has been assembled previously. A typical example of this is a time   stepping algorithm where the stiffness matrix is assembled once, and the   right hand side updated every time step. Note that, however, the entries   in the columns of the local matrix have to be exactly the same as those   that have been written into the global matrix. Otherwise, this function   will not be able to correctly handle inhomogeneities.    
*  [2.x.101]  This function in itself is thread-safe, i.e., it works properly   also when several threads call it simultaneously. However, the function   call is only thread-safe if the underlying global vector allows for   simultaneous access and the access is not to rows with the same global   index at the same time. This needs to be made sure from the caller's   site. There is no locking mechanism inside this method to prevent data   races.  
* [0.x.93]*
   Same as the previous function, except that it uses two (possibly) different   index sets to correctly handle inhomogeneities when the local matrix is   computed from a combination of two neighboring elements, for example for an   edge integral term in DG. Note that in the case that these two elements   have different polynomial degree, the local matrix is rectangular.     <tt>local_dof_indices_row</tt> is the set of row indices and   <tt>local_dof_indices_col</tt> is the set of column indices of the local   matrix. <tt>diagonal=false</tt> says whether the two index sets are equal   or not.     If both index sets are equal, <tt>diagonal</tt> must be set to true or we   simply use the previous function. If both index sets are different   (diagonal=false) the <tt>global_vector</tt> is modified to handle   inhomogeneities but no entries from <tt>local_vector</tt> are added. Note   that the edge integrals for inner edged for DG do not contribute any values   to the right hand side.  
* [0.x.94]*
   Enter a single value into a result vector, obeying constraints.  
* [0.x.95]*
   This function takes a pointer to a vector of local contributions ( [2.x.102]    local_vector) corresponding to the degrees of freedom indices given in  [2.x.103]    local_dof_indices and distributes them to the global vector. In other   words, this function implements a   [scatter   operation](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)).   In most   cases, these local contributions will be the result of an integration   over a cell or face of a cell. However, as long as the entries in  [2.x.104]    local_dof_indices indicate reasonable global vector entries, this   function is happy with whatever it is given.     If one of the elements of  [2.x.105]  belongs to a constrained   node, then rather than writing the corresponding element of  [2.x.106]    local_vector into  [2.x.107]  the element is distributed to the   entries in the global vector to which this particular degree of freedom   is constrained.     Thus, by using this function to distribute local contributions to the   global object, one saves the call to the condense function after the   vectors and matrices are fully assembled. Note that this function   completely ignores inhomogeneous constraints.    
*  [2.x.108]  This function in itself is thread-safe, i.e., it works properly   also when several threads call it simultaneously. However, the function   call is only thread-safe if the underlying global vector allows for   simultaneous access and the access is not to rows with the same global   index at the same time. This needs to be made sure from the caller's   site. There is no locking mechanism inside this method to prevent data   races.  
* [0.x.96]*
   This function takes a matrix of local contributions ( [2.x.109]    corresponding to the degrees of freedom indices given in  [2.x.110]    local_dof_indices and distributes them to the global matrix. In other   words, this function implements a   [scatter   operation](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)).   In most   cases, these local contributions will be the result of an integration   over a cell or face of a cell. However, as long as  [2.x.111]  and  [2.x.112]    local_dof_indices have the same number of elements, this function is   happy with whatever it is given.     In contrast to the similar function in the DoFAccessor class, this   function also takes care of constraints, i.e. if one of the elements of    [2.x.113]  belongs to a constrained node, then rather than   writing the corresponding element of  [2.x.114]  into  [2.x.115]    global_matrix, the element is distributed to the entries in the global   matrix to which this particular degree of freedom is constrained.     With this scheme, we never write into rows or columns of constrained   degrees of freedom. In order to make sure that the resulting matrix can   still be inverted, we need to do something with the diagonal elements   corresponding to constrained nodes. Thus, if a degree of freedom in  [2.x.116]    local_dof_indices is constrained, we distribute the corresponding entries   in the matrix, but also add the absolute value of the diagonal entry of   the local matrix to the corresponding entry in the global matrix.   Assuming the discretized operator is positive definite, this guarantees   that the diagonal entry is always non-zero, positive, and of the same   order of magnitude as the other entries of the matrix. On the other hand,   when solving a source problem  [2.x.117]  the exact value of the diagonal   element is not important, since the value of the respective degree of   freedom will be overwritten by the distribute() call later on anyway.    
*  [2.x.118]  The procedure described above adds an unforeseeable number of   artificial eigenvalues to the spectrum of the matrix. Therefore, it is   recommended to use the equivalent function with two local index vectors   in such a case.     By using this function to distribute local contributions to the global   object, one saves the call to the condense function after the vectors and   matrices are fully assembled.    
*  [2.x.119]  This function in itself is thread-safe, i.e., it works properly   also when several threads call it simultaneously. However, the function   call is only thread-safe if the underlying global matrix allows for   simultaneous access and the access is not to rows with the same global   index at the same time. This needs to be made sure from the caller's   site. There is no locking mechanism inside this method to prevent data   races.  
* [0.x.97]*
   This function does almost the same as the function above but can treat   general rectangular matrices. The main difference to achieve this is that   the diagonal entries in constrained rows are left untouched instead of   being filled with arbitrary values.     Since the diagonal entries corresponding to eliminated degrees of freedom   are not set, the result may have a zero eigenvalue, if applied to a   square matrix. This has to be considered when solving the resulting   problems. For solving a source problem  [2.x.120] , it is possible to set the   diagonal entry after building the matrix by a piece of code of the form    
* [1.x.25]
*      The value of one which is used here is arbitrary, but in the context of   Krylov space methods uncritical, since it corresponds to an invariant   subspace. If the other matrix entries are smaller or larger by a factor   close to machine accuracy, it may be advisable to adjust it.     For solving eigenvalue problems, this will only add one spurious zero   eigenvalue (with a multiplicity that is possibly greater than one).   Taking this into account, nothing else has to be changed.  
* [0.x.98]*
   This function does almost the same as the function above for general   rectangular matrices but uses different AffineConstraints objects on the   row and column indices. The convention is that row indices are constrained   according to the calling AffineConstraints  [2.x.121] , whereas   column indices are constrained according to the given AffineConstraints    [2.x.122] . This function allows to handle the   case where rows and columns of a matrix are represented by different   function spaces with their own enumeration of indices, as e.g. in mixed   finite element problems with separate DoFHandler objects or for flux   matrices between different levels in multigrid methods.     Like the other method with separate slots for row and column indices,   this method does not add diagonal entries to eliminated degrees of   freedom. See there for a more elaborate description.  
* [0.x.99]*
   This function simultaneously writes elements into matrix and vector,   according to the constraints specified by the calling AffineConstraints.   In other words, it performs the   [scatter   operation](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing))   of the corresponding functions for matrices and vectors at the same time.   This function can correctly handle inhomogeneous constraints as well. For   the parameter use_inhomogeneities_for_rhs see the documentation in    [2.x.123]    module.    
*  [2.x.124]  This function in itself is thread-safe, i.e., it works properly   also when several threads call it simultaneously. However, the function   call is only thread-safe if the underlying global matrix and vector allow   for simultaneous access and the access is not to rows with the same   global index at the same time. This needs to be made sure from the   caller's site. There is no locking mechanism inside this method to   prevent data races.  
* [0.x.100]*
   Do a similar operation as the distribute_local_to_global() function that   distributes writing entries into a matrix for constrained degrees of   freedom, except that here we don't write into a matrix but only allocate   sparsity pattern entries.     As explained in the    [2.x.125]  "hp-paper"   and in  [2.x.126] , first allocating a sparsity pattern and later coming back   and allocating additional entries for those matrix entries that will be   written to due to the elimination of constrained degrees of freedom   (using  [2.x.127]  ), can be a very expensive procedure.   It is cheaper to allocate these entries right away without having to do a   second pass over the sparsity pattern object. This function does exactly   that.     Because the function only allocates entries in a sparsity pattern, all it   needs to know are the degrees of freedom that couple to each other.   Unlike the previous function, no actual values are written, so the second   input argument is not necessary here.     The third argument to this function, keep_constrained_entries determines   whether the function shall allocate entries in the sparsity pattern at   all for entries that will later be set to zero upon condensation of the   matrix. These entries are necessary if the matrix is built unconstrained,   and only later condensed. They are not necessary if the matrix is built   using the distribute_local_to_global() function of this class which   distributes entries right away when copying a local matrix into a global   object. The default of this argument is true, meaning to allocate the few   entries that may later be set to zero.     By default, the function adds entries for all pairs of indices given in   the first argument to the sparsity pattern (unless   keep_constrained_entries is false). However, sometimes one would like to   only add a subset of all of these pairs. In that case, the last argument   can be used which specifies a boolean mask which of the pairs of indices   should be considered. If the mask is false for a pair of indices, then no   entry will be added to the sparsity pattern for this pair, irrespective   of whether one or both of the indices correspond to constrained degrees   of freedom.     This function is not typically called from user code, but is used in the    [2.x.128]  function when passed an   AffineConstraints object.    
*  [2.x.129]  This function in itself is thread-safe, i.e., it works properly   also when several threads call it simultaneously. However, the function   call is only thread-safe if the underlying global sparsity pattern allows   for simultaneous access and the access is not to rows with the same   global index at the same time. This needs to be made sure from the   caller's site. There is no locking mechanism inside this method to   prevent data races.  
* [0.x.101]*
   Similar to the other function, but for non-quadratic sparsity patterns.  
* [0.x.102]*
   This function imports values from a global vector ( [2.x.130]  by   applying the constraints to a vector of local values, expressed in   iterator format.  In most cases, the local values will be identified by   the local dof values on a cell. However, as long as the entries in  [2.x.131]    local_dof_indices indicate reasonable global vector entries, this   function is happy with whatever it is given.     If one of the elements of  [2.x.132]  belongs to a constrained   node, then rather than writing the corresponding element of  [2.x.133]    global_vector into  [2.x.134]  the constraints are resolved as the   respective distribute function does, i.e., the local entry is constructed   from the global entries to which this particular degree of freedom is   constrained.     In contrast to the similar function get_dof_values in the DoFAccessor   class, this function does not need the constrained values to be correctly   set (i.e., distribute to be called).  
* [0.x.103]*
    [2.x.135]   
* [0.x.104]*
    [2.x.136]  Dealing with constraints after solving a linear system    [2.x.137]   
* [0.x.105]*
   Given a vector, set all constrained degrees of freedom to values so   that the constraints are satisfied. For example, if the current object   stores the constraint  [2.x.138] , then this   function will read the values of  [2.x.139]  and  [2.x.140]  from the given vector   and set the element  [2.x.141]  according to this constraints. Similarly, if   the current object stores the constraint  [2.x.142] , then this   function will set the 42nd element of the given vector to 208.    
*  [2.x.143]  If this function is called with a parallel vector  [2.x.144]  then the   vector must not contain ghost elements.  
* [0.x.106]*
    [2.x.145]   
* [0.x.107]*
   This class represents one constraint in an AffineConstraints object.  
* [0.x.108]*
     A data type in which we store the list of entries that make up the     homogeneous part of a constraint.    
* [0.x.109]*
     Global DoF index of this line. Since only very few lines are stored,     we can not assume a specific order and have to store the index     explicitly.    
* [0.x.110]*
     Row numbers and values of the entries in this line.         For the reason why we use a vector instead of a map and the     consequences thereof, the same applies as what is said for      [2.x.146]     
* [0.x.111]*
     Value of the inhomogeneity.    
* [0.x.112]*
     Default constructor.    
* [0.x.113]*
     Copy constructor.    
* [0.x.114]*
     Copy assignment.    
* [0.x.115]*
     This operator is a bit weird and unintuitive: it compares the line     numbers of two lines. We need this to sort the lines; in fact we could     do this using a comparison predicate.  However, this way, it is easier,     albeit unintuitive since two lines really have no god-given order     relation.    
* [0.x.116]*
     This operator is likewise weird: it checks whether the line indices of     the two operands are equal, irrespective of the fact that the contents     of the line may be different.    
* [0.x.117]*
     Determine an estimate for the memory consumption (in bytes) of this     object.    
* [0.x.118]*
     Write and read the data of this object from a stream for the purpose     of serialization using the [BOOST serialization     library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).    
* [0.x.119]*
   Alias for the iterator type that is used in the LineRange container.  
* [0.x.120]*
   Alias for the return type used by get_lines().  
* [0.x.121]*
   Return a range object containing (const) iterators to all line entries   stored in the AffineConstraints container. Such a range is useful to   initialize range-based for loops as supported by C++11.      [2.x.147]  A range object for the half open range <code>[this->begin(),   this->end())</code> of line entries.  
* [0.x.122]*
   Check if the current object is consistent on all processors   in a distributed computation.     This method checks if all processors agree on the constraints for their   local lines as given by  [2.x.148]  This method is a collective   operation and will return  [2.x.149]  only if all processors are consistent.     Please supply the owned DoFs per processor as returned by    [2.x.150]   [2.x.151]  as    [2.x.152]  and the result of    [2.x.153]  as    [2.x.154]  The former is used to determine ownership of the   specific DoF, while the latter is used as the set of rows that need to be   checked.     If  [2.x.155]  is set to  [2.x.156]  additional debug information is written   to  [2.x.157]     
*  [2.x.158]  This method exchanges all constraint information of locally active   lines and is as such slow for large computations and should probably   only be used in debug mode. We do not check all lines returned by   get_local_lines() but only the locally active ones, as we allow processors   to not know about some locally relevant rows.      [2.x.159]  Whether all AffineConstraints objects are consistent. Returns   the same value on all processors.  
* [0.x.123]*
   Exception    
*  [2.x.160]   
* [0.x.124]*
   Exception    
*  [2.x.161]   
* [0.x.125]*
   Exception    
*  [2.x.162]   
* [0.x.126]*
   Exception    
*  [2.x.163]   
* [0.x.127]*
   Exception    
*  [2.x.164]   
* [0.x.128]*
   Exception.    
*  [2.x.165]   
* [0.x.129]*
   Exception    
*  [2.x.166]   
* [0.x.130]*
   Exception    
*  [2.x.167]   
* [0.x.131]*
   Exception    
*  [2.x.168]   
* [0.x.132]*
   Exception    
*  [2.x.169]   
* [0.x.133]*
   Store the lines of the matrix.  Entries are usually appended in an   arbitrary order and insertion into a vector is done best at the end, so   the order is unspecified after all entries are inserted. Sorting of the   entries takes place when calling the <tt>close()</tt> function.     We could, instead of using a vector, use an associative array, like a map   to store the lines. This, however, would mean a much more fragmented heap   since it allocates many small objects, and would additionally make usage   of this matrix much slower.  
* [0.x.134]*
   A list of size_type that contains the position of the ConstraintLine of a   constrained degree of freedom, or  [2.x.170]  if the   degree of freedom is not constrained. The  [2.x.171]    return value returns thus whether there is a constraint line for a given   degree of freedom index. Note that this class has no notion of how many   degrees of freedom there really are, so if we check whether there is a   constraint line for a given degree of freedom, then this vector may   actually be shorter than the index of the DoF we check for.     This field exists since when adding a new constraint line we have to   figure out whether it already exists. Previously, we would simply walk   the unsorted list of constraint lines until we either hit the end or   found it. This algorithm is O(N) if N is the number of constraints, which   makes it O(N^2) when inserting all constraints. For large problems with   many constraints, this could easily take 5-10 per cent of the total run   time. With this field, we can save this time since we find any constraint   in O(1) time or get to know that it a certain degree of freedom is not   constrained.     To make things worse, traversing the list of existing constraints   requires reads from many different places in memory. Thus, in large 3d   applications, the add_line() function showed up very prominently in the   overall compute time, mainly because it generated a lot of cache misses.   This should also be fixed by using the O(1) algorithm to access the   fields of this array.     The field is useful in a number of other contexts as well, e.g. when one   needs random access to the constraints as in all the functions that apply   constraints on the fly while add cell contributions into vectors and   matrices.  
* [0.x.135]*
   This IndexSet is used to limit the lines to save in the AffineConstraints   to a subset. This is necessary, because the lines_cache vector would   become too big in a distributed calculation.  
* [0.x.136]*
   Store whether the arrays are sorted.  If so, no new entries can be added.  
* [0.x.137]*
   Internal function to calculate the index of line  [2.x.172]  in the vector   lines_cache using local_lines.  
* [0.x.138]*
   This function actually implements the local_to_global function for   standard (non-block) matrices.  
* [0.x.139]*
   This function actually implements the local_to_global function for block   matrices.  
* [0.x.140]*
   This function actually implements the local_to_global function for   standard (non-block) sparsity types.  
* [0.x.141]*
   This function actually implements the local_to_global function for block   sparsity types.  
* [0.x.142]*
   Internal helper function for distribute_local_to_global function.     Creates a list of affected global rows for distribution, including the   local rows where the entries come from. The list is sorted according to   the global row indices.  
* [0.x.143]*
   Internal helper function for add_entries_local_to_global function.     Creates a list of affected rows for distribution without any additional   information, otherwise similar to the other make_sorted_row_list()   function.  
* [0.x.144]*
   Internal helper function for distribute_local_to_global function.  
* [0.x.145]*
     A "traits" class that can be used to determine whether a given type is a     block matrix type or not. For example,    
* [1.x.26]
*      has the value `false`, whereas    
* [1.x.27]
*      is true. This is sometimes useful in template contexts where we may want     to do things differently depending on whether a template type denotes a     regular or a block matrix type.          [2.x.173]       [2.x.174]  "Block (linear algebra)"    
* [0.x.146]*
       Overload returning true if the class is derived from BlockMatrixBase,       which is what block matrices do (with the exception of       BlockSparseMatrixEZ).      
* [0.x.147]*
       Overload for BlockSparseMatrixEZ, which is the only block matrix not       derived from BlockMatrixBase at the time of writing this class.      
* [0.x.148]*
       Catch all for all other potential types that are then apparently not       block matrices.      
* [0.x.149]*
       A statically computable value that indicates whether the template       argument to this class is a block matrix (in fact whether the type is       derived from BlockMatrixBase<T> or is one of the other block matrix       types).      
* [0.x.150]*
     A class that can be used to determine whether a given type is a block     sparsity pattern type or not. In this, it matches the IsBlockMatrix     class.          [2.x.175]       [2.x.176]  "Block (linear algebra)"    
* [0.x.151]*
       Overload returning true if the class is derived from       BlockSparsityPatternBase, which is what block sparsity patterns do.      
* [0.x.152]*
       Catch all for all other potential types that are then apparently not       block sparsity patterns.      
* [0.x.153]*
       A statically computable value that indicates whether the template       argument to this class is a block sparsity pattern (in fact whether the       type is derived from BlockSparsityPatternBase<T>).      
* [0.x.154]