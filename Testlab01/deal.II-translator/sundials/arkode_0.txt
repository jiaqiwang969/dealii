[0.x.0]*
 A namespace for dealing with ODE solvers through the SUNDIALS package.

* 
* [0.x.1]*
   Interface to SUNDIALS additive Runge-Kutta methods (ARKode).     The class ARKode is a wrapper to SUNDIALS variable-step, embedded,   additive Runge-Kutta solver which is a general purpose solver for systems   of ordinary differential equations characterized by the presence of both   fast and slow dynamics.     Fast dynamics are treated implicitly, and slow dynamics are treated   explicitly, using nested families of implicit and explicit Runge-Kutta   solvers.     Citing directly from ARKode documentation:     ARKode solves ODE initial value problems (IVPs) in  [2.x.0] . These problems   should be posed in explicit form as     [1.x.0]     Here,  [2.x.1]  is the independent variable (e.g. time), and the dependent   variables are given by  [2.x.2] , and we use notation  [2.x.3]  to denote    [2.x.4] .  [2.x.5]  is a user-supplied nonsingular operator from  [2.x.6] .   This operator may depend on  [2.x.7]  but not on  [2.x.8] .     For standard systems of ordinary differential equations and for problems   arising from the spatial semi-discretization of partial differential   equations using finite difference or finite volume methods,  [2.x.9]  is   typically the identity matrix,  [2.x.10] . For PDEs using a finite-element   spatial semi-discretization  [2.x.11]  is typically a well-conditioned mass   matrix.     The two right-hand side functions may be described as:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.12] : contains the "slow" time scale components of the system.                  This will be integrated using explicit methods.
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.13] : contains the "fast" time scale components of the system.                  This will be integrated using implicit methods.     ARKode may be used to solve stiff, nonstiff and multi-rate problems.   Roughly speaking, stiffness is characterized by the presence of at least   one rapidly damped mode, whose time constant is small compared to the time   scale of the solution itself. In the implicit/explicit (ImEx) splitting   above, these stiff components should be included in the right-hand side   function  [2.x.14] .     For multi-rate problems, a user should provide both of the functions  [2.x.15]    and  [2.x.16]  that define the IVP system.     For nonstiff problems, only  [2.x.17]  should be provided, and  [2.x.18]  is assumed   to be zero, i.e. the system reduces to the non-split IVP:     [1.x.1]     In this scenario, the ARK methods reduce to classical explicit Runge-Kutta   methods (ERK). For these classes of methods, ARKode allows orders of   accuracy  [2.x.19] , with embeddings of orders  [2.x.20] . These default to the Heun-Euler-2-1-2,   Bogacki-Shampine-4-2-3, Zonneveld-5-3-4, Cash-Karp-6-4-5, Verner-8-5-6 and   Fehlberg-13-7-8 methods, respectively.     Finally, for stiff (linear or nonlinear) problems the user may provide only    [2.x.21] , implying that  [2.x.22] , so that the system reduces to the non-split   IVP     [1.x.2]     Similarly to ERK methods, in this scenario the ARK methods reduce to   classical diagonally-implicit Runge-Kutta methods (DIRK). For these   classes of methods, ARKode allows orders of accuracy  [2.x.23] ,   with embeddings of orders  [2.x.24] . These default to the   SDIRK-2-1-2, ARK-4-2-3 (implicit), SDIRK-5-3-4 and ARK-8-4-5 (implicit)   methods, respectively.     For both DIRK and ARK methods, an implicit system of the form   [1.x.3]   must be solved for each stage  [2.x.25] , where   we have the data   [1.x.4]   for the ARK methods, or   [1.x.5]   for the DIRK methods. Here  [2.x.26]  and  [2.x.27]  are the Butcher's   tables for the chosen solver.     If  [2.x.28]  depends nonlinearly on  [2.x.29]  then the systems above correspond   to a nonlinear system of equations; if  [2.x.30]  depends linearly on    [2.x.31]  then this is a linear system of equations. By specifying the flag   `implicit_function_is_linear`, ARKode takes some shortcuts that allow a   faster solution process.     For systems of either type, ARKode allows a choice of solution strategy.   The default solver choice is a variant of Newton's method,   [1.x.6]   where  [2.x.32]  is the Newton index, and the Newton update  [2.x.33]    requires the solution of the linear Newton system   [1.x.7]   where   [1.x.8]     As an alternate to Newton's method, ARKode may solve for each stage  [2.x.34]  using an Anderson-accelerated fixed point iteration   [1.x.9]     Unlike with Newton's method, this option does not require the solution of   a linear system at each iteration, instead opting for solution of a   low-dimensional least-squares solution to construct the nonlinear update.     Finally, if the user specifies `implicit_function_is_linear`, i.e.,    [2.x.35]  depends linearly on  [2.x.36] , and if the Newton-based nonlinear   solver is chosen, then the system will be solved using only a single   Newton iteration. Notice that in order for the Newton solver to be used,   at least the jacobian_times_vector() function (or solve_jacobian_system()   for SUNDIALS version > 4.0.0) should be supplied. If this function is not   supplied, then only the fixed-point iteration will be supported, and the  `implicit_function_is_linear` setting is ignored.     The optimal solver (Newton vs fixed-point) is highly problem-dependent.   Since fixed-point solvers do not require the solution of any linear   systems, each iteration may be significantly less costly than their Newton   counterparts. However, this can come at the cost of slower convergence (or   even divergence) in comparison with Newton-like methods. These fixed-point   solvers do allow for user specification of the Anderson-accelerated   subspace size,  [2.x.37] . While the required amount of solver memory grows   proportionately to  [2.x.38] , larger values of  [2.x.39]  may result in faster   convergence.     This improvement may be significant even for "small" values, e.g.  [2.x.40] , and convergence may not improve (or even deteriorate) for   larger values of  [2.x.41] . While ARKode uses a Newton-based iteration as its   default solver due to its increased robustness on very stiff problems, it   is highly recommended that users also consider the fixed-point solver for   their cases when attempting a new problem.     For either the Newton or fixed-point solvers, it is well-known that both   the efficiency and robustness of the algorithm intimately depends on the   choice of a good initial guess. In ARKode, the initial guess for either   nonlinear solution method is a predicted value  [2.x.42]  that is computed   explicitly from the previously-computed data (e.g.  [2.x.43] , and    [2.x.44]  where  [2.x.45] ). Additional information on the specific predictor   algorithms implemented in ARKode is provided in ARKode documentation.     The user has to provide the implementation of at least one (or both) of the   following  [2.x.46] 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - implicit_function()
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - explicit_function()     If the mass matrix is different from the identity, the user should supply
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - mass_times_vector() (or solve_mass_system() for SUNDIALS version      < 4.0.0) and, optionally,
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - mass_times_setup() (or setup_mass() for SUNDIALS version < 4.0.0)     If the use of a Newton method is desired, then the user should also supply
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - jacobian_times_vector (or solve_jacobian_system() for SUNDIALS version      < 4.0.0)
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - optional: jacobian_times_setup() (or setup_jacobian() for SUNDIALS      version < 4.0.0)    
*  [2.x.47]  Although SUNDIALS can provide a difference quotient approximation     of the Jacobian, this is currently not supported through this wrapper.     Only for SUNDIALS version > 4.0.0: A SUNDIALS default solver (SPGMR) is   used to solve the linear systems. To use a custom linear solver for the   mass matrix and/or Jacobian, set:
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - solve_mass() and/or
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - solve_jacobian()     Only for SUNDIALS version > 4.0.0: To use a custom preconditioner with   either a default or custom linear solver, set:
* 

* 
* 

* 
* 

* 
* 
*  - jacobian_preconditioner_solve() and/or mass_preconditioner_solve()   and, optionally,
* 

* 
* 

* 
* 

* 
* 
*  - jacobian_preconditioner_setup() and/or mass_preconditioner_setup()     Also the following functions could be rewritten. By default   they do nothing, or are not required.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - solver_should_restart()
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - get_local_tolerances()     To produce output at fixed steps, set the function
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - output_step()     Any other custom settings of the ARKODE object can be specified in
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - custom_setup()     To provide a simple example, consider the harmonic oscillator problem:   [1.x.10]     We write it in terms of a first order ode:  [1.x.11]     That is  [2.x.48]    where   [1.x.12]   and  [2.x.49] .     The exact solution is  [2.x.50] ,  [2.x.51] ,  [2.x.52] .     A minimal implementation, using only explicit RK methods, is given by the   following code snippet:    
* [1.x.13]
*   
* [0.x.2]*
     Additional parameters that can be passed to the ARKode class.    
* [0.x.3]*
       Initialization parameters for ARKode.             Global parameters:              [2.x.53]  initial_time Initial time        [2.x.54]  final_time Final time        [2.x.55]  initial_step_size Initial step size        [2.x.56]  output_period Desired time interval between each output             Running parameters:              [2.x.57]  minimum_step_size Minimum step size        [2.x.58]  maximum_order Maximum ARK order        [2.x.59]  maximum_non_linear_iterations Maximum number of nonlinear         iterations        [2.x.60]  implicit_function_is_linear Specifies that the implicit portion         of the problem is linear        [2.x.61]  implicit_function_is_time_independent Specifies that the         implicit portion of the problem is linear and time independent        [2.x.62]  mass_is_time_independent Specifies that the mass pre-factor is         independent of time        [2.x.63]  anderson_acceleration_subspace The number of vectors to use for         Anderson acceleration within the packaged SUNDIALS solver.             Error parameters:              [2.x.64]  absolute_tolerance Absolute error tolerance        [2.x.65]  relative_tolerance Relative error tolerance      
* [0.x.4]*
       Add all AdditionalData() parameters to the given ParameterHandler       object. When the parameters are parsed from a file, the internal       parameters are automatically updated.             The options you pass at construction time are set as default values in       the ParameterHandler object `prm`. You can later modify them by parsing       a parameter file using `prm`. The values of the parameter will be       updated whenever the content of `prm` is updated.             Make sure that this class lives longer than `prm`. Undefined behavior       will occur if you destroy this class, and then parse a parameter file       using `prm`.      
* [0.x.5]*
       Initial time for the DAE.      
* [0.x.6]*
       Final time.      
* [0.x.7]*
       Initial step size.      
* [0.x.8]*
       Minimum step size.      
* [0.x.9]*
       Absolute error tolerance for adaptive time stepping.      
* [0.x.10]*
       Relative error tolerance for adaptive time stepping.      
* [0.x.11]*
       Maximum order of ARK.      
* [0.x.12]*
       Desired time period between each output. The actual output time period       may be adjusted by Arkode.      
* [0.x.13]*
       Maximum number of iterations for Newton or fixed point method during       time advancement.      
* [0.x.14]*
       Specify whether the implicit portion of the problem is linear.      
* [0.x.15]*
       Specify whether the implicit portion of the problem is linear and time       independent.      
* [0.x.16]*
       Specify whether the mass pre-factor is time independent. Has no effect       if no mass is specified.      
* [0.x.17]*
       Number of subspace vectors to use for Anderson acceleration. Only       meaningful if the packaged SUNDIALS fixed-point solver is used.      
* [0.x.18]*
     Constructor. It is possible to fine tune the SUNDIALS ARKode solver by     passing an AdditionalData() object that sets all of the solver     parameters.         The MPI communicator is simply ignored in the serial case.              [2.x.66]  data ARKode configuration data      [2.x.67]  mpi_comm MPI communicator    
* [0.x.19]*
     Destructor.    
* [0.x.20]*
     Integrate the initial value problem. This function returns the final     number of computed steps.          [2.x.68]  solution On input, this vector contains the initial condition. On       output, it contains the solution at the final time.    
* [0.x.21]*
     Integrate the initial value problem. Compared to the function above, this     function allows to specify an  [2.x.69]  for the next solution.     Repeated calls of this function must use monotonously increasing values     for  [2.x.70]  The last solution state is saved internally     along with the  [2.x.71]  and will be reused as initial     condition for the next call.         Users may find this function useful when integrating ARKode into an outer     time loop of their own, especially when output_step() is too restrictive.        
*  [2.x.72]   [2.x.73]  may be larger than  [2.x.74]        which is ignored by this function.          [2.x.75]  solution The final solution. If the solver restarts, either       because it is the first ever solve or the flag  [2.x.76]  is       set, the vector is also used as initial condition.      [2.x.77]  intermediate_time The time for the incremental solution step. Must       be greater than the last time that was used in a previous call to this       function.      [2.x.78]  reset_solver Optional flag to recreate all internal objects which       may be desirable for spatial adaptivity methods. If set to `true`,       reset() is called before solving the ODE, which sets  [2.x.79]  as       initial condition. This willnot* reset the stored time from previous       calls to this function.    
* [0.x.22]*
     Clear internal memory and start with clean objects. This function is     called when the simulation starts and when the user returns true to a     call to solver_should_restart().         By default solver_should_restart() returns false. If the user needs to     implement, for example, local adaptivity in space, he or she may assign     a different function to solver_should_restart() that performs all mesh     changes, transfers the solution to the new mesh, and returns true.          [2.x.80]  t  The new starting time      [2.x.81]  h  The new starting time step      [2.x.82]  y  The new initial solution    
* [0.x.23]*
     Provides user access to the internally used ARKODE memory.         This functionality is intended for users who wish to query additional     information directly from the ARKODE integrator, refer to the ARKODE     manual for the various `ARKStepGet...` functions. The `ARKStepSet...`     functions should not be called since this might lead to conflicts with     various settings that are performed by this ARKode object.        
*  [2.x.83]  If custom settings of ARKODE functionality (that are not achievable       via the interface of this class) are required, the function       custom_setup() should be used.          [2.x.84]  pointer to the ARKODE memory block that can be passed to SUNDIALS       functions    
* [0.x.24]*
     A function object that was used to `reinit` the given vector. Setting     this field does no longer have any effect and all auxiliary vectors are     reinit-ed automatically based on the user-supplied vector in solve_ode().          [2.x.85]  This function is no longer used and can be safely removed in       user code.    
* [0.x.25]*
     A function object that users may supply and that is intended to compute     the explicit part of the IVP right hand side. Sets  [2.x.86] .         At least one of explicit_function() or implicit_function() must be     provided. According to which one is provided, explicit, implicit, or     mixed RK methods are used.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.26]*
     A function object that users may supply and that is intended to compute     the implicit part of the IVP right hand side. Sets  [2.x.87] .         At least one of explicit_function() or implicit_function() must be     provided. According to which one is provided, explicit, implicit, or     mixed RK methods are used.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.27]*
     A function object that users may supply and that is intended to     prepare the linear solver for subsequent calls to     solve_jacobian_system().         Make sure that after a call to this function, we know how to compute     solutions of systems  [2.x.88] , where  [2.x.89]  is some approximation to the     Newton matrix,  [2.x.90] . This function is     optional. If the user does not provide it, then solve_jacobian_system()     is assumed to also perform the setup internally.         The setup_jacobian() function may call a user-supplied function to     compute needed data related to the Jacobian matrix. Alternatively, it may     choose to retrieve and use stored values of this data. In either case,     setup_jacobian() may also preprocess that data as needed for     solve_jacobian_system(), which may involve calling a generic function     (such as for LU factorization).         This data may be intended either for direct use (in a direct linear     solver) or for use in a preconditioner (in a preconditioned iterative     linear solver). The setup_jacobian() function is not called at every     stage solve (or even every time step), but only as frequently as the     solver determines that it is appropriate to perform the setup task. In     this way, Jacobian-related data generated by setup_jacobian() is     expected to be used over a number of time steps.         If the user uses a matrix based computation of the Jacobian, then this     is the right place where an assembly routine shoulde be called to     assemble both a matrix and a preconditioner for the Jacobian system.     Subsequent calls (possibly more than one) to solve_jacobian_system() can     assume that this function has been called at least once.         Notice that no assumption is made by this interface on what the user     should do in this function. ARKode only assumes that after a call to     setup_jacobian() it is possible to call solve_jacobian_system(), to     obtain a solution  [2.x.91]  to the system  [2.x.92] . If this function is not     provided, then it is never called.         Arguments to the function are          [2.x.93]  t  the current time      [2.x.94]  gamma  the current factor to use in the jacobian computation      [2.x.95]  ypred  is the predicted  [2.x.96]  vector for the current ARKode     internal step      [2.x.97]  fpred  is the value of the implicit right-hand side at ypred,             [2.x.98] .          [2.x.99]  convfail Input flag used to indicate any problem that     occurred during the solution of the nonlinear equation on the current     time step for which the linear solver is being used. This flag can be     used to help decide whether the Jacobian data kept by a linear solver     needs to be updated or not. Its possible values are:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - ARK_NO_FAILURES: this value is passed if either this is the first     call for this step, or the local error test failed on the previous     attempt at this step (but the Newton iteration converged).
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - ARK_FAIL_BAD_J: this value is passed if (a) the previous Newton         corrector iteration did not converge and the linear solver's setup         function indicated that its Jacobian-related data is not current, or     (b) during the previous Newton corrector iteration, the linear solver's         solve function failed in a recoverable manner and the linear solver's         setup function indicated that its Jacobian-related data is not     current.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - ARK_FAIL_OTHER: this value is passed if during the current internal         step try, the previous Newton iteration failed to converge even     though the linear solver was using current Jacobian-related data.          [2.x.100]  j_is_current: a boolean to be filled in by setup_jacobian().     The value should be set to `true` if the Jacobian data is current after     the call, and should be set to `false` if its Jacobian data is not     current. If setup_jacobian() calls for re-evaluation of Jacobian data     (based on convfail and ARKode state data), then it should set     `j_is_current` to `true` unconditionally, otherwise an infinite loop can     result.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (ARKodeReinit will be called if this happens, and           then last function will be attempted again
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an           assertion will be thrown.    
* [0.x.28]*
     A function object that users may supply and that is intended to solve     the Jacobian linear system. This function will be called by ARKode     (possibly several times) after setup_jacobian() has been called at least     once. ARKode tries to do its best to call setup_jacobian() the minimum     amount of times. If convergence can be achieved without updating the     Jacobian, then ARKode does not call setup_jacobian() again. If, on the     contrary, internal ARKode convergence tests fail, then ARKode calls     again setup_jacobian() with updated vectors and coefficients so that     successive calls to solve_jacobian_systems() lead to better convergence     in the Newton process.         If you do not specify a solve_jacobian_system() function, then a fixed     point iteration is used instead of a Newton method. Notice that this may     not converge, or may converge very slowly.         The jacobian  [2.x.101]  should be (an approximation of) the system Jacobian     [1.x.14]     evaluated at `t`, `ycur`. `fcur` is  [2.x.102] .         A call to this function should store in `dst` the result of  [2.x.103]      applied to `src`, i.e., `J*dst = src`. It is the users responsibility to     set up proper solvers and preconditioners inside this function.             Arguments to the function are          [2.x.104]  t  the current time      [2.x.105]  gamma  the current factor to use in the jacobian computation      [2.x.106]  ycur  is the current  [2.x.107]  vector for the current ARKode       internal step      [2.x.108]  fcur  is the current value of the implicit right-hand side at       ycur,  [2.x.109] .             This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (ARKodeReinit will be called if this happens, and           then last function will be attempted again
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an           assertion will be thrown.    
* [0.x.29]*
     A function object that users may supply and that is intended to set up     the mass matrix. This function is called by ARKode any time a mass     matrix update is required. The user should compute the mass matrix (or     update all the variables that allow the application of the mass matrix).     This function is called by ARKode once, before any call to     solve_mass_system().         ARKode supports the case where the mass matrix may depend on time, but     not the case where the mass matrix depends on the solution itself.         If the user does not provide a solve_mass_matrix() function, then the     identity is used. If the setup_mass() function is not provided, then     solve_mass_system() should do all the work by itself.         If the user uses a matrix based computation of the mass matrix, then     this is the right place where an assembly routine shoulde be called to     assemble both a matrix and a preconditioner. Subsequent calls (possibly     more than one) to solve_mass_system() can assume that this function     has been called at least once.         Notice that no assumption is made by this interface on what the user     should do in this function. ARKode only assumes that after a call to     setup_mass() it is possible to call solve_mass_system(), to     obtain a solution  [2.x.110]  to the system  [2.x.111] .         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (ARKodeReinit will be called if this happens, and           then last function will be attempted again
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an           assertion will be thrown.    
* [0.x.30]*
     A function object that users may supply and that is intended to solve     the mass matrix linear system. This function will be called by ARKode     (possibly several times) after setup_mass() has been called at least     once. ARKode tries to do its best to call setup_mass() the minimum     amount of times.         A call to this function should store in `dst` the result of  [2.x.112]      applied to `src`, i.e., `M*dst = src`. It is the users responsibility to     set up proper solvers and preconditioners inside this function.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (ARKodeReinit will be called if this happens, and           then last function will be attempted again
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an           assertion will be thrown.    
* [0.x.31]*
     A function object that users may supply and that is intended to compute     the product of the mass matrix with a given vector `v`. This function     will be called by ARKode (possibly several times) after     mass_times_setup() has been called at least once. ARKode tries to do its     best to call mass_times_setup() the minimum amount of times.         A call to this function should store in `Mv` the result of  [2.x.113]      applied to `v`.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.32]*
     A function object that users may supply and that is intended to set up     the mass matrix. This function is called by ARKode any time a mass     matrix update is required. The user should compute the mass matrix (or     update all the variables that allow the application of the mass matrix).     This function is guaranteed to be called by ARKode at least once, before     any call to mass_times_vector().         ARKode supports the case where the mass matrix may depend on time, but     not the case where the mass matrix depends on the solution itself.         If the user does not provide a mass_times_vector() function, then the     identity is used. If the mass_times_setup() function is not provided,     then mass_times_vector() should do all the work by itself.         If the user uses a matrix-based computation of the mass matrix, then     this is the right place where an assembly routine should be called to     assemble the matrix. Subsequent calls (possibly  more than one) to     mass_times_vector() can assume that this function has been called at     least once.        
*  [2.x.114]  No assumption is made by this interface on what the user       should do in this function. ARKode only assumes that after a call to       mass_times_setup() it is possible to call mass_times_vector().          [2.x.115]  t The current evaluation time         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.33]*
     A function object that users may supply and that is intended to compute     the product of the Jacobian matrix with a given vector `v`. The Jacobian     here refers to  [2.x.116] , i.e., the Jacobian of     the user-specified implicit_function.         A call to this function should store in `Jv` the result of  [2.x.117]      applied to `v`.         Arguments to the function are          [2.x.118]  v  The vector to be multiplied by the Jacobian      [2.x.119]  Jv The vector to be filled with the product J*v      [2.x.120]  t  The current time      [2.x.121]  y  The current  [2.x.122]  vector for the current ARKode internal       step      [2.x.123]  fy  The current value of the implicit right-hand side at y,        [2.x.124] .         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.34]*
     A function object that users may supply and that is intended to set up     all data necessary for the application of jacobian_times_vector(). This     function is called by ARKode any time a Jacobian update is required.     The user should compute the Jacobian (or update all the variables that     allow the application of Jacobian). This function is guaranteed to     be called by ARKode at least once, before any call to     jacobian_times_vector().         If the jacobian_times_setup() function is not provided, then     jacobian_times_vector() should do all the work by itself.         If the user uses a matrix based computation of the Jacobian, then this is     the right place where an assembly routine should be called to assemble     the matrix. Subsequent calls (possibly  more than one) to     jacobian_times_vector() can assume that this function has been called at     least once.        
*  [2.x.125]  No assumption is made by this interface on what the user       should do in this function. ARKode only assumes that after a call to       jacobian_times_setup() it is possible to call jacobian_times_vector().          [2.x.126]  t  The current time      [2.x.127]  y  The current ARKode internal solution vector  [2.x.128]       [2.x.129]  fy  The implicit right-hand side function evaluated at the       current time  [2.x.130]  and state  [2.x.131] , i.e.,  [2.x.132]          This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.35]*
     A LinearSolveFunction object that users may supply and that is intended     to solve the linearized system  [2.x.133] , where  [2.x.134]  is the     Jacobian of the nonlinear residual. The application of the mass matrix      [2.x.135]  and Jacobian  [2.x.136]  are known through the functions mass_times_vector()     and jacobian_times_vector() and  [2.x.137]  is a factor provided by     SUNDIALS. The matrix-vector product  [2.x.138]  is encoded in the supplied     SundialsOperator. If a preconditioner was set through     jacobian_preconditioner_solve(), it is encoded in the     SundialsPreconditioner. If no preconditioner was supplied this way, the     preconditioner is the identity matrix, i.e., no preconditioner. The user     is free to use a custom preconditioner in this function object that is     not supplied through SUNDIALS.         If you do not specify a solve_linearized_system() function, then a     SUNDIALS packaged SPGMR solver with default settings is used.         For more details on the function type refer to LinearSolveFunction.    
* [0.x.36]*
     A LinearSolveFunction object that users may supply and that is intended     to solve the mass system  [2.x.139] . The matrix-vector product  [2.x.140]  is     encoded in the supplied SundialsOperator. If a preconditioner was set     through mass_preconditioner_solve(), it is encoded in the     SundialsPreconditioner. If no preconditioner was supplied this way, the     preconditioner is the identity matrix, i.e., no preconditioner. The user     is free to use a custom preconditioner in this function object that is     not supplied through SUNDIALS.         The user must specify this function if a non-identity mass matrix is used     and applied in mass_times_vector().         For more details on the function type refer to LinearSolveFunction.    
* [0.x.37]*
     A function object that users may supply to either pass a preconditioner     to a SUNDIALS built-in solver or to apply a custom preconditioner within     the user's own linear solve specified in solve_linearized_system().         This function should compute the solution to the preconditioner equation      [2.x.141]  and store it in  [2.x.142]  In this equation  [2.x.143]  should approximate the     Jacobian  [2.x.144]  of the nonlinear system.          [2.x.145]  t  The current time      [2.x.146]  y  The current  [2.x.147]  vector for the current ARKode internal       step      [2.x.148]  fy  The current value of the implicit right-hand side at y,        [2.x.149] .      [2.x.150]  r  The right-hand side of the preconditioner equation      [2.x.151]  z The solution of applying the preconditioner, i.e., solving        [2.x.152]       [2.x.153]  gamma The value  [2.x.154]  in the preconditioner equation      [2.x.155]  tol The tolerance up to which the system should be solved      [2.x.156]  lr An input flag indicating whether the preconditioner solve       is to use the left preconditioner (lr = 1) or the right preconditioner       (lr = 2). Only relevant if used with a SUNDIALS packaged solver. If       used with a custom solve_mass() function this will be set to zero.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.38]*
     A function object that users may supply to set up a preconditioner     specified in jacobian_preconditioner_solve().         This function should prepare the solution of the preconditioner equation      [2.x.157] . In this equation  [2.x.158]  should approximate the Jacobian  [2.x.159]      of the nonlinear system.         If the jacobian_preconditioner_setup() function is not provided, then     jacobian_preconditioner_solve() should do all the work by itself.        
*  [2.x.160]  No assumption is made by this interface on what the user       should do in this function. ARKode only assumes that after a call to       jacobian_preconditioner_setup() it is possible to call       jacobian_preconditioner_solve().          [2.x.161]  t  The current time      [2.x.162]  y  The current  [2.x.163]  vector for the current ARKode internal       step      [2.x.164]  fy  The current value of the implicit right-hand side at y,        [2.x.165] .      [2.x.166]  jok  An input flag indicating whether the Jacobian-related       data needs to be updated. The jok argument provides for the reuse of       Jacobian data in the preconditioner solve function. When jok =       SUNFALSE, the Jacobian-related data should be recomputed from scratch.       When jok = SUNTRUE the Jacobian data, if saved from the previous call       to this function, can be reused (with the current value of gamma). A       call with jok = SUNTRUE can only occur after a call with jok =       SUNFALSE.      [2.x.167]  jcur On output this should be set to SUNTRUE if Jacobian data       was recomputed, or set to SUNFALSE if Jacobian data was not recomputed,       but saved data was still reused.      [2.x.168]  gamma The value  [2.x.169]  in  [2.x.170] . The preconditioner       should approximate the inverse of this matrix.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.39]*
     A function object that users may supply to either pass a preconditioner     to a SUNDIALS built-in solver or to apply a custom preconditioner within     the user's own linear solve specified in solve_mass().         This function should compute the solution to the preconditioner equation      [2.x.171]  and store it in  [2.x.172]  In this equation  [2.x.173]  should approximate the     mass matrix  [2.x.174] .          [2.x.175]  t  The current time      [2.x.176]  r  The right-hand side of the preconditioner equation      [2.x.177]  z The solution of applying the preconditioner, i.e., solving        [2.x.178]       [2.x.179]  gamma The value  [2.x.180]  in the preconditioner equation      [2.x.181]  tol The tolerance up to which the system should be solved      [2.x.182]  lr An input flag indicating whether the preconditioner solve       is to use the left preconditioner (lr = 1) or the right preconditioner       (lr = 2). Only relevant if used with a SUNDIALS packaged solver. If       used with a custom solve_mass() function this will be set to zero.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.40]*
     A function object that users may supply to set up a preconditioner     specified in mass_preconditioner_solve().         This function should prepare the solution of the preconditioner equation      [2.x.183] . In this equation  [2.x.184]  should approximate the mass matrix  [2.x.185] .         If the mass_preconditioner_setup() function is not provided, then     mass_preconditioner_solve() should do all the work by itself.        
*  [2.x.186]  No assumption is made by this interface on what the user       should do in this function. ARKode only assumes that after a call to       mass_preconditioner_setup() it is possible to call       mass_preconditioner_solve().          [2.x.187]  t  The current time         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.41]*
     A function object that users may supply and that is intended to     postprocess the solution. This function is called by ARKode at fixed     time increments (every `output_period` seconds), and it is passed a     polynomial interpolation of the solution, computed using the current ARK     order and the (internally stored) previously computed solution steps.        
*  [2.x.188]  It is well possible that internally ARKode computes a time       step which is much larger than the `output_period` step, and therefore       calls this function consecutively several times by simply performing       all intermediate interpolations. There is no relationship between how       many times this function is called and how many time steps have       actually been computed.    
* [0.x.42]*
     A function object that users may supply and that is intended to evaluate     whether the solver should be restarted (for example because the number of     degrees of freedom has changed).         This function is supposed to perform all operations that are necessary     in `sol` to make sure that the resulting vectors are consistent, and of     the correct final size.         For example, one may decide that a local refinement is necessary at time     t. This function should then return true, and change the dimension of     `sol` to reflect the new dimension. Since ARKode does not know about the     new dimension, an internal reset is necessary.         The default implementation simply returns `false`, i.e., no restart is     performed during the evolution.    
* [0.x.43]*
     A function object that users may supply and that is intended to return a     vector whose components are the weights used by ARKode to compute the     vector norm. The implementation of this function is optional, and it is     used only if implemented.    
* [0.x.44]*
     A function object that users may supply and which is intended to perform     custom settings on the supplied  [2.x.189]  object. Refer to the     SUNDIALS documentation for valid options.         For instance, the following code attaches two files for diagnostic and     error output of the internal ARKODE implementation:        
* [1.x.15]
*         
*  [2.x.190]  This function will be called at the end of all other set up right       before the actual time evloution is started or continued with       solve_ode(). This function is also called when the solver is restarted,       see solver_should_restart(). Consult the SUNDIALS manual to see which       options are still available at this point.          [2.x.191]  arkode_mem pointer to the ARKODE memory block which can be used       for custom calls to `ARKStepSet...` methods.    
* [0.x.45]*
     Throw an exception when a function with the given name is not     implemented.    
* [0.x.46]*
     Internal routine to call ARKode repeatedly.    
* [0.x.47]*
     Set up the (non)linear solver and preconditioners in the ARKODE memory     object based on the user-specified functions.      [2.x.192]  solution The solution vector which is used as a template to create       new vectors.    
* [0.x.48]*
     Set up the solver and preconditioner for a non-identity mass matrix in     the ARKODE memory object based on the user-specified functions.      [2.x.193]  solution The solution vector which is used as a template to create       new vectors.    
* [0.x.49]*
     This function is executed at construction time to set the      [2.x.194]  above to trigger an assert if they are not     implemented.    
* [0.x.50]*
     ARKode configuration data.    
* [0.x.51]*
     ARKode memory object.    
* [0.x.52]*
     MPI communicator. SUNDIALS solver runs happily in     parallel. Note that if the library is compiled without MPI     support, MPI_Comm is aliased as int.    
* [0.x.53]*
     The final time in the last call to solve_ode().    
* [0.x.54]*
   Handle ARKode exceptions.  
* [0.x.55]