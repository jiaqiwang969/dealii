[0.x.0]*
   We supply adaptive methods to align computational resources with the   complexity of the numerical solution. Error estimates are an appropriate   means of determining where adjustments need to be made.     However with hp-adaptivity, we have two ways to realize these adjustments:   For irregular solutions, h-adaptive methods which dynamically assign cell   sizes tend to reduce the approximation error, while for smooth solutions   p-adaptive methods are better suited in which function spaces will be   selected dynamically. This namespace collects tools to decide which type   of adaptive methods to apply.     [1.x.0]     To successfully apply hp-adaptive methods, we recommend the following   workflow:    [2.x.0]     [2.x.1]  A suitable error estimate is the basis for any kind of adaptive method.   Similar to pure grid refinement, we will determine error estimates in the   usual way (i.e. KellyErrorEstimator) and mark cells for refinement or   coarsening (i.e. GridRefinement).     Calling  [2.x.2]  at this stage   will perform pure grid refinement as expected.      [2.x.3]  Once all refinement and coarsening flags have been distributed on the   mesh, we may determine if those qualify for p-adaptive methods.   Corresponding functions will set  [2.x.4]  on top of the   refinement and coarsening flags if they fulfil a certain criterion.     In case of refinement, the superordinate element of the underlying    [2.x.5]  will be assigned as the future finite element.   Correspondingly, the subordinate element will be selected for coarsening.      [2.x.6]  will now supply both   h- and p-adaptive methods independently.      [2.x.7]  Right now, there may be cells scheduled for both h- and p-adaptation.   If we do not want to impose both methods at once, we need to decide which   one to pick for each cell individually and unambiguously. Since grid   refinement will be imposed by default and we only determine qualification   for p-adaptivity on top, we will always decide in favour of p-adaptive   methods.     Calling  [2.x.8]  will now perform   either h- or p-adaptive methods uniquely on each cell.      [2.x.9]  Up to this point, each cell knows its destiny in terms of adaptivity.   We can now move on to prepare all data structures to be transferred across   mesh changes. Previously set refinement and coarsening flags as well as    [2.x.10]  will be used to update the data accordingly.    [2.x.11]      As an example, a realisation of pure p-adaptive methods would look like the   following:  
* [1.x.1]
*     
*  [2.x.12]   
* [0.x.1]*
     An alias that defines the characteristics of a function that can be used     as a comparison criterion for deciding whether to perform h- or     p-adaptation.         Such functions take two numbers as arguments: The first one corresponds     to the provided criterion, while the other one conforms to the reference.     The result of the comparison will be returned as a boolean.    
* [0.x.2]*
      [2.x.13]  Setting p-adaptivity flags      [2.x.14]     
* [0.x.3]*
     Each cell flagged for h-refinement will also be flagged for p-refinement.     The same applies to coarsening.        
*  [2.x.15]   [2.x.16]  and        [2.x.17]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.4]*
     Adapt which finite element to use on cells that have been specifically     flagged for p-adaptation via the parameter  [2.x.18]  Future finite     elements will only be assigned if cells have been flagged for refinement     and coarsening beforehand.         Each entry of the parameter  [2.x.19]  needs to correspond to an active     cell.        
*  [2.x.20]   [2.x.21]  and        [2.x.22]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.5]*
     Adapt which finite element to use on cells whose criteria meet a certain     absolute threshold.         For p-refinement and p-coarsening, two separate thresholds need to     provided via parameters  [2.x.23]  and  [2.x.24]          We consider a cell for p-adaptivity if it is currently flagged for     refinement or coarsening and its criterion successfully compares to the     corresponding threshold. Let us be more specific on the default case: We     consider a cell for p-refinement if it is flagged for refinement and its     criterion is larger than or equal to the corresponding threshold. The     same applies for p-coarsening, but the cell's criterion must be lower     than or equal to the threshold. However, different compare function     objects can be supplied via the parameters  [2.x.25]  and      [2.x.26]  to impose different decision strategies.         Each entry of the parameter  [2.x.27]  needs to correspond to an active     cell.        
*  [2.x.28]   [2.x.29]  and        [2.x.30]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.6]*
     Adapt which finite element to use on cells whose criteria meet a certain     threshold relative to the overall range of criterion values.         The threshold will be determined for refined and coarsened cells     separately based on the currently set refinement markers. For each class     of cells, we determine the maximal and minimal values of all criteria and     determine the threshold by linear interpolation between these limits.     Parameters  [2.x.31]  and  [2.x.32]  are used as     interpolation factors, where `0` corresponds to the minimal and `1` to     the maximal value. By default, mean values are considered as thresholds.         We consider a cell for p-adaptivity if it is currently flagged for     refinement or coarsening and its criterion successfully compares to the     corresponding threshold. Let us be more specific on the default case: We     consider a cell for p-refinement if it is flagged for refinement and its     criterion is larger than or equal to the corresponding threshold. The     same applies for p-coarsening, but the cell's criterion must be lower     than or equal to the threshold. However, different compare function     objects can be supplied via the parameters  [2.x.33]  and      [2.x.34]  to impose different decision strategies.         Each entry of the parameter  [2.x.35]  needs to correspond to an active     cell. Parameters  [2.x.36]  and  [2.x.37]  need to be     in the interval  [2.x.38] .        
*  [2.x.39]   [2.x.40]  and        [2.x.41]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.7]*
     Adapt which finite element to use on a given fraction of cells.         Out of all cells flagged for a certain type of adaptation, be it     refinement or coarsening, we will determine a fixed number of cells among     this subset that will be flagged for the corresponding p-adaptive     variant.         For each of both refinement and coarsening subsets, we will determine a     threshold based on the provided parameter  [2.x.42]  containing     indicators for every active cell. In the default case for refinement, all     cells with an indicator larger than or equal to the corresponding     threshold will be considered for p-refinement, while for coarsening all     cells with an indicator less than or equal to the matching threshold are     taken into account. However, different compare function objects can be     supplied via the parameters  [2.x.43]  and  [2.x.44]  to     impose different decision strategies.         For refinement, the threshold will be associated with the cell that has     the  [2.x.45]  times  [2.x.46]  largest     indicator, while it is the cell with the  [2.x.47]  times      [2.x.48]  lowest indicator for coarsening.         Each entry of the parameter  [2.x.49]  needs to correspond to an active     cell. Parameters  [2.x.50]  and  [2.x.51]  need to be     in the interval  [2.x.52] .        
*  [2.x.53]   [2.x.54]  and        [2.x.55]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.8]*
     Adapt which finite element to use on cells based on the regularity of the     (unknown) analytical solution.         With an approximation of the local Sobolev regularity index  [2.x.56] ,     we may assess to which finite element space our local solution on cell      [2.x.57]  belongs. Since the regularity index is only an estimate, we won't     use it to assign the finite element space directly, but rather consider     it as an indicator for adaptation. If a cell is flagged for refinement,     we will perform p-refinement once it satisfies      [2.x.58] , where  [2.x.59]  is     the polynomial degree of the finite element superordinate to the     currently active element on cell  [2.x.60] . In case of coarsening, the     criterion  [2.x.61]  has to be met, with      [2.x.62]  the degree of the subordinate element.         Each entry of the parameter  [2.x.63]  needs to correspond     to an active cell.         For more theoretical details see  [2.x.64]  .        
*  [2.x.65]   [2.x.66]  and        [2.x.67]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.9]*
     Adapt which finite element to use on each cell based on how its criterion     relates to a reference.         We consider a cell for p-adaptivity if it is currently flagged for     refinement or coarsening and its criterion successfully compares to the     corresponding reference. Other than functions     p_adaptivity_from_absolute_threshold() and     p_adaptivity_from_relative_threshold(), compare function objects have to     be provided explicitly via the parameters  [2.x.68]  and      [2.x.69]          Each entry of the parameters  [2.x.70]  and  [2.x.71]  needs to     correspond to an active cell.        
*  [2.x.72]   [2.x.73]  and        [2.x.74]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.10]*
      [2.x.75]     
* [0.x.11]*
      [2.x.76]  Error prediction      [2.x.77]     
* [0.x.12]*
     Predict how the current  [2.x.78]  will adapt after refinement     and coarsening were to happen on the provided  [2.x.79]  and write its     results to  [2.x.80]  Each entry of  [2.x.81]  and      [2.x.82]  corresponds to an active cell on the underlying     Triangulation, thus each container has to be of size      [2.x.83]  The errors are interpreted to be     measured in the energy norm; this assumption enters the rate of     convergence that is used in the prediction. The  [2.x.84] -norm of the output     argument  [2.x.85]  corresponds to the predicted global error     after adaptation.         For p-adaptation, the local error is expected to converge exponentially     with the polynomial degree of the assigned finite element. Each increase     or decrease of the degree will thus change its value by a user-defined     control parameter  [2.x.86]          For h-adaptation, we expect the local error  [2.x.87]  on cell  [2.x.88]  to be     proportional to  [2.x.89]  in the energy norm, where  [2.x.90]  denotes the     cell diameter and  [2.x.91]  the polynomial degree of the currently assigned     finite element on cell  [2.x.92] .         During h-coarsening, the finite elements on siblings may be     different, and their parent cell will be assigned to their least     dominating finite element that belongs to its most general child. Thus,     we will always interpolate on an enclosing finite element space.     Additionally assuming that the finite elements on the cells to be     coarsened are sufficient to represent the solution correctly (e.g. at     least quadratic basis functions for a quadratic solution), we are     confident to say that the error will not change by sole interpolation on     the larger finite element space.         For p-adaptation, the local error is expected to converge exponentially     with the polynomial degree of the assigned finite element. Each increase     or decrease of the degree will thus change its value by a user-defined     control parameter  [2.x.93]  The assumption of exponential convergence     is only valid if both h- and p-adaptive methods are combined in a sense     that they are both utilitzed throughout a mesh, but do not have to be     applied both on a cell simultaneously.         The prediction algorithm is formulated as follows with control parameters      [2.x.94]   [2.x.95]  and  [2.x.96]  that may be used to influence     prediction for each adaptation type individually. The results for each     individual cell are stored in the  [2.x.97]  output argument.      [2.x.98]          On basis of the refinement history, we use the predicted error estimates     to decide how cells will be adapted in the next adaptation step.     Comparing the predicted error from the previous adaptation step to the     error estimates of the current step allows us to justify whether our     previous choice of adaptation was justified, and lets us decide how to     adapt in the next one.         We thus have to transfer the predicted error from the old to the adapted     mesh. When transferring the predicted error to the adapted mesh, make     sure to configure your CellDataTransfer object with      [2.x.99]  as a refinement strategy and      [2.x.100]  as a coarsening strategy.     This ensures that the  [2.x.101] -norm of the predict errors is preserved on     both meshes.         In this context, we assume that the local error on a cell to be h-refined     will be divided equally on all of its  [2.x.102]  children, whereas local     errors on siblings will be summed up on the parent cell in case of     h-coarsening. This assumption is often not satisfied in practice: For     example, if a cell is at a corner singularity, then the one child cell     that ends up closest to the singularity will inherit the majority of the     remaining error
* 
*  -  but this function can not know where the singularity     will be, and consequently assumes equal distribution.         Incorporating the transfer from the old to the adapted mesh, the complete     error prediction algorithm reads as follows:      [2.x.103]          With these predicted error estimates, we are capable of adapting the     finite element on cells based on their refinement history or rather the     predicted change of their error estimates.         If a cell is flagged for adaptation, we want to perform p-adaptation once     the associated error indicators  [2.x.104]  on cell  [2.x.105]  satisfy      [2.x.106] , where the subscript  [2.x.107]      denotes the predicted error. This corresponds to our assumption of     smoothness being correct, else h-adaptation is applied. We achieve this     with the function  [2.x.108]  and a     function object  [2.x.109]  for both comparator parameters.         Also with an alternative strategy, we can determine the fractions of     cells to be h- and p-adapted among all cells to be adapted. For this, use      [2.x.110]  with criteria      [2.x.111] .         For the very first adaptation step in either case, the user needs to     decide whether h- or p-adaptation is supposed to happen. An h-step will     be applied with  [2.x.112] , whereas      [2.x.113]  ensures a p-step. The latter may be     realized with  [2.x.114]          The following code snippet demonstrates how to impose hp-adaptivity based     on refinement history in an application:    
* [1.x.2]
*          For more theoretical details see  [2.x.115]  , where the default     parameters for this function come from as well, i.e.      [2.x.116] ,  [2.x.117] ,      [2.x.118] .         If you are working with  [2.x.119]  objects, you     need to pay special attention. Here, p4est determines the details of grid     refinement, and consequently, it yields more reliable and trustworthy     results when we determine the predicted errors during the adaptation     process. We can do exactly this by attaching this function to the signal      [2.x.120]  which is triggered after     p4est got refined, but before data is prepared for transfer. Refinement     and coarsening flags of the Triangulation object need to be matched with     the already refined p4est oracle using      [2.x.121]      Thus, a construct like the following is necessary to correctly predict     errors in parallel distributed applications.    
* [1.x.3]
*      The container  [2.x.122]  then needs to follow the     usual  [2.x.123]  workflow.        
*  [2.x.124]  We want to predict the error by how adaptation will actually happen.       Thus, this function needs to be called after        [2.x.125]  and        [2.x.126]     
* [0.x.13]*
      [2.x.127]     
* [0.x.14]*
      [2.x.128]  Decide between h- and p-adaptivity      [2.x.129]     
* [0.x.15]*
     Choose p-adaptivity over h-adaptivity in any case.         Removes all refine and coarsen flags on cells that have a      [2.x.130]  assigned.        
*  [2.x.131]   [2.x.132]  and        [2.x.133]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.16]*
     Choose p-adaptivity over h-adaptivity whenever it is invoked on all     related cells.         In case of refinement, information about finite elements will be     inherited. Thus we will prefer p-refinement over h-refinement whenever     desired, i.e. clear the refine flag and supply a corresponding      [2.x.134]          However for coarsening, we follow a different approach. Flagging a cell     for h-coarsening does not ultimately mean that it will be coarsened. Only     if a cell and all of its siblings are flagged, they will be merged into     their parent cell. If we consider p-coarsening on top, we must decide for     all siblings together how they will be coarsened. We distinguish between     three different cases:      [2.x.135]       [2.x.136]  Not all siblings flagged for coarsening: p-coarsening.        [2.x.137]        We keep the  [2.x.138]  and clear the coarsen flags       on all siblings.      [2.x.139]  All siblings flagged for coarsening, but not all for       p-adaptation: h-coarsening.        [2.x.140]        We keep the coarsen flags and clear all  [2.x.141]        on all siblings.      [2.x.142]  All siblings flagged for coarsening and p-adaptation: p-coarsening.        [2.x.143]        We keep the  [2.x.144]  and clear the coarsen flags       on all siblings.      [2.x.145]         
*  [2.x.146]  The function  [2.x.147]        will clean up all h-coarsening flags if they are not shared among       all siblings. In the hp-case, we need to bring forward this decision:       If the cell will not be coarsened, but qualifies for p-adaptivity,       we have to set all flags accordingly. So this function anticipates       the decision that  [2.x.148]        would have made later on.        
*  [2.x.149]   [2.x.150]  and        [2.x.151]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.17]*
      [2.x.152]     
* [0.x.18]*
      [2.x.153]  Optimiize p-level distribution      [2.x.154]     
* [0.x.19]*
     Limit p-level differences between neighboring cells.         Essentially does to future FE indices what      [2.x.155]  does to refinement     flags.         In detail, this function limits the level difference of neighboring cells     and thus smoothes the overall function space. Future FE indices will be     raised (and never lowered) so that the level difference to neighboring     cells is never larger than  [2.x.156]          Multiple FE hierarchies might have been registered via      [2.x.157]  This function operates on only one     hierarchy, namely the one that contains the FE index  [2.x.158]      Cells with future FE indices that are not part of the corresponding     hierarchy will be ignored.         The function can optionally be called before performing adaptation with      [2.x.159]  It is not necessary     to call this function, nor will it be automatically invoked in any part     of the library (contrary to its Triangulation counterpart).         On cells that will be h-coarsened, we enforce the difference criterion as     if it is already a parent cell. That means, we set the level of all     siblings to the highest one among them. In that case, all sibling cells     need to have the h-coarsenening flags set terminally via      [2.x.160]  beforehand. Otherwise     an assertion will be triggered.         Returns whether any future FE indices have been changed by this function.    
* [0.x.20]*
      [2.x.161]     
* [0.x.21]