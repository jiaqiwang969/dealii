[0.x.0]*
 This base class of the FEEvaluation and FEFaceEvaluation classes handles mapping-related information independent of the degrees of freedom and finite element in use. This class provides access functionality for user code but is otherwise invisible without any public constructor. The usage is through the class FEEvaluation instead.
*  This class has four template arguments:
*   [2.x.0]  dim Dimension in which this class is to be used
*   [2.x.1]  Number Number format, usually  [2.x.2]  or  [2.x.3] 
*   [2.x.4]  is_face Whether the class is used for a cell integrator (with quadrature dimension the same as the space dimension) or for a face integrator (with quadrature dimension one less)
*   [2.x.5]  VectorizedArrayType Type of array to be woked on in a vectorized                             fashion, defaults to VectorizedArray<Number>
* 

* 
*  [2.x.6]  Currently only VectorizedArray<Number, width> is supported as       VectorizedArrayType.
* 

* 

* 
*  [2.x.7] 

* 
* [0.x.1]*
   Destructor.  
* [0.x.2]*
   Return the index offset within the geometry fields for the cell the  [2.x.8]    reinit() function has been called for. This index can be used to access   an index into a field that has the same compression behavior as the   Jacobian of the geometry, e.g., to store an effective coefficient tensors   that combines a coefficient with the geometry for lower memory transfer   as the available data fields.  
* [0.x.3]*
   Return the type of the cell the  [2.x.9]  function has been called for.   Valid values are  [2.x.10]  for Cartesian cells (which allows for   considerable data compression),  [2.x.11]  for cells with affine mappings,   and  [2.x.12]  for general cells without any compressed storage applied.  
* [0.x.4]*
   Return a reference to the ShapeInfo object currently in use.  
* [0.x.5]*
   Return a reference to the DoFInfo object currently in use.  
* [0.x.6]*
   Return the determinant of the Jacobian from the unit to the real cell   times the quadrature weight.  
* [0.x.7]*
   Return the inverse and transposed version  [2.x.13]  of the   Jacobian of the mapping between the unit to the real cell defined as    [2.x.14] . The  [2.x.15]  entry of the returned tensor   contains  [2.x.16] , i.e., columns refer to reference space   coordinates and rows to real cell coordinates. Thus, the returned tensor   represents a covariant transformation, which is used in the    [2.x.17]  function to transform the unit cell   gradients to gradients on the real cell by a multiplication  [2.x.18] .  
* [0.x.8]*
   Return the unit normal vector on a face. Note that both sides of a face   use the same orientation of the normal vector: For the faces enumerated   as `interior` in FaceToCellTopology and selected with the   `is_interior_face=true` flag of the constructor, this corresponds to the   outer normal vector, whereas for faces enumerated as `exterior` in   FaceToCellTopology and selected with the `is_interior_face=false` flag of   the constructor, the normal points into the element as a consequence of   the single normal vector.    
*  [2.x.19]  Only implemented in case `is_face == true`.  
* [0.x.9]*
   Provides a unified interface to access data in a vector of   VectorizedArray fields of length  [2.x.20]  +    [2.x.21]  for both cells (plain read) and faces   (indirect addressing).  
* [0.x.10]*
   Provides a unified interface to set data in a vector of   VectorizedArray fields of length  [2.x.22]  +    [2.x.23]  for both cells (plain read) and faces   (indirect addressing).  
* [0.x.11]*
   The same as above, just for  [2.x.24]  of length of VectorizedArrayType for   arbitrary data type.  
* [0.x.12]*
   The same as above, just for  [2.x.25]  of length of VectorizedArrayType for   arbitrary data type.  
* [0.x.13]*
   Return the id of the cells this FEEvaluation or FEFaceEvaluation is   associated with.  
* [0.x.14]*
   Return the id of the cells/faces this FEEvaluation/FEFaceEvaluation is   associated with.  
* [0.x.15]*
   Return the numbering of local degrees of freedom within the evaluation   routines of FEEvaluation in terms of the standard numbering on finite   elements.  
* [0.x.16]*
   Return an ArrayView to internal memory for temporary use. Note that some   of this memory is overwritten during evaluate() and integrate() calls so   do not assume it to be stable over those calls. The maximum size you can   write into is 3*dofs_per_cell+2*n_q_points.  
* [0.x.17]*
   Return the number of the quadrature formula of the present cell.  
* [0.x.18]*
   Return index of the current cell or face.  
* [0.x.19]*
   Return the active FE index for this class for efficient indexing in the hp-   case.  
* [0.x.20]*
   Return the active quadrature index for this class for efficient indexing in   the hp-case.  
* [0.x.21]*
   Return the underlying MatrixFree object.  
* [0.x.22]*
   Constructor. Made protected to prevent users from directly using this   class. Takes all data stored in MatrixFree. If applied to problems with   more than one quadrature formula selected during construction of   `matrix_free`, `quad_no` allows to select the appropriate formula.  
* [0.x.23]*
   Constructor that comes with reduced functionality and works similar as   FEValues.  
* [0.x.24]*
   Copy constructor. If FEEvaluationBase was constructed from a mapping, fe,   quadrature, and update flags, the underlying geometry evaluation based on   FEValues will be deep-copied in order to allow for using in parallel with   threads.  
* [0.x.25]*
   Copy assignment operator. If FEEvaluationBase was constructed from a   mapping, fe, quadrature, and update flags, the underlying geometry   evaluation based on FEValues will be deep-copied in order to allow for   using in parallel with threads.  
* [0.x.26]*
   This is the general array for all data fields.  
* [0.x.27]*
   This is the user-visible part of scratch_data_array, only showing the   last part of scratch_data_array. The first part is consumed by   values_dofs, values_quad, etc.  
* [0.x.28]*
   The number of the quadrature formula of the present cell.  
* [0.x.29]*
   A pointer to the underlying data.  
* [0.x.30]*
   A pointer to the underlying DoF indices and constraint description   for the component specified at construction. Also contained in   matrix_info, but it simplifies code if we store a reference to it.  
* [0.x.31]*
   A pointer to the underlying transformation data from unit to real cells   for the given quadrature formula specified at construction. Also   contained in matrix_info, but it simplifies code if we store a reference   to it.  
* [0.x.32]*
   The active FE index for this class for efficient indexing in the hp-case.  
* [0.x.33]*
   The active quadrature index for this class for efficient indexing in the   hp-case.  
* [0.x.34]*
   A pointer to the underlying quadrature formula specified at construction.   Also contained in matrix_info, but it simplifies code if we store a   reference to it.  
* [0.x.35]*
   The number of quadrature points in the current evaluation context.  
* [0.x.36]*
   A pointer to the unit cell shape data, i.e., values, gradients and   Hessians in 1D at the quadrature points that constitute the tensor   product. Also contained in matrix_info, but it simplifies code if we   store a reference to it.  
* [0.x.37]*
   A pointer to the Jacobian information of the present cell. Only set to a   useful value if on a non-Cartesian cell.  
* [0.x.38]*
   A pointer to the Jacobian determinant of the present cell. If on a   Cartesian cell or on a cell with constant Jacobian, this is just the   Jacobian determinant, otherwise the Jacobian determinant times the   quadrature weight.  
* [0.x.39]*
   A pointer to the normal vectors at faces.  
* [0.x.40]*
   A pointer to the normal vectors times the jacobian at faces.  
* [0.x.41]*
   A pointer to the quadrature weights of the underlying quadrature formula.  
* [0.x.42]*
   After a call to reinit(), stores the number of the cell we are currently   working with.  
* [0.x.43]*
   Flag holding information whether a face is an interior or exterior face   according to the defined direction of the normal.  Not used for cells.  
* [0.x.44]*
   Stores the index an FEFaceEvaluation object is currently pointing into   (interior face, exterior face, data associated with cell).  
* [0.x.45]*
   Stores the current number of a face within the given cell in case   `is_face==true`, using values between `0` and `2*dim`.  
* [0.x.46]*
   Stores the orientation of the given face with respect to the standard   orientation, 0 if in standard orientation.  
* [0.x.47]*
   Stores the subface index of the given face. Usually, this variable takes   the value  [2.x.26]  to indicate integration over the   full face, but in case the current physical face has a neighbor that is   more refined, it is a subface and must scale the entries in ShapeInfo   appropriately.  
* [0.x.48]*
   Stores the type of the cell we are currently working with after a call to   reinit(). Valid values are  [2.x.27]   [2.x.28]  and  [2.x.29]  which   have different implications on how the Jacobian transformations are   stored internally in MappingInfo.  
* [0.x.49]*
   Geometry data that can be generated FEValues on the fly with the   respective constructor.  
* [0.x.50]*
 This is the base class for the FEEvaluation classes.  This class needs usually not be called in user code and does not have any public constructor. The usage is through the class FEEvaluation instead. It implements a reinit method that is used to set pointers so that operations on quadrature points can be performed quickly, access functions to vectors for the  [2.x.30]   [2.x.31]  and  [2.x.32]  functions, as well as methods to access values and gradients of finite element functions. It also inherits the geometry access functions provided by the class FEEvaluationBaseData.
*  This class has five template arguments:
*   [2.x.33]  dim Dimension in which this class is to be used
*   [2.x.34]  n_components Number of vector components when solving a system of PDEs. If the same operation is applied to several components of a PDE (e.g. a vector Laplace equation), they can be applied simultaneously with one call (and often more efficiently)
*   [2.x.35]  Number Number format, usually  [2.x.36]  or  [2.x.37] 
*   [2.x.38]  is_face Whether the class is used for a cell integrator (with quadrature dimension the same as the space dimension) or for a face integrator (with quadrature dimension one less)
*   [2.x.39]  VectorizedArrayType Type of array to be woked on in a vectorized                             fashion, defaults to VectorizedArray<Number>
* 

* 
*  [2.x.40]  Currently only VectorizedArray<Number, width> is supported as       VectorizedArrayType.
* 

* 

* 
*  [2.x.41] 

* 
* [0.x.51]*
    [2.x.42]  1: Reading from and writing to vectors  
* [0.x.52]*
   For the vector  [2.x.43]  read out the values on the degrees of freedom of   the current cell, and store them internally. Similar functionality as the   function  [2.x.44]  when no constraints are   present, but it also includes constraints from hanging nodes, so one can   see it as a similar function to  [2.x.45]  as   well. Note that if vectorization is enabled, the DoF values for several   cells are set.     If some constraints on the vector are inhomogeneous, use the function   read_dof_values_plain instead and provide the vector with useful data   also in constrained positions by calling  [2.x.46]    When accessing vector entries during the solution of linear systems, the   temporary solution should always have homogeneous constraints and this   method is the correct one.     If the given vector template class is a block vector (determined through   the template function  [2.x.47]  which checks   for vectors derived from  [2.x.48]  or an    [2.x.49]  or  [2.x.50]  this function reads    [2.x.51]  blocks from the block vector starting at the index    [2.x.52]  For non-block vectors,  [2.x.53]  is ignored.    
*  [2.x.54]  If this class was constructed without a MatrixFree object and the   information is acquired on the fly through a    [2.x.55]  only one single cell is used by this   class and this function extracts the values of the underlying components   on the given cell. This call is slower than the ones done through a   MatrixFree object and lead to a structure that does not effectively use   vectorization in the evaluate routines based on these values (instead,    [2.x.56]  same copies are worked on).  
* [0.x.53]*
   For the vector  [2.x.57]  read out the values on the degrees of freedom of   the current cell, and store them internally. Similar functionality as the   function  [2.x.58]  As opposed to the   read_dof_values function, this function reads out the plain entries from   vectors, without taking stored constraints into account. This way of   access is appropriate when the constraints have been distributed on the   vector by a call to  [2.x.59]  previously. This   function is also necessary when inhomogeneous constraints are to be used,   as MatrixFree can only handle homogeneous constraints. Note that if   vectorization is enabled, the DoF values for several cells are set.     If the given vector template class is a block vector (determined through   the template function  [2.x.60]  which checks   for vectors derived from  [2.x.61]  or an    [2.x.62]  or  [2.x.63]  this function reads    [2.x.64]  blocks from the block vector starting at the index    [2.x.65]  For non-block vectors,  [2.x.66]  is ignored.    
*  [2.x.67]  If this class was constructed without a MatrixFree object and the   information is acquired on the fly through a    [2.x.68]  only one single cell is used by this   class and this function extracts the values of the underlying components   on the given cell. This call is slower than the ones done through a   MatrixFree object and lead to a structure that does not effectively use   vectorization in the evaluate routines based on these values (instead,    [2.x.69]  same copies are worked on).  
* [0.x.54]*
   Takes the values stored internally on dof values of the current cell and   sums them into the vector  [2.x.70]  The function also applies constraints   during the write operation. The functionality is hence similar to the   function  [2.x.71]  If vectorization   is enabled, the DoF values for several cells are used.     If the given vector template class is a block vector (determined through   the template function  [2.x.72]  which checks   for vectors derived from  [2.x.73]  or an    [2.x.74]  or  [2.x.75]  this function   writes to  [2.x.76]  blocks of the block vector starting at the   index  [2.x.77]  For non-block vectors,  [2.x.78]  is ignored.     The  [2.x.79]  can be used to suppress the write access for some of the   cells contained in the current cell vectorization batch, e.g. in case of   local time stepping, where some cells are excluded from a call. A value   of `true` in the bitset means that the respective lane index will be   processed, whereas a value of `false` skips this index. The default   setting is a bitset that contains all ones, which will write the   accumulated integrals to all cells in the batch.    
*  [2.x.80]  If this class was constructed without a MatrixFree object and the   information is acquired on the fly through a    [2.x.81]  only one single cell is used by this   class and this function extracts the values of the underlying components   on the given cell. This call is slower than the ones done through a   MatrixFree object and lead to a structure that does not effectively use   vectorization in the evaluate routines based on these values (instead,    [2.x.82]  same copies are worked on).  
* [0.x.55]*
   Takes the values stored internally on dof values of the current cell and   writes them into the vector  [2.x.83]  The function skips the degrees of   freedom which are constrained. As opposed to the   distribute_local_to_global method, the old values at the position given   by the current cell are overwritten. Thus, if a degree of freedom is   associated to more than one cell (as usual in continuous finite   elements), the values will be overwritten and only the value written last   is retained. Please note that in a parallel context this function might   also touch degrees of freedom owned by other MPI processes, so that a   subsequent update or accumulation of ghost values as done by    [2.x.84]  might invalidate the degrees of freedom set by this   function.     If the given vector template class is a block vector (determined through   the template function  [2.x.85]  which checks   for vectors derived from  [2.x.86]  or an    [2.x.87]  or  [2.x.88]  this function   writes to  [2.x.89]  blocks of the block vector starting at the   index  [2.x.90]  For non-block vectors,  [2.x.91]  is ignored.     The  [2.x.92]  can be used to suppress the write access for some   of the cells contained in the current cell vectorization batch, e.g. in   case of local time stepping, where some  cells are excluded from a call.   A value of `true` in the bitset means that the respective lane index will   be processed, whereas a value of `false` skips this index. The default   setting is a bitset that contains all ones, which will write the   accumulated integrals to all cells in the batch.    
*  [2.x.93]  If this class was constructed without a MatrixFree object and the   information is acquired on the fly through a    [2.x.94]  only one single cell is used by this   class and this function extracts the values of the underlying components   on the given cell. This call is slower than the ones done through a   MatrixFree object and lead to a structure that does not effectively use   vectorization in the evaluate routines based on these values (instead,    [2.x.95]  same copies are worked on).  
* [0.x.56]*
   Same as set_dof_values(), but without resolving constraints.  
* [0.x.57]*
    [2.x.96]  2: Access to data at quadrature points or the gather vector data  
* [0.x.58]*
   Return the value stored for the local degree of freedom with index  [2.x.97]    dof. If the object is vector-valued, a vector-valued return argument is   given. Thus, the argument  [2.x.98]  can at most run until  [2.x.99]    dofs_per_component rather than  [2.x.100]  since the different   components of a vector-valued FE are return together. Note that when   vectorization is enabled, values from several cells are grouped   together. If  [2.x.101]  was called last, the value corresponds to   the one set there. If  [2.x.102]  was called last, it instead   corresponds to the value of the integrated function with the test   function of the given index.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.59]*
   Write a value to the field containing the degrees of freedom with   component  [2.x.103]  Writes to the same field as is accessed through  [2.x.104]    get_dof_value. Therefore, the original data that was read from a vector   is overwritten as soon as a value is submitted.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.60]*
   Return the value of a finite element function at quadrature point number    [2.x.105]  after a call to  [2.x.106]  with    [2.x.107]  set, or the value that has been stored there with   a call to  [2.x.108]  If the object is   vector-valued, a vector-valued return argument is given. Note that when   vectorization is enabled, values from several cells are grouped together.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.61]*
   Write a value to the field containing the values on quadrature points   with component  [2.x.109]  Access to the same field as through   get_value(). If applied before the function  [2.x.110]    with  [2.x.111]  set is called, this specifies the value   which is tested by all basis function on the current cell and integrated   over.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.62]*
   Return the gradient of a finite element function at quadrature point   number  [2.x.112]  after a call to  [2.x.113]  with    [2.x.114]  or the value that has been stored there with   a call to  [2.x.115]      Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.63]*
   Return the derivative of a finite element function at quadrature point   number  [2.x.116]  after a call to    [2.x.117]  the direction normal   to the face:  [2.x.118]      This call is equivalent to calling get_gradient() get_normal_vector()   but will use a more efficient internal representation of data.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.64]*
   Write a contribution that is tested by the gradient to the field   containing the values on quadrature points with component  [2.x.119]    Access to the same field as through get_gradient(). If applied before the   function  [2.x.120]  is called,   this specifies what is tested by all basis function gradients on the   current cell and integrated over.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.65]*
   Write a contribution that is tested by the gradient to the field   containing the values on quadrature points with component  [2.x.121]    q_point. Access to the same field as through get_gradient() or   get_normal_derivative(). If applied before the function    [2.x.122]  is called, this   specifies what is tested by all basis function gradients on the current   cell and integrated over.    
*  [2.x.123]  This operation writes the data to the same field as   submit_gradient(). As a consequence, only one of these two can be   used. Usually, the contribution of a potential call to this function must   be added into the contribution for submit_gradient().    
*  [2.x.124]  The derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.66]*
   Return the Hessian of a finite element function at quadrature point   number  [2.x.125]  after a call to    [2.x.126]  If only the diagonal   or even the trace of the Hessian, the Laplacian, is needed, use the other   functions below.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.67]*
   Return the diagonal of the Hessian of a finite element function at   quadrature point number  [2.x.127]  after a call to    [2.x.128]      Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.68]*
   Return the Laplacian (i.e., the trace of the Hessian) of a finite element   function at quadrature point number  [2.x.129]  after a call to    [2.x.130]  Compared to the case   when computing the full Hessian, some operations can be saved when only   the Laplacian is requested.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.69]*
   Return the divergence of a vector-valued finite element at quadrature   point number  [2.x.131]  after a call to  [2.x.132]     
*  [2.x.133]  Only available for n_components_==dim.  
* [0.x.70]*
   Return the symmetric gradient of a vector-valued finite element at   quadrature point number  [2.x.134]  after a call to  [2.x.135]    evaluate(...,true,...). It corresponds to <tt>0.5   (grad+grad<sup>T</sup>)</tt>.    
*  [2.x.136]  Only available for n_components_==dim.  
* [0.x.71]*
   Return the curl of the vector field,  [2.x.137]  after a call to  [2.x.138]    evaluate(...,true,...).    
*  [2.x.139]  Only available for n_components_==dim.  
* [0.x.72]*
   Write a contribution that is tested by the divergence to the field   containing the values on quadrature points with component  [2.x.140]    Access to the same field as through  [2.x.141]  If applied before   the function  [2.x.142]  is called, this specifies what is   tested by all basis function gradients on the current cell and integrated   over.    
*  [2.x.143]  Only available for n_components_==dim.    
*  [2.x.144]  This operation writes the data to the same field as   submit_gradient(). As a consequence, only one of these two can be   used. Usually, the contribution of a potential call to this function must   be added into the diagonal of the contribution for submit_gradient().  
* [0.x.73]*
   Write a contribution that is tested by the symmetric gradient to the field   containing the values on quadrature points with component  [2.x.145]    Access to the same field as through  [2.x.146]  If applied before   the function  [2.x.147]  is called, this specifies the   symmetric gradient which is tested by all basis function symmetric   gradients on the current cell and integrated over.    
*  [2.x.148]  Only available for n_components_==dim.    
*  [2.x.149]  This operation writes the data to the same field as   submit_gradient(). As a consequence, only one of these two can be   used. Usually, the contribution of a potential call to this function must   be added to the respective entries of the rank-2 tensor for   submit_gradient().  
* [0.x.74]*
   Write the components of a curl containing the values on quadrature point    [2.x.150]  Access to the same data field as through  [2.x.151]     
*  [2.x.152]  Only available for n_components_==dim.    
*  [2.x.153]  This operation writes the data to the same field as   submit_gradient(). As a consequence, only one of these two can be   used. Usually, the contribution of a potential call to this function must   be added to the respective entries of the rank-2 tensor for   submit_gradient().  
* [0.x.75]*
   Takes values at quadrature points, multiplies by the Jacobian determinant   and quadrature weights (JxW) and sums the values for all quadrature   points on the cell. The result is a scalar, representing the integral   over the function over the cell. If a vector-element is used, the   resulting components are still separated. Moreover, if vectorization is   enabled, the integral values of several cells are contained in the slots   of the returned VectorizedArray field.    
*  [2.x.154]  In case the FEEvaluation object is initialized with a batch of   cells where not all lanes in the SIMD vector VectorizedArray are   representing actual data, this method performs computations on dummy data   (that is copied from the last valid lane) that will not make sense. Thus,   the user needs to make sure that it is not used in any computation   explicitly, like when summing the results of several cells.  
* [0.x.76]*
    [2.x.155]  3: Access to internal data  
* [0.x.77]*
   Return a read-only pointer to the first field of the dof values. This is   the data field the read_dof_values() functions write into. First come the   dof values for the first component, then all values for the second   component, and so on. This is related to the internal data structures   used in this class. In general, it is safer to use the get_dof_value()   function instead.  
* [0.x.78]*
   Return a read and write pointer to the first field of the dof values.   This is the data field the read_dof_values() functions write into. First   come the dof values for the first component, then all values for the   second component, and so on. This is related to the internal data   structures used in this class. In general, it is safer to use the   get_dof_value() function instead.  
* [0.x.79]*
   Return a read-only pointer to the first field of function values on   quadrature points. First come the function values on all quadrature   points for the first component, then all values for the second component,   and so on. This is related to the internal data structures used in this   class. The raw data after a call to  [2.x.156]  only contains unit cell   operations, so possible transformations, quadrature weights etc. must be   applied manually. In general, it is safer to use the get_value() function   instead, which does all the transformation internally.  
* [0.x.80]*
   Return a read and write pointer to the first field of function values on   quadrature points. First come the function values on all quadrature   points for the first component, then all values for the second component,   and so on. This is related to the internal data structures used in this   class. The raw data after a call to  [2.x.157]  only contains unit cell   operations, so possible transformations, quadrature weights etc. must be   applied manually. In general, it is safer to use the get_value() function   instead, which does all the transformation internally.  
* [0.x.81]*
   Return a read-only pointer to the first field of function gradients on   quadrature points. First comes the x-component of the gradient for the   first component on all quadrature points, then the y-component, and so   on. Next comes the x-component of the second component, and so on. This   is related to the internal data structures used in this class. The raw   data after a call to  [2.x.158]  only contains unit cell operations, so   possible transformations, quadrature weights etc. must be applied   manually. In general, it is safer to use the get_gradient() function   instead, which does all the transformation internally.  
* [0.x.82]*
   Return a read and write pointer to the first field of function gradients   on quadrature points. First comes the x-component of the gradient for the   first component on all quadrature points, then the y-component, and so   on. Next comes the x-component of the second component, and so on. This   is related to the internal data structures used in this class. The raw   data after a call to  [2.x.159]  only contains unit cell operations, so   possible transformations, quadrature weights etc. must be applied   manually. In general, it is safer to use the get_gradient() function   instead, which does all the transformation internally.  
* [0.x.83]*
   Return a read-only pointer to the first field of function hessians on   quadrature points. First comes the xx-component of the hessian for the   first component on all quadrature points, then the yy-component, zz-   component in (3D), then the xy-component, and so on. Next comes the xx-   component of the second component, and so on. This is related to the   internal data structures used in this class. The raw data after a call to    [2.x.160]  only contains unit cell operations, so possible   transformations, quadrature weights etc. must be applied manually. In   general, it is safer to use the get_laplacian() or get_hessian()   functions instead, which does all the transformation internally.  
* [0.x.84]*
   Return a read and write pointer to the first field of function hessians   on quadrature points. First comes the xx-component of the hessian for the   first component on all quadrature points, then the yy-component, zz-   component in (3D), then the xy-component, and so on. Next comes the xx-   component of the second component, and so on. This is related to the   internal data structures used in this class. The raw data after a call to    [2.x.161]  only contains unit cell operations, so possible   transformations, quadrature weights etc. must be applied manually. In   general, it is safer to use the get_laplacian() or get_hessian()   functions instead, which does all the transformation internally.  
* [0.x.85]*
   Return the first selected component.  
* [0.x.86]*
   Constructor. Made protected to prevent users from directly using this   class. Takes all data stored in MatrixFree. If applied to problems with   more than one finite element or more than one quadrature formula selected   during construction of  [2.x.162]   [2.x.163]   [2.x.164]    first_selected_component and  [2.x.165]  allow to select the appropriate   components.  
* [0.x.87]*
   Constructor that comes with reduced functionality and works similar as   FEValues. The arguments are similar to the ones passed to the constructor   of FEValues, with the notable difference that FEEvaluation expects a one-   dimensional quadrature formula, Quadrature<1>, instead of a  [2.x.166]    dimensional one. The finite element can be both scalar or vector valued,   but this method always only selects a scalar base element at a time (with    [2.x.167]  copies as specified by the class template argument). For   vector-valued elements, the optional argument  [2.x.168]    allows to specify the index of the base element to be used for   evaluation. Note that the internal data structures always assume that the   base element is primitive, non-primitive are not supported currently.     As known from FEValues, a call to the reinit method with a    [2.x.169]  is necessary to make the geometry and   degrees of freedom of the current class known. If the iterator includes   DoFHandler information (i.e., it is a  [2.x.170]  or   similar), the initialization allows to also read from or write to vectors   in the standard way for  [2.x.171]  types for one   cell at a time. However, this approach is much slower than the path with   MatrixFree with MPI since index translation has to be done. As only one   cell at a time is used, this method does not vectorize over several   elements (which is most efficient for vector operations), but only   possibly within the element if the evaluate/integrate routines are   combined inside user code (e.g. for computing cell matrices).     The optional FEEvaluationBaseData object allows several   FEEvaluation objects to share the geometry evaluation, i.e., the   underlying mapping and quadrature points do only need to be evaluated   once. This only works if the quadrature formulas are the same. Otherwise,   a new evaluation object is created. Make sure to not pass an optional   object around when you intend to use the FEEvaluation object in %parallel   with another one because otherwise the intended sharing may create race   conditions.  
* [0.x.88]*
   Copy constructor. If FEEvaluationBase was constructed from a mapping, fe,   quadrature, and update flags, the underlying geometry evaluation based on   FEValues will be deep-copied in order to allow for using in parallel with   threads.  
* [0.x.89]*
   Copy assignment operator. If FEEvaluationBase was constructed from a   mapping, fe, quadrature, and update flags, the underlying geometry   evaluation based on FEValues will be deep-copied in order to allow for   using in parallel with threads.  
* [0.x.90]*
   A unified function to read from and write into vectors based on the given   template operation. It can perform the operation for  [2.x.172]     [2.x.173]  and  [2.x.174]  It performs the   operation for several vectors at a time.  
* [0.x.91]*
   A unified function to read from and write into vectors based on the given   template operation for DG-type schemes where all degrees of freedom on   cells are contiguous. It can perform the operation for read_dof_values(),   distribute_local_to_global(), and set_dof_values() for several vectors at   a time, depending on n_components.  
* [0.x.92]*
   A unified function to read from and write into vectors based on the given   template operation for the case when we do not have an underlying   MatrixFree object. It can perform the operation for  [2.x.175]     [2.x.176]  and  [2.x.177]  It performs the   operation for several vectors at a time, depending on n_components.  
* [0.x.93]*
   This field stores the values for local degrees of freedom (e.g. after   reading out from a vector but before applying unit cell transformations   or before distributing them into a result vector). The methods   get_dof_value() and submit_dof_value() read from or write to this field.     The values of this array are stored in the start section of    [2.x.178]  Due to its access as a thread local memory, the   memory can get reused between different calls. As opposed to requesting   memory on the stack, this approach allows for very large polynomial   degrees.  
* [0.x.94]*
   This field stores the values of the finite element function on quadrature   points after applying unit cell transformations or before integrating.   The methods get_value() and submit_value() access this field.     The values of this array are stored in the start section of    [2.x.179]  Due to its access as a thread local memory, the   memory can get reused between different calls. As opposed to requesting   memory on the stack, this approach allows for very large polynomial   degrees.  
* [0.x.95]*
   This field stores the gradients of the finite element function on   quadrature points after applying unit cell transformations or before   integrating. The methods get_gradient() and submit_gradient() (as well as   some specializations like get_symmetric_gradient() or get_divergence())   access this field.     The values of this array are stored in the start section of    [2.x.180]  Due to its access as a thread local memory, the   memory can get reused between different calls. As opposed to requesting   memory on the stack, this approach allows for very large polynomial   degrees.  
* [0.x.96]*
   This field stores the Hessians of the finite element function on   quadrature points after applying unit cell transformations. The methods   get_hessian(), get_laplacian(), get_hessian_diagonal() access this field.     The values of this array are stored in the start section of    [2.x.181]  Due to its access as a thread local memory, the   memory can get reused between different calls. As opposed to requesting   memory on the stack, this approach allows for very large polynomial   degrees.  
* [0.x.97]*
   Stores the number of components in the finite element as detected in the   MatrixFree storage class for comparison with the template argument.  
* [0.x.98]*
   Debug information to track whether dof values have been initialized   before accessed. Used to control exceptions when uninitialized data is   used.  
* [0.x.99]*
   Debug information to track whether values on quadrature points have been   initialized before accessed. Used to control exceptions when   uninitialized data is used.  
* [0.x.100]*
   Debug information to track whether gradients on quadrature points have   been initialized before accessed. Used to control exceptions when   uninitialized data is used.  
* [0.x.101]*
   Debug information to track whether Hessians on quadrature points have   been initialized before accessed. Used to control exceptions when   uninitialized data is used.  
* [0.x.102]*
   Debug information to track whether values on quadrature points have been   submitted for integration before the integration is actually stared. Used   to control exceptions when uninitialized data is used.  
* [0.x.103]*
   Debug information to track whether gradients on quadrature points have   been submitted for integration before the integration is actually stared.   Used to control exceptions when uninitialized data is used.  
* [0.x.104]*
   For a FiniteElement with more than one base element, select at which   component this data structure should start.  
* [0.x.105]*
   A temporary data structure necessary to read degrees of freedom when no   MatrixFree object was given at initialization.  
* [0.x.106]*
   Sets the pointers for values, gradients, hessians to the central   scratch_data_array of the base class.  
* [0.x.107]*
 This class provides access to the data fields of the FEEvaluation classes. Generic access is achieved through the base class, and specializations for scalar and vector-valued elements are defined separately.
* 

* 
*  [2.x.182] 

* 
* [0.x.108]*
   Constructor. Made protected to prevent initialization in user code. Takes   all data stored in MatrixFree. If applied to problems with more than one   finite element or more than one quadrature formula selected during   construction of  [2.x.183]   [2.x.184]  and  [2.x.185]    quad_no allow to select the appropriate components.  
* [0.x.109]*
   Constructor with reduced functionality for similar usage of FEEvaluation   as FEValues, including matrix assembly.  
* [0.x.110]*
   Copy constructor  
* [0.x.111]*
   Copy assignment operator  
* [0.x.112]*
 This class provides access to the data fields of the FEEvaluation classes. Partial specialization for scalar fields that defines access with simple data fields, i.e., scalars for the values and Tensor<1,dim> for the gradients.
* 

* 
*  [2.x.186] 

* 
* [0.x.113]*
    [2.x.187]   [2.x.188]   
* [0.x.114]*
    [2.x.189]   [2.x.190]   
* [0.x.115]*
    [2.x.191]   [2.x.192]   
* [0.x.116]*
    [2.x.193]   [2.x.194]   
* [0.x.117]*
    [2.x.195]   [2.x.196]   
* [0.x.118]*
    [2.x.197]   [2.x.198]   
* [0.x.119]*
    [2.x.199]   [2.x.200]   
* [0.x.120]*
    [2.x.201]   [2.x.202]   
* [0.x.121]*
    [2.x.203]   [2.x.204]   
* [0.x.122]*
    [2.x.205]   [2.x.206]   
* [0.x.123]*
    [2.x.207]   [2.x.208]   
* [0.x.124]*
    [2.x.209]   [2.x.210]   
* [0.x.125]*
    [2.x.211]   [2.x.212]   
* [0.x.126]*
   Constructor. Made protected to avoid initialization in user code. Takes   all data stored in MatrixFree. If applied to problems with more than one   finite element or more than one quadrature formula selected during   construction of  [2.x.213]   [2.x.214]  and  [2.x.215]    quad_no allow to select the appropriate components.  
* [0.x.127]*
   Constructor with reduced functionality for similar usage of FEEvaluation   as FEValues, including matrix assembly.  
* [0.x.128]*
   Copy constructor  
* [0.x.129]*
   Copy assignment operator  
* [0.x.130]*
 This class provides access to the data fields of the FEEvaluation classes. Partial specialization for fields with as many components as the underlying space dimension, i.e., values are of type Tensor<1,dim> and gradients of type Tensor<2,dim>. Provides some additional functions for access, like the symmetric gradient and divergence.
* 

* 
*  [2.x.216] 

* 
* [0.x.131]*
    [2.x.217]   [2.x.218]   
* [0.x.132]*
   Return the divergence of a vector-valued finite element at quadrature   point number  [2.x.219]  after a call to  [2.x.220]   
* [0.x.133]*
   Return the symmetric gradient of a vector-valued finite element at   quadrature point number  [2.x.221]  after a call to  [2.x.222]    evaluate(...,true,...). It corresponds to <tt>0.5   (grad+grad<sup>T</sup>)</tt>.  
* [0.x.134]*
   Return the curl of the vector field,  [2.x.223]  after a call to  [2.x.224]    evaluate(...,true,...).  
* [0.x.135]*
    [2.x.225]   [2.x.226]   
* [0.x.136]*
    [2.x.227]   [2.x.228]   
* [0.x.137]*
    [2.x.229]   [2.x.230]   
* [0.x.138]*
   Write a contribution that is tested by the gradient to the field   containing the values on quadrature points with component  [2.x.231]    This function is an alternative to the other submit_gradient function   when using a system of fixed number of equations which happens to   coincide with the dimension for some dimensions, but not all. To allow   for dimension-independent programming, this function can be used instead.  
* [0.x.139]*
   Write a contribution that is tested by the divergence to the field   containing the values on quadrature points with component  [2.x.232]    Access to the same field as through  [2.x.233]  If applied before   the function  [2.x.234]  is called, this specifies what is   tested by all basis function gradients on the current cell and integrated   over.  
* [0.x.140]*
   Write a contribution that is tested by the symmetric gradient to the field   containing the values on quadrature points with component  [2.x.235]    Access to the same field as through  [2.x.236]  If applied before   the function  [2.x.237]  is called, this specifies the   symmetric gradient which is tested by all basis function symmetric   gradients on the current cell and integrated over.  
* [0.x.141]*
   Write the components of a curl containing the values on quadrature point    [2.x.238]  Access to the same data field as through  [2.x.239]   
* [0.x.142]*
   Constructor. Made protected to avoid initialization in user code. Takes   all data stored in MatrixFree. If applied to problems with more than one   finite element or more than one quadrature formula selected during   construction of  [2.x.240]   [2.x.241]  and  [2.x.242]    quad_no allow to select the appropriate components.  
* [0.x.143]*
   Constructor with reduced functionality for similar usage of FEEvaluation   as FEValues, including matrix assembly.  
* [0.x.144]*
   Copy constructor  
* [0.x.145]*
   Copy assignment operator  
* [0.x.146]*
 This class provides access to the data fields of the FEEvaluation classes. Partial specialization for scalar fields in 1d that defines access with simple data fields, i.e., scalars for the values and Tensor<1,1> for the gradients.
* 

* 
*  [2.x.243] 

* 
* [0.x.147]*
    [2.x.244]   [2.x.245]   
* [0.x.148]*
    [2.x.246]   [2.x.247]   
* [0.x.149]*
    [2.x.248]   [2.x.249]   
* [0.x.150]*
    [2.x.250]   [2.x.251]   
* [0.x.151]*
    [2.x.252]   [2.x.253]   
* [0.x.152]*
    [2.x.254]   [2.x.255]   
* [0.x.153]*
    [2.x.256]   [2.x.257]   
* [0.x.154]*
    [2.x.258]   [2.x.259]   
* [0.x.155]*
    [2.x.260]   [2.x.261]   
* [0.x.156]*
    [2.x.262]   [2.x.263]   
* [0.x.157]*
    [2.x.264]   [2.x.265]   
* [0.x.158]*
    [2.x.266]   [2.x.267]   
* [0.x.159]*
    [2.x.268]   [2.x.269]   
* [0.x.160]*
    [2.x.270]   [2.x.271]   
* [0.x.161]*
    [2.x.272]   [2.x.273]   
* [0.x.162]*
    [2.x.274]   [2.x.275]   
* [0.x.163]*
    [2.x.276]   [2.x.277]   
* [0.x.164]*
   Constructor. Made protected to avoid initialization in user code. Takes   all data stored in MatrixFree. If applied to problems with more than one   finite element or more than one quadrature formula selected during   construction of  [2.x.278]   [2.x.279]  and  [2.x.280]    quad_no allow to select the appropriate components.  
* [0.x.165]*
   Constructor with reduced functionality for similar usage of FEEvaluation   as FEValues, including matrix assembly.  
* [0.x.166]*
   Copy constructor  
* [0.x.167]*
   Copy assignment operator  
* [0.x.168]*
 The class that provides all functions necessary to evaluate functions at quadrature points and cell integrations. In functionality, this class is similar to FEValues, however, it includes a lot of specialized functions that make it much faster (between 5 and 500, depending on the polynomial degree). For evaluation of face terms in DG, see the class FEFaceEvaluation.
*  [1.x.0]
*  [1.x.1]
*  The first and foremost way of usage is to initialize this class from a MatrixFree object that caches everything related to the degrees of freedom and the mapping information. This way, it is possible to use vectorization for applying a differential operator for several cells at once.
*  The capabilities of FEEvaluation span a large spectrum of integration tasks for weak forms. In general, there are two classes of tasks that get done. One is the  [2.x.281]  path that interpolates from a solution vector to quadrature points:
* 

* 
* [1.x.2]
* 
*  Likewise, a gradient of the finite element solution represented by  [2.x.282]  vector can be interpolated to the quadrature points by  [2.x.283]  phi.get_gradient(q). The combination of read_dof_values(), evaluate() and get_value() is similar to what  [2.x.284]  or  [2.x.285]  does, but it is in general much faster because it makes use of the tensor product, see the description of the evaluation routines below, and can do this operation for several cells at once through vectorization.
*  The second class of tasks done by FEEvaluation are integration tasks for right hand sides. In finite element computations, these typically consist of multiplying a quantity on quadrature points (a function value, or a field interpolated by the finite element space itself) by a set of test functions and integrating over the cell through summation of the values in each quadrature point, multiplied by the quadrature weight and the Jacobian determinant of the transformation. If a generic Function object is given and we want to compute  [2.x.286] , this is done by the following cell-wise integration:
* 

* 
* [1.x.3]
* 
*  In this code, the call to  [2.x.287]  prepares for the multiplication by the test function prior to the actual integration (inside the submit call, the value to be tested is also multiplied by the determinant of the Jacobian and the quadrature weight). In the  [2.x.288]  call, an integral contribution tested by each basis function underlying the FEEvaluation object (e.g. the four linear shape functions of FE_Q [2.x.289]  in 2D) is computed, which gives the vector entries to be summed into the  [2.x.290]  vector. Note that the above code needs to explicitly loop over the components in the vectorized array for evaluating the function, which is necessary for interfacing with a generic Function object with double arguments. Simple functions can also be implemented in VectorizedArray form directly as VectorizedArray provides the basic math operations.
*  For evaluating a bilinear form, the evaluation on a source vector is combined with the integration involving test functions that get written into a result vector. This setting is the context of matrix-free operator evaluation and explained in the  [2.x.291]  and  [2.x.292]  tutorial programs.
*  Note that the two vector accesses through  [2.x.293]  and  [2.x.294]  resolve constraints on the fly, based on the AffineConstraints object specified at the  [2.x.295]  call. In case the values in the degrees of freedom are of interest (usually only the values in quadrature points are necessary), these can be accessed through  [2.x.296]  where i is the index of the basis function. Note that the numbering of the degrees of freedom for continuous elements in FEEvaluation is different from the ordering in FE_Q (or FEValues) because FEEvaluation needs to access them in lexicographic order, which is the ordering used in FE_DGQ, for instance. Re-indexing would be too expensive because the access inside evaluate() and integrate() is on the critical path in the tensorial evaluation parts. An alternative to filling the DoF values by read_dof_values() before an evaluate() call is to manually assign a value by a set_dof_value() call. Likewise, if the local result of integration should be further processed rather than scattered into a vector by distribute_local_to_global(), one can access it by get_dof_value() after an integrate() call. An example for using the values of an integral in a different context is fast assembly of matrices as shown in the next subsection.
*  For most operator evaluation tasks that repeatedly go through the mesh, the realization by MatrixFree that combines pre-computed data for the mapping (Jacobian transformations for the geometry description) with on-the-fly evaluation of basis functions is the most efficient way of doing things. In other words, the framework selects a trade-off between memory usage and initialization of objects that is suitable for replacement of matrix-vector products or explicit time integration in a matrix-free way.
*  [1.x.4]
*  The second form of usage is to initialize FEEvaluation from geometry information generated by FEValues. This allows to apply the integration loops on the fly without prior initialization of MatrixFree objects. This can be useful when the memory and initialization cost of MatrixFree is not acceptable, e.g. when a different number of quadrature points should be used for one single evaluation in error computation. Also, when using the routines of this class to assemble matrices the trade-off implied by the MatrixFree class may not be desired. In such a case, the cost to initialize the necessary geometry data on the fly is comparably low and thus avoiding a global object MatrixFree can be useful. When used in this way, reinit methods reminiscent from FEValues with a cell iterator are used. However, note that this model results in working on a single cell at a time, with geometry data duplicated in all components of the vectorized array. Thus, vectorization is only useful when it can apply the same operation on different data, e.g. when performing matrix assembly.
*  As an example, consider the following code to assemble the contributions to the Laplace matrix:
* 

* 
* [1.x.5]
* 
*  This code generates the columns of the cell matrix with the loop over  [2.x.297]  above. The way this is done is the following: FEEvaluation's routines focus on the evaluation of finite element operators, so for computing a cell matrix out of an operator evaluation it is applied to all the unit vectors on the cell. Applying the operator on a unit vector might seem inefficient but the evaluation routines used here are so quick that they still work much faster than what is possible with FEValues. In particular, the complexity is  [2.x.298]  rather than  [2.x.299] .
*  Due to vectorization, we can generate matrix columns for several unit vectors at a time (e.g. 4). The variable  [2.x.300]  make sure that we do the last iteration where the number of cell dofs is not divisible by the vectorization length correctly. Also note that we need to get the internal dof numbering applied by fe_eval because FEEvaluation internally uses a lexicographic numbering of degrees of freedom as explained above.
*  [1.x.6]
*  The temporary data for holding the solution values on the local degrees of freedom as well as the interpolated values, gradients, and Hessians on quadrature points is a scratch array provided by  [2.x.301]  that is re-used between different calls to FEEvaluation. Therefore, constructing an FEEvaluation object is typically cheap and does not involve any expensive operation. Only a few dozen pointers to the actual data fields are set during construction. Therefore, no negative performance impact arises when creating an FEEvaluation several times per loop, such as at the top of a `local_cell_operation` operation that is split in small chunks for a parallel for loop, obviating a separate scratch data field for parallel loops as necessary in the loop of  [2.x.302] 
*  When using the FEEvaluation class in multithreaded mode, the thread local storage of the scratch data in MatrixFree automatically makes sure that each thread gets it private data array. Note, however, that deal.II must be compiled with thread support also when all the thread parallelization is provided externally and not done via deal.II's routines, such as OpenMP. This is because deal.II needs to know the notation of thread local storage. The FEEvaluation kernels have been verified to work within OpenMP loops.
*  [1.x.7]
*  This class is designed to perform all arithmetics on single-instruction multiple-data (SIMD) instructions present on modern CPUs by explicit vectorization, which are made available in deal.II through the class VectorizedArray, using the widest vector width available at configure/compile time. In order to keep programs flexible, FEEvaluation always applies vectorization over several elements. This is often the best compromise because computations on different elements are usually independent in the finite element method (except of course the process of adding an integral contribution to a global residual vector), also in more complicated scenarios: Stabilization parameter can e.g. be defined as the maximum of some quantities on all quadrature points of a cell divided by the cell's volume, but without locally mixing the results with neighbors. Using the terminology from computer architecture, the design of FEEvaluation relies on not doing any cross-lane data exchange when operating on the cell in typical integration scenarios.
*  When the number of cells in the problem is not a multiple of the number of array elements in the SIMD vector, the implementation of FEEvaluation fills in some dummy entries in the unused SIMD lanes and carries them around nonetheless, a choice made necessary since the length of VectorizedArray is fixed at compile time. Yet, this approach most often results in superior code as compared to an auto-vectorization setup where an alternative unvectorized code path would be necessary next to the vectorized version to be used on fully populated lanes, together with a dispatch mechanism. In  [2.x.303]  the empty lanes resulting from a reinit() call to an incomplete batch of cells are set to zero, whereas  [2.x.304]  or  [2.x.305]  simply ignores the content in the empty lanes. The number of actually filled SIMD lanes can by queried by  [2.x.306] 
*  Obviously, the computations performed on the artificial lanes (without real data) should never be mixed with valid results. The contract in using this class is that the user makes sure that lanes are not crossed in user code, in particular since it is not clear a priori which cells are going to be put together in vectorization. For example, results on an element should not be added to results on other elements except through the global vector access methods or by access that is masked by  [2.x.307]  No guarantee can be made that results on artificial lanes will always be zero that can safely be added to other results: The data on JxW or Jacobians is copied from the last valid lane in order to avoid division by zero that could trigger floating point exceptions or trouble in other situations.
*  [1.x.8]
*  This class contains specialized evaluation routines for elements based on tensor-product quadrature formulas and tensor-product-like shape functions, including standard FE_Q or FE_DGQ elements and quadrature points symmetric around 0.5 (like Gauss quadrature), FE_DGP elements based on truncated tensor products as well as the faster case of Gauss-Lobatto elements with Gauss-Lobatto quadrature which give diagonal mass matrices and quicker evaluation internally. The main benefit of this class is the evaluation of all shape functions in all quadrature or integration over all shape functions in  [2.x.308]  operations instead of the slower  [2.x.309]  complexity in the evaluation routines of FEValues. This is done by an algorithm called sum factorization which factors out constant factors during the evaluation along a coordinate direction. This algorithm is the basis of many spectral element algorithms.
*  Note that many of the operations available through this class are inherited from the base class FEEvaluationBase, in particular reading from and writing to vectors. Also, the class inherits from FEEvaluationAccess that implements access to values, gradients and Hessians of the finite element function on quadrature points.
*  This class assumes that the shape functions of the FiniteElement under consideration do  [2.x.310] not [2.x.311]  depend on the geometry of the cells in real space. Currently, other finite elements cannot be treated with the matrix-free concept.
*  [1.x.9]
*  The class FEEvaluation as two usage models. The first usage model is to specify the polynomial degree as a template parameter. This guarantees maximum efficiency: The evaluation with sum factorization performs a number of nested short 1D loops of length equal to the polynomial degree plus one. If the loop bounds are known at compile time, the compiler can unroll loops as deemed most efficient by its heuristics. At least the innermost loop is almost always completely unrolled, avoiding the loop overhead.
*  However, carrying the polynomial degree (and the number of quadrature points) as a template parameter makes things more complicated in codes where different polynomial degrees should be considered, e.g. in application codes where the polynomial degree is given through an input file. The second usage model is to rely on pre-compiled code for polynomial degrees. While a user code can use different functions for the cells (that get e.g. invoked by some dynamic dispatch mechanism for the various degree templates), deal.II also supports usage of this class based on the information in the element passed to the initialization. For this usage model, set the template parameter for the polynomial degree to
* 
*  -  and choose an arbitrary number for the number of quadrature points. That code part contains pre-compiled templated code for polynomial degrees between 1 and 6 and common quadrature formulas, which runs almost as fast as the templated version. In case the chosen degree is not pre-compiled, an evaluator object with template specialization for
* 
*  -  is invoked that runs according to run-time bounds.
*  An overview of the performance of FEEvaluation is given in the following figure. It considers the time spent per degree of freedom for evaluating the Laplacian with continuous finite elements using a code similar to the  [2.x.312]  tutorial program for single-precision arithmetics. The time is based on an experiment on a single core of an Intel Xeon E5-2687W v4, running at 3.4 GHz and measured at problem sizes of around 10 million. The plot lists the computational time (around 0.1 seconds) divided by the number of degrees freedom.
*   [2.x.313] 
*  The figure shows that the templated computational kernels are between 2.5 and 3 times faster than the non-templated ones. The fastest turnaround on this setup is for polynomial degree 5 at 7.4e-9 seconds per degree of freedom or 134 million degrees of freedom per second
* 
*  - on a single core. The non-templated version is also fastest at polynomial degree 5 with 2.1e-9 seconds per degree of freedom or 48 million degrees of freedom per second. Note that using FEEvaluation with template `degree=-1` selects the fast path for degrees between one and six, and the slow path for other degrees.
*  [1.x.10]
*  It is also possible to pre-compile the code in FEEvaluation for a different maximal polynomial degree. This is controlled by the class  [2.x.314]  and the implementation in `include/deal.II/matrix_free/evaluation_template_factory.templates.h`. By setting the macro `FE_EVAL_FACTORY_DEGREE_MAX` to the desired integer and instantiating the classes FEEvaluationFactory and FEFaceEvaluationFactory (the latter for FEFaceEvaluation) creates paths to templated functions for a possibly larger set of degrees. You can check if fast evaluation/integration for a given degree/n_quadrature_points pair by calling  [2.x.315]  or  [2.x.316] 
*  [1.x.11]
*  FEEvaluation also allows for treating vector-valued problems through a template parameter on the number of components:
* 

* 
* [1.x.12]
* 
*  If used this way, the components can be gathered from several components of an  [2.x.317]  through the call
* 

* 
* [1.x.13]
* 
*  where the 0 means that the vectors starting from the zeroth vector in the  [2.x.318]  should be used, <code>src[0], src[1], ..., src[n_components-1]</code>.
*  An alternative way for reading multi-component systems is possible if the DoFHandler underlying the MatrixFree data is based on an FESystem of  [2.x.319]  n_components entries. In that case, a single vector is provided for the read_dof_values() and distribute_local_to_global() calls.
*  An important property of FEEvaluation in multi-component systems is the layout of multiple components in the get_value(), get_gradient(), or get_dof_value() calls. In this case, instead of a scalar return field VectorizedArray [2.x.320]  a tensor is returned,
* 

* 
* [1.x.14]
* 
*  In a similar vein, the submit_value() and submit_gradient() calls take tensors of values. Note that there exist specializations for  [2.x.321]  n_components=1 and  [2.x.322]  which are provided through the base class FEEvaluationAccess. In the scalar case, these provide the scalar return types described above. In the vector-valued case, the gradient is converted from <code>Tensor [2.x.323]   [2.x.324]   [2.x.325]  to <code>Tensor [2.x.326]   [2.x.327]  Furthermore, additional operations such as the diveregence or curl are available.
*  In case different shape functions are combined, for example mixed finite element formulations in Stokes flow, two FEEvaluation objects are created, one for the velocity and one for the pressure. Those are then combined on quadrature points:
* 

* 
* [1.x.15]
* 
*  This code assumes that a BlockVector of two components describes the velocity and pressure components, respectively. For identifying the different DoFHandler objects for velocity and pressure, the second argument to the FEEvaluation objects specify the respective component 0 for velocity and 1 for pressure. For further examples of vector-valued problems, the deal.II test suite includes a few additional examples as well, e.g. the Stokes operator described above is found at https://github.com/dealii/dealii/blob/master/tests/matrix_free/matrix_vector_stokes_noflux.cc
*  [1.x.16]
*  The design of FEEvaluation and MatrixFree separates the geometry from the basis functions. Therefore, several DoFHandler objects (or the same DoFHandler equipped with different constraint objects) can share the same geometry information like in the Stokes example above. All geometry is cached once in MatrixFree, so FEEvaluation does not need to do expensive initialization calls and rather sets a few pointers. This realization is based on the idea that the geometry information is needed only once also when several fields are evaluated, in a departure from FEValues which sets up the internal mapping data for each field. If for example a multi-component PDE involves the shape values on one component and the shape gradient on the other, no efficiency is lost if both are based on the same MatrixFree object where the update flags specify that both  [2.x.328]  update_values ,  [2.x.329]  , and  [2.x.330]  are given. The selection of desired quantities of shape values is through the flags in the evaluate() or integrate calls and the access at quadrature points:
* 

* 
* [1.x.17]
* 
*  In the loop over quadrature points, one can ask any of the two FEEvaluation objects &mdash; it does not really matter which one because they only keep pointers to the quadrature point data &mdash; to provide the quadrature point location.
*  This observation also translates to the case when different differential operators are implemented in a program, for example the action of a mass matrix for one phase of the algorithm and the action of a stiffness matrix in another one. Only a single MatrixFree object is necessary, maintaining full efficiency by using different local functions with the respective implementation in separate FEEvaluation objects. In other words, a user does not need to bother about being conservative when providing update_flags to the initialization of MatrixFree for efficiency reasons
* 
*  - no overhead incurs inside FEEvaluation, except for at most one or two more  [2.x.331]  statements inside the  [2.x.332]  call. Rather, the largest set of flags necessary among all calls is perfectly fine from an efficiency point of view.
*  For the combination of different fields, including different solution vectors that come from different time steps, it is mandatory that all FEEvaluation objects share the same MatrixFree object. This is because the way cells are looped by  [2.x.333]  can be different for different DoFHandler or AffineConstraints arguments. More precisely, even though the layout is going to be the same in serial, there is no guarantee about the ordering for different DoFHandler/AffineConstraints in the MPI case. The reason is that the algorithm detects cells that need data exchange with MPI and those can change for different elements &mdash; FE_Q with hanging node constraints connects to more neighbors than a FE_DGQ element, for instance, and cells which need data exchange are put in different positions inside the cell loop. Of course, if the exact same DoFHandler, AffineConstraints, and options (such as the setting for thread parallelism) are set, then the order is going to be the same because the algorithm is deterministic.
*   [2.x.334]  dim Dimension in which this class is to be used
*   [2.x.335]  fe_degree Degree of the tensor product finite element with fe_degree+1 degrees of freedom per coordinate direction. Can be set to
* 
*  -  if the degree is not known at compile time, but performance will usually be worse by a factor of 2-3.
*   [2.x.336]  n_q_points_1d Number of points in the quadrature formula in 1D, defaults to fe_degree+1
*   [2.x.337]  n_components Number of vector components when solving a system of PDEs. If the same operation is applied to several components of a PDE (e.g. a vector Laplace equation), they can be applied simultaneously with one call (and often more efficiently). Defaults to 1.
*   [2.x.338]  Number Number format, usually  [2.x.339]  or  [2.x.340]  Defaults to  [2.x.341]  double
* 

* 
*  [2.x.342] 

* 
* [0.x.169]*
   An alias to the base class.  
* [0.x.170]*
   An underlying number type specified as template argument.  
* [0.x.171]*
   The type of function values, e.g. `VectorizedArrayType` for   `n_components=1` or `Tensor<1,dim,VectorizedArrayType >` for   `n_components=dim`.  
* [0.x.172]*
   The type of gradients, e.g. `Tensor<1,dim,VectorizedArrayType>` for   `n_components=1` or `Tensor<2,dim,VectorizedArrayType >` for   `n_components=dim`.  
* [0.x.173]*
   The dimension given as template argument.  
* [0.x.174]*
   The number of solution components of the evaluator given as template   argument.  
* [0.x.175]*
   The static number of quadrature points determined from the given template   argument `n_q_points_1d`. Note that the actual number of quadrature   points, `n_q_points`, can be different if `fe_degree=-1` is given and   run-time loop lengths are used rather than compile time ones.  
* [0.x.176]*
   The static number of degrees of freedom of a scalar component determined   from the given template argument `fe_degree`. Note that the actual number   of degrees of freedom `dofs_per_component` can be different if   `fe_degree=-1` is given or if the underlying is of more complicated type   than the usual FE_Q or FE_DGQ ones, such as FE_DGP.  
* [0.x.177]*
   The static number of degrees of freedom of all components determined from   the given template argument `fe_degree`. Note that the actual number of   degrees of freedom `dofs_per_cell` can be different if `fe_degree=-1` is   given or if the underlying is of more complicated type than the usual   FE_Q or FE_DGQ ones, such as FE_DGP.  
* [0.x.178]*
   The static number of degrees of freedom of all components determined from   the given template argument `fe_degree`. Note that the actual number of   degrees of freedom `dofs_per_cell` can be different if `fe_degree=-1` is   given or if the underlying is of more complicated type than the usual   FE_Q or FE_DGQ ones, such as FE_DGP.  
* [0.x.179]*
   Constructor. Takes all data stored in MatrixFree. If applied to problems   with more than one finite element or more than one quadrature formula   selected during construction of  [2.x.343]  the appropriate component   can be selected by the optional arguments.      [2.x.344]  matrix_free Data object that contains all data      [2.x.345]  dof_no If matrix_free was set up with multiple DoFHandler   objects, this parameter selects to which DoFHandler/AffineConstraints pair   the given evaluator should be attached to.      [2.x.346]  quad_no If matrix_free was set up with multiple Quadrature   objects, this parameter selects the appropriate number of the quadrature   formula.      [2.x.347]  first_selected_component If the dof_handler selected by dof_no   uses an FESystem consisting of more than one component, this parameter   allows for selecting the component where the current evaluation routine   should start. Note that one evaluator does not support combining   different shape functions in different components. In other words, the   same base element of a FESystem needs to be set for the components   between  [2.x.348]  and    [2.x.349] .      [2.x.350]  active_fe_index If matrix_free was set up with DoFHandler   objects with  [2.x.351]  this parameter selects to which   DoFHandler/AffineConstraints pair the given evaluator should be attached   to.      [2.x.352]  active_quad_index If matrix_free was set up with  [2.x.353]    objects, this parameter selects the appropriate number of the quadrature   formula.  
* [0.x.180]*
   Constructor. Takes all data stored in MatrixFree for a given cell range,   which allows to automatically identify the active_fe_index and   active_quad_index in case of a p-adaptive strategy.     The rest of the arguments are the same as in the constructor above.  
* [0.x.181]*
   Constructor that comes with reduced functionality and works similar as   FEValues. The arguments are similar to the ones passed to the constructor   of FEValues, with the notable difference that FEEvaluation expects a one-   dimensional quadrature formula, Quadrature<1>, instead of a  [2.x.354]    dimensional one. The finite element can be both scalar or vector valued,   but this method always only selects a scalar base element at a time (with    [2.x.355]  copies as specified by the class template). For vector-   valued elements, the optional argument  [2.x.356]  allows   to specify the index of the base element to be used for evaluation. Note   that the internal data structures always assume that the base element is   primitive, non-primitive are not supported currently.     As known from FEValues, a call to the reinit method with a    [2.x.357]  is necessary to make the geometry and   degrees of freedom of the current class known. If the iterator includes   DoFHandler information (i.e., it is a  [2.x.358]  or   similar), the initialization allows to also read from or write to vectors   in the standard way for  [2.x.359]  types for   one cell at a time. However, this approach is much slower than the path   with MatrixFree with MPI since index translation has to be done. As only   one cell at a time is used, this method does not vectorize over several   elements (which is most efficient for vector operations), but only   possibly within the element if the evaluate/integrate routines are   combined inside user code (e.g. for computing cell matrices).  
* [0.x.182]*
   Constructor for the reduced functionality. This constructor is equivalent   to the other one except that it makes the object use a  [2.x.360]  mapping   (i.e., an object of type MappingQGeneric(1)) implicitly.  
* [0.x.183]*
   Constructor for the reduced functionality. Similar to the other   constructor with FiniteElement argument but using another   FEEvaluationBase object to provide information about the geometry. This   allows several FEEvaluation objects to share the geometry evaluation, i.e.,   the underlying mapping and quadrature points do only need to be evaluated   once. Make sure to not pass an optional object around when you intend to   use the FEEvaluation object in %parallel to the given one because   otherwise the intended sharing may create race conditions.  
* [0.x.184]*
   Copy constructor. If FEEvaluationBase was constructed from a mapping, fe,   quadrature, and update flags, the underlying geometry evaluation based on   FEValues will be deep-copied in order to allow for using in parallel with   threads.  
* [0.x.185]*
   Copy assignment operator. If FEEvaluationBase was constructed from a   mapping, fe, quadrature, and update flags, the underlying geometry   evaluation based on FEValues will be deep-copied in order to allow for   using in parallel with threads.  
* [0.x.186]*
   Initialize the operation pointer to the current cell batch index. Unlike   the reinit functions taking a cell iterator as argument below and the    [2.x.361]  methods, where the information related to a particular   cell is generated in the reinit call, this function is very cheap since   all data is pre-computed in  [2.x.362]  and only a few indices have   to be set appropriately.  
* [0.x.187]*
   Initialize the data to the current cell using a TriaIterator object as   usual in FEValues. The argument is either of type    [2.x.363]  or  [2.x.364]  This   option is only available if the FEEvaluation object was created with a   finite element, quadrature formula and correct update flags and   [1.x.18] a MatrixFree object. This initialization method loses the   ability to use vectorization, see also the description of the   FEEvaluation class. When this reinit method is used, FEEvaluation can   also read from vectors (but less efficient than with data coming from   MatrixFree).  
* [0.x.188]*
   Initialize the data to the current cell using a TriaIterator object as   usual in FEValues. This option is only available if the FEEvaluation   object was created with a finite element, quadrature formula and correct   update flags and [1.x.19] a MatrixFree object. This initialization   method loses the ability to use vectorization, see also the description   of the FEEvaluation class. When this reinit method is used, FEEvaluation   can [1.x.20] read from vectors because no DoFHandler information is   available.  
* [0.x.189]*
   Check if face evaluation/integration is supported.  
* [0.x.190]*
   Evaluate the function values, the gradients, and the Hessians of the   polynomial interpolation from the DoF values in the input vector to the   quadrature points on the unit cell.  The function arguments specify which   parts shall actually be computed. This function has to be called first so   that the access functions  [2.x.365]   [2.x.366]  or  [2.x.367]    get_laplacian give useful information (unless these values have been set   manually).  
* [0.x.191]*
   Like above but with separate bool flags.    [2.x.368]  use evaluate() with the EvaluationFlags argument.  
* [0.x.192]*
   Evaluate the function values, the gradients, and the Hessians of the   polynomial interpolation from the DoF values in the input array  [2.x.369]    values_array to the quadrature points on the unit cell. If multiple   components are involved in the current FEEvaluation object, the sorting   in  [2.x.370]  is such that all degrees of freedom for the first   component come first, then all degrees of freedom for the second, and so   on. The function arguments specify which parts shall actually be   computed. This function has to be called first so that the access   functions  [2.x.371]   [2.x.372]  or  [2.x.373]  give   useful information (unless these values have been set manually).  
* [0.x.193]*
   Like above but using separate bool flags.    [2.x.374]  use evaluate() with the EvaluationFlags argument.  
* [0.x.194]*
   Read from the input vector and evaluates the function values, the   gradients, and the Hessians of the polynomial interpolation of the vector   entries from  [2.x.375]  associated with the current cell to the   quadrature points on the unit cell. The function arguments specify which   parts shall actually be computed. This function has to be called first so   that the access functions  [2.x.376]   [2.x.377]  or  [2.x.378]    get_laplacian give useful information (unless these values have been set   manually).     This call is equivalent to calling read_dof_values() followed by   evaluate(), but might internally use some additional optimizations.  
* [0.x.195]*
    [2.x.379]  Please use the gather_evaluate() function with the EvaluationFlags argument.  
* [0.x.196]*
   This function takes the values and/or gradients that are stored on   quadrature points, tests them by all the basis functions/gradients on the   cell and performs the cell integration. The two function arguments    [2.x.380]  and  [2.x.381]  are used to enable/disable   summation of the contributions submitted to the values or gradients slots,   respectively. The result is written into the internal data field    [2.x.382]  (that is usually written into the result vector by the   distribute_local_to_global() or set_dof_values() methods).  
* [0.x.197]*
    [2.x.383]  Please use the integrate() function with the EvaluationFlags argument.  
* [0.x.198]*
   This function takes the values and/or gradients that are stored on   quadrature points, tests them by all the basis functions/gradients on the   cell and performs the cell integration. The two function arguments  [2.x.384]    integrate_values and  [2.x.385]  are used to enable/disable   summation of the contributions submitted to the values or gradients   slots, respectively. As opposed to the other integrate() method, this   call stores the result of the testing in the given array  [2.x.386]    whose previous results is overwritten, rather than writing it on the   internal data structures behind begin_dof_values().  
* [0.x.199]*
    [2.x.387]  Please use the integrate() function with the EvaluationFlags argument.  
* [0.x.200]*
   This function takes the values and/or gradients that are stored on   quadrature points, tests them by all the basis functions/gradients on the   cell, performs the cell integration, and adds the result into the global   vector  [2.x.388]  on the degrees of freedom associated with the   present cell index. The two function arguments  [2.x.389]  and    [2.x.390]  are used to enable/disable summation of the   contributions submitted to the values or gradients slots, respectively.     This call is equivalent to calling integrate() followed by   distribute_local_to_global(), but might internally use   some additional optimizations.  
* [0.x.201]*
    [2.x.391]  Please use the integrate_scatter() function with the EvaluationFlags argument.  
* [0.x.202]*
   Return the q-th quadrature point in real coordinates stored in   MappingInfo.  
* [0.x.203]*
   The number of degrees of freedom of a single component on the cell for   the underlying evaluation object. Usually close to   static_dofs_per_component, but the number depends on the actual element   selected and is thus not static.  
* [0.x.204]*
   The number of degrees of freedom on the cell accumulated over all   components in the current evaluation object. Usually close to   static_dofs_per_cell = static_dofs_per_component*n_components, but the   number depends on the actual element selected and is thus not static.  
* [0.x.205]*
   The number of quadrature points in use. If the number of quadrature   points in 1d is given as a template, this number is simply the   <tt>dim</tt>-th power of that value. If the element degree is set to
* 
*  -    (dynamic selection of element degree), the static value of quadrature   points is inaccurate and this value must be used instead.  
* [0.x.206]*
   Checks if the template arguments regarding degree of the element   corresponds to the actual element used at initialization.  
* [0.x.207]*
 The class that provides all functions necessary to evaluate functions at quadrature points and face integrations. The design of the class is similar to FEEvaluation and most of the interfaces are shared with that class, in particular most access functions that come from the common base classes FEEvaluationAccess and FEEvaluationBase. Furthermore, the relation of this class to FEEvaluation is similar to the relation between FEValues and FEFaceValues.
*   [2.x.392]  dim Dimension in which this class is to be used
*   [2.x.393]  fe_degree Degree of the tensor product finite element with                  fe_degree+1 degrees of freedom per coordinate                  direction. If set to
* 
*  - , the degree of the underlying                  element will be used, which acts as a run time constant                  rather than a compile time constant that slows down the                  execution.
*   [2.x.394]  n_q_points_1d Number of points in the quadrature formula in 1D,                  usually chosen as fe_degree+1
*   [2.x.395]  n_components Number of vector components when solving a system of                  PDEs. If the same operation is applied to several                  components of a PDE (e.g. a vector Laplace equation), they                  can be applied simultaneously with one call (and often                  more efficiently)
*   [2.x.396]  Number Number format, usually  [2.x.397]  or  [2.x.398] 
*   [2.x.399]  VectorizedArrayType Type of array to be woked on in a vectorized                             fashion, defaults to VectorizedArray<Number>
* 

* 
*  [2.x.400]  Currently only VectorizedArray<Number, width> is supported as       VectorizedArrayType.

* 
* [0.x.208]*
   An alias to the base class.  
* [0.x.209]*
   A underlying number type specified as template argument.  
* [0.x.210]*
   The type of function values, e.g. `VectorizedArrayType` for   `n_components=1` or `Tensor<1,dim,VectorizedArrayType >` for   `n_components=dim`.  
* [0.x.211]*
   The type of gradients, e.g. `Tensor<1,dim,VectorizedArrayType>` for   `n_components=1` or `Tensor<2,dim,VectorizedArrayType >` for   `n_components=dim`.  
* [0.x.212]*
   The dimension given as template argument.  
* [0.x.213]*
   The number of solution components of the evaluator given as template   argument.  
* [0.x.214]*
   The static number of quadrature points determined from the given template   argument `n_q_points_1d` taken to the power of dim-1. Note that the actual   number of quadrature points, `n_q_points`, can be different if   `fe_degree=-1` is given and run-time loop lengths are used rather than   compile time ones.  
* [0.x.215]*
   The static number of quadrature points on a cell with the same quadrature   formula. Note that this value is only present for simpler comparison with   the cell quadrature, as the actual number of points is given to a face by   the `static_n_q_points` variable.  
* [0.x.216]*
   The static number of degrees of freedom of a scalar component determined   from the given template argument `fe_degree`. Note that the actual number   of degrees of freedom `dofs_per_component` can be different if   `fe_degree=-1` is given.  
* [0.x.217]*
   The static number of degrees of freedom of all components determined from   the given template argument `fe_degree`. Note that the actual number of   degrees of freedom `dofs_per_cell` can be different if `fe_degree=-1` is   given.  
* [0.x.218]*
   The static number of degrees of freedom of all components determined from   the given template argument `fe_degree`. Note that the actual number of   degrees of freedom `dofs_per_cell` can be different if `fe_degree=-1` is   given.  
* [0.x.219]*
   Constructor. Takes all data stored in MatrixFree. If applied to problems   with more than one finite element or more than one quadrature formula   selected during construction of  [2.x.401]  the appropriate component   can be selected by the optional arguments.      [2.x.402]  matrix_free Data object that contains all data      [2.x.403]  is_interior_face This selects which of the two cells of an   internal face the current evaluator will be based upon. The interior face   is the main face along which the normal vectors are oriented. The   exterior face coming from the other side provides the same normal vector   as the interior side, so if the outer normal vector to that side is   desired, it must be multiplied by
* 
*  - .      [2.x.404]  dof_no If matrix_free was set up with multiple DoFHandler   objects, this parameter selects to which DoFHandler/AffineConstraints pair   the given evaluator should be attached to.      [2.x.405]  quad_no If matrix_free was set up with multiple Quadrature   objects, this parameter selects the appropriate number of the quadrature   formula.      [2.x.406]  first_selected_component If the dof_handler selected by dof_no   uses an FESystem consisting of more than one base element, this parameter   selects the number of the base element in FESystem. Note that this does   not directly relate to the component of the respective element due to the   possibility for a multiplicity in the element.      [2.x.407]  active_fe_index If matrix_free was set up with DoFHandler   objects with  [2.x.408]  this parameter selects to which   DoFHandler/AffineConstraints pair the given evaluator should be attached   to.      [2.x.409]  face_type In the case of a face, indicate its reference-cell type   (0 for line or quadrilateral 1 for triangle).      [2.x.410]  active_quad_index If matrix_free was set up with  [2.x.411]    objects, this parameter selects the appropriate number of the quadrature   formula.  
* [0.x.220]*
   Constructor. Takes all data stored in MatrixFree for a given face range,   which allows to automatically identify the active_fe_index and   active_quad_index in case of a p-adaptive strategy.     The rest of the arguments are the same as in the constructor above.  
* [0.x.221]*
   Initializes the operation pointer to the current face. This method is the   default choice for face integration as the data stored in MappingInfo is   stored according to this numbering. Unlike the reinit functions taking a   cell iterator as argument below and the  [2.x.412]  methods, where   the information related to a particular cell is generated in the reinit   call, this function is very cheap since all data is pre-computed in    [2.x.413]  and only a few indices and pointers have to be set   appropriately.  
* [0.x.222]*
   As opposed to the reinit() method from the base class, this reinit()   method initializes for a given number of cells and a face number. This   method is less efficient than the other reinit() method taking a   numbering of the faces because it needs to copy the data associated with   the faces to the cells in this call.  
* [0.x.223]*
   Check if face evaluation/integration is supported.  
* [0.x.224]*
   Evaluates the function values, the gradients, and the Laplacians of the   FE function given at the DoF values stored in the internal data field   `dof_values` (that is usually filled by the read_dof_values() method) at   the quadrature points on the unit cell.  The function arguments specify   which parts shall actually be computed. Needs to be called before the   functions get_value(), get_gradient() or get_normal_derivative() give   useful information (unless these values have been set manually by   accessing the internal data pointers).  
* [0.x.225]*
    [2.x.414]  Please use the evaluate() function with the EvaluationFlags argument.  
* [0.x.226]*
   Evaluates the function values, the gradients, and the Laplacians of the   FE function given at the DoF values in the input array `values_array` at   the quadrature points on the unit cell. If multiple components are   involved in the current FEEvaluation object, the sorting in values_array   is such that all degrees of freedom for the first component come first,   then all degrees of freedom for the second, and so on. The function   arguments specify which parts shall actually be computed. Needs to be   called before the functions get_value(), get_gradient(), or   get_normal_derivative() give useful information (unless these values have   been set manually).  
* [0.x.227]*
    [2.x.415]  Please use the evaluate() function with the EvaluationFlags argument.  
* [0.x.228]*
   Reads from the input vector and evaluates the function values, the   gradients, and the Laplacians of the FE function at the quadrature points   on the unit cell. The function arguments specify which parts shall   actually be computed. Needs to be called before the functions   get_value(), get_gradient(), or get_normal_derivative() give useful   information.     This call is equivalent to calling read_dof_values() followed by   evaluate(), but might internally use some additional optimizations.  
* [0.x.229]*
    [2.x.416]  Please use the gather_evaluate() function with the EvaluationFlags argument.  
* [0.x.230]*
   This function takes the values and/or gradients that are stored on   quadrature points, tests them by all the basis functions/gradients on the   cell and performs the cell integration. The two function arguments   `integrate_val` and `integrate_grad` are used to enable/disable some of   values or gradients. The result is written into the internal data field   `dof_values` (that is usually written into the result vector by the   distribute_local_to_global() or set_dof_values() methods).  
* [0.x.231]*
    [2.x.417]  Please use the integrate() function with the EvaluationFlags argument.  
* [0.x.232]*
   This function takes the values and/or gradients that are stored on   quadrature points, tests them by all the basis functions/gradients on the   cell and performs the cell integration. The two function arguments   `integrate_val` and `integrate_grad` are used to enable/disable some of   values or gradients. As opposed to the other integrate() method, this   call stores the result of the testing in the given array `values_array`.  
* [0.x.233]*
    [2.x.418]  Please use the integrate() function with the EvaluationFlags argument.  
* [0.x.234]*
   This function takes the values and/or gradients that are stored on   quadrature points, tests them by all the basis functions/gradients on the   cell and performs the cell integration. The two function arguments   `integrate_val` and `integrate_grad` are used to enable/disable some of   values or gradients.     This call is equivalent to calling integrate() followed by   distribute_local_to_global(), but might internally use some additional   optimizations.  
* [0.x.235]*
    [2.x.419]  Please use the integrate_scatter() function with the EvaluationFlags argument.  
* [0.x.236]*
   Returns the q-th quadrature point on the face in real coordinates stored   in MappingInfo.  
* [0.x.237]*
   The number of degrees of freedom of a single component on the cell for   the underlying evaluation object. Usually close to   static_dofs_per_component, but the number depends on the actual element   selected and is thus not static.  
* [0.x.238]*
   The number of degrees of freedom on the cell accumulated over all   components in the current evaluation object. Usually close to   static_dofs_per_cell = static_dofs_per_component*n_components, but the   number depends on the actual element selected and is thus not static.  
* [0.x.239]*
   The number of quadrature points in use. If the number of quadrature   points in 1d is given as a template, this number is simply the   <tt>dim-1</tt>-th power of that value. If the element degree is set to
* 
*  -    (dynamic selection of element degree), the static value of quadrature   points is inaccurate and this value must be used instead.  
* [0.x.240]*
   Return face number of each face of the current face batch.  
* [0.x.241]*
   Determine the orientation of each face of the current face batch.  
* [0.x.242]*
   Implementation for standard vectors (that have the begin() methods).  
* [0.x.243]*
   Implementation for block vectors.  
* [0.x.244]*
   Implementation for vectors that have the begin() methods.  
* [0.x.245]*
   Implementation for all other vectors like block vectors.  
* [0.x.246]