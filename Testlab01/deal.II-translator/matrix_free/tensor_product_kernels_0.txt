[0.x.0]*
   In this namespace, the evaluator routines that evaluate the tensor   products are implemented.  
* [0.x.1]*
     Do not use anything more than the tensor product structure of the     finite element.    
* [0.x.2]*
     Perform evaluation by exploiting symmetry in the finite element: i.e.,     skip some computations by utilizing the symmetry in the shape functions     and quadrature points.    
* [0.x.3]*
     Use symmetry to apply the operator to even and odd parts of the input     vector separately: see the documentation of the EvaluatorTensorProduct     specialization for more information.    
* [0.x.4]*
     Use symmetry in Legendre and similar polynomial spaces where the shape     functions with even number are symmetric about the center of the     quadrature points (think about even polynomial degrees) and the shape     functions with odd number are anti-symmetric about the center of the     quadrature points (think about odd polynomial degrees). This allows to     use a strategy similar to the even-odd technique but without separate     coefficient arrays. See the documentation of the EvaluatorTensorProduct     specialization for more information.    
* [0.x.5]*
   Determine which quantity should be computed via the tensor product kernels.  
* [0.x.6]*
     Evaluate/integrate by shape functions.    
* [0.x.7]*
     Evaluate/integrate by gradients of the shape functions.    
* [0.x.8]*
     Evaluate/integrate by hessians of the shape functions.    
* [0.x.9]*
   Generic evaluator framework that valuates the given shape data in general   dimensions using the tensor product form. Depending on the particular   layout in the matrix entries, this corresponds to a usual matrix-matrix   product or a matrix-matrix product including some symmetries.      [2.x.0]  variant Variant of evaluation used for creating template                   specializations    [2.x.1]  dim Dimension of the function    [2.x.2]  n_rows Number of rows in the transformation matrix, which corresponds                  to the number of 1d shape functions in the usual tensor                  contraction setting    [2.x.3]  n_columns Number of columns in the transformation matrix, which                     corresponds to the number of 1d shape functions in the                     usual tensor contraction setting    [2.x.4]  Number Abstract number type for input and output arrays    [2.x.5]  Number2 Abstract number type for coefficient arrays (defaults to                   same type as the input/output arrays); must implement                   operator* with Number to be valid  
* [0.x.10]*
   Internal evaluator for shape function in arbitrary dimension using the   tensor product form of the basis functions.      [2.x.6]  dim Space dimension in which this class is applied    [2.x.7]  n_rows Number of rows in the transformation matrix, which corresponds                  to the number of 1d shape functions in the usual tensor                  contraction setting    [2.x.8]  n_columns Number of columns in the transformation matrix, which                     corresponds to the number of 1d shape functions in the                     usual tensor contraction setting    [2.x.9]  Number Abstract number type for input and output arrays    [2.x.10]  Number2 Abstract number type for coefficient arrays (defaults to                   same type as the input/output arrays); must implement                   operator* with Number and produce Number as an output to                   be a valid type  
* [0.x.11]*
     Empty constructor. Does nothing. Be careful when using 'values' and     related methods because they need to be filled with the other pointer    
* [0.x.12]*
     Constructor, taking the data from ShapeInfo    
* [0.x.13]*
     This function applies the tensor product kernel, corresponding to a     multiplication of 1D stripes, along the given  [2.x.11]  of the tensor     data in the input array. This function allows the  [2.x.12]  and  [2.x.13]      arrays to alias for the case n_rows == n_columns, i.e., it is safe to     perform the contraction in place where  [2.x.14]  and  [2.x.15]  point to the     same address. For the case n_rows != n_columns, the output is in general     not correct.          [2.x.16]  direction Direction that is evaluated      [2.x.17]  contract_over_rows If true, the tensor contraction sums                                over the rows in the given  [2.x.18]                                 array, otherwise it sums over the columns      [2.x.19]  add If true, the result is added to the output vector, else                 the computed values overwrite the content in the output      [2.x.20]  one_line If true, the kernel is only applied along a single 1D                      stripe within a dim-dimensional tensor, not the full                      n_rows^dim points as in the  [2.x.21]  case.          [2.x.22]  shape_data Transformation matrix with  [2.x.23]  rows and                        [2.x.24]  columns, stored in row-major format      [2.x.25]  in Pointer to the start of the input data vector      [2.x.26]  out Pointer to the start of the output data vector    
* [0.x.14]*
     This function applies the tensor product operation to produce face values     from cell values. As opposed to the apply method, this method assumes     that the directions orthogonal to the face have n_rows degrees of     freedom per direction and not n_columns for those directions lower than     the one currently applied. In other words, apply_face() must be called     before calling any interpolation within the face.          [2.x.27]  face_direction Direction of the normal vector (0=x, 1=y, etc)      [2.x.28]  contract_onto_face If true, the input vector is of size n_rows^dim                                and interpolation into n_rows^(dim-1) points                                is performed. This is a typical scenario in                                 [2.x.29]  calls. If false,                                data from n_rows^(dim-1) points is expanded                                into the n_rows^dim points of the higher-                                dimensional data array. Derivatives in the                                case contract_onto_face==false are summed                                together      [2.x.30]  add If true, the result is added to the output vector, else                 the computed values overwrite the content in the output      [2.x.31]  max_derivative Sets the number of derivatives that should be                 computed. 0 means only values, 1 means values and first                 derivatives, 2 second derivates. Note that all the                 derivatives access the data in  [2.x.32]  passed to                 the constructor of the class      [2.x.33]  lex_faces Sets how the evaluation points on the faces should be                       sorted: lexicographically or right-hand-system number                       (special treatment of orientation 1 in 3D). Per default                       right-hand-system number is enabled, which is only                       working for dimensions up to 3.          [2.x.34]  in address of the input data vector      [2.x.35]  out address of the output data vector    
* [0.x.15]*
   Internal evaluator for shape function using the tensor product form   of the basis functions. The same as the other templated class but   without making use of template arguments and variable loop bounds   instead.      [2.x.36]  dim Space dimension in which this class is applied    [2.x.37]  Number Abstract number type for input and output arrays    [2.x.38]  Number2 Abstract number type for coefficient arrays (defaults to                   same type as the input/output arrays); must implement                   operator* with Number and produce Number as an output to                   be a valid type  
* [0.x.16]*
     Empty constructor. Does nothing. Be careful when using 'values' and     related methods because they need to be filled with the other constructor    
* [0.x.17]*
     Constructor, taking the data from ShapeInfo    
* [0.x.18]*
     Constructor, taking the data from ShapeInfo    
* [0.x.19]*
   Internal evaluator for 1d-3d shape function using the tensor product form   of the basis functions. This class specializes the general application of   tensor-product based elements for "symmetric" finite elements, i.e., when   the shape functions are symmetric about 0.5 and the quadrature points   are, too.      [2.x.39]  dim Space dimension in which this class is applied    [2.x.40]  n_rows Number of rows in the transformation matrix, which corresponds                  to the number of 1d shape functions in the usual tensor                  contraction setting    [2.x.41]  n_columns Number of columns in the transformation matrix, which                     corresponds to the number of 1d shape functions in the                     usual tensor contraction setting    [2.x.42]  Number Abstract number type for input and output arrays    [2.x.43]  Number2 Abstract number type for coefficient arrays (defaults to                   same type as the input/output arrays); must implement                   operator* with Number and produce Number as an output to                   be a valid type  
* [0.x.20]*
     Constructor, taking the data from ShapeInfo    
* [0.x.21]*
   Internal evaluator for 1d-3d shape function using the tensor product form   of the basis functions.     This class implements a different approach to the symmetric case for   values, gradients, and Hessians also treated with the above functions: It   is possible to reduce the cost per dimension from N^2 to N^2/2, where N   is the number of 1D dofs (there are only N^2/2 different entries in the   shape matrix, so this is plausible). The approach is based on the idea of   applying the operator on the even and odd part of the input vectors   separately, given that the shape functions evaluated on quadrature points   are symmetric. This method is presented e.g. in the book "Implementing   Spectral Methods for Partial Differential Equations" by David A. Kopriva,   Springer, 2009, section 3.5.3 (Even-Odd-Decomposition). Even though the   experiments in the book say that the method is not efficient for N<20, it   is more efficient in the context where the loop bounds are compile-time   constants (templates).      [2.x.44]  dim Space dimension in which this class is applied    [2.x.45]  n_rows Number of rows in the transformation matrix, which corresponds                  to the number of 1d shape functions in the usual tensor                  contraction setting    [2.x.46]  n_columns Number of columns in the transformation matrix, which                     corresponds to the number of 1d shape functions in the                     usual tensor contraction setting    [2.x.47]  Number Abstract number type for input and output arrays    [2.x.48]  Number2 Abstract number type for coefficient arrays (defaults to                   same type as the input/output arrays); must implement                   operator* with Number and produce Number as an output to                   be a valid type  
* [0.x.22]*
     Empty constructor. Does nothing. Be careful when using 'values' and     related methods because they need to be filled with the other     constructor passing in at least an array for the values.    
* [0.x.23]*
     Constructor, taking the data from ShapeInfo (using the even-odd     variants stored there)    
* [0.x.24]*
     Constructor, taking the data from ShapeInfo (using the even-odd     variants stored there)    
* [0.x.25]*
     This function applies the tensor product kernel, corresponding to a     multiplication of 1D stripes, along the given  [2.x.49]  of the tensor     data in the input array. This function allows the  [2.x.50]  and  [2.x.51]      arrays to alias for the case n_rows == n_columns, i.e., it is safe to     perform the contraction in place where  [2.x.52]  and  [2.x.53]  point to the     same address. For the case n_rows != n_columns, the output is only     correct if  [2.x.54]  is set to true.          [2.x.55]  direction Direction that is evaluated      [2.x.56]  contract_over_rows If true, the tensor contraction sums                                over the rows in the given  [2.x.57]                                 array, otherwise it sums over the columns      [2.x.58]  add If true, the result is added to the output vector, else                 the computed values overwrite the content in the output      [2.x.59]  type Determines whether to use the symmetries appearing in                  shape values (type=0), shape gradients (type=1) or                  second derivatives (type=2, similar to type 0 but                  without two additional zero entries)      [2.x.60]  one_line If true, the kernel is only applied along a single 1D                      stripe within a dim-dimensional tensor, not the full                      n_rows^dim points as in the  [2.x.61]  case.          [2.x.62]  shape_data Transformation matrix with  [2.x.63]  rows and                        [2.x.64]  columns, stored in row-major format      [2.x.65]  in Pointer to the start of the input data vector      [2.x.66]  out Pointer to the start of the output data vector    
* [0.x.26]*
   Internal evaluator for 1d-3d shape function using the tensor product form   of the basis functions.     This class implements an approach similar to the even-odd decomposition   but with a different type of symmetry. In this case, we assume that a   single shape function already shows the symmetry over the quadrature   points, rather than the complete basis that is considered in the even-odd   case. In particular, we assume that the shape functions are ordered as in   the Legendre basis, with symmetric shape functions in the even slots   (rows of the values array) and point-symmetric in the odd slots. Like the   even-odd decomposition, the number of operations are N^2/2 rather than   N^2 FMAs (fused multiply-add), where N is the number of 1D dofs. The   difference is in the way the input and output quantities are symmetrized.      [2.x.67]  dim Space dimension in which this class is applied    [2.x.68]  n_rows Number of rows in the transformation matrix, which corresponds                  to the number of 1d shape functions in the usual tensor                  contraction setting    [2.x.69]  n_columns Number of columns in the transformation matrix, which                     corresponds to the number of 1d shape functions in the                     usual tensor contraction setting    [2.x.70]  Number Abstract number type for input and output arrays    [2.x.71]  Number2 Abstract number type for coefficient arrays (defaults to                   same type as the input/output arrays); must implement                   operator* with Number and produce Number as an output to                   be a valid type  
* [0.x.27]*
     Empty constructor. Does nothing. Be careful when using 'values' and     related methods because they need to be filled with the other     constructor passing in at least an array for the values.    
* [0.x.28]*
     Constructor, taking the data from ShapeInfo (using the even-odd     variants stored there)    
* [0.x.29]*
     Constructor, taking the data from ShapeInfo (using the even-odd     variants stored there)    
* [0.x.30]*
     This function applies the tensor product kernel, corresponding to a     multiplication of 1D stripes, along the given  [2.x.72]  of the tensor     data in the input array. This function allows the  [2.x.73]  and  [2.x.74]      arrays to alias for the case n_rows == n_columns, i.e., it is safe to     perform the contraction in place where  [2.x.75]  and  [2.x.76]  point to the     same address. For the case n_rows != n_columns, the output is only     correct if  [2.x.77]  is set to true.          [2.x.78]  direction Direction that is evaluated      [2.x.79]  contract_over_rows If true, the tensor contraction sums                                over the rows in the given  [2.x.80]                                 array, otherwise it sums over the columns      [2.x.81]  add If true, the result is added to the output vector, else                 the computed values overwrite the content in the output      [2.x.82]  type Determines whether the evaluation is symmetric in even                  rows (type=0) or odd rows (type=1) of  [2.x.83]  and                  skew-symmetric in odd rows (type=0) or even rows (type=1)      [2.x.84]  one_line If true, the kernel is only applied along a single 1D                      stripe within a dim-dimensional tensor, not the full                      n_rows^dim points as in the  [2.x.85]  case.          [2.x.86]  shape_data Transformation matrix with  [2.x.87]  rows and                        [2.x.88]  columns, stored in row-major format      [2.x.89]  in Pointer to the start of the input data vector      [2.x.90]  out Pointer to the start of the output data vector    
* [0.x.31]*
   Struct to avoid using Tensor<1, dim, Point<dim2>> in   evaluate_tensor_product_value_and_gradient because a Point cannot be used   within Tensor. Instead, a specialization of this struct upcasts the point   to a Tensor<1,dim>.  
* [0.x.32]*
   Compute the polynomial interpolation of a tensor product shape function    [2.x.91]  given a vector of coefficients  [2.x.92]  in the form    [2.x.93] . The shape   functions  [2.x.94]  represent a tensor   product. The function returns a pair with the value of the interpolation   as the first component and the gradient in reference coordinates as the   second component. Note that for compound types (e.g. the `values` field   begin a Point<spacedim> argument), the components of the gradient are   sorted as Tensor<1, dim, Tensor<1, spacedim>> with the derivatives   as the first index; this is a consequence of the generic arguments in the   function.      [2.x.95]  poly The underlying one-dimensional polynomial basis    [2.x.96]  given as a vector of polynomials.      [2.x.97]  values The expansion coefficients  [2.x.98]  of type `Number` in   the polynomial interpolation. The coefficients can be simply `double`   variables but e.g. also Point<spacedim> in case they define arithmetic   operations with the type `Number2`.      [2.x.99]  p The position in reference coordinates where the interpolation   should be evaluated.      [2.x.100]  d_linear Flag to specify whether a d-linear (linear in 1D,   bi-linear in 2D, tri-linear in 3D) interpolation should be made, which   allows to unroll loops and considerably speed up evaluation.      [2.x.101]  renumber Optional parameter to specify a renumbering in the   coefficient vector, assuming that `values[renumber[i]]` returns   the lexicographic (tensor product) entry of the coefficients. If the   vector is entry, the values are assumed to be sorted lexicographically.  
* [0.x.33]*
   Same as evaluate_tensor_product_value_and_gradient() but for integration.  
* [0.x.34]