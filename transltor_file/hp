include/deal.II-translator/hp/collection_0.txt
[0.x.0]*
   This class implements a collection of objects.     It implements the concepts stated in the  [2.x.0]    module described in the doxygen documentation.    
*  [2.x.1]   
* [0.x.1]*
     Default constructor. Leads to an empty collection that can later be     filled using push_back().    
* [0.x.2]*
     Add a new object.    
* [0.x.3]*
     Return the object which was specified by the user for the     active FE index which is provided as a parameter to this method.          [2.x.2]   [2.x.3]  must be between zero and the number of elements of the     collection.    
* [0.x.4]*
     Return the number of objects stored in this container.    
* [0.x.5]*
     Determine an estimate for the memory consumption (in bytes) of this     object.    
* [0.x.6]*
     The real container, which stores pointers to the different objects.    
* [0.x.7]

include/deal.II-translator/hp/dof_handler_0.txt
[0.x.0]*
   Manage the distribution and numbering of the degrees of freedom for hp-   FEM algorithms. This class satisfies the    [2.x.0]  "MeshType concept"   requirements.     The purpose of this class is to allow for an enumeration of degrees of   freedom in the same way as the ::DoFHandler class, but it allows to use a   different finite element on every cell. To this end, one assigns an    [2.x.1]  to every cell that indicates which element   within a collection of finite elements (represented by an object of type    [2.x.2]  is the one that lives on this cell. The class then   enumerates the degree of freedom associated with these finite elements on   each cell of a triangulation and, if possible, identifies degrees of   freedom at the interfaces of cells if they match. If neighboring cells   have degrees of freedom along the common interface that do not immediate   match (for example, if you have  [2.x.3]  and  [2.x.4]  elements meeting at a   common face), then one needs to compute constraints to ensure that the   resulting finite element space on the mesh remains conforming.     The whole process of working with objects of this type is explained in    [2.x.5] . Many of the algorithms this class implements are described in   the    [2.x.6]  "hp-paper".       [1.x.0]     The typical workflow for using this class is to create a mesh, assign an   active FE index to every active cell, calls    [2.x.7]  and then assemble a linear system and   solve a problem on this finite element space. However, one can skip   assigning active FE indices upon mesh refinement in certain   circumstances. In particular, the following rules apply:
* 

* 
* 

* 
* 

* 
* 
*  - Upon mesh refinement, child cells inherit the active FE index of     the parent.
* 

* 
* 

* 
* 

* 
* 
*  - When coarsening cells, the (now active) parent cell will be assigned     an active FE index that is determined from its (no longer active)     children, following the FiniteElementDomination logic: Out of the set of     elements previously assigned to the former children, we choose the one     dominated by all children for the parent cell. If none was found, we pick     the most dominant element in the whole collection that is dominated by     all former children. See  [2.x.8]      for further information on this topic.    
*  [2.x.9]  Finite elements need to be assigned to each cell by either calling   set_fe() or distribute_dofs() first to make this functionality available.       [1.x.1]     When this class is used with either a  [2.x.10]    or a  [2.x.11]  you can only set active   FE indices on cells that are locally owned,   using a call such as  [2.x.12] .   On the other hand, setting the active FE index on ghost   or artificial cells is not allowed.     Ghost cells do acquire the information what element   is active on them, however: whenever   you call  [2.x.13]  all processors that   participate in the parallel mesh exchange information in such a way   that the active FE index on ghost cells equals the active FE index   that was set on that processor that owned that particular ghost cell.   Consequently, one can [1.x.2] the  [2.x.14]  on ghost   cells, just not set it by hand.     On artificial cells, no information is available about the    [2.x.15]  used there. That's because we don't even know   whether these cells exist at all, and even if they did, the   current processor does not know anything specific about them.   See    [2.x.16]  "the glossary entry on artificial cells"   for more information.     During refinement and coarsening, information about the  [2.x.17]    of each cell will be automatically transferred.     However, using a  [2.x.18]  with an    [2.x.19]  requires additional attention during serialization, since no   information on active FE indices will be automatically transferred. This   has to be done manually using the   prepare_for_serialization_of_active_fe_indices() and   deserialize_active_fe_indices() functions. The former has to be called   before  [2.x.20]  is invoked, and the   latter needs to be run after  [2.x.21]    If further data will be attached to the triangulation via the    [2.x.22]     [2.x.23]  or  [2.x.24]    classes, all corresponding preparation and deserialization function calls   need to happen in the same order. Consult the documentation of    [2.x.25]  for more information.      
*  [2.x.26]       [2.x.27]  The basic  [2.x.28]  is capable of hp-adaptation now.  
* [0.x.1]

include/deal.II-translator/hp/fe_collection_0.txt
[0.x.0]*
   This class acts as a collection of finite element objects used in the   DoFHandler.     It implements the concepts stated in the    [2.x.0]    module described in the doxygen documentation.     In addition to offering access to the elements of the collection, this   class provides access to the maximal number of degrees of freedom per   vertex, line, etc, to allow allocation of as much memory as is necessary   in the worst case when using the finite elements associated with the   cells of a triangulation.     This class has not yet been implemented for the use in the codimension   one case (<tt>spacedim != dim </tt>).    
*  [2.x.1]   
* [0.x.1]*
     Whenever p-adaptivity is considered in an hp-finite element program,     a hierarchy of finite elements needs to be established to determine     succeeding finite elements for refinement and preceding ones for     coarsening.         In this struct, we supply a hierarchy that is imposed on all FECollection     objects by default.    
* [0.x.2]*
       Return the index succeeding  [2.x.2]  in the  [2.x.3]              Once the last element of the  [2.x.4]  is reached, there is no element on a higher level in       the hierarchy and thus we return the last value.      
* [0.x.3]*
       Return the index preceding  [2.x.5]  in the  [2.x.6]              Once the first element of the  [2.x.7]  is reached, there is no element on a lower level in       the hierarchy and thus we return the first value.      
* [0.x.4]*
     Default constructor. Leads to an empty collection that can later be     filled using push_back(). Establishes a hierarchy of finite elements     corresponding to their index in the collection.    
* [0.x.5]*
     Conversion constructor. This constructor creates a FECollection from a     single finite element. More finite element objects can be added with     push_back(), if desired, though it would probably be clearer to add all     mappings the same way.    
* [0.x.6]*
     Constructor. This constructor creates a FECollection from one or     more finite element objects passed to the constructor. For this     call to be valid, all arguments need to be of types derived     from class FiniteElement<dim,spacedim>.    
* [0.x.7]*
     Constructor. Same as above but for any number of elements. Pointers to     the elements are passed in a vector to this constructor. As above, the     finite element objects pointed to by the argument are not actually used     other than to create copies internally. Consequently, you can delete     these pointers immediately again after calling this constructor.    
* [0.x.8]*
     Copy constructor.    
* [0.x.9]*
     Move constructor.        
*  [2.x.8]  The implementation of standard datatypes may change with different     libraries, so their move members may or may not be flagged non-throwing.     We need to explicitly set the noexcept specifier according to its     member variables to still get the performance benefits (and to satisfy     clang-tidy).    
* [0.x.10]*
     Move assignment operator.    
* [0.x.11]*
     Equality comparison operator. All stored FiniteElement objects are     compared in order.    
* [0.x.12]*
     Non-equality comparison operator. All stored FiniteElement objects are     compared in order.    
* [0.x.13]*
     Add a finite element. This function generates a copy of the given     element, i.e. you can do things like <tt>push_back(FE_Q<dim>(1));</tt>.     The internal copy is later destroyed by this object upon destruction of     the entire collection.         When a new element is added, it needs to have the same number of vector     components as all other elements already in the collection.    
* [0.x.14]*
     Return the number of vector components of the finite elements in this     collection.  This number must be the same for all elements in the     collection.         This function calls  [2.x.9]   See      [2.x.10]  "the glossary"     for more information.    
* [0.x.15]*
     Return the number of vector blocks of the finite elements in this     collection. While this class ensures that all elements stored in it     have the same number of vector components, there is no such guarantees     for the number of blocks each element is made up of (an element may     have fewer blocks than vector components; see      [2.x.11]  "the glossary"     for more information). For example, you may have an FECollection object     that stores one copy of an FESystem with  [2.x.12]  FE_Q objects     and one copy of an FE_RaviartThomas element. Both have  [2.x.13]      vector components but while the former has  [2.x.14]  blocks the     latter has only one. Consequently, this function will throw an     assertion if the number of blocks is not the same for all elements. If     they are the same, this function returns the result of      [2.x.15]     
* [0.x.16]*
     Return the maximum of values returned by  [2.x.16]      over all elements of this collection.    
* [0.x.17]*
     Return the maximal number of degrees of freedom per vertex over all     elements of this collection.    
* [0.x.18]*
     Return the maximal number of degrees of freedom per line over all     elements of this collection.    
* [0.x.19]*
     Return the maximal number of degrees of freedom per quad over all     elements of this collection.    
* [0.x.20]*
     Return the maximal number of degrees of freedom per hex over all     elements of this collection.    
* [0.x.21]*
     Return the maximal number of degrees of freedom per face over all     elements of this collection.    
* [0.x.22]*
     Return the maximal number of degrees of freedom per cell over all     elements of this collection.    
* [0.x.23]*
     Return whether all elements in this collection implement the hanging     node constraints in the new way, which has to be used to make elements     "hp-compatible". If this is not the case, the function returns false,     which implies, that at least one element in the FECollection does not     support the new face interface constraints. On the other hand, if this     method does return true, this does not imply that the hp-method will     work!         This behavior is related to the fact, that FiniteElement classes,     which provide the new style hanging node constraints might still not     provide them for all possible cases. If FE_Q and FE_RaviartThomas     elements are included in the FECollection and both properly implement     the get_face_interpolation_matrix method, this method will return true.     But the get_face_interpolation_matrix might still fail to find an     interpolation matrix between these two elements.    
* [0.x.24]*
     Return the indices of finite elements in this FECollection that dominate     all elements associated with the provided set of indices  [2.x.17]          You may find information about the domination behavior of finite elements     in their respective class documentation or in the implementation of their     inherited member function  [2.x.18]      Consider that a finite element may or may not dominate itself (e.g.     FE_Nothing elements).         For example, if a FECollection consists of     `{FE_Q(1),FE_Q(2),FE_Q(3),FE_Q(4)}` elements and we are looking for the     finite elements that dominate the middle elements of this     collection (i.e.,  [2.x.19]  is `{1,2}`), then the answer is `{FE_Q(1),FE_Q(2)`     and therefore this function will return their indices in the     FECollection, namely `{0,1}`.         The  [2.x.20]  parameter describes the codimension of the investigated     subspace and specifies that it is subject to this comparison. See      [2.x.21]  for more information.    
* [0.x.25]*
     Return the indices of finite elements in this FECollection that are     dominated by all elements associated with the provided set of indices  [2.x.22]          You may find information about the domination behavior of finite elements     in their respective class documentation or in the implementation of their     inherited member function  [2.x.23]      Consider that a finite element may or may not dominate itself (e.g.     FE_Nothing elements).         For example, if a FECollection consists of     `{FE_Q(1),FE_Q(2),FE_Q(3),FE_Q(4)}` elements and we are looking for the     finite elements that are dominated by the middle elements of this     collection (i.e.,  [2.x.24]  is `{1,2}`), then the answer is `{FE_Q(3),FE_Q(4)`     and therefore this function will return their indices in the     FECollection, namely `{2,3}`.         The  [2.x.25]  parameter describes the codimension of the investigated     subspace and specifies that it is subject to this comparison. See      [2.x.26]  for more information.    
* [0.x.26]*
     Return the index of a finite element from the provided set of indices  [2.x.27]      that dominates all other elements of this very set.         You may find information about the domination behavior of finite elements     in their respective class documentation or in the implementation of their     inherited member function  [2.x.28]      Consider that a finite element may or may not dominate itself (e.g.     FE_Nothing elements).         If this set consists of exactly one element, we consider it to be     the dominating one and return its corresponding index. Further, if the     function is not able to find a finite element at all, it returns      [2.x.29]          For example, if a FECollection consists of     `{FE_Q(1),FE_Q(2),FE_Q(3),FE_Q(4)}` elements and we are looking for the     dominating finite element among the middle elements of this     collection (i.e.,  [2.x.30]  is `{1,2}`), then the answer is FE_Q(2)     and therefore this function will return its index in the     FECollection, namely `1`.         It is of course possible that there is more than one element that     dominates all selected elements. For example, if the collection consists     of `{FE_Q(1),FE_Q(1),FE_Q(2),FE_Q(2)}` and `fes` covers all indices,     then one could return zero or one.  In that case, the function returns     either `0` or `1` since there is no tie-breaker between the two.         The  [2.x.31]  parameter describes the codimension of the investigated     subspace and specifies that it is subject to this comparison. See      [2.x.32]  for more information.    
* [0.x.27]*
     Return the index of a finite element from the provided set of indices  [2.x.33]      that is dominated by all other elements of this very set.         You may find information about the domination behavior of finite elements     in their respective class documentation or in the implementation of their     inherited member function  [2.x.34]      Consider that a finite element may or may not dominate itself (e.g.     FE_Nothing elements).         If this set consists of exactly one element, we consider it to be     the dominated one and return its corresponding index. Further, if the     function is not able to find a finite element at all, it returns      [2.x.35]          For example, if a FECollection consists of     `{FE_Q(1),FE_Q(2),FE_Q(3),FE_Q(4)}` elements and we are looking for the     dominated finite element among the middle elements of this     collection (i.e.,  [2.x.36]  is `{1,2}`), then the answer is FE_Q(3)     and therefore this function will return its index in the     FECollection, namely `2`.         It is of course possible that there is more than one element that is     dominated by all selected elements. For example, if the collection     consists of `{FE_Q(1),FE_Q(1),FE_Q(2),FE_Q(2)}` and `fes` covers all     indices, then one could return two or three.  In that case, the function     returns either `2` or `3` since there is no tie-breaker between the two.         The  [2.x.37]  parameter describes the codimension of the investigated     subspace and specifies that it is subject to this comparison. See      [2.x.38]  for more information.    
* [0.x.28]*
     Return the index of a finite element from the provided set of indices  [2.x.39]      that dominates all other elements of this very set. If we do not succeed,     we extend our search on the whole collection by picking the least     dominating one, which is the element that describes the largest finite     element space of which all of the finite elements of the     provided set  [2.x.40]  are part of.         You may find information about the domination behavior of finite elements     in their respective class documentation or in the implementation of their     inherited member function  [2.x.41]      Consider that a finite element may or may not dominate itself (e.g.     FE_Nothing elements).         If this set consists of exactly one element, we consider it to be     the dominated one and return its corresponding index. Further, if the     function is not able to find a finite element at all, it returns      [2.x.42]          The  [2.x.43]  parameter describes the codimension of the investigated     subspace and specifies that it is subject to this comparison. See      [2.x.44]  for more information.    
* [0.x.29]*
     Return the index of a finite element from the provided set of indices  [2.x.45]      that is dominated by all other elements of this very set. If we do not     succeed, we extend our search on the whole collection by picking the most     dominated one, which is the element that describes the smallest finite     element space which includes all finite elements of the provided set  [2.x.46]          You may find information about the domination behavior of finite elements     in their respective class documentation or in the implementation of their     inherited member function  [2.x.47]      Consider that a finite element may or may not dominate itself (e.g.     FE_Nothing elements).         If this set consists of exactly one element, we consider it to be     the dominating one and return its corresponding index. Further, if the     function is not able to find a finite element at all, it returns      [2.x.48]          The  [2.x.49]  parameter describes the codimension of the investigated     subspace and specifies that it is subject to this comparison. See      [2.x.50]  for more information.    
* [0.x.30]*
     Set functions determining the hierarchy of finite elements, i.e. a     function  [2.x.51]  that returns the index of the finite element following     the given one, and a function  [2.x.52]  returning the preceding one.         Both functions expect an  [2.x.53]  to be passed along with a     finite element index, on whose basis the new index will be found and     returned.        
*  [2.x.54]  Both passed and returned indices have to be valid within the index     range of this collection, i.e. within [0, size()).    
* [0.x.31]*
     Set the default hierarchy corresponding to the index of each finite     element in the collection.         This default hierarchy is established with functions      [2.x.55]  and  [2.x.56]     
* [0.x.32]*
     Returns a sequence of FE indices that corresponds to the registered     hierarchy in ascending order, i.e., FE indices are sorted from lowest to     highest level.         Multiple sequences of FE indices are possible with a single custom     hierarchy that can be registered with set_hierarchy(). This function     will return the sequence that contains the user-provided index      [2.x.57]  which could be located anywhere inside the sequence. The     default hierarchy set via set_default_hierarchy(), which corresponds to     FE indices in ascending order, consists of only one sequence.         This function can be used, for example, to verify that your provided     hierarchy covers all elements in the desired order.         Only one sequence of FE indices exists if the size of the returned     container equals the number of elements of this object, i.e.,      [2.x.58]     
* [0.x.33]*
     %Function returning the index of the finite element following the given      [2.x.59]  in hierarchy.         By default, the index succeeding  [2.x.60]  will be returned. If  [2.x.61]      already corresponds to the last index, the last index will be returned.     A custom hierarchy can be supplied via the member function     set_hierachy().    
* [0.x.34]*
     %Function returning the index of the finite element preceding the given      [2.x.62]  in hierarchy.         By default, the index preceding  [2.x.63]  will be returned. If  [2.x.64]      already corresponds to the first index, the first index will be returned.     A custom hierarchy can be supplied via the member function     set_hierachy().    
* [0.x.35]*
     Return a component mask with as many elements as this object has vector     components and of which exactly the one component is true that     corresponds to the given argument.        
*  [2.x.65]  This function is the equivalent of      [2.x.66]  with the same arguments. It verifies     that it gets the same result from every one of the elements that are     stored in this FECollection. If this is not the case, it throws an     exception.          [2.x.67]  scalar An object that represents a single scalar vector     component of this finite element.      [2.x.68]  A component mask that is false in all components except for the     one that corresponds to the argument.    
* [0.x.36]*
     Return a component mask with as many elements as this object has vector     components and of which exactly the  [2.x.69]  components are     true that correspond to the given argument.        
*  [2.x.70]  This function is the equivalent of      [2.x.71]  with the same arguments. It verifies     that it gets the same result from every one of the elements that are     stored in this FECollection. If this is not the case, it throws an     exception.          [2.x.72]  vector An object that represents dim vector components of this     finite element.      [2.x.73]  A component mask that is false in all components except for the     ones that corresponds to the argument.    
* [0.x.37]*
     Return a component mask with as many elements as this object has vector     components and of which exactly the  [2.x.74]      components are true that correspond to the given argument.        
*  [2.x.75]  This function is the equivalent of      [2.x.76]  with the same arguments. It verifies     that it gets the same result from every one of the elements that are     stored in this FECollection. If this is not the case, it throws an     exception.          [2.x.77]  sym_tensor An object that represents dim*(dim+1)/2 components of     this finite element that are jointly to be interpreted as forming a     symmetric tensor.      [2.x.78]  A component mask that is false in all components except for the     ones that corresponds to the argument.    
* [0.x.38]*
     Given a block mask (see      [2.x.79]  "this glossary entry"     ), produce a component mask (see      [2.x.80]  "this glossary entry"     ) that represents the components that correspond to the blocks selected     in the input argument. This is essentially a conversion operator from     BlockMask to ComponentMask.        
*  [2.x.81]  This function is the equivalent of      [2.x.82]  with the same arguments. It verifies     that it gets the same result from every one of the elements that are     stored in this FECollection. If this is not the case, it throws an     exception.          [2.x.83]  block_mask The mask that selects individual blocks of the finite     element      [2.x.84]  A mask that selects those components corresponding to the     selected blocks of the input argument.    
* [0.x.39]*
     Return a block mask with as many elements as this object has blocks and     of which exactly the one component is true that corresponds to the     given argument. See      [2.x.85]  "the glossary"     for more information.        
*  [2.x.86]  This function will only succeed if the scalar referenced by the     argument encompasses a complete block. In other words, if, for example,     you pass an extractor for the single  [2.x.87]  velocity and this object     represents an FE_RaviartThomas object, then the single scalar object     you selected is part of a larger block and consequently there is no     block mask that would represent it. The function will then produce an     exception.        
*  [2.x.88]  This function is the equivalent of      [2.x.89]  with the same arguments. It verifies     that it gets the same result from every one of the elements that are     stored in this FECollection. If this is not the case, it throws an     exception.          [2.x.90]  scalar An object that represents a single scalar vector     component of this finite element.      [2.x.91]  A component mask that is false in all components except for the     one that corresponds to the argument.    
* [0.x.40]*
     Return a component mask with as many elements as this object has vector     components and of which exactly the  [2.x.92]  components are     true that correspond to the given argument. See      [2.x.93]  "the glossary"     for more information.        
*  [2.x.94]  This function is the equivalent of      [2.x.95]  with the same arguments. It verifies     that it gets the same result from every one of the elements that are     stored in this FECollection. If this is not the case, it throws an     exception.        
*  [2.x.96]  The same caveat applies as to the version of the function above:     The extractor object passed as argument must be so that it corresponds     to full blocks and does not split blocks of this element.          [2.x.97]  vector An object that represents dim vector components of this     finite element.      [2.x.98]  A component mask that is false in all components except for the     ones that corresponds to the argument.    
* [0.x.41]*
     Return a component mask with as many elements as this object has vector     components and of which exactly the  [2.x.99]      components are true that correspond to the given argument. See      [2.x.100]  "the glossary"     for more information.        
*  [2.x.101]  The same caveat applies as to the version of the function above:     The extractor object passed as argument must be so that it corresponds     to full blocks and does not split blocks of this element.        
*  [2.x.102]  This function is the equivalent of      [2.x.103]  with the same arguments. It verifies     that it gets the same result from every one of the elements that are     stored in this FECollection. If this is not the case, it throws an     exception.          [2.x.104]  sym_tensor An object that represents dim*(dim+1)/2 components of     this finite element that are jointly to be interpreted as forming a     symmetric tensor.      [2.x.105]  A component mask that is false in all components except for the     ones that corresponds to the argument.    
* [0.x.42]*
     Given a component mask (see      [2.x.106]  "this glossary entry"     ), produce a block mask (see      [2.x.107]  "this glossary entry"     ) that represents the blocks that correspond to the components selected     in the input argument. This is essentially a conversion operator from     ComponentMask to BlockMask.        
*  [2.x.108]  This function will only succeed if the components referenced by     the argument encompasses complete blocks. In other words, if, for     example, you pass an component mask for the single  [2.x.109]  velocity and     this object represents an FE_RaviartThomas object, then the single     component you selected is part of a larger block and consequently there     is no block mask that would represent it. The function will then     produce an exception.        
*  [2.x.110]  This function is the equivalent of      [2.x.111]  with the same arguments. It verifies     that it gets the same result from every one of the elements that are     stored in this FECollection. If this is not the case, it throws an     exception.          [2.x.112]  component_mask The mask that selects individual components of     the finite element      [2.x.113]  A mask that selects those blocks corresponding to the selected     blocks of the input argument.    
* [0.x.43]*
      [2.x.114]  Exceptions      [2.x.115]     
* [0.x.44]*
     Exception        
*  [2.x.116]     
* [0.x.45]*
      [2.x.117]     
* [0.x.46]*
     %Function returning the index of the finite element following the given     one in hierarchy.    
* [0.x.47]*
     %Function returning the index of the finite element preceding the given     one in hierarchy.    
* [0.x.48]

include/deal.II-translator/hp/fe_values_0.txt
[0.x.0]*
   Base class for the  [2.x.0]  classes, storing the data   that is common to them. The main task of this class is to provide a   table where for every combination of finite element, mapping, and   quadrature object from their corresponding collection objects there is   a matching ::FEValues, ::FEFaceValues, or ::FESubfaceValues object.     To make things more efficient, however, these FE*Values objects are only   created once requested (lazy allocation). Alternatively if desired, this   can be bypassed by computing all objects in advance with the corresponding   precalculate_fe_values() function.     The first template parameter denotes the space dimension we are in, the   second the dimensionality of the object that we integrate on, i.e. for   usual  [2.x.1]  it is equal to the first one, while for face   integration it is one less. The third template parameter indicates the   type of underlying non-hp-FE*Values base type, i.e. it could either be   ::FEValues, ::FEFaceValues, or ::FESubfaceValues.    
*  [2.x.2]   
* [0.x.1]*
     Constructor. Set the fields of this class to the values indicated by     the parameters to the constructor.    
* [0.x.2]*
     Like the above function but taking a vector of quadrature collections.     For  [2.x.3]  the ith entry of the quadrature collections are     interpreted as the face quadrature rules to be applied the ith face.    
* [0.x.3]*
     Constructor. This constructor is equivalent to the other one except     that it makes the object use a  [2.x.4]  mapping (i.e., an object of type     MappingQGeneric(1)) implicitly.    
* [0.x.4]*
     Like the above function but taking a vector quadrature collections.     For  [2.x.5]  the ith entry of the quadrature collections are     interpreted as the face quadrature rules to be applied the ith face.    
* [0.x.5]*
     Copy constructor.    
* [0.x.6]*
     Copy operator. While objects of this type can be copy-constructed,     they cannot be copied and consequently this operator is disabled.    
* [0.x.7]*
     For timing purposes it may be useful to create all required FE*Values     objects in advance, rather than computing them on request via lazy     allocation as usual in this class.         This function precalculates the FE*Values objects corresponding to the     provided parameters: The total of all vector entries corresponding to the     same index describes an FE*Values object similarly to select_fe_values().    
* [0.x.8]*
     Same as above, geared to the most common use of  [2.x.6]  objects in     which FE, quadrature and mapping indices are similar on each individual     cell.         FE*Values objects are created for every FE in the FECollection, with     quadrature and mapping corresponding to the same index from the     QuadratureCollection and MappingCollection, respectively.         If QuadratureCollection or MappingCollection contains only one object, it     is used for all FE*Values objects.    
* [0.x.9]*
     Get a reference to the collection of finite element objects used     here.    
* [0.x.10]*
     Get a reference to the collection of mapping objects used here.    
* [0.x.11]*
     Get a reference to the collection of quadrature objects used here.    
* [0.x.12]*
     Get the underlying update flags.    
* [0.x.13]*
     Return a reference to the  [2.x.7]  object selected by the last     call to select_fe_values(). select_fe_values() in turn is called when     you called the  [2.x.8]  function of the  [2.x.9]  class     the last time.    
* [0.x.14]*
     Select a FEValues object suitable for the given FE, quadrature, and     mapping indices. If such an object doesn't yet exist, create one.         The function returns a writable reference so that derived classes can     also reinit() the selected FEValues object.    
* [0.x.15]*
     A pointer to the collection of finite elements to be used.    
* [0.x.16]*
     A pointer to the collection of mappings to be used.    
* [0.x.17]*
     Copy of the quadrature collection object provided to the constructor.    
* [0.x.18]*
     Vector of quadrature collections. For  [2.x.10]  the ith entry of     the quadrature collections are interpreted as the face quadrature rules     to be applied the ith face.         The variable q_collection collects the first quadrature rule of each     quadrature collection of the vector.    
* [0.x.19]*
     A table in which we store pointers to fe_values objects for different     finite element, mapping, and quadrature objects from our collection.     The first index indicates the index of the finite element within the     fe_collection, the second the index of the mapping within the mapping     collection, and the last one the index of the quadrature formula     within the q_collection.         Initially, all entries have zero pointers, and we will allocate them     lazily as needed in select_fe_values() or precalculate_fe_values().    
* [0.x.20]*
     Set of indices pointing at the fe_values object selected last time     the select_fe_value() function was called.    
* [0.x.21]*
     Values of the update flags as given to the constructor.    
* [0.x.22]*
   An hp-equivalent of the ::FEValues class. See the  [2.x.11]  tutorial   program for examples of use.     The idea of this class is as follows: when one assembled matrices in the   hp-finite element method, there may be different finite elements on   different cells, and consequently one may also want to use different   quadrature formulas for different cells. On the other hand, the   ::FEValues efficiently handles pre-evaluating whatever information is   necessary for a single finite element and quadrature object. This class   brings these concepts together: it provides a "collection" of ::FEValues   objects.     Upon construction, one passes not one finite element and quadrature   object (and possible a mapping), but a whole collection of type    [2.x.12]  and  [2.x.13]  Later on, when one sits on a   concrete cell, one would call the reinit() function for this particular   cell, just as one does for a regular ::FEValues object. The difference is   that this time, the reinit() function looks up the active FE index of   that cell, if necessary creates a ::FEValues object that matches the   finite element and quadrature formulas with that particular index in   their collections, and then re-initializes it for the current cell. The   ::FEValues object that then fits the finite element and quadrature   formula for the current cell can then be accessed using the   get_present_fe_values() function, and one would work with it just like   with any ::FEValues object for non-hp-DoFHandler objects.     The reinit() functions have additional arguments with default values. If   not specified, the function takes the index into the  [2.x.14]     [2.x.15]  and  [2.x.16]  objects from the   active FE index of the cell, as explained above. However, one can also   select different indices for a current cell. For example, by specifying a   different index into the  [2.x.17]  class, one does not need to sort   the quadrature objects in the quadrature collection so that they match   one-to-one the order of finite element objects in the FE collection (even   though choosing such an order is certainly convenient).     Note that ::FEValues objects are created on the fly, i.e. only as they   are needed. This ensures that we do not create objects for every   combination of finite element, quadrature formula and mapping, but only   those that will actually be needed. Alternatively if desired, this   can be bypassed by computing all objects in advance with the corresponding    [2.x.18]  function.     This class has not yet been implemented for the use in the codimension   one case (<tt>spacedim != dim </tt>).    
*  [2.x.19]   
* [0.x.23]*
     Constructor. Initialize this object with the given parameters.    
* [0.x.24]*
     Constructor. This constructor is equivalent to the other one except     that it makes the object use a  [2.x.20]  mapping (i.e., an object of type     MappingQGeneric(1)) implicitly.    
* [0.x.25]*
     Reinitialize the object for the given cell.         After the call, you can get an FEValues object using the     get_present_fe_values() function that corresponds to the present cell.     For this FEValues object, we use the additional arguments described     below to determine which finite element, mapping, and quadrature     formula to use. They are order in such a way that the arguments one may     want to change most frequently come first. The rules for these     arguments are as follows:         If the  [2.x.21]  argument to this function is left at its default     value, then we use that finite element within the  [2.x.22]      passed to the constructor of this class with index given by      [2.x.23] . Consequently, the      [2.x.24]  argument given to this object should really be the     same as that used in the construction of the DoFHandler associated     with the present cell. On the other hand, if a value is given for this     argument, it overrides the choice of      [2.x.25] .         If the  [2.x.26]  argument is left at its default value, then we use     that quadrature formula within the  [2.x.27]  passed to the     constructor of this class with index given by      [2.x.28] , i.e. the same index as that of     the finite element. In this case, there should be a corresponding     quadrature formula for each finite element in the  [2.x.29]  As     a special case, if the quadrature collection contains only a single     element (a frequent case if one wants to use the same quadrature object     for all finite elements in an hp-discretization, even if that may not     be the most efficient), then this single quadrature is used unless a     different value for this argument is specified. On the other hand, if a     value is given for this argument, it overrides the choice of      [2.x.30]  or the choice for the single     quadrature.         If the  [2.x.31]  argument is left at its default value, then we     use that mapping object within the  [2.x.32]  passed to the     constructor of this class with index given by      [2.x.33] , i.e. the same index as that of     the finite element. As above, if the mapping collection contains only a     single element (a frequent case if one wants to use a  [2.x.34]  mapping for     all finite elements in an hp-discretization), then this single mapping     is used unless a different value for this argument is specified.    
* [0.x.26]*
     Like the previous function, but for non-DoFHandler iterators. The reason     this function exists is so that one can use  [2.x.35]  for     Triangulation objects too.         Since  [2.x.36]  doesn't make sense for     triangulation iterators, this function chooses the zero-th finite     element, mapping, and quadrature object from the relevant constructions     passed to the constructor of this object. The only exception is if you     specify a value different from the default value for any of these last     three arguments.    
* [0.x.27]*
   This is the equivalent of the  [2.x.37]  class but for face   integrations, i.e. it is to  [2.x.38]  what ::FEFaceValues is to   ::FEValues.     The same comments apply as in the documentation of the  [2.x.39]    class. However, it is important to note that it is here more common that   one would want to explicitly specify an index to a particular quadrature   formula in the reinit() functions. This is because the default index   corresponds to the finite element index on the current function. On the   other hand, integration on faces will typically have to happen with a   quadrature formula that is adjusted to the finite elements used on both   sides of a face. If one sorts the elements of the  [2.x.40]  with   ascending polynomial degree, and matches these finite elements with   corresponding quadrature formulas in the  [2.x.41]  passed to the   constructor, then the quadrature index passed to the reinit() function   should typically be something like  [2.x.42]    (cell- [2.x.43]  neighbor- [2.x.44]  to ensure   that a quadrature formula is chosen that is sufficiently accurate for    [2.x.45] both [2.x.46]  finite elements.    
*  [2.x.47]   
* [0.x.28]*
     Constructor. Initialize this object with the given parameters.    
* [0.x.29]*
     Like the function above, but taking a vector of collection of quadrature     rules. This allows to assign each face a different quadrature rule: the     ith entry of a collection is used as the face quadrature rule on the ith     face.         In the case that the collections only contains a single face quadrature,     this quadrature rule is use on all faces.    
* [0.x.30]*
     Constructor. This constructor is equivalent to the other one except     that it makes the object use a  [2.x.48]  mapping (i.e., an object of type     MappingQGeneric(1)) implicitly.    
* [0.x.31]*
     Like the function above, but taking a vector of collection of quadrature     rules. This allows to assign each face a different quadrature rule: the     ith entry of a collection is used as the face quadrature rule on the ith     face.         In the case that the collections only contains a single face quadrature,     this quadrature rule is use on all faces.    
* [0.x.32]*
     Reinitialize the object for the given cell and face.         After the call, you can get an FEFaceValues object using the     get_present_fe_values() function that corresponds to the present cell.     For this FEFaceValues object, we use the additional arguments described     below to determine which finite element, mapping, and quadrature     formula to use. They are order in such a way that the arguments one may     want to change most frequently come first. The rules for these     arguments are as follows:         If the  [2.x.49]  argument to this function is left at its default     value, then we use that finite element within the  [2.x.50]      passed to the constructor of this class with index given by      [2.x.51] . Consequently, the      [2.x.52]  argument given to this object should really be the     same as that used in the construction of the DoFHandler associated     with the present cell. On the other hand, if a value is given for this     argument, it overrides the choice of      [2.x.53] .         If the  [2.x.54]  argument is left at its default value, then we use     that quadrature formula within the  [2.x.55]  passed to the     constructor of this class with index given by      [2.x.56] , i.e. the same index as that of     the finite element. In this case, there should be a corresponding     quadrature formula for each finite element in the  [2.x.57]  As     a special case, if the quadrature collection contains only a single     element (a frequent case if one wants to use the same quadrature object     for all finite elements in an hp-discretization, even if that may not     be the most efficient), then this single quadrature is used unless a     different value for this argument is specified. On the other hand, if a     value is given for this argument, it overrides the choice of      [2.x.58]  or the choice for the single     quadrature.         If the  [2.x.59]  argument is left at its default value, then we     use that mapping object within the  [2.x.60]  passed to the     constructor of this class with index given by      [2.x.61] , i.e. the same index as that of     the finite element. As above, if the mapping collection contains only a     single element (a frequent case if one wants to use a  [2.x.62]  mapping for     all finite elements in an hp-discretization), then this single mapping     is used unless a different value for this argument is specified.    
* [0.x.33]*
     Reinitialize the object for the given cell and face.        
*  [2.x.63]   [2.x.64]  must be one of  [2.x.65]  face iterators.    
* [0.x.34]*
     Like the previous function, but for non-DoFHandler iterators. The reason     this function exists is so that one can use this class for     Triangulation objects too.         Since  [2.x.66]  doesn't make sense for     triangulation iterators, this function chooses the zero-th finite     element, mapping, and quadrature object from the relevant constructions     passed to the constructor of this object. The only exception is if you     specify a value different from the default value for any of these last     three arguments.    
* [0.x.35]*
     Reinitialize the object for the given cell and face.        
*  [2.x.67]   [2.x.68]  must be one of  [2.x.69]  face iterators.    
* [0.x.36]*
   This class implements for subfaces what  [2.x.70]  does for faces.   See there for further documentation.    
*  [2.x.71]   
* [0.x.37]*
     Constructor. Initialize this object with the given parameters.    
* [0.x.38]*
     Constructor. This constructor is equivalent to the other one except     that it makes the object use a  [2.x.72]  mapping (i.e., an object of type     MappingQGeneric(1)) implicitly.    
* [0.x.39]*
     Reinitialize the object for the given cell, face, and subface.         After the call, you can get an FESubfaceValues object using the     get_present_fe_values() function that corresponds to the present cell.     For this FESubfaceValues object, we use the additional arguments     described below to determine which finite element, mapping, and     quadrature formula to use. They are order in such a way that the     arguments one may want to change most frequently come first. The rules     for these arguments are as follows:         If the  [2.x.73]  argument is left at its default value, then we use     that quadrature formula within the  [2.x.74]  passed to the     constructor of this class with index given by      [2.x.75] , i.e. the same index as that of     the finite element. In this case, there should be a corresponding     quadrature formula for each finite element in the  [2.x.76]  As     a special case, if the quadrature collection contains only a single     element (a frequent case if one wants to use the same quadrature object     for all finite elements in an hp-discretization, even if that may not     be the most efficient), then this single quadrature is used unless a     different value for this argument is specified. On the other hand, if a     value is given for this argument, it overrides the choice of      [2.x.77]  or the choice for the single     quadrature.         If the  [2.x.78]  argument is left at its default value, then we     use that mapping object within the  [2.x.79]  passed to the     constructor of this class with index given by      [2.x.80] , i.e. the same index as that of     the finite element. As above, if the mapping collection contains only a     single element (a frequent case if one wants to use a  [2.x.81]  mapping for     all finite elements in an hp-discretization), then this single mapping     is used unless a different value for this argument is specified.    
* [0.x.40]*
     Like the previous function, but for non-DoFHandler iterators. The reason     this function exists is so that one can use this class for     Triangulation objects too.         Since  [2.x.82]  doesn't make sense for     Triangulation iterators, this function chooses the zero-th finite     element, mapping, and quadrature object from the relevant constructions     passed to the constructor of this object. The only exception is if you     specify a value different from the default value for any of these last     three arguments.    
* [0.x.41]

include/deal.II-translator/hp/mapping_collection_0.txt
[0.x.0]*
   This class implements a collection of mapping objects in the same way as   the  [2.x.0]  implements a collection of finite element classes.     It implements the concepts stated in the    [2.x.1]    module described in the doxygen documentation.     Although it is recommended to supply an appropriate mapping for each   finite element kind used in a hp-computation, the MappingCollection class   implements a conversion constructor from a single mapping.  Therefore it   is possible to offer only a single mapping to the  [2.x.2]  class   instead of a  [2.x.3]  This is for the convenience of the   user, as many simple geometries do not require different mappings along   the boundary to achieve optimal convergence rates.  Hence providing a   single mapping object will usually suffice. See the  [2.x.4]  class   for the rules which mapping will be selected for a given cell.    
*  [2.x.5]   
* [0.x.1]*
     Default constructor. Leads to an empty collection that can later be     filled using push_back().    
* [0.x.2]*
     Conversion constructor. This constructor creates a MappingCollection     from a single mapping. More mappings can be added with push_back(), if     desired, though it would probably be clearer to add all mappings the     same way.    
* [0.x.3]*
     Copy constructor.    
* [0.x.4]*
     Constructor. This constructor creates a MappingCollection from one or     more mapping objects passed to the constructor. For this     call to be valid, all arguments need to be of types derived     from class Mapping<dim,spacedim>.    
* [0.x.5]*
     Add a new mapping to the MappingCollection. Generally, you will     want to use the same order for mappings as for the elements of     the  [2.x.6]  object you use. However, the same     considerations as discussed with the  [2.x.7]      function also apply in the current context.         This class creates a copy of the given mapping object, i.e., you can     do things like <tt>push_back(MappingQ<dim>(3));</tt>. The internal copy     is later destroyed by this object upon destruction of the entire     collection.    
* [0.x.6]*
   Many places in the library by default use (bi-,tri-)linear mappings   unless users explicitly provide a different mapping to use. In these   cases, the called function has to create a  [2.x.8]  mapping object, i.e., an   object of kind MappingQGeneric(1). This is costly. It would also be   costly to create such objects as static objects in the affected   functions, because static objects are never destroyed throughout the   lifetime of a program, even though they only have to be created once the   first time code runs through a particular function.     In order to avoid creation of (static or dynamic)  [2.x.9]  mapping objects   in these contexts throughout the library, this class defines a static   collection of mappings with a single  [2.x.10]  mapping object. This   collection can then be used in all of those places where such a   collection is needed.  
* [0.x.7]*
     The publicly available static  [2.x.11]  mapping collection object.    
* [0.x.8]

include/deal.II-translator/hp/q_collection_0.txt
[0.x.0]*
   This class implements a collection of quadrature objects in the same way   as the  [2.x.0]  implements a collection of finite element   classes.     It implements the concepts stated in the    [2.x.1]    module described in the doxygen documentation.    
*  [2.x.2]   
* [0.x.1]*
     Default constructor. Leads to an empty collection that can later be     filled using push_back().    
* [0.x.2]*
     Copy constructor.    
* [0.x.3]*
     Conversion constructor. This constructor creates a QCollection from a     single quadrature rule. More quadrature formulas can be added with     push_back(), if desired, though it would probably be clearer to add all     mappings the same way.    
* [0.x.4]*
     Constructor. This constructor creates a QCollection from one or     more quadrature objects passed to the constructor. For this     call to be valid, all arguments need to be of types derived     from class Quadrature<dim>.    
* [0.x.5]*
     Add a new quadrature rule to the QCollection. In most cases, you will     want to add quadrature rules in the same order as the elements were     added to the  [2.x.3]  for which this quadrature rule collection     is meant. If done this way, the  [2.x.4]  objects with which you will     use both  [2.x.5]  and  [2.x.6]  objects will automatically     choose corresponding elements and quadrature formulas. On the other hand,     it is possible to use arbitrary combinations of elements and quadrature     formulas in  [2.x.7]  and  [2.x.8]  objects when     specifically specifying appropriate indices in calls to      [2.x.9]  or  [2.x.10]  In those cases,     there need not be a correspondence between elements of the      [2.x.11]  and  [2.x.12]  objects; they need not even be of     the same size in this case.         The same arguments about the order of elements of collections can, by     the way, also be made about the elements of  [2.x.13]      objects.         This class creates a copy of the given quadrature object, i.e., you can     do things like <tt>push_back(QGauss<dim>(3));</tt>. The internal copy     is later destroyed by this object upon destruction of the entire     collection.    
* [0.x.6]*
     Equality comparison operator. All stored Quadrature objects are compared     in order.    
* [0.x.7]*
     Return the maximum number of quadrature points over all the elements of     the collection. This is mostly useful to initialize arrays to allocate     the maximum amount of memory that may be used when re-sizing later on     to a articular quadrature formula from within this collection.    
* [0.x.8]*
     Exception    
* [0.x.9]*
     The real container, which stores pointers to the different quadrature     objects.    
* [0.x.10]

include/deal.II-translator/hp/refinement_0.txt
[0.x.0]*
   We supply adaptive methods to align computational resources with the   complexity of the numerical solution. Error estimates are an appropriate   means of determining where adjustments need to be made.     However with hp-adaptivity, we have two ways to realize these adjustments:   For irregular solutions, h-adaptive methods which dynamically assign cell   sizes tend to reduce the approximation error, while for smooth solutions   p-adaptive methods are better suited in which function spaces will be   selected dynamically. This namespace collects tools to decide which type   of adaptive methods to apply.     [1.x.0]     To successfully apply hp-adaptive methods, we recommend the following   workflow:    [2.x.0]     [2.x.1]  A suitable error estimate is the basis for any kind of adaptive method.   Similar to pure grid refinement, we will determine error estimates in the   usual way (i.e. KellyErrorEstimator) and mark cells for refinement or   coarsening (i.e. GridRefinement).     Calling  [2.x.2]  at this stage   will perform pure grid refinement as expected.      [2.x.3]  Once all refinement and coarsening flags have been distributed on the   mesh, we may determine if those qualify for p-adaptive methods.   Corresponding functions will set  [2.x.4]  on top of the   refinement and coarsening flags if they fulfil a certain criterion.     In case of refinement, the superordinate element of the underlying    [2.x.5]  will be assigned as the future finite element.   Correspondingly, the subordinate element will be selected for coarsening.      [2.x.6]  will now supply both   h- and p-adaptive methods independently.      [2.x.7]  Right now, there may be cells scheduled for both h- and p-adaptation.   If we do not want to impose both methods at once, we need to decide which   one to pick for each cell individually and unambiguously. Since grid   refinement will be imposed by default and we only determine qualification   for p-adaptivity on top, we will always decide in favour of p-adaptive   methods.     Calling  [2.x.8]  will now perform   either h- or p-adaptive methods uniquely on each cell.      [2.x.9]  Up to this point, each cell knows its destiny in terms of adaptivity.   We can now move on to prepare all data structures to be transferred across   mesh changes. Previously set refinement and coarsening flags as well as    [2.x.10]  will be used to update the data accordingly.    [2.x.11]      As an example, a realisation of pure p-adaptive methods would look like the   following:  
* [1.x.1]
*     
*  [2.x.12]   
* [0.x.1]*
     An alias that defines the characteristics of a function that can be used     as a comparison criterion for deciding whether to perform h- or     p-adaptation.         Such functions take two numbers as arguments: The first one corresponds     to the provided criterion, while the other one conforms to the reference.     The result of the comparison will be returned as a boolean.    
* [0.x.2]*
      [2.x.13]  Setting p-adaptivity flags      [2.x.14]     
* [0.x.3]*
     Each cell flagged for h-refinement will also be flagged for p-refinement.     The same applies to coarsening.        
*  [2.x.15]   [2.x.16]  and        [2.x.17]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.4]*
     Adapt which finite element to use on cells that have been specifically     flagged for p-adaptation via the parameter  [2.x.18]  Future finite     elements will only be assigned if cells have been flagged for refinement     and coarsening beforehand.         Each entry of the parameter  [2.x.19]  needs to correspond to an active     cell.        
*  [2.x.20]   [2.x.21]  and        [2.x.22]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.5]*
     Adapt which finite element to use on cells whose criteria meet a certain     absolute threshold.         For p-refinement and p-coarsening, two separate thresholds need to     provided via parameters  [2.x.23]  and  [2.x.24]          We consider a cell for p-adaptivity if it is currently flagged for     refinement or coarsening and its criterion successfully compares to the     corresponding threshold. Let us be more specific on the default case: We     consider a cell for p-refinement if it is flagged for refinement and its     criterion is larger than or equal to the corresponding threshold. The     same applies for p-coarsening, but the cell's criterion must be lower     than or equal to the threshold. However, different compare function     objects can be supplied via the parameters  [2.x.25]  and      [2.x.26]  to impose different decision strategies.         Each entry of the parameter  [2.x.27]  needs to correspond to an active     cell.        
*  [2.x.28]   [2.x.29]  and        [2.x.30]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.6]*
     Adapt which finite element to use on cells whose criteria meet a certain     threshold relative to the overall range of criterion values.         The threshold will be determined for refined and coarsened cells     separately based on the currently set refinement markers. For each class     of cells, we determine the maximal and minimal values of all criteria and     determine the threshold by linear interpolation between these limits.     Parameters  [2.x.31]  and  [2.x.32]  are used as     interpolation factors, where `0` corresponds to the minimal and `1` to     the maximal value. By default, mean values are considered as thresholds.         We consider a cell for p-adaptivity if it is currently flagged for     refinement or coarsening and its criterion successfully compares to the     corresponding threshold. Let us be more specific on the default case: We     consider a cell for p-refinement if it is flagged for refinement and its     criterion is larger than or equal to the corresponding threshold. The     same applies for p-coarsening, but the cell's criterion must be lower     than or equal to the threshold. However, different compare function     objects can be supplied via the parameters  [2.x.33]  and      [2.x.34]  to impose different decision strategies.         Each entry of the parameter  [2.x.35]  needs to correspond to an active     cell. Parameters  [2.x.36]  and  [2.x.37]  need to be     in the interval  [2.x.38] .        
*  [2.x.39]   [2.x.40]  and        [2.x.41]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.7]*
     Adapt which finite element to use on a given fraction of cells.         Out of all cells flagged for a certain type of adaptation, be it     refinement or coarsening, we will determine a fixed number of cells among     this subset that will be flagged for the corresponding p-adaptive     variant.         For each of both refinement and coarsening subsets, we will determine a     threshold based on the provided parameter  [2.x.42]  containing     indicators for every active cell. In the default case for refinement, all     cells with an indicator larger than or equal to the corresponding     threshold will be considered for p-refinement, while for coarsening all     cells with an indicator less than or equal to the matching threshold are     taken into account. However, different compare function objects can be     supplied via the parameters  [2.x.43]  and  [2.x.44]  to     impose different decision strategies.         For refinement, the threshold will be associated with the cell that has     the  [2.x.45]  times  [2.x.46]  largest     indicator, while it is the cell with the  [2.x.47]  times      [2.x.48]  lowest indicator for coarsening.         Each entry of the parameter  [2.x.49]  needs to correspond to an active     cell. Parameters  [2.x.50]  and  [2.x.51]  need to be     in the interval  [2.x.52] .        
*  [2.x.53]   [2.x.54]  and        [2.x.55]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.8]*
     Adapt which finite element to use on cells based on the regularity of the     (unknown) analytical solution.         With an approximation of the local Sobolev regularity index  [2.x.56] ,     we may assess to which finite element space our local solution on cell      [2.x.57]  belongs. Since the regularity index is only an estimate, we won't     use it to assign the finite element space directly, but rather consider     it as an indicator for adaptation. If a cell is flagged for refinement,     we will perform p-refinement once it satisfies      [2.x.58] , where  [2.x.59]  is     the polynomial degree of the finite element superordinate to the     currently active element on cell  [2.x.60] . In case of coarsening, the     criterion  [2.x.61]  has to be met, with      [2.x.62]  the degree of the subordinate element.         Each entry of the parameter  [2.x.63]  needs to correspond     to an active cell.         For more theoretical details see  [2.x.64]  .        
*  [2.x.65]   [2.x.66]  and        [2.x.67]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.9]*
     Adapt which finite element to use on each cell based on how its criterion     relates to a reference.         We consider a cell for p-adaptivity if it is currently flagged for     refinement or coarsening and its criterion successfully compares to the     corresponding reference. Other than functions     p_adaptivity_from_absolute_threshold() and     p_adaptivity_from_relative_threshold(), compare function objects have to     be provided explicitly via the parameters  [2.x.68]  and      [2.x.69]          Each entry of the parameters  [2.x.70]  and  [2.x.71]  needs to     correspond to an active cell.        
*  [2.x.72]   [2.x.73]  and        [2.x.74]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.10]*
      [2.x.75]     
* [0.x.11]*
      [2.x.76]  Error prediction      [2.x.77]     
* [0.x.12]*
     Predict how the current  [2.x.78]  will adapt after refinement     and coarsening were to happen on the provided  [2.x.79]  and write its     results to  [2.x.80]  Each entry of  [2.x.81]  and      [2.x.82]  corresponds to an active cell on the underlying     Triangulation, thus each container has to be of size      [2.x.83]  The errors are interpreted to be     measured in the energy norm; this assumption enters the rate of     convergence that is used in the prediction. The  [2.x.84] -norm of the output     argument  [2.x.85]  corresponds to the predicted global error     after adaptation.         For p-adaptation, the local error is expected to converge exponentially     with the polynomial degree of the assigned finite element. Each increase     or decrease of the degree will thus change its value by a user-defined     control parameter  [2.x.86]          For h-adaptation, we expect the local error  [2.x.87]  on cell  [2.x.88]  to be     proportional to  [2.x.89]  in the energy norm, where  [2.x.90]  denotes the     cell diameter and  [2.x.91]  the polynomial degree of the currently assigned     finite element on cell  [2.x.92] .         During h-coarsening, the finite elements on siblings may be     different, and their parent cell will be assigned to their least     dominating finite element that belongs to its most general child. Thus,     we will always interpolate on an enclosing finite element space.     Additionally assuming that the finite elements on the cells to be     coarsened are sufficient to represent the solution correctly (e.g. at     least quadratic basis functions for a quadratic solution), we are     confident to say that the error will not change by sole interpolation on     the larger finite element space.         For p-adaptation, the local error is expected to converge exponentially     with the polynomial degree of the assigned finite element. Each increase     or decrease of the degree will thus change its value by a user-defined     control parameter  [2.x.93]  The assumption of exponential convergence     is only valid if both h- and p-adaptive methods are combined in a sense     that they are both utilitzed throughout a mesh, but do not have to be     applied both on a cell simultaneously.         The prediction algorithm is formulated as follows with control parameters      [2.x.94]   [2.x.95]  and  [2.x.96]  that may be used to influence     prediction for each adaptation type individually. The results for each     individual cell are stored in the  [2.x.97]  output argument.      [2.x.98]          On basis of the refinement history, we use the predicted error estimates     to decide how cells will be adapted in the next adaptation step.     Comparing the predicted error from the previous adaptation step to the     error estimates of the current step allows us to justify whether our     previous choice of adaptation was justified, and lets us decide how to     adapt in the next one.         We thus have to transfer the predicted error from the old to the adapted     mesh. When transferring the predicted error to the adapted mesh, make     sure to configure your CellDataTransfer object with      [2.x.99]  as a refinement strategy and      [2.x.100]  as a coarsening strategy.     This ensures that the  [2.x.101] -norm of the predict errors is preserved on     both meshes.         In this context, we assume that the local error on a cell to be h-refined     will be divided equally on all of its  [2.x.102]  children, whereas local     errors on siblings will be summed up on the parent cell in case of     h-coarsening. This assumption is often not satisfied in practice: For     example, if a cell is at a corner singularity, then the one child cell     that ends up closest to the singularity will inherit the majority of the     remaining error
* 
*  -  but this function can not know where the singularity     will be, and consequently assumes equal distribution.         Incorporating the transfer from the old to the adapted mesh, the complete     error prediction algorithm reads as follows:      [2.x.103]          With these predicted error estimates, we are capable of adapting the     finite element on cells based on their refinement history or rather the     predicted change of their error estimates.         If a cell is flagged for adaptation, we want to perform p-adaptation once     the associated error indicators  [2.x.104]  on cell  [2.x.105]  satisfy      [2.x.106] , where the subscript  [2.x.107]      denotes the predicted error. This corresponds to our assumption of     smoothness being correct, else h-adaptation is applied. We achieve this     with the function  [2.x.108]  and a     function object  [2.x.109]  for both comparator parameters.         Also with an alternative strategy, we can determine the fractions of     cells to be h- and p-adapted among all cells to be adapted. For this, use      [2.x.110]  with criteria      [2.x.111] .         For the very first adaptation step in either case, the user needs to     decide whether h- or p-adaptation is supposed to happen. An h-step will     be applied with  [2.x.112] , whereas      [2.x.113]  ensures a p-step. The latter may be     realized with  [2.x.114]          The following code snippet demonstrates how to impose hp-adaptivity based     on refinement history in an application:    
* [1.x.2]
*          For more theoretical details see  [2.x.115]  , where the default     parameters for this function come from as well, i.e.      [2.x.116] ,  [2.x.117] ,      [2.x.118] .         If you are working with  [2.x.119]  objects, you     need to pay special attention. Here, p4est determines the details of grid     refinement, and consequently, it yields more reliable and trustworthy     results when we determine the predicted errors during the adaptation     process. We can do exactly this by attaching this function to the signal      [2.x.120]  which is triggered after     p4est got refined, but before data is prepared for transfer. Refinement     and coarsening flags of the Triangulation object need to be matched with     the already refined p4est oracle using      [2.x.121]      Thus, a construct like the following is necessary to correctly predict     errors in parallel distributed applications.    
* [1.x.3]
*      The container  [2.x.122]  then needs to follow the     usual  [2.x.123]  workflow.        
*  [2.x.124]  We want to predict the error by how adaptation will actually happen.       Thus, this function needs to be called after        [2.x.125]  and        [2.x.126]     
* [0.x.13]*
      [2.x.127]     
* [0.x.14]*
      [2.x.128]  Decide between h- and p-adaptivity      [2.x.129]     
* [0.x.15]*
     Choose p-adaptivity over h-adaptivity in any case.         Removes all refine and coarsen flags on cells that have a      [2.x.130]  assigned.        
*  [2.x.131]   [2.x.132]  and        [2.x.133]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.16]*
     Choose p-adaptivity over h-adaptivity whenever it is invoked on all     related cells.         In case of refinement, information about finite elements will be     inherited. Thus we will prefer p-refinement over h-refinement whenever     desired, i.e. clear the refine flag and supply a corresponding      [2.x.134]          However for coarsening, we follow a different approach. Flagging a cell     for h-coarsening does not ultimately mean that it will be coarsened. Only     if a cell and all of its siblings are flagged, they will be merged into     their parent cell. If we consider p-coarsening on top, we must decide for     all siblings together how they will be coarsened. We distinguish between     three different cases:      [2.x.135]       [2.x.136]  Not all siblings flagged for coarsening: p-coarsening.        [2.x.137]        We keep the  [2.x.138]  and clear the coarsen flags       on all siblings.      [2.x.139]  All siblings flagged for coarsening, but not all for       p-adaptation: h-coarsening.        [2.x.140]        We keep the coarsen flags and clear all  [2.x.141]        on all siblings.      [2.x.142]  All siblings flagged for coarsening and p-adaptation: p-coarsening.        [2.x.143]        We keep the  [2.x.144]  and clear the coarsen flags       on all siblings.      [2.x.145]         
*  [2.x.146]  The function  [2.x.147]        will clean up all h-coarsening flags if they are not shared among       all siblings. In the hp-case, we need to bring forward this decision:       If the cell will not be coarsened, but qualifies for p-adaptivity,       we have to set all flags accordingly. So this function anticipates       the decision that  [2.x.148]        would have made later on.        
*  [2.x.149]   [2.x.150]  and        [2.x.151]  may change       refine and coarsen flags as well as future finite element indices.       Avoid calling them before this particular function.    
* [0.x.17]*
      [2.x.152]     
* [0.x.18]*
      [2.x.153]  Optimiize p-level distribution      [2.x.154]     
* [0.x.19]*
     Limit p-level differences between neighboring cells.         Essentially does to future FE indices what      [2.x.155]  does to refinement     flags.         In detail, this function limits the level difference of neighboring cells     and thus smoothes the overall function space. Future FE indices will be     raised (and never lowered) so that the level difference to neighboring     cells is never larger than  [2.x.156]          Multiple FE hierarchies might have been registered via      [2.x.157]  This function operates on only one     hierarchy, namely the one that contains the FE index  [2.x.158]      Cells with future FE indices that are not part of the corresponding     hierarchy will be ignored.         The function can optionally be called before performing adaptation with      [2.x.159]  It is not necessary     to call this function, nor will it be automatically invoked in any part     of the library (contrary to its Triangulation counterpart).         On cells that will be h-coarsened, we enforce the difference criterion as     if it is already a parent cell. That means, we set the level of all     siblings to the highest one among them. In that case, all sibling cells     need to have the h-coarsenening flags set terminally via      [2.x.160]  beforehand. Otherwise     an assertion will be triggered.         Returns whether any future FE indices have been changed by this function.    
* [0.x.20]*
      [2.x.161]     
* [0.x.21]

