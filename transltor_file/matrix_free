include/deal.II-translator/matrix_free/cuda_fe_evaluation_0.txt
[0.x.0]*
 Namespace for the CUDA wrappers

* 
* [0.x.1]*
     Compute the dof/quad index for a given thread id, dimension, and     number of points in each space dimensions.    
* [0.x.2]*
   This class provides all the functions necessary to evaluate functions at   quadrature points and cell integrations. In functionality, this class is   similar to FEValues<dim>.     This class has five template arguments:      [2.x.0]  dim Dimension in which this class is to be used      [2.x.1]  fe_degree Degree of the tensor prodict finite element with fe_degree+1   degrees of freedom per coordinate direction      [2.x.2]  n_q_points_1d Number of points in the quadrature formular in 1D,   defaults to fe_degree+1      [2.x.3]  n_components Number of vector components when solving a system of   PDEs. If the same operation is applied to several components of a PDE (e.g.   a vector Laplace equation), they can be applied simultaneously with one   call (and often more efficiently). Defaults to 1      [2.x.4]  Number Number format,  [2.x.5]  or  [2.x.6]  Defaults to  [2.x.7]    double.    
*  [2.x.8]   
* [0.x.3]*
     An alias for scalar quantities.    
* [0.x.4]*
     An alias for vectorial quantities.    
* [0.x.5]*
     An alias to kernel specific information.    
* [0.x.6]*
     Dimension.    
* [0.x.7]*
     Number of components.    
* [0.x.8]*
     Number of quadrature points per cell.    
* [0.x.9]*
     Number of tensor degrees of freedoms per cell.    
* [0.x.10]*
     Constructor.    
* [0.x.11]*
     For the vector  [2.x.9]  read out the values on the degrees of freedom of     the current cell, and store them internally. Similar functionality as     the function  [2.x.10]  when no     constraints are present, but it also includes constraints from hanging     nodes, so once can see it as a similar function to      [2.x.11]  as well.    
* [0.x.12]*
     Take the value stored internally on dof values of the current cell and     sum them into the vector  [2.x.12]  The function also applies constraints     during the write operation. The functionality is hence similar to the     function  [2.x.13]     
* [0.x.13]*
     Evaluate the function values and the gradients of the FE function given     at the DoF values in the input vector at the quadrature points on the     unit cell. The function arguments specify which parts shall actually be     computed. This function needs to be called before the functions      [2.x.14]  or  [2.x.15]  give useful information.    
* [0.x.14]*
     This function takes the values and/or gradients that are stored on     quadrature points, tests them by all the basis functions/gradients on     the cell and performs the cell integration. The two function arguments      [2.x.16]  and  [2.x.17]  are used to enable/disable some     of the values or the gradients.    
* [0.x.15]*
     Same as above, except that the quadrature point is computed from thread     id.    
* [0.x.16]*
     Same as above, except that the local dof index is computed from the     thread id.    
* [0.x.17]*
     Same as above, except that the quadrature point is computed from the     thread id.    
* [0.x.18]*
     Same as above, except that the local dof index is computed from the     thread id.    
* [0.x.19]*
     Same as above, except that the quadrature point is computed from the     thread id.    
* [0.x.20]*
     Same as above, except that the quadrature point is computed from the     thread id.    
* [0.x.21]*
     Same as above, except that the functor  [2.x.18]  only takes a single input     argument (fe_eval) and computes the quadrature point from the thread id.          [2.x.19]  needs to define     \code     __device__ void operator()(        [2.x.20]  fe_degree, n_q_points_1d, n_components, Number>fe_eval) const;     \endcode    
* [0.x.22]

include/deal.II-translator/matrix_free/cuda_hanging_nodes_internal_0.txt
[0.x.0]*
     This class creates the mask used in the treatment of hanging nodes in      [2.x.0]      The implementation of this class is explained in  [2.x.1] Section 3 of     Matrix-Free Finite-Element Computations On Graphics Processors With     Adaptively Refined Unstructured Meshes [2.x.2]  by Karl Ljungkvist,     SpringSim-HPC, 2017 April 23-26.    
* [0.x.1]*
       Constructor.      
* [0.x.2]*
       Compute the value of the constraint mask for a given cell.      
* [0.x.3]*
       Set up line-to-cell mapping for edge constraints in 3D.      
* [0.x.4]*
     This function resolves the hanging nodes using tensor product.         The implementation of this class is explained in  [2.x.3] Matrix-Free     Finite-Element Computations On Graphics Processors With Adaptively     Refined Unstructured Meshes [2.x.4]  by Karl Ljungkvist, SpringSim-HPC, 2017     April 23-26.    
* [0.x.5]

include/deal.II-translator/matrix_free/cuda_matrix_free.templates_0.txt
[0.x.0]*
     Transpose a N x M matrix stored in a one-dimensional array to a M x N     matrix stored in a one-dimensional array.    
* [0.x.1]*
     Same as above but the source and the destination are the same vector.    
* [0.x.2]*
     Allocate an array to the device and copy  [2.x.0]  to the device.    
* [0.x.3]*
     Helper class to (re)initialize MatrixFree object.    
* [0.x.4]

include/deal.II-translator/matrix_free/cuda_matrix_free_0.txt
[0.x.0]*
   This class collects all the data that is stored for the matrix free   implementation. The storage scheme is tailored towards several loops   performed with the same data, i.e., typically doing many matrix-vector   products or residual computations on the same mesh.     This class does not implement any operations involving finite element basis   functions, i.e., regarding the operation performed on the cells. For these   operations, the class FEEvaluation is designed to use the data collected in   this class.     This class implements a loop over all cells (cell_loop()). This loop is   scheduled in such a way that cells that share degrees of freedom   are not worked on simultaneously, which implies that it is possible to   write to vectors in parallel without having to explicitly synchronize   access to these vectors and matrices. This class does not implement any   shape values, all it does is to cache the respective data. To implement   finite element operations, use the class  [2.x.0]      This class traverse the cells in a different order than the usual   Triangulation class in deal.II.    
*  [2.x.1]  Only float and double are supported.    
*  [2.x.2]   
* [0.x.1]*
     Parallelization scheme used: parallel_in_elem (parallelism at the level     of degrees of freedom) or parallel_over_elem (parallelism at the level of     cells)    
* [0.x.2]*
     Standardized data struct to pipe additional data to MatrixFree.    
* [0.x.3]*
       Constructor.      
* [0.x.4]*
       Parallelization scheme used, parallelization over degrees of freedom or       over cells.      
* [0.x.5]*
       This flag is used to determine which quantities should be cached. This       class can cache data needed for gradient computations (inverse       Jacobians), Jacobian determinants (JxW), quadrature points as well as       data for Hessians (derivative of Jacobians). By default, only data for       gradients and Jacobian determinants times quadrature weights, JxW, are       cached. If quadrature points of second derivatives are needed, they       must be specified by this field.      
* [0.x.6]*
       If true, use graph coloring. Otherwise, use atomic operations. Graph       coloring ensures bitwise reproducibility but is slower on Pascal and       newer architectures.      
* [0.x.7]*
        Overlap MPI communications with computation. This requires CUDA-aware        MPI and use_coloring must be false.      
* [0.x.8]*
     Structure which is passed to the kernel. It is used to pass all the     necessary information from the CPU to the GPU.    
* [0.x.9]*
       Pointer to the quadrature points.      
* [0.x.10]*
       Map the position in the local vector to the position in the global       vector.      
* [0.x.11]*
       Pointer to the inverse Jacobian.      
* [0.x.12]*
       Pointer to the Jacobian times the weights.      
* [0.x.13]*
       ID of the associated MatrixFree object.      
* [0.x.14]*
       Number of cells.      
* [0.x.15]*
       Length of the padding.      
* [0.x.16]*
       Row start (including padding).      
* [0.x.17]*
       Mask deciding where constraints are set on a given cell.      
* [0.x.18]*
       If true, use graph coloring has been used and we can simply add into       the destingation vector. Otherwise, use atomic operations.      
* [0.x.19]*
     Default constructor.    
* [0.x.20]*
     Destructor.    
* [0.x.21]*
     Return the length of the padding.    
* [0.x.22]*
     Extracts the information needed to perform loops over cells. The     DoFHandler and AffineConstraints objects describe the layout of     degrees of freedom, the DoFHandler and the mapping describe the     transformation from unit to real cell, and the finite element     underlying the DoFHandler together with the quadrature formula     describe the local operations. This function takes an IteratorFilters     object (predicate) to loop over a subset of the active cells. When using     MPI, the predicate should filter out non locally owned cells.    
* [0.x.23]*
     Same as above using  [2.x.3]  as predicate.    
* [0.x.24]*
     Initializes the data structures. Same as above but using a Q1 mapping.    
* [0.x.25]*
     Return the Data structure associated with  [2.x.4]     
* [0.x.26]*
     This method runs the loop over all cells and apply the local operation on     each element in parallel.  [2.x.5]  is a functor which is applied on each color.          [2.x.6]  needs to define     \code     __device__ void operator()(       const unsigned int                                          cell,       const typename  [2.x.7]   [2.x.8]         [2.x.9]  Number>                     shared_data,       const Number                                              src,       Number                                                    dst) const;       static const unsigned int n_dofs_1d;       static const unsigned int n_local_dofs;       static const unsigned int n_q_points;     \endcode    
* [0.x.27]*
     This method runs the loop over all cells and apply the local operation on     each element in parallel. This function is very similar to cell_loop()     but it uses a simpler functor.          [2.x.10]  needs to define     \code      __device__ void operator()(        const unsigned int                                          cell,        const typename  [2.x.11]   [2.x.12]      static const unsigned int n_dofs_1d;     static const unsigned int n_local_dofs;     static const unsigned int n_q_points;     \endcode    
* [0.x.28]*
     Copy the values of the constrained entries from  [2.x.13]  to  [2.x.14]  This is     used to impose zero Dirichlet boundary condition.    
* [0.x.29]*
     Set the entries in  [2.x.15]  corresponding to constrained values to  [2.x.16]      The main purpose of this function is to set the constrained entries of     the source vector used in cell_loop() to zero.    
* [0.x.30]*
     Initialize a serial vector. The size corresponds to the number of degrees     of freedom in the DoFHandler object.    
* [0.x.31]*
     Initialize a distributed vector. The local elements correspond to the     locally owned degrees of freedom and the ghost elements correspond to the     (additional) locally relevant dofs.    
* [0.x.32]*
     Return the colored graph of locally owned active cells.    
* [0.x.33]*
     Return the partitioner that represents the locally owned data and the     ghost indices where access is needed to for the cell loop. The     partitioner is constructed from the locally owned dofs and ghost dofs     given by the respective fields. If you want to have specific information     about these objects, you can query them with the respective access     functions. If you just want to initialize a (parallel) vector, you should     usually prefer this data structure as the data exchange information can     be reused from one vector to another.    
* [0.x.34]*
     Free all the memory allocated.    
* [0.x.35]*
     Return the DoFHandler.    
* [0.x.36]*
     Return an approximation of the memory consumption of this class in bytes.    
* [0.x.37]*
     Initializes the data structures.    
* [0.x.38]*
     Helper function. Loop over all the cells and apply the functor on each     element in parallel. This function is used when MPI is not used.    
* [0.x.39]*
     Helper function. Loop over all the cells and apply the functor on each     element in parallel. This function is used when MPI is used.    
* [0.x.40]*
     This function should never be called. Calling it results in an internal     error. This function exists only because cell_loop needs     distributed_cell_loop() to exist for  [2.x.17]     
* [0.x.41]*
     Helper function. Copy the values of the constrained entries of  [2.x.18]  to      [2.x.19]  This function is used when MPI is not used.    
* [0.x.42]*
     Helper function. Copy the values of the constrained entries of  [2.x.20]  to      [2.x.21]  This function is used when MPI is used.    
* [0.x.43]*
     This function should never be called. Calling it results in an internal     error. This function exists only because copy_constrained_values needs     distributed_copy_constrained_values() to exist for      [2.x.22]     
* [0.x.44]*
     Helper function. Set the constrained entries of  [2.x.23]  to  [2.x.24]  This     function is used when MPI is not used.    
* [0.x.45]*
     Helper function. Set the constrained entries of  [2.x.25]  to  [2.x.26]  This     function is used when MPI is used.    
* [0.x.46]*
     This function should never be called. Calling it results in an internal     error. This function exists only because set_constrained_values needs     distributed_set_constrained_values() to exist for      [2.x.27]     
* [0.x.47]*
     Unique ID associated with the object.    
* [0.x.48]*
     Parallelization scheme used, parallelization over degrees of freedom or     over cells.    
* [0.x.49]*
     If true, use graph coloring. Otherwise, use atomic operations. Graph     coloring ensures bitwise reproducibility but is slower on Pascal and     newer architectures.    
* [0.x.50]*
      Overlap MPI communications with computation. This requires CUDA-aware      MPI and use_coloring must be false.    
* [0.x.51]*
     Total number of degrees of freedom.    
* [0.x.52]*
     Degree of the finite element used.    
* [0.x.53]*
     Number of degrees of freedom per cell.    
* [0.x.54]*
     Number of constrained degrees of freedom.    
* [0.x.55]*
     Number of quadrature points per cells.    
* [0.x.56]*
     Number of colors produced by the graph coloring algorithm.    
* [0.x.57]*
     Number of cells in each color.    
* [0.x.58]*
     Vector of pointers to the quadrature points associated to the cells of     each color.    
* [0.x.59]*
     Map the position in the local vector to the position in the global     vector.    
* [0.x.60]*
     Vector of pointer to the inverse Jacobian associated to the cells of each     color.    
* [0.x.61]*
     Vector of pointer to the Jacobian times the weights associated to the     cells of each color.    
* [0.x.62]*
     Pointer to the constrained degrees of freedom.    
* [0.x.63]*
     Mask deciding where constraints are set on a given cell.    
* [0.x.64]*
     Grid dimensions associated to the different colors. The grid dimensions     are used to launch the CUDA kernels.    
* [0.x.65]*
     Block dimensions associated to the different colors. The block dimensions     are used to launch the CUDA kernels.    
* [0.x.66]*
     Shared pointer to a Partitioner for distributed Vectors used in     cell_loop. When MPI is not used the pointer is null.    
* [0.x.67]*
     Cells per block (determined by the function cells_per_block_shmem() ).    
* [0.x.68]*
     Grid dimensions used to launch the CUDA kernels     in_constrained_values-operations.    
* [0.x.69]*
     Block dimensions used to launch the CUDA kernels     in_constrained_values-operations.    
* [0.x.70]*
     Length of the padding (closest power of two larger than or equal to     the number of thread).    
* [0.x.71]*
     Row start of each color.    
* [0.x.72]*
     Pointer to the DoFHandler associated with the object.    
* [0.x.73]*
     Colored graphed of locally owned active cells.    
* [0.x.74]*
   Structure to pass the shared memory into a general user function.  
* [0.x.75]*
     Constructor.    
* [0.x.76]*
     Shared memory for dof and quad values.    
* [0.x.77]*
     Shared memory for computed gradients in reference coordinate system.     The gradient in each direction is saved in a struct-of-array     format, i.e. first, all gradients in the x-direction come...    
* [0.x.78]*
   Compute the quadrature point index in the local cell of a given thread.      [2.x.28]   [2.x.29]   
* [0.x.79]*
   Return the quadrature point index local of a given thread. The index is   only unique for a given MPI process.      [2.x.30]   [2.x.31]   
* [0.x.80]*
   Return the quadrature point associated with a given thread.      [2.x.32]   [2.x.33]   
* [0.x.81]*
   Structure which is passed to the kernel. It is used to pass all the   necessary information from the CPU to the GPU.  
* [0.x.82]*
     Vector of quadrature points.    
* [0.x.83]*
     Map the position in the local vector to the position in the global     vector.    
* [0.x.84]*
     Vector of inverse Jacobians.    
* [0.x.85]*
     Vector of Jacobian times the weights.    
* [0.x.86]*
     ID of the associated MatrixFree object.    
* [0.x.87]*
     Number of cells.    
* [0.x.88]*
     Length of the padding.    
* [0.x.89]*
     Row start (including padding).    
* [0.x.90]*
     Mask deciding where constraints are set on a given cell.    
* [0.x.91]*
     If true, use graph coloring has been used and we can simply add into     the destingation vector. Otherwise, use atomic operations.    
* [0.x.92]*
   Copy  [2.x.34]  from the device to the device.  [2.x.35]  should be   identical to the one used in  [2.x.36]       [2.x.37]   [2.x.38]   
* [0.x.93]*
   This function is the host version of local_q_point_id().      [2.x.39]   [2.x.40]   
* [0.x.94]*
   This function is the host version of get_quadrature_point(). It assumes   that the data in MatrixFree<dim,  [2.x.41]  has been copied to the host   using copy_mf_data_to_host().      [2.x.42]   [2.x.43]   
* [0.x.95]

include/deal.II-translator/matrix_free/cuda_tensor_product_kernels_0.txt
[0.x.0]*
     In this namespace, the evaluator routines that evaluate the tensor     products are implemented.        
*  [2.x.0]     
* [0.x.1]*
     Generic evaluator framework.        
*  [2.x.1]     
* [0.x.2]*
     Internal evaluator for 1d-3d shape function using the tensor product form     of the basis functions.        
*  [2.x.2]     
* [0.x.3]*
       Evaluate the values of a finite element function at the quadrature       points.      
* [0.x.4]*
       Evaluate the gradient of a finite element function at the quadrature       points for a given  [2.x.3]       
* [0.x.5]*
       Helper function for values() and gradients().      
* [0.x.6]*
       Evaluate the finite element function at the quadrature points.      
* [0.x.7]*
       Helper function for integrate(). Integrate the finite element function.      
* [0.x.8]*
       Evaluate the gradients of the finite element function at the quadrature       points.      
* [0.x.9]*
       Evaluate the values and the gradients of the finite element function at        the quadrature points.      
* [0.x.10]*
       Helper function for integrate(). Integrate the gradients of the finite       element function.      
* [0.x.11]*
       Helper function for integrate(). Integrate the values and the gradients       of the finite element function.      
* [0.x.12]

include/deal.II-translator/matrix_free/dof_info.templates_0.txt
[0.x.0]

include/deal.II-translator/matrix_free/dof_info_0.txt
[0.x.0]*
     A struct that takes entries describing a constraint and puts them into     a sorted list where duplicates are filtered out    
* [0.x.1]*
       This function inserts some constrained entries to the collection of       all values. It stores the (reordered) numbering of the dofs       (according to the ordering that matches with the function) in       new_indices, and returns the storage position the double array for       access later on.      
* [0.x.2]*
     The class that stores the indices of the degrees of freedom for all the     cells. Essentially, this is a smart number cache in the style of a     DoFHandler that also embeds the description of constraints directly on     the cell level without the need to refer to the external     AffineConstraints object.         This class only stores index relations. The weights for hanging node     constraints are stored in a different field. This is because a     different field allows for the same compressed weight data on different     DoFHandlers for vector-valued problems. There, the indices might be     constrained differently on different components (e.g. Dirichlet     conditions only on selected components), whereas the weights from     hanging nodes are the same and need to be stored only once. The     combination will be handled in the MatrixFree class.        
*  [2.x.0]     
* [0.x.3]*
       This value is used to define subranges in the vectors which we can       zero inside the  [2.x.1]  call. The goal is to only clear a       part of the vector at a time to keep the values that are zeroed in       caches, saving one global vector access for the case where this is       applied rather than `vector = 0.;`.             We set the granularity to 64
* 
*  - that is a number sufficiently large       to minimize loop peel overhead within the work (and compatible with       vectorization lengths of up to 16) and small enough to not waste on       the size of the individual chunks.      
* [0.x.4]*
       Default empty constructor.      
* [0.x.5]*
       Copy constructor.      
* [0.x.6]*
       Move constructor.      
* [0.x.7]*
       Destructor.      
* [0.x.8]*
       Copy assignment operator.      
* [0.x.9]*
       Move assignment operator.      
* [0.x.10]*
       Clear all data fields in this class.      
* [0.x.11]*
       Return the FE index for a given finite element degree. If not in hp-       mode, this function always returns index 0. If an index is not found       in hp-mode, it returns  [2.x.2]       
* [0.x.12]*
       Populate the vector  [2.x.3]  with locally owned degrees of freedom       stored on the cell block  [2.x.4]        If  [2.x.5]  is `true`, then the returned vector will contain indices       required to resolve constraints.             The image below illustrates the output of this function for cell blocks       zero and one with zero Dirichlet boundary conditions at the bottom of       the domain. Note that due to the presence of constraints, the DoFs       returned by this function for the case `with_constraints = true` are       not a simple union       of per cell DoFs on the cell block  [2.x.6]               [2.x.7]             
*  [2.x.8]  The returned indices may contain duplicates. The unique set can be       obtain using  [2.x.9]  followed by  [2.x.10]  and        [2.x.11]       
* [0.x.13]*
       This internal method takes the local indices on a cell and fills them       into this class. It resolves the constraints and distributes the       results. Ghost indices, i.e., indices that are located on another       processor, get a temporary number by this function, and will later be       assigned the correct index after all the ghost indices have been       collected by the call to  [2.x.12]       
* [0.x.14]*
       This method assigns the correct indices to ghost indices from the       temporary numbering employed by the  [2.x.13]  function. The       numbers are localized with respect to the MPI process, and ghosts       start at the end of the locally owned range. This way, we get direct       access to all vector entries.      
* [0.x.15]*
       This method reorders the way cells are gone through based on a given       renumbering of the cells. It also takes  [2.x.14]  cells       together and interprets them as one cell only, as is needed for       vectorization.      
* [0.x.16]*
       Finds possible compression for the cell indices that we can apply for       increased efficiency. Run at the end of reorder_cells.      
* [0.x.17]*
       Finds possible compression for the face indices that we can apply for       increased efficiency. Run at the end of reorder_cells.      
* [0.x.18]*
       This function computes the connectivity of the currently stored       indices in terms of connections between the individual cells and       fills the structure into a sparsity pattern.      
* [0.x.19]*
       In case face integrals are enabled, find out whether certain loops       over the unknowns only access a subset of all the ghost dofs we keep       in the main partitioner.      
* [0.x.20]*
       Given  [2.x.15]  containing the local index of       cells of macro faces (inner/outer) and macro faces compute       dof_indices_contiguous_sm.      
* [0.x.21]*
       Compute a renumbering of the degrees of freedom to improve the data       access patterns for this class that can be utilized by the categories       in the IndexStorageVariants enum. For example, the index ordering can       be improved for typical DG elements by interleaving the degrees of       freedom from batches of cells, which avoids the explicit data       transposition in  [2.x.16]  Currently, these       more advanced features are not implemented, so there is only limited       value of this function.      
* [0.x.22]*
       Fills the array that defines how to zero selected ranges in the result       vector within the cell loop, filling the two member variables  [2.x.17]        vector_zero_range_list_index and  [2.x.18]              The intent of this pattern is to zero the vector entries in close       temporal proximity to the first access and thus keeping the vector       entries in cache.      
* [0.x.23]*
       Return the memory consumption in bytes of this class.      
* [0.x.24]*
       Prints a detailed summary of memory consumption in the different       structures of this class to the given output stream.      
* [0.x.25]*
       Prints a representation of the indices in the class to the given       output stream.      
* [0.x.26]*
       Enum for various storage variants of the indices. This storage format       is used to implement more efficient indexing schemes in case the       underlying data structures allow for them, and to inform the access       functions in  [2.x.19]  on which array       to get the data from. One example of more efficient storage is the       enum value  [2.x.20]  which means that one can       get the indices to all degrees of freedom of a cell by reading only       the first index for each cell, whereas all subsequent indices are       merely an offset from the first index.      
* [0.x.27]*
         This value indicates that no index compression was found and the         only valid storage is to access all indices present on the cell,         possibly including constraints. For a cell/face of this index type,         the data access in FEEvaluationBase is directed to the array  [2.x.21]          dof_indices with the index         `row_starts[cell_index*n_vectorization*n_components].first`.        
* [0.x.28]*
         This value indicates that the indices are interleaved for access         with vectorized gather and scatter operation. This storage variant         is possible in case there are no constraints on the cell and the         indices in the batch of cells are not pointing to the same global         index in different slots of a vectorized array (in order to support         scatter operations). For a cell/face of this index type, the data         access in FEEvaluationBase is directed to the array         `dof_indices_interleaved` with the index         `row_starts[cell_index*n_vectorization*n_components].first`.        
* [0.x.29]*
         This value indicates that the indices within a cell are all         contiguous, and one can get the index to the cell by reading that         single value for each of the cells in the cell batch. For a         cell/face of this index type, the data access in FEEvaluationBase         is directed to the array `dof_indices_contiguous` with the index         `cell_index*n_vectorization*n_components`.        
* [0.x.30]*
         This value indicates that the indices with a cell are contiguous and         interleaved for vectorization, i.e., the first DoF index on a cell         to the four or eight cells in the vectorization batch come first,         than the second DoF index, and so on. Furthermore, the interleaving         between cells implies that only the batches for vectorization can be         accessed efficiently, whereas there is a strided access for getting         only some of the entries.                 The two additional categories `interleaved_contiguous_strided` and         `interleaved_contiguous_mixed_strides` are a consequence of this         storage type. The former is for faces where at least one of the two         adjacent sides will break with the interleaved storage. We then have         to make a strided access as described in the next category. The last         category `interleaved_contiguous_mixed_strides` appears in the ghost         layer, see the more detailed description of that category below.         Again, this is something that cannot be avoided in general once we         interleave the indices between cells.                 For a cell/face of this index type, the data access in         FEEvaluationBase is directed to the array `dof_indices_contiguous`         with the index `cell_index*n_vectorization*n_components`.        
* [0.x.31]*
         Similar to interleaved_contiguous storage, but for the case when the         interleaved indices are only contiguous within the degrees of         freedom, but not also over the components of a vectorized array.         This happens typically on faces with DG where the cells have         `interleaved_contiguous` storage but the faces' numbering is not the         same as the cell's numbering. For a         cell/face of this index type, the data access in FEEvaluationBase         is directed to the array `dof_indices_contiguous` with the index         `cell_index*n_vectorization*n_components`.        
* [0.x.32]*
         Similar to interleaved_contiguous_separate storage, but for the case         when the interleaved indices are not `n_vectorization apart`. This         happens typically within the ghost layer of DG where the remote         owner has applied an interleaved storage and the current processor         only sees some of the cells. For a         cell/face of this index type, the data access in FEEvaluationBase         is directed to the array `dof_indices_contiguous` with the index         `cell_index*n_vectorization*n_components`, including the array         `dof_indices_interleave_strides` for the information about the         actual stride.        
* [0.x.33]*
       Enum used to distinguish the data arrays for the vectorization type       in cells and faces.      
* [0.x.34]*
         The data index for the faces designated as interior        
* [0.x.35]*
         The data index for the faces designated as exterior        
* [0.x.36]*
         The data index for the cells        
* [0.x.37]*
       Stores the dimension of the underlying DoFHandler. Since the indices       are not templated, this is the variable that makes the dimension       accessible in the (rare) cases it is needed inside this class.      
* [0.x.38]*
       For efficiency reasons, always keep a fixed number of cells with       similar properties together. This variable controls the number of       cells batched together. As opposed to the other classes which are       templated on the number type, this class as a pure index container is       not templated, so we need to keep the information otherwise contained       in  [2.x.22]       
* [0.x.39]*
       Stores the index storage variant of all cell and face batches.             The three arrays given here address the types for the faces decorated       as interior (0), the faces decorated with as exterior (1), and the       cells (2) according to CellOrFaceAccess.      
* [0.x.40]*
       Stores the rowstart indices of the compressed row storage in the  [2.x.23]        dof_indices and  [2.x.24]  fields. These two fields are       always accessed together, so it is simpler to keep just one variable       for them. This also obviates keeping two rowstart vectors in sync.      
* [0.x.41]*
       Stores the indices of the degrees of freedom for each cell. These       indices are computed in MPI-local index space, i.e., each processor       stores the locally owned indices as numbers between <tt>0</tt> and       <tt>n_locally_owned_dofs-1</tt> and ghost indices in the range       <tt>n_locally_owned_dofs</tt> to       <tt>n_locally_owned_dofs+n_ghost_dofs</tt>. The translation between       this MPI-local index space and the global numbering of degrees of       freedom is stored in the  [2.x.25]  data structure.  This       array also includes the indirect contributions from constraints,       which are described by the  [2.x.26]  field. Because of       variable lengths of rows, this would be a vector of a vector.       However, we use one contiguous memory region and store the rowstart       in the variable  [2.x.27]       
* [0.x.42]*
       This variable describes the position of constraints in terms of the       local numbering of degrees of freedom on a cell. The first number       stores the distance from one constrained degree of freedom to the       next. This allows to identify the position of constrained DoFs as we       loop through the local degrees of freedom of the cell when reading       from or writing to a vector. The second number stores the index of       the constraint weights, stored in the variable constraint_pool_data.      
* [0.x.43]*
       Reordered index storage for  [2.x.28]       
* [0.x.44]*
       Compressed index storage for faster access than through  [2.x.29]        dof_indices used according to the description in IndexStorageVariants.             The three arrays given here address the types for the faces decorated       as interior (0), the faces decorated with as exterior (1), and the       cells (2) according to CellOrFaceAccess.      
* [0.x.45]*
       The same as above but for shared-memory usage. The first value of the       pair is identifying the owning process and the second the index       within that locally-owned data of that process.            
*  [2.x.30]  This data structure is only set up if all entries in         index_storage_variants[2] are  [2.x.31]       
* [0.x.46]*
       Compressed index storage for faster access than through  [2.x.32]        dof_indices used according to the description in IndexStorageVariants.             The three arrays given here address the types for the faces decorated       as minus (0), the faces decorated with as plus (1), and the cells       (2).      
* [0.x.47]*
       Caches the number of indices filled when vectorizing. This       information can implicitly deduced from the row_starts data fields,       but this field allows for faster access.             The three arrays given here address the types for the faces decorated       as interior (0), the faces decorated with as exterior (1), and the       cells (2) according to CellOrFaceAccess.      
* [0.x.48]*
       This stores the parallel partitioning that can be used to set up       vectors. The partitioner includes the description of the local range       in the vector, and also includes how the ghosts look like. This       enables initialization of vectors based on the DoFInfo field.      
* [0.x.49]*
       Vector exchanger compatible with vector_partitioner.      
* [0.x.50]*
       Vector exchanger compatible with partitioners that select a subset of       ghost indices to the full       vector partitioner stored in  [2.x.33]  These       partitioners are used in specialized loops that only import parts of       the ghosted region for reducing the amount of communication. There       are five variants of the partitioner initialized:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - one that queries only the cell values,
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - one that additionally describes the indices for         evaluating the function values on relevant faces,
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - one that describes the indices for evaluation both the function         values and the gradients on relevant faces adjacent to the locally         owned cells,
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - one that additionally describes the indices for         evaluating the function values on all faces, and
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - one that describes the indices for evaluation both the function         values and the gradients on all faces adjacent to the locally owned         cells.      
* [0.x.51]*
       This stores a (sorted) list of all locally owned degrees of freedom       that are constrained.      
* [0.x.52]*
       Stores the rowstart indices of the compressed row storage in the  [2.x.34]        plain_dof_indices fields.      
* [0.x.53]*
       Stores the indices of the degrees of freedom for each cell. This       array does not include the indirect contributions from constraints,       which are included in  [2.x.35]  Because of variable lengths of       rows, this would be a vector of a vector. However, we use one       contiguous memory region and store the rowstart in the variable  [2.x.36]        row_starts_plain_indices.      
* [0.x.54]*
       Stores the offset in terms of the number of base elements over all       DoFInfo objects.      
* [0.x.55]*
       Stores the number of base elements in the DoFHandler where the       indices have been read from.      
* [0.x.56]*
       Stores the number of components of each base element in the finite       element where the indices have been read from.      
* [0.x.57]*
       The ith entry of this vector stores the component number of the given       base element.      
* [0.x.58]*
       For a given component in an FESystem, this variable tells which base       element the index belongs to.      
* [0.x.59]*
       For a vector-valued element, this gives the constant offset in the       number of degrees of freedom starting at the given component, as the       degrees are numbered by degrees of freedom. This data structure does       not take possible constraints and thus, shorter or longer lists, into       account. This information is encoded in the row_starts variables       directly.             The outer vector goes through the various FE indices in the hp-case,       similarly to the  [2.x.37]  variable.      
* [0.x.60]*
       Stores the number of degrees of freedom per cell.      
* [0.x.61]*
       Stores the number of degrees of freedom per face.      
* [0.x.62]*
       Informs on whether plain indices are cached.      
* [0.x.63]*
       Stores the index of the active finite element in the hp-case.      
* [0.x.64]*
       Stores the maximum degree of different finite elements for the hp-       case.      
* [0.x.65]*
       To each of the slots in an hp-adaptive case, the inner vector stores       the corresponding element degree. This is used by the constructor of       FEEvaluationBase to identify the correct data slot in the hp-case.      
* [0.x.66]*
       Temporarily stores the numbers of ghosts during setup. Cleared when       calling  [2.x.38]  Then, all information is collected by the       partitioner.      
* [0.x.67]*
       Stores an integer to each partition in TaskInfo that indicates       whether to clear certain parts in the result vector if the user       requested it with the respective argument in the  [2.x.39]       
* [0.x.68]*
       Stores the actual ranges in the vector to be cleared.      
* [0.x.69]*
       Stores an integer to each partition in TaskInfo that indicates when       to schedule operations that will be done before any access to vector       entries.      
* [0.x.70]*
       Stores the actual ranges of the operation before any access to vector       entries.      
* [0.x.71]*
       Stores an integer to each partition in TaskInfo that indicates when       to schedule operations that will be done after all access to vector       entries.      
* [0.x.72]*
       Stores the actual ranges of the operation after all access to vector       entries.      
* [0.x.73]

include/deal.II-translator/matrix_free/evaluation_flags_0.txt
[0.x.0]*


* 
*  [2.x.0] 
*  This namespace contains the enum EvaluationFlags used in FEEvaluation to control evaluation and integration of values, gradients, etc..

* 
* [0.x.1]*
  
*  [2.x.1]      This enum contains a set of flags used by  [2.x.2]     [2.x.3]  and others to determine if values, gradients,   hessians, or a combination of them is being used.  
* [0.x.2]*
     Do not use or compute anything.    
* [0.x.3]*
     Use or evaluate values.    
* [0.x.4]*
     Use or evaluate gradients.    
* [0.x.5]*
     Use or evaluate hessians.    
* [0.x.6]*
   Global operator which returns an object in which all bits are set which are   either set in the first or the second argument. This operator exists since   if it did not then the result of the bit-or <tt>operator |</tt> would be an   integer which would in turn trigger a compiler warning when we tried to   assign it to an object of type UpdateFlags.      [2.x.4]   
* [0.x.7]*
   Global operator which sets the bits from the second argument also in the   first one.      [2.x.5]   
* [0.x.8]*
   Global operator which returns an object in which all bits are set which are   set in the first as well as the second argument. This operator exists since   if it did not then the result of the bit-and <tt>operator &</tt> would be   an integer which would in turn trigger a compiler warning when we tried to   assign it to an object of type UpdateFlags.      [2.x.6]   
* [0.x.9]*
   Global operator which clears all the bits in the first argument if they are   not also set in the second argument.      [2.x.7]   
* [0.x.10]

include/deal.II-translator/matrix_free/evaluation_kernels_0.txt
[0.x.0]*
   This struct performs the evaluation of function values, gradients and   Hessians for tensor-product finite elements. The operation is used for   both the symmetric and non-symmetric case, which use different apply   functions 'values', 'gradients' in the individual coordinate   directions. The apply functions for values are provided through one of   the template classes EvaluatorTensorProduct which in turn are selected   from the  [2.x.0]  template argument.     There are two specialized implementation classes   FEEvaluationImplCollocation (for Gauss-Lobatto elements where the nodal   points and the quadrature points coincide and the 'values' operation is   identity) and FEEvaluationImplTransformToCollocation (which can be   transformed to a collocation space and can then use the identity in these   spaces), which both allow for shorter code.  
* [0.x.1]*
   Specialization for  [2.x.1]  which cannot use the   sum-factorization kernels.  
* [0.x.2]*
   This struct implements the change between two different bases. This is an   ingredient in the FEEvaluationImplTransformToCollocation class where we   first transform to the appropriate basis where we can compute the   derivative through collocation techniques.     This class allows for dimension-independent application of the operation,   implemented by template recursion. It has been tested up to 6D.  
* [0.x.3]*
     This applies the transformation that contracts over the rows of the     coefficient array, generating values along the columns of the     coefficient array.          [2.x.2]  n_components The number of vector components.      [2.x.3]  transformation_matrix The coefficient matrix handed in as a                         vector, using  [2.x.4]  rows and  [2.x.5]                          columns if interpreted as a matrix.      [2.x.6]  values_in    The array of the input of size basis_size_1^dim. It                         may alias with values_out      [2.x.7]  values_out   The array of size basis_size_2^dim where the results                         of the transformation are stored. It may alias with                         the values_in array.      [2.x.8]  basis_size_1_variable In case the template argument basis_size_1     is zero, the size of the first basis can alternatively be passed in as a     run time argument. The template argument takes precedence in case it is     nonzero for efficiency reasons.      [2.x.9]  basis_size_2_variable In case the template argument basis_size_1     is zero, the size of the second basis can alternatively be passed in as a     run time argument.    
* [0.x.4]*
     This applies the transformation that contracts over the columns of the     coefficient array, generating values along the rows of the coefficient     array.          [2.x.10]  n_components The number of vector components.      [2.x.11]  transformation_matrix The coefficient matrix handed in as a                         vector, using  [2.x.12]  rows and  [2.x.13]                          columns if interpreted as a matrix.      [2.x.14]  add_into_result Define whether the result should be added into the                         array  [2.x.15]  (if true) or overwrite the                         previous content. The result is undefined in case                         values_in and values_out point to the same array and                          [2.x.16]  is true, in which case an                         exception is thrown.      [2.x.17]  values_in    The array of the input of size basis_size_2^dim. It                         may alias with values_out. Note that the previous                         content of  [2.x.18]  is overwritten within the                         function.      [2.x.19]  values_out   The array of size basis_size_1^dim where the results                         of the transformation are stored. It may alias with                         the  [2.x.20]  array.      [2.x.21]  basis_size_1_variable In case the template argument basis_size_1     is zero, the size of the first basis can alternatively be passed in as a     run time argument. The template argument takes precedence in case it is     nonzero for efficiency reasons.      [2.x.22]  basis_size_2_variable In case the template argument basis_size_1     is zero, the size of the second basis can alternatively be passed in as a     run time argument.    
* [0.x.5]*
     This operation applies a mass-matrix-like operation, consisting of a     do_forward() operation, multiplication by the coefficients in the     quadrature points, and the do_backward() operation.          [2.x.23]  n_components The number of vector components.      [2.x.24]  transformation_matrix The coefficient matrix handed in as a                         vector, using  [2.x.25]  rows and  [2.x.26]                          columns if interpreted as a matrix.      [2.x.27]  coefficients The array of coefficients by which the result is                         multiplied. Its length must be either                         basis_size_2^dim or n_components*basis_size_2^dim.      [2.x.28]  values_in    The array of the input of size basis_size_2^dim. It                         may alias with values_out.      [2.x.29]  scratch_data Array to hold temporary data during the operation.                         Must be of length basis_size_2^dim.      [2.x.30]  values_out   The array of size basis_size_1^dim where the results                         of the transformation are stored. It may alias with                         the values_in array.    
* [0.x.6]*
   This struct performs the evaluation of function values, gradients and   Hessians for tensor-product finite elements. This a specialization for   elements where the nodal points coincide with the quadrature points like   FE_Q shape functions on Gauss-Lobatto elements integrated with   Gauss-Lobatto quadrature. The assumption of this class is that the shape   'values' operation is identity, which allows us to write shorter code.     In literature, this form of evaluation is often called spectral   evaluation, spectral collocation or simply collocation, meaning the same   location for shape functions and evaluation space (quadrature points).  
* [0.x.7]*
   This struct performs the evaluation of function values, gradients and   Hessians for tensor-product finite elements. This a specialization for   symmetric basis functions about the mid point 0.5 of the unit interval   with the same number of quadrature points as degrees of freedom. In that   case, we can first transform the basis to one that has the nodal points   in the quadrature points (i.e., the collocation space) and then perform   the evaluation of the first and second derivatives in this transformed   space, using the identity operation for the shape values.  
* [0.x.8]*
   This class chooses an appropriate evaluation strategy based on the   template parameters and the shape_info variable which contains runtime   parameters for the strategy underlying  [2.x.31]  i.e.   this calls  [2.x.32]     [2.x.33]  or    [2.x.34]  with   appropriate template parameters. In case the template parameters   fe_degree and n_q_points_1d contain valid information (i.e. fe_degree>-1   and n_q_points_1d>0), we simply pass these values to the respective   template specializations.  Otherwise, we perform a runtime matching of   the runtime parameters to find the correct specialization. This matching   currently supports  [2.x.35]  and  [2.x.36] .  
* [0.x.9]*
   This class chooses an appropriate evaluation strategy based on the   template parameters and the shape_info variable which contains runtime   parameters for the strategy underlying  [2.x.37]  i.e.   this calls  [2.x.38]     [2.x.39]  or    [2.x.40]  with   appropriate template parameters. In case the template parameters   fe_degree and n_q_points_1d contain valid information (i.e. fe_degree>-1   and n_q_points_1d>0), we simply pass these values to the respective   template specializations.  Otherwise, we perform a runtime matching of   the runtime parameters to find the correct specialization. This matching   currently supports  [2.x.41]  and  [2.x.42] .  
* [0.x.10]*
     Interpolate the values on the cell quadrature points onto a face.    
* [0.x.11]*
   This struct implements the action of the inverse mass matrix operation   using an FEEvaluationBaseData argument.  
* [0.x.12]*
   This struct implements the action of the inverse mass matrix operation   using an FEEvaluationBaseData argument.  
* [0.x.13]*
     Version for degree =
* 
*  -     
* [0.x.14]*
   This struct implements the action of the inverse mass matrix operation   using an FEEvaluationBaseData argument.  
* [0.x.15]

include/deal.II-translator/matrix_free/evaluation_selector_0.txt
[0.x.0]*
 This class chooses an appropriate evaluation strategy based on the template parameters and the shape_info variable, providing a short-cut to some internal functions.

* 
* [0.x.1]*
   Chooses an appropriate evaluation strategy for the evaluate function, i.e.   this calls  [2.x.0]     [2.x.1]  or    [2.x.2]  with   appropriate template parameters.  
* [0.x.2]*
   Chooses an appropriate evaluation strategy for the integrate function, i.e.   this calls  [2.x.3]     [2.x.4]  or    [2.x.5]  with   appropriate template parameters.  
* [0.x.3]

include/deal.II-translator/matrix_free/evaluation_template_factory.templates_0.txt
[0.x.0]

include/deal.II-translator/matrix_free/evaluation_template_factory_0.txt
[0.x.0]

include/deal.II-translator/matrix_free/face_info_0.txt
[0.x.0]*
     Data type for information about the batches build for vectorization of     the face integrals. The setup of the batches for the faces is     independent of the cells, and thus, we must store the relation to the     cell indexing for accessing the degrees of freedom.         Interior faces are stored by the two adjacent cells, which we label as     "interior" and "exterior" side of the face. Normal vectors stored in     MappingInfo are only stored once and are the outer normals to the cells     on the "interior" side, whereas the sign is the opposite for the     "exterior" side.         This data field is stored as a vector for all faces involved in the     computation. In order to avoid gaps in the memory representation, the     four 'char' variables are put next to each other which occupies the     same size as the unsigned integers on most architectures.    
* [0.x.1]*
       Indices of the faces in the current face batch as compared to the       numbers of the cells on the logical "interior" side of the face which       is aligned to the direction of  [2.x.0]       
* [0.x.2]*
       Indices of the faces in the current face batch as compared to the       numbers of the cells on the logical "exterior" side of the face which       is aligned to the opposite direction of        [2.x.1]  Note that the distinction into       interior and exterior faces is purely logical and refers to the       direction of the normal only. In the actual discretization of a       problem, the discretization typically needs to make sure that interior       and exterior sides are treated properly, such as with upwind fluxes.             For boundary faces, the numbers are set to        [2.x.2]       
* [0.x.3]*
       Index of the face between 0 and  [2.x.3]  within       the cells on the "exterior" side of the faces.             For a boundary face, this data field stores the boundary id.      
* [0.x.4]*
       Index of the face between 0 and  [2.x.4]  within       the cells on the "interior" side of the faces.      
* [0.x.5]*
       For adaptively refined meshes, the cell on the exterior side of the       face might be less refined than the interior side. This index       indicates the possible subface index on the exterior side.      
* [0.x.6]*
       In 3D, one of the two cells adjacent to a face might use a different       orientation (also called as face orientation, face flip and face       rotation) than the standard orientation. This variable stores the       values of face orientation, face flip and face       rotation (for one of the interior or exterior side) for the present       batch of faces in the first free bits. The forth bit is one if the       internal cell has non-standard orientation.            
*  [2.x.5]  In contrast to other place in the library, the face-orientation         bit (first bit) is flipped.      
* [0.x.7]*
       Reference-cell type of the given face: 0 for line or quadrilateral,       1 for triangle.      
* [0.x.8]*
       Return the memory consumption of the present data structure.      
* [0.x.9]*
     A data structure that holds the connectivity between the faces and the     cells.    
* [0.x.10]*
       Clear all data fields to be in a state similar to after having       called the default constructor.      
* [0.x.11]*
       Return the memory consumption of the present data structure.      
* [0.x.12]*
       Vectorized storage of interior faces, linking to the two cells in the       vectorized cell storage.      
* [0.x.13]*
       This table translates a triple of the macro cell number, the index of a       face within a cell and the index within the cell batch of vectorization       into the index within the  [2.x.6]  array.      
* [0.x.14]*
       Stores the boundary ids of the faces in vectorized format using the       same indexing as the cell_and_face_to_plain_faces data structure      
* [0.x.15]

include/deal.II-translator/matrix_free/face_setup_internal_0.txt
[0.x.0]*
     A struct that is used to represent a collection of faces of a process     with one of its neighbor within the setup done in struct FaceInfo.    
* [0.x.1]*
     A struct that extracts the faces relevant to a given set of cells,     including the assignment of which of the two neighboring processors at     a subdomain boundary with MPI should do the integration (from both     sides). This data structure is used for the setup of the connectivity     between faces and cells and for identification of the dof indices to be     used for face integrals.    
* [0.x.2]*
       Perform the initial detection of faces before reading the indices on       the cells. This does not add the faces yet but only decides on       whether some of the faces should be considered for processing       locally.      
* [0.x.3]*
       Upon completion of the dof indices, this function extracts the       information relevant for FaceToCellTopology and categorizes the faces       into interior faces, boundary faces, and ghost faces (not processed       locally but adjacent to some of the cells present locally).      
* [0.x.4]*
       Fills the information about the cell, the face number, and numbers       within the plain array representation in MatrixFree into       FaceToCellTopology (without vectorization, which is something applied       later).      
* [0.x.5]*
       A type that categorizes faces in the first initialize() function such       that we can later get their correct value in generate_faces().      
* [0.x.6]*
     Actually form the batches for vectorized execution of face integrals.    
* [0.x.7]*
     This simple comparison for collect_faces_vectorization() identifies     faces of the same type, i.e., where all of the interior and exterior     face number, subface index and orientation are the same. This is used     to batch similar faces together for vectorization.    
* [0.x.8]*
     This comparator is used within collect_faces_vectorization() to create     a sorting of FaceToCellTopology objects based on their     identifiers. This is used to obtain a good data locality when     processing the face integrals.    
* [0.x.9]

include/deal.II-translator/matrix_free/fe_evaluation_0.txt
[0.x.0]*
 This base class of the FEEvaluation and FEFaceEvaluation classes handles mapping-related information independent of the degrees of freedom and finite element in use. This class provides access functionality for user code but is otherwise invisible without any public constructor. The usage is through the class FEEvaluation instead.
*  This class has four template arguments:
*   [2.x.0]  dim Dimension in which this class is to be used
*   [2.x.1]  Number Number format, usually  [2.x.2]  or  [2.x.3] 
*   [2.x.4]  is_face Whether the class is used for a cell integrator (with quadrature dimension the same as the space dimension) or for a face integrator (with quadrature dimension one less)
*   [2.x.5]  VectorizedArrayType Type of array to be woked on in a vectorized                             fashion, defaults to VectorizedArray<Number>
* 

* 
*  [2.x.6]  Currently only VectorizedArray<Number, width> is supported as       VectorizedArrayType.
* 

* 

* 
*  [2.x.7] 

* 
* [0.x.1]*
   Destructor.  
* [0.x.2]*
   Return the index offset within the geometry fields for the cell the  [2.x.8]    reinit() function has been called for. This index can be used to access   an index into a field that has the same compression behavior as the   Jacobian of the geometry, e.g., to store an effective coefficient tensors   that combines a coefficient with the geometry for lower memory transfer   as the available data fields.  
* [0.x.3]*
   Return the type of the cell the  [2.x.9]  function has been called for.   Valid values are  [2.x.10]  for Cartesian cells (which allows for   considerable data compression),  [2.x.11]  for cells with affine mappings,   and  [2.x.12]  for general cells without any compressed storage applied.  
* [0.x.4]*
   Return a reference to the ShapeInfo object currently in use.  
* [0.x.5]*
   Return a reference to the DoFInfo object currently in use.  
* [0.x.6]*
   Return the determinant of the Jacobian from the unit to the real cell   times the quadrature weight.  
* [0.x.7]*
   Return the inverse and transposed version  [2.x.13]  of the   Jacobian of the mapping between the unit to the real cell defined as    [2.x.14] . The  [2.x.15]  entry of the returned tensor   contains  [2.x.16] , i.e., columns refer to reference space   coordinates and rows to real cell coordinates. Thus, the returned tensor   represents a covariant transformation, which is used in the    [2.x.17]  function to transform the unit cell   gradients to gradients on the real cell by a multiplication  [2.x.18] .  
* [0.x.8]*
   Return the unit normal vector on a face. Note that both sides of a face   use the same orientation of the normal vector: For the faces enumerated   as `interior` in FaceToCellTopology and selected with the   `is_interior_face=true` flag of the constructor, this corresponds to the   outer normal vector, whereas for faces enumerated as `exterior` in   FaceToCellTopology and selected with the `is_interior_face=false` flag of   the constructor, the normal points into the element as a consequence of   the single normal vector.    
*  [2.x.19]  Only implemented in case `is_face == true`.  
* [0.x.9]*
   Provides a unified interface to access data in a vector of   VectorizedArray fields of length  [2.x.20]  +    [2.x.21]  for both cells (plain read) and faces   (indirect addressing).  
* [0.x.10]*
   Provides a unified interface to set data in a vector of   VectorizedArray fields of length  [2.x.22]  +    [2.x.23]  for both cells (plain read) and faces   (indirect addressing).  
* [0.x.11]*
   The same as above, just for  [2.x.24]  of length of VectorizedArrayType for   arbitrary data type.  
* [0.x.12]*
   The same as above, just for  [2.x.25]  of length of VectorizedArrayType for   arbitrary data type.  
* [0.x.13]*
   Return the id of the cells this FEEvaluation or FEFaceEvaluation is   associated with.  
* [0.x.14]*
   Return the id of the cells/faces this FEEvaluation/FEFaceEvaluation is   associated with.  
* [0.x.15]*
   Return the numbering of local degrees of freedom within the evaluation   routines of FEEvaluation in terms of the standard numbering on finite   elements.  
* [0.x.16]*
   Return an ArrayView to internal memory for temporary use. Note that some   of this memory is overwritten during evaluate() and integrate() calls so   do not assume it to be stable over those calls. The maximum size you can   write into is 3*dofs_per_cell+2*n_q_points.  
* [0.x.17]*
   Return the number of the quadrature formula of the present cell.  
* [0.x.18]*
   Return index of the current cell or face.  
* [0.x.19]*
   Return the active FE index for this class for efficient indexing in the hp-   case.  
* [0.x.20]*
   Return the active quadrature index for this class for efficient indexing in   the hp-case.  
* [0.x.21]*
   Return the underlying MatrixFree object.  
* [0.x.22]*
   Constructor. Made protected to prevent users from directly using this   class. Takes all data stored in MatrixFree. If applied to problems with   more than one quadrature formula selected during construction of   `matrix_free`, `quad_no` allows to select the appropriate formula.  
* [0.x.23]*
   Constructor that comes with reduced functionality and works similar as   FEValues.  
* [0.x.24]*
   Copy constructor. If FEEvaluationBase was constructed from a mapping, fe,   quadrature, and update flags, the underlying geometry evaluation based on   FEValues will be deep-copied in order to allow for using in parallel with   threads.  
* [0.x.25]*
   Copy assignment operator. If FEEvaluationBase was constructed from a   mapping, fe, quadrature, and update flags, the underlying geometry   evaluation based on FEValues will be deep-copied in order to allow for   using in parallel with threads.  
* [0.x.26]*
   This is the general array for all data fields.  
* [0.x.27]*
   This is the user-visible part of scratch_data_array, only showing the   last part of scratch_data_array. The first part is consumed by   values_dofs, values_quad, etc.  
* [0.x.28]*
   The number of the quadrature formula of the present cell.  
* [0.x.29]*
   A pointer to the underlying data.  
* [0.x.30]*
   A pointer to the underlying DoF indices and constraint description   for the component specified at construction. Also contained in   matrix_info, but it simplifies code if we store a reference to it.  
* [0.x.31]*
   A pointer to the underlying transformation data from unit to real cells   for the given quadrature formula specified at construction. Also   contained in matrix_info, but it simplifies code if we store a reference   to it.  
* [0.x.32]*
   The active FE index for this class for efficient indexing in the hp-case.  
* [0.x.33]*
   The active quadrature index for this class for efficient indexing in the   hp-case.  
* [0.x.34]*
   A pointer to the underlying quadrature formula specified at construction.   Also contained in matrix_info, but it simplifies code if we store a   reference to it.  
* [0.x.35]*
   The number of quadrature points in the current evaluation context.  
* [0.x.36]*
   A pointer to the unit cell shape data, i.e., values, gradients and   Hessians in 1D at the quadrature points that constitute the tensor   product. Also contained in matrix_info, but it simplifies code if we   store a reference to it.  
* [0.x.37]*
   A pointer to the Jacobian information of the present cell. Only set to a   useful value if on a non-Cartesian cell.  
* [0.x.38]*
   A pointer to the Jacobian determinant of the present cell. If on a   Cartesian cell or on a cell with constant Jacobian, this is just the   Jacobian determinant, otherwise the Jacobian determinant times the   quadrature weight.  
* [0.x.39]*
   A pointer to the normal vectors at faces.  
* [0.x.40]*
   A pointer to the normal vectors times the jacobian at faces.  
* [0.x.41]*
   A pointer to the quadrature weights of the underlying quadrature formula.  
* [0.x.42]*
   After a call to reinit(), stores the number of the cell we are currently   working with.  
* [0.x.43]*
   Flag holding information whether a face is an interior or exterior face   according to the defined direction of the normal.  Not used for cells.  
* [0.x.44]*
   Stores the index an FEFaceEvaluation object is currently pointing into   (interior face, exterior face, data associated with cell).  
* [0.x.45]*
   Stores the current number of a face within the given cell in case   `is_face==true`, using values between `0` and `2*dim`.  
* [0.x.46]*
   Stores the orientation of the given face with respect to the standard   orientation, 0 if in standard orientation.  
* [0.x.47]*
   Stores the subface index of the given face. Usually, this variable takes   the value  [2.x.26]  to indicate integration over the   full face, but in case the current physical face has a neighbor that is   more refined, it is a subface and must scale the entries in ShapeInfo   appropriately.  
* [0.x.48]*
   Stores the type of the cell we are currently working with after a call to   reinit(). Valid values are  [2.x.27]   [2.x.28]  and  [2.x.29]  which   have different implications on how the Jacobian transformations are   stored internally in MappingInfo.  
* [0.x.49]*
   Geometry data that can be generated FEValues on the fly with the   respective constructor.  
* [0.x.50]*
 This is the base class for the FEEvaluation classes.  This class needs usually not be called in user code and does not have any public constructor. The usage is through the class FEEvaluation instead. It implements a reinit method that is used to set pointers so that operations on quadrature points can be performed quickly, access functions to vectors for the  [2.x.30]   [2.x.31]  and  [2.x.32]  functions, as well as methods to access values and gradients of finite element functions. It also inherits the geometry access functions provided by the class FEEvaluationBaseData.
*  This class has five template arguments:
*   [2.x.33]  dim Dimension in which this class is to be used
*   [2.x.34]  n_components Number of vector components when solving a system of PDEs. If the same operation is applied to several components of a PDE (e.g. a vector Laplace equation), they can be applied simultaneously with one call (and often more efficiently)
*   [2.x.35]  Number Number format, usually  [2.x.36]  or  [2.x.37] 
*   [2.x.38]  is_face Whether the class is used for a cell integrator (with quadrature dimension the same as the space dimension) or for a face integrator (with quadrature dimension one less)
*   [2.x.39]  VectorizedArrayType Type of array to be woked on in a vectorized                             fashion, defaults to VectorizedArray<Number>
* 

* 
*  [2.x.40]  Currently only VectorizedArray<Number, width> is supported as       VectorizedArrayType.
* 

* 

* 
*  [2.x.41] 

* 
* [0.x.51]*
    [2.x.42]  1: Reading from and writing to vectors  
* [0.x.52]*
   For the vector  [2.x.43]  read out the values on the degrees of freedom of   the current cell, and store them internally. Similar functionality as the   function  [2.x.44]  when no constraints are   present, but it also includes constraints from hanging nodes, so one can   see it as a similar function to  [2.x.45]  as   well. Note that if vectorization is enabled, the DoF values for several   cells are set.     If some constraints on the vector are inhomogeneous, use the function   read_dof_values_plain instead and provide the vector with useful data   also in constrained positions by calling  [2.x.46]    When accessing vector entries during the solution of linear systems, the   temporary solution should always have homogeneous constraints and this   method is the correct one.     If the given vector template class is a block vector (determined through   the template function  [2.x.47]  which checks   for vectors derived from  [2.x.48]  or an    [2.x.49]  or  [2.x.50]  this function reads    [2.x.51]  blocks from the block vector starting at the index    [2.x.52]  For non-block vectors,  [2.x.53]  is ignored.    
*  [2.x.54]  If this class was constructed without a MatrixFree object and the   information is acquired on the fly through a    [2.x.55]  only one single cell is used by this   class and this function extracts the values of the underlying components   on the given cell. This call is slower than the ones done through a   MatrixFree object and lead to a structure that does not effectively use   vectorization in the evaluate routines based on these values (instead,    [2.x.56]  same copies are worked on).  
* [0.x.53]*
   For the vector  [2.x.57]  read out the values on the degrees of freedom of   the current cell, and store them internally. Similar functionality as the   function  [2.x.58]  As opposed to the   read_dof_values function, this function reads out the plain entries from   vectors, without taking stored constraints into account. This way of   access is appropriate when the constraints have been distributed on the   vector by a call to  [2.x.59]  previously. This   function is also necessary when inhomogeneous constraints are to be used,   as MatrixFree can only handle homogeneous constraints. Note that if   vectorization is enabled, the DoF values for several cells are set.     If the given vector template class is a block vector (determined through   the template function  [2.x.60]  which checks   for vectors derived from  [2.x.61]  or an    [2.x.62]  or  [2.x.63]  this function reads    [2.x.64]  blocks from the block vector starting at the index    [2.x.65]  For non-block vectors,  [2.x.66]  is ignored.    
*  [2.x.67]  If this class was constructed without a MatrixFree object and the   information is acquired on the fly through a    [2.x.68]  only one single cell is used by this   class and this function extracts the values of the underlying components   on the given cell. This call is slower than the ones done through a   MatrixFree object and lead to a structure that does not effectively use   vectorization in the evaluate routines based on these values (instead,    [2.x.69]  same copies are worked on).  
* [0.x.54]*
   Takes the values stored internally on dof values of the current cell and   sums them into the vector  [2.x.70]  The function also applies constraints   during the write operation. The functionality is hence similar to the   function  [2.x.71]  If vectorization   is enabled, the DoF values for several cells are used.     If the given vector template class is a block vector (determined through   the template function  [2.x.72]  which checks   for vectors derived from  [2.x.73]  or an    [2.x.74]  or  [2.x.75]  this function   writes to  [2.x.76]  blocks of the block vector starting at the   index  [2.x.77]  For non-block vectors,  [2.x.78]  is ignored.     The  [2.x.79]  can be used to suppress the write access for some of the   cells contained in the current cell vectorization batch, e.g. in case of   local time stepping, where some cells are excluded from a call. A value   of `true` in the bitset means that the respective lane index will be   processed, whereas a value of `false` skips this index. The default   setting is a bitset that contains all ones, which will write the   accumulated integrals to all cells in the batch.    
*  [2.x.80]  If this class was constructed without a MatrixFree object and the   information is acquired on the fly through a    [2.x.81]  only one single cell is used by this   class and this function extracts the values of the underlying components   on the given cell. This call is slower than the ones done through a   MatrixFree object and lead to a structure that does not effectively use   vectorization in the evaluate routines based on these values (instead,    [2.x.82]  same copies are worked on).  
* [0.x.55]*
   Takes the values stored internally on dof values of the current cell and   writes them into the vector  [2.x.83]  The function skips the degrees of   freedom which are constrained. As opposed to the   distribute_local_to_global method, the old values at the position given   by the current cell are overwritten. Thus, if a degree of freedom is   associated to more than one cell (as usual in continuous finite   elements), the values will be overwritten and only the value written last   is retained. Please note that in a parallel context this function might   also touch degrees of freedom owned by other MPI processes, so that a   subsequent update or accumulation of ghost values as done by    [2.x.84]  might invalidate the degrees of freedom set by this   function.     If the given vector template class is a block vector (determined through   the template function  [2.x.85]  which checks   for vectors derived from  [2.x.86]  or an    [2.x.87]  or  [2.x.88]  this function   writes to  [2.x.89]  blocks of the block vector starting at the   index  [2.x.90]  For non-block vectors,  [2.x.91]  is ignored.     The  [2.x.92]  can be used to suppress the write access for some   of the cells contained in the current cell vectorization batch, e.g. in   case of local time stepping, where some  cells are excluded from a call.   A value of `true` in the bitset means that the respective lane index will   be processed, whereas a value of `false` skips this index. The default   setting is a bitset that contains all ones, which will write the   accumulated integrals to all cells in the batch.    
*  [2.x.93]  If this class was constructed without a MatrixFree object and the   information is acquired on the fly through a    [2.x.94]  only one single cell is used by this   class and this function extracts the values of the underlying components   on the given cell. This call is slower than the ones done through a   MatrixFree object and lead to a structure that does not effectively use   vectorization in the evaluate routines based on these values (instead,    [2.x.95]  same copies are worked on).  
* [0.x.56]*
   Same as set_dof_values(), but without resolving constraints.  
* [0.x.57]*
    [2.x.96]  2: Access to data at quadrature points or the gather vector data  
* [0.x.58]*
   Return the value stored for the local degree of freedom with index  [2.x.97]    dof. If the object is vector-valued, a vector-valued return argument is   given. Thus, the argument  [2.x.98]  can at most run until  [2.x.99]    dofs_per_component rather than  [2.x.100]  since the different   components of a vector-valued FE are return together. Note that when   vectorization is enabled, values from several cells are grouped   together. If  [2.x.101]  was called last, the value corresponds to   the one set there. If  [2.x.102]  was called last, it instead   corresponds to the value of the integrated function with the test   function of the given index.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.59]*
   Write a value to the field containing the degrees of freedom with   component  [2.x.103]  Writes to the same field as is accessed through  [2.x.104]    get_dof_value. Therefore, the original data that was read from a vector   is overwritten as soon as a value is submitted.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.60]*
   Return the value of a finite element function at quadrature point number    [2.x.105]  after a call to  [2.x.106]  with    [2.x.107]  set, or the value that has been stored there with   a call to  [2.x.108]  If the object is   vector-valued, a vector-valued return argument is given. Note that when   vectorization is enabled, values from several cells are grouped together.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.61]*
   Write a value to the field containing the values on quadrature points   with component  [2.x.109]  Access to the same field as through   get_value(). If applied before the function  [2.x.110]    with  [2.x.111]  set is called, this specifies the value   which is tested by all basis function on the current cell and integrated   over.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.62]*
   Return the gradient of a finite element function at quadrature point   number  [2.x.112]  after a call to  [2.x.113]  with    [2.x.114]  or the value that has been stored there with   a call to  [2.x.115]      Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.63]*
   Return the derivative of a finite element function at quadrature point   number  [2.x.116]  after a call to    [2.x.117]  the direction normal   to the face:  [2.x.118]      This call is equivalent to calling get_gradient() get_normal_vector()   but will use a more efficient internal representation of data.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.64]*
   Write a contribution that is tested by the gradient to the field   containing the values on quadrature points with component  [2.x.119]    Access to the same field as through get_gradient(). If applied before the   function  [2.x.120]  is called,   this specifies what is tested by all basis function gradients on the   current cell and integrated over.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.65]*
   Write a contribution that is tested by the gradient to the field   containing the values on quadrature points with component  [2.x.121]    q_point. Access to the same field as through get_gradient() or   get_normal_derivative(). If applied before the function    [2.x.122]  is called, this   specifies what is tested by all basis function gradients on the current   cell and integrated over.    
*  [2.x.123]  This operation writes the data to the same field as   submit_gradient(). As a consequence, only one of these two can be   used. Usually, the contribution of a potential call to this function must   be added into the contribution for submit_gradient().    
*  [2.x.124]  The derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.66]*
   Return the Hessian of a finite element function at quadrature point   number  [2.x.125]  after a call to    [2.x.126]  If only the diagonal   or even the trace of the Hessian, the Laplacian, is needed, use the other   functions below.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.67]*
   Return the diagonal of the Hessian of a finite element function at   quadrature point number  [2.x.127]  after a call to    [2.x.128]      Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.68]*
   Return the Laplacian (i.e., the trace of the Hessian) of a finite element   function at quadrature point number  [2.x.129]  after a call to    [2.x.130]  Compared to the case   when computing the full Hessian, some operations can be saved when only   the Laplacian is requested.     Note that the derived class FEEvaluationAccess overloads this operation   with specializations for the scalar case (n_components == 1) and for the   vector-valued case (n_components == dim).  
* [0.x.69]*
   Return the divergence of a vector-valued finite element at quadrature   point number  [2.x.131]  after a call to  [2.x.132]     
*  [2.x.133]  Only available for n_components_==dim.  
* [0.x.70]*
   Return the symmetric gradient of a vector-valued finite element at   quadrature point number  [2.x.134]  after a call to  [2.x.135]    evaluate(...,true,...). It corresponds to <tt>0.5   (grad+grad<sup>T</sup>)</tt>.    
*  [2.x.136]  Only available for n_components_==dim.  
* [0.x.71]*
   Return the curl of the vector field,  [2.x.137]  after a call to  [2.x.138]    evaluate(...,true,...).    
*  [2.x.139]  Only available for n_components_==dim.  
* [0.x.72]*
   Write a contribution that is tested by the divergence to the field   containing the values on quadrature points with component  [2.x.140]    Access to the same field as through  [2.x.141]  If applied before   the function  [2.x.142]  is called, this specifies what is   tested by all basis function gradients on the current cell and integrated   over.    
*  [2.x.143]  Only available for n_components_==dim.    
*  [2.x.144]  This operation writes the data to the same field as   submit_gradient(). As a consequence, only one of these two can be   used. Usually, the contribution of a potential call to this function must   be added into the diagonal of the contribution for submit_gradient().  
* [0.x.73]*
   Write a contribution that is tested by the symmetric gradient to the field   containing the values on quadrature points with component  [2.x.145]    Access to the same field as through  [2.x.146]  If applied before   the function  [2.x.147]  is called, this specifies the   symmetric gradient which is tested by all basis function symmetric   gradients on the current cell and integrated over.    
*  [2.x.148]  Only available for n_components_==dim.    
*  [2.x.149]  This operation writes the data to the same field as   submit_gradient(). As a consequence, only one of these two can be   used. Usually, the contribution of a potential call to this function must   be added to the respective entries of the rank-2 tensor for   submit_gradient().  
* [0.x.74]*
   Write the components of a curl containing the values on quadrature point    [2.x.150]  Access to the same data field as through  [2.x.151]     
*  [2.x.152]  Only available for n_components_==dim.    
*  [2.x.153]  This operation writes the data to the same field as   submit_gradient(). As a consequence, only one of these two can be   used. Usually, the contribution of a potential call to this function must   be added to the respective entries of the rank-2 tensor for   submit_gradient().  
* [0.x.75]*
   Takes values at quadrature points, multiplies by the Jacobian determinant   and quadrature weights (JxW) and sums the values for all quadrature   points on the cell. The result is a scalar, representing the integral   over the function over the cell. If a vector-element is used, the   resulting components are still separated. Moreover, if vectorization is   enabled, the integral values of several cells are contained in the slots   of the returned VectorizedArray field.    
*  [2.x.154]  In case the FEEvaluation object is initialized with a batch of   cells where not all lanes in the SIMD vector VectorizedArray are   representing actual data, this method performs computations on dummy data   (that is copied from the last valid lane) that will not make sense. Thus,   the user needs to make sure that it is not used in any computation   explicitly, like when summing the results of several cells.  
* [0.x.76]*
    [2.x.155]  3: Access to internal data  
* [0.x.77]*
   Return a read-only pointer to the first field of the dof values. This is   the data field the read_dof_values() functions write into. First come the   dof values for the first component, then all values for the second   component, and so on. This is related to the internal data structures   used in this class. In general, it is safer to use the get_dof_value()   function instead.  
* [0.x.78]*
   Return a read and write pointer to the first field of the dof values.   This is the data field the read_dof_values() functions write into. First   come the dof values for the first component, then all values for the   second component, and so on. This is related to the internal data   structures used in this class. In general, it is safer to use the   get_dof_value() function instead.  
* [0.x.79]*
   Return a read-only pointer to the first field of function values on   quadrature points. First come the function values on all quadrature   points for the first component, then all values for the second component,   and so on. This is related to the internal data structures used in this   class. The raw data after a call to  [2.x.156]  only contains unit cell   operations, so possible transformations, quadrature weights etc. must be   applied manually. In general, it is safer to use the get_value() function   instead, which does all the transformation internally.  
* [0.x.80]*
   Return a read and write pointer to the first field of function values on   quadrature points. First come the function values on all quadrature   points for the first component, then all values for the second component,   and so on. This is related to the internal data structures used in this   class. The raw data after a call to  [2.x.157]  only contains unit cell   operations, so possible transformations, quadrature weights etc. must be   applied manually. In general, it is safer to use the get_value() function   instead, which does all the transformation internally.  
* [0.x.81]*
   Return a read-only pointer to the first field of function gradients on   quadrature points. First comes the x-component of the gradient for the   first component on all quadrature points, then the y-component, and so   on. Next comes the x-component of the second component, and so on. This   is related to the internal data structures used in this class. The raw   data after a call to  [2.x.158]  only contains unit cell operations, so   possible transformations, quadrature weights etc. must be applied   manually. In general, it is safer to use the get_gradient() function   instead, which does all the transformation internally.  
* [0.x.82]*
   Return a read and write pointer to the first field of function gradients   on quadrature points. First comes the x-component of the gradient for the   first component on all quadrature points, then the y-component, and so   on. Next comes the x-component of the second component, and so on. This   is related to the internal data structures used in this class. The raw   data after a call to  [2.x.159]  only contains unit cell operations, so   possible transformations, quadrature weights etc. must be applied   manually. In general, it is safer to use the get_gradient() function   instead, which does all the transformation internally.  
* [0.x.83]*
   Return a read-only pointer to the first field of function hessians on   quadrature points. First comes the xx-component of the hessian for the   first component on all quadrature points, then the yy-component, zz-   component in (3D), then the xy-component, and so on. Next comes the xx-   component of the second component, and so on. This is related to the   internal data structures used in this class. The raw data after a call to    [2.x.160]  only contains unit cell operations, so possible   transformations, quadrature weights etc. must be applied manually. In   general, it is safer to use the get_laplacian() or get_hessian()   functions instead, which does all the transformation internally.  
* [0.x.84]*
   Return a read and write pointer to the first field of function hessians   on quadrature points. First comes the xx-component of the hessian for the   first component on all quadrature points, then the yy-component, zz-   component in (3D), then the xy-component, and so on. Next comes the xx-   component of the second component, and so on. This is related to the   internal data structures used in this class. The raw data after a call to    [2.x.161]  only contains unit cell operations, so possible   transformations, quadrature weights etc. must be applied manually. In   general, it is safer to use the get_laplacian() or get_hessian()   functions instead, which does all the transformation internally.  
* [0.x.85]*
   Return the first selected component.  
* [0.x.86]*
   Constructor. Made protected to prevent users from directly using this   class. Takes all data stored in MatrixFree. If applied to problems with   more than one finite element or more than one quadrature formula selected   during construction of  [2.x.162]   [2.x.163]   [2.x.164]    first_selected_component and  [2.x.165]  allow to select the appropriate   components.  
* [0.x.87]*
   Constructor that comes with reduced functionality and works similar as   FEValues. The arguments are similar to the ones passed to the constructor   of FEValues, with the notable difference that FEEvaluation expects a one-   dimensional quadrature formula, Quadrature<1>, instead of a  [2.x.166]    dimensional one. The finite element can be both scalar or vector valued,   but this method always only selects a scalar base element at a time (with    [2.x.167]  copies as specified by the class template argument). For   vector-valued elements, the optional argument  [2.x.168]    allows to specify the index of the base element to be used for   evaluation. Note that the internal data structures always assume that the   base element is primitive, non-primitive are not supported currently.     As known from FEValues, a call to the reinit method with a    [2.x.169]  is necessary to make the geometry and   degrees of freedom of the current class known. If the iterator includes   DoFHandler information (i.e., it is a  [2.x.170]  or   similar), the initialization allows to also read from or write to vectors   in the standard way for  [2.x.171]  types for one   cell at a time. However, this approach is much slower than the path with   MatrixFree with MPI since index translation has to be done. As only one   cell at a time is used, this method does not vectorize over several   elements (which is most efficient for vector operations), but only   possibly within the element if the evaluate/integrate routines are   combined inside user code (e.g. for computing cell matrices).     The optional FEEvaluationBaseData object allows several   FEEvaluation objects to share the geometry evaluation, i.e., the   underlying mapping and quadrature points do only need to be evaluated   once. This only works if the quadrature formulas are the same. Otherwise,   a new evaluation object is created. Make sure to not pass an optional   object around when you intend to use the FEEvaluation object in %parallel   with another one because otherwise the intended sharing may create race   conditions.  
* [0.x.88]*
   Copy constructor. If FEEvaluationBase was constructed from a mapping, fe,   quadrature, and update flags, the underlying geometry evaluation based on   FEValues will be deep-copied in order to allow for using in parallel with   threads.  
* [0.x.89]*
   Copy assignment operator. If FEEvaluationBase was constructed from a   mapping, fe, quadrature, and update flags, the underlying geometry   evaluation based on FEValues will be deep-copied in order to allow for   using in parallel with threads.  
* [0.x.90]*
   A unified function to read from and write into vectors based on the given   template operation. It can perform the operation for  [2.x.172]     [2.x.173]  and  [2.x.174]  It performs the   operation for several vectors at a time.  
* [0.x.91]*
   A unified function to read from and write into vectors based on the given   template operation for DG-type schemes where all degrees of freedom on   cells are contiguous. It can perform the operation for read_dof_values(),   distribute_local_to_global(), and set_dof_values() for several vectors at   a time, depending on n_components.  
* [0.x.92]*
   A unified function to read from and write into vectors based on the given   template operation for the case when we do not have an underlying   MatrixFree object. It can perform the operation for  [2.x.175]     [2.x.176]  and  [2.x.177]  It performs the   operation for several vectors at a time, depending on n_components.  
* [0.x.93]*
   This field stores the values for local degrees of freedom (e.g. after   reading out from a vector but before applying unit cell transformations   or before distributing them into a result vector). The methods   get_dof_value() and submit_dof_value() read from or write to this field.     The values of this array are stored in the start section of    [2.x.178]  Due to its access as a thread local memory, the   memory can get reused between different calls. As opposed to requesting   memory on the stack, this approach allows for very large polynomial   degrees.  
* [0.x.94]*
   This field stores the values of the finite element function on quadrature   points after applying unit cell transformations or before integrating.   The methods get_value() and submit_value() access this field.     The values of this array are stored in the start section of    [2.x.179]  Due to its access as a thread local memory, the   memory can get reused between different calls. As opposed to requesting   memory on the stack, this approach allows for very large polynomial   degrees.  
* [0.x.95]*
   This field stores the gradients of the finite element function on   quadrature points after applying unit cell transformations or before   integrating. The methods get_gradient() and submit_gradient() (as well as   some specializations like get_symmetric_gradient() or get_divergence())   access this field.     The values of this array are stored in the start section of    [2.x.180]  Due to its access as a thread local memory, the   memory can get reused between different calls. As opposed to requesting   memory on the stack, this approach allows for very large polynomial   degrees.  
* [0.x.96]*
   This field stores the Hessians of the finite element function on   quadrature points after applying unit cell transformations. The methods   get_hessian(), get_laplacian(), get_hessian_diagonal() access this field.     The values of this array are stored in the start section of    [2.x.181]  Due to its access as a thread local memory, the   memory can get reused between different calls. As opposed to requesting   memory on the stack, this approach allows for very large polynomial   degrees.  
* [0.x.97]*
   Stores the number of components in the finite element as detected in the   MatrixFree storage class for comparison with the template argument.  
* [0.x.98]*
   Debug information to track whether dof values have been initialized   before accessed. Used to control exceptions when uninitialized data is   used.  
* [0.x.99]*
   Debug information to track whether values on quadrature points have been   initialized before accessed. Used to control exceptions when   uninitialized data is used.  
* [0.x.100]*
   Debug information to track whether gradients on quadrature points have   been initialized before accessed. Used to control exceptions when   uninitialized data is used.  
* [0.x.101]*
   Debug information to track whether Hessians on quadrature points have   been initialized before accessed. Used to control exceptions when   uninitialized data is used.  
* [0.x.102]*
   Debug information to track whether values on quadrature points have been   submitted for integration before the integration is actually stared. Used   to control exceptions when uninitialized data is used.  
* [0.x.103]*
   Debug information to track whether gradients on quadrature points have   been submitted for integration before the integration is actually stared.   Used to control exceptions when uninitialized data is used.  
* [0.x.104]*
   For a FiniteElement with more than one base element, select at which   component this data structure should start.  
* [0.x.105]*
   A temporary data structure necessary to read degrees of freedom when no   MatrixFree object was given at initialization.  
* [0.x.106]*
   Sets the pointers for values, gradients, hessians to the central   scratch_data_array of the base class.  
* [0.x.107]*
 This class provides access to the data fields of the FEEvaluation classes. Generic access is achieved through the base class, and specializations for scalar and vector-valued elements are defined separately.
* 

* 
*  [2.x.182] 

* 
* [0.x.108]*
   Constructor. Made protected to prevent initialization in user code. Takes   all data stored in MatrixFree. If applied to problems with more than one   finite element or more than one quadrature formula selected during   construction of  [2.x.183]   [2.x.184]  and  [2.x.185]    quad_no allow to select the appropriate components.  
* [0.x.109]*
   Constructor with reduced functionality for similar usage of FEEvaluation   as FEValues, including matrix assembly.  
* [0.x.110]*
   Copy constructor  
* [0.x.111]*
   Copy assignment operator  
* [0.x.112]*
 This class provides access to the data fields of the FEEvaluation classes. Partial specialization for scalar fields that defines access with simple data fields, i.e., scalars for the values and Tensor<1,dim> for the gradients.
* 

* 
*  [2.x.186] 

* 
* [0.x.113]*
    [2.x.187]   [2.x.188]   
* [0.x.114]*
    [2.x.189]   [2.x.190]   
* [0.x.115]*
    [2.x.191]   [2.x.192]   
* [0.x.116]*
    [2.x.193]   [2.x.194]   
* [0.x.117]*
    [2.x.195]   [2.x.196]   
* [0.x.118]*
    [2.x.197]   [2.x.198]   
* [0.x.119]*
    [2.x.199]   [2.x.200]   
* [0.x.120]*
    [2.x.201]   [2.x.202]   
* [0.x.121]*
    [2.x.203]   [2.x.204]   
* [0.x.122]*
    [2.x.205]   [2.x.206]   
* [0.x.123]*
    [2.x.207]   [2.x.208]   
* [0.x.124]*
    [2.x.209]   [2.x.210]   
* [0.x.125]*
    [2.x.211]   [2.x.212]   
* [0.x.126]*
   Constructor. Made protected to avoid initialization in user code. Takes   all data stored in MatrixFree. If applied to problems with more than one   finite element or more than one quadrature formula selected during   construction of  [2.x.213]   [2.x.214]  and  [2.x.215]    quad_no allow to select the appropriate components.  
* [0.x.127]*
   Constructor with reduced functionality for similar usage of FEEvaluation   as FEValues, including matrix assembly.  
* [0.x.128]*
   Copy constructor  
* [0.x.129]*
   Copy assignment operator  
* [0.x.130]*
 This class provides access to the data fields of the FEEvaluation classes. Partial specialization for fields with as many components as the underlying space dimension, i.e., values are of type Tensor<1,dim> and gradients of type Tensor<2,dim>. Provides some additional functions for access, like the symmetric gradient and divergence.
* 

* 
*  [2.x.216] 

* 
* [0.x.131]*
    [2.x.217]   [2.x.218]   
* [0.x.132]*
   Return the divergence of a vector-valued finite element at quadrature   point number  [2.x.219]  after a call to  [2.x.220]   
* [0.x.133]*
   Return the symmetric gradient of a vector-valued finite element at   quadrature point number  [2.x.221]  after a call to  [2.x.222]    evaluate(...,true,...). It corresponds to <tt>0.5   (grad+grad<sup>T</sup>)</tt>.  
* [0.x.134]*
   Return the curl of the vector field,  [2.x.223]  after a call to  [2.x.224]    evaluate(...,true,...).  
* [0.x.135]*
    [2.x.225]   [2.x.226]   
* [0.x.136]*
    [2.x.227]   [2.x.228]   
* [0.x.137]*
    [2.x.229]   [2.x.230]   
* [0.x.138]*
   Write a contribution that is tested by the gradient to the field   containing the values on quadrature points with component  [2.x.231]    This function is an alternative to the other submit_gradient function   when using a system of fixed number of equations which happens to   coincide with the dimension for some dimensions, but not all. To allow   for dimension-independent programming, this function can be used instead.  
* [0.x.139]*
   Write a contribution that is tested by the divergence to the field   containing the values on quadrature points with component  [2.x.232]    Access to the same field as through  [2.x.233]  If applied before   the function  [2.x.234]  is called, this specifies what is   tested by all basis function gradients on the current cell and integrated   over.  
* [0.x.140]*
   Write a contribution that is tested by the symmetric gradient to the field   containing the values on quadrature points with component  [2.x.235]    Access to the same field as through  [2.x.236]  If applied before   the function  [2.x.237]  is called, this specifies the   symmetric gradient which is tested by all basis function symmetric   gradients on the current cell and integrated over.  
* [0.x.141]*
   Write the components of a curl containing the values on quadrature point    [2.x.238]  Access to the same data field as through  [2.x.239]   
* [0.x.142]*
   Constructor. Made protected to avoid initialization in user code. Takes   all data stored in MatrixFree. If applied to problems with more than one   finite element or more than one quadrature formula selected during   construction of  [2.x.240]   [2.x.241]  and  [2.x.242]    quad_no allow to select the appropriate components.  
* [0.x.143]*
   Constructor with reduced functionality for similar usage of FEEvaluation   as FEValues, including matrix assembly.  
* [0.x.144]*
   Copy constructor  
* [0.x.145]*
   Copy assignment operator  
* [0.x.146]*
 This class provides access to the data fields of the FEEvaluation classes. Partial specialization for scalar fields in 1d that defines access with simple data fields, i.e., scalars for the values and Tensor<1,1> for the gradients.
* 

* 
*  [2.x.243] 

* 
* [0.x.147]*
    [2.x.244]   [2.x.245]   
* [0.x.148]*
    [2.x.246]   [2.x.247]   
* [0.x.149]*
    [2.x.248]   [2.x.249]   
* [0.x.150]*
    [2.x.250]   [2.x.251]   
* [0.x.151]*
    [2.x.252]   [2.x.253]   
* [0.x.152]*
    [2.x.254]   [2.x.255]   
* [0.x.153]*
    [2.x.256]   [2.x.257]   
* [0.x.154]*
    [2.x.258]   [2.x.259]   
* [0.x.155]*
    [2.x.260]   [2.x.261]   
* [0.x.156]*
    [2.x.262]   [2.x.263]   
* [0.x.157]*
    [2.x.264]   [2.x.265]   
* [0.x.158]*
    [2.x.266]   [2.x.267]   
* [0.x.159]*
    [2.x.268]   [2.x.269]   
* [0.x.160]*
    [2.x.270]   [2.x.271]   
* [0.x.161]*
    [2.x.272]   [2.x.273]   
* [0.x.162]*
    [2.x.274]   [2.x.275]   
* [0.x.163]*
    [2.x.276]   [2.x.277]   
* [0.x.164]*
   Constructor. Made protected to avoid initialization in user code. Takes   all data stored in MatrixFree. If applied to problems with more than one   finite element or more than one quadrature formula selected during   construction of  [2.x.278]   [2.x.279]  and  [2.x.280]    quad_no allow to select the appropriate components.  
* [0.x.165]*
   Constructor with reduced functionality for similar usage of FEEvaluation   as FEValues, including matrix assembly.  
* [0.x.166]*
   Copy constructor  
* [0.x.167]*
   Copy assignment operator  
* [0.x.168]*
 The class that provides all functions necessary to evaluate functions at quadrature points and cell integrations. In functionality, this class is similar to FEValues, however, it includes a lot of specialized functions that make it much faster (between 5 and 500, depending on the polynomial degree). For evaluation of face terms in DG, see the class FEFaceEvaluation.
*  [1.x.0]
*  [1.x.1]
*  The first and foremost way of usage is to initialize this class from a MatrixFree object that caches everything related to the degrees of freedom and the mapping information. This way, it is possible to use vectorization for applying a differential operator for several cells at once.
*  The capabilities of FEEvaluation span a large spectrum of integration tasks for weak forms. In general, there are two classes of tasks that get done. One is the  [2.x.281]  path that interpolates from a solution vector to quadrature points:
* 

* 
* [1.x.2]
* 
*  Likewise, a gradient of the finite element solution represented by  [2.x.282]  vector can be interpolated to the quadrature points by  [2.x.283]  phi.get_gradient(q). The combination of read_dof_values(), evaluate() and get_value() is similar to what  [2.x.284]  or  [2.x.285]  does, but it is in general much faster because it makes use of the tensor product, see the description of the evaluation routines below, and can do this operation for several cells at once through vectorization.
*  The second class of tasks done by FEEvaluation are integration tasks for right hand sides. In finite element computations, these typically consist of multiplying a quantity on quadrature points (a function value, or a field interpolated by the finite element space itself) by a set of test functions and integrating over the cell through summation of the values in each quadrature point, multiplied by the quadrature weight and the Jacobian determinant of the transformation. If a generic Function object is given and we want to compute  [2.x.286] , this is done by the following cell-wise integration:
* 

* 
* [1.x.3]
* 
*  In this code, the call to  [2.x.287]  prepares for the multiplication by the test function prior to the actual integration (inside the submit call, the value to be tested is also multiplied by the determinant of the Jacobian and the quadrature weight). In the  [2.x.288]  call, an integral contribution tested by each basis function underlying the FEEvaluation object (e.g. the four linear shape functions of FE_Q [2.x.289]  in 2D) is computed, which gives the vector entries to be summed into the  [2.x.290]  vector. Note that the above code needs to explicitly loop over the components in the vectorized array for evaluating the function, which is necessary for interfacing with a generic Function object with double arguments. Simple functions can also be implemented in VectorizedArray form directly as VectorizedArray provides the basic math operations.
*  For evaluating a bilinear form, the evaluation on a source vector is combined with the integration involving test functions that get written into a result vector. This setting is the context of matrix-free operator evaluation and explained in the  [2.x.291]  and  [2.x.292]  tutorial programs.
*  Note that the two vector accesses through  [2.x.293]  and  [2.x.294]  resolve constraints on the fly, based on the AffineConstraints object specified at the  [2.x.295]  call. In case the values in the degrees of freedom are of interest (usually only the values in quadrature points are necessary), these can be accessed through  [2.x.296]  where i is the index of the basis function. Note that the numbering of the degrees of freedom for continuous elements in FEEvaluation is different from the ordering in FE_Q (or FEValues) because FEEvaluation needs to access them in lexicographic order, which is the ordering used in FE_DGQ, for instance. Re-indexing would be too expensive because the access inside evaluate() and integrate() is on the critical path in the tensorial evaluation parts. An alternative to filling the DoF values by read_dof_values() before an evaluate() call is to manually assign a value by a set_dof_value() call. Likewise, if the local result of integration should be further processed rather than scattered into a vector by distribute_local_to_global(), one can access it by get_dof_value() after an integrate() call. An example for using the values of an integral in a different context is fast assembly of matrices as shown in the next subsection.
*  For most operator evaluation tasks that repeatedly go through the mesh, the realization by MatrixFree that combines pre-computed data for the mapping (Jacobian transformations for the geometry description) with on-the-fly evaluation of basis functions is the most efficient way of doing things. In other words, the framework selects a trade-off between memory usage and initialization of objects that is suitable for replacement of matrix-vector products or explicit time integration in a matrix-free way.
*  [1.x.4]
*  The second form of usage is to initialize FEEvaluation from geometry information generated by FEValues. This allows to apply the integration loops on the fly without prior initialization of MatrixFree objects. This can be useful when the memory and initialization cost of MatrixFree is not acceptable, e.g. when a different number of quadrature points should be used for one single evaluation in error computation. Also, when using the routines of this class to assemble matrices the trade-off implied by the MatrixFree class may not be desired. In such a case, the cost to initialize the necessary geometry data on the fly is comparably low and thus avoiding a global object MatrixFree can be useful. When used in this way, reinit methods reminiscent from FEValues with a cell iterator are used. However, note that this model results in working on a single cell at a time, with geometry data duplicated in all components of the vectorized array. Thus, vectorization is only useful when it can apply the same operation on different data, e.g. when performing matrix assembly.
*  As an example, consider the following code to assemble the contributions to the Laplace matrix:
* 

* 
* [1.x.5]
* 
*  This code generates the columns of the cell matrix with the loop over  [2.x.297]  above. The way this is done is the following: FEEvaluation's routines focus on the evaluation of finite element operators, so for computing a cell matrix out of an operator evaluation it is applied to all the unit vectors on the cell. Applying the operator on a unit vector might seem inefficient but the evaluation routines used here are so quick that they still work much faster than what is possible with FEValues. In particular, the complexity is  [2.x.298]  rather than  [2.x.299] .
*  Due to vectorization, we can generate matrix columns for several unit vectors at a time (e.g. 4). The variable  [2.x.300]  make sure that we do the last iteration where the number of cell dofs is not divisible by the vectorization length correctly. Also note that we need to get the internal dof numbering applied by fe_eval because FEEvaluation internally uses a lexicographic numbering of degrees of freedom as explained above.
*  [1.x.6]
*  The temporary data for holding the solution values on the local degrees of freedom as well as the interpolated values, gradients, and Hessians on quadrature points is a scratch array provided by  [2.x.301]  that is re-used between different calls to FEEvaluation. Therefore, constructing an FEEvaluation object is typically cheap and does not involve any expensive operation. Only a few dozen pointers to the actual data fields are set during construction. Therefore, no negative performance impact arises when creating an FEEvaluation several times per loop, such as at the top of a `local_cell_operation` operation that is split in small chunks for a parallel for loop, obviating a separate scratch data field for parallel loops as necessary in the loop of  [2.x.302] 
*  When using the FEEvaluation class in multithreaded mode, the thread local storage of the scratch data in MatrixFree automatically makes sure that each thread gets it private data array. Note, however, that deal.II must be compiled with thread support also when all the thread parallelization is provided externally and not done via deal.II's routines, such as OpenMP. This is because deal.II needs to know the notation of thread local storage. The FEEvaluation kernels have been verified to work within OpenMP loops.
*  [1.x.7]
*  This class is designed to perform all arithmetics on single-instruction multiple-data (SIMD) instructions present on modern CPUs by explicit vectorization, which are made available in deal.II through the class VectorizedArray, using the widest vector width available at configure/compile time. In order to keep programs flexible, FEEvaluation always applies vectorization over several elements. This is often the best compromise because computations on different elements are usually independent in the finite element method (except of course the process of adding an integral contribution to a global residual vector), also in more complicated scenarios: Stabilization parameter can e.g. be defined as the maximum of some quantities on all quadrature points of a cell divided by the cell's volume, but without locally mixing the results with neighbors. Using the terminology from computer architecture, the design of FEEvaluation relies on not doing any cross-lane data exchange when operating on the cell in typical integration scenarios.
*  When the number of cells in the problem is not a multiple of the number of array elements in the SIMD vector, the implementation of FEEvaluation fills in some dummy entries in the unused SIMD lanes and carries them around nonetheless, a choice made necessary since the length of VectorizedArray is fixed at compile time. Yet, this approach most often results in superior code as compared to an auto-vectorization setup where an alternative unvectorized code path would be necessary next to the vectorized version to be used on fully populated lanes, together with a dispatch mechanism. In  [2.x.303]  the empty lanes resulting from a reinit() call to an incomplete batch of cells are set to zero, whereas  [2.x.304]  or  [2.x.305]  simply ignores the content in the empty lanes. The number of actually filled SIMD lanes can by queried by  [2.x.306] 
*  Obviously, the computations performed on the artificial lanes (without real data) should never be mixed with valid results. The contract in using this class is that the user makes sure that lanes are not crossed in user code, in particular since it is not clear a priori which cells are going to be put together in vectorization. For example, results on an element should not be added to results on other elements except through the global vector access methods or by access that is masked by  [2.x.307]  No guarantee can be made that results on artificial lanes will always be zero that can safely be added to other results: The data on JxW or Jacobians is copied from the last valid lane in order to avoid division by zero that could trigger floating point exceptions or trouble in other situations.
*  [1.x.8]
*  This class contains specialized evaluation routines for elements based on tensor-product quadrature formulas and tensor-product-like shape functions, including standard FE_Q or FE_DGQ elements and quadrature points symmetric around 0.5 (like Gauss quadrature), FE_DGP elements based on truncated tensor products as well as the faster case of Gauss-Lobatto elements with Gauss-Lobatto quadrature which give diagonal mass matrices and quicker evaluation internally. The main benefit of this class is the evaluation of all shape functions in all quadrature or integration over all shape functions in  [2.x.308]  operations instead of the slower  [2.x.309]  complexity in the evaluation routines of FEValues. This is done by an algorithm called sum factorization which factors out constant factors during the evaluation along a coordinate direction. This algorithm is the basis of many spectral element algorithms.
*  Note that many of the operations available through this class are inherited from the base class FEEvaluationBase, in particular reading from and writing to vectors. Also, the class inherits from FEEvaluationAccess that implements access to values, gradients and Hessians of the finite element function on quadrature points.
*  This class assumes that the shape functions of the FiniteElement under consideration do  [2.x.310] not [2.x.311]  depend on the geometry of the cells in real space. Currently, other finite elements cannot be treated with the matrix-free concept.
*  [1.x.9]
*  The class FEEvaluation as two usage models. The first usage model is to specify the polynomial degree as a template parameter. This guarantees maximum efficiency: The evaluation with sum factorization performs a number of nested short 1D loops of length equal to the polynomial degree plus one. If the loop bounds are known at compile time, the compiler can unroll loops as deemed most efficient by its heuristics. At least the innermost loop is almost always completely unrolled, avoiding the loop overhead.
*  However, carrying the polynomial degree (and the number of quadrature points) as a template parameter makes things more complicated in codes where different polynomial degrees should be considered, e.g. in application codes where the polynomial degree is given through an input file. The second usage model is to rely on pre-compiled code for polynomial degrees. While a user code can use different functions for the cells (that get e.g. invoked by some dynamic dispatch mechanism for the various degree templates), deal.II also supports usage of this class based on the information in the element passed to the initialization. For this usage model, set the template parameter for the polynomial degree to
* 
*  -  and choose an arbitrary number for the number of quadrature points. That code part contains pre-compiled templated code for polynomial degrees between 1 and 6 and common quadrature formulas, which runs almost as fast as the templated version. In case the chosen degree is not pre-compiled, an evaluator object with template specialization for
* 
*  -  is invoked that runs according to run-time bounds.
*  An overview of the performance of FEEvaluation is given in the following figure. It considers the time spent per degree of freedom for evaluating the Laplacian with continuous finite elements using a code similar to the  [2.x.312]  tutorial program for single-precision arithmetics. The time is based on an experiment on a single core of an Intel Xeon E5-2687W v4, running at 3.4 GHz and measured at problem sizes of around 10 million. The plot lists the computational time (around 0.1 seconds) divided by the number of degrees freedom.
*   [2.x.313] 
*  The figure shows that the templated computational kernels are between 2.5 and 3 times faster than the non-templated ones. The fastest turnaround on this setup is for polynomial degree 5 at 7.4e-9 seconds per degree of freedom or 134 million degrees of freedom per second
* 
*  - on a single core. The non-templated version is also fastest at polynomial degree 5 with 2.1e-9 seconds per degree of freedom or 48 million degrees of freedom per second. Note that using FEEvaluation with template `degree=-1` selects the fast path for degrees between one and six, and the slow path for other degrees.
*  [1.x.10]
*  It is also possible to pre-compile the code in FEEvaluation for a different maximal polynomial degree. This is controlled by the class  [2.x.314]  and the implementation in `include/deal.II/matrix_free/evaluation_template_factory.templates.h`. By setting the macro `FE_EVAL_FACTORY_DEGREE_MAX` to the desired integer and instantiating the classes FEEvaluationFactory and FEFaceEvaluationFactory (the latter for FEFaceEvaluation) creates paths to templated functions for a possibly larger set of degrees. You can check if fast evaluation/integration for a given degree/n_quadrature_points pair by calling  [2.x.315]  or  [2.x.316] 
*  [1.x.11]
*  FEEvaluation also allows for treating vector-valued problems through a template parameter on the number of components:
* 

* 
* [1.x.12]
* 
*  If used this way, the components can be gathered from several components of an  [2.x.317]  through the call
* 

* 
* [1.x.13]
* 
*  where the 0 means that the vectors starting from the zeroth vector in the  [2.x.318]  should be used, <code>src[0], src[1], ..., src[n_components-1]</code>.
*  An alternative way for reading multi-component systems is possible if the DoFHandler underlying the MatrixFree data is based on an FESystem of  [2.x.319]  n_components entries. In that case, a single vector is provided for the read_dof_values() and distribute_local_to_global() calls.
*  An important property of FEEvaluation in multi-component systems is the layout of multiple components in the get_value(), get_gradient(), or get_dof_value() calls. In this case, instead of a scalar return field VectorizedArray [2.x.320]  a tensor is returned,
* 

* 
* [1.x.14]
* 
*  In a similar vein, the submit_value() and submit_gradient() calls take tensors of values. Note that there exist specializations for  [2.x.321]  n_components=1 and  [2.x.322]  which are provided through the base class FEEvaluationAccess. In the scalar case, these provide the scalar return types described above. In the vector-valued case, the gradient is converted from <code>Tensor [2.x.323]   [2.x.324]   [2.x.325]  to <code>Tensor [2.x.326]   [2.x.327]  Furthermore, additional operations such as the diveregence or curl are available.
*  In case different shape functions are combined, for example mixed finite element formulations in Stokes flow, two FEEvaluation objects are created, one for the velocity and one for the pressure. Those are then combined on quadrature points:
* 

* 
* [1.x.15]
* 
*  This code assumes that a BlockVector of two components describes the velocity and pressure components, respectively. For identifying the different DoFHandler objects for velocity and pressure, the second argument to the FEEvaluation objects specify the respective component 0 for velocity and 1 for pressure. For further examples of vector-valued problems, the deal.II test suite includes a few additional examples as well, e.g. the Stokes operator described above is found at https://github.com/dealii/dealii/blob/master/tests/matrix_free/matrix_vector_stokes_noflux.cc
*  [1.x.16]
*  The design of FEEvaluation and MatrixFree separates the geometry from the basis functions. Therefore, several DoFHandler objects (or the same DoFHandler equipped with different constraint objects) can share the same geometry information like in the Stokes example above. All geometry is cached once in MatrixFree, so FEEvaluation does not need to do expensive initialization calls and rather sets a few pointers. This realization is based on the idea that the geometry information is needed only once also when several fields are evaluated, in a departure from FEValues which sets up the internal mapping data for each field. If for example a multi-component PDE involves the shape values on one component and the shape gradient on the other, no efficiency is lost if both are based on the same MatrixFree object where the update flags specify that both  [2.x.328]  update_values ,  [2.x.329]  , and  [2.x.330]  are given. The selection of desired quantities of shape values is through the flags in the evaluate() or integrate calls and the access at quadrature points:
* 

* 
* [1.x.17]
* 
*  In the loop over quadrature points, one can ask any of the two FEEvaluation objects &mdash; it does not really matter which one because they only keep pointers to the quadrature point data &mdash; to provide the quadrature point location.
*  This observation also translates to the case when different differential operators are implemented in a program, for example the action of a mass matrix for one phase of the algorithm and the action of a stiffness matrix in another one. Only a single MatrixFree object is necessary, maintaining full efficiency by using different local functions with the respective implementation in separate FEEvaluation objects. In other words, a user does not need to bother about being conservative when providing update_flags to the initialization of MatrixFree for efficiency reasons
* 
*  - no overhead incurs inside FEEvaluation, except for at most one or two more  [2.x.331]  statements inside the  [2.x.332]  call. Rather, the largest set of flags necessary among all calls is perfectly fine from an efficiency point of view.
*  For the combination of different fields, including different solution vectors that come from different time steps, it is mandatory that all FEEvaluation objects share the same MatrixFree object. This is because the way cells are looped by  [2.x.333]  can be different for different DoFHandler or AffineConstraints arguments. More precisely, even though the layout is going to be the same in serial, there is no guarantee about the ordering for different DoFHandler/AffineConstraints in the MPI case. The reason is that the algorithm detects cells that need data exchange with MPI and those can change for different elements &mdash; FE_Q with hanging node constraints connects to more neighbors than a FE_DGQ element, for instance, and cells which need data exchange are put in different positions inside the cell loop. Of course, if the exact same DoFHandler, AffineConstraints, and options (such as the setting for thread parallelism) are set, then the order is going to be the same because the algorithm is deterministic.
*   [2.x.334]  dim Dimension in which this class is to be used
*   [2.x.335]  fe_degree Degree of the tensor product finite element with fe_degree+1 degrees of freedom per coordinate direction. Can be set to
* 
*  -  if the degree is not known at compile time, but performance will usually be worse by a factor of 2-3.
*   [2.x.336]  n_q_points_1d Number of points in the quadrature formula in 1D, defaults to fe_degree+1
*   [2.x.337]  n_components Number of vector components when solving a system of PDEs. If the same operation is applied to several components of a PDE (e.g. a vector Laplace equation), they can be applied simultaneously with one call (and often more efficiently). Defaults to 1.
*   [2.x.338]  Number Number format, usually  [2.x.339]  or  [2.x.340]  Defaults to  [2.x.341]  double
* 

* 
*  [2.x.342] 

* 
* [0.x.169]*
   An alias to the base class.  
* [0.x.170]*
   An underlying number type specified as template argument.  
* [0.x.171]*
   The type of function values, e.g. `VectorizedArrayType` for   `n_components=1` or `Tensor<1,dim,VectorizedArrayType >` for   `n_components=dim`.  
* [0.x.172]*
   The type of gradients, e.g. `Tensor<1,dim,VectorizedArrayType>` for   `n_components=1` or `Tensor<2,dim,VectorizedArrayType >` for   `n_components=dim`.  
* [0.x.173]*
   The dimension given as template argument.  
* [0.x.174]*
   The number of solution components of the evaluator given as template   argument.  
* [0.x.175]*
   The static number of quadrature points determined from the given template   argument `n_q_points_1d`. Note that the actual number of quadrature   points, `n_q_points`, can be different if `fe_degree=-1` is given and   run-time loop lengths are used rather than compile time ones.  
* [0.x.176]*
   The static number of degrees of freedom of a scalar component determined   from the given template argument `fe_degree`. Note that the actual number   of degrees of freedom `dofs_per_component` can be different if   `fe_degree=-1` is given or if the underlying is of more complicated type   than the usual FE_Q or FE_DGQ ones, such as FE_DGP.  
* [0.x.177]*
   The static number of degrees of freedom of all components determined from   the given template argument `fe_degree`. Note that the actual number of   degrees of freedom `dofs_per_cell` can be different if `fe_degree=-1` is   given or if the underlying is of more complicated type than the usual   FE_Q or FE_DGQ ones, such as FE_DGP.  
* [0.x.178]*
   The static number of degrees of freedom of all components determined from   the given template argument `fe_degree`. Note that the actual number of   degrees of freedom `dofs_per_cell` can be different if `fe_degree=-1` is   given or if the underlying is of more complicated type than the usual   FE_Q or FE_DGQ ones, such as FE_DGP.  
* [0.x.179]*
   Constructor. Takes all data stored in MatrixFree. If applied to problems   with more than one finite element or more than one quadrature formula   selected during construction of  [2.x.343]  the appropriate component   can be selected by the optional arguments.      [2.x.344]  matrix_free Data object that contains all data      [2.x.345]  dof_no If matrix_free was set up with multiple DoFHandler   objects, this parameter selects to which DoFHandler/AffineConstraints pair   the given evaluator should be attached to.      [2.x.346]  quad_no If matrix_free was set up with multiple Quadrature   objects, this parameter selects the appropriate number of the quadrature   formula.      [2.x.347]  first_selected_component If the dof_handler selected by dof_no   uses an FESystem consisting of more than one component, this parameter   allows for selecting the component where the current evaluation routine   should start. Note that one evaluator does not support combining   different shape functions in different components. In other words, the   same base element of a FESystem needs to be set for the components   between  [2.x.348]  and    [2.x.349] .      [2.x.350]  active_fe_index If matrix_free was set up with DoFHandler   objects with  [2.x.351]  this parameter selects to which   DoFHandler/AffineConstraints pair the given evaluator should be attached   to.      [2.x.352]  active_quad_index If matrix_free was set up with  [2.x.353]    objects, this parameter selects the appropriate number of the quadrature   formula.  
* [0.x.180]*
   Constructor. Takes all data stored in MatrixFree for a given cell range,   which allows to automatically identify the active_fe_index and   active_quad_index in case of a p-adaptive strategy.     The rest of the arguments are the same as in the constructor above.  
* [0.x.181]*
   Constructor that comes with reduced functionality and works similar as   FEValues. The arguments are similar to the ones passed to the constructor   of FEValues, with the notable difference that FEEvaluation expects a one-   dimensional quadrature formula, Quadrature<1>, instead of a  [2.x.354]    dimensional one. The finite element can be both scalar or vector valued,   but this method always only selects a scalar base element at a time (with    [2.x.355]  copies as specified by the class template). For vector-   valued elements, the optional argument  [2.x.356]  allows   to specify the index of the base element to be used for evaluation. Note   that the internal data structures always assume that the base element is   primitive, non-primitive are not supported currently.     As known from FEValues, a call to the reinit method with a    [2.x.357]  is necessary to make the geometry and   degrees of freedom of the current class known. If the iterator includes   DoFHandler information (i.e., it is a  [2.x.358]  or   similar), the initialization allows to also read from or write to vectors   in the standard way for  [2.x.359]  types for   one cell at a time. However, this approach is much slower than the path   with MatrixFree with MPI since index translation has to be done. As only   one cell at a time is used, this method does not vectorize over several   elements (which is most efficient for vector operations), but only   possibly within the element if the evaluate/integrate routines are   combined inside user code (e.g. for computing cell matrices).  
* [0.x.182]*
   Constructor for the reduced functionality. This constructor is equivalent   to the other one except that it makes the object use a  [2.x.360]  mapping   (i.e., an object of type MappingQGeneric(1)) implicitly.  
* [0.x.183]*
   Constructor for the reduced functionality. Similar to the other   constructor with FiniteElement argument but using another   FEEvaluationBase object to provide information about the geometry. This   allows several FEEvaluation objects to share the geometry evaluation, i.e.,   the underlying mapping and quadrature points do only need to be evaluated   once. Make sure to not pass an optional object around when you intend to   use the FEEvaluation object in %parallel to the given one because   otherwise the intended sharing may create race conditions.  
* [0.x.184]*
   Copy constructor. If FEEvaluationBase was constructed from a mapping, fe,   quadrature, and update flags, the underlying geometry evaluation based on   FEValues will be deep-copied in order to allow for using in parallel with   threads.  
* [0.x.185]*
   Copy assignment operator. If FEEvaluationBase was constructed from a   mapping, fe, quadrature, and update flags, the underlying geometry   evaluation based on FEValues will be deep-copied in order to allow for   using in parallel with threads.  
* [0.x.186]*
   Initialize the operation pointer to the current cell batch index. Unlike   the reinit functions taking a cell iterator as argument below and the    [2.x.361]  methods, where the information related to a particular   cell is generated in the reinit call, this function is very cheap since   all data is pre-computed in  [2.x.362]  and only a few indices have   to be set appropriately.  
* [0.x.187]*
   Initialize the data to the current cell using a TriaIterator object as   usual in FEValues. The argument is either of type    [2.x.363]  or  [2.x.364]  This   option is only available if the FEEvaluation object was created with a   finite element, quadrature formula and correct update flags and   [1.x.18] a MatrixFree object. This initialization method loses the   ability to use vectorization, see also the description of the   FEEvaluation class. When this reinit method is used, FEEvaluation can   also read from vectors (but less efficient than with data coming from   MatrixFree).  
* [0.x.188]*
   Initialize the data to the current cell using a TriaIterator object as   usual in FEValues. This option is only available if the FEEvaluation   object was created with a finite element, quadrature formula and correct   update flags and [1.x.19] a MatrixFree object. This initialization   method loses the ability to use vectorization, see also the description   of the FEEvaluation class. When this reinit method is used, FEEvaluation   can [1.x.20] read from vectors because no DoFHandler information is   available.  
* [0.x.189]*
   Check if face evaluation/integration is supported.  
* [0.x.190]*
   Evaluate the function values, the gradients, and the Hessians of the   polynomial interpolation from the DoF values in the input vector to the   quadrature points on the unit cell.  The function arguments specify which   parts shall actually be computed. This function has to be called first so   that the access functions  [2.x.365]   [2.x.366]  or  [2.x.367]    get_laplacian give useful information (unless these values have been set   manually).  
* [0.x.191]*
   Like above but with separate bool flags.    [2.x.368]  use evaluate() with the EvaluationFlags argument.  
* [0.x.192]*
   Evaluate the function values, the gradients, and the Hessians of the   polynomial interpolation from the DoF values in the input array  [2.x.369]    values_array to the quadrature points on the unit cell. If multiple   components are involved in the current FEEvaluation object, the sorting   in  [2.x.370]  is such that all degrees of freedom for the first   component come first, then all degrees of freedom for the second, and so   on. The function arguments specify which parts shall actually be   computed. This function has to be called first so that the access   functions  [2.x.371]   [2.x.372]  or  [2.x.373]  give   useful information (unless these values have been set manually).  
* [0.x.193]*
   Like above but using separate bool flags.    [2.x.374]  use evaluate() with the EvaluationFlags argument.  
* [0.x.194]*
   Read from the input vector and evaluates the function values, the   gradients, and the Hessians of the polynomial interpolation of the vector   entries from  [2.x.375]  associated with the current cell to the   quadrature points on the unit cell. The function arguments specify which   parts shall actually be computed. This function has to be called first so   that the access functions  [2.x.376]   [2.x.377]  or  [2.x.378]    get_laplacian give useful information (unless these values have been set   manually).     This call is equivalent to calling read_dof_values() followed by   evaluate(), but might internally use some additional optimizations.  
* [0.x.195]*
    [2.x.379]  Please use the gather_evaluate() function with the EvaluationFlags argument.  
* [0.x.196]*
   This function takes the values and/or gradients that are stored on   quadrature points, tests them by all the basis functions/gradients on the   cell and performs the cell integration. The two function arguments    [2.x.380]  and  [2.x.381]  are used to enable/disable   summation of the contributions submitted to the values or gradients slots,   respectively. The result is written into the internal data field    [2.x.382]  (that is usually written into the result vector by the   distribute_local_to_global() or set_dof_values() methods).  
* [0.x.197]*
    [2.x.383]  Please use the integrate() function with the EvaluationFlags argument.  
* [0.x.198]*
   This function takes the values and/or gradients that are stored on   quadrature points, tests them by all the basis functions/gradients on the   cell and performs the cell integration. The two function arguments  [2.x.384]    integrate_values and  [2.x.385]  are used to enable/disable   summation of the contributions submitted to the values or gradients   slots, respectively. As opposed to the other integrate() method, this   call stores the result of the testing in the given array  [2.x.386]    whose previous results is overwritten, rather than writing it on the   internal data structures behind begin_dof_values().  
* [0.x.199]*
    [2.x.387]  Please use the integrate() function with the EvaluationFlags argument.  
* [0.x.200]*
   This function takes the values and/or gradients that are stored on   quadrature points, tests them by all the basis functions/gradients on the   cell, performs the cell integration, and adds the result into the global   vector  [2.x.388]  on the degrees of freedom associated with the   present cell index. The two function arguments  [2.x.389]  and    [2.x.390]  are used to enable/disable summation of the   contributions submitted to the values or gradients slots, respectively.     This call is equivalent to calling integrate() followed by   distribute_local_to_global(), but might internally use   some additional optimizations.  
* [0.x.201]*
    [2.x.391]  Please use the integrate_scatter() function with the EvaluationFlags argument.  
* [0.x.202]*
   Return the q-th quadrature point in real coordinates stored in   MappingInfo.  
* [0.x.203]*
   The number of degrees of freedom of a single component on the cell for   the underlying evaluation object. Usually close to   static_dofs_per_component, but the number depends on the actual element   selected and is thus not static.  
* [0.x.204]*
   The number of degrees of freedom on the cell accumulated over all   components in the current evaluation object. Usually close to   static_dofs_per_cell = static_dofs_per_component*n_components, but the   number depends on the actual element selected and is thus not static.  
* [0.x.205]*
   The number of quadrature points in use. If the number of quadrature   points in 1d is given as a template, this number is simply the   <tt>dim</tt>-th power of that value. If the element degree is set to
* 
*  -    (dynamic selection of element degree), the static value of quadrature   points is inaccurate and this value must be used instead.  
* [0.x.206]*
   Checks if the template arguments regarding degree of the element   corresponds to the actual element used at initialization.  
* [0.x.207]*
 The class that provides all functions necessary to evaluate functions at quadrature points and face integrations. The design of the class is similar to FEEvaluation and most of the interfaces are shared with that class, in particular most access functions that come from the common base classes FEEvaluationAccess and FEEvaluationBase. Furthermore, the relation of this class to FEEvaluation is similar to the relation between FEValues and FEFaceValues.
*   [2.x.392]  dim Dimension in which this class is to be used
*   [2.x.393]  fe_degree Degree of the tensor product finite element with                  fe_degree+1 degrees of freedom per coordinate                  direction. If set to
* 
*  - , the degree of the underlying                  element will be used, which acts as a run time constant                  rather than a compile time constant that slows down the                  execution.
*   [2.x.394]  n_q_points_1d Number of points in the quadrature formula in 1D,                  usually chosen as fe_degree+1
*   [2.x.395]  n_components Number of vector components when solving a system of                  PDEs. If the same operation is applied to several                  components of a PDE (e.g. a vector Laplace equation), they                  can be applied simultaneously with one call (and often                  more efficiently)
*   [2.x.396]  Number Number format, usually  [2.x.397]  or  [2.x.398] 
*   [2.x.399]  VectorizedArrayType Type of array to be woked on in a vectorized                             fashion, defaults to VectorizedArray<Number>
* 

* 
*  [2.x.400]  Currently only VectorizedArray<Number, width> is supported as       VectorizedArrayType.

* 
* [0.x.208]*
   An alias to the base class.  
* [0.x.209]*
   A underlying number type specified as template argument.  
* [0.x.210]*
   The type of function values, e.g. `VectorizedArrayType` for   `n_components=1` or `Tensor<1,dim,VectorizedArrayType >` for   `n_components=dim`.  
* [0.x.211]*
   The type of gradients, e.g. `Tensor<1,dim,VectorizedArrayType>` for   `n_components=1` or `Tensor<2,dim,VectorizedArrayType >` for   `n_components=dim`.  
* [0.x.212]*
   The dimension given as template argument.  
* [0.x.213]*
   The number of solution components of the evaluator given as template   argument.  
* [0.x.214]*
   The static number of quadrature points determined from the given template   argument `n_q_points_1d` taken to the power of dim-1. Note that the actual   number of quadrature points, `n_q_points`, can be different if   `fe_degree=-1` is given and run-time loop lengths are used rather than   compile time ones.  
* [0.x.215]*
   The static number of quadrature points on a cell with the same quadrature   formula. Note that this value is only present for simpler comparison with   the cell quadrature, as the actual number of points is given to a face by   the `static_n_q_points` variable.  
* [0.x.216]*
   The static number of degrees of freedom of a scalar component determined   from the given template argument `fe_degree`. Note that the actual number   of degrees of freedom `dofs_per_component` can be different if   `fe_degree=-1` is given.  
* [0.x.217]*
   The static number of degrees of freedom of all components determined from   the given template argument `fe_degree`. Note that the actual number of   degrees of freedom `dofs_per_cell` can be different if `fe_degree=-1` is   given.  
* [0.x.218]*
   The static number of degrees of freedom of all components determined from   the given template argument `fe_degree`. Note that the actual number of   degrees of freedom `dofs_per_cell` can be different if `fe_degree=-1` is   given.  
* [0.x.219]*
   Constructor. Takes all data stored in MatrixFree. If applied to problems   with more than one finite element or more than one quadrature formula   selected during construction of  [2.x.401]  the appropriate component   can be selected by the optional arguments.      [2.x.402]  matrix_free Data object that contains all data      [2.x.403]  is_interior_face This selects which of the two cells of an   internal face the current evaluator will be based upon. The interior face   is the main face along which the normal vectors are oriented. The   exterior face coming from the other side provides the same normal vector   as the interior side, so if the outer normal vector to that side is   desired, it must be multiplied by
* 
*  - .      [2.x.404]  dof_no If matrix_free was set up with multiple DoFHandler   objects, this parameter selects to which DoFHandler/AffineConstraints pair   the given evaluator should be attached to.      [2.x.405]  quad_no If matrix_free was set up with multiple Quadrature   objects, this parameter selects the appropriate number of the quadrature   formula.      [2.x.406]  first_selected_component If the dof_handler selected by dof_no   uses an FESystem consisting of more than one base element, this parameter   selects the number of the base element in FESystem. Note that this does   not directly relate to the component of the respective element due to the   possibility for a multiplicity in the element.      [2.x.407]  active_fe_index If matrix_free was set up with DoFHandler   objects with  [2.x.408]  this parameter selects to which   DoFHandler/AffineConstraints pair the given evaluator should be attached   to.      [2.x.409]  face_type In the case of a face, indicate its reference-cell type   (0 for line or quadrilateral 1 for triangle).      [2.x.410]  active_quad_index If matrix_free was set up with  [2.x.411]    objects, this parameter selects the appropriate number of the quadrature   formula.  
* [0.x.220]*
   Constructor. Takes all data stored in MatrixFree for a given face range,   which allows to automatically identify the active_fe_index and   active_quad_index in case of a p-adaptive strategy.     The rest of the arguments are the same as in the constructor above.  
* [0.x.221]*
   Initializes the operation pointer to the current face. This method is the   default choice for face integration as the data stored in MappingInfo is   stored according to this numbering. Unlike the reinit functions taking a   cell iterator as argument below and the  [2.x.412]  methods, where   the information related to a particular cell is generated in the reinit   call, this function is very cheap since all data is pre-computed in    [2.x.413]  and only a few indices and pointers have to be set   appropriately.  
* [0.x.222]*
   As opposed to the reinit() method from the base class, this reinit()   method initializes for a given number of cells and a face number. This   method is less efficient than the other reinit() method taking a   numbering of the faces because it needs to copy the data associated with   the faces to the cells in this call.  
* [0.x.223]*
   Check if face evaluation/integration is supported.  
* [0.x.224]*
   Evaluates the function values, the gradients, and the Laplacians of the   FE function given at the DoF values stored in the internal data field   `dof_values` (that is usually filled by the read_dof_values() method) at   the quadrature points on the unit cell.  The function arguments specify   which parts shall actually be computed. Needs to be called before the   functions get_value(), get_gradient() or get_normal_derivative() give   useful information (unless these values have been set manually by   accessing the internal data pointers).  
* [0.x.225]*
    [2.x.414]  Please use the evaluate() function with the EvaluationFlags argument.  
* [0.x.226]*
   Evaluates the function values, the gradients, and the Laplacians of the   FE function given at the DoF values in the input array `values_array` at   the quadrature points on the unit cell. If multiple components are   involved in the current FEEvaluation object, the sorting in values_array   is such that all degrees of freedom for the first component come first,   then all degrees of freedom for the second, and so on. The function   arguments specify which parts shall actually be computed. Needs to be   called before the functions get_value(), get_gradient(), or   get_normal_derivative() give useful information (unless these values have   been set manually).  
* [0.x.227]*
    [2.x.415]  Please use the evaluate() function with the EvaluationFlags argument.  
* [0.x.228]*
   Reads from the input vector and evaluates the function values, the   gradients, and the Laplacians of the FE function at the quadrature points   on the unit cell. The function arguments specify which parts shall   actually be computed. Needs to be called before the functions   get_value(), get_gradient(), or get_normal_derivative() give useful   information.     This call is equivalent to calling read_dof_values() followed by   evaluate(), but might internally use some additional optimizations.  
* [0.x.229]*
    [2.x.416]  Please use the gather_evaluate() function with the EvaluationFlags argument.  
* [0.x.230]*
   This function takes the values and/or gradients that are stored on   quadrature points, tests them by all the basis functions/gradients on the   cell and performs the cell integration. The two function arguments   `integrate_val` and `integrate_grad` are used to enable/disable some of   values or gradients. The result is written into the internal data field   `dof_values` (that is usually written into the result vector by the   distribute_local_to_global() or set_dof_values() methods).  
* [0.x.231]*
    [2.x.417]  Please use the integrate() function with the EvaluationFlags argument.  
* [0.x.232]*
   This function takes the values and/or gradients that are stored on   quadrature points, tests them by all the basis functions/gradients on the   cell and performs the cell integration. The two function arguments   `integrate_val` and `integrate_grad` are used to enable/disable some of   values or gradients. As opposed to the other integrate() method, this   call stores the result of the testing in the given array `values_array`.  
* [0.x.233]*
    [2.x.418]  Please use the integrate() function with the EvaluationFlags argument.  
* [0.x.234]*
   This function takes the values and/or gradients that are stored on   quadrature points, tests them by all the basis functions/gradients on the   cell and performs the cell integration. The two function arguments   `integrate_val` and `integrate_grad` are used to enable/disable some of   values or gradients.     This call is equivalent to calling integrate() followed by   distribute_local_to_global(), but might internally use some additional   optimizations.  
* [0.x.235]*
    [2.x.419]  Please use the integrate_scatter() function with the EvaluationFlags argument.  
* [0.x.236]*
   Returns the q-th quadrature point on the face in real coordinates stored   in MappingInfo.  
* [0.x.237]*
   The number of degrees of freedom of a single component on the cell for   the underlying evaluation object. Usually close to   static_dofs_per_component, but the number depends on the actual element   selected and is thus not static.  
* [0.x.238]*
   The number of degrees of freedom on the cell accumulated over all   components in the current evaluation object. Usually close to   static_dofs_per_cell = static_dofs_per_component*n_components, but the   number depends on the actual element selected and is thus not static.  
* [0.x.239]*
   The number of quadrature points in use. If the number of quadrature   points in 1d is given as a template, this number is simply the   <tt>dim-1</tt>-th power of that value. If the element degree is set to
* 
*  -    (dynamic selection of element degree), the static value of quadrature   points is inaccurate and this value must be used instead.  
* [0.x.240]*
   Return face number of each face of the current face batch.  
* [0.x.241]*
   Determine the orientation of each face of the current face batch.  
* [0.x.242]*
   Implementation for standard vectors (that have the begin() methods).  
* [0.x.243]*
   Implementation for block vectors.  
* [0.x.244]*
   Implementation for vectors that have the begin() methods.  
* [0.x.245]*
   Implementation for all other vectors like block vectors.  
* [0.x.246]

include/deal.II-translator/matrix_free/fe_point_evaluation_0.txt
[0.x.0]*
     Struct to distinguish between the value and gradient types of different     numbers of components used by the FlexibleEvaluator class.    
* [0.x.1]*
 This class provides an interface to the evaluation of interpolated solution values and gradients on cells on arbitrary reference point positions. These points can change from cell to cell, both with respect to their quantity as well to the location. The two typical use cases are evaluations on non-matching grids and particle simulations.
*  The use of this class is similar to FEValues or FEEvaluation: The class is first initialized to a cell by calling  [2.x.0]  unit_points)`, with the main difference to the other concepts that the underlying points in reference coordinates need to be passed along. Then, upon call to evaluate() or integrate(), the user can compute information at the give points. Eventually, the access functions get_value() or get_gradient() allow to query this information at a specific point index.
*  The functionality is similar to creating an FEValues object with a Quadrature object on the `unit_points` on every cell separately and then calling  [2.x.1]  or  [2.x.2]  and for some elements and mappings this is what actually happens internally. For specific combinations of Mapping and FiniteElement realizations, however, there is a much more efficient implementation that avoids the memory allocation and other expensive start-up cost of FEValues. Currently, the functionality is specialized for mappings derived from MappingQGeneric and for finite elements with tensor product structure that work with the  [2.x.3]  module. In those cases, the cost implied by this class is similar (or sometimes even somewhat lower) than using  [2.x.4]  followed by  [2.x.5] 

* 
* [0.x.2]*
   Constructor.      [2.x.6]  mapping The Mapping class describing the actual geometry of a cell   passed to the evaluate() function.      [2.x.7]  fe The FiniteElement object that is used for the evaluation, which   is typically the same on all cells to be evaluated.      [2.x.8]  update_flags Specify the quantities to be computed by the mapping   during the call of reinit(). During evaluate() or integrate(), this data   is queried to produce the desired result (e.g., the gradient of a finite   element solution).      [2.x.9]  first_selected_component For multi-component FiniteElement   objects, this parameter allows to select a range of `n_components`   components starting from this parameter.  
* [0.x.3]*
   Set up the mapping information for the given cell, e.g., by computing the   Jacobian of the mapping the given points if gradients of the functions   are requested.      [2.x.10]  cell An iterator to the current cell      [2.x.11]  unit_points List of points in the reference locations of the   current cell where the FiniteElement object should be   evaluated/integrated in the evaluate() and integrate() functions.  
* [0.x.4]*
   This function interpolates the finite element solution, represented by   `solution_values`, on the cell and `unit_points` passed to reinit().      [2.x.12]  solution_values This array is supposed to contain the unknown   values on the element as returned by `cell->get_dof_values(global_vector,   solution_values)`.      [2.x.13]  evaluation_flags Flags specifying which quantities should be   evaluated at the points.  
* [0.x.5]*
   This function multiplies the quantities passed in by previous   submit_value() or submit_gradient() calls by the value or gradient of the   test functions, and performs summation over all given points. This is   similar to the integration of a bilinear form in terms of the test   function, with the difference that this formula does not include a `JxW`   factor. This allows the class to naturally embed point information   (e.g. particles) into a finite element formulation. Of course, by   multiplication of a `JxW` information of the data given to   submit_value(), the integration can also be represented by this class.      [2.x.14]  solution_values This array will contain the result of the   integral, which can be used to during   `cell->set_dof_values(solution_values, global_vector)` or   `cell->distribute_local_to_global(solution_values, global_vector)`. Note   that for multi-component systems where only some of the components are   selected by the present class, the entries not touched by this class will   be zeroed out.      [2.x.15]  integration_flags Flags specifying which quantities should be   integrated at the points.    
* [0.x.6]*
   Return the value at quadrature point number  [2.x.16]  after a call to    [2.x.17]  with  [2.x.18]  set, or   the value that has been stored there with a call to    [2.x.19]  If the object is vector-valued, a   vector-valued return argument is given.  
* [0.x.7]*
   Write a value to the field containing the values on points   with component point_index. Access to the same field as through   get_value(). If applied before the function  [2.x.20]    with  [2.x.21]  set is called, this specifies the value   which is tested by all basis function on the current cell and   integrated over.  
* [0.x.8]*
   Return the gradient in real coordinates at the point with index   `point_index` after a call to  [2.x.22]  with    [2.x.23]  set, or the gradient that has been stored there   with a call to  [2.x.24]  The gradient in real   coordinates is obtained by taking the unit gradient (also accessible via   get_unit_gradient()) and applying the inverse Jacobian of the mapping. If   the object is vector-valued, a vector-valued return argument is given.  
* [0.x.9]*
   Return the gradient in unit coordinates at the point with index   `point_index` after a call to  [2.x.25]  with    [2.x.26]  set, or the gradient that has been stored there   with a call to  [2.x.27]  If the object is   vector-valued, a vector-valued return argument is given. Note that when   vectorization is enabled, values from several points are grouped   together.  
* [0.x.10]*
   Write a contribution that is tested by the gradient to the field   containing the values on points with the given `point_index`. Access to   the same field as through get_gradient(). If applied before the function    [2.x.28]  is called, this   specifies what is tested by all basis function gradients on the current   cell and integrated over.  
* [0.x.11]*
   Return the Jacobian of the transformation on the current cell with the   given point index. Prerequisite: This class needs to be constructed with   UpdateFlags containing `update_jacobian`.  
* [0.x.12]*
   Return the inverse of the Jacobian of the transformation on the current   cell with the given point index. Prerequisite: This class needs to be   constructed with UpdateFlags containing `update_inverse_jacobian` or   `update_gradients`.  
* [0.x.13]*
   Return the position in real coordinates of the given point index among   the points passed to reinit().  
* [0.x.14]*
   Return the position in unit/reference coordinates of the given point   index, i.e., the respective point passed to the reinit() function.  
* [0.x.15]*
   Pointer to the Mapping object passed to the constructor.  
* [0.x.16]*
   Pointer to MappingQGeneric class that enables the fast path of this   class.  
* [0.x.17]*
   Pointer to the FiniteElement object passed to the constructor.  
* [0.x.18]*
   Description of the 1D polynomial basis for tensor product elements used   for the fast path of this class using tensor product evaluators.  
* [0.x.19]*
   Store whether the polynomials are linear with nodes at 0 and 1.  
* [0.x.20]*
   Renumbering between the unknowns of unknowns implied by the FiniteElement   class and a lexicographic numbering used for the tensorized code path.  
* [0.x.21]*
   Temporary array to store the `solution_values` passed to the evaluate()   function in a format compatible with the tensor product evaluators. For   vector-valued setups, this array uses a `Tensor<1, n_components>` type to   collect the unknowns for a particular basis function.  
* [0.x.22]*
   Temporary array to store a vectorized version of the `solution_values`   computed during `integrate()` in a format compatible with the tensor   product evaluators. For vector-valued setups, this array uses a   `Tensor<1, n_components, VectorizedArray<Number>>` format.  
* [0.x.23]*
   Temporary array to store the values at the points.  
* [0.x.24]*
   Temporary array to store the gradients in unit coordinates at the points.  
* [0.x.25]*
   Temporary array to store the gradients in real coordinates at the points.  
* [0.x.26]*
   Number of unknowns per component, i.e., number of unique basis functions,   for the chosen FiniteElement (or base element).  
* [0.x.27]*
   For complicated FiniteElement objects this variable informs us about   which unknowns actually carry degrees of freedom in the selected   components.  
* [0.x.28]*
   The desired update flags for the evaluation.  
* [0.x.29]*
   The update flags specific for the mapping in the fast evaluation path.  
* [0.x.30]*
   The FEValues object underlying the slow evaluation path.  
* [0.x.31]*
   Array to store temporary data computed by the mapping for the fast   evaluation path.  
* [0.x.32]*
   The reference points specified at reinit().  
* [0.x.33]

include/deal.II-translator/matrix_free/helper_functions_0.txt
[0.x.0]

include/deal.II-translator/matrix_free/mapping_data_on_the_fly_0.txt
[0.x.0]*
     This class provides evaluated mapping information using standard     deal.II information in a form that FEEvaluation and friends can use for     vectorized access. Since no vectorization over cells is available with     the DoFHandler/Triangulation cell iterators, the interface to     FEEvaluation's vectorization model is to use  [2.x.0]       [2.x.1]  copies of the same element. This     interface is thus primarily useful for evaluating several operators on     the same cell, e.g., when assembling cell matrices.         As opposed to the Mapping classes in deal.II, this class does not     actually provide a boundary description that can be used to evaluate     the geometry, but it rather provides the evaluated geometry from a     given deal.II mapping (as passed to the constructor of this class) in a     form accessible to FEEvaluation.    
* [0.x.1]*
       Constructor, similar to FEValues. Since this class only evaluates the       geometry, no finite element has to be specified and the simplest       element, FE_Nothing, is used internally for the underlying FEValues       object.      
* [0.x.2]*
       Constructor. This constructor is equivalent to the other one except       that it makes the object use a  [2.x.2]  mapping (i.e., an object of type       MappingQGeneric(1)) implicitly.      
* [0.x.3]*
       Initialize with the given cell iterator.      
* [0.x.4]*
       Return whether reinit() has been called at least once, i.e., a cell       has been set.      
* [0.x.5]*
       Return a triangulation iterator to the current cell.      
* [0.x.6]*
       Return a reference to the underlying FEValues object that evaluates       certain quantities (only mapping-related ones like Jacobians or       mapped quadrature points are accessible, as no finite element data is       actually used).      
* [0.x.7]*
       Return a reference to the underlying storage field of type       MappingInfoStorage of the same format as the data fields in       MappingInfo. This ensures compatibility with the precomputed data       fields in the MappingInfo class.      
* [0.x.8]*
       Return a reference to 1D quadrature underlying this object.      
* [0.x.9]*
       A cell iterator in case we generate the data on the fly to be able to       check if we need to re-generate the information stored in this class.      
* [0.x.10]*
       Dummy finite element object necessary for initializing the FEValues       object.      
* [0.x.11]*
       An underlying FEValues object that performs the (scalar) evaluation.      
* [0.x.12]*
       Get 1D quadrature formula to be used for reinitializing shape info.      
* [0.x.13]*
       The storage part created for a single cell and held in analogy to       MappingInfo.      
* [0.x.14]

include/deal.II-translator/matrix_free/mapping_info.templates_0.txt
[0.x.0]*
       Internal temporary data used for the initialization.      
* [0.x.1]*
       Helper function called internally during the initialize function.      
* [0.x.2]*
       This invokes the FEValues part of the initialization of MappingQ,       storing the resulting quadrature points and an initial representation       of Jacobians in two arrays.      
* [0.x.3]*
       This evaluates the mapping information on a range of cells calling       into the tensor product interpolators of the matrix-free framework,       using a polynomial expansion of the cell geometry in terms of       MappingQ.      
* [0.x.4]*
       This evaluates the mapping information on a range of cells calling       into the tensor product interpolators of the matrix-free framework,       using a polynomial expansion of the cell geometry in terms of       MappingQ.      
* [0.x.5]

include/deal.II-translator/matrix_free/mapping_info_0.txt
[0.x.0]*
     An enum to identify various types of cells and faces. The most general     type is what we typically compute in the FEValues context but for many     geometries we can save significant storage.        
*  [2.x.0]     
* [0.x.1]*
       The cell or face is Cartesian.      
* [0.x.2]*
       The cell or face can be described with an affine mapping.      
* [0.x.3]*
       The face is flat, i.e., the normal factor on a face is the same on       all quadrature points. This type is not assigned for cells.      
* [0.x.4]*
       There is no special information available for compressing the       representation of the object under consideration.      
* [0.x.5]*
     Definition of a structure that stores all cached data related to the     evaluated geometry from the mapping. In order to support hp-adaptivity     and compressed storage (in particular for Jacobians, JxW values, and     normals), storage length can be different for different rows. Thus, it     allows to jump at the data of individual rows similar to compressed row     storage in sparse matrices. We have two different start indices for     fields with different sizes. The first category of offsets are the     indices for Jacobians of the transformation from unit to real cell (we     store the inverse Jacobian), second derivatives, JxW values, and normal     vectors. We keep separate arrays for all these data structures because     a user code might access only some of them. In such a case, one array     will be gone through in a contiguous order with access to all entries,     which makes it easy for the processor to prefetch data. Having all data     in a single array would require some strides in the access pattern,     which is much more complicated for the processor to predict (and indeed     leads to prefetching of data that does not get used on Intel processors     such as BroadwellEP).         The second category of indices are the offsets for the quadrature     points. Quadrature points can be compressed less than the other fields     and thus need longer fields. Quadrature point indices are often used in     other contexts such as evaluation of right hand sides.         The third component is a descriptor of data from the unit cells, called     QuadratureDescriptor, which contains the quadrature weights and     permutations of how to go through quadrature points in case of face     data. The latter comes in a vector for the support of hp-adaptivity,     with several data fields for the individual quadrature formulas.        
*  [2.x.1]     
* [0.x.6]*
         Constructor. Does nothing.        
* [0.x.7]*
         Set up the lengths in the various members of this struct.        
* [0.x.8]*
         Set up the lengths in the various members of this struct.        
* [0.x.9]*
         Returns the memory consumption in bytes.        
* [0.x.10]*
         Number of quadrature points applied on the given cell or face.        
* [0.x.11]*
         Original one-dimensional quadrature formula applied on the given         cell or face.        
* [0.x.12]*
         Quadrature formula applied on the given cell or face.        
* [0.x.13]*
         Quadrature weights separated by dimension for use in specific         situations.        
* [0.x.14]*
         A cached vector of quadrature weights in the given number format         (non-vectorized, as it is cheap to broadcast the value to all lanes         when it is used in a vectorized context).        
* [0.x.15]*
         For quadrature on faces, the evaluation of basis functions is not         in the correct order if a face is not in the standard orientation         to a given element. This data structure is used to re-order the         data evaluated on quadrature points to represent the correct order.        
* [0.x.16]*
       A class describing the layout of the sections in the  [2.x.2]        field and also includes some data that depends on the number of       quadrature points in the hp-context such as the inner quadrature       formula and re-indexing for faces that are not in the standard       orientation.      
* [0.x.17]*
       Collection of quadrature formulae applied on the given face.            
*  [2.x.3]  Only filled for faces, since faces might be quadrilateral or         triangle shaped.      
* [0.x.18]*
       Stores the index offset into the arrays  [2.x.4]   [2.x.5]         [2.x.6]  and the second derivatives. Note that affine cells       have shorter fields of length 1, where the others have lengths equal       to the number of quadrature points of the given cell.      
* [0.x.19]*
       The storage of the Jacobian determinant (times the quadrature weight       in case the transformation is non-affine) on quadrature       points.             Indexed by  [2.x.7]       
* [0.x.20]*
       Stores the normal vectors.             Indexed by  [2.x.8]       
* [0.x.21]*
       The storage of covariant transformation on quadrature points, i.e.,       the inverse and transposed Jacobians of the transformation from the       unit to the real cell.             Indexed by  [2.x.9]              Contains two fields for access from both sides for interior faces,       but the default case (cell integrals or boundary integrals) only       fills the zeroth component and ignores the first one.      
* [0.x.22]*
       The storage of the gradients of the inverse Jacobian       transformation. Because of symmetry, only the upper diagonal and       diagonal part are needed. The first index runs through the       derivatives, starting with the diagonal and then continuing row-wise,       i.e.,  [2.x.10]  first, then        [2.x.11] , and so on. The second index       is the spatial coordinate.             Indexed by  [2.x.12]              Contains two fields for access from both sides for interior faces,       but the default case (cell integrals or boundary integrals) only       fills the zeroth component and ignores the first one.      
* [0.x.23]*
       Stores the Jacobian transformations times the normal vector (this       represents a shortcut that is accessed often and can thus get higher       performance).             Indexed by  [2.x.13]       
* [0.x.24]*
       Stores the index offset of a particular cell into the quadrature       points array in real coordinates. Note that Cartesian cells have       shorter fields (length is  [2.x.14]  than non-Cartesian cells       (length is  [2.x.15]  or faces.      
* [0.x.25]*
       Stores the quadrature points in real coordinates, including a       compression scheme for Cartesian cells where we do not need to store       the full data on all points.             Indexed by  [2.x.16]       
* [0.x.26]*
       Clears all data fields except the descriptor vector.      
* [0.x.27]*
       Returns the quadrature index for a given number of quadrature       points. If not in hp-mode or if the index is not found, this       function always returns index 0. Hence, this function does not       check whether the given degree is actually present.      
* [0.x.28]*
       Prints a detailed summary of memory consumption in the different       structures of this class to the given output stream.      
* [0.x.29]*
       Returns the memory consumption in bytes.      
* [0.x.30]*
     The class that stores all geometry-dependent data related with cell     interiors for use in the matrix-free class.        
*  [2.x.17]     
* [0.x.31]*
       Compute the information in the given cells and faces. The cells are       specified by the level and the index within the level (as given by        [2.x.18]  and  [2.x.19]  in order to allow       for different kinds of iterators, e.g. standard DoFHandler,       multigrid, etc.)  on a fixed Triangulation. In addition, a mapping       and several 1D quadrature formulas are given.      
* [0.x.32]*
       Update the information in the given cells and faces that is the       result of a change in the given `mapping` class, keeping the cells,       quadrature formulas and other unknowns unchanged. This call is only       valid if  [2.x.20]  has been called before.      
* [0.x.33]*
       Return the type of a given cell as detected during initialization.      
* [0.x.34]*
       Clear all data fields in this class.      
* [0.x.35]*
       Return the memory consumption of this class in bytes.      
* [0.x.36]*
       Prints a detailed summary of memory consumption in the different       structures of this class to the given output stream.      
* [0.x.37]*
       The given update flags for computing the geometry on the cells.      
* [0.x.38]*
       The given update flags for computing the geometry on the boundary       faces.      
* [0.x.39]*
       The given update flags for computing the geometry on the interior       faces.      
* [0.x.40]*
       The given update flags for computing the geometry on the faces for       cell-centric loops.      
* [0.x.41]*
       Stores whether a cell is Cartesian (cell type 0), has constant       transform data (Jacobians) (cell type 1), or is general (cell type       3). Type 2 is only used for faces and no cells are assigned this       value.      
* [0.x.42]*
       Stores whether a face (and both cells adjacent to the face) is       Cartesian (face type 0), whether it represents an affine situation       (face type 1), whether it is a flat face where the normal vector is       the same throughout the face (face type 2), or is general (face type       3).      
* [0.x.43]*
       The data cache for the cells.      
* [0.x.44]*
       The data cache for the faces.      
* [0.x.45]*
       The data cache for the face-associated-with-cell topology, following       the  [2.x.21]  variable for the cell types.      
* [0.x.46]*
       The pointer to the underlying  [2.x.22]  object.      
* [0.x.47]*
       The pointer to the first entry of mapping_collection.      
* [0.x.48]*
       Reference-cell type related to each quadrature and active quadrature       index.      
* [0.x.49]*
       Internal function to compute the geometry for the case the mapping is       a MappingQ and a single quadrature formula per slot (non-hp-case) is       used. This method computes all data from the underlying cell       quadrature points using the fast operator evaluation techniques from       the matrix-free framework itself, i.e., it uses a polynomial       description of the cell geometry (that is computed in a first step)       and then computes all Jacobians and normal vectors based on this       information. This optimized approach is much faster than going       through FEValues and FEFaceValues, especially when several different       quadrature formulas are involved, and consumes less memory.              [2.x.23]  tria The triangulation to be used for setup              [2.x.24]  cells The actual cells of the triangulation to be worked on,       given as a tuple of the level and index within the level as used in       the main initialization of the class              [2.x.25]  faces The description of the connectivity from faces to cells       as filled in the MatrixFree class      
* [0.x.50]*
       Computes the information in the given cells, called within       initialize.      
* [0.x.51]*
       Computes the information in the given faces, called within       initialize.      
* [0.x.52]*
       Computes the information in the given faces, called within       initialize.      
* [0.x.53]*
       Helper function to determine which update flags must be set in the       internal functions to initialize all data as requested by the user.      
* [0.x.54]*
     A helper class to extract either cell or face data from mapping info     for use in FEEvaluationBase.    
* [0.x.55]*
     A class that is used to compare floating point arrays (e.g.  [2.x.26]      Tensor<1,dim>, etc.). The idea of this class is to consider two arrays as     equal if they are the same within a given tolerance. We use this     comparator class within a  [2.x.27]  of the given arrays. Note that this     comparison operator does not satisfy all the mathematical properties one     usually wants to have (consider e.g. the numbers a=0, b=0.1, c=0.2 with     tolerance 0.15; the operator gives a<c, but neither a<b? nor b<c? is     satisfied). This is not a problem in the use cases for this class, but be     careful when using it in other contexts.    
* [0.x.56]*
       Compare two vectors of numbers (not necessarily of the same length)      
* [0.x.57]*
       Compare two vectorized arrays (stored as tensors to avoid alignment       issues).      
* [0.x.58]*
       Compare two rank-1 tensors of vectorized arrays (stored as tensors to       avoid alignment issues).      
* [0.x.59]*
       Compare two rank-2 tensors of vectorized arrays (stored as tensors to       avoid alignment issues).      
* [0.x.60]*
       Compare two arrays of tensors.      
* [0.x.61]

include/deal.II-translator/matrix_free/matrix_free.templates_0.txt
[0.x.0]

include/deal.II-translator/matrix_free/matrix_free_0.txt
[0.x.0]*
 This class collects all the data that is stored for the matrix free implementation. The storage scheme is tailored towards several loops performed with the same data, i.e., typically doing many matrix-vector products or residual computations on the same mesh. The class is used in  [2.x.0]  and  [2.x.1] .
*  This class does not implement any operations involving finite element basis functions, i.e., regarding the operation performed on the cells. For these operations, the class FEEvaluation is designed to use the data collected in this class.
*  The stored data can be subdivided into three main components:
* 

* 
* 
*  - DoFInfo: It stores how local degrees of freedom relate to global degrees of freedom. It includes a description of constraints that are evaluated as going through all local degrees of freedom on a cell.
* 

* 
* 
*  - MappingInfo: It stores the transformations from real to unit cells that are necessary in order to build derivatives of finite element functions and find location of quadrature weights in physical space.
* 

* 
* 
*  - ShapeInfo: It contains the shape functions of the finite element, evaluated on the unit cell.
*  Besides the initialization routines, this class implements only a single operation, namely a loop over all cells (cell_loop()). This loop is scheduled in such a way that cells that share degrees of freedom are not worked on simultaneously, which implies that it is possible to write to vectors (or matrices) in parallel without having to explicitly synchronize access to these vectors and matrices. This class does not implement any shape values, all it does is to cache the respective data. To implement finite element operations, use the class FEEvaluation (or some of the related classes).
*  This class traverses the cells in a different order than the usual Triangulation class in deal.II, in order to be flexible with respect to parallelization in shared memory and vectorization.
*  Vectorization is implemented by merging several topological cells into one so-called macro cell. This enables the application of all cell-related operations for several cells with one CPU instruction and is one of the main features of this framework.
*  For details on usage of this class, see the description of FEEvaluation or the  [2.x.2]  "matrix-free module".
* 

* 
*  [2.x.3] 

* 
* [0.x.1]*
   An alias for the underlying number type specified by the template   argument.  
* [0.x.2]*
   The dimension set by the template argument `dim`.  
* [0.x.3]*
   Collects the options for initialization of the MatrixFree class. The   first parameter specifies the MPI communicator to be used, the second the   parallelization options in shared memory (task-based parallelism, where   one can choose between no parallelism and three schemes that avoid that   cells with access to the same vector entries are accessed   simultaneously), the third with the block size for task parallel   scheduling, the fourth the update flags that should be stored by this   class.     The fifth parameter specifies the level in the triangulation from which   the indices are to be used. If the level is set to    [2.x.4]  the active cells are traversed, and   otherwise the cells in the given level. This option has no effect in case   a DoFHandler is given.     The parameter  [2.x.5]  indicates whether the DoFInfo   class should also allow for access to vectors without resolving   constraints.     The two parameters `initialize_indices` and `initialize_mapping` allow   the user to disable some of the initialization processes. For example, if   only the scheduling that avoids touching the same vector/matrix indices   simultaneously is to be found, the mapping needs not be   initialized. Likewise, if the mapping has changed from one iteration to   the next but the topology has not (like when using a deforming mesh with   MappingQEulerian), it suffices to initialize the mapping only.     The two parameters `cell_vectorization_categories` and   `cell_vectorization_categories_strict` control the formation of batches   for vectorization over several cells. It is used implicitly when working   with hp-adaptivity but can also be useful in other contexts, such as in   local time stepping where one would like to control which elements   together form a batch of cells. The array `cell_vectorization_categories`   is accessed by the number given by cell->active_cell_index() when working   on the active cells with `mg_level` set to  [2.x.6]    and by cell->index() for the level cells. By default, the different   categories in `cell_vectorization_category` can be mixed and the algorithm   is allowed to merge lower category numbers with the next higher categories   if it is necessary inside the algorithm, in order to avoid partially   filled SIMD lanes as much as possible. This gives a better utilization of   the vectorization but might need special treatment, in particular for   face integrals. If set to  [2.x.7]  the algorithm will instead keep   different categories separate and not mix them in a single vectorized   array.  
* [0.x.4]*
     Collects options for task parallelism. See the documentation of the     member variable  [2.x.8]  for a     thorough description.    
* [0.x.5]*
       Perform application in serial.      
* [0.x.6]*
       Partition the cells into two levels and afterwards form chunks.      
* [0.x.7]*
       Partition on the global level and color cells within the partitions.      
* [0.x.8]*
       Use the traditional coloring algorithm: this is like        [2.x.9]  but only uses one partition.      
* [0.x.9]*
     Constructor for AdditionalData.    
* [0.x.10]*
     Copy constructor.    
* [0.x.11]*
     Copy assignment.    
* [0.x.12]*
     Set the scheme for task parallelism. There are four options available.     If set to  [2.x.10]  the operator application is done in serial without     shared memory parallelism. If this class is used together with MPI and     MPI is also used for parallelism within the nodes, this flag should be     set to  [2.x.11]  The default value is  [2.x.12]  i.e. we     actually use multithreading with the first option described below.         The first option  [2.x.13]  is to partition the cells on     two levels in onion-skin-like partitions and forming chunks of     tasks_block_size after the partitioning. The partitioning finds sets of     independent cells that enable working in parallel without accessing the     same vector entries at the same time.         The second option  [2.x.14]  is to use a partition on the     global level and color cells within the partitions (where all chunks     within a color are independent). Here, the subdivision into chunks of     cells is done before the partitioning, which might give worse     partitions but better cache performance if degrees of freedom are not     renumbered.         The third option  [2.x.15]  is to use a traditional algorithm of coloring     on the global level. This scheme is a special case of the second option     where only one partition is present. Note that for problems with     hanging nodes, there are quite many colors (50 or more in 3D), which     might degrade parallel performance (bad cache behavior, many     synchronization points).        
*  [2.x.16]  Threading support is currently experimental for the case inner     face integrals are performed and it is recommended to use MPI     parallelism if possible. While the scheme has been verified to work     with the `partition_partition` option in case of usual DG elements, no     comprehensive tests have been performed for systems of more general     elements, like combinations of continuous and discontinuous elements     that add face integrals to all terms.    
* [0.x.13]*
     Set the number of so-called macro cells that should form one     partition. If zero size is given, the class tries to find a good size     for the blocks based on  [2.x.17]  and the number of     cells present. Otherwise, the given number is used. If the given number     is larger than one third of the number of total cells, this means no     parallelism. Note that in the case vectorization is used, a macro cell     consists of more than one physical cell.    
* [0.x.14]*
     This flag determines the mapping data on cells that is cached. This     class can cache data needed for gradient computations (inverse     Jacobians), Jacobian determinants (JxW), quadrature points as well as     data for Hessians (derivative of Jacobians). By default, only data for     gradients and Jacobian determinants times quadrature weights, JxW, are     cached. If quadrature points or second derivatives are needed, they     must be specified by this field (even though second derivatives might     still be evaluated on Cartesian cells without this option set here,     since there the Jacobian describes the mapping completely).    
* [0.x.15]*
     This flag determines the mapping data on boundary faces to be     cached. Note that MatrixFree uses a separate loop layout for face     integrals in order to effectively vectorize also in the case of hanging     nodes (which require different subface settings on the two sides) or     some cells in the batch of a VectorizedArray of cells that are adjacent     to the boundary and others that are not.         If set to a value different from update_general (default), the face     information is explicitly built. Currently, MatrixFree supports to     cache the following data on faces: inverse Jacobians, Jacobian     determinants (JxW), quadrature points, data for Hessians (derivative of     Jacobians), and normal vectors.        
*  [2.x.18]  In order to be able to perform a `face_operation` or     `boundary_operation` in the  [2.x.19]  either this field or      [2.x.20]  must be set to a value different     from  [2.x.21]     
* [0.x.16]*
     This flag determines the mapping data on interior faces to be     cached. Note that MatrixFree uses a separate loop layout for face     integrals in order to effectively vectorize also in the case of hanging     nodes (which require different subface settings on the two sides) or     some cells in the batch of a VectorizedArray of cells that are adjacent     to the boundary and others that are not.         If set to a value different from update_general (default), the face     information is explicitly built. Currently, MatrixFree supports to     cache the following data on faces: inverse Jacobians, Jacobian     determinants (JxW), quadrature points, data for Hessians (derivative of     Jacobians), and normal vectors.        
*  [2.x.22]  In order to be able to perform a `face_operation` or     `boundary_operation` in the  [2.x.23]  either this field or      [2.x.24]  must be set to a value different     from  [2.x.25]     
* [0.x.17]*
     This flag determines the mapping data for faces in a different layout     with respect to vectorizations. Whereas     `mapping_update_flags_inner_faces` and     `mapping_update_flags_boundary_faces` trigger building the data in a     face-centric way with proper vectorization, the current data field     attaches the face information to the cells and their way of     vectorization. This is only needed in special situations, as for     example for block-Jacobi methods where the full operator to a cell     including its faces are evaluated. This data is accessed by      [2.x.26]      face_number)</code>. However, currently no coupling terms to neighbors     can be computed with this approach because the neighbors are not laid     out by the VectorizedArray data layout with an     array-of-struct-of-array-type data structures.         Note that you should only compute this data field in case you really     need it as it more than doubles the memory required by the mapping data     on faces.         If set to a value different from update_general (default), the face     information is explicitly built. Currently, MatrixFree supports to     cache the following data on faces: inverse Jacobians, Jacobian     determinants (JxW), quadrature points, data for Hessians (derivative of     Jacobians), and normal vectors.    
* [0.x.18]*
     This option can be used to define whether we work on a certain level of     the mesh, and not the active cells. If set to invalid_unsigned_int     (which is the default value), the active cells are gone through,     otherwise the level given by this parameter. Note that if you specify     to work on a level, its dofs must be distributed by using      [2.x.27] .    
* [0.x.19]*
     Controls whether to enable reading from vectors without resolving     constraints, i.e., just read the local values of the vector. By     default, this option is enabled. In case you want to use      [2.x.28]  this flag needs to be set.    
* [0.x.20]*
     Option to control whether the indices stored in the DoFHandler     should be read and the pattern for task parallelism should be     set up in the initialize method of MatrixFree. The default     value is true. Can be disabled in case the mapping should be     recomputed (e.g. when using a deforming mesh described through     MappingEulerian) but the topology of cells has remained the     same.    
* [0.x.21]*
     Option to control whether the mapping information should be     computed in the initialize method of MatrixFree. The default     value is true. Can be disabled when only some indices should be     set up (e.g. when only a set of independent cells should be     computed).    
* [0.x.22]*
     Option to control whether the loops should overlap communications and     computations as far as possible in case the vectors passed to the loops     support non-blocking data exchange. In most situations, overlapping is     faster in case the amount of data to be sent is more than a few     kilobytes. If less data is sent, the communication is latency bound on     most clusters (point-to-point latency is around 1 microsecond on good     clusters by 2016 standards). Depending on the MPI implementation and     the fabric, it may be faster to not overlap and wait for the data to     arrive. The default is true, i.e., communication and computation are     overlapped.    
* [0.x.23]*
     By default, the face part will only hold those faces (and ghost     elements behind faces) that are going to be processed locally. In case     MatrixFree should have access to all neighbors on locally owned cells,     this option enables adding the respective faces at the end of the face     range.    
* [0.x.24]*
     This data structure allows to assign a fraction of cells to different     categories when building the information for vectorization. It is used     implicitly when working with hp-adaptivity but can also be useful in     other contexts, such as in local time stepping where one would like to     control which elements together form a batch of cells.         This array is accessed by the number given by cell->active_cell_index()     when working on the active cells with  [2.x.29]  set to  [2.x.30]  and     by cell->index() for the level cells.        
*  [2.x.31]  This field is empty upon construction of AdditionalData. It is     the responsibility of the user to resize this field to     `triangulation.n_active_cells()` or `triangulation.n_cells(level)` when     filling data.    
* [0.x.25]*
     By default, the different categories in  [2.x.32]      can be mixed and the algorithm is allowed to merge lower categories with     the next higher categories if it is necessary inside the algorithm. This     gives a better utilization of the vectorization but might need special     treatment, in particular for face integrals. If set to  [2.x.33]  the     algorithm will instead keep different categories separate and not mix     them in a single vectorized array.    
* [0.x.26]*
     Shared-memory MPI communicator. Default: MPI_COMM_SELF.    
* [0.x.27]*
    [2.x.34]  1: Construction and initialization  
* [0.x.28]*
   Default empty constructor. Does nothing.  
* [0.x.29]*
   Copy constructor, calls copy_from  
* [0.x.30]*
   Destructor.  
* [0.x.31]*
   Extracts the information needed to perform loops over cells. The   DoFHandler and AffineConstraints objects describe the layout of degrees   of freedom, the DoFHandler and the mapping describe the   transformations from unit to real cell, and the finite element   underlying the DoFHandler together with the quadrature formula   describe the local operations. Note that the finite element underlying   the DoFHandler must either be scalar or contain several copies of the   same element. Mixing several different elements into one FESystem is   not allowed. In that case, use the initialization function with   several DoFHandler arguments.  
* [0.x.32]*
   Initializes the data structures. Same as above, but using a  [2.x.35]    mapping.      [2.x.36]  Use the overload taking a Mapping object instead.  
* [0.x.33]*
   Extracts the information needed to perform loops over cells. The   DoFHandler and AffineConstraints objects describe the layout of degrees of   freedom, the DoFHandler and the mapping describe the transformations from   unit to real cell, and the finite element underlying the DoFHandler   together with the quadrature formula describe the local operations. As   opposed to the scalar case treated with the other initialization   functions, this function allows for problems with two or more different   finite elements. The DoFHandlers to each element must be passed as   pointers to the initialization function. Alternatively, a system of   several components may also be represented by a single DoFHandler with an   FESystem element. The prerequisite for this case is that each base   element of the FESystem must be compatible with the present class, such   as the FE_Q or FE_DGQ classes.     This function also allows for using several quadrature formulas, e.g.   when the description contains independent integrations of elements of   different degrees. However, the number of different quadrature formulas   can be sets independently from the number of DoFHandlers, when several   elements are always integrated with the same quadrature formula.  
* [0.x.34]*
   Initializes the data structures. Same as above, but  using DoFHandlerType.      [2.x.37]  Use the overload taking a DoFHandler object instead.  
* [0.x.35]*
   Initializes the data structures. Same as above, but  using a  [2.x.38]    mapping.      [2.x.39]  Use the overload taking a Mapping object instead.  
* [0.x.36]*
   Initializes the data structures. Same as above, but  using DoFHandlerType.      [2.x.40]  Use the overload taking a DoFHandler object instead.  
* [0.x.37]*
   Initializes the data structures. Same as before, but now the index set   description of the locally owned range of degrees of freedom is taken   from the DoFHandler. Moreover, only a single quadrature formula is used,   as might be necessary when several components in a vector-valued problem   are integrated together based on the same quadrature formula.  
* [0.x.38]*
   Initializes the data structures. Same as above, but  using DoFHandlerType.      [2.x.41]  Use the overload taking a DoFHandler object instead.  
* [0.x.39]*
   Initializes the data structures. Same as above, but  using a  [2.x.42]    mapping.      [2.x.43]  Use the overload taking a Mapping object instead.  
* [0.x.40]*
   Initializes the data structures. Same as above, but  using DoFHandlerType.      [2.x.44]  Use the overload taking a DoFHandler object instead.  
* [0.x.41]*
   Copy function. Creates a deep copy of all data structures. It is usually   enough to keep the data for different operations once, so this function   should not be needed very often.  
* [0.x.42]*
   Refreshes the geometry data stored in the MappingInfo fields when the   underlying geometry has changed (e.g. by a mapping that can deform   through a change in the spatial configuration like MappingFEField)   whereas the topology of the mesh and unknowns have remained the   same. Compared to reinit(), this operation only has to re-generate the   geometry arrays and can thus be significantly cheaper (depending on the   cost to evaluate the geometry).  
* [0.x.43]*
   Same as above but with  [2.x.45]   
* [0.x.44]*
   Clear all data fields and brings the class into a condition similar to   after having called the default constructor.  
* [0.x.45]*
   This class defines the type of data access for face integrals in loop ()   that is passed on to the `update_ghost_values` and `compress` functions   of the parallel vectors, with the purpose of being able to reduce the   amount of data that must be exchanged. The data exchange is a real   bottleneck in particular for high-degree DG methods, therefore a more   restrictive way of exchange is clearly beneficial. Note that this   selection applies to FEFaceEvaluation objects assigned to the exterior   side of cells accessing  [2.x.46]  only; all   [1.x.0] objects are available in any case.  
* [0.x.46]*
     The loop does not involve any FEFaceEvaluation access into neighbors,     as is the case with only boundary integrals (but no interior face     integrals) or when doing mass matrices in a  [2.x.47]      like setup.    
* [0.x.47]*
     The loop does only involve FEFaceEvaluation access into neighbors by     function values, such as  [2.x.48]  with     argument  [2.x.49]  but no access to shape function     derivatives (which typically need to access more data). For FiniteElement     types where only some of the shape functions have support on a face, such     as an FE_DGQ element with Lagrange polynomials with nodes on the element     surface, the data exchange is reduced from `(k+1)^dim` to     `(k+1)^(dim-1)`.    
* [0.x.48]*
     Same as above. To be used if data has to be accessed from exterior faces     if FEFaceEvaluation was reinitialized by providing the cell batch number     and a face number. This configuration is useful in the context of     cell-centric loops.          [2.x.50]   [2.x.51]  has to enabled.    
* [0.x.49]*
     The loop does involve FEFaceEvaluation access into neighbors by     function values and gradients, but no second derivatives, such as      [2.x.52]  with  [2.x.53]  and      [2.x.54]  set. For FiniteElement types where only some     of the shape functions have non-zero value and first derivative on a     face, such as an FE_DGQHermite element, the data exchange is reduced,     e.g. from `(k+1)^dim` to `2(k+1)^(dim-1)`. Note that for bases that do     not have this special property, the full neighboring data is sent anyway.    
* [0.x.50]*
     Same as above. To be used if data has to be accessed from exterior faces     if FEFaceEvaluation was reinitialized by providing the cell batch number     and a face number. This configuration is useful in the context of     cell-centric loops.          [2.x.55]   [2.x.56]  has to enabled.    
* [0.x.51]*
     General setup where the user does not want to make a restriction. This     is typically more expensive than the other options, but also the most     conservative one because the full data of elements behind the faces to     be computed locally will be exchanged.    
* [0.x.52]*
    [2.x.57]  2: Matrix-free loops  
* [0.x.53]*
   This method runs the loop over all cells (in parallel) and performs the   MPI data exchange on the source vector and destination vector.      [2.x.58]  cell_operation  [2.x.59]  with the signature <tt>cell_operation   (const MatrixFree<dim,Number> &, OutVector &, InVector &,    [2.x.60]  int,unsigned int> &)</tt> where the first argument   passes the data of the calling class and the last argument defines the   range of cells which should be worked on (typically more than one cell   should be worked on in order to reduce overheads).  One can pass a pointer   to an object in this place if it has an `operator()` with the correct set   of arguments since such a pointer can be converted to the function object.      [2.x.61]  dst Destination vector holding the result. If the vector is of   type  [2.x.62]  (or composite objects thereof   such as  [2.x.63]  the loop calls    [2.x.64]  at the end of the call   internally. For other vectors, including parallel Trilinos or PETSc   vectors, no such call is issued. Note that Trilinos/Epetra or PETSc   vectors do currently not work in parallel because the present class uses   MPI-local index addressing, as opposed to the global addressing implied   by those external libraries.      [2.x.65]  src Input vector. If the vector is of type    [2.x.66]  (or composite objects thereof such as    [2.x.67]  the loop calls    [2.x.68]  at the start of   the call internally to make sure all necessary data is locally   available. Note, however, that the vector is reset to its original state   at the end of the loop, i.e., if the vector was not ghosted upon entry of   the loop, it will not be ghosted upon finishing the loop.      [2.x.69]  zero_dst_vector If this flag is set to `true`, the vector `dst`   will be set to zero inside the loop. Use this case in case you perform a   typical `vmult()` operation on a matrix object, as it will typically be   faster than calling `dst = 0;` before the loop separately. This is   because the vector entries are set to zero only on subranges of the   vector, making sure that the vector entries stay in caches as much as   possible.  
* [0.x.54]*
   This is the second variant to run the loop over all cells, now providing   a function pointer to a member function of class `CLASS`. This method   obviates the need to define a lambda function or to call  [2.x.70]  to bind   the class into the given   function in case the local function needs to access data in the class   (i.e., it is a non-static member function).      [2.x.71]  cell_operation Pointer to member function of `CLASS` with the   signature <tt>cell_operation (const MatrixFree<dim,Number> &, OutVector &,   InVector &,  [2.x.72]  int,unsigned int> &)</tt> where the first   argument passes the data of the calling class and the last argument   defines the range of cells which should be worked on (typically more than   one cell should be worked on in order to reduce overheads).      [2.x.73]  owning_class The object which provides the `cell_operation`   call. To be compatible with this interface, the class must allow to call   `owning_class->cell_operation(...)`.      [2.x.74]  dst Destination vector holding the result. If the vector is of   type  [2.x.75]  (or composite objects thereof   such as  [2.x.76]  the loop calls    [2.x.77]  at the end of the call   internally. For other vectors, including parallel Trilinos or PETSc   vectors, no such call is issued. Note that Trilinos/Epetra or PETSc   vectors do currently not work in parallel because the present class uses   MPI-local index addressing, as opposed to the global addressing implied   by those external libraries.      [2.x.78]  src Input vector. If the vector is of type    [2.x.79]  (or composite objects thereof such as    [2.x.80]  the loop calls    [2.x.81]  at the start of   the call internally to make sure all necessary data is locally   available. Note, however, that the vector is reset to its original state   at the end of the loop, i.e., if the vector was not ghosted upon entry of   the loop, it will not be ghosted upon finishing the loop.      [2.x.82]  zero_dst_vector If this flag is set to `true`, the vector `dst`   will be set to zero inside the loop. Use this case in case you perform a   typical `vmult()` operation on a matrix object, as it will typically be   faster than calling `dst = 0;` before the loop separately. This is   because the vector entries are set to zero only on subranges of the   vector, making sure that the vector entries stay in caches as much as   possible.  
* [0.x.55]*
   Same as above, but for class member functions which are non-const.  
* [0.x.56]*
   This function is similar to the cell_loop with an  [2.x.83]  object to   specify to operation to be performed on cells, but adds two additional   functors to execute some additional work before and after the cell   integrals are computed.     The two additional functors work on a range of degrees of freedom,   expressed in terms of the degree-of-freedom numbering of the selected   DoFHandler `dof_handler_index_pre_post` in MPI-local indices. The   arguments to the functors represent a range of degrees of freedom at a   granularity of    [2.x.84]  entries   (except for the last chunk which is set to the number of locally owned   entries) in the form `[first, last)`. The idea of these functors is to   bring operations on vectors closer to the point where they accessed in a   matrix-free loop, with the goal to increase cache hits by temporal   locality. This loop guarantees that the `operation_before_loop` hits all   relevant unknowns before they are first touched in the cell_operation   (including the MPI data exchange), allowing to execute some vector update   that the `src` vector depends upon. The `operation_after_loop` is similar
* 

* 
* 

* 
* 

* 
* 
*  - it starts to execute on a range of DoFs once all DoFs in that range   have been touched for the last time by the `cell_operation`   (including the MPI data exchange), allowing e.g. to compute some vector   operations that depend on the result of the current cell loop in `dst` or   want to modify `src`. The efficiency of caching depends on the numbering   of the degrees of freedom because of the granularity of the ranges.      [2.x.85]  cell_operation Pointer to member function of `CLASS` with the   signature <tt>cell_operation (const MatrixFree<dim,Number> &, OutVector &,   InVector &,  [2.x.86]  int,unsigned int> &)</tt> where the first   argument passes the data of the calling class and the last argument   defines the range of cells which should be worked on (typically more than   one cell should be worked on in order to reduce overheads).      [2.x.87]  owning_class The object which provides the `cell_operation`   call. To be compatible with this interface, the class must allow to call   `owning_class->cell_operation(...)`.      [2.x.88]  dst Destination vector holding the result. If the vector is of   type  [2.x.89]  (or composite objects thereof   such as  [2.x.90]  the loop calls    [2.x.91]  at the end of the call   internally. For other vectors, including parallel Trilinos or PETSc   vectors, no such call is issued. Note that Trilinos/Epetra or PETSc   vectors do currently not work in parallel because the present class uses   MPI-local index addressing, as opposed to the global addressing implied   by those external libraries.      [2.x.92]  src Input vector. If the vector is of type    [2.x.93]  (or composite objects thereof such as    [2.x.94]  the loop calls    [2.x.95]  at the start of   the call internally to make sure all necessary data is locally   available. Note, however, that the vector is reset to its original state   at the end of the loop, i.e., if the vector was not ghosted upon entry of   the loop, it will not be ghosted upon finishing the loop.      [2.x.96]  operation_before_loop This functor can be used to perform an   operation on entries of the `src` and `dst` vectors (or other vectors)   before the operation on cells first touches a particular DoF according to   the general description in the text above. This function is passed a   range of the locally owned degrees of freedom on the selected   `dof_handler_index_pre_post` (in MPI-local numbering).      [2.x.97]  operation_after_loop This functor can be used to perform an   operation on entries of the `src` and `dst` vectors (or other vectors)   after the operation on cells last touches a particular DoF according to   the general description in the text above. This function is passed a   range of the locally owned degrees of freedom on the selected   `dof_handler_index_pre_post` (in MPI-local numbering).      [2.x.98]  dof_handler_index_pre_post Since MatrixFree can be initialized   with a vector of DoFHandler objects, each of them will in general have   vector sizes and thus different ranges returned to   `operation_before_loop` and `operation_after_loop`. Use this variable to   specify which one of the DoFHandler objects the index range should be   associated to. Defaults to the `dof_handler_index` 0.    
*  [2.x.99]  The close locality of the `operation_before_loop` and   `operation_after_loop` is currently only implemented for the MPI-only   case. In case threading is enabled, the complete `operation_before_loop`   is scheduled before the parallel loop, and `operation_after_loop` is   scheduled strictly afterwards, due to the complicated dependencies.  
* [0.x.57]*
   Same as above, but for class member functions which are non-const.  
* [0.x.58]*
   Same as above, but taking an  [2.x.100]  as the `cell_operation`   rather than a class member function.  
* [0.x.59]*
   This method runs a loop over all cells (in parallel) and performs the MPI   data exchange on the source vector and destination vector. As opposed to   the other variants that only runs a function on cells, this method also   takes as arguments a function for the interior faces and for the boundary   faces, respectively.      [2.x.101]  cell_operation  [2.x.102]  with the signature <tt>cell_operation   (const MatrixFree<dim,Number> &, OutVector &, InVector &,    [2.x.103]  int,unsigned int> &)</tt> where the first argument   passes the data of the calling class and the last argument defines the   range of cells which should be worked on (typically more than one cell   should be worked on in order to reduce overheads). One can pass a pointer   to an object in this place if it has an  [2.x.104]  with the   correct set of arguments since such a pointer can be converted to the   function object.      [2.x.105]  face_operation  [2.x.106]  with the signature <tt>face_operation   (const MatrixFree<dim,Number> &, OutVector &, InVector &,    [2.x.107]  int,unsigned int> &)</tt> in analogy to   `cell_operation`, but now the part associated to the work on interior   faces. Note that the MatrixFree framework treats periodic faces as interior   ones, so they will be assigned their correct neighbor after applying   periodicity constraints within the face_operation calls.      [2.x.108]  boundary_operation  [2.x.109]  with the signature   <tt>boundary_operation (const MatrixFree<dim,Number> &, OutVector &,   InVector &,  [2.x.110]  int,unsigned int> &)</tt> in analogy to   `cell_operation` and `face_operation`, but now the part associated to the   work on boundary faces. Boundary faces are separated by their   `boundary_id` and it is possible to query that id using    [2.x.111]  Note that both interior and faces use the   same numbering, and faces in the interior are assigned lower numbers than   the boundary faces.      [2.x.112]  dst Destination vector holding the result. If the vector is of   type  [2.x.113]  (or composite objects thereof   such as  [2.x.114]  the loop calls    [2.x.115]  at the end of the call   internally.      [2.x.116]  src Input vector. If the vector is of type    [2.x.117]  (or composite objects thereof such as    [2.x.118]  the loop calls    [2.x.119]  at the start of   the call internally to make sure all necessary data is locally   available. Note, however, that the vector is reset to its original state   at the end of the loop, i.e., if the vector was not ghosted upon entry of   the loop, it will not be ghosted upon finishing the loop.      [2.x.120]  zero_dst_vector If this flag is set to `true`, the vector `dst`   will be set to zero inside the loop. Use this case in case you perform a   typical `vmult()` operation on a matrix object, as it will typically be   faster than calling `dst = 0;` before the loop separately. This is   because the vector entries are set to zero only on subranges of the   vector, making sure that the vector entries stay in caches as much as   possible.      [2.x.121]  dst_vector_face_access Set the type of access into the vector   `dst` that will happen inside the body of the  [2.x.122]    function. As explained in the description of the DataAccessOnFaces   struct, the purpose of this selection is to reduce the amount of data   that must be exchanged over the MPI network (or via `memcpy` if within   the shared memory region of a node) to gain performance. Note that there   is no way to communicate this setting with the FEFaceEvaluation class,   therefore this selection must be made at this site in addition to what is   implemented inside the `face_operation` function. As a consequence, there   is also no way to check that the setting passed to this call is   consistent with what is later done by `FEFaceEvaluation`, and it is the   user's responsibility to ensure correctness of data.      [2.x.123]  src_vector_face_access Set the type of access into the vector   `src` that will happen inside the body of the  [2.x.124]  function,   in analogy to `dst_vector_face_access`.  
* [0.x.60]*
   This is the second variant to run the loop over all cells, interior   faces, and boundary faces, now providing three function pointers to   member functions of class  [2.x.125]  with the signature <code>operation   (const MatrixFree<dim,Number> &, OutVector &, InVector &,    [2.x.126]  int,unsigned int>&)const</code>. This method obviates   the need to define a lambda function or to call  [2.x.127]  to bind   the class into the given   function in case the local function needs to access data in the class   (i.e., it is a non-static member function).      [2.x.128]  cell_operation Pointer to member function of `CLASS` with the   signature <tt>cell_operation (const MatrixFree<dim,Number> &, OutVector &,   InVector &,  [2.x.129]  int,unsigned int> &)</tt> where the first   argument passes the data of the calling class and the last argument   defines the range of cells which should be worked on (typically more than   one cell should be worked on in order to reduce overheads). Note that the   loop will typically split the `cell_range` into smaller pieces and work   on `cell_operation`, `face_operation`, and `boundary_operation`   alternately, in order to increase the potential reuse of vector entries   in caches.      [2.x.130]  face_operation Pointer to member function of `CLASS` with the   signature <tt>face_operation (const MatrixFree<dim,Number> &, OutVector &,   InVector &,  [2.x.131]  int,unsigned int> &)</tt> in analogy to   `cell_operation`, but now the part associated to the work on interior   faces. Note that the MatrixFree framework treats periodic faces as   interior ones, so they will be assigned their correct neighbor after   applying periodicity constraints within the face_operation calls.      [2.x.132]  boundary_operation Pointer to member function of `CLASS` with the   signature <tt>boundary_operation (const MatrixFree<dim,Number> &, OutVector   &, InVector &,  [2.x.133]  int,unsigned int> &)</tt> in analogy to   `cell_operation` and `face_operation`, but now the part associated to the   work on boundary faces. Boundary faces are separated by their   `boundary_id` and it is possible to query that id using    [2.x.134]  Note that both interior and faces use the   same numbering, and faces in the interior are assigned lower numbers than   the boundary faces.      [2.x.135]  owning_class The object which provides the `cell_operation`   call. To be compatible with this interface, the class must allow to call   `owning_class->cell_operation(...)`, `owning_class->face_operation(...)`,   and `owning_class->boundary_operation(...)`.      [2.x.136]  dst Destination vector holding the result. If the vector is of   type  [2.x.137]  (or composite objects thereof   such as  [2.x.138]  the loop calls    [2.x.139]  at the end of the call   internally.      [2.x.140]  src Input vector. If the vector is of type    [2.x.141]  (or composite objects thereof such as    [2.x.142]  the loop calls    [2.x.143]  at the start of   the call internally to make sure all necessary data is locally   available. Note, however, that the vector is reset to its original state   at the end of the loop, i.e., if the vector was not ghosted upon entry of   the loop, it will not be ghosted upon finishing the loop.      [2.x.144]  zero_dst_vector If this flag is set to `true`, the vector `dst`   will be set to zero inside the loop. Use this case in case you perform a   typical `vmult()` operation on a matrix object, as it will typically be   faster than calling `dst = 0;` before the loop separately. This is   because the vector entries are set to zero only on subranges of the   vector, making sure that the vector entries stay in caches as much as   possible.      [2.x.145]  dst_vector_face_access Set the type of access into the vector   `dst` that will happen inside the body of the  [2.x.146]    function. As explained in the description of the DataAccessOnFaces   struct, the purpose of this selection is to reduce the amount of data   that must be exchanged over the MPI network (or via `memcpy` if within   the shared memory region of a node) to gain performance. Note that there   is no way to communicate this setting with the FEFaceEvaluation class,   therefore this selection must be made at this site in addition to what is   implemented inside the `face_operation` function. As a consequence, there   is also no way to check that the setting passed to this call is   consistent with what is later done by `FEFaceEvaluation`, and it is the   user's responsibility to ensure correctness of data.      [2.x.147]  src_vector_face_access Set the type of access into the vector   `src` that will happen inside the body of the  [2.x.148]  function,   in analogy to `dst_vector_face_access`.  
* [0.x.61]*
   Same as above, but for class member functions which are non-const.  
* [0.x.62]*
   This method runs the loop over all cells (in parallel) similarly as   cell_loop() does. However, this function is intended to be used   for the case if face and boundary integrals should be also   evaluated. In contrast to loop(), the user provides only a single function   that should contain the cell integral over a cell (or batch of cells when   vectorizing) and the face and boundary integrals over all its faces. This   is referred to in the literature as `element-centric loop` or `cell-centric   loop`.     To be able to evaluate all face integrals (with values or gradients   from the neighboring cells), all ghost values from neighboring cells are   updated. Use    [2.x.149]  face_no) to access quantities on arbitrary   faces of a cell and the respective neighbors.      [2.x.150]  cell_operation Pointer to member function of `CLASS` with the   signature <tt>cell_operation (const MatrixFree<dim,Number> &, OutVector &,   InVector &,  [2.x.151]  int,unsigned int> &)</tt> where the first   argument passes the data of the calling class and the last argument   defines the range of cells which should be worked on (typically more than   one cell is passed in from the loop in order to reduce overheads).      [2.x.152]  owning_class The object which provides the `cell_operation`   call. To be compatible with this interface, the class must allow to call   `owning_class->cell_operation(...)`.      [2.x.153]  dst Destination vector holding the result. If the vector is of   type  [2.x.154]  (or composite objects thereof   such as  [2.x.155]  the loop calls    [2.x.156]  at the end of the call   internally.      [2.x.157]  src Input vector. If the vector is of type    [2.x.158]  (or composite objects thereof such as    [2.x.159]  the loop calls    [2.x.160]  at the start of   the call internally to make sure all necessary data is locally   available. Note, however, that the vector is reset to its original state   at the end of the loop, i.e., if the vector was not ghosted upon entry of   the loop, it will not be ghosted upon finishing the loop.      [2.x.161]  zero_dst_vector If this flag is set to `true`, the vector `dst`   will be set to zero inside the loop. Use this case in case you perform a   typical `vmult()` operation on a matrix object, as it will typically be   faster than calling `dst = 0;` before the loop separately. This is   because the vector entries are set to zero only on subranges of the   vector, making sure that the vector entries stay in caches as much as   possible.      [2.x.162]  src_vector_face_access Set the type of access into the vector   `src` that will happen inside the body of the  [2.x.163]  function   during face integrals.   As explained in the description of the DataAccessOnFaces   struct, the purpose of this selection is to reduce the amount of data   that must be exchanged over the MPI network (or via `memcpy` if within   the shared memory region of a node) to gain performance. Note that there   is no way to communicate this setting with the FEFaceEvaluation class,   therefore this selection must be made at this site in addition to what is   implemented inside the `face_operation` function. As a consequence, there   is also no way to check that the setting passed to this call is   consistent with what is later done by `FEFaceEvaluation`, and it is the   user's responsibility to ensure correctness of data.  
* [0.x.63]*
   Same as above, but for the class member function which is non-const.  
* [0.x.64]*
   Same as above, but with  [2.x.164]   
* [0.x.65]*
   In the hp-adaptive case, a subrange of cells as computed during the cell   loop might contain elements of different degrees. Use this function to   compute what the subrange for an individual finite element degree is. The   finite element degree is associated to the vector component given in the   function call.  
* [0.x.66]*
   In the hp-adaptive case, a subrange of cells as computed during the cell   loop might contain elements of different degrees. Use this function to   compute what the subrange for a given index the hp-finite element, as   opposed to the finite element degree in the other function.  
* [0.x.67]*
   In the hp adaptive case, return number of active_fe_indices.  
* [0.x.68]*
   In the hp-adaptive case, return the active_fe_index of a cell range.  
* [0.x.69]*
   In the hp-adaptive case, return the active_fe_index of a face range.  
* [0.x.70]*
    [2.x.165]  3: Initialization of vectors  
* [0.x.71]*
   Initialize function for a general vector. The length of the vector is   equal to the total number of degrees in the DoFHandler. If the vector is   of class  [2.x.166]  the ghost entries   are set accordingly. For vector-valued problems with several DoFHandlers   underlying this class, the parameter  [2.x.167]  defines which   component is to be used.     For the vectors used with MatrixFree and in FEEvaluation, a vector needs   to hold all    [2.x.168]  "locally active DoFs"   and also some of the    [2.x.169]  "locally relevant DoFs".   The selection of DoFs is such that one can read all degrees of freedom on   all locally relevant elements (locally active) plus the degrees of freedom   that constraints expand into from the locally owned cells. However, not   all locally relevant DoFs are stored because most of them would never be   accessed in matrix-vector products and result in too much data sent   around which impacts the performance.  
* [0.x.72]*
   Initialize function for a distributed vector. The length of the vector is   equal to the total number of degrees in the DoFHandler. If the vector is   of class  [2.x.170]  the ghost entries   are set accordingly. For vector-valued problems with several DoFHandlers   underlying this class, the parameter  [2.x.171]  defines which   component is to be used.     For the vectors used with MatrixFree and in FEEvaluation, a vector needs   to hold all    [2.x.172]  "locally active DoFs"   and also some of the    [2.x.173]  "locally relevant DoFs".   The selection of DoFs is such that one can read all degrees of freedom on   all locally relevant elements (locally active) plus the degrees of freedom   that constraints expand into from the locally owned cells. However, not   all locally relevant DoFs are stored because most of them would never be   accessed in matrix-vector products and result in too much data sent   around which impacts the performance.  
* [0.x.73]*
   Return the partitioner that represents the locally owned data and the   ghost indices where access is needed to for the cell loop. The   partitioner is constructed from the locally owned dofs and ghost dofs   given by the respective fields. If you want to have specific information   about these objects, you can query them with the respective access   functions. If you just want to initialize a (parallel) vector, you should   usually prefer this data structure as the data exchange information can   be reused from one vector to another.  
* [0.x.74]*
   Return the set of cells that are owned by the processor.  
* [0.x.75]*
   Return the set of ghost cells needed but not owned by the processor.  
* [0.x.76]*
   Return a list of all degrees of freedom that are constrained. The list   is returned in MPI-local index space for the locally owned range of the   vector, not in global MPI index space that spans all MPI processors. To   get numbers in global index space, call   <tt>get_vector_partitioner()->local_to_global</tt> on an entry of the   vector. In addition, it only returns the indices for degrees of freedom   that are owned locally, not for ghosts.  
* [0.x.77]*
   Computes a renumbering of degrees of freedom that better fits with the   data layout in MatrixFree according to the given layout of data. Note that   this function does not re-arrange the information stored in this class,   but rather creates a renumbering for consumption of    [2.x.174]  To have any effect a MatrixFree object must be   set up again using the renumbered DoFHandler and AffineConstraints. Note   that if a DoFHandler calls  [2.x.175]  all information in   MatrixFree becomes invalid.  
* [0.x.78]*
    [2.x.176]  4: General information  
* [0.x.79]*
   Return whether a given FiniteElement  [2.x.177]  is supported by this class.  
* [0.x.80]*
   Return the number of different DoFHandlers specified at initialization.  
* [0.x.81]*
   For the finite element underlying the DoFHandler specified by  [2.x.178]    dof_handler_index, return the number of base elements.  
* [0.x.82]*
   Return the number of cells this structure is based on. If you are using a   usual DoFHandler, it corresponds to the number of (locally owned) active   cells. Note that most data structures in this class do not directly act   on this number but rather on n_cell_batches() which gives the number of   cells as seen when lumping several cells together with vectorization.  
* [0.x.83]*
    [2.x.179]  Use n_cell_batches() instead.  
* [0.x.84]*
   Return the number of cell batches that this structure works on. The   batches are formed by application of vectorization over several cells in   general. The cell range in  [2.x.180]  runs from zero to   n_cell_batches() (exclusive), so this is the appropriate size if you want   to store arrays of data for all cells to be worked on. This number is   approximately  [2.x.181]    (depending on how many cell batches that do not get filled up completely).  
* [0.x.85]*
   Return the number of additional cell batches that this structure keeps   for face integration. Note that not all cells that are ghosted in the   triangulation are kept in this data structure, but only the ones which   are necessary for evaluating face integrals from both sides.  
* [0.x.86]*
   Return the number of interior face batches that this structure works on.   The batches are formed by application of vectorization over several faces   in general. The face range in  [2.x.182]  runs from zero to   n_inner_face_batches() (exclusive), so this is the appropriate size if   you want to store arrays of data for all interior faces to be worked on.  
* [0.x.87]*
   Return the number of boundary face batches that this structure works on.   The batches are formed by application of vectorization over several faces   in general. The face range in  [2.x.183]  runs from n_inner_face_batches() to   n_inner_face_batches()+n_boundary_face_batches() (exclusive), so if you   need to store arrays that hold data for all boundary faces but not the   interior ones, this number gives the appropriate size.  
* [0.x.88]*
   Return the number of faces that are not processed locally but belong to   locally owned faces.  
* [0.x.89]*
   In order to apply different operators to different parts of the boundary,   this method can be used to query the boundary id of a given face in the   faces' own sorting by lanes in a VectorizedArray. Only valid for an index   indicating a boundary face.  
* [0.x.90]*
   Return the boundary ids for the faces within a cell, using the cells'   sorting by lanes in the VectorizedArray.  
* [0.x.91]*
   Return the DoFHandler with the index as given to the respective    [2.x.184]  argument in the reinit() function.  
* [0.x.92]*
   Return the DoFHandler with the index as given to the respective    [2.x.185]  argument in the reinit() function. Note that if you want to   call this function with a template parameter different than the default   one, you will need to use the `template` before the function call, i.e.,   you will have something like `matrix_free.template    [2.x.186]       [2.x.187]  Use the non-templated equivalent of this function.  
* [0.x.93]*
   Return the cell iterator in deal.II speak to a given cell batch   (populating several lanes in a VectorizedArray) and the lane index within   the vectorization across cells in the renumbering of this structure.     Note that the cell iterators in deal.II go through cells differently to   what the cell loop of this class does. This is because several cells are   processed together (vectorization across cells), and since cells with   neighbors on different MPI processors need to be accessed at a certain   time when accessing remote data and overlapping communication with   computation.  
* [0.x.94]*
   This returns the level and index for the cell that would be returned by   get_cell_iterator() for the same arguments `cell_batch_index` and   `lane_index`.  
* [0.x.95]*
   Return the cell iterator in deal.II speak to an interior/exterior cell of   a face in a pair of a face batch and lane index. The second element of   the pair is the face number so that the face iterator can be accessed:   `pair.first()->face(pair.second());`     Note that the face iterators in deal.II go through cells differently to   what the face/boundary loop of this class does. This is because several   faces are worked on together (vectorization), and since faces with neighbor   cells on different MPI processors need to be accessed at a certain time   when accessing remote data and overlapping communication with computation.  
* [0.x.96]*
    [2.x.188]   [2.x.189]       [2.x.190]  Use get_cell_iterator() instead.  
* [0.x.97]*
   Since this class uses vectorized data types with usually more than one   value in the data field, a situation might occur when some components of   the vector type do not correspond to an actual cell in the mesh. When   using only this class, one usually does not need to bother about that   fact since the values are padded with zeros. However, when this class is   mixed with deal.II access to cells, care needs to be taken. This function   returns  [2.x.191]  if not all `n_lanes` cells for the given   `cell_batch_index` correspond to actual cells of the mesh and some are   merely present for padding reasons. To find out how many cells are   actually used, use the function n_active_entries_per_cell_batch().  
* [0.x.98]*
    [2.x.192]  Use n_active_entries_per_cell_batch() instead.  
* [0.x.99]*
   This query returns how many cells among the  [2.x.193]    many cells within a cell batch to actual cells in the mesh, rather than   being present for padding reasons. For most given cell batches in   n_cell_batches(), this number is equal to  [2.x.194]    but there might be one or a few cell batches in the mesh (where the   numbers do not add up) where only some of the cells within a batch are   used, indicated by the function at_irregular_cell().  
* [0.x.100]*
   Use this function to find out how many faces over the length of   vectorization data types correspond to real faces (both interior and   boundary faces, as those use the same indexing but with different ranges)   in the mesh. For most given indices in n_inner_faces_batches() and   n_boundary_face_batches(), this is just  [2.x.195]  many, but   there might be one or a few meshes (where the numbers do not add up)   where there are less such lanes filled.  
* [0.x.101]*
   Return the number of degrees of freedom per cell for a given hp-index.  
* [0.x.102]*
   Return the number of quadrature points per cell for a given hp-index.  
* [0.x.103]*
   Return the number of degrees of freedom on each face of the cell for   given hp-index.  
* [0.x.104]*
   Return the number of quadrature points on each face of the cell for   given hp-index.  
* [0.x.105]*
   Return the quadrature rule for given hp-index.  
* [0.x.106]*
   Return the quadrature rule for given hp-index.  
* [0.x.107]*
   Return the category the current batch of cells was assigned to. Categories   run between the given values in the field    [2.x.196]  for non-hp-DoFHandler types   and return the active FE index in the hp-adaptive case.  
* [0.x.108]*
   Return the category on the cells on the two sides of the current batch of   faces.  
* [0.x.109]*
   Queries whether or not the indexation has been set.  
* [0.x.110]*
   Queries whether or not the geometry-related information for the cells has   been set.  
* [0.x.111]*
   Return the level of the mesh to be worked on. Returns    [2.x.197]  if working on active cells.  
* [0.x.112]*
   Return an approximation of the memory consumption of this class in   bytes.  
* [0.x.113]*
   Prints a detailed summary of memory consumption in the different   structures of this class to the given output stream.  
* [0.x.114]*
   Prints a summary of this class to the given output stream. It is focused   on the indices, and does not print all the data stored.  
* [0.x.115]*
    [2.x.198]  5: Access of internal data structure     Note: Expert mode, interface not stable between releases.  
* [0.x.116]*
   Return information on task graph.  
* [0.x.117]   Return geometry-dependent information on the cells.  
* [0.x.118]*
   Return information on indexation degrees of freedom.  
* [0.x.119]*
   Return the number of weights in the constraint pool.  
* [0.x.120]*
   Return a pointer to the first number in the constraint pool data with   index  [2.x.199]  (to be used together with  [2.x.200]   
* [0.x.121]*
   Return a pointer to one past the last number in the constraint pool data   with index  [2.x.201]  (to be used together with  [2.x.202]    constraint_pool_begin()).  
* [0.x.122]*
   Return the unit cell information for given hp-index.  
* [0.x.123]*
   Return the connectivity information of a face.  
* [0.x.124]*
   Return the table that translates a triple of the macro cell number,   the index of a face within a cell and the index within the cell batch of   vectorization into the index within the faces array.  
* [0.x.125]*
   Obtains a scratch data object for internal use. Make sure to release it   afterwards by passing the pointer you obtain from this object to the   release_scratch_data() function. This interface is used by FEEvaluation   objects for storing their data structures.     The organization of the internal data structure is a thread-local storage   of a list of vectors. Multiple threads will each get a separate storage   field and separate vectors, ensuring thread safety. The mechanism to   acquire and release objects is similar to the mechanisms used for the   local contributions of WorkStream, see    [2.x.203]  "the WorkStream paper".  
* [0.x.126]*
   Makes the object of the scratchpad available again.  
* [0.x.127]*
   Obtains a scratch data object for internal use. Make sure to release it   afterwards by passing the pointer you obtain from this object to the   release_scratch_data_non_threadsafe() function. Note that, as opposed to   acquire_scratch_data(), this method can only be called by a single thread   at a time, but opposed to the acquire_scratch_data() it is also possible   that the thread releasing the scratch data can be different than the one   that acquired it.  
* [0.x.128]*
   Makes the object of the scratch data available again.  
* [0.x.129]*
   This is the actual reinit function that sets up the indices for the   DoFHandler case.  
* [0.x.130]*
   Initializes the fields in DoFInfo together with the constraint pool that   holds all different weights in the constraints (not part of DoFInfo   because several DoFInfo classes can have the same weights which   consequently only need to be stored once).  
* [0.x.131]*
   Initializes the DoFHandlers based on a DoFHandler<dim> argument.  
* [0.x.132]*
   Pointers to the DoFHandlers underlying the current problem.  
* [0.x.133]*
   Contains the information about degrees of freedom on the individual cells   and constraints.  
* [0.x.134]*
   Contains the weights for constraints stored in DoFInfo. Filled into a   separate field since several vector components might share similar   weights, which reduces memory consumption. Moreover, it obviates template   arguments on DoFInfo and keeps it a plain field of indices only.  
* [0.x.135]*
   Contains an indicator to the start of the ith index in the constraint   pool data.  
* [0.x.136]*
   Holds information on transformation of cells from reference cell to real   cell that is needed for evaluating integrals.  
* [0.x.137]*
   Contains shape value information on the unit cell.  
* [0.x.138]*
   Describes how the cells are gone through. With the cell level (first   index in this field) and the index within the level, one can reconstruct   a deal.II cell iterator and use all the traditional things deal.II offers   to do with cell iterators.  
* [0.x.139]*
   For discontinuous Galerkin, the cell_level_index includes cells that are   not on the local processor but that are needed to evaluate the cell   integrals. In cell_level_index_end_local, we store the number of local   cells.  
* [0.x.140]*
   Stores the basic layout of the cells and faces to be treated, including   the task layout for the shared memory parallelization and possible   overlaps between communications and computations with MPI.  
* [0.x.141]*
   Vector holding face information. Only initialized if   build_face_info=true.  
* [0.x.142]*
   Stores whether indices have been initialized.  
* [0.x.143]*
   Stores whether indices have been initialized.  
* [0.x.144]*
   Scratchpad memory for use in evaluation. We allow more than one   evaluation object to attach to this field (this, the outer    [2.x.204]  so we need to keep tracked of whether a certain data   field is already used (first part of pair) and keep a list of   objects.  
* [0.x.145]*
   Scratchpad memory for use in evaluation and other contexts, non-thread   safe variant.  
* [0.x.146]*
   Stored the level of the mesh to be worked on.  
* [0.x.147]*
   Internal class for exchanging data between vectors.  
* [0.x.148]*
     Constructor. Takes MF data, flag for face access in DG and     number of components.    
* [0.x.149]*
     Destructor.    
* [0.x.150]*
     Go through all components in MF object and choose the one     whose partitioner is compatible with the Partitioner in this component.    
* [0.x.151]*
     Get partitioner for the given  [2.x.205]  taking into     account vector_face_access set in constructor.    
* [0.x.152]*
     Start update_ghost_value for serial vectors    
* [0.x.153]*
     Start update_ghost_value for vectors that do not support     the split into _start() and finish() stages    
* [0.x.154]*
     Start update_ghost_value for vectors that _do_ support     the split into _start() and finish() stages, but don't support     exchange on a subset of DoFs    
* [0.x.155]*
     Finally, start update_ghost_value for vectors that _do_ support     the split into _start() and finish() stages and also support     exchange on a subset of DoFs,     i.e.  [2.x.206]     
* [0.x.156]*
     Finish update_ghost_value for vectors that do not support     the split into _start() and finish() stages and serial vectors    
* [0.x.157]*
     Finish update_ghost_value for vectors that _do_ support     the split into _start() and finish() stages, but don't support     exchange on a subset of DoFs    
* [0.x.158]*
     Finish update_ghost_value for vectors that _do_ support     the split into _start() and finish() stages and also support     exchange on a subset of DoFs,     i.e.  [2.x.207]     
* [0.x.159]*
     Start compress for serial vectors    
* [0.x.160]*
     Start compress for vectors that do not support     the split into _start() and finish() stages    
* [0.x.161]*
     Start compress for vectors that _do_ support     the split into _start() and finish() stages, but don't support     exchange on a subset of DoFs    
* [0.x.162]*
     Start compress for vectors that _do_ support     the split into _start() and finish() stages and also support     exchange on a subset of DoFs,     i.e.  [2.x.208]     
* [0.x.163]*
     Finish compress for vectors that do not support     the split into _start() and finish() stages and serial vectors    
* [0.x.164]*
     Finish compress for vectors that _do_ support     the split into _start() and finish() stages, but don't support     exchange on a subset of DoFs    
* [0.x.165]*
     Start compress for vectors that _do_ support     the split into _start() and finish() stages and also support     exchange on a subset of DoFs,     i.e.  [2.x.209]     
* [0.x.166]*
     Reset all ghost values for serial vectors    
* [0.x.167]*
     Reset all ghost values for vector that don't support     exchange on a subset of DoFs    
* [0.x.168]*
     Reset all ghost values for vector that _do_ support     exchange on a subset of DoFs, i.e.      [2.x.210]     
* [0.x.169]*
     Zero out vector region for vector that _do_ support     exchange on a subset of DoFs <==> begin() + ind == local_element(ind),     i.e.  [2.x.211]     
* [0.x.170]*
     Zero out vector region for vector that do _not_ support exchange on a     subset of DoFs <==> begin() + ind == local_element(ind) but are still a     vector type    
* [0.x.171]*
     Zero out vector region for non-vector types, i.e., classes that do not     have  [2.x.212]     
* [0.x.172]*
   An internal class to convert three function pointers to the   scheme with virtual functions above.  
* [0.x.173]

include/deal.II-translator/matrix_free/operators_0.txt
[0.x.0]*
   Abstract base class for matrix-free operators which can be used both at   the finest mesh or at a certain level in geometric multigrid.     A derived class has to implement apply_add() method as well as   compute_diagonal() to initialize the protected member   inverse_diagonal_entries and/or diagonal_entries. In case of a   non-symmetric operator, Tapply_add() should be additionally implemented.     Currently, the only supported vectors are    [2.x.0]  and    [2.x.1]      [1.x.0]     MatrixFree allows to use several DoFHandler/AffineConstraints combinations   by passing a  [2.x.2]  with pointers to the respective objects into   the  [2.x.3]  function. This class supports to select only some   of the blocks in the underlying MatrixFree object by optional integer   lists that specify the chosen blocks.     One application of constructing a matrix-free operator only on selected   blocks would be the setting of the  [2.x.4]  tutorial program: This   problem has three [1.x.1], one for the velocity, one for the   pressure, and one for temperature. The time lag scheme used for temporal   evolution splits the temperature equation away from the Stokes system in   velocity and pressure. However, there are cross terms like the velocity   that enters the temperature advection-diffusion equation or the   temperature that enters the right hand side of the velocity. In order to   be sure that MatrixFree uses the same integer indexing to the different   blocks, one needs to put all the three blocks into the same MatrixFree   object. However, when solving a linear system the operators involved   either address the first two in the Stokes solver, or the last one for   the temperature solver. In the former case, a BlockVector of two   components would be selected with a vector selecting the blocks {0, 1} in   MatrixFree, whereas in the latter, a non-block vector selecting the block   {2} would be used.     A second application of selection is in problems with a Newton-type   iteration or problems with inhomogeneous boundary conditions. In such a   case, one has to deal with two different sets of constraints: One set of   constraints applies to the solution vector which might include hanging   node constraints or periodicity constraints but no constraints on   inhomogeneous Dirichlet boundaries. Before the nonlinear iteration, the   boundary values are set to the expected value in the vector, representing   the initial guess. In each iteration of the Newton method, a linear   system subject to zero Dirichlet boundary conditions is solved that is   then added to the initial guess. This setup can be realized by using a   vector of two pointers pointing to the same DoFHandler object and a   vector of two pointers to the two AffineConstraints objects. If the first   AffineConstraints object is the one including the zero Dirichlet   constraints, one would give a  [2.x.5]  int>(1, 0) to the   initialize() function, i.e., a vector of length 1 that selects exactly the   first AffineConstraints object with index 0.     For systems of PDEs where the different blocks of MatrixFree are   associated with different physical components of the equations, adding   another block with a different AffineConstraints argument solely for the   purpose of boundary conditions might lead to cumbersome index   handling. Instead, one could set up a second MatrixFree instance with the   different AffineConstraints object but the same interpretation of blocks,   and use that for interpolating inhomogeneous boundary conditions (see also   the discussion in the results section of the  [2.x.6]  tutorial program):    
* [1.x.2]
*   
* [0.x.1]*
     Number alias.    
* [0.x.2]*
     size_type needed for preconditioner classes.    
* [0.x.3]*
     Default constructor.    
* [0.x.4]*
     Virtual destructor.    
* [0.x.5]*
     Release all memory and return to a state just like after having called     the default constructor.    
* [0.x.6]*
     Initialize operator on fine scale.         The optional selection vector allows to choose only some components     from the underlying MatrixFree object, e.g. just a single one. The     entry  [2.x.7]  in the vector chooses the DoFHandler     and AffineConstraints object that was given as the      [2.x.8]  argument to the  [2.x.9]  call.     Different arguments for rows and columns also make it possible to     select non-diagonal blocks or rectangular blocks. If the row vector is     empty, all components are selected, otherwise its size must be smaller     or equal to  [2.x.10]  and all indices need to be     unique and within the range of 0 and  [2.x.11]  If the     column selection vector is empty, it is taken the same as the row     selection, defining a diagonal block.    
* [0.x.7]*
     Initialize operator on a level  [2.x.12]  for a single FiniteElement.         The optional selection vector allows to choose only some components     from the underlying MatrixFree object, e.g. just a single one. The     entry  [2.x.13]  in the vector chooses the DoFHandler     and AffineConstraints object that was given as the      [2.x.14]  argument to the  [2.x.15]  call.     Since a multigrid operator is always associated to inverting a matrix     and thus represents a diagonal block, the same vector for rows and     columns is used as opposed to the non-level initialization function. If     empty, all components are selected.    
* [0.x.8]*
     Initialize operator on a level  [2.x.16]  for multiple FiniteElement     objects.         The optional selection vector allows to choose only some components     from the underlying MatrixFree object, e.g. just a single one. The     entry  [2.x.17]  in the vector chooses the DoFHandler     and AffineConstraints object that was given as the      [2.x.18]  argument to the  [2.x.19]  call.     Since a multigrid operator is always associated to inverting a matrix     and thus represents a diagonal block, the same vector for rows and     columns is used as opposed to the non-level initialization function. If     empty, all components are selected.    
* [0.x.9]*
     Return the dimension of the codomain (or range) space.    
* [0.x.10]*
     Return the dimension of the domain space.    
* [0.x.11]*
     vmult operator for interface.    
* [0.x.12]*
     vmult operator for interface.    
* [0.x.13]*
     Matrix-vector multiplication.    
* [0.x.14]*
     Transpose matrix-vector multiplication.    
* [0.x.15]*
     Adding Matrix-vector multiplication.    
* [0.x.16]*
     Adding transpose matrix-vector multiplication.    
* [0.x.17]*
     Return the value of the matrix entry (row,col). In matrix-free context     this function is valid only for row==col when diagonal is initialized.    
* [0.x.18]*
     Determine an estimate for the memory consumption (in bytes) of this     object.    
* [0.x.19]*
     A wrapper for initialize_dof_vector() of MatrixFree object.    
* [0.x.20]*
     Compute diagonal of this operator.         A derived class needs to implement this function and resize and fill     the protected member inverse_diagonal_entries and/or diagonal_entries     accordingly.    
* [0.x.21]*
     Get read access to the MatrixFree object stored with this operator.    
* [0.x.22]*
     Get read access to the inverse diagonal of this operator.    
* [0.x.23]*
     Get read access to the diagonal of this operator.    
* [0.x.24]*
     Apply the Jacobi preconditioner, which multiplies every element of the     <tt>src</tt> vector by the inverse of the respective diagonal element and     multiplies the result with the relaxation factor <tt>omega</tt>.    
* [0.x.25]*
     Perform necessary operations related to constraints before calling     apply_add() or Tapply_add() inside mult_add().    
* [0.x.26]*
     Perform necessary operations related to constraints after calling     apply_add() or Tapply_add() inside mult_add().    
* [0.x.27]*
     Set constrained entries (both from hanging nodes and edge constraints)     of  [2.x.20]  to one.    
* [0.x.28]*
     Apply operator to  [2.x.21]  and add result in  [2.x.22]     
* [0.x.29]*
     Apply transpose operator to  [2.x.23]  and add result in  [2.x.24]          Default implementation is to call apply_add().    
* [0.x.30]*
     MatrixFree object to be used with this operator.    
* [0.x.31]*
     A shared pointer to a diagonal matrix that stores the     diagonal elements as a vector.    
* [0.x.32]*
     A shared pointer to a diagonal matrix that stores the inverse of     diagonal elements as a vector.    
* [0.x.33]*
     A vector which defines the selection of sub-components of MatrixFree     for the rows of the matrix representation.    
* [0.x.34]*
     A vector which defines the selection of sub-components of MatrixFree     for the columns of the matrix representation.    
* [0.x.35]*
     Indices of DoFs on edge in case the operator is used in GMG context.    
* [0.x.36]*
     Auxiliary vector.    
* [0.x.37]*
     A flag which determines whether or not this operator has interface     matrices in GMG context.    
* [0.x.38]*
     %Function which implements vmult_add ( [2.x.25]  = false) and     Tvmult_add ( [2.x.26]  = true).    
* [0.x.39]*
     Adjust the ghost range of the vectors to the storage requirements of     the underlying MatrixFree class. This is used inside the mult_add() as     well as vmult_interface_up() and vmult_interface_down() methods in     order to ensure that the cell loops will be able to access the ghost     indices with the correct local indices.    
* [0.x.40]*
   Auxiliary class to provide interface vmult/Tvmult methods required in   adaptive geometric multgrids.  [2.x.27]  class should be derived   from  [2.x.28]  class.     The adaptive multigrid realization in deal.II implements an approach   called local smoothing. This means that the smoothing on the finest level   only covers the local part of the mesh defined by the fixed (finest) grid   level and ignores parts of the computational domain where the terminal   cells are coarser than this level. As the method progresses to coarser   levels, more and more of the global mesh will be covered. At some coarser   level, the whole mesh will be covered. Since all level matrices in the   multigrid method cover a single level in the mesh, no hanging nodes   appear on the level matrices. At the interface between multigrid levels,   homogeneous Dirichlet boundary conditions are set while smoothing. When   the residual is transferred to the next coarser level, however, the   coupling over the multigrid interface needs to be taken into account.   This is done by the so-called interface (or edge) matrices that compute   the part of the residual that is missed by the level matrix with   homogeneous Dirichlet conditions. We refer to the    [2.x.29]  "Multigrid paper by Janssen and Kanschat"   for more details.     For the implementation of those interface matrices, most infrastructure   is already in place and provided by  [2.x.30]  through the   two multiplication routines vmult_interface_down() and   vmult_interface_up(). The only thing MGInterfaceOperator does is   wrapping those operations and make them accessible via    [2.x.31]  and  [2.x.32]  interface as expected by the multigrid routines   (that were originally written for matrices, hence expecting those names).   Note that the vmult_interface_down is used during the restriction phase of   the multigrid V-cycle, whereas vmult_interface_up is used during the   prolongation phase.  
* [0.x.41]*
     Number alias.    
* [0.x.42]*
     Size type.    
* [0.x.43]*
     Default constructor.    
* [0.x.44]*
     Clear the pointer to the OperatorType object.    
* [0.x.45]*
     Initialize this class with an operator  [2.x.33]     
* [0.x.46]*
     vmult operator, see class description for more info.    
* [0.x.47]*
     Tvmult operator, see class description for more info.    
* [0.x.48]*
     A wrapper for initialize_dof_vector() of OperatorType object.    
* [0.x.49]*
     Const pointer to the operator class.    
* [0.x.50]*
   This class implements the operation of the action of the inverse of a   mass matrix on an element for the special case of an evaluation object   with as many quadrature points as there are cell degrees of freedom. It   uses algorithms from FEEvaluation and produces the exact mass matrix for   DGQ elements. This algorithm uses tensor products of inverse 1D shape   matrices over quadrature points, so the inverse operation is exactly as   expensive as applying the forward operator on each cell. Of course, for   continuous finite elements this operation does not produce the inverse of   a mass operation as the coupling between the elements cannot be   considered by this operation.     The equation may contain variable coefficients, so the user is required   to provide an array for the inverse of the local coefficient (this class   provide a helper method 'fill_inverse_JxW_values' to get the inverse of a   constant-coefficient operator).  
* [0.x.51]*
     Constructor. Initializes the shape information from the ShapeInfo field     in the class FEEval.    
* [0.x.52]*
     Applies the inverse mass matrix operation on an input array. It is     assumed that the passed input and output arrays are of correct size,     namely  [2.x.34]  long. The inverse of the     local coefficient (also containing the inverse JxW values) must be     passed as first argument. Passing more than one component in the     coefficient is allowed.    
* [0.x.53]*
     Applies the inverse mass matrix operation on an input array, using the     inverse of the JxW values provided by the `fe_eval` argument passed to     the constructor of this class. Note that the user code must call      [2.x.35]  on the underlying evaluator to make the      [2.x.36]  method return the information of the correct     cell. It is assumed that the pointers of the input and output arrays     are valid over the length  [2.x.37]  which is the     number of entries processed by this function. The `in_array` and     `out_array` arguments may point to the same memory position.    
* [0.x.54]*
     This operation performs a projection from the data given in quadrature     points to the actual basis underlying this object. This projection can     also be interpreted as a change of the basis from the Lagrange     interpolation polynomials in the quadrature points to the     basis underlying the current `fe_eval` object.         Calling this function on an array as    
* [1.x.3]
*      is equivalent to    
* [1.x.4]
*      provided that  [2.x.38]  holds the inverse of the quadrature     weights and no additional coefficients. This setup highlights the     underlying projection, testing a right hand side and applying an     inverse mass matrix. This function works both for the scalar case as     described in the example or for multiple components that are laid out     component by component.         Compared to the more verbose alternative, the given procedure is     considerably faster because it can bypass the  [2.x.39]  step     and the first half of the transformation to the quadrature points,     reducing the number of tensor product calls from 3*dim*n_components to     dim*n_components.    
* [0.x.55]*
     Fills the given array with the inverse of the JxW values, i.e., a mass     matrix with coefficient 1. Non-unit coefficients must be multiplied (in     inverse form) to this array.    
* [0.x.56]*
     A reference to the FEEvaluation object for getting the JxW_values.    
* [0.x.57]*
   This class implements the operation of the action of a mass matrix.     Note that this class only supports the non-blocked vector variant of the   Base operator because only a single FEEvaluation object is used in the   apply function.  
* [0.x.58]*
     Number alias.    
* [0.x.59]*
     size_type needed for preconditioner classes.    
* [0.x.60]*
     Constructor.    
* [0.x.61]*
     For preconditioning, we store a lumped mass matrix at the diagonal     entries.    
* [0.x.62]*
     Applies the mass matrix operation on an input vector. It is     assumed that the passed input and output vector are correctly initialized     using initialize_dof_vector().    
* [0.x.63]*
     For this operator, there is just a cell contribution.    
* [0.x.64]*
   This class implements the operation of the action of a Laplace matrix,   namely  [2.x.40] , where  [2.x.41]  is   the scalar heterogeneity coefficient.     Note that this class only supports the non-blocked vector variant of the   Base operator because only a single FEEvaluation object is used in the   apply function.  
* [0.x.65]*
     Number alias.    
* [0.x.66]*
     size_type needed for preconditioner classes.    
* [0.x.67]*
     Constructor.    
* [0.x.68]*
     The diagonal is approximated by computing a local diagonal matrix per     element and distributing it to the global diagonal. This will lead to     wrong results on element with hanging nodes but is still an acceptable     approximation to be used in preconditioners.    
* [0.x.69]*
     Set the heterogeneous scalar coefficient  [2.x.42]  to be     used at the quadrature points. The Table needs to have as many rows as     there are cell batches in the underlying MatrixFree object,      [2.x.43]  The number of batches is related to the     fact that the matrix-free operators do not work on individual cells,     but instead of batches of cells at once due to vectorization. The Table     can take two different numbers of columns.  One case is to select it     equal to the total number of quadrature points in `dim` dimensions,     which is the `dim`th power of the `n_q_points_1d` template     parameter. Here, `(*scalar_coefficient)(cell,q)` corresponds to the     value of the coefficient on cell batch `cell` and quadrature point     index `q`. The second supported variant is a Table with a single     column, in which case the same variable coefficient value is used at     all quadrature points of a cell.         Such tables can be initialized by    
* [1.x.5]
*      where  [2.x.44]  is a MatrixFree object and      [2.x.45]  is a function which provides the following method     <code>VectorizedArray<double> value(const Point<dim,     VectorizedArray<double> > &p_vec)</code>.         If this function is not called, the coefficient is assumed to be unity.         The argument to this function is a shared pointer to such a table. The     class stores the shared pointer to this table, not a deep copy     and uses it to form the Laplace matrix. Consequently, you can update the     table and re-use the current object to obtain the action of a Laplace     matrix with this updated coefficient. Alternatively, if the table values     are only to be filled once, the original shared pointer can also go out     of scope in user code and the clear() command or destructor of this class     will delete the table.    
* [0.x.70]*
     Resets all data structures back to the same state as for a newly     constructed object.    
* [0.x.71]*
     Read/Write access to coefficients to be used in Laplace operator.         The function will throw an error if coefficients are not previously set     by set_coefficient() function.    
* [0.x.72]*
     Applies the laplace matrix operation on an input vector. It is     assumed that the passed input and output vector are correctly initialized     using initialize_dof_vector().    
* [0.x.73]*
     Applies the Laplace operator on a cell.    
* [0.x.74]*
     Apply diagonal part of the Laplace operator on a cell.    
* [0.x.75]*
     Apply Laplace operator on a cell  [2.x.46]     
* [0.x.76]*
     User-provided heterogeneity coefficient.    
* [0.x.77]

include/deal.II-translator/matrix_free/shape_info.templates_0.txt
[0.x.0]

include/deal.II-translator/matrix_free/shape_info_0.txt
[0.x.0]*
     An enum that encodes the type of element detected during     initialization. FEEvaluation will select the most efficient algorithm     based on the given element type.         There is an implied ordering in the type  [2.x.0]      in the sense that both  [2.x.1]  and      [2.x.2]  are also of type      [2.x.3]  Likewise, a configuration of type      [2.x.4]  is also of type      [2.x.5]  As a consequence, we support `<=`     operations between the types with this sorting, but not against the     even higher indexed types such as  [2.x.6]         
*  [2.x.7]     
* [0.x.1]*
       Tensor product shape function where the shape value evaluation in the       quadrature point corresponds to the identity operation and no       interpolation needs to be performed (collocation approach, also       called spectral evaluation). This is for example the case for an       element with nodes in the Gauss-Lobatto support points and       integration in the Gauss-Lobatto quadrature points of the same order.      
* [0.x.2]*
       Symmetric tensor product shape functions fulfilling a Hermite       identity with values and first derivatives zero at the element end       points in 1D.      
* [0.x.3]*
       Usual tensor product shape functions whose shape values and       quadrature points are symmetric about the midpoint of the unit       interval 0.5      
* [0.x.4]*
       Tensor product shape functions without further particular properties      
* [0.x.5]*
       Polynomials of complete degree rather than tensor degree which can be       described by a truncated tensor product      
* [0.x.6]*
       Tensor product shape functions that are symmetric about the midpoint       of the unit interval 0.5 that additionally add a constant shape       function according to FE_Q_DG0.      
* [0.x.7]*
       Shape functions without an tensor product properties.      
* [0.x.8]*
     This struct stores the shape functions, their gradients and Hessians     evaluated for a one-dimensional section of a tensor product finite     element and tensor product quadrature formula in reference     coordinates. This data structure also includes the evaluation of     quantities at the cell boundary and on the sub-interval  [2.x.8]  and      [2.x.9]  for face integrals.    
* [0.x.9]*
       Empty constructor. Sets default configuration.      
* [0.x.10]*
       Return the memory consumption of this class in bytes.      
* [0.x.11]*
       Encodes the type of element detected at construction. FEEvaluation       will select the most efficient algorithm based on the given element       type.      
* [0.x.12]*
       Stores the shape values of the 1D finite element evaluated on all 1D       quadrature points. The length of       this array is <tt>n_dofs_1d n_q_points_1d</tt> and quadrature       points are the index running fastest.      
* [0.x.13]*
       Stores the shape gradients of the 1D finite element evaluated on all       1D quadrature points. The length of       this array is <tt>n_dofs_1d n_q_points_1d</tt> and quadrature       points are the index running fastest.      
* [0.x.14]*
       Stores the shape Hessians of the 1D finite element evaluated on all       1D quadrature points. The length of       this array is <tt>n_dofs_1d n_q_points_1d</tt> and quadrature       points are the index running fastest.      
* [0.x.15]*
       Stores the shape gradients of the shape function space associated to       the quadrature (collocation), given by FE_DGQ<1>(Quadrature<1>).      
* [0.x.16]*
       Stores the shape hessians of the shape function space associated to       the quadrature (collocation), given by FE_DGQ<1>(Quadrature<1>).      
* [0.x.17]*
       Stores the shape values in a different format, namely the so-called       even-odd scheme where the symmetries in shape_values are used for       faster evaluation.      
* [0.x.18]*
       Stores the shape gradients in a different format, namely the so-       called even-odd scheme where the symmetries in shape_gradients are       used for faster evaluation.      
* [0.x.19]*
       Stores the shape second derivatives in a different format, namely the       so-called even-odd scheme where the symmetries in shape_hessians are       used for faster evaluation.      
* [0.x.20]*
       Stores the shape gradients of the shape function space associated to       the quadrature (collocation), given by FE_DGQ<1>(Quadrature<1>). This       array provides an alternative representation of the       shape_gradients_collocation field in the even-odd format.      
* [0.x.21]*
       Stores the shape hessians of the shape function space associated to       the quadrature (collocation), given by FE_DGQ<1>(Quadrature<1>). This       array provides an alternative representation of the       shape_hessians_collocation field in the even-odd format.      
* [0.x.22]*
       Stores the inverse transformation from the data at quadrature points       to the basis defined by the shape_values fields. The data at       quadrature points is interpreted either implicitly by its polynomial       interpolation, or explicitly in terms of separate polynomials such as       with the `_collocation` fields. The size of the array equals the       layout of the `shape_values` array, and it is combined with the shape       values array such that this matrix is the pseudo inverse of       shape_values. In case the number of 1D quadrature points equals the       size of the basis, this array is exactly the inverse of the       shape_values array. The length of this array is <tt>n_dofs_1d       n_q_points_1d</tt> and quadrature points are the index running       fastest.      
* [0.x.23]*
       Stores the even-odd variant of the `inverse_shape_values` field.      
* [0.x.24]*
       Collects all data of 1D shape values evaluated at the point 0 and 1       (the vertices) in one data structure. Sorting is first the values,       then gradients, then second derivatives.      
* [0.x.25]*
       Collects all data of 1D nodal shape values (defined by the Lagrange       polynomials in the points of the quadrature rule) evaluated at the       point 0 and 1 (the vertices) in one data structure.             This data structure can be used to interpolate from the cell to the       face quadrature points.            
*  [2.x.10]  In contrast to shape_data_on_face, only the vales are evaluated.      
* [0.x.26]*
       Stores one-dimensional values of shape functions on subface. Since       there are two subfaces, store two variants.      
* [0.x.27]*
       Stores one-dimensional gradients of shape functions on subface. Since       there are two subfaces, store two variants.      
* [0.x.28]*
       Stores one-dimensional gradients of shape functions on subface. Since       there are two subfaces, store two variants.      
* [0.x.29]*
       We store a copy of the one-dimensional quadrature formula       used for initialization.      
* [0.x.30]*
       Stores the degree of the element.      
* [0.x.31]*
       Stores the number of quadrature points per dimension.      
* [0.x.32]*
       Indicates whether the basis functions are nodal in 0 and 1, i.e., the       end points of the unit cell.      
* [0.x.33]*
       Stores the shape values of the finite element evaluated on all       quadrature points for all faces and orientations (no tensor-product       structure exploited).      
* [0.x.34]*
       Stores the shape gradients of the finite element evaluated on all       quadrature points for all faces, orientations, and directions       (no tensor-product structure  exploited).      
* [0.x.35]*
     This struct stores a tensor (Kronecker) product view of the finite     element and quadrature formula used for evaluation. It is based on a     single or a collection of UnivariateShapeData object(s) that describe     one-dimensional ingredients, plus some additional information about how     these are combined and how indices are laid out in the multi-dimensional     case such as the hierarchical
* 
-> lexicographic ordering of FE_Q.        
*  [2.x.11]     
* [0.x.36]*
       Encodes the type of element detected at construction. FEEvaluation       will select the most efficient algorithm based on the given element       type.      
* [0.x.37]*
       Empty constructor. Does nothing.      
* [0.x.38]*
       Constructor that initializes the data fields using the reinit method.      
* [0.x.39]*
       Initializes the data fields. Takes a one-dimensional quadrature       formula and a finite element as arguments and evaluates the shape       functions, gradients and Hessians on the one-dimensional unit cell.       This function assumes that the finite element is derived from a one-       dimensional element by a tensor product and that the zeroth shape       function in zero evaluates to one.      
* [0.x.40]*
       Return which kinds of elements are supported by MatrixFree.      
* [0.x.41]*
       Return data of univariate shape functions which defines the       dimension  [2.x.12]  of tensor product shape functions       regarding vector component  [2.x.13]  of the underlying       finite element.      
* [0.x.42]*
       Return the memory consumption of this class in bytes.      
* [0.x.43]*
       Renumbering from deal.II's numbering of cell degrees of freedom to       lexicographic numbering used inside the FEEvaluation schemes of the       underlying element in the DoFHandler. For vector-valued elements, the       renumbering starts with a lexicographic numbering of the first       component, then everything of the second component, and so on.      
* [0.x.44]*
       Stores data of univariate shape functions defining the       underlying tensor product finite element.      
* [0.x.45]*
       Grants access to univariate shape function data of given       dimension and vector component. Rows identify dimensions and       columns identify vector components.      
* [0.x.46]*
       Stores the number of space dimensions.      
* [0.x.47]*
       Stores the number of vector components of the underlying       vector-valued finite element.      
* [0.x.48]*
       Stores the number of quadrature points in  [2.x.14]  dimensions for a       cell.      
* [0.x.49]*
       Stores the number of DoFs per cell of the scalar element in  [2.x.15]        dimensions.      
* [0.x.50]*
       Stores the number of quadrature points per face in  [2.x.16]  dimensions.      
* [0.x.51]*
       Stores the number of quadrature points of a face in  [2.x.17]  dimensions       for simplex, wedge and pyramid reference cells.      
* [0.x.52]*
       Stores the number of DoFs per face in  [2.x.18]  dimensions.      
* [0.x.53]*
       For nodal basis functions with nodes located at the boundary of the       unit cell, face integrals that involve only the values of the shape       functions (approximations of first derivatives in DG) do not need to       load all degrees of freedom of the cell but rather only the degrees       of freedom located on the face. While it would also be possible to       compute these indices on the fly, we choose to simplify the code and       store the indirect addressing in this class.             The first table index runs through the faces of a cell, and the       second runs through the nodal degrees of freedom of the face, using        [2.x.19]  entries.             The indices stored in this member variable are as follows. Consider       for example a 2D element of degree 3 with the following degrees of       freedom in lexicographic numbering:      
* [1.x.0]
*              The first row stores the indices on the face with index 0, i.e., the       numbers  [2.x.20] , the second row holds the indices        [2.x.21]  for face 1, the third row holds the indices        [2.x.22]  for face 2, and the last (fourth) row holds       the indices  [2.x.23] . Similarly, the indices are       stored in 3D. (Note that the y faces in 3D use indices reversed in       terms of the lexicographic numbers due to the orientation of the       coordinate system.)            
*  [2.x.24]  This object is only filled in case  [2.x.25]        evaluates to  [2.x.26]       
* [0.x.54]*
       The  [2.x.27]  provides a shortcut for the       evaluation of values on the faces. For Hermite-type basis functions,       one can go one step further and also use shortcuts to get derivatives       more cheaply where only two layers of degrees of freedom contribute       to the derivative on the face. In the lexicographic ordering, the       respective indices is in the next "layer" of degrees of freedom as       compared to the nodal values. This array stores the indirect       addressing of both the values and the gradient.             The first table index runs through the faces of a cell, and the       second runs through the pairs of the nodal degrees of freedom of the       face and the derivatives, using  [2.x.28]  entries.             The indices stored in this member variable are as follows. Consider       for example a 2D element of degree 3 with the following degrees of       freedom in lexicographic numbering:      
* [1.x.1]
*              The first row stores the indices for values and gradients on the face       with index 0, i.e., the numbers <code>0, 1, 5, 6, 10, 11, 15, 16, 20,       21</code>, the second row holds the indices <code>4, 3, 9, 8, 14, 13,       19, 18, 24, 23</code> for face 1, the third row holds the indices        [2.x.29]  for face 2, and the last       (fourth) row holds the indices <code>20, 15, 21, 16, 22, 17, 23, 18,       24, 19</code>. Similarly, the indices are stored in 3D. (Note that       the y faces in 3D use indices reversed in terms of the lexicographic       numbers due to the orientation of the coordinate system.)            
*  [2.x.30]  This object is only filled in case  [2.x.31]  evaluates to        [2.x.32]       
* [0.x.55]*
       For degrees on faces, the basis functions are not       in the correct order if a face is not in the standard orientation       to a given element. This data structure is used to re-order the       basis functions to represent the correct order.      
* [0.x.56]*
       Check whether we have symmetries in the shape values. In that case,       also fill the shape_???_eo fields.      
* [0.x.57]*
       Check whether symmetric 1D basis functions are such that the shape       values form a diagonal matrix, i.e., the nodal points are collocated       with the quadrature points. This allows for specialized algorithms       that save some operations in the evaluation.      
* [0.x.58]

include/deal.II-translator/matrix_free/task_info_0.txt
[0.x.0]*
   An interface for the worker object that runs the various operations we   want to perform during the matrix-free loop.  
* [0.x.1]*
     A struct that collects all information related to parallelization with     threads: The work is subdivided into tasks that can be done     independently.    
* [0.x.2]*
       Constructor.      
* [0.x.3]*
       Clears all the data fields and resets them       to zero.      
* [0.x.4]*
       Runs the matrix-free loop.      
* [0.x.5]*
       Make the number of cells which can only be treated in the       communication overlap divisible by the vectorization length.      
* [0.x.6]*
       Sets up the blocks for running the cell loop based on the options       controlled by the input arguments.              [2.x.0]  cells_with_comm A list of cells that need to exchange data       prior to performing computations. These will be given a certain id in       the partitioning to make sure cell loops that overlap communication       with communication have the ghost data ready.              [2.x.1]  dofs_per_cell Gives an expected value for the number of degrees       of freedom on a cell, which is used to determine the block size for       interleaving cell and face integrals.              [2.x.2]  categories_are_hp Defines whether       `cell_vectorization_categories` is originating from a hp-adaptive       computation with variable polynomial degree or a user-defined       variant.              [2.x.3]  cell_vectorization_categories This set of categories defines       the cells that should be grouped together inside the lanes of a       vectorized array. This can be the polynomial degree in an hp-element       or a user-provided grouping.              [2.x.4]  cell_vectorization_categories_strict Defines whether the       categories defined by the previous variables should be separated       strictly or whether it is allowed to insert lower categories into the       next high one(s).              [2.x.5]  parent_relation This data field is used to specify which cells       have the same parent cell. Cells with the same ancestor are grouped       together into the same batch(es) with vectorization across cells.              [2.x.6]  renumbering When leaving this function, the vector contains a       new numbering of the cells that aligns with the grouping stored in       this class.              [2.x.7]  incompletely_filled_vectorization Given the vectorized layout       of this class, some cell batches might have components in the       vectorized array (SIMD lanes) that are not used and do not carray       valid data. This array indicates the cell batches where this occurs       according to the renumbering returned by this function.      
* [0.x.7]*
       First step in the block creation for the task-parallel blocking setup.              [2.x.8]  boundary_cells A list of cells that need to exchange data prior       to performing computations. These will be given a certain id in the       partitioning.              [2.x.9]  renumbering When leaving this function, the vector contains a       new numbering of the cells that aligns with the grouping stored in       this class (before actually creating the tasks).              [2.x.10]  incompletely_filled_vectorization Given the vectorized layout       of this class, some cell batches might have components in the       vectorized array (SIMD lanes) that are not used and do not carray       valid data. This array indicates the cell batches where this occurs       according to the renumbering returned by this function.      
* [0.x.8]*
       This helper function determines a block size if the user decided not       to force a block size through  [2.x.11]  This is       computed based on the number of hardware threads on the system and       the number of macro cells that we should work on.      
* [0.x.9]*
       This method goes through all cells that have been filled into  [2.x.12]        dof_indices and finds out which cells can be worked on independently       and which ones are neighboring and need to be done at different times       when used in parallel.             The strategy is based on a two-level approach. The outer level is       subdivided into partitions similar to the type of neighbors in       Cuthill-McKee, and the inner level is subdivided via colors (for       chunks within the same color, can work independently). One task is       represented by a chunk of cells. The cell chunks are formed before       subdivision into partitions and colors.              [2.x.13]  connectivity (in/out) Determines whether cells `i` and `j` are       conflicting, expressed by an entry in position (i,j).              [2.x.14]  renumbering (in/out) At output, the element j of this variable       gives the original number of the cell that is reordered to place j by       the ordering due to the thread graph.              [2.x.15]  irregular_cells (in/out) Informs the current function whether       some SIMD lanes in VectorizedArray would not be filled for a given       cell batch index.              [2.x.16]  hp_bool Defines whether we are in hp-mode or not      
* [0.x.10]*
       This function goes through all cells that have been filled into  [2.x.17]        dof_indices and finds out which cells can be worked on independently       and which ones are neighboring and need to be done at different times       when used in parallel.             The strategy is based on a two-level approach. The outer level is       subdivided into partitions similar to the type of neighbors in       Cuthill-McKee, and the inner level is again subdivided into Cuthill-       McKee-like partitions (partitions whose level differs by more than 2       can be worked on independently). One task is represented by a chunk       of cells. The cell chunks are formed after subdivision into the two       levels of partitions.              [2.x.18]  cell_active_fe_index The active FE index corresponding to the       individual indices in the list of all cell indices, in order to be       able to not place cells with different indices into the same cell       batch with vectorization.              [2.x.19]  connectivity (in/out) Determines whether cells `i` and `j` are       conflicting, expressed by an entry in position (i,j).              [2.x.20]  renumbering (in/out) At output, the element j of this variable       gives the original number of the cell that is reordered to place j by       the ordering due to the thread graph.              [2.x.21]  irregular_cells (in/out) Informs the current function whether       some SIMD lanes in VectorizedArray would not be filled for a given       cell batch index.              [2.x.22]  hp_bool Defines whether we are in hp-mode or not      
* [0.x.11]*
       Either calls make_thread_graph_partition_color() or       make_thread_graph_partition_partition() accessible from the outside,       depending on the setting in the data structure.              [2.x.23]  cell_active_fe_index The active FE index corresponding to the       individual indices in the list of all cell indices, in order to be       able to not place cells with different indices into the same cell       batch with vectorization.              [2.x.24]  connectivity (in/out) Determines whether cells `i` and `j` are       conflicting, expressed by an entry in position (i,j).              [2.x.25]  renumbering (in/out) At output, the element j of this variable       gives the original number of the cell that is reordered to place j by       the ordering due to the thread graph.              [2.x.26]  irregular_cells (in/out) Informs the current function whether       some SIMD lanes in VectorizedArray would not be filled for a given       cell batch index.              [2.x.27]  hp_bool Defines whether we are in hp-mode or not      
* [0.x.12]*
       This function computes the connectivity between blocks of cells from       the connectivity between the individual cells.      
* [0.x.13]*
       %Function to create coloring on the second layer within each       partition.      
* [0.x.14]*
       %Function to create partitioning on the second layer within each       partition.      
* [0.x.15]*
       This function creates partitions according to the provided connectivity       graph.              [2.x.28]  connectivity Connectivity between (blocks of cells)              [2.x.29]  cluster_size The number of cells in each partition should be a       multiple of cluster_size (for blocking later on)              [2.x.30]  cell_partition Saves of each (block of cells) to which       partition the block belongs              [2.x.31]  partition_list partition_list[j] gives the old number of the       block that should be renumbered to j due to the partitioning              [2.x.32]  partition_size Vector pointing to start of each partition (on       output)              [2.x.33]  partition number of partitions created      
* [0.x.16]*
       Update fields of task info for task graph set up in       make_thread_graph.      
* [0.x.17]*
       Creates a task graph from a connectivity structure.      
* [0.x.18]*
       Returns the memory consumption of the class.      
* [0.x.19]*
       Prints minimum, average, and maximal memory consumption over the MPI       processes.      
* [0.x.20]*
       Number of physical cells in the mesh, not cell batches after       vectorization      
* [0.x.21]*
       Number of physical ghost cells in the mesh which are subject to       special treatment and should not be included in loops      
* [0.x.22]*
       Number of lanes in the SIMD array that are used for vectorization      
* [0.x.23]*
       Block size information for multithreading      
* [0.x.24]*
       Number of blocks for multithreading      
* [0.x.25]*
       Parallel scheme applied by multithreading      
* [0.x.26]*
       The blocks are organized by a vector-of-vector concept, and this data       field  [2.x.34]  stores the distance from one 'vector' to       the next within the linear storage of all data to the two-level       partitioning.      
* [0.x.27]*
       This is a linear storage of all partitions, building a range of       indices of the form cell_partition_data[idx] to       cell_partition_data[idx+1] within the integer list of all cells in       MatrixFree, subdivided into chunks by  [2.x.35]       
* [0.x.28]*
       Like cell_partition_data but with precomputed subranges for each       active fe index. The start and end point of a partition is given       by cell_partition_data_hp_ptr.      
* [0.x.29]*
       Pointers within cell_partition_data_hp, indicating the start and end       of a partition.      
* [0.x.30]*
       This is a linear storage of all partitions of inner faces, building a       range of indices of the form face_partition_data[idx] to       face_partition_data[idx+1] within the integer list of all interior       faces in MatrixFree, subdivided into chunks by  [2.x.36]        partition_row_index.      
* [0.x.31]*
       Like face_partition_data but with precomputed subranges for each       active fe index pair. The start and end point of a partition is given       by face_partition_data_hp_ptr.      
* [0.x.32]*
       Pointers within face_partition_data_hp, indicating the start and end       of a partition.      
* [0.x.33]*
       This is a linear storage of all partitions of boundary faces,       building a range of indices of the form boundary_partition_data[idx]       to boundary_partition_data[idx+1] within the integer list of all       boundary faces in MatrixFree, subdivided into chunks by  [2.x.37]        partition_row_index.      
* [0.x.34]*
       Like boundary_partition_data but with precomputed subranges for each       active fe index. The start and end point of a partition is given       by boundary_partition_data_hp_ptr.      
* [0.x.35]*
       Pointers within boundary_partition_data_hp, indicating the start and       end of a partition.      
* [0.x.36]*
       This is a linear storage of all partitions of interior faces on       boundaries to other processors that are not locally used, building a       range of indices of the form ghost_face_partition_data[idx] to       ghost_face_partition_data[idx+1] within the integer list of all such       faces in MatrixFree, subdivided into chunks by  [2.x.38]        partition_row_index.      
* [0.x.37]*
       This is a linear storage of all partitions of faces for multigrid       levels that have a coarser neighbor and are only included in certain       residual computations but not in smoothing, building a range of       indices of the form refinement_edge_face_partition_data[idx] to       refinement_edge_face_partition_data[idx+1] within the integer list of       all such faces in MatrixFree, subdivided into chunks by  [2.x.39]        partition_row_index.      
* [0.x.38]*
       Thread information (which chunk to start 'even' partitions from) to       be handed to the dynamic task scheduler      
* [0.x.39]*
       Thread information (which chunk to start 'odd' partitions from) to be       handed to the dynamic task scheduler      
* [0.x.40]*
       Thread information regarding the dependencies for partitions handed       to the dynamic task scheduler      
* [0.x.41]*
       Thread information regarding the dependencies for partitions handed       to the dynamic task scheduler      
* [0.x.42]*
       Number of even partitions accumulated over the field  [2.x.40]        partitions_even      
* [0.x.43]*
       Number of odd partitions accumulated over the field  [2.x.41]        partitions_odd      
* [0.x.44]*
       Number of blocked workers accumulated over the field  [2.x.42]        partition_n_blocked_workers      
* [0.x.45]*
       Number of workers accumulated over the field  [2.x.43]       
* [0.x.46]*
       Stores whether a particular task is at an MPI boundary and needs data       exchange      
* [0.x.47]*
       MPI communicator      
* [0.x.48]*
       Shared-memory MPI communicator      
* [0.x.49]*
       Rank of MPI process      
* [0.x.50]*
       Number of MPI rank for the current communicator      
* [0.x.51]

include/deal.II-translator/matrix_free/tensor_product_kernels_0.txt
[0.x.0]*
   In this namespace, the evaluator routines that evaluate the tensor   products are implemented.  
* [0.x.1]*
     Do not use anything more than the tensor product structure of the     finite element.    
* [0.x.2]*
     Perform evaluation by exploiting symmetry in the finite element: i.e.,     skip some computations by utilizing the symmetry in the shape functions     and quadrature points.    
* [0.x.3]*
     Use symmetry to apply the operator to even and odd parts of the input     vector separately: see the documentation of the EvaluatorTensorProduct     specialization for more information.    
* [0.x.4]*
     Use symmetry in Legendre and similar polynomial spaces where the shape     functions with even number are symmetric about the center of the     quadrature points (think about even polynomial degrees) and the shape     functions with odd number are anti-symmetric about the center of the     quadrature points (think about odd polynomial degrees). This allows to     use a strategy similar to the even-odd technique but without separate     coefficient arrays. See the documentation of the EvaluatorTensorProduct     specialization for more information.    
* [0.x.5]*
   Determine which quantity should be computed via the tensor product kernels.  
* [0.x.6]*
     Evaluate/integrate by shape functions.    
* [0.x.7]*
     Evaluate/integrate by gradients of the shape functions.    
* [0.x.8]*
     Evaluate/integrate by hessians of the shape functions.    
* [0.x.9]*
   Generic evaluator framework that valuates the given shape data in general   dimensions using the tensor product form. Depending on the particular   layout in the matrix entries, this corresponds to a usual matrix-matrix   product or a matrix-matrix product including some symmetries.      [2.x.0]  variant Variant of evaluation used for creating template                   specializations    [2.x.1]  dim Dimension of the function    [2.x.2]  n_rows Number of rows in the transformation matrix, which corresponds                  to the number of 1d shape functions in the usual tensor                  contraction setting    [2.x.3]  n_columns Number of columns in the transformation matrix, which                     corresponds to the number of 1d shape functions in the                     usual tensor contraction setting    [2.x.4]  Number Abstract number type for input and output arrays    [2.x.5]  Number2 Abstract number type for coefficient arrays (defaults to                   same type as the input/output arrays); must implement                   operator* with Number to be valid  
* [0.x.10]*
   Internal evaluator for shape function in arbitrary dimension using the   tensor product form of the basis functions.      [2.x.6]  dim Space dimension in which this class is applied    [2.x.7]  n_rows Number of rows in the transformation matrix, which corresponds                  to the number of 1d shape functions in the usual tensor                  contraction setting    [2.x.8]  n_columns Number of columns in the transformation matrix, which                     corresponds to the number of 1d shape functions in the                     usual tensor contraction setting    [2.x.9]  Number Abstract number type for input and output arrays    [2.x.10]  Number2 Abstract number type for coefficient arrays (defaults to                   same type as the input/output arrays); must implement                   operator* with Number and produce Number as an output to                   be a valid type  
* [0.x.11]*
     Empty constructor. Does nothing. Be careful when using 'values' and     related methods because they need to be filled with the other pointer    
* [0.x.12]*
     Constructor, taking the data from ShapeInfo    
* [0.x.13]*
     This function applies the tensor product kernel, corresponding to a     multiplication of 1D stripes, along the given  [2.x.11]  of the tensor     data in the input array. This function allows the  [2.x.12]  and  [2.x.13]      arrays to alias for the case n_rows == n_columns, i.e., it is safe to     perform the contraction in place where  [2.x.14]  and  [2.x.15]  point to the     same address. For the case n_rows != n_columns, the output is in general     not correct.          [2.x.16]  direction Direction that is evaluated      [2.x.17]  contract_over_rows If true, the tensor contraction sums                                over the rows in the given  [2.x.18]                                 array, otherwise it sums over the columns      [2.x.19]  add If true, the result is added to the output vector, else                 the computed values overwrite the content in the output      [2.x.20]  one_line If true, the kernel is only applied along a single 1D                      stripe within a dim-dimensional tensor, not the full                      n_rows^dim points as in the  [2.x.21]  case.          [2.x.22]  shape_data Transformation matrix with  [2.x.23]  rows and                        [2.x.24]  columns, stored in row-major format      [2.x.25]  in Pointer to the start of the input data vector      [2.x.26]  out Pointer to the start of the output data vector    
* [0.x.14]*
     This function applies the tensor product operation to produce face values     from cell values. As opposed to the apply method, this method assumes     that the directions orthogonal to the face have n_rows degrees of     freedom per direction and not n_columns for those directions lower than     the one currently applied. In other words, apply_face() must be called     before calling any interpolation within the face.          [2.x.27]  face_direction Direction of the normal vector (0=x, 1=y, etc)      [2.x.28]  contract_onto_face If true, the input vector is of size n_rows^dim                                and interpolation into n_rows^(dim-1) points                                is performed. This is a typical scenario in                                 [2.x.29]  calls. If false,                                data from n_rows^(dim-1) points is expanded                                into the n_rows^dim points of the higher-                                dimensional data array. Derivatives in the                                case contract_onto_face==false are summed                                together      [2.x.30]  add If true, the result is added to the output vector, else                 the computed values overwrite the content in the output      [2.x.31]  max_derivative Sets the number of derivatives that should be                 computed. 0 means only values, 1 means values and first                 derivatives, 2 second derivates. Note that all the                 derivatives access the data in  [2.x.32]  passed to                 the constructor of the class      [2.x.33]  lex_faces Sets how the evaluation points on the faces should be                       sorted: lexicographically or right-hand-system number                       (special treatment of orientation 1 in 3D). Per default                       right-hand-system number is enabled, which is only                       working for dimensions up to 3.          [2.x.34]  in address of the input data vector      [2.x.35]  out address of the output data vector    
* [0.x.15]*
   Internal evaluator for shape function using the tensor product form   of the basis functions. The same as the other templated class but   without making use of template arguments and variable loop bounds   instead.      [2.x.36]  dim Space dimension in which this class is applied    [2.x.37]  Number Abstract number type for input and output arrays    [2.x.38]  Number2 Abstract number type for coefficient arrays (defaults to                   same type as the input/output arrays); must implement                   operator* with Number and produce Number as an output to                   be a valid type  
* [0.x.16]*
     Empty constructor. Does nothing. Be careful when using 'values' and     related methods because they need to be filled with the other constructor    
* [0.x.17]*
     Constructor, taking the data from ShapeInfo    
* [0.x.18]*
     Constructor, taking the data from ShapeInfo    
* [0.x.19]*
   Internal evaluator for 1d-3d shape function using the tensor product form   of the basis functions. This class specializes the general application of   tensor-product based elements for "symmetric" finite elements, i.e., when   the shape functions are symmetric about 0.5 and the quadrature points   are, too.      [2.x.39]  dim Space dimension in which this class is applied    [2.x.40]  n_rows Number of rows in the transformation matrix, which corresponds                  to the number of 1d shape functions in the usual tensor                  contraction setting    [2.x.41]  n_columns Number of columns in the transformation matrix, which                     corresponds to the number of 1d shape functions in the                     usual tensor contraction setting    [2.x.42]  Number Abstract number type for input and output arrays    [2.x.43]  Number2 Abstract number type for coefficient arrays (defaults to                   same type as the input/output arrays); must implement                   operator* with Number and produce Number as an output to                   be a valid type  
* [0.x.20]*
     Constructor, taking the data from ShapeInfo    
* [0.x.21]*
   Internal evaluator for 1d-3d shape function using the tensor product form   of the basis functions.     This class implements a different approach to the symmetric case for   values, gradients, and Hessians also treated with the above functions: It   is possible to reduce the cost per dimension from N^2 to N^2/2, where N   is the number of 1D dofs (there are only N^2/2 different entries in the   shape matrix, so this is plausible). The approach is based on the idea of   applying the operator on the even and odd part of the input vectors   separately, given that the shape functions evaluated on quadrature points   are symmetric. This method is presented e.g. in the book "Implementing   Spectral Methods for Partial Differential Equations" by David A. Kopriva,   Springer, 2009, section 3.5.3 (Even-Odd-Decomposition). Even though the   experiments in the book say that the method is not efficient for N<20, it   is more efficient in the context where the loop bounds are compile-time   constants (templates).      [2.x.44]  dim Space dimension in which this class is applied    [2.x.45]  n_rows Number of rows in the transformation matrix, which corresponds                  to the number of 1d shape functions in the usual tensor                  contraction setting    [2.x.46]  n_columns Number of columns in the transformation matrix, which                     corresponds to the number of 1d shape functions in the                     usual tensor contraction setting    [2.x.47]  Number Abstract number type for input and output arrays    [2.x.48]  Number2 Abstract number type for coefficient arrays (defaults to                   same type as the input/output arrays); must implement                   operator* with Number and produce Number as an output to                   be a valid type  
* [0.x.22]*
     Empty constructor. Does nothing. Be careful when using 'values' and     related methods because they need to be filled with the other     constructor passing in at least an array for the values.    
* [0.x.23]*
     Constructor, taking the data from ShapeInfo (using the even-odd     variants stored there)    
* [0.x.24]*
     Constructor, taking the data from ShapeInfo (using the even-odd     variants stored there)    
* [0.x.25]*
     This function applies the tensor product kernel, corresponding to a     multiplication of 1D stripes, along the given  [2.x.49]  of the tensor     data in the input array. This function allows the  [2.x.50]  and  [2.x.51]      arrays to alias for the case n_rows == n_columns, i.e., it is safe to     perform the contraction in place where  [2.x.52]  and  [2.x.53]  point to the     same address. For the case n_rows != n_columns, the output is only     correct if  [2.x.54]  is set to true.          [2.x.55]  direction Direction that is evaluated      [2.x.56]  contract_over_rows If true, the tensor contraction sums                                over the rows in the given  [2.x.57]                                 array, otherwise it sums over the columns      [2.x.58]  add If true, the result is added to the output vector, else                 the computed values overwrite the content in the output      [2.x.59]  type Determines whether to use the symmetries appearing in                  shape values (type=0), shape gradients (type=1) or                  second derivatives (type=2, similar to type 0 but                  without two additional zero entries)      [2.x.60]  one_line If true, the kernel is only applied along a single 1D                      stripe within a dim-dimensional tensor, not the full                      n_rows^dim points as in the  [2.x.61]  case.          [2.x.62]  shape_data Transformation matrix with  [2.x.63]  rows and                        [2.x.64]  columns, stored in row-major format      [2.x.65]  in Pointer to the start of the input data vector      [2.x.66]  out Pointer to the start of the output data vector    
* [0.x.26]*
   Internal evaluator for 1d-3d shape function using the tensor product form   of the basis functions.     This class implements an approach similar to the even-odd decomposition   but with a different type of symmetry. In this case, we assume that a   single shape function already shows the symmetry over the quadrature   points, rather than the complete basis that is considered in the even-odd   case. In particular, we assume that the shape functions are ordered as in   the Legendre basis, with symmetric shape functions in the even slots   (rows of the values array) and point-symmetric in the odd slots. Like the   even-odd decomposition, the number of operations are N^2/2 rather than   N^2 FMAs (fused multiply-add), where N is the number of 1D dofs. The   difference is in the way the input and output quantities are symmetrized.      [2.x.67]  dim Space dimension in which this class is applied    [2.x.68]  n_rows Number of rows in the transformation matrix, which corresponds                  to the number of 1d shape functions in the usual tensor                  contraction setting    [2.x.69]  n_columns Number of columns in the transformation matrix, which                     corresponds to the number of 1d shape functions in the                     usual tensor contraction setting    [2.x.70]  Number Abstract number type for input and output arrays    [2.x.71]  Number2 Abstract number type for coefficient arrays (defaults to                   same type as the input/output arrays); must implement                   operator* with Number and produce Number as an output to                   be a valid type  
* [0.x.27]*
     Empty constructor. Does nothing. Be careful when using 'values' and     related methods because they need to be filled with the other     constructor passing in at least an array for the values.    
* [0.x.28]*
     Constructor, taking the data from ShapeInfo (using the even-odd     variants stored there)    
* [0.x.29]*
     Constructor, taking the data from ShapeInfo (using the even-odd     variants stored there)    
* [0.x.30]*
     This function applies the tensor product kernel, corresponding to a     multiplication of 1D stripes, along the given  [2.x.72]  of the tensor     data in the input array. This function allows the  [2.x.73]  and  [2.x.74]      arrays to alias for the case n_rows == n_columns, i.e., it is safe to     perform the contraction in place where  [2.x.75]  and  [2.x.76]  point to the     same address. For the case n_rows != n_columns, the output is only     correct if  [2.x.77]  is set to true.          [2.x.78]  direction Direction that is evaluated      [2.x.79]  contract_over_rows If true, the tensor contraction sums                                over the rows in the given  [2.x.80]                                 array, otherwise it sums over the columns      [2.x.81]  add If true, the result is added to the output vector, else                 the computed values overwrite the content in the output      [2.x.82]  type Determines whether the evaluation is symmetric in even                  rows (type=0) or odd rows (type=1) of  [2.x.83]  and                  skew-symmetric in odd rows (type=0) or even rows (type=1)      [2.x.84]  one_line If true, the kernel is only applied along a single 1D                      stripe within a dim-dimensional tensor, not the full                      n_rows^dim points as in the  [2.x.85]  case.          [2.x.86]  shape_data Transformation matrix with  [2.x.87]  rows and                        [2.x.88]  columns, stored in row-major format      [2.x.89]  in Pointer to the start of the input data vector      [2.x.90]  out Pointer to the start of the output data vector    
* [0.x.31]*
   Struct to avoid using Tensor<1, dim, Point<dim2>> in   evaluate_tensor_product_value_and_gradient because a Point cannot be used   within Tensor. Instead, a specialization of this struct upcasts the point   to a Tensor<1,dim>.  
* [0.x.32]*
   Compute the polynomial interpolation of a tensor product shape function    [2.x.91]  given a vector of coefficients  [2.x.92]  in the form    [2.x.93] . The shape   functions  [2.x.94]  represent a tensor   product. The function returns a pair with the value of the interpolation   as the first component and the gradient in reference coordinates as the   second component. Note that for compound types (e.g. the `values` field   begin a Point<spacedim> argument), the components of the gradient are   sorted as Tensor<1, dim, Tensor<1, spacedim>> with the derivatives   as the first index; this is a consequence of the generic arguments in the   function.      [2.x.95]  poly The underlying one-dimensional polynomial basis    [2.x.96]  given as a vector of polynomials.      [2.x.97]  values The expansion coefficients  [2.x.98]  of type `Number` in   the polynomial interpolation. The coefficients can be simply `double`   variables but e.g. also Point<spacedim> in case they define arithmetic   operations with the type `Number2`.      [2.x.99]  p The position in reference coordinates where the interpolation   should be evaluated.      [2.x.100]  d_linear Flag to specify whether a d-linear (linear in 1D,   bi-linear in 2D, tri-linear in 3D) interpolation should be made, which   allows to unroll loops and considerably speed up evaluation.      [2.x.101]  renumber Optional parameter to specify a renumbering in the   coefficient vector, assuming that `values[renumber[i]]` returns   the lexicographic (tensor product) entry of the coefficients. If the   vector is entry, the values are assumed to be sorted lexicographically.  
* [0.x.33]*
   Same as evaluate_tensor_product_value_and_gradient() but for integration.  
* [0.x.34]

include/deal.II-translator/matrix_free/tools_0.txt
[0.x.0]*
 A namespace for utility functions in the context of matrix-free operator evaluation.

* 
* [0.x.1]*
   Modify  [2.x.0]  so that cells are categorized   according to their boundary IDs, making face integrals in the case of   cell-centric loop simpler.  
* [0.x.2]*
   Compute the diagonal of a linear operator ( [2.x.1]  given    [2.x.2]  and the local cell integral operation  [2.x.3]  The   vector is initialized to the right size in the function.     The parameters  [2.x.4]   [2.x.5]  and  [2.x.6]  are   passed to the constructor of the FEEvaluation that is internally set up.  
* [0.x.3]*
   Same as above but with a class and a function pointer.  
* [0.x.4]*
   Compute the matrix representation of a linear operator ( [2.x.7]  given    [2.x.8]  and the local cell integral operation  [2.x.9]    Constrained entries on the diagonal are set to one.     The parameters  [2.x.10]   [2.x.11]  and  [2.x.12]  are   passed to the constructor of the FEEvaluation that is internally set up.  
* [0.x.5]*
   Same as above but with a class and a function pointer.  
* [0.x.6]*
     If value type of matrix and constrains equals, return a reference     to the given AffineConstraint instance.    
* [0.x.7]*
     If value type of matrix and constrains do not equal, a new     AffineConstraint instance with the value type of the matrix is     created and a reference to it is returned.    
* [0.x.8]

include/deal.II-translator/matrix_free/type_traits_0.txt
[0.x.0]

include/deal.II-translator/matrix_free/util_0.txt
[0.x.0]

include/deal.II-translator/matrix_free/vector_access_internal_0.txt
[0.x.0]

include/deal.II-translator/matrix_free/vector_data_exchange_0.txt
[0.x.0]*
     Namespace containing classes for inter-process data exchange (i.e.,     for update_ghost_values and compress) in MatrixFree.    
* [0.x.1]*
       Interface needed by MatrixFree.      
* [0.x.2]*
       Class that simply delegates the task to a  [2.x.0]       
* [0.x.3]*
       Similar to the above but using the internal data structures in the       partitioner in order to identify indices of degrees of freedom that are       in the same shared memory region.      
* [0.x.4]*
         Global communicator.        
* [0.x.5]*
         Shared-memory sub-communicator.        
* [0.x.6]*
         Number of locally-owned vector entries.        
* [0.x.7]*
         Number of ghost vector entries.        
* [0.x.8]*
         Number of global vector entries.        
* [0.x.9]*
         A variable caching the number of ghost indices in a larger set of         indices by rank.        
* [0.x.10]*
         The set of indices that appear for an IndexSet that is a subset of a         larger set for each rank in a compressed manner.        
* [0.x.11]*
         An array that contains information which processors my ghost indices         belong to, at which offset and how many those indices are        
* [0.x.12]*
         The set of processors and length of data field which send us their         ghost data.                
*  [2.x.1]  Structured as ghost_targets_data.        
* [0.x.13]*
         An array that caches the number of chunks in the import indices per         MPI rank. The length is import_indices_data.size()+1.                 The set of (local) indices that we are importing during compress()         from remote processes, i.e., others' ghosts that belong to the local         range.        
* [0.x.14]*
         Shared-memory ranks from which data is copied from during         export_to_ghosted_array_finish().        
* [0.x.15]*
         Indices from where to copy data from during         export_to_ghosted_array_finish().        
* [0.x.16]*
         Indices where to copy data to during         export_to_ghosted_array_finish().        
* [0.x.17]*
         Shared-memory ranks from where to copy data from during         import_from_ghosted_array_finish().        
* [0.x.18]*
         Indices from where to copy data from during         import_from_ghosted_array_finish().        
* [0.x.19]*
         Indices where to copy data to during         import_from_ghosted_array_finish().        
* [0.x.20]

