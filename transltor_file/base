include/deal.II-translator/base/aligned_vector_0.txt
[0.x.0]*
 This is a replacement class for  [2.x.0]  to be used in combination with VectorizedArray and derived data types. It allocates memory aligned to addresses of a vectorized data type (in order to avoid segmentation faults when a variable of type VectorizedArray which the compiler assumes to be aligned to certain memory addresses does not actually follow these rules). This could also be achieved by proving  [2.x.1]  with a user-defined allocator. On the other hand, writing an own small vector class lets us implement parallel copy and move operations with TBB, insert deal.II-style assertions, and cut some unnecessary functionality. Note that this vector is a bit more memory-consuming than  [2.x.2]  because of alignment, so it is recommended to only use this vector on long vectors.

* 
* [0.x.1]*
   Declare standard types used in all containers. These types parallel those   in the <tt>C++</tt> standard libraries <tt>vector<...></tt> class.  
* [0.x.2]*
   Empty constructor. Sets the vector size to zero.  
* [0.x.3]*
   Set the vector size to the given size and initializes all elements with   T().      [2.x.3]   
* [0.x.4]*
   Destructor.  
* [0.x.5]*
   Copy constructor.      [2.x.4]   
* [0.x.6]*
   Move constructor. Create a new aligned vector by stealing the contents of    [2.x.5]   
* [0.x.7]*
   Assignment to the input vector  [2.x.6]       [2.x.7]   
* [0.x.8]*
   Move assignment operator.  
* [0.x.9]*
   Change the size of the vector. If the new size is larger than the   previous size, then new elements will be added to the end of the   vector; these elements will remain uninitialized (i.e., left in   an undefined state) if  [2.x.8]  is `true`, and   will be default initialized if  [2.x.9]  is `false`.   See [here](https://en.cppreference.com/w/cpp/types/is_trivial) for   a definition of what  [2.x.10]  does.     If the new size is less than the previous size, then the last few   elements will be destroyed if  [2.x.11]  will be `false`   or will simply be ignored in the future if    [2.x.12]  is `true`.     As a consequence of the outline above, the "_fast" suffix of this   function refers to the fact that for "trivial" classes `T`, this   function omits constructor/destructor calls and in particular the   initialization of new elements.    
*  [2.x.13]  This method can only be invoked for classes  [2.x.14]  that define a   default constructor,  [2.x.15]  Otherwise, compilation will fail.  
* [0.x.10]*
   Change the size of the vector. It keeps old elements previously   available, and initializes each newly added element to a   default-constructed object of type  [2.x.16]      If the new vector size is shorter than the old one, the memory is   not immediately released unless the new size is zero; however,   the size of the current object is of course set to the requested   value. The destructors of released elements are also called.      [2.x.17]   
* [0.x.11]*
   Change the size of the vector. It keeps old elements previously   available, and initializes each newly added element with the   provided initializer.     If the new vector size is shorter than the old one, the memory is   not immediately released unless the new size is zero; however,   the size of the current object is of course set to the requested   value.    
*  [2.x.18]  This method can only be invoked for classes that define the copy   assignment operator. Otherwise, compilation will fail.      [2.x.19]   
* [0.x.12]*
   Reserve memory space for  [2.x.20]  elements.     If the argument  [2.x.21]  is less than the current number of stored   elements (as indicated by calling size()), then this function does not   do anything at all. Except if the argument  [2.x.22]  is set   to zero, then all previously allocated memory is released (this operation   then being equivalent to directly calling the clear() function).     In order to avoid too frequent reallocation (which involves copy of the   data), this function doubles the amount of memory occupied when the given   size is larger than the previously allocated size.     Note that this function only changes the amount of elements the object  can* store, but not the number of elements itactually* stores. As   a consequence, no constructors or destructors of newly created objects   are run, though the existing elements may be moved to a new location (which   involves running the move constructor at the new location and the   destructor at the old location).  
* [0.x.13]*
   Releases all previously allocated memory and leaves the vector in a state   equivalent to the state after the default constructor has been called.  
* [0.x.14]*
   Inserts an element at the end of the vector, increasing the vector size   by one. Note that the allocated size will double whenever the previous   space is not enough to hold the new element.  
* [0.x.15]*
   Return the last element of the vector (read and write access).  
* [0.x.16]*
   Return the last element of the vector (read-only access).  
* [0.x.17]*
   Inserts several elements at the end of the vector given by a range of   elements.  
* [0.x.18]*
   Fills the vector with size() copies of a default constructed object.    
*  [2.x.23]  Unlike the other fill() function, this method can also be   invoked for classes that do not define a copy assignment   operator.      [2.x.24]   
* [0.x.19]*
   Fills the vector with size() copies of the given input.    
*  [2.x.25]  This method can only be invoked for classes that define the copy   assignment operator. Otherwise, compilation will fail.      [2.x.26]   
* [0.x.20]*
   This function replicates the state found on the process indicated by    [2.x.27]  across all processes of the MPI communicator. The current   state found on any of the processes other than  [2.x.28]  is lost   in this process. One can imagine this operation to act like a call to    [2.x.29]  from the root process to all other processes,   though in practice the function may try to move the data into shared   memory regions on each of the machines that host MPI processes and   let all MPI processes on this machine then access this shared memory   region instead of keeping their own copy.     The intent of this function is to quickly exchange large arrays from   one process to others, rather than having to compute or create it on   all processes. This is specifically the case for data loaded from   disk
* 
*  -  say, large data tables
* 
*  -  that are more easily dealt with by   reading once and then distributing across all processes in an MPI   universe, than letting each process read the data from disk itself.   Specifically, the use of shared memory regions allows for replicating   the data only once per multicore machine in the MPI universe, rather   than replicating data once for each MPI process. This results in   large memory savings if the data is large on today's machines that   can easily house several dozen MPI processes per shared memory   space. This use case is outlined in the TableBase class documentation   as the current function is called from    [2.x.30]  Indeed, the primary rationale   for this function is to enable sharing data tables based on TableBase   across MPI processes.     This function does not imply a model of keeping data on different processes   in sync, as  [2.x.31]  and other vector classes do where   there exists a notion of certain elements of the vector owned by each   process and possibly ghost elements that are mirrored from its owning   process to other processes. Rather, the elements of the current object are   simply copied to the other processes, and it is useful to think of this   operation as creating a set of `const` AlignedVector objects on all   processes that should not be changed any more after the replication   operation, as this is the only way to ensure that the vectors remain the   same on all processes. This is particularly true because of the use of   shared memory regions where any modification of a vector element on one MPI   process may also result in a modification of elements visible on other   processes, assuming they are located within one shared memory node.    
*  [2.x.32]  The use of shared memory between MPI processes requires     that the detected MPI installation supports the necessary operations.     This is the case for MPI 3.0 and higher.    
*  [2.x.33]  This function is not cheap. It needs to create sub-communicators     of the provided  [2.x.34]  object, which is generally an expensive     operation. Likewise, the generation of shared memory spaces is not     a cheap operation. As a consequence, this function primarily makes     sense when the goal is to share large read-only data tables among     processes; examples are data tables that are loaded at start-up     time and then used over the course of the run time of the program.     In such cases, the start-up cost of running this function can be     amortized over time, and the potential memory savings from not having to     store the table on each process may be substantial on machines with     large core counts on which many MPI processes run on the same machine.    
*  [2.x.35]  This function only makes sense if the data type `T` is     "self-contained", i.e., all if its information is stored in its     member variables, and if none of the member variables are pointers     to other parts of the memory. This is because if a type `T` does     have pointers to other parts of memory, then moving `T` into     a shared memory space does not result in the other processes having     access to data that the object points to with its member variable     pointers: These continue to live only on one process, and are     typically in memory areas not accessible to the other processes.     As a consequence, the usual use case for this function is to share     arrays of simple objects such as `double`s or `int`s.    
*  [2.x.36]  After calling this function, objects on different MPI processes     share a common state. That means that certain operations become     "collective", i.e., they must be called on all participating     processors at the same time. In particular, you can no longer call     resize(), reserve(), or clear() on one MPI process
* 
*  -  you have to do     so on all processes at the same time, because they have to communicate     for these operations. If you do not do so, you will likely get     a deadlock that may be difficult to debug. By extension, this rule of     only collectively resizing extends to this function itself: You can     not call it twice in a row because that implies that first all but the     `root_process` throw away their data, which is not a collective     operation. Generally, these restrictions on what can and can not be     done hint at the correctness of the comments above: You should treat     an AlignedVector on which the current function has been called as     `const`, on which no further operations can be performed until     the destructor is called.  
* [0.x.21]*
   Swaps the given vector with the calling vector.  
* [0.x.22]*
   Return whether the vector is empty, i.e., its size is zero.  
* [0.x.23]*
   Return the size of the vector.  
* [0.x.24]*
   Return the capacity of the vector, i.e., the size this vector can hold   without reallocation. Note that capacity() >= size().  
* [0.x.25]*
   Read-write access to entry  [2.x.37]  in the vector.  
* [0.x.26]*
   Read-only access to entry  [2.x.38]  in the vector.  
* [0.x.27]*
   Return a pointer to the underlying data buffer.  
* [0.x.28]*
   Return a const pointer to the underlying data buffer.  
* [0.x.29]*
   Return a read and write pointer to the beginning of the data array.  
* [0.x.30]*
   Return a read and write pointer to the end of the data array.  
* [0.x.31]*
   Return a read-only pointer to the beginning of the data array.  
* [0.x.32]*
   Return a read-only pointer to the end of the data array.  
* [0.x.33]*
   Return the memory consumption of the allocated memory in this class. If   the underlying type  [2.x.39]  allocates memory by itself, this memory is not   counted.  
* [0.x.34]*
   Write the data of this object to a stream for the purpose of   serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.35]*
   Read the data of this object from a stream for the purpose of   serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.36]*
   Write and read the data of this object from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.37]*
   Pointer to actual data array.  
* [0.x.38]*
   Pointer to one past the last valid value.  
* [0.x.39]*
   Pointer to the end of the allocated memory.  
* [0.x.40]*
 This namespace defines the copy and set functions used in AlignedVector. These functions operate in parallel when there are enough elements in the vector.

* 
* [0.x.41]*
   A class that given a range of memory locations calls the placement-new   operator on these memory locations and copy-constructs objects of type   `T` there.     This class is based on the specialized for loop base class   ParallelForLoop in parallel.h whose purpose is the following: When   calling a parallel for loop on AlignedVector with apply_to_subranges, it   generates different code for every different argument we might choose (as   it is templated). This gives a lot of code (e.g. it triples the memory   required for compiling the file matrix_free.cc and the final object size   is several times larger) which is completely useless. Therefore, this   class channels all copy commands through one call to apply_to_subrange   for all possible types, which makes the copy operation much cleaner   (thanks to a virtual function, whose cost is negligible in this context).      [2.x.40]  AlignedVector  
* [0.x.42]*
     Constructor. Issues a parallel call if there are sufficiently many     elements, otherwise works in serial. Copies the data from the half-open     interval between  [2.x.41]  and  [2.x.42]  to array starting at      [2.x.43]  (by calling the copy constructor with placement new).         The elements from the source array are simply copied via the placement     new copy constructor.    
* [0.x.43]*
     This method moves elements from the source to the destination given in     the constructor on a subrange given by two integers.    
* [0.x.44]*
   Like AlignedVectorCopyConstruct, but use the move-constructor of `T`   to create new objects.      [2.x.44]  AlignedVector  
* [0.x.45]*
     Constructor. Issues a parallel call if there are sufficiently many     elements, otherwise works in serial. Moves the data from the half-open     interval between  [2.x.45]  and  [2.x.46]  to array starting at      [2.x.47]  (by calling the move constructor with placement new).         The data is moved between the two arrays by invoking the destructor on     the source range (preparing for a subsequent call to free).    
* [0.x.46]*
     This method moves elements from the source to the destination given in     the constructor on a subrange given by two integers.    
* [0.x.47]*
   A class that given a range of memory locations calls either calls   the placement-new operator on these memory locations (if   `initialize_memory==true`) or just copies the given initializer   into this memory location (if `initialize_memory==false`). The   latter is appropriate for classes that have only trivial constructors,   such as the built-in types `double`, `int`, etc., and structures   composed of such types.      [2.x.48]  initialize_memory Determines whether the set command should   initialize memory (with a call to the copy constructor) or rather use the   copy assignment operator. A template is necessary to select the   appropriate operation since some classes might define only one of those   two operations.      [2.x.49]  AlignedVector  
* [0.x.48]*
     Constructor. Issues a parallel call if there are sufficiently many     elements, otherwise work in serial.    
* [0.x.49]*
     This sets elements on a subrange given by two integers.    
* [0.x.50]*
   Like AlignedVectorInitialize, but use default-constructed objects   as initializers.      [2.x.50]  initialize_memory Sets whether the set command should   initialize memory (with a call to the copy constructor) or rather use the   copy assignment operator. A template is necessary to select the   appropriate operation since some classes might define only one of those   two operations.      [2.x.51]  AlignedVector  
* [0.x.51]*
     Constructor. Issues a parallel call if there are sufficiently many     elements, otherwise work in serial.    
* [0.x.52]*
     This initializes elements on a subrange given by two integers.    
* [0.x.53]*
 Relational operator == for AlignedVector
*   [2.x.52]  AlignedVector

* 
* [0.x.54]*
 Relational operator != for AlignedVector
*   [2.x.53]  AlignedVector

* 
* [0.x.55]

include/deal.II-translator/base/array_view_0.txt
[0.x.0]*
 A class that represents a window of memory locations of type  [2.x.0]  and presents it as if it was an array. In essence, this class is nothing more than just a pointer to the first location and an integer that represents the length of the array in elements. The memory remains owned by whoever allocated it, as this class does not take over ownership.
*  The advantage of using this class is that you don't have to pass around pairs of pointers and that  [2.x.1]  checks for the validity of the index with which you subscript this array view. Note that accessing elements is only allowed if the underlying data is stored in CPU memory.
*  This class can handle views to both non-constant and constant memory locations. If you want to represent a view of a constant array, then the template argument type of this class needs to be  [2.x.2]  as well. The following code snippet gives an example:

* 
* [1.x.0]
*  In either case, accessing an element of a view does not change the ArrayView object itself, and consequently  [2.x.3]  is a  [2.x.4]  const function. This corresponds to the notion that a view simply represents a, well, "view" of memory that is owned by someone else. Thus, accessing elements of the view changes the memory managed by some other object, but not the view itself, allowing us to make  [2.x.5]  a  [2.x.6]  member function. This is in contrast to, say,  [2.x.7]  which manages the memory it points to and changing an element of the  [2.x.8]  therefore changes the  [2.x.9]  object itself
* 
*  -  consequently, the  [2.x.10]  is non- [2.x.11] 
* 

* 
*  [2.x.12]  This class is similar to    [2.x.13]  but the   latter is only available starting in C++20.
* 

* 
*  [2.x.14] 

* 
* [0.x.1]*
   An alias that denotes the "value_type" of this container-like class,   i.e., the type of the element it "stores" or points to.  
* [0.x.2]*
   An alias for iterators pointing into the array.  
* [0.x.3]*
   An alias for const iterators pointing into the array.  
* [0.x.4]*
   Default constructor.  
* [0.x.5]*
   Constructor.      [2.x.15]  starting_element A pointer to the first element of the array   this object should represent.    [2.x.16]  n_elements The length (in elements) of the chunk of memory   this object should represent.    
*  [2.x.17]  The object that is constructed from these arguments has no   knowledge how large the object into which it points really is. As a   consequence, whenever you call  [2.x.18]  the array view can   check that the given index is within the range of the view, but it can't   check that the view is indeed a subset of the valid range of elements of   the underlying object that allocated that range. In other words, you need   to ensure that the range of the view specified by the two arguments to   this constructor is in fact a subset of the elements of the array into   which it points. The appropriate way to do this is to use the   make_array_view() functions.  
* [0.x.6]*
   Copy constructor from array views that point to non- [2.x.19]  elements. If   the current object will point to non- [2.x.20]  elements, then this is a   straight forward copy constructor. On the other hand, if the current   type's  [2.x.21]  template argument is a  [2.x.22]  qualified type,   then the current constructor is a conversion constructor that converts a   non- [2.x.23]  view to a  [2.x.24]  view, akin to converting a non- [2.x.25]    pointer to a  [2.x.26]  pointer.  
* [0.x.7]*
   A constructor that automatically creates a view from a single value_type   object. The view so created then has length one.  
* [0.x.8]*
   A constructor that automatically creates a view from a  [2.x.27]  object.   The view encompasses all elements of the given vector.     This implicit conversion constructor is particularly useful when calling   a function that takes an ArrayView object as argument, and passing in   a  [2.x.28]     
*  [2.x.29]  This constructor takes a reference to a  [2.x.30]  vector as argument.     It can only be used to initialize ArrayView objects that point to      [2.x.31]  memory locations, such as  [2.x.32] .     You cannot initialize ArrayView objects to non- [2.x.33]  memory with     such arguments, such as  [2.x.34] .  
* [0.x.9]*
   A constructor that automatically creates a view from a  [2.x.35]  object.   The view encompasses all elements of the given vector.     This implicit conversion constructor is particularly useful when calling   a function that takes an ArrayView object as argument, and passing in   a  [2.x.36]     
*  [2.x.37]  This constructor takes a reference to a non- [2.x.38]  vector as     argument. It can be used to initialize ArrayView objects that point to     either  [2.x.39]  memory locations, such as      [2.x.40] , or to non- [2.x.41]  memory,     such as  [2.x.42] .  
* [0.x.10]*
   A constructor that automatically creates a view for a given C-style array.   This constructor can be used as follows:  
* [1.x.1]
*    The object so returned is then a view of the array, with the size 7   correctly deduced.  
* [0.x.11]*
   A constructor that automatically creates a view from a  [2.x.43]  object.   The view encompasses all elements of the given vector.     This implicit conversion constructor is particularly useful when calling   a function that takes an ArrayView object as argument, and passing in   a  [2.x.44]   
* [0.x.12]*
   A constructor that automatically creates a view from a  [2.x.45]  object.   The view encompasses all elements of the given vector.     This implicit conversion constructor is particularly useful when calling   a function that takes an ArrayView object as argument, and passing in   a  [2.x.46]   
* [0.x.13]*
   Reinitialize a view.      [2.x.47]  starting_element A pointer to the first element of the array   this object should represent.    [2.x.48]  n_elements The length (in elements) of the chunk of memory   this object should represent.    
*  [2.x.49]  The object that is constructed from these arguments has no   knowledge how large the object into which it points really is. As a   consequence, whenever you call  [2.x.50]  the array view can   check that the given index is within the range of the view, but it can't   check that the view is indeed a subset of the valid range of elements of   the underlying object that allocated that range. In other words, you need   to ensure that the range of the view specified by the two arguments to   this constructor is in fact a subset of the elements of the array into   which it points. The appropriate way to do this is to use the   make_array_view() functions.  
* [0.x.14]*
   Compare two ArrayView objects of the same type. Two objects are considered   equal if they have the same size and the same starting pointer.   This version always compares with the const value_type.  
* [0.x.15]*
   Compare two ArrayView objects of the same type. Two objects are considered   equal if they have the same size and the same starting pointer.   This version always compares with the non-const value_type.  
* [0.x.16]*
   Compare two ArrayView objects of the same type. Two objects are considered   equal if they have the same size and the same starting pointer.   This version always compares with the const value_type.  
* [0.x.17]*
   Compare two ArrayView objects of the same type. Two objects are considered   equal if they have the same size and the same starting pointer.   This version always compares with the non-const value_type.  
* [0.x.18]*
   Return the size (in elements) of the view of memory this object   represents.  
* [0.x.19]*
   Return a pointer to the underlying array serving as element storage.   In case the container is empty a nullptr is returned.  
* [0.x.20]*
   Return an iterator pointing to the beginning of the array view.  
* [0.x.21]*
   Return an iterator pointing to one past the end of the array view.  
* [0.x.22]*
   Return a constant iterator pointing to the beginning of the array view.  
* [0.x.23]*
   Return a constant iterator pointing to one past the end of the array view.  
* [0.x.24]*
   Return a reference to the  [2.x.51] th element of the range represented by the   current object.     This function is marked as  [2.x.52]  because it does not change the    [2.x.53] view object [2.x.54] . It may however return a reference to a non- [2.x.55]    memory location depending on whether the template type of the class is  [2.x.56]    const or not.     This function is only allowed to be called if the underlying data is indeed   stored in CPU memory.  
* [0.x.25]*
   A pointer to the first element of the range of locations in memory that   this object represents.  
* [0.x.26]*
   The length of the array this object represents.  
* [0.x.27]*
     Return whether the objects one gets by dereferencing the     iterators within the given iterator range form a contiguous     range in memory.    
* [0.x.28]*
     Return whether the objects one gets by dereferencing the     iterators within the given iterator range form a contiguous     range in memory.         This specialization for ( [2.x.57]  or non- [2.x.58]  pointers     returns  [2.x.59]  unconditionally since the fact that objects     pointed to by pointers are contiguous is embedded in the memory     model of C++.    
* [0.x.29]*
 Create an ArrayView that takes a pair of iterators as arguments. The type of the ArrayView is inferred from the value type of the iterator (e.g., the view created from two const iterators will have a const type).
*   [2.x.60]  The iterators  [2.x.61]  and  [2.x.62]  must bound (in the usual half-open way) a contiguous in memory range of values. This function is intended for use with iterators into containers like  [2.x.63]  and will not work correctly with, e.g.,  [2.x.64] . In debug mode, we check that the provided iterators represent contiguous memory indeed.
*   [2.x.65]  ArrayView

* 
* [0.x.30]*
 Create a view from a pair of pointers.  [2.x.66]  may be const-qualified.
*   [2.x.67]  The pointers  [2.x.68]  and  [2.x.69]  must bound (in the usual half-open way) a contiguous in memory range of values.
*   [2.x.70]  ArrayView

* 
* [0.x.31]*
 Create a view from an ArrayView itself.
*  This function is used for  [2.x.71]  references to objects of ArrayView type. It only exists for compatibility purposes.
*   [2.x.72]  array_view The ArrayView that we wish to make a copy of.
*   [2.x.73]  ArrayView

* 
* [0.x.32]*
 Create a view from an ArrayView itself.
*  This function is used for non- [2.x.74]  references to objects of ArrayView type. It only exists for compatibility purposes.
*   [2.x.75]  array_view The ArrayView that we wish to make a copy of.
*   [2.x.76]  ArrayView

* 
* [0.x.33]*
 Create a view to an entire Tensor object. This is equivalent to initializing an ArrayView object with a pointer to the first element and the size of the given argument.
*  This function is used for  [2.x.77]  references to objects of Tensor type because they contain immutable elements. Consequently, the return type of this function is a view to a set of  [2.x.78]  objects.
*   [2.x.79]  tensor The Tensor for which we want to have an array view object. The array view corresponds to the  [2.x.80] entire [2.x.81]  object but the order in which the entries are presented in the array is an implementation detail and should not be relied upon.
*   [2.x.82]  ArrayView

* 
* [0.x.34]*
 Create a view to an entire Tensor object. This is equivalent to initializing an ArrayView object with a pointer to the first element and the size of the given argument.
*  This function is used for non- [2.x.83]  references to objects of Tensor type. Such objects contain elements that can be written to. Consequently, the return type of this function is a view to a set of writable objects.
*   [2.x.84]  tensor The Tensor for which we want to have an array view object. The array view corresponds to the  [2.x.85] entire [2.x.86]  object but the order in which the entries are presented in the array is an implementation detail and should not be relied upon.
*   [2.x.87]  ArrayView

* 
* [0.x.35]*
 Create a view to an entire SymmetricTensor object. This is equivalent to initializing an ArrayView object with a pointer to the first element and the size of the given argument.
*  This function is used for  [2.x.88]  references to objects of SymmetricTensor type because they contain immutable elements. Consequently, the return type of this function is a view to a set of  [2.x.89]  objects.
*   [2.x.90]  tensor The SymmetricTensor for which we want to have an array view object. The array view corresponds to the  [2.x.91] entire [2.x.92]  object but the order in which the entries are presented in the array is an implementation detail and should not be relied upon.
*   [2.x.93]  ArrayView

* 
* [0.x.36]*
 Create a view to an entire SymmetricTensor object. This is equivalent to initializing an ArrayView object with a pointer to the first element and the size of the given argument.
*  This function is used for non- [2.x.94]  references to objects of SymmetricTensor type. Such objects contain elements that can be written to. Consequently, the return type of this function is a view to a set of writable objects.
*   [2.x.95]  tensor The SymmetricTensor for which we want to have an array view object. The array view corresponds to the  [2.x.96] entire [2.x.97]  object but the order in which the entries are presented in the array is an implementation detail and should not be relied upon.
*   [2.x.98]  ArrayView

* 
* [0.x.37]*
 Create a view to an entire C-style array. This is equivalent to initializing an ArrayView object with a pointer to the first element and the size of the given argument.
*  Whether the resulting ArrayView is writable or not depends on the ElementType being a const type or not.
*   [2.x.99]  array The C-style array for which we want to have an ArrayView object. The ArrayView corresponds to the  [2.x.100] entire [2.x.101]  vector.
*   [2.x.102]  ArrayView

* 
* [0.x.38]*
 Create a view to an entire Vector object. This is equivalent to initializing an ArrayView object with a pointer to the first element and the size of the given argument.
*  This function is used for non- [2.x.103]  references to objects of Vector type. Such objects contain elements that can be written to. Consequently, the return type of this function is a view to a set of writable objects.
*   [2.x.104]  vector The Vector for which we want to have an array view object. The array view corresponds to the  [2.x.105] entire [2.x.106]  Vector.
*   [2.x.107]  ArrayView

* 
* [0.x.39]*
 Create a view to an entire Vector object. This is equivalent to initializing an ArrayView object with a pointer to the first element and the size of the given argument.
*  This function is used for  [2.x.108]  references to objects of Vector type because they contain immutable elements. Consequently, the return type of this function is a view to a set of  [2.x.109]  objects.
*   [2.x.110]  vector The Vector for which we want to have an array view object. The array view corresponds to the  [2.x.111] entire [2.x.112]  Vector.
*   [2.x.113]  ArrayView

* 
* [0.x.40]*
 Create a view to an entire  [2.x.114]  object. This is equivalent to initializing an ArrayView object with a pointer to the first element and the size of the given argument.
*  This function is used for non- [2.x.115]  references to objects of vector type. Such objects contain elements that can be written to. Consequently, the return type of this function is a view to a set of writable objects.
*   [2.x.116]  vector The vector for which we want to have an array view object. The array view corresponds to the  [2.x.117] entire [2.x.118]  vector.
*   [2.x.119]  ArrayView

* 
* [0.x.41]*
 Create a view to an entire  [2.x.120]  object. This is equivalent to initializing an ArrayView object with a pointer to the first element and the size of the given argument.
*  This function is used for  [2.x.121]  references to objects of vector type because they contain immutable elements. Consequently, the return type of this function is a view to a set of  [2.x.122]  objects.
*   [2.x.123]  vector The vector for which we want to have an array view object. The array view corresponds to the  [2.x.124] entire [2.x.125]  vector.
*   [2.x.126]  ArrayView

* 
* [0.x.42]*
 Create a view to a part of a  [2.x.127]  object. This is equivalent to initializing the ArrayView object with a pointer to the  [2.x.128]  th element and the  [2.x.129]  as the length of the view.
*  This function is used for non- [2.x.130]  references to objects of vector type. Such objects contain elements that can be written to. Consequently, the return type of this function is a view to a set of writable objects.
*   [2.x.131]  vector The vector for which we want to have an array view object.  [2.x.132]  starting_index The index of the first element of the vector that will be part of this view.  [2.x.133]  size_of_view Number of elements in the new ArrayView.
*   [2.x.134]   [2.x.135] 
*   [2.x.136]  ArrayView

* 
* [0.x.43]*
 Create a view to a part of a  [2.x.137]  object. This is equivalent to initializing the ArrayView object with a pointer to the  [2.x.138]  th element and the  [2.x.139]  as the length of the view.
*  This function is used for  [2.x.140]  references to objects of vector type because they contain immutable elements. Consequently, the return type of this function is a view to a set of  [2.x.141]  objects.
*   [2.x.142]  vector The vector for which we want to have an array view object.  [2.x.143]  starting_index The index of the first element of the vector that will be part of this view.  [2.x.144]  size_of_view Number of elements in the new ArrayView.
*   [2.x.145]   [2.x.146] 
*   [2.x.147]  ArrayView

* 
* [0.x.44]*
 Create a view to an entire row of a Table<2> object. This is equivalent to initializing an ArrayView object with a pointer to the first element of the given row, and the length of the row as the length of the view.
*  This function is used for non- [2.x.148]  references to objects of Table type. Such objects contain elements that can be written to. Consequently, the return type of this function is a view to a set of writable objects.
*   [2.x.149]  table The Table for which we want to have an array view object. The array view corresponds to an  [2.x.150] entire [2.x.151]  row.  [2.x.152]  row The index of the row into the table to which this view should correspond.
*   [2.x.153]  ArrayView

* 
* [0.x.45]*
 Create a view to an entire Table<2> object. This is equivalent to initializing an ArrayView object with a pointer to the first element of the given table, and the number of table entries as the length of the view.
*  This function is used for non- [2.x.154]  references to objects of Table type. Such objects contain elements that can be written to. Consequently, the return type of this function is a view to a set of writable objects.
*   [2.x.155]  table The Table for which we want to have an array view object. The array view corresponds to the  [2.x.156] entire [2.x.157]  table but the order in which the entries are presented in the array is an implementation detail and should not be relied upon.
*   [2.x.158]  ArrayView

* 
* [0.x.46]*
 Create a view to an entire Table<2> object. This is equivalent to initializing an ArrayView object with a pointer to the first element of the given table, and the number of table entries as the length of the view.
*  This function is used for  [2.x.159]  references to objects of Table type because they contain immutable elements. Consequently, the return type of this function is a view to a set of  [2.x.160]  objects.
*   [2.x.161]  table The Table for which we want to have an array view object. The array view corresponds to the  [2.x.162] entire [2.x.163]  table but the order in which the entries are presented in the array is an implementation detail and should not be relied upon.
*   [2.x.164]  ArrayView

* 
* [0.x.47]*
 Create a view to an entire LAPACKFullMatrix object. This is equivalent to initializing an ArrayView object with a pointer to the first element of the given object, and the number entries as the length of the view.
*  This function is used for  [2.x.165]  references to objects of LAPACKFullMatrix type. Such objects contain elements that can be written to. Consequently, the return type of this function is a view to a set of  [2.x.166]  objects.
*   [2.x.167]  matrix The LAPACKFullMatrix for which we want to have an array view object. The array view corresponds to the  [2.x.168] entire [2.x.169]  object but the order in which the entries are presented in the array is an implementation detail and should not be relied upon.
*   [2.x.170]  ArrayView

* 
* [0.x.48]*
 Create a view to an entire LAPACKFullMatrix object. This is equivalent to initializing an ArrayView object with a pointer to the first element of the given object, and the number of entries as the length of the view.
*  This function is used for  [2.x.171]  references to objects of LAPACKFullMatrix type because they contain immutable elements. Consequently, the return type of this function is a view to a set of  [2.x.172]  objects.
*   [2.x.173]  matrix The LAPACKFullMatrix for which we want to have an array view object. The array view corresponds to the  [2.x.174] entire [2.x.175]  object but the order in which the entries are presented in the array is an implementation detail and should not be relied upon.
*   [2.x.176]  ArrayView

* 
* [0.x.49]*
 Create a view to an entire row of a Table<2> object. This is equivalent to initializing an ArrayView object with a pointer to the first element of the given row, and the length of the row as the length of the view.
*  This function is used for  [2.x.177]  references to objects of Table type because they contain immutable elements. Consequently, the return type of this function is a view to a set of  [2.x.178]  objects.
*   [2.x.179]  table The Table for which we want to have an array view object. The array view corresponds to an  [2.x.180] entire [2.x.181]  row.  [2.x.182]  row The index of the row into the table to which this view should correspond.
*   [2.x.183]  ArrayView

* 
* [0.x.50]*
 Create a view to (a part of) a row of a Table<2> object.
*  This function is used for non- [2.x.184]  references to objects of Table type. Such objects contain elements that can be written to. Consequently, the return type of this function is a view to a set of writable objects.
*   [2.x.185]  table The Table for which we want to have an array view object. The array view corresponds to an  [2.x.186] entire [2.x.187]  row.  [2.x.188]  row The index of the row into the table to which this view should correspond.  [2.x.189]  starting_column The index of the column into the given row of the table that corresponds to the first element of this view.  [2.x.190]  size_of_view The number of elements this view should have. This corresponds to the number of columns in the current row to which the view should correspond.
*   [2.x.191]  ArrayView

* 
* [0.x.51]*
 Create a view to (a part of) a row of a Table<2> object.
*  This function is used for  [2.x.192]  references to objects of Table type because they contain immutable elements. Consequently, the return type of this function is a view to a set of  [2.x.193]  objects.
*   [2.x.194]  table The Table for which we want to have an array view object. The array view corresponds to an  [2.x.195] entire [2.x.196]  row.  [2.x.197]  row The index of the row into the table to which this view should correspond.  [2.x.198]  starting_column The index of the column into the given row of the table that corresponds to the first element of this view.  [2.x.199]  size_of_view The number of elements this view should have. This corresponds to the number of columns in the current row to which the view should correspond.
*   [2.x.200]  ArrayView

* 
* [0.x.52] Create a view that doesn't allow the container it points to to be modified. This is useful if the object passed in is not `const` already and a function requires a view to constant memory in its signature.
*  This function returns an object of type `ArrayView<const T>` where `T` is the element type of the container.
*   [2.x.201]  ArrayView

* 
* [0.x.53]

include/deal.II-translator/base/auto_derivative_function_0.txt
[0.x.0]*
 This class automatically computes the gradient of a function by employing numerical difference quotients. This only, if the user function does not provide the gradient function himself.
*  The following example of an user defined function overloads and implements only the value() function but not the gradient() function. If the gradient() function is invoked then the gradient function implemented by the AutoDerivativeFunction is called, where the latter function employs numerical difference quotients.
* 

* 
* [1.x.0]
* 
*  If the user overloads and implements also the gradient function, then, of course, the users gradient function is called.
*  Note, that the usage of the value() and gradient() functions explained above, also applies to the value_list() and gradient_list() functions as well as to the vector valued versions of these functions, see e.g. vector_value(), vector_gradient(), vector_value_list() and vector_gradient_list().
*  The gradient() and gradient_list() functions make use of the  [2.x.0]  function. The vector_gradient() and vector_gradient_list() make use of the  [2.x.1]  function. Make sure that the user defined function implements the value() function and the vector_value() function, respectively.
*  Furthermore note, that an object of this class does [1.x.1] represent the derivative of a function, like FunctionDerivative, that gives a directional derivative by calling the value() function. In fact, this class (the AutoDerivativeFunction class) can substitute the Function class as base class for user defined classes. This class implements the gradient() functions for automatic computation of numerical difference quotients and serves as intermediate class between the base Function class and the user defined function class.
* 

* 
*  [2.x.2] 

* 
* [0.x.1]*
   Names of difference formulas.  
* [0.x.2]*
     The symmetric Euler formula of second order:     [1.x.2]    
* [0.x.3]*
     The upwind Euler formula of first order:     [1.x.3]    
* [0.x.4]*
     The fourth order scheme     [1.x.4]    
* [0.x.5]*
   Constructor. Takes the difference step size <tt>h</tt>. It's within the   user's responsibility to choose an appropriate value here. <tt>h</tt>   should be chosen taking into account the absolute value as well as the   amount of local variation of the function. Setting <tt>h=1e-6</tt> might   be a good choice for functions with an absolute value of about 1, that   furthermore does not vary to much.     <tt>h</tt> can be changed later using the set_h() function.     Sets DifferenceFormula <tt>formula</tt> to the default <tt>Euler</tt>   formula of the set_formula() function. Change this preset formula by   calling the set_formula() function.  
* [0.x.6]*
   Virtual destructor; absolutely necessary in this case.  
* [0.x.7]*
   Choose the difference formula. See the enum #DifferenceFormula for   available choices.  
* [0.x.8]*
   Takes the difference step size <tt>h</tt>. It's within the user's   responsibility to choose an appropriate value here. <tt>h</tt> should be   chosen taking into account the absolute value of as well as the amount of   local variation of the function. Setting <tt>h=1e-6</tt> might be a good   choice for functions with an absolute value of about 1, that furthermore   does not vary to much.  
* [0.x.9]*
   Return the gradient of the specified component of the function at the   given point.     Compute numerical difference quotients using the preset   #DifferenceFormula.  
* [0.x.10]*
   Return the gradient of all components of the function at the given point.     Compute numerical difference quotients using the preset   #DifferenceFormula.  
* [0.x.11]*
   Set <tt>gradients</tt> to the gradients of the specified component of the   function at the <tt>points</tt>.  It is assumed that <tt>gradients</tt>   already has the right size, i.e.  the same size as the <tt>points</tt>   array.     Compute numerical difference quotients using the preset   #DifferenceFormula.  
* [0.x.12]*
   Set <tt>gradients</tt> to the gradients of the function at the   <tt>points</tt>, for all components. It is assumed that   <tt>gradients</tt> already has the right size, i.e. the same size as the   <tt>points</tt> array.     The outer loop over <tt>gradients</tt> is over the points in the list,   the inner loop over the different components of the function.     Compute numerical difference quotients using the preset   #DifferenceFormula.  
* [0.x.13]*
   Return a #DifferenceFormula of the order <tt>ord</tt> at minimum.  
* [0.x.14]*
   Step size of the difference formula. Set by the set_h() function.  
* [0.x.15]*
   Includes the unit vectors scaled by <tt>h</tt>.  
* [0.x.16]*
   Difference formula. Set by the set_formula() function.  
* [0.x.17]

include/deal.II-translator/base/bounding_box_0.txt
[0.x.0]*
 The enumerator NeighborType describes the neighboring relation between two bounding boxes.

* 
* [0.x.1]*
   Not neighbors: the intersection is empty.  
* [0.x.2]*
   Simple neighbors: the boxes intersect with an intersection of dimension at   most `spacedim
* 
*  - 2`. For example, in 2d this means that the two boxes   touch at one corner of the each box.  
* [0.x.3]*
   Attached neighbors: neighbors with an intersection of   `dimension > spacedim
* 
*  - 2`. For example, in 2d this means that the two   boxes touch along an edge.  
* [0.x.4]*
   Mergeable neighbors: neighbors which can be expressed with a single   BoundingBox, e.g.   
* [1.x.0]
*    or one is inside the other  
* [0.x.5]*
 A class that represents a box of arbitrary dimension <tt>spacedim</tt> and with sides parallel to the coordinate axes, that is, a region
*  [1.x.1]
*  where  [2.x.0] (x_0^U , ..., x_{spacedim-1}^U) denote the two vertices (bottom left and top right) which are used to represent the box.
*  Geometrically, a bounding box is thus:
* 

* 
* 
*  - 1D: a segment (represented by its vertices in the proper order)
* 

* 
* 
*  - 2D: a rectangle (represented by the vertices V at bottom left, top right)

* 
* [1.x.2]
* 
* 

* 
* 
*  - 3D: a cuboid (in which case the two vertices V follow the convention and are not owned by the same face)

* 
* [1.x.3]
* 
*  Bounding boxes are, for example, useful in parallel distributed meshes to give a general description of the owners of each portion of the mesh.
*  Taking the cross section of a BoundingBox<spacedim> orthogonal to a given direction gives a box in one dimension lower: BoundingBox<spacedim
* 
*  - 1>. In 3D, the 2 coordinates of the cross section of BoundingBox<3> can be ordered in 2 different ways. That is, if we take the cross section orthogonal to the y direction we could either order a 3D-coordinate into a 2D-coordinate as  [2.x.1]  or as  [2.x.2] . This class uses the second convention, corresponding to the coordinates being ordered cyclicly  [2.x.3]  To be precise, if we take a cross section:
*  | Orthogonal to | Cross section coordinates ordered as | |:-------------:|:------------------------------------:| |      x        |               (y, z)                 | |      y        |               (z, x)                 | |      z        |               (x, y)                 |
*  This is according to the convention set by the function  [2.x.4] .

* 
* [0.x.6]*
   Standard constructor. Creates an object that corresponds to an empty box,   i.e. a degenerate box with both points being the origin.  
* [0.x.7]*
   Standard constructor for non-empty boxes: it uses a pair of points   which describe the box: one for the bottom and one for the top   corner.  
* [0.x.8]*
   Construct the bounding box that encloses all the points in the given   container.     The constructor supports any Container that provides begin() and end()   iterators to Point<spacedim, Number> elements.  
* [0.x.9]*
   Return a reference to the boundary_points  
* [0.x.10]*
   Return a const reference to the boundary_points  
* [0.x.11]*
   Test for equality.  
* [0.x.12]*
   Test for inequality.  
* [0.x.13]*
   Check if the current object and  [2.x.5]  are neighbors, i.e. if the boxes   have dimension spacedim, check if their intersection is non empty.     Return an enumerator of type NeighborType.  
* [0.x.14]*
   Enlarge the current object so that it contains  [2.x.6]  .   If the current object already contains  [2.x.7]  then it is not changed   by this function.  
* [0.x.15]*
   Return true if the point is inside the Bounding Box, false otherwise. The   parameter  [2.x.8]  is a factor by which the bounding box is enlarged   relative to the dimensions of the bounding box in order to determine in a   numerically robust way whether the point is inside.  
* [0.x.16]*
   Increase (or decrease) the size of the bounding box by the given amount.   After calling this method, the lower left corner of the bounding box will   have each coordinate decreased by  [2.x.9]  and the upper right corner   of the bounding box will have each coordinate increased by  [2.x.10]      If you call this method with a negative number, and one of the axes of the   original bounding box is smaller than amount/2, the method will trigger   an assertion.  
* [0.x.17]*
   Compute the volume (i.e. the dim-dimensional measure) of the BoundingBox.  
* [0.x.18]*
   Returns the point in the center of the box.  
* [0.x.19]*
   Returns the side length of the box in  [2.x.11]   
* [0.x.20]*
   Return the lower bound of the box in  [2.x.12]   
* [0.x.21]*
   Return the upper bound of the box in  [2.x.13]   
* [0.x.22]*
   Return the bounds of the box in  [2.x.14]  as a one-dimensional box.  
* [0.x.23]*
   Returns the indexth vertex of the box. Vertex is meant in the same way as   for a cell, so that  [2.x.15]   [2.x.16] .  
* [0.x.24]*
   Returns the indexth child of the box. Child is meant in the same way as for   a cell.  
* [0.x.25]*
   Returns the cross section of the box orthogonal to  [2.x.17]    This is a box in one dimension lower.    
*  [2.x.18]  Calling this method in 1D will result in an exception since    [2.x.19]  is not implemented.  
* [0.x.26]*
   Apply the affine transformation that transforms this BoundingBox to a unit   BoundingBox object.     If  [2.x.20]  is this bounding box, and  [2.x.21]  is the unit bounding box,   compute the affine mapping that satisfies  [2.x.22]  and apply it to    [2.x.23]   
* [0.x.27]*
   Apply the affine transformation that transforms the unit BoundingBox object   to this object.     If  [2.x.24]  is this bounding box, and  [2.x.25]  is the unit bounding box,   compute the affine mapping that satisfies  [2.x.26]  and apply it to    [2.x.27]   
* [0.x.28]*
   Write or read the data of this object to or from a stream for the   purpose of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.29]*
 Specialization of BoundingBox for spacedim 0. This class exists to enable dimension-independent programming but unconditionally throws an exception in its constructor.

* 
* [0.x.30]*
   Default constructor. Throws an exception.  
* [0.x.31]*
   Equivalent two-point constructor. Throws an exception.  
* [0.x.32]*
   Equivalent container constructor. Throws an exception.  
* [0.x.33]*
 Returns the unit box  [2.x.28] .
*   [2.x.29]  BoundingBox

* 
* [0.x.34]*
   This function defines a convention for how coordinates in dim   dimensions should translate to the coordinates in dim + 1 dimensions,   when one of the coordinates in dim + 1 dimensions is locked to a given   value.     The convention is the following: Starting from the locked coordinate we   store the lower dimensional coordinates consecutively and wrap around   when going over the dimension. This relationship is, in 2D,     | locked in 2D | 1D coordinate | 2D coordinate |   |:------------:|:-------------:|:-------------:|   |     x0       |      (a)      |   (x0,  a)    |   |     x1       |      (a)      |   (a , x1)    |     and, in 3D,     | locked in 3D | 2D coordinates | 3D coordinates |   |:-------------|:--------------:|:--------------:|   |     x0       |    (a, b)      | (x0,  a,  b)   |   |     x1       |    (a, b)      | ( b, x1,  a)   |   |     x2       |    (a, b)      | ( a,  b, x2)   |     Given a locked coordinate, this function maps a coordinate index in dim   dimension to a coordinate index in dim + 1 dimensions.      [2.x.30]  locked_coordinate should be in the range [0, dim+1).    [2.x.31]  coordinate_in_dim should be in the range [0, dim).    [2.x.32]  A coordinate index in the range [0, dim+1)      [2.x.33]  BoundingBox  
* [0.x.35]

include/deal.II-translator/base/bounding_box_data_out_0.txt
[0.x.0]*
 This class generates graphical output for BoundingBox objects, starting from any object that can be converted by boost to a BoundingBox.

* 
* [0.x.1]*
   Constructor.  
* [0.x.2]*
   Destructor.  
* [0.x.3]*
   Generate patches from a range of objects that can be converted by boost to   a collection of BoundingBox objects.     You could pass to this function iterators to BoundingBox objects, or to   pairs or tuples in which the first element is a BoundingBox object.  
* [0.x.4]*
   Generate patches from a container of objects that can be converted by boost   to a collection of BoundingBox objects.     You could pass to this function a container of BoundingBox objects, or a   container of pairs or tuples in which the first element is a BoundingBox   object.  
* [0.x.5]*
   Attach data to each output patch that was generated by build_patches().     The  [2.x.0]  parameter is expected to have the same size of the   container you used in the call to build_patches(), and each entry should   have the same size of the  [2.x.1]  argument.      [2.x.2]  datasets The actual data to attach to each patch    [2.x.3]  dataset_names The name of each component of the dataset  
* [0.x.6]*
   The actual boxes.  
* [0.x.7]*
   Names of datasets.  
* [0.x.8]

include/deal.II-translator/base/communication_pattern_base_0.txt
[0.x.0]*
     CommunicationPattern is an abstract class that is used to define a     communication plan that can be called repeatedly to efficiently obtain     off-processor elements. The idea is to decouple the communication pattern     from the data that needs to be communicated. The goal is to reuse the     same communication pattern for different containers. This is similar to     the way SparseMatrix and SparsityPattern works.    
* [0.x.1]*
       Destructor.      
* [0.x.2]*
       Reinitialize the communication pattern. The first argument       `vector_space_vector_index_set` is the index set associated to a       VectorSpaceVector object. The second argument       `read_write_vector_index_set` is the index set associated to a       ReadWriteVector object.      
* [0.x.3]*
       Return a constant reference to the underlying MPI communicator.      
* [0.x.4]

include/deal.II-translator/base/complex_overloads_0.txt
[0.x.0]*
 Provide an <tt>operator*</tt> that operates on mixed complex floating point types. Annoyingly, the standard library does not provide such an operator...
*   [2.x.0]  ProductType

* 
* [0.x.1]*
 Provide an <tt>operator/</tt> that operates on mixed complex floating point types. Annoyingly, the standard library does not provide such an operator...
*   [2.x.1]  ProductType

* 
* [0.x.2]*
 Provide an <tt>operator*</tt> for a scalar multiplication of a complex floating point type with a different real floating point type. Annoyingly, the standard library does not provide such an operator...
*   [2.x.2]  ProductType

* 
* [0.x.3]*
 Provide an <tt>operator/</tt> for a scalar division of a complex floating point type with a different real floating point type. Annoyingly, the standard library does not provide such an operator...
*   [2.x.3]  ProductType

* 
* [0.x.4]*
 Provide an <tt>operator*</tt> for a scalar multiplication of a real floating point type with a different complex floating point type. Annoyingly, the standard library does not provide such an operator...
*   [2.x.4]  ProductType

* 
* [0.x.5]*
 Provide an <tt>operator/</tt> for a scalar division of a real floating point type with a different complex floating point type. Annoyingly, the standard library does not provide such an operator...
*   [2.x.5]  ProductType

* 
* [0.x.6]

include/deal.II-translator/base/conditional_ostream_0.txt
[0.x.0]*
 A class that allows printing to an output stream, e.g.  [2.x.0]  depending on the ConditionalOStream object being active (default) or not. The condition of this object can be changed by set_condition() and in the constructor. This class is used in the  [2.x.1] ,  [2.x.2] ,  [2.x.3] ,  [2.x.4] , and  [2.x.5]  tutorial programs.
*  This class is mostly useful in parallel computations. Ordinarily, you would use  [2.x.6]  to print messages like what the program is presently doing, or the number of degrees of freedom in each step. However, in parallel programs, this means that each of the MPI processes write to the screen, which yields many repetitions of the same text. To avoid it, one would have to have a designated process, say the one with MPI process number zero, do the output, and guard each write statement with an if- condition. This becomes cumbersome and clutters up the code. Rather than doing so, the present class can be used: objects of its type act just like a standard output stream, but they only print something based on a condition that can be set to, for example, <tt>mpi_process==0</tt>, so that only one process has a true condition and in all other processes writes to this object just disappear in nirvana.
*  The usual usage of this class is as follows:
* 

* 
* [1.x.0]
* 
*  Here, `Reading parameter file on process xy' is printed by each process separately. In contrast to that, `Solving ...' and `done' is printed to standard output only once, namely by process 0.
*  This class is not derived from ostream. Therefore

* 
* [1.x.1]
*  is  [2.x.7] not [2.x.8]  possible. Instead use the is_active() function for a work- around:
* 

* 
* [1.x.2]
* 
* 

* 
*  [2.x.9] 

* 
* [0.x.1]*
   Constructor. Set the stream to which we want to write, and the condition   based on which writes are actually forwarded. Per default the condition   of an object is active.  
* [0.x.2]*
   Depending on the <tt>active</tt> flag set the condition of this stream to   active (true) or non-active (false). An object of this class prints to   <tt>cout</tt> if and only if its condition is active.  
* [0.x.3]*
   Return the condition of the object.  
* [0.x.4]*
   Return a reference to the stream currently in use.  
* [0.x.5]*
   Output a constant something through this stream. This function must be  [2.x.10]    const so that member objects of this type can also be used from  [2.x.11]    member functions of the surrounding class.  
* [0.x.6]*
   Treat ostream manipulators. This function must be  [2.x.12]  so that member   objects of this type can also be used from  [2.x.13]  member functions of   the surrounding class.     Note that compilers want to see this treated differently from the general   template above since functions like  [2.x.14]  are actually overloaded   and can't be bound directly to a template type.  
* [0.x.7]*
   Reference to the stream we want to write to.  
* [0.x.8]*
   Stores the actual condition the object is in.  
* [0.x.9]

include/deal.II-translator/base/convergence_table_0.txt
[0.x.0]*
 The ConvergenceTable class is an application to the TableHandler class and stores some convergence data, such as residuals of the cg-method, or some evaluated [1.x.0]-errors of discrete solutions, etc, and evaluates convergence rates or orders.
*  The already implemented #RateMode's are #reduction_rate, where the convergence rate is the quotient of two following rows, and #reduction_rate_log2, that evaluates the order of convergence. These standard evaluations are useful for global refinement, for local refinement this may not be an appropriate method, as the convergence rates should be set in relation to the number of cells or the number of DoFs. The implementations of these non-standard methods is left to a user.
*  For example, the number of cells may be added to the table by calling `add_value("n cells", n_cells)`. The number of DoFs may be added to the table by calling `add_value("n dofs", n_dofs)`. Of course, one can also add more kinds of information by calling add_value() with other arguments. In any case, before the output of the table the functions evaluate_convergence_rates() and evaluate_all_convergence_rates() may be called.
*  There are two possibilities of how to evaluate the convergence rates of multiple columns in the same RateMode.  [2.x.0]   [2.x.1]  call evaluate_convergence_rates() for all wanted columns  [2.x.2]  call omit_column_from_convergence_rate_evaluation() for all columns for which this evaluation is not desired and then evaluate_all_convergence_rates() to evaluate the convergence rates of all columns that have not been flagged for omission.  [2.x.3] 
*  A detailed discussion of this class can also be found in the  [2.x.4]  and  [2.x.5]  example programs. It is also used in  [2.x.6] .
* 

* 
*  [2.x.7] 

* 
* [0.x.1]*
   Constructor.  
* [0.x.2]*
   Rate in relation to the rows.  
* [0.x.3]*
     Do not do anything.    
* [0.x.4]*
     Quotient of values in the previous row and in this row.    
* [0.x.5]*
     Logarithm of #reduction_rate to the base 2 representing the order of     convergence when halving the grid size, e.g. from h to h/2.    
* [0.x.6]*
   Evaluate the convergence rates of the data column   <tt>data_column_key</tt> due to the #RateMode in relation to the   reference column <tt>reference_column_key</tt>. Be sure that the value   types of the table entries of the data column and the reference data   column is a number, i.e. double, float, (unsigned) int, and so on.     As this class has no information on the space dimension upon which the   reference column vs. the value column is based upon, it needs to be   passed as last argument to this method. The [1.x.1] is 2, which is appropriate for the number of cells   in 2D. If you work in 3D, set the number to 3. If the reference column is    [2.x.8] , remember to set the dimension to 1 also when working in 3D to get   correct rates.     The new rate column and the data column will be merged to a supercolumn.   The tex caption of the supercolumn will be (by default) the same as the   one of the data column. This may be changed by using the   <tt>set_tex_supercaption (...)</tt> function of the base class   TableHandler.     This method behaves in the following way:     If RateMode is reduction_rate, then the computed output is  [2.x.9]  where  [2.x.10]  is the reference column (no   dimension dependence!).     If RateMode is reduction_rate_log2, then the computed output is  [2.x.11] .     This is useful, for example, if we use as reference key the number of   degrees of freedom or better, the number of cells.  Assuming that the   error is proportional to  [2.x.12]  in 2D, then this method   will produce the rate  [2.x.13]  as a result. For general dimension, as   described by the last parameter of this function, the formula needs to be    [2.x.14] .    
*  [2.x.15]  Since this function adds columns to the table after several rows   have already been filled, it switches off the auto fill mode of the   TableHandler base class. If you intend to add further data with auto   fill, you will have to re-enable it after calling this function.  
* [0.x.7]*
   Evaluate the convergence rates of the data column   <tt>data_column_key</tt> due to the #RateMode.  Be sure that the value   types of the table entries of the data column is a number, i.e. double,   float, (unsigned) int, and so on.     The new rate column and the data column will be merged to a supercolumn.   The tex caption of the supercolumn will be (by default) the same as the   one of the data column. This may be changed by using the   set_tex_supercaption() function of the base class TableHandler.    
*  [2.x.16]  Since this function adds columns to the table after several rows   have already been filled, it switches off the auto fill mode of the   TableHandler base class. If you intend to add further data with auto   fill, you will have to re-enable it after calling this function.  
* [0.x.8]*
   Omit this column <tt>key</tt> (not supercolumn!) from the evaluation of   the convergence rates of `all' columns (see the following two functions).     The  [2.x.17]  is reserved for omitting the column from convergence   rate evaluation.  
* [0.x.9]*
   Evaluate convergence rates due to the <tt>rate_mode</tt> in relation to   the reference column <tt>reference_column_key</tt>. This function   evaluates the rates of ALL columns except of the columns that are to be   omitted (see previous function) and except of the columns that are   previously evaluated rate columns.  This function allows to evaluate the   convergence rate for almost all columns of a table without calling   evaluate_convergence_rates() for each column separately.     Example: Columns like <tt>n cells</tt> or <tt>n dofs</tt> columns may be   wanted to be omitted in the evaluation of the convergence rates. Hence   they should omitted by calling the   omit_column_from_convergence_rate_evaluation().  
* [0.x.10]*
   Evaluate convergence rates due to the <tt>rate_mode</tt>. This function   evaluates the rates of ALL columns except of the columns that are to be   omitted (see previous function) and except of the columns that are   previously evaluated rate columns.  This function allows to evaluate the   convergence rate for almost all columns of a table without calling   evaluate_convergence_rates() for each column separately.     Example: Columns like <tt>n cells</tt> or <tt>n dofs</tt> columns may be   wanted to be omitted in the evaluation of the convergence rates. Hence   they should omitted by calling the   omit_column_from_convergence_rate_evaluation().  
* [0.x.11]*
    [2.x.18]  Exceptions    [2.x.19]   
* [0.x.12]*
   Exception  
* [0.x.13]

include/deal.II-translator/base/cuda_0.txt
[0.x.0]*
   A namespace for utility structures for CUDA.  
* [0.x.1]*
     Various CUDA APIs need an object to store internal data. This structure     creates, initializes, stores, and destroys these so-called handles for     the respective CUDA libraries used inside deal.II.    
* [0.x.2]*
       Constructor. Initialize the handles for the different libraries.      
* [0.x.3]*
       Copy constructor is deleted.      
* [0.x.4]*
       Destructor. Destroy the handles.      
* [0.x.5]*
       Pointer to an opaque cuSolverDN context.       The handle must be passed to every cuSolverDN library function.      
* [0.x.6]*
       Pointer to an opaque cuSolverSP context.       The handle must be passed to every cuSolverSP library function.      
* [0.x.7]*
       Pointer to an opaque cuSPARSE context.       The handle must be passed to every cuSPARSE library function.      
* [0.x.8]*
     Allocate  [2.x.0]  on the device.    
* [0.x.9]*
     Free memory on the device.    
* [0.x.10]*
     Allocator to be used for  [2.x.1]  pointing to device memory.    
* [0.x.11]*
     Deleter to be used for  [2.x.2]  pointing to device memory.    
* [0.x.12]*
     Copy the device ArrayView  [2.x.3]  to the host ArrayView  [2.x.4]     
* [0.x.13]*
     Copy the host ArrayView  [2.x.5]  to the device ArrayView  [2.x.6]     
* [0.x.14]*
     Copy the elements in  [2.x.7]  to the host in  [2.x.8]     
* [0.x.15]*
     Copy the elements in  [2.x.9]  to the device in  [2.x.10]  The     memory needs to be allocate on the device before this function is called.    
* [0.x.16]

include/deal.II-translator/base/cuda_size_0.txt
[0.x.0]*
   Define the size of a block when launching a CUDA kernel. This number can be   changed depending on the architecture the code is running on.  
* [0.x.1]*
   Define the size of chunk of data worked on by a thread. This number can be   changed depending on the architecture the code is running on.  
* [0.x.2]*
   Define the number of threads in a warp.  
* [0.x.3]*
   Define the largest finite element degree that can be solved using    [2.x.0]  Changing this number will affect the amount of   constant memory being used.  
* [0.x.4]*
   Define the maximum number of valid  [2.x.1]  object.   Changing this number will affect the amount of constant memory being used.  
* [0.x.5]

include/deal.II-translator/base/data_out_base_0.txt
[0.x.0]*
 This is a base class for output of data on meshes of very general form. Output data is expected as a set of <tt>patches</tt> and written to the output stream in the format expected by the visualization tool. For a list of output formats, check the enumeration #OutputFormat. For each format listed there, this class contains a function <tt>write_format</tt>, writing the output. Refer to the documentation of those functions for details on a certain format.
*  [1.x.0]
*  Data is not written with the deal.II mesh structure. Instead, it relies on a set of <tt>patches</tt> created by a derived class (for example the DataOut, DataOutStack, DataOutFaces, DataOutRotation, or MatrixOut classes).  Each Patch describes a single logical cell of a mesh, possibly subdivided a number of times to represent higher order polynomials defined on this cell. To this end, a patch consists of a <tt>dim</tt>-dimensional regular grid with the same number of grid points in each direction. In the simplest case it may consist of the corner points of a single mesh cell. For each point of this local grid, the Patch contains an arbitrary number of data values, though the number of data sets must be the same for each point on each patch.
*  By offering this interface to the different output formats, it is simple to extend this class to new formats without depending on such things as actual triangulations and handling of data vectors. These things shall be provided by derived class which have a user callable interface then.
*  Inside each patch, the data is organized in the usual lexicographical order, [1.x.1] running fastest, then [1.x.2] and [1.x.3]. Nodes are stored in this order and cells as well. Each cell in 3D is stored such that the front face is in the [1.x.4]-plane. In order to enhance intelligibility of this concept, the following two sections are kept from a previous version of this documentation.
* 

*  [1.x.5]
*  Grids can be thought of as a collection of cells; if you want to write out data on such a grid, you can do so by writing them one cell at a time. The functions in this class therefore take a list of objects describing the data on one cell each. This data for each cell usually consists of a list of vertices for this cell, and a list of data values (for example solution data, error information, etc) at each of these vertices.
*  In some cases, this interface to a cell is too restricted, however. For example, you may have higher order elements and printing the values at the vertices only is not enough. For this reason, we not only provide writing the data on the vertices only, but the data is organizes as a tensor product grid on each cell. The parameter <tt>n_subdivisions</tt>, which is given for each patch separately, denotes how often the cell is to be divided for output; for example, <tt>n_subdivisions==1</tt> yields no subdivision of the cell, <tt>n_subdivisions==2</tt> will produce a grid of 3 times 3 points in two spatial dimensions and 3 times 3 times 3 points in three dimensions, <tt>n_subdivisions==3</tt> will yield 4 times 4 (times 4) points, etc. The actual location of these points on the patch will be computed by a multilinear transformation from the vertices given for this patch.  For cells at the boundary, a mapping might be used to calculate the position of the inner points. In that case the coordinates are stored inside the Patch, as they cannot be easily recovered otherwise.
*  Given these comments, the actual data to be printed on this patch of points consists of several data sets each of which has a value at each of the patch points. For example with <tt>n_subdivisions==2</tt> in two space dimensions, each data set has to provide nine values, and since the patch is to be printed as a tensor product (or its transformation to the real space cell), its values are to be ordered like [1.x.6], i.e. the z-coordinate runs fastest, then the y-coordinate, then x (if there are that many space directions).
* 

*  [1.x.7]
*  In general, the patches as explained above might be too restricted. For example, one might want to draw only the outer faces of a domain in a three-dimensional computation, if one is not interested in what happens inside. Then, the objects that should be drawn are two-dimensional in a three-dimensional world. The Patch class and associated output functions handle these cases. The Patch class therefore takes two template parameters, the first, named <tt>dim</tt> denoting the dimension of the object (in the above example, this would be two), while the second, named <tt>spacedim</tt>, denotes the dimension of the embedding space (this would be three). The corner points of a patch have the dimension of the space, while their number is determined by the dimension of the patch. By default, the second template parameter has the same value as the first, which would correspond to outputting a cell, rather than a face or something else.
*  [1.x.8]
*  The members of this namespace are not usually called from user code directly. Rather, classes that use the functions declared here are typically derived from DataOutInterface.
*  The interface of this class basically consists of the declaration of a data type describing a patch and a bunch of functions taking a list of patches and writing them in one format or other to the stream. It is in the responsibility of the derived classes to provide this list of patches. In addition to the list of patches, a name for each data set may be given.
* 

*  [1.x.9]
*  This class also provides a few functions (parse_output_format(), get_output_format_names(), default_suffix()) that can be used to query which output formats this class supports. The provide a list of names for all the formats we can output, parse a string and return an enum indicating each format, and provide a way to convert a value of this enum into the usual suffix used for files of that name. Using these functions, one can entirely free applications from knowledge which formats the library presently allows to output; several of the example programs show how to do this.
*  [1.x.10]
*  All functions take a parameter which is a structure of type <tt>XFlags</tt>, where <tt>X</tt> is the name of the output format. To find out what flags are presently supported, read the documentation of the different structures.
*  Note that usually the output formats used for scientific visualization programs have no or very few parameters (apart from some compatibility flags) because there the actual appearance of output is determined using the visualization program and the files produced by this class store more or less only raw data.
*  The direct output formats, like Postscript or Povray need to be given a lot more parameters, though, since there the output file has to contain all details of the viewpoint, light source, etc.
*  [1.x.11]
*  An abstraction layer has been introduced to facilitate coding backends for additional visualization tools. It is applicable for data formats separating the information into a field of vertices, a field of connection information for the grid cells and data fields.
*  For each of these fields, output functions are implemented, namely write_nodes(), write_cells() and write_data(). In order to use these functions, a format specific output stream must be written, following the examples of DXStream, GmvStream, VtkStream and so on, implemented in the .cc file.
*  In this framework, the implementation of a new output format is reduced to writing the section headers and the new output stream class for writing a single mesh object.
*  [1.x.12]  [2.x.0] 
*   [2.x.1] EPS output based on an earlier implementation by Stefan Nauber for the old DataOut class
*   [2.x.2] Povray output by Thomas Richter
*   [2.x.3] Tecplot output by Benjamin Shelton Kirk
*   [2.x.4] Lagrange VTK output by Alexander Grayver
*   [2.x.5] 
* 

* 
*  [2.x.6] 

* 
* [0.x.1]*
   Data structure describing a patch of data in <tt>dim</tt> space   dimensions.     A patch consists of the following data:    [2.x.7]     [2.x.8]  the corner #vertices,    [2.x.9]  the number #n_subdivisions of the number of cells the Patch has in   each space direction,    [2.x.10]  the #data attached to each vertex, in the usual lexicographic   ordering,    [2.x.11]  information on #neighbors.    [2.x.12]      See the general documentation of the DataOutBase class for more   information on its contents and purposes.  In the case of two dimensions,   the next picture is an example of <tt>n_subdivisions</tt> = 4 because the   number of (sub)cells within each patch is equal to   <tt>2<sup>dim</sup></tt>.    
*  [2.x.13]   
* [0.x.2]*
     Make the <tt>spacedim</tt> template parameter available.    
* [0.x.3]*
     Corner points of a patch.  Interior points are computed by a multilinear     transformation of the unit cell to the cell specified by these corner     points, if  [2.x.14] .         On the other hand, if  [2.x.15] , then     the coordinates of the points at which output is to be generated     is attached in additional rows to the  [2.x.16]  table.         The order of points is the same as for cells in the     triangulation.    
* [0.x.4]*
     Patch indices of neighbors of the current patch. This is made available     for the OpenDX format that requires neighbor     information for advanced output.    
* [0.x.5]*
     Number of this patch. Since we are not sure patches are always     handled in the same order, we better store this.    
* [0.x.6]*
     Number of subdivisions with which this patch is to be written.     <tt>1</tt> means no subdivision, <tt>2</tt> means bisection, <tt>3</tt>     trisection, etc.    
* [0.x.7]*
     Data vectors. The format is as follows: <tt>data(i,.)</tt> denotes the     data belonging to the <tt>i</tt>th data vector. <tt>data.n_cols()</tt>     therefore equals the number of output points; this number is     <tt>(subdivisions+1)^{dim}</tt>. <tt>data.n_rows()</tt> equals the number     of data vectors. For the current purpose, a data vector equals one     scalar, even if multiple scalars may later be interpreted as vectors.         Within each column, <tt>data(.,j)</tt> are the data values at the     output point <tt>j</tt>, where <tt>j</tt> denotes the usual     lexicographic ordering in deal.II. This is also the order of points as     provided by the <tt>QIterated</tt> class when used with the     <tt>QTrapezoid</tt> class as subquadrature.         Since the number of data vectors is usually the same for all patches to     be printed, <tt>data.size()</tt> should yield the same value for all     patches provided. The exception are patches for which     points_are_available are set, where the actual coordinates of the point     are appended to the 'data' field, see the documentation of the     points_are_available flag.    
* [0.x.8]*
     A flag indicating whether the coordinates of the interior patch points     (assuming that the patch is supposed to be subdivided further) are     appended to the  [2.x.17]  table ( [2.x.18]  or not ( [2.x.19]  The latter     is the default and in this case the locations of the points interior to     this patch are computed by (bi-, tri-)linear interpolation from the     vertices of the patch.         This option exists since patch points may be evaluated using a Mapping     (rather than by a linear interpolation) and therefore have to be stored     in the Patch structure.    
* [0.x.9]*
     Reference-cell type of the underlying cell of this patch.    
* [0.x.10]*
     Default constructor. Sets #n_subdivisions to one, #points_are_available     to false, and #patch_index to #no_neighbor.    
* [0.x.11]*
     Compare the present patch for equality with another one. This is used     in a few of the automated tests in our testsuite.    
* [0.x.12]*
     Return an estimate for the memory consumption, in bytes, of this     object. This is not exact (but will usually be close) because     calculating the memory usage of trees (e.g.,  [2.x.20]  is     difficult.    
* [0.x.13]*
     Swap the current object's contents with those of the given argument.    
* [0.x.14]*
     Value to be used if this patch has no neighbor on one side.    
* [0.x.15]*
      [2.x.21]  Exceptions      [2.x.22]     
* [0.x.16]*
     Exception    
* [0.x.17]*
   A specialization of the general Patch<dim,spacedim> template that is   tailored to the case of points, i.e., zero-dimensional objects embedded   in  [2.x.23]  dimensional space.     The current class is compatible with the general template to allow for   using the same functions accessing patches of arbitrary dimensionality   in a generic way. However, it makes some variables that are nonsensical   for zero-dimensional patches into  [2.x.24]  variables that exist only   once in the entire program, as opposed to once per patch. Specifically,   this is the case for the  [2.x.25]  array and the  [2.x.26]    member variable that make no sense for zero-dimensional patches because   points have no natural neighbors across their non-existent faces, nor   can they reasonably be subdivided.  
* [0.x.18]*
     Make the <tt>spacedim</tt> template parameter available.    
* [0.x.19]*
     Corner points of a patch.  For the current class of zero-dimensional     patches, there is of course only a single vertex.         If  [2.x.27] , then     the coordinates of the point at which output is to be generated     is attached as an additional row to the  [2.x.28]  table.    
* [0.x.20]*
     An unused,  [2.x.29]  variable that exists only to allow access     from general code in a generic fashion.    
* [0.x.21]*
     Number of this patch. Since we are not sure patches are always     handled in the same order, we better store this.    
* [0.x.22]*
     Number of subdivisions with which this patch is to be written.     <tt>1</tt> means no subdivision, <tt>2</tt> means bisection, <tt>3</tt>     trisection, etc.         Since subdivision makes no sense for zero-dimensional patches,     this variable is not used but exists only to allow access     from general code in a generic fashion.    
* [0.x.23]*
     Data vectors. The format is as follows: <tt>data(i,.)</tt> denotes the     data belonging to the <tt>i</tt>th data vector. <tt>data.n_cols()</tt>     therefore equals the number of output points; this number is     of course one for the current class, given that we produce output on     points. <tt>data.n_rows()</tt> equals the number of     data vectors. For the current purpose, a data vector equals one scalar,     even if multiple scalars may later be interpreted as vectors.         Within each column, <tt>data(.,j)</tt> are the data values at the     output point <tt>j</tt>; for the current class,  [2.x.30]  can only     be zero.         Since the number of data vectors is usually the same for all patches to     be printed, <tt>data.size()</tt> should yield the same value for all     patches provided. The exception are patches for which     points_are_available are set, where the actual coordinates of the point     are appended to the 'data' field, see the documentation of the     points_are_available flag.    
* [0.x.24]*
     A flag indicating whether the coordinates of the interior patch points     (assuming that the patch is supposed to be subdivided further) are     appended to the  [2.x.31]  table ( [2.x.32]  or not ( [2.x.33]  The latter     is the default and in this case the locations of the points interior to     this patch are computed by (bi-, tri-)linear interpolation from the     vertices of the patch.         This option exists since patch points may be evaluated using a Mapping     (rather than by a linear interpolation) and therefore have to be stored     in the Patch structure.    
* [0.x.25]*
     Reference-cell type of the underlying cell of this patch.    
* [0.x.26]*
     Default constructor. Sets #points_are_available     to false, and #patch_index to #no_neighbor.    
* [0.x.27]*
     Compare the present patch for equality with another one. This is used     in a few of the automated tests in our testsuite.    
* [0.x.28]*
     Return an estimate for the memory consumption, in bytes, of this     object. This is not exact (but will usually be close) because     calculating the memory usage of trees (e.g.,  [2.x.34]  is     difficult.    
* [0.x.29]*
     Swap the current object's contents with those of the given argument.    
* [0.x.30]*
     Value to be used if this patch has no neighbor on one side.    
* [0.x.31]*
      [2.x.35]  Exceptions      [2.x.36]     
* [0.x.32]*
     Exception    
* [0.x.33]*
   Base class describing common functionality between different output   flags.     This is implemented with the "Curiously Recurring Template Pattern";   derived classes use their own type to fill in the typename so that   <tt>memory_consumption</tt> works correctly. See the Wikipedia page on   the pattern for more information.    
*  [2.x.37]   
* [0.x.34]*
     Declare all flags with name and type as offered by this class, for use     in input files.         This method does nothing, but child classes may override this method to     add fields to <tt>prm</tt>.    
* [0.x.35]*
     Read the parameters declared in declare_parameters() and set the flags     for this output format accordingly.         This method does nothing, but child classes may override this method to     add fields to <tt>prm</tt>.    
* [0.x.36]*
     Return an estimate for the memory consumption, in bytes, of this     object. This is not exact (but will usually be close) because     calculating the memory usage of trees (e.g.,  [2.x.38]  is     difficult.    
* [0.x.37]*
   Flags controlling the details of output in OpenDX format.    
*  [2.x.39]   
* [0.x.38]*
     Write neighbor information. This information is necessary for instance,     if OpenDX is supposed to compute integral curves (streamlines). If it     is not present, streamlines end at cell boundaries.    
* [0.x.39]*
     Write integer values of the Triangulation in binary format.    
* [0.x.40]*
     Write coordinate vectors in binary format.    
* [0.x.41]*
     Write data vectors in binary format.    
* [0.x.42]*
     Write binary coordinate vectors as double (64 bit) numbers instead of     float (32 bit).    
* [0.x.43]*
     Constructor.    
* [0.x.44]*
     Declare all flags with name and type as offered by this class, for use     in input files.    
* [0.x.45]*
     Read the parameters declared in declare_parameters() and set the flags     for this output format accordingly.         The flags thus obtained overwrite all previous contents of this object.    
* [0.x.46]*
   Flags controlling the details of output in UCD format for AVS.    
*  [2.x.40]   
* [0.x.47]*
     Write a comment at the beginning of the file stating the date of     creation and some other data.  While this is supported by the UCD     format and AVS, some other programs get confused by this, so the     default is to not write a preamble. However, a preamble can be written     using this flag.         Default:  [2.x.41] .    
* [0.x.48]*
     Constructor.    
* [0.x.49]*
     Declare all flags with name and type as offered by this class, for use     in input files.    
* [0.x.50]*
     Read the parameters declared in declare_parameters() and set the flags     for this output format accordingly.         The flags thus obtained overwrite all previous contents of this object.    
* [0.x.51]*
   Flags controlling the details of output in Gnuplot format.    
*  [2.x.42]   
* [0.x.52]*
     Default constructor. Sets up the dimension labels with the default values     of <tt>"x"</tt>, <tt>"y"</tt>, and <tt>"z"</tt>.    
* [0.x.53]*
     Constructor which sets up non-default values for the dimension labels.    
* [0.x.54]*
     Labels to use in each spatial dimension. These default to <tt>"x"</tt>,     <tt>"y"</tt>, and <tt>"z"</tt>. Labels are printed to the Gnuplot file     surrounded by angle brackets: For example, if the space dimension is 2     and the labels are <tt>"x"</tt> and <tt>"t"</tt>, then the relevant     line will start with    
* [1.x.13]
*      Any extra labels will be ignored.         If you specify these labels yourself then there should be at least     <tt>spacedim</tt> labels, where <tt>spacedim</tt> is the spatial     dimension of the output data.    
* [0.x.55]*
     Return an estimate for the memory consumption, in bytes, of this     object.    
* [0.x.56]*
     Exception to raise when there are not enough specified dimension     labels.    
* [0.x.57]*
   Flags controlling the details of output in Povray format. Several flags   are implemented, see their respective documentation.    
*  [2.x.43]   
* [0.x.58]*
     Normal vector interpolation, if set to true         default = false    
* [0.x.59]*
     Use bicubic patches (b-splines) instead of triangles.         default = false    
* [0.x.60]*
     include external "data.inc" with camera, light and texture definition     for the scene.         default = false    
* [0.x.61]*
     Constructor.    
* [0.x.62]*
     Declare all flags with name and type as offered by this class, for use     in input files.    
* [0.x.63]*
     Read the parameters declared in declare_parameters() and set the flags     for this output format accordingly.         The flags thus obtained overwrite all previous contents of this object.    
* [0.x.64]*
   Flags controlling the details of output in encapsulated postscript   format.    
*  [2.x.44]   
* [0.x.65]*
     This denotes the number of the data vector which shall be used for     generating the height information. By default, the first data vector is     taken, i.e. <tt>height_vector==0</tt>, if there is any data vector. If     there is no data vector, no height information is generated.    
* [0.x.66]*
     Number of the vector which is to be taken to colorize cells. The same     applies as for #height_vector.    
* [0.x.67]*
     Enum denoting the possibilities whether the scaling should be done such     that the given <tt>size</tt> equals the width or the height of the     resulting picture.    
* [0.x.68]*
     See above. Default is <tt>width</tt>.    
* [0.x.69]*
     Width or height of the output as given in postscript units This usually     is given by the strange unit 1/72 inch. Whether this is height or width     is specified by the flag <tt>size_type</tt>.         Default is 300, which represents a size of roughly 10 cm.    
* [0.x.70]*
     Width of a line in postscript units. Default is 0.5.    
* [0.x.71]*
     Angle of the line origin-viewer against the z-axis in degrees.         Default is the Gnuplot-default of 60.    
* [0.x.72]*
     Angle by which the viewers position projected onto the x-y-plane is     rotated around the z-axis, in positive sense when viewed from above.     The unit are degrees, and zero equals a position above or below the     negative y-axis.         Default is the Gnuplot-default of 30.  An example of a Gnuplot-default     of 0 is the following:        
* [1.x.14]
*     
* [0.x.73]*
     Factor by which the z-axis is to be stretched as compared to the x- and     y-axes. This is to compensate for the different sizes that coordinate     and solution values may have and to prevent that the plot looks to much     out-of-place (no elevation at all if solution values are much smaller     than coordinate values, or the common "extremely mountainous area" in     the opposite case.         Default is <tt>1.0</tt>.    
* [0.x.74]*
     Flag the determines whether the lines bounding the cells (or the parts     of each patch) are to be plotted.         Default: <tt>true</tt>.    
* [0.x.75]*
     Flag whether to fill the regions between the lines bounding the cells     or not. If not, no hidden line removal is performed, which in this     crude implementation is done through writing the cells in a back-to-     front order, thereby hiding the cells in the background by cells in the     foreground.         If this flag is <tt>false</tt> and #draw_mesh is <tt>false</tt> as     well, nothing will be printed.         If this flag is <tt>true</tt>, then the cells will be drawn either     colored by one of the data sets (if #shade_cells is <tt>true</tt>), or     pure white (if #shade_cells is false or if there are no data sets).         Default is <tt>true</tt>.    
* [0.x.76]*
     Flag to determine whether the cells shall be colorized by the data set     denoted by #color_vector, or simply be painted in white. This flag only     makes sense if <tt>#draw_cells==true</tt>. Colorization is done through     #color_function.         Default is <tt>true</tt>.    
* [0.x.77]*
     Structure keeping the three color values in the RGB system.    
* [0.x.78]*
       Return <tt>true</tt> if the color represented by the three color       values is a grey scale, i.e. all components are equal.      
* [0.x.79]*
     Definition of a function pointer type taking a value and returning a     triple of color values in RGB values.         Besides the actual value by which the color is to be computed, min and     max values of the data to be colorized are given as well.    
* [0.x.80]*
     This is a pointer to the function which is used to colorize the cells.     By default, it points to the static function default_color_function()     which is a member of this class.    
* [0.x.81]*
     Default colorization function. This one does what one usually wants: It     shifts colors from black (lowest value) through blue, green and red to     white (highest value). For the exact definition of the color scale     refer to the implementation.         This function was originally written by Stefan Nauber.    
* [0.x.82]*
     This is an alternative color function producing a grey scale between     black (lowest values) and white (highest values). You may use it by     setting the #color_function variable to the address of this function.    
* [0.x.83]*
     This is one more alternative color function producing a grey scale     between white (lowest values) and black (highest values), i.e. the     scale is reversed to the previous one. You may use it by setting the     #color_function variable to the address of this function.    
* [0.x.84]*
     Constructor.    
* [0.x.85]*
     Declare all flags with name and type as offered by this class, for use     in input files.         For coloring, only the color functions declared in this class are     offered.    
* [0.x.86]*
     Read the parameters declared in declare_parameters() and set the flags     for this output format accordingly.         The flags thus obtained overwrite all previous contents of this object.    
* [0.x.87]*
   Flags controlling the details of output in GMV format. At present no   flags are implemented.    
*  [2.x.45]   
* [0.x.88]*
   Flags controlling the details of output in Tecplot format.    
*  [2.x.46]   
* [0.x.89]*
     Tecplot allows to assign names to zones. This variable stores this     name.    
* [0.x.90]*
     Solution time for each zone in a strand. This value must be non-     negative, otherwise it will not be written to file. Do not assign any     value for this in case of a static zone.    
* [0.x.91]*
     Constructor.    
* [0.x.92]*
     Return an estimate for the memory consumption, in bytes, of this     object.    
* [0.x.93]*
   Flags controlling the details of output in VTK format.    
*  [2.x.47]   
* [0.x.94]*
     The time of the time step if this file is part of a time dependent     simulation.         The value of this variable is written into the output file according to     the instructions provided in     http://www.visitusers.org/index.php?title=Time_and_Cycle_in_VTK_files     unless it is at its default value of    
* [1.x.15].    
* [0.x.95]*
     The number of the time step if this file is part of a time dependent     simulation, or the cycle within a nonlinear or other iteration.         The value of this variable is written into the output file according to     the instructions provided in     http://www.visitusers.org/index.php?title=Time_and_Cycle_in_VTK_files     unless it is at its default value of    
* [1.x.16].    
* [0.x.96]*
     Flag to determine whether the current date and time shall be printed as     a comment in the file's second line.         Default is <tt>true</tt>.    
* [0.x.97]*
     A data type providing the different possible zlib compression     levels. These map directly to constants defined by zlib.    
* [0.x.98]*
       Do not use any compression.      
* [0.x.99]*
       Use the fastest available compression algorithm.      
* [0.x.100]*
       Use the algorithm which results in the smallest compressed       files. This is the default flag.      
* [0.x.101]*
       Use the default compression algorithm. This is a compromise between       speed and file size.      
* [0.x.102]*
     Flag determining the compression level at which zlib, if available, is     run. The default is <tt>best_compression</tt>.    
* [0.x.103]*
     Flag determining whether to write patches as linear cells     or as a high-order Lagrange cell.         Default is <tt>false</tt>.        
*  [2.x.48]  The ability to write data that corresponds to higher order     polynomials rather than simply linear or bilinear is a feature that was     only introduced in VTK 8.1.0 in December 2017. You will need at least     Paraview version 5.5.0 released in April 2018 or a similarly recent     version of VisIt for this feature to work (for example, VisIt 3.1.1,     released in February 2020, does not yet support this feature). Older     versions of these programs are likely going to result in errors when     trying to read files generated with this flag set to true. Experience     with these programs shows that these error messages are likely going to     be rather less descriptive and more obscure.    
* [0.x.104]*
     Constructor.    
* [0.x.105]*
   Flags for SVG output.    
*  [2.x.49]   
* [0.x.106]*
     Height of the image in SVG units. Default value is 4000.    
* [0.x.107]*
     Width of the image in SVG units. If left zero, the width is computed     from the height.    
* [0.x.108]*
     This denotes the number of the data vector which shall be used for     generating the height information. By default, the first data vector is     taken, i.e. <tt>#height_vector==0</tt>, if there is any data vector. If     there is no data vector, no height information is generated.    
* [0.x.109]*
     Angles for the perspective view    
* [0.x.110]*
     Draw a margin of 5% around the plotted area    
* [0.x.111]*
     Draw a colorbar encoding the cell coloring    
* [0.x.112]*
     Constructor.    
* [0.x.113]*
   Flags controlling the details of output in deal.II intermediate format.   At present no flags are implemented.    
*  [2.x.50]   
* [0.x.114]*
     An indicator of the current file format version used to write     intermediate format. We do not attempt to be backward compatible, so     this number is used only to verify that the format we are writing is     what the current readers and writers understand.    
* [0.x.115]*
   Flags controlling the DataOutFilter.    
*  [2.x.51]   
* [0.x.116]*
     Filter duplicate vertices and associated values. This will drastically     reduce the output data size but will result in an output file that     does not faithfully represent the actual data if the data corresponds     to discontinuous fields. In particular, along subdomain boundaries     the data will still be discontinuous, while it will look like a     continuous field inside of the subdomain.    
* [0.x.117]*
     Whether the XDMF output refers to HDF5 files. This affects how output     is structured.    
* [0.x.118]*
     Constructor.    
* [0.x.119]*
     Declare all flags with name and type as offered by this class, for use     in input files.    
* [0.x.120]*
     Read the parameters declared in <tt>declare_parameters</tt> and set the     flags for this output format accordingly.         The flags thus obtained overwrite all previous contents of this object.    
* [0.x.121]*
     Determine an estimate for the memory consumption (in bytes) of this     object.    
* [0.x.122]*
   DataOutFilter provides a way to remove redundant vertices and values   generated by the deal.II output. By default, DataOutBase and the classes   that build on it output data at each corner of each cell. This means that   data is output multiple times for each vertex of the mesh. The purpose of   this scheme is to support output of discontinuous quantities, either   because the finite element space is discontinuous or because the quantity   that is output is computed from a solution field and is discontinuous   across faces.     This class is an attempt to rein in the amount of data that is written.   If the fields that are written to files are indeed discontinuous, the   only way to faithfully represent them is indeed to write multiple values   for each vertex (this is typically done by writing multiple node   locations for the same vertex and defining data at these nodes). However,   for fine meshes, one may not necessarily be interested in an exact   representation of output fields that will likely only have small   discontinuities. Rather, it may be sufficient to just output one value   per vertex, which may be chosen arbitrarily from among those that are   defined at this vertex from any of the adjacent cells.  
* [0.x.123]*
     Default constructor.    
* [0.x.124]*
     Destructor with a given set of flags. See DataOutFilterFlags for     possible flags.    
* [0.x.125]*
     Write a point with the specified index into the filtered data set. If     the point already exists and we are filtering redundant values, the     provided index will internally refer to another recorded point.    
* [0.x.126]*
     Record a deal.II cell in the internal reordered format.    
* [0.x.127]*
     Record a single deal.II cell without subdivisions (e.g. simplex) in the     internal reordered format.    
* [0.x.128]*
     Filter and record a data set. If there are multiple values at a given     vertex and redundant values are being removed, one is arbitrarily     chosen as the recorded value. In the future this can be expanded to     average/min/max multiple values at a given vertex.    
* [0.x.129]*
     Resize and fill a vector with all the filtered node vertex points, for     output to a file.    
* [0.x.130]*
     Resize and fill a vector with all the filtered cell vertex indices, for     output to a file.    
* [0.x.131]*
     Get the name of the data set indicated by the set number.    
* [0.x.132]*
     Get the dimensionality of the data set indicated by the set number.    
* [0.x.133]*
     Get the raw double valued data of the data set indicated by the set     number.    
* [0.x.134]*
     Return the number of nodes in this DataOutFilter. This may be smaller     than the original number of nodes if filtering is enabled.    
* [0.x.135]*
     Return the number of filtered cells in this DataOutFilter. Cells are     not filtered so this will be the original number of cells.    
* [0.x.136]*
     Return the number of filtered data sets in this DataOutFilter. Data     sets are not filtered so this will be the original number of data sets.    
* [0.x.137]*
     Empty functions to do base class inheritance.    
* [0.x.138]*
     Empty functions to do base class inheritance.    
* [0.x.139]*
     Empty class to provide comparison function for Map3DPoint.    
* [0.x.140]         The return statement below is an optimized version of the following         code:                 for (unsigned int d=0; d<3; ++d)         {           if (one(d) < two(d))             return true;           else if (one(d) > two(d))             return false;         }         return false;        
* [0.x.141]*
     Flags used to specify filtering behavior.    
* [0.x.142]*
     The number of space dimensions in which the vertices represented     by the current object live. This corresponds to the usual      [2.x.52]  argument, but since this class is not templated on the     dimension, we need to store it here.    
* [0.x.143]*
     The number of cells stored in  [2.x.53] .    
* [0.x.144]*
     Map of points to an internal index.    
* [0.x.145]*
     Map of actual point index to internal point index.    
* [0.x.146]*
     Map of cells to the filtered points.    
* [0.x.147]*
     Data set names.    
* [0.x.148]*
     Data set dimensions.    
* [0.x.149]*
     Data set data.    
* [0.x.150]*
     Record a cell vertex index based on the internal reordering.    
* [0.x.151]*
   Provide a data type specifying the presently supported output formats.  
* [0.x.152]*
     Use the format already stored in the object.    
* [0.x.153]*
     Do not write any output.    
* [0.x.154]*
     Output for OpenDX.    
* [0.x.155]*
     Output in the UCD format for AVS.    
* [0.x.156]*
     Output for the Gnuplot tool.    
* [0.x.157]*
     Output for the Povray raytracer.    
* [0.x.158]*
     Output in encapsulated PostScript.    
* [0.x.159]*
     Output for GMV.    
* [0.x.160]*
     Output for Tecplot in text format.    
* [0.x.161]*
     Output for Tecplot in binary format. Faster and smaller than text     format.          [2.x.54]  Using Tecplot binary output is deprecated.    
* [0.x.162]*
     Output in VTK format.    
* [0.x.163]*
     Output in VTK format.    
* [0.x.164]*
     Output in SVG format.    
* [0.x.165]*
     Output in deal.II intermediate format.    
* [0.x.166]*
     Output in HDF5 format.    
* [0.x.167]*
   Write the given list of patches to the output stream in OpenDX format.  
* [0.x.168]*
   Write the given list of patches to the output stream in eps format.     Output in this format circumvents the use of auxiliary graphic programs   converting some output format into a graphics format. This has the   advantage that output is easy and fast, and the disadvantage that you   have to give a whole bunch of parameters which determine the direction of   sight, the mode of colorization, the scaling of the height axis, etc. (Of   course, all these parameters have reasonable default values, which you   may want to change.)     This function only supports output for two-dimensional domains (i.e.,   with dim==2), with values in the vertical direction taken from a data   vector.     Basically, output consists of the mesh and the cells in between them. You   can draw either of these, or both, or none if you are really interested   in an empty picture. If written, the mesh uses black lines. The cells in   between the mesh are either not printed (this will result in a loss of   hidden line removal, i.e.  you can "see through" the cells to lines   behind), printed in white (which does nothing apart from the hidden line   removal), or colorized using one of the data vectors (which need not be   the same as the one used for computing the height information) and a   customizable color function. The default color functions chooses the   color between black, blue, green, red and white, with growing values of   the data field chosen for colorization. At present, cells are displayed   with one color per cell only, which is taken from the value of the data   field at the center of the cell; bilinear interpolation of the color on a   cell is not used.     By default, the viewpoint is chosen like the default viewpoint in   GNUPLOT, i.e.  with an angle of 60 degrees with respect to the positive   z-axis and rotated 30 degrees in positive sense (as seen from above) away   from the negative y-axis.  Of course you can change these settings.     EPS output is written without a border around the picture, i.e. the   bounding box is close to the output on all four sides. Coordinates are   written using at most five digits, to keep picture size at a reasonable   size.     All parameters along with their default values are listed in the   documentation of the <tt>EpsFlags</tt> member class of this class. See   there for more and detailed information.  
* [0.x.169]*
   This is the same function as above except for domains that are not two-   dimensional. This function is not implemented (and will throw an error if   called) but is declared to allow for dimension-independent programs.  
* [0.x.170]*
   Write the given list of patches to the output stream in GMV format.     Data is written in the following format: nodes are considered the points   of the patches. In spatial dimensions less than three, zeroes are   inserted for the missing coordinates. The data vectors are written as   node or cell data, where for the first the data space is interpolated to   (bi-,tri-)linear elements.  
* [0.x.171]*
   Write the given list of patches to the output stream in gnuplot format.   Visualization of two-dimensional data can then be achieved by starting   <tt>gnuplot</tt> and entering the commands    
* [1.x.17]
*    This example assumes that the number of the data vector displayed is   [1.x.18].     The GNUPLOT format is not able to handle data on unstructured grids   directly. Directly would mean that you only give the vertices and the   solution values thereon and the program constructs its own grid to   represent the data. This is only possible for a structured tensor product   grid in two dimensions. However, it is possible to give several such   patches within one file, which is exactly what the respective function of   this class does: writing each cell's data as a patch of data, at least if   the patches as passed from derived classes represent cells. Note that the   functions on patches need not be continuous at interfaces between   patches, so this method also works for discontinuous elements. Note also,   that GNUPLOT can do hidden line removal for patched data.     While this discussion applies to two spatial dimensions, it is more   complicated in 3d. The reason is that we could still use patches, but it   is difficult when trying to visualize them, since if we use a cut through   the data (by, for example, using x- and z-coordinates, a fixed y-value   and plot function values in z-direction, then the patched data is not a   patch in the sense GNUPLOT wants it any more. Therefore, we use another   approach, namely writing the data on the 3d grid as a sequence of lines,   i.e. two points each associated with one or more data sets.  There are   therefore 12 lines for each subcells of a patch.     Given the lines as described above, a cut through this data in Gnuplot   can then be achieved like this:  
* [1.x.19]
*      This command plots data in  [2.x.55] - and  [2.x.56] -direction unbounded, but in    [2.x.57] -direction only those data points which are above the  [2.x.58] - [2.x.59] -plane (we   assume here a positive solution, if it has negative values, you might   want to decrease the lower bound). Furthermore, it only takes the data   points with z-values (<tt>&3</tt>) equal to 0.5, i.e. a cut through the   domain at <tt>z=0.5</tt>. For the data points on this plane, the data   values of the first data set (<tt>&4</tt>) are raised in z-direction   above the x-y-plane; all other points are denoted the value <tt>-1</tt>   instead of the value of the data vector and are not plotted due to the   lower bound in z plotting direction, given in the third pair of brackets.     More complex cuts are possible, including nonlinear ones. Note however,   that only those points which are actually on the cut-surface are plotted.  
* [0.x.172]*
   Write the given list of patches to the output stream for the Povray   raytracer.     Output in this format creates a povray source file, include standard   camera and light source definition for rendering with povray 3.1 At   present, this format only supports output for two-dimensional data, with   values in the third direction taken from a data vector.     The output uses two different povray-objects:      [2.x.60]     [2.x.61]  <tt>BICUBIC_PATCH</tt> A <tt>bicubic_patch</tt> is a 3-dimensional   Bezier patch. It consists of 16 Points describing the surface. The 4   corner points are touched by the object, while the other 12 points pull   and stretch the patch into shape. One <tt>bicubic_patch</tt> is generated   on each patch. Therefore the number of subdivisions has to be 3 to provide   the patch with 16 points. A bicubic patch is not exact but generates very   smooth images.      [2.x.62]  <tt>MESH</tt> The mesh object is used to store large number of   triangles. Every square of the patch data is split into one upper-left   and one lower-right triangle. If the number of subdivisions is three, 32   triangle are generated for every patch.     Using the smooth flag povray interpolates the normals on the triangles,   imitating a curved surface    [2.x.63]      All objects get one texture definition called Tex. This texture has to be   declared somewhere before the object data. This may be in an external   data file or at the beginning of the output file. Setting the   <tt>external_data</tt> flag to false, an standard camera, light and   texture (scaled to fit the scene) is added to the output file. Set to   true an include file "data.inc" is included. This file is not generated   by deal and has to include camera, light and the texture definition Tex.     You need povray (>=3.0) to render the scene. The minimum options for   povray are:  
* [1.x.20]
*    If the external file "data.inc" is used, the path to this file has to be   included in the povray options.  
* [0.x.173]*
   Write the given list of patches to the output stream in Tecplot ASCII   format (FEBLOCK).     For more information consult the Tecplot Users and Reference manuals.  
* [0.x.174]*
   Write the given list of patches to the output stream in UCD format   described in the AVS developer's guide (now AVS). Due to limitations in   the present format, only node based data can be output, which in one   reason why we invented the patch concept. In order to write higher order   elements, you may split them up into several subdivisions of each cell.   These subcells will then, however, also appear as different cells by   programs which understand the UCD format.     No use is made of the possibility to give model data since these are not   supported by all UCD aware programs. You may give cell data in derived   classes by setting all values of a given data set on a patch to the same   value.  
* [0.x.175]*
   Write the given list of patches to the output stream in VTK format. The   data is written in the traditional VTK format as opposed to the XML-based   format that write_vtu() produces.     The nonscalar_data_ranges argument denotes ranges of components in the   output that are considered a vector, rather than simply a collection of   scalar fields. The VTK output format has special provisions that allow   these components to be output by a single name rather than having to   group several scalar fields into a vector later on in the visualization   program.    
*  [2.x.64]  VTK is a legacy format and has largely been supplanted by the VTU   format (an XML-structured version of VTK). In particular, VTU allows for   the compression of data and consequently leads to much smaller file sizes   that equivalent VTK files for large files. Since all visualization   programs that support VTK also support VTU, you should consider using the   latter file format instead, by using the write_vtu() function.  
* [0.x.176]*
   Write the given list of patches to the output stream in VTU format. The   data is written in the XML-based VTK format as opposed to the traditional   format that write_vtk() produces.     The nonscalar_data_ranges argument denotes ranges of components in the   output that are considered a vector, rather than simply a collection of   scalar fields. The VTK output format has special provisions that allow   these components to be output by a single name rather than having to   group several scalar fields into a vector later on in the visualization   program.     Some visualization programs, such as ParaView, can read several separate   VTU files to parallelize visualization. In that case, you need a    [2.x.65]  file that describes which VTU files form a group. The    [2.x.66]  function can generate such a   centralized record. Likewise,  [2.x.67]  does   the same for VisIt (although VisIt can also read  [2.x.68]  records   since version 2.5.1). Finally, for time dependent problems, you may also   want to look at  [2.x.69]      The use of this function is explained in  [2.x.70] .  
* [0.x.177]*
   This writes the header for the xml based vtu file format. This routine is   used internally together with  [2.x.71]  and    [2.x.72]  by  [2.x.73]   
* [0.x.178]*
   This function writes the footer for the xml based vtu file format. This   routine is used internally together with    [2.x.74]  and  [2.x.75]    by  [2.x.76]   
* [0.x.179]*
   This function writes the main part for the xml based vtu file format. This   routine is used internally together with    [2.x.77]  and    [2.x.78]  by  [2.x.79]   
* [0.x.180]*
   Some visualization programs, such as ParaView, can read several separate   VTU files that all form part of the same simulation, in order to   parallelize visualization. In that case, you need a    [2.x.80]  file that describes which VTU files (written, for   example, through the  [2.x.81]  function) form a group.   The current function can generate such a centralized record.     This function is typically not called by itself from user space, but   you may want to call it through  [2.x.82]    since the DataOutInterface class has access to information that you   would have to provide to the current function by hand.     In any case, whether this function is called directly or via    [2.x.83]  the central record file so   written contains a list of (scalar or vector) fields that describes which   fields can actually be found in the individual files that comprise the set   of parallel VTU files along with the names of these files. This function   gets the names and types of fields through the third and fourth   argument; you can determine these by hand, but in practice, this function   is most easily called by calling  [2.x.84]    which determines the last two arguments by calling    [2.x.85]  and    [2.x.86]  functions. The second   argument to this function specifies the names of the files that form the   parallel set.    
*  [2.x.87]  Use  [2.x.88]  and  [2.x.89]    for writing each piece. Also note that   only one parallel process needs to call the current function, listing the   names of the files written by all parallel processes.    
*  [2.x.90]  In order to tell Paraview to group together multiple    [2.x.91]  files that each describe one time step of a time   dependent simulation, see the  [2.x.92]    function.    
*  [2.x.93]  Older versions of VisIt (before 2.5.1), can not read    [2.x.94]  records. However, it can read visit records as written   by the write_visit_record() function.  
* [0.x.181]*
   In ParaView it is possible to visualize time-dependent data tagged with   the current integration time of a time dependent simulation. To use this   feature you need a  [2.x.95]  file that describes which VTU or   PVTU file belongs to which timestep. This function writes a file that   provides this mapping, i.e., it takes a list of pairs each of which   indicates a particular time instant and the corresponding file that   contains the graphical data for this time instant.     A typical use case, in program that computes a time dependent solution,   would be the following ( [2.x.96]  are   member variables of the class with types  [2.x.97]  and    [2.x.98] , respectively; the variable    [2.x.99]  is of type    [2.x.100] ):    
* [1.x.21]
*     
*  [2.x.101]  See  [2.x.102]   [2.x.103]    and  [2.x.104]    for writing solutions at each timestep.    
*  [2.x.105]  The second element of each pair, i.e., the file in which the   graphical data for each time is stored, may itself be again a file that   references other files. For example, it could be the name for a    [2.x.106]  file that references multiple parts of a parallel   computation.  
* [0.x.182]*
   This function is the exact equivalent of the write_pvtu_record() function   but for older versions of the VisIt visualization program and for one   visualization graph (or one time step only). See there for the purpose of   this function.     This function is documented in the "Creating a master file for parallel"   section (section 5.7) of the "Getting data into VisIt" report that can be   found here:   https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf  
* [0.x.183]*
   This function is equivalent to the write_visit_record() above but for   multiple time steps. Here is an example of how the function would be   used:  
* [1.x.22]
*      This function is documented in the "Creating a master file for parallel"   section (section 5.7) of the "Getting data into VisIt" report that can be   found here:   https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf  
* [0.x.184]*
   This function is equivalent to the write_visit_record() above but for   multiple time steps and with additional information about the time for   each timestep. Here is an example of how the function would be   used:  
* [1.x.23]
*      This function is documented in the "Creating a master file for parallel"   section (section 5.7) of the "Getting data into VisIt" report that can be   found here:   https://wci.llnl.gov/codes/visit/2.0.0/GettingDataIntoVisIt2.0.0.pdf  
* [0.x.185]*
   Write the given list of patches to the output stream in SVG format.     SVG (Scalable Vector Graphics) is an XML-based vector image format   developed and maintained by the World Wide Web Consortium (W3C). This   function conforms to the latest specification SVG 1.1, released on August   16, 2011. Controlling the graphic output is possible by setting or   clearing the respective flags (see the SvgFlags struct). At present, this   format only supports output for two-dimensional data, with values in the   third direction taken from a data vector.     For the output, each patch is subdivided into four triangles which are   then written as polygons and filled with a linear color gradient. The   arising coloring of the patches visualizes the data values at the   vertices taken from the specified data vector. A colorbar can be drawn to   encode the coloring.    
*  [2.x.107]  This function is so far only implemented for two dimensions with an   additional dimension reserved for data information.  
* [0.x.186]*
   Write the given list of patches to the output stream in deal.II   intermediate format. This is not a format understood by any other   graphics program, but is rather a direct dump of the intermediate   internal format used by deal.II. This internal format is generated by the   various classes that can generate output using the DataOutBase class, for   example from a finite element solution, and is then converted in the   present class to the final graphics format.     Note that the intermediate format is what its name suggests: a direct   representation of internal data. It isn't standardized and will change   whenever we change our internal representation. You can only expect to   process files written in this format using the same version of deal.II   that was used for writing.     The reason why we offer to write out this intermediate format is that it   can be read back into a deal.II program using the DataOutReader class,   which is helpful in at least two contexts: First, this can be used to   later generate graphical output in any other graphics format presently   understood; this way, it is not necessary to know at run-time which   output format is requested, or if multiple output files in different   formats are needed. Secondly, in contrast to almost all other graphics   formats, it is possible to merge several files that contain intermediate   format data, and generate a single output file from it, which may be   again in intermediate format or any of the final formats. This latter   option is most helpful for parallel programs: as demonstrated in the    [2.x.108]  example program, it is possible to let only one processor   generate the graphical output for the entire parallel program, but this   can become vastly inefficient if many processors are involved, because   the load is no longer balanced. The way out is to let each processor   generate intermediate graphical output for its chunk of the domain, and   the later merge the different files into one, which is an operation that   is much cheaper than the generation of the intermediate data.     Intermediate format deal.II data is usually stored in files with the   ending <tt>.d2</tt>.  
* [0.x.187]*
   Write the data in  [2.x.109]  to a single HDF5 file containing both the   mesh and solution values.  
* [0.x.188]*
   Write the data in  [2.x.110]  to HDF5 file(s). If  [2.x.111]  is   false, the mesh data will not be written and the solution file will   contain only the solution values. If  [2.x.112]  is true and the   filenames are the same, the resulting file will contain both mesh data   and solution values.  
* [0.x.189]*
   DataOutFilter is an intermediate data format that reduces the amount of   data that will be written to files. The object filled by this function   can then later be used again to write data in a concrete file format;   see, for example,  [2.x.113]   
* [0.x.190]*
   Given an input stream that contains data written by   write_deal_II_intermediate(), determine the <tt>dim</tt> and   <tt>spacedim</tt> template parameters with which that function was   called, and return them as a pair of values.     Note that this function eats a number of elements at the present position   of the stream, and therefore alters it. In order to read from it using,   for example, the DataOutReader class, you may wish to either reset the   stream to its previous position, or close and reopen it.  
* [0.x.191]*
   Return the OutputFormat value corresponding to the given string. If the   string does not match any known format, an exception is thrown.     The main purpose of this function is to allow a program to use any   implemented output format without the need to extend the program's parser   each time a new format is implemented.     To get a list of presently available format names, e.g. to give it to the   ParameterHandler class, use the function get_output_format_names().  
* [0.x.192]*
   Return a list of implemented output formats. The different names are   separated by vertical bar signs (<tt>`|'</tt>) as used by the   ParameterHandler classes.  
* [0.x.193]*
   Provide a function which tells us which suffix a file with a given output   format usually has. At present the following formats are defined:    [2.x.114]     [2.x.115]  <tt>dx</tt>: <tt>.dx</tt>    [2.x.116]  <tt>ucd</tt>: <tt>.inp</tt>    [2.x.117]  <tt>gnuplot</tt>: <tt>.gnuplot</tt>    [2.x.118]  <tt>povray</tt>: <tt>.pov</tt>    [2.x.119]  <tt>eps</tt>: <tt>.eps</tt>    [2.x.120]  <tt>gmv</tt>: <tt>.gmv</tt>    [2.x.121]  <tt>tecplot</tt>: <tt>.dat</tt>    [2.x.122]  <tt>tecplot_binary</tt>: <tt>.plt</tt>    [2.x.123]  <tt>vtk</tt>: <tt>.vtk</tt>    [2.x.124]  <tt>vtu</tt>: <tt>.vtu</tt>    [2.x.125]  <tt>svg</tt>: <tt>.svg</tt>    [2.x.126]  <tt>deal_II_intermediate</tt>: <tt>.d2</tt>.    [2.x.127]       [2.x.128]  Using Tecplot binary output is deprecated.  
* [0.x.194]*
    [2.x.129]  Exceptions    [2.x.130]   
* [0.x.195]*
   Exception  
* [0.x.196]*
   An output function did not receive any patches for writing.  
* [0.x.197]*
   Exception  
* [0.x.198]*
   Exception  
* [0.x.199]*
 This class is the interface to the functions in the DataOutBase namespace, as already its name might suggest. It does not offer much functionality apart from a way to access the implemented formats and a way to dynamically dispatch what output format to chose.
*  This class is thought as a base class to classes actually generating data for output. It has two abstract virtual functions, get_patches() and get_dataset_names() produce the data which is actually needed. These are the only functions that need to be overloaded by a derived class. In addition to that, it has a function for each output format supported by the underlying base class which gets the output data using these two virtual functions and passes them to the raw output functions.
*  The purpose of this class is mainly two-fold: to support storing flags by which the output in the different output formats are controlled, and means to work with output in a way where output format, flags and other things are determined at run time. In addition to that it offers the abstract interface to derived classes briefly discussed above.
* 

*  [1.x.24]
*  The way we treat flags in this class is very similar to that used in the <tt>GridOut</tt> class. For detailed information on the why's and how's, as well as an example of programming, we refer to the documentation of that class.
*  Basically, this class stores a set of flags for each output format supported by the underlying <tt>DataOutBase</tt> class. These are used whenever one of the <tt>write_*</tt> functions is used. By default, the values of these flags are set to reasonable start-ups, but in case you want to change them, you can create a structure holding the flags for one of the output formats and set it using the <tt>set_flags</tt> functions of this class to determine all future output the object might produce by that output format.
*  For information on what parameters are supported by different output functions, please see the documentation of the <tt>DataOutBase</tt> class and its member classes.
* 

*  [1.x.25]
*  In the output flags classes, described above, many flags are defined for output in the different formats. In order to make them available to the input file handler class <tt>ParameterHandler</tt>, each of these has a function declaring these flags to the parameter handler and to read them back from an actual input file. In order to avoid that in user programs these functions have to be called for each available output format and the respective flag class, the present <tt>DataOutInterface</tt> class offers a function <tt>declare_parameters</tt> which calls the respective function of all known output format flags classes. The flags of each such format are packed together in a subsection in the input file. Likewise, there is a function <tt>parse_parameters</tt> which reads these parameters and stores them in the flags associated with this object (see above).
*  Using these functions, you do not have to track which formats are presently implemented.
*  Usage is as follows:

* 
* [1.x.26]
*  Note that in the present example, the class <tt>DataOut</tt> was used. However, any other class derived from <tt>DataOutInterface</tt> would work alike.
* 

*  [1.x.27]
*  This class, much like the <tt>GridOut</tt> class, has a set of functions providing a list of supported output formats, an <tt>enum</tt> denoting all these and a function to parse a string and return the respective <tt>enum</tt> value if it is a valid output format's name (actually, these functions are inherited from the base class). Finally, there is a function <tt>write</tt>, which takes a value of this <tt>enum</tt> and dispatches to one of the actual <tt>write_*</tt> functions depending on the output format selected by this value.
*  The functions offering the different output format names are, respectively, <tt>default_suffix</tt>, <tt>parse_output_format</tt>, and <tt>get_output_format_names</tt>. They make the selection of output formats in parameter files much easier, and especially independent of the formats presently implemented. User programs need therefore not be changed whenever a new format is implemented.
*  Additionally, objects of this class have a default format, which can be set by the parameter "Output format" of the parameter file. Within a program, this can be changed by the member function <tt>set_default_format</tt>. Using this default format, it is possible to leave the format selection completely to the parameter file. A suitable suffix for the output file name can be obtained by <tt>default_suffix</tt> without arguments.
* 

* 
*  [2.x.131] 

* 
* [0.x.200]*
   Constructor.  
* [0.x.201]*
   Destructor. Does nothing, but is declared virtual since this class has   virtual functions.  
* [0.x.202]*
   Obtain data through get_patches() and write it to <tt>out</tt> in OpenDX   format. See  [2.x.132]   
* [0.x.203]*
   Obtain data through get_patches() and write it to <tt>out</tt> in EPS   format. See  [2.x.133]   
* [0.x.204]*
   Obtain data through get_patches() and write it to <tt>out</tt> in GMV   format. See  [2.x.134]   
* [0.x.205]*
   Obtain data through get_patches() and write it to <tt>out</tt> in GNUPLOT   format. See  [2.x.135]   
* [0.x.206]*
   Obtain data through get_patches() and write it to <tt>out</tt> in POVRAY   format. See  [2.x.136]   
* [0.x.207]*
   Obtain data through get_patches() and write it to <tt>out</tt> in Tecplot   format. See  [2.x.137]   
* [0.x.208]*
   Obtain data through get_patches() and write it to <tt>out</tt> in UCD   format for AVS. See  [2.x.138]   
* [0.x.209]*
   Obtain data through get_patches() and write it to <tt>out</tt> in Vtk   format. See  [2.x.139]     
*  [2.x.140]  VTK is a legacy format and has largely been supplanted by the VTU   format (an XML-structured version of VTK). In particular, VTU allows for   the compression of data and consequently leads to much smaller file sizes   that equivalent VTK files for large files. Since all visualization   programs that support VTK also support VTU, you should consider using the   latter file format instead, by using the write_vtu() function.  
* [0.x.210]*
   Obtain data through get_patches() and write it to <tt>out</tt> in Vtu   (VTK's XML) format. See  [2.x.141]      Some visualization programs, such as ParaView, can read several separate   VTU files to parallelize visualization. In that case, you need a    [2.x.142]  file that describes which VTU files form a group. The    [2.x.143]  function can generate such a   centralized record. Likewise,  [2.x.144]  does   the same for older versions of VisIt (although VisIt can also read    [2.x.145]  records since version 2.5.1). Finally,    [2.x.146]  can be used to group together the   files that jointly make up a time dependent simulation.  
* [0.x.211]*
   Collective MPI call to write the solution from all participating nodes   (those in the given communicator) to a single compressed .vtu file on a   shared file system.  The communicator can be a sub communicator of the   one used by the computation.  This routine uses MPI I/O to achieve high   performance on parallel filesystems. Also see    [2.x.147]   
* [0.x.212]*
   Some visualization programs, such as ParaView, can read several separate   VTU files that all form part of the same simulation, in order to   parallelize visualization. In that case, you need a    [2.x.148]  file that describes which VTU files (written, for   example, through the  [2.x.149]  function) form a group.   The current function can generate such a centralized record.     The central record file generated by this function   contains a list of (scalar or vector) fields that describes which   fields can actually be found in the individual files that comprise the set   of parallel VTU files along with the names of these files. This function   gets the names and types of fields through the get_dataset_names() and   get_nonscalar_data_ranges() functions of this class. The second argument   to this function specifies the names of the files that form the parallel   set.    
*  [2.x.150]  Use  [2.x.151]  and  [2.x.152]    for writing each piece. Also note that   only one parallel process needs to call the current function, listing the   names of the files written by all parallel processes.    
*  [2.x.153]  The use of this function is explained in  [2.x.154] .    
*  [2.x.155]  In order to tell Paraview to group together multiple    [2.x.156]  files that each describe one time step of a time   dependent simulation, see the  [2.x.157]    function.    
*  [2.x.158]  Older versions of VisIt (before 2.5.1), can not read    [2.x.159]  records. However, it can read visit records as written   by the write_visit_record() function.  
* [0.x.213]*
   This function writes several .vtu files and a .pvtu record in parallel   and constructs the filenames automatically. It is a combination of    [2.x.160]  or    [2.x.161]  and    [2.x.162]      For example, running   <code> write_vtu_with_pvtu_record("output/", "solution", 3, comm, 4, 2)   </code> on 10 processes generates the files  
* [1.x.28]
*    where the `.0.vtu` file contains the output of the first half of the   processes grouped together, and the `.1.vtu` the data from the remaining   half.     A specified  [2.x.163]  and a  [2.x.164]    form the first part of the filename. The filename is then extended with   a  [2.x.165]  labeling the current timestep/iteration/etc., the processor ID,   and finally the .vtu/.pvtu ending. Since the number of timesteps to be   written depends on the application, the number of digits to be reserved in   the filename can be specified as parameter  [2.x.166]  and the number   is not padded with leading zeros if this parameter is left at its default   value  [2.x.167]  If more than one file identifier   is needed (e.g. time step number and iteration counter of solver), the   last identifier is used as  [2.x.168]  while all other identifiers have to be   added to  [2.x.169]  when calling this function.     In a   parallel setting, several files are typically written per time step. The   number of files written in parallel depends on the number of MPI processes   (see parameter  [2.x.170]  and a   specified number of  [2.x.171]  with default value 0. The background is that   VTU file output supports grouping files from several CPUs into a given   number of files using MPI I/O when writing on a parallel filesystem. The   default value of  [2.x.172]  is 0, meaning that every MPI rank will write one   file. A value of 1 will generate one big file containing the solution over   the whole domain, while a larger value will create  [2.x.173]  files (but not   more than there are MPI ranks).     Note that only one processor needs to   generate the .pvtu file, where processor zero is chosen to take over this   job.     The return value is the filename of the centralized file for the pvtu   record.    
*  [2.x.174]  The code simply combines the strings  [2.x.175]  and    [2.x.176]  i.e., the user has to make sure that    [2.x.177]  contains a trailing character, e.g. "/", that separates the   directory from the filename.    
*  [2.x.178]  Use an empty string "" for the first argument if output is to be   written in the current working directory.  
* [0.x.214]*
   Obtain data through get_patches() and write it to <tt>out</tt> in SVG   format. See  [2.x.179]   
* [0.x.215]*
   Obtain data through get_patches() and write it to <tt>out</tt> in deal.II   intermediate format. See  [2.x.180]      Note that the intermediate format is what its name suggests: a direct   representation of internal data. It isn't standardized and will change   whenever we change our internal representation. You can only expect to   process files written in this format using the same version of deal.II   that was used for writing.  
* [0.x.216]*
   Create an XDMFEntry based on the data in the data_filter. This assumes   the mesh and solution data were written to a single file. See   write_xdmf_file() for an example of usage.  
* [0.x.217]*
   Create an XDMFEntry based on the data in the data_filter. This assumes   the mesh and solution data were written to separate files. See   write_xdmf_file() for an example of usage.  
* [0.x.218]*
   Write an XDMF file based on the provided vector of XDMFEntry objects.   Below is an example of how to use this function with HDF5 and the   DataOutFilter:    
* [1.x.29]
*   
* [0.x.219]*
   Write the data in  [2.x.181]  to a single HDF5 file containing both the   mesh and solution values. Below is an example of how to use this function   with the DataOutFilter:    
* [1.x.30]
*   
* [0.x.220]*
   Write the data in data_filter to HDF5 file(s). If write_mesh_file is   false, the mesh data will not be written and the solution file will   contain only the solution values. If write_mesh_file is true and the   filenames are the same, the resulting file will contain both mesh data   and solution values.  
* [0.x.221]*
   DataOutFilter is an intermediate data format that reduces the amount of   data that will be written to files. The object filled by this function   can then later be used again to write data in a concrete file format;   see, for example,  [2.x.182]   
* [0.x.222]*
   Write data and grid to <tt>out</tt> according to the given data format.   This function simply calls the appropriate <tt>write_*</tt> function. If   no output format is requested, the <tt>default_format</tt> is written.     An error occurs if no format is provided and the default format is   <tt>default_format</tt>.  
* [0.x.223]*
   Set the default format. The value set here is used anytime, output for   format <tt>default_format</tt> is requested.  
* [0.x.224]*
   Set the flags to be used for output. This method expects <tt>flags</tt>   to be a member of one of the child classes of <tt>OutputFlagsBase</tt>.  
* [0.x.225]*
   A function that returns the same string as the respective function in the   base class does; the only exception being that if the parameter is   omitted, then the value for the present default format is returned, i.e.   the correct suffix for the format that was set through   set_default_format() or parse_parameters() before calling this function.  
* [0.x.226]*
   Declare parameters for all output formats by declaring subsections within   the parameter file for each output format and call the respective   <tt>declare_parameters</tt> functions of the flag classes for each output   format.     Some of the declared subsections may not contain entries, if the   respective format does not export any flags.     Note that the top-level parameters denoting the number of subdivisions   per patch and the output format are not declared, since they are only   passed to virtual functions and are not stored inside objects of this   type. You have to declare them yourself.  
* [0.x.227]*
   Read the parameters declared in declare_parameters() and set the flags   for the output formats accordingly.     The flags thus obtained overwrite all previous contents of the flag   objects as default-constructed or set by the set_flags() function.  
* [0.x.228]*
   Return an estimate for the memory consumption, in bytes, of this object.   This is not exact (but will usually be close) because calculating the   memory usage of trees (e.g.,  [2.x.183]  is difficult.  
* [0.x.229]*
   This is the abstract function through which derived classes propagate   preprocessed data in the form of Patch structures (declared in the base   class DataOutBase) to the actual output function. You need to overload   this function to allow the output functions to know what they shall   print.  
* [0.x.230]*
   Abstract virtual function through which the names of data sets are   obtained by the output functions of the base class.  
* [0.x.231]*
   This functions returns information about how the individual components of   output files that consist of more than one data set are to be   interpreted.     It returns a list of index pairs and corresponding name and type indicating   which components of the output are to be considered vector- or   tensor-valued rather than just a collection of scalar data. The index pairs   are inclusive; for example, if we have a Stokes problem in 2d with   components (u,v,p), then the corresponding vector data range should be   (0,1), and the returned list would consist of only a single element with a   tuple such as (0,1,"velocity",component_is_part_of_vector).     Since some of the derived classes do not know about non-scalar data, this   function has a default implementation that simply returns an empty   string, meaning that all data is to be considered a collection of scalar   fields.  
* [0.x.232]*
   Validate that the names of the datasets returned by get_dataset_names() and   get_nonscalar_data_ranges() are valid. This currently consists of checking   that names are not used more than once. If an invalid state is encountered,   an Assert() will be triggered in debug mode.  
* [0.x.233]*
   The default number of subdivisions for patches. This is filled by   parse_parameters() and should be obeyed by build_patches() in derived   classes.  
* [0.x.234]*
   Standard output format.  Use this format, if output format default_format   is requested. It can be changed by the <tt>set_format</tt> function or in   a parameter file.  
* [0.x.235]*
   Flags to be used upon output of OpenDX data. Can be changed by using the   <tt>set_flags</tt> function.  
* [0.x.236]*
   Flags to be used upon output of UCD data. Can be changed by using the   <tt>set_flags</tt> function.  
* [0.x.237]*
   Flags to be used upon output of GNUPLOT data. Can be changed by using the   <tt>set_flags</tt> function.  
* [0.x.238]*
   Flags to be used upon output of POVRAY data. Can be changed by using the   <tt>set_flags</tt> function.  
* [0.x.239]*
   Flags to be used upon output of EPS data in one space dimension. Can be   changed by using the <tt>set_flags</tt> function.  
* [0.x.240]*
   Flags to be used upon output of gmv data in one space dimension. Can be   changed by using the <tt>set_flags</tt> function.  
* [0.x.241]*
   Flags to be used upon output of Tecplot data in one space dimension. Can   be changed by using the <tt>set_flags</tt> function.  
* [0.x.242]*
   Flags to be used upon output of vtk data in one space dimension. Can be   changed by using the <tt>set_flags</tt> function.  
* [0.x.243]*
   Flags to be used upon output of svg data in one space dimension. Can be   changed by using the <tt>set_flags</tt> function.  
* [0.x.244]*
   Flags to be used upon output of deal.II intermediate data in one space   dimension. Can be changed by using the <tt>set_flags</tt> function.  
* [0.x.245]*
 A class that is used to read data written in deal.II intermediate format back in, so that it can be written out in any of the other supported graphics formats. This class has two main purposes:
*  The first use of this class is so that application programs can defer the decision of which graphics format to use until after the program has been run. The data is written in intermediate format into a file, and later on it can then be converted into any graphics format you wish. This may be useful, for example, if you want to convert it to gnuplot format to get a quick glimpse and later on want to convert it to OpenDX format as well to get a high quality version of the data. The present class allows to read this intermediate format back into the program, and allows it to be written in any other supported format using the relevant functions of the base class.
*  The second use is mostly useful in parallel programs: rather than having one central process generate the graphical output for the entire program, one can let each process generate the graphical data for the cells it owns, and write it into a separate file in intermediate format. Later on, all these intermediate files can then be read back in and merged together, a process that is fast compared to generating the data in the first place. The use of the intermediate format is mostly because it allows separate files to be merged, while this is almost impossible once the data has been written out in any of the supported established graphics formats.
*  This second use scenario is explained in some detail in the  [2.x.184]  example program.
*  In order to read data back into this object, you have to know the template parameters for the space dimension which were used when writing the data. If this knowledge is available at compile time, then this is no problem. However, if it is not (such as in a simple format converter), then it needs to be figured out at run time, even though the compiler already needs it at compile time. A way around using the  [2.x.185]  function.
*  Note that the intermediate format is what its name suggests: a direct representation of internal data. It isn't standardized and will change whenever we change our internal representation. You can only expect to process files written in this format using the same version of deal.II that was used for writing.
* 

* 
*  [2.x.186] 

* 
* [0.x.246]*
   Read a sequence of patches as written previously by    [2.x.187]  and store them in the   present object. This overwrites any previous content.  
* [0.x.247]*
   This function can be used to merge the patches read by the other object   into the patches that this present object stores. This is sometimes handy   if one has, for example, a domain decomposition algorithm where each   block is represented by a DoFHandler of its own, but one wants to output   the solution on all the blocks at the same time. Alternatively, it may   also be used for parallel programs, where each process only generates   output for its share of the cells, even if all processes can see all   cells.     For this to work, the input files for the present object and the given   argument need to have the same number of output vectors, and they need to   use the same number of subdivisions per patch. The output will probably   look rather funny if patches in both objects overlap in space.     If you call read() for this object after merging in patches, the previous   state is overwritten, and the merged-in patches are lost.     This function will fail if either this or the other object did not yet   set up any patches.  
* [0.x.248]*
   Exception  
* [0.x.249]*
   Exception  
* [0.x.250]*
   Exception  
* [0.x.251]*
   This is the function through which this class propagates preprocessed   data in the form of Patch structures (declared in the base class   DataOutBase) to the actual output function.     It returns the patches as read the last time a stream was given to the   read() function.  
* [0.x.252]*
   Abstract virtual function through which the names of data sets are   obtained by the output functions of the base class.     Return the names of the variables as read the last time we read a file.  
* [0.x.253]*
   This functions returns information about how the individual components of   output files that consist of more than one data set are to be   interpreted.     It returns a list of index pairs and corresponding name indicating which   components of the output are to be considered vector-valued rather than   just a collection of scalar data. The index pairs are inclusive; for   example, if we have a Stokes problem in 2d with components (u,v,p), then   the corresponding vector data range should be (0,1), and the returned   list would consist of only a single element with a tuple such as   (0,1,"velocity").     Since some of the derived classes do not know about vector data, this   function has a default implementation that simply returns an empty   string, meaning that all data is to be considered a collection of scalar   fields.  
* [0.x.254]*
   Arrays holding the set of patches as well as the names of output   variables, all of which we read from an input stream.  
* [0.x.255]*
   Information about whether certain components of the output field are to   be considered vectors.  
* [0.x.256]*
 A class to store relevant data to use when writing a lightweight XDMF file. The XDMF file in turn points to heavy data files (such as HDF5) where the actual simulation data is stored. This allows flexibility in arranging the data, and also allows the mesh to be separated from the point data.

* 
* [0.x.257]*
   Default constructor that creates an invalid object.  
* [0.x.258]*
   Simplified constructor that calls the complete constructor for   cases where  [2.x.188] , and    [2.x.189] .  
* [0.x.259]*
   Simplified constructor that calls the complete constructor for   cases where  [2.x.190] .  
* [0.x.260]*
   Constructor that sets all members to provided parameters.  
* [0.x.261]*
   Record an attribute and associated dimensionality.  
* [0.x.262]*
   Read or write the data of this object for serialization using the   [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.263]*
   Get the XDMF content associated with this entry.   If the entry is not valid, this returns an empty string.      [2.x.191]  Use the overload taking an `unsigned int` and a   `const ReferenceCell &` instead.  
* [0.x.264]*
   Get the XDMF content associated with this entry.   If the entry is not valid, this returns an empty string.  
* [0.x.265]*
   Whether this entry is valid and contains data to be written.  
* [0.x.266]*
   The name of the HDF5 heavy data solution file this entry references.  
* [0.x.267]*
   The name of the HDF5 mesh file this entry references.  
* [0.x.268]*
   The simulation time associated with this entry.  
* [0.x.269]*
   The number of data nodes.  
* [0.x.270]*
   The number of data cells.  
* [0.x.271]*
   The dimension associated with the data.  
* [0.x.272]*
   The dimension of the space the data lives in.   Note that dimension <= space_dimension.  
* [0.x.273]*
   The attributes associated with this entry and their dimension.  
* [0.x.274]*
   Output operator for an object of type  [2.x.192]  This   operator dumps the intermediate graphics format represented by the patch   data structure. It may later be converted into regular formats for a   number of graphics programs.  
* [0.x.275]*
   Input operator for an object of type  [2.x.193]  This   operator reads the intermediate graphics format represented by the patch   data structure, using the format in which it was written using the   operator<<.  
* [0.x.276]

include/deal.II-translator/base/derivative_form_0.txt
[0.x.0]*
 This class represents the (tangential) derivatives of a function  [2.x.0] . Such functions are always used to map the reference dim-dimensional cell into spacedim-dimensional space. For such objects, the first derivative of the function is a linear map from  [2.x.1]  to  [2.x.2] , i.e., it can be represented as a matrix in  [2.x.3] . This makes sense since one would represent the first derivative,  [2.x.4]  with  [2.x.5] , in such a way that the directional derivative in direction  [2.x.6]  so that

* 
* [1.x.0]
*  i.e., one needs to be able to multiply the matrix  [2.x.7]  by a vector in  [2.x.8] , and the result is a difference of function values, which are in  [2.x.9] . Consequently, the matrix must be of size  [2.x.10] .
*  Similarly, the second derivative is a bilinear map from   [2.x.11]  to  [2.x.12] , which one can think of a rank-3 object of size  [2.x.13] .
*  In deal.II we represent these derivatives using objects of type DerivativeForm [2.x.14]  DerivativeForm [2.x.15]  and so on.

* 
* [0.x.1]*
   Constructor. Initialize all entries to zero.  
* [0.x.2]*
   Constructor from a tensor.  
* [0.x.3]*
   Constructor from a tensor.  
* [0.x.4]*
   Read-Write access operator.  
* [0.x.5]*
   Read-only access operator.  
* [0.x.6]*
   Assignment operator.  
* [0.x.7]*
   Assignment operator.  
* [0.x.8]*
   Assignment operator.  
* [0.x.9]*
   Converts a DerivativeForm <order, dim, dim, Number> to Tensor<order+1, dim,   Number>. In particular, if order == 1 and the derivative is the Jacobian of    [2.x.16] , then Tensor[i] =  [2.x.17] .  
* [0.x.10]*
   Converts a DerivativeForm<1, dim, 1, Number> to Tensor<1, dim, Number>.  
* [0.x.11]*
   Return the transpose of a rectangular DerivativeForm,   viewed as a two dimensional matrix.  
* [0.x.12]*
   Compute the Frobenius norm of this form, i.e., the expression    [2.x.18] .  
* [0.x.13]*
   Compute the volume element associated with the jacobian of the   transformation  [2.x.19] . That is to say if  [2.x.20]  is square, it computes    [2.x.21] , in case DF is not square returns  [2.x.22] .  
* [0.x.14]*
   Assuming that the current object stores the Jacobian of a mapping    [2.x.23] , then the current function computes the [1.x.1] form   of the derivative, namely  [2.x.24] , where    [2.x.25] . If  [2.x.26]  is a square matrix (i.e.,  [2.x.27] ), then this function   simplifies to computing  [2.x.28] .  
* [0.x.15]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.16]*
   Exception.  
* [0.x.17]*
   Auxiliary function that computes  [2.x.29]  where A represents the current   object.  
* [0.x.18]*
   Array of tensors holding the subelements.  
* [0.x.19]*
 One of the uses of DerivativeForm is to apply it as a linear transformation. This function returns  [2.x.30] , which approximates the change in  [2.x.31]  when  [2.x.32]  is changed by the amount  [2.x.33]  [1.x.2] The transformation corresponds to [1.x.3] in index notation and corresponds to  [2.x.34]  in matrix notation.
*   [2.x.35]  DerivativeForm

* 
* [0.x.20]*
 Similar to the previous apply_transformation(). Each row of the result corresponds to one of the rows of  [2.x.36]  transformed by  [2.x.37]  equivalent to  [2.x.38]  in matrix notation.
*   [2.x.39]  DerivativeForm

* 
* [0.x.21]*
 Similar to the previous apply_transformation(). Each row of the result corresponds to one of the rows of  [2.x.40]  transformed by  [2.x.41] 
*   [2.x.42]  DerivativeForm

* 
* [0.x.22]*
 Similar to the previous apply_transformation(). In matrix notation, it computes  [2.x.43] . Moreover, the result of this operation  [2.x.44]  can be interpreted as a metric tensor in  [2.x.45]  which corresponds to the Euclidean metric tensor in  [2.x.46] . For every pair of vectors  [2.x.47] , we have: [1.x.4]
*   [2.x.48]  DerivativeForm

* 
* [0.x.23]*
 Transpose of a rectangular DerivativeForm DF, mostly for compatibility reasons.
*   [2.x.49]  DerivativeForm

* 
* [0.x.24]

include/deal.II-translator/base/discrete_time_0.txt
[0.x.0]*
 This class provides a means to keep track of the simulation time in a time-dependent simulation. It manages stepping forward from a start time  [2.x.0]  to an end time  [2.x.1] . It also allows adjusting the time step size during the simulation. This class provides the necessary interface to be incorporated in any time-dependent simulation. The usage of this class is demonstrated in  [2.x.2]  and  [2.x.3] .
*  This class provides a number of invariants that are guaranteed to be true at all times.
*  The current simulation time is within the closed interval between the   start time and the end time ( [2.x.4] ). Whenever time is incremented, the step size is positive ( [2.x.5] ).   In other words, time advances in strictly ascending order   ( [2.x.6] ).
*  The model this class follows is that one sets adesired* time step length either through the constructor or using set_desired_next_step_size() function. This step size will then be used in all following calls to the advance_time() function, but may be adjusted slightly towards the end of the simulation to ensure that the simulation time hits the end time exactly. The adjustment is useful for the following reasons:
*  Let's say that you loop over all of the time steps by using a `for` loop

* 
* [1.x.0]
*  or, if you like this better, the equivalent `while` loop:

* 
* [1.x.1]
* 
*  In the above example the time starts at  [2.x.7]  until  [2.x.8] . Assuming the time step  [2.x.9]  is not modified inside the loop, the time is advanced from  [2.x.10]  to  [2.x.11] ,  [2.x.12] ,  [2.x.13]  and finally it reaches the end time at  [2.x.14] . Here, the final step size needs to be reduced from its desired value of 0.3 to  [2.x.15]  in order to ensure that we finish the simulation exactly at the specified end time. In fact, you should assume that not only the last time step length may be adjusted, but also previously ones
* 
*  -  for example, this class may take the liberty to spread the decrease in time step size out over several time steps and increment time from  [2.x.16] , to  [2.x.17] ,  [2.x.18] ,  [2.x.19] , and finally  [2.x.20]  to avoid too large a change in time step size from one step to another.
*  The other situation in which the time step needs to be adjusted (this time to slightly larger values) is if a time increment falls just short of the final time. Imagine, for example, a similar situation as above, but with different end time:

* 
* [1.x.2]
*  Here, the time step from  [2.x.21]  to  [2.x.22]  falls just short of the final time  [2.x.23] . Instead of following up with a very small step of length  [2.x.24] , the class stretches the last time step (or last time steps) slightly to reach the desired end time.
*  The examples above make clear that the time step size given to this class is only adesired* step size. You can query the actual time step size using the get_next_step_size() function.
* 

*  ### Details of time-stepping
*  Since time is marched forward in a discrete manner in our simulations, we need to discuss how we increment time. During time stepping we enter two separate alternating regimes in every step.
*  The*snapshot** stage (the*current** stage, the*consistent**
   stage): In this part of the algorithm, we are at  [2.x.25]  and all   quantities of the simulation (displacements, strains, temperatures, etc.)   are up-to-date for  [2.x.26] . In this stage,current time* refers to    [2.x.27] ,next time* refers to  [2.x.28] ,previous time* refers to    [2.x.29] . The other useful notation quantities are thenext* time step   size  [2.x.30]  andprevious* time step size  [2.x.31] . In   this stage, it is a perfect occasion to generate text output using print   commands within the user's code. Additionally, post-processed outputs can   be prepared here, which can then later be viewed by visualization programs   such as `Tecplot`, `Paraview`, and `VisIt`. Additionally, during the   snapshot stage, the code can assess the quality of the previous step and   decide whether it wants to increase or decrease the time step size. The   step size for the next time step can be modified here, by calling   set_desired_next_step_size(). The*update** stage (the*transition** stage, the*inconsistent**
   stage): In this section of the program, the internal state of the   simulation is getting updated from  [2.x.32]  to  [2.x.33] . All of the   variables need to be updated one by one, the step number is incremented,   the time is incremented by  [2.x.34] , and time-integration   algorithms are used to update the other simulation quantities. In the   middle of this stage, some variables have been updated to  [2.x.35]  but   other variables still represent their value at  [2.x.36] . Thus, we call this   the inconsistent stage, requiring that no post-processing output related   to the state variables take place within it. The state variables, namely   those related to time, the solution field and any internal variables, are   not synchronized and then get updated one by one. In general, the order of   updating variables is arbitrary, but some care should be taken if there   are interdependencies between them. For example, if some variable such as    [2.x.37]  depends on the calculation of another variable such as  [2.x.38] , then  [2.x.39]    must be updated before  [2.x.40]  can be updated.
*    The question arises whether time should be incremented before updating   state quantities. Multiple possibilities exist, depending on program and   formulation requirements, and possibly the programmer's preferences:   Time is incrementedbefore* the rest of the updates. In this case, even     though time is incremented to  [2.x.41] , not all variables are updated     yet. During this update phase,  [2.x.42]  equals theprevious* time step     size.Previous* means that it is referring to the  [2.x.43]  of the     `advance_time()` command that was performed previously. In the     following example code, we are assuming that `a` and `b` are two state     variables that need to be updated in this time step.    
* [1.x.3]
*      Here, the code starts in a consistent state, but once advance_time()     is called, the time variable, `a`, and `b` are no longer consistent     with each other until after the last statement. At that point,     the variables are all consistent again.   Time is incremented from  [2.x.44]  to  [2.x.45] after* all variables have     already been updated for  [2.x.46] . During the update stage,  [2.x.47]  is     denoted as thenext* time step size.Next* means that  [2.x.48]  of the     step corresponds to the `advance_time()` command that will happen     subsequently.    
* [1.x.4]
*    Time is incremented in the middle of the other updates: In this case      [2.x.49]  would correspond tonext* orprevious* depending of whether it     is used before or after the call to `advance_time()`.    
* [1.x.5]
* 
*  One thing to note is that, during the update phase,  [2.x.50]  is referred to either*next** or*previous** time step size, depending on whether advance_time() has been called yet. The notion ofcurrent* time step size is ill-defined. In fact, in the update stage the definition of every variable depends on whether it has been updated yet or not, hence the name*the inconsistent stage**.
*  The following code snippet shows the code sections for the snapshot stage and the update stage in the context of a complete time-dependent simulation. This code follows the coding conventions incorporated in the tutorial examples. Note that even though this example is written in the format of a `for` loop, it can equivalently be written as a `while` or `do while` loop (as shown in  [2.x.51] ).

* 
* [1.x.6]
*  The `run()` function in  [2.x.52]  shows a very similar example where the call to advance_time() ends the update stage and is followed by generating graphical output with the then-current time.

* 
* [0.x.1]*
   Constructor.      [2.x.53]  start_time The time at the start of the simulation.      [2.x.54]  end_time The time at the end of the simulation.      [2.x.55]  desired_start_step_size A desired step size for incrementing   time for the first step. It is not guaranteed that this value will be   actually used as the size of the first step, as discussed in the   introduction.      [2.x.56]   [2.x.57]  must be non-negative.    
*  [2.x.58]   [2.x.59]  is an optional parameter. If it is not   provided or it is specified as zero, it indicates that the   desired size for the time step will be calculated at a different location   in the code. In this case, the created object cannot increment time until   the step size is changed by calling set_desired_next_step_size().  
* [0.x.2]*
   Return the current time.  
* [0.x.3]*
   Return the next time that we would reach if we were to advance the time   by one step.    
*  [2.x.60]  If the simulation is at the end time, this method returns the   end time.  
* [0.x.4]*
   Return the time we were at before `advance_time()` was called last time.    
*  [2.x.61]  If the simulation is at the start time, this method returns the   start time.  
* [0.x.5]*
   Return the start time.  
* [0.x.6]*
   Return the end of the time interval.   The final time step ends exactly at this point. This exact floating-point   equality is very important because it allows us to equality-compare   current time with end time and decide whether we have reached the end of   the simulation.  
* [0.x.7]*
   Return whether no step has taken place yet.  
* [0.x.8]*
   Return whether time has reached the end time.  
* [0.x.9]*
   Return the size of the step from current time step to the   next. As discussed in the introduction to the class, this is the  actual* time step, and may differ from thedesired* time step   set in the constructor or through the   set_desired_next_step_size() function.    
*  [2.x.62]  If the simulation is at the end time, this method returns zero.  
* [0.x.10]*
   Return the step size of the previous step.    
*  [2.x.63]  If the simulation is at the start time, this method returns zero.  
* [0.x.11]*
   Return the number of times the simulation time has been incremented.   Return zero when the simulation is at the start time.  
* [0.x.12]*
   Set thedesired* value of the next time step size. By calling this   method, we are indicating the next time advance_time() is called, we   would like  [2.x.64]  to be used to advance the simulation time.   However, if the step is too large such that the next   simulation time exceeds the end time, the step size is truncated.   Additionally, if the step size is such that the next simulation time   approximates the end time (but falls just slightly short of it), the step   size is adjusted such that the next simulation time exactly matches the   end time.  
* [0.x.13]*
   Set theactual* value of the next time step size. By calling this   method, we are indicating the next time advance_time() is called,    [2.x.65]  is to be used to advance the simulation time.    
*  [2.x.66]  The difference between set_next_step_size() and   set_desired_next_step_size() is that the former uses the provided  [2.x.67]    exactly without any adjustment, but produces an   error (in debug mode) if  [2.x.68]  is not in the acceptable range.   Generally, set_desired_next_step_size() is the preferred method because   it can adjust the  [2.x.69]  intelligently, based on  [2.x.70] .    [2.x.71]   [2.x.72] .  
* [0.x.14]*
   Advance the current time based on the value of the current step.   If you want to adjust the next time step size, call the method   set_desired_next_step_size() before calling this method.   If you call this function repeatedly, the time   is increased with the same step size until it reaches the end   time. See the documentation of set_desired_next_step_size() for   explanation of the rules for automatic adjustment of the step size.      [2.x.73]  Current time must be smaller than the end time. The object cannot   advance time if it is already at the end time. This rule is created to   avoid the creation of an infinite loop when advance_time() is called   inside a loop.      [2.x.74]  The time step size must be nonzero. If the step size is currently   zero, change it by calling set_desired_next_step_size() before calling   advance_time().  
* [0.x.15]*
   Set the current time equal to start time and set the step size to the   initial step size.  
* [0.x.16]*
   The beginning of the time interval.  
* [0.x.17]*
  The end of the time interval.  
* [0.x.18]*
   The current time.  
* [0.x.19]*
   The time at the next step.    
*  [2.x.75]  Internally, the next simulation time is stored instead of the   current step size. For example, when the method   set_desired_next_step_size() is called, it computes the appropriate next   simulation time and stores it. When advance_time() is called, the   current_time is replaced by next_time. This choice for the internal state   allows for simpler code and ensures than when we call advance_time() at   the last step, the floating-point value of the time exactly matches the   end time.  
* [0.x.20]*
   The previous time.  
* [0.x.21]*
   The size of the first step.  
* [0.x.22]*
   The step number i.e. the number of times the simulation time ha been   incremented.  
* [0.x.23]

include/deal.II-translator/base/event_0.txt
[0.x.0]*
   Objects of this kind are used to notify interior applications of changes   provoked by an outer loop. They are handed to the application through    [2.x.0]  and it is up to the actual application how to handle   them.     Event is organized as an extensible binary enumerator. Every class can   add its own events using assign(). A typical code example is    
* [1.x.0]
*   
* [0.x.1]*
     This function registers a new event type and assigns a unique     identifier to it. The result of this function should be stored for     later use.    
* [0.x.2]*
     If you forgot to store the result of assign, here is how to retrieve it     knowing the name.    
* [0.x.3]*
     Constructor, generating a clear Event.    
* [0.x.4]*
     Clear all flags    
* [0.x.5]*
     Set all flags    
* [0.x.6]*
     Add the flags of the other event    
* [0.x.7]*
     Clear the flags of the other event    
* [0.x.8]*
     Test whether all the flags set in the other Event are also set in this     one.    
* [0.x.9]*
     Return <tt>true</tt> if any event is set.    
* [0.x.10]*
     List the flags to a stream.    
* [0.x.11]*
     List all assigned events.    
* [0.x.12]*
     Sometimes, actions have to be taken by all means. Therefore, if this     value is true, test() always returns true.    
* [0.x.13]*
     The actual list of events    
* [0.x.14]*
     The names of registered events    
* [0.x.15]*
   Events used by library operators  
* [0.x.16]*
     The program has just started and everything should be new.    
* [0.x.17]*
     The mesh has changed.    
* [0.x.18]*
     The current derivative leads to slow convergence of Newton's method.    
* [0.x.19]*
     The time stepping scheme starts a new time step.    
* [0.x.20]*
     The time stepping scheme has changed the time step size.    
* [0.x.21]*
   Output shift operator for events. Calls  [2.x.1]       [2.x.2]  Event  
* [0.x.22]

include/deal.II-translator/base/exceptions_0.txt
[0.x.0]*
 This class is the base class for all exception classes. Do not use its methods and variables directly since the interface and mechanism may be subject to change. Rather create new exception classes using the <tt>DeclException</tt> macro family.
*  See the  [2.x.0]  module for more details on this class and what can be done with classes derived from it.
* 

* 
*  [2.x.1] 

* 
* [0.x.1]*
   Default constructor.  
* [0.x.2]*
   Copy constructor.  
* [0.x.3]*
   Destructor.  
* [0.x.4]*
   Copy operator. This operator is deleted since exception objects   are not copyable.  
* [0.x.5]*
   Set the file name and line of where the exception appeared as well as the   violated condition and the name of the exception as a char pointer. This   function also populates the stacktrace.  
* [0.x.6]*
   Override the standard function that returns the description of the error.  
* [0.x.7]*
   Get exception name.  
* [0.x.8]*
   Print out the general part of the error information.  
* [0.x.9]*
   Print more specific information about the exception which occurred.   Overload this function in your own exception classes.  
* [0.x.10]*
   Print a stacktrace, if one has been recorded previously, to the given   stream.  
* [0.x.11]*
   Name of the file this exception happens in.  
* [0.x.12]*
   Line number in this file.  
* [0.x.13]*
   Name of the function, pretty printed.  
* [0.x.14]*
   The violated condition, as a string.  
* [0.x.15]*
   Name of the exception and call sequence.  
* [0.x.16]*
   A backtrace to the position where the problem happened, if the system   supports this.  
* [0.x.17]*
   The number of stacktrace frames that are stored in the previous variable.   Zero if the system does not support stack traces.  
* [0.x.18]*
   array of pointers that contains the raw stack trace  
* [0.x.19]*
   Internal function that generates the c_string. Called by what().  
* [0.x.20]*
   A pointer to the c_string that will be printed by what(). It is populated   by generate_message()  
* [0.x.21]*
 Declare an exception class derived from ExceptionBase without parameters.
* 

* 
*  [2.x.2]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.3]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.4] , by including the header  [2.x.5]  after all other deal.II headers have been included.
* 

* 
*  [2.x.6] 

* 
* [0.x.22]*
 Declare an exception class derived from ExceptionBase that can take one runtime argument, but if none is given in the place where you want to throw the exception, it simply reverts to the default text provided when declaring the exception class through this macro.
* 

* 
*  [2.x.7]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.8]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.9] , by including the header  [2.x.10]  after all other deal.II headers have been included.
* 

* 
*  [2.x.11] 

* 
* [0.x.23]*
 Declare an exception class derived from ExceptionBase with one additional parameter.
* 

* 
*  [2.x.12]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.13]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.14] , by including the header  [2.x.15]  after all other deal.II headers have been included.
* 

* 
*  [2.x.16] 

* 
* [0.x.24]*
 Declare an exception class derived from ExceptionBase with two additional parameters.
* 

* 
*  [2.x.17]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.18]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.19] , by including the header  [2.x.20]  after all other deal.II headers have been included.
* 

* 
*  [2.x.21] 

* 
* [0.x.25]*
 Declare an exception class derived from ExceptionBase with three additional parameters.
* 

* 
*  [2.x.22]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.23]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.24] , by including the header  [2.x.25]  after all other deal.II headers have been included.
* 

* 
*  [2.x.26] 

* 
* [0.x.26]*
 Declare an exception class derived from ExceptionBase with four additional parameters.
* 

* 
*  [2.x.27]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.28]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.29] , by including the header  [2.x.30]  after all other deal.II headers have been included.
* 

* 
*  [2.x.31] 

* 
* [0.x.27]*
 Declare an exception class derived from ExceptionBase with five additional parameters.
* 

* 
*  [2.x.32]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.33]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.34] , by including the header  [2.x.35]  after all other deal.II headers have been included.
* 

* 
*  [2.x.36] 

* 
* [0.x.28]*
 Declare an exception class derived from ExceptionBase without parameters.
* 

* 
*  [2.x.37]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.38]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.39] , by including the header  [2.x.40]  after all other deal.II headers have been included.
* 

* 
*  [2.x.41] 

* 
* [0.x.29]*
 Declare an exception class derived from ExceptionBase that can take one runtime argument, but if none is given in the place where you want to throw the exception, it simply reverts to the default text provided when declaring the exception class through this macro.
* 

* 
*  [2.x.42]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.43]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.44] , by including the header  [2.x.45]  after all other deal.II headers have been included.
* 

* 
*  [2.x.46] 

* 
* [0.x.30]*
 Declare an exception class derived from ExceptionBase with one additional parameter.
* 

* 
*  [2.x.47]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.48]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.49] , by including the header  [2.x.50]  after all other deal.II headers have been included.
* 

* 
*  [2.x.51] 

* 
* [0.x.31]*
 Declare an exception class derived from ExceptionBase with two additional parameters.
* 

* 
*  [2.x.52]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.53]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.54] , by including the header  [2.x.55]  after all other deal.II headers have been included.
* 

* 
*  [2.x.56] 

* 
* [0.x.32]*
 Declare an exception class derived from ExceptionBase with three additional parameters.
* 

* 
*  [2.x.57]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.58]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.59] , by including the header  [2.x.60]  after all other deal.II headers have been included.
* 

* 
*  [2.x.61] 

* 
* [0.x.33]*
 Declare an exception class derived from ExceptionBase with four additional parameters.
* 

* 
*  [2.x.62]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.63]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.64] , by including the header  [2.x.65]  after all other deal.II headers have been included.
* 

* 
*  [2.x.66] 

* 
* [0.x.34]*
 Declare an exception class derived from ExceptionBase with five additional parameters.
* 

* 
*  [2.x.67]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.68]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.69] , by including the header  [2.x.70]  after all other deal.II headers have been included.
* 

* 
*  [2.x.71] 

* 
* [0.x.35]*
 Declare some exceptions that occur over and over. This way, you can simply use these exceptions, instead of having to declare them locally in your class. The namespace in which these exceptions are declared is later included into the global namespace by

* 
* [1.x.0]
* 
* 

* 
*  [2.x.72] 

* 
* [0.x.36]*
    [2.x.73]  Exceptions  
* [0.x.37]*
   Exception denoting a division by zero.  
* [0.x.38]*
   Exception raised if a number is not finite.     This exception should be used to catch infinite or not a number results   of arithmetic operations that do not result from a division by zero (use   ExcDivideByZero for those).     The exception uses  [2.x.74]  as its argument to ensure that we can use   it for all scalar arguments (real or complex-valued).  
* [0.x.39]*
   Trying to allocate a new object failed due to lack of free memory.  
* [0.x.40]*
   A memory handler reached a point where all allocated objects should have   been released. Since this exception is thrown, some were still allocated.  
* [0.x.41]*
   An error occurred reading or writing a file.  
* [0.x.42]*
   An error occurred opening the named file.     The constructor takes a single argument of type  [2.x.75]  naming   the file.  
* [0.x.43]*
   Exception denoting a part of the library or application program that has   not yet been implemented. In many cases, this only indicates that there   wasn't much need for something yet, not that this is difficult to   implement. It is therefore quite worth the effort to take a look at the   corresponding place and see whether it can be implemented without too   much effort.  
* [0.x.44]*
   This exception usually indicates that some condition which the programmer   thinks must be satisfied at a certain point in an algorithm, is not   fulfilled. This might be due to some programming error above, due to   changes to the algorithm that did not preserve this assertion, or due to   assumptions the programmer made that are not valid at all (i.e. the   exception is thrown although there is no error here). Within the library,   this exception is most often used when we write some kind of complicated   algorithm and are not yet sure whether we got it right; we then put in   assertions after each part of the algorithm that check for some   conditions that should hold there, and throw an exception if they do not.     We usually leave in these assertions even after we are confident that the   implementation is correct, since if someone later changes or extends the   algorithm, these exceptions will indicate to them if they violate   assumptions that are used later in the algorithm. Furthermore, it   sometimes happens that an algorithm does not work in very rare corner   cases. These cases will then be trapped sooner or later by the exception,   so that the algorithm can then be fixed for these cases as well.  
* [0.x.45]*
   This exception is used in functions that may not be called (i.e. in pure   functions) but could not be declared pure since the class is intended to   be used anyway, even though the respective function may only be called if   a derived class is used.  
* [0.x.46]*
   This exception is used if some object is found uninitialized.  
* [0.x.47]*
   The object is in a state not suitable for this operation.  
* [0.x.48]*
   This exception is raised if a functionality is not possible in the given   dimension. Mostly used to throw function calls in 1d.     The constructor takes a single <tt>int</tt>, denoting the dimension.  
* [0.x.49]*
   This exception is raised if a functionality is not possible in the given   combination of dimension and space-dimension.     The constructor takes two <tt>int</tt>, denoting the dimension and the   space dimension.  
* [0.x.50]*
   A number is zero, but it should not be here.  
* [0.x.51]*
   The object should have been filled with something before this member   function is called.  
* [0.x.52]*
   This exception is raised whenever the sizes of two objects were assumed   to be equal, but were not.     Parameters to the constructor are the first and second size, both of type   <tt>int</tt>.  
* [0.x.53]*
   The first dimension should be either equal to the second or the third,   but it is neither.  
* [0.x.54]*
   This exception indicates that an index is not within the expected range.   For example, it may be that you are trying to access an element of a   vector which does not exist.     The constructor takes three <tt>int</tt> arguments, namely    [2.x.76]     [2.x.77]  the violating index    [2.x.78]  the lower bound    [2.x.79]  the upper bound plus one    [2.x.80]   
* [0.x.55]*
   This exception indicates that an index is not within the expected range.   For example, it may be that you are trying to access an element of a   vector which does not exist.     The constructor takes three arguments, namely    [2.x.81]     [2.x.82]  the violating index    [2.x.83]  the lower bound    [2.x.84]  the upper bound plus one    [2.x.85]      This generic exception differs from ExcIndexRange by allowing to specify   the type of indices.  
* [0.x.56]*
   A number is too small.  
* [0.x.57]*
   A generic exception definition for the ExcLowerRange above.  
* [0.x.58]*
   This exception indicates that the first argument should be an integer   multiple of the second, but is not.  
* [0.x.59]*
   This exception is thrown if the iterator you access has corrupted data.   It might for instance be, that the container it refers does not have an   entry at the point the iterator refers.     Typically, this will be an internal error of deal.II, because the   increment and decrement operators should never yield an invalid iterator.  
* [0.x.60]*
   This exception is thrown if the iterator you incremented or decremented   was already at its final state.  
* [0.x.61]*
   This exception works around a design flaw in the <tt>DeclException0</tt>   macro: exceptions declared through DeclException0 do not allow one to   specify a message that is displayed when the exception is raised, as   opposed to the other exceptions which allow to show a text along with the   given parameters.     When throwing this exception, you can give a message as a    [2.x.86]  as argument to the exception that is then displayed.   The argument can, of course, be constructed at run-time, for example   including the name of a file that can't be opened, or any other text you   may want to assemble from different pieces.  
* [0.x.62]*
   Parallel vectors with ghost elements are read-only vectors.  
* [0.x.63]*
   Some of our numerical classes allow for setting all entries to zero using   the assignment operator <tt>=</tt>.     In many cases, this assignment operator makes sense [1.x.1] for the   argument zero. In other cases, this exception is thrown.  
* [0.x.64]*
   This function requires support for the LAPACK library.  
* [0.x.65]*
   This function requires support for the MPI library.  
* [0.x.66]*
   This function requires support for the FunctionParser library.  
* [0.x.67]*
   This function requires support for the Assimp library.  
* [0.x.68]*
   This exception is raised if an error happened in a CUDA kernel.     The constructor takes a single <tt>char*</tt>, the output of   cudaGetErrorString.  
* [0.x.69]*
   This exception is raised if an error happened in a cuSPARSE function.  
* [0.x.70]*
   This function requires support for the Exodus II library.  
* [0.x.71]*
   Exception for MPI errors. This exception is only defined if    [2.x.87]  is compiled with MPI support. This exception should   be used with  [2.x.88]  to check error codes of MPI   functions. For example:  
* [1.x.2]
*    or, using the convenience macro  [2.x.89] ,  
* [1.x.3]
*      If the assertion fails then the error code will be used to print a helpful   message to the screen by utilizing the  [2.x.90]    function.    
*  [2.x.91]   
* [0.x.72]*
   Exception for ExodusII errors. This exception is only defined if    [2.x.92]  is compiled with SEACAS support, which is available   through Trilinos. This function should be used with the convenience macro   AssertThrowExodusII.    
*  [2.x.93]   
* [0.x.73]*
     Constructor.          [2.x.94]  error_code The error code returned by an ExodusII function.    
* [0.x.74]*
     Print a description of the error to the given stream.    
* [0.x.75]*
     Store the error code.    
* [0.x.76]*
 In this namespace, functions in connection with the Assert and AssertThrow mechanism are declared.
* 

* 
*  [2.x.95] 

* 
* [0.x.77]*
     Setting this variable to false will disable deal.II's exception mechanism     to abort the problem. The Assert() macro will throw the exception instead     and the AssertNothrow() macro will just print the error message. This     variable should not be changed directly. Use disable_abort_on_exception()     instead.    
* [0.x.78]*
   Set a string that is printed upon output of the message indicating a   triggered <tt>Assert</tt> statement. This string, which is printed in   addition to the usual output may indicate information that is otherwise   not readily available unless we are using a debugger. For example, with   distributed programs on cluster computers, the output of all processes is   redirected to the same console window. In this case, it is convenient to   set as additional name the name of the host on which the program runs, so   that one can see in which instance of the program the exception occurred.     The string pointed to by the argument is copied, so doesn't need to be   stored after the call to this function.     Previously set additional output is replaced by the argument given to   this function.      [2.x.96]  Exceptions  
* [0.x.79]*
   Calling this function disables printing a stacktrace along with the other   output printed when an exception occurs. Most of the time, you will want   to see such a stacktrace; suppressing it, however, is useful if one wants   to compare the output of a program across different machines and systems,   since the stacktrace shows memory addresses and library names/paths that   depend on the exact setup of a machine.      [2.x.97]  Exceptions  
* [0.x.80]*
   Calling this function switches off the use of  [2.x.98]  when   an exception is created using the Assert() macro. Instead, the Exception   will be thrown using 'throw', so it can be caught if desired. Generally,   you want to abort the execution of a program when Assert() is called, but   it needs to be switched off if you want to log all exceptions created, or   if you want to test if an assertion is working correctly. This is done   for example in regression tests. Please note that some fatal errors will   still call abort(), e.g. when an exception is caught during exception   handling.      [2.x.99]  Exceptions  
* [0.x.81]*
   The functions in this namespace are in connection with the Assert and   AssertThrow mechanism but are solely for internal purposes and are not   for use outside the exception handling and throwing mechanism.    
*  [2.x.100]   
* [0.x.82]*
     Abort the program by printing the     error message provided by  [2.x.101]  and calling  [2.x.102]     
* [0.x.83]*
     An enum describing how to treat an exception in issue_error_noreturn.    
* [0.x.84]*
       Abort the program by calling  [2.x.103]  unless        [2.x.104]  has been called: in       that case the program will throw an exception.      
* [0.x.85]*
       Throw the exception normally.      
* [0.x.86]*
     This routine does the main work for the exception generation mechanism     used in the <tt>Assert</tt> and <tt>AssertThrow</tt> macros: as the     name implies, this function either ends by throwing an exception (if      [2.x.105]  is throw_on_exception, or  [2.x.106]  is try_abort_exception     and  [2.x.107]  is false) or with a     call to <tt>abort</tt> (if  [2.x.108]  is try_abort_exception and      [2.x.109]  is true).         The actual exception object (the last argument) is typically an unnamed     object created in place; because we modify it, we can't take it by     const reference, and temporaries don't bind to non-const references.     So take it by value (=copy it) with a templated type to avoid slicing
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  the performance implications are pretty minimal anyway.          [2.x.110]     
* [0.x.87]*
     Internal function that does the work of issue_error_nothrow.    
* [0.x.88]*
     Exception generation mechanism in case we must not throw.          [2.x.111]         
*  [2.x.112]  This function is defined with a template for the same reasons as     issue_error_noreturn().    
* [0.x.89]*
     Return a string given an error code. This is similar to the     cudaGetErrorString function but there is no equivalent function for     cuSPARSE.    
* [0.x.90]*
     Return a string given an error code. This is similar to the     cudaGetErrorString function but there is no equivalent function for     cuSOLVER.    
* [0.x.91]*
 A macro that serves as the main routine in the exception mechanism for debug mode error checking. It asserts that a certain condition is fulfilled, otherwise issues an error and aborts the program.
*  A more detailed description can be found in the  [2.x.113]  module. It is first used in  [2.x.114]  and  [2.x.115] . See also the <tt>ExceptionBase</tt> class for more information.
* 

* 
*  [2.x.116]  Active in DEBUG mode only
* 

* 
*  [2.x.117]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.118]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.119] , by including the header  [2.x.120]  after all other deal.II headers have been included.
* 

* 
*  [2.x.121] 

* 
* [0.x.92]*
 A variant of the <tt>Assert</tt> macro above that exhibits the same runtime behavior as long as disable_abort_on_exception was not called.
*  However, if disable_abort_on_exception was called, this macro merely prints the exception that would be thrown to deallog and continues normally without throwing an exception.
*  A more detailed description can be found in the  [2.x.122]  module, in the discussion about the corner case at the bottom of the page.
* 

* 
*  [2.x.123]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.124]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.125] , by including the header  [2.x.126]  after all other deal.II headers have been included.
* 

* 
*  [2.x.127]  Active in DEBUG mode only

* 
*  [2.x.128] 

* 
* [0.x.93]*
 A macro that serves as the main routine in the exception mechanism for dynamic error checking. It asserts that a certain condition is fulfilled, otherwise throws an exception via the C++  [2.x.129]  mechanism. This exception can be caught via a  [2.x.130]  clause, as is shown in  [2.x.131]  and all following tutorial programs.
*  A more detailed description can be found in the  [2.x.132]  module. It is first used in  [2.x.133]  and  [2.x.134] . See also the <tt>ExceptionBase</tt> class for more information.
* 

* 
*  [2.x.135]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.136]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.137] , by including the header  [2.x.138]  after all other deal.II headers have been included.
* 

* 
*  [2.x.139]  Active in both DEBUG and RELEASE modes

* 
*  [2.x.140] 

* 
* [0.x.94]*
 Special assertion for dimension mismatch.
*  Since this is used very often and always repeats the arguments, we introduce this special assertion for ExcDimensionMismatch in order to keep the user codes shorter.
* 

* 
*  [2.x.141]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.142]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.143] , by including the header  [2.x.144]  after all other deal.II headers have been included.
* 

* 
*  [2.x.145] 

* 
* [0.x.95]*
 An assertion that tests whether <tt>vec</tt> has size <tt>dim1</tt>, and each entry of the vector is itself an array that has the size <tt>dim2</tt>.
* 

* 
*  [2.x.146]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.147]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.148] , by including the header  [2.x.149]  after all other deal.II headers have been included.
* 

* 
*  [2.x.150] 

* 
* [0.x.96]*
 An assertion that tests that a given index is within the half-open range  [2.x.151] . It throws an exception object  [2.x.152]  if the assertion fails.
* 

* 
*  [2.x.153]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.154]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.155] , by including the header  [2.x.156]  after all other deal.II headers have been included.
* 

* 
*  [2.x.157] 

* 
* [0.x.97]*
 An assertion that checks whether a number is finite or not. We explicitly cast the number to  [2.x.158]  to match the signature of the exception (see there for an explanation of why we use  [2.x.159]  at all) and to satisfy the fact that  [2.x.160]  has no implicit conversions.
* 

* 
*  [2.x.161]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.162]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.163] , by including the header  [2.x.164]  after all other deal.II headers have been included.
* 

* 
*  [2.x.165] 

* 
* [0.x.98]*
 An assertion that checks whether or not an error code returned by an MPI function is equal to  [2.x.166] . If the check fails then an exception of type ExcMPI is thrown with the given error code as an argument.
* 

* 
*  [2.x.167]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.168]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.169] , by including the header  [2.x.170]  after all other deal.II headers have been included.
* 

* 
*  [2.x.171]  Active only if deal.II is compiled with MPI

* 
*  [2.x.172] 

* 
* [0.x.99]*
 An assertion that checks that the error code produced by calling a CUDA routine is equal to cudaSuccess.
* 

* 
*  [2.x.173]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.174]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.175] , by including the header  [2.x.176]  after all other deal.II headers have been included.
* 

* 
*  [2.x.177] 

* 
* [0.x.100]*
 The non-throwing equivalent of AssertCuda.
* 

* 
*  [2.x.178]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.179]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.180] , by including the header  [2.x.181]  after all other deal.II headers have been included.
* 

* 
*  [2.x.182] 

* 
* [0.x.101]*
 An assertion that checks that the kernel was launched and executed successfully.
* 

* 
*  [2.x.183]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.184]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.185] , by including the header  [2.x.186]  after all other deal.II headers have been included.
* 

* 
*  [2.x.187] 

* 
* [0.x.102]*
 An assertion that checks that the error code produced by calling a cuSPARSE routine is equal to CUSPARSE_STATUS_SUCCESS.
* 

* 
*  [2.x.188]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.189]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.190] , by including the header  [2.x.191]  after all other deal.II headers have been included.
* 

* 
*  [2.x.192] 

* 
* [0.x.103]*
 The non-throwing equivalent of AssertCusparse.
* 

* 
*  [2.x.193]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.194]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.195] , by including the header  [2.x.196]  after all other deal.II headers have been included.
* 

* 
*  [2.x.197] 

* 
* [0.x.104]*
 An assertion that checks that the error code produced by calling a cuSOLVER routine is equal to CUSOLVER_STATUS_SUCCESS.
* 

* 
*  [2.x.198]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.199]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.200] , by including the header  [2.x.201]  after all other deal.II headers have been included.
* 

* 
*  [2.x.202] 

* 
* [0.x.105]*
 Assertion that checks that the error code produced by calling an ExodusII routine is equal to EX_NOERR (which is zero).
* 

* 
*  [2.x.203]  This and similar macro names are examples of preprocessor definitions in the deal.II library that are not prefixed by a string that likely makes them unique to deal.II. As a consequence, it is possible that other libraries your code interfaces with define the same name, and the result will be name collisions (see https://en.wikipedia.org/wiki/Name_collision). One can  [2.x.204]  this macro, as well as all other macros defined by deal.II that are not prefixed with either  [2.x.205] , by including the header  [2.x.206]  after all other deal.II headers have been included.
* 

* 
*  [2.x.207] 

* 
* [0.x.106]

include/deal.II-translator/base/flow_function_0.txt
[0.x.0]*
   Base class for analytic solutions to incompressible flow problems.     Additional to the Function interface, this function provides for an   offset of the pressure: if the pressure of the computed solution has an   integral mean value different from zero, this value can be given to   pressure_adjustment() in order to compute correct pressure errors.    
*  [2.x.0]  Derived classes should implement pressures with integral mean value   zero always.    
*  [2.x.1]  Thread safety: Some of the functions make use of internal data to   compute values. Therefore, every thread should obtain its own object of   derived classes.    
*  [2.x.2]   
* [0.x.1]*
     Constructor, setting up some internal data structures.    
* [0.x.2]*
     Virtual destructor.    
* [0.x.3]*
     Store an adjustment for the pressure function, such that its mean value     is <tt>p</tt>.    
* [0.x.4]*
     Values in a structure more suitable for vector valued functions. The     outer vector is indexed by solution component, the inner by quadrature     point.    
* [0.x.5]*
     Gradients in a structure more suitable for vector valued functions. The     outer vector is indexed by solution component, the inner by quadrature     point.    
* [0.x.6]*
     Force terms in a structure more suitable for vector valued functions.     The outer vector is indexed by solution component, the inner by     quadrature point.          [2.x.3]  This is not the true Laplacian, but the force term to be used     as right hand side in Stokes' equations    
* [0.x.7]*
     The force term in the momentum equation.    
* [0.x.8]*
     Return an estimate for the memory consumption, in bytes, of this object.    
* [0.x.9]*
     Mean value of the pressure to be added by derived classes.    
* [0.x.10]*
     A mutex that guards the following scratch arrays.    
* [0.x.11]*
     Auxiliary values for the usual Function interface.    
* [0.x.12]*
     Auxiliary values for the usual Function interface.    
* [0.x.13]*
   Laminar pipe flow in two and three dimensions. The channel stretches   along the [1.x.0]-axis and has radius  [2.x.4]  The  [2.x.5]  number   is used to scale the pressure properly for a Navier-Stokes problem.    
*  [2.x.6]   
* [0.x.14]*
     Construct an object for the given channel radius <tt>r</tt> and the     Reynolds number <tt>Re</tt>.    
* [0.x.15]*
   Artificial divergence free function with homogeneous boundary conditions   on the cube [-1,1]<sup>dim</sup>.     The function in 2D is   [1.x.1]  
*  [2.x.7]   
* [0.x.16]*
     Constructor setting the Reynolds number required for pressure     computation and scaling of the right hand side.    
* [0.x.17]*
     Change the viscosity and the reaction parameter.    
* [0.x.18]*
   A singular solution to Stokes' equations on a 2d L-shaped domain.     This function satisfies  [2.x.8]  and   represents a typical singular solution around a reentrant corner of an   L-shaped domain that can be created using  [2.x.9]  The   velocity vanishes on the two faces of the re-entrant corner and    [2.x.10]  and  [2.x.11]  are singular at the origin while they are   smooth in the rest of the domain because they can be written as a product   of a smooth function and the term  [2.x.12]  where  [2.x.13]  is the radius   and  [2.x.14]  is a fixed parameter.     Taken from Houston, Sch&ouml;tzau, Wihler, proceeding ENUMATH 2003.    
*  [2.x.15]   
* [0.x.19]*
   Flow solution in 2D by Kovasznay (1947).     This function is valid on the half plane right of the line [1.x.2].    
*  [2.x.16]   
* [0.x.20]*
     Construct an object for the give Reynolds number <tt>Re</tt>. If the     parameter <tt>Stokes</tt> is true, the right hand side of the momentum     equation returned by vector_laplacians() contains the nonlinearity,     such that the Kovasznay solution can be obtained as the solution to a     Stokes problem.    
* [0.x.21]

include/deal.II-translator/base/function_0.txt
[0.x.0]*
 This class is a model for a general function that, given a point at which to evaluate the function, returns a vector of values with one or more components.
*  The class serves the purpose of representing both scalar and vector valued functions. To this end, we consider scalar functions as a special case of vector valued functions, in the former case only having a single component return vector. Since handling vectors is comparatively expensive, the interface of this class has functions which only ask for a single component of the vector-valued results (this is what you will usually need in case you know that your function is scalar-valued) as well as functions you can ask for an entire vector of results with as many components as the function object represents. Access to function objects therefore is through the following methods:

* 
* [1.x.0]
* 
*  For more efficiency, there are other functions returning one or all components at a list of points at once:

* 
* [1.x.1]
* 
*  Furthermore, there are functions returning the gradient of the function or even higher derivatives at one or several points.
*  You will usually only overload those functions you need; the functions returning several values at a time (value_list(), vector_value_list(), and gradient analogs) will call those returning only one value (value(), vector_value(), and gradient analogs), while those ones will throw an exception when called but not overloaded.
*  Conversely, the functions returning all components of the function at one or several points (i.e. vector_value(), vector_value_list()), will  [2.x.0] not [2.x.1]  call the function returning one component at one point repeatedly, once for each point and component. The reason is efficiency: this would amount to too many virtual function calls. If you have vector- valued functions, you should therefore also provide overloads of the virtual functions for all components at a time.
*  Also note, that unless only called a very small number of times, you should overload all sets of functions (returning only one value, as well as those returning a whole array), since the cost of evaluation of a point value is often less than the virtual function call itself.
*  Support for time dependent functions can be found in the base class FunctionTime.
* 

*  [1.x.2]
*  If the functions you are dealing with have a number of components that are a priori known (for example, <tt>dim</tt> elements), you might consider using the TensorFunction class instead. This is, in particular, true if the objects you return have the properties of a tensor, i.e., they are for example dim-dimensional vectors or dim-by-dim matrices. On the other hand, functions like  [2.x.2]  or  [2.x.3]  definitely only want objects of the current type. You can use the VectorFunctionFromTensorFunction class to convert the former to the latter.
* 

*  [1.x.3]
*  Most of the time, your functions will have the form  [2.x.4] . However, there are occasions where you want the function to return vectors (or scalars) over a different number field, for example functions that return complex numbers or vectors of complex numbers:  [2.x.5] . In such cases, you can choose a value different than the default  [2.x.6]  for the second template argument of this class: it describes the scalar type to be used for each component of your return values. It defaults to  [2.x.7]  but in the example above, it could be set to  [2.x.8] .  [2.x.9]  is an example of this.
*   [2.x.10]  dim The space dimension of the range space within which the domain    [2.x.11]  of the function lies. Consequently, the function will be   evaluated at objects of type  [2.x.12]   [2.x.13]  RangeNumberType The scalar type of the vector space that is the range   (or image) of this function. As discussed above, objects of the current type represent functions from  [2.x.14]  to    [2.x.15]  where  [2.x.16]  is the underlying scalar type of   the vector space. The type of  [2.x.17]  is given by the  [2.x.18]  template   argument.
* 

* 
*  [2.x.19] 

* 
* [0.x.1]*
   Export the value of the template parameter as a static member constant.   Sometimes useful for some expression template programming.  
* [0.x.2]*
   Number of vector components.  
* [0.x.3]*
   The scalar-valued real type used for representing time.  
* [0.x.4]*
   Constructor. May take an initial value for the number of components   (which defaults to one, i.e. a scalar function), and the time variable,   which defaults to zero.  
* [0.x.5]*
   Copy constructor.  
* [0.x.6]*
   Virtual destructor; absolutely necessary in this case.     This destructor is declared pure virtual, such that objects of this class   cannot be created. Since all the other virtual functions have a pseudo-   implementation to avoid overhead in derived classes, they can not be   abstract. As a consequence, we could generate an object of this class   because none of this class's functions are abstract.     We circumvent this problem by making the destructor of this class   abstract virtual. This ensures that at least one member function is   abstract, and consequently, no objects of type Function can be created.   However, there is no need for derived classes to explicitly implement a   destructor: every class has a destructor, either explicitly implemented   or implicitly generated by the compiler, and this resolves the   abstractness of any derived class even if they do not have an explicitly   declared destructor.     Nonetheless, since derived classes want to call the destructor of a base   class, this destructor is implemented (despite it being pure virtual).  
* [0.x.7]*
   Assignment operator. This is here only so that you can have objects of   derived classes in containers, or assign them otherwise. It will raise an   exception if the object from which you assign has a different number of   components than the one being assigned to.  
* [0.x.8]*
   Return the value of the function at the given point. Unless there is only   one component (i.e. the function is scalar), you should state the   component you want to have evaluated; it defaults to zero, i.e. the first   component.  
* [0.x.9]*
   Return all components of a vector-valued function at a given point.     <tt>values</tt> shall have the right size beforehand, i.e. #n_components.     The default implementation will call value() for each component.  
* [0.x.10]*
   Set <tt>values</tt> to the point values of the specified component of the   function at the <tt>points</tt>.  It is assumed that <tt>values</tt>   already has the right size, i.e.  the same size as the <tt>points</tt>   array.     By default, this function repeatedly calls value() for each point   separately, to fill the output array.  
* [0.x.11]*
   Set <tt>values</tt> to the point values of the function at the   <tt>points</tt>.  It is assumed that <tt>values</tt> already has the   right size, i.e.  the same size as the <tt>points</tt> array, and that   all elements be vectors with the same number of components as this   function has.     By default, this function repeatedly calls vector_value() for each point   separately, to fill the output array.  
* [0.x.12]*
   For each component of the function, fill a vector of values, one for each   point.     The default implementation of this function in Function calls   value_list() for each component. In order to improve performance, this   can be reimplemented in derived classes to speed up performance.  
* [0.x.13]*
   Return the gradient of the specified component of the function at the   given point.  
* [0.x.14]*
   Return the gradient of all components of the function at the given point.  
* [0.x.15]*
   Set <tt>gradients</tt> to the gradients of the specified component of the   function at the <tt>points</tt>.  It is assumed that <tt>gradients</tt>   already has the right size, i.e.  the same size as the <tt>points</tt>   array.  
* [0.x.16]*
   For each component of the function, fill a vector of gradient values, one   for each point.     The default implementation of this function in Function calls   value_list() for each component. In order to improve performance, this   can be reimplemented in derived classes to speed up performance.  
* [0.x.17]*
   Set <tt>gradients</tt> to the gradients of the function at the   <tt>points</tt>, for all components. It is assumed that   <tt>gradients</tt> already has the right size, i.e. the same size as the   <tt>points</tt> array.     The outer loop over <tt>gradients</tt> is over the points in the list,   the inner loop over the different components of the function.  
* [0.x.18]*
   Compute the Laplacian of a given component at point <tt>p</tt>.  
* [0.x.19]*
   Compute the Laplacian of all components at point <tt>p</tt> and store   them in <tt>values</tt>.  
* [0.x.20]*
   Compute the Laplacian of one component at a set of points.  
* [0.x.21]*
   Compute the Laplacians of all components at a set of points.  
* [0.x.22]*
   Compute the Hessian of a given component at point <tt>p</tt>, that is the   gradient of the gradient of the function.  
* [0.x.23]*
   Compute the Hessian of all components at point <tt>p</tt> and store them   in <tt>values</tt>.  
* [0.x.24]*
   Compute the Hessian of one component at a set of points.  
* [0.x.25]*
   Compute the Hessians of all components at a set of points.  
* [0.x.26]*
   Return an estimate for the memory consumption, in bytes, of this object.     This function is virtual and can be overloaded by derived classes.  
* [0.x.27]*
   Provide a function which always returns the constant values handed to the   constructor.    
*  [2.x.20]   
* [0.x.28]*
     Constructor; set values of all components to the provided one. The     default number of components is one.    
* [0.x.29]*
     Constructor; takes an  [2.x.21]  object as an     argument. The number of components is determined by     <tt>values.size()</tt>.    
* [0.x.30]*
     Constructor; takes an <tt>Vector<RangeNumberType></tt> object as an     argument. The number of components is determined by     <tt>values.size()</tt>.    
* [0.x.31]*
     Constructor; uses whatever stores in [begin_ptr, begin_ptr+n_components)     to initialize a new object.    
* [0.x.32]*
     Store the constant function value vector.    
* [0.x.33]*
   Provide a function which always returns zero. Obviously, also the   derivatives of this function are zero. Also, it returns zero on all   components in case the function is not a scalar one, which can be obtained   by passing the constructor the appropriate number of components.     This function is of use when you want to implement homogeneous boundary   conditions, or zero initial conditions.    
*  [2.x.22]   
* [0.x.34]*
     Constructor. The number of components is preset to one.    
* [0.x.35]*
   A function whose output is also its input. One possible application of this   function is interpolating or projecting a finite element field that   represents spatial coordinates: e.g., one can set up a finite element field   to interpolate the positions of a Triangulation's cells with this function   (via  [2.x.23]  which is useful when doing calculations   in a Lagrangian reference frame.    
*  [2.x.24]   
* [0.x.36]*
     Constructor. The number of components is set to dim.    
* [0.x.37]*
      [2.x.25]   [2.x.26]     
* [0.x.38]*
      [2.x.27]   [2.x.28]     
* [0.x.39]*
      [2.x.29]   [2.x.30]     
* [0.x.40]*
      [2.x.31]   [2.x.32]     
* [0.x.41]*
 Provide a function which always returns the constant values handed to the constructor.
*   [2.x.33]  use  [2.x.34]  instead.

* 
* [0.x.42]*
 Provide a function which always returns zero.
*   [2.x.35]  use  [2.x.36]  instead.

* 
* [0.x.43]*
 This is a constant vector-valued function, in which one or more components of the vector have a constant value and all other components are zero.  It is especially useful as a weight function for  [2.x.37]  where it allows to integrate only one or a few vector components, rather than the entire vector-valued solution. In other words, it acts as a component mask with a single component selected (see the  [2.x.38]  "the glossary entry on component masks"). See the  [2.x.39]  tutorial program for a detailed explanation and a use case.
* 

* 
*  [2.x.40] 

* 
* [0.x.44]*
   Constructor if only a single component shall be non-zero. Arguments   denote the component selected, the value for that component and the total   number of vector components.  
* [0.x.45]*
   Constructor. As before, but the value for the selected component is   assumed to be one. In essence, this function then works as a mask.  
* [0.x.46]*
   Constructor if multiple components shall have non-zero, unit values (i.e.   this should be a mask for multiple components). The first argument   denotes a half-open interval of components (for example  [2.x.41]    for the first dim components), and the second argument is the total   number of vector components.  
* [0.x.47]*
   Substitute function value with value of a <tt>ConstantFunction [2.x.42]    RangeNumberType [2.x.43]  object and keep the current selection pattern.     This is useful if you want to have different values in different   components since the provided constructors of   <tt>ComponentSelectFunction [2.x.44]  RangeNumberType [2.x.45]  class can only   have same value for all components.    
*  [2.x.46]  We copy the underlying component value data from  [2.x.47]  from its   beginning. So the number of components of  [2.x.48]  cannot be less than the   calling object.  
* [0.x.48]*
   Return the value of the function at the given point for all components.  
* [0.x.49]*
   Set <tt>values</tt> to the point values of the function at the   <tt>points</tt>, for all components. It is assumed that <tt>values</tt>   already has the right size, i.e. the same size as the <tt>points</tt>   array.  
* [0.x.50]*
   Return an estimate for the memory consumption, in bytes, of this object.  
* [0.x.51]*
   Half-open interval of the indices of selected components.  
* [0.x.52]*
 This class provides a way to convert a scalar function of the kind

* 
* [1.x.4]
*  into an object of type Function [2.x.49]  Since the argument returns a scalar, the result is clearly a Function object for which  [2.x.50] . The class works by storing a pointer to the given function and every time  [2.x.51]  is called, calls  [2.x.52]  and returns the corresponding value. It also makes sure that  [2.x.53]  is in fact zero, as needs be for scalar functions.
*  The class provides an easy way to turn a simple global function into something that has the required Function [2.x.54]  interface for operations like  [2.x.55]  etc., and thereby allows for simpler experimenting without having to write all the boiler plate code of declaring a class that is derived from Function and implementing the  [2.x.56]  function. An example of this is given in the results section of  [2.x.57] .
*  The class gains additional expressive power because the argument it takes does not have to be a pointer to an actual function. Rather, it is a function object, i.e., it can also be the result of a lambda function or some other object that can be called with a single argument. For example, if you need a Function object that returns the norm of a point, you could write it like so:

* 
* [1.x.5]
*  and then pass the  [2.x.58]  around, or you could write it like so:

* 
* [1.x.6]
* 
*  Similarly, to generate an object that computes the distance to a point  [2.x.59] , we could do this:

* 
* [1.x.7]
*  or we could write it like so:

* 
* [1.x.8]
*  The savings in work to write this are apparent.
* 

* 
*  [2.x.60] 

* 
* [0.x.53]*
   Given a function object that takes a Point and returns a RangeNumberType   value, convert this into an object that matches the Function<dim,   RangeNumberType> interface.  
* [0.x.54]*
   Return the value of the function at the given point. Returns the value   the function given to the constructor produces for this point.  
* [0.x.55]*
   The function object which we call when this class's value() or   value_list() functions are called.  
* [0.x.56]*
 This class is similar to the ScalarFunctionFromFunctionObject class in that it allows for the easy conversion of a function object to something that satisfies the interface of the Function base class. The difference is that here, the given function object is still a scalar function (i.e. it has a single value at each space point) but that the Function object generated is vector valued. The number of vector components is specified in the constructor, where one also selects a single one of these vector components that should be filled by the passed object. The result is a vector Function object that returns zero in each component except the single selected one where it returns the value returned by the given as the first argument to the constructor.
* 

* 
*  [2.x.61]  In the above discussion, note the difference between the (scalar) "function object" (i.e., a C++ object  [2.x.62]  that can be called as in  [2.x.63] ) and the capitalized (vector valued) "Function object" (i.e., an object of a class that is derived from the Function base class).
*  To be more concrete, let us consider the following example:

* 
* [1.x.9]
*  Here,  [2.x.64]  then represents a Function object that for every point returns the vector  [2.x.65] , i.e. a mask function that could, for example, be passed to  [2.x.66]  This effect can also be achieved using the ComponentSelectFunction class but is obviously easily extended to functions that are non-constant in their one component.
* 

* 
*  [2.x.67] 

* 
* [0.x.57]*
   Given a function object that takes a Point and returns a RangeNumberType   value, convert this into an object that matches the Function [2.x.68]    interface.      [2.x.69]  function_object The scalar function that will form one component   of the resulting Function object.    [2.x.70]  n_components The total number of vector components of the   resulting Function object.    [2.x.71]  selected_component The single component that should be filled by   the first argument.  
* [0.x.58]*
   Return the value of the function at the given point. Returns the value   the function given to the constructor produces for this point.  
* [0.x.59]*
   Return all components of a vector-valued function at a given point.     <tt>values</tt> shall have the right size beforehand, i.e. #n_components.  
* [0.x.60]*
   The function object which we call when this class's value() or   value_list() functions are called.  
* [0.x.61]*
   The vector component whose value is to be filled by the given scalar   function.  
* [0.x.62]*
 This class is similar to the ScalarFunctionFromFunctionObject and VectorFunctionFromFunctionObject classes in that it allows for the easy conversion of a vector of function objects to something that satisfies the interface of the Function base class.
*  The difference is that here the Function object generated may be vector valued, and you can specify the gradients of the function. The number of vector components is deduced from the size of the vector in the constructor.
*  To be more concrete, let us consider the following example:
* 

* 
* [1.x.10]
* 

* 
* [0.x.63]*
   Default constructor.     This constructor does not initialize the internal methods. To have a   usable function, you need to call at least the set_function_values()   method. If you need also the gradients of the solution, then you must   also call the set_function_gradients() method.  
* [0.x.64]*
   Constructor for functions of which you only know the values.     The resulting function will have a number of components equal to the size   of the vector  [2.x.72]  A call to the  [2.x.73]    method will trigger an exception, unless you first call the   set_function_gradients() method.  
* [0.x.65]*
   Constructor for functions of which you know both the values and the   gradients.     The resulting function will have a number of components equal to the size   of the vector  [2.x.74]  If the size of  [2.x.75]  and  [2.x.76]  does not   match, an exception is triggered.  
* [0.x.66]*
   Return the value of the function at the given point. Unless there is only   one component (i.e. the function is scalar), you should state the   component you want to have evaluated; it defaults to zero, i.e. the first   component.  
* [0.x.67]*
   Return the gradient of the function at the given point. Unless there is   only one component (i.e. the function is scalar), you should state the   component you want to have evaluated; it defaults to zero, i.e. the first   component.  
* [0.x.68]*
   Reset the function values of this object. An assertion is thrown if the   size of the  [2.x.77]  parameter does not match the number of components of   this object.  
* [0.x.69]*
   Reset the function gradients of this object. An assertion is thrown if the   size of the  [2.x.78]  parameter does not match the number of components of   this object.  
* [0.x.70]*
   The actual function values.  
* [0.x.71]*
   The actual function gradients.  
* [0.x.72]*
 This class is built as a means of translating the <code>Tensor<1,dim, RangeNumberType> </code> values produced by objects of type TensorFunction and returning them as a multiple component version of the same thing as a Vector for use in, for example, the  [2.x.79]  or the many other functions taking Function objects. It allows the user to place the desired components into an <tt>n_components</tt> long vector starting at the <tt>selected_component</tt> location in that vector and have all other components be 0.
*  For example: Say you created a class called

* 
* [1.x.11]
*  which extends the TensorFunction class and you have an object

* 
* [1.x.12]
*  of that class which you want to interpolate onto your mesh using the  [2.x.80]  function, but the finite element you use for the DoFHandler object has 3 copies of a finite element with <tt>dim</tt> components, for a total of 3*dim components. To interpolate onto that DoFHandler, you need an object of type Function that has 3*dim vector components. Creating such an object from the existing  [2.x.81]  object is done using this piece of code:

* 
* [1.x.13]
*  where the  [2.x.82]  components of the tensor function are placed into the first  [2.x.83]  components of the function object.
* 

* 
*  [2.x.84] 

* 
* [0.x.73]*
   Given a TensorFunction object that takes a <tt>Point</tt> and returns a   <tt>Tensor<1,dim, RangeNumberType></tt> value, convert this into an object   that matches the Function [2.x.85]  interface.     By default, create a Vector object of the same size as   <tt>tensor_function</tt> returns, i.e., with <tt>dim</tt> components.      [2.x.86]  tensor_function The TensorFunction that will form one component of   the resulting Vector Function object.    [2.x.87]  n_components The total number of vector components of the   resulting TensorFunction object.    [2.x.88]  selected_component The first component that should be filled by   the first argument.  This should be such that the entire tensor_function   fits inside the <tt>n_component</tt> length return vector.  
* [0.x.74]*
   This destructor is defined as virtual so as to coincide with all other   aspects of class.  
* [0.x.75]*
   Return a single component of a vector-valued function at a given point.  
* [0.x.76]*
   Return all components of a vector-valued function at a given point.     <tt>values</tt> shall have the right size beforehand, i.e. #n_components.  
* [0.x.77]*
   Return all components of a vector-valued function at a list of points.     <tt>value_list</tt> shall be the same size as <tt>points</tt> and each   element of the vector will be passed to vector_value() to evaluate the   function  
* [0.x.78]*
   The TensorFunction object which we call when this class's vector_value()   or vector_value_list() functions are called.  
* [0.x.79]*
   The first vector component whose value is to be filled by the given   TensorFunction.  The values will be placed in components   selected_component to selected_component+dim-1 for a   <tt>TensorFunction<1,dim, RangeNumberType></tt> object.  
* [0.x.80]

include/deal.II-translator/base/function_bessel_0.txt
[0.x.0]*
   The Bessel functions of first kind or positive integer order.    
*  [2.x.0]   
* [0.x.1]*
     Constructor.  [2.x.1]  must be nonnegative.    
* [0.x.2]

include/deal.II-translator/base/function_cspline_0.txt
[0.x.0]*
   The cubic spline function using GNU Scientific Library.   The resulting curve is piecewise cubic on each interval, with matching   first and second derivatives at the supplied data-points. The second   derivative is chosen to be zero at the first point and last point.    
*  [2.x.0]  This function is only implemented for dim==1 .    
*  [2.x.1]   
* [0.x.1]*
     Constructor which should be provided with a set of points at which     interpolation is to be done  [2.x.2]  and a set of function     values  [2.x.3]  .    
* [0.x.2]*
     Return an estimate for the memory consumption, in bytes, of this object.    
* [0.x.3]*
     Points at which interpolation is provided    
* [0.x.4]*
     Values of the function at interpolation points    
* [0.x.5]*
     GSL accelerator for spline interpolation    
* [0.x.6]*
     GSL cubic spline interpolator    
* [0.x.7]*
     A mutex for accelerator object.    
* [0.x.8]

include/deal.II-translator/base/function_derivative_0.txt
[0.x.0]*
 Derivative of a function object.  The value access functions of this class return the directional derivative of a function with respect to a direction provided on construction. If <tt>b</tt> is the vector, the derivative <tt>b . grad f</tt> is computed. This derivative is evaluated directly, not by computing the gradient of <tt>f</tt> and its scalar product with <tt>b</tt>.
*  The derivative is computed numerically, using one of the provided difference formulas (see <tt>set_formula</tt> for available schemes). Experimenting with <tt>h</tt> and the difference scheme may be necessary to obtain sufficient results.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Constructor. Provided are the functions to compute derivatives of, the   direction vector of the differentiation and the step size <tt>h</tt> of   the difference formula.  
* [0.x.2]*
   Constructor. Provided are the functions to compute derivatives of and the   direction vector of the differentiation in each quadrature point and the   difference step size.     This is the constructor for a variable velocity field. Most probably, a   new object of <tt>FunctionDerivative</tt> has to be constructed for each   set of quadrature points.     The number of quadrature point must still be the same, when values are   accessed.  
* [0.x.3]*
   Choose the difference formula. This is set to the default in the   constructor.     Formulas implemented right now are first order backward Euler   (<tt>UpwindEuler</tt>), second order symmetric Euler (<tt>Euler</tt>) and   a symmetric fourth order formula (<tt>FourthOrder</tt>).  
* [0.x.4]*
   Change the base step size of the difference formula  
* [0.x.5]*
   Return an estimate for the memory consumption, in bytes, of this object.   This is not exact (but will usually be close) because calculating the   memory usage of trees (e.g.,  [2.x.1]  is difficult.  
* [0.x.6]*
   Function for differentiation.  
* [0.x.7]*
   Step size of the difference formula.  
* [0.x.8]*
   Difference formula.  
* [0.x.9]*
   Helper object. Contains the increment vector for the formula.  
* [0.x.10]

include/deal.II-translator/base/function_level_set_0.txt
[0.x.0]*
     Signed-distance level set function of a sphere:      [2.x.0] .     Here,  [2.x.1]  is the center of the sphere and  [2.x.2]  is its radius. This     function is thus zero on the sphere, negative "inside" the ball having     the sphere as its boundary, and positive in the rest of      [2.x.3] .         This function has gradient and Hessian equal to      [2.x.4] ,      [2.x.5] ,     where  [2.x.6]  is the Kronecker delta function.        
*  [2.x.7]     
* [0.x.1]*
       Constructor, takes the center and radius of the sphere.      
* [0.x.2]*
        [2.x.8]   [2.x.9]             
*  [2.x.10]  The gradient is singular at the center of the sphere. If the       incoming  [2.x.11]  is too close to the center, a floating-point       exception may be thrown or entries in the gradient may be +inf/-inf       or +nan/-nan, depending on how the point is located relative to the       singularity.      
* [0.x.3]*
        [2.x.12]   [2.x.13]             
*  [2.x.14]  The Hessian is singular at the center of the sphere. If the       incoming  [2.x.15]  is too close to the center, a floating-point       exception may be thrown or entries in the Hessian may be +inf/-inf       or +nan/-nan, depending on how the point is located relative to the       singularity.      
* [0.x.4]*
     Signed level set function of a plane in  [2.x.16] :      [2.x.17] .     Here,  [2.x.18]  is the plane normal and  [2.x.19]  is a point in the plane.     Thus, with respect to the direction of the normal, this function is     positive above the plane, zero in the plane, and negative below the     plane. If the normal is normalized,  [2.x.20]  will be the signed distance to     the closest point in the plane.        
*  [2.x.21]     
* [0.x.5]*
       Constructor, takes a point in the plane and the plane normal.      
* [0.x.6]

include/deal.II-translator/base/function_lib_0.txt
[0.x.0]*
 Namespace implementing some concrete classes derived from the Function class that describe actual functions. This is rather a collection of classes that we have needed for our own programs once and thought might be useful to others as well at some point.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   The distance to the origin squared.     This function returns the square norm of the radius vector of a point.     Together with the function, its derivatives and Laplacian are defined.    
*  [2.x.1]   
* [0.x.2]*
   The function <tt>xy</tt> in 2d and 3d, not implemented in 1d. This   function serves as an example for a vanishing Laplacian.    
*  [2.x.2]   
* [0.x.3]*
     Laplacian of the function at one point.    
* [0.x.4]*
     Laplacian of the function at multiple points.    
* [0.x.5]*
   d-quadratic pillow on the unit hypercube.     This is a function for testing the implementation. It has zero Dirichlet   boundary values on the domain  [2.x.3] . In the inside, it is the   product of  [2.x.4]  over all space dimensions.     Providing a non-zero argument to the constructor, the whole function can   be offset by a constant.     Together with the function, its derivatives and Laplacian are defined.    
*  [2.x.5]   
* [0.x.6]*
     Constructor. Provide a constant that will be added to each function     value.    
* [0.x.7]*
     The value at a single point.    
* [0.x.8]*
     Values at multiple points.    
* [0.x.9]*
     Gradient at a single point.    
* [0.x.10]*
     Gradients at multiple points.    
* [0.x.11]*
     Laplacian at a single point.    
* [0.x.12]*
     Laplacian at multiple points.    
* [0.x.13]*
   Cosine-shaped pillow function. This is another function with zero   boundary values on  [2.x.6] . In the interior it is the product of    [2.x.7] .    
*  [2.x.8]   
* [0.x.14]*
     Constructor which allows to optionally generate a vector valued cosine     function with the same value in each component.    
* [0.x.15]*
     Second derivatives at a single point.    
* [0.x.16]*
     Second derivatives at multiple points.    
* [0.x.17]*
   Gradient of the cosine-shaped pillow function.     This is a vector-valued function with  [2.x.9]  components, the gradient of   CosineFunction. On the square [-1,1], it has tangential boundary   conditions zero. Thus, it can be used to test implementations of Maxwell   operators without bothering about boundary terms.    
*  [2.x.10]   
* [0.x.18]*
     Constructor, creating a function with  [2.x.11]  components.    
* [0.x.19]*
   Product of exponential functions in each coordinate direction.    
*  [2.x.12]   
* [0.x.20]*
     The value at a single point.    
* [0.x.21]*
     Values at multiple points.    
* [0.x.22]*
     Gradient at a single point.    
* [0.x.23]*
     Gradients at multiple points.    
* [0.x.24]*
     Laplacian at a single point.    
* [0.x.25]*
     Laplacian at multiple points.    
* [0.x.26]*
   A function that solves the Laplace equation (with specific   boundary values but zero right hand side) and that has a   singularity at the center of the L-shaped domain in 2D (i.e.,   at the location of the re-entrant corner of this non-convex   domain).     The function is given in polar coordinates by  [2.x.13]  with a singularity at the origin and   should be used with  [2.x.14]  Here,  [2.x.15]  is   defined as theclockwise* angle against the positive  [2.x.16] -axis.     This function is often used to illustrate that the solutions of the Laplace   equation   [1.x.0]   can be singular even if the boundary values are smooth. (Here, if the   domain is the L-shaped domain  [2.x.17] , the   boundary values for  [2.x.18]  are zero on the two line segments adjacent to the   origin, and equal to  [2.x.19]  on the   remaining parts of the boundary.) The function itself remains bounded on   the domain, but its gradient is of the form  [2.x.20]  in the vicinity of   the origin and consequently diverges as one approaches the origin.    
*  [2.x.21]   
* [0.x.27]*
   Gradient of the harmonic singularity on the L-shaped domain in 2D.     The gradient of LSingularityFunction, which is a vector valued function   with vanishing curl and divergence.    
*  [2.x.22]   
* [0.x.28]*
     Default constructor setting the dimension to 2.    
* [0.x.29]*
   Singularity on the slit domain in 2D and 3D.    
*  [2.x.23]   
* [0.x.30]*
   Singularity on the slit domain with one Neumann boundary in 2D.    
*  [2.x.24]   
* [0.x.31]*
   A jump in x-direction transported into some direction.     If the advection is parallel to the y-axis, the function is   <tt>-atan(sx)</tt>, where <tt>s</tt> is the steepness parameter provided   in the constructor.     For different advection directions, this function will be turned in the   parameter space.     Together with the function, its derivatives and Laplacian are defined.    
*  [2.x.25]   
* [0.x.32]*
     Constructor. Provide the advection direction here and the steepness of     the slope.    
* [0.x.33]*
     Function value at one point.    
* [0.x.34]*
     Function values at multiple points.    
* [0.x.35]*
     Gradient at one point.    
* [0.x.36]*
     Gradients at multiple points.    
* [0.x.37]*
     Laplacian of the function at one point.    
* [0.x.38]*
     Laplacian of the function at multiple points.    
* [0.x.39]*
     Return an estimate for the memory consumption, in bytes, of this     object. This is not exact (but will usually be close) because     calculating the memory usage of trees (e.g.,  [2.x.26]  is     difficult.    
* [0.x.40]*
     Advection vector.    
* [0.x.41]*
     Steepness (maximal derivative) of the slope.    
* [0.x.42]*
     Advection angle.    
* [0.x.43]*
     Sine of <tt>angle</tt>.    
* [0.x.44]*
     Cosine of <tt>angle</tt>.    
* [0.x.45]*
   Given a wavenumber vector generate a cosine function. The wavenumber   coefficient is given as a  [2.x.27] -dimensional point  [2.x.28]  in Fourier space, and   the function is then recovered as  [2.x.29] .     The class has its name from the fact that it resembles one component of a   Fourier cosine decomposition.    
*  [2.x.30]   
* [0.x.46]*
     Constructor. Take the Fourier coefficients in each space direction as     argument.    
* [0.x.47]*
     Return the value of the function at the given point. Unless there is     only one component (i.e. the function is scalar), you should state the     component you want to have evaluated; it defaults to zero, i.e. the     first component.    
* [0.x.48]*
     Return the gradient of the specified component of the function at the     given point.    
* [0.x.49]*
     Compute the Laplacian of a given component at point <tt>p</tt>.    
* [0.x.50]*
     Stored Fourier coefficients.    
* [0.x.51]*
   Given a wavenumber vector generate a sine function. The wavenumber   coefficient is given as a  [2.x.31] -dimensional point  [2.x.32]  in Fourier space, and   the function is then recovered as  [2.x.33] .     The class has its name from the fact that it resembles one component of a   Fourier sine decomposition.    
*  [2.x.34]   
* [0.x.52]*
     Constructor. Take the Fourier coefficients in each space direction as     argument.    
* [0.x.53]*
     Return the value of the function at the given point. Unless there is     only one component (i.e. the function is scalar), you should state the     component you want to have evaluated; it defaults to zero, i.e. the     first component.    
* [0.x.54]*
     Return the gradient of the specified component of the function at the     given point.    
* [0.x.55]*
     Compute the Laplacian of a given component at point <tt>p</tt>.    
* [0.x.56]*
     Stored Fourier coefficients.    
* [0.x.57]*
   Given a sequence of wavenumber vectors and weights generate a sum of sine   functions. Each wavenumber coefficient is given as a  [2.x.35] -dimensional   point  [2.x.36]  in Fourier space, and the entire function is then recovered as    [2.x.37] .    
*  [2.x.38]   
* [0.x.58]*
     Constructor. Take the Fourier coefficients in each space direction as     argument.    
* [0.x.59]*
     Return the value of the function at the given point. Unless there is     only one component (i.e. the function is scalar), you should state the     component you want to have evaluated; it defaults to zero, i.e. the     first component.    
* [0.x.60]*
     Return the gradient of the specified component of the function at the     given point.    
* [0.x.61]*
     Compute the Laplacian of a given component at point <tt>p</tt>.    
* [0.x.62]*
     Stored Fourier coefficients and weights.    
* [0.x.63]*
   Given a sequence of wavenumber vectors and weights generate a sum of   cosine functions. Each wavenumber coefficient is given as a    [2.x.39] -dimensional point  [2.x.40]  in Fourier space, and the entire function is   then recovered as  [2.x.41] .    
*  [2.x.42]   
* [0.x.64]*
     Constructor. Take the Fourier coefficients in each space direction as     argument.    
* [0.x.65]*
     Return the value of the function at the given point. Unless there is     only one component (i.e. the function is scalar), you should state the     component you want to have evaluated; it defaults to zero, i.e. the     first component.    
* [0.x.66]*
     Return the gradient of the specified component of the function at the     given point.    
* [0.x.67]*
     Compute the Laplacian of a given component at point <tt>p</tt>.    
* [0.x.68]*
     Stored Fourier coefficients and weights.    
* [0.x.69]*
   Base function for cut-off function. This class stores the center and the   radius of the supporting ball of a cut-off function. It also stores the   number of the non-zero component, if the function is vector-valued.     This class can also be used for approximated Dirac delta functions. These   are special cut-off functions whose integral is always equal to one,   independently of the radius of the supporting ball.    
*  [2.x.43]   
* [0.x.70]*
     Value used in the constructor of this and derived classes to denote     that no component is selected.    
* [0.x.71]*
     Constructor.          [2.x.44]  radius Radius of the ball      [2.x.45]  center Center of the ball      [2.x.46]  n_components Number of components of this function object      [2.x.47]  select If this is different from      [2.x.48]  then the function will be non-zero     for this component only      [2.x.49]  integrate_to_one Rescale the value of the function whenever a     new radius is set, to guarantee that the integral is equal to one      [2.x.50]  unitary_integral_value Value of the integral when the radius     is equal to 1.0. Derived classes will need to supply this value, to     guarantee that the rescaling is performed correctly.    
* [0.x.72]*
     Virtual destructor.    
* [0.x.73]*
     Set the center of the ball to the point  [2.x.51]     
* [0.x.74]*
     Set the radius of the ball to  [2.x.52]     
* [0.x.75]*
     Return the center stored in this object.    
* [0.x.76]*
     Return the radius stored in this object.    
* [0.x.77]*
     Return a boolean indicating whether this function integrates to one.    
* [0.x.78]*
     Center of the integration ball.    
* [0.x.79]*
     Radius of the ball.    
* [0.x.80]*
     Component selected. If <tt>no_component</tt>, the function is the same     in all components.    
* [0.x.81]*
     Flag that controls whether we rescale the value when the radius changes.    
* [0.x.82]*
     The reference integral value. Derived classes should specify what their     integral is when  [2.x.53]  = 1.0.    
* [0.x.83]*
     Current rescaling to apply the cut-off function.    
* [0.x.84]*
   Tensor product of CutOffFunctionBase objects.     Instead of using the distance to compute the cut-off function, this class   performs a tensor product of the same CutOffFunctionBase object in each   coordinate direction.    
*  [2.x.54]   
* [0.x.85]*
     Construct an empty CutOffFunctionTensorProduct object.         Before you can use this class, you have to call the set_base() method     with a class derived from the CutOffFunctionBase object.         If you try to use this class before you call the set_base() method,     and exception will be triggered.    
* [0.x.86]*
     Initialize the class with an object of type      [2.x.55]  CutOffFunctionBaseType<1>.    
* [0.x.87]*
     Set the new center.    
* [0.x.88]*
     Set the new radius.    
* [0.x.89]*
     Function value at one point.    
* [0.x.90]*
     Function gradient at one point.    
* [0.x.91]*
   Cut-off function in L-infinity for an arbitrary ball.  This function is   the characteristic function of a ball around <tt>center</tt> with a   specified <tt>radius</tt>, that is, [1.x.1] If vector   valued, it can be restricted to a single component.    
*  [2.x.56]   
* [0.x.92]*
     Constructor. Arguments are the center of the ball and its radius.         If an argument <tt>select</tt> is given and not
* 
*  - , the cut-off     function will be non-zero for this component only.    
* [0.x.93]*
     Function value at one point.    
* [0.x.94]*
     Function values at multiple points.    
* [0.x.95]*
     Function values at multiple points.    
* [0.x.96]*
   Cut-off function for an arbitrary ball. This function is a cone with   support in a ball of certain <tt>radius</tt> around <tt>center</tt>. The   maximum value is 1. If vector valued, it can be restricted to a single   component.    
*  [2.x.57]   
* [0.x.97]*
     Constructor. Arguments are the center of the ball and its radius.         If an argument <tt>select</tt> is given, the cut-off function will be     non-zero for this component only.    
* [0.x.98]*
     Function value at one point.    
* [0.x.99]*
     Function values at multiple points.    
* [0.x.100]*
     Function values at multiple points.    
* [0.x.101]*
   A cut-off function for an arbitrarily-sized ball that is in the space  [2.x.58]    (i.e., continuously differentiable). This is a cut-off function that is   often used in the literature of the Immersed Boundary Method.     The expression of the function in radial coordinates is given by    [2.x.59]  where  [2.x.60]  is the distance to the center, and    [2.x.61]  is the radius of the sphere. If vector valued, it can be restricted to   a single component.    
*  [2.x.62]   
* [0.x.102]*
     Constructor.    
* [0.x.103]*
     Function value at one point.    
* [0.x.104]*
     Function values at multiple points.    
* [0.x.105]*
     Function values at multiple points.    
* [0.x.106]*
     Function gradient at one point.    
* [0.x.107]*
   Cut-off function for an arbitrary ball. This is the traditional cut-off   function in C-infinity for a ball of certain <tt>radius</tt> around   <tt>center</tt>,  [2.x.63] , where  [2.x.64]  is the distance   to the center, and  [2.x.65]  is the radius of the sphere. If vector valued, it   can be restricted to a single component.    
*  [2.x.66]   
* [0.x.108]*
     Constructor. Arguments are the center of the ball and its radius.         If an argument <tt>select</tt> is given, the cut-off function will be     non-zero for this component only.    
* [0.x.109]*
     Function value at one point.    
* [0.x.110]*
     Function values at multiple points.    
* [0.x.111]*
     Function values at multiple points.    
* [0.x.112]*
     Function gradient at one point.    
* [0.x.113]*
   A class that represents a function object for a monomial. Monomials are   polynomials with only a single term, i.e. in 1-d they have the form    [2.x.67] , in 2-d the form  [2.x.68] , and in 3-d    [2.x.69] . Monomials are therefore   described by a  [2.x.70] -tuple of exponents. Consequently, the class's   constructor takes a Tensor<1,dim> to describe the set of exponents. Most   of the time these exponents will of course be integers, but real   exponents are of course equally valid. Exponents can't be real when the   bases are negative numbers.    
*  [2.x.71]   
* [0.x.114]*
     Constructor. The first argument is explained in the general description     of the class. The second argument denotes the number of vector     components this object shall represent. All vector components will have     the same value.    
* [0.x.115]*
     Function value at one point.    
* [0.x.116]*
     Return all components of a vector-valued function at a given point.         <tt>values</tt> shall have the right size beforehand, i.e.     #n_components.    
* [0.x.117]*
     Function values at multiple points.    
* [0.x.118]*
     Function gradient at one point.    
* [0.x.119]*
     The set of exponents.    
* [0.x.120]*
   A scalar function that computes its values by (bi-, tri-)linear   interpolation from a set of point data that are arranged on a possibly   non-uniform tensor product mesh. In other words, considering the three-   dimensional case, let there be points  [2.x.72] ,    [2.x.73] ,  [2.x.74] , and data  [2.x.75]  defined at   point  [2.x.76] , then evaluating the function at a point  [2.x.77]  will find the box so that  [2.x.78] , and do a trilinear interpolation of the   data on this cell. Similar operations are done in lower dimensions.     This class is most often used for either evaluating coefficients or right   hand sides that are provided experimentally at a number of points inside   the domain, or for comparing outputs of a solution on a finite element   mesh against previously obtained data defined on a grid.    
*  [2.x.79]  If the points  [2.x.80]  are actually equally spaced on an interval    [2.x.81]  and the same is true for the other data points in higher   dimensions, you should use the InterpolatedUniformGridData class instead.     If a point is requested outside the box defined by the end points of the   coordinate arrays, then the function is assumed to simply extend by   constant values beyond the last data point in each coordinate direction.   (The class does not throw an error if a point lies outside the box since   it frequently happens that a point lies just outside the box by an amount   on the order of numerical roundoff.)    
*  [2.x.82]  The use of the related class InterpolatedUniformGridData is   discussed in  [2.x.83] .       [1.x.2]     This class is often used to interpolate data provided by fairly   large data tables that are expensive to read from disk, and that take   a large amount of memory when replicated on every process of parallel   (MPI) programs.     The Table class can help with amortizing this cost by using   shared memory to store the data only as often as necessary
* 
*  -  see the   documentation of the TableBase class. Once one has obtained such a   Table object that uses shared memory to store the data only as often   as is necessary, one has to avoid that the current classcopies*
   the table into its own member variable. Rather, it is necessary to   use themove* constructor of this class to take over ownership of   the table and its shared memory space. This can be achieved using   the following extension of the code snippet shown in the   documentation of the TableBase class:  
* [1.x.3]
*       
*  [2.x.84]   
* [0.x.121]*
     Constructor to initialize this class instance with the data given in  [2.x.85]      data_values.          [2.x.86]  coordinate_values An array of dim arrays. Each of the inner     arrays contains the coordinate values  [2.x.87]  and     similarly for the other coordinate directions. These arrays need not     have the same size. Obviously, we need dim such arrays for a dim-     dimensional function object. The coordinate values within this array     are assumed to be strictly ascending to allow for efficient lookup.          [2.x.88]  data_values A dim-dimensional table of data at each of the mesh     points defined by the coordinate arrays above. The data passed in is     copied into internal data structures. Note that the Table     class has a number of conversion constructors that allow converting     other data types into a table where you specify this argument.    
* [0.x.122]*
     Like the previous constructor, but take the arguments as rvalue     references andmove*, instead ofcopy* the data. This is often useful     in cases where the data stored in these tables is large and the     information used to initialize the current object is no longer needed     separately. In other words, there is no need to keep the original object     from which this object could copy its information, but it might as well     take over ("move") the data.    
* [0.x.123]*
     Compute the value of the function set by bilinear interpolation of the     given data set.          [2.x.89]  p The point at which the function is to be evaluated.      [2.x.90]  component The vector component. Since this function is scalar,     only zero is a valid argument here.      [2.x.91]  The interpolated value at this point. If the point lies outside     the set of coordinates, the function is extended by a constant.    
* [0.x.124]*
     Compute the gradient of the function defined by bilinear interpolation     of the given data set.          [2.x.92]  p The point at which the function gradient is to be evaluated.      [2.x.93]  component The vector component. Since this function is scalar,     only zero is a valid argument here.      [2.x.94]  The value of the gradient of the interpolated function at this     point. If the point lies outside the set of coordinates, the function     is extended by a constant and so its gradient is extended by 0.    
* [0.x.125]*
     Return an estimate for the memory consumption, in bytes, of this object.    
* [0.x.126]*
     Return a reference to the internally stored data.    
* [0.x.127]*
     Find the index in the table of the rectangle containing an input point    
* [0.x.128]*
     The set of coordinate values in each of the coordinate directions.    
* [0.x.129]*
     The data that is to be interpolated.    
* [0.x.130]*
   A scalar function that computes its values by (bi-, tri-)linear   interpolation from a set of point data that are arranged on a uniformly   spaced tensor product mesh. In other words, considering the three-   dimensional case, let there be points  [2.x.95]  that result   from a uniform subdivision of the interval  [2.x.96]  into  [2.x.97]    sub-intervals of size  [2.x.98] , and similarly    [2.x.99] ,  [2.x.100] . Also consider data  [2.x.101]    defined at point  [2.x.102] , then evaluating the function at a   point  [2.x.103]  will find the box so that  [2.x.104] , and do a trilinear   interpolation of the data on this cell. Similar operations are done in   lower dimensions.     This class is most often used for either evaluating coefficients or right   hand sides that are provided experimentally at a number of points inside   the domain, or for comparing outputs of a solution on a finite element   mesh against previously obtained data defined on a grid.    
*  [2.x.105]  If you have a problem where the points  [2.x.106]  are not equally spaced   (e.g., they result from a computation on a graded mesh that is denser   closer to one boundary), then use the InterpolatedTensorProductGridData   class instead.     If a point is requested outside the box defined by the end points of the   coordinate arrays, then the function is assumed to simply extend by   constant values beyond the last data point in each coordinate direction.   (The class does not throw an error if a point lies outside the box since   it frequently happens that a point lies just outside the box by an amount   on the order of numerical roundoff.)    
*  [2.x.107]  The use of this class is discussed in  [2.x.108] .       [1.x.4]     This class supports the same facilities for dealing with large data sets   as the InterpolatedTensorProductGridData class. See there for more   information and example codes.      
*  [2.x.109]   
* [0.x.131]*
     Constructor      [2.x.110]  interval_endpoints The left and right end points of the     (uniformly subdivided) intervals in each of the coordinate directions.      [2.x.111]  n_subintervals The number of subintervals in each coordinate     direction. A value of one for a coordinate means that the interval is     considered as one subinterval consisting of the entire range. A value     of two means that there are two subintervals each with one half of the     range, etc.      [2.x.112]  data_values A dim-dimensional table of data at each of the mesh     points defined by the coordinate arrays above. Note that the Table     class has a number of conversion constructors that allow converting     other data types into a table where you specify this argument.    
* [0.x.132]*
     Like the previous constructor, but take the arguments as rvalue     references andmove*, instead ofcopy* the data. This is often useful     in cases where the data stored in these tables is large and the     information used to initialize the current object is no longer needed     separately. In other words, there is no need to keep the original object     from which this object could copy its information, but it might as well     take over ("move") the data.    
* [0.x.133]*
     Compute the value of the function set by bilinear interpolation of the     given data set.          [2.x.113]  p The point at which the function is to be evaluated.      [2.x.114]  component The vector component. Since this function is scalar,     only zero is a valid argument here.      [2.x.115]  The interpolated value at this point. If the point lies outside     the set of coordinates, the function is extended by a constant.    
* [0.x.134]*
     Compute the gradient of the function set by bilinear interpolation of the     given data set.          [2.x.116]  p The point at which the function is to be evaluated.      [2.x.117]  component The vector component. Since this function is scalar,       only zero is a valid argument here.      [2.x.118]  The gradient of the interpolated function at this point. If the       point lies outside the set of coordinates, the function is extended       by a constant whose gradient is then of course zero.    
* [0.x.135]*
     Return an estimate for the memory consumption, in bytes, of this object.    
* [0.x.136]*
     Return a reference to the internally stored data.    
* [0.x.137]*
     The set of interval endpoints in each of the coordinate directions.    
* [0.x.138]*
     The number of subintervals in each of the coordinate directions.    
* [0.x.139]*
     The data that is to be interpolated.    
* [0.x.140]*
   A class that represents a function object for a polynomial. A polynomial   is composed by the summation of multiple monomials. If the polynomial has   n monomials and the dimension is equal to dim, the polynomial can be   written as  [2.x.119] , where  [2.x.120]  are the coefficients of the   monomials and  [2.x.121]  are their exponents. The class's constructor   takes a Table<2,double> to describe the set of exponents and a   Vector<double> to describe the set of coefficients.    
*  [2.x.122]   
* [0.x.141]*
     Constructor. The coefficients and the exponents of the polynomial are     passed as arguments. The Table<2, double> exponents has a number of     rows equal to the number of monomials of the polynomial and a number of     columns equal to dim. The i-th row of the exponents table contains the      [2.x.123]  exponents of the i-th monomial  [2.x.124] . The i-th element of the coefficients vector     contains the coefficient  [2.x.125]  for the i-th monomial.    
* [0.x.142]*
     Function value at one point.    
* [0.x.143]*
     Function values at multiple points.    
* [0.x.144]*
     Function gradient at one point.    
* [0.x.145]*
     Return an estimate for the memory consumption, in bytes, of this object.    
* [0.x.146]*
     The set of exponents.    
* [0.x.147]*
     The set of coefficients.    
* [0.x.148]

include/deal.II-translator/base/function_parser_0.txt
[0.x.0]*
 This class implements a function object that gets its value by parsing a string describing this function. It is a wrapper class for the muparser library (see https://beltoforion.de/en/muparser/). This class lets you evaluate strings such as "sqrt(1-x^2+y^2)" for given values of 'x' and 'y'. Please refer to the muparser documentation for more information.  This class is used in the  [2.x.0]  and  [2.x.1]  tutorial programs (the latter being much simpler to understand).
*  In addition to the built-in functions of muparser, namely

* 
* [1.x.0]
*  this class also supports the following operations:
* 

* 
* 
*  -  [2.x.2] 
* 

* 
* 
*  -  [2.x.3]  (logic or and and)
* 

* 
* 
*  -  [2.x.4]  (rounding)
* 

* 
* 
*  -  [2.x.5] 
* 

* 
* 
*  -  [2.x.6] 
* 

* 
* 
*  -  [2.x.7] 
* 

* 
* 
*  -  [2.x.8] 
* 

* 
*  [2.x.9]  This class implements the list of functions just mentioned as   user-defined functions by extending muparser. This means, in particular,   that the `if(condition, then-value, else-value)` syntax evaluates all   three arguments before determining whether the condition is true, and   then discarding either the "then" or the "else" expressions. In almost   all situations, this is not a problem except if the evaluation of   one of the expressions throws a floating point exception in cases   where it will later be discarded. (Assuming floating point exceptions   are switched on, as is the default for deal.II in debug mode on most   systems.) An example would be the expression `if(x>0, sqrt(x), 0)`   which is mathematically well defined, but on systems where this is   enabled will abort the program with a floating point exception when   evaluated with a negative `x`. This is because the square root of   `x` is computed before the `if` statement's condition is considered   to determine whether the result should be the second or third   argument. If this kind of behavior is a problem, you can resort to   the muparser built-in syntax `(condition ? then-value : else-value)`,   using the ternary syntax familiar to C++ programmers. If this   syntax is used, muparser uses lazy evaluation in which only one of the   branches is evaluated, depending on whether the `condition` is   true or false.
*  The following examples shows how to use this class:

* 
* [1.x.1]
*  The second example is a bit more complex:

* 
* [1.x.2]
* 
*  This class overloads the virtual methods value() and vector_value() of the Function base class with the byte compiled versions of the expressions given to the initialize() methods. Note that the class will not work unless you first call the initialize() method that accepts the text description of the function as an argument (among other things).
*  The syntax to describe a function follows usual programming practice, and is explained in detail at the homepage of the underlying muparser library at https://beltoforion.de/en/muparser/.
*  For a wrapper of the FunctionParser class that supports ParameterHandler, see  [2.x.10] 
*  Vector-valued functions can either be declared using strings where the function components are separated by semicolons, or using a vector of strings each defining one vector component.
*  An example of time dependent scalar function is the following:

* 
* [1.x.3]
* 
*  The following is another example of how to instantiate a vector valued function by using a single string:

* 
* [1.x.4]
* 
* 

* 
*  [2.x.11]  The difference between this class and the SymbolicFunction class is that the SymbolicFunction class allows to compute first and second order derivatives (in a symbolic way), while this class computes first order derivatives only, using finite differences. For complicated expressions, this class is generally faster than SymbolicFunction.
* 

* 
*  [2.x.12] 

* 
* [0.x.1]*
   Constructor. Its arguments are the same of the base class Function, with   the additional parameter  [2.x.13]  used for the computation of gradients   using finite differences. This object needs to be initialized with the   initialize() method before you can use it. If an attempt to use this   function is made before the initialize() method has been called, then an   exception is thrown.  
* [0.x.2]*
   Constructor for parsed functions. Takes directly a semi-colon separated   list of expressions (one for each component of the function), an optional   comma-separated list of constants, variable names and step size for the   computation of first order derivatives by finite differences.  
* [0.x.3]*
   Copy constructor. Objects of this type can not be copied, and   consequently this constructor is deleted.  
* [0.x.4]*
   Move constructor. Objects of this type can not be moved, and   consequently this constructor is deleted.  
* [0.x.5]*
   Destructor.  
* [0.x.6]*
   Copy operator. Objects of this type can not be copied, and   consequently this operator is deleted.  
* [0.x.7]*
   Move operator. Objects of this type can not be moved, and   consequently this operator is deleted.  
* [0.x.8]*
   Type for the constant map. Used by the initialize() method.  
* [0.x.9]*
   Initialize the object by setting the actual parsed functions.      [2.x.14]  vars a string with the variables that will be used by the   expressions to be evaluated. Note that the variables can have any name   (of course different from the function names defined above!), but the   order IS important. The first variable will correspond to the first   component of the point in which the function is evaluated, the second   variable to the second component and so forth. If this function is also   time dependent, then it is necessary to specify it by setting the    [2.x.15]  parameter to true.  An exception is thrown if   the number of variables specified here is different from dim (if this   function is not time-dependent) or from dim+1 (if it is time-dependent).      [2.x.16]  expressions a list of strings containing the expressions that   will be byte compiled by the internal parser (muParser). Note that   the size of this vector must match exactly the number of components of   the FunctionParser, as declared in the constructor. If this is not the   case, an exception is thrown.      [2.x.17]  constants a map of constants used to pass any necessary constant   that we want to specify in our expressions (in the example above the   number pi). An expression is valid if and only if it contains only   defined variables and defined constants (other than the functions   specified above). If a constant is given whose name is not valid (eg:    [2.x.18] ) an exception is thrown.      [2.x.19]  time_dependent If this is a time dependent function, then the   last variable declared in  [2.x.20]  is assumed to be the time variable, and    [2.x.21]  is used to initialize it when evaluating the   function. Naturally the number of variables parsed by initialize() in   this case is dim+1. The value of this parameter defaults to false, i.e.,   do not consider time.  
* [0.x.10]*
   Initialize the function. Same as above, but accepts a string rather than   a vector of strings. If this is a vector valued function, its components   are expected to be separated by a semicolon. An exception is thrown if   this method is called and the number of components successfully parsed   does not match the number of components of the base function.  
* [0.x.11]*
   A function that returns default names for variables, to be used in the   first argument of the initialize() functions: it returns "x" in 1d, "x,y"   in 2d, and "x,y,z" in 3d.  
* [0.x.12]*
   Return the value of the function at the given point. Unless there is only   one component (i.e., the function is scalar), you should state the   component you want to have evaluated; it defaults to zero, i.e., the first   component.  
* [0.x.13]*
   Return all components of a vector-valued function at the given point  [2.x.22]    p.      [2.x.23]  shall have the right size beforehand, i.e.   #n_components.  
* [0.x.14]*
   Return an array of function expressions (one per component), used to   initialize this function.  
* [0.x.15]*
    [2.x.24]  Exceptions    [2.x.25]   
* [0.x.16]*
   Place for the variables for each thread  
* [0.x.17]*
   The muParser objects for each thread (and one for each component). We are   storing a unique_ptr so that we don't need to include the definition of    [2.x.26]  in this header.  
* [0.x.18]*
   An array to keep track of all the constants, required to initialize fp in   each thread.  
* [0.x.19]*
   An array for the variable names, required to initialize fp in each   thread.  
* [0.x.20]*
   Initialize fp and vars on the current thread. This function may only be   called once per thread. A thread can test whether the function has   already been called by testing whether 'fp.get().size()==0' (not   initialized) or >0 (already initialized).  
* [0.x.21]*
   An array of function expressions (one per component), required to   initialize fp in each thread.  
* [0.x.22]*
   State of usability. This variable is checked every time the function is   called for evaluation. It's set to true in the initialize() methods.  
* [0.x.23]*
   Number of variables. If this is also a function of time, then the number   of variables is dim+1, otherwise it is dim. In the case that this is a   time dependent function, the time is supposed to be the last variable. If   #n_vars is not identical to the number of the variables parsed by the   initialize() method, then an exception is thrown.  
* [0.x.24]

include/deal.II-translator/base/function_restriction_0.txt
[0.x.0]*
   This class takes a function in `dim + 1` dimensions and creates a new   function in one dimension lower by restricting one of the coordinates to a   given value. Mathematically this corresponds to taking a function    [2.x.0] ,   a fixed value,  [2.x.1] , and defining a new function (the restriction)    [2.x.2] .   Using this class, this translates to  
* [1.x.0]
*      The `dim`-dimensional coordinates on the restriction are ordered starting   from the restricted (`dim + 1`)-coordinate. In particular, this means that   if the  [2.x.3] -coordinate is locked to  [2.x.4]  in 3D, the coordinates are ordered   as  [2.x.5]  on the restriction:    [2.x.6] .   This is the same convention as in  [2.x.7]   
* [0.x.1]*
     Constructor, takes the (`dim + 1`)-coordinate direction and the value     that the incoming function should be restricted to.         A pointer to the incoming function is stored internally, so the function     must have a longer lifetime than the created restriction.    
* [0.x.2]*
   This class creates a 1-dimensional function from a `dim + 1` dimensional   function by restricting `dim` of the coordinate values to a given point.   Mathematically this corresponds to taking a function,  [2.x.8] , and   a point  [2.x.9] , and defining a new function  [2.x.10] .   Using this class, this translates to  
* [1.x.1]
*      The coordinates of the point will be expanded in the higher-dimensional   functions coordinates starting from the open-direction (and wrapping   around). In particular, if we restrict to a point  [2.x.11]  and choose to   keep the y-direction open, the restriction that is created is the function    [2.x.12] .   This is consistent with the convention in  [2.x.13]   
* [0.x.3]*
     Constructor, takes the point that the incoming function should be     restricted to and which (`dim + 1`)-dimensional coordinate direction     should be kept "open".         A pointer to the incoming function is stored internally, so the function     must have a longer lifetime than the created restriction.    
* [0.x.4]*
   Creates a (`dim + 1`)-dimensional point by copying over the coordinates of   the incoming `dim`-dimensional point and setting the "missing"   (`dim + 1`)-dimensional component to the incoming coordinate value.     For example, given the input    [2.x.14]  this function creates the point  [2.x.15] .     The coordinates of the `dim`-dimensional point are written to the   coordinates of the (`dim + 1`)-dimensional point in the order of the   convention given by the function coordinate_to_one_dim_higher. Thus, the   order of coordinates on the lower-dimensional point are not preserved:    [2.x.16]  creates the point  [2.x.17] .  
* [0.x.5]

include/deal.II-translator/base/function_spherical_0.txt
[0.x.0]*
   An abstract base class for a scalar-valued function  [2.x.0]    defined in spherical coordinates. This class wraps transformation of   values, gradients and hessians from spherical coordinates to the Cartesian   coordinate system used by the Function base class. Therefore derived   classes only need to implement those functions in spherical coordinates   (specifically svalue(), sgradient() and shessian() ). The convention for   angles is the same as in  [2.x.1]     
*  [2.x.2]  This function is currently only implemented for dim==3 .    
*  [2.x.3]   
* [0.x.1]*
     Constructor which should be provided with  [2.x.4]  defining the origin     of the coordinate system.         Note that components of this function are treated as entirely separate     quantities
* 
*  -  not as the components of a vector that will be     re-interpreted in a different coordinate system.    
* [0.x.2]*
     Return the value of the function at the given point.         This function converts the given point to spherical coordinates,     calls svalue() with it, and returns the result.    
* [0.x.3]*
     Return the gradient with respect to the Cartesian coordinates at point  [2.x.5]          This function converts the given point to spherical coordinates,     calls sgradient() with it, and converts the result into Cartesian     coordinates.    
* [0.x.4]*
     Return the Hessian with respect to the Cartesian coordinates at point  [2.x.6]          This function converts the given point to spherical coordinates,     calls sgradient and shessian() with it, and converts the result into     Cartesian coordinates.    
* [0.x.5]*
     Return an estimate for the memory consumption, in bytes, of this object.    
* [0.x.6]*
     Return the value at point  [2.x.7]  Here,  [2.x.8]  is provided in spherical     coordinates.    
* [0.x.7]*
     Return the gradient in spherical coordinates.         The returned object should contain derivatives in the following order:      [2.x.9] .    
* [0.x.8]*
     Return the Hessian in spherical coordinates.         The returned object should contain derivatives in the following order:      [2.x.10] .    
* [0.x.9]*
     A vector from the origin to the center of spherical coordinate system.    
* [0.x.10]

include/deal.II-translator/base/function.templates_0.txt
[0.x.0]*
 The constructor for <tt>VectorFunctionFromTensorFunction</tt> which initiates the return vector to be size <tt>n_components</tt>.

* 
* [0.x.1]*
 Member function <tt>vector_value_list </tt> is the interface for giving a list of points ( [2.x.0] ) of which to evaluate using the <tt>vector_value</tt> member function.  Again, this function is written so as to not replicate the function definition but passes each point on to <tt>vector_value</tt> to be evaluated.

* 
* [0.x.2]

include/deal.II-translator/base/function_time_0.txt
[0.x.0]*
 Support for time dependent functions. The library was also designed for time dependent problems. For this purpose, the function objects also contain a field which stores the time, as well as functions manipulating them. Time independent problems should not access or even abuse them for other purposes, but since one normally does not create thousands of function objects, the gain in generality weighs out the fact that we need not store the time value for not time dependent problems. The second advantage is that the derived standard classes like <tt>ZeroFunction</tt>, <tt>ConstantFunction</tt> etc also work for time dependent problems.
*  Access to the time goes through the following functions:  [2.x.0]    [2.x.1]  <tt>get_time</tt>: return the present value of the time variable.   [2.x.2]  <tt>set_time</tt>: set the time value to a specific value.   [2.x.3]  <tt>advance_time</tt>: increase the time by a certain time step.  [2.x.4]  The latter two functions are virtual, so that derived classes can perform computations which need only be done once for every new time. For example, if a time dependent function had a factor <tt>sin(t)</tt>, then it may be a reasonable choice to calculate this factor in a derived version of set_time(), store it in a member variable and use that one rather than computing it every time <tt>value()</tt>, <tt>value_list</tt> or one of the other functions of class Function is called.
*  By default, the advance_time() function calls the set_time() function with the new time, so it is sufficient in most cases to overload only set_time() for computations as sketched out above.
*  The constructor of this class takes an initial value for the time variable, which defaults to zero. Because a default value is given, none of the derived classes needs to take an initial value for the time variable if not needed.
*   [2.x.5]  Number The data type in which time values are to be stored. This will, in almost all cases, simply be the default  [2.x.6]  but there are cases where one may want to store the time in a different (and always scalar) type. An example would be an interval type that can store a value as well as its uncertainty. Another example would be a type that allows for Automatic Differentiation (see, for example, the Sacado type used in  [2.x.7] ) and thereby can generate analytic (temporal) derivatives of a function.
* 

* 

* 
*  [2.x.8] 

* 
* [0.x.1]*
   Constructor. May take an initial value for the time variable, which   defaults to zero.  
* [0.x.2]*
   Virtual destructor.  
* [0.x.3]*
   Return the value of the time variable.  
* [0.x.4]*
   Set the time to <tt>new_time</tt>, overwriting the old value.  
* [0.x.5]*
   Advance the time by the given time step <tt>delta_t</tt>.  
* [0.x.6]*
   The type this class is initialized with and that is used to represent time.  
* [0.x.7]*
   Store the present time.  
* [0.x.8]

include/deal.II-translator/base/function_time.templates_0.txt
[0.x.0]

include/deal.II-translator/base/function_tools_0.txt
[0.x.0]*
   Estimate bounds on the value and bounds on each gradient component of a   Function,  [2.x.0] , over a BoundingBox, by approximating it by a 2nd order   Taylor polynomial starting from the box center.     Each lower and upper bound is returned as a    [2.x.1] , such that the first entry is the   lower bound,  [2.x.2] , and the second is the upper bound,  [2.x.3] , i.e.    [2.x.4] .     The function value, gradient, and Hessian are computed at the box center.   The bounds on the value of the function are then estimated as      [2.x.5] ,   where    [2.x.6] .     Here,  [2.x.7]  is half the side length of the box in the  [2.x.8] th coordinate   direction, which is the distance we extrapolate. The bounds on the gradient   components are estimated similarly as      [2.x.9] ,   where    [2.x.10] .     If the function has more than 1 component the  [2.x.11]  parameter can   be used to specify which function component the bounds should be computed   for.  
* [0.x.1]

include/deal.II-translator/base/geometric_utilities_0.txt
[0.x.0]*
 A namespace for geometric utility functions that are not particularly specific to finite element computing or numerical programs, but nevertheless are needed in various contexts when writing applications.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   A namespace for coordinate transformations.  
* [0.x.2]*
     Return spherical coordinates of a Cartesian point  [2.x.1]      The returned array is filled with radius, azimuth angle  [2.x.2]      and polar/inclination angle  [2.x.3]  (omitted in 2D).         In 3D the transformation is given by    
* [1.x.0]
*          The use of this function is demonstrated in  [2.x.4] .    
* [0.x.3]*
     Return the Cartesian coordinates of a spherical point defined by  [2.x.5]      which is filled with radius  [2.x.6] , azimuth angle      [2.x.7]  and polar/inclination angle  [2.x.8]      (omitted in 2D).         In 3D the transformation is given by    
* [1.x.1]
*     
* [0.x.4]

include/deal.II-translator/base/geometry_info_0.txt
[0.x.0]*
 A class that can represent the kinds of objects a triangulation is made up of: vertices, lines, quads and hexes.
*  The class is rather primitive: it only stores a single integer that represents the dimensionality of the object represented. In other words, this class is useful primarily as a way to pass around an object whose data type explains what it does (unlike just passing around an integer), and for providing symbolic names for these objects such as  [2.x.0]  instead of an integer zero.
*  Since the ability to identify such objects with the integral dimension of the object represented, this class provides conversion operators to and from unsigned integers.

* 
* [0.x.1]*
   An enumeration providing symbolic names for the objects that can be   represented by this class. The numeric values of these symbolic names   equal the geometric dimensionality of the represented objects to make   conversion from and to integer variables simpler.  
* [0.x.2]*
     A vertex.    
* [0.x.3]*
     A line.    
* [0.x.4]*
     A quadrilateral.    
* [0.x.5]*
     A hexahedron.    
* [0.x.6]*
   Constructor. Initialize the object with the given argument representing a   vertex, line, etc.  
* [0.x.7]*
   Constructor. Initialize the object with an integer that should represent   the dimensionality of the geometric object in question. This will usually   be a number between zero (a vertex) and three (a hexahedron).  
* [0.x.8]*
   Return the integral dimension of the object currently represented, i.e.   zero for a vertex, one for a line, etc.  
* [0.x.9]*
   The object currently represented.  
* [0.x.10]*
 A class that provides possible choices for isotropic and anisotropic refinement flags in the current space dimension.
*  This general template is unused except in some weird template constructs. Actual use is made, however, of the specializations  [2.x.1] ,  [2.x.2] , and  [2.x.3] .
* 

* 
*  [2.x.4] 

* 
* [0.x.11]*
   Possible values for refinement cases in the current dimension.     Note the construction of the values: the lowest bit describes a cut of   the x-axis, the second to lowest bit corresponds to a cut of the y-axis   and the third to lowest bit corresponds to a cut of the z-axis. Thus, the   following relations hold (among others):    
* [1.x.0]
*      Only those cuts that are reasonable in a given space dimension are   offered, of course.     In addition, the tag  [2.x.5]  denotes isotropic   refinement in the space dimension selected by the template argument of   this class.     If you choose anisotropic refinement, for example by passing as argument   to  [2.x.6]    one of the flags  [2.x.7]   [2.x.8]     [2.x.9]  or a combination of these, then keep in mind   that refining in x-, y-, or z-direction happens with regard to the    [2.x.10] local [2.x.11]  coordinate system of the cell. In other words, these   flags determine which edges and faces of the cell will be cut into new   edges and faces. On the other hand, this process is independent of   how the cell is oriented within the  [2.x.12] global [2.x.13]  coordinate system,   and you should not assume any particular orientation of the cell's   local coordinate system within the global coordinate system of the   space it lives in.  
* [0.x.12]*
     Do not perform refinement.    
* [0.x.13]*
     Perform isotropic refinement. This implies     refining in all coordinate directions. For the     current general template class
* 
*  -  which is never used     because there are specializations for the 1d, 2d, and 3d     cases
* 
*  - , we simply set this number to a value that has     all bits set. The specializations in     RefinementPossibilities<1>, RefinementPossibilities<2>,     and RefinementPossibilities<3> set the corresponding `enum` element     to more reasonable values.    
* [0.x.14]*
 A class that provides possible choices for isotropic and anisotropic refinement flags in the current space dimension.
*  This specialization is used for  [2.x.14] , where it offers refinement in x-direction.
* 

* 
*  [2.x.15] 

* 
* [0.x.15]*
   Possible values for refinement cases in the current dimension.     Note the construction of the values: the lowest bit describes a cut of   the x-axis, the second to lowest bit corresponds to a cut of the y-axis   and the third to lowest bit corresponds to a cut of the z-axis. Thus, the   following relations hold (among others):    
* [1.x.1]
*      Only those cuts that are reasonable in a given space dimension are   offered, of course.     In addition, the tag  [2.x.16]  denotes isotropic   refinement in the space dimension selected by the template argument of   this class.     If you choose anisotropic refinement, for example by passing as argument   to  [2.x.17]    one of the flags  [2.x.18]   [2.x.19]     [2.x.20]  or a combination of these, then keep in mind   that refining in x-, y-, or z-direction happens with regard to the    [2.x.21] local [2.x.22]  coordinate system of the cell. In other words, these   flags determine which edges and faces of the cell will be cut into new   edges and faces. On the other hand, this process is independent of   how the cell is oriented within the  [2.x.23] global [2.x.24]  coordinate system,   and you should not assume any particular orientation of the cell's   local coordinate system within the global coordinate system of the   space it lives in.  
* [0.x.16]*
     Do not refine.    
* [0.x.17]*
     Perform a cut in the x-direction.    
* [0.x.18]*
     Perform isotropic refinement.    
* [0.x.19]*
 A class that provides possible choices for isotropic and anisotropic refinement flags in the current space dimension.
*  This specialization is used for  [2.x.25] , where it offers refinement in x- and y-direction separately, as well as isotropic refinement in both directions at the same time.
* 

* 
*  [2.x.26] 

* 
* [0.x.20]*
   Possible values for refinement cases in the current dimension.     Note the construction of the values: the lowest bit describes a cut of   the x-axis, the second to lowest bit corresponds to a cut of the y-axis   and the third to lowest bit corresponds to a cut of the z-axis. Thus, the   following relations hold (among others):    
* [1.x.2]
*      Only those cuts that are reasonable in a given space dimension are   offered, of course.     In addition, the tag  [2.x.27]  denotes isotropic   refinement in the space dimension selected by the template argument of   this class.     If you choose anisotropic refinement, for example by passing as argument   to  [2.x.28]    one of the flags  [2.x.29]   [2.x.30]     [2.x.31]  or a combination of these, then keep in mind   that refining in x-, y-, or z-direction happens with regard to the    [2.x.32] local [2.x.33]  coordinate system of the cell. In other words, these   flags determine which edges and faces of the cell will be cut into new   edges and faces. On the other hand, this process is independent of   how the cell is oriented within the  [2.x.34] global [2.x.35]  coordinate system,   and you should not assume any particular orientation of the cell's   local coordinate system within the global coordinate system of the   space it lives in.  
* [0.x.21]*
     Do not refine.    
* [0.x.22]*
     Perform a cut in the x-direction.    
* [0.x.23]*
     Perform a cut in the y-direction.    
* [0.x.24]*
     Perform cuts in the x- and y-directions.    
* [0.x.25]*
     Perform isotropic refinement.    
* [0.x.26]*
 A class that provides possible choices for isotropic and anisotropic refinement flags in the current space dimension.
*  This specialization is used for  [2.x.36] , where it offers refinement in x-, y- and z-direction separately, as well as combinations of these and isotropic refinement in all directions at the same time.
* 

* 
*  [2.x.37] 

* 
* [0.x.27]*
   Possible values for refinement cases in the current dimension.     Note the construction of the values: the lowest bit describes a cut of   the x-axis, the second to lowest bit corresponds to a cut of the y-axis   and the third to lowest bit corresponds to a cut of the z-axis. Thus, the   following relations hold (among others):    
* [1.x.3]
*      Only those cuts that are reasonable in a given space dimension are   offered, of course.     In addition, the tag  [2.x.38]  denotes isotropic   refinement in the space dimension selected by the template argument of   this class.     If you choose anisotropic refinement, for example by passing as argument   to  [2.x.39]    one of the flags  [2.x.40]   [2.x.41]     [2.x.42]  or a combination of these, then keep in mind   that refining in x-, y-, or z-direction happens with regard to the    [2.x.43] local [2.x.44]  coordinate system of the cell. In other words, these   flags determine which edges and faces of the cell will be cut into new   edges and faces. On the other hand, this process is independent of   how the cell is oriented within the  [2.x.45] global [2.x.46]  coordinate system,   and you should not assume any particular orientation of the cell's   local coordinate system within the global coordinate system of the   space it lives in.  
* [0.x.28]*
     Do not refine.    
* [0.x.29]*
     Perform a cut in the x-direction.    
* [0.x.30]*
     Perform a cut in the y-direction.    
* [0.x.31]*
     Perform a cut in the x and y-directions.    
* [0.x.32]*
     Perform a cut in the z-direction.    
* [0.x.33]*
     Perform a cuts in the x- and y-directions.    
* [0.x.34]*
     Perform a cuts in the x- and y-directions.    
* [0.x.35]*
     Perform a cuts in the x-, y-, and z-directions.    
* [0.x.36]*
     Perform isotropic refinement.    
* [0.x.37]*
 A class storing the possible anisotropic and isotropic refinement cases of an object with  [2.x.47]  dimensions (for example, for a line  [2.x.48]  in whatever space dimension we are, for a quad  [2.x.49] , etc.). Possible values of this class are the ones listed in the enumeration declared within the base class; see there for more information.
* 

* 
*  [2.x.50] 

* 
* [0.x.38]*
   Default constructor. Initialize the refinement case with no_refinement.  
* [0.x.39]*
   Constructor. Take and store a value indicating a particular refinement   from the list of possible refinements specified in the base class.  
* [0.x.40]*
   Constructor. Take and store a value indicating a particular refinement as   a bit field. To avoid implicit conversions to and from integral values,   this constructor is marked as explicit.  
* [0.x.41]*
   Return the numeric value stored by this class. While the presence of this   operator might seem dangerous, it is useful in cases where one would like   to have code like <tt>switch (refinement_flag)... case    [2.x.51]  ... </tt>, which can be written as    [2.x.52] .   Another application is to use an object of the current type as an index   into an array; however, this use is deprecated as it assumes a certain   mapping from the symbolic flags defined in the RefinementPossibilities   base class to actual numerical values (the array indices).  
* [0.x.42]*
   Return the union of the refinement flags represented by the current   object and the one given as argument.  
* [0.x.43]*
   Return the intersection of the refinement flags represented by the   current object and the one given as argument.  
* [0.x.44]*
   Return the negation of the refinement flags represented by the current   object. For example, in 2d, if the current object holds the flag    [2.x.53] ;   if the current value is  [2.x.54]  then the result   will be  [2.x.55] ; etc.  
* [0.x.45]*
   Return the flag that corresponds to cutting a cell along the axis given   as argument. For example, if  [2.x.56]  then the returned value is    [2.x.57]   
* [0.x.46]*
   Return the amount of memory occupied by an object of this type.  
* [0.x.47]*
   Read or write the data of this object to or from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.48]*
   Exception.  
* [0.x.49]*
   Store the refinement case as a bit field with as many bits as are   necessary in any given dimension.  
* [0.x.50]*
   A class that provides all possible situations a face (in the current   space dimension  [2.x.58]  might be subdivided into subfaces. For    [2.x.59]  they correspond to the cases   given in  [2.x.60] . However,    [2.x.61]  includes the refinement cases of    [2.x.62] , but additionally some subface   possibilities a face might be subdivided into which occur through   repeated anisotropic refinement steps performed on one of two neighboring   cells.     This general template is unused except in some weird template constructs.   Actual is made, however, of the specializations    [2.x.63] ,    [2.x.64]  and    [2.x.65] .    
*  [2.x.66]   
* [0.x.51]*
     Possible cases of faces being subdivided into subface.    
* [0.x.52]*
       Do not refine.      
* [0.x.53]*
       Refine isotropically.      
* [0.x.54]*
   A class that provides all possible situations a face (in the current   space dimension  [2.x.67]  might be subdivided into subfaces.     For  [2.x.68]  we provide a dummy implementation only.    
*  [2.x.69]   
* [0.x.55]*
     Possible cases of faces being subdivided into subface.         Dummy implementation.    
* [0.x.56]*
       Do not refine.      
* [0.x.57]*
       Refine isotropically.      
* [0.x.58]*
   A class that provides all possible situations a face (in the current   space dimension  [2.x.70]  might be subdivided into subfaces.     For  [2.x.71]  there are no faces. Thereby, there are no subface   possibilities.    
*  [2.x.72]   
* [0.x.59]*
     Possible cases of faces being subdivided into subface.         In 1d there are no faces, thus no subface possibilities.    
* [0.x.60]*
       Do not refine.      
* [0.x.61]*
       Refine isotropically.      
* [0.x.62]*
   A class that provides all possible situations a face (in the current   space dimension  [2.x.73]  might be subdivided into subfaces.     This specialization is used for  [2.x.74] , where it offers the   following possibilities: a face (line) being refined   ( [2.x.75] ).    
*  [2.x.76]   
* [0.x.63]*
     Possible cases of faces being subdivided into subface.         In 2d there are following possibilities: a face (line) being refined     ( [2.x.77] ).    
* [0.x.64]*
       Do not refine.      
* [0.x.65]*
       Cut in the x-direction.      
* [0.x.66]*
       Refine isotropically.      
* [0.x.67]*
   A class that provides all possible situations a face (in the current   space dimension  [2.x.78]  might be subdivided into subfaces.     This specialization is used for dim=3, where it offers following   possibilities: a face (quad) being refined in x- or y-direction (in the   face-intern coordinate system) separately, ( [2.x.79]  or   ( [2.x.80]  which   corresponds to ( [2.x.81] ). Additionally, it offers the   possibilities a face can have through repeated anisotropic refinement   steps performed on one of the two neighboring cells.  It might be   possible for example, that a face (quad) is refined with    [2.x.82]  and afterwards the left child is again refined with    [2.x.83] , so that there are three active subfaces. Note,   however, that only refinement cases are allowed such that each line on a   face between two hexes has not more than one hanging node. Furthermore,   it is not allowed that two neighboring hexes are refined such that one of   the hexes refines the common face with  [2.x.84]  and the other   hex refines that face with  [2.x.85] . In fact,    [2.x.86]  takes care of this   situation and ensures that each face of a refined cell is completely   contained in a single face of neighboring cells.     The following drawings explain the SubfacePossibilities and give the   corresponding subface numbers:  
* [1.x.4]
*     
*  [2.x.87]   
* [0.x.68]*
     Possible cases of faces being subdivided into subface.         See documentation to the SubfacePossibilities<3> for more details on     the subface possibilities.    
* [0.x.69]*
   A class that provides all possible cases a face (in the current space   dimension  [2.x.88]  might be subdivided into subfaces.    
*  [2.x.89]   
* [0.x.70]*
     Constructor. Take and store a value indicating a particular subface     possibility in the list of possible situations specified in the base     class.    
* [0.x.71]*
     Return the numeric value stored by this class. While the presence of     this operator might seem dangerous, it is useful in cases where one     would like to have code like <code>switch (subface_case)... case      [2.x.90]  ... </code>, which can be written as <code>switch      [2.x.91]  Another application     is to use an object of the current type as an index into an array;     however, this use is deprecated as it assumes a certain mapping from     the symbolic flags defined in the SubfacePossibilities base class to     actual numerical values (the array indices).    
* [0.x.72]*
     Return the amount of memory occupied by an object of this type.    
* [0.x.73]*
     Exception.    
* [0.x.74]*
     Store the refinement case as a bit field with as many bits as are     necessary in any given dimension.    
* [0.x.75]*
 This class provides a description of zero-dimensional cells. It has been superseded by the ReferenceCell class
* 
*  -  see there for more information.
*  Topological description of zero dimensional cells, i.e. points. This class might not look too useful but often is if in a certain dimension we would like to enquire information about objects with dimension one lower than the present, e.g. about faces.
*  This class contains as static members information on vertices and faces of a  [2.x.92]  grid cell. The interface is the same for all dimensions. If a value is of no use in a low dimensional cell, it is (correctly) set to zero, e.g. #max_children_per_face in 1d.
*  This information should always replace hard-coded numbers of vertices, neighbors and so on, since it can be used dimension independently.
* 

* 
*  [2.x.93] 

* 
* [0.x.76]*
   Maximum number of children of a cell, i.e. the number of children of an   isotropically refined cell.     If a cell is refined anisotropically, the actual number of children may   be less than the value given here.  
* [0.x.77]*
   Number of faces a cell has.  
* [0.x.78]*
   Return an object that can be thought of as an array containing all   indices from zero to `faces_per_cell`. This allows to write code   using range-based for loops of the following kind:  
* [1.x.5]
*    Here, we are looping over all faces of all cells, with `face_index`   taking on all valid indices.     Of course, since this class is for the case `dim==0`, the   returned object is actually an empty array.  
* [0.x.79]*
   Maximum number of children of a refined face, i.e. the number of children   of an isotropically refined face.     If a cell is refined anisotropically, the actual number of children may   be less than the value given here.  
* [0.x.80]*
   Return the number of children of a cell (or face) refined with   <tt>ref_case</tt>. Since we are concerned here with points, the number of   children is equal to one.  
* [0.x.81]*
   Number of vertices a cell has.  
* [0.x.82]*
   Return an object that can be thought of as an array containing all   indices from zero to `vertices_per_cell`. This allows to write code   using range-based for loops of the following kind:  
* [1.x.6]
*    Here, we are looping over all vertices of all cells, with `vertex_index`   taking on all valid indices.     Of course, since this class is for the case `dim==0`, the   returned object is a array with just one entry: zero. That's   because an of dimension zero is really just a single point,   corresponding to a vertex itself.  
* [0.x.83]*
   Map face vertex number to cell vertex number, i.e. give the cell vertex   number of the <tt>vertex</tt>th vertex of face <tt>face</tt>, e.g.    [2.x.94]  see the image   under point N4 in the 2d section of this class's documentation.     Through the <tt>face_orientation</tt>, <tt>face_flip</tt> and   <tt>face_rotation</tt> arguments this function handles faces oriented in   the standard and non-standard orientation. <tt>face_orientation</tt>   defaults to <tt>true</tt>, <tt>face_flip</tt> and <tt>face_rotation</tt>   default to <tt>false</tt> (standard orientation). In 2d only   <tt>face_flip</tt> is considered. See this    [2.x.95]  "glossary"   article for more information.     As the children of a cell are ordered according to the vertices of the   cell, this call is passed down to the child_cell_on_face() function.   Hence this function is simply a wrapper of child_cell_on_face() giving it   a suggestive name.     Of course, since this class is for the case `dim==0`, this function   is not implemented.  
* [0.x.84]*
   Map face line number to cell line number, i.e. give the cell line number   of the <tt>line</tt>th line of face <tt>face</tt>, e.g.    [2.x.96]      Through the <tt>face_orientation</tt>, <tt>face_flip</tt> and   <tt>face_rotation</tt> arguments this function handles faces oriented in   the standard and non-standard orientation. <tt>face_orientation</tt>   defaults to <tt>true</tt>, <tt>face_flip</tt> and <tt>face_rotation</tt>   default to <tt>false</tt> (standard orientation) and has no effect in 2d.     Of course, since this class is for the case `dim==0`, this function   is not implemented.  
* [0.x.85]*
   Number of vertices each face has. Since this is not useful in one   dimension, we provide a useless number (in the hope that a compiler may   warn when it sees constructs like <tt>for (i=0; i<vertices_per_face;   ++i)</tt>, at least if  [2.x.97]  is an <tt>unsigned int</tt>.  
* [0.x.86]*
   Number of lines each face has.  
* [0.x.87]*
   Number of quads on each face.  
* [0.x.88]*
   Number of lines of a cell.  
* [0.x.89]*
   Number of quadrilaterals of a cell.  
* [0.x.90]*
   Number of hexahedra of a cell.  
* [0.x.91]*
   Rearrange vertices for UCD output.  For a cell being written in UCD   format, each entry in this field contains the number of a vertex in   <tt>deal.II</tt> that corresponds to the UCD numbering at this location.     Typical example: write a cell and arrange the vertices, such that UCD   understands them.    
* [1.x.7]
*      As the vertex numbering in deal.II versions <= 5.1 happened to coincide   with the UCD numbering, this field can also be used like a   old_to_lexicographic mapping.  
* [0.x.92]*
   Rearrange vertices for OpenDX output.  For a cell being written in OpenDX   format, each entry in this field contains the number of a vertex in   <tt>deal.II</tt> that corresponds to the DX numbering at this location.     Typical example: write a cell and arrange the vertices, such that OpenDX   understands them.    
* [1.x.8]
*   
* [0.x.93]*
 This class provides dimension independent information to all topological structures that make up the unit, or  [2.x.98]  "reference cell". This class has been superseded by the ReferenceCell class
* 
*  -  see there for more information.
* 

*  It is the one central point in the library where information about the numbering of vertices, lines, or faces of the reference cell is collected. Consequently, the information of this class is used extensively in the geometric description of Triangulation objects, as well as in various other parts of the code. In particular, it also serves as the focus of writing code in a dimension independent way; for example, instead of writing a loop over vertices 0<=v<4 in 2d, one would write it as  [2.x.99]  thus allowing the code to work in 3d as well without changes.
*  The most frequently used parts of the class are its static members like vertices_per_cell, faces_per_cell, etc. However, the class also offers information about more abstract questions like the orientation of faces, etc. The following documentation gives a textual description of many of these concepts.
* 

*  [1.x.9]
*  From version 5.2 onwards deal.II is based on a numbering scheme that uses a lexicographic ordering (with x running fastest) wherever possible, hence trying to adopt a kind of 'canonical' ordering.
*  The ordering of vertices and faces (lines) in 2d is defined by
* 

* 
* 
*  - Vertices are numbered in lexicographic ordering
* 

* 
* 
*  - Faces (lines in 2d): first the two faces with normals in x- and then y-direction. For each two faces: first the face with normal in negative coordinate direction, then the one with normal in positive direction, i.e. the faces are ordered according to their normals pointing in
* 
*  - , x,
* 
*  - , y direction.
* 

* 
* 
*  - The direction of a line is represented by the direction of point 0 towards point 1 and is always in one of the coordinate directions
* 

* 
* 
*  - Face lines in 3d are ordered, such that the induced 2d local coordinate system (x,y) implies (right hand rule) a normal in face normal direction, see N2/.
*  The resulting numbering of vertices and faces (lines) in 2d as well as the directions of lines is shown in the following.

* 
* [1.x.10]
* 
*  Note that the orientation of lines has to be correct upon construction of a grid; however, it is automatically preserved upon refinement.
*  Further we define that child lines have the same direction as their parent, i.e. that <tt>line->child(0)->vertex(0)==line->vertex(0)</tt> and <tt>line->child(1)->vertex(1)==line->vertex(1)</tt>. This also implies, that the first sub-line (<tt>line->child(0)</tt>) is the one at vertex(0) of the old line.
*  Similarly we define, that the four children of a quad are adjacent to the vertex with the same number of the old quad.
*  Note that information about several of these conventions can be extracted at run- or compile-time from the member functions and variables of the present class.
* 

*  [1.x.11]
*  When explicit coordinates are required for points in a cell (e.g for quadrature formulae or the point of definition of trial functions), we define the following coordinate system for the unit cell:

* 
* [1.x.12]
* 
*  Here, vertex 0 is the origin of the coordinate system, vertex 1 has coordinates <tt>(1,0)</tt>, vertex 2 at <tt>(0,1)</tt> and vertex 3 at <tt>(1,1)</tt>. The  [2.x.100]  function can be used to query this information at run-time.
* 

*  [1.x.13]
*  By convention, we will use the following numbering conventions for vertices, lines and faces of hexahedra in three space dimensions. Before giving these conventions we declare the following sketch to be the standard way of drawing 3d pictures of hexahedra:

* 
* [1.x.14]
*  The left part of the picture shows the left, bottom and back face of the cube, while the right one shall be the top, right and front face. You may recover the whole cube by moving the two parts together into one.
*  Note again that information about several of the following conventions can be extracted at run- or compile-time from the member functions and variables of the present class.
*  [1.x.15]
*  The ordering of vertices in 3d is defined by the same rules as in the 2d case. In particular, the following is still true:
* 

* 
* 
*  - Vertices are numbered in lexicographic ordering.
*  Hence, the vertices are numbered as follows

* 
* [1.x.16]
* 
*  We note, that first the vertices on the bottom face (z=0) are numbered exactly the same way as are the vertices on a quadrilateral. Then the vertices on the top face (z=1) are numbered similarly by moving the bottom face to the top. Again, the  [2.x.101]  function can be used to query this information at run-time.
* 

*  [1.x.17]
*  Here, the same holds as for the vertices:
* 

* 
* 
*  - Line ordering in 3d:  [2.x.102]   [2.x.103] first the lines of face (z=0) in 2d line ordering,  [2.x.104] then the lines of face (z=1) in 2d line ordering,  [2.x.105] finally the lines in z direction in lexicographic ordering  [2.x.106] 

* 
* [1.x.18]
*  As in 2d lines are directed in coordinate directions.

* 
* [1.x.19]
* 
*  The fact that edges (just as vertices and faces) are entities that are stored in their own right rather than constructed from cells each time they are needed, means that adjacent cells actually have pointers to edges that are thus shared between them. This implies that the convention that sets of parallel edges have parallel directions is not only a local condition. Before a list of cells is passed to an object of the Triangulation class for creation of a triangulation, you therefore have to make sure that cells are oriented in a compatible fashion, so that edge directions are globally according to above convention. However, the GridReordering class can do this for you, by reorienting cells and edges of an arbitrary list of input cells that need not be already sorted.
*  [1.x.20]
*  The numbering of faces in 3d is defined by a rule analogous to 2d:
* 

* 
* 
*  - Faces (quads in 3d): first the two faces with normals in x-, then y- and z-direction. For each two faces: first the face with normal in negative coordinate direction, then the one with normal in positive direction, i.e. the faces are ordered according to their normals pointing in
* 
*  - , x,
* 
*  - , y,
* 

* 
* 
*  - , z direction.
*  Therefore, the faces are numbered in the ordering: left, right, front, back, bottom and top face:

* 
* [1.x.21]
* 
*  The  [2.x.107] standard [2.x.108]  direction of the faces is such, that the induced 2d local coordinate system (x,y) implies (right hand rule) a normal in face normal direction, see N2a).  In the following we show the local coordinate system and the numbering of face lines:  [2.x.109]   [2.x.110]  Faces 0 and 1: 
* [1.x.22]
* 
*   [2.x.111]  Faces 2 and 3: 
* [1.x.23]
* 
*   [2.x.112]  Faces 4 and 5: 
* [1.x.24]
*   [2.x.113] 
*  The face line numbers (0,1,2,3) correspond to following cell line numbers.  [2.x.114]   [2.x.115]  Face 0: lines 8, 10, 0, 4;  [2.x.116]  Face 1: lines 9, 11, 1, 5;  [2.x.117]  Face 2: lines 2, 6, 8, 9;  [2.x.118]  Face 3: lines 3, 7, 10, 11;  [2.x.119]  Face 4: lines 0, 1, 2, 3;  [2.x.120]  Face 5: lines 4, 5, 6, 7;  [2.x.121]  You can get these numbers using the  [2.x.122]  function.
*  The face normals can be deduced from the face orientation by applying the right hand side rule (x,y
* 
-> normal).  We note, that in the standard orientation of faces in 2d, faces 0 and 2 have normals that point into the cell, and faces 1 and 3 have normals pointing outward. In 3d, faces 0, 2, and 4 have normals that point into the cell, while the normals of faces 1, 3, and 5 point outward. This information, again, can be queried from  [2.x.123] 
*  However, it turns out that a significant number of 3d meshes cannot satisfy this convention. This is due to the fact that the face convention for one cell already implies something for the neighbor, since they share a common face and fixing it for the first cell also fixes the normal vectors of the opposite faces of both cells. It is easy to construct cases of loops of cells for which this leads to cases where we cannot find orientations for all faces that are consistent with this convention.
*  For this reason, above convention is only what we call the  [2.x.124] standard orientation [2.x.125] . deal.II actually allows faces in 3d to have either the standard direction, or its opposite, in which case the lines that make up a cell would have reverted orders, and the above line equivalences would not hold any more. You can ask a cell whether a given face has standard orientation by calling <tt>cell->face_orientation(face_no)</tt>: if the result is  [2.x.126]  then the face has standard orientation, otherwise its normal vector is pointing the other direction. There are not very many places in application programs where you need this information actually, but a few places in the library make use of this. Note that in 2d, the result is always  [2.x.127]  More information on the topic can be found in this  [2.x.128]  "glossary" article.
*  In order to allow all kinds of meshes in 3d, including  [2.x.129] Moebius [2.x.130] -loops, a face might even be rotated looking from one cell, whereas it is according to the standard looking at it from the neighboring cell sharing that particular face. In order to cope with this, two flags <tt>face_flip</tt> and <tt>face_rotation</tt> are available, to represent rotations by 180 and 90 degree, respectively. Setting both flags amounts to a rotation of 270 degrees (all counterclockwise). You can ask the cell for these flags like for the <tt>face_orientation</tt>. In order to enable rotated faces, even lines can deviate from their standard direction in 3d. This information is available as the <tt>line_orientation</tt> flag for cells and faces in 3d. Again, this is something that should be internal to the library and application program will probably never have to bother about it. For more information on this see also  [2.x.131]  "this glossary entry".
* 

*  [1.x.25]
*  The eight children of an isotropically refined cell are numbered according to the vertices they are adjacent to:

* 
* [1.x.26]
* 
*  Taking into account the orientation of the faces, the following children are adjacent to the respective faces:  [2.x.132]   [2.x.133]  Face 0: children 0, 2, 4, 6;  [2.x.134]  Face 1: children 1, 3, 5, 7;  [2.x.135]  Face 2: children 0, 4, 1, 5;  [2.x.136]  Face 3: children 2, 6, 3, 7;  [2.x.137]  Face 4: children 0, 1, 2, 3;  [2.x.138]  Face 5: children 4, 5, 6, 7.  [2.x.139]  You can get these numbers using the  [2.x.140]  function. As each child is adjacent to the vertex with the same number these numbers are also given by the  [2.x.141]  function.
*  Note that, again, the above list only holds for faces in their standard orientation. If a face is not in standard orientation, then the children at positions 1 and 2 (counting from 0 to 3) would be swapped. In fact, this is what the child_cell_on_face and the face_to_cell_vertices functions of GeometryInfo<3> do, when invoked with a <tt>face_orientation=false</tt> argument.
*  The information which child cell is at which position of which face is most often used when computing jump terms across faces with hanging nodes, using objects of type FESubfaceValues. Sitting on one cell, you would look at a face and figure out which child of the neighbor is sitting on a given subface between the present and the neighboring cell. To avoid having to query the standard orientation of the faces of the two cells every time in such cases, you should use a function call like <tt>cell->neighbor_child_on_subface(face_no,subface_no)</tt>, which returns the correct result both in 2d (where face orientations are immaterial) and 3d (where it is necessary to use the face orientation as additional argument to  [2.x.142] 
*  For anisotropic refinement, the child cells can not be numbered according to adjacent vertices, thus the following conventions are used:

* 
* [1.x.27]
* 
* 

* 
* [1.x.28]
* 
* 

* 
* [1.x.29]
* 
* 

* 
* [1.x.30]
* 
* 

* 
* [1.x.31]
* 
* 

* 
* [1.x.32]
* 
*  This information can also be obtained by the  [2.x.143]  function.
*  [1.x.33]
*  We define the following coordinate system for the explicit coordinates of the vertices of the unit cell:

* 
* [1.x.34]
* 
*  By the convention laid down as above, the vertices have the following coordinates (lexicographic, with x running fastest):  [2.x.144]   [2.x.145]  Vertex 0: <tt>(0,0,0)</tt>;  [2.x.146]  Vertex 1: <tt>(1,0,0)</tt>;  [2.x.147]  Vertex 2: <tt>(0,1,0)</tt>;  [2.x.148]  Vertex 3: <tt>(1,1,0)</tt>;  [2.x.149]  Vertex 4: <tt>(0,0,1)</tt>;  [2.x.150]  Vertex 5: <tt>(1,0,1)</tt>;  [2.x.151]  Vertex 6: <tt>(0,1,1)</tt>;  [2.x.152]  Vertex 7: <tt>(1,1,1)</tt>.  [2.x.153] 
* 

* 
* 

* 
*  [2.x.154]  Instantiations for this template are provided for dimensions 1,2,3,4, and there is a specialization for dim=0 (see the section on  [2.x.155]  in the manual).
* 

* 
*  [2.x.156] 

* 
* [0.x.94]*
   Maximum number of children of a refined cell, i.e. the number of children   of an isotropically refined cell.     If a cell is refined anisotropically, the actual number of children may   be less than the value given here.  
* [0.x.95]*
   Number of faces of a cell.  
* [0.x.96]*
   Return an object that can be thought of as an array containing all   indices from zero to `faces_per_cell`. This allows to write code   using range-based for loops of the following kind:  
* [1.x.35]
*    Here, we are looping over all faces of all cells, with `face_index`   taking on all valid indices for faces (zero and one in 1d, zero   through three in 2d, and zero through 5 in 3d).      [2.x.157]  CPP11  
* [0.x.97]*
   Maximum number of children of a refined face, i.e. the number of children   of an isotropically refined face.     If a cell is refined anisotropically, the actual number of children may   be less than the value given here.  
* [0.x.98]*
   Number of vertices of a cell.  
* [0.x.99]*
   Return an object that can be thought of as an array containing all   indices from zero to `vertices_per_cell`. This allows to write code   using range-based for loops of the following kind:  
* [1.x.36]
*    Here, we are looping over all vertices of all cells, with `vertex_index`   taking on all valid indices.      [2.x.158]  CPP11  
* [0.x.100]*
   Number of vertices on each face.  
* [0.x.101]*
   Number of lines on each face.  
* [0.x.102]*
   Number of quads on each face.  
* [0.x.103]*
   Number of lines of a cell.     The formula to compute this makes use of the fact that when going from   one dimension to the next, the object of the lower dimension is copied   once (thus twice the old number of lines) and then a new line is inserted   between each vertex of the old object and the corresponding one in the   copy.  
* [0.x.104]*
   Number of quadrilaterals of a cell.     This number is computed recursively just as the previous one, with the   exception that new quads result from connecting an original line and its   copy.  
* [0.x.105]*
   Number of hexahedra of a cell.  
* [0.x.106]*
   Rearrange vertices for UCD output.  For a cell being written in UCD   format, each entry in this field contains the number of a vertex in   <tt>deal.II</tt> that corresponds to the UCD numbering at this location.     Typical example: write a cell and arrange the vertices, such that UCD   understands them.    
* [1.x.37]
*      As the vertex numbering in deal.II versions <= 5.1 happened to coincide   with the UCD numbering, this field can also be used like a   old_to_lexicographic mapping.  
* [0.x.107]*
   Rearrange vertices for OpenDX output.  For a cell being written in OpenDX   format, each entry in this field contains the number of a vertex in   <tt>deal.II</tt> that corresponds to the DX numbering at this location.     Typical example: write a cell and arrange the vertices, such that OpenDX   understands them.    
* [1.x.38]
*   
* [0.x.108]*
   This field stores for each vertex to which faces it belongs. In any given   dimension, the number of faces is equal to the dimension. The first index   in this 2D-array runs over all vertices, the second index over  [2.x.159]    faces to which the vertex belongs.     The order of the faces for each vertex is such that the first listed face   bounds the reference cell in [1.x.39] direction, the second in [1.x.40]   direction, and so on.  
* [0.x.109]*
   Return the number of children of a cell (or face) refined with   <tt>ref_case</tt>.  
* [0.x.110]*
   Return the number of subfaces of a face refined according to    [2.x.160]   [2.x.161]   
* [0.x.111]*
   Given a face on the reference element with a    [2.x.162]   [2.x.163]  this   function returns the ratio between the area of the  [2.x.164]  th   subface and the area(=1) of the face.     E.g. for  [2.x.165]  the ratio is 1/4 for each of the   subfaces.  
* [0.x.112]*
   Given a cell refined with the  [2.x.166]   [2.x.167]    cell_refinement_case return the  [2.x.168]  of the  [2.x.169]    face_no th face.  
* [0.x.113]*
   Given the SubfaceCase  [2.x.170]  of the  [2.x.171]  th face,   return the smallest RefinementCase of the cell, which corresponds to that   refinement of the face.  
* [0.x.114]*
   Given a cell refined with the RefinementCase  [2.x.172]    return the RefinementCase of the  [2.x.173]  th face.  
* [0.x.115]*
   Return the minimal / smallest RefinementCase of the cell, which ensures   refinement of line  [2.x.174]   
* [0.x.116]*
   This field stores which child cells are adjacent to a certain face of the   mother cell.     For example, in 2D the layout of a cell is as follows:  
* [1.x.41]
*    Vertices and faces are indicated with their numbers, faces also with   their directions.     Now, when refined, the layout is like this:  
* [1.x.42]
*      Thus, the child cells on face 0 are (ordered in the direction of the   face) 0 and 2, on face 3 they are 2 and 3, etc.     For three spatial dimensions, the exact order of the children is laid   down in the general documentation of this class.     Through the <tt>face_orientation</tt>, <tt>face_flip</tt> and   <tt>face_rotation</tt> arguments this function handles faces oriented in   the standard and non-standard orientation. <tt>face_orientation</tt>   defaults to <tt>true</tt>, <tt>face_flip</tt> and <tt>face_rotation</tt>   default to <tt>false</tt> (standard orientation) and has no effect in 2d.   The concept of face orientations is explained in this    [2.x.175]  "glossary"   entry.     In the case of anisotropically refined cells and faces, the  [2.x.176]    RefinementCase of the face, <tt>face_ref_case</tt>, might have an   influence on which child is behind which given subface, thus this is an   additional argument, defaulting to isotropic refinement of the face.  
* [0.x.117]*
   Map line vertex number to cell vertex number, i.e. give the cell vertex   number of the <tt>vertex</tt>th vertex of line <tt>line</tt>, e.g.    [2.x.177]      The order of the lines, as well as their direction (which in turn   determines which is the first and which the second vertex on a line) is   the canonical one in deal.II, as described in the general documentation   of this class.     For <tt>dim=2</tt> this call is simply passed down to the   face_to_cell_vertices() function.  
* [0.x.118]*
   Map face vertex number to cell vertex number, i.e. give the cell vertex   number of the <tt>vertex</tt>th vertex of face <tt>face</tt>, e.g.    [2.x.178]  see the image   under point N4 in the 2d section of this class's documentation.     Through the <tt>face_orientation</tt>, <tt>face_flip</tt> and   <tt>face_rotation</tt> arguments this function handles faces oriented in   the standard and non-standard orientation. <tt>face_orientation</tt>   defaults to <tt>true</tt>, <tt>face_flip</tt> and <tt>face_rotation</tt>   default to <tt>false</tt> (standard orientation). In 2d only   <tt>face_flip</tt> is considered. See this    [2.x.179]  "glossary"   article for more information.     As the children of a cell are ordered according to the vertices of the   cell, this call is passed down to the child_cell_on_face() function.   Hence this function is simply a wrapper of child_cell_on_face() giving it   a suggestive name.  
* [0.x.119]*
   Map face line number to cell line number, i.e. give the cell line number   of the <tt>line</tt>th line of face <tt>face</tt>, e.g.    [2.x.180]      Through the <tt>face_orientation</tt>, <tt>face_flip</tt> and   <tt>face_rotation</tt> arguments this function handles faces oriented in   the standard and non-standard orientation. <tt>face_orientation</tt>   defaults to <tt>true</tt>, <tt>face_flip</tt> and <tt>face_rotation</tt>   default to <tt>false</tt> (standard orientation) and has no effect in 2d.  
* [0.x.120]*
   Map the vertex index  [2.x.181]  of a face in standard orientation to one   of a face with arbitrary  [2.x.182]   [2.x.183]  and  [2.x.184]    face_rotation. The values of these three flags default to <tt>true</tt>,   <tt>false</tt> and <tt>false</tt>, respectively. this combination   describes a face in standard orientation.     This function is only implemented in 3D.  
* [0.x.121]*
   Map the vertex index  [2.x.185]  of a face with arbitrary  [2.x.186]    face_orientation,  [2.x.187]  and  [2.x.188]  to a face in standard   orientation. The values of these three flags default to <tt>true</tt>,   <tt>false</tt> and <tt>false</tt>, respectively. this combination   describes a face in standard orientation.     This function is only implemented in 3D.  
* [0.x.122]*
   Map the line index  [2.x.189]  of a face in standard orientation to one of a   face with arbitrary  [2.x.190]   [2.x.191]  and  [2.x.192]    face_rotation. The values of these three flags default to <tt>true</tt>,   <tt>false</tt> and <tt>false</tt>, respectively. this combination   describes a face in standard orientation.     This function is only implemented in 3D.  
* [0.x.123]*
   Map the vertex index  [2.x.193]  of a line in standard orientation to one of a   face with arbitrary  [2.x.194]  The value of this flag default to   <tt>true</tt>.  
* [0.x.124]*
   Decompose the vertex index in a quad into a pair of a line index and a   vertex index within this line.    
*  [2.x.195]  Which line is selected is not of importance (and not exposed on     purpose).  
* [0.x.125]*
   Decompose the vertex index in a hex into a pair of a quad index and a   vertex index within this quad.    
*  [2.x.196]  Which quad is selected is not of importance (and not exposed on     purpose).  
* [0.x.126]*
   Decompose the line index in a hex into a pair of a quad index and a line   index within this quad.    
*  [2.x.197]  Which quad is selected is not of importance (and not exposed on     purpose).  
* [0.x.127]*
   Map the line index  [2.x.198]  of a face with arbitrary  [2.x.199]     [2.x.200]  and  [2.x.201]  to a face in standard orientation. The   values of these three flags default to <tt>true</tt>, <tt>false</tt> and   <tt>false</tt>, respectively. this combination describes a face in   standard orientation.     This function is only implemented in 3D.  
* [0.x.128]*
   Return the position of the  [2.x.202]  vertex on the unit cell. The order of   vertices is the canonical one in deal.II, as described in the general   documentation of this class.  
* [0.x.129]*
   Given a point  [2.x.203]  in unit coordinates, return the number of the child   cell in which it would lie in. If the point lies on the interface of two   children, return any one of their indices. The result is always less than    [2.x.204]      The order of child cells is described the general documentation of this   class.  
* [0.x.130]*
   Given coordinates  [2.x.205]  on the unit cell, return the values of the   coordinates of this point in the coordinate system of the given child.   Neither original nor returned coordinates need actually be inside the   cell, we simply perform a scale-and-shift operation with a shift that   depends on the number of the child.  
* [0.x.131]*
   The reverse function to the one above: take a point in the coordinate   system of the child, and transform it to the coordinate system of the   mother cell.  
* [0.x.132]*
   Return true if the given point is inside the unit cell of the present   space dimension.  
* [0.x.133]*
   Return true if the given point is inside the unit cell of the present   space dimension. This function accepts an additional parameter which   specifies how much the point position may actually be outside the true   unit cell. This is useful because in practice we may often not be able to   compute the coordinates of a point in reference coordinates exactly, but   only up to numerical roundoff.     The tolerance parameter may be less than zero, indicating that the point   should be safely inside the cell.  
* [0.x.134]*
   Projects a given point onto the unit cell, i.e. each coordinate outside   [0..1] is modified to lie within that interval.  
* [0.x.135]*
   Return the infinity norm of the vector between a given point  [2.x.206]    outside the unit cell to the closest unit cell boundary. For points   inside the cell, this is defined as zero.  
* [0.x.136]*
   Compute the value of the  [2.x.207] -th  [2.x.208] -linear (i.e. (bi-,tri-)linear) shape   function at location  [2.x.209] .  
* [0.x.137]*
   Compute the gradient of the  [2.x.210] -th  [2.x.211] -linear (i.e. (bi-,tri-)linear)   shape function at location  [2.x.212] .  
* [0.x.138]*
   For a (bi-, tri-)linear mapping from the reference cell, face, or edge to   the object specified by the given vertices, compute the alternating form   of the transformed unit vectors vertices. For an object of dimensionality    [2.x.213]  there are  [2.x.214]  vectors with  [2.x.215]  components each, and   the alternating form is a tensor of rank spacedim-dim that corresponds to   the wedge product of the  [2.x.216]  unit vectors, and it corresponds to the   volume and normal vectors of the mapping from reference element to the   element described by the vertices.     For example, if dim==spacedim==2, then the alternating form is a scalar   (because spacedim-dim=0) and its value equals  [2.x.217] , where  [2.x.218]  is a   vector that is rotated to the right by 90 degrees from  [2.x.219] . If   dim==spacedim==3, then the result is again a scalar with value  [2.x.220] , where  [2.x.221]  are   the images of the unit vectors at a vertex of the unit dim-dimensional   cell under transformation to the dim-dimensional cell in spacedim-   dimensional space. In both cases, i.e. for dim==2 or 3, the result   happens to equal the determinant of the Jacobian of the mapping from   reference cell to cell in real space. Note that it is the actual   determinant, not its absolute value as often used in transforming   integrals from one coordinate system to another. In particular, if the   object specified by the vertices is a parallelogram (i.e. a linear   transformation of the reference cell) then the computed values are the   same at all vertices and equal the (signed) area of the cell; similarly,   for parallel-epipeds, it is the volume of the cell.     Likewise, if we have dim==spacedim-1 (e.g. we have a quad in 3d space, or   a line in 2d), then the alternating product denotes the normal vector   (i.e. a rank-1 tensor, since spacedim-dim=1) to the object at each   vertex, where the normal vector's magnitude denotes the area element of   the transformation from the reference object to the object given by the   vertices. In particular, if again the mapping from reference object to   the object under consideration here is linear (not bi- or trilinear),   then the returned vectors are all %parallel, perpendicular to the mapped   object described by the vertices, and have a magnitude equal to the   area/volume of the mapped object. If dim=1, spacedim=2, then the returned   value is  [2.x.222] , where  [2.x.223]  is the image of the   sole unit vector of a line mapped to the line in 2d given by the   vertices; if dim=2, spacedim=3, then the returned values are  [2.x.224]  where  [2.x.225]  are the two three-dimensional vectors that are   tangential to the quad mapped into three-dimensional space.     This function is used in order to determine how distorted a cell is (see   the entry on    [2.x.226]  "distorted cells"   in the glossary).  
* [0.x.139]*
   For each face of the reference cell, this field stores the coordinate   direction in which its normal vector points. In <tt>dim</tt> dimension   these are the <tt>2*dim</tt> first entries of <tt>{0,0,1,1,2,2,3,3}</tt>.     Note that this is only the coordinate number. The actual direction of the   normal vector is obtained by multiplying the unit vector in this   direction with #unit_normal_orientation.  
* [0.x.140]*
   Orientation of the unit normal vector of a face of the reference cell. In   <tt>dim</tt> dimension these are the <tt>2*dim</tt> first entries of   <tt>{-1,1,-1,1,-1,1,-1,1}</tt>.     Each value is either <tt>1</tt> or <tt>-1</tt>, corresponding to a normal   vector pointing in the positive or negative coordinate direction,   respectively.     Note that this is only the  [2.x.227] standard orientation [2.x.228]  of faces. At   least in 3d, actual faces of cells in a triangulation can also have the   opposite orientation, depending on a flag that one can query from the   cell it belongs to. For more information, see the    [2.x.229]  "glossary"   entry on face orientation.  
* [0.x.141]*
   Unit normal vector (Point<dim>) of a face of the reference cell.     Note that this is only the  [2.x.230] standard orientation [2.x.231]  of faces. At   least in 3d, actual faces of cells in a triangulation can also have the   opposite orientation, depending on a flag that one can query from the   cell it belongs to. For more information, see the    [2.x.232]  "glossary"   entry on face orientation.  
* [0.x.142]*
   Unit tangential vectors (array of `dim-1` elements of Point<dim>) of a   face of the reference cell, arranged in a right-hand coordinate system   such that the cross product between the two vectors return the unit   normal vector.     Note that this is only the  [2.x.233] standard orientation [2.x.234]  of faces. At   least in 3d, actual faces of cells in a triangulation can also have the   opposite orientation, depending on a flag that one can query from the   cell it belongs to. For more information, see the    [2.x.235]  "glossary"   entry on face orientation.  
* [0.x.143]*
   List of numbers which denotes which face is opposite to a given face. Its   entries are the first <tt>2*dim</tt> entries of <tt>{ 1, 0, 3, 2, 5, 4,   7, 6}</tt>.  
* [0.x.144]*
   Exception  
* [0.x.145]*
   Exception  
* [0.x.146]

include/deal.II-translator/base/graph_coloring_0.txt
[0.x.0]*
 A namespace containing functions that can color graphs.

* 
* [0.x.1]*
     Given two sets of indices that are assumed to be sorted, determine     whether they will have a nonempty intersection. The actual intersection     is not computed.      [2.x.0]  indices1 A set of indices, assumed sorted.      [2.x.1]  indices2 A set of indices, assumed sorted.      [2.x.2]  Whether the two sets of indices do have a nonempty     intersection.    
* [0.x.2]*
     Create a partitioning of the given range of iterators using a     simplified version of the Cuthill-McKee algorithm (Breadth First Search     algorithm). The function creates partitions that contain "zones" of     iterators where the first partition contains the first iterator, the     second zone contains all those iterators that have conflicts with the     single element in the first zone, the third zone contains those     iterators that have conflicts with the iterators of the second zone and     have not previously been assigned to a zone, etc. If the iterators     represent cells, then this generates partitions that are like onion     shells around the very first cell. Note that elements in each zone may     conflict with other elements in the same zone.         The question whether two iterators conflict is determined by a user-     provided function. The meaning of this function is discussed in the     documentation of the  [2.x.3]  function.          [2.x.4]  begin The first element of a range of iterators for which a     partitioning is sought.      [2.x.5]  end The element past the end of the range of iterators.      [2.x.6]  get_conflict_indices A user defined function object     returning a set of indicators that are descriptive of what represents a     conflict. See above for a more thorough discussion.      [2.x.7]  A set of sets of iterators (where sets are represented by      [2.x.8]  for efficiency). Each element of the outermost set     corresponds to the iterators pointing to objects that are in the same     partition (i.e., the same zone).    
* [0.x.3]*
     This function uses DSATUR (Degree SATURation) to color the elements of     a set. DSATUR works as follows:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Arrange the vertices by decreasing order of degrees.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Color a vertex of maximal degree with color 1.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Choose a vertex with a maximal saturation degree. If there is        equality, choose any vertex of maximal degree in the uncolored        subgraph.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Color the chosen vertex with the least possible (lowest numbered)        color.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - If all the vertices are colored, stop. Otherwise, return to 3.          [2.x.9]  partition The set of iterators that should be colored.      [2.x.10]  get_conflict_indices A user defined function object     returning a set of indicators that are descriptive of what represents a     conflict. See above for a more thorough discussion.      [2.x.11]  partition_coloring A set of sets of iterators (where sets     are represented by  [2.x.12]  for efficiency). Each element of the     outermost set corresponds to the iterators pointing to objects that are     in the same partition (have the same color) and consequently do not     conflict. The elements of different sets may conflict.    
* [0.x.4]*
     Given a partition-coloring graph, i.e., a set of zones (partitions)     each of which is colored, produce a combined coloring for the entire     set of iterators. This is possible because any color on an even (resp.     odd) zone does not conflict with any color of any other even (resp.     odd) zone. Consequently, we can combine colors from all even and all     odd zones. This function tries to create colors of similar number of     elements.    
* [0.x.5]*
   Create a partitioning of the given range of iterators so that iterators   that point to conflicting objects will be placed into different   partitions, where the question whether two objects conflict is determined   by a user-provided function.     This function can also be considered as a graph coloring: each object   pointed to by an iterator is considered to be a node and there is an edge   between each two nodes that conflict. The graph coloring algorithm then   assigns a color to each node in such a way that two nodes connected by an   edge do not have the same color.     A typical use case for this function is in assembling a matrix in   parallel. There, one would like to assemble local contributions on   different cells at the same time (an operation that is purely local and   so requires no synchronization) but then we need to add these local   contributions to the global matrix. In general, the contributions from   different cells may be to the same matrix entries if the cells share   degrees of freedom and, consequently, can not happen at the same time   unless we want to risk a race condition (see   http://en.wikipedia.org/wiki/Race_condition). Thus, we call these two   cells in conflict, and we can only allow operations in parallel from   cells that do not conflict. In other words, two cells are in conflict if   the set of matrix entries (for example characterized by the rows) have a   nonempty intersection.     In this generality, computing the graph of conflicts would require   calling a function that determines whether two iterators (or the two   objects they represent) conflict, and calling it for every pair of   iterators, i.e.,  [2.x.13]  times. This is too expensive in   general. A better approach is to require a user-defined function that   returns for every iterator it is called for a set of indicators of some   kind that characterize a conflict; two iterators are in conflict if their   conflict indicator sets have a nonempty intersection. In the example of   assembling a matrix, the conflict indicator set would contain the indices   of all degrees of freedom on the cell pointed to (in the case of   continuous Galerkin methods) or the union of indices of degree of freedom   on the current cell and all cells adjacent to the faces of the current   cell (in the case of discontinuous Galerkin methods, because there one   computes face integrals coupling the degrees of freedom connected by a   common face
* 
*  -  see  [2.x.14] ).    
*  [2.x.15]  The conflict set returned by the user defined function passed as   third argument needs to accurately describe [1.x.0] degrees of freedom   for which anything is written into the matrix or right hand side. In   other words, if the writing happens through a function like    [2.x.16]  then the set of conflict   indices must actually contain not only the degrees of freedom on the   current cell, but also those they are linked to by constraints such as   hanging nodes.     In other situations, the conflict indicator sets may represent something   different altogether
* 
*  -  it is up to the caller of this function to   describe what it means for two iterators to conflict. Given this,   computing conflict graph edges can be done significantly more cheaply   than with  [2.x.17]  operations.     In any case, the result of the function will be so that iterators whose   conflict indicator sets have overlap will not be assigned to the same   color.    
*  [2.x.18]  The algorithm used in this function is described in a paper by   Turcksin, Kronbichler and Bangerth, see    [2.x.19] .      [2.x.20]  begin The first element of a range of iterators for which a   coloring is sought.    [2.x.21]  end The element past the end of the range of iterators.    [2.x.22]  get_conflict_indices A user defined function object returning   a set of indicators that are descriptive of what represents a conflict.   See above for a more thorough discussion.    [2.x.23]  A set of sets of iterators (where sets are represented by    [2.x.24]  for efficiency). Each element of the outermost set   corresponds to the iterators pointing to objects that are in the same   partition (have the same color) and consequently do not conflict. The   elements of different sets may conflict.  
* [0.x.6]*
    [2.x.25]  a wrapper function for    [2.x.26]  is an alternate method for   coloring using graph connections represented by SparsityPattern.   For further details, refer to  [2.x.27]   
* [0.x.7]

include/deal.II-translator/base/hdf5_0.txt
[0.x.0]*
 Namespace containing deal.II's HDF5 interface.
*  The [Hierarchical Data Format (HDF)](https://www.hdfgroup.org/) is a cross platform and a high I/O performance format designed to store large amounts of data. It supports serial and MPI I/O access. This set of classes provides an interface to the [HDF5 library](https://www.hdfgroup.org/downloads/hdf5/).
*  The tutorial  [2.x.0]  shows how to use deal.II's HDF5 interface.
*  # Groups, Datasets and attributes An HDF5 file is organized in [groups](https://bitbucket.hdfgroup.org/pages/HDFFV/hdf5doc/master/browse/html/UG/HDF5_Users_Guide-Responsive%20HTML5/HDF5_Users_Guide/Groups/HDF5_Groups.htm) and [datasets](https://bitbucket.hdfgroup.org/pages/HDFFV/hdf5doc/master/browse/html/UG/HDF5_Users_Guide-Responsive%20HTML5/HDF5_Users_Guide/Datasets/HDF5_Datasets.htm). Groups can contain datasets and other groups. Datasets are objects composed by a collection of data elements. Datasets are equivalent to tensors and matrices. In addition, attributes can be attached to the root file, a group or a dataset. An [HDF5 attribute](https://bitbucket.hdfgroup.org/pages/HDFFV/hdf5doc/master/browse/html/UG/HDF5_Users_Guide-Responsive%20HTML5/HDF5_Users_Guide/Attributes/HDF5_Attributes.htm) is a small meta data. The methods  [2.x.1]  and  [2.x.2]  can be used to get and set attributes.
*  An example is shown below

* 
* [1.x.0]
* 
*  # MPI I/O An HDF5 file can be opened/created with serial (one single process) or MPI support (several processes access the same HDF5 file).  [2.x.3]   [2.x.4]  &, const FileAccessMode) opens/creates an HDF5 file for serial operations.  [2.x.5]   [2.x.6]  &, const FileAccessMode, const MPI_Comm &) creates or opens an HDF5 file in parallel using MPI. The HDF5 calls that modify the structure of the file are always collective, whereas writing and reading raw data in a dataset can be done independently or collectively. [Collective access is usually faster](https://www.hdfgroup.org/2015/08/parallel-io-with-hdf5/) since it allows MPI to do optimizations. In the deal.II's HDF5 interface all the calls are set to collective in order to maximize the performance. This means that all the MPI processes have to contribute to every single call, even if they don't have data to write. MPI HDF5 requires that deal.II and HDF5 have been compiled with MPI support.
*  ## Write a hyperslab in parallel Hyperslabs are portions of datasets. A hyperslab can be a contiguous collection of points in a dataset, or it can be a regular pattern of points or blocks in a datataset. Hyperslabs are equivalent to python numpy and h5py [slices](http://docs.h5py.org/en/latest/high/dataset.html#reading-writing-data). See the [1.x.1]  section in the HDF5 User's Guide. See as well the [1.x.2].
*  The example below shows how to write a simple rectangular hyperslab. The offset defines the origin of the hyperslab in the original dataset. The dimensions of the hyperslab are `hyperslab_dimensions = {2, 5}`. Note that each process can write a hyperslab with a different size. If a process does not write any data at all, the process should call the function  [2.x.7]  because the operation iscollective* and all the MPI processes have to contribute to the call, even if they don't have data to write.

* 
* [1.x.3]
* 
*  The function  [2.x.8]  Container &,const  [2.x.9]  &, const  [2.x.10]  &) is used to write simple hyperslabs and the function  [2.x.11]  Container &,const  [2.x.12]  &, const  [2.x.13]  &, const  [2.x.14]  &, const  [2.x.15]  &, const  [2.x.16]  &) is used to write complex hyperslabs.
*  ## Write unordered data in parallel The example below shows how to write a selection of data. Note that each process can write a different amount of data. If a process does not write any data at all, the process should call the function  [2.x.17]  because the operation iscollective* and all the MPI processes have to contribute to the call, even if they don't have data to write. A more detailed example can be found in  [2.x.18] .

* 
* [1.x.4]
* 
*  ## Query the I/O mode that HDF5 used in the last parallel I/O call The default access mode in the deal.II's HDF5 C++ interface  is collective which is typically faster since it allows MPI to do more optimizations. In some cases, such as when there is type conversion, the HDF5 library can decide to do independent I/O instead of collective I/O, even if the user asks for collective I/O. See the following [article](https://www.hdfgroup.org/2015/08/parallel-io-with-hdf5/). In cases where maximum performance is a requirement, it is important to make sure that all MPI read/write operations are collective. The HDF5 library provides API routines that can be used after the read/write I/O operations to query the I/O mode. If  [2.x.19]  is True, then after every read/write operation the deal.II's HDF5 interface calls the routines [H5Pget_mpio_actual_io_mode()](https://support.hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-GetMpioActualIoMode) and [H5Pget_mpio_no_collective_cause()](https://support.hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-GetMpioNoCollectiveCause). The results are stored in  [2.x.20]   [2.x.21]  and  [2.x.22]  We suggest to query the I/O mode only in Debug mode because it requires calling additional HDF5 routines.
*  The following code can be used to query the I/O method.

* 
* [1.x.5]
* 
*  If the write operation was collective then the output should be

* 
* [1.x.6]
*  See  [2.x.23]   [2.x.24]  and  [2.x.25]  for all the possible return codes.
*  # Rank of HDF5 datasets and hyperslabs The deal.II's HDF5 interface can be used to write/read data to datasets and hyperslabs of any particular rank. `FullMatrix` can only be used to write/read data to datasets and hyperslabs of rank 2. In the other hand,  [2.x.26]  and `Vector` can be used to write/read data to datasets and hyperslabs of rank 1, 2, 3 and higher, the data is organized in [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order) which is commonly used in C and C++ matrices. We can re-write the code from the previous section using  [2.x.27] 

* 
* [1.x.7]
*  The previous code writes the following hyperslab matrix

* 
* [1.x.8]
* 
*  # Datatypes Attribute datatypes can be float, `double`,  [2.x.28]   [2.x.29]  `int`, `unsigned int`, `bool` and  [2.x.30]   [2.x.31]  and  [2.x.32]  can be used with all of these datatypes.
*  Dataset datatypes can be `float`, `double`,  [2.x.33]   [2.x.34]  `int` and `unsigned int`.  [2.x.35]   [2.x.36]   [2.x.37]  etc. can be used with all of these datatypes. Note that the dataset datatype can not be `bool`, the reason is that it can not be assumed that  [2.x.38]  stores the elements in a contiguous way.
* 

*  ## Complex numbers and HDF5 There is no official HDF5 format to store  [2.x.39]  numbers in a HDF5 file. But thede facto* standard is to store the  [2.x.40]  number in a compound type in which `r` corresponds to the real part and `i` corresponds to the imaginary part. In this interface we define two compound types one for  [2.x.41]  which corresponds to `(double,double)` and another one for  [2.x.42]  which corresponds to `(float,float)`. These two types correspond respectively to the types of python/numpy/h5py: `complex128` and `complex64`. This means that the files generated by this interface will be read correctly by python/numpy/h5py and at the same time this interface is able to read the files generated by python/numpy/h5py.
*  # Data exchange with python scripts The HDF5 format can be used to exchange data with python scripts. The strings are stored as HDF5 variable-length UTF-8 strings and the complex numbers, as explained above, are stored as HDF5 compound datatypes compatible with [h5py](https://www.h5py.org/) and [numpy](http://www.numpy.org/).
*  The following python script writes the parameters for a deal.II simulation: ~~~~~~~~~~~~~{.py} h5_file = h5py.File('simulation.hdf5','w') data = h5_file.create_group('data') data.attrs['nb_frequency_points'] = 50 # int data.attrs['rho'] = 2300.5 # double data.attrs['save_vtk_files'] = True # bool data.attrs['simulation_type'] = 'elastic_equation' # utf8 string ~~~~~~~~~~~~~
*  C++ deal.II simulation with MPI HDF5:

* 
* [1.x.9]
* 
*  Read the simulation results with python: ~~~~~~~~~~~~~{.py} h5_file = h5py.File('simulation.hdf5','r+') data = h5_file['data'] displacement = data['displacement'] # complex128 dtype active_cells = data.attrs['degrees_of_freedom']) ~~~~~~~~~~~~~
*  # HDF5 and thread safety By default HDF5 is not thread-safe. The HDF5 library can be configured to be thread-safe, see [the HDF5 documentation](https://support.hdfgroup.org/HDF5/faq/threadsafe.html). The thread-safe HDF5 version serializes the API but does not provide any level of concurrency. To achieve high parallel performance with HDF5, we advice to use HDF5 with MPI.

* 
* [0.x.1]*
   Base class for the HDF5 objects.  
* [0.x.2]*
     Constructor.  [2.x.43]  is the name of the HDF5 Object. If  [2.x.44]  is     True then MPI I/O is used.    
* [0.x.3]*
     Reads an attribute.  [2.x.45]  can be `float`, `double`,  [2.x.46]       [2.x.47]  `int`, `unsigned int`, `bool` or  [2.x.48]      Note that the encoding of  [2.x.49]  is UTF8 in order to be compatible     with python3.         Datatype conversion takes place at the time of a read or write and is     automatic. See the [1.x.10]  section in the HDF5     User's Guide.    
* [0.x.4]*
     Writes an attribute.  [2.x.50]  can be `float`, `double`,  [2.x.51]       [2.x.52]  `int`, `unsigned int`, `bool` or  [2.x.53]      Note that the encoding of  [2.x.54]  is UTF8 in order to be compatible     with python3.         Datatype conversion takes place at the time of a read or write and is     automatic. See the [1.x.11]  section in the HDF5     User's Guide.    
* [0.x.5]*
     Returns the #name of the object. In the case of File, #name corresponds     to the file name. In the case of Group and DataSet, #name corresponds to     the name of the object in the HDF5 file.    
* [0.x.6]*
     Name of the HDF5Oject. In the case of File,  [2.x.55]  corresponds to the     file name. In the case of Group and DataSet  [2.x.56]  corresponds to the     name of the object in the HDF5 file.    
* [0.x.7]*
     HDF5 identifier for the objects File, Group and DataSet. The      [2.x.57]  pointer allows the object to be copied. For example     several parts of the program can share and access the same group; when     all the functions that access the group are closed, the HDF5 resources of     the group will be automatically released.    
* [0.x.8]*
     If true use parallel HDF5, if false use serial HDF5.    
* [0.x.9]*
   This class implements an HDF5 DataSet.  
* [0.x.10]*
     Open dataset. This is an internal constructor. The function      [2.x.58]  should be used to open a dataset.    
* [0.x.11]*
     Create dataset. This is an internal constructor. The function      [2.x.59]  should be used to create a dataset.    
* [0.x.12]*
     Reads all the data of the dataset.         Datatype conversion takes place at the time of the read operation and is     automatic. See the [1.x.12]  section in the HDF5     User's Guide.         `Container` can be  [2.x.60]   [2.x.61]       [2.x.62]   [2.x.63]       [2.x.64]   [2.x.65]  int>`, `Vector<float>`,     `Vector<double>`,  [2.x.66]       [2.x.67]  `FullMatrix<float>`,     `FullMatrix<double>`,  [2.x.68]  or      [2.x.69]     
* [0.x.13]*
     Reads data of a subset of the dataset.         Datatype conversion takes place at the time of the read operation and is     automatic. See the [1.x.13]  section in the HDF5     User's Guide.         The selected elements can be scattered and take any shape in the dataset.     For example, in the case of a dataset with rank 4 a selection of 3 points     will be described by a 3-by-4 array. Note the indexing is zero-based. To     select the points (1,1,1,1), (14,6,12,18), and (8,22,30,22), the point     selection array would be as follows:        
* [1.x.14]
*          [1.x.15]         Datatype conversion takes place at the time of the read operation and is     automatic. See the [1.x.16]  section in the HDF5     User's Guide.    
* [0.x.14]*
     Reads a hyperslab from the dataset. The parameters are summarized     below:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.70]  The starting location for the hyperslab.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.71]  The number of elements to select along each dimension.         When reading a hyperslab, HDF5 also allows to provide "stride" and     "block" parameters (see the [HDF5 documentation](https://support.hdfgroup.org/HDF5/doc1.8/RM/RM_H5S.html#Dataspace-SelectHyperslab)).     These are not used by the current function and set to `nullptr`. However     these parameters can be used with the function     read_hyperslab(const  [2.x.72]  &, const  [2.x.73]  &, const  [2.x.74]  &, const  [2.x.75]  &, const  [2.x.76]  &)         See the [1.x.17]  section in the HDF5 User's Guide. See as well the     [1.x.18].         Datatype conversion takes place at the time of a read or write and is     automatic. See the [1.x.19]  section in the HDF5     User's Guide.         `Container` can be  [2.x.77]   [2.x.78]       [2.x.79]   [2.x.80]       [2.x.81]   [2.x.82]  int>`, `Vector<float>`,     `Vector<double>`,  [2.x.83]       [2.x.84]  `FullMatrix<float>`,     `FullMatrix<double>`,  [2.x.85]  or      [2.x.86]     
* [0.x.15]*
     Writes a data hyperslab to the dataset. The parameters are summarized     below:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.87]  the dimensions of the data memory block.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.88]  The starting location for the hyperslab.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.89]  The number of elements to separate each element or block to                   be selected.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.90]  The number of elements or blocks to select along each                  dimension.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.91]  The size of the block selected from the dataspace.         See the [1.x.20]  section in the HDF5 User's Guide. See as well the     [1.x.21].         Datatype conversion takes place at the time of a read or write and is     automatic. See the [1.x.22]  section in the HDF5     User's Guide.         `Container` can be  [2.x.92]   [2.x.93]       [2.x.94]   [2.x.95]       [2.x.96]   [2.x.97]  int>`, `Vector<float>`,     `Vector<double>`,  [2.x.98]       [2.x.99]  `FullMatrix<float>`,     `FullMatrix<double>`,  [2.x.100]  or      [2.x.101]     
* [0.x.16]*
     This function does not read any data, but it can contribute to a     collective read call.  [2.x.102]  can be `float`, `double`,      [2.x.103]   [2.x.104]  `int` or `unsigned int`.         Datatype conversion takes place at the time of a read or write and is     automatic. See the [1.x.23]  section in the HDF5     User's Guide.    
* [0.x.17]*
     Writes data in the dataset.  [2.x.105]  can be `float`, `double`,      [2.x.106]   [2.x.107]  `int` or `unsigned int`.         Datatype conversion takes place at the time of a read or write and is     automatic. See the [1.x.24]  section in the HDF5     User's Guide.         `Container` can be  [2.x.108]   [2.x.109]       [2.x.110]   [2.x.111]       [2.x.112]   [2.x.113]  int>`, `Vector<float>`,     `Vector<double>`,  [2.x.114]       [2.x.115]  `FullMatrix<float>`,     `FullMatrix<double>`,  [2.x.116]  or      [2.x.117]     
* [0.x.18]*
     Writes data to a subset of the dataset.  [2.x.118]  can be `float`, `double`,      [2.x.119]   [2.x.120]  `int` or `unsigned int`.         The selected elements can be scattered and take any shape in the dataset.     For example, in the case of a dataset with rank 4 a selection of 3 points     will be described by a 3-by-4 array. Note the indexing is zero-based. To     select the points (1,1,1,1), (14,6,12,18), and (8,22,30,22), the point     selection array would be as follows:        
* [1.x.25]
*          [1.x.26]         Datatype conversion takes place at the time of a read or write and is     automatic. See the [1.x.27]  section in the HDF5     User's Guide.    
* [0.x.19]*
     Writes a data hyperslab to the dataset. The parameters are summarized     below:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.121]  The starting location for the hyperslab.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.122]  The number of elements to select along each dimension.         When writing a hyperslab, HDF5 also allows to provide "stride" and     "block" parameters (see the [HDF5 documentation](https://support.hdfgroup.org/HDF5/doc1.8/RM/RM_H5S.html#Dataspace-SelectHyperslab)).     These are not used by the current function and set to `nullptr`. However     these parameters can be used with the function     write_hyperslab(const Container &data, const  [2.x.123]  &data_dimensions, const  [2.x.124]  &offset, const  [2.x.125]  &stride, const  [2.x.126]  &count, const  [2.x.127]  &block).         See the [1.x.28]  section in the HDF5 User's Guide. See as well the     [1.x.29].         Datatype conversion takes place at the time of a read or write and is     automatic. See the [1.x.30]  section in the HDF5     User's Guide.    
* [0.x.20]*
     Writes a data hyperslab to the dataset. The parameters are summarized     below:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.128]  the dimensions of the data memory block.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.129]  The starting location for the hyperslab.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.130]  The number of elements to separate each element or block to be                   selected.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.131]  The number of elements or blocks to select along each                  dimension.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.132]  The size of the block selected from the dataspace.         See the [1.x.31]  section in the HDF5 User's Guide. See as well the     [1.x.32].         Datatype conversion takes place at the time of a read or write and is     automatic. See the [1.x.33]  section in the HDF5     User's Guide.         `Container` can be  [2.x.133]   [2.x.134]       [2.x.135]   [2.x.136]       [2.x.137]   [2.x.138]  int>`, `Vector<float>`,     `Vector<double>`,  [2.x.139]       [2.x.140]  `FullMatrix<float>`,     `FullMatrix<double>`,  [2.x.141]  or      [2.x.142]     
* [0.x.21]*
     This function does not write any data, but it can contribute to a     collective write call. In the context of a collective MPI write call,     if a process does not write any data at all, the process should call     this function because the operation iscollective* and all the MPI     processes have to contribute to the call, even if they don't have data     to write.  [2.x.143]  can be `float`, `double`,  [2.x.144]       [2.x.145]  `int` or `unsigned int`.         Datatype conversion takes place at the time of a read or write and is     automatic. See the [1.x.34]  section in the HDF5     User's Guide.         An example of how to use this function can be found in  [2.x.146] .    
* [0.x.22]*
     This function returns the boolean query_io_mode.         In cases where maximum performance has to be achieved, it is important to     make sure that all MPI read/write operations are collective. The HDF5     library provides API routines that can be used after the read/write I/O     operations to query the I/O mode. If query_io_mode is set to true, then     after every read/write operation the deal.II's HDF5 interface calls the     routines     [H5Pget_mpio_actual_io_mode()](https://support.hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-GetMpioActualIoMode)     and     [H5Pget_mpio_no_collective_cause()](https://support.hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-GetMpioNoCollectiveCause).     The results are stored in io_mode, local_no_collective_cause and     global_no_collective_cause. We suggest to query the I/O mode only in     Debug mode because it requires calling additional HDF5 routines.    
* [0.x.23]*
     This function sets the boolean query_io_mode.    
* [0.x.24]*
     This function returns the I/O mode that was used on the last     parallel I/O call. See [1.x.35].         The return value is a  [2.x.147]  and can be     Value                          | Meaning
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - ---------------------------- |
* 
*  - -----     H5D_MPIO_NO_COLLECTIVE         | No collective I/O was performed. Collective I/O was not requested or collective I/O isn't possible on this dataset.     H5D_MPIO_CHUNK_INDEPENDENT     | HDF5 performed chunk collective optimization schemes and each chunk was accessed independently.     H5D_MPIO_CHUNK_COLLECTIVE      | HDF5 performed chunk collective optimization and each chunk was accessed collectively.     H5D_MPIO_CHUNK_MIXED           | HDF5 performed chunk collective optimization and some chunks were accessed independently, some collectively.     H5D_MPIO_CONTIGUOUS_COLLECTIVE | Collective I/O was performed on a contiguous dataset.    
* [0.x.25]*
     This function returns the I/O mode that was used on the last     parallel I/O call. See [1.x.36].     The return type is `H5D_mpio_actual_io_mode_t` which corresponds to the     value returned by H5Pget_mpio_actual_io_mode.         The return value can be     Value                          | Meaning
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - ---------------------------- |
* 
*  - -----     H5D_MPIO_NO_COLLECTIVE         | No collective I/O was performed. Collective I/O was not requested or collective I/O isn't possible on this dataset.     H5D_MPIO_CHUNK_INDEPENDENT     | HDF5 performed chunk collective optimization and each chunk was accessed independently.     H5D_MPIO_CHUNK_COLLECTIVE      | HDF5 performed chunk collective optimization and each chunk was accessed collectively.     H5D_MPIO_CHUNK_MIXED           | HDF5 performed chunk collective optimization and some chunks were accessed independently, some collectively.     H5D_MPIO_CONTIGUOUS_COLLECTIVE | Collective I/O was performed on a contiguous dataset.    
* [0.x.26]*
     This function returns the local causes that broke collective I/O on the     last parallel I/O call. See [1.x.37].         The return value is a string and can be     Value                                      | Meaning
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - ---------------------------------------- |
* 
*  - -----     H5D_MPIO_COLLECTIVE                        | Collective I/O was performed successfully.     H5D_MPIO_SET_INDEPENDENT                   | Collective I/O was not performed because independent I/O was requested.     H5D_MPIO_DATATYPE_CONVERSION               | Collective I/O was not performed because datatype conversions were required.     H5D_MPIO_DATA_TRANSFORMS                   | Collective I/O was not performed because data transforms needed to be applied.     H5D_MPIO_SET_MPIPOSIX                      | Collective I/O was not performed because the selected file driver was MPI-POSIX.     H5D_MPIO_NOT_SIMPLE_OR_SCALAR_DATASPACES   | Collective I/O was not performed because one of the dataspaces was neither simple nor scalar.     H5D_MPIO_POINT_SELECTIONS                  | Collective I/O was not performed because there were point selections in one of the dataspaces.     H5D_MPIO_NOT_CONTIGUOUS_OR_CHUNKED_DATASET | Collective I/O was not performed because the dataset was neither contiguous nor chunked.     H5D_MPIO_FILTERS                           | Collective I/O was not performed because filters needed to be applied.    
* [0.x.27]*
     This function returns the local causes that broke collective I/O on the     last parallel I/O call. See [1.x.38].     The return type is `uint32_t` and corresponds to the value returned by     [H5Pget_mpio_no_collective_cause](https://support.hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-GetMpioNoCollectiveCause).         The return value can be     Value                                      | Meaning
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - ---------------------------------------- |
* 
*  - -----     H5D_MPIO_COLLECTIVE                        | Collective I/O was performed successfully.     H5D_MPIO_SET_INDEPENDENT                   | Collective I/O was not performed because independent I/O was requested.     H5D_MPIO_DATATYPE_CONVERSION               | Collective I/O was not performed because datatype conversions were required.     H5D_MPIO_DATA_TRANSFORMS                   | Collective I/O was not performed because data transforms needed to be applied.     H5D_MPIO_SET_MPIPOSIX                      | Collective I/O was not performed because the selected file driver was MPI-POSIX.     H5D_MPIO_NOT_SIMPLE_OR_SCALAR_DATASPACES   | Collective I/O was not performed because one of the dataspaces was neither simple nor scalar.     H5D_MPIO_POINT_SELECTIONS                  | Collective I/O was not performed because there were point selections in one of the dataspaces.     H5D_MPIO_NOT_CONTIGUOUS_OR_CHUNKED_DATASET | Collective I/O was not performed because the dataset was neither contiguous nor chunked.     H5D_MPIO_FILTERS                           | Collective I/O was not performed because filters needed to be applied.    
* [0.x.28]*
     This function retrieves the global causes that broke collective I/O on     the last parallel I/O call. See [1.x.39].         The return value is a  [2.x.148]  and can be     Value                                      | Meaning
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - ---------------------------------------- |
* 
*  - -----     H5D_MPIO_COLLECTIVE                        | Collective I/O was performed successfully.     H5D_MPIO_SET_INDEPENDENT                   | Collective I/O was not performed because independent I/O was requested.     H5D_MPIO_DATATYPE_CONVERSION               | Collective I/O was not performed because datatype conversions were required.     H5D_MPIO_DATA_TRANSFORMS                   | Collective I/O was not performed because data transforms needed to be applied.     H5D_MPIO_SET_MPIPOSIX                      | Collective I/O was not performed because the selected file driver was MPI-POSIX.     H5D_MPIO_NOT_SIMPLE_OR_SCALAR_DATASPACES   | Collective I/O was not performed because one of the dataspaces was neither simple nor scalar.     H5D_MPIO_POINT_SELECTIONS                  | Collective I/O was not performed because there were point selections in one of the dataspaces.     H5D_MPIO_NOT_CONTIGUOUS_OR_CHUNKED_DATASET | Collective I/O was not performed because the dataset was neither contiguous nor chunked.     H5D_MPIO_FILTERS                           | Collective I/O was not performed because filters needed to be applied.    
* [0.x.29]*
     This function returns the global causes that broke collective I/O on the     last parallel I/O call. See [1.x.40].     The return type is `uint32_t` and corresponds to the value returned by     H5Pget_mpio_no_collective_cause.         The return value can be     Value                                      | Meaning
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - ---------------------------------------- |
* 
*  - -----     H5D_MPIO_COLLECTIVE                        | Collective I/O was performed successfully.     H5D_MPIO_SET_INDEPENDENT                   | Collective I/O was not performed because independent I/O was requested.     H5D_MPIO_DATATYPE_CONVERSION               | Collective I/O was not performed because datatype conversions were required.     H5D_MPIO_DATA_TRANSFORMS                   | Collective I/O was not performed because data transforms needed to be applied.     H5D_MPIO_SET_MPIPOSIX                      | Collective I/O was not performed because the selected file driver was MPI-POSIX.     H5D_MPIO_NOT_SIMPLE_OR_SCALAR_DATASPACES   | Collective I/O was not performed because one of the dataspaces was neither simple nor scalar.     H5D_MPIO_POINT_SELECTIONS                  | Collective I/O was not performed because there were point selections in one of the dataspaces.     H5D_MPIO_NOT_CONTIGUOUS_OR_CHUNKED_DATASET | Collective I/O was not performed because the dataset was neither contiguous nor chunked.     H5D_MPIO_FILTERS                           | Collective I/O was not performed because filters needed to be applied.    
* [0.x.30]*
     This function returns the dimensions of the dataset. The vector     dimensions is a one-dimensional array of size rank specifying the size of     each dimension of the dataset.    
* [0.x.31]*
     This function returns the total number of elements in the dataset.    
* [0.x.32]*
     This function returns the rank of the dataset.    
* [0.x.33]*
     Rank of the DataSet    
* [0.x.34]*
     The vector `dimensions` is a one-dimensional array of size rank     specifying the size of each dimension of the dataset.    
* [0.x.35]*
     HDF5 dataspace identifier.    
* [0.x.36]*
     Total number of elements in the dataset.    
* [0.x.37]*
     If query_io_mode is set to true, then after every read/write operation     the deal.II's HDF5 interface calls the routines     [H5Pget_mpio_actual_io_mode()](https://support.hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-GetMpioActualIoMode)     and     [H5Pget_mpio_no_collective_cause()](https://support.hdfgroup.org/HDF5/doc/RM/RM_H5P.html#Property-GetMpioNoCollectiveCause).     The results are stored in io_mode, local_no_collective_cause and     global_no_collective_cause.    
* [0.x.38]*
     I/O mode that was performed on the last parallel I/O call.    
* [0.x.39]*
     Local causes that broke collective I/O on the     last parallel I/O call. See [1.x.41].    
* [0.x.40]*
     Global causes that broke collective I/O on the     last parallel I/O call. See [1.x.42].    
* [0.x.41]*
   This class implements an HDF5 Group  
* [0.x.42]*
     Group access mode    
* [0.x.43]*
       Opens an existing group      
* [0.x.44]*
       Creates a new group      
* [0.x.45]*
     This constructor creates or opens a group depending on the value of      [2.x.149]  The group will be placed inside the group  [2.x.150]  The     parameter  [2.x.151]  defines if the I/O operations are serial or     parallel. This is an internal constructor, the functions open_group() and     create_group() of the current class should be used to open or create a     group.    
* [0.x.46]*
     Internal constructor used by File. The constructor sets the protected     const members of HDF5Group:  [2.x.152]  and  [2.x.153]  It does not create or     open a Group.    
* [0.x.47]*
     Opens a sub-group of the current Group or File.    
* [0.x.48]*
     Creates a sub-group in the current Group or File.    
* [0.x.49]*
     Opens a dataset.    
* [0.x.50]*
     Creates a dataset.  [2.x.154]  can be `float`, `double`,      [2.x.155]   [2.x.156]  `int` or `unsigned int`.         Datatype conversion takes place at the time of a read or write and is     automatic. See the [1.x.43]  section in the HDF5     User's Guide.    
* [0.x.51]*
     Create and write data to a dataset.  [2.x.157]  can be `float`, `double`,      [2.x.158]   [2.x.159]  `int` or `unsigned int`.         Datatype conversion takes place at the time of a read or write and is     automatic. See the [1.x.44]  section in the HDF5     User's Guide.         `Container` can be  [2.x.160]   [2.x.161]       [2.x.162]   [2.x.163]       [2.x.164]   [2.x.165]  int>`, `Vector<float>`,     `Vector<double>`,  [2.x.166]       [2.x.167]  `FullMatrix<float>`,     `FullMatrix<double>`,  [2.x.168]  or      [2.x.169]     
* [0.x.52]*
   This class implements an HDF5 File  
* [0.x.53]*
     File access mode    
* [0.x.54]*
       Read/write, file must exist      
* [0.x.55]*
       Create file, truncate if exists      
* [0.x.56]*
     Creates or opens an HDF5 file for serial operations. This call does not     require MPI support. It creates or opens an HDF5 file depending on the     value of  [2.x.170]     
* [0.x.57]*
     Creates or opens an HDF5 file in parallel using MPI. This requires that     deal.II and HDF5 were compiled with MPI support. It creates or opens a     HDF5 file depending on the value of  [2.x.171]   [2.x.172]      defines the processes that participate in this call; `MPI_COMM_WORLD` is     a common value for the MPI communicator.    
* [0.x.58]*
     Delegation internal constructor.     File(const  [2.x.173]  &, const MPI_Comm &, const Mode);     and     File(const  [2.x.174]  &, const Mode)     should be used to open or create HDF5 files.    
* [0.x.59]* This function returns the HDF5 datatype corresponding to the C++ type.     In the case of  [2.x.175]  types the HDF5 handlers are automatically     freed using the destructor of  [2.x.176]   [2.x.177]  is     used instead of  [2.x.178]  because the destructor of      [2.x.179]  doesn't have to be defined in the template argument. In     the other hand, the destructor of  [2.x.180]  has to be defined in the     template argument. Native types such as `H5T_NATIVE_DOUBLE` do not     require a destructor, but compound types such as  [2.x.181]      require a destructor to free the HDF5 resources.    
* [0.x.60]* Return the dimensions of `data`. For a  [2.x.182]  this function returns      [2.x.183]          Several HDF5 functions such as H5Screate_simple() require a     one-dimensional array that specifies the size of each dimension of the     container, see:     https://support.hdfgroup.org/HDF5/doc1.8/RM/RM_H5S.html#Dataspace-CreateSimple    
* [0.x.61]* Return the dimensions of `data`. For a Vector this function returns      [2.x.184]     
* [0.x.62]* Return the dimensions of `data`. For a FullMatrix the function returns      [2.x.185]  columns}`.    
* [0.x.63]* This function returns the total size of the container. For a  [2.x.186]      the function returns `int(vector_size)`.    
* [0.x.64]* This function returns the total size of the container. For a Vector the     function returns `int(vector_size)`.    
* [0.x.65]* This function returns the total size of the container. For a FullMatrix     the function returns `int(rows*columns)`.    
* [0.x.66]* This function initializes and returns a container of type  [2.x.187]      Vector or FullMatrix. The function does not set the values of the     elements of the container. The container can store data of a HDF5 dataset     or a HDF5 selection. The dimensions parameter holds the dimensions of the     HDF5 dataset or selection.         In the case of a  [2.x.188]  the size of the vector will be the total     size given by dimensions. For example in the case of a dataset of rank 3,     the dimensions are  [2.x.189]  The size of     the returned  [2.x.190]  will be `dim_0*dim_1*dim_2`.         In the case of a  [2.x.191]  the size of the returned  [2.x.192]      will be as well `dim_0*dim_1*dim_2`.         A FullMatrix can store only data of HDF5 datasets with rank 2. The size     of the FullMatrix will be FullMatrix(dim_0,dim_2)    
* [0.x.67]* Same as above.    
* [0.x.68]* Same as above.    
* [0.x.69]* This helper function sets the property list of the read and write     operations of DataSet. A property list has to be created for the MPI     driver. For the serial driver the default H5P_DEFAULT can be used. In     addition H5Pset_dxpl_mpio is used to set the MPI mode to collective.    
* [0.x.70]* This helper function releases the property list handler of the read and     write operations of DataSet. For the serial version there is no need to     release the property list handler because H5P_DEFAULT has been used. If     query_io_mode is True then H5Pget_mpio_actual_io_mode and     H5Pget_mpio_no_collective_cause are used to check if the operation has     been collective.    
* [0.x.71]* Convert a HDF5 no_collective_cause code to a human readable string.    
* [0.x.72]     Create scalar attribute.    
* [0.x.73]     Write scalar attribute.    
* [0.x.74]     Create scalar attribute.    
* [0.x.75]     Write scalar attribute.     In most of the cases H5Awrite and H5Dwrite take a pointer to the data.     But in the particular case of a variable length string, H5Awrite takes     the address of the pointer of the string.    
* [0.x.76]

include/deal.II-translator/base/incremental_function_0.txt
[0.x.0]*
   This class represents an incremental function. That is, given an arbitrary   function  [2.x.0] , this class will return   <code>f(t)
* 
*  - f(t
* 
*  - delta_t)</code>, where  [2.x.1]  denotes the   function evaluated at time  [2.x.2]  and, likewise, <code>f(t
* 
*  -   delta_t)</code> denotes the function evaluated at time <code>t
* 
*  -   delta_t</code>. The decrement  [2.x.3]  is set by the method   set_decrement(). The main application of this class is to transform a given   Dirichlet boundary condition function into incremental form, as is   required by some implementations of non-linear solution schemes.    
*  [2.x.4]   
* [0.x.1]*
     Export the value of the template parameter as a static member constant.     This is sometimes useful in the context of template programming.    
* [0.x.2]*
     The scalar-valued real type used for representing time.    
* [0.x.3]*
     Constructor which wraps a given function  [2.x.5]         
*  [2.x.6]  This class stores a non-constant reference to  [2.x.7]      and will call  [2.x.8]  during evaluation     in order to evaluate the  [2.x.9]  class at any arbitrary time.     It is guaranteed that the temporal state of  [2.x.10]  is returned     to its original settings after each function evaluation in this     class.    
* [0.x.4]*
     Return the value of the function at the given point.         Unless there is only one component (i.e. the function is scalar), you     should state the component you want to have evaluated. By default, the     value of the first component is computed.    
* [0.x.5]*
     Return all components of a vector-valued function at a given point.         It is required that the  [2.x.11]  vector have the correct size before     this function is called.    
* [0.x.6]*
     Set the time decrement.         It is expected that this value be positive.    
* [0.x.7]*
     A reference to the function being wrapped.    
* [0.x.8]*
     The time decrement.    
* [0.x.9]*
     An auxiliary vector to store values.    
* [0.x.10]*
     Thread mutex for supporting evaluation in multi-threaded contexts.    
* [0.x.11]

include/deal.II-translator/base/index_set_0.txt
[0.x.0]*
 A class that represents a subset of indices among a larger set. For example, it can be used to denote the set of degrees of freedom within the range  [2.x.0]  that belongs to a particular subdomain, or those among all degrees of freedom that are stored on a particular processor in a distributed parallel computation.
*  This class can represent a collection of half-open ranges of indices as well as individual elements. For practical purposes it also stores the overall range these indices can assume. In other words, you need to specify the size of the index space  [2.x.1]  of which objects of this class are a subset.
*  There are two ways to iterate over the IndexSets: First, begin() and end() allow iteration over individual indices in the set. Second, begin_interval() and end_interval() allow iteration over the half-open ranges as described above.
*  The data structures used in this class along with a rationale can be found in the  [2.x.2]  "Distributed Computing paper".

* 
* [0.x.1]*
    [2.x.3]  is the type used for storing the size and the individual   entries in the IndexSet.  
* [0.x.2]*
   One can see an IndexSet as a container of size size(), where the elements   of the containers are bool values that are either false or true,   depending on whether a particular index is an element of the IndexSet or   not. In other words, an IndexSet is a bit like a vector in which the   elements we store are booleans. In this view, the correct local alias   indicating the type of the elements of the vector would then be  [2.x.4]      On the other hand,  [2.x.5]  has the disadvantage that it is not a   numerical type that, for example, allows multiplication with a  [2.x.6]    In other words, one can not easily use a vector of booleans in a place   where other vectors are allowed. Consequently, we declare the type of the   elements of such a vector as a signed integer. This uses the fact that in   the C++ language, booleans are implicitly convertible to integers. In   other words, declaring the type of the elements of the vector as a signed   integer is only a small lie, but it is a useful one.  
* [0.x.3]*
   Default constructor.  
* [0.x.4]*
   Constructor that also sets the overall size of the index range.  
* [0.x.5]*
   Copy constructor.  
* [0.x.6]*
   Copy assignment operator.  
* [0.x.7]*
   Move constructor. Create a new IndexSet by transferring the internal data   of the input set.  
* [0.x.8]*
   Move assignment operator. Transfer the internal data of the input set into   the current one.  
* [0.x.9]*
   Constructor from a Trilinos Epetra_BlockMap.  
* [0.x.10]*
   Remove all indices from this index set. The index set retains its size,   however.  
* [0.x.11]*
   Set the maximal size of the indices upon which this object operates.     This function can only be called if the index set does not yet contain   any elements.  This can be achieved by calling clear(), for example.  
* [0.x.12]*
   Return the size of the index space of which this index set is a subset   of.     Note that the result is not equal to the number of indices within this   set. The latter information is returned by n_elements().  
* [0.x.13]*
   Add the half-open range  [2.x.7]  to the set of indices   represented by this class.    [2.x.8]  begin The first element of the range to be added.    [2.x.9]  end The past-the-end element of the range to be added.  
* [0.x.14]*
   Add an individual index to the set of indices.  
* [0.x.15]*
   Add a whole set of indices described by dereferencing every element of   the iterator range  [2.x.10] .      [2.x.11]  begin Iterator to the first element of range of indices to be   added    [2.x.12]  end The past-the-end iterator for the range of elements to be   added.  [2.x.13]  The condition  [2.x.14]  needs to be satisfied.  
* [0.x.16]*
   Add the given IndexSet  [2.x.15]  to the current one, constructing the   union ofthis and  [2.x.16]      If the  [2.x.17]  argument is nonzero, then every index in  [2.x.18]  is   shifted by  [2.x.19]  before being added to the current index set. This   allows to construct, for example, one index set from several others that   are supposed to represent index sets corresponding to different ranges   (e.g., when constructing the set of nonzero entries of a block vector   from the sets of nonzero elements of the individual blocks of a vector).     This function will generate an exception if any of the (possibly shifted)   indices of the  [2.x.20]  index set lie outside the range    [2.x.21]  represented by the current object.  
* [0.x.17]*
   Return whether the specified index is an element of the index set.  
* [0.x.18]*
   Return whether the index set stored by this object defines a contiguous   range. This is true also if no indices are stored at all.  
* [0.x.19]*
   Return whether the index set stored by this object contains no elements.   This is similar, but faster than checking  [2.x.22] .  
* [0.x.20]*
   Return whether the IndexSets are ascending with respect to MPI process   number and 1:1, i.e., each index is contained in exactly one IndexSet   (among those stored on the different processes), each process stores   contiguous subset of indices, and the index set on process  [2.x.23]  starts   at the index one larger than the last one stored on process  [2.x.24] .   In case there is only one MPI process, this just means that the IndexSet   is complete.  
* [0.x.21]*
   Return the number of elements stored in this index set.  
* [0.x.22]*
   Return the global index of the local index with number  [2.x.25]    stored in this index set.  [2.x.26]  obviously needs to be less than   n_elements().  
* [0.x.23]*
   Return the how-manyth element of this set (counted in ascending order)  [2.x.27]    global_index is.  [2.x.28]  needs to be less than the size(). This   function returns  [2.x.29]  if the index  [2.x.30]  is not actually   a member of this index set, i.e. if is_element(global_index) is false.  
* [0.x.24]*
   Each index set can be represented as the union of a number of contiguous   intervals of indices, where if necessary intervals may only consist of   individual elements to represent isolated members of the index set.     This function returns the minimal number of such intervals that are   needed to represent the index set under consideration.  
* [0.x.25]*
   This function returns the local index of the beginning of the largest   range.     In other words, the return value is nth_index_in_set(x), where x is the   first index of the largest contiguous range of indices in the   IndexSet. The return value is therefore equal to the number of elements   in the set that come before the largest range.     This call assumes that the IndexSet is nonempty.  
* [0.x.26]*
   Compress the internal representation by merging individual elements with   contiguous ranges, etc. This function does not have any external effect.  
* [0.x.27]*
   Comparison for equality of index sets. This operation is only allowed if   the size of the two sets is the same (though of course they do not have   to have the same number of indices).  
* [0.x.28]*
   Comparison for inequality of index sets. This operation is only allowed   if the size of the two sets is the same (though of course they do not   have to have the same number of indices).  
* [0.x.29]*
   Return the intersection of the current index set and the argument given,   i.e. a set of indices that are elements of both index sets. The two index   sets must have the same size (though of course they do not have to have   the same number of indices).  
* [0.x.30]*
   This command takes an interval <tt>[begin, end)</tt> and returns the   intersection of the current index set with the interval, shifted to the   range <tt>[0, end-begin)</tt>.     In other words, the result of this operation is the intersection of the   set represented by the current object and the interval <tt>[begin,   end)</tt>, as seen [1.x.0] by   shifting the result of the intersection operation to the left by   <tt>begin</tt>. This corresponds to the notion of a [1.x.1]: The   interval <tt>[begin, end)</tt> is a [1.x.2] through which we see   the set represented by the current object.  
* [0.x.31]*
   Split the set indices represented by this object into blocks given by the    [2.x.31]  structure. The sum of its entries must match the   global size of the current object.  
* [0.x.32]*
   Remove all elements contained in  [2.x.32]  from this set. In other words,   if  [2.x.33]  is the current object and  [2.x.34]  the argument, then we compute  [2.x.35] .  
* [0.x.33]*
   Return a new IndexSet, with global size equal to   `this->size()*other.size()`, containing for every element `n` of this   IndexSet, the entries in the half open range `[n*other.size(),   (n+1)*other.size())` of the  [2.x.36]  IndexSet.     The name results from the perspective that one starts with an IndexSet and   takes the tensor product with another IndexSet with `other.size()`   elements; this results in a matrix of size `this->size()` times   `other.size()` that has ones in exactly the rows for which this IndexSet   contained an index and in the columns for which the  [2.x.37]  IndexSet   contained an index. This matrix is then "unrolled" again by going through   each row one by one and reindexing the entries of the matrix in consecutive   order. A one in the matrix then corresponds to an entry in the reindexed   IndexSet that is returned by this function.  
* [0.x.34]*
   Remove and return the last element of the last range.   This function throws an exception if the IndexSet is empty.  
* [0.x.35]*
   Remove and return the first element of the first range.   This function throws an exception if the IndexSet is empty.  
* [0.x.36]*
   Fill the given vector with all indices contained in this IndexSet.  
* [0.x.37]*
   Fill the given vector with either zero or one elements, providing a   binary representation of this index set. The given vector is assumed to   already have the correct size.     The given argument is filled with integer values zero and one, using    [2.x.38] . Thus, any object that has such an   operator can be used as long as it allows conversion of integers zero and   one to elements of the vector. Specifically, this is the case for classes   Vector, BlockVector, but also  [2.x.39]   [2.x.40]    and  [2.x.41]   
* [0.x.38]*
   Output a text representation of this IndexSet to the given stream. Used   for testing.  
* [0.x.39]*
   Write the IndexSet into a text based file format, that can be read in   again using the read() function.  
* [0.x.40]*
   Construct the IndexSet from a text based representation given by the   stream  [2.x.42]  written by the write() function.  
* [0.x.41]*
   Write the IndexSet into a binary, compact representation, that can be   read in again using the block_read() function.  
* [0.x.42]*
   Construct the IndexSet from a binary representation given by the stream    [2.x.43]  written by the write_block() function.  
* [0.x.43]*
   Given an MPI communicator, create a Trilinos map object that represents a   distribution of vector elements or matrix rows in which we will locally   store those elements or rows for which we store the index in the current   index set, and all the other elements/rows elsewhere on one of the other   MPI processes.     The last argument only plays a role if the communicator is a parallel   one, distributing computations across multiple processors. In that case,   if the last argument is false, then it is assumed that the index sets   this function is called with on all processors are mutually exclusive but   together enumerate each index exactly once. In other words, if you call   this function on two processors, then the index sets this function is   called with must together have all possible indices from zero to   size()-1, and no index must appear in both index sets. This corresponds,   for example, to the case where we want to split the elements of vectors   into unique subsets to be stored on different processors
* 
*  -  no element   should be owned by more than one processor, but each element must be   owned by one.     On the other hand, if the second argument is true, then the index sets   can be overlapping, and they also do not need to span the whole index   set. This is a useful operation if we want to create vectors that not   only contain the locally owned indices, but for example also the elements   that correspond to degrees of freedom located on ghost cells. Another   application of this method is to select a subset of the elements of a   vector, e.g. for extracting only certain solution components.  
* [0.x.44]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.45]*
   Write or read the data of this object to or from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.46]*
    [2.x.44]  Iterators    [2.x.45]   
* [0.x.47]*
   Dereferencing an IntervalIterator will return a reference to an object of   this type. It allows access to a contiguous interval  [2.x.46]  (also called   a range) of the IndexSet being iterated over.  
* [0.x.48]*
     Construct a valid accessor given an IndexSet and the index  [2.x.47]      of the range to point to.    
* [0.x.49]*
     Construct an invalid accessor for the IndexSet.    
* [0.x.50]*
     Number of elements in this interval.    
* [0.x.51]*
     If true, we are pointing at a valid interval in the IndexSet.    
* [0.x.52]*
     Return an iterator pointing at the first index in this interval.    
* [0.x.53]*
     Return an iterator pointing directly after the last index in this     interval.    
* [0.x.54]*
     Return the index of the last index in this interval.    
* [0.x.55]*
     Private copy constructor.    
* [0.x.56]*
     Private copy operator.    
* [0.x.57]*
     Test for equality, used by IntervalIterator.    
* [0.x.58]*
     Smaller-than operator, used by IntervalIterator.    
* [0.x.59]*
     Advance this accessor to point to the next interval in the  [2.x.48]      index_set.    
* [0.x.60]*
     Reference to the IndexSet.    
* [0.x.61]*
     Index into index_set.ranges[]. Set to  [2.x.49]  if     invalid or the end iterator.    
* [0.x.62]*
   Class that represents an iterator pointing to a contiguous interval    [2.x.50]  as returned by  [2.x.51]   
* [0.x.63]*
     Construct a valid iterator pointing to the interval with index  [2.x.52]      range_idx.    
* [0.x.64]*
     Construct an invalid iterator (used as end()).    
* [0.x.65]*
     Construct an empty iterator.    
* [0.x.66]*
     Copy constructor from  [2.x.53]  iterator.    
* [0.x.67]*
     Assignment of another iterator.    
* [0.x.68]*
     Prefix increment.    
* [0.x.69]*
     Postfix increment.    
* [0.x.70]*
     Dereferencing operator, returns an IntervalAccessor.    
* [0.x.71]*
     Dereferencing operator, returns a pointer to an IntervalAccessor.    
* [0.x.72]*
     Comparison.    
* [0.x.73]*
     Inverse of <tt>==</tt>.    
* [0.x.74]*
     Comparison operator.    
* [0.x.75]*
     Return the distance between the current iterator and the argument. The     distance is given by how many times one has to apply operator++ to the     current iterator to get the argument (for a positive return value), or     operator-- (for a negative return value).    
* [0.x.76]*
     Mark the class as forward iterator and declare some alias which are     standard for iterators and are used by algorithms to enquire about the     specifics of the iterators they work on.    
* [0.x.77]*
     Accessor that contains what IndexSet and interval we are pointing at.    
* [0.x.78]*
   Class that represents an iterator pointing to a single element in the   IndexSet as returned by  [2.x.54]   
* [0.x.79]*
     Construct an iterator pointing to the global index  [2.x.55]  in the     interval  [2.x.56]     
* [0.x.80]*
     Construct an iterator pointing to the end of the IndexSet.    
* [0.x.81]*
     Dereferencing operator. The returned value is the index of the element     inside the IndexSet.    
* [0.x.82]*
     Does this iterator point to an existing element?    
* [0.x.83]*
     Prefix increment.    
* [0.x.84]*
     Postfix increment.    
* [0.x.85]*
     Comparison.    
* [0.x.86]*
     Inverse of <tt>==</tt>.    
* [0.x.87]*
     Comparison operator.    
* [0.x.88]*
     Return the distance between the current iterator and the argument. In     the expression  [2.x.57]  the distance is given by     how many times one has to apply operator++ to the right operand  [2.x.58]      it_right to get the left operand  [2.x.59]  (for a positive return     value), or to  [2.x.60]  to get the  [2.x.61]  (for a negative return     value).    
* [0.x.89]*
     Mark the class as forward iterator and declare some alias which are     standard for iterators and are used by algorithms to enquire about the     specifics of the iterators they work on.    
* [0.x.90]*
     Advance iterator by one.    
* [0.x.91]*
     The parent IndexSet.    
* [0.x.92]*
     Index into index_set.ranges.    
* [0.x.93]*
     The global index this iterator is pointing at.    
* [0.x.94]*
   Return an iterator that points at the first index that is contained in   this IndexSet.  
* [0.x.95]*
   Return an element iterator pointing to the element with global index    [2.x.62]  or the next larger element if the index is not in the   set. This is equivalent to  
* [1.x.3]
*      If there is no element in this IndexSet at or behind  [2.x.63]    this method will return end().  
* [0.x.96]*
   Return an iterator that points one after the last index that is contained   in this IndexSet.  
* [0.x.97]*
   Return an Iterator that points at the first interval of this IndexSet.  
* [0.x.98]*
   Return an Iterator that points one after the last interval of this   IndexSet.  
* [0.x.99]*
    [2.x.64]   
* [0.x.100]*
   A type that denotes the half open index range  [2.x.65] .     The nth_index_in_set denotes the how many-th index within this IndexSet   the first element of the current range is. This information is only   accurate if  [2.x.66]  has been called after the last   insertion.  
* [0.x.101]*
     Default constructor. Since there is no useful choice for a default     constructed interval, this constructor simply creates something that     resembles an invalid range. We need this constructor for serialization     purposes, but the invalid range should be filled with something read     from the archive before it is used, so we should hopefully never get to     see an invalid range in the wild.    
* [0.x.102]*
     Constructor. Create a half-open interval with the given indices.          [2.x.67]  i1 Left end point of the interval.      [2.x.68]  i2 First index greater than the last index of the indicated     range.    
* [0.x.103]*
     Write or read the data of this object to or from a stream for the     purpose of serialization using the [BOOST serialization     library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).    
* [0.x.104]*
   A set of contiguous ranges of indices that make up (part of) this index   set. This variable is always kept sorted.     The variable is marked "mutable" so that it can be changed by compress(),   though this of course doesn't change anything about the external   representation of this index set.  
* [0.x.105]*
   True if compress() has been called after the last change in the set of   indices.     The variable is marked "mutable" so that it can be changed by compress(),   though this of course doesn't change anything about the external   representation of this index set.  
* [0.x.106]*
   The overall size of the index range. Elements of this index set have to   have a smaller number than this value.  
* [0.x.107]*
   This integer caches the index of the largest range in  [2.x.69]  This   gives <tt>O(1)</tt> access to the range with most elements, while general   access costs <tt>O(log(n_ranges))</tt>. The largest range is needed for   the methods  [2.x.70]   [2.x.71]   [2.x.72]    In many applications, the largest range contains most elements (the   locally owned range), whereas there are only a few other elements   (ghosts).  
* [0.x.108]*
   A mutex that is used to synchronize operations of the do_compress()   function that is called from many 'const' functions via compress().  
* [0.x.109]*
   Actually perform the compress() operation.  
* [0.x.110]*
 Create and return an index set of size  [2.x.73]  that contains every single index within this range. In essence, this function returns an index set created by

* 
* [1.x.4]
*  This function exists so that one can create and initialize index sets that are complete in one step, or so one can write code like

* 
* [1.x.5]
* 
*   [2.x.74]  IndexSet

* 
* [0.x.111]

include/deal.II-translator/base/iterator_range_0.txt
[0.x.0]*
 A class that is used to denote a collection of iterators that can be expressed in terms of a range of iterators characterized by a begin and an end iterator. As is common in C++, these ranges are specified as half open intervals defined by a begin iterator and a one-past-the-end iterator.
*  The purpose of this class is so that classes such as Triangulation and DoFHandler can return ranges of cell iterators using an object of the current type from functions such as  [2.x.0]  and that such an object can then be used in a range-based for loop as supported by C++11, see also  [2.x.1]  "C++11 standard".
*  For example, such a loop could look like this if the goal is to set the user flag on every active cell:

* 
* [1.x.0]
*  In other words, the  [2.x.2]  objects are iterators, and the range object returned by  [2.x.3]  and similar functions are conceptually thought of as [1.x.1].
*  Of course, the class may also be used to denote other iterator ranges using different kinds of iterators into other containers.
* 

*  [1.x.2]
*  Informally, the way the C++11 standard describes [1.x.3] works as follows: A [1.x.4] of the form

* 
* [1.x.5]
*  where  [2.x.4]  is a container or collection, is equivalent to the following loop:

* 
* [1.x.6]
*  (The precise definition can be found here: https://en.cppreference.com/w/cpp/language/range-for .) In other words, the compiler introduces a temporary variable that [1.x.7] over the elements of the container or collection, and the original variable  [2.x.5]  that appeared in the range-based for loop represents the [1.x.8] state of these iterators
* 
*  -  namely, the [1.x.9] of the collection.
*  In the context of loops over cells, we typically want to retain the fact that the loop variable is an iterator, not a value. This is because in deal.II, we never actually use the [1.x.10] of a cell iterator: conceptually, it would represent a cell, and technically it is implemented by classes such as CellAccessor and DoFCellAccessor, but these classes are never used explicitly. Consequently, what we would like is that a call such as  [2.x.6]  returns an object that represents a [1.x.11] of the kind <code>{begin, begin+1, ..., end-1}</code>. This is conveniently expressed as the half open interval  [2.x.7] . The loop variable in the range- based for loop would then take on each of these iterators in turn.
* 

*  [1.x.12]
*  To represent the desired semantics as outlined above, this class stores a half-open range of iterators  [2.x.8]  of the given template type. Secondly, the class needs to provide begin() and end() functions in such a way that if you [1.x.13] the result of  [2.x.9]  you get the  [2.x.10]  iterator. Furthermore, you must be able to increment the object returned by  [2.x.11]  so that  [2.x.12] . In other words,  [2.x.13]  must return an iterator that when dereferenced returns an iterator of the template type  [2.x.14] : It is an iterator over iterators in the same sense as if you had a pointer into an array of pointers.
*  This is implemented in the form of the  [2.x.15]  class.
* 

* 
*  [2.x.16] 

* 
* [0.x.1]*
   Typedef for the iterator type that iterates over other iterators.  
* [0.x.2]*
   Typedef for the iterator type represent by this class.  
* [0.x.3]*
   Default constructor. Create a range represented by two default   constructed iterators. This range is likely (depending on the type of the   iterators) empty.  
* [0.x.4]*
   Constructor. Constructs a range given the begin and end iterators.      [2.x.17]  begin An iterator pointing to the first element of the range    [2.x.18]  end   An iterator pointing past the last element represented   by this range.  
* [0.x.5]*
   Return the iterator pointing to the first element of this range.  
* [0.x.6]*
   Return the iterator pointing to the first element of this range.  
* [0.x.7]*
   Return the iterator pointing to the element past the last element of this   range.  
* [0.x.8]*
   Return the iterator pointing to the element past the last element of this   range.  
* [0.x.9]*
   Iterators characterizing the begin and end of the range.  
* [0.x.10]*
 A class that implements the semantics of iterators over iterators as discussed in the design sections of the IteratorRange class.

* 
* [0.x.11]*
   Typedef the elements of the collection to give them a name that is more   distinct.  
* [0.x.12]*
   Constructor. Initialize this iterator-over-iterator in such a way that   it points to the given argument.      [2.x.19]  iterator An iterator to which this object is supposed to point.  
* [0.x.13]*
   Dereferencing operator.    [2.x.20]  The iterator within the collection currently pointed to.  
* [0.x.14]*
   Dereferencing operator.    [2.x.21]  The iterator within the collection currently pointed to.  
* [0.x.15]*
   Prefix increment operator. Move the current iterator to the next   element of the collection and return the new value.  
* [0.x.16]*
   Postfix increment operator. Move the current iterator to the next   element of the collection, but return the previous value of the   iterator.  
* [0.x.17]*
   Comparison operator    [2.x.22]  i_o_i Another iterator over iterators.    [2.x.23]  Returns whether the current iterator points to a different   object than the iterator represented by the argument.  
* [0.x.18]*
   Implicit conversion operator.      [2.x.24]  When you call this conversion operator (i.e., you convert this   iterator-over-iterators to the iterator we are currently pointing to),   you obtain a `const` reference to this underlying iterator. The only   thing you can really do with this result is dereferencing itself: it   presumably points to something useful, but since you don't know where   the pointed to object lives, you shouldn't increment or decrement the   iterator you get from this operator. As a consequence, the returned   iterator is marked as `const`, as this should prevent you from doing   anything other than dereference it.  
* [0.x.19]*
   Mark the class as forward iterator and declare some alias which are   standard for iterators and are used by algorithms to enquire about the   specifics of the iterators they work on.  
* [0.x.20]*
   The object this iterator currently points to.  
* [0.x.21]*
 Create an object of type IteratorRange given the beginning and end iterator.

* 
* [0.x.22]

include/deal.II-translator/base/job_identifier_0.txt
[0.x.0]*
 Identification of a program run. <tt>JobIdentifier</tt> determines the start time of a program run and stores it as a program identifier. There exists a library object <tt>dealjobid</tt> of this class. This object can be accessed by all output functions to provide an id for the current job.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Constructor. Set program identifier to value of <tt>program_id</tt>   concatenated with the present time.  
* [0.x.2]*
   This function returns an identifier for the running program. Currently,   the library provides a function returning "JobID".     The user may define a replacement of this function in their source code and   avoid linking the library version. Unfortunately, this mechanism does not   work with shared libraries.  
* [0.x.3]*
   Obtain the base name of the filename passed as argument. That is,   if the file is <tt>mypath/file.cc</tt> return just   <tt>file</tt>. For example, this function can be called from a   user program with argument <tt>__FILE__</tt> to create an   identifier for the program being run.  
* [0.x.4]*
   Return the value of <tt>id</tt>.  
* [0.x.5]*
   %Function to identify the presently running program.  
* [0.x.6]*
   String holding the identifier of the presently running program.  
* [0.x.7]

include/deal.II-translator/base/linear_index_iterator_0.txt
[0.x.0]*
 Many classes in deal.II, such as FullMatrix, TransposeTable, and SparseMatrix, store their data in contiguous buffers (though the  [2.x.0] interpretation [2.x.1]  of what the elements of these buffers represent can, of course, be complex). For example, FullMatrix and TransposeTable store their data in row major and column major order respectively, whereas for SparseMatrix the mapping from buffer location to matrix entry  [2.x.2]  is more complicated. In any case, however, the contiguous arrangements of elements enables random access iteration.
*  LinearIndexIterator provides most of the functionality needed to write iterators for these classes. LinearIndexIterator is essentially a simplified version of  [2.x.3]  that assumes  [2.x.4]  provides certain members (documented below) that completely describe the state of the iterator. The intended use of this class is for containers to define their own accessor classes and then use the curiously recurring template pattern (CRTP) technique to define their iterators. For example, here is a container that uses LinearIndexIterator to define its own iterator classes:
* 

* 
* [1.x.0]
* 
*   [2.x.5]  DerivedIterator As shown in the example above, concrete iterator classes should use this class with the CRTP technique: this provides the boiler-plate comparison and arithmetic operators for iterators. This is necessary for, e.g.,  [2.x.6]  to return the correct type.
*   [2.x.7]  AccessorType LinearIndexIterator assumes that the  [2.x.8]  template parameter has the following members which completely describe the current state of the iterator:  [2.x.9]     [2.x.10] A pointer named  [2.x.11]  to the original container (e.g.,   the relevant SparseMatrix). This should be a  [2.x.12]  pointer   for  [2.x.13]  iterators. [2.x.14]     [2.x.15] An array index named  [2.x.16]  that stores the current   position in the container's storage buffer.  [2.x.17]  does   not need to be an integer: it could be a class type (convertible to the   correct index type of the container) that implements    [2.x.18] , and    [2.x.19] . For example, one could implement a strided   iterator by implementing  [2.x.20]  and    [2.x.21]  with multiplicative factors. [2.x.22]   [2.x.23]  In addition,  [2.x.24]  should declare the relevant LinearIndexIterator instantiation to be a  [2.x.25]  and define a  [2.x.26]  type.
* 

* 
*  [2.x.27]  TransposeTable uses this template to implement its iterators.

* 
* [0.x.1]*
   Iterator category.  
* [0.x.2]*
   An alias for the type you get when you dereference an iterator of the   current kind.  
* [0.x.3]*
   Difference type.  
* [0.x.4]*
   Reference type.  
* [0.x.5]*
   Pointer type.  
* [0.x.6]*
   Size type used by the underlying container.  
* [0.x.7]*
   Copy operator.  
* [0.x.8]*
   Prefix increment.  
* [0.x.9]*
   Postfix increment.  
* [0.x.10]*
   Prefix decrement.  
* [0.x.11]*
   Postfix decrement.  
* [0.x.12]*
   Return an iterator that is  [2.x.28]  entries ahead of the current one.  
* [0.x.13]*
   Return an iterator that is  [2.x.29]  entries behind the current one.  
* [0.x.14]*
   Increment the iterator position by  [2.x.30]   
* [0.x.15]*
   Decrement the iterator position by  [2.x.31]   
* [0.x.16]*
   Return the distance between the current iterator and the argument. The   distance is given by how many times one has to apply operator++() to the   current iterator to get the argument (for a positive return value), or   operator--() (for a negative return value).  
* [0.x.17]*
   Dereferencing operator.  
* [0.x.18]*
   Dereferencing operator.  
* [0.x.19]*
   Comparison operator. Returns  [2.x.32]  if both iterators point to   the same entry in the same container.  
* [0.x.20]*
   Opposite of operator==().  
* [0.x.21]*
   Comparison operator: uses the same ordering as operator<(), but also   checks for equality.     This function is only valid if both iterators point into the same   container.  
* [0.x.22]*
   Comparison operator: uses the same ordering as operator>(), but also   checks for equality.     This function is only valid if both iterators point into the same   container.  
* [0.x.23]*
   Comparison operator. Result is true if either the first row number is   smaller or if the row numbers are equal and the first index is smaller.     This function is only valid if both iterators point into the same   container.  
* [0.x.24]*
   Comparison operator. Works in the same way as operator<(), just the other   way round.  
* [0.x.25]   The inheriting class should have a default constructor.  
* [0.x.26]*
   Constructor that copies an accessor.  
* [0.x.27]*
   Store an object of the accessor class.  
* [0.x.28]

include/deal.II-translator/base/logstream_0.txt
[0.x.0]*
 A class that simplifies the process of execution logging. It does so by providing  [2.x.0]   [2.x.1]  a push and pop mechanism for prefixes, and  [2.x.2]  the possibility of distributing information to files and the console.  [2.x.3] 
*  The usual usage of this class is through the pregenerated object <tt>deallog</tt>. Typical setup steps are:  [2.x.4]   [2.x.5]  <tt>deallog.depth_console(n)</tt>: restrict output on screen to outer loops.  [2.x.6]   [2.x.7]  write logging information into a file.  [2.x.8]  <tt>deallog.depth_file(n)</tt>: restrict output to file to outer loops.  [2.x.9] 
*  Before entering a new phase of your program, e.g. a new loop, a new prefix can be set via  [2.x.10]  p("loopname");</tt>. The destructor of the prefix will pop the prefix text from the stack.
*  Write via the <tt>&lt;&lt;</tt> operator, <tt> deallog << "This is a log notice";</tt> will be buffered thread locally until a  [2.x.11]  or  [2.x.12]  is encountered, which will trigger a writeout to the console and, if set up, the log file.
*  [1.x.0]
*  In the vicinity of concurrent threads, LogStream behaves in the following manner:  [2.x.13]   [2.x.14]  Every write to a Logstream with operator <tt>&lt;&lt;</tt> (or with one of the special member functions) is buffered in a thread-local storage.  [2.x.15]  An  [2.x.16]  or  [2.x.17]  will trigger a writeout to the console and (if attached) to the file stream. This writeout is sequentialized so that output from concurrent threads don't interleave.  [2.x.18]  On a new thread, invoking a writeout, as well as a call to #push or #pop will copy the current prefix of the "blessed" thread that created the LogStream instance to a thread-local storage. After that prefixes are thread-local.  [2.x.19] 
* 

* 
*  [2.x.20] 

* 
* [0.x.1]*
   A subclass allowing for the safe generation and removal of prefixes.     Somewhere at the beginning of a block, create one of these objects, and   it will appear as a prefix in LogStream output like  [2.x.21]  At the   end of the block, the prefix will automatically be removed, when this   object is destroyed.     In other words, the scope of the object so created determines the   lifetime of the prefix. The advantage of using such an object is that the   prefix is removed whichever way you exit the scope
* 
*  -  by    [2.x.22] ,    [2.x.23] , or by simply reaching the closing brace. In all of   these cases, it is not necessary to remember to pop the prefix manually   using  [2.x.24]  In this, it works just like the better known    [2.x.25]  and  [2.x.26]  classes.  
* [0.x.2]*
     Set a new prefix for  [2.x.27]  which will be removed when the     variable is destroyed.    
* [0.x.3]*
     Set a new prefix for the given stream, which will be removed when the     variable is destroyed.    
* [0.x.4]*
     Remove the prefix associated with this variable.    
* [0.x.5]*
     A pointer to the LogStream object to which the prefix is     applied.    
* [0.x.6]*
   Standard constructor. The constructor sets the output stream to    [2.x.28]  and the depth to zero. (Use attach() and   depth_console() to change this.)  
* [0.x.7]*
   Destructor.  
* [0.x.8]*
   Enable output to a second stream <tt>o</tt>.      [2.x.29]  o Attach this output stream.      [2.x.30]  print_job_id Whether or not the JobIdentifier for the current   process should be printed to the stream.      [2.x.31]  flags Format flags to set on the output stream  [2.x.32]   
* [0.x.9]*
   Disable output to the second stream. You may want to call <tt>close</tt>   on the stream that was previously attached to this object.  
* [0.x.10]*
   Return the default stream (<tt>std_out</tt>).  
* [0.x.11]*
   Return the file stream.  
* [0.x.12]*
   Return  [2.x.33]  if file stream has already been attached,    [2.x.34]  otherwise.  
* [0.x.13]*
   Return the prefix string.  
* [0.x.14]*
   Push another prefix on the stack. Prefixes are automatically separated by   a colon and there is a double colon after the last prefix.     A simpler way to add a prefix (without the manual need to add the   corresponding pop()) is to use the  [2.x.35]  class. Using   that class has the advantage that the corresponding pop() call is   issued whenever the Prefix object goes out of scope
* 
*  -  either at   the end of the code block, at the nearest  [2.x.36]  statement, or   because an intermediate function call results in an exception that   is not immediately caught.  
* [0.x.15]*
   Remove the last prefix added with push().  
* [0.x.16]*
   Maximum number of levels to be printed on the console. The default is 0,   which will not generate any output. This function allows one to restrict   console output to the highest levels of iterations. Only output with less   than <tt>n</tt> prefixes is printed. By calling this function with   <tt>n=0</tt>, no console output will be written. See  [2.x.37]  for an   example usage of this method.     The previous value of this parameter is returned.  
* [0.x.17]*
   Maximum number of levels to be written to the log file. The functionality   is the same as <tt>depth_console</tt>, nevertheless, this function should   be used with care, since it may spoil the value of a log file.     The previous value of this parameter is returned.  
* [0.x.18]*
   Log the thread id.  
* [0.x.19]*
   set the precision for the underlying stream and returns the previous   stream precision. This function mimics   http://www.cplusplus.com/reference/ios/ios_base/precision/  
* [0.x.20]*
   set the width for the underlying stream and returns the previous stream   width. This function mimics   http://www.cplusplus.com/reference/ios/ios_base/width/  
* [0.x.21]*
   set the flags for the underlying stream and returns the previous stream   flags. This function mimics   http://www.cplusplus.com/reference/ios/ios_base/flags/  
* [0.x.22]*
   Treat ostream manipulators. This passes on the whole thing to the   template function with the exception of the  [2.x.38]    manipulator, for which special action is performed: write the temporary   stream buffer including a header to the file and  [2.x.39]  and   empty the buffer.     An overload of this function is needed anyway, since the compiler can't   bind manipulators like  [2.x.40]  directly to template arguments  [2.x.41]    like in the previous general template. This is due to the fact that  [2.x.42]     [2.x.43]  is actually an overloaded set of functions for  [2.x.44]     [2.x.45]  and potentially more of this kind. This function is   therefore necessary to pick one element from this overload set.  
* [0.x.23]*
   Return an estimate for the memory consumption, in bytes, of this object.   This is not exact (but will usually be close) because calculating the   memory usage of trees (e.g.,  [2.x.46]  is difficult.  
* [0.x.24]*
   Internal wrapper around thread-local prefixes. This private function will   return the correct internal prefix stack. More important, a new thread-   local stack will be copied from the current stack of the "blessed" thread   that created this LogStream instance (usually, in the case of deallog,   the "main" thread).  
* [0.x.25]*
   Stack of strings which are printed at the beginning of each line to allow   identification where the output was generated.  
* [0.x.26]*
   We record the thread id of the thread creating this object. We need   this information to "steal" the current prefix from this "parent"   thread on first use of deallog on a new thread.  
* [0.x.27]*
   Default stream, where the output is to go to. This stream defaults to    [2.x.47]  but can be set to another stream through the   constructor.  
* [0.x.28]*
   Pointer to a stream, where a copy of the output is to go to. Usually,   this will be a file stream.     You can set and reset this stream by the <tt>attach</tt> function.  
* [0.x.29]*
   Value denoting the number of prefixes to be printed to the standard   output. If more than this number of prefixes is pushed to the stack, then   no output will be generated until the number of prefixes shrinks back   below this number.  
* [0.x.30]*
   Same for the maximum depth of prefixes for output to a file.  
* [0.x.31]*
   Flag for printing thread id.  
* [0.x.32]*
   A flag indicating whether output is currently at a new line  
* [0.x.33]*
   Print head of line.  
* [0.x.34]*
   Internal wrapper around "thread local" outstreams. This private function   will return the correct internal ostringstream buffer for operator<<.  
* [0.x.35]*
   We use our thread local storage facility to generate a stringstream for   every thread that sends log messages.  
* [0.x.36]*
 Output a constant something through LogStream:
* 

* 
*  [2.x.48]  We declare this operator as a non-member function so that it is possible to overload it with more specialized templated versions under C++11 overload resolution rules

* 
* [0.x.37]*
 The standard log object of deal.II:

* 
* [0.x.38]

include/deal.II-translator/base/memory_consumption_0.txt
[0.x.0]*
 This namespace provides functions helping to determine the amount of memory used by objects. The goal is not necessarily to give the amount of memory used up to the last bit (what is the memory used by a  [2.x.0]  object?), but rather to aid in the search for memory bottlenecks.
*  This namespace has a single member function memory_consumption() and a lot of specializations. Depending on the argument type of the function, there are several modes of operation:
*   [2.x.1]   [2.x.2]  If the argument is a fundamental C++ data type (such as <tt>bool</tt>, <tt>float</tt>, <tt>double</tt> or any of the integer types), then memory_consumption() just returns <tt>sizeof</tt> of its argument. The library also provides an estimate for the amount of memory occupied by a  [2.x.3] 
*   [2.x.4]  For objects, which are neither standard types, nor vectors, memory_consumption() will simply call the member function of same name. It is up to the implementation of the data type to provide a good estimate of the amount of memory used. Inside this function, the use of  [2.x.5]  for compounds of the class helps to obtain this estimate. Most classes in the deal.II library have such a member function.
*   [2.x.6]  For vectors and C++ arrays of objects, memory_consumption() recursively calls itself for all entries and adds the results to the size of the object itself. Some optimized specializations for standard data types exist.
*   [2.x.7]  For vectors of regular pointers, memory_consumption(T*) returns the size of the vector of pointers, ignoring the size of the objects.
*   [2.x.8] 
*  [1.x.0]
*  The function in this namespace and the functionality provided by it relies on the assumption that there is either a function <tt>memory_consumption(T)</tt> in this namespace determining the amount of memory used by objects of type <tt>T</tt> or that the class <tt>T</tt> has a member function of that name. While the latter is true for almost all classes in deal.II, we have only implemented the first kind of functions for the most common data types, such as fundamental types, strings, C++ vectors, C-style arrays, and C++ pairs. These functions therefore do not cover, for example, C++ maps, lists, etc. If you need such functions feel free to implement them and send them to us for inclusion.
* 

* 
*  [2.x.9]  Wells

* 
* [0.x.1]*
   Calculate the memory consumption of a fundamental type. See   EnableIfScalar for a discussion on how this restriction (SFINAE) is   implemented.  
* [0.x.2]*
   Estimate the memory consumption of an object. If no further template   specialization (past this one) is available for the type <tt>T</tt>, then   this function returns the member function   <tt>t.memory_consumption()</tt>'s value.  
* [0.x.3]*
   Determine the amount of memory consumed by a C-style string. The returned   value does not include the size of the pointer. This function only   measures up to (and including) the NUL byte; the underlying buffer may be   larger.  
* [0.x.4]*
   Determine the amount of memory in bytes consumed by a    [2.x.10]  variable.  
* [0.x.5]*
   Determine the amount of memory in bytes consumed by a   <tt>VectorizedArray</tt> variable.  
* [0.x.6]*
   Determine an estimate of the amount of memory in bytes consumed by a    [2.x.11]  variable.  
* [0.x.7]*
   Determine the amount of memory in bytes consumed by a    [2.x.12]  of elements of type <tt>T</tt> by   calling memory_consumption() for each entry.     This function loops over all entries of the vector and determines their   sizes using memory_consumption() for each <tt>v[i]</tt>. If the entries   are of constant size, there might be another global function   memory_consumption() for this data type or if there is a member function   of that class of that names that returns a constant value and the   compiler will unroll this loop so that the operation is fast. If the size   of the data elements is variable, for example if they do memory   allocation themselves, then the operation will necessarily be more   expensive.     Using the algorithm, in particular the loop over all elements, it is   possible to also compute the memory consumption of vectors of vectors,   vectors of strings, etc, where the individual elements may have vastly   different sizes.     Note that this algorithm also takes into account the size of elements   that are allocated by this vector but not currently used.     For the most commonly used vectors, there are special functions that   compute the size without a loop. This also applies for the special case   of vectors of bools.  
* [0.x.8]*
   Determine the amount of memory in bytes consumed by a    [2.x.13]  of <tt>N</tt> elements of type <tt>T</tt> by   calling memory_consumption() for each entry.     This function loops over all entries of the array and determines their   sizes using memory_consumption() for each <tt>v[i]</tt>. If the entries   are of constant size, there might be another global function   memory_consumption() for this data type or if there is a member function   of that class of that names that returns a constant value and the   compiler will unroll this loop so that the operation is fast. If the size   of the data elements is variable, for example if they do memory   allocation themselves, then the operation will necessarily be more   expensive.     Using the algorithm, in particular the loop over all elements, it is   possible to also compute the memory consumption of arrays of vectors,   arrays of strings, etc, where the individual elements may have vastly   different sizes.  
* [0.x.9]*
   Estimate the amount of memory (in bytes) occupied by a C-style array.   Since in this library we do not usually store simple data elements like   <tt>double</tt>s in such arrays (but rather use  [2.x.14]  or   deal.II <tt>Vector</tt> objects), we do not provide specializations like   for the  [2.x.15]  arrays, but always use the loop over all   elements.  
* [0.x.10]*
   Specialization of the determination of the memory consumption of a   vector, here for a vector of <tt>bool</tt>s.     This is a special case, as the bools are not stored one-by-one, but as a   bit field.  
* [0.x.11]*
   Determine an estimate of the amount of memory in bytes consumed by a pair   of values.  
* [0.x.12]*
   Calculate the memory consumption of a pointer.    
*  [2.x.16]  This function is overloaded for C-style strings; see the   documentation of that function for that case.    
*  [2.x.17]  This returns the size of the pointer, not the size of the object   pointed to.  
* [0.x.13]*
   Return the amount of memory used by a shared pointer.    
*  [2.x.18]  This returns the size of the pointer, not of the object pointed to.  
* [0.x.14]*
   Return the amount of memory used by a  [2.x.19]  object.    
*  [2.x.20]  This returns the size of the pointer, not of the object pointed to.  
* [0.x.15]

include/deal.II-translator/base/memory_space_0.txt
[0.x.0]*
   Structure describing Host memory space.  
* [0.x.1]*
   Structure describing CUDA memory space.  
* [0.x.2]

include/deal.II-translator/base/memory_space_data_0.txt
[0.x.0]*
   Data structure  
* [0.x.1]*
     Copy the active data (values for Host and values_dev for CUDA) to  [2.x.0]      If the data is on the device it is moved to the host.    
* [0.x.2]*
     Copy the data in  [2.x.1]  to the active data of the structure (values for     Host and values_dev for CUDA). The pointer  [2.x.2]  must be on the host.    
* [0.x.3]*
     Pointer to data on the host.    
* [0.x.4]*
     Pointer to data on the device.    
* [0.x.5]*
     Pointers to the data of the processes sharing the same memory.    
* [0.x.6]*
   Swap function similar to  [2.x.3]   
* [0.x.7]*
     This is currently not used.    
* [0.x.8]

include/deal.II-translator/base/mg_level_object_0.txt
[0.x.0]*
 This class represents an array with one object for each used level of a multilevel hierarchy, for example for use in the multigrid algorithms. In contrast to just a generic  [2.x.0] , this class allows to store objects only between some minimal and maximal index (=level), as one often wants to run a multilevel algorithm only on a subset of the levels of a mesh (e.g., because the second or third coarsest level is already small enough that it is cheaper to run a direct solver there, rather than recurse to even coarser levels). Despite storing objects only for these "interesting" levels, the class allows indexing simply by level. Internally, this is of course done by simply shifting the given index by the minimum level we have stored.
*  In a typical use case for this class, the objects stored on each level are either matrices or vectors.
* 

* 
*  [2.x.1] 

* 
*  [2.x.2] 

* 
* [0.x.1]*
   Constructor. Create a multilevel object with given minimal and   maximal level, and allocate storage for objects on    [2.x.3]  levels.    
*  [2.x.4]  Unlike in many other places of the library, the two arguments   here do not denote the first level and last-plus-one level, but indeed   an [1.x.0] range of levels for which to allocate storage   for level objects. Consequently, the defaults for the two arguments   will create an array with one level object, rather than an empty   array.      [2.x.5]  minlevel The lowest level for which to provision memory     for level objects.    [2.x.6]  maxlevel The highest level for which to provision memory     for level objects.    [2.x.7]  args Optional arguments passed to the constructor of the     underlying object.      [2.x.8]  minlevel <= maxlevel  
* [0.x.2]*
   Constructor. Same as above but without arguments to be forwarded to the   constructor of the underlying object.  
* [0.x.3]*
   Access object on level  [2.x.9]   
* [0.x.4]*
   Access object on level  [2.x.10]      This function can be called on a  [2.x.11]  object, and   consequently returns a  [2.x.12]  reference.  
* [0.x.5]*
   Delete all previous contents of this object and reset its size according   to the values of  [2.x.13]  and  [2.x.14]       [2.x.15]  new_minlevel The lowest level for which to provision memory     for level objects.    [2.x.16]  new_maxlevel The highest level for which to provision memory     for level objects.    [2.x.17]  args Optional arguments passed to the constructor of the     underlying object.      [2.x.18]  minlevel <= maxlevel  
* [0.x.6]*
   Call <tt>operator = (s)</tt> on all objects stored by this object.   This clearly requires that the objects stored on each level allow for   this operation. This is, in particular, true for vectors and matrices   if  [2.x.19]  is zero, thereby zeroing out all vector or matrix entries.  
* [0.x.7]*
   Call  [2.x.20]  on all objects stored by this object. This function   is only implemented for some  [2.x.21]  classes, e.g., matrix   types or the PreconditionBlockSOR and similar classes. Using this   function will fail with a compiler error if the  [2.x.22]    template type to this class does not provide a    [2.x.23]  member function.  
* [0.x.8]*
   The coarsest level for which this class stores a level object.  
* [0.x.9]*
   The highest level for which this class stores a level object.  
* [0.x.10]*
   Apply the action  [2.x.24]  to every object stored in here. The   parameter  [2.x.25]  is expected to be a function object that accepts   the syntax   <code>     action(const unsigned int level, Object &object);   </code>   This means this function can accept a lambda, a  [2.x.26]  or a plain   function pointer.  
* [0.x.11]*
   Memory used by this object.  
* [0.x.12]*
   Level of first component.  
* [0.x.13]*
   Array of the objects to be held.  
* [0.x.14]

include/deal.II-translator/base/mpi_0.txt
[0.x.0]*
 Helper macro to remove const from the pointer arguments to some MPI_*
 functions.
*  This is needed as the input arguments of functions like MPI_Allgather() are not marked as const in OpenMPI 1.6.5. If using MPI 3 or newer, this macro is a NOOP, while we do the following otherwise:
*  1. remove from type of  [2.x.0]  2. remove const from resulting type 3. add to resulting type 4. const_cast the given expression  [2.x.1]  to this new type.

* 
* [0.x.1]*
   Given the total number of elements  [2.x.2]  create an evenly   distributed 1:1 partitioning of the elements for across  [2.x.3]    The local sizes will be equal to the  [2.x.4]  divided by the number   of partitions plus the remainder being divided amongst the first   processes. Each process will store a contiguous subset of indices, and the   index set on process p+1 starts at the index one larger than the last one   stored on process p.   For example, a  [2.x.5]  of 11 with 3 processes will result   in the IndexSets { [0,4), [4,8), [8,11)] }, and this function will   return the  [2.x.6]  's IndexSet.  
* [0.x.2]*
   A namespace for utility functions that abstract certain operations using   the Message Passing Interface (MPI) or provide fallback operations in   case deal.II is configured not to use MPI at all.    
*  [2.x.7]   
* [0.x.3]*
     Return the number of MPI processes there exist in the given      [2.x.8]  "communicator"     object. If this is a sequential job (i.e., the program     is not using MPI at all, or is using MPI but has been started with     only one MPI process), then the communicator necessarily involves     only one process and the function returns 1.    
* [0.x.4]*
     Return the      [2.x.9]  "rank of the present MPI process"     in the space of processes described by the given      [2.x.10]  "communicator".     This will be a unique value for each process between zero and (less     than) the number of all processes (given by get_n_mpi_processes()).    
* [0.x.5]*
     Return a vector of the ranks (within  [2.x.11]  of a subset of     processes specified by  [2.x.12]     
* [0.x.6]*
     Consider an unstructured communication pattern where every process in     an MPI universe wants to send some data to a subset of the other     processors. To do that, the other processors need to know who to expect     messages from. This function computes this information.          [2.x.13]  mpi_comm A      [2.x.14]  "communicator"     that describes the processors that are going to communicate with each     other.          [2.x.15]  destinations The list of processors the current process wants to     send information to. This list need not be sorted in any way. If it     contains duplicate entries that means that multiple messages are     intended for a given destination.          [2.x.16]  A list of processors that have indicated that they want to send     something to the current processor. The resulting list is not sorted.     It may contain duplicate entries if processors enter the same     destination more than once in their destinations list.    
* [0.x.7]*
     Simplified (for efficiency) version of the     compute_point_to_point_communication_pattern()     which only computes the number of processes in an MPI universe to expect     communication from.          [2.x.17]  mpi_comm A      [2.x.18]  "communicator"     that describes the processors that are going to communicate with each     other.          [2.x.19]  destinations The list of processors the current process wants to     send information to. This list need not be sorted in any way. If it     contains duplicate entries that means that multiple messages are     intended for a given destination.          [2.x.20]  A number of processors that want to send something to the current     processor.    
* [0.x.8]*
     Given a      [2.x.21]  "communicator",     generate a new communicator that contains the same set of processors     but that has a different, unique identifier.         This functionality can be used to ensure that different objects, such     as distributed matrices, each have unique communicators over which they     can interact without interfering with each other.         When no longer needed, the communicator created here needs to be     destroyed using free_communicator().         This function is equivalent to calling      [2.x.22] .    
* [0.x.9]*
     Free the given      [2.x.23]  "communicator"      [2.x.24]  that was duplicated using duplicate_communicator().         The argument is passed by reference and will be invalidated and set to     the MPI null handle. This function is equivalent to calling      [2.x.25] .    
* [0.x.10]*
     Helper class to automatically duplicate and free an MPI      [2.x.26]  "communicator".         This class duplicates the communicator given in the constructor     using duplicate_communicator() and frees it automatically when     this object gets destroyed by calling free_communicator(). You     can access the wrapped communicator using operator*.         This class exists to easily allow duplicating communicators without     having to worry when and how to free it after usage.    
* [0.x.11]*
       Create a duplicate of the given  [2.x.27]       
* [0.x.12]*
       Do not allow making copies.      
* [0.x.13]*
       The destructor will free the communicator automatically.      
* [0.x.14]*
       Access the stored communicator.      
* [0.x.15]*
       Do not allow assignment of this class.      
* [0.x.16]*
       The communicator of course.      
* [0.x.17]*
     This class represents a mutex to guard a critical section for a set of     processors in a parallel computation using MPI.         The lock() commands waits until all MPI ranks in the communicator have     released a previous lock using unlock().         A typical usage involves guarding a critical section using a lock guard:    
* [1.x.0]
*          Here, the critical code will finish on all processors before the mutex     can be acquired again (for example by a second execution of the block     above. The critical code block typically involves MPI communication that     would yield incorrect results without the lock. For example, if the code     contains nonblocking receives with MPI_ANY_SOURCE, packets can be     confused between iterations.         Note that the mutex needs to be the same instance between calls to the     same critical region. While not required, this can be achieved by making     the instance static (like in the example above). The variable can also be     a global variable, or a member variable of the object to which the     executing function belongs.    
* [0.x.18]*
       This helper class provides a scoped lock for the CollectiveMutex.             See the class documentation of CollectiveMutex for details.      
* [0.x.19]*
         Constructor. Blocks until it can acquire the lock.        
* [0.x.20]*
         Destructor. Releases the lock.        
* [0.x.21]*
         A reference to the mutex.        
* [0.x.22]*
         The communicator.        
* [0.x.23]*
       Constructor of this class.      
* [0.x.24]*
       Destroy the mutex. Assumes the lock is not currently held.      
* [0.x.25]*
       Acquire the mutex and, if necessary, wait until we can do so.             This is a collective call that needs to be executed by all processors       in the communicator.      
* [0.x.26]*
       Release the lock.             This is a collective call that needs to be executed by all processors       in the communicator.      
* [0.x.27]*
       Keep track if we have this lock right now.      
* [0.x.28]*
       The request to keep track of the non-blocking barrier.      
* [0.x.29]*
     If  [2.x.28]  is an intracommunicator, this function returns a new     communicator  [2.x.29]  with communication group defined by the      [2.x.30]  argument. The function is only collective over the group of     processes that actually want to create the communicator, i.e., that     are named in the  [2.x.31]  argument. If multiple threads at a given     process perform concurrent create_group() operations, the user must     distinguish these operations by providing different  [2.x.32]  or  [2.x.33]      arguments.         This function was introduced in the MPI-3.0 standard. If available,     the corresponding function in the provided MPI implementation is used.     Otherwise, the implementation follows the one described in the     following publication:    
* [1.x.1]
*     
* [0.x.30]*
     Given the number of locally owned elements  [2.x.34]      create a 1:1 partitioning of the of elements across the MPI     communicator  [2.x.35]  The total size of elements is the sum of      [2.x.36]  across the MPI communicator.  Each process will     store contiguous subset of indices, and the index set on process p+1     starts at the index one larger than the last one stored on process p.    
* [0.x.31]*
     Given the total number of elements  [2.x.37]  create an evenly     distributed 1:1 partitioning of the elements across the     MPI communicator  [2.x.38]      Uses  [2.x.39]  to determine number of partitions and processor ID to call the      [2.x.40]  function above.    
* [0.x.32]*
     Calculate mean and standard deviation across the MPI communicator  [2.x.41]      for values provided as a range `[begin,end)`.     The mean is computed as  [2.x.42]  where the  [2.x.43]  are     the elements pointed to by the `begin` and `end` iterators on all     processors (i.e., each processor's `[begin,end)` range points to a subset     of the overall number of elements). The standard deviation is calculated     as  [2.x.44] , which is known as     unbiased sample variance.          [2.x.45]  Number specifies the type to store the mean value.     The standard deviation is stored as the corresponding real type.     This allows, for example, to calculate statistics from integer input     values.    
* [0.x.33]*
     Return the sum over all processors of the value  [2.x.46]  This function is     collective over all processors given in the      [2.x.47]  "communicator".     If deal.II is not configured for use of MPI, this function simply     returns the value of  [2.x.48]  This function corresponds to the      [2.x.49]  function, i.e. all processors receive the     result of this operation.        
*  [2.x.50]  Sometimes, not all processors need a result and in that case one     would call the  [2.x.51]  function instead of the      [2.x.52]  function. The latter is at most twice as     expensive, so if you are concerned about performance, it may be     worthwhile investigating whether your algorithm indeed needs the result     everywhere.        
*  [2.x.53]  This function is only implemented for certain template arguments      [2.x.54] .    
* [0.x.34]*
     Like the previous function, but take the sums over the elements of an     array of type T. In other words, the i-th element of the results     array is the sum over the i-th entries of the input arrays from each     processor. T and U must decay to the same type, e.g. they just differ by     one of them having a const type qualifier and the other not.         Input and output arrays may be the same.    
* [0.x.35]*
     Like the previous function, but take the sums over the elements of an     array as specified by the ArrayView arguments.     In other words, the i-th element of the results     array is the sum over the i-th entries of the input arrays from each     processor.         Input and output arrays may be the same.    
* [0.x.36]*
     Perform an MPI sum of the entries of a symmetric tensor.          [2.x.55]  SymmetricTensor    
* [0.x.37]*
     Perform an MPI sum of the entries of a tensor.          [2.x.56]  Tensor    
* [0.x.38]*
     Perform an MPI sum of the entries of a SparseMatrix.        
*  [2.x.57]   [2.x.58]  and  [2.x.59]  should have the same sparsity     pattern and it should be the same for all MPI processes.          [2.x.60]  SparseMatrix    
* [0.x.39]*
     Return the maximum over all processors of the value  [2.x.61]  This function     is collective over all processors given in the      [2.x.62]  "communicator".     If deal.II is not configured for use of MPI, this function simply     returns the value of  [2.x.63]  This function corresponds to the      [2.x.64]  function, i.e. all processors receive the     result of this operation.        
*  [2.x.65]  Sometimes, not all processors need a result and in that case one     would call the  [2.x.66]  function instead of the      [2.x.67]  function. The latter is at most twice as     expensive, so if you are concerned about performance, it may be     worthwhile investigating whether your algorithm indeed needs the result     everywhere.        
*  [2.x.68]  This function is only implemented for certain template arguments      [2.x.69] .    
* [0.x.40]*
     Like the previous function, but take the maximum over the elements of an     array of type T. In other words, the i-th element of the results array is     the maximum over the i-th entries of the input arrays from each     processor. T and U must decay to the same type, e.g. they just differ by     one of them having a const type qualifier and the other not.         Input and output vectors may be the same.    
* [0.x.41]*
     Like the previous function, but take the maximum over the elements of an     array as specified by the ArrayView arguments.     In other words, the i-th element of the results     array is the maximum over the i-th entries of the input arrays from each     processor.         Input and output arrays may be the same.    
* [0.x.42]*
     Return the minimum over all processors of the value  [2.x.70]  This function     is collective over all processors given in the      [2.x.71]  "communicator".     If deal.II is not configured for use of MPI, this function simply     returns the value of  [2.x.72]  This function corresponds to the      [2.x.73]  function, i.e. all processors receive the     result of this operation.        
*  [2.x.74]  Sometimes, not all processors need a result and in that case one     would call the  [2.x.75]  function instead of the      [2.x.76]  function. The latter is at most twice as     expensive, so if you are concerned about performance, it may be     worthwhile investigating whether your algorithm indeed needs the result     everywhere.        
*  [2.x.77]  This function is only implemented for certain template arguments      [2.x.78] .    
* [0.x.43]*
     Like the previous function, but take the minima over the elements of an     array of type T. In other words, the i-th element of the results     array is the minimum of the i-th entries of the input arrays from each     processor. T and U must decay to the same type, e.g. they just differ by     one of them having a const type qualifier and the other not.         Input and output arrays may be the same.    
* [0.x.44]*
     Like the previous function, but take the minimum over the elements of an     array as specified by the ArrayView arguments.     In other words, the i-th element of the results     array is the minimum over the i-th entries of the input arrays from each     processor.         Input and output arrays may be the same.    
* [0.x.45]*
     Performs a [1.x.2] operation over all processors of the value      [2.x.79]  The [1.x.3] operator `||` returns the boolean value     `true` if either or all operands are `true` and returns `false`     otherwise. If the provided value  [2.x.80]  corresponds to `0` in its     associated data type `T`, it will be interpreted as `false`, and `true`     otherwise. Data type `T` must be of type `integral`, i.e., `bool`,     `char`, `short`, `int`, `long`, or any of their variations.         This function is collective over all processors given in the      [2.x.81]  "communicator".     If deal.II is not configured for use of MPI, this function simply     returns the value of  [2.x.82]  This function corresponds to the      [2.x.83]  function, i.e., all processors receive the     result of this operation.        
*  [2.x.84]  Sometimes, not all processors need a result and in that case one     would call the  [2.x.85]  function instead of the      [2.x.86]  function. The latter is at most twice as     expensive, so if you are concerned about performance, it may be     worthwhile investigating whether your algorithm indeed needs the result     everywhere.    
* [0.x.46]*
     Like the previous function, but performs the [1.x.4] operation     on each element of an array. In other words, the i-th element of the     results array is the result of the [1.x.5] operation applied on     the i-th entries of the input arrays from each processor. T and U must     decay to the same type, e.g., they just differ by one of them having a     const type qualifier and the other not.         Input and output arrays may be the same.        
*  [2.x.87]  Depending on your standard library, this function may not work with       specializations of  [2.x.88]  for the data type `bool`. In that       case, use a different container or data type.    
* [0.x.47]*
     Like the previous function, but performs the [1.x.6] operation     on each element of an array as specified by the ArrayView arguments.     In other words, the i-th element of the results array is the result of     the [1.x.7] operation applied on the i-th entries of the input     arrays from each processor.         Input and output arrays may be the same.    
* [0.x.48]*
     A data structure to store the result of the min_max_avg() function.     The structure stores the minimum, maximum, and average of one     value contributed by each processor that participates in an      [2.x.89]  "MPI communicator".     The structure also stores     the indices (or, more precisely, the      [2.x.90]  "MPI rank")     of the processors that hold the minimum and maximum values,     as well as the sum over all values.        
*  [2.x.91]  This structure has no constructors because MPI requires it       to be a POD type.    
* [0.x.49]*
       The sum over all values contributed by the processors that       participate in the call to min_max_avg().      
* [0.x.50]*
       The minimum value over all values contributed by the processors that       participate in the call to min_max_avg().      
* [0.x.51]*
       The maximum value over all values contributed by the processors that       participate in the call to min_max_avg().      
* [0.x.52]*
       One of the ranks (i.e.,        [2.x.92]  "MPI rank"       within an        [2.x.93]  "MPI communicator")       of the       processors that hold the minimal value.      
* [0.x.53]*
       One of the ranks (i.e.,        [2.x.94]  "MPI rank"       within an        [2.x.95]  "MPI communicator")       of the       processors that hold the maximal value.      
* [0.x.54]*
       The average of the values contributed by the processors that       participate in the call to min_max_avg().      
* [0.x.55]*
     Return sum, average, minimum, maximum, processor id of minimum and     maximum as a collective operation of on the given MPI      [2.x.96]  "communicator"      [2.x.97]  Each processor's value is given in  [2.x.98]  and     the result will be returned. The result is available on all machines.        
*  [2.x.99]  Sometimes, not all processors need a result and in that case one     would call the  [2.x.100]  function instead of the      [2.x.101]  function. The latter is at most twice as     expensive, so if you are concerned about performance, it may be     worthwhile investigating whether your algorithm indeed needs the result     everywhere.    
* [0.x.56]*
     Same as above but returning the sum, average, minimum, maximum,     process id of minimum and maximum as a collective operation on the     given MPI      [2.x.102]  "communicator"      [2.x.103]  for each entry of the vector.        
*  [2.x.104]  This function performs a single reduction sweep.          [2.x.105]  Size of the input vector has to be the same on all processes.    
* [0.x.57]*
     Same as above but returning the sum, average, minimum, maximum,     process id of minimum and maximum as a collective operation on the     given MPI      [2.x.106]  "communicator"      [2.x.107]  for each entry of the ArrayView.        
*  [2.x.108]  This function performs a single reduction sweep.          [2.x.109]  Size of the input ArrayView has to be the same on all processes       and the input and output ArrayVew have to have the same size.    
* [0.x.58]*
     A class that is used to initialize the MPI system at the beginning of a     program and to shut it down again at the end. It also allows you to     control the number of threads used within each MPI process.         If deal.II is configured with PETSc, PETSc will be initialized     via `PetscInitialize` in the beginning (constructor of this     class) and de-initialized via `PetscFinalize` at the end (i.e.,     in the destructor of this class). The same is true for SLEPc.         If deal.II is configured with p4est, that library will also be     initialized in the beginning, and de-initialized at the end     (by calling sc_init(), p4est_init(), and sc_finalize()).         If a program uses MPI one would typically just create an object     of this type at the beginning of  [2.x.110] . The     constructor of this class then runs  [2.x.111]      with the given arguments and also initializes the other     libraries mentioned above. At the end of the program, the     compiler will invoke the destructor of this object which in     turns calls  [2.x.112]  to shut down the MPI     system.         This class is used in  [2.x.113] ,  [2.x.114] ,  [2.x.115] ,  [2.x.116] , and     several others.        
*  [2.x.117]  This class performs initialization of the MPI subsystem     as well as the dependent libraries listed above through the     `MPI_COMM_WORLD` communicator. This means that you will have to     create an MPI_InitFinalize object on [1.x.8] MPI processes,     whether or not you intend to use deal.II on a given     processor. In most use cases, one will of course want to work     on all MPI processes using essentially the same program, and so     this is not an issue. But if you plan to run deal.II-based work     on only a subset of MPI processes, using an @ ref     GlossMPICommunicator "MPI communicator" that is a subset of     `MPI_COMM_WORLD` (for example, in client-server settings where     only a subset of processes is responsible for the finite     element communications and the remaining processes do other     things), then you still need to create this object here on all     MPI processes at the beginning of the program because it uses     `MPI_COMM_WORLD` during initialization.    
* [0.x.59]*
       Initialize MPI (and, if deal.II was configured to use it, PETSc) and       set the number of threads used by deal.II (via the underlying       Threading Building Blocks library) to the given parameter.              [2.x.118]  argc A reference to the 'argc' argument passed to       main. This argument is used to initialize MPI (and, possibly, PETSc)       as they read arguments from the command line.        [2.x.119]  argv A reference to the 'argv' argument passed to       main.        [2.x.120]  max_num_threads The maximal number of threads this MPI       process should utilize. If this argument is set to        [2.x.121]  (the default value), then the number of       threads is determined automatically in the following way: the number       of threads to run on this MPI process is set in such a way that all       of the cores in your node are spoken for. In other words, if you have       started one MPI process per node, setting this argument is equivalent       to setting it to the number of cores present in the node this MPI       process runs on. If you have started as many MPI processes per node       as there are cores on each node, then this is equivalent to passing 1       as the argument. On the other hand, if, for example, you start 4 MPI       processes on each 16-core node, then this option will start 4 worker       threads for each node. If you start 3 processes on an 8 core node,       then they will start 3, 3 and 2 threads, respectively.            
*  [2.x.122]  This function calls  [2.x.123]  with       either  [2.x.124]  or, following the discussion above, a       number of threads equal to the number of cores allocated to this MPI       process. However,  [2.x.125]  in turn also       evaluates the environment variable DEAL_II_NUM_THREADS. Finally, the       worker threads can only be created on cores to which the current MPI       process has access to; some MPI implementations limit the number of       cores each process may access to one or a subset of cores in order to       ensure better cache behavior. Consequently, the number of threads       that will really be created will be the minimum of the argument       passed here, the environment variable (if set), and the number of       cores accessible to the thread.            
*  [2.x.126]   [2.x.127]  can only work if it is       called before any threads are created. The safest place for a call to       it is therefore at the beginning of  [2.x.128] .       Consequently, this extends to the current class: the best place to       create an object of this type is also at or close to the top of        [2.x.129] .      
* [0.x.60]*
       Destructor. Calls <tt>MPI_Finalize()</tt> in case this class owns the       MPI process.      
* [0.x.61]*
       Register a reference to an MPI_Request       on which we need to call `MPI_Wait` before calling `MPI_Finalize`.             The object  [2.x.130]  needs to exist when MPI_Finalize is called, which means the       request is typically statically allocated. Otherwise, you need to call       unregister_request() before the request goes out of scope. Note that it       is acceptable for a request to be already waited on (and consequently       reset to MPI_REQUEST_NULL).             It is acceptable to call this function more than once with the same       instance (as it is done in the example below).             Typically, this function is used by CollectiveMutex and not directly,       but it can also be used directly like this:      
* [1.x.9]
*       
* [0.x.62]*
       Unregister a request previously added using register_request().      
* [0.x.63]*
       A structure that has  [2.x.131]  objects to register a call back       to run after MPI init or finalize.             For documentation on signals, see       http://www.boost.org/doc/libs/release/libs/signals2 .      
* [0.x.64]*
         A signal that is triggered immediately after we have         initialized the MPI context with  [2.x.132] .        
* [0.x.65]*
         A signal that is triggered just before we close the MPI context         with  [2.x.133] . It can be used to deallocate         statically allocated MPI resources that need to be deallocated         before  [2.x.134]  is called.        
* [0.x.66]*
       Requests to MPI_Wait before finalizing      
* [0.x.67]*
     Return whether (i) deal.II has been compiled to support MPI (for     example by compiling with  [2.x.135] ) and if so whether     (ii)  [2.x.136]  has been called (for example using the      [2.x.137]  class). In other words, the result     indicates whether the current job is running under MPI.        
*  [2.x.138]  The function does not take into account whether an MPI job     actually runs on more than one processor or is, in fact, a single-node     job that happens to run under MPI.    
* [0.x.68]*
     Initiate a some-to-some communication, and exchange arbitrary objects     (the class T should be serializable using  [2.x.139]  between     processors.          [2.x.140]  comm MPI communicator.          [2.x.141]  objects_to_send A map from the rank (unsigned int) of the      process meant to receive the data and the object to send (the type `T`      must be serializable for this function to work properly). If this      map contains an entry with a key equal to the rank of the current      process (i.e., an instruction to a process to send data to itself),      then this data item is simply copied to the returned object.          [2.x.142]  A map from the rank (unsigned int) of the process      which sent the data and object received.    
* [0.x.69]*
     A generalization of the classic MPI_Allgather function, that accepts     arbitrary data types T, as long as  [2.x.143]  accepts T as an     argument.          [2.x.144]  comm MPI communicator.      [2.x.145]  object_to_send An object to send to all other processes          [2.x.146]  A vector of objects, with size equal to the number of      processes in the MPI communicator. Each entry contains the object      received from the processor with the corresponding rank within the      communicator.    
* [0.x.70]*
     A generalization of the classic MPI_Gather function, that accepts     arbitrary data types T, as long as  [2.x.147]  accepts T as an     argument.          [2.x.148]  comm MPI communicator.      [2.x.149]  object_to_send an object to send to the root process      [2.x.150]  root_process The process, which receives the objects from all     processes. By default the process with rank 0 is the root process.          [2.x.151]  The  [2.x.152]  receives a vector of objects, with size equal to the number of      processes in the MPI communicator. Each entry contains the object      received from the processor with the corresponding rank within the      communicator. All other processes receive an empty vector.    
* [0.x.71]*
     Sends an object  [2.x.153]  from the process  [2.x.154]      to all other processes.         A generalization of the classic `MPI_Bcast` function that accepts     arbitrary data types `T`, as long as  [2.x.155]  (which in turn     uses  [2.x.156]  see in  [2.x.157]  for details) accepts     `T` as an argument.          [2.x.158]  comm MPI communicator.      [2.x.159]  object_to_send An object to send to all processes.      [2.x.160]  root_process The process that sends the object to all     processes. By default the process with rank 0 is the root process.          [2.x.161]  On the root process, return a copy of  [2.x.162]        On every other process, return a copy of the object sent by       the  [2.x.163]     
* [0.x.72]*
     A function that combines values  [2.x.164]  from all processes     via a user-specified binary operation  [2.x.165]  on the  [2.x.166]      As such this function is similar to MPI_Reduce (and      [2.x.167]  however on the one hand due to the     user-specified binary operation it is slower for built-in types but     on the other hand general object types, including ones that store     variable amounts of data, can be handled.         In contrast to all_reduce, the result will be only available on a     single rank. On all other processes, the returned value is undefined.    
* [0.x.73]*
     A function that combines values  [2.x.168]  from all processes     via a user-specified binary operation  [2.x.169]  and distributes the     result back to all processes. As such this function is similar to     MPI_Allreduce (if it were implemented by a global reduction followed     by a broadcast step) but due to the user-specified binary operation also     general object types, including ones that store variable amounts of data,     can be handled.    
* [0.x.74]*
     Given a partitioned index set space, compute the owning MPI process rank     of each element of a second index set according to the partitioned index     set. A natural usage of this function is to compute for each ghosted     degree of freedom the MPI rank of the process owning that index.         One might think: "But we know which rank a ghost DoF belongs to based on     the subdomain id of the cell it is on". But this heuristic fails for DoFs     on interfaces between ghost cells with different subdomain_ids, or     between a ghost cell and an artificial cell. Furthermore, this function     enables a completely abstract exchange of information without the help of     the mesh in terms of neighbors.         The first argument passed to this function,  [2.x.170]  must     uniquely partition an index space between all processes.     Otherwise, there are no limitations on this argument: In particular,     there is no need in partitioning     the index space into contiguous subsets. Furthermore, there are no     limitations     on the second index set  [2.x.171]  as long as the size matches     the first one. It can be chosen arbitrarily and independently on each     process. In the case that the second index set also contains locally     owned indices, these indices will be treated correctly and the rank of     this process is returned for those entries.        
*  [2.x.172]  This is a collective operation: all processes within the given     communicator have to call this function. Since this function does not     use MPI_Alltoall or MPI_Allgather, but instead uses non-blocking     point-to-point communication instead, and only a single non-blocking     barrier, it reduces the memory consumption significantly. This function     is suited for large-scale simulations with >100k MPI ranks.          [2.x.173]  owned_indices Index set with indices locally owned by this                process.      [2.x.174]  indices_to_look_up Index set containing indices of which the                user is interested the rank of the owning process.      [2.x.175]  comm MPI communicator.          [2.x.176]  List containing the MPI process rank for each entry in the index             set  [2.x.177]  The order coincides with the order             within the ElementIterator.    
* [0.x.75]*
     Compute the union of the input vectors  [2.x.178]  of all processes in the       MPI communicator  [2.x.179]         
*  [2.x.180]  This is a collective operation. The result will available on all       processes.    
* [0.x.76]*
     The same as above but for  [2.x.181]     
* [0.x.77]

include/deal.II-translator/base/mpi_compute_index_owner_internal_0.txt
[0.x.0]*
       An internal namespace used for  [2.x.0]        and for  [2.x.1]       
* [0.x.1]*
         Specialization of  [2.x.2]  for setting up the         Dictionary even if there are ranges in the IndexSet space not owned         by any processes.                
*  [2.x.3]  Only for internal usage.        
* [0.x.2]*
           Constructor.          
* [0.x.3]*
           Implementation of            [2.x.4]           
* [0.x.4]*
           Implementation of            [2.x.5]           
* [0.x.5]*
           Implementation of            [2.x.6]           
* [0.x.6]*
         Dictionary class with basic partitioning in terms of a single         interval of fixed size known to all MPI ranks for two-stage index         lookup.        
* [0.x.7]*
           The minimum grain size for the intervals.                     We choose to limit the smallest size an interval for the           two-stage lookup can have with the following two conflicting           goals in mind: On the one hand, we do not want intervals in the           dictionary to become too short. For uneven distributions of           unknowns (some ranks with several thousands of unknowns, others           with none), the lookup DoFs
* 
-> dictionary then involves sending           from one MPI rank to many other MPI ranks holding dictionary           intervals, leading to an exceedingly high number of messages some           ranks have to send. Also, fewer longer intervals are generally           more efficient to look up. On the other hand, a range size too           large leads to opposite effect of many messages that come into a           particular dictionary owner in the lookup DoFs
* 
->           dictionary. With the current setting, we get at most 64 messages           coming to a single MPI rank in case there is 1 dof per MPI rank,           which is reasonably low. At the same time, uneven distributions           up to factors of 4096 can be handled with at most 64 messages as           well.          
* [0.x.8]*
           A vector with as many entries as there are dofs in the dictionary           of the current process, and each entry containing the rank of the           owner of that dof in the IndexSet `owned_indices`. This is           queried in the index lookup, so we keep an expanded list.          
* [0.x.9]*
           A sorted vector containing the MPI ranks appearing in           `actually_owning_ranks`.          
* [0.x.10]*
           The number of unknowns in the dictionary for on each MPI rank           used for the index space splitting. For simplicity of index           lookup without additional communication, this number is the same           on all MPI ranks.          
* [0.x.11]*
           The local range of the global index space that is represented in           the dictionary, computed from `dofs_per_process`, the current           MPI rank, and range_minimum_grain_size.          
* [0.x.12]*
           The actual size, computed as the minimum of dofs_per_process and           the possible end of the index space. Equivalent to           `local_range.second
* 
*  - local_range.first`.          
* [0.x.13]*
           The global size of the index space.          
* [0.x.14]*
           The number of ranks the `owned_indices` IndexSet is distributed           among.          
* [0.x.15]*
           A stride to distribute the work more evenly over MPI ranks in           case the grain size forces us to have fewer ranges than we have           processors.          
* [0.x.16]*
           Set up the dictionary by computing the partitioning from the           global size and sending the rank information on locally owned           ranges to the owner of the dictionary part.          
* [0.x.17]*
           Translate a global dof index to the MPI rank in the dictionary           using `dofs_per_process`. We multiply by `stride_small_size` to           ensure a balance over the MPI ranks due to the grain size.          
* [0.x.18]*
           Given an MPI rank id of an arbitrary processor, return the index           offset where the local range of that processor begins.          
* [0.x.19]*
           Given the rank in the owned indices from `actually_owning_ranks`,           this returns the index of the rank in the           `actually_owning_rank_list`.          
* [0.x.20]*
           Compute the partition from the global size of the index space and           the number of ranks.          
* [0.x.21]*
         Specialization of  [2.x.7]  for the context of          [2.x.8]  and          [2.x.9]  with additional         payload.        
* [0.x.22]*
           Constructor.          
* [0.x.23]*
           The index space which describes the locally owned space.          
* [0.x.24]*
           The indices which are "ghosts" on a given rank and should be           looked up in terms of their owner rank from owned_indices.          
* [0.x.25]*
           The underlying MPI communicator.          
* [0.x.26]*
           The present MPI rank.          
* [0.x.27]*
           The total number of ranks participating in the MPI communicator           `comm`.          
* [0.x.28]*
           Controls whether the origin of ghost owner should also be           stored. If true, it will be added into `requesters` and can be           queried by `get_requesters()`.          
* [0.x.29]*
           The result of the index owner computation: To each index           contained in `indices_to_look_up`, this vector contains the MPI           rank of the owner in `owned_indices`.          
* [0.x.30]*
           Keeps track of the origin of the requests. The layout of the data           structure is as follows: The outermost vector has as many entries           as  [2.x.10]  and represents the           information we should send back to the owners from the present           dictionary entry. The second vector then collects a list of MPI           ranks that have requested data, using the rank in the first pair           entry and a list of index ranges as the second entry.          
* [0.x.31]*
           The dictionary handling the requests.          
* [0.x.32]*
           Array to collect the indices to look up, sorted by the rank in           the dictionary.          
* [0.x.33]*
           The field where the indices for incoming data from the process           are stored.          
* [0.x.34]*
           Implementation of            [2.x.11]            adding the owner of a particular index in request_buffer (and           keeping track of who requested a particular index in case that           information is also desired).          
* [0.x.35]*
           Implementation of            [2.x.12]           
* [0.x.36]*
           Implementation of            [2.x.13]           
* [0.x.37]*
           Implementation of            [2.x.14]           
* [0.x.38]*
           Implementation of            [2.x.15]           
* [0.x.39]*
           Resolve the origin of the requests by sending the information           accumulated in terms of the dictionary owners during the run of           the consensus algorithm back to the owner in the original           IndexSet. This requires some point-to-point communication.                      [2.x.16]  Map of processors and associated ranges of indices that                   are requested from the current rank          
* [0.x.40]*
           Stores the index request in the `requesters` field. We first find           out the owner of the index that was requested (using the guess in           `owner_index`, as we typically might look up on the same rank           several times in a row, which avoids the binary search in            [2.x.17]  Once we know the rank of the           owner, we the vector entry with the rank of the request. Here, we           utilize the fact that requests are processed rank-by-rank, so we           can simply look at the end of the vector if there is already some           data stored or not. Finally, we build ranges, again using that           the index list is sorted and we therefore only need to append at           the end.          
* [0.x.41]

include/deal.II-translator/base/mpi_consensus_algorithms_0.txt
[0.x.0]*
     A namespace for consensus algorithms designed for dynamic-sparse     communication patterns.        
*  [2.x.0]     
* [0.x.1]*
       An interface to be able to use the Interface classes. The main       functionality of the implementations is to return a list of process       ranks this process wants data from and to deal with the optional       payload of the messages sent/received by the ConsensusAlgorithm       classes.             There are two kinds of messages:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - send/request message: A message consisting of a data request         which should be answered by another process. This message is         considered as a request message by the receiving rank.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - recv message: The answer to a send/request message.              [2.x.1]  T1 the type of the elements of the vector to sent        [2.x.2]  T2 the type of the elements of the vector to received            
*  [2.x.3]  Since the payloads of the messages are optional, users have             to deal with buffers themselves. The ConsensusAlgorithm classes       1) deliver only references to empty vectors (of size 0) the data to be       sent can be inserted to or read from, and 2) communicate these vectors       blindly.      
* [0.x.2]*
         Destructor.        
* [0.x.3]*
          [2.x.4]  A vector of ranks this process wants to send a request to.                
*  [2.x.5]  This is the only method which has to be implemented since the               payloads of the messages are optional.        
* [0.x.4]*
         Add to the request to the process with the specified rank a payload.                  [2.x.6]   other_rank rank of the process          [2.x.7]  send_buffer data to be sent part of the request         (optional)                
*  [2.x.8]  The buffer is empty. Before using it, you have to set its size.        
* [0.x.5]*
         Prepare the buffer where the payload of the answer of the request to         the process with the specified rank is saved in. The most obvious         task is to resize the buffer, since it is empty when the function is         called.                  [2.x.9]   other_rank rank of the process          [2.x.10]  recv_buffer data to be sent part of the request         (optional)        
* [0.x.6]*
         Prepare the buffer where the payload of the answer of the request to         the process with the specified rank is saved in.                  [2.x.11]   other_rank rank of the process          [2.x.12]   buffer_recv received payload (optional)          [2.x.13]  request_buffer payload to be sent as part of the request                     (optional)                
*  [2.x.14]  The request_buffer is empty. Before using it, you have to set               its size.        
* [0.x.7]*
         Process the payload of the answer of the request to the process with         the specified rank.                  [2.x.15]  other_rank rank of the process          [2.x.16]  recv_buffer data to be sent part of the request (optional)        
* [0.x.8]*
       A base class for algorithms that implement the task of coming up with       communication patterns to retrieve data from other processes in a       dynamic-sparse way. In computer science, this is often called a       [1.x.0].             Dynamic-sparse means in this context:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - By the time this function is called, the other processes do         not know yet that they have to answer requests.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Each process only has to communicate with a small subset of         processes of the MPI communicator.             Naturally, the user has to provide:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A communicator.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - For each rank a list of ranks of processes this process should         communicate to.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Functionality to pack/unpack data to be sent/received.             This base class only introduces a basic interface to achieve       these goals, while derived classes implement different algorithms       to actually compute such communication patterns.       The last two features of the list above this paragraph are implemented       in classes derived from  [2.x.17]               [2.x.18]  T1 The type of the elements of the vector to be sent.        [2.x.19]  T2 The type of the elements of the vector to be received.      
* [0.x.9]*
         Destructor.        
* [0.x.10]*
         Run consensus algorithm and return the requesting processes.        
* [0.x.11]*
         Reference to the process provided by the user.        
* [0.x.12]*
         MPI communicator.        
* [0.x.13]*
         Cache if job supports MPI.        
* [0.x.14]*
         Rank of this process.        
* [0.x.15]*
         Number of processes in the communicator.        
* [0.x.16]*
       This class implements a concrete algorithm for the        [2.x.20]  base class, using only point-to-point       communications and a single IBarrier.            
*  [2.x.21]  This class closely follows  [2.x.22] . Since the             algorithm shown there is not considering payloads, the algorithm             has been modified here in such a way that synchronous sends             (Issend) have been replaced by equivalent Isend/Irecv, where             Irecv receives the answer to a request (with payload).              [2.x.23]  T1 The type of the elements of the vector to be sent.        [2.x.24]  T2 The type of the elements of the vector to be received.      
* [0.x.17]*
         Constructor.                  [2.x.25]  process Process to be run during consensus algorithm.          [2.x.26]  comm MPI Communicator        
* [0.x.18]*
         Destructor.        
* [0.x.19]*
          [2.x.27]   [2.x.28]         
* [0.x.20]*
         List of processes this process wants to send requests to.        
* [0.x.21]*
         Buffers for sending requests.        
* [0.x.22]*
         Requests for sending requests.        
* [0.x.23]*
         Buffers for receiving answers to requests.        
* [0.x.24]*
         Requests for receiving answers to requests.        
* [0.x.25]*
         Buffers for sending answers to requests.        
* [0.x.26]*
         Requests for sending answers to requests.        
* [0.x.27]*
         List of processes who have made a request to this process.        
* [0.x.28]*
         Check if all request answers have been received by this rank.        
* [0.x.29]*
         Signal to all other ranks that this rank has received all request         answers via entering IBarrier.        
* [0.x.30]*
         Check if all ranks have received all their request answers, i.e.         all ranks have reached the IBarrier.        
* [0.x.31]*
         A request message from another rank has been received: process the         request and send an answer.        
* [0.x.32]*
         Start to send all requests via ISend and post IRecvs for the incoming         answer messages.        
* [0.x.33]*
         After all rank has received all answers, the MPI data structures can         be freed and the received answers can be processed.        
* [0.x.34]*
       This class implements a concrete algorithm for the        [2.x.29]  base class, using a two step approach.       In the first step the source ranks are determined and in the second       step a static sparse data exchange is performed.            
*  [2.x.30]  In contrast to NBX, this class splits the same         task into two distinct steps. In the first step, all processes         are identified who want to send a request to this process. In the         second step, the data is exchanged. However, since
* 
*  - in the         second step
* 
*  - now it is clear how many requests have to be answered,         i.e. when this process can stop waiting for requests, no IBarrier is         needed.            
*  [2.x.31]  The function          [2.x.32]  is         used to determine the source processes, which implements a         PEX-algorithm from  [2.x.33] .              [2.x.34]  T1 The type of the elements of the vector to be sent.        [2.x.35]  T2 The type of the elements of the vector to be received.      
* [0.x.35]*
         Constructor.                  [2.x.36]  process Process to be run during consensus algorithm.          [2.x.37]  comm MPI Communicator        
* [0.x.36]*
         Destructor.        
* [0.x.37]*
          [2.x.38]   [2.x.39]         
* [0.x.38]*
         List of ranks of processes this processes wants to send a request to.        
* [0.x.39]*
         List of ranks of processes wanting to send a request to this process.        
* [0.x.40]*
         Buffers for sending requests.        
* [0.x.41]*
         Buffers for receiving answers to requests.        
* [0.x.42]*
         Requests for sending requests and receiving answers to requests.        
* [0.x.43]*
         Buffers for sending answers to requests.        
* [0.x.44]*
         Requests for sending answers to requests.        
* [0.x.45]*
         List of processes who have made a request to this process.        
* [0.x.46]*
         The ith request message from another rank has been received: process         the request and send an answer.        
* [0.x.47]*
         Start to send all requests via ISend and post IRecvs for the incoming         answer messages.        
* [0.x.48]*
         After all answers have been exchanged, the MPI data structures can be         freed and the received answers can be processed.        
* [0.x.49]*
       A serial fall back for the above classes to allow programming       independently of whether MPI is used or not.      
* [0.x.50]*
         Constructor.                  [2.x.40]  process Process to be run during consensus algorithm.          [2.x.41]  comm MPI Communicator (ignored)        
* [0.x.51]*
          [2.x.42]   [2.x.43]         
* [0.x.52]*
       A class which delegates its task to other        [2.x.44]  implementations depending on the number       of processes in the MPI communicator. For a small number of processes       it uses PEX and for a large number of processes NBX. The threshold       depends if the program is compiled in debug or release mode.              [2.x.45]  T1 The type of the elements of the vector to be sent.        [2.x.46]  T2 The type of the elements of the vector to be received.      
* [0.x.53]*
         Constructor.                  [2.x.47]  process Process to be run during consensus algorithm.          [2.x.48]  comm MPI Communicator.        
* [0.x.54]*
         Destructor.        
* [0.x.55]*
          [2.x.49]   [2.x.50]                 
*  [2.x.51]  The function call is delegated to another  [2.x.52]  implementation.        
* [0.x.56]*
       This class implements  [2.x.53]        using user-provided function wrappers.       The advantage of this class is that users do not have to write their       own implementation but can register lambda functions directly.      
* [0.x.57]*
         Register functions that should be called for implementing the         interface of Process.                  [2.x.54]  function_compute_targets called during `compute_targets`.          [2.x.55]  function_create_request called during `create_request`.          [2.x.56]  function_answer_request called during `answer_request`.          [2.x.57]  function_prepare_buffer_for_answer called during           `prepare_buffer_for_answer`.          [2.x.58]  function_read_answer called during `read_answer`.        
* [0.x.58]*
          [2.x.59]   [2.x.60]         
* [0.x.59]*
          [2.x.61]   [2.x.62]         
* [0.x.60]*
          [2.x.63]   [2.x.64]         
* [0.x.61]*
          [2.x.65]   [2.x.66]         
* [0.x.62]*
          [2.x.67]   [2.x.68]         
* [0.x.63]

include/deal.II-translator/base/mpi_consensus_algorithms.templates_0.txt
[0.x.0]

include/deal.II-translator/base/mpi_noncontiguous_partitioner_0.txt
[0.x.0]*
     A flexible Partitioner class, which does not impose restrictions     regarding the order of the underlying index sets.    
* [0.x.1]*
       Default constructor. Requires calling one of the reinit() functions       to create a valid object.      
* [0.x.2]*
       Constructor. Set up point-to-point communication pattern based on the       IndexSets arguments  [2.x.0]  and  [2.x.1]  for the MPI       communicator  [2.x.2]       
* [0.x.3]*
       Constructor. Same as above but for vectors of indices  [2.x.3]        and  [2.x.4]  This allows the indices to not be sorted and the       values are read and written automatically at the right position of       the vector during update_values(), update_values_start(), and       update_values_finish(). It is allowed to include entries with the       value  [2.x.5]  which do not take part of the index       exchange but are present in the data vectors as padding.      
* [0.x.4]*
       Fill the vector  [2.x.6]  according to the precomputed communication       pattern with values from  [2.x.7]               [2.x.8]  The vectors only have to provide a method begin(), which allows         to access their raw data.              [2.x.9]  The size of both vectors must be at least as large as the number         of entries in the index sets passed to the constructors or the         reinit() functions.            
*  [2.x.10]  This function calls the methods update_values_start() and         update_values_finish() in sequence. Users can call these two         functions separately and hereby overlap communication and         computation.      
* [0.x.5]*
       Same as above but with an interface similar to        [2.x.11]  and        [2.x.12]  In this       function, the user can provide the temporary data structures to be       used.              [2.x.13]  The size of the  [2.x.14]  vector has to be at least         temporary_storage_size. The reason for this is that this vector is         used as buffer for both sending and receiving data.            
*  [2.x.15]  Any value less than 10 is a valid value of          [2.x.16]       
* [0.x.6]*
       Start update: Data is packed, non-blocking send and receives       are started.            
*  [2.x.17]  In contrast to the function          [2.x.18]  the user         does not pass a reference to the destination vector, since the data         is received into a designated part of the buffer  [2.x.19]  This         allows for padding and other post-processing of the received data.              [2.x.20]  The required size of the vectors are the same as in the functions         above.            
*  [2.x.21]  Any value less than 10 is a valid value of          [2.x.22]       
* [0.x.7]*
       Finish update. The method waits until all data has been sent and       received. Once data from any process is received it is processed and       placed at the right position of the vector  [2.x.23]             
*  [2.x.24]  In contrast to the function          [2.x.25]  the user         also has to pass a reference to the buffer  [2.x.26]          since the data has been received into the buffer and not into the         destination vector.              [2.x.27]  The required size of the vectors are the same as in the functions         above.      
* [0.x.8]*
       Returns the number of processes this process sends data to and the       number of processes this process receives data from.      
* [0.x.9]*
       Return the size of the temporary storage needed by the       export_to_ghosted_array() functions, if the temporary storage is       handled by the user code.      
* [0.x.10]*
       Return memory consumption in Byte.      
* [0.x.11]*
       Return the underlying communicator.      
* [0.x.12]*
       Initialize the inner data structures.      
* [0.x.13]*
       Initialize the inner data structures.      
* [0.x.14]*
       MPI communicator.      
* [0.x.15]*
       The ranks this process sends data to.      
* [0.x.16]*
       Offset of each process within send_buffer.            
*  [2.x.28]  Together with `send_indices` this forms a CRS data structure.      
* [0.x.17]*
       Local index of each entry in send_buffer within the destination       vector.            
*  [2.x.29]  Together with `send_ptr` this forms a CRS data structure.      
* [0.x.18]*
       The ranks this process receives data from.      
* [0.x.19]*
       Offset of each process within recv_buffer.            
*  [2.x.30]  Together with `recv_indices` this forms a CRS data structure.      
* [0.x.20]*
       Local index of each entry in recv_buffer within the destination       vector.            
*  [2.x.31]  Together with `recv_ptr` this forms a CRS data structure.      
* [0.x.21]*
       Buffer containing the values sorted by rank for sending and receiving.            
*  [2.x.32]  Only allocated if not provided externally by user.            
*  [2.x.33]  At this place we do not know the type of the data to be sent. So         we use an arbitrary type of size 1 byte. The type is cast to the         requested type in the relevant functions.      
* [0.x.22]*
       MPI requests for sending and receiving.            
*  [2.x.34]  Only allocated if not provided externally by user.      
* [0.x.23]

include/deal.II-translator/base/mpi_noncontiguous_partitioner.templates_0.txt
[0.x.0]

include/deal.II-translator/base/mpi_remote_point_evaluation_0.txt
[0.x.0]*
     Helper class to access values on non-matching grids.        
*  [2.x.0]  The name of the fields are chosen with the method       evaluate_and_process() in mind. Here, quantities are       computed at specified arbitrary positioned points (and even on remote       processes in the MPI universe) cell by cell and these values are sent       to requesting processes, which receive the result and resort the       result according to the points.    
* [0.x.1]*
       Constructor.              [2.x.1]  tolerance Tolerance in terms of unit cell coordinates for         determining all cells around a point passed to the class during         reinit(). Depending on the problem, it might be necessary to adjust         the tolerance in order to be able to identify a cell.         Floating point arithmetic implies that a point will, in general, not         lie exactly on a vertex, edge, or face.        [2.x.2]  enforce_unique_mapping Enforce unique mapping, i.e.,         (one-to-one) relation of points and cells.        [2.x.3]  rtree_level RTree level to be used during the construction of the bounding boxes.      
* [0.x.2]*
       Destructor.      
* [0.x.3]*
       Set up internal data structures and communication pattern based on       a list of points  [2.x.4]  and mesh description ( [2.x.5]  and  [2.x.6]        mapping).              [2.x.7]  This is a collective call that needs to be executed by all         processors in the communicator.      
* [0.x.4]*
       Data of points positioned in a cell.      
* [0.x.5]*
         Level and index of cells.        
* [0.x.6]*
         Pointers to beginning and ending of the (reference) points         associated to the cell.        
* [0.x.7]*
         Reference points in the interval [0,1]^dim.        
* [0.x.8]*
       Evaluate function  [2.x.8]  in the given  points and       triangulation. The result is stored in  [2.x.9]             
*  [2.x.10]  If the map of points to cells is not a         one-to-one relation (is_map_unique()==false), the result needs to be         processed with the help of get_point_ptrs(). This         might be the case if a point coincides with a geometric entity (e.g.,         vertex) that is shared by multiple cells or a point is outside of the         computational domain.              [2.x.11]  This is a collective call that needs to be executed by all         processors in the communicator.      
* [0.x.9]*
       This method is the inverse of the method evaluate_and_process(). It       makes the data at the points, provided by  [2.x.12]  available in the       function  [2.x.13]               [2.x.14]  This is a collective call that needs to be executed by all         processors in the communicator.      
* [0.x.10]*
       Return a CRS-like data structure to determine the position of the       result corresponding a point and the amount.      
* [0.x.11]*
       Return if points and cells have a one-to-one relation. This is not the       case if a point is not owned by any cell (the point is outside of the       domain) or if multiple cells own the point (the point is positioned       on a geometric entity shared by neighboring cells).      
* [0.x.12]*
       Return the Triangulation object used during reinit().      
* [0.x.13]*
       Return the Mapping object used during reinit().      
* [0.x.14]*
       Return if the internal data structures have been set up and if yes       whether they are still valid (and not invalidated due to changes of the       Triangulation).      
* [0.x.15]*
       Tolerance to be used while determining the surrounding cells of a       point.      
* [0.x.16]*
       Enforce unique mapping, i.e., (one-to-one) relation of points and       cells.      
* [0.x.17]*
       RTree level to be used during the construction of the bounding boxes.      
* [0.x.18]*
       Storage for the status of the triangulation signal.      
* [0.x.19]*
       Flag indicating if the reinit() function has been called and if yes       the triangulation has not been modified since then (potentially       invalidating the communication pattern).      
* [0.x.20]*
       Reference to the Triangulation object used during reinit().      
* [0.x.21]*
       Reference to the Mapping object used during reinit().      
* [0.x.22]*
       (One-to-one) relation of points and cells.      
* [0.x.23]*
       Since for each point multiple or no results can be available, the       pointers in this vector indicate the first and last entry associated       with a point in a CRS-like fashion.      
* [0.x.24]*
       Permutation index within a recv buffer.      
* [0.x.25]*
       Pointers of ranges within a receive buffer that are filled by ranks       specified by recv_ranks.      
* [0.x.26]*
       Ranks from where data is received.      
* [0.x.27]*
       Point data sorted according to cells so that evaluation (incl. reading       of degrees of freedoms) needs to performed only once per cell.      
* [0.x.28]*
       Permutation index within a send buffer.      
* [0.x.29]*
       Ranks to send to.      
* [0.x.30]*
       Pointers of ranges within a send buffer to be sent to the ranks       specified by send_ranks.      
* [0.x.31]

include/deal.II-translator/base/mpi_tags_0.txt
[0.x.0]*
       This enum holds all MPI tags used in point to point MPI communications       inside the deal.II library.             We keep these tags in a central location so that they are unique within       the library. Otherwise, communication that receives packages might pick       up packets from a different algorithm. This is especially true if       MPI_ANY_SOURCE is used.             The list of MPI functions that use an MPI tag is:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - MPI_Send, MPI_Recv, MPI_Sendrecv
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - MPI_Isend, MPI_Irecv
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - MPI_Probe, MPI_Iprobe
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - MPI_Comm_create_group, MPI_Intercomm_create,        [2.x.0]       
* [0.x.1]*
         The enum with the tags.        
* [0.x.2]

include/deal.II-translator/base/mpi.templates_0.txt
[0.x.0]*
       Return the corresponding MPI data type id for the argument given.      
* [0.x.1]

include/deal.II-translator/base/multithread_info_0.txt
[0.x.0]*
 This class provides information about the system which may be of use in multithreaded programs.  At the moment this is just the number of CPUs. If deal.II is compiled with multithreading support, some functions will use multiple threads for their action. Currently the library supports both thread-based and task-based parallelism.  [2.x.0]  describes the different uses of each. The default number of threads used for task-based parallel methods is selected automatically by the Threading Building Blocks library. See  [2.x.1]  for more information on this.  Thread-based parallel methods need to explicitly create threads and may want to use a number of threads that is related to the number of CPUs in your system. The recommended number of threads can be queried using  [2.x.2]  while the number of cores in the system is returned by  [2.x.3] 
* 

* 
*  [2.x.4] 

* 
* [0.x.1]*
   Constructor. This constructor is deleted because no instance of   this class needs to be constructed (all members are static).  
* [0.x.2]*
   The number of CPUs in the system.     This internally calls    [2.x.5]    but sets the result to 1 if the call returns an error.  
* [0.x.3]*
   Return the number of threads to use. This is initially set to the number   of cores the system has (see n_cores()) but can be further restricted by   set_thread_limit() and the environment variable DEAL_II_NUM_THREADS.  
* [0.x.4]*
   Return an estimate for the memory consumption, in bytes, of this object.   This is not exact (but will usually be close) because calculating the   memory usage of trees (e.g.,  [2.x.6]  is difficult.  
* [0.x.5]*
   Set the maximum number of threads to be used to the minimum of the   environment variable DEAL_II_NUM_THREADS and the given argument (or its   default value). This affects the initialization of the TBB. If neither is   given, the default from TBB is used (based on the number of cores in the   system).     This routine is executed automatically with the default argument before   your code in main() is running (using a static constructor). It is also   executed by  [2.x.7]  Use the appropriate   argument of the constructor of  [2.x.8]  if you   have an MPI based code.  
* [0.x.6]*
   Return if the TBB is running using a single thread either because of   thread affinity or because it is set via a call to set_thread_limit. This   is used in the PETScWrappers to avoid using the interface that is not   thread-safe.  
* [0.x.7]*
   Make sure the multithreading API is initialized. This normally does not   need to be called in usercode.  
* [0.x.8]*
   Return a reference to the global Executor from taskflow.     The Executor is set to use n_threads() worker threads that you can   control using set_thread_limit() and the DEAL_II_NUM_THREADS environment   variable.  
* [0.x.9]*
   Variable representing the maximum number of threads.  
* [0.x.10]*
   Store a taskflow Executor that is constructed with N workers (from   set_thread_limit).  
* [0.x.11]

include/deal.II-translator/base/mu_parser_internal_0.txt
[0.x.0]

include/deal.II-translator/base/mutable_bind_0.txt
[0.x.0]*
   A mutable version of  [2.x.0]  that binds all arguments of a function   pointer to a stored tuple, and allows you to update the tuple between   calls.     An example usage of this class is through the helper function   mutable_bind() that creates a MutableBind object on the fly, based on its   arguments:    
* [1.x.0]
*      The arguments are copied to the tuple, with their reference and const   attributes removed. Only copy constructible objects are allowed as   function arguments. If you need to keep some references around, you may   wrap your function into a lambda function:    
* [1.x.1]
*   
* [0.x.1]*
     An alias to the stored  [2.x.1]  type. Only copy constructible     objects are allowed as tuple members.    
* [0.x.2]*
     Construct a MutableBind object specifying the function, and     each arguments separately.    
* [0.x.3]*
     Construct a MutableBind object specifying the function, and     the arguments as a tuple.    
* [0.x.4]*
     Construct a MutableBind object specifying only the function. By default,     the arguments are left to their default constructor values.    
* [0.x.5]*
     Call the original function, passing as arguments the elements of the     tuple of bound arguments.    
* [0.x.6]*
     Set the arguments to use in  [2.x.2]  for next time     operator()() is called, using move semantic.    
* [0.x.7]*
     Set the arguments to use in  [2.x.3]  for next time     operator()() is called, using move semantic.    
* [0.x.8]*
     Parse the arguments to use in  [2.x.4]  from a string, for next time     operator()() is called.         The conversion is performed using a user supplied  [2.x.5]      object. By default,  [2.x.6]  is     used to determine how to convert from  [2.x.7]  to a TupleType     object.          [2.x.8]  value_string The string to convert from      [2.x.9]  pattern A unique pointer to the pattern to use when performing     the conversion    
* [0.x.9]*
     An  [2.x.10]  that stores the original function.    
* [0.x.10]*
     Currently stored arguments. These are forwarded to the function object     above, when calling operator()().    
* [0.x.11]*
   Create a MutableBind object from a function pointer and a list of   arguments.     An example usage is given by:  
* [1.x.2]
*   
* [0.x.12]*
   Same as above, using a  [2.x.11]  object.  
* [0.x.13]*
   Create a MutableBind object from a function pointer, with uninitialized   arguments.     Notice that if you do not call one of the  [2.x.12]    methods, or the  [2.x.13]  function on the returned   object, then the arguments passed to the function object will be   initialized with the values coming from each of the arguments' default   constructors.  
* [0.x.14]*
   Same as above, using a  [2.x.14]  object.  
* [0.x.15]

include/deal.II-translator/base/ndarray_0.txt
[0.x.0]*
     A variadic template helper class to recursively "unroll" the size     information of the ndarray. This is best explained on an example:    
* [1.x.0]
*     
* [0.x.1]*
     Recursively define the type alias "type" of HelperArray<T, N, ...Ns>     by wrapping a  [2.x.0]  around HelperArray<T,  [2.x.1]     
* [0.x.2]*
     End recursion once no  [2.x.2]  template parameters are left and     simply set the type alias to type T    
* [0.x.3]*
 A (variadic template) type alias for conveniently defining multidimensional [1.x.1]s
*  The problem we try to address with the type alias is the following. Suppose you want to create a multdimensional array of doubles of, for example, rank 3, with sizes 2, 3, 4 for the first, middle, and last index. Then using C-style arrays you could simply write

* 
* [1.x.2]
*  Nowadays, there are a number of good reasons why using C-style arrays is usually discouraged (ranging from incompatibilities with STL functions requiring awkward wrappers, surprises when comparing for equality, etc.) If you want to do the same, however, using the more modern (and encouraged)  [2.x.3]  class, then you would have to declare

* 
* [1.x.3]
*  The repetitions of  [2.x.4]  look awkward and, worse, the index ranges have reversed: the leftmost index has range [0,2), the middle index has range [0,3) and the rightmost index has range [0,4). We address this issue by providing a class ndarray that allows to you declare the above stacked  [2.x.5]  type by simply writing:

* 
* [1.x.4]
* 
* 

* 
*  [2.x.6]   [2.x.7]  is merely syntactic sugar in form of a [1.x.5] (`using` declaration). It is not a deal.II specific class, but merely a helper to cleanly define multidimensional arrays realized by "stacked"  [2.x.8]  classes.

* 
* [0.x.4]

include/deal.II-translator/base/numbers_0.txt
[0.x.0]*
   A helper class specifying the maximal vector length of VectorizedArray   for a specified data type Number for the given processor architecture and   optimization level.     The value of the maximal vector length is used as default template   argument in VectorizedArray, such that VectorizedArray<Number> is   equivalent to VectorizedArray<Number,    [2.x.0]     
*  [2.x.1]  This class is the default implementation for data types for which   no vectorization is supported.      [2.x.2]  Number The underlying data type for which one wants to find out     the maximal length of hardware supported vectors.  
* [0.x.1]*
     Maximal vector length of VectorizedArray for an arbitrary type.    
* [0.x.2]*
   A helper class specifying the maximal vector length of VectorizedArray   for the data type `double` for the given processor architecture and   optimization level. For a detailed description of supported maximal vector   lengths, see the documentation of VectorizedArray.  
* [0.x.3]*
     Maximal vector length of VectorizedArray for double.    
* [0.x.4]*
   A helper class specifying the maximal vector length of VectorizedArray   for the data type `float` for the given processor architecture and   optimization level. For a detailed description of supported maximal vector   lengths, see the documentation of VectorizedArray.  
* [0.x.5]*
     Maximal vector length of VectorizedArray for float.    
* [0.x.6]*
 Namespace for the declaration of universal constants. Since the availability in <tt>math.h</tt> is not always guaranteed, we put them here. Since this file is included by <tt>base/config.h</tt>, they are available to the whole library.
*  The constants defined here are a subset of the <tt>M_XXX</tt> constants sometimes declared in the system include file <tt>math.h</tt>, but without the prefix <tt>M_</tt>.
*  In addition to that, we declare  <tt>invalid_unsigned_int</tt> to be the largest unsigned integer representable; this value is widely used in the library as a marker for an invalid index, an invalid size of an array, and similar purposes.

* 
* [0.x.7]*
   e  
* [0.x.8]*
   log_2 e  
* [0.x.9]*
   log_10 e  
* [0.x.10]*
   log_e 2  
* [0.x.11]*
   log_e 10  
* [0.x.12]*
   pi  
* [0.x.13]*
   pi/2  
* [0.x.14]*
   pi/4  
* [0.x.15]*
   sqrt(2)  
* [0.x.16]*
   1/sqrt(2)  
* [0.x.17]*
   Check whether the given type can be used in CUDA device code.   If not, DEAL_II_CUDA_HOST_DEV needs to be disabled for functions   that use this type.  
* [0.x.18]*
    [2.x.3]  cannot be used in CUDA device code.  
* [0.x.19]*
   Return  [2.x.4]  if the given value is a finite floating point number, i.e.   is neither plus or minus infinity nor NaN (not a number).     Note that the argument type of this function is  [2.x.5] . In   other words, if you give a very large number of type <code>long   double</code>, this function may return  [2.x.6]  even if the   number is finite with respect to type  [2.x.7] .  
* [0.x.20]*
   Return  [2.x.8]  if real and imaginary parts of the given complex number   are finite.  
* [0.x.21]*
   Return  [2.x.9]  if real and imaginary parts of the given complex number   are finite.  
* [0.x.22]*
   Return  [2.x.10]  if real and imaginary parts of the given complex number   are finite.     Again may not work correctly if real or imaginary parts are very large   numbers that are infinite in terms of  [2.x.11] , but finite   with respect to  [2.x.12] .  
* [0.x.23]*
   Return whether two numbers are equal to one another.     For intricate data types (e.g. some automatically differentiable numbers),   this function returns the result of the comparison of scalar values stored   by the input arguments.    
*  [2.x.13]  This function expects that  [2.x.14]  is castable to the type   of  [2.x.15]   
* [0.x.24]*
   Return whether two numbers are not equal to one another.     For intricate data types (e.g. some automatically differentiable numbers),   this function returns the result of the comparison of scalar values stored   by the input arguments.    
*  [2.x.16]  This function expects that  [2.x.17]  is castable to the type   of  [2.x.18]   
* [0.x.25]*
   Return whether or not a value is equal to zero.     For intricate data types (e.g. some automatically differentiable numbers),   this function returns the result of the comparison of scalar values stored   by the input arguments.  
* [0.x.26]*
   Return whether  [2.x.19]  is less than that of  [2.x.20]      For intricate data types (e.g. some automatically differentiable numbers),   this function returns the result of the comparison of scalar values stored   by the input arguments.    
*  [2.x.21]  This function expects that  [2.x.22]  is castable to the type   of  [2.x.23]   
* [0.x.27]*
   Return whether  [2.x.24]  is less than or equal to that of  [2.x.25]      For intricate data types (e.g. some automatically differentiable numbers),   this function returns the result of the comparison of scalar values stored   by the input arguments.    
*  [2.x.26]  This function expects that  [2.x.27]  is castable to the type   of  [2.x.28]   
* [0.x.28]*
   Return whether  [2.x.29]  is greater than that of  [2.x.30]      For intricate data types (e.g. some automatically differentiable numbers),   this function returns the result of the comparison of scalar values stored   by the input arguments.    
*  [2.x.31]  This function expects that  [2.x.32]  is castable to the type   of  [2.x.33]   
* [0.x.29]*
   Return whether  [2.x.34]  is greater than or equal to that of  [2.x.35]      For intricate data types (e.g. some automatically differentiable numbers),   this function returns the result of the comparison of scalar values stored   by the input arguments.    
*  [2.x.36]  This function expects that  [2.x.37]  is castable to the type   of  [2.x.38]   
* [0.x.30]*
   A structure that, together with its partial specializations    [2.x.39]  >, provides traits and member functions   that make it possible to write templates that work on both real number   types and complex number types. This template is mostly used to implement   linear algebra classes such as vectors and matrices that work for both   real and complex numbers.  
* [0.x.31]*
     A flag that specifies whether the template type given to this class is     complex or real. Since the general template is selected for non-complex     types, the answer is  [2.x.40] .    
* [0.x.32]*
     For this data type, alias the corresponding real type. Since the     general template is selected for all data types that are not     specializations of  [2.x.41]  the underlying type must be real-     values, so the real_type is equal to the underlying type.    
* [0.x.33]*
     Return the complex-conjugate of the given number. Since the general     template is selected if number is not a complex data type, this     function simply returns the given number.        
*  [2.x.42]  This function can also be used in CUDA device code.    
* [0.x.34]*
     Return the square of the absolute value of the given number. Since the     general template is chosen for types not equal to  [2.x.43]  this     function simply returns the square of the given number.        
*  [2.x.44]  If the template type can be used in CUDA device code, the same holds true     for this function.    
* [0.x.35]*
     Return the absolute value of a number.    
* [0.x.36]*
   Specialization of the general NumberTraits class that provides the   relevant information if the underlying data type is  [2.x.45]   
* [0.x.37]*
     A flag that specifies whether the template type given to this class is     complex or real. Since this specialization of the general template is     selected for complex types, the answer is  [2.x.46] .    
* [0.x.38]*
     For this data type, alias the corresponding real type. Since this     specialization of the template is selected for number types      [2.x.47]  the real type is equal to the type used to store the     two components of the complex number.    
* [0.x.39]*
     Return the complex-conjugate of the given number.    
* [0.x.40]*
     Return the square of the absolute value of the given number. Since this     specialization of the general template is chosen for types equal to      [2.x.48]  this function returns the product of a number and its     complex conjugate.    
* [0.x.41]*
     Return the absolute value of a complex number.    
* [0.x.42]*
   A test to see if it is possible to convert one number   type to the other.  
* [0.x.43]   The structs below are needed to convert between some special number types.   Also see tensor.h for another specialization.  
* [0.x.44]*
   Return whether two numbers are equal to one another. For intricate data   types (e.g. some automatically differentiable numbers), this function   returns only whether the scalar values stored by the input values are   equal.    
*  [2.x.49]  When ADOL-C is compiled with the "advanced branching" feature, then   this specialization is only intended for use in assertions and   other code paths that do not affect the end result of a computation.  
* [0.x.45]*
   Return whether two numbers are equal to one another. For intricate data   types (e.g. some automatically differentiable numbers), this function   returns only whether the scalar values stored by the input values are   equal.    
*  [2.x.50]  When ADOL-C is compiled with the "advanced branching" feature, then   this specialization is only intended for use in assertions and   other code paths that do not affect the end result of a computation.  
* [0.x.46]*
   Return whether two numbers are equal to one another. For intricate data   types (e.g. some automatically differentiable numbers), this function   returns only whether the scalar values stored by the input values are   equal.    
*  [2.x.51]  When ADOL-C is compiled with the "advanced branching" feature, then   this specialization is only intended for use in assertions and   other code paths that do not affect the end result of a computation.  
* [0.x.47]*
   Return whether  [2.x.52]  is less than that of  [2.x.53]      For intricate data types (e.g. some automatically differentiable numbers),   this function returns the result of the comparison of scalar values stored   by the input arguments.    
*  [2.x.54]  When ADOL-C is compiled with the "advanced branching" feature, then   this specialization is only intended for use in assertions and   other code paths that do not affect the end result of a computation.  
* [0.x.48]*
   Return whether  [2.x.55]  is less than that of  [2.x.56]      For intricate data types (e.g. some automatically differentiable numbers),   this function returns the result of the comparison of scalar values stored   by the input arguments.    
*  [2.x.57]  When ADOL-C is compiled with the "advanced branching" feature, then   this specialization is only intended for use in assertions and   other code paths that do not affect the end result of a computation.  
* [0.x.49]*
   Return whether  [2.x.58]  is less than that of  [2.x.59]      For intricate data types (e.g. some automatically differentiable numbers),   this function returns the result of the comparison of scalar values stored   by the input arguments.    
*  [2.x.60]  When ADOL-C is compiled with the "advanced branching" feature, then   this specialization is only intended for use in assertions and   other code paths that do not affect the end result of a computation.  
* [0.x.50]

include/deal.II-translator/base/parallel_0.txt
[0.x.0]*
     Helper struct to tell us if we can use SIMD instructions for the given      [2.x.0]  type.    
* [0.x.1]*
     Convert a function object of type F into an object that can be applied     to all elements of a range of synchronous iterators.    
* [0.x.2]*
       Constructor. Take and package the given function object.      
* [0.x.3]*
       The stored function object.      
* [0.x.4]*
       Apply F to a set of iterators with two elements.      
* [0.x.5]*
       Apply F to a set of iterators with three elements.      
* [0.x.6]*
       Apply F to a set of iterators with three elements.      
* [0.x.7]*
     Take a function object and create a Body object from it. We do this in     this helper function since alternatively we would have to specify the     actual data type of F
* 
*  -  which for function objects is often     extraordinarily complicated.    
* [0.x.8]*
     Encapsulate  [2.x.1]     
* [0.x.9]*
     Encapsulate  [2.x.2]  when an affinite_partitioner is provided.    
* [0.x.10]*
   An algorithm that performs the action <code>*out++ =   predicate(*in++)</code> where the  [2.x.3]  iterator ranges over   the given input range.     This algorithm does pretty much what  [2.x.4]  does. The difference   is that the function can run in parallel when deal.II is configured to   use multiple threads.     If running in parallel, the iterator range is split into several chunks   that are each packaged up as a task and given to the Threading Building   Blocks scheduler to work on as compute resources are available. The   function returns once all chunks have been worked on. The last argument   denotes the minimum number of elements of the iterator range per task;   the number must be large enough to amortize the startup cost of new   tasks, and small enough to ensure that tasks can be reasonably load   balanced.     For a discussion of the kind of problems to which this function is   applicable, see the    [2.x.5]  "Parallel computing with multiple processors"   module.  
* [0.x.11]*
   An algorithm that performs the action <code>*out++ = predicate(*in1++,  in2++)</code> where the  [2.x.6]  iterator ranges over the given   input range, using the parallel for operator of tbb.     This algorithm does pretty much what  [2.x.7]  does. The difference   is that the function can run in parallel when deal.II is configured to   use multiple threads.     If running in parallel, the iterator range is split into several chunks   that are each packaged up as a task and given to the Threading Building   Blocks scheduler to work on as compute resources are available. The   function returns once all chunks have been worked on. The last argument   denotes the minimum number of elements of the iterator range per task;   the number must be large enough to amortize the startup cost of new   tasks, and small enough to ensure that tasks can be reasonably load   balanced.     For a discussion of the kind of problems to which this function is   applicable, see the    [2.x.8]  "Parallel computing with multiple processors"   module.  
* [0.x.12]*
   An algorithm that performs the action <code>*out++ = predicate(*in1++,  in2++,in3++)</code> where the  [2.x.9]  iterator ranges over   the given input range.     This algorithm does pretty much what  [2.x.10]  does. The difference   is that the function can run in parallel when deal.II is configured to   use multiple threads.     If running in parallel, the iterator range is split into several chunks   that are each packaged up as a task and given to the Threading Building   Blocks scheduler to work on as compute resources are available. The   function returns once all chunks have been worked on. The last argument   denotes the minimum number of elements of the iterator range per task;   the number must be large enough to amortize the startup cost of new   tasks, and small enough to ensure that tasks can be reasonably load   balanced.     For a discussion of the kind of problems to which this function is   applicable, see the    [2.x.11]  "Parallel computing with multiple processors"   module.  
* [0.x.13]*
     Take a range argument and call the given function with its begin and     end.    
* [0.x.14]*
   This function applies the given function argument  [2.x.12]  to all elements in   the range  [2.x.13]  and may do so in parallel. An example   of its use is given in  [2.x.14] .     However, in many cases it is not efficient to call a function on each   element, so this function calls the given function object on sub-ranges.   In other words: if the given range  [2.x.15]  is smaller   than grainsize or if multithreading is not enabled, then we call    [2.x.16] ; otherwise, we may execute, possibly in   %parallel, a sequence of calls  [2.x.17]  where    [2.x.18]  and the   collection of calls we do to  [2.x.19]  will happen on disjoint   subintervals that collectively cover the original interval    [2.x.20] .     Oftentimes, the called function will of course have to get additional   information, such as the object to work on for a given value of the   iterator argument. This can be achieved by [1.x.0] certain   arguments. For example, here is an implementation of a matrix-vector   multiplication  [2.x.21]  for a full matrix  [2.x.22]  and vectors  [2.x.23] :  
* [1.x.1]
*      Note how we use the lambda function to convert    [2.x.24]  from a function that takes 5 arguments   to one taking 2 by binding the remaining arguments. The resulting function   object requires only two arguments, `begin_row` and `end_row`, with all   other arguments fixed.     The code, if in single-thread mode, will call    [2.x.25]  on the entire range    [2.x.26]  exactly once. In multi-threaded mode, however, it   may be called multiple times on subranges of this interval, possibly   allowing more than one CPU core to take care of part of the work.     The  [2.x.27]  argument (50 in the example above) makes sure that   subranges do not become too small, to avoid spending more time on   scheduling subranges to CPU resources than on doing actual work.     For a discussion of the kind of problems to which this function is   applicable, see also the    [2.x.28]  "Parallel computing with multiple processors"   module.  
* [0.x.15]*
   This is a class specialized to for loops with a fixed range given by   unsigned integers. This is an abstract base class that an actual worker   function is derived from. There is a public function apply that issues a   for loop in parallel, subdividing the work onto available processor cores   whenever there is enough work to be done (i.e., the number of elements is   larger than grain_size). Inside the function, a virtual function   apply_to_subrange specifying a range of two integers <tt>[lower,   upper)</tt> is called which needs to be defined in a derived class.     The parallelization cases covered by this class are a subset of what is   possible with the function apply_to_subranges (which also covers the case   of more general iterators that might not be described by an integer   range). However, for simple integer ranges one might prefer this class,   like when there are many structurally similar loops, e.g., some simple   copy or arithmetic operations on an array of pointers. In that case,   apply_to_subranges will generate a lot of code (or rather, a lot of   symbols) because it passes the long names generated by  [2.x.29]  to the   templated parallel for functions in TBB. This can considerably increase   compile times and the size of the object code. Similarly, the incorrect   use of  [2.x.30]  often results in very cryptic error messages, which can   be avoided by this class (only a virtual function needs to be defined in   a derived class). Finally, the additional cost of a virtual function is   negligible in the context of parallel functions: It is much more   expensive to actually issue the work onto a thread, which in turn should   be much less than the actual work done in the for loop.  
* [0.x.16]*
     Destructor. Made virtual to ensure that derived classes also have     virtual destructors.    
* [0.x.17]*
     This function runs the for loop over the given range     <tt>[lower,upper)</tt>, possibly in parallel when end-begin is larger     than the minimum parallel grain size. This function is marked const     because it any operation that changes the data of a derived class will     inherently not be thread-safe when several threads work with the same     data simultaneously.    
* [0.x.18]*
     Virtual function for working on subrange to be defined in a derived     class.  This function is marked const because it any operation that     changes the data of a derived class will inherently not be thread-safe     when several threads work with the same data simultaneously.    
* [0.x.19]*
     A class that conforms to the Body requirements of the TBB     parallel_reduce function. The first template argument denotes the type     on which the reduction is to be done. The second denotes the type of     the function object that shall be called for each subrange.    
* [0.x.20]*
       A variable that will hold the result of the reduction.      
* [0.x.21]*
       Constructor. Take the function object to call on each sub-range as       well as the neutral element with respect to the reduction operation.             The second argument denotes a function object that will be used to       reduce the result of two computations into one number. An example if       we want to simply accumulate integer results would be        [2.x.31]       
* [0.x.22]*
       Splitting constructor. See the TBB book for more details about this.      
* [0.x.23]*
       Join operation: merge the results from computations on different sub-       intervals.      
* [0.x.24]*
       Execute the given function on the specified range.      
* [0.x.25]*
       The function object to call on every sub-range.      
* [0.x.26]*
       The neutral element with respect to the reduction operation. This is       needed when calling the splitting constructor since we have to re-set       the result variable in this case.      
* [0.x.27]*
       The function object to be used to reduce the result of two calls into       one number.      
* [0.x.28]*
   This function works a lot like the apply_to_subranges(), but it allows to   accumulate numerical results computed on each subrange into one number.   The type of this number is given by the ResultType template argument that   needs to be explicitly specified.     An example of use of this function is to compute the value of the   expression  [2.x.32]  for a square matrix  [2.x.33]  and a vector  [2.x.34] . The sum   over rows can be parallelized and the whole code might look like this:  
* [1.x.2]
*      Here,  [2.x.35]  is called on the entire   range  [2.x.36]  if this range is less than the minimum   grainsize (above chosen as 50) or if deal.II is configured to not use   multithreading. Otherwise, it may be called on subsets of the given   range, with results from the individual subranges accumulated internally.      [2.x.37]  If ResultType is a floating point type, then accumulation is not   an associative operation. In other words, if the given function object is   called three times on three subranges, returning values  [2.x.38] , then the   returned result of this function is  [2.x.39] . However, depending on how   the three sub-tasks are distributed on available CPU resources, the   result may also be  [2.x.40]  or any other permutation; because floating   point addition is not associative (as opposed, of course, to addition of   real %numbers), the result of invoking this function several times may   differ on the order of round-off.     For a discussion of the kind of problems to which this function is   applicable, see also the    [2.x.41]  "Parallel computing with multiple processors"   module.  
* [0.x.29]*
   A class that wraps a TBB affinity partitioner in a thread-safe way. In   Vector, we use a shared pointer to share an affinity partitioner   between different vectors of the same size for improving data (and   NUMA) locality. However, when an outer task does multiple vector   operations, the shared pointer could lead to race conditions. This   class only allows one instance to get a partitioner. The other objects   cannot use that object and need to create their own copy.  
* [0.x.30]*
       Constructor.      
* [0.x.31]*
       Destructor. Check that the object is not in use any more, i.e., all       loops have been completed.      
* [0.x.32]*
       Return an affinity partitioner. In case the partitioner owned by the       class is free, it is returned here. In case another thread has not       released it yet, a new object is created. To free the partitioner       again, return it by the release_one_partitioner() call.      
* [0.x.33]*
       After using the partitioner in a tbb loop through       acquire_one_partitioner(), this call makes the partitioner available       again.      
* [0.x.34]*
       The stored partitioner that can accumulate knowledge over several       runs of  [2.x.42]       
* [0.x.35]*
       A flag to indicate whether the partitioner has been acquired but not       released yet, i.e., it is in use somewhere else.      
* [0.x.36]*
       A mutex to guard the access to the in_use flag.      
* [0.x.37]*
     If we do computations on vectors in parallel (say, we add two vectors     to get a third, and we do the loop over all elements in parallel), then     this variable determines the minimum number of elements for which it is     profitable to split a range of elements any further to distribute to     different threads.         This variable is available as a global writable variable in order to     allow the testsuite to also test the parallel case. By default, it is     set to several thousand elements, which is a case that the testsuite     would not normally encounter. As a consequence, in the testsuite we set     it to one
* 
*  -  a value that's hugely unprofitable but definitely tests     parallel operations.    
* [0.x.38]*
     Like  [2.x.43]  but now     denoting the number of rows of a matrix that should be worked on as a     minimum.    
* [0.x.39]*
     This is the function actually called by TBB for the ParallelForInteger     class.    
* [0.x.40]

include/deal.II-translator/base/parameter_acceptor_0.txt
[0.x.0]*
 A parameter acceptor base class. This class is used to define a public interface for classes which want to use a single global ParameterHandler to handle parameters. This class declares one static ParameterHandler, and two static functions (declare_all_parameters() and parse_all_parameters()) that manage all of the derived classes.
*  The basic interface provides two subscription mechanisms: a*global subscription mechanism** and a*local subscription mechanism**.
*  The global subscription mechanism is such that whenever an object of a class derived from ParameterAcceptor is created, then a pointer to that object-of-derived-type is registered, together with a path in the parameter file.
*  Such registry is traversed upon invocation of the single function  [2.x.0]  which in turn calls the method  [2.x.1]  for each of the registered classes, reads the file `file.prm` and subsequently calls the method  [2.x.2]  again for each of the registered classes. The method log_info() can be used to extract information about the classes that have been derived from ParameterAcceptor, and that will be parsed when calling  [2.x.3] 
*  ParameterAcceptor can be used in three different ways: by overloading the  [2.x.4]  and  [2.x.5]  methods, by calling its  [2.x.6]  method for each parameter we want to have, or by constructing a ParameterAcceptorProxy class with your own class, provided that your class implements the  [2.x.7]  and  [2.x.8]  functions (the first can be a static member in this case).
*  By using the add_parameter method, ParameterAcceptor makes sure that the given parameter is registered in the global parameter handler (by calling  [2.x.9]  at the correct path. If you define all your parameters using the  [2.x.10]  method, then you don't need to overload any of the virtual methods of this class.
*  If some post processing is required on the parsed values, the user can attach a signal to  [2.x.11]  and  [2.x.12]  that are called just after the declare_parameters() and parse_parameters() functions of each derived class.  [2.x.13]  has an example of doing this.
*  A typical usage of this class is the following:
* 

* 
* [1.x.0]
* 
*  An implementation that uses user defined declare and parse functions is given by the following example:
* 

* 
* [1.x.1]
* 
* 

*  Parameter files can be organised into section/subsection/subsubsection. To do so, the  [2.x.14]  passed to ParameterAcceptor within the constructor of the derived class needs to contain the separator "/". In fact, "first/second/third/My Class" will organize the parameters as follows
* 

* 
* [1.x.2]
* 
*  In the following examples, we propose some use cases with increasing complexities.
*  MyClass is derived from ParameterAcceptor and has a member object that is derived itself from ParameterAcceptor.

* 
* [1.x.3]
* 
*  In this case, the structure of the parameters will be

* 
* [1.x.4]
* 
*  Now suppose that in the main file we need two or more objects of MyClass

* 
* [1.x.5]
* 
*  What we will read in the parameter file looks like

* 
* [1.x.6]
*  Note that there is only one section "Forcing term", this is because both objects have defined the same name for the section of their SomeParsedClass. There are two strategies to change this behavior. The first one (not recommended) would be to change the name of the section of SomeParsedClass such that it contains also the string passed to the constructor of MyClass:

* 
* [1.x.7]
* 
*  The other way to proceed (recommended) is to use exploit the /section/subsection approach*in the main class**.

* 
* [1.x.8]
*  Now, in the parameter file we can find

* 
* [1.x.9]
* 
*  Note the "/" at the begin of the string name. This is interpreted by ParameterAcceptor like the root folder in Unix systems. The sections "Class A" and "Class B" will not be nested under any section. On the other hand, if the string does not begin with a "/" as in the previous cases the section will be created*under the current path**, which depends on the previously defined sections/subsections/subsubsections. Indeed, the section "Forcing term" is nested under "Class A" or "Class B". To make things more clear. let's consider the following two examples
* 

* 
* [1.x.10]
*  The parameter file will have the following structure

* 
* [1.x.11]
* 
*  If instead one of the paths ends with "/" instead of just a name of the class, subsequent classes will interpret this as a full path, interpreting the class name as a directory name:

* 
* [1.x.12]
*  The parameter file will have the following structure

* 
* [1.x.13]
* 
*  As a final remark, in order to allow a proper management of all the sections/subsections, the instantiation of objects and the call to  [2.x.15]  cannot be done on multiple, concurrently running threads.
*  If you pass an empty name, the  [2.x.16]  function is used to fill the section name with a human readable version of the class name itself.
*  See the tutorial program  [2.x.17]  for an example on how to use this class.

* 
* [0.x.1]*
   The constructor adds derived classes to the list of acceptors. If   a section name is specified, then this is used to scope the   parameters in the given section, otherwise a pretty printed   version of the derived class is used.  
* [0.x.2]*
   Destructor.  
* [0.x.3]*
   Call declare_all_parameters(), read the parameters from `filename` (only   if `filename` is a non-empty string), and then call   parse_all_parameters().     If the parameter `filename` is the empty string, then no attempt to read a   parameter file is done. This may be useful if you are ok with using   default values, and don't want to read external files to use a class   derived from ParameterAcceptor.     If  [2.x.18]  is not the empty string, then we write the content   that was read into the  [2.x.19]  file, using the style specified   in  [2.x.20]  The format of both input and output   files are selected using the extensions of the files themselves. This can   be either `prm`, `xml`, or `json` for the  [2.x.21]  and any of the   supported formats for the  [2.x.22]      If the input file does not exist, a default one with the same name is   created for you following the style specified in    [2.x.23]  and an exception is thrown.     By default, the file format used to write the files is deduced from   the extension of the file names. If the corresponding    [2.x.24]  specifies a format specification, this must   be compatible with the file extension, or an exception will be thrown.     If the extension is not recognized, and you do not specify a format in the   corresponding  [2.x.25]  an assertion is thrown.      [2.x.26]  filename Input file name    [2.x.27]  output_filename Output file name    [2.x.28]  output_style_for_output_filename How to write the output file    [2.x.29]  prm The ParameterHandler to use    [2.x.30]  output_style_for_filename How to write the default input file if it   does not exist  
* [0.x.4]*
   Call declare_all_parameters(), read the parameters from the `input_stream`   in `prm` format, and then call parse_all_parameters().     An exception is thrown if the `input_stream` is invalid.      [2.x.31]  input_stream Input stream    [2.x.32]  prm The ParameterHandler to use  
* [0.x.5]*
   Clear class list and global parameter file.  
* [0.x.6]*
   Derived classes can use this method to declare their parameters.    [2.x.33]  calls it for each derived class. The   default implementation is empty.  
* [0.x.7]*
   Declare parameter call back. This signal is triggered right after   declare_parameters() has been called, to allow users to prepare their   variables right after parameters have been decalred. The default   implementation is empty.  
* [0.x.8]*
   Derived classes can use this method to parse their parameters.    [2.x.34]  calls it for each derived class. The   default implementation is empty.  
* [0.x.9]*
   Parse parameter call back. This function is called at the end of   parse_parameters(), to allow users to process their parameters right after   they have been parsed. The default implementation is empty.     You can use this function, for example, to create a quadrature rule after   you have read how many quadrature points you wanted to use from the   parameter file.  
* [0.x.10]*
   Parse the given ParameterHandler. This function enters the   subsection returned by get_section_name() for each derived class,   and parses all parameters that were added using add_parameter().  
* [0.x.11]*
   Initialize the global ParameterHandler with all derived classes   parameters.This function enters the subsection returned by   get_section_name() for each derived class, and declares all parameters   that were added using add_parameter().  
* [0.x.12]*
   Return the section name of this class. If a name was provided   at construction time, then that name is returned, otherwise it   returns the demangled name of this class.  
* [0.x.13]*
   Traverse all registered classes, and figure out what subsections we need to   enter.  
* [0.x.14]*
   Add a parameter in the correct path. This method forwards all arguments to   the prm.add_parameter() method, after entering the correct section path.   By default it uses the  [2.x.35]  variable as   ParameterHandler.     See the documentation of  [2.x.36]  for more   information.  
* [0.x.15]*
   The global parameter handler.  
* [0.x.16]*
   Add the given  [2.x.37]  to the global path stored in this class.     This function changes the behavior of enter_my_subsection(), by   appending a new subsection to the path stored in this class.     This method can be used to split the parameters of this class into   subsections, while still maintaining the general behavior of this   class.     An example usage is given by the following snippet:  
* [1.x.14]
*      which will produce a parameter file organized as    
* [1.x.15]
*   
* [0.x.17]*
   Leave the subsection that was entered by calling the enter_subsection()   function.  
* [0.x.18]*
   Make sure we enter the right subsection of the given parameter.  
* [0.x.19]*
   This function undoes what the enter_my_subsection() function did. It only   makes sense if enter_my_subsection() was called on `prm` before this one.  
* [0.x.20]*
   A list containing all constructed classes of type   ParameterAcceptor.  
* [0.x.21]*
   Separator between sections.  
* [0.x.22]*
 A proxy ParameterAcceptor wrapper for classes that have a static member function  [2.x.38]  and a non virtual  [2.x.39]  method.
*  If you cannot or do not want to derive your "parameter accepting" class from ParameterAcceptor, for example if by design you are required to have a static member function  [2.x.40]  and a member  [2.x.41]  parse_parameters, or if someone has already implemented such a class for you, and only provides you with an API that you cannot modify, then you may be able to use ParameterAcceptor facilities nonetheless, by wrapping your class into ParameterAcceptorProxy.
*  This class implements the public interface of ParameterAcceptor, and at the same time it derives from the template class  [2.x.42]  allowing you to register your existing  [2.x.43]  as a ParameterAcceptor class, without requiring you to explicitly derive your  [2.x.44]  from ParameterAcceptor.
*  An example usage is given by the following snippet of code, using  [2.x.45]  as an example source class:
* 

* 
* [1.x.16]
* 
*  The above snippet of code will initialize  [2.x.46]  with a section "Some function", and will correctly parse and assign to the object `fun` the expression parsed from the file `test.prm`. If non-existent, the program will exit, and generate it for you (here you can see the resulting short text version of the parameter file generated with the above snippet):
* 

* 
* [1.x.17]
* 
*  The resulting `fun` object, is both a ParsedFunction object and a ParameterAcceptor one, allowing you to use it as a replacement of the ParsedFunction class, with automatic declaration and parsing of parameter files.
*  See the tutorial program  [2.x.47]  for an example on how to use this class.

* 
* [0.x.23]*
   Default constructor. The argument `section_name` is forwarded to the   constructor of the ParameterAcceptor class, while all other arguments   are passed to the SourceClass constructor.  
* [0.x.24]*
   Overloads the  [2.x.48]  function, by calling    [2.x.49]  with  [2.x.50]  as an argument.  
* [0.x.25]*
   Overloads the  [2.x.51]  function, by calling    [2.x.52]  with  [2.x.53]  as an argument.  
* [0.x.26]

include/deal.II-translator/base/parameter_handler_0.txt
[0.x.0]*
 The ParameterHandler class provides a standard interface to an input file which provides at run-time for program parameters such as time step sizes, geometries, right hand sides etc. The input for the program is given in files, streams or strings in memory using text like  
* [1.x.0]
*  Input may be sorted into subsection trees in order to give the input a logical structure, and input files may include other files.
*  The ParameterHandler class is discussed in  [2.x.0] ,  [2.x.1] , and  [2.x.2] .
*  [1.x.1]
*  In order to use the facilities of a ParameterHandler object, one first has to make known the different entries the input file may or may not contain. This is done in the following way:
*   
* [1.x.2]
*  Each entry is declared using the function declare_entry(). The first parameter is the name of the entry (in short: the entry). The second is the default answer to be taken in case the entry is not specified in the input file. The third parameter is a regular expression which the input (and the default answer) has to match.  Several such regular expressions are defined in Patterns. This parameter can be omitted, in which case it will default to  [2.x.3]  i.e. a pattern that matches every input string. The fourth parameter can be used to document the intent or expected format of an entry; its value is printed as a comment when writing all entries of a ParameterHandler object using the print_parameters() function to allow for easier understanding of a parameter file. It can be omitted as well, in which case no such documentation will be printed.
*  Entries may be located in subsections which form a kind of input tree. For example input parameters for linear solver routines should be classified in a subsection named <tt>Linear solver</tt> or any other suitable name. This is accomplished in the following way:

* 
* [1.x.3]
* 
*  Subsections may be nested. For example a nonlinear solver may have a linear solver as member object. Then the function call tree would be something like (if the class <tt>NonLinEq</tt> has a member variables <tt>eq</tt> of type <tt>LinEq</tt>):

* 
* [1.x.4]
* 
*  For class member functions which declare the different entries we propose to use the common name <tt>declare_parameters</tt>. In normal cases this method can be <tt>static</tt> since the entries will not depend on any previous knowledge. Classes for which entries should logically be grouped into subsections should declare these subsections themselves. If a class has two or more member variables of the same type both of which should have their own parameters, this parent class' method <tt>declare_parameters</tt> is responsible to group them into different subsections:

* 
* [1.x.5]
* 
* 

*  [1.x.6]
*  For the first example above the input file would look like the following:  
* [1.x.7]
*  The words <tt>subsection</tt>, <tt>set</tt> and <tt>end</tt> may be either written in lowercase or uppercase letters. Leading and trailing whitespace is removed, multiple whitespace is condensed into only one. Since the latter applies also to the name of an entry, an entry name will not be recognized if in the declaration multiple whitespace is used.
*  In entry names and values the following characters are not allowed: <tt>\#</tt>, <tt>{</tt>, <tt>}</tt>, <tt>|</tt>. Their use is reserved for the MultipleParameterLoop class.
*  Comments starting with \# are skipped.
*  Continuation lines are allowed by means of the character <tt>\\</tt>, which must be the last character (aside from whitespace, which is ignored) of the line. When a line is a continuation (i.e., the previous line ended in a <tt>\\</tt>), then, unlike the default behavior of the <tt>C</tt> preprocessor, all whitespace at the beginning of the line is ignored.
*  We propose to use the following scheme to name entries: start the first word with a capital letter and use lowercase letters further on. The same applies to the possible entry values to the right of the <tt>=</tt> sign.
* 

*  [1.x.8]
*  An input file can include other include files using the syntax  
* [1.x.9]
*  The file so referenced is searched for relative to the current directory (not relative to the directory in which the including parameter file is located, since this is not known to all three versions of the parse_input() function).
* 

*  [1.x.10]
*  In order to read input there are three possibilities: reading from an  [2.x.4]  object, reading from a file of which the name is given and reading from a string in memory in which the lines are separated by <tt> [2.x.5]  characters. These possibilities are used as follows:  
* [1.x.11]
*  You can use several sources of input successively. Entries which are changed more than once will be overwritten every time they are used.
*  You should not try to declare entries using declare_entry() and enter_subsection() with as yet unknown subsection names after using parse_input(). The results in this case are unspecified.
*  If an error occurs upon reading the input, error messages are written to  [2.x.6]  and the reader function returns with a return value of  [2.x.7] . This is opposed to almost all other functions in deal.II, which would normally throw an exception if an error occurs; this difference in behavior is a relic of the fact that this class predates deal.II and had previously been written for a different project.
* 

*  [1.x.12]
*  An alternative to using the hand-written input files shown above is to use the graphical user interface (GUI) that accompanies this class.
*  See [1.x.13] for further details.
*  [1.x.14]
*  Each class gets its data out of a ParameterHandler object by calling the get()  member functions like this:  
* [1.x.15]
*  get() returns the value of the given entry. If the entry was not specified in the input source(s), the default value is returned. You have to enter and leave subsections exactly as you did when declaring subsections. You may choose the order in which to traverse the subsection tree.
*  It is possible to avoid calls to enter_subsection() and leave_subsection() by supplying get() with a vector of strings representing the path from which to get a value. For example, the following two versions of get_parameters() will produce the same result:  
* [1.x.16]
* 
*   
* [1.x.17]
* 
*  The latter method allows the ParameterHandler reference to be  [2.x.8] 
*  It is guaranteed that only entries matching the given regular expression are returned, i.e. an input entry value which does not match the regular expression is not stored.
*  You can use get() to retrieve the parameter in text form, get_integer() to get an integer or get_double() to get a double. You can also use get_bool(). It will cause an internal error if the string could not be converted to an integer, double or a bool. This should, though, not happen if you correctly specified the regular expression for this entry; you should not try to get out an integer or a double from an entry for which no according regular expression was set. The internal error is raised through the Assert() macro family which only works in debug mode.
*  If you want to print out all user selectable features, use the print_parameters() function. It is generally a good idea to print all parameters at the beginning of a log file, since this way input and output are together in one file which makes matching at a later time easier. Additionally, the function also print those entries which have not been modified in the input file and are thus set to default values; since default values may change in the process of program development, you cannot know the values of parameters not specified in the input file.
* 

* 
*  [1.x.18]
*  It is often convenient to have something happen as soon as a parameter value is read. This could be a check that it is valid
* 
*  -  say, that a file that is listed in the parameter file exists
* 
*  -  or to initiate something else in response, such as setting a variable outside the ParameterHandler (as in the example shown below). In almost all cases, this "action" could also be initiated once all parameters are read via parse_input(), but it is sometimes [1.x.19] to do it right away.
*  This is facilitated by the add_action() function that can be called after declaring a parameter via declare_entry(). "Actions" are in essence pointers to functions that will be called for parameters that have associated actions. These functions take the value of a parameter as argument, and can then do whatever they want with it
* 
*  -  e.g., save it somewhere outside the ParameterHandler object. (Exactly when the action is called is described in the documentation of the add_action() function.) Of course, in C++ one doesn't usually pass around the address of a function, but an action can be a function-like object (taking a string as argument) that results from calling such as a [1.x.20] that has the form

* 
* [1.x.21]
*  and that is attached to a specific parameter.
*  A typical example of such an action would be as follows: let's assume that you have a program that declares a parameter for the number of iterations it is going to run, say

* 
* [1.x.22]
*  then one could obtain this parameter from a parameter file using a code snippet in  [2.x.9]  as follows:

* 
* [1.x.23]
* 
*  This two-step process
* 
*  -  first declaring the parameter, and later reading it
* 
*  -  is a bit cumbersome because one has to first declare [1.x.24] parameters and at a later time retrieve them from the ParameterHandler object. In large programs, these two things also often happen in different functions.
*  To avoid this, it would be nice if we could put both the declaration and the retrieval into the same place. This can be done via actions, and the function would then look like this:

* 
* [1.x.25]
*  Here, the action consists of a lambda function that takes the value for this parameter as a string, and then converts it to an integer to store in the variable where it belongs. This action is executed inside the call to  [2.x.10] , and so there is now no longer a need to extract the parameter's value at a later time. Furthermore, the code that sets the member variable is located right next to the place where the parameter is actually declared, so we no longer need to have two separate parts of the code base that deal with input parameters.
*  Of course, it is possible to execute far more involved actions than just setting a member variable as shown above, even though that is a typical case.
* 

*  [1.x.26]
*  We propose that every class which gets data out of a ParameterHandler object provides a function named <tt>get_parameters</tt>. This should be declared <tt>virtual</tt>. <tt>get_parameters</tt> functions in derived classes should call the  [2.x.11]  function.
* 

*  [1.x.27]
*  Experience has shown that in programs defining larger numbers of parameters (more than, say, fifty) it is advantageous to define an additional class holding these parameters. This class is more like a C-style structure, having a large number of variables, usually public. It then has at least two functions, which declare and parse the parameters. In the main program, the main class has an object of this parameter class and delegates declaration and parsing of parameters to this object.
*  The advantage of this approach is that you can keep out the technical details (declaration and parsing) out of the main class and additionally don't clutter up your main class with dozens or more variables denoting the parameters.
* 

* 
*  [1.x.28]
*  This is the code:  
* [1.x.29]
* 
* 

*  This is the input file (named "prmtest.prm"):  
* [1.x.30]
* 
*  And here is the output of the program:  
* [1.x.31]
* 
* 

* 
*  [1.x.32]
*  Here is some more internal information about the representation of parameters:
*  Logically, parameters and the nested sections they are arranged in can be thought of as a hierarchical directory structure, or a tree. Take, for example, the following code declaring a set of parameters and sections they live in:  
* [1.x.33]
* 
*  We can think of the parameters so arranged as a file system in which every parameter is a directory. The name of this directory is the name of the parameter, and in this directory lie files that describe the parameter. These files are at the time of writing this documentation (other fields, such as those indicating "actions" may also exist in each directory):
* 

* 
* 
*  -  [2.x.12] : The content of this file is the current value of this parameter; initially, the content of the file equals the default value of the parameter.
* 

* 
* 
*  -  [2.x.13] : The content of this file is the default value of the parameter.
* 

* 
* 
*  -  [2.x.14] : A textual representation of the pattern that describes the parameter's possible values.
* 

* 
* 
*  -  [2.x.15] : A number that indexes the  [2.x.16]  object that is used to describe the parameter.
* 

* 
* 
*  -  [2.x.17] : The content of this file is the documentation given for a parameter as the last argument of the  [2.x.18]  call. With the exception of the  [2.x.19]  file, the contents of files are never changed after declaration of a parameter.
*  Alternatively, a directory in this file system may not have a file called  [2.x.20]  in it. In that case, the directory represents a subsection as declared above, and the directory's name will correspond to the name of the subsection. It will then have no files in it at all, but it may have further directories in it: some of these directories will be parameters (indicates by the presence of files) or further nested subsections.
*  Given this explanation, the code above will lead to a hierarchical representation of data that looks like this (the content of files is indicated at the right in a different font):
*   [2.x.21] 
*  Once parameters have been read in, the contents of the  [2.x.22]  "files" may be different while the other files remain untouched.
*  Using the  [2.x.23]  function with  [2.x.24]  as second argument, we can get a complete representation of this data structure in XML. It will look like this:  
* [1.x.34]
*  This representation closely resembles the directory/file structure discussed above. The only difference is that directory and file names are mangled: since they should only contain letters and numbers, every character in their names that is not a letter or number is replaced by an underscore followed by its two-digit hexadecimal representation. In addition, the special name "value" is mangled when used as the name of a parameter, given that this name is also used to name special files in the hierarchy structure. Finally, the entire tree is wrapped into a tag  [2.x.25]  to satisfy the XML requirement that there be only a single top-level construct in each file.
*  The tree structure (and its XML representation) is what the graphical user interface (see above) uses to represent parameters like a directory/file collection.
* 

* 

* 
*  [2.x.26] 

* 
* [0.x.1]*
   List of possible output formats used for functions like    [2.x.27]  The options can be categorized into   two groups:
* 

* 
* 

* 
* 

* 
* 
*  - format options: PRM, LaTeX, Description, XML, JSON
* 

* 
* 

* 
* 

* 
* 
*  - stylistic options: Short, KeepDeclarationOrder     Only one format option may be specified at the time. Any function that   accepts an OutputStyle as an option will throw if you specify more than   one.     A number of shortcuts of commonly used option combinations are provided.   E.g., ShortPRM prints the parameters in the PRM format, while skipping the   documentation.  
* [0.x.2]*
     Default stylistic style: print documentation and sort all parameters     alphabetically.    
* [0.x.3]*
     Write input for ParameterHandler without comments or changed default     values.    
* [0.x.4]*
     Keep the order of the parameters as they have been declared.    
* [0.x.5]*
     Write human readable output suitable to be read by      [2.x.28]  again.    
* [0.x.6]*
     Write human readable output suitable to be read by      [2.x.29]  again.          [2.x.30]  Use `PRM` instead of `Text`.    
* [0.x.7]*
     Write parameters as a LaTeX table.    
* [0.x.8]*
     Write out declared parameters with description and possible values.        
*  [2.x.31]  This format is not suitable to be read back again.    
* [0.x.9]*
     Write out everything as an [1.x.35] file suitable to be read     by  [2.x.32]  again.         See the general documentation of this class for an example of output.    
* [0.x.10]*
     Write out everything as a [1.x.36] file suitable to be     read by  [2.x.33]  again.    
* [0.x.11]*
     Write the content of ParameterHandler without comments or changed default     values.    
* [0.x.12]*
     Write the content of ParameterHandler without comments or changed default     values.          [2.x.34]  Use `ShortPRM` instead of `ShortText`.    
* [0.x.13]*
     Write the content of ParameterHandler without comments or changed default     values as a XML file.    
* [0.x.14]*
     Write the content of ParameterHandler without comments or changed default     values as a JSON file.    
* [0.x.15]*
     Write the content of ParameterHandler without comments or changed default     values as a LaTeX file.    
* [0.x.16]*
   Constructor.  
* [0.x.17]*
   Destructor. Declare this only to have a virtual destructor, which is   safer as we have virtual functions.  It actually does nothing   spectacular.  
* [0.x.18]*
   Inhibit automatic CopyConstructor.  
* [0.x.19]*
   Inhibit automatic assignment operator.  
* [0.x.20]*
   Parse each line from a stream until the stream returns the <tt>eof</tt>   condition or error to provide values for known parameter fields. The second   argument can be used to denote the name of the file (if that's what the   input stream represents) we are reading from; this is only used when   creating output for exceptions.     If non-empty  [2.x.35]  is provided, the ParameterHandler object   will stop parsing lines after encountering  [2.x.36]  .   This is handy when adding extra data that shall be parsed manually.     If  [2.x.37]  is  [2.x.38] , the parameter handler   will skip undefined sections and entries. This is useful for partially   parsing a parameter file, for example to obtain only the spatial dimension   of the problem. By default all entries and subsections are expected to be   declared.     The function sets the value of all parameters it encounters in the   input file to the provided value. Parameters not explicitly listed   in the input file are left at the value they previously held, which   will be the default value provided to declare_entry() unless one   has previously read a different input file.     Each parameter value is matched against the pattern for this   parameter that was provided to declare_entry(), and for each parameter   all associated actions that may previously have been set by   add_action() are executed. If a parameter does not satisfy its   pattern, or if an associated action throws an exception, then the   value provided for the parameter is not set and the current   object reverts to the subsection it was in before the current   function was called. No further processing of the input stream   occurs, that is everything that comes after the parameter whose   value does not satisfy its pattern is ignored.  
* [0.x.21]*
   Parse input from a specified parameter file  [2.x.39]  independently   of the type of input file (prm, xml, json) being used. The code path   selected by this function is extracted from the ending of the filename,   so the user has to make sure that the content of the input file is   consistent with its name.     The parameter  [2.x.40]  will only be used for parameter files of .prm type.   See the other parse_input function for documentation.     The user can specify whether parameters in the input file not added to the   parameter handler will be skipped by  [2.x.41]  (enables partial   parsing), and whether the code will assert that all parameters of the   parameter handler declared with flag `has_to_be_set=true` are indeed found   in the input file.     If the function is called with `skip_undefined=true`, it is recommended to   also set `assert_mandatory_entries_are_found=true`. For example, this   ensures that parameters with typos in the input file will not be skipped,   while such mistakes would otherwise remain unrecognized.  
* [0.x.22]*
   Parse input from a string to populate known parameter fields. The lines   in the string must be separated by <tt> [2.x.42]  characters.     The function in essence reads the entire file into a stream and   then calls the other parse_input() function with that stream. See   there for more information.  
* [0.x.23]*
   Parse input from an XML stream to populate known parameter fields. This   could be from a file originally written by the print_parameters() function   using the XML output style and then modified by hand as necessary, or from   a file written using this method and then modified by the graphical   parameter GUI (see the general documentation of this class).  
* [0.x.24]*
   Parse input from a JSON stream to populate known parameter fields. This   could be from a file originally written by the print_parameters() function   using the JSON output style and then modified by hand as necessary, or from   a separate program that knows how to write JSON format for ParameterHandler   input.  
* [0.x.25]*
   Clear all contents.  
* [0.x.26]*
   Declare a new entry with name <tt>entry</tt>, default and for which any   input has to match the <tt>pattern</tt> (default: any pattern).     The function generates an exception of type ExcValueDoesNotMatchPattern   if the default value doesn't match the given pattern, using the C++ throw   mechanism. However, this exception is only generated [1.x.37] the   entry has been created; if you have code where no sensible default value   for a parameter is possible, you can then catch and ignore this   exception.     The parameter  [2.x.43]  defaulting to an empty string is used   to add a documenting text to each entry which will be printed as a comment   when this class is asked to write out all declarations to a stream using   the print_parameters() function.     The parameter  [2.x.44]  can be used in order to declare this   parameter as a parameter whose default value has to be overwritten by   one of the methods provided by this class. Whether a parameter has been set   successfully can be queried by the functions get_entries_wrongly_not_set()   and assert_that_entries_have_been_set().    
*  [2.x.45]  An entry can be declared more than once without generating an   error, for example to override an earlier default value.  
* [0.x.27]*
   Attach an action to the parameter with name  [2.x.46]  in the current   section. The action needs to be a function-like object that takes the   value of the parameter as a (string) argument. See the general   documentation of this class for a longer description of actions, as well as   examples.     The action is executed in three different circumstances:
* 

* 
* 

* 
* 

* 
* 
*  - With the default value of the parameter with name  [2.x.47]  at     the end of the current function. This is useful because it allows     for the action to execute whatever it needs to do at least once     for each parameter, even those that are not actually specified in     the input file (and thus remain at their default values).
* 

* 
* 

* 
* 

* 
* 
*  - Within the  [2.x.48]  functions that explicitly     set a value for a parameter.
* 

* 
* 

* 
* 

* 
* 
*  - Within the parse_input() function and similar functions such     as parse_input_from_string(). Here, the action is executed     whenever the parameter with which it is associated is read     from the input, after it has been established that the value     so read matches the pattern that corresponds to this parameter,     and before the value is actually saved.     It is valid to add multiple actions to the same parameter. They will   in that case be executed in the same order in which they were added.    
*  [2.x.49]  Actions may modify all sorts of variables in their scope. The    only thing an action should not modify is the ParameterHandler object    it is attached to. In other words, it is not allowed to enter or    leave sections of the current ParameterHandler object. It is, in    principle, acceptable to call  [2.x.50]  and related    functions on other parameters in the current section, but since    there is no guarantee about the order in which they will be read    from an input file, you will not want to rely on the values these    functions would return.    
*  [2.x.51]  Throwing an exception in an action is generally not a good    idea, but yields fundamentally the same result as if one tries to    read a parameter from a file for which the value does not satisfy    the pattern associated with the parameter. In other words, the    value just read is discarded, and  [2.x.52]     stops to read any further content from the file. See     [2.x.53]  for more information.  
* [0.x.28]*
   Declare a new entry name  [2.x.54]  set its default value to the content of   the variable  [2.x.55]  and create an action that will fill  [2.x.56]    parameter with updated values when a file is parsed, or the entry is set   to a new value.     By default, the pattern to use is obtained by calling the function    [2.x.57]  but a custom one can be used.     The parameter  [2.x.58]  can be used in order to declare this   parameter as a parameter whose default value has to be overwritten by   one of the methods provided by this class. Whether a parameter has been set   successfully can be queried by the functions get_entries_wrongly_not_set()   and assert_that_entries_have_been_set().  
* [0.x.29]*
   Create an alias for an existing entry. This provides a way to refer to a   parameter in the input file using an alternate name. The alias will be in   the current section, and the referenced entry needs to be an existing   entry in the current section.     The primary purpose of this function is to allow for a backward   compatible way of changing names in input files of applications for which   backward compatibility is important. This can be achieved by changing the   name of the parameter in the call to declare_entry(), and then creating   an alias that maps the old name to the new name. This way, old input   files can continue to refer to parameters under the old name, and they   will automatically be mapped to the new parameter name.     It is valid to set the same parameter multiple times in an input file.   The value that will ultimately be chosen in such cases is simply the last   value set. This rule also applies to aliases, where the final value of a   parameter is the last value set either through the current name of the   parameter or through any of its possible multiple aliases. For example,   if you have an input file that looks like  
* [1.x.38]
*    where  [2.x.59]  is an alias declared via  
* [1.x.39]
*    then the final value for the parameter called  [2.x.60]  will be   2, not 1.      [2.x.61]  existing_entry_name The name of an existing parameter in the   current section that the alias should refer to.    [2.x.62]  alias_name An alternate name for the parameter referenced by the   first argument.    [2.x.63]  alias_is_deprecated If true, mark the alias as deprecated. This   will then be listed in the description of the alias if you call   print_parameters(), and you will get a warning on the screen when reading   an input file that contains this deprecated alias. The purpose of this   argument is to be able to allow the use of an old name for a parameter   (see above) but make it clear that this old name will eventually be   removed.  
* [0.x.30]*
   Enter a subsection. If it does not yet exist, create it.  
* [0.x.31]*
   Leave present subsection.  
* [0.x.32]*
   Check whether a subsection or a subsection path exists in current tree.   The input parameter  [2.x.64]  is assumed to be relative to the   currently selected path.  
* [0.x.33]*
   Return value of entry  [2.x.65]   If the entry was changed,   then the changed value is returned, otherwise the default value. If the   value of an undeclared entry is required, an  [2.x.66]  will fail.  
* [0.x.34]*
   Return value of entry  [2.x.67]   If the entry was changed,   then the changed value is returned, otherwise the default value. If the   value of an undeclared entry is required, an  [2.x.68]  will fail.   If  [2.x.69]  is non-empty, the value will be gotten   from the subsection represented by that path instead of the current   subsection. The first string in  [2.x.70]  must be the name   of a subsection of the current section, and each next string must be the   name of a subsection of the one before it.  
* [0.x.35]*
   Return value of entry  [2.x.71]  as  [2.x.72] . (A long   int is chosen so that even very large unsigned values can be returned by   this function).  
* [0.x.36]*
   Return value of entry  [2.x.73]  as  [2.x.74] . (A long   int is chosen so that even very large unsigned values can be returned by   this function).   If  [2.x.75]  is non-empty, the value will be gotten   from the subsection represented by that path instead of the current   subsection.  
* [0.x.37]*
   Return value of entry  [2.x.76]  as  [2.x.77]   
* [0.x.38]*
   Return value of entry  [2.x.78]  as  [2.x.79]    If  [2.x.80]  is non-empty, the value will be gotten   from the subsection represented by that path instead of the current   subsection.  
* [0.x.39]*
   Return value of entry  [2.x.81]  as  [2.x.82]  The entry may   be "true" or "yes" for  [2.x.83]  "false" or "no" for  [2.x.84]    respectively.  
* [0.x.40]*
   Return value of entry  [2.x.85]  as  [2.x.86]  The entry may   be "true" or "yes" for  [2.x.87]  "false" or "no" for  [2.x.88]    respectively.   If  [2.x.89]  is non-empty, the value will be gotten   from the subsection represented by that path instead of the current   subsection.  
* [0.x.41]*
   Change the value presently stored for <tt>entry_name</tt> to the one   given in the second argument.     The parameter must already exist in the present subsection.     The function throws an exception of type ExcValueDoesNotMatchPattern if   the new value does not conform to the pattern for this entry.  
* [0.x.42]*
   Same as above, but an overload where the second argument is a character   pointer. This is necessary, since otherwise the call to    [2.x.90]  will be mapped to the function taking one   string and a bool as arguments, which is certainly not what is most often   intended.     The function throws an exception of type ExcValueDoesNotMatchPattern if   the new value does not conform to the pattern for this entry.  
* [0.x.43]*
   Change the value presently stored for <tt>entry_name</tt> to the one   given in the second argument.     The parameter must already exist in the present subsection.     The function throws an exception of type ExcValueDoesNotMatchPattern if   the new value does not conform to the pattern for this entry.  
* [0.x.44]*
   Change the value presently stored for <tt>entry_name</tt> to the one   given in the second argument.     The parameter must already exist in the present subsection.     For internal purposes, the new value needs to be converted to a string.   This is done using 16 digits of accuracy, so the set value and the one   you can get back out using get_double() may differ in the 16th digit.     The function throws an exception of type ExcValueDoesNotMatchPattern if   the new value does not conform to the pattern for this entry.  
* [0.x.45]*
   Change the value presently stored for <tt>entry_name</tt> to the one   given in the second argument.     The parameter must already exist in the present subsection.     The function throws an exception of type ExcValueDoesNotMatchPattern if   the new value does not conform to the pattern for this entry.  
* [0.x.46]*
   Print all parameters with the given  [2.x.91]  to  [2.x.92]      Before printing, all current parameters and subsections are sorted   alphabetically by default.   This behavior can be disabled setting the optional parameter  [2.x.93]    to <tt>KeepDeclarationOrder</tt>: in this case entries are printed in the   same order as they have been declared.     In <tt>PRM</tt>, <tt>XML</tt>, and <tt>JSON</tt> format, the output is   formatted in such a way that it is   possible to use it for later input again. This is most useful to record   the parameters for a specific run, since if you output the parameters   using this function into a log file, you can always recover the results   by simply copying the output to your input file.     Besides the name and value of each entry, the output also contains the   default value of entries if it is different from the actual value, as   well as the documenting string given to the declare_entry() function if   available.     By using the flag <tt>Short</tt> in combination with <tt>PRM</tt>,   <tt>XML</tt>, <tt>JSON</tt>, or <tt>LaTeX</tt> (or by using the shortcuts   <tt>ShortPRM</tt>, <tt>ShortXML</tt>, <tt>ShortJSON</tt>, or   <tt>ShortLaTeX</tt>), a reduced output can be generated, only containing   the values and skipping the documentation.     In <tt>XML</tt> format, the output starts with one root element   <tt>ParameterHandler</tt> in order to get a valid XML document and all   subsections under it.     In <tt>LaTeX</tt> format, the output contains the same information but in   a format so that the resulting file can be input into a latex document   such as a manual for the code for which this object handles run-time   parameters. The various sections of parameters are then represented by   latex section and subsection commands as well as by nested enumerations.     You can reference specific parameter sections and individual parameters   by the labels that are generated automatically for each entry. The   labels have the format  [2.x.94]    and  [2.x.95] . Because   special characters can appear in the section and entry names, these   will be "mangled". Here, all characters except  [2.x.96]    are replaced by  [2.x.97]  is the two-digit   ascii code of the character in hexadecimal encoding (so a space becomes    [2.x.98]  for example).     While this function escapes special LaTeX-specific characters (backslash,   underscore, etc.) in most of the output (names, default values, etc.),   the documentation string is passed as-is. This means you can use math   environments and other formatting in the description, but you need   to escape quotes, backslashes, underscores, etc. yourself.     In addition, all parameter names are listed with  [2.x.99]    statements in two indices called  [2.x.100]  (where the name of   each parameter is listed in the index) and  [2.x.101]    where parameter names are listed sorted by the section in which they   exist. By default, the LaTeX program ignores these  [2.x.102]    commands, but they can be used to generate an index by using the   following commands in the preamble of the latex file:  
* [1.x.40]
*    and at the end of the file this:  
* [1.x.41]
*   
* [0.x.47]*
   Print all parameters to the file given by  [2.x.103]  with the given output   style  [2.x.104]      This function deduces the output format from the extension of the specified   filename. Supported extensions are `prm`, `xml`, `tex`, and `json`. Hence,   it is not necessary to specify an output format via the  [2.x.105]  argument   as long as one of these extensions is added to the filename. If an output   format is specified in the  [2.x.106]  parameter nevertheless, the output   format has to be consistent with the filename extension.     If no extension is specified or the extension is not supported, the   output format is deduced from the  [2.x.107]  argument.     If neither the extension is supported, nor does the  [2.x.108]  parameter   contain a format specification, an assertion is thrown.      [2.x.109]  filename The output file name.    [2.x.110]  style The style with which output is produced.  
* [0.x.48]*
   Print parameters to a logstream. This function allows to print all   parameters into a log-file. Sections will be indented in the usual log-   file style.     All current parameters and subsections are sorted   alphabetically by default.   This behavior can be disabled setting the optional parameter  [2.x.111]    to <tt>KeepDeclarationOrder</tt>: in this case entries are printed in the   same order as they have been declared.    
*  [2.x.112]  All style settings in  [2.x.113]  not related to the ordering are     ignored.  
* [0.x.49]*
   Log parameters in the present subsection. The subsection is determined by   the <tt>subsection_path</tt> member variable. This variable is controlled   by entering and leaving subsections through the enter_subsection() and   leave_subsection() functions.     All current parameters and subsections are sorted   alphabetically by default.   This behavior can be disabled setting the optional parameter  [2.x.114]    to <tt>KeepDeclarationOrder</tt>: in this case entries are printed in the   same order as they have been declared.    
*  [2.x.115]  All style settings in  [2.x.116]  not related to the ordering are     ignored.     In most cases, you will not want to use this function directly, but have   it called recursively by the previous function.  
* [0.x.50]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.51]*
   Write the data of this object to a stream for the purpose of   serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.52]*
   Read the data of this object from a stream for the purpose of   serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.53]*
   Write and read the data of this object from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.54]*
   Test for equality.  
* [0.x.55]*
   Return a set of parameter names (including subsection names) corresponding   to those entries of the parameter handler that have not been set by one of   the functions parsing parameters from an input file or by an explicit call   to one of the set() functions, but that have been declared as mandatory   parameters that must be set (through the last argument of the   declare_entry() function or add_parameter() function).  
* [0.x.56]*
   Asserts that those entries of the parameter handler with flag   `has_to_be_set = true` have been set. An exception is invoked   if at least one of these parameters has not been set.  
* [0.x.57]*
    [2.x.117]  Exceptions    [2.x.118]   
* [0.x.58]*
   Exception  
* [0.x.59]*
   Exception  
* [0.x.60]*
   Exception  
* [0.x.61]*
   Exception  
* [0.x.62]*
   Exception for when there are an unequal number of 'subsection' and 'end'   statements. The first argument is the name of the file and the second   argument is a formatted list of the subsection path before and after   entering the parser.  
* [0.x.63]*
   Exception for when, during parsing of a parameter file, the parser   encounters a subsection in the file that was not previously declared.  
* [0.x.64]*
   General exception for a line that could not be parsed, taking, as   arguments, the line number, file name, and a brief description of why the   line cannot be parsed.  
* [0.x.65]*
   Exception for an entry in a parameter file that does not match the   provided pattern. The arguments are, in order, the line number, file   name, entry value, entry name, and a description of the pattern.  
* [0.x.66]*
   Exception for when an XML file cannot be read at all. This happens when   there is no top-level XML element called "ParameterHandler" or when there   are multiple top level elements.  
* [0.x.67]*
   Exception for when an entry in an XML parameter file does not match the   provided pattern. The arguments are, in order, the entry value, entry   name, and a description of the pattern.      [2.x.119]  Use ExcValueDoesNotMatchPattern instead of ExcInvalidEntryForPatternXML.  
* [0.x.68]*
   Exception for when the file given in an include statement cannot be   open. The arguments are, in order, the line number of the include   statement, current parameter file name, and the name of the file intended   for inclusion.  
* [0.x.69]*
   The separator used when accessing elements of a path into the parameter   tree.  
* [0.x.70]*
   Path of presently selected subsections; empty list means top level  
* [0.x.71]*
   The complete tree of sections and entries. See the general documentation   of this class for a description how data is stored in this variable.     The variable is a pointer so that we can use an incomplete type, rather   than having to include all of the property_tree stuff from boost. This   works around a problem with gcc 4.5.  
* [0.x.72]*
   A map that stores a pair of boolean variables for each entry   added to the parameter handler. The first bool describes whether the   parameter has to be set according to the last argument of the functions   declare_entry() or add_parameter(), and the second bool contains the   information whether the parameter has been set by any of the functions   parsing input parameters or by a set function of this class.  
* [0.x.73]*
   A list of patterns that are used to describe the parameters of this   object. Every nodes in the property tree corresponding to a parameter   stores an index into this array.  
* [0.x.74]*
   A list of actions that are associated with parameters. These   are added by the add_action() function. Nodes in the property   tree corresponding to individual parameters   store indices into this array in order to reference specific actions.  
* [0.x.75]*
   Return the string that identifies the current path into the property   tree. This is only a path, i.e. it is not terminated by the   path_separator character.     This function simply calls collate_path_string() with    [2.x.120]  as argument  
* [0.x.76]*
   Given the name of an entry as argument, the function computes a full path   into the parameter tree using the current subsection.  
* [0.x.77]*
   This function computes a full path into the parameter tree given a path   from the current subsection and the name of an entry.  
* [0.x.78]*
   Scan one line of input. <tt>input_filename</tt> and   <tt>current_line_n</tt> are the name of the input file and the number of   the line presently scanned (these are used in exception messages to show   where parse errors occurred). This function will raise an exception if   the line contains an undeclared subsection or entry, if the line's entry   does not match its given pattern, or if the line could not be understood   as a valid parameter file expression.     The function modifies its argument, but also takes it by value, so the   caller's variable is not changed.     If  [2.x.121]  is  [2.x.122] , the parser   will skip undefined sections and entries. This is useful for partially   parsing a parameter file, for example to obtain only the spatial dimension   of the problem. By default all entries and subsections are expected to be   declared.  
* [0.x.79]*
   Print out the parameters of the subsection given by the    [2.x.123]  argument, as well as all subsections   within it recursively. This function is called from the   print_parameters() function, and is implemented for all  [2.x.124]    arguments other than XML and JSON (where we can output the   entire set of parameters via BOOST functions). The  [2.x.125]    argument indicates how many spaces the output should be indented,   so that subsections properly nest inside the output of higher   sections.  
* [0.x.80]*
 Global operator which returns an object in which all bits are set which are either set in the first or the second argument. This operator exists since if it did not then the result of the bit-or <tt>operator |</tt> would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type  [2.x.126] 

* 
* [0.x.81]*
 The class MultipleParameterLoop offers an easy possibility to test several parameter sets during one run of the program. For this it uses the ParameterHandler class to read in data in a standardized form, searches for variant entry values and performs a loop over all combinations of parameters.
*  Variant entry values are given like this:  
* [1.x.42]
*  The loop will then perform three runs of the program, one for each value of <tt>Time step size</tt>, while all other parameters are as specified or with their default value. If there are several variant entry values in the input, a loop is performed for each combination of variant values:  
* [1.x.43]
*  will result in four runs of the programs, with time step 0.1 and 0.2 for each of the two solvers.
*  In addition to variant entries, this class also supports [1.x.44] that look like this:  
* [1.x.45]
*  This indicates that if there are variant entries producing a total of four different runs, then we will write their results to the files <tt>ofile.1</tt>, <tt>ofile.2</tt>, <tt>ofile.3</tt> and <tt>ofile.4</tt>, respectively. Array entries do not generate multiple runs of the main loop themselves, but if there are variant entries, then in the [1.x.46]th run of the main loop, also the [1.x.47]th value of an array is returned.
*  Since the different variants are constructed in the order of declaration, not in the order in which the variant entries appear in the input file, it may be difficult to guess the mapping between the different variants and the appropriate entry in an array. You will have to check the order of declaration, or use only one variant entry.
*  It is guaranteed that only selections which match the regular expression (pattern) given upon declaration of an entry are given back to the program. If a variant value does not match the regular expression, the default value is stored and an error is issued. Before the first run of the loop, all possible values are checked for their conformance, so that the error is issued at the very beginning of the program.
* 

*  [1.x.48]
*  The usage of this class is similar to the ParameterHandler class. First the entries and subsections have to be declared, then a loop is performed in which the different parameter sets are set, a new instance of a user class is created which is then called. Taking the classes of the example for the ParameterHandler class, the extended program would look like this:  
* [1.x.49]
* 
*  As can be seen, first a new helper class has to be set up. This must contain a virtual constructor for a problem class. You can also derive your problem class from  [2.x.127]  and let <tt>create_new</tt> clear all member variables. If you have access to all inherited member variables in some way this is the recommended procedure. A third possibility is to use multiple inheritance and derive a helper class from both the  [2.x.128]  and the problem class. In any case, <tt>create_new</tt> has to provide a clean problem object which is the problem in the second and third possibility.
*  The derived class also has to provide for member functions which declare the entries and which run the program. Running the program includes getting the parameters out of the ParameterHandler object.
*  After defining an object of this helper class and an object of the MultipleParameterLoop class, the entries have to be declared in the same way as for the ParameterHandler class. Then the input has to be read. Finally the loop is called. This executes the following steps:  
* [1.x.50]
*  <tt>UserObject</tt> is the parameter to the <tt>loop</tt> function. <tt>create_new</tt> is given the number of the run (starting from one) to enable naming output files differently for each run.
* 

*  [1.x.51]
*  Variant values are specified like <tt>prefix{ v1 | v2 | v3 | ... }postfix</tt>. Whitespace to the right of the opening brace <tt>{</tt> is ignored as well as to the left of the closing brace <tt>}</tt> while whitespace on the respectively other side is not ignored. Whitespace around the mid symbols <tt>|</tt> is also ignored. The empty selection <tt>prefix{ v1 | }postfix</tt> is also allowed and produces the strings <tt>prefixv1postfix</tt> and <tt>prefixpostfix</tt>.
*  The syntax for array values is equal, apart from the double braces: <tt>prefix{{ v1 | v2 | v3 }}postfix</tt>.
* 

*  [1.x.52]
*  Given the above extensions to the example program for the ParameterHandler and the following input file  
* [1.x.53]
*  this is the output:  
* [1.x.54]
*  Since <tt>create_new</tt> gets the number of the run it would also be possible to output the number of the run.
* 

* 

* 
*  [2.x.129] 

* 
* [0.x.82]*
   This is the class the helper class or the problem class has to be derived   of.  
* [0.x.83]*
     Destructor. It doesn't actually do anything, but is declared to force     derived classes to have a virtual destructor.    
* [0.x.84]*
     <tt>create_new</tt> must provide a clean object, either by creating a     new one or by cleaning an old one.    
* [0.x.85]*
     Get the parameters and run any necessary action.    
* [0.x.86]*
   Constructor  
* [0.x.87]*
   Destructor. Declare this only to have a virtual destructor, which is   safer as we have virtual functions. It actually does nothing spectacular.  
* [0.x.88]*
   Read input from a stream until the stream returns the <tt>eof</tt>   condition or error. The second argument can be used to denote the name of   the file (if that's what the input stream represents) we are reading   from; this is only used when creating output for error messages.     If non-empty  [2.x.130]  is provided, the ParameterHandler object   will stop parsing lines after encountering  [2.x.131]  .   This is handy when adding extra data that shall be parsed manually.     If  [2.x.132]  is  [2.x.133] , the parameter handler   will skip undefined sections and entries. This is useful for partially   parsing a parameter file, for example to obtain only the spatial dimension   of the problem. By default all entries and subsections are expected to be   declared.    
*  [2.x.134]  This is the only overload of the three <tt>parse_input</tt>   functions implemented by ParameterHandler overridden with new behavior by   this class. This is because the other two <tt>parse_input</tt> functions   just reformat their inputs and then call this version.  
* [0.x.89]*
   Overriding virtual functions which are overloaded (like    [2.x.135]  which has two different sets of input   argument types) causes the non-overridden functions to be hidden. Get   around this by explicitly using both variants of    [2.x.136]  and then overriding the one we care about.  
* [0.x.90]*
   run the central loop.  
* [0.x.91]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.92]*
   An object in the list of entries with multiple values.  
* [0.x.93]*
     Declare what a multiple entry is: a variant entry (in curly braces     <tt>{</tt>, <tt>}</tt>) or an array (in double curly braces     <tt>{{</tt>, <tt>}}</tt>).    
* [0.x.94]*
       A variant entry.      
* [0.x.95]*
       An array entry.      
* [0.x.96]*
     Constructor    
* [0.x.97]*
     Construct an object with given subsection path, name and value. The     splitting up into the different variants is done later by     <tt>split_different_values</tt>.    
* [0.x.98]*
     Split the entry value into the different branches.    
* [0.x.99]*
     Path to variant entry.    
* [0.x.100]*
     Name of entry.    
* [0.x.101]*
     Original variant value.    
* [0.x.102]*
     List of entry values constructed out of what was given in the input     file.    
* [0.x.103]*
     Store whether this entry is a variant entry or an array.    
* [0.x.104]*
     Determine an estimate for the memory consumption (in bytes) of this     object.    
* [0.x.105]*
   List of variant entry values.  
* [0.x.106]*
   Number of branches constructed from the different combinations of the   variants. This obviously equals the number of runs to be performed.  
* [0.x.107]*
   Initialize the different branches, i.e.  construct the combinations.  
* [0.x.108]*
   Traverse the section currently set by   enter_subsection()/leave_subsection() and see which of the entries are   variant or array entries. Then fill the multiple_choices variable using   this information.  
* [0.x.109]*
   Transfer the entry values for one run to the entry tree.  
* [0.x.110]

include/deal.II-translator/base/parsed_convergence_table_0.txt
[0.x.0]*


* 
*  [2.x.0] 
*  This class simplifies the construction of convergence tables, reading the options for the generation of the table from a parameter file. It provides a series of methods that can be used to compute the error given a reference exact solution, or the difference between two numerical solutions, or any other custom computation of the error, given via  [2.x.1]  objects.
*  An example usage of this class is given by

* 
* [1.x.0]
* 
*  The above code constructs a ParsedConvergenceTable that works for scalar problems, and will produce an error table with `H1_norm`, `L2_norm`, and `Linfty_norm` norms of the error.
*  Whenever a call to the methods error_from_exact() or difference() is made, the instance of this class inspects its parameters, computes all norms specified by the parameter given at construction time, possibly modified via a parameter file, computes all extra column entries specified using the method add_extra_column(), and writes one row of the convergence table.
*  Once you have finished with the computations, a call to output_table() will generate a formatted convergence table on the provided stream, and to the file (if any) specified in the parameter file.
*  With a small modification, the same code can be used to estimate the errors of mixed or multi-physics problems, e.g.:

* 
* [1.x.1]
* 
*  The above code assumes that you are solving a Stokes problem with three components. Two components for the vector velocity field `u`, and one component for the pressure field `p`, and will produce an error table with `H1` and `L2` norm of the error in the velocity field (first two, components) and `L2` error in the pressure field.
*  You may also call `table.output_table()` without arguments, to write the table only to the file specified in the parameter file.
*  By calling the method add_parameters() passing a ParameterHandler object, the following options will be defined in the given ParameterHandler object (in the current level of the ParameterHandler object, i.e., whatever level you have entered with the  [2.x.2]  method), and can be modified at run time through a parameter file:

* 
* [1.x.2]
* 
*  When using this class, please cite

* 
* [1.x.3]
* 

* 
* [0.x.1]*
   Minimal constructor for ParsedConvergenceTable objects.     The number of components must match the number of components of the   finite element space that is used to compute the errors. If   a component name is repeated, than it is interpreted as a vector field,   and the errors of the repeated components are grouped together.     The size of the vector  [2.x.3]  must match the number of   unique component names, and may contain zero or more comma separated   identifiers for the norm to compute for each component (see the   documentation of  [2.x.4]  for the available options).     For example, the following constructor  
* [1.x.4]
*    would produce (if the parameter file is left untouched) a table similar to  
* [1.x.5]
*      See the other constructor for a documentation of all the parameters you can   change.      [2.x.5]  component_names Specify the names of the components;    [2.x.6]  list_of_error_norms Specify what error norms to compute for each   unique component name.  
* [0.x.2]*
   Full constructor for ParsedConvergenceTable.      [2.x.7]  component_names Names of the components. Repeated consecutive   names are interpreted as components of a vector valued field;    [2.x.8]  list_of_error_norms Specify what error norms to compute for each   unique component name;    [2.x.9]  exponent The exponent to use in p-norms;    [2.x.10]  extra_columns Extra columns to add. These may be "cells" or "dofs";    [2.x.11]  rate_key Specify the extra column by which we will compute the   error rates. This key can either be one of "cells" or "dofs", or, if you   add extra columns to the table via the method add_extra_column(), it may   be one of the extra columns you added;    [2.x.12]  rate_mode Specify the rate mode to use when computing error rates.   This maybe either "reduction_rate", "reduction_rate_log2", or "none". See   the documentation of  [2.x.13]  for an explanation of how   each of this mode behaves;    [2.x.14]  error_file_name Name of error output file (with extension txt,   gpl, tex, or org). If different from the empty string, than   output_table() also writes in this file in the format deduced from its   extension;    [2.x.15]  precision How many digits to use when writing the error;    [2.x.16]  compute_error Control whether the filling of the table is enabled   or not. This flag may be used to disable at run time any error computation;     The parameters you specify with this constructor can be written to a   ParameterHandler object by calling the add_parameters() method. Once you   call the add_parameters() method, the following options will be defined in   the given ParameterHandler object, and the parameters of the instance of   this class will follow the modification you make to the ParameterHandler   object at run time:  
* [1.x.6]
*   
* [0.x.3]*
   Attach all the parameters in this class to entries of the parameter   handler  [2.x.17]  Whenever the content of  [2.x.18]  changes, the parameters   of this class will be updated.  
* [0.x.4]*
   Add a row to the error table, containing the error between  [2.x.19]  and   the  [2.x.20]  function, in the norm(s) specified in the parameter file.     If you specify a  [2.x.21]  function during this call, then this is used   to compute weighted errors. The weight function can be either a scalar   function (which will be used for all components), or a vector function.   When it is a vector function, an assertion is triggered if the number of   components does not coincide with the number of components of the   underlying finite element space.  
* [0.x.5]*
   Same as above, with a different mapping.  
* [0.x.6]*
   Add an additional column (with name  [2.x.22]  to the table, by invoking   the function  [2.x.23]  when calling error_from_exact() or   difference().     You can call this method as many times as you want. If  [2.x.24]  was   already used in a previous call, then calling this method with the same   name will overwrite whatever function you had previously specified. If   you use a lambda function for this call, make sure that the variables used   internally in the lambda function remain valid until the call to   error_from_exact() or difference().     Make sure you add all extra columns before the first call to   error_from_exact() or difference(). Adding additional columns to the   convergence table after you already started filling the table will trigger   an exception.     This method may be used, for example, to compute the error w.r.t. to   time step increments in time, for example:  
* [1.x.7]
*    will produce a table similar to  
* [1.x.8]
*    provided that you use the following parameter file (only non default   entries are shown here):  
* [1.x.9]
*         [2.x.25]  column_name Name of the column to add;    [2.x.26]  custom_function %Function that will be called to fill the given   entry. You need to make sure that the scope of this function is valid   up to the call to error_from_exact() or difference();    [2.x.27]  compute_rate If set to true, then this column will be included in   the list of columns for which error rates are computed. You may want to set   this to false if you want to compute error rates with respect to this   column. In this case, you should also specify  [2.x.28]  as the rate   key in the parameter file.  
* [0.x.7]*
   Difference between two solutions in the same vector space.  
* [0.x.8]*
   Same as above, with a non default mapping.  
* [0.x.9]*
   Write the error table to the  [2.x.29]  stream (in text format), and   (possibly) to the file stream specified in the parameters (with the format   deduced from the file name extension).  
* [0.x.10]*
   Write the error table to the file stream specified in the parameters.     If the "Error file name" option in the parameter file is set to the empty   string, no output is written.  
* [0.x.11]*
   Add rates to the output table.  
* [0.x.12]*
   Names of the solution components.  
* [0.x.13]*
   Same as above, but containing repeated component names only once.  
* [0.x.14]*
   Masks for each unique component name.  
* [0.x.15]*
   Additional methods to call when adding rows to the table.  
* [0.x.16]*
   Type of error to compute per components.  
* [0.x.17]*
   Exponent to use in p-norm types.  
* [0.x.18]*
   The actual table  
* [0.x.19]*
   Extra columns to add to the table.  
* [0.x.20]*
   The name of column with respect to which we compute convergence rates.  
* [0.x.21]*
   Reduction rate mode. See  [2.x.30]  for a documentation.  
* [0.x.22]*
   The precision used to output the table.  
* [0.x.23]*
   Filename to use when writing to file.  
* [0.x.24]*
   Compute the error. If this is false, all methods that perform the   computation of the error are disabled and don't do anything.  
* [0.x.25]

include/deal.II-translator/base/parsed_function_0.txt
[0.x.0]*
   Friendly interface to the FunctionParser class. This class is meant as a   wrapper for the FunctionParser class. It is used in the  [2.x.0]  tutorial   program.     It provides two methods to declare and parse a ParameterHandler object   and creates the Function object declared in the parameter file. This   class is derived from the AutoDerivativeFunction class, so you don't need   to specify derivatives. An example of usage of this class is as follows:      
* [1.x.0]
*      And here is an example of how the input parameter could look like (see   the documentation of the FunctionParser class for a detailed description   of the syntax of the function definition):      
* [1.x.1]
*     
*  [2.x.1]   
* [0.x.1]*
     Construct a vector function. The vector function which is generated has      [2.x.2]  components (defaults to 1). The parameter  [2.x.3]  is used     to initialize the AutoDerivativeFunction class from which this class is     derived.    
* [0.x.2]*
     Declare parameters needed by this class. The additional parameter  [2.x.4]      n_components is used to generate the right code according to the number     of components of the function that will parse this ParameterHandler. If     the number of components which is parsed does not match the number of     components of this object, an assertion is thrown and the program is     aborted.  The default behavior for this class is to declare the     following entries:         
* [1.x.2]
*     
* [0.x.3]*
     Parse parameters needed by this class.  If the number of components     which is parsed does not match the number of components of this object,     an assertion is thrown and the program is aborted.  In order for the     class to function properly, we follow the same conventions declared in     the FunctionParser class (look there for a detailed description of the     syntax for function declarations).         The three variables that can be parsed from a parameter file are the     following:         
* [1.x.3]
*          %Function constants is a collection of pairs in the form name=value,     separated by commas, for example:         
* [1.x.4]
*          These constants can be used in the declaration of the function     expression, which follows the convention of the FunctionParser class.     In order to specify vector functions, semicolons have to be used to     separate the different components, e.g.:         
* [1.x.5]
*          The variable names entry can be used to customize the name of the     variables used in the Function. It defaults to         
* [1.x.6]
*          for one dimensional problems,         
* [1.x.7]
*          for two dimensional problems and         
* [1.x.8]
*          for three dimensional problems.         The time variable can be set according to specifications in the     FunctionTime base class.    
* [0.x.4]*
     Return all components of a vector-valued function at the given point  [2.x.5]      p.    
* [0.x.5]*
     Return the value of the function at the given point. Unless there is     only one component (i.e. the function is scalar), you should state the     component you want to have evaluated; it defaults to zero, i.e. the     first component.    
* [0.x.6]*
     Set the time to a specific value for time-dependent functions.         We need to overwrite this to set the time also in the accessor     FunctionParser<dim>.    
* [0.x.7]*
     The object with which we do computations.    
* [0.x.8]

include/deal.II-translator/base/partitioner_0.txt
[0.x.0]*
     This class defines a model for the partitioning of a vector (or, in     fact, any linear data structure) among processors using MPI.         The partitioner stores the global vector size and the locally owned     range as a half-open interval [ [2.x.0]   [2.x.1]  on each process.     Furthermore, it includes a structure for the point-to-point communication     patterns. It allows the inclusion of ghost indices (i.e. indices that a     current processor needs to have access to, but are owned by another     process) through an IndexSet. In addition, it also stores the other     processors' ghost indices belonging to the current processor (see     import_targets()), which are the indices where other processors might     require information from. In a sense, these import indices form the dual     of the ghost indices. This information is gathered once when constructing     the partitioner, which obviates subsequent global communication steps     when exchanging data.         The figure below gives an example of index space  [2.x.2]  being split     into four parts that are each owned by one MPI process:      [2.x.3]      The first row (above the thick black line) shows which process owns which     elements. Below it, the next four lines indicate which elements of     the overall array each processor wants to know about
* 
*  -  this is     generally a superset of the locally owned elements, with the difference     being what are called "ghost elements".         To understand the remaining pieces of the figure (and this class),     remember that in MPI, you can't just ask another process for data.     (That's not quite true: There are mechanisms in newer MPI standards     for this, but as a general rule it's true.) Rather, if you need     information, you need to send another process a message, the other     process needs to expect the message and respond as appropriate with     a message of its own. In practice, it is therefore easier and faster     if each process willalready* know what it will be asked and, at     the appropriate time, just send that data. The remaining lines of     information set up this kind of scheme.         To this end, note that process 0 will want to know about five     elements it does not own itself: those with indices 20, 21 (owned     by process 1); and 40, 41, 43 (owned by process 2). Similar information     can be obtained from the following lines. To satisfy this need for     knowledge, it would therefore be quite useful if process 1 stored     that, at the appropriate time, it will have to send elements 20, 21     to process 0. Similarly, if you go through lines 2-4 below the thick     black line, you will see that process 0 should know that it will need     to send elements 1, 2, 13, 18, 19 to process 1; 18, 19 to process 2;     and elements 1, 2, 13 to process 3. These are called "import indices"     because other processes will want to import them. Instead of storing     these indices as a set, it is often useful to use half-open index     sets instead, and so the import indices listed above form the following     collection of sets: `[1,3)`, `[13,14)`, `[18,20)`, `[18,20)`,     `[1,3)`, `[13,14)`. This is how the import indices are shown     in the figure above. We now only have to know which of these     half-open sets are to be sent to whom. This is done in the line     above it where we list the "import targets" (i.e., the target     processes for an import operations): Process 1 will receive 5     elements (which are comprised of the first three half-open     target index sets), process 2 will receive 2 indices     (the fourth half-open interval), and process 3 will receive     3 indices (the remaining two half-open intervals). This information     is encoded as the pairs `{1,5}`, `{2,2}`, `{3,3}` as the import     targets. Similar considerations can be made for what processes     1, 2, and 3 will have to send out.         Finally, when receiving information, it is useful to know how     many indices each process will receive from whom since then one     can already pre-allocate buffers of the right size. This is listed     in the last line under "ghost targets": Process 0 will receive     two elements from process 1 (namely those with indices 20, 21),     and three from process 2 (namely those with indices 40, 41, 43).     This is encoded as pairs `{1,2}` and `{2,3}`. Again, similar     considerations can be made for what processes 1, 2, and 3     should expect, and what is then shown in their respective columns.         The main purpose of this class is to set up these data structures     knowing only which process owns which elements, and for which     additional ghost elements each process needs knowledge.             [1.x.0]         The partitioner includes a mechanism for converting global to local and     local to global indices. Internally, this class stores vector elements     using the convention as follows: The local range is associated with     local indices [0, locally_owned_size()), and ghost indices are stored     consecutively in [locally_owned_size(), locally_owned_size() +     n_ghost_indices()). The ghost indices are sorted according to their     global index.             [1.x.1]         This class also handles the ghost data exchange for partitioned     arrays of objects
* 
*  -  i.e., if a separate class stores the     locally owned elements on each process, then this class     facilitates the importation of those elements that are locally     needed as ghosts but stored elsewhere. An example of where this class     is used is the  [2.x.4]  class.         The data exchange happens through four functions:      [2.x.5]       [2.x.6]  export_to_ghosted_array_start() is used for initiating an export     operation that sends data from the locally owned data field, passed as     an array, to the ghost data arrays of other processes (according to the     ghost indices stored in the present class).     This call starts non-blocking MPI send communication     routines, but does not wait for the routines to finish. Thus, the user     may not write into the respective positions of the underlying arrays as     the data might still be needed by MPI.      [2.x.7]  export_to_ghosted_array_finish() finalizes the MPI data exchange     started in export_to_ghosted_array_start() and signals that the data in     the arrays may be used for further processing or modified as     appropriate.      [2.x.8]  import_from_ghosted_array_start() is used for initiating an import     operation that sends data from a ghost data field, passed as an array,     to the locally owned array according to the ghost indices stored in the     present class. A  [2.x.9]  flag can be passed to decide     on how to combine the data in the ghost field with the data at the     owner, since both relate to the same data entry. In assembly, this is     usually an add-to operation where contributions from all processes to     a locally owned element need to be added up. This call starts     non-blocking MPI communication routines, but does not wait for the     routines to finish. Thus, the user may not write into the respective     positions of the underlying arrays as the data might still be needed by     MPI.      [2.x.10]  import_from_ghosted_array_finish() finalizes the MPI data exchange     started in import_from_ghosted_array_start() and signals that the data     in the arrays may be used for further processing or modified as     appropriate.      [2.x.11]          The MPI communication routines are point-to-point communication patterns.             [1.x.2]         This partitioner class operates on a fixed set of ghost indices and     must always be compatible with the ghost indices inside the array whose     partitioning it represents. In some cases,     one only wants to send around some of the ghost indices present in     a vector, but without creating a copy of the vector with a     suitable index set
* 
*  - think e.g. of local time stepping where different     regions of a vector might be exchanged at different stages of a time     step slice. This class supports that case by the following model: A     vector is first created with the full ghosted index set. Then, a second     Partitioner instance is created that sets ghost indices with a tighter     index set as ghosts, but specifying the larger index set as the second     argument to the set_ghost_indices() call. When data is exchanged, the     export_to_ghosted_array_start() and import_from_ghosted_array_start()     detect this case and only send the selected indices, taken from the     full array of ghost entries.    
* [0.x.1]*
       Default constructor.      
* [0.x.2]*
       Constructor with size argument. Creates an MPI_COMM_SELF structure       where there is no real parallel layout.      
* [0.x.3]*
       Constructor that takes the number of locally-owned degrees of freedom        [2.x.12]  and the number of ghost degrees of freedom  [2.x.13]              The local index range is translated to global indices in an ascending       and one-to-one fashion, i.e., the indices of process  [2.x.14]  sit exactly       between the indices of the processes  [2.x.15]  and  [2.x.16] , respectively.            
*  [2.x.17]  Setting the  [2.x.18]  variable to an appropriate value         provides memory space for the ghost data in a vector's memory         allocation as and allows access to it via local_element(). However,         the associated global indices must be handled externally in this         case.      
* [0.x.4]*
       Constructor with index set arguments. This constructor creates a       distributed layout based on a given communicators, an IndexSet       describing the locally owned range and another one for describing       ghost indices that are owned by other processors, but that we need to       have read or write access to.      
* [0.x.5]*
       Constructor with one index set argument. This constructor creates a       distributed layout based on a given communicator, and an IndexSet       describing the locally owned range. It allows to set the ghost       indices at a later time. Apart from this, it is similar to the other       constructor with two index sets.      
* [0.x.6]*
       Reinitialize the communication pattern. The first argument       `vector_space_vector_index_set` is the index set associated to a       VectorSpaceVector object. The second argument       `read_write_vector_index_set` is the index set associated to a       ReadWriteVector object.      
* [0.x.7]*
       Set the locally owned indices. Used in the constructor.      
* [0.x.8]*
       Set the ghost indices after the constructor has been       called.             The optional parameter  [2.x.19]  allows defining an       indirect addressing into a larger set of ghost indices. This setup is       useful if a distributed vector is based on that larger ghost index       set but only a tighter subset should be communicated according to        [2.x.20]       
* [0.x.9]*
       Return the global size.      
* [0.x.10]*
       Return the number of locally owned indices,       i.e., local_range().second minus local_range().first.       The returned numbers need to add up to the total number of indices when       summed over all processes              [2.x.21]  Use the more clearly named function locally_owned_size()       instead.      
* [0.x.11]*
       Return the number of locally owned indices,       i.e., local_range().second minus local_range().first.       The returned numbers need to add up to the total number of indices when       summed over all processes      
* [0.x.12]*
       Return an IndexSet representation of the local range. This class       only supports contiguous local ranges, so the IndexSet actually only       consists of one single range of data, and is equivalent to the result       of local_range().      
* [0.x.13]*
       Return the local range. The returned pair consists of the index of       the first element and the index of the element one past the last       locally owned one.      
* [0.x.14]*
       Return true if the given global index is in the local range of this       processor.      
* [0.x.15]*
       Return the local index corresponding to the given global index. If       the given global index is neither locally owned nor a ghost, an       exception is thrown.             Note that the returned local index for locally owned indices will be       between 0 and locally_owned_size()
* 
*  - 1, and the local index for       ghosts is between locally_owned_size() and locally_owned_size() +       n_ghost_indices()
* 
*  - 1.      
* [0.x.16]*
       Return the global index corresponding to the given local index.             Note that the local index for locally owned indices must be between 0       and locally_owned_size()
* 
*  - 1, and the local index for ghosts must be       between locally_owned_size() and locally_owned_size() +       n_ghost_indices()
* 
*  - 1.      
* [0.x.17]*
       Return whether the given global index is a ghost index on the       present processor. Returns false for indices that are owned locally       and for indices not present at all.      
* [0.x.18]*
       Return an IndexSet representation of all ghost indices.      
* [0.x.19]*
       Return the number of ghost indices. Same as       ghost_indices().n_elements(), but cached for simpler access.      
* [0.x.20]*
       In case the partitioner was built to define ghost indices as a subset       of indices in a larger set of ghosts, this function returns the       numbering in terms of ranges within that set. Similar structure as in       an IndexSet, but tailored to be iterated over.             In case the partitioner did not take a second set of ghost indices       into account, this subset is simply defined as the half-open interval        [2.x.22] .      
* [0.x.21]*
       Return a list of processors (first entry) and the number of ghost       degrees of freedom owned by that processor (second entry). The sum of       the latter over all processors equals n_ghost_indices().      
* [0.x.22]*
       Return a vector of ranges of local indices that we are importing during       compress(), i.e., others' ghosts that belong to the local range.       Similar structure as in an IndexSet, but tailored to be iterated over,       and some indices may be duplicated. The returned pairs consists of the       index of the first element and the index of the element one past the       last one in a range.      
* [0.x.23]*
       Number of import indices, i.e., indices that are ghosts on other       processors and we will receive data from.      
* [0.x.24]*
       Return a list of processors (first entry) and the number of degrees       of freedom imported from it during compress() operation (second entry)       for all the processors that data is obtained from, i.e., locally owned       indices that are ghosts on other processors.            
*  [2.x.23]  The returned vector only contains those processor id's for which       the second entry is non-zero.      
* [0.x.25]*
       Check whether the given partitioner is compatible with the current       partitioner. Two partitioners are compatible if       they have the same local sizes and the same ghost indices. They do not       necessarily need to correspond to the same data that is stored based       on these partioner objects. This is a local operation       only, i.e., if only some processors decide that the partitioning is       not compatible, only these processors will return  [2.x.24]  whereas       the other processors will return  [2.x.25]       
* [0.x.26]*
       Check whether the given partitioner is compatible with the       current partitioner. Two partitioners are compatible if       they have the same local size and the same ghost indices. They do not       necessarily need to correspond to the same data that is stored based       on these partioner objects. As opposed to       is_compatible(), this method checks for compatibility among all       processors and the method only returns  [2.x.26]  if the partitioner is       the same on all processors. In other words, it does a global       "and" operation over the results returned by is_compatible() on all       involved processes.             This method performs global communication, so make sure to use it       only in a context where all processors call it the same number of       times.      
* [0.x.27]*
       Return the MPI ID of the calling processor. Cached to have simple       access.      
* [0.x.28]*
       Return the total number of MPI processor participating in the given       partitioner. Cached to have simple access.      
* [0.x.29]*
       Return the MPI communicator underlying the partitioner object.      
* [0.x.30]*
       Return whether ghost indices have been explicitly added as a  [2.x.27]        ghost_indices argument. Only true if a reinit() call or constructor       provided that argument.      
* [0.x.31]*
       Start the exportation of the data in a locally owned array to the       range described by the ghost indices of this class.              [2.x.28]  communication_channel Sets an offset to the MPI_Isend and       MPI_Irecv calls that avoids interference with other ongoing       export_to_ghosted_array_start() calls on different entries. Typically       handled within the blocks of a block vector. Any value less than 200       is a valid value.              [2.x.29]  locally_owned_array The array of data from which the data is       extracted and sent to the ghost entries on a remote processor.              [2.x.30]  temporary_storage A temporary storage array of length       n_import_indices() that is used to hold the packed data from the  [2.x.31]        locally_owned_array to be sent. Note that this array must not be       touched until the respective export_to_ghosted_array_finish() call       has been made because the model uses non-blocking communication.              [2.x.32]  ghost_array The array that will receive the exported data,       i.e., the entries that a remote processor sent to the calling       process. Its size must either be n_ghost_indices() or equal the       number of ghost indices in the larger index set that was given as       second argument to set_ghost_indices(). In case only selected indices       are sent, no guarantee is made regarding the entries that do not get       set. Some of them might be used to organize the transfer and later       reset to zero, so make sure you do not use them in computations.              [2.x.33]  requests The list of MPI requests for the ongoing non-blocking       communication that will be finalized in the       export_to_ghosted_array_finish() call.             This functionality is used in        [2.x.34]       
* [0.x.32]*
       Finish the exportation of the data in a locally owned array to the       range described by the ghost indices of this class.              [2.x.35]  ghost_array The array that will receive the exported data       started in the  [2.x.36]  This must be the       same array as passed to that function, otherwise the behavior is       undefined.              [2.x.37]  requests The list of MPI requests for the ongoing non-blocking       communication that were started in the       export_to_ghosted_array_start() call. This must be the same array as       passed to that function, otherwise MPI will likely throw an error.             This functionality is used in        [2.x.38]       
* [0.x.33]*
       Start importing the data on an array indexed by the ghost indices of       this class that is later accumulated into a locally owned array with       import_from_ghosted_array_finish().              [2.x.39]  vector_operation Defines how the data sent to the owner should       be combined with the existing entries, e.g., added into.              [2.x.40]  communication_channel Sets an offset to the MPI_Isend and       MPI_Irecv calls that avoids interference with other ongoing       import_from_ghosted_array_start() calls on different       entries. Typically handled within the blocks of a block vector.       Any value less than 200 is a valid value.              [2.x.41]  ghost_array The array of ghost data that is sent to a remote       owner of the respective index in a vector. Its size must either be       n_ghost_indices() or equal the number of ghost indices in the larger       index set that was given as second argument to       set_ghost_indices(). This or the subsequent       import_from_ghosted_array_finish() function, the order is       implementation-dependent, will set all data entries behind  [2.x.42]        ghost_array to zero.              [2.x.43]  temporary_storage A temporary storage array of length       n_import_indices() that is used to hold the packed data from MPI       communication that will later be written into the locally owned       array. Note that this array must not be touched until the respective       import_from_ghosted_array_finish() call has been made because the       model uses non-blocking communication.              [2.x.44]  requests The list of MPI requests for the ongoing non-blocking       communication that will be finalized in the       export_to_ghosted_array_finish() call.             This functionality is used in        [2.x.45]       
* [0.x.34]*
       Finish importing the data from an array indexed by the ghost       indices of this class into a specified locally owned array, combining       the results according to the given input  [2.x.46]               [2.x.47]  vector_operation Defines how the data sent to the owner should       be combined with the existing entries, e.g., added into.              [2.x.48]  temporary_storage The same array given to the       import_from_ghosted_array_start() call that contains the packed data       from MPI communication. In thus function, it is combined at the       corresponding entries described by the ghost relations according to        [2.x.49]               [2.x.50]  ghost_array The array of ghost data that is sent to a remote       owner of the respective index in a vector. Its size must either be       n_ghost_indices() or equal the number of ghost indices in the larger       index set that was given as second argument to       set_ghost_indices(). This function will set all data entries behind        [2.x.51]  to zero for the implementation-dependent cases when it       was not already done in the import_from_ghosted_array_start() call.              [2.x.52]  locally_owned_storage The array of data where the resulting data       sent by remote processes to the calling process will be accumulated       into.              [2.x.53]  requests The list of MPI requests for the ongoing non-blocking       communication that have been initiated in the       import_to_ghosted_array_finish() call. This must be the same array as       passed to that function, otherwise MPI will likely throw an error.             This functionality is used in        [2.x.54]       
* [0.x.35]*
       Compute the memory consumption of this structure.      
* [0.x.36]*
       Exception      
* [0.x.37]*
       Exception      
* [0.x.38]*
       Initialize import_indices_plain_dev from import_indices_data. This       function is only used when using CUDA-aware MPI.      
* [0.x.39]*
       The global size of the vector over all processors      
* [0.x.40]*
       The range of the vector that is stored locally.      
* [0.x.41]*
       The range of the vector that is stored locally. Extracted from       locally_owned_range for performance reasons.      
* [0.x.42]*
       The set of indices to which we need to have read access but that are       not locally owned      
* [0.x.43]*
       A variable caching the number of ghost indices. It would be expensive       to use  [2.x.55]  to compute this.      
* [0.x.44]*
       An array that contains information which processors my ghost indices       belong to and how many those indices are      
* [0.x.45]*
       The set of (local) indices that we are importing during compress(),       i.e., others' ghosts that belong to the local range. Similar       structure as in an IndexSet, but tailored to be iterated over, and       some indices may be duplicates.      
* [0.x.46]*
       The set of (local) indices that we are importing during compress(),       i.e., others' ghosts that belong to the local range. The data stored is       the same than in import_indices_data but the data is expanded in plain       arrays. This variable is only used when using CUDA-aware MPI.      
* [0.x.47]*
       A variable caching the number of ghost indices. It would be expensive       to compute it by iterating over the import indices and accumulate them.      
* [0.x.48]*
       The set of processors and length of data field which send us their       ghost data      
* [0.x.49]*
       An array that caches the number of chunks in the import indices per MPI       rank. The length is import_indices_data.size()+1.      
* [0.x.50]*
       A variable caching the number of ghost indices in a larger set of       indices given by the optional argument to set_ghost_indices().      
* [0.x.51]*
       An array that caches the number of chunks in the import indices per MPI       rank. The length is ghost_indices_subset_data.size()+1.      
* [0.x.52]*
       The set of indices that appear for an IndexSet that is a subset of a       larger set. Similar structure as in an IndexSet within all ghost       indices, but tailored to be iterated over.      
* [0.x.53]*
       The ID of the current processor in the MPI network      
* [0.x.54]*
       The total number of processors active in the problem      
* [0.x.55]*
       The MPI communicator involved in the problem      
* [0.x.56]*
       A variable storing whether the ghost indices have been explicitly set.      
* [0.x.57]

include/deal.II-translator/base/partitioner.templates_0.txt
[0.x.0]

include/deal.II-translator/base/path_search_0.txt
[0.x.0]*
 Support for searching files in a list of paths and with a list of suffixes.
*  A list of search paths is maintained for each file class supported. A file class is defined by a unique string. The classes provided are  [2.x.0]  <dt> MESH  [2.x.1]  mesh input files in various formats (see GridIn) <dt> PARAMETER  [2.x.2]  Parameter files (<tt>.prm</tt>)  [2.x.3] 
*  Additional file classes can be added easily by using add_class().
*  Usage: First, you construct a PathSearch object for a certain file class, e.g. meshes. Then, you use the find() method to obtain a full path name and you can open the file.

* 
* [1.x.0]
* 
*  This piece of code will first traverse all paths in the list set up for file class <tt>MESH</tt>. If it manages to open a file, it returns the <tt>istream</tt> object. If not, it will try to append the first suffix of the suffix list and do the same. And so on. If no file is found in the end, an exception is thrown.
*  If you want to restrict your search to a certain mesh format, <tt>.inp</tt> for instance, then either use <tt>"grid.inp"</tt> in the code above or use the alternative find(const  [2.x.4]   [2.x.5]  char*) function

* 
* [1.x.1]
* 
*  Path lists are by default starting with the current directory (<tt>"./"</tt>), followed optionally by a standard directory of deal.II. Use show() to find out the path list for a given class. Paths and suffixes can be added using the functions add_path() and add_suffix(), respectively.
* 

* 
*  [2.x.6]  Directories in the path list should always end with a trailing <tt>"/"</tt>, while suffixes should always start with a dot. These characters are not added automatically (allowing you to do some real file name editing).
*   [2.x.7]  Add support for environment variables like in kpathsea.
* 

* 
*  [2.x.8] 

* 
* [0.x.1]*
   Position for adding a new item to a list.  
* [0.x.2]*
   Constructor. The first argument is a string identifying the class of   files to be searched for.     The debug argument determines the verbosity of this class.  
* [0.x.3]*
   Find a file in the class specified by the constructor and return its   complete path name (including a possible suffix).     File search works by actually trying to open the file. If  [2.x.9]  is   successful with the provided  [2.x.10]  then the file is found,   otherwise the search continues.      [2.x.11]  Be careful with  [2.x.12]  In particular, use <tt>"w"</tt>   with great care! If the file does not exist, it cannot be found. If it   does exist, the  [2.x.13]  function will truncate it to zero length.      [2.x.14]  filename The base name of the file to be found, without path   components and suffix.    [2.x.15]  open_mode The mode handed over to the  [2.x.16]  function.  
* [0.x.4]*
   Find a file in the class specified by the constructor and return its   complete path name. Do not use the standard suffix list, but only try to   apply the suffix given.     File search works by actually trying to open the file. If  [2.x.17]  is   successful with the provided  [2.x.18]  then the file is found,   otherwise the search continues.      [2.x.19]  Be careful with  [2.x.20]  In particular, use <tt>"w"</tt>   with great care! If the file does not exist, it cannot be found. If it   does exist, the  [2.x.21]  function will truncate it to zero length.      [2.x.22]  filename The base name of the file to be found, without path   components and suffix.    [2.x.23]  suffix The suffix to be used for opening.    [2.x.24]  open_mode The mode handed over to the  [2.x.25]  function.  
* [0.x.5]*
   Show the paths and suffixes used for this object.  
* [0.x.6]*
   Add a new class.  
* [0.x.7]*
   Add a path to the current class. See  [2.x.26]  for possible   position arguments.  
* [0.x.8]*
   Add a path to the current class. See  [2.x.27]  for possible   position arguments.  
* [0.x.9]*
   This class was not registered in the path search mechanism.  
*  [2.x.28]   
* [0.x.10]*
   The PathSearch class could not find a file with this name in its path   list.  
*  [2.x.29]   
* [0.x.11]*
   Type of values in the class maps.  
* [0.x.12]*
   Initialize the static list objects for further use.  
* [0.x.13]*
   Get path list for a certain class. Used to set up #my_path_list in   constructor.  
* [0.x.14]*
   Get suffix list for a certain class. Used to set up #my_suffix_list in   constructor.  
* [0.x.15]*
   The file class handled by this object.  
* [0.x.16]*
   All path lists for all classes, such that we can build them only once.  
* [0.x.17]*
   List of suffixes for each class.  
* [0.x.18]*
   Path list for the class this object belongs to.  
* [0.x.19]*
   Suffix list for the class this object belongs to.  
* [0.x.20]*
   Debug flag. No output if zero.  
* [0.x.21]*
   The empty string.  
* [0.x.22]

include/deal.II-translator/base/patterns_0.txt
[0.x.0]*
 Namespace for a few classes that act as patterns for the ParameterHandler class. These classes implement an interface that checks whether a parameter in an input file matches a certain pattern, such as "being boolean", "an integer value", etc.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Base class to declare common interface. The purpose of this class is   mostly to define the interface of patterns, and to force derived classes   to have a <tt>clone</tt> function. It is thus, in the languages of the   "Design Patterns" book (Gamma et al.), a "prototype".  
* [0.x.2]*
     Make destructor of this and all derived classes virtual.    
* [0.x.3]*
     Return <tt>true</tt> if the given string matches the pattern.    
* [0.x.4]*
     List of possible description output formats.         Capitalization chosen for similarity to  [2.x.1]     
* [0.x.5]*
       Simple text suitable for machine parsing in the static public member       functions for all of the built in inheriting classes.             Preferably human readable, but machine parsing is more critical.      
* [0.x.6]*
       Easily human readable plain text format suitable for plain text       documentation.      
* [0.x.7]*
       Easily human readable LaTeX format suitable for printing in manuals.      
* [0.x.8]*
     Return a string describing the pattern.    
* [0.x.9]*
     Return a pointer to an exact copy of the object. This is necessary     since we want to store objects of this type in containers, were we need     to copy objects without knowledge of their actual data type (we only     have pointers to the base class).         Ownership of the objects returned by this function is passed to the     caller of this function.    
* [0.x.10]*
     Determine an estimate for the memory consumption (in bytes) of this     object. To avoid unnecessary overhead, we do not force derived classes     to provide this function as a virtual overloaded one, but rather try to     cast the present object to one of the known derived classes and if that     fails then take the size of this base class instead and add 32 byte     (this value is arbitrary, it should account for virtual function     tables, and some possible data elements). Since there are usually not     many thousands of objects of this type around, and since the     memory_consumption mechanism is used to find out where memory in the     range of many megabytes is, this seems like a reasonable approximation.         On the other hand, if you know that your class deviates from this     assumption significantly, you can still overload this function.    
* [0.x.11]*
   Return pointer to the correct derived class based on description.  
* [0.x.12]*
     Escape the string  [2.x.2]  for the specified  [2.x.3]  so that characters     will appear as intended. For example, characters like _ can not be     written as is in LateX and have to be escaped as \_.    
* [0.x.13]*
   Test for the string being an integer. If bounds are given to the   constructor, then the integer given also needs to be within the interval   specified by these bounds. Note that unlike common convention in the C++   standard library, both bounds of this interval are inclusive; the reason   is that in practice in most cases, one needs closed intervals, but these   can only be realized with inclusive bounds for non-integer values. We   thus stay consistent by always using closed intervals.     If the upper bound given to the constructor is smaller than the   lower bound, then every integer is allowed.     Giving bounds may be useful if for example a value can only be positive   and less than a reasonable upper bound (for example the number of   refinement steps to be performed), or in many other cases.  
* [0.x.14]*
     Minimal integer value. If the numeric_limits class is available use     this information to obtain the extremal values, otherwise set it so     that this class understands that all values are allowed.    
* [0.x.15]*
     Maximal integer value. If the numeric_limits class is available use     this information to obtain the extremal values, otherwise set it so     that this class understands that all values are allowed.    
* [0.x.16]*
     Constructor. Bounds can be specified within which a valid     parameter has to be. If the upper bound is smaller than the     lower bound, then the entire set of integers is implied. The     default values are chosen such that no bounds are enforced on     parameters.         Note that the range implied by an object of the current type     is inclusive of both bounds values, i.e., the  [2.x.4]  is     an allowed value, rather than indicating a half-open value as     is often done in other contexts.    
* [0.x.17]*
     Return <tt>true</tt> if the string is an integer and its value is     within the specified range.    
* [0.x.18]*
     Return a description of the pattern that valid strings are expected to     match. If bounds were specified to the constructor, then include them     into this description.    
* [0.x.19]*
     Return a copy of the present object, which is newly allocated on the     heap. Ownership of that object is transferred to the caller of this     function.    
* [0.x.20]*
     Create a new object if the start of description matches     description_init.  Ownership of that object is transferred to the     caller of this function.    
* [0.x.21]*
     Value of the lower bound. A number that satisfies the      [2.x.5]      operation of this class must be equal to this value or larger, if the     bounds of the interval for a valid range.    
* [0.x.22]*
     Value of the upper bound. A number that satisfies the      [2.x.6]      operation of this class must be equal to this value or less, if the     bounds of the interval for a valid range.    
* [0.x.23]*
     Initial part of description    
* [0.x.24]*
   Test for the string being a <tt>double</tt>. If bounds are given to the   constructor, then the integer given also needs to be within the interval   specified by these bounds. Note that unlike common convention in the C++   standard library, both bounds of this interval are inclusive; the reason   is that in practice in most cases, one needs closed intervals, but these   can only be realized with inclusive bounds for non-integer values. We   thus stay consistent by always using closed intervals.     If the upper bound given to the constructor is smaller than the   lower bound, then every double precision number is allowed.     Giving bounds may be useful if for example a value can only be positive   and less than a reasonable upper bound (for example damping parameters   are frequently only reasonable if between zero and one), or in many other   cases.  
* [0.x.25]*
     Minimal double value used as default value, taken from      [2.x.7]     
* [0.x.26]*
     Maximal double value used as default value, taken from      [2.x.8]     
* [0.x.27]*
     Constructor. Bounds can be specified within which a valid     parameter has to be. If the upper bound is smaller than the     lower bound, then the entire set of double precision numbers is     implied. The default values are chosen such that no bounds are     enforced on parameters.    
* [0.x.28]*
     Return <tt>true</tt> if the string is a number and its value is within     the specified range.    
* [0.x.29]*
     Return a description of the pattern that valid strings are expected to     match. If bounds were specified to the constructor, then include them     into this description.    
* [0.x.30]*
     Return a copy of the present object, which is newly allocated on the     heap. Ownership of that object is transferred to the caller of this     function.    
* [0.x.31]*
     Creates a new object on the heap using  [2.x.9]  if the given      [2.x.10]  is a valid format (for example created by calling     description() on an existing object), or  [2.x.11]  otherwise. Ownership     of the returned object is transferred to the caller of this function,     which should be freed using  [2.x.12]     
* [0.x.32]*
     Value of the lower bound. A number that satisfies the      [2.x.13]      operation of this class must be equal to this value or larger, if the     bounds of the interval form a valid range.    
* [0.x.33]*
     Value of the upper bound. A number that satisfies the      [2.x.14]      operation of this class must be equal to this value or less, if the     bounds of the interval form a valid range.    
* [0.x.34]*
     Initial part of description    
* [0.x.35]*
   Test for the string being one of a sequence of values given like a   regular expression. For example, if the string given to the constructor   is <tt>"red|blue|black"</tt>, then the    [2.x.15]    function returns <tt>true</tt> exactly if the string is either "red" or   "blue" or "black". Spaces around the pipe signs do not matter and are   eliminated.  
* [0.x.36]*
     Constructor. Take the given parameter as the specification of valid     strings.    
* [0.x.37]*
     Return <tt>true</tt> if the string is an element of the description     list passed to the constructor.    
* [0.x.38]*
     Return a description of the pattern that valid strings are expected to     match. Here, this is the list of valid strings passed to the     constructor.    
* [0.x.39]*
     Return a copy of the present object, which is newly allocated on the     heap. Ownership of that object is transferred to the caller of this     function.    
* [0.x.40]*
     Determine an estimate for the memory consumption (in bytes) of this     object.    
* [0.x.41]*
     Create a new object if the start of description matches     description_init.  Ownership of that object is transferred to the     caller of this function.    
* [0.x.42]*
     List of valid strings as passed to the constructor. We don't make this     string constant, as we process it somewhat in the constructor.    
* [0.x.43]*
     Initial part of description    
* [0.x.44]*
   This pattern matches a list of values separated by commas (or another   string), each of which have to match a pattern given to the constructor.   With two additional parameters, the number of elements this list has to   have can be specified. If none is specified, the list may have zero or   more entries.  
* [0.x.45]*
     Maximal integer value. If the numeric_limits class is available use     this information to obtain the extremal values, otherwise set it so     that this class understands that all values are allowed.    
* [0.x.46]*
     Constructor. Take the given parameter as the specification of valid     elements of the list.         The three other arguments can be used to denote minimal and maximal     allowable lengths of the list, and the string that is used as a     separator between elements of the list.    
* [0.x.47]*
     Return the internally stored separator.    
* [0.x.48]*
     Return the internally stored base pattern.    
* [0.x.49]*
     Copy constructor.    
* [0.x.50]*
     Return <tt>true</tt> if the string is a comma-separated list of strings     each of which match the pattern given to the constructor.    
* [0.x.51]*
     Return a description of the pattern that valid strings are expected to     match.    
* [0.x.52]*
     Return a copy of the present object, which is newly allocated on the     heap. Ownership of that object is transferred to the caller of this     function.    
* [0.x.53]*
     Create a new object if the start of description matches     description_init.  Ownership of that object is transferred to the     caller of this function.    
* [0.x.54]*
     Determine an estimate for the memory consumption (in bytes) of this     object.    
* [0.x.55]*
      [2.x.16]  Exceptions      [2.x.17]     
* [0.x.56]*
     Exception.    
* [0.x.57]*
     Copy of the pattern that each element of the list has to satisfy.    
* [0.x.58]*
     Minimum number of elements the list must have.    
* [0.x.59]*
     Maximum number of elements the list must have.    
* [0.x.60]*
     Separator between elements of the list.    
* [0.x.61]*
     Initial part of description    
* [0.x.62]*
   This pattern matches a list of comma-separated values each of which   denotes a pair of key and value. Both key and value have to match a   pattern given to the constructor. For each entry of the map, parameters   have to be entered in the form  [2.x.18] . In other words, a   map is described in the form <code>key1: value1, key2: value2, key3:   value3, ...</code>. Two constructor arguments allow to choose a delimiter   between pairs other than the comma, and a delimiter between key and value   other than colon.     With two additional parameters, the number of elements this list has to   have can be specified. If none is specified, the map may have zero or   more entries.  
* [0.x.63]*
     Maximal integer value. If the numeric_limits class is available use     this information to obtain the extremal values, otherwise set it so     that this class understands that all values are allowed.    
* [0.x.64]*
     Constructor. Take the given parameter as the specification of valid     elements of the list.         The four other arguments can be used to denote minimal and maximal     allowable lengths of the list as well as the separators used to delimit     pairs of the map and the symbol used to separate keys and values.    
* [0.x.65]*
     Copy constructor.    
* [0.x.66]*
     Return <tt>true</tt> if the string is a comma-separated list of strings     each of which match the pattern given to the constructor.    
* [0.x.67]*
     Return a description of the pattern that valid strings are expected to     match.    
* [0.x.68]*
     Return a copy of the present object, which is newly allocated on the     heap. Ownership of that object is transferred to the caller of this     function.    
* [0.x.69]*
     Create a new object if the start of description matches     description_init.  Ownership of that object is transferred to the     caller of this function.    
* [0.x.70]*
     Determine an estimate for the memory consumption (in bytes) of this     object.    
* [0.x.71]*
     Return a reference to the key pattern.    
* [0.x.72]*
     Return a reference to the value pattern.    
* [0.x.73]*
     Return the separator of the map entries.    
* [0.x.74]*
     Return the key-value separator.    
* [0.x.75]*
      [2.x.19]  Exceptions      [2.x.20]     
* [0.x.76]*
     Exception.    
* [0.x.77]*
     Copy of the patterns that each key and each value of the map has to     satisfy.    
* [0.x.78]*
     Minimum number of elements the list must have.    
* [0.x.79]*
     Maximum number of elements the list must have.    
* [0.x.80]*
     Separator between elements of the list.    
* [0.x.81]*
     Separator between keys and values.    
* [0.x.82]*
     Initial part of description    
* [0.x.83]*
   This pattern matches colon-separated values of arbitrary types. Each type   has to match a pattern given to the constructor.     An example usage is the following:    
* [1.x.0]
*      or, if you want to exploit  [2.x.21]     
* [1.x.1]
*      The constructor expects a vector of Patterns, and optionally a string   specifying the separator to use when parsing the Tuple from a string.     The default separator is a colon, owing to the fact that a pair is in fact   a tuple with two elements.  
* [0.x.84]*
     Constructor. Use a vector of unique pointers to Patterns to construct     the tuple.          [2.x.22]  patterns The pattern each object of the Tuple should match      [2.x.23]  separator An optional string used to delimit each element     Constructor.    
* [0.x.85]*
     Constructor. Same as above, specialized for const char. This is     necessary to avoid compilers errors due to the variadic constructors     provided below.    
* [0.x.86]*
     Constructor. Creates a Tuple from more than one class derived from     PatternBase.          [2.x.24]  separator What separator to use.      [2.x.25]  patterns The list of patterns to use    
* [0.x.87]*
     Constructor. This is needed to allow users to specify     directly the separator without using  [2.x.26]          Since we support a pure variadic templates version, without this     specialization, the compiler will fail with cryptic errors.    
* [0.x.88]*
     Constructor. Same as above, using the default separator.          [2.x.27]  patterns The list of patterns to use    
* [0.x.89]*
     Copy constructor.    
* [0.x.90]*
     Return <tt>true</tt> if the string is a list of strings     each of which matches the patterns given to the constructor.    
* [0.x.91]*
     Return a description of the pattern that valid strings are expected to     match.    
* [0.x.92]*
     Return a copy of the present object, which is newly allocated on the     heap. Ownership of that object is transferred to the caller of this     function.    
* [0.x.93]*
     Create a new object if the start of description matches     description_init.  Ownership of that object is transferred to the     caller of this function.    
* [0.x.94]*
     Determine an estimate for the memory consumption (in bytes) of this     object.    
* [0.x.95]*
     Return a reference to the i-th pattern in the tuple.    
* [0.x.96]*
     Return the separator of the tuple entries.    
* [0.x.97]*
     Copy of the patterns stored in the Tuple.    
* [0.x.98]*
     Separator between elements of the list.    
* [0.x.99]*
     Initial part of description.    
* [0.x.100]*
   This class is much like the Selection class, but it allows the input to   be a comma-separated list of values which each have to be given in the   constructor argument. The input is allowed to be empty or contain values   more than once and have an arbitrary number of spaces around commas. Of   course commas are not allowed inside the values given to the constructor.     For example, if the string to the constructor was <tt>"ucd|gmv|eps"</tt>,   then the following would be legal inputs: "eps", "gmv, eps", or "".  
* [0.x.101]*
     Constructor.  [2.x.28]  is a list of valid options separated by "|".    
* [0.x.102]*
     Return <tt>true</tt> if the string is an element of the description     list passed to the constructor.    
* [0.x.103]*
     Return a description of the pattern that valid strings are expected to     match. Here, this is the list of valid strings passed to the     constructor.    
* [0.x.104]*
     Return a copy of the present object, which is newly allocated on the     heap. Ownership of that object is transferred to the caller of this     function.    
* [0.x.105]*
     Create a new object if the start of description matches     description_init.  Ownership of that object is transferred to the     caller of this function.    
* [0.x.106]*
     Determine an estimate for the memory consumption (in bytes) of this     object.    
* [0.x.107]*
      [2.x.29]  Exceptions      [2.x.30]     
* [0.x.108]*
     Exception.    
* [0.x.109]*
     List of valid strings as passed to the constructor. We don't make this     string constant, as we process it somewhat in the constructor.    
* [0.x.110]*
     Initial part of description    
* [0.x.111]*
   Test for the string being either "true" or "false". This is mapped to the   Selection class.  
* [0.x.112]*
     Constructor.    
* [0.x.113]*
     Return a description of the pattern that valid strings are expected to     match.    
* [0.x.114]*
     Return a copy of the present object, which is newly allocated on the     heap. Ownership of that object is transferred to the caller of this     function.    
* [0.x.115]*
     Create a new object if the start of description matches     description_init.  Ownership of that object is transferred to the     caller of this function.    
* [0.x.116]*
     Initial part of description    
* [0.x.117]*
   Always returns <tt>true</tt> when testing a string.  
* [0.x.118]*
     Constructor. (Allow for at least one non-virtual function in this     class, as otherwise sometimes no virtual table is emitted.)    
* [0.x.119]*
     Return <tt>true</tt> if the string matches its constraints, i.e.     always.    
* [0.x.120]*
     Return a description of the pattern that valid strings are expected to     match. Here, this is the string <tt>"[Anything]"</tt>.    
* [0.x.121]*
     Return a copy of the present object, which is newly allocated on the     heap. Ownership of that object is transferred to the caller of this     function.    
* [0.x.122]*
     Create a new object if the start of description matches     description_init.  Ownership of that object is transferred to the     caller of this function.    
* [0.x.123]*
     Initial part of description    
* [0.x.124]*
   A pattern that can be used to indicate when a parameter is intended to be   the name of a file. By itself, this class does not check whether the   string that is given in a parameter file actually corresponds to an   existing file (it could, for example, be the name of a file to which you   want to write output). Functionally, the class is therefore equivalent to   the Anything class. However, it allows to specify the [1.x.2] of a   parameter. The flag given to the constructor also allows to specify   whether the file is supposed to be an input or output file.     The reason for the existence of this class is to support graphical user   interfaces for editing parameter files. These may open a file selection   dialog if the filename is supposed to represent an input file.  
* [0.x.125]*
     Files can be used for input or output. This can be specified in the     constructor by choosing the flag <tt>type</tt>.    
* [0.x.126]*
       Open for input.      
* [0.x.127]*
       Open for output.      
* [0.x.128]*
     Constructor.  The type of the file can be specified by choosing the     flag.    
* [0.x.129]*
     Return <tt>true</tt> if the string matches its constraints, i.e.     always.    
* [0.x.130]*
     Return a description of the pattern that valid strings are expected to     match. Here, this is the string <tt>"[Filename]"</tt>.    
* [0.x.131]*
     Return a copy of the present object, which is newly allocated on the     heap. Ownership of that object is transferred to the caller of this     function.    
* [0.x.132]*
     file type flag    
* [0.x.133]*
     Create a new object if the start of description matches     description_init.  Ownership of that object is transferred to the     caller of this function.    
* [0.x.134]*
     Initial part of description    
* [0.x.135]*
   A pattern that can be used to indicate when a parameter is intended to be   the name of a directory. By itself, this class does not check whether the   string that is given in a parameter file actually corresponds to an   existing directory. Functionally, the class is therefore equivalent to   the Anything class. However, it allows to specify the [1.x.3] of a   parameter.     The reason for the existence of this class is to support graphical user   interfaces for editing parameter files. These may open a file selection   dialog to select or create a directory.  
* [0.x.136]*
     Constructor.    
* [0.x.137]*
     Return <tt>true</tt> if the string matches its constraints, i.e.     always.    
* [0.x.138]*
     Return a description of the pattern that valid strings are expected to     match. Here, this is the string <tt>"[Filename]"</tt>.    
* [0.x.139]*
     Return a copy of the present object, which is newly allocated on the     heap. Ownership of that object is transferred to the caller of this     function.    
* [0.x.140]*
     Create a new object if the start of description matches     description_init.  Ownership of that object is transferred to the     caller of this function.    
* [0.x.141]*
     Initial part of description    
* [0.x.142]*
   Namespace for a few classes and functions that act on values and patterns,   and allow to convert from non elementary types to strings and vice versa.     A typical usage of these tools is in the following example:    
* [1.x.4]
*      Convert<T> is used by the function  [2.x.31]  in this   namespace. Internally it uses the  [2.x.32]  class to decide how   many different separators are required to convert the given type to a   string.     For example, to write vectors of vectors, the default is to use "," for the   first (inner) separator, and ";" for the second (outer) separator, i.e.    
* [1.x.5]
*      Separators for  [2.x.33]  and  [2.x.34]  compatible types are   selected according to the   rank of the list and map objects, using the arrays    [2.x.35]  and    [2.x.36]      They are currently set to:    
* [1.x.6]
*      When one needs a mixture of  [2.x.37]  and  [2.x.38]  types, their   RankInfo is computed by taking the maximum of the vector_rank of the Key   and of the Value type, so that, for example, it is possible to have the   following  
* [1.x.7]
*      Some non elementary types are supported, like Point(), or    [2.x.39]  If you wish to support more types, you have to   specialize the Convert struct as well as the RankInfo struct.    
*  [2.x.40]   
* [0.x.143]*
     Converter class. This class is used to generate strings and Patterns     associated to the given type, and to convert from a string to the given     type and vice versa.         The second template parameter is used internally to allow for advanced     SFINAE (substitution failure is not an error) tricks used to specialise     this class for arbitrary STL containers and maps.    
* [0.x.144]*
       Return a  [2.x.41]  to a Pattern that can be used to interpret a       string as the type of the template argument, and the other way around.             While the current function (in the general Convert template) is       deleted, it is implemented and available in the specializations of the       Convert       class template for particular kinds of template arguments  [2.x.42]       
* [0.x.145]*
       Return a string containing a textual version of the variable s. Use the       pattern passed to perform the conversion, or create and use a default       one.             While the current function (in the general Convert template) is       deleted, it is implemented and available in the specializations of the       Convert       class template for particular kinds of template arguments  [2.x.43]       
* [0.x.146]*
       Convert a string to a value, using the given pattern. Use the pattern       passed to perform the conversion, or create and use a default one.             While the current function (in the general Convert template) is       deleted, it is implemented and available in the specializations of the       Convert       class template for particular kinds of template arguments  [2.x.44]       
* [0.x.147]*
     A utility function that simplifies the conversion to strings of     arbitrarily complex types.         This function calls the method  [2.x.45]  with the default     pattern. An example usage is the following:        
* [1.x.8]
*          See the documentation of the class  [2.x.46]  and of the     helper class  [2.x.47]  for details on the way separators     are selected when outputting STL container types.    
* [0.x.148]*
     A utility function that simplifies the conversion from strings to     arbitrary types.         This function calls the method  [2.x.48]  with the default     pattern. An example usage is the following:        
* [1.x.9]
*          See the documentation of the class  [2.x.49]  and of the     helper class  [2.x.50]  for details on the separators you     should use in your string patterns when converting from a string to a     container type.         Notice that the current content of variable  [2.x.51]  is ignored. Its type is     used to infer how to interpret the string. If the string is successfully     parsed, then  [2.x.52]  will be set to the parsed content of  [2.x.53]     
* [0.x.149]*
      [2.x.54]  Exceptions      [2.x.55]     
* [0.x.150]*
     Exception.    
* [0.x.151]*
       Store information about the rank types of the given class.             A class has Rank equal to the number of different separators       that are required to uniquely identify its element(s) in a string.             This class is used to detect whether the class T is compatible       with a  [2.x.56]  pattern or with a  [2.x.57]  pattern.             Objects like Point() or  [2.x.58]  are vector-likes, and       have vector_rank 1. Elementary types, like `int`, `unsigned int`,       `double`, etc. have vector_rank 0.  [2.x.59]   [2.x.60]  and in       general containers have rank equal to 1 + vector_rank of the contained       type. Similarly for map types.             A class with  [2.x.61]  = 0 is either elementary or a       map. A class with  [2.x.62]  = 0 is either a List compatible       class, or an elementary type.             Elementary types are not compatible with  [2.x.63]  but non       elementary types, like Point(), or  [2.x.64]  are compatible       with the List type. Adding more compatible types is a matter of adding       a specialization of this struct for the given type.      
* [0.x.152]*
       Convert a string to a value, using the given pattern, or a default one.      
* [0.x.153]

include/deal.II-translator/base/point_0.txt
[0.x.0]*
 A class that represents a point in a Cartesian space of dimension  [2.x.0]  .
*  Objects of this class are used to represent points (i.e., vectors anchored at the origin) of a vector space equipped with a [1.x.0]. They are, among other uses, passed to functions that operate on points in spaces of a priori fixed dimension: rather than using functions like <code>double f(const double x)</code> and <code>double f(const double x, const double y)</code>, you can use  [2.x.1]  instead as it allows writing dimension independent code.
*  deal.II specifically uses Point objects as indicating points that are represented by Cartesian coordinates, i.e., where a point in  [2.x.2]  dim space dimensions is characterized by signed distances along the axes of a coordinate system spanned by  [2.x.3]  mutually orthogonal unit vectors (called the "coordinate axes"). This choice of representing a vector makes addition and scaling of vectors particularly simple: one only has to add or multiply each coordinate value. On the other hand, adding or scaling vectors is not nearly as simple when a vector is represented in other kinds of coordinate systems (e.g., [1.x.1]).
* 

*  [1.x.2]
*  The Point class is derived from Tensor [2.x.4]  and consequently shares the latter's member functions and other attributes. In fact, it has relatively few additional functions itself (the most notable exception being the distance() function to compute the Euclidean distance between two points in space), and these two classes can therefore often be used interchangeably.
*  Nonetheless, there are semantic differences that make us use these classes in different and well-defined contexts. Within deal.II, we use the <tt>Point</tt> class to denote points in space, i.e., for vectors (rank-1 tensors) that are  [2.x.5] anchored at the origin [2.x.6] . On the other hand, vectors that are anchored elsewhere (and consequently do not represent  [2.x.7] points [2.x.8]  in the common usage of the word) are represented by objects of type Tensor [2.x.9]  In particular, this is the case for direction vectors, normal vectors, gradients, and the differences between two points (i.e., what you get when you subtract one point from another): all of these are represented by Tensor [2.x.10]  objects rather than Point [2.x.11] 
*  Furthermore, the Point class is only used where the coordinates of an object can be thought to possess the dimension of a length. An object that represents the weight, height, and cost of an object is neither a point nor a tensor (because it lacks the transformation properties under rotation of the coordinate system) and should consequently not be represented by either of these classes. Use an array of size 3 in this case, or the  [2.x.12]  class. Alternatively, as in the case of vector-valued functions, you can use objects of type Vector or  [2.x.13] .
* 

*   [2.x.14]  dim An integer that denotes the dimension of the space in which a point lies. This of course equals the number of coordinates that identify a point.  [2.x.15]  Number The data type in which the coordinates values are to be stored. This will, in almost all cases, simply be the default  [2.x.16]  but there are cases where one may want to store coordinates in a different (and always scalar) type. An example would be an interval type that can store the value of a coordinate as well as its uncertainty. Another example would be a type that allows for Automatic Differentiation (see, for example, the Sacado type used in  [2.x.17] ) and thereby can generate analytic (spatial) derivatives of a function when passed a Point object whose coordinates are stored in such a type.
* 

* 

* 
*  [2.x.18] 

* 
* [0.x.1]*
   Standard constructor. Creates an object that corresponds to the origin,   i.e., all coordinates are set to zero.    
*  [2.x.19]  This function can also be used in CUDA device code.  
* [0.x.2]*
   Convert a tensor to a point.  
* [0.x.3]*
   Constructor for one dimensional points. This function is only implemented   for <tt>dim==1</tt> since the usage is considered unsafe for points with   <tt>dim!=1</tt> as it would leave some components of the point   coordinates uninitialized.    
*  [2.x.20]  This function can also be used in CUDA device code.  
* [0.x.4]*
   Constructor for two dimensional points. This function is only implemented   for <tt>dim==2</tt> since the usage is considered unsafe for points with   <tt>dim!=2</tt> as it would leave some components of the point   coordinates uninitialized (if dim>2) or would not use some arguments (if   dim<2).    
*  [2.x.21]  This function can also be used in CUDA device code.  
* [0.x.5]*
   Constructor for three dimensional points. This function is only   implemented for <tt>dim==3</tt> since the usage is considered unsafe for   points with <tt>dim!=3</tt> as it would leave some components of the   point coordinates uninitialized (if dim>3) or would not use some   arguments (if dim<3).    
*  [2.x.22]  This function can also be used in CUDA device code.  
* [0.x.6]*
   Convert a  [2.x.23]  to a  [2.x.24]   
* [0.x.7]*
   Return a unit vector in coordinate direction <tt>i</tt>, i.e., a vector   that is zero in all coordinates except for a single 1 in the <tt>i</tt>th   coordinate.    
*  [2.x.25]  This function can also be used in CUDA device code.  
* [0.x.8]*
   Read access to the <tt>index</tt>th coordinate.    
*  [2.x.26]  This function can also be used in CUDA device code.  
* [0.x.9]*
   Read and write access to the <tt>index</tt>th coordinate.    
*  [2.x.27]  This function can also be used in CUDA device code.  
* [0.x.10]*
   Assignment operator from Tensor<1, dim, Number> with different underlying   scalar type. This obviously requires that the  [2.x.28]  type is   convertible to  [2.x.29]   
* [0.x.11]*
    [2.x.30]  Addition and subtraction of points.    [2.x.31]   
* [0.x.12]*
   Add an offset given as Tensor<1,dim,Number> to a point.    
*  [2.x.32]  This function can also be used in CUDA device code.  
* [0.x.13]*
   Subtract two points, i.e., obtain the vector that connects the two. As   discussed in the documentation of this class, subtracting two points   results in a vector anchored at one of the two points (rather than at the   origin) and, consequently, the result is returned as a Tensor [2.x.33]    rather than as a Point [2.x.34]     
*  [2.x.35]  This function can also be used in CUDA device code.  
* [0.x.14]*
   Subtract a difference vector (represented by a Tensor [2.x.36]  from the   current point. This results in another point and, as discussed in the   documentation of this class, the result is then naturally returned as a   Point [2.x.37]  object rather than as a Tensor [2.x.38]     
*  [2.x.39]  This function can also be used in CUDA device code.  
* [0.x.15]*
   The opposite vector.    
*  [2.x.40]  This function can also be used in CUDA device code.  
* [0.x.16]*
    [2.x.41]   
* [0.x.17]*
    [2.x.42]  Multiplication and scaling of points. Dot products. Norms.    [2.x.43]   
* [0.x.18]*
   Multiply the current point by a factor.    
*  [2.x.44]  This function can also be used in CUDA device code.      [2.x.45]  EnableIfScalar  
* [0.x.19]*
   Divide the current point by a factor.    
*  [2.x.46]  This function can also be used in CUDA device code.  
* [0.x.20]*
   Return the scalar product of the vectors representing two points.    
*  [2.x.47]  This function can also be used in CUDA device code.  
* [0.x.21]*
   Return the scalar product of this point vector with itself, i.e. the   square, or the square of the norm. In case of a complex number type it is   equivalent to the contraction of this point vector with a complex   conjugate of itself.    
*  [2.x.48]  This function is equivalent to    [2.x.49]  which returns the square of the   Frobenius norm.    
*  [2.x.50]  This function can also be used in CUDA device code.  
* [0.x.22]*
   Return the Euclidean distance of <tt>this</tt> point to the point   <tt>p</tt>, i.e. the  [2.x.51]  norm of the difference between the   vectors representing the two points.    
*  [2.x.52]  This function can also be used in CUDA device code.  
* [0.x.23]*
   Return the squared Euclidean distance of <tt>this</tt> point to the point   <tt>p</tt>.    
*  [2.x.53]  This function can also be used in CUDA device code.  
* [0.x.24]*
    [2.x.54]   
* [0.x.25]*
   Read or write the data of this object to or from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.26]*
 Global operator scaling a point vector by a scalar.
* 

* 
*  [2.x.55]  This function can also be used in CUDA device code.
*   [2.x.56]  Point  [2.x.57]  EnableIfScalar

* 
* [0.x.27]*
 Output operator for points. Print the elements consecutively, with a space in between.  [2.x.58]  Point

* 
* [0.x.28]*
 Input operator for points. Inputs the elements consecutively.  [2.x.59]  Point

* 
* [0.x.29]*
 Output operator for points of dimension 1. This is implemented specialized from the general template in order to avoid a compiler warning that the loop is empty.

* 
* [0.x.30]

include/deal.II-translator/base/polynomial_0.txt
[0.x.0]*
  [2.x.0]  Polynomials  [2.x.1] 

* 
* [0.x.1]*
 A namespace in which classes relating to the description of 1d polynomial spaces are declared.

* 
* [0.x.2]*
   Base class for all 1D polynomials. A polynomial is represented in this   class by its coefficients, which are set through the constructor or by   derived classes.     There are two paths for evaluation of polynomials. One is based on the   coefficients which are evaluated through the Horner scheme which is a   robust general-purpose scheme. An alternative and more stable evaluation   of high-degree polynomials with roots in the unit interval is provided by   a product in terms of the roots. This form is available for special   polynomials such as Lagrange polynomials or Legendre polynomials and used   with the respective constructor. To obtain this more stable evaluation   form, the constructor with the roots in form of a Lagrange polynomial   must be used. In case a manipulation is done that changes the roots, the   representation is switched to the coefficient form.     This class is a typical example of a possible template argument for the   TensorProductPolynomials class.  
* [0.x.3]*
     Constructor. The coefficients of the polynomial are passed as     arguments, and denote the polynomial  [2.x.2] , i.e. the first     element of the array denotes the constant term, the second the linear     one, and so on. The degree of the polynomial represented by this object     is thus the number of elements in the <tt>coefficient</tt> array minus     one.    
* [0.x.4]*
     Constructor creating a zero polynomial of degree  [2.x.3]     
* [0.x.5]*
     Constructor for a Lagrange polynomial and its point of evaluation. The     idea is to construct  [2.x.4] , where j     is the evaluation point specified as argument and the support points     contain all points (including x_j, which will internally not be     stored).    
* [0.x.6]*
     Default constructor creating an illegal object.    
* [0.x.7]*
     Return the value of this polynomial at the given point.         This function uses the most numerically stable evaluation     algorithm for the provided form of the polynomial. If the     polynomial is in the product form of roots, the evaluation is     based on products of the form (x
* 
*  - x_i), whereas the Horner     scheme is used for polynomials in the coefficient form.    
* [0.x.8]*
     Return the values and the derivatives of the Polynomial at point     <tt>x</tt>.  <tt>values[i], i=0,...,values.size()-1</tt> includes the     <tt>i</tt>th derivative. The number of derivatives to be computed is     thus determined by the size of the array passed.         This function uses the Horner scheme for numerical stability of the     evaluation for polynomials in the coefficient form or the product of     terms involving the roots if that representation is used.    
* [0.x.9]*
     Return the values and the derivatives of the Polynomial at point     <tt>x</tt>.  <tt>values[i], i=0,...,n_derivatives</tt> includes the     <tt>i</tt>th derivative. The number of derivatives to be computed is     determined by  [2.x.5]  and  [2.x.6]  has to provide sufficient     space for  [2.x.7]  + 1 values.         This function uses the most numerically stable evaluation     algorithm for the provided form of the polynomial. If the     polynomial is in the product form of roots, the evaluation is     based on products of the form (x
* 
*  - x_i), whereas the Horner     scheme is used for polynomials in the coefficient form.         The template type `Number2` must implement arithmetic     operations such as additions or multiplication with the type     `number` of the polynomial, and must be convertible from     `number` by `operator=`.    
* [0.x.10]*
     Degree of the polynomial. This is the degree reflected by the number of     coefficients provided by the constructor. Leading non-zero coefficients     are not treated separately.    
* [0.x.11]*
     Scale the abscissa of the polynomial.  Given the polynomial [1.x.0]     and the scaling [1.x.1], then the result of this operation is the     polynomial [1.x.2], such that [1.x.3].         The operation is performed in place.    
* [0.x.12]*
     Shift the abscissa oft the polynomial.  Given the polynomial     [1.x.4] and the shift [1.x.5], then the result of this     operation is the polynomial [1.x.6], such that [1.x.7].         The template parameter allows to compute the new coefficients with     higher accuracy, since all computations are performed with type     <tt>number2</tt>. This may be necessary, since this operation involves     a big number of additions. On a Sun Sparc Ultra with Solaris 2.8, the     difference between <tt>double</tt> and <tt>long double</tt> was not     significant, though.         The operation is performed in place, i.e. the coefficients of the     present object are changed.    
* [0.x.13]*
     Compute the derivative of a polynomial.    
* [0.x.14]*
     Compute the primitive of a polynomial. the coefficient of the zero     order term of the polynomial is zero.    
* [0.x.15]*
     Multiply with a scalar.    
* [0.x.16]*
     Multiply with another polynomial.    
* [0.x.17]*
     Add a second polynomial.    
* [0.x.18]*
     Subtract a second polynomial.    
* [0.x.19]*
     Test for equality of two polynomials.    
* [0.x.20]*
     Print coefficients.    
* [0.x.21]*
     Write or read the data of this object to or from a stream for the     purpose of serialization using the [BOOST serialization     library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).    
* [0.x.22]*
     Return an estimate (in bytes) for the memory consumption of this object.    
* [0.x.23]*
     This function performs the actual scaling.    
* [0.x.24]*
     This function performs the actual shift    
* [0.x.25]*
     Multiply polynomial by a factor.    
* [0.x.26]*
     Transform polynomial form of product of linear factors into standard     form,  [2.x.8] . Deletes all data structures related to the     product form.    
* [0.x.27]*
     Coefficients of the polynomial  [2.x.9] . This vector is filled     by the constructor of this class and may be passed down by derived     classes.         This vector cannot be constant since we want to allow copying of     polynomials.    
* [0.x.28]*
     Stores whether the polynomial is in Lagrange product form, i.e.,     constructed as a product  [2.x.10] , or not.    
* [0.x.29]*
     If the polynomial is in Lagrange product form, i.e., constructed as a     product  [2.x.11] , store the shifts  [2.x.12] .    
* [0.x.30]*
     If the polynomial is in Lagrange product form, i.e., constructed as a     product  [2.x.13] , store the weight c.    
* [0.x.31]*
   Class generates Polynomial objects representing a monomial of degree n,   that is, the function  [2.x.14] .  
* [0.x.32]*
     Constructor, taking the degree of the monomial and an optional     coefficient as arguments.    
* [0.x.33]*
     Return a vector of Monomial objects of degree zero through     <tt>degree</tt>, which then spans the full space of polynomials up to     the given degree. This function may be used to initialize the     TensorProductPolynomials and PolynomialSpace classes.    
* [0.x.34]*
     Needed by constructor.    
* [0.x.35]*
   Lagrange polynomials with equidistant interpolation points in [0,1]. The   polynomial of degree <tt>n</tt> has got <tt>n+1</tt> interpolation   points. The interpolation points are sorted in ascending order. This   order gives an index to each interpolation point.  A Lagrangian   polynomial equals to 1 at its `support point', and 0 at all other   interpolation points. For example, if the degree is 3, and the support   point is 1, then the polynomial represented by this object is cubic and   its value is 1 at the point <tt>x=1/3</tt>, and zero at the point   <tt>x=0</tt>, <tt>x=2/3</tt>, and <tt>x=1</tt>. All the polynomials have   polynomial degree equal to <tt>degree</tt>, but together they span the   entire space of polynomials of degree less than or equal <tt>degree</tt>.     The Lagrange polynomials are implemented up to degree 10.  
* [0.x.36]*
     Constructor. Takes the degree <tt>n</tt> of the Lagrangian polynomial     and the index <tt>support_point</tt> of the support point. Fills the     <tt>coefficients</tt> of the base class Polynomial.    
* [0.x.37]*
     Return a vector of polynomial objects of degree <tt>degree</tt>, which     then spans the full space of polynomials up to the given degree. The     polynomials are generated by calling the constructor of this class with     the same degree but support point running from zero to <tt>degree</tt>.     This function may be used to initialize the TensorProductPolynomials     and PolynomialSpace classes.    
* [0.x.38]*
     Compute the <tt>coefficients</tt> of the base class Polynomial. This     function is <tt>static</tt> to allow to be called in the constructor.    
* [0.x.39]*
   Given a set of points along the real axis, this function returns all   Lagrange polynomials for interpolation of these points. The number of   polynomials is equal to the number of points and the maximum degree is   one less.  
* [0.x.40]*
   Legendre polynomials of arbitrary degree. Constructing a Legendre   polynomial of degree <tt>p</tt>, the roots will be computed by the Gauss   formula of the respective number of points and a representation of the   polynomial by its roots.    
*  [2.x.15]  The polynomials defined by this class differ in two aspects by what   is usually referred to as Legendre polynomials: (i) This classes defines   them on the reference interval  [2.x.16] , rather than the commonly used   interval  [2.x.17] . (ii) The polynomials have been scaled in such a way   that they are orthonormal, not just orthogonal; consequently, the   polynomials do not necessarily have boundary values equal to one.  
* [0.x.41]*
     Constructor for polynomial of degree <tt>p</tt>.    
* [0.x.42]*
     Return a vector of Legendre polynomial objects of degrees zero through     <tt>degree</tt>, which then spans the full space of polynomials up to     the given degree. This function may be used to initialize the     TensorProductPolynomials and PolynomialSpace classes.    
* [0.x.43]*
   Lobatto polynomials of arbitrary degree on <tt>[0,1]</tt>.     These polynomials are the integrated Legendre polynomials on [0,1]. The   first two polynomials are the standard linear shape functions given by    [2.x.18]  and  [2.x.19] . For  [2.x.20]  we use the definition    [2.x.21] , where    [2.x.22]  denotes the  [2.x.23] -th Legendre polynomial on  [2.x.24] . The Lobatto   polynomials  [2.x.25]  form a complete basis of the polynomials   space of degree  [2.x.26] .     Calling the constructor with a given index <tt>k</tt> will generate the   polynomial with index <tt>k</tt>. But only for  [2.x.27]  the index equals   the degree of the polynomial. For <tt>k==0</tt> also a polynomial of   degree 1 is generated.     These polynomials are used for the construction of the shape functions of   N&eacute;d&eacute;lec elements of arbitrary order.  
* [0.x.44]*
     Constructor for polynomial of degree <tt>p</tt>. There is an exception     for <tt>p==0</tt>, see the general documentation.    
* [0.x.45]*
     Return the polynomials with index <tt>0</tt> up to <tt>degree</tt>.     There is an exception for <tt>p==0</tt>, see the general documentation.    
* [0.x.46]*
     Compute coefficients recursively.    
* [0.x.47]*
   Hierarchical polynomials of arbitrary degree on <tt>[0,1]</tt>.     When Constructing a Hierarchical polynomial of degree <tt>p</tt>, the   coefficients will be computed by a recursion formula.  The coefficients   are stored in a static data vector to be available when needed next time.     These hierarchical polynomials are based on those of Demkowicz, Oden,   Rachowicz, and Hardy (CMAME 77 (1989) 79-112, Sec. 4). The first two   polynomials are the standard linear shape functions given by  [2.x.28]  and  [2.x.29] . For  [2.x.30]  we use the definitions    [2.x.31]  and  [2.x.32] . These satisfy the recursion relations    [2.x.33]  and  [2.x.34] .     The degrees of freedom are the values at the vertices and the derivatives   at the midpoint. Currently, we do not scale the polynomials in any way,   although better conditioning of the element stiffness matrix could   possibly be achieved with scaling.     Calling the constructor with a given index <tt>p</tt> will generate the   following: if <tt>p==0</tt>, then the resulting polynomial is the linear   function associated with the left vertex, if <tt>p==1</tt> the one   associated with the right vertex. For higher values of <tt>p</tt>, you   get the polynomial of degree <tt>p</tt> that is orthogonal to all   previous ones. Note that for <tt>p==0</tt> you therefore do [1.x.8]   get a polynomial of degree zero, but one of degree one. This is to allow   generating a complete basis for polynomial spaces, by just iterating over   the indices given to the constructor.     On the other hand, the function generate_complete_basis() creates a   complete basis of given degree. In order to be consistent with the   concept of a polynomial degree, if the given argument is zero, it does   [1.x.9] return the linear polynomial described above, but rather a   constant polynomial.  
* [0.x.48]*
     Constructor for polynomial of degree <tt>p</tt>. There is an exception     for <tt>p==0</tt>, see the general documentation.    
* [0.x.49]*
     Return a vector of Hierarchical polynomial objects of degrees zero     through <tt>degree</tt>, which then spans the full space of polynomials     up to the given degree. Note that there is an exception if the given     <tt>degree</tt> equals zero, see the general documentation of this     class.         This function may be used to initialize the TensorProductPolynomials,     AnisotropicPolynomials, and PolynomialSpace classes.    
* [0.x.50]*
     Compute coefficients recursively.    
* [0.x.51]*
     Get coefficients for constructor.  This way, it can use the non-     standard constructor of Polynomial.    
* [0.x.52]*
     Vector with already computed coefficients. For each degree of the     polynomial, we keep one pointer to the list of coefficients; we do so     rather than keeping a vector of vectors in order to simplify     programming multithread-safe. In order to avoid memory leak, we use a     unique_ptr in order to correctly free the memory of the vectors when     the global destructor is called.    
* [0.x.53]*
   Polynomials for Hermite interpolation condition.     This is the set of polynomials of degree at least three, such that the   following interpolation conditions are met: the polynomials and their   first derivatives vanish at the values [1.x.10]=0 and [1.x.11]=1, with   the exceptions [1.x.12]<sub>0</sub>(0)=1,   [1.x.13]<sub>[1.x.14]</sub>(1)=1, [1.x.15]'<sub>2</sub>(0)=1,   [1.x.16]<sub>3</sub>(1)=1.     For degree three, we obtain the standard four Hermitian interpolation   polynomials, see for instance [1.x.17].   For higher degrees, these are augmented first, by the polynomial of   degree four with vanishing values and derivatives at [1.x.18]=0 and   [1.x.19]=1, then by the product of this fourth order polynomial with   Legendre polynomials of increasing order. The implementation is  
* [1.x.20]
*   
* [0.x.54]*
     Constructor for polynomial with index <tt>p</tt>. See the class     documentation on the definition of the sequence of polynomials.    
* [0.x.55]*
     Return the polynomials with index <tt>0</tt> up to <tt>p+1</tt> in a     space of degree up to <tt>p</tt>. Here, <tt>p</tt> has to be at least     3.    
* [0.x.56]*
   Polynomials for a variant of Hermite polynomials with better condition   number in the interpolation than the basis from HermiteInterpolation.     In analogy to the proper Hermite polynomials, this basis evaluates the   first polynomial  [2.x.35]  to 1 at  [2.x.36]  and has both a zero value and zero   derivative at  [2.x.37] . Likewise, the last polynomial  [2.x.38]  evaluates to 1   at  [2.x.39]  with a zero value and zero derivative at  [2.x.40] . The second   polynomial  [2.x.41]  and the second to last polynomial  [2.x.42]  represent   the derivative degree of freedom at  [2.x.43]  and  [2.x.44] , respectively.   They are zero at both the end points  [2.x.45]  and have zero   derivative at the opposite end,  [2.x.46]  and  [2.x.47] . As   opposed to the original Hermite polynomials,  [2.x.48]  does not have zero   derivative at  [2.x.49] . The additional degree of freedom is used to make    [2.x.50]  and  [2.x.51]  orthogonal, which for  [2.x.52]  results in a root at    [2.x.53]  for  [2.x.54]  and at  [2.x.55]  for  [2.x.56] ,   respectively. Furthermore, the extension of these polynomials to higher   degrees  [2.x.57]  is constructed by adding additional nodes inside the unit   interval, again ensuring better conditioning. The nodes are computed as   the roots of the Jacobi polynomials for  [2.x.58] , which are   orthogonal against the square of the generating function  [2.x.59]    with the Hermite   property. Then, these polynomials are constructed in the usual way as   Lagrange polynomials with double roots at  [2.x.60]  and  [2.x.61] . For example   with  [2.x.62] , all of  [2.x.63]  get an additional root at  [2.x.64]    through the factor  [2.x.65] . In summary, this basis is dominated by   nodal contributions, but it is not a nodal one because the second and   second to last polynomials that are non-nodal, and due to the presence of   double nodes in  [2.x.66]  and  [2.x.67] . The weights of the basis functions are   set such that the sum of all polynomials with unit weight represents the   constant function 1, similarly to Lagrange polynomials.     The basis only contains Hermite information for  [2.x.68] ,   but it is also implemented for degrees between 0 and two. For the linear   case, the usual hat functions are implemented, whereas the polynomials   for  [2.x.69]  are  [2.x.70] ,  [2.x.71] , and    [2.x.72] , in accordance with the construction principle for degree 3.     These two relaxations improve the condition number of the mass matrix   (i.e., interpolation) significantly, as can be seen from the following   table:      [2.x.73]      This polynomial inherits the advantageous property of Hermite polynomials   where only two functions have value and/or derivative nonzero on a face   advantageous for discontinuous Galerkin methods   but gives better condition numbers of interpolation, which improves the   performance of some iterative schemes like conjugate gradients with   point-Jacobi. This polynomial is used in FE_DGQHermite.  
* [0.x.57]*
     Constructor for the polynomial with index <tt>index</tt> within the set     up polynomials of degree  [2.x.74]     
* [0.x.58]*
     Return the polynomials with index <tt>0</tt> up to <tt>degree+1</tt> in     a space of degree up to <tt>degree</tt>.    
* [0.x.59]   Evaluate a Jacobi polynomial  [2.x.75]  specified by the   parameters  [2.x.76]   [2.x.77]   [2.x.78]  where  [2.x.79]  is the degree of the   Jacobi polynomial.    
*  [2.x.80]  The Jacobi polynomials are not orthonormal and are defined on the   unit interval  [2.x.81]  as usual for deal.II, rather than  [2.x.82]  often   used in literature.  [2.x.83]  is the point of evaluation.  
* [0.x.60]*
   Compute the roots of the Jacobi polynomials on the unit interval  [2.x.84]    of the given degree. These roots are used in several places inside the   deal.II library, such as the Gauss-Lobatto quadrature formula or for the   Hermite-like interpolation.     The algorithm uses a Newton algorithm, using the zeros of the Chebyshev   polynomials as an initial guess. This code has been tested for alpha and   beta equal to zero (Legendre case), one (Gauss-Lobatto case) as well as   two, so be careful when using it for other values as the Newton iteration   might or might not converge.  
* [0.x.61]

include/deal.II-translator/base/polynomials_abf_0.txt
[0.x.0]*
 This class implements the [1.x.0]-conforming, vector-valued Arnold-Boffi-Falk polynomials as described in the article by Arnold-Boffi- Falk: Quadrilateral H(div) finite elements, SIAM J. Numer. Anal. Vol.42, No.6, pp.2429-2451
* 

*  The ABF polynomials are constructed such that the divergence is in the tensor product polynomial space [1.x.1]. Therefore, the polynomial order of each component must be two orders higher in the corresponding direction, yielding the polynomial spaces [1.x.2] and [1.x.3] in 2D and 3D, resp.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Constructor. Creates all basis functions for Raviart-Thomas polynomials   of given degree.      [2.x.1]  k: the degree of the Raviart-Thomas-space, which is the degree of   the largest tensor product polynomial space [1.x.4]   contained.  
* [0.x.2]*
   Compute the value and the first and second derivatives of each Raviart-   Thomas polynomial at  [2.x.2]      The size of the vectors must either be zero or equal <tt>n()</tt>.  In   the first case, the function will not compute these values.     If you need values or derivatives of all tensor product polynomials then   use this function, rather than using any of the <tt>compute_value</tt>,   <tt>compute_grad</tt> or <tt>compute_grad_grad</tt> functions, see below,   in a loop over all tensor product polynomials.  
* [0.x.3]*
   Return the name of the space, which is <tt>ABF</tt>.  
* [0.x.4]*
   Return the number of polynomials in the space <tt>RT(degree)</tt> without   requiring to build an object of PolynomialsABF. This is required by the   FiniteElement classes.  
* [0.x.5]*
    [2.x.3]   [2.x.4]   
* [0.x.6]*
   An object representing the polynomial space for a single component. We   can re-use it for the other vector components by rotating the   coordinates of the evaluation point.  
* [0.x.7]*
   A mutex that guards the following scratch arrays.  
* [0.x.8]*
   Auxiliary memory.  
* [0.x.9]*
   Auxiliary memory.  
* [0.x.10]*
   Auxiliary memory.  
* [0.x.11]*
   Auxiliary memory.  
* [0.x.12]*
   Auxiliary memory.  
* [0.x.13]

include/deal.II-translator/base/polynomials_adini_0.txt
[0.x.0]*
 The cubic polynomial space for the Adini element
*  This space consists of the cubic space [1.x.0] augmented by the functions [1.x.1] and [1.x.2].
*  The basis of the space is chosen to match the node functionals of the Adini element.
*   [2.x.0]  This polynomial space is implemented in 2D only and does not compute derivatives of order 3 or higher.
* 

* 
*  [2.x.1] 

* 
* [0.x.1]*
   Constructor for the polynomials of the described space  
* [0.x.2]*
   Compute the value and the first and second derivatives of each   polynomial at <tt>unit_point</tt>.     The size of the vectors must either be equal 0 or equal n(). In the first   case, the function will not compute these values, i.e. you indicate what   you want to have computed by resizing those vectors which you want   filled.     If you need values or derivatives of all polynomials then use this   function, rather than using any of the compute_value(), compute_grad() or   compute_grad_grad() functions, see below, in a loop over all polynomials.  
* [0.x.3]*
   Compute the value of the <tt>i</tt>th polynomial at <tt>unit_point</tt>.     Consider using evaluate() instead.  
* [0.x.4]*
    [2.x.2]   [2.x.3]   
* [0.x.5]*
    [2.x.4]   [2.x.5]   
* [0.x.6]*
    [2.x.6]   [2.x.7]   
* [0.x.7]*
    [2.x.8]   [2.x.9]   
* [0.x.8]*
   Compute the gradient of the <tt>i</tt>th polynomial at   <tt>unit_point</tt>.     Consider using evaluate() instead.  
* [0.x.9]*
   Compute the second derivative (grad_grad) of the <tt>i</tt>th polynomial   at <tt>unit_point</tt>.     Consider using evaluate() instead.  
* [0.x.10]*
   Return the name of the space, which is <tt>PolynomialsAdini</tt>.  
* [0.x.11]*
    [2.x.10]   [2.x.11]   
* [0.x.12]*
   Store the coefficients of the polynomials in the order    [2.x.12]   
* [0.x.13]*
   Store the coefficients of the x-derivative of the polynomials in the   order  [2.x.13]   
* [0.x.14]*
   Store the coefficients of the y-derivative of the polynomials in the   order  [2.x.14]   
* [0.x.15]*
   Store the coefficients of the second x-derivative of the polynomials in   the order  [2.x.15]   
* [0.x.16]*
   Store the coefficients of the second y-derivative of the polynomials in   the order  [2.x.16]   
* [0.x.17]*
   Store the coefficients of the second mixed derivative of the polynomials   in the order  [2.x.17]   
* [0.x.18]

include/deal.II-translator/base/polynomials_barycentric_0.txt
[0.x.0]*
 Polynomial implemented in barycentric coordinates.
*  Barycentric coordinates are a coordinate system defined on simplices that are particularly easy to work with since they express coordinates in the simplex as convex combinations of the vertices. For example, any point in a triangle can be written as
*  [1.x.0]
*  where each value  [2.x.0]  is the relative weight of each vertex (so the centroid is, in 2D, where each  [2.x.1] ). Since we only consider convex combinations we can rewrite this equation as
*  [1.x.1]
*  This results in three polynomials that are equivalent to  [2.x.2]  in 2D. More exactly, this class implements a polynomial space defined with the basis, in 2D, of

* 
* [1.x.2]
*  and, in 3D,

* 
* [1.x.3]
* 
*  which is, in practice, a very convenient basis for defining simplex polynomials: for example, the fourth basis function of a TRI6 element is
*  [1.x.4]
*  Barycentric polynomials in  [2.x.3] -dimensional space have  [2.x.4]  can be written in terms of the other monomials.
*  Monomials can be conveniently constructed with  [2.x.5] 
* 

* 
*  [2.x.6] 

* 
* [0.x.1]*
   Constructor for the zero polynomial.  
* [0.x.2]*
   Constructor for a monomial.  
* [0.x.3]*
   Return the specified monomial.  
* [0.x.4]*
   Print the polynomial to the output stream with lowest-order terms first.   For example, the first P6 basis function is printed as    [2.x.7]  is the first   barycentric variable,  [2.x.8]  is the second, etc.  
* [0.x.5]*
   Degree of each barycentric polynomial.  
* [0.x.6]*
   Unary minus.  
* [0.x.7]*
   Add a scalar.  
* [0.x.8]*
   Subtract a scalar.  
* [0.x.9]*
   Multiply by a scalar.  
* [0.x.10]*
   Divide by a scalar.  
* [0.x.11]*
   Add another barycentric polynomial.  
* [0.x.12]*
   Subtract another barycentric polynomial.  
* [0.x.13]*
   Multiply by another barycentric polynomial.  
* [0.x.14]*
   Differentiate in barycentric coordinates.  
* [0.x.15]*
   Differentiate in Cartesian coordinates.  
* [0.x.16]*
   Evaluate the polynomial.  
* [0.x.17]*
   Return an estimate, in bytes, of the memory usage of the object.  
* [0.x.18]*
   Coefficients of the polynomial. The exponents are the integer indexes.  
* [0.x.19]*
   Utility function for barycentric polynomials
* 
*  - its convenient to loop   over all the indices at once in a dimension-independent way, but we also   need to access the actual indices of the underlying Table object. This   utility function converts an integral index into the equivalent   TableIndices array (which are also the implicitly stored polynomial   exponents).  
* [0.x.20]*
 Scalar polynomial space based on barycentric polynomials.

* 
* [0.x.21]*
   Make the dimension available to the outside.  
* [0.x.22]*
   Get the standard Lagrange basis for a specified degree.  
* [0.x.23]*
   Constructor taking the polynomial  [2.x.9]  as input.  
* [0.x.24]*
   Access operator.  
* [0.x.25]*
    [2.x.10]   [2.x.11]   
* [0.x.26]*
    [2.x.12]   [2.x.13]   
* [0.x.27]*
    [2.x.14]   [2.x.15]   
* [0.x.28]*
    [2.x.16]   [2.x.17]   
* [0.x.29]*
    [2.x.18]   [2.x.19]   
* [0.x.30]*
    [2.x.20]   [2.x.21]   
* [0.x.31]*
    [2.x.22]   [2.x.23]   
* [0.x.32]*
    [2.x.24]   [2.x.25]   
* [0.x.33]*
    [2.x.26]   [2.x.27]   
* [0.x.34]*
    [2.x.28]   [2.x.29]   
* [0.x.35]*
    [2.x.30]   [2.x.31]   
* [0.x.36]*
 Multiply a BarycentricPolynomial by a constant.

* 
* [0.x.37]*
 Add a constant to a BarycentricPolynomial.

* 
* [0.x.38]*
 Subtract a BarycentricPolynomial from a constant.

* 
* [0.x.39]*
 Write a BarycentricPolynomial to the provided output stream.

* 
* [0.x.40]

include/deal.II-translator/base/polynomials_bdm_0.txt
[0.x.0]*
 This class implements the [1.x.0]-conforming, vector-valued Brezzi-Douglas-Marini ([1.x.1]) polynomials described in Brezzi and Fortin's [1.x.2] (refer to pages 119
* 
*  - 124).
*  The [1.x.3] polynomial space contain the entire   [2.x.0]  space (constructed with PolynomialSpace Legendre polynomials) as well as part of  [2.x.1]  (ie.  [2.x.2] ).  Furthermore,  [2.x.3]  elements are designed so that  [2.x.4]  and  [2.x.5] . More details of two and three dimensional  [2.x.6]  elements are given below. [2.x.7]    <dt> In 2D:    [2.x.8]   [2.x.9] .
*    Note: the curl of a scalar function is given by  [2.x.10] .
*    The basis used to construct the  [2.x.11]  shape functions is  
* [1.x.4]
* 
*    The dimension of the  [2.x.12]  space is  [2.x.13] , with  [2.x.14]  unknowns per edge and  [2.x.15]  interior unknowns.
*    <dt> In 3D:    [2.x.16]   [2.x.17] .
*    Note: the 3D description of  [2.x.18]  is not unique.  See [1.x.5] page 122 for an alternative definition.
*    The dimension of the  [2.x.19]  space is    [2.x.20] , with  [2.x.21]    unknowns per face and  [2.x.22]  interior unknowns.
*  [2.x.23] 
* 

* 
* 

* 
*  [2.x.24] 

* 
* [0.x.1]*
   Constructor. Creates all basis functions for BDM polynomials of given   degree.      [2.x.25]  k: the degree of the BDM-space, which is the degree of the largest   complete polynomial space [1.x.6] contained in the BDM-   space.  
* [0.x.2]*
   Compute the value and the first and second derivatives of each BDM   polynomial at  [2.x.26]      The size of the vectors must either be zero or equal <tt>n()</tt>.  In   the first case, the function will not compute these values.     If you need values or derivatives of all tensor product polynomials then   use this function, rather than using any of the <tt>compute_value</tt>,   <tt>compute_grad</tt> or <tt>compute_grad_grad</tt> functions, see below,   in a loop over all tensor product polynomials.  
* [0.x.3]*
   Return the name of the space, which is <tt>BDM</tt>.  
* [0.x.4]*
   Return the number of polynomials in the space <tt>BDM(degree)</tt>   without requiring to build an object of PolynomialsBDM. This is required   by the FiniteElement classes.  
* [0.x.5]*
    [2.x.27]   [2.x.28]   
* [0.x.6]*
   An object representing the polynomial space used here. The constructor   fills this with the monomial basis.  
* [0.x.7]*
   Storage for monomials. In 2D, this is just the polynomial of order   [1.x.7]. In 3D, we need all polynomials from degree zero to [1.x.8].  
* [0.x.8]*
   A mutex that guards the following scratch arrays.  
* [0.x.9]*
   Auxiliary memory.  
* [0.x.10]*
   Auxiliary memory.  
* [0.x.11]*
   Auxiliary memory.  
* [0.x.12]*
   Auxiliary memory.  
* [0.x.13]*
   Auxiliary memory.  
* [0.x.14]

include/deal.II-translator/base/polynomials_bernardi_raugel_0.txt
[0.x.0]*
 This class implements the Bernardi-Raugel polynomials similarly to the description in the [1.x.0] paper from 1985 by Christine Bernardi and Geneviève Raugel.
*  The Bernardi-Raugel polynomials are originally defined as an enrichment of the  [2.x.0]  elements on simplicial meshes for Stokes problems by the addition of bubble functions, yielding a locking-free finite element which is a subset of  [2.x.1]  elements. This implementation is an enrichment of  [2.x.2]  elements which is a subset of  [2.x.3]  elements for quadrilateral and hexahedral meshes.
*  The  [2.x.4]  bubble functions are defined to have magnitude 1 at the center of face  [2.x.5]  and direction  [2.x.6]  normal to face  [2.x.7] , and magnitude 0 on all other vertices and faces. Ordering is consistent with the face numbering in GeometryInfo. The vector  [2.x.8]  points in the positive axis direction and not necessarily normal to the element for consistent orientation across edges. [2.x.9]    <dt> 2D bubble functions (in order)    [2.x.10]   [2.x.11]  edge:  [2.x.12] 
*          [2.x.13]  edge:  [2.x.14] 
*          [2.x.15]  edge:  [2.x.16] 
*          [2.x.17]  edge:  [2.x.18] 
*    <dt> 3D bubble functions (in order)    [2.x.19]   [2.x.20]  edge:  [2.x.21] 
*          [2.x.22]  edge:  [2.x.23] 
*          [2.x.24]  edge:  [2.x.25] 
*          [2.x.26]  edge:  [2.x.27] 
*          [2.x.28]  edge:  [2.x.29] 
*          [2.x.30]  edge:  [2.x.31] 
*  [2.x.32] 
*  Then the  [2.x.33]  polynomials are defined on quadrilaterals and hexahedra by  [2.x.34] .
* 

* 

* 
*  [2.x.35] 

* 
* [0.x.1]*
   Constructor. Creates all basis functions for Bernardi-Raugel polynomials   of given degree.      [2.x.36]  k The degree of the Bernardi-Raugel-space, which is currently   limited to the case <tt>k=1</tt>.  
* [0.x.2]*
   Return the name of the space, which is <tt>BernardiRaugel</tt>.  
* [0.x.3]*
   Compute the value and derivatives of each Bernardi-Raugel   polynomial at  [2.x.37]      The size of the vectors must either be zero or equal <tt>n()</tt>.  In   the first case, the function will not compute these values.     If you need values or derivatives of all tensor product polynomials then   use this function, rather than using any of the <tt>compute_value</tt>,   <tt>compute_grad</tt> or <tt>compute_grad_grad</tt> functions, see below,   in a loop over all tensor product polynomials.  
* [0.x.4]*
   Return the number of polynomials in the space <tt>BR(degree)</tt> without   requiring to build an object of PolynomialsBernardiRaugel. This is   required by the FiniteElement classes.  
* [0.x.5]*
    [2.x.38]   [2.x.39]   
* [0.x.6]*
   An object representing the polynomial space of Q   functions which forms the <tt>BR</tt> polynomials through   outer products of these with the corresponding unit ijk   vectors.  
* [0.x.7]*
   An object representing the polynomial space of bubble   functions which forms the <tt>BR</tt> polynomials through   outer products of these with the corresponding normals.  
* [0.x.8]*
   A static member function that creates the polynomial space we use to   initialize the #polynomial_space_Q member variable.  
* [0.x.9]*
   A static member function that creates the polynomial space we use to   initialize the #polynomial_space_bubble member variable.  
* [0.x.10]

include/deal.II-translator/base/polynomials_bernstein_0.txt
[0.x.0]*
 This class implements Bernstein basis polynomials of desire degree as described in http://www.idav.ucdavis.edu/education/CAGDNotes/Bernstein-Polynomials.pdf in the paragraph "Converting from the Bernstein Basis to the Power Basis".
*  They are used to create the Bernstein finite element FE_Bernstein.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Construct the  [2.x.1] 
* 
*  - h Bernstein Polynomial of degree  [2.x.2]     
* [1.x.0]
*       [2.x.3]  index    [2.x.4]  degree  
* [0.x.2]

include/deal.II-translator/base/polynomials_integrated_legendre_sz_0.txt
[0.x.0]*
 Class implementing the integrated Legendre polynomials described in the PhD thesis of Sabine Zaglmayr.
*  This class was written based upon the existing deal.II Legendre class as a base, but with the coefficients adjusted so that the recursive formula is for the integrated Legendre polynomials described in the PhD thesis of Sabine Zaglmayr. The polynomials can be generated recursively from:
* 

* 
* 
*  -  [2.x.0]  (added so that it can be generated recursively from 0)
* 

* 
* 
*  -  [2.x.1] 
* 

* 
* 
*  -  [2.x.2] 
* 

* 
* 
*  -  [2.x.3] .
*  However, it is also possible to generate them directly from the Legendre polynomials:
*   [2.x.4] 

* 
* [0.x.1]*
   Constructor generating the coefficients of the polynomials at degree p.  
* [0.x.2]*
   Return the complete set of Integrated Legendre polynomials up to the   given degree.  
* [0.x.3]*
   Main function to compute the co-efficients of the polynomial at degree p.  
* [0.x.4]

include/deal.II-translator/base/polynomials_nedelec_0.txt
[0.x.0]*
 This class implements the first family [1.x.0]-conforming, vector-valued polynomials, proposed by J.-C. Nédélec in 1980 (Numer. Math. 35).
*  The Nédélec polynomials are constructed such that the curl is in the tensor product polynomial space [1.x.1]. Therefore, the polynomial order of each component must be one order higher in the corresponding two directions, yielding the polynomial spaces [1.x.2] and [1.x.3] in 2D and 3D, resp.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Constructor. Creates all basis functions for Nédélec polynomials of   given degree.      [2.x.1]  k: the degree of the Nédélec space, which is the degree of the   largest tensor product polynomial space [1.x.4] contained.  
* [0.x.2]*
   Compute the value and the first and second derivatives of each Nédélec   polynomial at  [2.x.2]      The size of the vectors must either be zero or equal <tt>n()</tt>.  In   the first case, the function will not compute these values.     If you need values or derivatives of all tensor product polynomials then   use this function, rather than using any of the <tt>compute_value</tt>,   <tt>compute_grad</tt> or <tt>compute_grad_grad</tt> functions, see below,   in a loop over all tensor product polynomials.  
* [0.x.3]*
   Return the name of the space, which is <tt>Nedelec</tt>.  
* [0.x.4]*
   Return the number of polynomials in the space <tt>N(degree)</tt> without   requiring to build an object of PolynomialsNedelec. This is required by   the FiniteElement classes.  
* [0.x.5]*
    [2.x.3]   [2.x.4]   
* [0.x.6]*
   An object representing the polynomial space for a single component. We   can re-use it by rotating the coordinates of the evaluation point.  
* [0.x.7]*
   A static member function that creates the polynomial space we use to   initialize the #polynomial_space member variable.  
* [0.x.8]

include/deal.II-translator/base/polynomials_p_0.txt
[0.x.0]*
  [2.x.0]  Polynomials  [2.x.1] 

* 
* [0.x.1]*
 This class implements the polynomial space of degree <tt>p</tt> based on the monomials  [2.x.2] . I.e. in <tt>d</tt> dimensions it constructs all polynomials of the form  [2.x.3] , where  [2.x.4] . The base polynomials are given a specific ordering, e.g. in 2 dimensions:  [2.x.5] . The ordering of the monomials in  [2.x.6]  matches the ordering of the monomials in  [2.x.7]  for  [2.x.8] .

* 
* [0.x.2]*
   Access to the dimension of this object, for checking and automatic   setting of dimension in other classes.  
* [0.x.3]*
   Constructor. Creates all basis functions of  [2.x.9] .  [2.x.10]  p: the degree of   the polynomial space  
* [0.x.4]*
   Return the degree <tt>p</tt> of the polynomial space <tt>P_p</tt>.     Note, that this number is  [2.x.11]  compare   definition in PolynomialSpace.  
* [0.x.5]*
   For the <tt>n</tt>th polynomial  [2.x.12]  this function   gives the degrees i,j,k in the x,y,z directions.     In 1d and 2d, obviously only i and i,j are returned.  
* [0.x.6]*
   Fills the <tt>index_map</tt>.  
* [0.x.7]*
   Degree <tt>p</tt> of the polynomial space  [2.x.13] , i.e. the number   <tt>p</tt> which was given to the constructor.  
* [0.x.8]

include/deal.II-translator/base/polynomial_space_0.txt
[0.x.0]*
 Representation of the space of polynomials of degree at most n in higher dimensions.
*  Given a vector of [1.x.0] one-dimensional polynomials [1.x.1] to [1.x.2], where [1.x.3] has degree [1.x.4], this class generates all dim-dimensional polynomials of the form [1.x.5], where the sum of [1.x.6], [1.x.7] and [1.x.8] is less than or equal [1.x.9].
*  The output_indices() function prints the ordering of the polynomials, i.e. for each dim-dimensional polynomial in the polynomial space it gives the indices i,j,k of the one-dimensional polynomials in x,y and z direction. The ordering of the dim-dimensional polynomials can be changed by using the set_numbering() function.
*  The standard ordering of polynomials is that indices for the first space dimension vary fastest and the last space dimension is slowest. In particular, if we take for simplicity the vector of monomials [1.x.10], we get
*   [2.x.0]  <dt> 1D  [2.x.1]  [1.x.11] <dt> 2D:  [2.x.2]  [1.x.12] <dt> 3D:  [2.x.3]  [1.x.13]  [2.x.4] 
* 

* 
*  [2.x.5] 

* 
* [0.x.1]*
   Access to the dimension of this object, for checking and automatic   setting of dimension in other classes.  
* [0.x.2]*
   Constructor. <tt>pols</tt> is a vector of pointers to one-dimensional   polynomials and will be copied into a private member variable. The static   type of the template argument <tt>pols</tt> needs to be convertible to    [2.x.6]  i.e. should usually be a derived class   of  [2.x.7]   
* [0.x.3]*
   Prints the list of the indices to <tt>out</tt>.  
* [0.x.4]*
   Set the ordering of the polynomials. Requires   <tt>renumber.size()==n()</tt>. Stores a copy of <tt>renumber</tt>.  
* [0.x.5]*
   Compute the value and the first and second derivatives of each   polynomial at <tt>unit_point</tt>.     The size of the vectors must either be equal 0 or equal n(). In the first   case, the function will not compute these values, i.e. you indicate what   you want to have computed by resizing those vectors which you want   filled.     If you need values or derivatives of all polynomials then use this   function, rather than using any of the compute_value(), compute_grad() or   compute_grad_grad() functions, see below, in a loop over all polynomials.  
* [0.x.6]*
   Compute the value of the <tt>i</tt>th polynomial at unit point   <tt>p</tt>.     Consider using evaluate() instead.  
* [0.x.7]*
   Compute the <tt>order</tt>th derivative of the <tt>i</tt>th polynomial   at unit point <tt>p</tt>.     Consider using evaluate() instead.      [2.x.8]  order The order of the derivative.  
* [0.x.8]*
    [2.x.9]   [2.x.10]   
* [0.x.9]*
    [2.x.11]   [2.x.12]   
* [0.x.10]*
    [2.x.13]   [2.x.14]   
* [0.x.11]*
    [2.x.15]   [2.x.16]   
* [0.x.12]*
   Compute the gradient of the <tt>i</tt>th polynomial at unit point   <tt>p</tt>.     Consider using evaluate() instead.  
* [0.x.13]*
   Compute the second derivative (grad_grad) of the <tt>i</tt>th polynomial   at unit point <tt>p</tt>.     Consider using evaluate() instead.  
* [0.x.14]*
   Return the number of polynomials spanning the space represented by this   class. Here, if <tt>N</tt> is the number of one-dimensional polynomials   given, then the result of this function is [1.x.14] in 1d,   [1.x.15] in 2d, and [1.x.16] in 3d.  
* [0.x.15]*
   Return the name of the space, which is <tt>PolynomialSpace</tt>.  
* [0.x.16]*
    [2.x.17]   [2.x.18]   
* [0.x.17]*
   Compute numbers in x, y and z direction. Given an index <tt>n</tt> in the   d-dimensional polynomial space, return the indices i,j,k such that   [1.x.17].     In 1d and 2d, obviously only i and i,j are returned.  
* [0.x.18]*
   Copy of the vector <tt>pols</tt> of polynomials given to the constructor.  
* [0.x.19]*
   Index map for reordering the polynomials.  
* [0.x.20]*
   Index map for reordering the polynomials.  
* [0.x.21]

include/deal.II-translator/base/polynomials_piecewise_0.txt
[0.x.0]*
  [2.x.0]  Polynomials  [2.x.1] 

* 
* [0.x.1]*
 A namespace in which classes relating to the description of 1d polynomial spaces are declared.

* 
* [0.x.2]*
   Definition of piecewise 1D polynomials for the unit interval. This space   allows the description of interpolating polynomials on parts of the unit   interval, similarly to the definition of finite element basis functions   on subdivided elements. The primary purpose of this class is to   allow constructing the shape functions of the FE_Q_iso_Q1 class that has   a number of interpolation points in each coordinate direction, but instead   of using them for higher-order polynomials just chooses piecewise linear   shape functions
* 
*  -  in effect, it is a  [2.x.2]  element defined on a   subdivision of the reference cell, and replicated on each of these   sub-cells.     This class is not derived from the ScalarPolynomialsBase base class   because it is not actually a polynomial
* 
*  -  it is a piecewise polynomial.   However, it is interface-compatible with the  [2.x.3]    class, and consequently can be used as template argument for   TensorProductPolynomials.    
*  [2.x.4]   
* [0.x.3]*
     Constructor for Lagrange polynomial on an interval that is a subset of     the unit interval. It uses a polynomial description that is scaled to     the size of the subinterval compared to the unit interval, the total     number of intervals (subdivisions), the current index of the interval     as well as if the polynomial spans onto the next interval (e.g., if it     lives on two neighboring intervals).         If the number of intervals is one, the piecewise polynomial behaves     exactly like a usual polynomial.    
* [0.x.4]*
     Return the value of this polynomial at the given point, evaluating the     underlying polynomial. The polynomial evaluates to zero when outside of     the given interval (and possible the next one to the right when it     spans over that range).    
* [0.x.5]*
     Return the values and the derivatives of the Polynomial at point     <tt>x</tt>.  <tt>values[i], i=0,...,values.size()-1</tt> includes the     <tt>i</tt>th derivative. The number of derivatives to be computed is     thus determined by the size of the vector passed.         Note that all the derivatives evaluate to zero at the border between     intervals (assuming exact arithmetic) in the interior of the unit     interval, as there is no unique gradient value in that case for a     piecewise polynomial. This is not always desired (e.g., when evaluating     jumps of gradients on the element boundary), but it is the user's     responsibility to avoid evaluation at these points when it does not     make sense.    
* [0.x.6]*
     Return the values and the derivatives of the Polynomial at point     <tt>x</tt>.  <tt>values[i], i=0,...,n_derivatives</tt> includes the     <tt>i</tt>th derivative.The number of derivatives to be computed is     determined by  [2.x.5]  and  [2.x.6]  has to provide sufficient     space for  [2.x.7]  + 1 values.         Note that all the derivatives evaluate to zero at the border between     intervals (assuming exact arithmetic) in the interior of the unit     interval, as there is no unique gradient value in that case for a     piecewise polynomial. This is not always desired (e.g., when evaluating     jumps of gradients on the element boundary), but it is the user's     responsibility to avoid evaluation at these points when it does not     make sense.    
* [0.x.7]*
     Degree of the polynomial. This is the degree of the underlying base     polynomial.    
* [0.x.8]*
     Write or read the data of this object to or from a stream for the     purpose of serialization using the [BOOST serialization     library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).    
* [0.x.9]*
     Return an estimate (in bytes) for the memory consumption of this object.    
* [0.x.10]*
     Underlying polynomial object that is scaled to a subinterval and     concatenated accordingly.    
* [0.x.11]*
     A variable storing the number of intervals that the unit interval is     divided into.    
* [0.x.12]*
     A variable storing the index of the current polynomial in the range of     intervals.    
* [0.x.13]*
     Store if the polynomial spans over two adjacent intervals, i.e., the     one given in subinterval and the next one.    
* [0.x.14]*
   Generates a complete Lagrange basis on a subdivision of the unit interval   in smaller intervals for a given degree on the subintervals and number of   intervals.  
* [0.x.15]

include/deal.II-translator/base/polynomials_pyramid_0.txt
[0.x.0]*
 A namespace for functions and classes that provide support for simplex reference cell entities, i.e., triangles and tetrahedrons.
*  
*  [2.x.0] 

* 
* [0.x.1]*
 Polynomials defined on pyramid entities. This class is basis of FE_PyramidP.

* 
* [0.x.2]*
   Make the dimension available to the outside.  
* [0.x.3]   Constructor taking the polynomial  [2.x.1]  as input.    
*  [2.x.2]  Currently, only linear polynomials (degree=1) are implemented.  
* [0.x.4]*
    [2.x.3]   [2.x.4]     
*  [2.x.5]  Currently, only the vectors  [2.x.6]  and  [2.x.7]  are filled.  
* [0.x.5]*
    [2.x.8]   [2.x.9]     
*  [2.x.10]  Currently, only implemented for first derivative.  
* [0.x.6]*
    [2.x.11]   [2.x.12]     
*  [2.x.13]  Not implemented yet.  
* [0.x.7]*
    [2.x.14]   [2.x.15]     
*  [2.x.16]  Not implemented yet.  
* [0.x.8]*
    [2.x.17]   [2.x.18]     
*  [2.x.19]  Not implemented yet.  
* [0.x.9]*
    [2.x.20]   [2.x.21]     
*  [2.x.22]  Not implemented yet.  
* [0.x.10]

include/deal.II-translator/base/polynomials_rannacher_turek_0.txt
[0.x.0]*
 Basis for polynomial space on the unit square used for lowest order Rannacher Turek element.
*  The i-th basis function is the dual basis element corresponding to the dof which evaluates the function's mean value across the i-th face. The numbering can be found in GeometryInfo.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Dimension we are working in.  
* [0.x.2]*
   Constructor, checking that the basis is implemented in this dimension.  
* [0.x.3]*
   Value of basis function  [2.x.1]  at  [2.x.2]   
* [0.x.4]*
   <tt>order</tt>-th of basis function  [2.x.3]  at  [2.x.4]      Consider using evaluate() instead.  
* [0.x.5]*
    [2.x.5]   [2.x.6]   
* [0.x.6]*
    [2.x.7]   [2.x.8]   
* [0.x.7]*
    [2.x.9]   [2.x.10]   
* [0.x.8]*
    [2.x.11]   [2.x.12]   
* [0.x.9]*
   Gradient of basis function  [2.x.13]  at  [2.x.14]   
* [0.x.10]*
   Gradient of gradient of basis function  [2.x.15]  at  [2.x.16]   
* [0.x.11]*
   Compute values and derivatives of all basis functions at  [2.x.17]      Size of the vectors must be either equal to the number of polynomials or   zero. A size of zero means that we are not computing the vector entries.  
* [0.x.12]*
   Return the name of the space, which is <tt>RannacherTurek</tt>.  
* [0.x.13]*
    [2.x.18]   [2.x.19]   
* [0.x.14]

include/deal.II-translator/base/polynomials_raviart_thomas_0.txt
[0.x.0]*
 This class implements the [1.x.0]-conforming, vector-valued Raviart-Thomas polynomials as described in the book by Brezzi and Fortin.
*  The Raviart-Thomas polynomials are constructed such that the divergence is in the tensor product polynomial space [1.x.1]. Therefore, the polynomial order of each component must be one order higher in the corresponding direction, yielding the polynomial spaces [1.x.2] and [1.x.3] in 2D and 3D, resp.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Constructor. Creates all basis functions for Raviart-Thomas polynomials   of given degree.      [2.x.1]  k: the degree of the Raviart-Thomas-space, which is the degree of   the largest tensor product polynomial space [1.x.4]   contains.  
* [0.x.2]*
   Compute the value and the first and second derivatives of each Raviart-   Thomas polynomial at  [2.x.2]      The size of the vectors must either be zero or equal <tt>n()</tt>.  In   the first case, the function will not compute these values.     If you need values or derivatives of all tensor product polynomials then   use this function, rather than using any of the <tt>compute_value</tt>,   <tt>compute_grad</tt> or <tt>compute_grad_grad</tt> functions, see below,   in a loop over all tensor product polynomials.  
* [0.x.3]*
   Return the name of the space, which is <tt>RaviartThomas</tt>.  
* [0.x.4]*
   Return the number of polynomials in the space <tt>RT(degree)</tt> without   requiring to build an object of PolynomialsRaviartThomas. This is   required by the FiniteElement classes.  
* [0.x.5]*
    [2.x.3]   [2.x.4]   
* [0.x.6]*
   An object representing the polynomial space for a single component. We   can re-use it by rotating the coordinates of the evaluation point.  
* [0.x.7]*
   A static member function that creates the polynomial space we use to   initialize the #polynomial_space member variable.  
* [0.x.8]

include/deal.II-translator/base/polynomials_rt_bubbles_0.txt
[0.x.0]*
 This class implements the [1.x.0]-conforming, vector-valued enhanced Raviart-Thomas polynomials.
*  Similarly to the classical Raviart-Thomas space, the enhanced Raviart-Thomas polynomials are constructed such that the divergence is in the tensor product polynomial space [1.x.1].
*  This space is of the form [1.x.2], where [1.x.3] is defined as follows:  [2.x.0]  <dt> In 2D:

* 
* [1.x.4]
* 
*  <dt> In 3D: 
* [1.x.5]
*   [2.x.1]  where  [2.x.2] .
* 

* 
*  [2.x.3]  Unlike the classical Raviart-Thomas space, the lowest order for the enhanced space is 1, similarly to the Brezzi-Douglas-Marini (BDM) polynomial space.
*  The total dimension of the space [1.x.6], where [1.x.7] is the space dimension. This allows to associate shape functions with the Gauss-Lobatto quadrature points as shown in the figures below.
*   [2.x.4] 
* 

* 
*  [2.x.5] 

* 
* [0.x.1]*
   Constructor. Creates all basis functions for RT_bubbles polynomials of   given degree.  
* [0.x.2]*
   Computes the value and the first and second derivatives of each RT_bubbles   polynomial at  [2.x.6]      The size of the vectors must either be zero or equal <tt>n()</tt>.  In   the first case, the function will not compute these values.     If you need values or derivatives of all tensor product polynomials then   use this function, rather than using any of the <tt>compute_value</tt>,   <tt>compute_grad</tt> or <tt>compute_grad_grad</tt> functions, see below,   in a loop over all tensor product polynomials.  
* [0.x.3]*
   Return the name of the space, which is <tt>RT_Bubbles</tt>.  
* [0.x.4]*
   Return the number of polynomials in the space <tt>RT_Bubbles(degree)</tt>   without requiring to build an object of PolynomialsRT-Bubbles. This is   required by the FiniteElement classes.  
* [0.x.5]*
    [2.x.7]   [2.x.8]   
* [0.x.6]*
   An object representing the Raviart-Thomas part of the space  
* [0.x.7]*
   Storage for monomials, we need all polynomials from degree zero   to [1.x.8].  
* [0.x.8]

include/deal.II-translator/base/polynomials_wedge_0.txt
[0.x.0]*
 Polynomials defined on wedge entities. This class is basis of FE_WedgeP.
*  The polynomials are created via a tensor product of a  [2.x.0]  and a  [2.x.1]  however, are re-numerated to better match the definition of FiniteElement.

* 
* [0.x.1]*
   Make the dimension available to the outside.  
* [0.x.2]   Constructor taking the polynomial  [2.x.2]  as input.    
*  [2.x.3]  Currently, only linear (degree=1) and quadratic polynomials     (degree=2) are implemented.  
* [0.x.3]*
    [2.x.4]   [2.x.5]     
*  [2.x.6]  Currently, only the vectors  [2.x.7]  and  [2.x.8]  are filled.  
* [0.x.4]*
    [2.x.9]   [2.x.10]     
*  [2.x.11]  Currently, only implemented for first derivative.  
* [0.x.5]*
    [2.x.12]   [2.x.13]     
*  [2.x.14]  Not implemented yet.  
* [0.x.6]*
    [2.x.15]   [2.x.16]     
*  [2.x.17]  Not implemented yet.  
* [0.x.7]*
    [2.x.18]   [2.x.19]     
*  [2.x.20]  Not implemented yet.  
* [0.x.8]*
    [2.x.21]   [2.x.22]     
*  [2.x.23]  Not implemented yet.  
* [0.x.9]*
    [2.x.24]   [2.x.25]     
*  [2.x.26]  Not implemented yet.  
* [0.x.10]*
   Scalar polynomials defined on a triangle.  
* [0.x.11]*
   Scalar polynomials defined on a line.  
* [0.x.12]

include/deal.II-translator/base/process_grid_0.txt
[0.x.0]*
     A class taking care of setting up a two-dimensional processor grid.     For example an MPI communicator with 5 processes can be arranged into a     2x2 grid with the 5-th processor being inactive:    
* [1.x.0]
*          A shared pointer to this class is provided to ScaLAPACKMatrix matrices to     perform block-cyclic distribution.         Note that this class allows to setup a process grid which has fewer     MPI cores than the total number of cores in the communicator.         Currently the only place where one would use a ProcessGrid object is     in connection with a ScaLAPACKMatrix object.    
* [0.x.1]*
       Constructor for a process grid with  [2.x.0]  and  [2.x.1]  for a given  [2.x.2]        The product of rows and columns should be less or equal to the total       number of cores       in the  [2.x.3]       
* [0.x.2]*
       Constructor for a process grid for a given  [2.x.4]        In this case the process grid is heuristically chosen based on the       dimensions and block-cyclic distribution of a target matrix provided       in  [2.x.5]   [2.x.6]   [2.x.7]  and  [2.x.8]              The maximum number of MPI cores one can utilize is        [2.x.9] , where  [2.x.10]  are the matrix       dimension and  [2.x.11]  are the block sizes and  [2.x.12]  is the number of       processes in the  [2.x.13]  This function then creates a 2D processor grid       assuming the ratio between number of process row  [2.x.14]  and columns  [2.x.15]  to       be equal the ratio between matrix dimensions  [2.x.16]  and  [2.x.17] .             For example, a square matrix  [2.x.18]  with the block size  [2.x.19]        and the  [2.x.20]  with 11 cores will result in the  [2.x.21]        process grid.      
* [0.x.3]*
       Destructor.      
* [0.x.4]*
       Return the number of rows in the processes grid.      
* [0.x.5]*
       Return the number of columns in the processes grid.      
* [0.x.6]*
       Return row of this process in the process grid.             It's negative for inactive processes.      
* [0.x.7]*
       Return column of this process in the process grid.             It's negative for inactive processes.      
* [0.x.8]*
       Send  [2.x.22]  values stored consequently starting at  [2.x.23]  from       the process with rank zero to processes which       are not in the process grid.      
* [0.x.9]*
       Return  [2.x.24]  if the process is active within the grid.      
* [0.x.10]*
       A private constructor which takes grid dimensions as an        [2.x.25] .      
* [0.x.11]*
       An MPI communicator with all processes (active and inactive).      
* [0.x.12]*
       An MPI communicator with inactive processes and the process with rank       zero.      
* [0.x.13]*
       BLACS context. This is equivalent to MPI communicators and is       used by ScaLAPACK.      
* [0.x.14]*
       Rank of this MPI process.      
* [0.x.15]*
       Total number of MPI processes.      
* [0.x.16]*
       Number of rows in the processes grid.      
* [0.x.17]*
       Number of columns in the processes grid.      
* [0.x.18]*
       Row of this process in the grid.             It's negative for in-active processes.      
* [0.x.19]*
       Column of this process in the grid.             It's negative for in-active processes.      
* [0.x.20]*
       A flag which is true for processes within the 2D process grid.      
* [0.x.21]

include/deal.II-translator/base/qprojector_0.txt
[0.x.0]*
 This class is a helper class to facilitate the usage of quadrature formulae on faces or subfaces of cells. It computes the locations of quadrature points on the unit cell from a quadrature object for a manifold of one dimension less than that of the cell and the number of the face. For example, giving the Simpson rule in one dimension and using the project_to_face() function with face number 1, the returned points will be (1,0), (1,0.5) and (1,1). Note that faces have an orientation, so when projecting to face 3, you will get (0,0), (0,0.5) and (0,1), which is in clockwise sense, while for face 1 the points were in counterclockwise sense.
*  For the projection to subfaces (i.e. to the children of a face of the unit cell), the same applies as above. Note the order in which the children of a face are numbered, which in two dimensions coincides with the orientation of the face.
*  The second set of functions generates a quadrature formula by projecting a given quadrature rule on [1.x.0] faces and subfaces. This is used in the FEFaceValues and FESubfaceValues classes. Since we now have the quadrature points of all faces and subfaces in one array, we need to have a way to find the starting index of the points and weights corresponding to one face or subface within this array. This is done through the DataSetDescriptor member class.
*  The different functions are grouped into a common class to avoid putting them into global namespace. However, since they have no local data, all functions are declared <tt>static</tt> and can be called without creating an object of this class.
*  For the 3d case, you should note that the orientation of faces is even more intricate than for two dimensions. Quadrature formulae are projected upon the faces in their standard orientation, not to the inside or outside of the hexahedron. To make things more complicated, in 3d we allow faces in two orientations (which can be identified using <tt>cell->face_orientation(face)</tt>), so we have to project quadrature formula onto faces and subfaces in two orientations. (Refer to the documentation of the Triangulation class for a description of the orientation of the different faces, as well as to  [2.x.0]  "the glossary entry on face orientation" for more information on this.) The DataSetDescriptor member class is used to identify where each dataset starts.

* 
* [0.x.1]*
   Define an alias for a quadrature that acts on an object of one dimension   less. For cells, this would then be a face quadrature.  
* [0.x.2]*
   Compute the quadrature points on the cell if the given quadrature formula   is used on face <tt>face_no</tt>. For further details, see the general   doc for this class.    
*  [2.x.1]  This function is deprecated since it makes an implicit assumption   that the cell is a line (1D), a quad (2D), or a hex (3D). Use the other   version of this function that takes the reference cell type instead.  
* [0.x.3]*
   Compute the quadrature points on the cell if the given quadrature formula   is used on face <tt>face_no</tt>. For further details, see the general   doc for this class.  
* [0.x.4]*
   Compute the cell quadrature formula corresponding to using   <tt>quadrature</tt> on face <tt>face_no</tt>. For further details, see   the general doc for this class.    
*  [2.x.2]  This function is deprecated since it makes an implicit assumption   that the cell is a line (1D), a quad (2D), or a hex (3D). Use the other   version of this function that takes the reference cell type instead.  
* [0.x.5]*
   Compute the cell quadrature formula corresponding to using   <tt>quadrature</tt> on face <tt>face_no</tt>. For further details, see   the general doc for this class.  
* [0.x.6]*
   Compute the quadrature points on the cell if the given quadrature formula   is used on face <tt>face_no</tt>, subface number <tt>subface_no</tt>   corresponding to  [2.x.3]  <tt>ref_case</tt>. The last argument is   only used in 3D.    
*  [2.x.4]  Only the points are transformed. The quadrature weights are the   same as those of the original rule.    
*  [2.x.5]  This function is deprecated since it makes an implicit assumption   that the cell is a line (1D), a quad (2D), or a hex (3D). Use the other   version of this function that takes the reference cell type instead.  
* [0.x.7]*
   Compute the quadrature points on the cell if the given quadrature formula   is used on face <tt>face_no</tt>, subface number <tt>subface_no</tt>   corresponding to  [2.x.6]  <tt>ref_case</tt>. The last argument is   only used in 3D.    
*  [2.x.7]  Only the points are transformed. The quadrature weights are the   same as those of the original rule.  
* [0.x.8]*
   Compute the cell quadrature formula corresponding to using   <tt>quadrature</tt> on subface <tt>subface_no</tt> of face   <tt>face_no</tt> with RefinementCase<dim-1> <tt>ref_case</tt>. The last   argument is only used in 3D.    
*  [2.x.8]  Only the points are transformed. The quadrature weights are the   same as those of the original rule.    
*  [2.x.9]  This function is deprecated since it makes an implicit assumption   that the cell is a line (1D), a quad (2D), or a hex (3D). Use the other   version of this function that takes the reference cell type instead.  
* [0.x.9]*
   Compute the cell quadrature formula corresponding to using   <tt>quadrature</tt> on subface <tt>subface_no</tt> of face   <tt>face_no</tt> with RefinementCase<dim-1> <tt>ref_case</tt>. The last   argument is only used in 3D.    
*  [2.x.10]  Only the points are transformed. The quadrature weights are the   same as those of the original rule.    
*  [2.x.11]  This function is deprecated since it makes an implicit assumption   that the cell is a line (1D), a quad (2D), or a hex (3D). Use the other   version of this function that takes the reference cell type instead.  
* [0.x.10]*
   Take a face quadrature formula and generate a cell quadrature formula   from it where the quadrature points of the given argument are projected   on all faces.     The weights of the new rule are replications of the original weights.   Thus, the sum of the weights is not one, but the number of faces, which   is the surface of the reference cell.     This in particular allows us to extract a subset of points corresponding   to a single face and use it as a quadrature on this face, as is done in   FEFaceValues.    
*  [2.x.12]  In 3D, this function produces eight sets of quadrature points for   each face, in order to cope possibly different orientations of the mesh.    
*  [2.x.13]  This function is deprecated since it makes an implicit assumption   that the cell is a line (1D), a quad (2D), or a hex (3D). Use the other   version of this function that takes the reference cell type instead.  
* [0.x.11]*
   Take a collection of face quadrature formulas and generate a cell   quadrature formula from it where the quadrature points of the given   argument are projected on all faces.     The weights of the new rule are replications of the original weights.   Thus, the sum of the weights is not one, but the number of faces, which   is the surface of the reference cell.     This in particular allows us to extract a subset of points corresponding   to a single face and use it as a quadrature on this face, as is done in   FEFaceValues.    
*  [2.x.14]  In 3D, this function produces eight sets of quadrature points for   each face, in order to cope possibly different orientations of the mesh.  
* [0.x.12]*
   Like the above function, applying the same face quadrature   formula on all faces.  
* [0.x.13]*
   Take a face quadrature formula and generate a cell quadrature formula   from it where the quadrature points of the given argument are projected   on all subfaces.     Like in project_to_all_faces(), the weights of the new rule sum up to the   number of faces (not subfaces), which is the surface of the reference   cell.     This in particular allows us to extract a subset of points corresponding   to a single subface and use it as a quadrature on this face, as is done   in FESubfaceValues.    
*  [2.x.15]  This function is deprecated since it makes an implicit assumption   that the cell is a line (1D), a quad (2D), or a hex (3D). Use the other   version of this function that takes the reference cell type instead.  
* [0.x.14]*
   Take a face quadrature formula and generate a cell quadrature formula   from it where the quadrature points of the given argument are projected   on all subfaces.     Like in project_to_all_faces(), the weights of the new rule sum up to the   number of faces (not subfaces), which is the surface of the reference   cell.     This in particular allows us to extract a subset of points corresponding   to a single subface and use it as a quadrature on this face, as is done   in FESubfaceValues.  
* [0.x.15]*
   Project a given quadrature formula to a child of a cell. You may want to   use this function in case you want to extend an integral only over the   area which a potential child would occupy. The child numbering is the   same as the children would be numbered upon refinement of the cell.     As integration using this quadrature formula now only extends over a   fraction of the cell, the weights of the resulting object are divided by    [2.x.16]     
*  [2.x.17]  This function is deprecated since it makes an implicit assumption   that the cell is a line (1D), a quad (2D), or a hex (3D). Use the other   version of this function that takes the reference cell type instead.  
* [0.x.16]*
   Project a given quadrature formula to a child of a cell. You may want to   use this function in case you want to extend an integral only over the   area which a potential child would occupy. The child numbering is the   same as the children would be numbered upon refinement of the cell.     As integration using this quadrature formula now only extends over a   fraction of the cell, the weights of the resulting object are divided by    [2.x.18]   
* [0.x.17]*
   Project a quadrature rule to all children of a cell. Similarly to   project_to_all_subfaces(), this function replicates the formula generated   by project_to_child() for all children, such that the weights sum up to   one, the volume of the total cell again.     The child numbering is the same as the children would be numbered upon   refinement of the cell.    
*  [2.x.19]  This function is deprecated since it makes an implicit assumption   that the cell is a line (1D), a quad (2D), or a hex (3D). Use the other   version of this function that takes the reference cell type instead.  
* [0.x.18]*
   Project a quadrature rule to all children of a cell. Similarly to   project_to_all_subfaces(), this function replicates the formula generated   by project_to_child() for all children, such that the weights sum up to   one, the volume of the total cell again.     The child numbering is the same as the children would be numbered upon   refinement of the cell.  
* [0.x.19]*
   Project the one dimensional rule <tt>quadrature</tt> to the straight line   connecting the points <tt>p1</tt> and <tt>p2</tt>.    
*  [2.x.20]  This function is deprecated since it makes an implicit assumption   that the cell is a line (1D), a quad (2D), or a hex (3D). Use the other   version of this function that takes the reference cell type instead.  
* [0.x.20]*
   Project the one dimensional rule <tt>quadrature</tt> to the straight line   connecting the points <tt>p1</tt> and <tt>p2</tt>.  
* [0.x.21]*
   Since the project_to_all_faces() and project_to_all_subfaces() functions   chain together the quadrature points and weights of all projections of a   face quadrature formula to the faces or subfaces of a cell, we need a way   to identify where the starting index of the points and weights for a   particular face or subface is. This class provides this: there are static   member functions that generate objects of this type, given face or   subface indices, and you can then use the generated object in place of an   integer that denotes the offset of a given dataset.  
* [0.x.22]*
     Default constructor. This doesn't do much except generating an invalid     index, since you didn't give a valid descriptor of the cell, face, or     subface you wanted.    
* [0.x.23]*
     Static function to generate the offset of a cell. Since we only have     one cell per quadrature object, this offset is of course zero, but we     carry this function around for consistency with the other static     functions.    
* [0.x.24]*
     Static function to generate an offset object for a given face of a cell     with the given face orientation, flip and rotation. This function of     course is only allowed if <tt>dim>=2</tt>, and the face orientation,     flip and rotation are ignored if the space dimension equals 2.         The last argument denotes the number of quadrature points the lower-     dimensional face quadrature formula (the one that has been projected     onto the faces) has.        
*  [2.x.21]  This function is deprecated since it makes an implicit assumption     that the cell is a line (1D), a quad (2D), or a hex (3D). Use the other     version of this function that takes the reference cell type instead.    
* [0.x.25]*
     Static function to generate an offset object for a given face of a cell     with the given face orientation, flip and rotation. This function of     course is only allowed if <tt>dim>=2</tt>, and the face orientation,     flip and rotation are ignored if the space dimension equals 2.         The last argument denotes the number of quadrature points the lower-     dimensional face quadrature formula (the one that has been projected     onto the faces) has.    
* [0.x.26]*
     Like the above function but taking a quadrature collection, enabling     that each face might have different number of quadrature points.    
* [0.x.27]*
     Static function to generate an offset object for a given subface of a     cell with the given face orientation, flip and rotation. This function     of course is only allowed if <tt>dim>=2</tt>, and the face orientation,     flip and rotation are ignored if the space dimension equals 2.         The last but one argument denotes the number of quadrature points the     lower-dimensional face quadrature formula (the one that has been     projected onto the faces) has.         Through the last argument anisotropic refinement can be respected.        
*  [2.x.22]  This function is deprecated since it makes an implicit assumption     that the cell is a line (1D), a quad (2D), or a hex (3D). Use the other     version of this function that takes the reference cell type instead.    
* [0.x.28]*
     Static function to generate an offset object for a given subface of a     cell with the given face orientation, flip and rotation. This function     of course is only allowed if <tt>dim>=2</tt>, and the face orientation,     flip and rotation are ignored if the space dimension equals 2.         The last but one argument denotes the number of quadrature points the     lower-dimensional face quadrature formula (the one that has been     projected onto the faces) has.         Through the last argument anisotropic refinement can be respected.    
* [0.x.29]*
     Conversion operator to an integer denoting the offset of the first     element of this dataset in the set of quadrature formulas all projected     onto faces and subfaces. This conversion operator allows us to use     offset descriptor objects in place of integer offsets.    
* [0.x.30]*
     Store the integer offset for a given cell, face, or subface.    
* [0.x.31]*
     This is the real constructor, but it is private and thus only available     to the static member functions above.    
* [0.x.32]

include/deal.II-translator/base/quadrature_0.txt
[0.x.0]*
 Base class for quadrature formulae in arbitrary dimensions. This class stores quadrature points and weights on the unit line [0,1], unit square [0,1]x[0,1], etc.
*  There are a number of derived classes, denoting concrete integration formulae. Their names are prefixed by <tt>Q</tt>. Refer to the list of derived classes for more details.
*  The schemes for higher dimensions are typically tensor products of the one- dimensional formulae, but refer to the section on implementation detail below.
*  In order to allow for dimension independent programming, a quadrature formula of dimension zero exists. Since an integral over zero dimensions is the evaluation at a single point, any constructor of such a formula initializes to a single quadrature point with weight one. Access to the weight is possible, while access to the quadrature point is not permitted, since a Point of dimension zero contains no information. The main purpose of these formulae is their use in QProjector, which will create a useful formula of dimension one out of them.
*  [1.x.0]
*  For each quadrature formula we denote by <tt>m</tt>, the maximal degree of polynomials integrated exactly. This number is given in the documentation of each formula. The order of the integration error is <tt>m+1</tt>, that is, the error is the size of the cell to the <tt>m+1</tt> by the Bramble- Hilbert Lemma. The number <tt>m</tt> is to be found in the documentation of each concrete formula. For the optimal formulae QGauss we have  [2.x.0] , where N is the constructor parameter to QGauss. The tensor product formulae are exact on tensor product polynomials of degree <tt>m</tt> in each space direction, but they are still only of <tt>m+1</tt>st order.
*  [1.x.1]
*  Most integration formulae in more than one space dimension are tensor products of quadrature formulae in one space dimension, or more generally the tensor product of a formula in <tt>(dim-1)</tt> dimensions and one in one dimension. There is a special constructor to generate a quadrature formula from two others.  For example, the QGauss [2.x.1]  formulae include [1.x.2] quadrature points in <tt>dim</tt> dimensions, where N is the constructor parameter of QGauss.
* 

* 
*  [2.x.2]  Instantiations for this template are provided for dimensions 0, 1, 2, and 3 (see the section on  [2.x.3] ).

* 
* [0.x.1]*
   Define an alias for a quadrature that acts on an object of one dimension   less. For cells, this would then be a face quadrature.  
* [0.x.2]*
   Constructor.     This constructor is marked as explicit to avoid involuntary accidents   like in  [2.x.4]  where    [2.x.5]  was   meant.  
* [0.x.3]*
   Build this quadrature formula as the tensor product of a formula in a   dimension one less than the present and a formula in one dimension.   This constructor assumes (and tests) that constant functions are integrated   exactly, i.e. the sum of the quadrature weights is one.      [2.x.6]  expands to <tt>Quadrature<dim-1></tt>.  
* [0.x.4]*
   Build this quadrature formula as the <tt>dim</tt>-fold tensor product of   a formula in one dimension.     Assuming that the points in the one-dimensional rule are in ascending   order, the points of the resulting rule are ordered lexicographically   with [1.x.3] running fastest.     In order to avoid a conflict with the copy constructor in 1d, we let the   argument be a 0d quadrature formula for dim==1, and a 1d quadrature   formula for all other space dimensions.     This constructor does not require that constant functions are integrated   exactly. Therefore, it is appropriate if the one-dimensional formula   is defined with respect to a weighting function.  
* [0.x.5]*
   Copy constructor.  
* [0.x.6]*
   Move constructor. Construct a new quadrature object by transferring the   internal data of another quadrature object.  
* [0.x.7]*
   Construct a quadrature formula from given vectors of quadrature points   (which should really be in the unit cell) and the corresponding weights.   You will want to have the weights sum up to one, but this is not checked.  
* [0.x.8]*
   Construct a dummy quadrature formula from a list of points, with weights   set to infinity. The resulting object is therefore not meant to actually   perform integrations, but rather to be used with FEValues objects in   order to find the position of some points (the quadrature points in this   object) on the transformed cell in real space.  
* [0.x.9]*
   Constructor for a one-point quadrature. Sets the weight of this point to   one.  
* [0.x.10]*
   Virtual destructor.  
* [0.x.11]*
   Assignment operator. Copies contents of #weights and #quadrature_points   as well as size.  
* [0.x.12]*
   Move assignment operator. Moves all data from another quadrature object   to this object.  
* [0.x.13]*
   Test for equality of two quadratures.  
* [0.x.14]*
   Set the quadrature points and weights to the values provided in the   arguments.  
* [0.x.15]*
   Number of quadrature points.  
* [0.x.16]*
   Return the <tt>i</tt>th quadrature point.  
* [0.x.17]*
   Return a reference to the whole array of quadrature points.  
* [0.x.18]*
   Return the weight of the <tt>i</tt>th quadrature point.  
* [0.x.19]*
   Return a reference to the whole array of weights.  
* [0.x.20]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.21]*
   Write or read the data of this object to or from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.22]*
   This function returns true if the quadrature object is a tensor product   of one-dimensional formulas and the quadrature points are sorted   lexicographically.  
* [0.x.23]*
   In case the quadrature formula is a tensor product, this function   returns the  [2.x.7]  one-dimensional basis objects.   Otherwise, calling this function is not allowed.     For  [2.x.8]  equal to one, we can not return the  [2.x.9]  as a const   reference and have to return it by value. In this case, the array   will always contain a single element ( [2.x.10]     
*  [2.x.11]  The actual return type of this function is  
* [1.x.4]
*    The type is abbreviated in the online documentation to improve   readability of this page.  
* [0.x.24]*
   List of quadrature points. To be filled by the constructors of derived   classes.  
* [0.x.25]*
   List of weights of the quadrature points.  To be filled by the   constructors of derived classes.  
* [0.x.26]*
   Indicates if this object represents quadrature formula that is a tensor   product of one-dimensional formulas.   This flag is set if dim==1 or the constructors taking a Quadrature<1>   (and possibly a Quadrature<dim-1> object) is called. This implies   that the quadrature points are sorted lexicographically.  
* [0.x.27]*
   Stores the one-dimensional tensor basis objects in case this object   can be represented by a tensor product.  
* [0.x.28]*
 Quadrature formula implementing anisotropic distributions of quadrature points on the reference cell. To this end, the tensor product of <tt>dim</tt> one-dimensional quadrature formulas is generated.
* 

* 
*  [2.x.12]  Each constructor can only be used in the dimension matching the number of arguments.

* 
* [0.x.29]*
   Constructor for a one-dimensional formula. This one just copies the given   quadrature rule.  
* [0.x.30]*
   Constructor for a two-dimensional formula.  
* [0.x.31]*
   Constructor for a three-dimensional formula.  
* [0.x.32]*
 Quadrature formula constructed by iteration of another quadrature formula in each direction. In more than one space dimension, the resulting quadrature formula is constructed in the usual way by building the tensor product of the respective iterated quadrature formula in one space dimension.
*  In one space dimension, the given base formula is copied and scaled onto a given number of subintervals of length <tt>1/n_copies</tt>. If the quadrature formula uses both end points of the unit interval, then in the interior of the iterated quadrature formula there would be quadrature points which are used twice; we merge them into one with a weight which is the sum of the weights of the left- and the rightmost quadrature point.
*  Since all dimensions higher than one are built up by tensor products of one dimensional and <tt>dim-1</tt> dimensional quadrature formulae, the argument given to the constructor needs to be a quadrature formula in one space dimension, rather than in <tt>dim</tt> dimensions.
*  The aim of this class is to provide a low order formula, where the error constant can be tuned by increasing the number of quadrature points. This is useful in integrating non-differentiable functions on cells.

* 
* [0.x.33]*
   Constructor. Iterate the given quadrature formula <tt>n_copies</tt> times   in each direction.  
* [0.x.34]*
   Exception  
* [0.x.35]

include/deal.II-translator/base/quadrature_lib_0.txt
[0.x.0]*
 The Gauss-Legendre family of quadrature rules for numerical integration.
*  The coefficients of these quadrature rules are computed by the function described in [1.x.0].

* 
* [0.x.1]*
   Generate a formula with <tt>n</tt> quadrature points (in each space   direction), exact for polynomials of degree <tt>2n-1</tt>.  
* [0.x.2]*
 The Gauss-Lobatto family of quadrature rules for numerical integration.
*  This modification of the Gauss quadrature uses the two interval end points as well. Being exact for polynomials of degree [1.x.1], this formula is suboptimal by two degrees.
*  The quadrature points are interval end points plus the roots of the derivative of the Legendre polynomial [1.x.2] of degree [1.x.3]. The quadrature weights are [1.x.4].
* 

* 
*  [2.x.0]  This implementation has not been optimized concerning numerical stability and efficiency. It can be easily adapted to the general case of Gauss-Lobatto-Jacobi-Bouzitat quadrature with arbitrary parameters  [2.x.1] ,  [2.x.2] , of which the Gauss-Lobatto-Legendre quadrature ( [2.x.3] ) is a special case.
*   [2.x.4]  http://en.wikipedia.org/wiki/Handbook_of_Mathematical_Functions  [2.x.5]  Karniadakis, G.E. and Sherwin, S.J.: Spectral/hp element methods for computational fluid dynamics. Oxford: Oxford University Press, 2005

* 
* [0.x.3]*
   Generate a formula with <tt>n</tt> quadrature points (in each space   direction).  
* [0.x.4]*
 The midpoint rule for numerical quadrature. This one-point formula is exact for linear polynomials.

* 
* [0.x.5]*
 The Simpson rule for numerical quadrature. This formula with 3 quadrature points is exact for polynomials of degree 3.

* 
* [0.x.6]*
 The trapezoidal rule for numerical quadrature. This formula with two quadrature points is exact for linear polynomials and uses the end points of an interval for function evaluation in 1d, see https://en.wikipedia.org/wiki/Trapezoidal_rule . In higher dimensions, the class is constructed via a tensor product and then uses the vertices of a quadrilateral or hexahedron for function evaluation.

* 
* [0.x.7]*
 An alias for QTrapezoid available for historic reasons. This name is deprecated.
*  The class was originally named QTrapez, a poorly named choice since the proper name of the quadrature formula is "trapezoidal rule", or sometimes also called the "trapezoid rule". The misnomer resulted from the fact that its original authors' poor English language skills led them to translate the name incorrectly from the German "Trapezregel".

* 
* [0.x.8]*
 The Milne rule for numerical quadrature formula. The Milne rule is a closed Newton-Cotes formula and is exact for polynomials of degree 5.
*   [2.x.6]  Stoer: Einführung in die Numerische Mathematik I, p. 102

* 
* [0.x.9]*
 The Weddle rule for numerical quadrature. The Weddle rule is a closed Newton-Cotes formula and is exact for polynomials of degree 7.
*   [2.x.7]  Stoer: Einführung in die Numerische Mathematik I, p. 102

* 
* [0.x.10]*
 A class for Gauss quadrature with logarithmic weighting function. This formula is used to integrate  [2.x.8]  on the interval  [2.x.9] , where  [2.x.10]  is a smooth function without singularities. The collection of quadrature points and weights has been obtained using <tt>Numerical Recipes</tt>.
*  Notice that only the function  [2.x.11]  should be provided, i.e.,  [2.x.12] . Setting the  [2.x.13]  flag to true at construction time switches the weight from  [2.x.14]  to  [2.x.15] .
*  The weights and functions have been tabulated up to order 12.

* 
* [0.x.11]*
   Generate a formula with <tt>n</tt> quadrature points  
* [0.x.12]*
   Compute the points of the quadrature formula.  
* [0.x.13]*
   Compute the weights of the quadrature formula.  
* [0.x.14]*
 A class for Gauss quadrature with arbitrary logarithmic weighting function. This formula is used to integrate  [2.x.16]  on the interval  [2.x.17] , where  [2.x.18]  is a smooth function without singularities, and  [2.x.19]  and  [2.x.20]  are given at construction time, and are the location of the singularity  [2.x.21]  and an arbitrary scaling factor in the singularity.
*  You have to make sure that the point  [2.x.22]  is not one of the Gauss quadrature points of order  [2.x.23] , otherwise an exception is thrown, since the quadrature weights cannot be computed correctly.
*  This quadrature formula is rather expensive, since it uses internally two Gauss quadrature formulas of order n to integrate the nonsingular part of the factor, and two GaussLog quadrature formulas to integrate on the separate segments  [2.x.24]  and  [2.x.25] . If the singularity is one of the extremes and the factor alpha is 1, then this quadrature is the same as QGaussLog.
*  The last argument from the constructor allows you to use this quadrature rule in one of two possible ways: [1.x.5]
*  Which one of the two sets of weights is provided, can be selected by the  [2.x.26]  factor_out_singular_weight parameter. If it is false (the default), then the  [2.x.27]  weights are computed, and you should provide only the smooth function  [2.x.28] , since the singularity is included inside the quadrature. If the parameter is set to true, then the singularity is factored out of the quadrature formula, and you should provide a function  [2.x.29] , which should at least be similar to  [2.x.30] .
*  Notice that this quadrature rule is worthless if you try to use it for regular functions once you factored out the singularity.
*  The weights and functions have been tabulated up to order 12.

* 
* [0.x.15]*
   The constructor takes four arguments: the order of the Gauss formula on   each of the segments  [2.x.31]  and  [2.x.32] , the actual location of the   singularity, the scale factor inside the logarithmic function and a flag   that decides whether the singularity is left inside the quadrature   formula or it is factored out, to be included in the integrand.  
* [0.x.16]*
   Move constructor. We cannot rely on the move constructor for `Quadrature`,   since it does not know about the additional member `fraction` of this   class.  
* [0.x.17]*
   This is the length of interval  [2.x.33] , or 1 if either of the two   extremes have been selected.  
* [0.x.18]*
 A class for Gauss quadrature with  [2.x.34]  weighting function. This formula can be used to integrate  [2.x.35]  on the reference element  [2.x.36] , where  [2.x.37]  is a smooth function without singularities, and  [2.x.38]  is the distance from the point  [2.x.39]  to the vertex  [2.x.40] , given at construction time by specifying its index. Notice that this distance is evaluated in the reference element.
*  This quadrature formula is obtained from two QGauss quadrature formulas, upon transforming them into polar coordinate system centered at the singularity, and then again into another reference element. This allows for the singularity to be cancelled by part of the Jacobian of the transformation, which contains  [2.x.41] . In practice the reference element is transformed into a triangle by collapsing one of the sides adjacent to the singularity. The Jacobian of this transformation contains  [2.x.42] , which is removed before scaling the original quadrature, and this process is repeated for the next half element.
*  Upon construction it is possible to specify whether we want the singularity removed, or not. In other words, this quadrature can be used to integrate  [2.x.43] , or simply  [2.x.44] , with the  [2.x.45]  factor already included in the quadrature weights.

* 
* [0.x.19]*
   This constructor takes three arguments: the order of the Gauss formula,   the point of the reference element in which the singularity is located,   and whether we include the weighting singular function inside the   quadrature, or we leave it in the user function to be integrated.     Traditionally, quadrature formulas include their weighting function, and   the last argument is set to false by default. There are cases, however,   where this is undesirable (for example when you only know that your   singularity has the same order of 1/R, but cannot be written exactly in   this way).     In other words, you can use this function in either of the following way,   obtaining the same result:    
* [1.x.6]
*   
* [0.x.20]*
   The constructor takes three arguments: the order of the Gauss formula,   the index of the vertex where the singularity is located, and whether we   include the weighting singular function inside the quadrature, or we   leave it in the user function to be integrated. Notice that this is a   specialized version of the previous constructor which works only for the   vertices of the quadrilateral.     Traditionally, quadrature formulas include their weighting function, and   the last argument is set to false by default. There are cases, however,   where this is undesirable (for example when you only know that your   singularity has the same order of 1/R, but cannot be written exactly in   this way).     In other words, you can use this function in either of the following way,   obtaining the same result:    
* [1.x.7]
*   
* [0.x.21]*
   Given a quadrature point and a degree n, this function returns the size   of the singular quadrature rule, considering whether the point is inside   the cell, on an edge of the cell, or on a corner of the cell.  
* [0.x.22]*
 Sorted Quadrature. Given an arbitrary quadrature formula, this class generates a quadrature formula where the quadrature points are ordered according the weights, from those with smaller corresponding weight, to those with higher corresponding weights. This might be necessary, for example, when integrating high order polynomials, since in these cases you might sum very big numbers with very small numbers, and summation is not stable if the numbers to sum are not close to each other.

* 
* [0.x.23]*
   The constructor takes an arbitrary quadrature formula  [2.x.46]  and sorts   its points and weights according to ascending weights.  
* [0.x.24]*
   A rule for  [2.x.47]  to reorder pairs of points and weights.    [2.x.48]  and  [2.x.49]  are indices into the weights array and the result will   be determined by comparing the weights.  
* [0.x.25]*
 Telles quadrature of arbitrary order.
*  The coefficients of these quadrature rules are computed using a non linear change of variables starting from a Gauss-Legendre quadrature formula. This is done using a cubic polynomial,  [2.x.50]  in order to integrate a singular integral, with singularity at a given point x_0.
*  We start from a Gauss Quadrature Formula with arbitrary function. Then we apply the cubic variable change. In the paper, J.C.F.Telles:A Self-Adaptive Co-ordinate Transformation For Efficient Numerical Evaluation of General Boundary Element Integrals. International Journal for Numerical Methods in Engineering, vol 24, pages 959–973. year 1987, the author applies the transformation on the reference cell  [2.x.51]  getting

* 
* [1.x.8]
*  We get

* 
* [1.x.9]
*  with

* 
* [1.x.10]
*  Since the library assumes  [2.x.52]  as reference interval, we will map these values on the proper reference interval in the implementation.
*  This variable change can be used to integrate singular integrals. One example is  [2.x.53]  on the reference interval  [2.x.54] , where  [2.x.55]  is given at construction time, and is the location of the singularity  [2.x.56] , and  [2.x.57]  is a smooth non singular function.
*  Singular quadrature formula are rather expensive, nevertheless Telles' quadrature formula are much easier to compute with respect to other singular integration techniques as Lachat-Watson.
*  We have implemented the case for  [2.x.58] . When we deal the case  [2.x.59]  we have computed the quadrature formula has a tensorial product of one dimensional Telles' quadrature formulas considering the different components of the singularity.
*  The weights and functions for Gauss Legendre formula have been tabulated up to order 12.

* 
* [0.x.26]*
   A constructor that takes a quadrature formula and a singular point as   argument. The quadrature formula will be mapped using Telles' rule. Make   sure that the order of the quadrature rule is appropriate for the   singularity in question.  
* [0.x.27]*
   A variant of above constructor that takes as parameters the order  [2.x.60]    and location of a singularity. A Gauss Legendre quadrature of order n   will be used  
* [0.x.28]*
 Gauss-Chebyshev quadrature rules integrate the weighted product  [2.x.61]  with weight given by:  [2.x.62] . The nodes and weights are known analytically, and are exact for monomials up to the order  [2.x.63] , where  [2.x.64]  is the number of quadrature points. Here we rescale the quadrature formula so that it is defined on the interval  [2.x.65]  instead of  [2.x.66] . So the quadrature formulas integrate exactly the integral  [2.x.67]  with the weight:  [2.x.68] . For details see: M. Abramowitz & I.A. Stegun: Handbook of Mathematical Functions, par. 25.4.38

* 
* [0.x.29]*
 Gauss-Radau-Chebyshev quadrature rules integrate the weighted product  [2.x.69]  with weight given by:  [2.x.70]  with the additional constraint that a quadrature point lies at one of the two extrema of the interval. The nodes and weights are known analytically, and are exact for monomials up to the order  [2.x.71] , where  [2.x.72]  is the number of quadrature points. Here we rescale the quadrature formula so that it is defined on the interval  [2.x.73]  instead of  [2.x.74] . So the quadrature formulas integrate exactly the integral  [2.x.75]  with the weight:  [2.x.76] . By default the quadrature is constructed with the left endpoint as quadrature node, but the quadrature node can be imposed at the right endpoint through the variable ep that can assume the values left or right.

* 
* [0.x.30] EndPoint is used to specify which of the two endpoints of the unit interval   is used also as quadrature point  
* [0.x.31]*
     Left end point.    
* [0.x.32]*
     Right end point.    
* [0.x.33]*
   Move constructor. We cannot rely on the move constructor for `Quadrature`,   since it does not know about the additional member `ep` of this class.  
* [0.x.34]*
 Gauss-Lobatto-Chebyshev quadrature rules integrate the weighted product  [2.x.77]  with weight given by:  [2.x.78] , with the additional constraint that two of the quadrature points are located at the endpoints of the quadrature interval. The nodes and weights are known analytically, and are exact for monomials up to the order  [2.x.79] , where  [2.x.80]  is the number of quadrature points. Here we rescale the quadrature formula so that it is defined on the interval  [2.x.81]  instead of  [2.x.82] . So the quadrature formulas integrate exactly the integral  [2.x.83]  with the weight:  [2.x.84] . For details see: M. Abramowitz & I.A. Stegun: Handbook of Mathematical Functions, par. 25.4.40

* 
* [0.x.35]*
 Given an arbitrary quadrature formula, return one that chops the quadrature points above the hyper-plane defined by  [2.x.85] . In other words, it extracts those quadrature points from the base formula that satisfy  [2.x.86] ."
*  In general the resulting quadrature is not very useful, unless the quadrature you started from has been constructed specifically to integrate over triangles or tetrahedra. This class only ensures that the resulting quadrature formula only has quadrature points in the reference simplex or on its boundary.
*  No transformation is applied to the weights, and the weights referring to points that live outside the reference simplex are simply discarded.
*  The main use of this quadrature formula is not to chop tensor product quadratures. Ideally you should pass to this class a quadrature formula constructed directly using points and weights in the reference simplex, capable of integrating on triangles or tetrahedra.
*  For finite elements based on quadrilaterals and hexahedra, a QSimplex quadrature formula is not very useful on its own. This class is typically used in conjunction with other classes, like QSplit, to patch the reference element using several QSimplex quadrature formulas.
*  Such quadrature formulas are useful to integrate functions with singularities at certain points, or functions that present jumps along a co-dimension one surface inside the reference element, like in the extended finite element method (XFEM).

* 
* [0.x.36]*
   Construct a quadrature that only contains the points that are in the lower   left reference simplex.      [2.x.87]  quad The input quadrature.  
* [0.x.37]*
   Return an affine transformation of this quadrature, that can be used to   integrate on the simplex identified by `vertices`.     Both the quadrature point locations and the weights are transformed, so   that you can effectively use the resulting quadrature to integrate on the   simplex.     The transformation is defined as   [1.x.11]   where the matrix  [2.x.88]  is given by  [2.x.89] .     The weights are scaled with the absolute value of the determinant of  [2.x.90] ,   that is  [2.x.91] . If  [2.x.92]  is zero, an empty   quadrature is returned. This may happen, in two dimensions, if the three   vertices are aligned, or in three dimensions if the four vertices are on   the same plane.      [2.x.93]  vertices The vertices of the simplex you wish to integrate on    [2.x.94]  A quadrature object that can be used to integrate on the simplex  
* [0.x.38]*
 A quadrature that implements a polar transformation from a square to a triangle to integrate singularities in the origin of the reference simplex. The quadrature is obtained through the following polar transformation:
*  [1.x.12]

* 
* [0.x.39]*
   Construct a QTrianglePolar quadrature, with different formulas in the   radial and angular directions.      [2.x.95]  radial_quadrature Radial quadrature    [2.x.96]  angular_quadrature Angular quadrature  
* [0.x.40]*
   Call the other constructor, with QGauss<1>(n) for both radial and   angular quadrature.      [2.x.97]  n Order of QGauss quadrature  
* [0.x.41]*
 A quadrature that implements the Duffy transformation from a square to a triangle to integrate singularities in the origin of the reference simplex.
*  The Duffy transformation is defined as [1.x.13]
*  with determinant of the Jacobian equal to  [2.x.98] . Such transformation maps the reference square  [2.x.99]  to the reference simplex, by collapsing the left side of the square and squeezing quadrature points towards the origin, and then shearing the resulting triangle to the reference one. This transformation shows good convergence properties when  [2.x.100]  with singularities of order  [2.x.101]  in the origin, but different  [2.x.102]  values can be selected to increase convergence and/or accuracy when higher order Gauss rules are used (see "Generalized Duffy transformation for integrating vertex singularities", S. E. Mousavi, N. Sukumar, Computational Mechanics 2009).
*  When  [2.x.103] , this transformation is also known as the Lachat-Watson transformation.

* 
* [0.x.42]*
   Constructor that allows the specification of different quadrature rules   along the "radial" and "angular" directions.     Since this quadrature is not based on a Polar change of coordinates, it   is not fully proper to talk about radial and angular directions. However,   the effect of the Duffy transformation is similar to a polar change   of coordinates, since the resulting quadrature points are aligned radially   with respect to the singularity.      [2.x.104]  radial_quadrature Base quadrature to use in the radial direction    [2.x.105]  angular_quadrature Base quadrature to use in the angular direction    [2.x.106]  beta Exponent used in the transformation  
* [0.x.43]*
   Call the above constructor with QGauss<1>(n) quadrature formulas for   both the radial and angular quadratures.      [2.x.107]  n Order of QGauss quadrature    [2.x.108]  beta Exponent used in the transformation  
* [0.x.44]*
 A quadrature to use when the cell should be split into subregions to integrate using one or more base quadratures.

* 
* [0.x.45]*
   Construct a quadrature formula by splitting the reference hyper cube into   the minimum number of simplices that have vertex zero coinciding with    [2.x.109]  and patch together affine transformations of the  [2.x.110]    quadrature. The point  [2.x.111]  should be in the reference element,   and an exception is thrown if this is not the case.     In two dimensions, the resulting quadrature formula will be composed of   two, three, or four triangular quadrature formulas if  [2.x.112]    coincides with one of the vertices, if it lies on one of the edges, or if   it is internal to the reference element respectively.     The same is true for the three dimensional case, with six, eight, ten, or   twelve tetrahedral quadrature formulas if  [2.x.113]  coincides with one   of the vertices, if it lies on one of the edges, on one of the faces, or   if it is internal to the reference element respectively.     The resulting quadrature can be used, for example, to integrate functions   with integrable singularities at the split point, provided that you select   as base quadrature one that can integrate singular points on vertex zero   of the reference simplex.     An example usage in dimension two is given by:  
* [1.x.14]
*      The resulting quadrature will look like the following:    [2.x.114]       [2.x.115]  base Base QSimplex quadrature to use    [2.x.116]  split_point Where to split the hyper cube  
* [0.x.46]*
 Integration rule for simplex entities.
*  Users specify a number `n_points_1D` as an indication of what polynomial degree to be integrated exactly, similarly to the number of points in a QGauss quadrature object, even though the present quadrature formula is not a tensor product. The given value is translated for n_points_1D=1,2,3,4 to following number of quadrature points for 2D and 3D:
* 

* 
* 

* 
* 

* 
* 
*  - 2D: 1, 3, 7, 15
* 

* 
* 

* 
* 

* 
* 
*  - 3D: 1, 4, 10, 35
*  For 1D, the quadrature rule degenerates to a  [2.x.117] 
* 

* 
*  [2.x.118] 

* 
* [0.x.47]*
   Constructor taking the number of quadrature points in 1D direction    [2.x.119]   
* [0.x.48]*
 Witherden-Vincent rules for simplex entities.
*  Like QGauss, users should specify a number `n_points_1D` as an indication of what polynomial degree to be integrated exactly (e.g., for  [2.x.120]  points, the rule can integrate polynomials of degree  [2.x.121]  exactly). The given value for n_points_1D = 1, 2, 3, 4, 5 results in the following number of quadrature points in 2D and 3D:
* 

* 
* 
*  - 2D: 1, 6, 7, 15, 19
* 

* 
* 
*  - 3D: 1, 8, 14, 35, 59
*  For 1D, the quadrature rule degenerates to a  [2.x.122] 
*  These rules match the ones listed for Witherden-Vincent in the quadpy  [2.x.123]  library and were first described in  [2.x.124] .
* 

* 
*  [2.x.125] 

* 
* [0.x.49]*
   Constructor taking the number of quadrature points in 1D direction    [2.x.126]   
* [0.x.50]*
 Integration rule for wedge entities.

* 
* [0.x.51]*
   Users specify a number `n_points_1D` as an indication of what polynomial   degree to be integrated exactly. For details, see the comments of   QGaussSimplex.  
* [0.x.52]*
 Integration rule for pyramid entities.

* 
* [0.x.53]*
   Users specify a number `n_points_1D` as an indication of what polynomial   degree to be integrated exactly. For details, see the comments of   QGaussSimplex.  
* [0.x.54]

include/deal.II-translator/base/quadrature_point_data_0.txt
[0.x.0]*
 A class for storing at each cell represented by iterators of type  [2.x.0]  a vector of data  [2.x.1]  . The underlying structure and the initialize() method of this class are designed in such a way that one could use different child classes derived from the base DataType class to store data on a given cell. This implies the usage of pointers, in our case
* 
*  -   [2.x.2] 
*  The type  [2.x.3]  is arbitrary, but when using a class derived from TransferableQuadraturePointData one can use the facilities of  [2.x.4] 
* 

* 
*  [2.x.5]  The data type stored on each cell can be different. However, within the cell this class stores a vector of objects of a single data type. For this reason, this class may not be sufficiently flexible when, for example, adopting a level-set approach to describe material behavior.

* 
* [0.x.1]*
   Default constructor.  
* [0.x.2]*
   Default destructor.  
* [0.x.3]*
   Initialize data on the  [2.x.6]  to store  [2.x.7]  of objects of type  [2.x.8]  .   The typename  [2.x.9]  is possibly another class which is derived from the   base  [2.x.10]  class. In order to initialize the vector of objects   we have to assume that the class  [2.x.11]  has a default constructor.   This function has to be called on every cell where data is to be stored.     After the data is initialized, it can be modified using the get_data()   function.    
*  [2.x.12]  Subsequent calls of this function with the same  [2.x.13]  will not   alter the objects associated with it. In order to remove the stored data,   use the erase() function.    
*  [2.x.14]  It is possible to use different types  [2.x.15]  for different cells which   may reflect, for example, different constitutive models of continuum   mechanics in different parts of the domain.    
*  [2.x.16]  The first time this method is called, it stores a SmartPointer to the   Triangulation object that owns the cell. The future invocations of this   method expects the cell to be from the same stored triangulation.      [2.x.17]  The type  [2.x.18]  needs to either equal  [2.x.19]  or be a class derived   from  [2.x.20]   [2.x.21]  needs to be default constructible.  
* [0.x.4]*
   Same as above but for a range of iterators starting at  [2.x.22]    until, but not including,  [2.x.23]  for all locally owned cells, i.e.   for which `cell->is_locally_owned()==true` .  
* [0.x.5]*
   Removes data stored at the  [2.x.24]  Returns true if the data was removed.   If no data is attached to the  [2.x.25]  this function will not do anything   and returns false.    
*  [2.x.26]  This function will also check that there are no   outstanding references to the data stored on this cell. That is to say,   that the only references to the stored data are that made by this class.  
* [0.x.6]*
   Clear all the data stored in this object.  
* [0.x.7]*
   Get a vector of the data located at  [2.x.27]  .   A possible additional typename  [2.x.28]  is the class to which the base class   DataType could be cast. Since  [2.x.29]  is stored as shared pointers,   there is minimal overhead in returning a vector by value instead of by   reference.   This allows flexibility if class  [2.x.30]  is not the same as  [2.x.31]  on a   cell-by-cell basis.      [2.x.32]  The type  [2.x.33]  needs to match the class provided to initialize() .      [2.x.34]   [2.x.35]  must be from the same Triangulation that is used to   initialize() the cell data.  
* [0.x.8]*
   Get a vector of constant pointers to data located at  [2.x.36]  .   A possible additional typename  [2.x.37]  is the class to which the base class   DataType could be cast. Since  [2.x.38]  is stored as shared pointers,   there is minimal overhead in returning a vector by value instead of by   reference.   This allows flexibility if class  [2.x.39]  is not the same as  [2.x.40]  on a   cell-by-cell basis.      [2.x.41]  The type  [2.x.42]  needs to match the class provided to initialize() .      [2.x.43]   [2.x.44]  must be from the same Triangulation that is used to   initialize() the cell data.  
* [0.x.9]*
   Returns a  [2.x.45]  indicating whether  [2.x.46]  contains an   associated data or not. If data is available, dereferencing the    [2.x.47]  reveals a vector of pointers to the underlying data   at the quadrature points.   A possible additional typename  [2.x.48]  is the class to which the base class   DataType could be cast. Since  [2.x.49]  is stored as shared pointers,   there is minimal overhead in returning a vector by value instead of by   reference.   This allows flexibility if class  [2.x.50]  is not the same as  [2.x.51]  on a   cell-by-cell basis.      [2.x.52]  The type  [2.x.53]  needs to match the class provided to initialize().    [2.x.54]   [2.x.55]  must be from the same Triangulation that is used to   initialize() the cell data.  
* [0.x.10]*
   Returns a  [2.x.56]  indicating whether  [2.x.57]  contains an   associated data or not. If data is available, dereferencing the    [2.x.58]  reveals a vector of constant pointers to the   underlying data at the quadrature points.   A possible additional typename  [2.x.59]  is the class to which the base class   DataType could be cast. Since  [2.x.60]  is stored as shared pointers,   there is minimal overhead in returning a vector by value instead of by   reference.   This allows flexibility if class  [2.x.61]  is not the same as  [2.x.62]  on a   cell-by-cell basis.      [2.x.63]  The type  [2.x.64]  needs to match the class provided to initialize().    [2.x.65]   [2.x.66]  must be from the same Triangulation that is used to   initialize() the cell data.  
* [0.x.11]*
   Number of dimensions  
* [0.x.12]*
   Number of space dimensions  
* [0.x.13]*
   To ensure that all the cells in the CellDataStorage come from the same   Triangulation, we need to store a reference to that Triangulation within   the class.  
* [0.x.14]*
   A map to store a vector of data on each cell.   We need to use CellId as the key because it remains unique during   adaptive refinement.  
* [0.x.15]*
    [2.x.67]  Exceptions  
* [0.x.16]*
    [2.x.68]  Exceptions  
* [0.x.17]*
 An abstract class which specifies requirements for data on a single quadrature point to be transferable during refinement or repartitioning.
*  This class provides a framework by which derived classes representing data at quadrature points can declare how many scalar values they store, and then implement functions that pack and unpack these scalars into arrays. These arrays are used to transfer data from quadrature points of one cell to quadrature points of another cell as well as between processors upon mesh refinement and repartitioning. The transfer of quadrature point data between parent and child cells requires some kind of projection and/or interpolation. One possible implementation is via the L2 projection and prolongation matrices as implemented in  [2.x.69]  class.
*  To store and access instances of classes derived from this class, see the CellDataStorage class.

* 
* [0.x.18]*
   Default constructor.  
* [0.x.19]*
   Default virtual destructor.  
* [0.x.20]*
   Return the total number of values which will be   packed/unpacked from the user's DataType class. Consequently it is also   the size of the vectors in pack_values() and unpack_values() .  
* [0.x.21]*
   A virtual function that have to be implemented in derived classes to   pack all data stored in the derived class into a vector  [2.x.70]  .   This vector will contain all scalar and/or Tensorial data local to each   quadrature point.    
*  [2.x.71]   The function will be called with  [2.x.72]  of size number_of_values().   The implementation may still have an assert to check that it is indeed the   case.  
* [0.x.22]*
   The opposite of the above, namely   unpack a vector  [2.x.73]  into the data stored in this class.    
*  [2.x.74]   The function will be called with  [2.x.75]  of size number_of_values().   The implementation may still have an assert to check that it is indeed the   case.  
* [0.x.23]*
     A class for the transfer of continuous data stored at quadrature points     when performing h-adaptive refinement of      [2.x.76]  .         [1.x.0]         This class implements the transfer of the quadrature point data between     cells in case of adaptive refinement using L2 projection. That also     includes automatic shipping of information between different processors.         To that end, the constructor of the class is provided with three main     objects:     scalar FiniteElement  [2.x.77]   [2.x.78]  and  [2.x.79]      Quadrature rules.     First, the data located at  [2.x.80]  of each cell is L2-projected     to the continuous space defined by a single FiniteElement  [2.x.81]  .     This is achieved using      [2.x.82]  In  doing so     the mass matrix of this element is required, which will be calculated     with the  [2.x.83]  rule . Should the cell now belong to another processor,     the data is then sent to this processor. The class makes use of a feature     of p4est (and  [2.x.84]  that allows one to     attach information to cells during mesh refinement and rebalancing. On     receiving information on the target cell, the data is projected back to     the quadrature points using the matrix calculated by      [2.x.85]  .     In the case that local refinement is performed, this class first     project local DoF values of the parent element to each child.             This class is templated by  [2.x.86]  type, however the user's  [2.x.87]  class     has to be derived from the TransferableQuadraturePointData class. In     practice that amounts to implementing the following three functions shown     below for a quadrature point data with 2 scalars:    
* [1.x.1]
*      Note that the order of packing and unpacking has to be the same.         This class can then be use with CellDataStorage in the following way:    
* [1.x.2]
*      This approach can be extended to quadrature point data with Tensor     objects of arbitrary order, although with a little bit more work in     packing and unpacking of data inside MyQData class.        
*  [2.x.88]  Currently coarsening is not supported.        
*  [2.x.89]  The functionality provided by this class can alternatively be achieved     using  [2.x.90]  However, that would     require the following steps: (i) create an auxiliary DoFHandler with a     (discontinuous Galerkin) FiniteElement which has enough components to     represent all data stored at the quadrature points; (ii) project the data     to the FiniteElement space and thereby store results in global vectors;     (iii) use  [2.x.91]  to project FE vectors     to the new mesh; and (iv) finally project the data back to the quadrature     points on the new mesh via FEValues class. The     ContinuousQuadratureDataTransfer class aims at simplifying the whole     process by only requiring that the quadrature point data class is derived     from the TransferableQuadraturePointData. Everything else will be done     automatically.        
*  [2.x.92]  This class is not well suited to situations where the values stored     at quadrature points represent samples from a discontinuous field. An     example for such a situation would be where the data stored at the     quadrature points represents the elastic or plastic state of a material,     i.e., a property that varies discontinuously within a solid. In such     cases, trying to transfer data from the quadrature points to a finite     element field that is continuous (at least within one cell) will likely     yield over and undershoots that, once evaluated at a different set of     quadrature points (on child or parent cells) results in values that will     not make much sense.    
* [0.x.24]*
       An alias for a cell.      
* [0.x.25]*
       Constructor which takes the FiniteElement  [2.x.93]  , the quadrature       rule  [2.x.94]  used to integrate its local mass matrix and       finally the quadrature rule  [2.x.95]  which is used to store  [2.x.96]               [2.x.97]   [2.x.98]  has to be scalar-valued.            
*  [2.x.99]  Since this class does projection on cell-by-cell basis,        [2.x.100]  is only required to be continuous within the cell.      
* [0.x.26]*
       Prepare for coarsening and refinement of a triangulation  [2.x.101]  .        [2.x.102]  represents the cell data which should be transferred       and it should be initialized for each locally owned active cell.            
*  [2.x.103]  Although CellDataStorage class allows storing on different cells       different objects derived from the base class, here we assume that        [2.x.104]  contains objects of the same type, more specifically       they pack/unpack the same data.      
* [0.x.27]*
       Interpolate the data previously stored in this object before the mesh       was refined or coarsened onto the quadrature points of the currently       active set of cells.            
*  [2.x.105]  Before calling this function the user is expected to populate the       data stored in the  [2.x.106]  object provided to prepare_for_coarsening_and_refinement()       at new cells using  [2.x.107]  If that is not the       case, an exception will be thrown in debug mode.      
* [0.x.28]*
       A callback function used to pack the data on the current mesh into       objects that can later be retrieved after refinement, coarsening and       repartitioning.      
* [0.x.29]*
       A callback function used to unpack the data on the current mesh that       has been packed up previously on the mesh before refinement,       coarsening and repartitioning.      
* [0.x.30]*
       FiniteElement used to project data from and to quadrature points.      
* [0.x.31]*
       The size of the data that will be sent, which depends on the DataType       class.      
* [0.x.32]*
       Number of quadrature points at which DataType is stored.      
* [0.x.33]*
       Projection matrix from the quadrature points to local DoFs for a single       scalar.      
* [0.x.34]*
       Projection matrix from the local DoFs to quadrature points for a single       scalar.      
* [0.x.35]*
       Auxiliary matrix which represents projection of each internal value       stored       at the quadrature point (second index) to the local DoFs of the  [2.x.108]        (first index).      
* [0.x.36]*
       Projection of  [2.x.109]  to each child cell in case of adaptive refinement.      
* [0.x.37]*
       Auxiliary matrix which represents data (second index) stored at each       quadrature point (first index).      
* [0.x.38]*
       The handle that the  [2.x.110]  has assigned       to this object while registering the pack_callback function.      
* [0.x.39]*
       A pointer to the CellDataStorage class whose data will be transferred.      
* [0.x.40]*
       A pointer to the distributed triangulation to which cell data is       attached.      
* [0.x.41] Pack cell data of type  [2.x.111]  stored using  [2.x.112]  in  [2.x.113]  at each quadrature point to  [2.x.114]  Here  [2.x.115]  is a matrix whose first index corresponds to different quadrature points on the cell whereas the second index represents different values stored at each quadrature point in the DataType class.

* 
* [0.x.42] the opposite of the pack function above.

* 
* [0.x.43]

include/deal.II-translator/base/quadrature_selector_0.txt
[0.x.0]*
 This class implements the quadrature rule passed to its constructor as a string. Supported quadratures are QGauss (of all orders), QMidpoint, QMilne, QSimpson, QTrapezoid and QWeddle.
*  This class is useful if you want to use flexible quadrature rules, that are read from a parameter file (see ParameterHandler for this).
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Constructor. Takes the name of the quadrature rule (one of "gauss",   "milne", "weddle", etc) and, if it is "gauss", the number of quadrature   points in each coordinate direction.  
* [0.x.2]*
   This function returns all possible names for quadratures as a list   separated by <tt>|</tt>, so that you can use it for the definition of   parameter files (see ParameterHandler for details).  
* [0.x.3]*
    [2.x.1]  Exceptions    [2.x.2]   
* [0.x.4]*
   Exception  
* [0.x.5]*
   Exception  
* [0.x.6]*
   Exception  
* [0.x.7]*
   This static function creates a quadrature object according to the name   given as a string, and the appropriate order (if the name is "gauss"). It   is called from the constructor.  
* [0.x.8]

include/deal.II-translator/base/sacado_product_type_0.txt
[0.x.0]

include/deal.II-translator/base/scalar_polynomials_base_0.txt
[0.x.0]*
 This class provides a framework for the finite element polynomial classes for use with finite element classes that are derived from FE_Poly. An object of this type (or rather of a type derived from this class) is stored as a member variable in each object of type FE_Poly.
*  [1.x.0]
*  Any derived class must provide the most basic properties for shape functions evaluated on the reference cell. This includes, but is not limited to, implementing the evaluate(), name(), and clone() member functions. These functions are necessary to store the most basic information of how the polynomials in the derived class evaluate at a given point on the reference cell. More information on each function can be found in the corresponding function's documentation.
*  Some classes that derive from this class include  [2.x.0]     [2.x.1]  <tt>PolynomialsAdini</tt>    [2.x.2]  <tt>PolynomialsRannacherTurek</tt>    [2.x.3]  <tt>PolynomialsP</tt>    [2.x.4]  <tt>PolynomialSpace</tt>    [2.x.5]  <tt>TensorProductPolynomials</tt>    [2.x.6]  <tt>TensorProductPolynomialsConst</tt>    [2.x.7]  <tt>TensorProductPolynomialsBubbles</tt>  [2.x.8] 
* 

* 
*  [2.x.9] 

* 
* [0.x.1]*
   Constructor. This takes the degree of the space,  [2.x.10]  from the finite element   class, and  [2.x.11]  the number of polynomials for the space.  
* [0.x.2]*
   Move constructor.  
* [0.x.3]*
   Copy constructor.  
* [0.x.4]*
   Virtual destructor. Makes sure that pointers to this class are deleted   properly.  
* [0.x.5]*
   Compute the value and the derivatives of the polynomials at    [2.x.12]      The size of the vectors must either be zero or equal <tt>n()</tt>.  In   the first case, the function will not compute these values.     If you need values or derivatives of all polynomials then use this   function, rather than using any of the <tt>compute_value</tt>,   <tt>compute_grad</tt> or <tt>compute_grad_grad</tt> functions, see below,   in a loop over all tensor product polynomials.  
* [0.x.6]*
   Compute the value of the <tt>i</tt>th polynomial at unit point   <tt>p</tt>.     Consider using evaluate() instead.  
* [0.x.7]*
   Compute the <tt>order</tt>th derivative of the <tt>i</tt>th polynomial   at unit point <tt>p</tt>.     Consider using evaluate() instead.      [2.x.13]  order The order of the derivative.  
* [0.x.8]*
   Compute the first derivative of the <tt>i</tt>th polynomial   at unit point <tt>p</tt>.     Consider using evaluate() instead.  
* [0.x.9]*
   Compute the second derivative of the <tt>i</tt>th polynomial   at unit point <tt>p</tt>.     Consider using evaluate() instead.  
* [0.x.10]*
   Compute the third derivative of the <tt>i</tt>th polynomial   at unit point <tt>p</tt>.     Consider using evaluate() instead.  
* [0.x.11]*
   Compute the fourth derivative of the <tt>i</tt>th polynomial   at unit point <tt>p</tt>.     Consider using evaluate() instead.  
* [0.x.12]*
   Compute the gradient of the <tt>i</tt>th polynomial at unit point   <tt>p</tt>.     Consider using evaluate() instead.  
* [0.x.13]*
   Compute the second derivative (grad_grad) of the <tt>i</tt>th polynomial   at unit point <tt>p</tt>.     Consider using evaluate() instead.  
* [0.x.14]*
   Return the number of polynomials.  
* [0.x.15]*
   Return the highest polynomial degree of polynomials represented by this   class. A derived class may override this if its value is different from    [2.x.14]   
* [0.x.16]*
   A sort of virtual copy constructor, this function returns a copy of   the polynomial space object. Derived classes need to override the function   here in this base class and return an object of the same type as the   derived class.     Some places in the library, for example the constructors of FE_Poly,   need to make copies of polynomial spaces without knowing their exact type.   They do so through this function.  
* [0.x.17]*
   Return the name of the space.  
* [0.x.18]*
   Return an estimate (in bytes) for the memory consumption of this object.  
* [0.x.19]*
   The highest polynomial degree of this functions represented by this object.  
* [0.x.20]*
   The number of polynomials represented by this object.  
* [0.x.21]

include/deal.II-translator/base/signaling_nan_0.txt
[0.x.0]*
     A namespace for the implementation of functions that create signaling     NaN objects. This is where the  [2.x.0]  function     calls into.    
* [0.x.1]*
       A general template for classes that know how to initialize objects of       type  [2.x.1]  with signaling NaNs to denote invalid values.             The real implementation of this class happens in (partial)       specializations for particular values of the template argument  [2.x.2]       
* [0.x.2]*
       A specialization of the general NaNInitializer class that provides a       function that returns a  [2.x.3]  value equal to the invalid signaling       NaN.      
* [0.x.3]*
       A specialization of the general NaNInitializer class that provides a       function that returns a  [2.x.4]  value equal to the invalid       signaling NaN.      
* [0.x.4]*
       A specialization of the general NaNInitializer class that provides a       function that returns a Tensor<1,dim> value whose components are       invalid signaling NaN values.      
* [0.x.5]*
       A specialization of the general NaNInitializer class that provides a       function that returns a Tensor<rank,dim> value whose components are       invalid signaling NaN values.      
* [0.x.6]*
       A specialization of the general NaNInitializer class that provides a       function that returns a Tensor<rank,dim> value whose components are       invalid signaling NaN values.      
* [0.x.7]*
       A specialization of the general NaNInitializer class that provides a       function that returns a SymmetricTensor<rank,dim> value whose       components are invalid signaling NaN values.      
* [0.x.8]*
       A specialization of the general NaNInitializer class that provides a       function that returns a DerivativeForm<order,dim,spacedim> value       whose components are invalid signaling NaN values.      
* [0.x.9]*
   Provide an object of type  [2.x.5]  filled with a signaling NaN that will   cause an exception when used in a computation. The content of these   objects is a "signaling NaN" ("NaN" stands for "not a number", and   "signaling" implies that at least on platforms where this is supported,   any arithmetic operation using them terminates the program). The purpose   of such objects is to use them as markers for invalid objects and   arrays that are required to be initialized to valid values at some point,   and to trigger an error when this later initialization does not happen   before the first use. An example is code such as this:  
* [1.x.0]
*    The bug is that the `else` branch forgot to write a value into the `x`   variable. If your platform supports signaling NaNs, then this mistake   will become apparent in the last line above because the program is   going to be terminated by a floating point exception: The processor   realizes that the code is attempting to do an operation on the signaling   NaN still stored in `x` and aborts the program, thereby facilitating   an easy way to find what the problem is. This would not have been an easy   bug to find if one had just initialized `x` to zero in the first line   (or just left it uninitialized altogether): In that case, the call to    [2.x.6]  in the last line would have simply computed the sine of   "something" if `some condition == false`, but this invalid results may   not have been obvious to the calling site and would have required   a substantial amount of debugging to uncover because downstream   computations would simply have been wrong, without any indication of  why* they are wrong.      [2.x.7]  T The type of the returned invalid object. This type can either   be a scalar, or of type Tensor, SymmetricTensor, or DerivativeForm. Other   types may be supported if there is a corresponding specialization of the    [2.x.8]  class for this type.    
*  [2.x.9]  Because the type  [2.x.10]  is not used as a function argument, the   compiler cannot deduce it from the type of arguments. Consequently, you   have to provide it explicitly. For example, the line    
* [1.x.1]
*    initializes a tensor with invalid values.  
* [0.x.10]

include/deal.II-translator/base/smartpointer_0.txt
[0.x.0]*
 Smart pointers avoid using dangling pointers. They can be used just like a pointer (i.e. using the <tt>*</tt> and <tt>-></tt> operators and through casting) but make sure that the object pointed to is not deleted or moved from in the course of use of the pointer by signaling the pointee its use.
*  Objects pointed to, i.e. the class T, should inherit Subscriptor or must implement the same functionality. Null pointers are an exception from this rule and are allowed, too.
*  The second template argument P only serves a single purpose: if a constructor without a debug string is used, then the name of P is used as the debug string.
*  SmartPointer does NOT implement any memory handling! Especially, deleting a SmartPointer does not delete the object. Writing

* 
* [1.x.0]
*  is a sure way to program a memory leak! The secure version is

* 
* [1.x.1]
* 
*  Note that a smart pointer can handle <tt>const</tt>ness of an object, i.e. a <tt>SmartPointer<const ABC></tt> really behaves as if it were a pointer to a constant object (disallowing write access when dereferenced), while <tt>SmartPointer<ABC></tt> is a mutable pointer.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Standard constructor for null pointer. The id of this pointer is set to   the name of the class P.  
* [0.x.2]*
   Copy constructor for SmartPointer. We do not copy the object subscribed   to from <tt>tt</tt>, but subscribe ourselves to it again.  
* [0.x.3]*
   Copy constructor for SmartPointer. We do not copy the object subscribed   to from <tt>tt</tt>, but subscribe ourselves to it again.  
* [0.x.4]*
   Constructor taking a normal pointer. If possible, i.e. if the pointer is   not a null pointer, the constructor subscribes to the given object to   lock it, i.e. to prevent its destruction before the end of its use.     The <tt>id</tt> is used in the call to  [2.x.1]  and by   ~SmartPointer() in the call to  [2.x.2]   
* [0.x.5]*
   Constructor taking a normal pointer. If possible, i.e. if the pointer is   not a null pointer, the constructor subscribes to the given object to   lock it, i.e. to prevent its destruction before the end of its use. The   id of this pointer is set to the name of the class P.  
* [0.x.6]*
   Destructor, removing the subscription.  
* [0.x.7]*
   Assignment operator for normal pointers. The pointer subscribes to the   new object automatically and unsubscribes to an old one if it exists. It   will not try to subscribe to a null-pointer, but still delete the old   subscription.  
* [0.x.8]*
   Assignment operator for SmartPointer. The pointer subscribes to the new   object automatically and unsubscribes to an old one if it exists.  
* [0.x.9]*
   Assignment operator for SmartPointer. The pointer subscribes to the new   object automatically and unsubscribes to an old one if it exists.  
* [0.x.10]*
   Delete the object pointed to and set the pointer to zero.  
* [0.x.11]*
   Conversion to normal pointer.  
* [0.x.12]*
   Dereferencing operator. This operator throws an ExcNotInitialized() if the   pointer is a null pointer.  
* [0.x.13]*
   Dereferencing operator. This operator throws an ExcNotInitializedi() if the   pointer is a null pointer.  
* [0.x.14]*
   Exchange the pointers of this object and the argument. Since both the   objects to which is pointed are subscribed to before and after, we do not   have to change their subscription counters.     Note that this function (with two arguments) and the respective functions   where one of the arguments is a pointer and the other one is a C-style   pointer are implemented in global namespace.  
* [0.x.15]*
   Swap pointers between this object and the pointer given. As this releases   the object pointed to presently, we reduce its subscription count by one,   and increase it at the object which we will point to in the future.     Note that we indeed need a reference of a pointer, as we want to change   the pointer variable which we are given.  
* [0.x.16]*
   Return an estimate of the amount of memory (in bytes) used by this class.   Note in particular, that this only includes the amount of memory used by   [1.x.2] object, not by the object pointed to.  
* [0.x.17]*
   Pointer to the object we want to subscribe to. Since it is often   necessary to follow this pointer when debugging, we have deliberately   chosen a short name.  
* [0.x.18]*
   The identification for the subscriptor.  
* [0.x.19]*
   The Smartpointer is invalidated when the object pointed to is destroyed   or moved from.  
* [0.x.20]*
 Global function to swap the contents of two smart pointers. As both objects to which the pointers point retain to be subscribed to, we do not have to change their subscription count.

* 
* [0.x.21]*
 Global function to swap the contents of a smart pointer and a C-style pointer.
*  Note that we indeed need a reference of a pointer, as we want to change the pointer variable which we are given.

* 
* [0.x.22]*
 Global function to swap the contents of a C-style pointer and a smart pointer.
*  Note that we indeed need a reference of a pointer, as we want to change the pointer variable which we are given.

* 
* [0.x.23]

include/deal.II-translator/base/subscriptor_0.txt
[0.x.0]*
 Handling of subscriptions.
*  This class, as a base class, allows to keep track of other objects using a specific object. It is used to avoid that pointers that point to an object of a class derived from Subscriptor are referenced after that object has been invalidated. Here, invalidation is assumend to happen when the object is moved from or destroyed. The mechanism works as follows: The member function subscribe() accepts a pointer to a boolean that is modified on invalidation. The object that owns this pointer (usually an object of class type SmartPointer) is then expected to check the state of the boolean before trying to access this class.
*  The utility of this class is even enhanced by providing identifying strings to the functions subscribe() and unsubscribe(). These strings are represented as  [2.x.0]  pointers since the underlying buffer comes from (and is managed by) the run-time type information system: more exactly, these pointers are the result the function call  [2.x.1]  where  [2.x.2]  is some object. Therefore, the pointers provided to subscribe() and to unsubscribe() must be the same. Strings with equal contents will not be recognized to be the same. The handling in SmartPointer will take care of this. The current subscribers to this class can be obtained by calling list_subscribers().
* 

* 
*  [2.x.3] 

* 
* [0.x.1]*
   Constructor setting the counter to zero.  
* [0.x.2]*
   Copy-constructor.     The counter of the copy is zero, since references point to the original   object.  
* [0.x.3]*
   Move constructor.     An object inheriting from Subscriptor can only be moved if no other   objects are subscribing to it.  
* [0.x.4]*
   Destructor, asserting that the counter is zero.  
* [0.x.5]*
   Assignment operator.     This has to be handled with care, too, because the counter has to remain   the same. It therefore does nothing more than returning <tt>*this</tt>.  
* [0.x.6]*
   Move assignment operator. Only invalidates the object moved from.  
* [0.x.7]*
    [2.x.4]  Subscriptor functionality     Classes derived from Subscriptor provide a facility to subscribe to this   object. This is mostly used by the SmartPointer class.  
* [0.x.8]*
   Subscribes a user of the object by storing the pointer  [2.x.5]  The   subscriber may be identified by text supplied as  [2.x.6]   
* [0.x.9]*
   Unsubscribes a user from the object.    
*  [2.x.7]  The  [2.x.8]  and the  [2.x.9]  pointer must be the same as   the one supplied to subscribe().  
* [0.x.10]*
   Return the present number of subscriptions to this object. This allows to   use this class for reference counted lifetime determination where the   last one to unsubscribe also deletes the object.  
* [0.x.11]*
   List the subscribers to the input  [2.x.10]   
* [0.x.12]*
   List the subscribers to  [2.x.11]   
* [0.x.13]*
    [2.x.12]  Exceptions    [2.x.13]   
* [0.x.14]*
   Exception: Object may not be deleted, since it is used.  
* [0.x.15]*
   A subscriber with the identification string given to    [2.x.14]  did not subscribe to the object.  
* [0.x.16]*
   Read or write the data of this object to or from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).     This function does not actually serialize any of the member variables of   this class. The reason is that what this class stores is only who   subscribes to this object, but who does so at the time of storing the   contents of this object does not necessarily have anything to do with who   subscribes to the object when it is restored. Consequently, we do not   want to overwrite the subscribers at the time of restoring, and then   there is no reason to write the subscribers out in the first place.  
* [0.x.17]*
   Store the number of objects which subscribed to this object. Initially,   this number is zero, and upon destruction it shall be zero again (i.e.   all objects which subscribed should have unsubscribed again).     The creator (and owner) of an object is counted in the map below if HE   manages to supply identification.     We use the <tt>mutable</tt> keyword in order to allow subscription to   constant objects also.     This counter may be read from and written to concurrently in   multithreaded code: hence we use the  [2.x.15]  class   template.  
* [0.x.18]*
   In this map, we count subscriptions for each different identification   string supplied to subscribe().  
* [0.x.19]*
   The data type used in #counter_map.  
* [0.x.20]*
   The iterator type used in #counter_map.  
* [0.x.21]*
   In this vector, we store pointers to the validity bool in the SmartPointer   objects that subscribe to this class.  
* [0.x.22]*
   Pointer to the typeinfo object of this object, from which we can later   deduce the class name. Since this information on the derived class is   neither available in the destructor, nor in the constructor, we obtain it   in between and store it here.  
* [0.x.23]*
   Check that there are no objects subscribing to this object. If this check   passes then it is safe to destroy the current object. It this check fails   then this function will either abort or print an error message to deallog   (by using the AssertNothrow mechanism), but will not throw an exception.    
*  [2.x.16]  Since this function is just a consistency check it does nothing in   release mode.    
*  [2.x.17]  If this function is called when there is an uncaught exception   then, rather than aborting, this function prints an error message to the   standard error stream and returns.  
* [0.x.24]*
   A mutex used to ensure data consistency when printing out the list   of subscribers.  
* [0.x.25]

include/deal.II-translator/base/symbolic_function_0.txt
[0.x.0]*
   A Function class that leverages symbolic differentiation to compute   gradients, Laplacians, Hessians, and time derivatives.     This class can be used to define functions using methods provided by the    [2.x.0]  namespace. In particular, one can define a symbolic   evaluation point (the argument of the function), as well as a symbolic   expression.     The symbolic gradients and the symbolic Hessians are computed at   construction time, and when a substitution in the symbolic functions is   requested by the user using the method update_user_substitution_map().     Whenever one of the evaluation methods is called, a substitution is   attempted with the coordinate symbols argument replaced by the evaluation   point and the symbolic time replaced by the current time, as returned by   the get_time() method. The user has to make sure that at evaluation time   argument substitution provides a fully evaluated expression (i.e., no other   symbols are contained in the function expression, except numerical values),   or an exception will be thrown. Additional symbols can be partially   evaluated or substituted by storing them in a user supplied substitution   maps, that can be updated by calling update_user_substitution_map() or the   set_additional_function_arguments() methods.     The simplest use case of this class is given in the following example:  
* [1.x.0]
*    where a Function with two components is defined using a string containing   their expressions separated by semicolons.     A more involved example, that explicitly uses    [2.x.1]  objects, is given by  
* [1.x.1]
*      Partial substitution is possible (i.e., you can define the function using   additional symbols). However, as soon as you evaluate the function, you   have to make sure that all extraneous symbols (i.e., those not referring   to the spacial  [2.x.2]  or to the  [2.x.3]  variable)   have been substituted with numerical values, or expressions of the spatial   or temporal argument, by calling the update_user_substitution_map() or the   set_additional_function_arguments() methods.     If your function requires additional arguments to be evaluated, you can   specify them by calling the set_additional_function_arguments() method.     If you call update_user_substitution_map() and   set_additional_function_arguments() with the same argument, the effect on   the function evaluation will be the same, however, the internal behavior   and function derivatives will be different. The method   update_user_substitution_map() performs the substitution once (the first   time it is required), and then stores internally a copy of the resulting   expression, together with its derivatives (if required). These are then   used in all subsequent evaluations. Calling   set_additional_function_arguments() will evaluate the passed   substitution map on the fly during evaluation time,after* all   derivatives have been computed.    
*  [2.x.4]  The difference between this class and the FunctionParser class is   that this class allows to compute first and second order derivatives (in a   symbolic way), while the FunctionParser class computes first order   derivatives only, using finite differences. For complicated expressions,   this class may be slower than the FunctionParser class.    
*  [2.x.5]   
* [0.x.1]*
     Constructor.         The resulting Function object will have as many components as there     are entries in the vector of symbolic expressions  [2.x.6]          The vector  [2.x.7]  should contain a list of symbolic expression     involving the coordinate symbols argument  [2.x.8]  and     possibly the symbolic time argument  [2.x.9]  It is possible to     define it in terms of other symbols, as long as the optional parameter      [2.x.10]  replaces all symbols except      [2.x.11]  and  [2.x.12]      This is useful if, for example, you want to express formulas in terms of     material parameters that you want to name symbolically, rather than     through their numeric values when defining the formula, or when you want     to express your formula in terms of polar coordinates rather than     cartesian ones, and you want the symbolic engine to compute the     derivatives for you.     You may later update the symbol map contained in  [2.x.13]      by calling update_user_substitution_map().          [2.x.14]  function A vector of symbolic expressions of type      [2.x.15]  representing the components of this     Function.          [2.x.16]  coordinate_symbols A tensor of symbols representing coordinates,     used as input argument in the symbolic expressions contained in the      [2.x.17]  vector. The default  [2.x.18]  is a      [2.x.19]      containing the symbols "x" for `dim` equal to one, "x", "y" for `dim`     equal to two, and "x", "y", "z" for `dim` equal to three.          [2.x.20]  time_symbol A symbolic variable representing time. It defaults     to a symbolic variable named "t".          [2.x.21]  user_substitution_map Any other symbol that may be contained in     the symbolic function needs to be specified in this map. The map may be     empty, and the functions may still contain unevaluated symbols, provided     that you call update_user_substitution_map() and provide a replacement of     all symbols except  [2.x.22]  and  [2.x.23]  before any     evaluation occurs.    
* [0.x.2]*
     Constructor that takes a single string that describes the function     expression as a semicolon separated list of expressions.         The symbolic expression can use the default argument and the default     symbolic time variable, plus any additional symbols that you may     need, provided that you update the user substitution map that substitutes     all of them before you try to evaluate the function or its derivatives,     by calling update_user_substitution_map(), and that you provide all the     additional function arguments of your function using the method     set_additional_function_arguments().    
* [0.x.3]*
     Store and apply the substitution map  [2.x.24]  to each symbolic     component of this Function object.         Notice that this method will trigger a recomputation of the     gradients, Hessians, and Laplacians of each component.    
* [0.x.4]*
     Set the additional  [2.x.25]  to be substituted in next evaluation     step.         Notice that the  [2.x.26]  are substitutedafter* evaluating the      [2.x.27]  and after all derivatives are     computed. If the additional arguments you pass still depend on the     coordinate or time symbols, then evaluation of derivatives will result in     a partial derivative evaluation.         This method provides a way to evaluate functions that depend on more     arguments than simply the coordinates and time. If you want to compute     the total derivative w.r.t. to complicated symbolic expressions, you     should call update_user_substitution_map() instead.    
* [0.x.5]*
     Return a tensor of coordinate symbols that can be used to define the     expressions of this symbolic function object.         The default argument is a  [2.x.28]      containing the symbols "x" for `dim` equal to one, "x", "y" for `dim`     equal to two, and "x", "y", "z" for `dim` equal to three.    
* [0.x.6]*
     Get the actual arguments used for the coordinates in the symbolic     function. This object does not include any user-defined arguments.    
* [0.x.7]*
     Get the actual symbolic time in use in this symbolic function.    
* [0.x.8]*
     Get the actual symbolic expressions used in this symbolic function.    
* [0.x.9]*
     Get the currently stored  [2.x.29]     
* [0.x.10]*
     Return a SymbolicFunction object that represents the time derivative of     this function. The spatial argument, the symbolic time, and the currently     stored user substitution map are forwarded to the new function.    
* [0.x.11]*
     Print the stored arguments and function expression, as it would be     evaluated when calling the method value().    
* [0.x.12]*
     Return a substitution map that replaces the argument with the values of      [2.x.30]  the symbolic time with the value of this->get_time(), and any     additional arguments with the substitution map given by      [2.x.31]     
* [0.x.13]*
     Recompute the symbolic value of the function, applying the user     substitution map. This may be an expensive computation, and it is called     only if necessary.    
* [0.x.14]*
     Recompute the symbolic gradient of the function, applying the user     substitution map. This may be an expensive computation, and it is called     only if necessary.    
* [0.x.15]*
     Recompute the symbolic Hessian and the symbolic Lapalacian of the     function. This may be an expensive computation, and it is called     only if necessary.    
* [0.x.16]*
     The components of this symbolic function, before any subustitution took     place. This is immutable, and generated at construction time.         Before any evaluation takes place, the  [2.x.32]  is     applied to this object, and the result is stored in the internal variable     function.         During evaluation, the  [2.x.33]  the  [2.x.34]  and     any remaining symbols are substituted with the input evaluation point,     the current time, and the content of  [2.x.35]     
* [0.x.17]*
     Store the user substitution map used for expression substitutions. This     may be updated with a call to update_user_substitution_map(). Notice that     the function may still have unresolved symbols, provided that they are     resolved by a call to set_additional_function_arguments().    
* [0.x.18]*
     Store a user substitution map used for additional argument     substitutions. This will be updated by a call to     set_additional_function_arguments().    
* [0.x.19]*
     The actual components of this symbolic function. This is obtained from     the  [2.x.36]  after applying the  [2.x.37]     
* [0.x.20]*
     The gradients of each component of this symbolic function. This is     obtained by computing the symbolic gradient of the object  [2.x.38]      that is, after applying the  [2.x.39]  to  [2.x.40]     
* [0.x.21]*
     The Hessians of each component of this symbolic function. This is     obtained by computing the symbolic Hessian of the object  [2.x.41]      that is, after applying the  [2.x.42]  to  [2.x.43]     
* [0.x.22]*
     The Laplacians of each component of this symbolic function. This is     obtained by computing the symbolic Laplacian of the object  [2.x.44]      that is, after applying the  [2.x.45]  to  [2.x.46]     
* [0.x.23]*
     The coordinate symbols argument of the function.    
* [0.x.24]*
     The symbolic time argument of the function.    
* [0.x.25]*
   Allow output using the bitwise left shift operator.  
* [0.x.26]

include/deal.II-translator/base/symbolic_function.templates_0.txt
[0.x.0]

include/deal.II-translator/base/symmetric_tensor_0.txt
[0.x.0]*
   A namespace for functions and classes that are internal to how the   SymmetricTensor class (and its associate functions) works.  
* [0.x.1]*
     Compute the inverse of a symmetric tensor of a     generic  [2.x.0]   [2.x.1]  and  [2.x.2]  type.    
* [0.x.2]*
   A namespace for classes that are internal to how the SymmetricTensor   class works.  
* [0.x.3]*
     Create a TableIndices<2> object where the first entries up to     <tt>position-1</tt> are taken from previous_indices, and new_index is     put at position <tt>position</tt>. The remaining indices remain in     invalid state.    
* [0.x.4]*
     Create a TableIndices<4> object where the first entries up to     <tt>position-1</tt> are taken from previous_indices, and new_index is     put at position <tt>position</tt>. The remaining indices remain in     invalid state.    
* [0.x.5]*
     Typedef template magic denoting the result of a double contraction     between two tensors or ranks rank1 and rank2. In general, this is a     tensor of rank <tt>rank1+rank2-4</tt>, but if this is zero it is a     single scalar Number. For this case, we have a specialization.    
* [0.x.6]*
     Typedef template magic denoting the result of a double contraction     between two tensors or ranks rank1 and rank2. In general, this is a     tensor of rank <tt>rank1+rank2-4</tt>, but if this is zero it is a     single scalar Number. For this case, we have a specialization.    
* [0.x.7]*
     Declaration of alias for the type of data structures which are used     to store symmetric tensors. For example, for rank-2 symmetric tensors,     we use a flat vector to store all the elements. On the other hand,     symmetric rank-4 tensors are mappings from symmetric rank-2 tensors     into symmetric rank-2 tensors, so they can be represented as matrices,     etc.         This information is probably of little interest to all except the     accessor classes that need it. In particular, you shouldn't make any     assumptions about the storage format in your application programs.    
* [0.x.8]*
     Specialization of StorageType for rank-2 tensors.    
* [0.x.9]*
       Number of independent components of a symmetric tensor of rank 2. We       store only the upper right half of it.      
* [0.x.10]*
       Declare the type in which we actually store the data.      
* [0.x.11]*
     Specialization of StorageType for rank-4 tensors.    
* [0.x.12]*
       Number of independent components of a symmetric tensor of rank 2.       Since rank-4 tensors are mappings between such objects, we need this       information.      
* [0.x.13]*
       Number of independent components of a symmetric tensor of rank 4.      
* [0.x.14]*
       Declare the type in which we actually store the data. Symmetric       rank-4 tensors are mappings between symmetric rank-2 tensors, so we       can represent the data as a matrix if we represent the rank-2 tensors       as vectors.      
* [0.x.15]*
     Switch type to select a tensor of rank 2 and dimension <tt>dim</tt>,     switching on whether the tensor should be constant or not.    
* [0.x.16]*
     Switch type to select a tensor of rank 2 and dimension <tt>dim</tt>,     switching on whether the tensor should be constant or not.         Specialization for constant tensors.    
* [0.x.17]*
     Switch type to select a tensor of rank 2 and dimension <tt>dim</tt>,     switching on whether the tensor should be constant or not.         Specialization for non-constant tensors.    
* [0.x.18]*
      [2.x.3]          Class that acts as accessor to elements of type SymmetricTensor. The     template parameter <tt>constness</tt> may be either true or false, and     indicates whether the objects worked on are constant or not (i.e. write     access is only allowed if the value is false).         Since with <tt>N</tt> indices, the effect of applying     <tt>operator[]</tt> is getting access to something with <tt>N-1</tt>     indices, we have to implement these accessor classes recursively, with     stopping when we have only one index left. For the latter case, a     specialization of this class is declared below, where calling     <tt>operator[]</tt> gives you access to the objects actually stored by     the tensor; the tensor class also makes sure that only those elements     are actually accessed which we actually store, i.e. it reorders indices     if necessary. The template parameter <tt>P</tt> indicates how many     remaining indices there are. For a rank-2 tensor, <tt>P</tt> may be     two, and when using <tt>operator[]</tt>, an object with <tt>P=1</tt>     emerges.         As stated for the entire namespace, you will not usually have to do     with these classes directly, and should not try to use their interface     directly as it may change without notice. In fact, since the     constructors are made private, you will not even be able to generate     objects of this class, as they are only thought as temporaries for     access to elements of the table class, not for passing them around as     arguments of functions, etc.         This class is an adaptation of a similar class used for the Table     class.    
* [0.x.19]*
       Import two alias from the switch class above.      
* [0.x.20]*
       Constructor. Take a reference to the tensor object which we will       access.             The second argument denotes the values of previous indices into the       tensor. For example, for a rank-4 tensor, if P=2, then we will       already have had two successive element selections (e.g. through       <tt>tensor[1][2]</tt>), and the two index values have to be stored       somewhere. This class therefore only makes use of the first rank-P       elements of this array, but passes it on to the next level with P-1       which fills the next entry, and so on.             The constructor is made private in order to prevent you having such       objects around. The only way to create such objects is via the       <tt>Table</tt> class, which only generates them as temporary objects.       This guarantees that the accessor objects go out of scope earlier       than the mother object, avoid problems with data consistency.      
* [0.x.21]*
       Copy constructor.      
* [0.x.22]*
       Index operator.      
* [0.x.23]*
       Index operator.      
* [0.x.24]*
       Store the data given to the constructor.      
* [0.x.25]*
      [2.x.4]  Accessor class for SymmetricTensor. This is the     specialization for the last index, which actually allows access to the     elements of the table, rather than recursively returning access objects     for further subsets. The same holds for this specialization as for the     general template; see there for more information.    
* [0.x.26]*
       Import two alias from the switch class above.      
* [0.x.27]*
       Constructor. Take a reference to the tensor object which we will       access.             The second argument denotes the values of previous indices into the       tensor. For example, for a rank-4 tensor, if P=2, then we will       already have had two successive element selections (e.g. through       <tt>tensor[1][2]</tt>), and the two index values have to be stored       somewhere. This class therefore only makes use of the first rank-P       elements of this array, but passes it on to the next level with P-1       which fills the next entry, and so on.             For this particular specialization, i.e. for P==1, all but the last       index are already filled.             The constructor is made private in order to prevent you having such       objects around. The only way to create such objects is via the       <tt>Table</tt> class, which only generates them as temporary objects.       This guarantees that the accessor objects go out of scope earlier       than the mother object, avoid problems with data consistency.      
* [0.x.28]*
       Copy constructor.      
* [0.x.29]*
       Index operator.      
* [0.x.30]*
       Index operator.      
* [0.x.31]*
       Store the data given to the constructor.      
* [0.x.32]*
 Provide a class that stores symmetric tensors of rank 2,4,... efficiently, i.e. only store those off-diagonal elements of the full tensor that are not redundant. For example, for symmetric  [2.x.5]  tensors, this would be the elements 11, 22, and 12, while the element 21 is equal to the 12 element. Within this documentation, second order symmetric tensors are denoted as bold-faced upper-case Latin letters such as  [2.x.6]  or bold-faced Greek letters such as  [2.x.7] ,  [2.x.8] . The Cartesian coordinates of a second-order tensor such as  [2.x.9]  are represented as  [2.x.10]  where  [2.x.11]  are indices ranging from 0 to <tt>dim-1</tt>.
*  Using this class for symmetric tensors of rank 2 has advantages over matrices in many cases since the dimension is known to the compiler as well as the location of the data. It is therefore possible to produce far more efficient code than for matrices with runtime-dependent dimension. It is also more efficient than using the more general <tt>Tensor</tt> class, since fewer elements are stored, and the class automatically makes sure that the tensor represents a symmetric object.
*  For tensors of higher rank, the savings in storage are even higher. For example for the  [2.x.12]  tensors of rank 4, only 36 instead of the full 81 entries have to be stored. These rank 4 tensors are denoted by blackboard-style upper-case Latin letters such as  [2.x.13]  with components  [2.x.14] .
*  While the definition of a symmetric rank-2 tensor is obvious, tensors of rank 4 are considered symmetric if they are operators mapping symmetric rank-2 tensors onto symmetric rank-2 tensors. This so-called minor symmetry of the rank 4 tensor requires that for every set of four indices  [2.x.15] , the identity  [2.x.16]  holds. However, it does not imply the relation  [2.x.17] . Consequently, symmetric tensors of rank 4 as understood here are only tensors that map symmetric tensors onto symmetric tensors, but they do not necessarily induce a symmetric scalar product  [2.x.18]  or even a positive (semi-)definite form  [2.x.19] , where  [2.x.20]  are symmetric rank-2 tensors and the colon indicates the common double-index contraction that acts as a scalar product for symmetric tensors.
*  Symmetric tensors are most often used in structural and fluid mechanics, where strains and stresses are usually symmetric tensors, and the stress-strain relationship is given by a symmetric rank-4 tensor.
* 

* 
*  [2.x.21]  Symmetric tensors only exist with even numbers of indices. In other words, the only objects that you can use are <tt>SymmetricTensor<2,dim></tt>, <tt>SymmetricTensor<4,dim></tt>, etc, but <tt>SymmetricTensor<1,dim></tt> and <tt>SymmetricTensor<3,dim></tt> do not exist and their use will most likely lead to compiler errors.
* 

*  [1.x.0]
*  The elements of a tensor  [2.x.22]  can be accessed using the bracket operator, i.e. for a tensor of rank 4, <tt>C[0][1][0][1]</tt> accesses the element  [2.x.23] . This access can be used for both reading and writing (if the tensor is non-constant at least). You may also perform other operations on it, although that may lead to confusing situations because several elements of the tensor are stored at the same location. For example, for a rank-2 tensor that is assumed to be zero at the beginning, writing <tt>A[0][1]+=1; A[1][0]+=1;</tt> will lead to the same element being increased by one  [2.x.24] twice [2.x.25] , because even though the accesses use different indices, the elements that are accessed are symmetric and therefore stored at the same location. It may therefore be useful in application programs to restrict operations on individual elements to simple reads or writes.
* 

* 
*  [2.x.26] 

* 
* [0.x.33]*
   Provide a way to get the dimension of an object without explicit   knowledge of it's data type. Implementation is this way instead of   providing a function <tt>dimension()</tt> because now it is possible to   get the dimension at compile time without the expansion and preevaluation   of an inlined function; the compiler may therefore produce more efficient   code and you may use this value to declare other data types.  
* [0.x.34]*
   Publish the rank of this tensor to the outside world.  
* [0.x.35]*
   An integer denoting the number of independent components that fully   describe a symmetric tensor. In  [2.x.27]  space dimensions, this number equals    [2.x.28]  for symmetric tensors of rank 2.  
* [0.x.36]*
   Default constructor. Creates a tensor with all entries equal to zero.  
* [0.x.37]*
   Constructor. Generate a symmetric tensor from a general one. Assumes that    [2.x.29]  is already symmetric, and in debug mode this is in fact checked.   Note that no provision is made to assure that the tensor is symmetric   only up to round-off error: if the incoming tensor is not exactly   symmetric, then an exception is thrown. If you know that incoming tensor   is symmetric only up to round-off, then you may want to call the   <tt>symmetrize()</tt> function first. If you aren't sure, it is good   practice to check before calling <tt>symmetrize()</tt>.     Because we check for symmetry via a non-constexpr function call, you will   have to use the symmetrize() function in constexpr contexts instead.  
* [0.x.38]*
   A constructor that creates a symmetric tensor from an array holding its   independent elements. Using this constructor assumes that the caller   knows the order in which elements are stored in symmetric tensors; its   use is therefore discouraged, but if you think you want to use it anyway   you can query the order of elements using the unrolled_index() function.     This constructor is currently only implemented for symmetric tensors of   rank 2.     The size of the array passed is equal to    [2.x.30]  the reason for using   the object from the internal namespace is to work around bugs in some   older compilers.  
* [0.x.39]*
   Copy constructor from tensors with different underlying scalar type. This   obviously requires that the  [2.x.31]  type is convertible to  [2.x.32]    Number.  
* [0.x.40]*
   Return a pointer to the first element of the underlying storage.  
* [0.x.41]*
   Return a const pointer to the first element of the underlying storage.  
* [0.x.42]*
   Return a pointer to the element past the end of the underlying storage.  
* [0.x.43]*
   Return a const pointer to the element past the end of the underlying   storage.  
* [0.x.44]*
   Assignment operator from symmetric tensors with different underlying scalar   type.   This obviously requires that the  [2.x.33]  type is convertible to    [2.x.34]   
* [0.x.45]*
   This operator assigns a scalar to a tensor. To avoid confusion with what   exactly it means to assign a scalar value to a tensor, zero is the only   value allowed for <tt>d</tt>, allowing the intuitive notation    [2.x.35]  to reset all elements of the tensor to zero.  
* [0.x.46]*
   Convert the present symmetric tensor into a full tensor with the same   elements, but using the different storage scheme of full tensors.  
* [0.x.47]*
   Test for equality of two tensors.  
* [0.x.48]*
   Test for inequality of two tensors.  
* [0.x.49]*
   Add another tensor.  
* [0.x.50]*
   Subtract another tensor.  
* [0.x.51]*
   Scale the tensor by <tt>factor</tt>, i.e. multiply all components by   <tt>factor</tt>.  
* [0.x.52]*
   Scale the tensor by <tt>1/factor</tt>.  
* [0.x.53]*
   Unary minus operator. Negate all entries of a tensor.  
* [0.x.54]*
   Double contraction product between the present symmetric tensor and a   tensor of rank 2. For example, if the present object is the symmetric   rank-2 tensor  [2.x.36]  and it is multiplied by another symmetric   rank-2 tensor  [2.x.37] , then the result is the scalar-product double   contraction  [2.x.38] .   In this case, the return value evaluates to a single   scalar. While it is possible to define other scalar products (and   associated induced norms), this one seems to be the most appropriate one.     If the present object is a rank-4 tensor such as  [2.x.39] , then the   result is a rank-2 tensor  [2.x.40] , i.e.,   the operation contracts over the last two indices of the present object   and the indices of the argument, and the result is a tensor of rank 2   ( [2.x.41] ).     Note that the multiplication operator for symmetric tensors is defined to   be a double contraction over two indices, while it is defined as a single   contraction over only one index for regular <tt>Tensor</tt> objects. For   symmetric tensors it therefore acts in a way that is commonly denoted by   a "colon multiplication" in the mathematical literature.     There are global functions <tt>double_contract</tt> that do the same work   as this operator, but rather than returning the result as a return value,   they write it into the first argument to the function.  
* [0.x.55]*
   Contraction over two indices of the present object with the rank-4   symmetric tensor given as argument.  
* [0.x.56]*
   Return a read-write reference to the indicated element.  
* [0.x.57]*
   Return a  [2.x.42]  reference to the value referred to by the argument.  
* [0.x.58]*
   Access the elements of a row of this symmetric tensor. This function is   called for constant tensors.  
* [0.x.59]*
   Access the elements of a row of this symmetric tensor. This function is   called for non-constant tensors.  
* [0.x.60]*
   Return a  [2.x.43]  reference to the value referred to by the argument.     Exactly the same as operator().  
* [0.x.61]*
   Return a read-write reference to the indicated element.     Exactly the same as operator().  
* [0.x.62]*
   Access to an element according to unrolled index. The function   <tt>s.access_raw_entry(unrolled_index)</tt> does the same as   <tt>s[s.unrolled_to_component_indices(unrolled_index)]</tt>, but more   efficiently.  
* [0.x.63]*
   Access to an element according to unrolled index. The function   <tt>s.access_raw_entry(unrolled_index)</tt> does the same as   <tt>s[s.unrolled_to_component_indices(unrolled_index)]</tt>, but more   efficiently.  
* [0.x.64]*
   Return the Frobenius-norm of a tensor, i.e. the square root of the sum of   squares of all entries. This norm is induced by the scalar product   defined above for two symmetric tensors. Note that it includes [1.x.1]   entries of the tensor, counting symmetry, not only the unique ones (for   example, for rank-2 tensors, this norm includes adding up the squares of   upper right as well as lower left entries, not just one of them, although   they are equal for symmetric tensors).  
* [0.x.65]*
   Tensor objects can be unrolled by simply pasting all elements into one   long vector, but for this an order of elements has to be defined. For   symmetric tensors, this function returns which index within the range    [2.x.44]  the given entry in a symmetric   tensor has.  
* [0.x.66]*
   The opposite of the previous function: given an index  [2.x.45]  in the unrolled   form of the tensor, return what set of indices  [2.x.46]  (for rank-2   tensors) or  [2.x.47]  (for rank-4 tensors) corresponds to it.  
* [0.x.67]*
   Reset all values to zero.     Note that this is partly inconsistent with the semantics of the  [2.x.48]    clear() member functions of the standard library containers and of   several other classes within deal.II, which not only reset the values of   stored elements to zero, but release all memory and return the object   into a virginial state. However, since the size of objects of the present   type is determined by its template parameters, resizing is not an option,   and indeed the state where all elements have a zero value is the state   right after construction of such an object.  
* [0.x.68]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.69]*
   Read or write the data of this object to or from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.70]*
   A structure that describes properties of the base tensor.  
* [0.x.71]*
   Data storage type for a symmetric tensor.  
* [0.x.72]*
   The place where we store the data of the tensor.  
* [0.x.73]*
 Addition of two symmetric tensors of equal rank. The result is another SymmetricTensor that has a number type that is compatible with the operation.
*  If possible (e.g. when  [2.x.49]  and  [2.x.50]  are of the same type, or if the result of  [2.x.51]  is another  [2.x.52]  you should use <tt>operator+=</tt> instead since this does not require the creation of a temporary variable.
*   [2.x.53]  SymmetricTensor

* 
* [0.x.74]*
 Subtraction of two symmetric tensors of equal rank. The result is another SymmetricTensor that has a number type that is compatible with the operation.
*  If possible (e.g. when  [2.x.54]  and  [2.x.55]  are of the same type, or if the result of <code>Number()
* 
*  - OtherNumber()</code> is another  [2.x.56]  you should use <tt>operator-=</tt> instead since this does not require the creation of a temporary variable.
*   [2.x.57]  SymmetricTensor

* 
* [0.x.75]*
 Addition of a SymmetricTensor and a general Tensor of equal rank. The result is a general Tensor that has a number type that is compatible with the operation.
*   [2.x.58]  SymmetricTensor

* 
* [0.x.76]*
 Addition of a general Tensor with a SymmetricTensor of equal rank. The result is a general Tensor that has a number type that is compatible with the operation.
*   [2.x.59]  SymmetricTensor

* 
* [0.x.77]*
 Subtraction of a general Tensor from a SymmetricTensor of equal rank. The result is a general Tensor that has a number type that is compatible with the operation.
*   [2.x.60]  SymmetricTensor

* 
* [0.x.78]*
 Subtraction of a SymmetricTensor from a general Tensor of equal rank. The result is a general Tensor that has a number type that is compatible with the operation.
*   [2.x.61]  SymmetricTensor

* 
* [0.x.79]*
 Compute the determinant of a rank 2 symmetric tensor. The determinant is also commonly referred to as the third invariant of rank-2 tensors.
*  For a one-dimensional tensor, the determinant equals the only element and is therefore equivalent to the trace.
*  For greater notational simplicity, there is also a <tt>third_invariant()</tt> function that returns the determinant of a tensor.
*   [2.x.62]  SymmetricTensor

* 
* [0.x.80]*
 Compute the determinant of a rank 2 symmetric tensor. This function therefore computes the same value as the <tt>determinant()</tt> functions and is only provided for greater notational simplicity (since there are also functions first_invariant() and second_invariant()). [1.x.2]
*   [2.x.63]  SymmetricTensor

* 
* [0.x.81]*
 Compute and return the trace of a tensor of rank 2, i.e. the sum of its diagonal entries. The trace is the first invariant of a rank-2 tensor. [1.x.3]
*   [2.x.64]  SymmetricTensor

* 
* [0.x.82]*
 Compute the trace of a rank 2 symmetric tensor. This function therefore computes the same value as the <tt>trace()</tt> functions and is only provided for greater notational simplicity (since there are also functions second_invariant() and third_invariant()). [1.x.4]
*   [2.x.65]  SymmetricTensor

* 
* [0.x.83]*
 Compute the second invariant of a tensor of rank 2. The second invariant of a tensor  [2.x.66]  is defined as  [2.x.67] .
*  For the kind of arguments to this function, i.e., a rank-2 tensor of size 1, the result is simply zero.
*   [2.x.68]  SymmetricTensor

* 
* [0.x.84]*
 Compute the second invariant of a tensor of rank 2. The second invariant of a tensor  [2.x.69]  is defined as  [2.x.70] .
*  For the kind of arguments to this function, i.e., a symmetric rank-2 tensor of size 2, the result is (counting indices starting at one)  [2.x.71] . As expected, for the  [2.x.72]  symmetric tensors this function handles, this equals the determinant of the tensor. (This is so because for  [2.x.73]  symmetric tensors, there really are only two invariants, so the second and third invariant are the same; the determinant is the third invariant.)
*   [2.x.74]  SymmetricTensor

* 
* [0.x.85]*
 Compute the second invariant of a tensor of rank 2. The second invariant of a tensor  [2.x.75]  is defined as  [2.x.76] .
*   [2.x.77]  SymmetricTensor

* 
* [0.x.86]*
 Return the eigenvalues of a symmetric  [2.x.78]  tensor. The (single) entry of the tensor is, of course, equal to the (single) eigenvalue.
*   [2.x.79]  SymmetricTensor

* 
* [0.x.87]*
 Return the eigenvalues of a symmetric  [2.x.80]  tensor. The array of eigenvalues is sorted in descending order.
*  For  [2.x.81]  tensors, the eigenvalues of tensor  [2.x.82]  are the roots of [1.x.5]  [2.x.83]  as given by  [2.x.84] .
*   [2.x.85]  The algorithm employed here determines the eigenvalues by computing the roots of the characteristic polynomial. In the case that there exists a common root (the eigenvalues are equal), the computation is [1.x.6] of order  [2.x.86] . As an alternative, the eigenvectors() function provides a more robust, but costly, method to compute the eigenvalues of a symmetric tensor.
*   [2.x.87]  SymmetricTensor

* 
* [0.x.88]*
 Return the eigenvalues of a symmetric  [2.x.88]  tensor. The array of eigenvalues is sorted in descending order.
*  For  [2.x.89]  tensors, the eigenvalues of tensor  [2.x.90]  are the roots of [1.x.7]  [2.x.91] .
*   [2.x.92]  The algorithm employed here determines the eigenvalues by computing the roots of the characteristic polynomial. In the case that there exists a common root (the eigenvalues are equal), the computation is [1.x.8] of order  [2.x.93] . As an alternative, the eigenvectors() function provides a more robust, but costly, method to compute the eigenvalues of a symmetric tensor.
*   [2.x.94]  SymmetricTensor

* 
* [0.x.89]*
     Tridiagonalize a rank-2 symmetric tensor using the Householder method.     The specialized algorithm implemented here is given in    
* [1.x.9]
*      and is based off of the generic algorithm presented in section 11.3.2 of    
* [1.x.10]
*           [2.x.95]   A This tensor to be tridiagonalized      [2.x.96]  Q The orthogonal matrix effecting the transformation      [2.x.97]  d The diagonal elements of the tridiagonal matrix      [2.x.98]  e The off-diagonal elements of the tridiagonal matrix    
* [0.x.90]*
     Compute the eigenvalues and eigenvectors of a real-valued rank-2     symmetric tensor using the QL algorithm with implicit shifts.     The specialized algorithm implemented here is given in    
* [1.x.11]
*      and is based off of the generic algorithm presented in section 11.4.3 of    
* [1.x.12]
*           [2.x.99]  A The tensor of which the eigenvectors and eigenvalues are     to be computed.          [2.x.100]  An array containing the eigenvectors and the associated eigenvalues.     The array is not sorted in any particular order.    
* [0.x.91]*
     Compute the eigenvalues and eigenvectors of a real-valued rank-2     symmetric tensor using the Jacobi algorithm.     The specialized algorithm implemented here is given in    
* [1.x.13]
*      and is based off of the generic algorithm presented in section 11.4.3 of    
* [1.x.14]
*           [2.x.101]  A The tensor of which the eigenvectors and eigenvalues are     to be computed.          [2.x.102]  An array containing the eigenvectors and the associated eigenvalues.     The array is not sorted in any particular order.    
* [0.x.92]*
     Compute the eigenvalues and eigenvectors of a real-valued rank-2     symmetric 2x2 tensor using the characteristic equation to compute     eigenvalues and an analytical approach based on the cross-product for the     eigenvectors. If the computations are deemed too inaccurate then the     method falls back to ql_implicit_shifts.          [2.x.103]  A The tensor of which the eigenvectors and eigenvalues are     to be computed.          [2.x.104]  An array containing the eigenvectors and the associated eigenvalues.     The array is not sorted in any particular order.    
* [0.x.93]*
     Compute the eigenvalues and eigenvectors of a real-valued rank-2     symmetric 3x3 tensor using the characteristic equation to compute     eigenvalues and an analytical approach based on the cross-product for the     eigenvectors. If the computations are deemed too inaccurate then the     method falls back to ql_implicit_shifts. The specialized algorithm     implemented here is given in    
* [1.x.15]
*           [2.x.105]  A The tensor of which the eigenvectors and eigenvalues are     to be computed.          [2.x.106]  An array containing the eigenvectors and the associated eigenvalues.     The array is not sorted in any particular order.    
* [0.x.94]*
     A struct that is used to sort arrays of pairs of eign=envalues and     eigenvectors. Sorting is performed in descending order of eigenvalue.    
* [0.x.95]*
 An enumeration for the algorithm to be employed when performing the computation of normalized eigenvectors and their corresponding eigenvalues by the eigenvalues() and eigenvectors() methods operating on SymmetricTensor objects.
*  The specialized algorithms utilized in computing the eigenvectors are presented in

* 
* [1.x.16]
* 

* 
* [0.x.96]*
   A hybrid approach that preferentially uses the characteristic equation to   compute eigenvalues and an analytical approach based on the cross-product   for the eigenvectors. If the computations are deemed too inaccurate then   the method falls back to ql_implicit_shifts.     This method potentially offers the quickest computation if the pathological   case is not encountered.  
* [0.x.97]*
   The iterative QL algorithm with implicit shifts applied after   tridiagonalization of the tensor using the householder method.     This method offers a compromise between speed of computation and its   robustness. This method is particularly useful when the elements   of  [2.x.107]  have greatly varying magnitudes, which would typically lead to a   loss of accuracy when computing the smaller eigenvalues.  
* [0.x.98]*
   The iterative Jacobi algorithm.     This method offers is the most robust of the available options, with   reliable results obtained for even the most pathological cases. It is,   however, the slowest algorithm of all of those implemented.  
* [0.x.99]*
 Return the eigenvalues and eigenvectors of a real-valued rank-2 symmetric tensor  [2.x.108] . The array of matched eigenvalue and eigenvector pairs is sorted in descending order (determined by the eigenvalues).
*  The specialized algorithms utilized in computing the eigenvectors are presented in

* 
* [1.x.17]
* 
*   [2.x.109]  SymmetricTensor

* 
* [0.x.100]*
 Return the transpose of the given symmetric tensor. Since we are working with symmetric objects, the transpose is of course the same as the original tensor. This function mainly exists for compatibility with the Tensor class.
*   [2.x.110]  SymmetricTensor

* 
* [0.x.101]*
 Compute the deviator of a symmetric tensor, which is defined as  [2.x.111] , where  [2.x.112]  is the identity operator. This quantity equals the original tensor minus its contractive or dilative component and refers to the shear in, for example, elasticity.
*   [2.x.113]  SymmetricTensor

* 
* [0.x.102]*
 Return a unit symmetric tensor of rank 2, i.e., the  [2.x.114]  identity matrix  [2.x.115] .
*   [2.x.116]  SymmetricTensor

* 
* [0.x.103]*
 unit_symmetric_tensor<dim>() is the specialization of the function unit_symmetric_tensor<dim,Number>() which uses  [2.x.117]  as the data type for the elements.
*   [2.x.118]  SymmetricTensor

* 
* [0.x.104]*
 Return the tensor of rank 4 that, when multiplied by a symmetric rank 2 tensor  [2.x.119]  returns the deviator  [2.x.120] . It is the operator representation of the linear deviator operator  [2.x.121] , also known as the volumetric projection tensor, calculated as: [1.x.18]
*  For every tensor <tt>T</tt>, there holds the identity <tt>deviator<dim,Number>(T) == deviator_tensor<dim,Number>() T</tt>, up to numerical round-off. [1.x.19]
* 

* 
*  [2.x.122]  The reason this operator representation is provided is to simplify taking derivatives of the deviatoric part of tensors: [1.x.20]
*   [2.x.123]  SymmetricTensor

* 
* [0.x.105]*
 This version of the deviator_tensor<dim>() function is a specialization of deviator_tensor<dim,Number>() that uses <tt>double</tt> as the data type for the elements of the tensor.
*   [2.x.124]  SymmetricTensor

* 
* [0.x.106]*
 Return the fourth-order symmetric identity tensor  [2.x.125]  which maps symmetric second-order tensors, such as   [2.x.126] , to themselves. [1.x.21]
*  Note that this tensor, even though it is the identity, has a somewhat funny form, and in particular does not only consist of zeros and ones. For example, for <tt>dim=2</tt>, the identity tensor has all zero entries except for [1.x.22] [1.x.23] In index notation, we can write the general form [1.x.24] To see why this factor of  [2.x.127]  is necessary, consider computing  [2.x.128] . For the element  [2.x.129]  we have  [2.x.130] . On the other hand, we need to have  [2.x.131] , and symmetry implies  [2.x.132] , leading to  [2.x.133] , or, again by symmetry,  [2.x.134] . Similar considerations hold for the three-dimensional case.
*  This issue is also explained in the introduction to  [2.x.135] .
*   [2.x.136]  SymmetricTensor

* 
* [0.x.107]*
 This version of the identity_tensor<dim>() function is the specialization of identity_tensor<dim,Number>() which uses <tt>double</tt> as the data type for the elements of the tensor.
*   [2.x.137]  SymmetricTensor

* 
* [0.x.108]*
 Invert a symmetric rank-2 tensor.
* 

* 
*  [2.x.138]  If a tensor is not invertible, then the result is unspecified, but will likely contain the results of a division by zero or a very small number at the very least.
*   [2.x.139]  SymmetricTensor

* 
* [0.x.109]*
 Invert a symmetric rank-4 tensor. Since symmetric rank-4 tensors are mappings from and to symmetric rank-2 tensors, they can have an inverse.
*  If a tensor is not invertible, then the result is unspecified, but will likely contain the results of a division by zero or a very small number at the very least.
*   [2.x.140]  SymmetricTensor

* 
* [0.x.110]*
 Return the tensor of rank 4 that is the outer product of the two tensors given as arguments, i.e. the result  [2.x.141]  satisfies  [2.x.142]  for all symmetric tensors  [2.x.143] . In index notation [1.x.25]
*  For example, the deviator tensor  [2.x.144]  can be computed as <tt>identity_tensor<dim>()
* 
*  - 1/d outer_product (unit_symmetric_tensor<dim>(), unit_symmetric_tensor<dim>())</tt>, since the (double) contraction with the unit tensor yields the trace of a symmetric tensor ( [2.x.145] ).
*   [2.x.146]  SymmetricTensor

* 
* [0.x.111]*
 Return the symmetrized version of a full rank-2 tensor, i.e.  [2.x.147] , as a symmetric rank-2 tensor. This is the version for general dimensions.
*   [2.x.148]  SymmetricTensor

* 
* [0.x.112]*
 Multiplication of a symmetric tensor of general rank with a scalar from the right. This version of the operator is used if the scalar has the same data type as is used to store the elements of the symmetric tensor.
*   [2.x.149]  SymmetricTensor

* 
* [0.x.113]*
 Multiplication of a symmetric tensor of general rank with a scalar from the left. This version of the operator is used if the scalar has the same data type as is used to store the elements of the symmetric tensor.
*   [2.x.150]  SymmetricTensor

* 
* [0.x.114]*
 Multiplication of a symmetric tensor with a scalar number from the right.
*  The purpose of this operator is to enable only multiplication of a tensor by a scalar number (i.e., a floating point number, a complex floating point number, etc.). The function is written in a way that only allows the compiler to consider the function if the second argument is indeed a scalar number
* 
*  -  in other words,  [2.x.151]  will not match, for example  [2.x.152]  as the product of a tensor and a vector clearly would make no sense. The mechanism by which the compiler is prohibited of considering this operator for multiplication with non-scalar types are explained in the documentation of the EnableIfScalar class.
*  The return type of the function is chosen so that it matches the types of both the tensor and the scalar argument. For example, if you multiply a  [2.x.153]  by  [2.x.154] , then the result will be a  [2.x.155] . In other words, the type with which the returned tensor stores its components equals the type you would get if you multiplied an individual component of the input tensor by the scalar factor.
*   [2.x.156]  SymmetricTensor  [2.x.157]  EnableIfScalar

* 
* [0.x.115]*
 Multiplication of a symmetric tensor with a scalar number from the left. See the discussion with the operator with switched arguments for more information about template arguments and the return type.
*   [2.x.158]  SymmetricTensor  [2.x.159]  EnableIfScalar

* 
* [0.x.116]*
 Division of a symmetric tensor of general rank by a scalar.
*   [2.x.160]  SymmetricTensor

* 
* [0.x.117]*
 Multiplication of a symmetric tensor of general rank with a scalar from the right.
*   [2.x.161]  SymmetricTensor

* 
* [0.x.118]*
 Multiplication of a symmetric tensor of general rank with a scalar from the left.
*   [2.x.162]  SymmetricTensor

* 
* [0.x.119]*
 Division of a symmetric tensor of general rank by a scalar.
*   [2.x.163]  SymmetricTensor

* 
* [0.x.120]*
 Compute the scalar product  [2.x.164]  between two tensors  [2.x.165]  of rank 2. In the current case where both arguments are symmetric tensors, this is equivalent to calling the expression  [2.x.166]  which uses  [2.x.167] .
*   [2.x.168]  SymmetricTensor

* 
* [0.x.121]*
 Compute the scalar product  [2.x.169]  between two tensors  [2.x.170]  of rank 2. We don't use  [2.x.171]  for this operation since the product between two tensors is usually assumed to be the contraction over the last index of the first tensor and the first index of the second tensor. For example, if <tt>B</tt> is a Tensor, calling <tt>A*B</tt> (instead of <tt>scalar_product(A,B)</tt>) provides  [2.x.172] .
*   [2.x.173]  Tensor  [2.x.174]  SymmetricTensor

* 
* [0.x.122]*
 Compute the scalar product  [2.x.175]  between two tensors  [2.x.176]  of rank 2. We don't use  [2.x.177]  for this operation since the product between two tensors is usually assumed to be the contraction over the last index of the first tensor and the first index of the second tensor. For example, if <tt>A</tt> is a Tensor, calling <tt>A*B</tt> (instead of <tt>scalar_product(A,B)</tt>) provides  [2.x.178] .
*   [2.x.179]  Tensor  [2.x.180]  SymmetricTensor

* 
* [0.x.123]*
 Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.
*  This function does the same as  [2.x.181]  It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general Tensor class.
*   [2.x.182]  SymmetricTensor

* 
* [0.x.124]*
 Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.
*  This function does the same as  [2.x.183]  It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general Tensor class.
*   [2.x.184]  SymmetricTensor

* 
* [0.x.125]*
 Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.
*  This function does the same as  [2.x.185]  It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general Tensor class.
*   [2.x.186]  SymmetricTensor

* 
* [0.x.126]*
 Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.
*  This function does the same as  [2.x.187]  It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general Tensor class.
*   [2.x.188]  SymmetricTensor

* 
* [0.x.127]*
 Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.
*  This function does the same as  [2.x.189]  It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general Tensor class.
*   [2.x.190]  SymmetricTensor

* 
* [0.x.128]*
 Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.
*  This function does the same as  [2.x.191]  It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general Tensor class.
*   [2.x.192]  SymmetricTensor

* 
* [0.x.129]*
 Multiply a symmetric rank-2 tensor (i.e., a matrix) by a rank-1 tensor (i.e., a vector). The result is a rank-1 tensor (i.e., a vector).
*   [2.x.193]  SymmetricTensor

* 
* [0.x.130]*
 Multiply a rank-1 tensor (i.e., a vector) by a symmetric rank-2 tensor (i.e., a matrix). The result is a rank-1 tensor (i.e., a vector).
*   [2.x.194]  SymmetricTensor

* 
* [0.x.131]*
 The dot product (single contraction) for tensors: Return a tensor of rank  [2.x.195]  that is the contraction of the last index of a tensor  [2.x.196]  of rank  [2.x.197]  with the first index of a tensor  [2.x.198]  of rank  [2.x.199]  [1.x.26]
* 

* 
*  [2.x.200]  As one operand is a Tensor, the multiplication operator only performs a contraction over a single pair of indices. This is in contrast to the multiplication operator for SymmetricTensor, which does the double contraction.
*   [2.x.201]  SymmetricTensor

* 
* [0.x.132]*
 The dot product (single contraction) for tensors: Return a tensor of rank  [2.x.202]  that is the contraction of the last index of a tensor  [2.x.203]  of rank  [2.x.204]  with the first index of a tensor  [2.x.205]  of rank  [2.x.206]  [1.x.27]
* 

* 
*  [2.x.207]  As one operand is a Tensor, the multiplication operator only performs a contraction over a single pair of indices. This is in contrast to the multiplication operator for SymmetricTensor, which does the double contraction.
*   [2.x.208]  SymmetricTensor

* 
* [0.x.133]*
 Output operator for symmetric tensors of rank 2. Print the elements consecutively, with a space in between, two spaces between rank 1 subtensors, three between rank 2 and so on. No special amends are made to represents the symmetry in the output, for example by outputting only the unique entries.
*   [2.x.209]  SymmetricTensor

* 
* [0.x.134]*
 Output operator for symmetric tensors of rank 4. Print the elements consecutively, with a space in between, two spaces between rank 1 subtensors, three between rank 2 and so on. No special amends are made to represents the symmetry in the output, for example by outputting only the unique entries.
*   [2.x.210]  SymmetricTensor

* 
* [0.x.135]

include/deal.II-translator/base/symmetric_tensor.templates_0.txt
[0.x.0]

include/deal.II-translator/base/synchronous_iterator_0.txt
[0.x.0]*
 A class that represents a set of iterators each of which are incremented by one at the same time. This is typically used in calls like  [2.x.0]  where we have synchronous iterators marching through the containers  [2.x.1] . If an object of this type represents the end of a range, only the first element is considered (we only have  [2.x.2] , not  [2.x.3] ). An example of how this class is used is given in  [2.x.4] .
*  The template argument of the current class shall be of type  [2.x.5]  with arguments equal to the iterator types.
*  The individual iterators can be accessed using  [2.x.6]  where X is the number corresponding to the desired iterator.
*  This type, and the helper functions associated with it, are used as the Value concept for the blocked_range type of the Threading Building Blocks.

* 
* [0.x.1]*
   Constructor.  
* [0.x.2]*
   Dereference const operator. Returns a const reference to the iterators   represented by the current class.  
* [0.x.3]*
   Dereference operator. Returns a reference to the iterators   represented by the current class.  
* [0.x.4]*
   Storage for the iterators represented by the current class.  
* [0.x.5]*
 Return whether the first element of the first argument is less than the first element of the second argument. Since the objects compared march forward all elements at the same time, comparing the first element is sufficient.
*   [2.x.7]  SynchronousIterators

* 
* [0.x.6]*
 Return the distance between the first and the second argument. Since the objects compared march forward all elements at the same time, differencing the first element is sufficient.
*   [2.x.8]  SynchronousIterators

* 
* [0.x.7]*
 Advance a tuple of iterators by  [2.x.9] .
*   [2.x.10]  SynchronousIterators

* 
* [0.x.8]*
 Advance a tuple of iterators by  [2.x.11] .
*   [2.x.12]  SynchronousIterators

* 
* [0.x.9]*
 Advance a tuple of iterators by  [2.x.13] .
*   [2.x.14]  SynchronousIterators

* 
* [0.x.10]*
 Advance a tuple of iterators by 1.
*   [2.x.15]  SynchronousIterators

* 
* [0.x.11]*
 Advance a tuple of iterators by 1.
*   [2.x.16]  SynchronousIterators

* 
* [0.x.12]*
 Advance a tuple of iterators by 1.
*   [2.x.17]  SynchronousIterators

* 
* [0.x.13]*
 Advance the elements of this iterator by  [2.x.18] .
*   [2.x.19]  SynchronousIterators

* 
* [0.x.14]*
 Advance the elements of this iterator by 1.
*   [2.x.20]  SynchronousIterators

* 
* [0.x.15]*
 Compare synch iterators for inequality. Since they march in synch, comparing only the first element is sufficient.
*   [2.x.21]  SynchronousIterators

* 
* [0.x.16]

include/deal.II-translator/base/table_0.txt
[0.x.0]*
    [2.x.0]  Have a namespace in which we declare some classes that are used   to access the elements of tables using the <tt>operator[]</tt>. These are   quite technical, since they have to do their work recursively (due to the   fact that the number of indices is not known, we have to return an   iterator into the next lower dimension object if we access one object,   until we are on the lowest level and can actually return a reference to   the stored data type itself).  This is so technical that you will not   usually want to look at these classes at all, except possibly for   educational reasons.  None of the classes herein has a interface that you   should use explicitly in your programs (except, of course, through access   to the elements of tables with <tt>operator[]</tt>, which generates   temporary objects of the types of this namespace).  
* [0.x.1]*
      [2.x.1]  Have a class which declares some nested alias, depending     on its template parameters. The general template declares nothing, but     there are more useful specializations regarding the last parameter     indicating constness of the table for which accessor objects are to be     generated in this namespace.    
* [0.x.2]*
      [2.x.2]  Have a class which declares some nested alias, depending     on its template parameters. Specialization for accessors to constant     objects.    
* [0.x.3]*
      [2.x.3]  Have a class which declares some nested alias, depending     on its template parameters. Specialization for accessors to non-     constant objects.    
* [0.x.4]*
      [2.x.4]  Class that acts as accessor to subobjects of tables of type     <tt>Table<N,T></tt>. The template parameter <tt>C</tt> may be either     true or false, and indicates whether the objects worked on are constant     or not (i.e. write access is only allowed if the value is false).         Since with <tt>N</tt> indices, the effect of applying     <tt>operator[]</tt> is getting access to something with <tt>N-1</tt>     indices, we have to implement these accessor classes recursively, with     stopping when we have only one index left. For the latter case, a     specialization of this class is declared below, where calling     <tt>operator[]</tt> gives you access to the objects actually stored by     the table. In the value given to the index operator needs to be checked     whether it is inside its bounds, for which we need to know which index     of the table we are actually accessing presently. This is done through     the template parameter <tt>P</tt>: it indicates, how many remaining     indices there are. For a vector, <tt>P</tt> may only be one (and then     the specialization below is used). For a table this value may be two,     and when using <tt>operator[]</tt>, an object with <tt>P=1</tt>     emerges.         The value of <tt>P</tt> is also used to determine the stride: this     object stores a pointer indicating the beginning of the range of     objects that it may access. When we apply <tt>operator[]</tt> on this     object, the resulting new accessor may only access a subset of these     elements, and to know which subset we need to know the dimensions of     the table and the present index, which is indicated by <tt>P</tt>.         As stated for the entire namespace, you will not usually have to deal     with these classes directly, and should not try to use their interface     directly as it may change without notice. In fact, since the     constructors are made private, you will not even be able to generate     objects of this class, as they are only thought as temporaries for     access to elements of the table class, not for passing them around as     arguments of functions, etc.    
* [0.x.5]*
       Constructor. Take a pointer to the table object to know about the       sizes of the various dimensions, and a pointer to the subset of data       we may access.      
* [0.x.6]*
       Copy constructor. This constructor is public so that one can pass       sub-tables to functions as arguments, as in  [2.x.5] .             Using this constructor is risky if accessors are stored longer than       the table it points to. Don't do this.      
* [0.x.7]*
       Index operator. Performs a range check.      
* [0.x.8]*
       Exception for range check. Do not use global exception since this way       we can output which index is the wrong one.      
* [0.x.9]*
       Store the data given to the constructor. There are no non-const       member functions of this class, so there is no reason not to make       these elements constant.      
* [0.x.10]*
      [2.x.6]  Accessor class for tables. This is the specialization for the     last index, which actually allows access to the elements of the table,     rather than recursively returning access objects for further subsets.     The same holds for this specialization as for the general template; see     there for more information.    
* [0.x.11]*
       Typedef constant and non-constant iterator types to the elements of       this row, as well as all the other types usually required for the       standard library algorithms.      
* [0.x.12]*
       Import an alias from the switch class above.      
* [0.x.13]*
       Constructor. Take an iterator to the table object to know about the       sizes of the various dimensions, and a iterator to the subset of data       we may access (which in this particular case is only one row).             The constructor is made private in order to prevent you having such       objects around. The only way to create such objects is via the       <tt>Table</tt> class, which only generates them as temporary objects.       This guarantees that the accessor objects go out of scope earlier       than the mother object, avoid problems with data consistency.      
* [0.x.14]*
       Copy constructor. This constructor is public so that one can pass       sub-tables to functions as arguments, as in  [2.x.7] .             Using this constructor is risky if accessors are stored longer than       the table it points to. Don't do this.      
* [0.x.15]*
       Index operator. Performs a range check.      
* [0.x.16]*
       Return the length of one row, i.e. the number of elements       corresponding to the last index of the table object.      
* [0.x.17]*
       Return an iterator to the first element of this row.      
* [0.x.18]*
       Return an iterator to the element past the end of this row.      
* [0.x.19]*
       Store the data given to the constructor. There are no non-const       member functions of this class, so there is no reason not to make       these elements constant.      
* [0.x.20]*
 A class holding a multi-dimensional array of objects of templated type. If the template parameter indicating the number of dimensions is one, then this class more or less represents a vector; if it is two then it is a matrix; and so on.
*  This class specifically replaces attempts at higher-dimensional arrays like  [2.x.8]  or even higher nested constructs. These constructs have the disadvantage that they are hard to initialize, and most importantly that they are very inefficient if all rows of a matrix or higher-dimensional table have the same size (which is the usual case), since then the memory for each row is allocated independently, both wasting time and memory. This can be made more efficient by allocating only one chunk of memory for the entire object, which is what the current class does.
* 

*  [1.x.0]
*  In some way, this class is similar to the Tensor class, in that it templatizes on the number of dimensions. However, there are two major differences. The first is that the Tensor class stores only numeric values (as <tt>double</tt>s), while the Table class stores arbitrary objects. The second is that the Tensor class has fixed sizes in each dimension, also given as a template argument, while this class can handle arbitrary and different sizes in each dimension.
*  This has two consequences. First, since the size is not known at compile time, it has to do explicit memory allocation. Second, the layout of individual elements is not known at compile time, so access is slower than for the Tensor class where the number of elements are their location is known at compile time and the compiler can optimize with this knowledge (for example when unrolling loops). On the other hand, this class is of course more flexible, for example when you want a two-dimensional table with the number of rows equal to the number of degrees of freedom on a cell, and the number of columns equal to the number of quadrature points. Both numbers may only be known at run-time, so a flexible table is needed here. Furthermore, you may want to store, say, the gradients of shape functions, so the data type is not a single scalar value, but a tensor itself.
* 

*  [1.x.1]
*  The Table classes (derived from this class) are frequently used to store large data tables. A modest example is given in  [2.x.9]  where we store a  [2.x.10]  table of geographic elevation data for a region of Africa, and this data requires about 670 kB if memory; however, tables that store three- or more-dimensional data (say, information about the density, pressure, and temperature in the earth interior on a regular grid of `(latitude, longitude, depth)` points) can easily run into hundreds of megabytes or more. These tables are then often provided to classes such as InterpolatedTensorProductGridData or InterpolatedUniformGridData.
*  If you need to load such tables on single-processor (or multi-threaded) jobs, then there is nothing you can do about the size of these tables: The table just has to fit into memory. But, if your program is parallelized via MPI, then a typical first implementation would create a table object on every process and fill it on every MPI process by reading the data from a file. This is inefficient from two perspectives:
* 

* 
* 
*  - You will have a lot of processes that are all trying to read from   the same file at the same time.
* 

* 
* 
*  - In most cases, the data stored on every process is the same, and   while every process needs to be able to read from a table, it is not   necessary that every process stores its own table: All MPI processes   that happen to be located on the same machine might as well store   only one copy and make it available to each other via   [shared memory](https://en.wikipedia.org/wiki/Shared_memory); in   this model, only one MPI process per machine needs to store the data, and   all other processes could then access it.
*  Both of these use cases are enabled by the  [2.x.11]  function that is internally based on  [2.x.12]  This function allows for workflows like the following where we put that MPI process with rank zero in charge of reading the data (but it could have been any other "root rank" as well):

* 
* [1.x.2]
* 
*  The last call in this code snippet makes sure that the data is made available on all non-root processes, either by re-creating a copy of the table in the other processes' memory space or, if possible, by creating copies in shared memory once for all processes located on each of the machines used by the MPI job.
* 

* 
*  [2.x.13] 

* 
* [0.x.21]*
   Integer type used to count the number of elements in this container.  
* [0.x.22]*
   Default constructor. Set all dimensions to zero.  
* [0.x.23]*
   Constructor. Initialize the array with the given dimensions in each index   component.  
* [0.x.24]*
   Constructor. Initialize the array with the given dimensions in each index   component, and then initialize the elements of the table using the second   and third argument by calling fill(entries,C_style_indexing).  
* [0.x.25]*
   Copy constructor. Performs a deep copy.  
* [0.x.26]*
   Copy constructor. Performs a deep copy from a table object storing some   other data type.  
* [0.x.27]*
   Move constructor. Transfers the contents of another Table.  
* [0.x.28]*
   Destructor. Free allocated memory.  
* [0.x.29]*
   Assignment operator. Copy all elements of <tt>src</tt> into the matrix.   The size is adjusted if needed.     We can't use the other, templatized version since if we don't declare   this one, the compiler will happily generate a predefined copy operator   which is not what we want.  
* [0.x.30]*
   Copy operator. Copy all elements of <tt>src</tt> into the array. The size   is adjusted if needed.     This function requires that the type <tt>T2</tt> is convertible to   <tt>T</tt>.  
* [0.x.31]*
   Move assignment operator. Transfer all elements of <tt>src</tt> into the   table.  
* [0.x.32]*
   Test for equality of two tables.  
* [0.x.33]*
   Set all entries to their default value (i.e. copy them over with default   constructed objects). Do not change the size of the table, though.  
* [0.x.34]*
   Set the dimensions of this object to the sizes given in the first   argument, and allocate the required memory for table entries to   accommodate these sizes. If  [2.x.14]    is set to  [2.x.15]  all elements of the table are set to a   default constructed object for the element type. Otherwise the   memory is left in an uninitialized or otherwise undefined state.  
* [0.x.35]*
   Size of the table in direction <tt>i</tt>.  
* [0.x.36]*
   Return the sizes of this object in each direction.  
* [0.x.37]*
   Return the number of elements stored in this object, which is the product   of the extensions in each dimension.  
* [0.x.38]*
   Return whether the object is empty, i.e. one of the directions is zero.   This is equivalent to <tt>n_elements()==0</tt>.  
* [0.x.39]*
   Fill this table (which is assumed to already have the correct size) from   a source given by dereferencing the given forward iterator (which could,   for example, be a pointer to the first element of an array, or an   inserting  [2.x.16]  The second argument denotes whether the   elements pointed to are arranged in a way that corresponds to the last   index running fastest or slowest. The default is to use C-style indexing   where the last index runs fastest (as opposed to Fortran-style where the   first index runs fastest when traversing multidimensional arrays. For   example, if you try to fill an object of type Table<2,T>, then calling   this function with the default value for the second argument will result   in the equivalent of doing  
* [1.x.3]
*    On the other hand, if the second argument to this function is false, then   this would result in code of the following form:  
* [1.x.4]
*    Note the switched order in which we fill the table elements by traversing   the given set of iterators.      [2.x.17]  entries An iterator to a set of elements from which to initialize   this table. It is assumed that iterator can be incremented and   dereferenced a sufficient number of times to fill this table.    [2.x.18]  C_style_indexing If true, run over elements of the table with the   last index changing fastest as we dereference subsequent elements of the   input range. If false, change the first index fastest.  
* [0.x.40]*
   Fill all table entries with the same value.  
* [0.x.41]*
   Return a read-write reference to the indicated element.  
* [0.x.42]*
   Return the value of the indicated element as a read-only reference.     We return the requested value as a constant reference rather than by   value since this object may hold data types that may be large, and we   don't know here whether copying is expensive or not.  
* [0.x.43]*
   This function replicates the state found on the process indicated by    [2.x.19]  across all processes of the MPI communicator. The current   state found on any of the processes other than  [2.x.20]  is lost   in this process. One can imagine this operation to act like a call to    [2.x.21]  from the root process to all other processes,   though in practice the function may try to move the data into shared   memory regions on each of the machines that host MPI processes and   let all MPI processes on this machine then access this shared memory   region instead of keeping their own copy. See the general documentation   of this class for a code example.     The intent of this function is to quickly exchange large arrays from   one process to others, rather than having to compute or create it on   all processes. This is specifically the case for data loaded from   disk
* 
*  -  say, large data tables
* 
*  -  that are more easily dealt with by   reading once and then distributing across all processes in an MPI   universe, than letting each process read the data from disk itself.   Specifically, the use of shared memory regions allows for replicating   the data only once per multicore machine in the MPI universe, rather   than replicating data once for each MPI process. This results in   large memory savings if the data is large on today's machines that   can easily house several dozen MPI processes per shared memory   space.     This function does not imply a model of keeping data on different processes   in sync, as  [2.x.22]  and other vector classes do where   there exists a notion of certain elements of the vector owned by each   process and possibly ghost elements that are mirrored from its owning   process to other processes. Rather, the elements of the current object are   simply copied to the other processes, and it is useful to think of this   operation as creating a set of `const` AlignedVector objects on all   processes that should not be changed any more after the replication   operation, as this is the only way to ensure that the vectors remain the   same on all processes. This is particularly true because of the use of   shared memory regions where any modification of a vector element on one MPI   process may also result in a modification of elements visible on other   processes, assuming they are located within one shared memory node.    
*  [2.x.23]  The use of shared memory between MPI processes requires     that the detected MPI installation supports the necessary operations.     This is the case for MPI 3.0 and higher.    
*  [2.x.24]  This function is not cheap. It needs to create sub-communicators     of the provided  [2.x.25]  object, which is generally an expensive     operation. Likewise, the generation of shared memory spaces is not     a cheap operation. As a consequence, this function primarily makes     sense when the goal is to share large read-only data tables among     processes; examples are data tables that are loaded at start-up     time and then used over the course of the run time of the program.     In such cases, the start-up cost of running this function can be     amortized over time, and the potential memory savings from not having to     store the table on each process may be substantial on machines with     large core counts on which many MPI processes run on the same machine.    
*  [2.x.26]  This function only makes sense if the data type `T` is     "self-contained", i.e., all of its information is stored in its     member variables, and if none of the member variables are pointers     to other parts of the memory. This is because if a type `T` does     have pointers to other parts of memory, then moving `T` into     a shared memory space does not result in the other processes having     access to data that the object points to with its member variable     pointers: These continue to live only on one process, and are     typically in memory areas not accessible to the other processes.     As a consequence, the usual use case for this function is to share     arrays of simple objects such as `double`s or `int`s.    
*  [2.x.27]  After calling this function, objects on different MPI processes     share a common state. That means that certain operations become     "collective", i.e., they must be called on all participating     processors at the same time. In particular, you can no longer call     resize(), reserve(), or clear() on one MPI process
* 
*  -  you have to do     so on all processes at the same time, because they have to communicate     for these operations. If you do not do so, you will likely get     a deadlock that may be difficult to debug. By extension, this rule of     only collectively resizing extends to this function itself: You can     not call it twice in a row because that implies that first all but the     `root_process` throw away their data, which is not a collective     operation. Generally, these restrictions on what can and can not be     done hint at the correctness of the comments above: You should treat     an AlignedVector on which the current function has been called as     `const`, on which no further operations can be performed until     the destructor is called.  
* [0.x.44]*
   Swap the contents of this table and the other table  [2.x.28]  One could do   this operation with a temporary variable and copying over the data   elements, but this function is significantly more efficient since it only   swaps the pointers to the data of the two vectors and therefore does not   need to allocate temporary storage and move data around.     This function is analogous to the  [2.x.29]  function of all C++   standard containers. Also, there is a global function <tt>swap(u,v)</tt>   that simply calls <tt>u.swap(v)</tt>, again in analogy to standard   functions.  
* [0.x.45]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.46]*
   Write or read the data of this object to or from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.47]*
   Return the position of the indicated element within the array of elements   stored one after the other. This function does no index checking.  
* [0.x.48]*
   Return a read-write reference to the indicated element.     This function does no bounds checking and is only to be used internally   and in functions already checked.  
* [0.x.49]*
   Return the value of the indicated element as a read-only reference.     This function does no bounds checking and is only to be used internally   and in functions already checked.     We return the requested value as a constant reference rather than by   value since this object may hold data types that may be large, and we   don't know here whether copying is expensive or not.  
* [0.x.50]*
   Component-array.  
* [0.x.51]*
   Size in each direction of the table.  
* [0.x.52]*
 A class representing a table with arbitrary but fixed number of indices. This general template implements some additional functions over those provided by the TableBase class, such as indexing functions taking the correct number of arguments, etc.
*  Rather than this general template, these functions are implemented in partial specializations of this class, with fixed numbers of dimensions. See there, and in the documentation of the base class for more information.
* 

* 
*  [2.x.30] 

* 
* [0.x.53]*
 A class representing a one-dimensional table, i.e. a vector-like class. The majority of the interface of this class is implemented in the TableBase base class. See there for an outline of the rationale for and interface of this class.
* 

* 
*  [2.x.31] 

* 
* [0.x.54]*
   Integer type used to count the number of elements in this container.  
* [0.x.55]*
   Default constructor. Set all dimensions to zero.  
* [0.x.56]*
   Constructor. Pass down the given dimension to the base class.  
* [0.x.57]*
   Constructor. Create a table with a given size and initialize it from a   set of iterators.     This function is entirely equivalent to creating a table  [2.x.32]    of the given size and then calling  
* [1.x.5]
*    on it, using the  [2.x.33]  function where the arguments are   explained in more detail. The point, however, is that that is only   possible if the table can be changed after running the constructor,   whereas calling the current constructor allows sizing and initializing an   object right away so that it can be marked const.     Using this constructor, you can do things like this:  
* [1.x.6]
*    You can also initialize a table right from a file, using input iterators:  
* [1.x.7]
*         [2.x.34]  size The size of this one-dimensional table.    [2.x.35]  entries An iterator to a set of elements from which to initialize   this table. It is assumed that iterator can be incremented and   dereferenced a sufficient number of times to fill this table.    [2.x.36]  C_style_indexing If true, run over elements of the table with the   last index changing fastest as we dereference subsequent elements of the   input range. If false, change the first index fastest.  
* [0.x.58]*
   Access operator. Since this is a one-dimensional object, this simply   accesses the requested data element. Returns a read-only reference.  
* [0.x.59]*
   Access operator. Since this is a one-dimensional object, this simply   accesses the requested data element. Returns a read-write reference.  
* [0.x.60]*
   Access operator. Since this is a one-dimensional object, this simply   accesses the requested data element. Returns a read-only reference.  
* [0.x.61]*
   Access operator. Since this is a one-dimensional object, this simply   accesses the requested data element. Returns a read-write reference.  
* [0.x.62]*
   Make the variations of `operator()` from the base class available.  
* [0.x.63]*
 A namespace for iterators and accessors for Table<2, T> and TransposeTable. These classes have special accessors (that is, compared to Table<3, T>) since they have a matrix-like structure; i.e., the accessors also provide row and column information and are designed to be compatible with the SparseMatrix and SparsityPattern iterator classes.

* 
* [0.x.64]*
  
*  [2.x.37]    layout) of a table class.  
* [0.x.65]*
     The data are organized in row-major (i.e., C-style) order.    
* [0.x.66]*
     The data are organized in column-major (i.e., Fortran-style) order.    
* [0.x.67]*
  
*  [2.x.38]    both values of  [2.x.39] .  
* [0.x.68]*
  
*  [2.x.40]      This class is compatible with the requirements for an %Accessor described   in LinearIndexIterator: See the documentation of that class for a   description of the split between iterators and accessors.      [2.x.41]  TableType the type of the %Table, e.g., Table<2, T> or   TransposeTable.      [2.x.42]  Constness whether or not this object stores a constant pointer   and can modify the provided table object.      [2.x.43]  storage_order The storage scheme of the underlying table, e.g.,    [2.x.44]  for Table<2, T>.  
* [0.x.69]*
     Type of the stored pointer to the table.    
* [0.x.70]*
     Value type of the underlying container.    
* [0.x.71]*
     Numerical type of the row and column indices of the table.    
* [0.x.72]*
     Default constructor.    
* [0.x.73]*
     Constructor setting up the end iterator.    
* [0.x.74]*
     Copy constructor from a non-const Accessor.    
* [0.x.75]*
     Constructor taking an array index.    
* [0.x.76]*
     Comparison operator.    
* [0.x.77]*
     Get a constant reference to the value of the element represented by     this accessor.    
* [0.x.78]*
     Conversion operator that returns a constant reference to the element.    
* [0.x.79]*
     Return the row of the current entry.    
* [0.x.80]*
     Return the column of the current entry.    
* [0.x.81]*
     Pointer to the table.    
* [0.x.82]*
     Current index.    
* [0.x.83]*
     Check that  [2.x.45]  corresponds to an entry that is     actually stored by the table (i.e., assert that      [2.x.46]  is nonnegative and less than      [2.x.47] ).    
* [0.x.84]*
  
*  [2.x.48]    table. This is the same as the base class.  
* [0.x.85]*
     Use the base class value type.    
* [0.x.86]*
     Use the base class size type.    
* [0.x.87]*
     Inherit the base class constructors.    
* [0.x.88]*
  
*  [2.x.49]    a table.  
* [0.x.89]*
     Use the base class value type.    
* [0.x.90]*
     Use the base class size type.    
* [0.x.91]*
     Inherit the base class constructors.    
* [0.x.92]*
     Assignment operator. This assigns a new value to the table entry at the     current row and column coordinates.    
* [0.x.93]*
     Move assignment operator. This assigns a new value to the table entry at     the current row and column coordinates.    
* [0.x.94]*
     Since we overload value() we have to explicitly use the base class     version.    
* [0.x.95]*
     Get a reference to the value of the element represented by     this accessor.    
* [0.x.96]*
     Conversion operator that returns a reference to the element.    
* [0.x.97]*
  
*  [2.x.50]    TransposeTable.      [2.x.51]  TableType the type of the %Table, e.g., Table<2, T> or   TransposeTable.      [2.x.52]  Constness whether or not this is a constant iterator.      [2.x.53]  storage_order The storage scheme of the underlying table, e.g.,    [2.x.54]  for Table<2, T>.  
* [0.x.98]*
     Size type used by the underlying table.    
* [0.x.99]*
     Type of the stored pointer to the table.    
* [0.x.100]*
     Constructor from an accessor.    
* [0.x.101]*
     Constructor. Create the end iterator for a table.    
* [0.x.102]*
     Constructor for a particular table entry.    
* [0.x.103]*
     Copy constructor from a non-const iterator.    
* [0.x.104]*
     Constructor for an entry with a particular linear index.    
* [0.x.105]*
 A class representing a two-dimensional table, i.e. a matrix of objects (not necessarily only numbers). The majority of the interface of this class is implemented in the TableBase base class. See there for an outline of the rationale for and interface of this class.
*  This class also serves as the base class for the FullMatrix class and consequently has a number of functions that are specific to matrices and their needs.
* 

* 
*  [2.x.55] 

* 
* [0.x.106]*
   Integer type used to count the number of elements in this container.  
* [0.x.107]*
   Typedef for the values in the table.  
* [0.x.108]*
   Typedef for the references in the table.  
* [0.x.109]*
   Typedef for the constant references in the table.  
* [0.x.110]*
   Typedef for a constant iterator that traverses the table in column-major   order.  
* [0.x.111]*
   Typedef for an iterator that traverses the table in column-major order.  
* [0.x.112]*
   Default constructor. Set all dimensions to zero.  
* [0.x.113]*
   Constructor. Pass down the given dimensions to the base class.  
* [0.x.114]*
   Constructor. Create a table with a given size and initialize it from a   set of iterators.     This function is entirely equivalent to creating a table  [2.x.56]    of the given size and then calling  
* [1.x.8]
*    on it, using the  [2.x.57]  function where the arguments are   explained in more detail. The point, however, is that that is only   possible if the table can be changed after running the constructor,   whereas calling the current constructor allows sizing and initializing an   object right away so that it can be marked const.     Using this constructor, you can do things like this:  
* [1.x.9]
*    You can also initialize a table right from a file, using input iterators:  
* [1.x.10]
*         [2.x.58]  size1 The size of this table in the first dimension.    [2.x.59]  size2 The size of this table in the second dimension.    [2.x.60]  entries An iterator to a set of elements from which to initialize   this table. It is assumed that iterator can be incremented and   dereferenced a sufficient number of times to fill this table.    [2.x.61]  C_style_indexing If true, run over elements of the table with the   last index changing fastest as we dereference subsequent elements of the   input range. If false, change the first index fastest.  
* [0.x.115]*
   Reinitialize the object. This function is mostly here for compatibility   with the earlier <tt>vector2d</tt> class. Passes down to the base class   by converting the arguments to the data type requested by the base class.  
* [0.x.116]*
   Access operator. Generate an object that accesses the requested row of   this two-dimensional table. Range checks are performed.     This version of the function only allows read access.  
* [0.x.117]*
   Access operator. Generate an object that accesses the requested row of   this two-dimensional table. Range checks are performed.     This version of the function allows read-write access.  
* [0.x.118]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function only allows read access.  
* [0.x.119]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function allows read-write access.  
* [0.x.120]*
   Make the variations of `operator()` from the base class available.  
* [0.x.121]*
   Number of rows. This function really makes only sense since we have a   two-dimensional object here.  
* [0.x.122]*
   Number of columns. This function really makes only sense since we have a   two-dimensional object here.  
* [0.x.123]*
   Return an iterator pointing to the first entry.  
* [0.x.124]*
   Return a constant iterator pointing to the first entry.  
* [0.x.125]*
   Return an iterator pointing to one past the last entry.  
* [0.x.126]*
   Return a constant iterator pointing to one past the last entry.  
* [0.x.127]*
   Return a read-write reference to the element <tt>(i,j)</tt>.     This function does no bounds checking and is only to be used internally   and in functions already checked.     These functions are mainly here for compatibility with a former   implementation of these table classes for 2d arrays, then called   <tt>vector2d</tt>.  
* [0.x.128]*
   Return the value of the element <tt>(i,j)</tt> as a read-only reference.     This function does no bounds checking and is only to be used internally   and in functions already checked.     We return the requested value as a constant reference rather than by   value since this object may hold data types that may be large, and we   don't know here whether copying is expensive or not.     These functions are mainly here for compatibility with a former   implementation of these table classes for 2d arrays, then called   <tt>vector2d</tt>.  
* [0.x.129]*
 A class representing a three-dimensional table of objects (not necessarily only numbers). The majority of the interface of this class is implemented in the TableBase base class.See there for an outline of the rationale for and interface of this class.
* 

* 
*  [2.x.62] 

* 
* [0.x.130]*
   Integer type used to count the number of elements in this container.  
* [0.x.131]*
   Default constructor. Set all dimensions to zero.  
* [0.x.132]*
   Constructor. Pass down the given dimensions to the base class.  
* [0.x.133]*
   Constructor. Create a table with a given size and initialize it from a   set of iterators.     This function is entirely equivalent to creating a table  [2.x.63]    of the given size and then calling  
* [1.x.11]
*    on it, using the  [2.x.64]  function where the arguments are   explained in more detail. The point, however, is that that is only   possible if the table can be changed after running the constructor,   whereas calling the current constructor allows sizing and initializing an   object right away so that it can be marked const.     Using this constructor, you can do things like this (shown here for a   two-dimensional table, but the same works for the current class):  
* [1.x.12]
*    You can also initialize a table right from a file, using input iterators:  
* [1.x.13]
*         [2.x.65]  size1 The size of this table in the first dimension.    [2.x.66]  size2 The size of this table in the second dimension.    [2.x.67]  size3 The size of this table in the third dimension.    [2.x.68]  entries An iterator to a set of elements from which to initialize   this table. It is assumed that iterator can be incremented and   dereferenced a sufficient number of times to fill this table.    [2.x.69]  C_style_indexing If true, run over elements of the table with the   last index changing fastest as we dereference subsequent elements of the   input range. If false, change the first index fastest.  
* [0.x.134]*
   Access operator. Generate an object that accesses the requested two-   dimensional subobject of this three-dimensional table. Range checks are   performed.     This version of the function only allows read access.  
* [0.x.135]*
   Access operator. Generate an object that accesses the requested two-   dimensional subobject of this three-dimensional table. Range checks are   performed.     This version of the function allows read-write access.  
* [0.x.136]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function only allows read access.  
* [0.x.137]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function allows read-write access.  
* [0.x.138]*
   Make the variations of `operator()` from the base class available.  
* [0.x.139]*
 A class representing a four-dimensional table of objects (not necessarily only numbers). The majority of the interface of this class is implemented in the TableBase base class. See there for an outline of the rationale for and interface of this class.
* 

* 
*  [2.x.70] 

* 
* [0.x.140]*
   Integer type used to count the number of elements in this container.  
* [0.x.141]*
   Default constructor. Set all dimensions to zero.  
* [0.x.142]*
   Constructor. Pass down the given dimensions to the base class.  
* [0.x.143]*
   Access operator. Generate an object that accesses the requested three-   dimensional subobject of this four-dimensional table. Range checks are   performed.     This version of the function only allows read access.  
* [0.x.144]*
   Access operator. Generate an object that accesses the requested three-   dimensional subobject of this four-dimensional table. Range checks are   performed.     This version of the function allows read-write access.  
* [0.x.145]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function only allows read access.  
* [0.x.146]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function allows read-write access.  
* [0.x.147]*
   Make the variations of `operator()` from the base class available.  
* [0.x.148]*
 A class representing a five-dimensional table of objects (not necessarily only numbers). The majority of the interface of this class is implemented in the TableBase base class. See there for an outline of the rationale for and interface of this class.
* 

* 
*  [2.x.71] 

* 
* [0.x.149]*
   Integer type used to count the number of elements in this container.  
* [0.x.150]*
   Default constructor. Set all dimensions to zero.  
* [0.x.151]*
   Constructor. Pass down the given dimensions to the base class.  
* [0.x.152]*
   Access operator. Generate an object that accesses the requested four-   dimensional subobject of this five-dimensional table. Range checks are   performed.     This version of the function only allows read access.  
* [0.x.153]*
   Access operator. Generate an object that accesses the requested four-   dimensional subobject of this five-dimensional table. Range checks are   performed.     This version of the function allows read-write access.  
* [0.x.154]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function only allows read access.  
* [0.x.155]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function allows read-write access.  
* [0.x.156]*
   Make the variations of `operator()` from the base class available.  
* [0.x.157]*
 A class representing a six-dimensional table of objects (not necessarily only numbers). The majority of the interface of this class is implemented in the TableBase base class. See there for an outline of the rationale for and interface of this class.
* 

* 
*  [2.x.72] 

* 
* [0.x.158]*
   Integer type used to count the number of elements in this container.  
* [0.x.159]*
   Default constructor. Set all dimensions to zero.  
* [0.x.160]*
   Constructor. Pass down the given dimensions to the base class.  
* [0.x.161]*
   Access operator. Generate an object that accesses the requested five-   dimensional subobject of this six-dimensional table. Range checks are   performed.     This version of the function only allows read access.  
* [0.x.162]*
   Access operator. Generate an object that accesses the requested five-   dimensional subobject of this six-dimensional table. Range checks are   performed.     This version of the function allows read-write access.  
* [0.x.163]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function only allows read access.  
* [0.x.164]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function allows read-write access.  
* [0.x.165]*
   Make the variations of `operator()` from the base class available.  
* [0.x.166]*
 A class representing a seven-dimensional table of objects (not necessarily only numbers). The majority of the interface of this class is implemented in the TableBase base class. See there for an outline of the rationale for and interface of this class.
* 

* 
*  [2.x.73] 

* 
* [0.x.167]*
   Integer type used to count the number of elements in this container.  
* [0.x.168]*
   Default constructor. Set all dimensions to zero.  
* [0.x.169]*
   Constructor. Pass down the given dimensions to the base class.  
* [0.x.170]*
   Access operator. Generate an object that accesses the requested six-   dimensional subobject of this seven-dimensional table. Range checks are   performed.     This version of the function only allows read access.  
* [0.x.171]*
   Access operator. Generate an object that accesses the requested six-   dimensional subobject of this seven-dimensional table. Range checks are   performed.     This version of the function allows read-write access.  
* [0.x.172]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function only allows read access.  
* [0.x.173]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function allows read-write access.  
* [0.x.174]*
   Make the variations of `operator()` from the base class available.  
* [0.x.175]*
 A class representing a transpose two-dimensional table, i.e. a matrix of objects (not necessarily only numbers) in column first numbering (FORTRAN convention). The only real difference is therefore really in the storage format.
*  This class copies the functions of Table<2,T>, but the element access and the dimensions will be for the transpose ordering of the data field in TableBase.
* 

* 
*  [2.x.74] 

* 
* [0.x.176]*
   Integer type used to count the number of elements in this container.  
* [0.x.177]*
   Typedef for the values in the table.  
* [0.x.178]*
   Typedef for the references in the table.  
* [0.x.179]*
   Typedef for the constant references in the table.  
* [0.x.180]*
   Typedef for a constant iterator that traverses the table in column-major   order.  
* [0.x.181]*
   Typedef for an iterator that traverses the table in column-major order.  
* [0.x.182]*
   Default constructor. Set all dimensions to zero.  
* [0.x.183]*
   Constructor. Pass down the given dimensions to the base class.  
* [0.x.184]*
   Reinitialize the object. This function is mostly here for compatibility   with the earlier <tt>vector2d</tt> class. Passes down to the base class   by converting the arguments to the data type requested by the base class.  
* [0.x.185]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function only allows read access.  
* [0.x.186]*
   Direct access to one element of the table by specifying all indices at   the same time. Range checks are performed.     This version of the function allows read-write access.  
* [0.x.187]*
   Number of rows. This function really makes only sense since we have a   two-dimensional object here.  
* [0.x.188]*
   Number of columns. This function really makes only sense since we have a   two-dimensional object here.  
* [0.x.189]*
   Return an iterator pointing to the first entry.  
* [0.x.190]*
   Return a constant iterator pointing to the first entry.  
* [0.x.191]*
   Return an iterator pointing to one past the last entry.  
* [0.x.192]*
   Return a constant iterator pointing to one past the last entry.  
* [0.x.193]*
   Return a read-write reference to the element <tt>(i,j)</tt>.     This function does no bounds checking and is only to be used internally   and in functions already checked.     These functions are mainly here for compatibility with a former   implementation of these table classes for 2d arrays, then called   <tt>vector2d</tt>.  
* [0.x.194]*
   Return the value of the element <tt>(i,j)</tt> as a read-only reference.     This function does no bounds checking and is only to be used internally   and in functions already checked.     We return the requested value as a constant reference rather than by   value since this object may hold data types that may be large, and we   don't know here whether copying is expensive or not.     These functions are mainly here for compatibility with a former   implementation of these table classes for 2d arrays, then called   <tt>vector2d</tt>.  
* [0.x.195]*
 Global function  [2.x.75]  which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two tables.

* 
* [0.x.196]

include/deal.II-translator/base/table_indices_0.txt
[0.x.0]*
 A class representing a fixed size array of indices.
*  It is used in tensorial objects like the TableBase and SymmetricTensor classes to represent a nested choice of indices.
*   [2.x.0]  N The number of indices stored in each object.
* 

* 
*  [2.x.1] 

* 
* [0.x.1]*
   Default constructor. This constructor sets all indices to zero.  
* [0.x.2]*
   Constructor. Initializes the indices stored by this object by the given   arguments  [2.x.2]      This constructor will result in a compiler error if   the template argument  [2.x.3]  is different from the number of the arguments.  
* [0.x.3]*
   Read-only access the value of the <tt>i</tt>th index.  
* [0.x.4]*
   Write access the value of the <tt>i</tt>th index.  
* [0.x.5]*
   Compare two index fields for equality.  
* [0.x.6]*
   Compare two index fields for inequality.  
* [0.x.7]*
   Sort the indices in ascending order. While this operation is not very   useful for Table objects, it is used for the SymmetricTensor class.  
* [0.x.8]*
   Write or read the data of this object to or from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.9]*
   Store the indices in an array.  
* [0.x.10]*
 Output operator for TableIndices objects; reports them in a list like this:  [2.x.4] .
*   [2.x.5]  TableIndices

* 
* [0.x.11]

include/deal.II-translator/base/template_constraints_0.txt
[0.x.0]*
     A helper class whose `value` member is true or false depending on     whether all of the given boolean template arguments are true.    
* [0.x.1]*
 This struct is a generalization of  [2.x.0]  Derived> to template parameter packs and tests if all of the Derived... classes have Base as base class or are Base itself. The result is stored in the member variable value.

* 
* [0.x.2]*
 This struct is a generalization of  [2.x.1]  to template parameter packs and tests if all of the types in the `Types...` parameter pack are equal to the `Type` given as first template argument. The result is stored in the member variable value.

* 
* [0.x.3] A generalization of  [2.x.2]  that only works if [1.x.0] of the given boolean template parameters are true.

* 
* [0.x.4]*
 A type trait that checks to see if a class behaves as an iterable container that has a beginning and an end. This implies that the class either defines the `begin()` and `end()` functions, or is a C-style array.

* 
* [0.x.5]*
 A template class that simply exports its template argument as a local alias. This class, while at first appearing useless, makes sense in the following context: if you have a function template as follows:

* 
* [1.x.1]
*  then it can't be called in an expression like  [2.x.3]  because the type  [2.x.4]  of the template can not be deduced in a unique way from the types of the arguments. However, if the template is written as

* 
* [1.x.2]
*  then the call becomes valid: the type  [2.x.5]  is not deducible from the second argument to the function, so only the first argument participates in template type resolution.
*  The context for this feature is as follows: consider

* 
* [1.x.3]
*  This code fails to compile because the compiler can't decide whether the template type  [2.x.6]  (from the signature of the function given as first argument to  [2.x.7]  because the expression  [2.x.8]  has that type. Of course, what we would like the compiler to do is simply cast the  [2.x.9] . We can achieve this by writing the code as follows:

* 
* [1.x.4]
* 

* 
* [0.x.6]*
 A class that always returns a given value. This is needed as a workaround for lambdas used as default parameters some compilers struggle to deal with.

* 
* [0.x.7]*
 A class to perform comparisons of arbitrary pointers for equality. In some circumstances, one would like to make sure that two arguments to a function are not the same object. One would, in this case, make sure that their addresses are not the same. However, sometimes the types of these two arguments may be template types, and they may be the same type or not. In this case, a simple comparison as in <tt>&object1 != &object2</tt> does only work if the types of the two objects are equal, but the compiler will barf if they are not. However, in the latter case, since the types of the two objects are different, we can be sure that the two objects cannot be the same.
*  This class implements a comparison function that always returns  [2.x.10]  if the types of its two arguments are different, and returns <tt>p1 == p2</tt> otherwise.

* 
* [0.x.8]*
   Comparison function for pointers of the same type. Returns  [2.x.11]  if the   two pointers are equal.  
* [0.x.9]*
   Comparison function for pointers of different types. The C++ language   does not allow comparing these pointers using <tt>operator==</tt>.   However, since the two pointers have different types, we know that they   can't be the same, so we always return  [2.x.12]   
* [0.x.10]*
   A struct that implements the default product type resulting from the   multiplication of two types.    
*  [2.x.13]  Care should be taken when  [2.x.14]  or  [2.x.15]  have qualifiers ( [2.x.16]  or    [2.x.17]  or are  [2.x.18]  or  [2.x.19]  references! It is recommended   that specialization of this class is only made for unqualified (fully   stripped) types and that the ProductType class be used to determine the   result of operating with (potentially) qualified types.  
* [0.x.11]*
 A class with a local alias that represents the type that results from the product of two variables of type  [2.x.20]  and  [2.x.21]  In other words, we would like to infer the type of the  [2.x.22]  variable in code like this:

* 
* [1.x.5]
*  The local alias of this structure represents the type the variable  [2.x.23]  would have.
* 

*  [1.x.6]
*  The purpose of this class is principally to represent the type one needs to use to represent the values or gradients of finite element fields at quadrature points. For example, assume you are storing the values  [2.x.24]  of unknowns in a Vector<float>, then evaluating  [2.x.25]  at quadrature points results in values  [2.x.26]  that need to be stored as  [2.x.27]  variables because the  [2.x.28]  are  [2.x.29]  values and the  [2.x.30]  are computed as  [2.x.31]  values, and the product are then  [2.x.32]  values. On the other hand, if you store your unknowns  [2.x.33]  as  [2.x.34]  values and you try to evaluate  [2.x.35]  at quadrature points, then the gradients  [2.x.36]  need to be stored as objects of type  [2.x.37]  because that's what you get when you multiply a complex number by a  [2.x.38]  (the type used to represent the gradient of shape functions of scalar finite elements).
*  Likewise, if you are using a vector valued element (with dim components) and the  [2.x.39]  are stored as  [2.x.40]  variables, then  [2.x.41]  needs to have type  [2.x.42]  (because the shape functions have type  [2.x.43] ). Finally, if you store the  [2.x.44]  as objects of type  [2.x.45]  and you have a vector valued element, then the gradients  [2.x.46]  will result in objects of type  [2.x.47]   [2.x.48] 
*  In all of these cases, this type is used to identify which type needs to be used for the result of computing the product of unknowns and the values, gradients, or other properties of shape functions.

* 
* [0.x.12]*
 This class provides a local alias  [2.x.49]  that is equal to the template argument but only if the template argument corresponds to a scalar type (i.e., one of the floating point types, signed or unsigned integer, or a complex number). If the template type  [2.x.50]  is not a scalar, then no class  [2.x.51]  is declared and, consequently, no local alias is available.
*  The purpose of the class is to disable certain template functions if one of the arguments is not a scalar number. By way of (nonsensical) example, consider the following function:

* 
* [1.x.7]
*  This function can be called with any two arguments of the same type  [2.x.52]  This includes arguments for which this clearly makes no sense. Consequently, one may want to restrict the function to only scalars, and this can be written as

* 
* [1.x.8]
*  At a place where you call the function, the compiler will deduce the type  [2.x.53]  from the arguments. For example, in

* 
* [1.x.9]
*  it will deduce  [2.x.54]  to be  [2.x.55]  and because  [2.x.56]  equals  [2.x.57]  the compiler will instantiate a function <code>double multiply(const double, const double)</code> from the template above. On the other hand, in a context like

* 
* [1.x.10]
*  the compiler will deduce  [2.x.58]  to be  [2.x.59]  but because  [2.x.60]  does not exist the compiler does not consider the template for instantiation. This technique is called "Substitution Failure is not an Error (SFINAE)". It makes sure that the template function can not even be called, rather than leading to a later error about the fact that the operation  [2.x.61]  is not defined (or may lead to some nonsensical result). It also allows the declaration of overloads of a function such as  [2.x.62]  multiply for different types of arguments, without resulting in ambiguous call errors by the compiler.

* 
* [0.x.13]

include/deal.II-translator/base/tensor_0.txt
[0.x.0]*
 This class is a specialized version of the <tt>Tensor<rank,dim,Number></tt> class. It handles tensors of rank zero, i.e. scalars. The second template argument  [2.x.0]  is ignored.
*  This class exists because in some cases we want to construct objects of type Tensor [2.x.1]  which should expand to scalars, vectors, matrices, etc, depending on the values of the template arguments  [2.x.2]  and  [2.x.3]  We therefore need a class that acts as a scalar (i.e.  [2.x.4]  for all purposes but is part of the Tensor template family.
*   [2.x.5]  dim An integer that denotes the dimension of the space in which this tensor operates. This of course equals the number of coordinates that identify a point and rank-1 tensor. Since the current object is a rank-0 tensor (a scalar), this template argument has no meaning for this class.
*   [2.x.6]  Number The data type in which the tensor elements are to be stored. This will, in almost all cases, simply be the default  [2.x.7]  but there are cases where one may want to store elements in a different (and always scalar) type. It can be used to base tensors on  [2.x.8]  or  [2.x.9]  numbers or any other data type that implements basic arithmetic operations. Another example would be a type that allows for Automatic Differentiation (see, for example, the Sacado type used in  [2.x.10] ) and thereby can generate analytic (spatial) derivatives of a function that takes a tensor as argument.
* 

* 
*  [2.x.11] 

* 
* [0.x.1]*
   Provide a way to get the dimension of an object without explicit   knowledge of it's data type. Implementation is this way instead of   providing a function <tt>dimension()</tt> because now it is possible to   get the dimension at compile time without the expansion and preevaluation   of an inlined function; the compiler may therefore produce more efficient   code and you may use this value to declare other data types.  
* [0.x.2]*
   Publish the rank of this tensor to the outside world.  
* [0.x.3]*
   Number of independent components of a tensor of rank 0.  
* [0.x.4]*
   Declare a type that has holds real-valued numbers with the same precision   as the template argument to this class. For  [2.x.12]  this   corresponds to type number, and it is equal to Number for all other   cases. See also the respective field in Vector<Number>.     This alias is used to represent the return type of norms.  
* [0.x.5]*
   Type of objects encapsulated by this container and returned by   operator[](). This is a scalar number type for a rank 0 tensor.  
* [0.x.6]*
   Declare an array type which can be used to initialize an object of this   type statically. In case of a tensor of rank 0 this is just the scalar   number type Number.  
* [0.x.7]*
   Constructor. Set to zero.    
*  [2.x.13]  This function can also be used in CUDA device code.  
* [0.x.8]*
   Constructor from tensors with different underlying scalar type. This   obviously requires that the  [2.x.14]  type is convertible to  [2.x.15]    Number.    
*  [2.x.16]  This function can also be used in CUDA device code.  
* [0.x.9]*
   Constructor, where the data is copied from a C-style array.    
*  [2.x.17]  This function can also be used in CUDA device code.  
* [0.x.10]*
   Copy constructor  
* [0.x.11]*
   Copy assignment operator  
* [0.x.12]*
   Move constructor  
* [0.x.13]*
   Move assignment operator  
* [0.x.14]*
   Return a pointer to the first element of the underlying storage.  
* [0.x.15]*
   Return a const pointer to the first element of the underlying storage.  
* [0.x.16]*
   Return a pointer to the element past the end of the underlying storage.  
* [0.x.17]*
   Return a const pointer to the element past the end of the underlying   storage.  
* [0.x.18]*
   Return a reference to the encapsulated Number object. Since rank-0   tensors are scalars, this is a natural operation.     This is the non-const conversion operator that returns a writable   reference.    
*  [2.x.18]  This function can also be used in CUDA device code.  
* [0.x.19]*
   Return a reference to the encapsulated Number object. Since rank-0   tensors are scalars, this is a natural operation.     This is the const conversion operator that returns a read-only reference.    
*  [2.x.19]  This function can also be used in CUDA device code.  
* [0.x.20]*
   Assignment from tensors with different underlying scalar type. This   obviously requires that the  [2.x.20]  type is convertible to  [2.x.21]    Number.    
*  [2.x.22]  This function can also be used in CUDA device code.  
* [0.x.21]*
   This operator assigns a scalar to a tensor. This obviously requires   that the  [2.x.23]  type is convertible to  [2.x.24]     
*  [2.x.25]  This function can also be used in CUDA device code.  
* [0.x.22]*
   Test for equality of two tensors.  
* [0.x.23]*
   Test for inequality of two tensors.  
* [0.x.24]*
   Add another scalar.    
*  [2.x.26]  This function can also be used in CUDA device code.  
* [0.x.25]*
   Subtract another scalar.    
*  [2.x.27]  This function can also be used in CUDA device code.  
* [0.x.26]*
   Multiply the scalar with a <tt>factor</tt>.    
*  [2.x.28]  This function can also be used in CUDA device code.  
* [0.x.27]*
   Divide the scalar by <tt>factor</tt>.    
*  [2.x.29]  This function can also be used in CUDA device code.  
* [0.x.28]*
   Tensor with inverted entries.    
*  [2.x.30]  This function can also be used in CUDA device code.  
* [0.x.29]*
   Reset all values to zero.     Note that this is partly inconsistent with the semantics of the  [2.x.31]    clear() member functions of the standard library containers and of   several other classes within deal.II, which not only reset the values of   stored elements to zero, but release all memory and return the object   into a virginial state. However, since the size of objects of the present   type is determined by its template parameters, resizing is not an option,   and indeed the state where all elements have a zero value is the state   right after construction of such an object.  
* [0.x.30]*
   Return the Frobenius-norm of a tensor, i.e. the square root of the sum of   the absolute squares of all entries. For the present case of rank-1   tensors, this equals the usual <tt>l<sub>2</sub></tt> norm of the vector.  
* [0.x.31]*
   Return the square of the Frobenius-norm of a tensor, i.e. the sum of the   absolute squares of all entries.    
*  [2.x.32]  This function can also be used in CUDA device code.  
* [0.x.32]*
   Read or write the data of this object to or from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.33]*
   Internal type declaration that is used to specialize the return type of   operator[]() for Tensor<1,dim,Number>  
* [0.x.34]*
   The value of this scalar object.  
* [0.x.35]*
   Internal helper function for unroll.  
* [0.x.36]*
 A general tensor class with an arbitrary rank, i.e. with an arbitrary number of indices. The Tensor class provides an indexing operator and a bit of infrastructure, but most functionality is recursively handed down to tensors of rank 1 or put into external templated functions, e.g. the <tt>contract</tt> family.
*  The rank of a tensor specifies which types of physical quantities it can represent:  [2.x.33]     [2.x.34]  A rank-0 tensor is a scalar that can store quantities such as     temperature or pressure. These scalar quantities are shown in this     documentation as simple lower-case Latin letters e.g.  [2.x.35] .    [2.x.36]     [2.x.37]  A rank-1 tensor is a vector with  [2.x.38]  components and it can     represent vector quantities such as velocity, displacement, electric     field, etc. They can also describe the gradient of a scalar field.     The notation used for rank-1 tensors is bold-faced lower-case Latin     letters e.g.  [2.x.39] .     The components of a rank-1 tensor such as  [2.x.40]  are represented     as  [2.x.41]  where  [2.x.42]  is an index between 0 and <tt>dim-1</tt>.    [2.x.43]     [2.x.44]  A rank-2 tensor is a linear operator that can transform a vector     into another vector. These tensors are similar to matrices with      [2.x.45]  components. There is a related class     SymmetricTensor<2,dim> for tensors of rank 2 whose elements are     symmetric. Rank-2 tensors are usually denoted by bold-faced upper-case     Latin letters such as  [2.x.46]  or bold-faced Greek     letters for example  [2.x.47] .     The components of a rank 2 tensor such as  [2.x.48]  are shown with     two indices  [2.x.49]  as  [2.x.50] . These tensors usually describe the     gradients of vector fields (deformation gradient, velocity gradient,     etc.) or Hessians of scalar fields. Additionally, mechanical stress     tensors are rank-2 tensors that map the unit normal vectors of internal     surfaces into local traction (force per unit area) vectors.    [2.x.51]     [2.x.52]  Tensors with ranks higher than 2 are similarly defined in a     consistent manner. They have  [2.x.53]  components and     the number of indices required to identify a component equals     <tt>rank</tt>. For rank-4 tensors, a symmetric variant called     SymmetricTensor<4,dim> exists.    [2.x.54]   [2.x.55] 
*  Using this tensor class for objects of rank 2 has advantages over matrices in many cases since the dimension is known to the compiler as well as the location of the data. It is therefore possible to produce far more efficient code than for matrices with runtime-dependent dimension. It also makes the code easier to read because of the semantic difference between a tensor (an object that relates to a coordinate system and has transformation properties with regard to coordinate rotations and transforms) and matrices (which we consider as operators on arbitrary vector spaces related to linear algebra things).
*   [2.x.56]  rank_ An integer that denotes the rank of this tensor. A specialization of this class exists for rank-0 tensors.
*   [2.x.57]  dim An integer that denotes the dimension of the space in which this tensor operates. This of course equals the number of coordinates that identify a point and rank-1 tensor.
*   [2.x.58]  Number The data type in which the tensor elements are to be stored. This will, in almost all cases, simply be the default  [2.x.59]  but there are cases where one may want to store elements in a different (and always scalar) type. It can be used to base tensors on  [2.x.60]  or  [2.x.61]  numbers or any other data type that implements basic arithmetic operations. Another example would be a type that allows for Automatic Differentiation (see, for example, the Sacado type used in  [2.x.62] ) and thereby can generate analytic (spatial) derivatives of a function that takes a tensor as argument.
* 

* 
*  [2.x.63] 

* 
* [0.x.37]*
   Provide a way to get the dimension of an object without explicit   knowledge of it's data type. Implementation is this way instead of   providing a function <tt>dimension()</tt> because now it is possible to   get the dimension at compile time without the expansion and preevaluation   of an inlined function; the compiler may therefore produce more efficient   code and you may use this value to declare other data types.  
* [0.x.38]*
   Publish the rank of this tensor to the outside world.  
* [0.x.39]*
   Number of independent components of a tensor of current rank. This is dim   times the number of independent components of each sub-tensor.  
* [0.x.40]*
   Type of objects encapsulated by this container and returned by   operator[](). This is a tensor of lower rank for a general tensor, and a   scalar number type for Tensor<1,dim,Number>.  
* [0.x.41]*
   Declare an array type which can be used to initialize an object of this   type statically. For `dim == 0`, its size is 1. Otherwise, it is `dim`.  
* [0.x.42]*
   Constructor. Initialize all entries to zero.    
*  [2.x.64]  This function can also be used in CUDA device code.  
* [0.x.43]*
   A constructor where the data is copied from a C-style array.    
*  [2.x.65]  This function can also be used in CUDA device code.  
* [0.x.44]*
   A constructor where the data is copied from an ArrayView object.   Obviously, the ArrayView object must represent a stretch of   data of size `dim`<sup>`rank`</sup>. The sequentially ordered elements   of the argument `initializer` are interpreted as described by   unrolled_to_component_index().     This constructor obviously requires that the  [2.x.66]  type is   either equal to  [2.x.67]  or is convertible to  [2.x.68]    Number.    
*  [2.x.69]  This function can also be used in CUDA device code.  
* [0.x.45]*
   Constructor from tensors with different underlying scalar type. This   obviously requires that the  [2.x.70]  type is convertible to  [2.x.71]    Number.    
*  [2.x.72]  This function can also be used in CUDA device code.  
* [0.x.46]*
   Constructor that converts from a "tensor of tensors".  
* [0.x.47]*
   Conversion operator to tensor of tensors.  
* [0.x.48]*
   Copy constructor  
* [0.x.49]*
   Copy assignment operator  
* [0.x.50]*
   Move constructor  
* [0.x.51]*
   Move assignment operator  
* [0.x.52]*
   Read-Write access operator.    
*  [2.x.73]  This function can also be used in CUDA device code.  
* [0.x.53]*
   Read-only access operator.    
*  [2.x.74]  This function can also be used in CUDA device code.  
* [0.x.54]*
   Read access using TableIndices <tt>indices</tt>  
* [0.x.55]*
   Read and write access using TableIndices <tt>indices</tt>  
* [0.x.56]*
   Return a pointer to the first element of the underlying storage.  
* [0.x.57]*
   Return a const pointer to the first element of the underlying storage.  
* [0.x.58]*
   Return a pointer to the element past the end of the underlying storage.  
* [0.x.59]*
   Return a pointer to the element past the end of the underlying storage.  
* [0.x.60]*
   Assignment operator from tensors with different underlying scalar type.   This obviously requires that the  [2.x.75]  type is convertible to  [2.x.76]    Number.    
*  [2.x.77]  This function can also be used in CUDA device code.  
* [0.x.61]*
   This operator assigns a scalar to a tensor. To avoid confusion with what   exactly it means to assign a scalar value to a tensor, zero is the only   value allowed for <tt>d</tt>, allowing the intuitive notation   <tt>t=0</tt> to reset all elements of the tensor to zero.  
* [0.x.62]*
   Test for equality of two tensors.  
* [0.x.63]*
   Test for inequality of two tensors.  
* [0.x.64]*
   Add another tensor.    
*  [2.x.78]  This function can also be used in CUDA device code.  
* [0.x.65]*
   Subtract another tensor.    
*  [2.x.79]  This function can also be used in CUDA device code.  
* [0.x.66]*
   Scale the tensor by <tt>factor</tt>, i.e. multiply all components by   <tt>factor</tt>.    
*  [2.x.80]  This function can also be used in CUDA device code.  
* [0.x.67]*
   Scale the vector by <tt>1/factor</tt>.    
*  [2.x.81]  This function can also be used in CUDA device code.  
* [0.x.68]*
   Unary minus operator. Negate all entries of a tensor.    
*  [2.x.82]  This function can also be used in CUDA device code.  
* [0.x.69]*
   Reset all values to zero.     Note that this is partly inconsistent with the semantics of the  [2.x.83]    clear() member functions of the standard library containers and of   several other classes within deal.II, which not only reset the values of   stored elements to zero, but release all memory and return the object   into a virginial state. However, since the size of objects of the present   type is determined by its template parameters, resizing is not an option,   and indeed the state where all elements have a zero value is the state   right after construction of such an object.  
* [0.x.70]*
   Return the Frobenius-norm of a tensor, i.e. the square root of the sum of   the absolute squares of all entries. For the present case of rank-1   tensors, this equals the usual <tt>l<sub>2</sub></tt> norm of the vector.    
*  [2.x.84]  This function can also be used in CUDA device code.  
* [0.x.71]*
   Return the square of the Frobenius-norm of a tensor, i.e. the sum of the   absolute squares of all entries.    
*  [2.x.85]  This function can also be used in CUDA device code.  
* [0.x.72]*
   Fill a vector with all tensor elements.     This function unrolls all tensor entries into a single, linearly numbered   vector. As usual in C++, the rightmost index of the tensor marches   fastest.  
* [0.x.73]*
   Return an unrolled index in the range  [2.x.86]    for the element of the tensor indexed by the argument to the function.  
* [0.x.74]*
   Opposite of  component_to_unrolled_index: For an index in the range    [2.x.87] , return which set of indices it would   correspond to.  
* [0.x.75]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.76]*
   Read or write the data of this object to or from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.77]*
   Internal type declaration that is used to specialize the return type of   operator[]() for Tensor<1,dim,Number>  
* [0.x.78]*
   Array of tensors holding the subelements.  
* [0.x.79]*
   Internal helper function for unroll.  
* [0.x.80]*
   This constructor is for internal use. It provides a way   to create constexpr constructors for Tensor<rank, dim, Number>    
*  [2.x.88]  This function can also be used in CUDA device code.  
* [0.x.81]*
   The structs below are needed to initialize nested Tensor objects.   Also see numbers.h for another specialization.  
* [0.x.82]*
  [2.x.89]  Output functions for Tensor objects

* 
* [0.x.83]*
 Output operator for tensors. Print the elements consecutively, with a space in between, two spaces between rank 1 subtensors, three between rank 2 and so on.
*   [2.x.90]  Tensor

* 
* [0.x.84]*
 Output operator for tensors of rank 0. Since such tensors are scalars, we simply print this one value.
*   [2.x.91]  Tensor

* 
* [0.x.85]*
  [2.x.92]  Vector space operations on Tensor objects:

* 
* [0.x.86]*
 Scalar multiplication of a tensor of rank 0 with an object from the left.
*  This function unwraps the underlying  [2.x.93]  stored in the Tensor and multiplies  [2.x.94]  with it.
* 

* 
*  [2.x.95]  This function can also be used in CUDA device code.
*   [2.x.96]  Tensor

* 
* [0.x.87]*
 Scalar multiplication of a tensor of rank 0 with an object from the right.
*  This function unwraps the underlying  [2.x.97]  stored in the Tensor and multiplies  [2.x.98]  with it.
* 

* 
*  [2.x.99]  This function can also be used in CUDA device code.
*   [2.x.100]  Tensor

* 
* [0.x.88]*
 Scalar multiplication of two tensors of rank 0.
*  This function unwraps the underlying objects of type  [2.x.101]  and  [2.x.102]  OtherNumber that are stored within the Tensor and multiplies them. It returns an unwrapped number of product type.
* 

* 
*  [2.x.103]  This function can also be used in CUDA device code.
*   [2.x.104]  Tensor

* 
* [0.x.89]*
 Division of a tensor of rank 0 by a scalar number.
* 

* 
*  [2.x.105]  This function can also be used in CUDA device code.
*   [2.x.106]  Tensor

* 
* [0.x.90]*
 Add two tensors of rank 0.
* 

* 
*  [2.x.107]  This function can also be used in CUDA device code.
*   [2.x.108]  Tensor

* 
* [0.x.91]*
 Subtract two tensors of rank 0.
* 

* 
*  [2.x.109]  This function can also be used in CUDA device code.
*   [2.x.110]  Tensor

* 
* [0.x.92]*
 Multiplication of a tensor of general rank with a scalar number from the right.
*  Only multiplication with a scalar number type (i.e., a floating point number, a complex floating point number, etc.) is allowed, see the documentation of EnableIfScalar for details.
* 

* 
*  [2.x.111]  This function can also be used in CUDA device code.
*   [2.x.112]  Tensor

* 
* [0.x.93]*
 Multiplication of a tensor of general rank with a scalar number from the left.
*  Only multiplication with a scalar number type (i.e., a floating point number, a complex floating point number, etc.) is allowed, see the documentation of EnableIfScalar for details.
* 

* 
*  [2.x.113]  This function can also be used in CUDA device code.
*   [2.x.114]  Tensor

* 
* [0.x.94]*
 Division of a tensor of general rank with a scalar number. See the discussion on operator*() above for more information about template arguments and the return type.
* 

* 
*  [2.x.115]  This function can also be used in CUDA device code.
*   [2.x.116]  Tensor

* 
* [0.x.95]*
 Addition of two tensors of general rank.
*   [2.x.117]  rank The rank of both tensors.
* 

* 
*  [2.x.118]  This function can also be used in CUDA device code.
*   [2.x.119]  Tensor

* 
* [0.x.96]*
 Subtraction of two tensors of general rank.
*   [2.x.120]  rank The rank of both tensors.
* 

* 
*  [2.x.121]  This function can also be used in CUDA device code.
*   [2.x.122]  Tensor

* 
* [0.x.97]*
 Entrywise multiplication of two tensor objects of rank 0 (i.e. the multiplication of two scalar values).
*   [2.x.123]  Tensor

* 
* [0.x.98]*
 Entrywise multiplication of two tensor objects of general rank.
*  This multiplication is also called "Hadamard-product" (c.f. https://en.wikipedia.org/wiki/Hadamard_product_(matrices)), and generates a new tensor of size <rank, dim>: [1.x.0]
*   [2.x.124]  rank The rank of both tensors.
*   [2.x.125]  Tensor

* 
* [0.x.99]*
  [2.x.126]  Contraction operations and the outer product for tensor objects

* 
* [0.x.100]*
 The dot product (single contraction) for tensors: Return a tensor of rank  [2.x.127]  that is the contraction of the last index of a tensor  [2.x.128]  of rank  [2.x.129]  with the first index of a tensor  [2.x.130]  of rank  [2.x.131]  [1.x.1]
* 

* 
*  [2.x.132]  For the Tensor class, the multiplication operator only performs a contraction over a single pair of indices. This is in contrast to the multiplication operator for SymmetricTensor, which does the double contraction.
* 

* 
*  [2.x.133]  In case the contraction yields a tensor of rank 0 the scalar number is returned as an unwrapped number type.
*   [2.x.134]  Tensor

* 
* [0.x.101]*
 Generic contraction of a pair of indices of two tensors of arbitrary rank: Return a tensor of rank  [2.x.135]  that is the contraction of index  [2.x.136]  of a tensor  [2.x.137]  of rank  [2.x.138]  with the index  [2.x.139]  of a tensor  [2.x.140]  of rank  [2.x.141]  [1.x.2]
*  If for example the first index ( [2.x.142] ) of a tensor  [2.x.143]  shall be contracted with the third index ( [2.x.144] , this function should be invoked as

* 
* [1.x.3]
* 
* 

* 
*  [2.x.145]  The position of the index is counted from 0, i.e.,  [2.x.146] .
* 

* 
*  [2.x.147]  In case the contraction yields a tensor of rank 0 the scalar number is returned as an unwrapped number type.
*   [2.x.148]  Tensor

* 
* [0.x.102]*
 Generic contraction of two pairs of indices of two tensors of arbitrary rank: Return a tensor of rank  [2.x.149]  that is the contraction of index  [2.x.150]  with index  [2.x.151]  and index  [2.x.152]  index_3 with index  [2.x.153]  of a tensor  [2.x.154]  of rank  [2.x.155]  and a tensor  [2.x.156]  of rank  [2.x.157]  [1.x.4]
*  If for example the first index ( [2.x.158] ) shall be contracted with the third index ( [2.x.159] ), and the second index ( [2.x.160] ) with the first index ( [2.x.161] , this function should be invoked as

* 
* [1.x.5]
* 
* 

* 
*  [2.x.162]  The position of the index is counted from 0, i.e.,  [2.x.163] .
* 

* 
*  [2.x.164]  In case the contraction yields a tensor of rank 0 the scalar number is returned as an unwrapped number type.
*   [2.x.165]  Tensor

* 
* [0.x.103]*
 The scalar product, or (generalized) Frobenius inner product of two tensors of equal rank: Return a scalar number that is the result of a full contraction of a tensor  [2.x.166]  and  [2.x.167]  [1.x.6]
*   [2.x.168]  Tensor

* 
* [0.x.104]*
 Full contraction of three tensors: Return a scalar number that is the result of a full contraction of a tensor  [2.x.169]  of rank  [2.x.170]  a tensor  [2.x.171]  of rank  [2.x.172]  and a tensor  [2.x.173]  right of rank  [2.x.174]  [1.x.7]
* 

* 
*  [2.x.175]  Each of the three input tensors can be either a Tensor or SymmetricTensor.
*   [2.x.176]  Tensor

* 
* [0.x.105]*
 The outer product of two tensors of  [2.x.177]  and  [2.x.178]  Returns a tensor of rank  [2.x.179] : [1.x.8]
*   [2.x.180]  Tensor

* 
* [0.x.106]*
  [2.x.181]  Special operations on tensors of rank 1

* 
* [0.x.107]*
 Return the cross product in 2d. This is just a rotation by 90 degrees clockwise to compute the outer normal from a tangential vector. This function is defined for all space dimensions to allow for dimension independent programming (e.g. within switches over the space dimension), but may only be called if the actual dimension of the arguments is two (e.g. from the <tt>dim==2</tt> case in the switch).
*   [2.x.182]  Tensor

* 
* [0.x.108]*
 Return the cross product of 2 vectors in 3d. This function is defined for all space dimensions to allow for dimension independent programming (e.g. within switches over the space dimension), but may only be called if the actual dimension of the arguments is three (e.g. from the <tt>dim==3</tt> case in the switch).
*   [2.x.183]  Tensor

* 
* [0.x.109]*
  [2.x.184]  Special operations on tensors of rank 2

* 
* [0.x.110]*
 Compute the determinant of a tensor or rank 2.
*   [2.x.185]  Tensor

* 
* [0.x.111]*
 Specialization for dim==1.
*   [2.x.186]  Tensor

* 
* [0.x.112]*
 Specialization for dim==2.
*   [2.x.187]  Tensor

* 
* [0.x.113]*
 Specialization for dim==3.
*   [2.x.188]  Tensor

* 
* [0.x.114]*
 Compute and return the trace of a tensor of rank 2, i.e. the sum of its diagonal entries.
*   [2.x.189]  Tensor

* 
* [0.x.115]*
 Compute and return the inverse of the given tensor. Since the compiler can perform the return value optimization, and since the size of the return object is known, it is acceptable to return the result by value, rather than by reference as a parameter.
*   [2.x.190]  Tensor

* 
* [0.x.116]*
 Return the transpose of the given tensor.
*   [2.x.191]  Tensor

* 
* [0.x.117]*
 Return the adjugate of the given tensor of rank 2. The adjugate of a tensor  [2.x.192]  is defined as [1.x.9]
* 

* 
*  [2.x.193]  This requires that the tensor is invertible.
*   [2.x.194]  Tensor

* 
* [0.x.118]*
 Return the cofactor of the given tensor of rank 2. The cofactor of a tensor  [2.x.195]  is defined as [1.x.10]
* 

* 
*  [2.x.196]  This requires that the tensor is invertible.
*   [2.x.197]  Tensor

* 
* [0.x.119]*
 Return the nearest orthogonal matrix  [2.x.198]  by combining the products of the singular value decomposition (SVD)  [2.x.199]  for a given input  [2.x.200] , effectively replacing  [2.x.201]  with the identity matrix.
*  This is a (nonlinear) [projection operation](https://en.wikipedia.org/wiki/Projection_(mathematics)) since when applied twice, we have  [2.x.202]  as is easy to see. (That is because the SVD of  [2.x.203]  is simply  [2.x.204] .) Furthermore,  [2.x.205]  is really an orthogonal matrix because orthogonal matrices have to satisfy  [2.x.206] , which here implies that

* 
* [1.x.11]
*  due to the fact that the  [2.x.207]  and  [2.x.208]  factors that come out of the SVD are themselves orthogonal matrices.
*   [2.x.209]  A The tensor for which to find the closest orthogonal tensor.  [2.x.210]  Number The type used to store the entries of the tensor.   Must be either `float` or `double`.  [2.x.211]  In order to use this function, this program must be linked with the   LAPACK library.  [2.x.212]   [2.x.213]  must not be singular. This is because, conceptually, the problem   to be solved here is trying to find a matrix  [2.x.214]  that   minimizes some kind of distance from  [2.x.215]  while satisfying the   quadratic constraint    [2.x.216] . This is not so   dissimilar to the kind of problem where one wants to find a vector    [2.x.217]  that minimizes the quadratic objective   function  [2.x.218]  for a given  [2.x.219]    subject to the constraint  [2.x.220] 
* 
*  -  in other   words, we are seeking the point  [2.x.221]  on the unit sphere   that is closest to  [2.x.222] . This problem has a solution for all    [2.x.223]  except if  [2.x.224] . The corresponding condition   for the problem we are considering here is that  [2.x.225]  must not   have a zero eigenvalue.
*   [2.x.226]  Tensor

* 
* [0.x.120]*
 Return the  [2.x.227]  norm of the given rank-2 tensor, where  [2.x.228]  (maximum of the sums over columns).
*   [2.x.229]  Tensor

* 
* [0.x.121]*
 Return the  [2.x.230]  norm of the given rank-2 tensor, where  [2.x.231]  (maximum of the sums over rows).
*   [2.x.232]  Tensor

* 
* [0.x.122]

include/deal.II-translator/base/tensor_accessors_0.txt
[0.x.0]*
 This namespace is a collection of algorithms working on generic tensorial objects (of arbitrary rank).
*  The rationale to implement such functionality in a generic fashion in a separate namespace is
* 

* 
* 

* 
* 
*  - to easy code reusability and therefore avoid code duplication.
* 

* 
* 

* 
* 
*  - to have a well-defined interface that allows to exchange the low level implementation.
* 

*  A tensorial object has the notion of a rank and allows a rank-times recursive application of the index operator, e.g., if  [2.x.0]  is a tensorial object of rank 4, the following access is valid:

* 
* [1.x.0]
* 
*  deal.II has its own implementation for tensorial objects such as  [2.x.1]  dim, Number> and  [2.x.2]  dim, Number>
*  The methods and algorithms implemented in this namespace, however, are fully generic. More precisely, it can operate on nested c-style arrays, or on class types  [2.x.3]  with a minimal interface that provides a local alias  [2.x.4]  and an index operator  [2.x.5]  that returns a (const or non-const) reference of  [2.x.6] :

* 
* [1.x.1]
* 
*  This namespace provides primitives for access, reordering and contraction of such objects.
* 

* 
*  [2.x.7] 

* 
* [0.x.1]*
   This class provides a local alias  [2.x.8]  denoting the resulting   type of an access with operator[](unsigned int). More precisely,  [2.x.9]    value_type will be
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.10]  if T is a tensorial class providing an   alias  [2.x.11]  and does not have a const qualifier.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.12]  if T is a tensorial class   providing an alias  [2.x.13]  and does have a const   qualifier.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.14]  if T is a tensorial class   providing an alias  [2.x.15]  and does have a const   qualifier.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.16] 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.17]  and   does have a const qualifier.  
* [0.x.2]*
   This class provides a local alias  [2.x.18]  that is equal to the   alias  [2.x.19]  after  [2.x.20]  recursive   dereferences via ```operator[](unsigned int)```. Further, constness is   preserved via the ValueType type trait, i.e., if T is const,   ReturnType<rank,  [2.x.21]  will also be const.  
* [0.x.3]*
   Provide a "tensorial view" to a reference  [2.x.22]  of a tensor object of rank    [2.x.23]  in which the index  [2.x.24]  is shifted to the end. As an example   consider a tensor of 5th order in dim=5 space dimensions that can be   accessed through 5 recursive  [2.x.25]  invocations:  
* [1.x.2]
*    Index 1 (the 2nd index, count starts at 0) can now be shifted to the end   via  
* [1.x.3]
*    The usage of the  [2.x.26]  type was solely for the sake of an   example. The mechanism implemented by this function is available for   fairly general tensorial types  [2.x.27]      The purpose of this reordering facility is to be able to contract over an   arbitrary index of two (or more) tensors:
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - reorder the indices in mind to the end of the tensors
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - use the contract function below that contracts the _last_ elements of   tensors.    
*  [2.x.28]  This function returns an internal class object consisting of an   array subscript operator  [2.x.29]  and an   alias  [2.x.30]  describing its return value.      [2.x.31]  index The index to be shifted to the end. Indices are counted   from 0, thus the valid range is  [2.x.32] .    [2.x.33]  rank Rank of the tensorial object  [2.x.34]     [2.x.35]  T A tensorial object of rank  [2.x.36]   [2.x.37]  must provide a local   alias  [2.x.38]  and an index operator    [2.x.39]  that returns a (const or non-const) reference   of  [2.x.40] .  
* [0.x.4]*
   Return a reference (const or non-const) to a subobject of a tensorial   object  [2.x.41]  of type  [2.x.42]  as described by an array type  [2.x.43]    object  [2.x.44]  For example:  
* [1.x.4]
*    This is equivalent to  [2.x.45] .      [2.x.46]  T A tensorial object of rank  [2.x.47]   [2.x.48]  must provide a local   alias  [2.x.49]  and an index operator    [2.x.50]  that returns a (const or non-const) reference   of  [2.x.51] . Further, its tensorial rank must be equal or   greater than  [2.x.52]       [2.x.53]  ArrayType An array like object, such as  [2.x.54]  or    [2.x.55]   that stores at least  [2.x.56]  indices that can be   accessed via operator[]().  
* [0.x.5]*
   This function contracts two tensorial objects  [2.x.57]  and  [2.x.58]  and   stores the result in  [2.x.59]  The contraction is done over the _last_    [2.x.60]  indices of both tensorial objects:     [1.x.5]     Calling this function is equivalent of writing the following low level   code:  
* [1.x.6]
*    with r = rank_1 + rank_2
* 
*  - 2 no_contr, l = rank_1
* 
*  - no_contr, l1 =   rank_1, and c = no_contr.    
*  [2.x.61]  The Types  [2.x.62]   [2.x.63]  and  [2.x.64]  must have rank rank_1 + rank_2
* 
*  -   2 no_contr, rank_1, or rank_2, respectively. Obviously, no_contr must   be less or equal than rank_1 and rank_2.  
* [0.x.6]*
   Full contraction of three tensorial objects:     [1.x.7]     Calling this function is equivalent of writing the following low level   code:  
* [1.x.8]
*     
*  [2.x.65]  The Types  [2.x.66]   [2.x.67]  and  [2.x.68]  must have rank rank_1, rank_1 +   rank_2, and rank_3, respectively.  [2.x.69]  must be a scalar type.  
* [0.x.7]*
     An internally used type trait to allow nested application of the     function reordered_index_view(T &t).         The problem is that when working with the actual tensorial types, we     have to return subtensors by reference
* 
*  - but sometimes, especially for     StoreIndex and ReorderedIndexView that return rvalues, we have to     return by value.    
* [0.x.8]

include/deal.II-translator/base/tensor_function_0.txt
[0.x.0]*
 This class is a model for a tensor valued function. The interface of the class is mostly the same as that for the Function class, with the exception that it does not support vector-valued functions with several components, but that the return type is always tensor-valued. The returned values of the evaluation of objects of this type are always whole tensors, while for the <tt>Function</tt> class, one can ask for a specific component only, or use the <tt>vector_value</tt> function, which however does not return the value, but rather writes it into the address provided by its second argument. The reason for the different behavior of the classes is that in the case of tensor valued functions, the size of the argument is known to the compiler a priori, such that the correct amount of memory can be allocated on the stack for the return value; on the other hand, for the vector valued functions, the size is not known to the compiler, so memory has to be allocated on the heap, resulting in relatively expensive copy operations. One can therefore consider this class a specialization of the <tt>Function</tt> class for which the size is known. An additional benefit is that tensors of arbitrary rank can be returned, not only vectors, as for them the size can be determined similarly simply.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Alias for the return types of the <tt>value</tt> function.  
* [0.x.2]*
   Alias for the return types of the <tt>gradient</tt> functions.  
* [0.x.3]*
   The scalar-valued real type used for representing time.  
* [0.x.4]*
   Constructor. May take an initial value for the time variable, which   defaults to zero.  
* [0.x.5]*
   Virtual destructor; absolutely necessary in this case, as classes are   usually not used by their true type, but rather through pointers to this   base class.  
* [0.x.6]*
   Return the value of the function at the given point.  
* [0.x.7]*
   Set <tt>values</tt> to the point values of the function at the   <tt>points</tt>.  It is assumed that <tt>values</tt> already has the   right size, i.e.  the same size as the <tt>points</tt> array.  
* [0.x.8]*
   Return the gradient of the function at the given point.  
* [0.x.9]*
   Set <tt>gradients</tt> to the gradients of the function at the   <tt>points</tt>.  It is assumed that <tt>values</tt> already has the   right size, i.e.  the same size as the <tt>points</tt> array.  
* [0.x.10]*
 Provide a tensor valued function which always returns a constant tensor value. Obviously, all derivates of this function are zero.
* 

* 
*  [2.x.1] 

* 
* [0.x.11]*
   The scalar-valued real type used for representing time.  
* [0.x.12]*
   Constructor; takes the constant tensor value as an argument. The   reference value is copied internally.     An initial value for the time variable may be specified, otherwise it   defaults to zero.  
* [0.x.13]*
 Provide a tensor valued function which always returns zero. Obviously, all derivates of this function are zero.
* 

* 
*  [2.x.2] 

* 
* [0.x.14]*
   The scalar-valued real type used for representing time.  
* [0.x.15]*
   Constructor.     An initial value for the time variable may be specified, otherwise it   defaults to zero.  
* [0.x.16]

include/deal.II-translator/base/tensor_function_parser_0.txt
[0.x.0]*
 This class implements a tensor function object that gets its value by parsing a string describing this function. It is a wrapper class for the muparser library (see http://muparser.beltoforion.de/). This class is essentially an extension of the FunctionParser class to read in a TensorFunction. The class reads in an expression of length dim<sup>rank</sup> (separated by a semicolon) where the components of the tensor function are filled according to the C++ convention (fastest index is the most right one).
* 

* 
*  [2.x.0]  In contrast to the FunctionParser class the TensorFunctionParser class does not support 	 automatic differentiation.
*  A minimal example for the usage of the class would be:

* 
* [1.x.0]
* 
*  See also the documentation of the FunctionParser class.
*  This class overloads the virtual method value() and value_list() of the TensorFunction base class with the byte compiled versions of the expressions given to the initialize() methods. Note that the class will not work unless you first call the initialize() method that accepts the text description of the function as an argument (among other things).
*  The syntax to describe a function follows usual programming practice, and is explained in detail at the homepage of the underlying muparser library at http://muparser.beltoforion.de/ .
* 

*  Vector-valued functions can either be declared using strings where the function components are separated by semicolons, or using a vector of strings each defining one vector component.
* 

* 

* 
*  [2.x.1] 

* 
* [0.x.1]*
   Standard constructor. Only set initial time. This object needs to be   initialized with the initialize() method before you can use it. If an   attempt to use this function is made before the initialize() method has   been called, then an exception is thrown.  
* [0.x.2]*
   Constructor for parsed functions. This object needs to be initialized   with the initialize() method before you can use it. If an attempt to   use this function is made before the initialize() method has been called,   then an exception is thrown.   Takes a semicolon separated list of expressions (one for each component   of the tensor function), an optional comma-separated list of constants.  
* [0.x.3]*
   Copy constructor. Objects of this type can not be copied, and   consequently this constructor is deleted.  
* [0.x.4]*
   Move constructor. Objects of this type can not be moved, and   consequently this constructor is deleted.  
* [0.x.5]*
   Destructor.  
* [0.x.6]*
   Copy operator. Objects of this type can not be copied, and   consequently this operator is deleted.  
* [0.x.7]*
   Move operator. Objects of this type can not be moved, and   consequently this operator is deleted.  
* [0.x.8]*
   Type for the constant map. Used by the initialize() method.  
* [0.x.9]*
   Initialize the tensor function.  This method accepts the following   parameters:      [2.x.2]  vars A string with the variables that will be used by the   expressions to be evaluated. Note that the variables can have any name   (of course different from the function names defined above!), but the   order IS important. The first variable will correspond to the first   component of the point in which the function is evaluated, the second   variable to the second component and so forth. If this function is also   time dependent, then it is necessary to specify it by setting the    [2.x.3]  parameter to true.  An exception is thrown if   the number of variables specified here is different from dim (if this   function is not time-dependent) or from dim+1 (if it is time-dependent).      [2.x.4]  expressions A vector of strings containing the expressions that   will be byte compiled by the internal parser (TensorFunctionParser). Note   that the size of this vector must match exactly the number of components of   the TensorFunctionParser, as declared in the constructor. If this is not   the case, an exception is thrown.      [2.x.5]  constants A map of constants used to pass any necessary constant   that we want to specify in our expressions (in the example above the   number pi). An expression is valid if and only if it contains only   defined variables and defined constants (other than the functions   specified above). If a constant is given whose name is not valid (eg:    [2.x.6] ) an exception is thrown.      [2.x.7]  time_dependent If this is a time dependent function, then the   last variable declared in [1.x.1] is assumed to be the time variable,   and this->get_time() is used to initialize it when evaluating the   function. Naturally the number of variables parsed by the initialize()   method in this case is dim+1. The value of this parameter defaults to   false, i.e. do not consider time.  
* [0.x.10]*
   Initialize the function. Same as above, but accepts a string rather than   a vector of strings. If this is a vector valued function, its components   are expected to be separated by a semicolon. An exception is thrown if   this method is called and the number of components successfully parsed   does not match the number of components of the base function.  
* [0.x.11]*
   A function that returns default names for variables, to be used in the   first argument of the initialize() functions: it returns "x" in 1d, "x,y"   in 2d, and "x,y,z" in 3d.  
* [0.x.12]*
   Return the value of the tensor function at the given point.  
* [0.x.13]*
   Return the value of the tensor function at the given point.  
* [0.x.14]*
   Return an array of function expressions (one per component), used to   initialize this function.  
* [0.x.15]*
    [2.x.8]  Exceptions    [2.x.9]   
* [0.x.16]*
   Place for the variables for each thread  
* [0.x.17]*
   The muParser objects for each thread (and one for each component). We are   storing a unique_ptr so that we don't need to include the definition of    [2.x.10]  in this header.  
* [0.x.18]*
   An array to keep track of all the constants, required to initialize tfp in   each thread.  
* [0.x.19]*
   An array for the variable names, required to initialize tfp in each   thread.  
* [0.x.20]*
   Initialize tfp and vars on the current thread. This function may only be   called once per thread. A thread can test whether the function has   already been called by testing whether 'tfp.get().size()==0' (not   initialized) or >0 (already initialized).  
* [0.x.21]*
   An array of function expressions (one per component), required to   initialize tfp in each thread.  
* [0.x.22]*
   State of usability. This variable is checked every time the function is   called for evaluation. It's set to true in the initialize() methods.  
* [0.x.23]*
   Number of variables. If this is also a function of time, then the number   of variables is dim+1, otherwise it is dim. In the case that this is a   time dependent function, the time is supposed to be the last variable. If   #n_vars is not identical to the number of the variables parsed by the   initialize() method, then an exception is thrown.  
* [0.x.24]*
   Number of components is equal dim<sup>rank</sup>.  
* [0.x.25]

include/deal.II-translator/base/tensor_function.templates_0.txt
[0.x.0]

include/deal.II-translator/base/tensor_polynomials_base_0.txt
[0.x.0]*
 This class provides a framework for the finite element polynomial classes for use with finite element classes that are derived from FE_PolyTensor. An object of this type (or rather of a type derived from this class) is stored as a member variable in each object of type FE_PolyTensor.
*  [1.x.0]
*  Any derived class must provide the most basic properties for shape functions evaluated on the reference cell. This includes, but is not limited to, implementing the evaluate(), name(), and clone() member functions. These functions are necessary to store the most basic information of how the polynomials in the derived class evaluate at a given point on the reference cell. More information on each function can be found in the corresponding function's documentation.
*  Some classes that derive from this class include  [2.x.0]     [2.x.1]  <tt>PolynomialsABF</tt>    [2.x.2]  <tt>PolynomialsBDM</tt>    [2.x.3]  <tt>PolynomialsBernardiRaugel</tt>    [2.x.4]  <tt>PolynomialsNedelec</tt>    [2.x.5]  <tt>PolynomialsRaviartThomas</tt>    [2.x.6]  <tt>PolynomialsRT_Bubbles</tt>  [2.x.7] 
* 

* 
*  [2.x.8] 

* 
* [0.x.1]*
   Constructor. This takes the degree of the space,  [2.x.9]  from the finite element   class, and  [2.x.10]  the number of polynomials for the space.  
* [0.x.2]*
   Move constructor.  
* [0.x.3]*
   Copy constructor.  
* [0.x.4]*
   Virtual destructor. Makes sure that pointers to this class are deleted   properly.  
* [0.x.5]*
   Compute the value and the derivatives of the polynomials at    [2.x.11]      The size of the vectors must either be zero or equal <tt>n()</tt>.  In   the first case, the function will not compute these values.     If you need values or derivatives of all polynomials then use this   function, rather than using any of the <tt>compute_value</tt>,   <tt>compute_grad</tt> or <tt>compute_grad_grad</tt> functions, see below,   in a loop over all tensor product polynomials.  
* [0.x.6]*
   Return the number of polynomials.  
* [0.x.7]*
   Return the highest polynomial degree of polynomials represented by this   class. A derived class may override this if its value is different from    [2.x.12]   
* [0.x.8]*
   A sort of virtual copy constructor, this function returns a copy of   the polynomial space object. Derived classes need to override the function   here in this base class and return an object of the same type as the   derived class.     Some places in the library, for example the constructors of FE_PolyTensor,   need to make copies of polynomial spaces without knowing their exact type.   They do so through this function.  
* [0.x.9]*
   Return the name of the space.  
* [0.x.10]*
   The highest polynomial degree of this functions represented by this object.  
* [0.x.11]*
   The number of polynomials represented by this object.  
* [0.x.12]

include/deal.II-translator/base/tensor_product_polynomials_0.txt
[0.x.0]*
  [2.x.0]  Polynomials  [2.x.1] 

* 
* [0.x.1]*
 Tensor product of given polynomials.
*  Given a vector of [1.x.0] one-dimensional polynomials [1.x.1] to [1.x.2], this class generates [1.x.3] polynomials of the form [1.x.4]. If the base polynomials are mutually orthogonal on the interval [-1,1] or [0,1], then the tensor product polynomials are orthogonal on [-1,1]<sup>dim</sup> or [0,1]<sup>dim</sup>, respectively.
*  Indexing is as follows: the order of dim-dimensional polynomials is x-coordinates running fastest, then y-coordinate, etc. The first few polynomials are thus [1.x.5] and likewise in 3d.
*  The output_indices() function prints the ordering of the dim-dimensional polynomials, i.e. for each polynomial in the polynomial space it gives the indices i,j,k of the one-dimensional polynomials in x,y and z direction. The ordering of the dim-dimensional polynomials can be changed by using the set_numbering() function.
*   [2.x.2]  PolynomialType A class that satisfies the required interface for computing   tensor products. Typical choices for this template argument are    [2.x.3]  and  [2.x.4] 

* 
* [0.x.2]*
   Access to the dimension of this object, for checking and automatic   setting of dimension in other classes.  
* [0.x.3]*
   Constructor. <tt>pols</tt> is a vector of objects that should be derived   or otherwise convertible to one-dimensional polynomial objects of type   `PolynomialType` (template argument of class). It will be copied element   by element into a protected member variable.  
* [0.x.4]*
   Print the list of the indices to <tt>out</tt>.  
* [0.x.5]*
   Set the ordering of the polynomials. Requires   <tt>renumber.size()==n()</tt>.  Stores a copy of <tt>renumber</tt>.  
* [0.x.6]*
   Give read access to the renumber vector.  
* [0.x.7]*
   Give read access to the inverse renumber vector.  
* [0.x.8]*
   Compute the value and the first and second derivatives of each tensor   product polynomial at <tt>unit_point</tt>.     The size of the vectors must either be equal 0 or equal n(). In the first   case, the function will not compute these values.     If you need values or derivatives of all tensor product polynomials then   use this function, rather than using any of the compute_value(),   compute_grad() or compute_grad_grad() functions, see below, in a loop   over all tensor product polynomials.  
* [0.x.9]*
   Compute the value of the <tt>i</tt>th tensor product polynomial at   <tt>unit_point</tt>. Here <tt>i</tt> is given in tensor product   numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each point value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function with   <tt>values.size()==</tt>n() to get the point values of all tensor   polynomials all at once and in a much more efficient way.  
* [0.x.10]*
   Compute the <tt>order</tt>th derivative of the <tt>i</tt>th tensor   product polynomial at <tt>unit_point</tt>. Here <tt>i</tt> is given in   tensor product numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each derivative value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function, see above, with the   size of the appropriate parameter set to n() to get the point value of   all tensor polynomials all at once and in a much more efficient way.      [2.x.5]  order The derivative order.  
* [0.x.11]*
    [2.x.6]   [2.x.7]   
* [0.x.12]*
    [2.x.8]   [2.x.9]   
* [0.x.13]*
    [2.x.10]   [2.x.11]   
* [0.x.14]*
    [2.x.12]   [2.x.13]   
* [0.x.15]*
   Compute the grad of the <tt>i</tt>th tensor product polynomial at   <tt>unit_point</tt>. Here <tt>i</tt> is given in tensor product   numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each derivative value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function, see above, with   <tt>grads.size()==</tt>n() to get the point value of all tensor   polynomials all at once and in a much more efficient way.  
* [0.x.16]*
   Compute the second derivative (grad_grad) of the <tt>i</tt>th tensor   product polynomial at <tt>unit_point</tt>. Here <tt>i</tt> is given in   tensor product numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each derivative value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function, see above, with   <tt>grad_grads.size()==</tt>n() to get the point value of all tensor   polynomials all at once and in a much more efficient way.  
* [0.x.17]*
   Return the name of the space, which is <tt>TensorProductPolynomials</tt>.  
* [0.x.18]*
    [2.x.14]   [2.x.15]   
* [0.x.19]*
   Return an estimate (in bytes) for the memory consumption of this object.  
* [0.x.20]*
   Return a copy of the underlying one-dimensional polynomials given to the   constructor of this class.  
* [0.x.21]*
   Copy of the vector <tt>pols</tt> of polynomials given to the constructor.  
* [0.x.22]*
   Index map for reordering the polynomials.  
* [0.x.23]*
   Index map for reordering the polynomials.  
* [0.x.24]*
   Each tensor product polynomial [1.x.6] is a product of one-dimensional   polynomials in each space direction. Compute the indices of these one-   dimensional polynomials for each space direction, given the index   [1.x.7].  
* [0.x.25]*
   TensorProductPolynomialsBubbles has a TensorProductPolynomials class   so we declare it as a friend class.  
* [0.x.26]*
   TensorProductPolynomialsConst has a TensorProductPolynomials class   so we declare it as a friend class.  
* [0.x.27]*
 Anisotropic tensor product of given polynomials.
*  Given one-dimensional polynomials  [2.x.16]  in  [2.x.17] -direction,  [2.x.18]  in  [2.x.19] -direction, and so on, this class generates polynomials of the form  [2.x.20] . (With obvious generalization if  [2.x.21]  is in fact only 2. If  [2.x.22]  is in fact only 1, then the result is simply the same set of one-dimensional polynomials passed to the constructor.)
*  If the elements of each set of base polynomials are mutually orthogonal on the interval  [2.x.23]  or  [2.x.24] , then the tensor product polynomials are orthogonal on  [2.x.25]  or  [2.x.26] , respectively.
*  The resulting  [2.x.27]  tensor product polynomials are ordered as follows: We iterate over the  [2.x.28]  coordinates running fastest, then the  [2.x.29]  coordinate, etc. For example, for  [2.x.30]  the first few polynomials are thus  [2.x.31] ,  [2.x.32] ,  [2.x.33] , ...,  [2.x.34] ,  [2.x.35] ,  [2.x.36] , etc.

* 
* [0.x.28]*
   Constructor.  [2.x.37]  is a table of one-dimensional   polynomials. The number of rows in this table (the first index   when indexing into  [2.x.38]  needs to be equal to the   space dimension, with the elements of each row (i.e., the second   index) giving the polynomials that shall be used in this   particular coordinate direction.     Since we want to build [1.x.8] polynomials, the  [2.x.39]    sets of polynomials passed in as arguments may of course be   different, and may also vary in number.     The number of tensor product polynomials is <tt>Nx*Ny*Nz</tt>, or with   terms dropped if the number of space dimensions is less than 3.  
* [0.x.29]*
   Compute the value and the first and second derivatives of each tensor   product polynomial at <tt>unit_point</tt>.     The size of the vectors must either be equal <tt>0</tt> or equal   <tt>this->n()</tt>.  In the first case, the function will not compute   these values.     If you need values or derivatives of all tensor product polynomials then   use this function, rather than using any of the <tt>compute_value</tt>,   <tt>compute_grad</tt> or <tt>compute_grad_grad</tt> functions, see below,   in a loop over all tensor product polynomials.  
* [0.x.30]*
   Compute the value of the <tt>i</tt>th tensor product polynomial at   <tt>unit_point</tt>. Here <tt>i</tt> is given in tensor product   numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each point value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the <tt>compute</tt> function, see above,   with <tt>values.size()==this->n()</tt> to get the point values of all   tensor polynomials all at once and in a much more efficient way.  
* [0.x.31]*
   Compute the <tt>order</tt>th derivative of the <tt>i</tt>th tensor   product polynomial at <tt>unit_point</tt>. Here <tt>i</tt> is given in   tensor product numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each derivative value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function, see above, with the   size of the appropriate parameter set to n() to get the point value of   all tensor polynomials all at once and in a much more efficient way.      [2.x.40]  order The derivative order.  
* [0.x.32]*
    [2.x.41]   [2.x.42]   
* [0.x.33]*
    [2.x.43]   [2.x.44]   
* [0.x.34]*
    [2.x.45]   [2.x.46]   
* [0.x.35]*
    [2.x.47]   [2.x.48]   
* [0.x.36]*
   Compute the grad of the <tt>i</tt>th tensor product polynomial at   <tt>unit_point</tt>. Here <tt>i</tt> is given in tensor product   numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each derivative value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the <tt>compute</tt> function, see above,   with <tt>grads.size()==this->n()</tt> to get the point value of all   tensor polynomials all at once and in a much more efficient way.  
* [0.x.37]*
   Compute the second derivative (grad_grad) of the <tt>i</tt>th tensor   product polynomial at <tt>unit_point</tt>. Here <tt>i</tt> is given in   tensor product numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each derivative value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the <tt>compute</tt> function, see above,   with <tt>grad_grads.size()==this->n()</tt> to get the point value of   all tensor polynomials all at once and in a much more efficient way.  
* [0.x.38]*
   Return the name of the space, which is <tt>AnisotropicPolynomials</tt>.  
* [0.x.39]*
    [2.x.49]   [2.x.50]   
* [0.x.40]*
   Copy of the vector <tt>pols</tt> of polynomials given to the constructor.  
* [0.x.41]*
   Each tensor product polynomial  [2.x.51]  is a product of one-dimensional   polynomials in each space direction. Compute the indices of these one-   dimensional polynomials for each space direction, given the index   <tt>i</tt>.  
* [0.x.42]*
   Given the input to the constructor, compute <tt>n_pols</tt>.  
* [0.x.43]

include/deal.II-translator/base/tensor_product_polynomials_bubbles_0.txt
[0.x.0]*
  [2.x.0]  Polynomials  [2.x.1] 

* 
* [0.x.1]*
 A class that represents a space of tensor product polynomials, augmented by  [2.x.2]  (non-normalized) bubble functions of form  [2.x.3]  for  [2.x.4] . If `degree` is one, then the first factor disappears and one receives the usual bubble function centered at the mid-point of the cell.
*  This class inherits most of its functionality from TensorProductPolynomials. The bubble enrichments are added for the last index.

* 
* [0.x.2]*
   Access to the dimension of this object, for checking and automatic   setting of dimension in other classes.  
* [0.x.3]*
   Constructor. <tt>pols</tt> is a vector of objects that should be derived   or otherwise convertible to one-dimensional polynomial objects. It will   be copied element by element into a private variable.  
* [0.x.4]*
   Print the list of <tt>tensor_polys</tt> indices to <tt>out</tt>.  
* [0.x.5]*
   Set the ordering of the polynomials. Requires   <tt>renumber.size()==tensor_polys.n()</tt>.  Stores a copy of   <tt>renumber</tt>.  
* [0.x.6]*
   Give read access to the renumber vector.  
* [0.x.7]*
   Give read access to the inverse renumber vector.  
* [0.x.8]*
   Compute the value and the first and second derivatives of each tensor   product polynomial at <tt>unit_point</tt>.     The size of the vectors must either be equal 0 or equal n(). In the first   case, the function will not compute these values.     If you need values or derivatives of all tensor product polynomials then   use this function, rather than using any of the compute_value(),   compute_grad() or compute_grad_grad() functions, see below, in a loop   over all tensor product polynomials.  
* [0.x.9]*
   Compute the value of the <tt>i</tt>th tensor product polynomial at   <tt>unit_point</tt>. Here <tt>i</tt> is given in tensor product   numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each point value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function with   <tt>values.size()==</tt>n() to get the point values of all tensor   polynomials all at once and in a much more efficient way.  
* [0.x.10]*
   Compute the order  [2.x.5]  derivative of the <tt>i</tt>th tensor product   polynomial at <tt>unit_point</tt>. Here <tt>i</tt> is given in tensor   product numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each derivative value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function, see above, with the   size of the appropriate parameter set to n() to get the point value of   all tensor polynomials all at once and in a much more efficient way.  
* [0.x.11]*
    [2.x.6]   [2.x.7]   
* [0.x.12]*
    [2.x.8]   [2.x.9]   
* [0.x.13]*
    [2.x.10]   [2.x.11]   
* [0.x.14]*
    [2.x.12]   [2.x.13]   
* [0.x.15]*
   Compute the grad of the <tt>i</tt>th tensor product polynomial at   <tt>unit_point</tt>. Here <tt>i</tt> is given in tensor product   numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each derivative value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function, see above, with   <tt>grads.size()==</tt>n() to get the point value of all tensor   polynomials all at once and in a much more efficient way.  
* [0.x.16]*
   Compute the second derivative (grad_grad) of the <tt>i</tt>th tensor   product polynomial at <tt>unit_point</tt>. Here <tt>i</tt> is given in   tensor product numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each derivative value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function, see above, with   <tt>grad_grads.size()==</tt>n() to get the point value of all tensor   polynomials all at once and in a much more efficient way.  
* [0.x.17]*
   Return the number of tensor product polynomials plus the bubble   enrichments. For [1.x.0] 1d polynomials this is [1.x.1]   if the maximum degree of the polynomials is one and   [1.x.2] otherwise.  
* [0.x.18]*
   Return the name of the space, which is   <tt>TensorProductPolynomialsBubbles</tt>.  
* [0.x.19]*
    [2.x.14]   [2.x.15]   
* [0.x.20]*
   The TensorProductPolynomials object  
* [0.x.21]*
   Index map for reordering the polynomials.  
* [0.x.22]*
   Index map for reordering the polynomials.  
* [0.x.23]

include/deal.II-translator/base/tensor_product_polynomials_const_0.txt
[0.x.0]*
  [2.x.0]  Polynomials  [2.x.1] 

* 
* [0.x.1]*
 Tensor product of given polynomials and a locally constant function. This class inherits most of its functionality from TensorProductPolynomials. It works similarly to that class but adds a constant function for the last index.

* 
* [0.x.2]*
   Access to the dimension of this object, for checking and automatic   setting of dimension in other classes.  
* [0.x.3]*
   Constructor. <tt>pols</tt> is a vector of objects that should be derived   or otherwise convertible to one-dimensional polynomial objects. It will   be copied element by element into a private variable.  
* [0.x.4]*
   Print the list of <tt>tensor_polys</tt> indices to <tt>out</tt>.  
* [0.x.5]*
   Set the ordering of the polynomials. Requires   <tt>renumber.size()==tensor_polys.n()</tt>.  Stores a copy of   <tt>renumber</tt>.  
* [0.x.6]*
   Give read access to the renumber vector.  
* [0.x.7]*
   Give read access to the inverse renumber vector.  
* [0.x.8]*
   Compute the value and the first and second derivatives of each tensor   product polynomial at <tt>unit_point</tt>.     The size of the vectors must either be equal 0 or equal n(). In the first   case, the function will not compute these values.     If you need values or derivatives of all tensor product polynomials then   use this function, rather than using any of the compute_value(),   compute_grad() or compute_grad_grad() functions, see below, in a loop   over all tensor product polynomials.  
* [0.x.9]*
   Compute the value of the <tt>i</tt>th tensor product polynomial at   <tt>unit_point</tt>. Here <tt>i</tt> is given in tensor product   numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each point value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function with   <tt>values.size()==</tt>n() to get the point values of all tensor   polynomials all at once and in a much more efficient way.  
* [0.x.10]*
   Compute the <tt>order</tt>th derivative of the <tt>i</tt>th tensor   product polynomial at <tt>unit_point</tt>. Here <tt>i</tt> is given in   tensor product numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each derivative value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function, see above, with the   size of the appropriate parameter set to n() to get the point value of   all tensor polynomials all at once and in a much more efficient way.      [2.x.2]  order The derivative order.  
* [0.x.11]*
    [2.x.3]   [2.x.4]   
* [0.x.12]*
    [2.x.5]   [2.x.6]   
* [0.x.13]*
    [2.x.7]   [2.x.8]   
* [0.x.14]*
    [2.x.9]   [2.x.10]   
* [0.x.15]*
   Compute the grad of the <tt>i</tt>th tensor product polynomial at   <tt>unit_point</tt>. Here <tt>i</tt> is given in tensor product   numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each derivative value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function, see above, with   <tt>grads.size()==</tt>n() to get the point value of all tensor   polynomials all at once and in a much more efficient way.  
* [0.x.16]*
   Compute the second derivative (grad_grad) of the <tt>i</tt>th tensor   product polynomial at <tt>unit_point</tt>. Here <tt>i</tt> is given in   tensor product numbering.     Note, that using this function within a loop over all tensor product   polynomials is not efficient, because then each derivative value of the   underlying (one-dimensional) polynomials is (unnecessarily) computed   several times.  Instead use the evaluate() function, see above, with   <tt>grad_grads.size()==</tt>n() to get the point value of all tensor   polynomials all at once and in a much more efficient way.  
* [0.x.17]*
   Return the number of tensor product polynomials plus the constant   function. For [1.x.0] 1d polynomials this is [1.x.1].  
* [0.x.18]*
   Return the name of the space, which is   <tt>TensorProductPolynomialsConst</tt>.  
* [0.x.19]*
    [2.x.11]   [2.x.12]   
* [0.x.20]*
   The TensorProductPolynomials object  
* [0.x.21]*
   Index map for reordering the polynomials.  
* [0.x.22]*
   Index map for reordering the polynomials.  
* [0.x.23]

include/deal.II-translator/base/thread_local_storage_0.txt
[0.x.0]     Workaround: The standard unfortunately has an unfortunate design     "flaw" in the  [2.x.0]  type trait     when it comes to STL containers and containing non-copyable objects     T. The type trait is true even though any attempted invocation leads     to a compilation error. Work around this issue by unpacking some     commonly used containers:    
* [0.x.1]*
  
*  [2.x.1]    that accesses the object.     This class offers ways so that every thread that accesses it has its own   copy of an object of type T. In essence, accessing this object can never   result in race conditions in multithreaded programs since no other thread   than the current one can ever access it.     [1.x.0]     Objects of this class can either be default constructed or by providing   an "exemplar", i.e. an object of type T so that every time we need to   create a T on a thread that doesn't already have such an object, it is   copied from the exemplar.     Upon destruction of objects of this class, all T objects that correspond   to threads that have accessed this object are destroyed. Note that this   may be before the time when a thread is terminated.     [1.x.1]     The T object stored by this object can be accessed using the get()   function. It provides a reference to a unique object when accessed from   different threads. Objects of type T are created lazily, i.e. they are   only created whenever a thread actually calls get().  
* [0.x.2]*
     Default constructor. Initialize each thread local object using its     default constructor.    
* [0.x.3]*
     Copy constructor.    
* [0.x.4]*
     Move constructor. The constructor moves all internal data structures     from the argument.    
* [0.x.5]*
     A kind of copy constructor. Initializes an internal exemplar by the     given object. The exemplar is in turn used to initialize each thread     local object instead of invoking the default constructor.    
* [0.x.6]*
     A kind of move constructor. Moves the given object into an internal     exemplar. The exemplar is in turn used to initialize each thread     local object instead of invoking the default constructor.    
* [0.x.7]*
     Copy assignment operator.    
* [0.x.8]*
     Move assignment operator.    
* [0.x.9]*
     Return a reference to the data stored by this object for the current     thread this function is called on.         Note that there is no member function get() that is const and returns a     const reference as one would expect. The reason is that if such a     member function were called on a thread for which no thread-local     object has been created yet, then one has to create such an object     first which would certainly be a non-constant operation. If you need to     call the get() function for a member variable of a class from a const     member function, then you need to declare the member variable      [2.x.2]  to allow such access.    
* [0.x.10]*
     Same as above, except that  [2.x.3]  is set to true if an element was     already present for the current thread; false otherwise.    
* [0.x.11]*
     Conversion operator that simply converts the thread-local object to the     data type that it stores. This function is equivalent to calling the     get() member function; it's purpose is to make the TLS object look more     like the object it is storing.    
* [0.x.12]*
     Copy the given argument into the storage space used to represent the     current thread. Calling this function as  [2.x.4]      is equivalent to calling  [2.x.5] . The     intent of this operator is to make the ThreadLocalStorage object look     more like the object it represents on the current thread.          [2.x.6]  t The object to be copied into the storage space used for the     current thread.          [2.x.7]  The current object, after the changes have been made    
* [0.x.13]*
     Move the given argument into the storage space used to represent the     current thread. Calling this function as <code>tls_data =     object</code> is equivalent to calling <code>tls_data.get() =     object</code>. The intent of this operator is to make the     ThreadLocalStorage object look more like the object it represents on     the current thread. Move assignment operator.          [2.x.8]  t The object to be copied into the storage space used for the     current thread.          [2.x.9]  The current object, after the changes have been made    
* [0.x.14]*
     Remove the thread-local objects stored for all threads that have     created one with this object (i.e., that have called get() at least     once on this thread. This includes the current thread. If you call     get() subsequently on this or any other thread, new objects will again     be created.         If deal.II has been configured to not use multithreading, then this     function does not do anything at all. Note that this of course has     different semantics as in the multithreading context the objects are     deleted and created again (possible by copying from a sample object, if     the appropriate constructor of this class was called), whereas in the     multithreaded context the object is simply not touched at all. At the     same time, the purpose of this function is to release memory other     threads may have allocated for their own thread local objects after     which every use of this object will require some kind of     initialization. This is necessary both in the multithreaded or non-     multithreaded case.    
* [0.x.15]*
     The data element we store.    
* [0.x.16]*
     A mutex to guard insertion into the data object.         We use a  [2.x.10]  (or  [2.x.11]  if available)     here to be able to use  [2.x.12]  and  [2.x.13]  for a     readers-writer lock     (https://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock).    
* [0.x.17]*
     An exemplar for creating a new (thread specific) copy.    
* [0.x.18]*
  [2.x.14] 

* 
* [0.x.19]     We have to make sure not to call "data.emplace(id,exemplar)" if     the corresponding element is not copy constructible. We use some     SFINAE magic to work around the fact that C++14 does not have     "if constexpr".    
* [0.x.20]

include/deal.II-translator/base/thread_management_0.txt
[0.x.0]*
 A namespace for the implementation of thread management in deal.II. Most of the content of this namespace is discussed in detail in one of the reports linked to from the documentation page of deal.II.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   A class implementing a [1.x.0].   Mutexes are used to lock data structures to ensure that only a   single thread of execution can access them at the same time.     This class is a thin wrapper around  [2.x.1]  The only difference   is that this class is copyable when  [2.x.2]  is not.  Indeed, when   copied, the receiving object does not copy any state from the object   being copied, i.e. an entirely new mutex is created. These semantics   are consistent with the common use case if a mutex is used as a member   variable to lock the other member variables of a class: in that case,   the mutex of the copied-to object should only guard the members of the   copied-to object, not the members of both the copied-to and   copied-from object. Since at the time when the class is copied, the   destination's member variable is not used yet, its corresponding mutex   should also remain in its original state.  
* [0.x.2]*
     Default constructor.    
* [0.x.3]*
     Copy constructor. As discussed in this class's documentation, no state     is copied from the object given as argument.    
* [0.x.4]*
     Copy operators. As discussed in this class's documentation, no state     is copied from the object given as argument.    
* [0.x.5]*
   Split the range  [2.x.3]    subintervals of equal size. The last interval will be a little bit   larger, if the number of elements in the whole range is not exactly   divisible by  [2.x.4] . The type of the iterators has to   fulfill the requirements of a forward iterator, i.e.    [2.x.5]  must be available, and of course it must be   assignable.     A list of subintervals is returned as a vector of pairs of iterators,   where each pair denotes the range  [2.x.6] .    
*  [2.x.7]   
* [0.x.6]*
   Split the interval  [2.x.8]  into subintervals of (almost)   equal size. This function works mostly as the one before, with the   difference that instead of iterators, now values are taken that define   the whole interval.    
*  [2.x.9]   
* [0.x.7]*
    [2.x.10]  internal  
* [0.x.8]*
   A namespace in which helper functions and the like for the threading   subsystem are implemented. The members of this namespace are not meant   for public use.  
* [0.x.9]*
      [2.x.11]          If in a sub-thread an exception is thrown, it is not propagated to the     main thread. Therefore, the exception handler that is provided by the     applications main function or some of its other parts will not be able     to catch these exceptions. Therefore, we have to provide an exception     handler in the top function of each sub-thread that at least catches     the exception and prints some information, rather than letting the     operating system to just kill the program without a message. In each of     the functions we use as entry points to new threads, we therefore     install a try-catch block, and if an exception of type      [2.x.12]  is caught, it passes over control to this     function, which will then provide some output.    
* [0.x.10]*
      [2.x.13]          Same as above, but the type of the exception is not derived from      [2.x.14] , so there is little way to provide     something more useful.    
* [0.x.11]*
    [2.x.15]   
* [0.x.12]*
      [2.x.16]          Given an arbitrary type RT, store an element of it and grant     access to it through functions get() and set(). There are     specializations for reference types (which need to be stored as     pointers to the object being referenced), and for type void.         This function is not dissimilar to the  [2.x.17]      combination of classes. The difference is that a  [2.x.18]      can only be read once via  [2.x.19]  (presumably this     design is due to the fact that  [2.x.20]  can throw     an exception previously stored in the  [2.x.21]  On     the other hand, this class makes the result available for     as many times as desired. It also doesn't store any exceptions     (though they will be forwarded by the classes using the current     class).    
* [0.x.13]*
      [2.x.22]          Given an arbitrary type RT, store an element of it and grant access to     it through functions get() and set(). This is the specialization for     reference types: since references cannot be set after construction time,     we store a pointer instead, which holds the address of the object being     referenced.         This function is not dissimilar to the  [2.x.23]      combination of classes. The difference is that a  [2.x.24]      can only be read once via  [2.x.25]  (presumably this     design is due to the fact that  [2.x.26]  can throw     an exception previously stored in the  [2.x.27]  On     the other hand, this class makes the result available for     as many times as desired. It also doesn't store any exceptions     (though they will be forwarded by the classes using the current     class).    
* [0.x.14]*
      [2.x.28]          Given an arbitrary type RT, store an element of it and grant access to     it through functions get() and set(). This is the specialization for     type void: there is obviously nothing to store, so no function set(),     and a function get() that returns void.         This function is not dissimilar to the  [2.x.29]      combination of classes. The difference is that a  [2.x.30]      can only be read once via  [2.x.31]  (presumably this     design is due to the fact that  [2.x.32]  can throw     an exception previously stored in the  [2.x.33]  On     the other hand, this class makes the result available for     as many times as desired. It also doesn't store any exceptions     (though they will be forwarded by the classes using the current     class).    
* [0.x.15]*
     A class that represents threads. For each thread, we create exactly one     of these objects
* 
*  -  exactly one because it carries the returned value     of the function called on the thread.         While we have only one of these objects per thread, several      [2.x.34]  objects may refer to this descriptor. If all Thread     objects go out of scope the ThreadDescriptor will detach from the     thread before being destroyed.    
* [0.x.16]*
       An object that represents the thread started.      
* [0.x.17]*
       An object that will hold the value returned by the function called on       the thread.             The return value is stored in a shared_ptr because we might abandon       the ThreadDescriptor.  This makes sure the object stays alive       until the thread exits.      
* [0.x.18]*
       An atomic  bool variable that is initially false, is set to true       when a new thread is started, and is set back to false once join()       has been called.             We use this variable to make sure we can call join() twice on the       same thread. For some reason, the C++ standard library throws a        [2.x.35]  exception if one tries to call  [2.x.36]        twice (and in fact, before the second call,  [2.x.37]        returns false) but this is a somewhat desirable thing to do because       one doesn't have to keep track whether join() has been called before.       Using this variable, whenever we have called join() before, the       variable is set to true and we can skip over calling        [2.x.38]  a second time. Access to this variable is guarded       by the following mutex.            
*  [2.x.39]  Historically, we did not need the mutex for this variable:       threads can only be joined from the thread that created it       originally. Consequently, everything that happens in a function that       does not create threads (such as the join() function below) looks       atomic to the outside world. Since we clear and test thread_is_active       in the same function as we call  [2.x.40]  these actions are       atomic and need no mutex. Of course, two threads may call join() on       the same thread object at the same time, but this action is undefined       anyway since they can not both join the same thread. That said, more       recent C++ standards do not appear to have the requirement any more       that the only thread that can call join() is the one that created the       thread. Neither does `pthread_join` appear to have this requirement any       more.  Consequently, we can in fact join from different threads and       we test this in base/thread_validity_07.            
*  [2.x.41]  The reason why we need to use a  [2.x.42]  is       discussed in detail in the documentation of        [2.x.43]       
* [0.x.19]*
       Mutex guarding access to the previous variable.      
* [0.x.20]*
       Default constructor.      
* [0.x.21]*
       Start the thread and let it put its return value into the ret_val       object.      
* [0.x.22]*
       Wait for the thread to end.      
* [0.x.23]*
       The function that runs on the thread.      
* [0.x.24]*
   An object that represents a spawned thread. This object can be freely   copied around in user space, and all instances will represent the same   thread and can require to wait for its termination and access its return   value.     Threads can be abandoned, i.e. if you just call  [2.x.44]  but   don't care about the returned object, or if you assign the return    [2.x.45]  object to an object that subsequently goes out of scope,   then the thread previously created will still continue to do work. You   will simply not be able to access its return value any more, and it may   also happen that your program terminates before the thread has finished   its work.     The default value of the template argument is  [2.x.46] , so if   the function you are calling on a new thread has no return value, you can   omit the template argument.    
*  [2.x.47]       [2.x.48]  Use  [2.x.49]  or  [2.x.50]  instead.    
*  [2.x.51]  Since this class is used in ThreadGroup, its constructors, rather   than the class itself, are deprecated to allow compilation with
* 

* 
* 

* 
* 

* 
* 
*  - error=deprecated-declarations.  
* [0.x.25]*
     Construct a thread object with a function object.    
* [0.x.26]*
     Default constructor. You can't do much with a thread object constructed     this way, except for assigning it a thread object that holds data     created by the new_thread() functions.    
* [0.x.27]*
     Copy constructor.    
* [0.x.28]*
     Join the thread represented by this object, i.e. wait for it to finish.     If you have used the default constructor of this class and have not     assigned a thread object to it, then this function is a no-op.    
* [0.x.29]*
     Get the return value of the function of the thread. Since it     is only available once the thread finishes, this function     internally also calls join(). You can call this function     multiple times as long as the object refers to the same task,     and expect to get the same return value every time. (With the     exception of the case where the returned object has been moved;     see below.)        
*  [2.x.52]  The function returns a [1.x.1] to     the returned object, instead of the returned object. This     allows writing code such as    
* [1.x.2]
*      You will rarely have a need to write such code. On the other hand,     the function needs to return a writable (non- [2.x.53]  reference to     support code such as this:    
* [1.x.3]
*      Here, it is necessary to  [2.x.54]  the returned object (namely,     the  [2.x.55]  object) because      [2.x.56]  objects can not be copied. In other words,     to get the pointer out of the object returned from the thread, it needs     to be moved, and in order to be moved, the current function needs to     return a writable (non- [2.x.57]  reference.    
* [0.x.30]*
     Return true if this object has had a thread associated with it, either     by using the non-default constructor or by assignment.    
* [0.x.31]*
     Check for equality of thread objects. Since objects of this class store     an implicit pointer to an object that exists exactly once for each     thread, the check is simply to compare these pointers.    
* [0.x.32]*
     Shared pointer to the object representing the thread, and abstracting     operating system functions to work on it. This also makes sure that the     object lives as long as there is at least one subscriber to it.    
* [0.x.33]*
     A general template that returns  [2.x.58]  if t is of reference     type, and t otherwise.         The case that t is of reference type is handled in a partial     specialization declared below.    
* [0.x.34]*
     A general template that returns  [2.x.59]  if t is of reference     type, and t otherwise.         The case that t is of reference type is handled in this partial     specialization.    
* [0.x.35]*
   Overload of the new_thread function for objects that can be converted to    [2.x.60]  ()>, i.e. anything that can be called like a   function object without arguments and returning an object of type RT (or   void).    
*  [2.x.61]   
* [0.x.36]*
   Overload of the new_thread() function for objects that can be called like a   function object without arguments. In particular, this function allows   calling  [2.x.62]  with either objects that result from using    [2.x.63]  or using lambda functions. For example, this function is called   when writing code such as  
* [1.x.4]
*    Here, we run the sequence of functions    [2.x.64]  on   a separate thread, by making the lambda function declared here the   function to execute on the thread. The lambda function then returns   42 (which is a bit pointless here, but it could of course be some   computed number), and this is going to be the returned value you   can later retrieve via  [2.x.65]  once the   thread (i.e., the body of the lambda function) has completed.    
*  [2.x.66]  Every lambda function (or whatever else it is you pass to     the new_thread() function here, for example the result of a      [2.x.67]  expression) has a return type and consequently     returns an object of this type. This type can be inferred     using the C++11  [2.x.68]  statement used in the     declaration of this function, and it is then used as the template     argument of the  [2.x.69]  object returned by the current function.     In the example above, because the lambda function returns 42     (which in C++ has data type  [2.x.70] ), the inferred     type is  [2.x.71]  and the task object will have type      [2.x.72] . In other words, it is not [1.x.5]     to explicitly specify in user code what that return type     of the lambda or  [2.x.73]  expression will be, though it is     possible to explicitly do so by (entirely equivalently) writing    
* [1.x.6]
*     
*  [2.x.74]  In practice, the lambda functions you will pass to     new_thread() will of course typically be more complicated.     In particular, they will likely [1.x.7] variables     from the surrounding context and use them within the lambda.     See   https://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29     for more on how lambda functions work.    
*  [2.x.75]  If you pass a lambda function as an argument to the     current function that captures a variable [1.x.8],     or if you use a  [2.x.76]  that binds a function argument to     a reference variable using  [2.x.77]  or  [2.x.78]  then     obviously you can only do this if the variables you reference     or capture have a lifetime that extends at least until the time     where the thread finishes.    
*  [2.x.79]   
* [0.x.37]*
   Overload of the new_thread function for non-member or static member   functions.    
*  [2.x.80]   
* [0.x.38]*
   Overload of the non-const new_thread function for member functions.    
*  [2.x.81]   
* [0.x.39]*
   Overload of the new_thread function for const member functions.    
*  [2.x.82]   
* [0.x.40]*
   A container for thread objects. Allows to add new thread objects and wait   for them all together. The thread objects need to have the same return   value for the called function.    
*  [2.x.83]       [2.x.84]  Use TaskGroup instead.  
* [0.x.41]*
     Add another thread object to the collection.    
* [0.x.42]*
     Wait for all threads in the collection to finish. It is not a problem     if some of them have already been waited for, i.e. you may call this     function more than once, and you can also add new thread objects     between subsequent calls to this function if you want.    
* [0.x.43]*
     List of thread objects.    
* [0.x.44]*
     Set the value of a  [2.x.85]  object by evaluating the action.    
* [0.x.45]*
     Set the value of a  [2.x.86]  object by evaluating the     action. This function is a specialization of the previous one     for the case where the return type is `void`. Consequently, we     can't set a value. But we do evaluate the function object and     call  [2.x.87]  without argument.    
* [0.x.46]*
   This class describes a task object, i.e., what one obtains by calling    [2.x.88]  The idea is that  [2.x.89]  allows one to run   a function whenever the C++ run-time system finds it convenient
* 
*  -    typically, when there is an idle processor available. This can be used to   run things in the background when there is no immediate need for the   result, or if there are other things that could well be done in parallel.   Whenever the result of that background task is needed, one can call either   join() to just wait for the task to finish, or return_value() to obtain the   value that was returned by the function that was run on that background   task.     This class is conceptually similar to the    [2.x.90]  class that   is returned by    [2.x.91]  (which is   itself similar to what  [2.x.92]  does). The principal conceptual   difference is that one can only call  [2.x.93]  once, whereas one   can call  [2.x.94]  as many times as desired. It is,   thus, comparable to the    [2.x.95]    class. However,  [2.x.96]  can not be used for types that can not   be copied
* 
*  -  a particular restriction for  [2.x.97]  for example.    
*  [2.x.98]   
* [0.x.47]*
     Construct a task object, given a function object to execute on     the task, and then schedule this function for     execution. However, when  [2.x.99]  returns     1, i.e., if the deal.II runtime system has been configured to     only use one thread, then just execute the given function     object.          [2.x.100]  Using this constructor automatically makes the task object     joinable().    
* [0.x.48]*
     Default constructor. You can't do much with a task object constructed     this way, except for assigning it a task object that holds data created     by the  [2.x.101]  functions.          [2.x.102]  Using this constructor leaves the object in an unjoinable state,     i.e., joinable() will return false.    
* [0.x.49]*
     Join the task represented by this object, i.e. wait for it to finish.         A task can be joined multiple times (while the first join() operation     may block until the task has completed running, all successive attempts     to join will return immediately).         If the operation that was executed on the task with which this     object was initialized throws an exception instead of returning     regularly, then calling the current join() function will first     wait for that task to finish, and then in turn throw the     exception that the task operation had thrown originally. This     allows for the propagation of exceptions from tasks executed on     a separate thread to the calling thread.         (This behavior differs from that of      [2.x.103]      where the  [2.x.104]  function only waits for     completion of the operation, whereas the exception is     propagated only once one calls  [2.x.105]  However,     this is awkward when putting `void` functions onto separate     tasks because these do not actually return anything;     consequently, it is more natural to call  [2.x.106]      for such tasks than the  [2.x.107]  function since the     latter does not, actually, return anything that could be     gotten.)          [2.x.108]  You can't call this function if you have used the default     constructor of this class and have not assigned a task object to it. In     other words, the function joinable() must return true.    
* [0.x.50]*
     Return whether the current object can be joined. You can join a task     object once a task (typically created with  [2.x.109]  has     actually been assigned to it. On the other hand, the function returns     false if the object has been default constructed.         A task can be joined multiple times (while the first join() operation     may block until the task has completed running, all successive attempts     to join will return immediately). Consequently, if this function     returns true, it will continue to return true until the task object it     reports on is assigned to from another object.    
* [0.x.51]*
     Get the return value of the function of the task. Since it is     only available once the thread finishes, this function     internally also calls join(). You can call this function     multiple times as long as the object refers to the same task,     and expect to get the same return value every time. (With the     exception of the case where the returned object has been moved;     see below.)        
*  [2.x.110]  The function returns a [1.x.9] to     the returned object, instead of the returned object. This     allows writing code such as    
* [1.x.10]
*      You will rarely have a need to write such code. On the other hand,     the function needs to return a writable (non- [2.x.111]  reference to     support code such as this:    
* [1.x.11]
*      Here, it is necessary to  [2.x.112]  the returned object (namely,     the  [2.x.113]  object) because      [2.x.114]  objects can not be copied. In other words,     to get the pointer out of the object returned from the task, it needs     to be moved, and in order to be moved, the current function needs to     return a writable (non- [2.x.115]  reference.         This function internally calls the join() member function. As a     consequence, and as explained there, if the packaged task     throws an exception that is then re-thrown by the join()     function and consequently also the current function if you have     not previously called join().          [2.x.116]  You can't call this function if you have used the default     constructor of this class and have not assigned a task object to it. In     other words, the function joinable() must return true.    
* [0.x.52]*
      [2.x.117]  Exceptions      [2.x.118]     
* [0.x.53]*
     Exception    
* [0.x.54]*
     A data structure that holds a  [2.x.119]  into which the task deposits     its return value. Since one can only call  [2.x.120]  once,     we do so in the get() member function and then move the returned object     into the `returned_object` member variable from where we can read it     multiple times and from where it can also be moved away if it is not     copyable.    
* [0.x.55]*
       Constructor. Initializes an  [2.x.121]  object and assumes       that the task so set has not finished yet.      
* [0.x.56]*
       Wait for the  [2.x.122]  object to be ready, i.e., for the       time when the  [2.x.123]  receives its value. If this has       already happened, this function can follow a fast path.      
* [0.x.57]*
       A mutex used to synchronize access to the data structures of this       class.      
* [0.x.58]*
       The promise associated with the task that is represented by the current       class.      
* [0.x.59]*
       A boolean indicating whether the task in question has finished.            
*  [2.x.124]  We are using a  [2.x.125]  here because we have       to make sure that concurrent reads and stores between threads are       properly synchronized, and that sequential reads on a given thread       are not reordered or optimized away. A  [2.x.126]  [1] achieves       this because (if not otherwise annotated) reads and stores to the       boolean are subject to the  [2.x.127]  memory       ordering [2]. This ensures that Schmidt's double checking does       indeed work. For additional information (and a potentially more       efficient implementation) see [3].             [1] https://en.cppreference.com/w/cpp/atomic/atomic       [2] https://en.cppreference.com/w/cpp/atomic/memory_order       [3]       https://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/      
* [0.x.60]*
       The place where the returned value is moved to once the  [2.x.128]        has delivered.      
* [0.x.61]*
     A pointer to a descriptor of the object that described the task     and its return value.    
* [0.x.62]*
   Overload of the new_task function for objects that can be converted to    [2.x.129]  ()>, i.e. anything that can be called like a   function object without arguments and returning an object of type RT (or   void).    
*  [2.x.130]  When  [2.x.131]  returns 1, i.e., if the     deal.II runtime system has been configured to only use one     thread, then this function just executes the given function     object immediately and stores the return value in the Task     object returned by this function.    
*  [2.x.132]   [2.x.133]  is, in essence, equivalent to calling      [2.x.134]  ...)` in that it runs the given task     in the background. See https://en.cppreference.com/w/cpp/thread/async     for more information.    
*  [2.x.135]   
* [0.x.63]*
   Overload of the new_task function for objects that can be called like a   function object without arguments. In particular, this function allows   calling  [2.x.136]  with either objects that result from using    [2.x.137]  or using lambda functions. For example, this function is called   when writing code such as  
* [1.x.12]
*    Here, we schedule the call to the sequence of functions    [2.x.138]  on   a separate task, by making the lambda function declared here the   function to execute on the task. The lambda function then returns   42 (which is a bit pointless here, but it could of course be some   computed number), and this is going to be the returned value you   can later retrieve via  [2.x.139]  once the   task (i.e., the body of the lambda function) has completed.    
*  [2.x.140]  When  [2.x.141]  returns 1, i.e., if the     deal.II runtime system has been configured to only use one     thread, then this function just executes the given function     object immediately and stores the return value in the Task     object returned by this function.    
*  [2.x.142]  Every lambda function (or whatever else it is you pass to     the new_task() function here, for example the result of a      [2.x.143]  expression) has a return type and consequently     returns an object of this type. This type can be inferred     using the C++11  [2.x.144]  statement used in the     declaration of this function, and it is then used as the template     argument of the  [2.x.145]  object returned by the current function.     In the example above, because the lambda function returns 42     (which in C++ has data type  [2.x.146] ), the inferred     type is  [2.x.147]  and the task object will have type      [2.x.148] . In other words, it is not [1.x.13]     to explicitly specify in user code what that return type     of the lambda or  [2.x.149]  expression will be, though it is     possible to explicitly do so by (entirely equivalently) writing    
* [1.x.14]
*     
*  [2.x.150]  In practice, the lambda functions you will pass to     new_task() will of course typically be more complicated.     In particular, they will likely [1.x.15] variables     from the surrounding context and use them within the lambda.     See   https://en.wikipedia.org/wiki/Anonymous_function#C.2B.2B_.28since_C.2B.2B11.29     for more on how lambda functions work.    
*  [2.x.151]  If you pass a lambda function as an argument to the     current function that captures a variable [1.x.16],     or if you use a  [2.x.152]  that binds a function argument to     a reference variable using  [2.x.153]  or  [2.x.154]  then     obviously you can only do this if the variables you reference     or capture have a lifetime that extends at least until the time     where the task finishes.    
*  [2.x.155]   [2.x.156]  is, in essence, equivalent to calling      [2.x.157]  ...)` in that it runs the given task     in the background. See https://en.cppreference.com/w/cpp/thread/async     for more information.    
*  [2.x.158]   
* [0.x.64]*
   Overload of the new_task function for non-member or static member   functions. See the other functions of same name for more information.    
*  [2.x.159]   
* [0.x.65]*
   Overload of the non-const new_task function. See the other functions of   same name for more information.    
*  [2.x.160]   
* [0.x.66]*
   Overload of the new_task function. See the other functions of same name for   more information.    
*  [2.x.161]   
* [0.x.67]*
   A container for task objects. Allows to add new task objects and wait for   them all together. The task objects need to have the same return value   for the called function.     Note that the call to join_all() must be executed on the same thread as   the calls that add subtasks. Otherwise, there might be a deadlock. In   other words, a Task object should never passed on to another task for   calling the join() method.    
*  [2.x.162]   
* [0.x.68]*
     Add another task object to the collection.    
* [0.x.69]*
     Return how many tasks have been put into this group. This     function does not distinguish how many of these tasks have     already run and have finished, are still waiting to be     scheduled to a CPU resource, or are currently running. Tasks     that have been joined already are also still counted.    
* [0.x.70]*
     Wait for all tasks in the collection to finish. It is not a problem if     some of them have already been waited for, i.e. you may call this     function more than once, and you can also add new task objects between     subsequent calls to this function if you want.    
* [0.x.71]*
     List of task objects.    
* [0.x.72]*
  [2.x.163] 

* 
* [0.x.73]

include/deal.II-translator/base/timer_0.txt
[0.x.0]*
 A clock, compatible with the  [2.x.0]  notion of a clock, whose now() method returns a time point indicating the amount of CPU time that the current process has used.

* 
* [0.x.1]*
   Duration type. Windows measures CPU times, by default, in multiples of   1/64th of a second and POSIX uses microseconds, so go with microseconds   for uniformity.  
* [0.x.2]*
   Signed integral type used to store the value returned by count().  
* [0.x.3]*
   Ratio representing the length of a period (in seconds).  
* [0.x.4]*
   Time point type.  
* [0.x.5]*
   Boolean indicating that the clock monotonically increases.  
* [0.x.6]*
   Return the amount of CPU time that the current process has   used. Unfortunately, this requires platform-specific calls, so this   function returns 0 on platforms that are neither Windows nor POSIX.  
* [0.x.7]*
 The Timer class provides a way to measure both the amount of wall time (i.e., the amount of time elapsed on a wall clock) and the amount of CPU time that certain sections of an application have used. This class also offers facilities for synchronizing the elapsed time across an MPI communicator.
*  [1.x.0]
*  The Timer class can be started and stopped several times. It stores both the amount of time elapsed over the last start-stop cycle, or  [2.x.1] lap [2.x.2] , as well as the total time elapsed over all laps. Here is an example:
* 

* 
* [1.x.1]
* 
*  Alternatively, you can also restart the timer instead of resetting it. The times between successive calls to start() and stop() (i.e., the laps) will then be accumulated. The usage of this class is also explained in the  [2.x.3]  tutorial program.
* 

* 
*  [2.x.4]  The TimerOutput (combined with  [2.x.5]  class provide a convenient way to time multiple named sections and summarize the output.
* 

* 
*  [2.x.6]  Implementation of this class is system dependent. In particular, CPU times are accumulated from summing across all threads and will usually exceed the wall times.
* 

* 
*  [2.x.7] 

* 
* [0.x.8]*
   Constructor. Sets the accumulated times at zero and calls  [2.x.8]   
* [0.x.9]*
   Constructor specifying that CPU times should be summed over the given   communicator. If  [2.x.9]  is  [2.x.10]  then the Timer   will set the elapsed wall and CPU times over the last lap to their   maximum values across the provided communicator. This synchronization is   only performed if  [2.x.11]  is called before the timer is queried for   time duration values.     This constructor calls  [2.x.12]     
*  [2.x.13]  The timer is stopped before the synchronization over the   communicator occurs; the extra cost of the synchronization is not   measured.  
* [0.x.10]*
   Return a reference to the data structure containing basic statistics on   the last lap's wall time measured across all MPI processes in the given   communicator. This structure does not contain meaningful values until    [2.x.14]  has been called.  
* [0.x.11]*
   Return a reference to the data structure containing basic statistics on   the accumulated wall time measured across all MPI processes in the given   communicator. This structure does not contain meaningful values until    [2.x.15]  has been called.  
* [0.x.12]*
   Print the data returned by  [2.x.16]  to the   given stream.  
* [0.x.13]*
   Print the data returned by  [2.x.17]  to the   given stream.  
* [0.x.14]*
   Begin measuring a new lap. If  [2.x.18]  is    [2.x.19]  then an MPI barrier is used to ensure that all   processes begin the lap at the same wall time.  
* [0.x.15]*
   Stop the timer. This updates the lap times and accumulated times. If    [2.x.20]  then the lap times are   synchronized over all processors in the communicator (i.e., the lap times   are set to the maximum lap time).     Return the accumulated CPU time in seconds.  
* [0.x.16]*
   Stop the timer, if it is running, and reset all measured values to their   default states.  
* [0.x.17]*
   Equivalent to calling  [2.x.21]  followed by calling  [2.x.22]   
* [0.x.18]*
   Return the current accumulated wall time (including the current lap, if   the timer is running) in seconds without stopping the timer.  
* [0.x.19]*
   Return the wall time of the last lap in seconds. The timer is not stopped   by this function.  
* [0.x.20]*
   Return the accumulated CPU time (including the current lap, if the timer   is running) in seconds without stopping the timer.     If an MPI communicator is provided to the constructor then the returned   value is the sum of all accumulated CPU times over all processors in the   communicator.  
* [0.x.21]*
   Return the CPU time of the last lap in seconds. The timer is not stopped   by this function.  
* [0.x.22]*
   The Timer class stores timing information for two different clocks: a   wall clock and a CPU usage clock. Since the logic for handling both   clocks is, in most places, identical, we collect the relevant   measurements for each clock into this  [2.x.23] .      [2.x.24]  clock_type_ The type of the clock whose measurements are being   stored. This class should conform to the usual clock interface expected   by  [2.x.25]  (i.e., the correct alias and a static    [2.x.26]  method).  
* [0.x.23]*
     Store the clock type.    
* [0.x.24]*
     The time point type of the provided clock.    
* [0.x.25]*
     The duration type of the provided clock.    
* [0.x.26]*
     The time point corresponding to the start of the current lap. This is     obtained by calling  [2.x.27] .    
* [0.x.27]*
     The accumulated time over several laps.    
* [0.x.28]*
     The duration of the last lap.    
* [0.x.29]*
     Constructor. Sets  [2.x.28]  to the current     clock time and the durations to zero.    
* [0.x.30]*
     Reset the clock by setting  [2.x.29]  to the     current clock time and the durations to zero.    
* [0.x.31]*
   Alias for the wall clock.  
* [0.x.32]*
   Alias for the CPU clock.  
* [0.x.33]*
   Collection of wall time measurements.  
* [0.x.34]*
   Collection of CPU time measurements.  
* [0.x.35]*
   Whether or not the timer is presently running.  
* [0.x.36]*
   The communicator over which various time values are synchronized and   combined: see the documentation of the relevant constructor for   additional information.  
* [0.x.37]*
   Store whether or not the wall time and CPU time are synchronized across   the communicator in  [2.x.30]  and  [2.x.31]   
* [0.x.38]*
   A structure for parallel wall time measurement that includes the minimum,   maximum, and average over all processors known to the MPI communicator of   the last lap time.  
* [0.x.39]*
   A structure for parallel wall time measurement that includes the minimum   time recorded among all processes, the maximum time as well as the   average time defined as the sum of all individual times divided by the   number of MPI processes in the MPI_Comm for the total run time.  
* [0.x.40]*
 This class can be used to generate formatted output from time measurements of different subsections in a program. It is possible to create several sections that perform certain aspects of the program. A section can be entered several times. By changing the options in OutputFrequency and OutputType, the user can choose whether output should be generated every time a section is joined or just in the end of the program. Moreover, it is possible to show CPU times, wall times, or both.
*  The class is used in a substantial number of tutorial programs that collect timing data.  [2.x.32]  is an example of a relatively simple sequential program that uses it.  [2.x.33]  and several others mentioned below use it for parallel computations.
* 

*  [1.x.2]
*  Use of this class could be as follows:

* 
* [1.x.3]
*  When run, this program will return an output like this:

* 
* [1.x.4]
*  The output will see that we entered the assembly and solve section twice, and reports how much time we spent there. Moreover, the class measures the total time spent from start to termination of the TimerOutput object. In this case, we did a lot of other stuff, so that the time proportions of the functions we measured are far away from 100 percent.
* 

*  [1.x.5]
*  The scheme above where you have to have calls to  [2.x.34]  and  [2.x.35]  is awkward if the sections in between these calls contain  [2.x.36]  statements or may throw exceptions. In that case, it is easy to forget that one nevertheless needs to leave the section somehow, somewhere. An easier approach is to use "scoped" sections. This is a variable that when you create it enters a section, and leaves the section when you destroy it. If this is a variable local to a particular scope (a code block between curly braces) and you leave this scope due to a  [2.x.37]  statements or an exception, then the variable is destroyed and the timed section is left automatically. Consequently, we could have written the code piece above as follows, with exactly the same result but now exception-safe:

* 
* [1.x.6]
* 
* 

*  [1.x.7]
*  In a parallel program built on MPI, using the class in a way such as the one shown above would result in a situation where each process times the corresponding sections and then outputs the resulting timing information at the end. This is annoying since you'd get a lot of output
* 
*  -  one set of timing information from each processor.
*  This can be avoided by only letting one processor generate screen output, typically by using an object of type ConditionalOStream instead of  [2.x.38]  to write to screen (see, for example,  [2.x.39] ,  [2.x.40] ,  [2.x.41]  and  [2.x.42] , all of which use this method).
*  This way, only a single processor outputs timing information, typically the first process in the MPI universe. However, if you take the above code snippet as an example, imagine what would happen if  [2.x.43]  is fast on processor zero and slow on at least one of the other processors; and if the first thing  [2.x.44]  does is something that requires all processors to communicate. In this case, on processor zero, the timing section with name  [2.x.45]  will yield a short run time on processor zero, whereas the section  [2.x.46]  will take a long time: not because  [2.x.47]  takes a particularly long time, but because on the processor on which we time (or, rather, the one on which we generate output) happens to have to wait for a long time till the other processor is finally done with  [2.x.48]  and starts to participate in  [2.x.49] . In other words, the timing that is reported is unreliable because it reflects run times from other processors. Furthermore, the run time of this section on processor zero has nothing to do with the run time of the section on other processors but instead with the run time of [1.x.8] on another processor.
*  The first way to avoid this is to introduce a barrier into the parallel code just before we start and stop timing sections. This ensures that all processes are at the same place and the timing information then reflects the maximal run time across all processors. To achieve this, you need to initialize the TimerOutput object with an MPI communicator object, for example as in the following code:

* 
* [1.x.9]
*  Here,  [2.x.50]  is an object of type ConditionalOStream that makes sure that we only generate output on a single processor. See the  [2.x.51] ,  [2.x.52] , and  [2.x.53]  tutorial programs for this kind of usage of this class.
*  The second variant to cope with this issue is print more information about the recorded times to be able to understand this kind of imbalances without actually adding the barriers. While this approach is still affected by imbalances between different MPI processes, its output is not the arbitrary time of rank 0, but the minimum, average and maximum of the MPI results, using information from  [2.x.54]  As the data is also equipped with the rank id where the minimum and maximum are attained, this approach allows to identify on which ranks certain slowdowns occur. In case some imbalance between the MPI ranks from one section to the next can be tolerated, this strategy can hence be advantageous over the barrier variant as it does not synchronize the program in places where it is not necessary, and rather tries to display the imbalance observed in various phases. In order to use this variant initialize the output object without any native print settings and without communicator,

* 
* [1.x.10]
*  and then call

* 
* [1.x.11]
*  where appropriate. Here, the output is written to the  [2.x.55]  object of type ConditionalOStream passed to the constructor, making sure the information is only printed once. See  [2.x.56]  for an example usage of this variant. Besides the basic minimum, average, and maximum of times over all MPI ranks, the  [2.x.57]  function also takes a second argument to specify output of quantiles, e.g., the time taken by the 10\% of the slowest and fastest ranks, respectively, to get additional insight into the statistical distribution.
* 

* 
*  [2.x.58] 

* 
* [0.x.41]*
   Helper class to enter/exit sections in TimerOutput be constructing a   simple scope-based object. The purpose of this class is explained in the   documentation of TimerOutput.  
* [0.x.42]*
     Enter the given section in the timer. Exit automatically when calling     stop() or destructor runs.    
* [0.x.43]*
     Destructor calls stop()    
* [0.x.44]*
     In case you want to exit the scope before the destructor is executed,     call this function.    
* [0.x.45]*
     Reference to the TimerOutput object    
* [0.x.46]*
     Name of the section we need to exit    
* [0.x.47]*
     Do we still need to exit the section we are in?    
* [0.x.48]*
   An enumeration data type that describes whether to generate output every   time we exit a section, just in the end, both, or never.  
* [0.x.49]*
     Generate output after every call.    
* [0.x.50]*
     Generate output in summary at the end.    
* [0.x.51]*
     Generate output both after every call and in summary at the end.    
* [0.x.52]*
     Never generate any output.    
* [0.x.53]*
   An enumeration data type that describes the type of data to return   when fetching the data from the timer.  
* [0.x.54]*
     Output CPU times.    
* [0.x.55]*
     Output wall clock times.    
* [0.x.56]*
     Output number of calls.    
* [0.x.57]*
   An enumeration data type that describes whether to show CPU times, wall   times, or both CPU and wall times whenever we generate output.  
* [0.x.58]*
     Output CPU times.    
* [0.x.59]*
     Output wall clock times.    
* [0.x.60]*
     Output both CPU and wall clock times in separate tables.    
* [0.x.61]*
     Output both CPU and wall clock times in a single table.    
* [0.x.62]*
   Constructor.      [2.x.59]  stream The stream (of type  [2.x.60]  to which output is   written.    [2.x.61]  output_frequency A variable indicating when output is to be   written to the given stream.    [2.x.62]  output_type A variable indicating what kind of timing the output   should represent (CPU or wall time).  
* [0.x.63]*
   Constructor.      [2.x.63]  stream The stream (of type ConditionalOstream) to which output is   written.    [2.x.64]  output_frequency A variable indicating when output is to be   written to the given stream.    [2.x.65]  output_type A variable indicating what kind of timing the output   should represent (CPU or wall time).  
* [0.x.64]*
   Constructor that takes an MPI communicator as input. A timer constructed   this way will sum up the CPU times over all processors in the MPI network   for calculating the CPU time, or take the maximum over all processors,   depending on the value of  [2.x.66]  . See the documentation of this   class for the rationale for this constructor and an example.      [2.x.67]  mpi_comm An MPI communicator across which we should accumulate or   otherwise synchronize the timing information we produce on every MPI   process.    [2.x.68]  stream The stream (of type  [2.x.69]  to which output is   written.    [2.x.70]  output_frequency A variable indicating when output is to be   written to the given stream.    [2.x.71]  output_type A variable indicating what kind of timing the output   should represent (CPU or wall time). In this parallel context, when this   argument selects CPU time, then times are accumulated over all processes   participating in the MPI communicator. If this argument selects wall   time, then reported times are the maximum over all processors' run times   for this section. (The latter is computed by placing an    [2.x.72]  call before starting and stopping the timer for   each section.  
* [0.x.65]*
   Constructor that takes an MPI communicator as input. A timer constructed   this way will sum up the CPU times over all processors in the MPI network   for calculating the CPU time, or take the maximum over all processors,   depending on the value of  [2.x.73]  . See the documentation of this   class for the rationale for this constructor and an example.      [2.x.74]  mpi_comm An MPI communicator across which we should accumulate or   otherwise synchronize the timing information we produce on every MPI   process.    [2.x.75]  stream The stream (of type ConditionalOstream) to which output is   written.    [2.x.76]  output_frequency A variable indicating when output is to be   written to the given stream.    [2.x.77]  output_type A variable indicating what kind of timing the output   should represent (CPU or wall time). In this parallel context, when this   argument selects CPU time, then times are accumulated over all processes   participating in the MPI communicator. If this argument selects wall   time, then reported times are the maximum over all processors' run times   for this section. (The latter is computed by placing an    [2.x.78]  call before starting and stopping the timer for   each section.)  
* [0.x.66]*
   Destructor. Calls print_summary() in case the option for writing the   summary output is set.  
* [0.x.67]*
   Open a section by given a string name of it. In case the name already   exists, that section is entered once again and times are accumulated.  
* [0.x.68]*
   Leave a section. If no name is given, the last section that was entered   is left.  
* [0.x.69]*
   Get a map with the collected data of the specified type for each subsection  
* [0.x.70]*
   Print a formatted table that summarizes the time consumed in the various   sections.  
* [0.x.71]*
   Print a formatted table that summarizes the wall time consumed in the   various sections, using statistics in terms of the minimum, average, and   maximum of times in the various sections and the MPI ranks where the   minimum and maximum are attained. Note that this call only provides   useful information when the TimerOutput object is constructed without an   MPI_Comm argument, to let individual sections run without being disturbed   by barriers.     The optional argument `quantile` allows to add two additional columns to   the output in terms of the distribution of run times. If quantile = 0.1,   the value and rank of the 10% lowest data is printed as well as the value   and rank at 90% of the distribution function, in addition to the minimum   and the maximum. The value of `quantile` needs to be between 0 (no   quantiles are printed besides the minimum and maximum) and 0.5 (when the   median is given).  
* [0.x.72]*
   By calling this function, all output can be disabled. This function   together with enable_output() can be useful if one wants to control the   output in a flexible way without putting a lot of <tt>if</tt> clauses in   the program.  
* [0.x.73]*
   This function re-enables output of this class if it was previously   disabled with disable_output(). This function together with   disable_output() can be useful if one wants to control the output in a   flexible way without putting a lot of <tt>if</tt> clauses in the program.  
* [0.x.74]*
   Resets the recorded timing information.  
* [0.x.75]*
   When to output information to the output stream.  
* [0.x.76]*
   Whether to show CPU times, wall times, or both CPU and wall times.  
* [0.x.77]*
   A timer object for the overall run time. If we are using MPI, this timer   also accumulates over all MPI processes.  
* [0.x.78]*
   A structure that groups all information that we collect about each of the   sections.  
* [0.x.79]*
   A list of all the sections and their information.  
* [0.x.80]*
   The stream object to which we are to output.  
* [0.x.81]*
   A boolean variable that sets whether output of this class is currently on   or off.  
* [0.x.82]*
   A list of the sections that have been entered and not exited. The list is   kept in the order in which sections have been entered, but elements may   be removed in the middle if an argument is given to the leave_subsection()   function.  
* [0.x.83]*
   mpi communicator  
* [0.x.84]*
   A lock that makes sure that this class gives reasonable results even when   used with several threads.  
* [0.x.85]

include/deal.II-translator/base/time_stepping_0.txt
[0.x.0]*
 Namespace containing the time stepping methods.

* 
* [0.x.1]*
   The following Runge-Kutta methods are available:
* 

* 
* 

* 
* 

* 
* 
*  - Explicit methods (see  [2.x.0] 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - FORWARD_EULER (first order)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - RK_THIRD_ORDER (third order Runge-Kutta)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - SSP_THIRD_ORDER (third order SSP Runge-Kutta)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - RK_CLASSIC_FOURTH_ORDER (classical fourth order Runge-Kutta)
* 

* 
* 

* 
* 

* 
* 
*  - Low-storage (explicit) Runge-Kutta methods
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - LOW_STORAGE_RK_STAGE3_ORDER3 (Three stages and third order)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - LOW_STORAGE_RK_STAGE5_ORDER4 (Five stages and fourth order)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - LOW_STORAGE_RK_STAGE7_ORDER4 (Seven stages and fourth order)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - LOW_STORAGE_RK_STAGE9_ORDER5 (Nine stages and fifth order)
* 

* 
* 

* 
* 

* 
* 
*  - Implicit methods (see  [2.x.1] 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - BACKWARD_EULER (first order)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - IMPLICIT_MIDPOINT (second order)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - CRANK_NICOLSON (second order)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - SDIRK_TWO_STAGES (second order)
* 

* 
* 

* 
* 

* 
* 
*  - Embedded explicit methods (see  [2.x.2] 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - HEUN_EULER (second order)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - BOGACKI_SHAMPINE (third order)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - DOPRI (Dormand-Prince method, fifth order; this is the method used by   ode45 in MATLAB)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - FEHLBERG (fifth order)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - CASH_KARP (fifth order)  
* [0.x.2]*
     Forward Euler method, first order.    
* [0.x.3]*
     Third order Runge-Kutta method.    
* [0.x.4]*
     Third order Strong Stability Preserving (SSP) Runge-Kutta method     (SSP time discretizations are also called Total Variation Diminishing     (TVD) methods in the literature, see  [2.x.3] ).    
* [0.x.5]*
     Classical fourth order Runge-Kutta method.    
* [0.x.6]*
     Three-stage scheme of order three by Kennedy et al.      [2.x.4] . Its stability region is     significantly smaller than the higher order schemes, but due to three     stages only, it is very competitive in terms of the work per stage.    
* [0.x.7]*
     Five-stage scheme of order four,     defined in the paper by Kennedy et al.  [2.x.5] .    
* [0.x.8]*
     Seven-stage scheme of order four defined in the paper by Tselios and     Simos  [2.x.6] .    
* [0.x.9]*
     Nine-stage scheme of order five     defined in the paper by Kennedy et al.  [2.x.7] .    
* [0.x.10]*
     Backward Euler method, first order.    
* [0.x.11]*
     Implicit midpoint method, second order.    
* [0.x.12]*
     Crank-Nicolson method, second order.    
* [0.x.13]*
     Two stage SDIRK method (short for "singly diagonally implicit     Runge-Kutta"), second order.    
* [0.x.14]*
     Heun's method (improved Euler's method), second order.    
* [0.x.15]*
     Bogacki–Shampine method, third-order.    
* [0.x.16]*
     Dormand-Prince method, fifth order; this is the method used by     ode45 in MATLAB.    
* [0.x.17]*
     Fehlberg method, fifth order.    
* [0.x.18]*
     Cash–Karp method, fifth order.    
* [0.x.19]*
     Invalid.    
* [0.x.20]*
   Reason for exiting evolve_one_time_step when using an embedded method:   DELTA_T, MIN_DELTA_T, MAX_DELTA_T.  
* [0.x.21]*
     The time step is in the valid range.    
* [0.x.22]*
     The time step was increased to the minimum acceptable time step.    
* [0.x.23]*
     The time step was reduced to the maximum acceptable time step.    
* [0.x.24]*
   Abstract class for time stepping methods. These methods assume that the   equation has the form:  [2.x.8] .  
* [0.x.25]*
     Virtual destructor.    
* [0.x.26]*
     Purely virtual function. This function is used to advance from time  [2.x.9]      t to t+  [2.x.10]   [2.x.11]  is a vector of functions  [2.x.12]  that     should be integrated, the input parameters are the time t and the     vector y and the output is value of f at this point.  [2.x.13]  is a     vector functions that compute the inverse of the Jacobians associated     to the implicit problems. The input parameters are the time,  [2.x.14] ,     and a vector. The output is the value of function at this point. This     function returns the time at the end of the time step.    
* [0.x.27]*
     Empty structure used to store information.    
* [0.x.28]*
     Purely virtual function that return Status.    
* [0.x.29]*
   Base class for the Runge-Kutta method  
* [0.x.30]*
     Virtual destructor.    
* [0.x.31]*
     Purely virtual method used to initialize the Runge-Kutta method.    
* [0.x.32]*
     This function is used to advance from time  [2.x.15]  to t+  [2.x.16]   [2.x.17]      is a vector of functions  [2.x.18]  that should be integrated, the     input parameters are the time t and the vector y and the output is     value of f at this point.  [2.x.19]  is a vector functions that     compute the inverse of the Jacobians associated to the implicit     problems. The input parameters are the time,  [2.x.20] , and a vector.     The output is the value of function at this point. This function     returns the time at the end of the time step. When using Runge-Kutta     methods,  [2.x.21]  and @ J_inverse can only contain one element.    
* [0.x.33]*
     Purely virtual function. This function is used to advance from time  [2.x.22]      t to t+  [2.x.23]   [2.x.24]   is the function  [2.x.25]  that should be     integrated, the input parameters are the time t and the vector y and     the output is value of f at this point.  [2.x.26]  is a     function that computes  [2.x.27]  where  [2.x.28]  is the identity     matrix,  [2.x.29]  is given, and  [2.x.30]  is the Jacobian  [2.x.31] . The input parameters are the time,  [2.x.32] , and a     vector. The output is the value of function at this point.     evolve_one_time_step returns the time at the end of the time step.    
* [0.x.34]*
     Number of stages of the Runge-Kutta method.    
* [0.x.35]*
     Butcher tableau coefficients.    
* [0.x.36]*
     Butcher tableau coefficients.    
* [0.x.37]*
     Butcher tableau coefficients.    
* [0.x.38]*
   ExplicitRungeKutta is derived from RungeKutta and implement the explicit   methods.  
* [0.x.39]*
     Default constructor. This constructor creates an object for which     you will want to call  [2.x.33]      before it can be used.    
* [0.x.40]*
     Constructor. This function calls initialize(runge_kutta_method).    
* [0.x.41]*
     Initialize the explicit Runge-Kutta method.    
* [0.x.42]*
     This function is used to advance from time  [2.x.34]  to t+  [2.x.35]   [2.x.36]      is the function  [2.x.37]  that should be integrated, the input     parameters are the time t and the vector y and the output is value of f     at this point.  [2.x.38]  is a function that computes  [2.x.39]  where  [2.x.40]  is the identity matrix,  [2.x.41]  is given,     and  [2.x.42]  is the Jacobian  [2.x.43] . The input     parameter are the time,  [2.x.44] , and a vector. The output is the value     of function at this point. evolve_one_time_step returns the time at the     end of the time step.    
* [0.x.43]*
     This function is used to advance from time  [2.x.45]  to t+  [2.x.46]  This     function is similar to the one derived from RungeKutta, but does not     required id_minus_tau_J_inverse because it is not used for explicit     methods. evolve_one_time_step returns the time at the end of the time     step.    
* [0.x.44]*
     This structure stores the name of the method used.    
* [0.x.45]*
     Return the status of the current object.    
* [0.x.46]*
     Compute the different stages needed.    
* [0.x.47]*
     Status structure of the object.    
* [0.x.48]*
   The LowStorageRungeKutta class is derived from RungeKutta and implements a   specific class of explicit methods. The main advantages of low-storage   methods are the reduced memory consumption and the reduced memory access.  
* [0.x.49]*
     Default constructor. This constructor creates an object for which     you will want to call  [2.x.47]      before it can be used.    
* [0.x.50]*
     Constructor. This function calls initialize(runge_kutta_method).    
* [0.x.51]*
     Initialize the explicit Runge-Kutta method.    
* [0.x.52]*
     This function is used to advance from time  [2.x.48]  to t+  [2.x.49]   [2.x.50]      is the function  [2.x.51]  that should be integrated, the input     parameters are the time t and the vector y and the output is value of f     at this point.  [2.x.52]  is a function that computes  [2.x.53]  where  [2.x.54]  is the identity matrix,  [2.x.55]  is given,     and  [2.x.56]  is the Jacobian  [2.x.57] . The input     parameters are the time,  [2.x.58] , and a vector. The output is the value     of function at this point. evolve_one_time_step returns the time at the     end of the time step.    
* [0.x.53]*
     This function is used to advance from time  [2.x.59]  to t+  [2.x.60]  This     function is similar to the one derived from RungeKutta, but does not     required id_minus_tau_J_inverse because it is not used for explicit     methods. evolve_one_time_step returns the time at the end of the time     step. Note that vec_ki holds the evaluation of the differential operator,     and vec_ri holds the right-hand side for the differential operator     application.    
* [0.x.54]*
     Get the coefficients of the scheme.     Note that here vector  [2.x.61]  is not the conventional definition in terms of a     Butcher tableau but merely one of the sub-diagonals. More details can be     found in  [2.x.62]  and the references therein.    
* [0.x.55]*
     This structure stores the name of the method used.    
* [0.x.56]*
     Return the status of the current object.    
* [0.x.57]*
     Compute  one stage of low storage rk.    
* [0.x.58]*
     Status structure of the object.    
* [0.x.59]*
   This class is derived from RungeKutta and implement the implicit methods.   This class works only for Diagonal Implicit Runge-Kutta (DIRK) methods.  
* [0.x.60]*
     Default constructor. initialize(runge_kutta_method) and     set_newton_solver_parameters(unsigned int,double) need to be called     before the object can be used.    
* [0.x.61]*
     Constructor. This function calls initialize(runge_kutta_method) and     initialize the maximum number of iterations and the tolerance of the     Newton solver.    
* [0.x.62]*
     Initialize the implicit Runge-Kutta method.    
* [0.x.63]*
     This function is used to advance from time  [2.x.63]  to t+  [2.x.64]   [2.x.65]      is the function  [2.x.66]  that should be integrated, the input     parameters are the time t and the vector y and the output is value of f     at this point.  [2.x.67]  is a function that computes  [2.x.68]  where  [2.x.69]  is the identity matrix,  [2.x.70]  is given,     and  [2.x.71]  is the Jacobian  [2.x.72] . The input     parameters this function receives are the time,  [2.x.73] , and a vector.     The output is the value of function at this point. evolve_one_time_step     returns the time at the end of the time step.    
* [0.x.64]*
     Set the maximum number of iterations and the tolerance used by the     Newton solver.    
* [0.x.65]*
     Structure that stores the name of the method, the number of Newton     iterations and the norm of the residual when exiting the Newton solver.    
* [0.x.66]*
     Return the status of the current object.    
* [0.x.67]*
     Compute the different stages needed.    
* [0.x.68]*
     Newton solver used for the implicit stages.    
* [0.x.69]*
     Compute the residual needed by the Newton solver.    
* [0.x.70]*
     When using SDIRK, there is no need to compute the linear combination of     the stages. Thus, when this flag is true, the linear combination is     skipped.    
* [0.x.71]*
     Maximum number of iterations of the Newton solver.    
* [0.x.72]*
     Tolerance of the Newton solver.    
* [0.x.73]*
     Status structure of the object.    
* [0.x.74]*
   This class is derived from RungeKutta and implements embedded explicit   methods.  
* [0.x.75]*
     Default constructor. initialize(runge_kutta_method) and     set_time_adaptation_parameters(double, double, double, double, double,     double) need to be called before the object can be used.    
* [0.x.76]*
     Constructor. This function calls initialize(runge_kutta_method) and     initialize the parameters needed for time adaptation.    
* [0.x.77]*
     Destructor.    
* [0.x.78]*
     If necessary, deallocate memory allocated by the object.    
* [0.x.79]*
     Initialize the embedded explicit Runge-Kutta method.    
* [0.x.80]*
     This function is used to advance from time  [2.x.74]  to t+  [2.x.75]   [2.x.76]      is the function  [2.x.77]  that should be integrated, the input     parameters are the time t and the vector y and the output is value of f     at this point.  [2.x.78]  is a function that computes  [2.x.79]  where  [2.x.80]  is the identity matrix,  [2.x.81]  is given,     and  [2.x.82]  is the Jacobian  [2.x.83] . The input     parameters are the time,  [2.x.84] , and a vector. The output is the     value of function at this point. evolve_one_time_step returns the time     at the end of the time step.    
* [0.x.81]*
     This function is used to advance from time  [2.x.85]  to t+  [2.x.86]  This     function is similar to the one derived from TimeStepping, but does not     required id_minus_tau_J_inverse because it is not used for explicit     methods. evolve_one_time_step returns the time at the end of the time     step.    
* [0.x.82]*
     Set the parameters necessary for the time adaptation.    
* [0.x.83]*
     Structure that stores the name of the method, the reason to exit     evolve_one_time_step, the number of iteration inside n_iterations, a     guess of what the next time step should be, and an estimate of the norm     of the error.    
* [0.x.84]*
     Return the status of the current object.    
* [0.x.85]*
     Compute the different stages needed.    
* [0.x.86]*
     This parameter is the factor (>1) by which the time step is multiplied     when the time stepping can be coarsen.    
* [0.x.87]*
     This parameter is the factor (<1) by which the time step is multiplied     when the time stepping must be refined.    
* [0.x.88]*
     Smallest time step allowed.    
* [0.x.89]*
     Largest time step allowed.    
* [0.x.90]*
     Refinement tolerance: if the error estimate is larger than refine_tol,     the time step is refined.    
* [0.x.91]*
     Coarsening tolerance: if the error estimate is smaller than coarse_tol,     the time step is coarsen.    
* [0.x.92]*
     If the flag is true, the last stage is the same as the first stage and     one evaluation of f can be saved.    
* [0.x.93]*
     Butcher tableau coefficients.    
* [0.x.94]*
     Butcher tableau coefficients.    
* [0.x.95]*
     If the last_same_as_first flag is set to true, the last stage is saved     and reused as the first stage of the next time step.    
* [0.x.96]*
     Status structure of the object.    
* [0.x.97]

include/deal.II-translator/base/time_stepping.templates_0.txt
[0.x.0]

include/deal.II-translator/base/types_0.txt
[0.x.0]*
 A namespace in which we declare alias for types used in deal.II, as well as special values for these types.

* 
* [0.x.1]*
   The type used to denote subdomain_ids of cells.     See the    [2.x.0]  "glossary"   for more information.     There is a special value,  [2.x.1]  that is used to   indicate an invalid value of this type.  
* [0.x.2]*
   The type used for global indices of vertices.  
* [0.x.3]*
   An identifier that denotes the MPI type associated with    [2.x.2]   
* [0.x.4]*
   The type used to denote the global index of degrees of freedom. This   type is then also used for querying the globalnumber* of degrees   of freedom, since the number is simply the largest index plus one.     While in sequential computations the 4 billion indices of 32-bit unsigned   integers is plenty, parallel computations using (for example) the    [2.x.3]  class can overflow this number and   consequently, deal.II chooses a larger integer type when   configured to use 64-bit indices.     The data type always corresponds to an unsigned integer type.     See the    [2.x.4]    page for guidance on when this type should or should not be used.  
* [0.x.5]*
   An identifier that denotes the MPI type associated with    [2.x.5]   
* [0.x.6]*
   The type used to denote the global index of a cell. This type   is then also used for querying the globalnumber* of cells in   a triangulation since the number is simply the largest index plus one.     While in sequential computations the 4 billion indices of 32-bit unsigned   integers is plenty, parallel computations using (for example) the    [2.x.6]  class can overflow this number and   consequently, deal.II chooses a larger integer type when   configured to use 64-bit indices.     The data type always corresponds to an unsigned integer type.  
* [0.x.7]*
   The type used for coarse-cell ids. See the glossary   entry on    [2.x.7]  "coarse cell IDs"   for more information.  
* [0.x.8]*
   The type used to denote boundary indicators associated with every piece   of the boundary and, in the case of meshes that describe manifolds in   higher dimensions, associated with every cell.     There is a special value,  [2.x.8]  that is used   to indicate an invalid value of this type and that is used as the   boundary indicator for faces that are in the interior of the domain and   therefore not part of any addressable boundary component.      [2.x.9]     [2.x.10]  "Glossary entry on boundary indicators"  
* [0.x.9]*
   The type used to denote manifold indicators associated with every object   of the mesh.     There is a special value,  [2.x.11]  that is used to   indicate the standard cartesian manifold.      [2.x.12]     [2.x.13]  "Glossary entry on manifold indicators"  
* [0.x.10]*
   The type used to denote material indicators associated with every cell.     There is a special value,  [2.x.14]  that is used to   indicate an invalid value of this type.      [2.x.15]     [2.x.16]  "Glossary entry on material indicators"  
* [0.x.11]*
   The type used to denote geometric entity types.  
* [0.x.12]*
 Declare type used in Epetra.

* 
* [0.x.13]*
     Declare type of integer used in the Epetra package of Trilinos.    
* [0.x.14]*
     Declare type of integer used in the Epetra package of Trilinos.    
* [0.x.15]*
   Representation of the largest number that can be put into an unsigned   integer. This value is widely used throughout the library as a marker for   an invalid unsigned integer value, such as an invalid array index, an   invalid array size, and the like.  
* [0.x.16]*
   Representation of the largest number that can be put into a size_type.   This value is used throughout the library as a marker for an invalid   size_type value, such as an invalid array index, an invalid array size,   and the like. Invalid_size_type is equivalent to invalid_dof_index.  
* [0.x.17]*
   An invalid value for indices of degrees of freedom.  
* [0.x.18]*
   An invalid value for coarse cell ids. See the glossary   entry on    [2.x.17]  "coarse cell IDs"   for more information.  
* [0.x.19]*
   Invalid material_id which we need in several places as a default value.   We assume that all material_ids lie in the range [0,   invalid_material_id).  
* [0.x.20]*
   Invalid boundary_id which we need in several places as a default value.   We assume that all valid boundary_ids lie in the range [0,   invalid_boundary_id).      [2.x.18]     [2.x.19]  "Glossary entry on boundary indicators"  
* [0.x.21]*
   A boundary indicator number that we reserve for internal faces.  We   assume that all valid boundary_ids lie in the range [0,   internal_face_boundary_id).     This is an indicator that is used internally (by the library) to   differentiate between faces that lie at the boundary of the domain and   faces that lie in the interior of the domain. You should never try to   assign this boundary indicator to anything in user code.      [2.x.20]     [2.x.21]  "Glossary entry on boundary indicators"  
* [0.x.22]*
   A manifold_id we reserve for the default flat Cartesian manifold.      [2.x.22]     [2.x.23]  "Glossary entry on manifold indicators"  
* [0.x.23]*
   A special id for an invalid subdomain id. This value may not be used as a   valid id but is used, for example, for default arguments to indicate a   subdomain id that is not to be used.     See the    [2.x.24]  "glossary"   for more information.  
* [0.x.24]*
   The subdomain id assigned to a cell whose true subdomain id we don't   know, for example because it resides on a different processor on a mesh   that is kept distributed on many processors. Such cells are called   "artificial".     See the glossary entries on    [2.x.25]  "subdomain ids"   and    [2.x.26]  "artificial cells"   as well as the    [2.x.27]    module for more information.  
* [0.x.25]

include/deal.II-translator/base/undefine_macros_0.txt
[0.x.0]

include/deal.II-translator/base/utilities_0.txt
[0.x.0]*
 A namespace for utility functions that are not particularly specific to finite element computing or numerical programs, but nevertheless are needed in various contexts when writing applications.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Return a string of the form "deal.II version x.y.z" where "x.y.z"   identifies the version of deal.II you are using. This information   is also provided by the DEAL_II_PACKAGE_NAME and   DEAL_II_PACKAGE_VERSION preprocessor variables.  
* [0.x.2]*
   Assign to each point in  [2.x.1]  an index using the Hilbert space filling curve.   To that end, a bounding box for  [2.x.2]  will be determined, based on which their   integer coordinates are calculated.   The linear index is given as a dim-collection of bits, from high to low.   This is done in order to keep the maximum resolution in terms of bit depth   along each axis. Note that this dim-integer index can still be easily used   for sorting and ordering, for example using the lexicographic ordering of   tuples of integers.     The depth of the Hilbert curve (i.e. the number of bits per dimension) by   default is equal to  [2.x.3] .    
*  [2.x.4]  This function can also handle degenerate cases, e.g. when the bounding   box has zero size in one of the dimensions.  
* [0.x.3]*
   Same as above, but for points in integer coordinates.  
* [0.x.4]*
   Pack the least significant  [2.x.5]  bits from each element of  [2.x.6]    (starting from last) into a single unsigned integer. The last element   of  [2.x.7]  will be used to set the first  [2.x.8]  bits in the   resulting integer, the second to last element is used to set the next  [2.x.9]  bits,   etc.. To fit all the data into the output, the following should hold    [2.x.10] .     The function is useful in debugging and visualization of indices returned   by inverse_Hilbert_space_filling_curve().    
*  [2.x.11]  There is no need to use this function in order to compare indices   returned by inverse_Hilbert_space_filling_curve(), as that can easily be   done via  [2.x.12] .  
* [0.x.5]*
   If the library is configured with ZLIB, then this function compresses the   input string and returns a non-zero terminated string containing the   compressed input.     If the library was not configured with ZLIB enabled, the returned string   is identical to the input string.      [2.x.13]  input The string to compress      [2.x.14]  A compressed version of the input string  
* [0.x.6]*
   If the library is configured with ZLIB, then this function assumes that the   input string has been compressed using the compress() function, and returns   the original decompressed string.     If the library was not configured with ZLIB enabled, the returned string   is identical to the input string.      [2.x.15]  compressed_input A compressed string, as returned by the   function compress()      [2.x.16]  The original uncompressed string.  
* [0.x.7]*
   Encodes the binary input as a base64 string.     Base64 is a group of binary-to-text encoding schemes that represent binary   data in an ASCII string format by translating it into a radix-64   representation. Base64 is designed to carry data stored in binary formats   across channels that only reliably support text content. It is used also   to store binary formats in a machine independent way.      [2.x.17]  binary_input A vector of characters, representing your input as   binary data.    [2.x.18]  A string containing the binary input as a base64 string.  
* [0.x.8]*
   Decodes a base64 string into a binary output.     This is the inverse of the encode_base64() function above.      [2.x.19]  base64_input A string that contains the input in base64 format.    [2.x.20]  A vector of characters that represents your input as binary data.  
* [0.x.9]*
   Convert a number  [2.x.21]  to a string, with as many digits as given to   fill with leading zeros.     If the second parameter is left at its default value, the number is not   padded with leading zeros. The result is then the same as if the standard   C++  [2.x.22]  (or the older C function `itoa()`) had been called.     This function takes an `unsigned int` as argument. As a consequence,   if you call it with a `signed int` (which is of course the same   type as `int`), the argument is implicitly converted to   unsigned integers and negative numbers may not be printed as you had   hoped. Similarly, if you call the function with a `long int`, the   printed result might show the effects of an overflow upon conversion   to `unsigned int`.    
*  [2.x.23]  The use of this function is discouraged and users should use    [2.x.24]  instead. In its current   implementation the function simply calls <code>to_string [2.x.25]    int [2.x.26]   
* [0.x.10]*
   Convert a number  [2.x.27]  to a string, with  [2.x.28]  characters. The   string is padded with leading zeros, after a possible minus sign.   Therefore the total number of padding zeros is  [2.x.29]  minus any signs,   decimal points and digits of  [2.x.30]      If the second parameter is left at its default value, the number is not   padded with leading zeros. The result is then the same as if the C++   function  [2.x.31]  had been called (for integral types),   or if  [2.x.32]  had been called (for all other types).  
* [0.x.11]*
   Determine how many digits are needed to represent numbers at most as   large as the given number.  
* [0.x.12]*
   This function allows to cut off a floating point number  [2.x.33]    after  [2.x.34]  of accuracy, i.e., after  [2.x.35]  decimal places   in scientific floating point notation. When interpreted as rounding   operation, this function reduces the absolute value of a floating point   number and always rounds towards zero, since decimal places are simply   cut off.  
* [0.x.13]*
   Given a string, convert it to an integer. Throw an assertion if that is   not possible.  
* [0.x.14]*
   Return a string describing the dimensions of the object. Often, functions   in the deal.II library as well as in user codes need to define a string   containing the template dimensions of some objects defined using two   template parameters: dim (the topological dimension of the object) and   spacedim (the dimension of the embedding Euclidean space).  Since in all   deal.II classes, by default spacedim is equal to dimension, the above   string is usually contracted to "<dim>", instead of "<dim,spacedim>".   This function returns a string containing "dim" if dim is equal to   spacedim, otherwise it returns "dim,spacedim".  
* [0.x.15]*
   Given a list of strings, convert it to a list of integers. Throw an   assertion if that is not possible.  
* [0.x.16]*
   Given a string, convert it to an double. Throw an assertion if that is   not possible.  
* [0.x.17]*
   Given a list of strings, convert it to a list of doubles. Throw an   assertion if that is not possible.  
* [0.x.18]*
   Given a string that contains text separated by a  [2.x.36]  split it   into its components; for each component, remove leading and trailing   spaces. The default value of the delimiter is a comma, so that the   function splits comma separated lists of strings.     To make data input from tables simpler, if the input string ends in a   delimiter (possibly followed by an arbitrary amount of whitespace), then   this last delimiter is ignored. For example,  
* [1.x.0]
*    yields the same 3-element list of output  [2.x.37]    as you would get if the input had been  
* [1.x.1]
*    or  
* [1.x.2]
*    As a consequence of this rule, a call like  
* [1.x.3]
*    yields a one-element list. Because of the trimming of whitespace, the   single element is the empty string.     This function can digest the case that the delimiter is a space. In this   case, it returns all words in the string. Combined with the rules above,   this implies that  
* [1.x.4]
*    yields again the 3-element list of output    [2.x.38]  from above despite the presence of space   at the end of the string. Furthermore,  
* [1.x.5]
*    yields an empty list regardless of the number of spaces in the string.  
* [0.x.19]*
   Specialization of split_string_list() for the case where the delimiter   is a single char.  
* [0.x.20]*
   Take a text, usually a documentation or something, and try to break it   into individual lines of text at most  [2.x.39]  characters wide, by   breaking at positions marked by  [2.x.40]  in the text. If this is not   possible, return the shortest lines that are longer than  [2.x.41]   The   default value of the delimiter is a space character. If original_text   contains newline characters (\n), the string is split at these locations,   too.  
* [0.x.21]*
   Return true if the given pattern string appears in the first position of   the string.  
* [0.x.22]*
   Read a (signed) integer starting at the position in  [2.x.42]  indicated by   the second argument, and return this integer as a pair together with how   many characters it takes up in the string.     If no integer can be read at the indicated position, return    [2.x.43]   
* [0.x.23]*
   Return a string with all occurrences of  [2.x.44]  in  [2.x.45]  replaced by    [2.x.46]   
* [0.x.24]*
   Return a string with all standard whitespace characters (including   '<tt>\\t</tt>', '<tt>\\n</tt>', and '<tt>\\r</tt>') at the beginning and   end of  [2.x.47]  removed.  
* [0.x.25]*
   Generate a random number from a normalized Gaussian probability   distribution centered around  [2.x.48]  and with standard deviation  [2.x.49]    The returned number will be different every time the function is called.     This function is reentrant, i.e., it can safely be called from multiple   threads at the same time. In addition, each thread will get the same   sequence of numbers every time. On the other hand, if you run    [2.x.50]  objects via the Threading Building Blocks, then tasks will   be assigned to mostly random threads, and may get a different sequence of   random numbers in different runs of the program, since a previous task   may already have consumed the first few random numbers generated for the   thread you're on. If this is a problem, you need to create your own   random number generator objects every time you want to start from a   defined point.    
*  [2.x.51]  Like the system function rand(), this function produces the same   sequence of random numbers every time a program is started. This is an   important property for debugging codes, but it makes it impossible to   really verify statistical properties of a code. For `rand()`, you can call   `srand()` to "seed" the random number generator to get different sequences   of random numbers every time a program is called. However, this function   does not allow seeding the random number generator. If you need this, as   above, use one of the C++ or BOOST facilities.  
* [0.x.26]*
   Return a string description of the type of the variable  [2.x.52]      In general, C++ uses mangled names to identify types. This function   uses  [2.x.53]  to return a human readable string describing   the type of the variable passed as argument.  
* [0.x.27]*
   Calculate a fixed power, provided as a template argument, of a number.     This function provides an efficient way to calculate things like    [2.x.54]  is a known number at compile time.     Use this function as in  [2.x.55] .  
* [0.x.28]*
   A replacement for  [2.x.56]  that allows compile-time   calculations for constant expression arguments. The  [2.x.57]  must   be an integer type and the exponent  [2.x.58]  must not be negative.  
* [0.x.29]*
   Optimized replacement for  [2.x.59]  for searching within   the range of column indices. Slashes execution time by approximately one   half for the present application, partly because the binary search is   replaced by a linear search for small loop lengths.     Another reason for this function is rather obscure: when using the GCC   libstdc++ function  [2.x.60]  complexity is O(log(N)) as required.   However, when using the debug version of the GCC libstdc++ as we do when   running the testsuite, then  [2.x.61]  tests whether the sequence   is in fact partitioned with respect to the pivot 'value' (i.e. in essence   that the sequence is sorted as required for binary search to work).   However, verifying this means that the complexity of  [2.x.62]    jumps to O(N); we call this function O(N) times below, making the overall   complexity O(N**2). The consequence is that a few tests with big meshes   completely run off the wall time limit for tests and fail with the   libstdc++ debug mode     This function simply makes the assumption that the sequence is sorted,   and we simply don't do the additional check.  
* [0.x.30]*
   The same function as above, but taking an argument that is used to   compare individual elements of the sequence of objects pointed to by the   iterators.  
* [0.x.31]*
   Given a permutation vector (i.e. a vector  [2.x.63]  where each    [2.x.64]  and  [2.x.65]  for  [2.x.66] ), produce the reverse   permutation  [2.x.67] .  
* [0.x.32]*
   Given a permutation vector (i.e. a vector  [2.x.68]  where each    [2.x.69]  and  [2.x.70]  for  [2.x.71] ), produce the inverse   permutation  [2.x.72]  so that  [2.x.73] .  
* [0.x.33]*
   Given an arbitrary object of type T, use  [2.x.74]  utilities   to pack the object into a vector of characters and append it to the   given buffer. The number of elements that have been added to the buffer   will be returned. The object can be unpacked using the  [2.x.75]    function below.     If the library has been compiled with ZLIB enabled, then the output buffer   can be compressed. This can be triggered with the parameter    [2.x.76]  and is only of effect if ZLIB is enabled.     If many consecutive calls with the same buffer are considered, it is   recommended for reasons of performance to ensure that its capacity is   sufficient.  
* [0.x.34]*
   Creates and returns a buffer solely for the given object, using the   above mentioned pack function.     If the library has been compiled with ZLIB enabled, then the output buffer   can be compressed. This can be triggered with the parameter    [2.x.77]  and is only of effect if ZLIB is enabled.  
* [0.x.35]*
   Given a vector of characters, obtained through a call to the function    [2.x.78]  restore its content in an object of type T.     This function uses  [2.x.79]  utilities to unpack the object   from a vector of characters, and it is the inverse of the function    [2.x.80]      The  [2.x.81]  parameter denotes if the buffer to   read from could have been previously compressed with ZLIB, and   is only of effect if ZLIB is enabled.    
*  [2.x.82]  Since no arguments to this function depend on the template type     [2.x.83]  you must manually specify the template argument when calling    this function.    
*  [2.x.84]  If you want to pack() or unpack() arrays of objects, then the    following works:   
* [1.x.6]
*     However, the converse does not:   
* [1.x.7]
*     This is because C++ does not allow functions to return arrays.    Consequently, there is a separate unpack() function for arrays, see    below.  
* [0.x.36]*
   Same unpack function as above, but takes constant iterators on   (a fraction of) a given packed buffer of type  [2.x.85]  instead.     The  [2.x.86]  parameter denotes if the buffer to   read from could have been previously compressed with ZLIB, and   is only of effect if ZLIB is enabled.  
* [0.x.37]*
   Given a vector of characters, obtained through a call to the function    [2.x.87]  restore its content in an array of type T.     This function uses  [2.x.88]  utilities to unpack the object   from a vector of characters, and it is the inverse of the function    [2.x.89]      The  [2.x.90]  parameter denotes if the buffer to   read from could have been previously compressed with ZLIB, and   is only of effect if ZLIB is enabled.    
*  [2.x.91]  This function exists due to a quirk of C++. Specifically,    if you want to pack() or unpack() arrays of objects, then the    following works:   
* [1.x.8]
*     However, the converse does not:   
* [1.x.9]
*     This is because C++ does not allow functions to return arrays.    The current function therefore allows to write   
* [1.x.10]
*     Note that unlike the other unpack() function, it is not necessary    to explicitly specify the template arguments since they can be    deduced from the second argument.  
* [0.x.38]*
   Same unpack function as above, but takes constant iterators on   (a fraction of) a given packed buffer of type  [2.x.92]  instead.     The  [2.x.93]  parameter denotes if the buffer to   read from could have been previously compressed with ZLIB, and   is only of effect if ZLIB is enabled.  
* [0.x.39]*
   Check if the bit at position  [2.x.94]  in  [2.x.95]  is set.  
* [0.x.40]*
   Set the bit at position  [2.x.96]  in  [2.x.97]  to value  [2.x.98]   
* [0.x.41]*
   Convert an object of type  [2.x.99]  to an object of   type  [2.x.100]  where it is assumed that we can cast   the pointer to `From` to a pointer to `To` using a `dynamic_cast`
* 

* 
* 

* 
* 

* 
* 
*  -  in other words, we assume that `From` and `To` are connected   through a class hierarchy, and that the object pointed to is in   fact of a type that contains both a `From` and a `To`. An example   is if either `To` is derived from `From` or the other way around.     The function throws an exception of type  [2.x.101]  if the   `dynamic_cast` does not succeed. This is the same exception you   would get if a regular `dynamic_cast` between object types (but not   pointer types) does not succeed.     An example of how this function works is as follows:  
* [1.x.11]
*     
*  [2.x.102]  This function does not try to convert the `Deleter` objects stored     by  [2.x.103]  objects. The function therefore only works if the     deleter objects are at their defaults, i.e., if they are of type      [2.x.104]  and  [2.x.105]   
* [0.x.42]*
   Return underlying value. Default: return input.  
* [0.x.43]*
   Return underlying value. Specialization for  [2.x.106]   
* [0.x.44]*
   Return underlying value. Specialization for const  [2.x.107]   
* [0.x.45]*
   Return underlying value. Specialization for  [2.x.108]   
* [0.x.46]*
   Return underlying value. Specialization for const  [2.x.109]   
* [0.x.47]*
   A namespace for utility functions that probe system properties.    
*  [2.x.110]   
* [0.x.48]*
     Return the CPU load as returned by "uptime". Note that the     interpretation of this number depends on the actual number of     processors in the machine. This is presently only implemented on Linux,     using the /proc/loadavg pseudo-file, on other systems we simply return     zero.    
* [0.x.49]*
     Return the instruction set extension for vectorization as described by     DEAL_II_VECTORIZATION_WIDTH_IN_BITS in vectorization.h as a string. The     list of possible return values is:          [2.x.111]     
* [0.x.50]*
     Structure that hold information about memory usage in kB. Used by     get_memory_stats(). See man 5 proc entry /status for details.    
* [0.x.51]*
       Peak virtual memory size in kB.      
* [0.x.52]*
       Current virtual memory size in kB.      
* [0.x.53]*
       Peak resident memory size in kB. Also known as "high water mark" (HWM).      
* [0.x.54]*
       Current resident memory size in kB. Also known as "resident set size"       (RSS).      
* [0.x.55]*
     Fill the  [2.x.112]  structure with information about the memory     consumption of this process. This is only implemented on Linux.    
* [0.x.56]*
     Return the name of the host this process runs on.    
* [0.x.57]*
     Return the present time as HH:MM:SS.    
* [0.x.58]*
     Return the present date as YYYY/MM/DD. MM and DD may be either one or     two digits.    
* [0.x.59]*
     Call the system function posix_memalign, or a replacement function if     not available, to allocate memory with a certain minimal alignment. The     first argument will then return a pointer to this memory block that can     be released later on through a standard  [2.x.113]  call.          [2.x.114]  memptr The address of a pointer variable that will after this     call point to the allocated memory.      [2.x.115]  alignment The minimal alignment of the memory block, in bytes.      [2.x.116]  size The size of the memory block to be allocated, in bytes.        
*  [2.x.117]  This function checks internally for error codes, rather than     leaving this task to the calling site.    
* [0.x.60]*
   This namespace provides some of the basic structures used in the   initialization of the Trilinos objects (e.g., matrices, vectors, and   preconditioners).  
* [0.x.61]*
     Return a Trilinos Epetra_Comm object needed for creation of     Epetra_Maps.         If deal.II has been configured to use a compiler that does not support     MPI then the resulting communicator will be a serial one. Otherwise,     the communicator will correspond to MPI_COMM_WORLD, i.e. a communicator     that encompasses all processes within this MPI universe.    
* [0.x.62]*
     Return a Trilinos Epetra_Comm object needed for creation of     Epetra_Maps.         If deal.II has been configured to use a compiler that does not support     MPI then the resulting communicator will be a serial one. Otherwise,     the communicator will correspond to MPI_COMM_SELF, i.e. a communicator     that comprises only this one processor.    
* [0.x.63]*
     Return a  [2.x.118]  object needed for creation of  [2.x.119]          If deal.II has been configured to use a compiler that does not support     MPI then the resulting communicator will be a serial one. Otherwise,     the communicator will correspond to MPI_COMM_SELF, i.e. a communicator     that comprises only this one processor.    
* [0.x.64]*
     Given a communicator, duplicate it. If the given communicator is     serial, that means to just return a copy of itself. On the other hand,     if it is %parallel, we duplicate the underlying MPI_Comm object: we     create a separate MPI communicator that contains the same processors     and in the same order but has a separate identifier distinct from the     given communicator. The function returns a pointer to a new object of a     class derived from Epetra_Comm. The caller of this function needs to     assume ownership of this function. The returned object should be     destroyed using the destroy_communicator() function.         This facility is used to separate streams of communication. For     example, a program could simply use MPI_Comm_World for everything. But     it is easy to come up with scenarios where sometimes not all processors     participate in a communication that is intended to be global
* 
*  -  for     example if we assemble a matrix on a coarse mesh with fewer cells than     there are processors, some processors may not sync their matrices with     the rest because they haven't written into it because they own no     cells. That's clearly a bug. However, if these processors just continue     their work, and the next %parallel operation happens to be a sync on a     different matrix, then the sync could succeed
* 
*  -  by accident, since     different processors are talking about different matrices.         This kind of situation can be avoided if we use different communicators     for different matrices which reduces the likelihood that communications     meant to be separate aren't recognized as such just because they happen     on the same communicator. In addition, it is conceivable that some MPI     operations can be parallelized using multiple threads because their     communicators identifies the communication in question, not their     relative timing as is the case in a sequential program that just uses a     single communicator.    
* [0.x.65]*
     Given an Epetra communicator that was created by the     duplicate_communicator() function, destroy the underlying MPI     communicator object and reset the Epetra_Comm object to a the result of     comm_self().         It is necessary to call this function at the time when the result of     duplicate_communicator() is no longer needed. The reason is that in     that function, we first create a new MPI_Comm object and then create an     Epetra_Comm around it. While we can take care of destroying the latter,     it doesn't destroy the communicator since it can only assume that it     may also be still used by other objects in the program. Consequently,     we have to take care of destroying it ourselves, explicitly.         This function does exactly that. Because this has to happen while the     Epetra_Comm object is still around, it first resets the latter and then     destroys the communicator object.        
*  [2.x.120]  If you call this function on an Epetra_Comm object that is not     created by duplicate_communicator(), you are likely doing something     quite wrong. Don't do this.    
* [0.x.66]*
     Return the number of MPI processes there exist in the given      [2.x.121]  "communicator"     object. If this is a sequential job (i.e., the program     is not using MPI at all, or is using MPI but has been started with     only one MPI process), then the communicator necessarily involves     only one process and the function returns 1.    
* [0.x.67]*
     Return the number of the present MPI process in the space of processes     described by the given communicator. This will be a unique value for     each process between zero and (less than) the number of all processes     (given by get_n_mpi_processes()).    
* [0.x.68]*
     Given a Trilinos Epetra map, create a new map that has the same     subdivision of elements to processors but uses the given communicator     object instead of the one stored in the first argument. In essence,     this means that we create a map that communicates among the same     processors in the same way, but using a separate channel.         This function is typically used with a communicator that has been     obtained by the duplicate_communicator() function.    
* [0.x.69]

include/deal.II-translator/base/vectorization_0.txt
[0.x.0]*
 An iterator for VectorizedArray.

* 
* [0.x.1]*
   Constructor.      [2.x.0]  data The actual VectorizedArray.    [2.x.1]  lane A pointer to the current lane.  
* [0.x.2]*
   Compare for equality.  
* [0.x.3]*
   Compare for inequality.  
* [0.x.4]*
   Copy assignment.  
* [0.x.5]*
   Dereferencing operator (const version): returns the value of the current   lane.  
* [0.x.6]*
   Dereferencing operator (non- [2.x.2]  version): returns the value of the   current lane.  
* [0.x.7]*
   Prefix <tt>++</tt> operator: <tt>++iterator</tt>. This operator advances   the iterator to the next lane and returns a reference to   <tt>*this</tt>.  
* [0.x.8]*
   This operator advances the iterator by  [2.x.3]  lanes and returns a   reference to <tt>*this</tt>.  
* [0.x.9]*
   Prefix <tt>--</tt> operator: <tt>--iterator</tt>. This operator advances   the iterator to the previous lane and returns a reference to   <tt>*this</tt>.  
* [0.x.10]*
   Create new iterator, which is shifted by  [2.x.4]   
* [0.x.11]*
   Compute distance between this iterator and iterator  [2.x.5]   
* [0.x.12]*
   Pointer to the actual VectorizedArray.  
* [0.x.13]*
   Pointer to the current lane.  
* [0.x.14]*
 A base class for the various VectorizedArray template specializations, containing common functionalities.
*   [2.x.6]  T Type of the actual vectorized array. We are using the   Couriously Recurring Template Pattern (see   https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern) in this   class to avoid having to resort to `virtual` member functions.

* 
* [0.x.15]*
   Return the number of elements in the array.  
* [0.x.16]*
    [2.x.7]  An iterator pointing to the beginning of the underlying data.  
* [0.x.17]*
    [2.x.8]  An iterator pointing to the beginning of the underlying data (`const`   version).  
* [0.x.18]*
    [2.x.9]  An iterator pointing to the end of the underlying data.  
* [0.x.19]*
    [2.x.10]  An iterator pointing to the end of the underlying data (`const`   version).  
* [0.x.20]*
 This generic class defines a unified interface to a vectorized data type. For general template arguments, this class simply corresponds to the template argument. For example, VectorizedArray<long double> is nothing else but a wrapper around <tt>long double</tt> with exactly one data field of type <tt>long double</tt> and overloaded arithmetic operations. This means that <tt>VectorizedArray<ComplicatedType></tt> has a similar layout as ComplicatedType, provided that ComplicatedType defines basic arithmetic operations. For floats and doubles, an array of numbers are packed together with the goal to be processed in a single-instruction/multiple-data (SIMD) fashion. In the SIMD context, the elements of such a short vector are often called lanes. The number of elements packed together, i.e., the number of lanes, depends on the computer system and compiler flags that are used for compilation of deal.II. The fundamental idea of these packed data types is to use one single CPU instruction to perform arithmetic operations on the whole array using the processor's vector (SIMD) units. Most computer systems by 2010 standards will use an array of two doubles or four floats, respectively (this corresponds to the SSE/SSE2 data sets) when compiling deal.II on 64-bit operating systems. On Intel Sandy Bridge processors and newer or AMD Bulldozer processors and newer, four doubles or eight floats are used when deal.II is configured using gcc with \--with-cpu=native or \--with-cpu=corei7-avx. On compilations with AVX-512 support (e.g., Intel Skylake Server from 2017), eight doubles or sixteen floats are used.
*  This behavior of this class is made similar to the basic data types double and float. The definition of a vectorized array does not initialize the data field but rather leaves it undefined, as is the case for double and float. However, when calling something like `VectorizedArray<double> a = VectorizedArray<double>()` or `VectorizedArray<double> a = 0.`, it sets all numbers in this field to zero. This class is of standard layout type according to the C++11 standard, which means that there is an equivalent C representation and the class can e.g. be safely copied with  [2.x.11]  (See also https://en.cppreference.com/w/cpp/named_req/StandardLayoutType.) The standard layout is also necessary for ensuring correct alignment of data with address boundaries when collected in a vector (i.e., when the first element in a vector is properly aligned, all subsequent elements will be correctly aligned, too).
*  Note that for proper functioning of this class, certain data alignment rules must be respected. This is because the computer expects the starting address of a VectorizedArray<double> field at specific addresses in memory (usually, the address of the vectorized array should be a multiple of the length of the array in bytes). Otherwise, a segmentation fault or a severe loss of performance might occur. When creating a single data field on the stack like `VectorizedArray<double> a = 5.;`, the compiler will take care of data alignment automatically. However, when allocating a long vector of VectorizedArray<double> data, one needs to respect these rules. Use the class AlignedVector or data containers based on AlignedVector (such as Table) for this purpose. It is a class very similar to  [2.x.12]  otherwise but always makes sure that data is correctly aligned.
*  The user can explicitly control the width of a particular instruction set architecture (ISA) extension by specifying the number of lanes via the second template parameter of this wrapper class. For example on Intel Skylake Server, you have the following options for the data type double:
* 

* 
* 

* 
* 
*  - VectorizedArray<double, 1> // no vectorization (auto-optimization)
* 

* 
* 

* 
* 
*  - VectorizedArray<double, 2> // SSE2
* 

* 
* 

* 
* 
*  - VectorizedArray<double, 4> // AVX
* 

* 
* 

* 
* 
*  - VectorizedArray<double, 8> // AVX-512 (default)
*  and for Intel Sandy Bridge, Haswell, Broadwell, AMD Bulldozer and Zen/Ryzen:
* 

* 
* 

* 
* 
*  - VectorizedArray<double, 1> // no vectorization (auto-optimization)
* 

* 
* 

* 
* 
*  - VectorizedArray<double, 2> // SSE2
* 

* 
* 

* 
* 
*  - VectorizedArray<double, 4> // AVX (default)
*  and for processors with AltiVec support:
* 

* 
* 

* 
* 
*  - VectorizedArray<double, 1>
* 

* 
* 

* 
* 
*  - VectorizedArray<double, 2>
*  for older x86 processors or in case no processor-specific compilation flags were added (i.e., without `-D CMAKE_CXX_FLAGS=-march=native` or similar flags):
* 

* 
* 

* 
* 
*  - VectorizedArray<double, 1> // no vectorization (auto-optimization)
* 

* 
* 

* 
* 
*  - VectorizedArray<double, 2> // SSE2
*  Similar considerations also apply to the data type `float`.
*  Wrongly selecting the width, e.g., width=3 or width=8 on a processor which does not support AVX-512 leads to a static assert.
*   [2.x.13]  Number underlying data type  [2.x.14]  width  vector length (optional; if not set, the maximal width of the                architecture is used)

* 
* [0.x.21]*
   This gives the type of the array elements.  
* [0.x.22]*
   Default empty constructor, leaving the data in an uninitialized state   similar to float/double.  
* [0.x.23]*
   Construct an array with the given scalar broadcast to all lanes.  
* [0.x.24]*
   This function assigns a scalar to this class.  
* [0.x.25]*
   Access operator (only valid with component 0 in the base class without   specialization).  
* [0.x.26]*
   Constant access operator (only valid with component 0 in the base class   without specialization).  
* [0.x.27]*
   Addition  
* [0.x.28]*
   Subtraction  
* [0.x.29]*
   Multiplication  
* [0.x.30]*
   Division  
* [0.x.31]*
   Load size() data items from memory into the calling class, starting at   the given address. The pointer `ptr` needs not be aligned by the amount   of bytes in the vectorized array, as opposed to casting a double address   to VectorizedArray<double>*.  
* [0.x.32]*
   Write the content of the calling class into memory in form of   size() data items to the given address. The pointer `ptr` needs not be   aligned by the amount of bytes in the vectorized array, as opposed to   casting a double address to VectorizedArray<double>*.  
* [0.x.33]*
   Write the content of the calling class into memory in form of   size() data items to the given address using non-temporal stores that   bypass the processor's caches, using  [2.x.15]  store intrinsics on   supported CPUs. The destination of the store  [2.x.16]  must be aligned by   the amount of bytes in the vectorized array.     This store operation can be faster than usual store operations in case   the store is streaming because it avoids the read-for-ownership transfer   typically invoked in standard stores. This approximately works as follows   (see the literature on computer architecture for details): When an   algorithm stores some results to a memory address, a processor typically   wants to move it into some of its caches as it expects the data to be   re-used again at some point. Since caches are organized in lines of sizes   either 64 byte or 128 byte but writes are usually smaller, a processor   must first load in the destination cache line upon a write because only   part of the cache line is overwritten initially. If a series of stores   write data in a chunk bigger than any of its caches could handle, the   data finally has to be moved out from the caches to main memory. But   since all addressed have first been read, this doubles the load on main   memory, which can incur a performance penalty. Furthermore, the   organization of caches in a multicore context also requires reading an   address before something can be written to cache to that address, see   e.g. the [1.x.0] for details. The instruction underlying   this function call signals to the processor that these two prerequisites   on a store are relaxed: Firstly, one expects the whole cache line to be   overwritten (meaning that the memory subsystem makes sure that   consecutive stores that together span a cache line are merged, and   appropriately handling the case where only part of a cache line is   written), so there is no need to first read the "remainder" of the cache   line. Secondly, the data behind that particular memory will not be   subject to cache coherency protocol as it will be in main memory both   when the same processor wants to access it again as well as any other   processors in a multicore chip. Due to this particular setup, any   subsequent access to the data written by this function will need to query   main memory, which is slower than an access from a cache both   latency-wise and throughput-wise. Thus, this command should only be used   for storing large arrays that will collectively not fit into caches, as   performance will be degraded otherwise. For a typical use case, see also   [1.x.1].     Note that streaming stores are only available in the specialized SSE/AVX   classes of VectorizedArray of type  [2.x.17]  or  [2.x.18]  not in the   generic base class.  
* [0.x.34]*
   Load size() data items from memory into the calling class, starting at   the given address and with given offsets, each entry from the offset   providing one element of the vectorized array.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.2]
*   
* [0.x.35]*
   Write the content of the calling class into memory in form of   size() data items to the given address and the given offsets, filling the   elements of the vectorized array into each offset.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.3]
*   
* [0.x.36]*
   Actual data field. To be consistent with the standard layout type and to   enable interaction with external SIMD functionality, this member is   declared public.  
* [0.x.37]*
   Return the square root of this field. Not for use in user code. Use   sqrt(x) instead.  
* [0.x.38]*
   Return the absolute value of this field. Not for use in user code. Use   abs(x) instead.  
* [0.x.39]*
   Return the component-wise maximum of this field and another one. Not for   use in user code. Use max(x,y) instead.  
* [0.x.40]*
   Return the component-wise minimum of this field and another one. Not for   use in user code. Use min(x,y) instead.  
* [0.x.41]*
  [2.x.19]  Packing and unpacking of a VectorizedArray

* 
* [0.x.42]*
 Create a vectorized array that sets all entries in the array to the given scalar, i.e., broadcasts the scalar to all array elements.
*   [2.x.20]  VectorizedArray

* 
* [0.x.43]*
 Create a vectorized array of given type and broadcast the scalar value to all array elements.
*    [2.x.21]  VectorizedArray

* 
* [0.x.44]*
 Load size() data items from memory into the VectorizedArray  [2.x.22]  starting at the given addresses and with given offset, each entry from the offset providing one element of the vectorized array.
*  This operation corresponds to the following code:

* 
* [1.x.4]
* 

* 
* [0.x.45]*
 This method loads  [2.x.23]  data streams from the given array  [2.x.24]  The offsets to the input array are given by the array  [2.x.25]  offsets. From each stream, n_entries are read. The data is then transposed and stored it into an array of VectorizedArray type. The output array  [2.x.26]  out is expected to be an array of size  [2.x.27]  This method operates on plain arrays, so no checks for valid data access are made. It is the user's responsibility to ensure that the given arrays are valid according to the access layout below.
*  This operation corresponds to a transformation of an array-of-struct (input) into a struct-of-array (output) according to the following formula:
* 

* 
* [1.x.5]
* 
*  A more optimized version of this code will be used for supported types.
*  This is the inverse operation to vectorized_transpose_and_store().
*   [2.x.28]  VectorizedArray

* 
* [0.x.46]*
 The same as above with the difference that an array of pointers are passed in as input argument  [2.x.29] 
*  In analogy to the function above, one can consider that `in+offset[v]` is precomputed and passed as input argument.
*  However, this function can also be used if some function returns an array of pointers and no assumption can be made that they belong to the same array, i.e., they can have their origin in different memory allocations.

* 
* [0.x.47]*
 This method stores the vectorized arrays in transposed form into the given output array  [2.x.30]  with the given offsets  [2.x.31]  This operation corresponds to a transformation of a struct-of-array (input) into an array- of-struct (output). This method operates on plain array, so no checks for valid data access are made. It is the user's responsibility to ensure that the given arrays are valid according to the access layout below.
*  This method assumes that the specified offsets do not overlap. Otherwise, the behavior is undefined in the vectorized case. It is the user's responsibility to make sure that the access does not overlap and avoid undefined behavior.
*  The argument  [2.x.32]  selects where the entries should only be written into the output arrays or the result should be added into the existing entries in the output. For  [2.x.33] , the following code is assumed:
* 

* 
* [1.x.6]
* 
*  For  [2.x.34] , the code implements the following action:

* 
* [1.x.7]
* 
*  A more optimized version of this code will be used for supported types.
*  This is the inverse operation to vectorized_load_and_transpose().
*   [2.x.35]  VectorizedArray

* 
* [0.x.48]*
 The same as above with the difference that an array of pointers are passed in as input argument  [2.x.36] 
*  In analogy to the function above, one can consider that `out+offset[v]` is precomputed and passed as input argument.
*  However, this function can also be used if some function returns an array of pointers and no assumption can be made that they belong to the same array, i.e., they can have their origin in different memory allocations.

* 
* [0.x.49]*
 Specialization of VectorizedArray class for double and AVX-512.

* 
* [0.x.50]*
   This gives the type of the array elements.  
* [0.x.51]*
   Default empty constructor, leaving the data in an uninitialized state   similar to float/double.  
* [0.x.52]*
   Construct an array with the given scalar broadcast to all lanes.  
* [0.x.53]*
   This function can be used to set all data fields to a given scalar.  
* [0.x.54]*
   Access operator.  
* [0.x.55]*
   Constant access operator.  
* [0.x.56]*
   Addition.  
* [0.x.57]*
   Subtraction.  
* [0.x.58]*
   Multiplication.  
* [0.x.59]*
   Division.  
* [0.x.60]*
   Load size() data items from memory into the calling class, starting at   the given address. The memory need not be aligned by 64 bytes, as opposed   to casting a double address to VectorizedArray<double>*.  
* [0.x.61]*
   Write the content of the calling class into memory in form of  [2.x.37]    size() to the given address. The memory need not be aligned by   64 bytes, as opposed to casting a double address to   VectorizedArray<double>*.  
* [0.x.62]*  [2.x.38]   [2.x.39]   
*  [2.x.40]  Memory must be aligned by 64 bytes.  
* [0.x.63]*
   Load  [2.x.41]  from memory into the calling class, starting at   the given address and with given offsets, each entry from the offset   providing one element of the vectorized array.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.8]
*   
* [0.x.64]*
   Write the content of the calling class into memory in form of  [2.x.42]    size() to the given address and the given offsets, filling the   elements of the vectorized array into each offset.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.9]
*   
* [0.x.65]*
   Actual data field. To be consistent with the standard layout type and to   enable interaction with external SIMD functionality, this member is   declared public.  
* [0.x.66]*
   Return the square root of this field. Not for use in user code. Use   sqrt(x) instead.  
* [0.x.67]*
   Return the absolute value of this field. Not for use in user code. Use   abs(x) instead.  
* [0.x.68]*
   Return the component-wise maximum of this field and another one. Not for   use in user code. Use max(x,y) instead.  
* [0.x.69]*
   Return the component-wise minimum of this field and another one. Not for   use in user code. Use min(x,y) instead.  
* [0.x.70]*
 Specialization for double and AVX-512.

* 
* [0.x.71]*
 Specialization for double and AVX-512.

* 
* [0.x.72]*
 Specialization for double and AVX-512.

* 
* [0.x.73]*
 Specialization for double and AVX-512.

* 
* [0.x.74]*
 Specialization for float and AVX512.

* 
* [0.x.75]*
   This gives the type of the array elements.  
* [0.x.76]*
   Default empty constructor, leaving the data in an uninitialized state   similar to float/double.  
* [0.x.77]*
   Construct an array with the given scalar broadcast to all lanes.  
* [0.x.78]*
   This function can be used to set all data fields to a given scalar.  
* [0.x.79]*
   Access operator.  
* [0.x.80]*
   Constant access operator.  
* [0.x.81]*
   Addition.  
* [0.x.82]*
   Subtraction.  
* [0.x.83]*
   Multiplication.  
* [0.x.84]*
   Division.  
* [0.x.85]*
   Load  [2.x.43]  from memory into the calling class, starting at   the given address. The memory need not be aligned by 64 bytes, as opposed   to casting a float address to VectorizedArray<float>*.  
* [0.x.86]*
   Write the content of the calling class into memory in form of  [2.x.44]    size() to the given address. The memory need not be aligned by   64 bytes, as opposed to casting a float address to   VectorizedArray<float>*.  
* [0.x.87]*  [2.x.45]   [2.x.46]   
*  [2.x.47]  Memory must be aligned by 64 bytes.  
* [0.x.88]*
   Load  [2.x.48]  from memory into the calling class, starting at   the given address and with given offsets, each entry from the offset   providing one element of the vectorized array.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.10]
*   
* [0.x.89]*
   Write the content of the calling class into memory in form of  [2.x.49]    size() to the given address and the given offsets, filling the   elements of the vectorized array into each offset.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.11]
*   
* [0.x.90]*
   Actual data field. To be consistent with the standard layout type and to   enable interaction with external SIMD functionality, this member is   declared public.  
* [0.x.91]*
   Return the square root of this field. Not for use in user code. Use   sqrt(x) instead.  
* [0.x.92]*
   Return the absolute value of this field. Not for use in user code. Use   abs(x) instead.  
* [0.x.93]*
   Return the component-wise maximum of this field and another one. Not for   use in user code. Use max(x,y) instead.  
* [0.x.94]*
   Return the component-wise minimum of this field and another one. Not for   use in user code. Use min(x,y) instead.  
* [0.x.95]*
 Specialization for float and AVX-512.

* 
* [0.x.96]*
 Specialization for float and AVX-512.

* 
* [0.x.97]*
 Specialization for float and AVX-512.

* 
* [0.x.98]*
 Specialization for float and AVX-512.

* 
* [0.x.99]*
 Specialization of VectorizedArray class for double and AVX.

* 
* [0.x.100]*
   This gives the type of the array elements.  
* [0.x.101]*
   Default empty constructor, leaving the data in an uninitialized state   similar to float/double.  
* [0.x.102]*
   Construct an array with the given scalar broadcast to all lanes.  
* [0.x.103]*
   This function can be used to set all data fields to a given scalar.  
* [0.x.104]*
   Access operator.  
* [0.x.105]*
   Constant access operator.  
* [0.x.106]*
   Addition.  
* [0.x.107]*
   Subtraction.  
* [0.x.108]*
   Multiplication.  
* [0.x.109]*
   Division.  
* [0.x.110]*
   Load  [2.x.50]  from memory into the calling class, starting at   the given address. The memory need not be aligned by 32 bytes, as opposed   to casting a double address to VectorizedArray<double>*.  
* [0.x.111]*
   Write the content of the calling class into memory in form of  [2.x.51]    size() to the given address. The memory need not be aligned by   32 bytes, as opposed to casting a double address to   VectorizedArray<double>*.  
* [0.x.112]*  [2.x.52]   [2.x.53]   
*  [2.x.54]  Memory must be aligned by 32 bytes.  
* [0.x.113]*
   Load  [2.x.55]  from memory into the calling class, starting at   the given address and with given offsets, each entry from the offset   providing one element of the vectorized array.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.12]
*   
* [0.x.114]*
   Write the content of the calling class into memory in form of  [2.x.56]    size() to the given address and the given offsets, filling the   elements of the vectorized array into each offset.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.13]
*   
* [0.x.115]*
   Actual data field. To be consistent with the standard layout type and to   enable interaction with external SIMD functionality, this member is   declared public.  
* [0.x.116]*
   Return the square root of this field. Not for use in user code. Use   sqrt(x) instead.  
* [0.x.117]*
   Return the absolute value of this field. Not for use in user code. Use   abs(x) instead.  
* [0.x.118]*
   Return the component-wise maximum of this field and another one. Not for   use in user code. Use max(x,y) instead.  
* [0.x.119]*
   Return the component-wise minimum of this field and another one. Not for   use in user code. Use min(x,y) instead.  
* [0.x.120]*
 Specialization for double and AVX.

* 
* [0.x.121]*
 Specialization for double and AVX.

* 
* [0.x.122]*
 Specialization for double and AVX.

* 
* [0.x.123]*
 Specialization for double and AVX.

* 
* [0.x.124]*
 Specialization for float and AVX.

* 
* [0.x.125]*
   This gives the type of the array elements.  
* [0.x.126]*
   Default empty constructor, leaving the data in an uninitialized state   similar to float/double.  
* [0.x.127]*
   Construct an array with the given scalar broadcast to all lanes.  
* [0.x.128]*
   This function can be used to set all data fields to a given scalar.  
* [0.x.129]*
   Access operator.  
* [0.x.130]*
   Constant access operator.  
* [0.x.131]*
   Addition.  
* [0.x.132]*
   Subtraction.  
* [0.x.133]*
   Multiplication.  
* [0.x.134]*
   Division.  
* [0.x.135]*
   Load  [2.x.57]  from memory into the calling class, starting at   the given address. The memory need not be aligned by 32 bytes, as opposed   to casting a float address to VectorizedArray<float>*.  
* [0.x.136]*
   Write the content of the calling class into memory in form of  [2.x.58]    size() to the given address. The memory need not be aligned by   32 bytes, as opposed to casting a float address to   VectorizedArray<float>*.  
* [0.x.137]*  [2.x.59]   [2.x.60]   
*  [2.x.61]  Memory must be aligned by 32 bytes.  
* [0.x.138]*
   Load  [2.x.62]  from memory into the calling class, starting at   the given address and with given offsets, each entry from the offset   providing one element of the vectorized array.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.14]
*   
* [0.x.139]*
   Write the content of the calling class into memory in form of  [2.x.63]    size() to the given address and the given offsets, filling the   elements of the vectorized array into each offset.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.15]
*   
* [0.x.140]*
   Actual data field. To be consistent with the standard layout type and to   enable interaction with external SIMD functionality, this member is   declared public.  
* [0.x.141]*
   Return the square root of this field. Not for use in user code. Use   sqrt(x) instead.  
* [0.x.142]*
   Return the absolute value of this field. Not for use in user code. Use   abs(x) instead.  
* [0.x.143]*
   Return the component-wise maximum of this field and another one. Not for   use in user code. Use max(x,y) instead.  
* [0.x.144]*
   Return the component-wise minimum of this field and another one. Not for   use in user code. Use min(x,y) instead.  
* [0.x.145]*
 Specialization for float and AVX.

* 
* [0.x.146]*
 Specialization for float and AVX.

* 
* [0.x.147]*
 Specialization for float and AVX.

* 
* [0.x.148]*
 Specialization for float and AVX.

* 
* [0.x.149]*
 Specialization for double and SSE2.

* 
* [0.x.150]*
   This gives the type of the array elements.  
* [0.x.151]*
   Default empty constructor, leaving the data in an uninitialized state   similar to float/double.  
* [0.x.152]*
   Construct an array with the given scalar broadcast to all lanes.  
* [0.x.153]*
   This function can be used to set all data fields to a given scalar.  
* [0.x.154]*
   Access operator.  
* [0.x.155]*
   Constant access operator.  
* [0.x.156]*
   Addition.  
* [0.x.157]*
   Subtraction.  
* [0.x.158]*
   Multiplication.  
* [0.x.159]*
   Division.  
* [0.x.160]*
   Load  [2.x.64]  from memory into the calling class, starting at   the given address. The memory need not be aligned by 16 bytes, as opposed   to casting a double address to VectorizedArray<double>*.  
* [0.x.161]*
   Write the content of the calling class into memory in form of  [2.x.65]    size() to the given address. The memory need not be aligned by   16 bytes, as opposed to casting a double address to   VectorizedArray<double>*.  
* [0.x.162]*  [2.x.66]   [2.x.67]   
*  [2.x.68]  Memory must be aligned by 16 bytes.  
* [0.x.163]*
   Load  [2.x.69]  from memory into the calling class, starting at   the given address and with given offsets, each entry from the offset   providing one element of the vectorized array.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.16]
*   
* [0.x.164]*
   Write the content of the calling class into memory in form of  [2.x.70]    size() to the given address and the given offsets, filling the   elements of the vectorized array into each offset.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.17]
*   
* [0.x.165]*
   Actual data field. To be consistent with the standard layout type and to   enable interaction with external SIMD functionality, this member is   declared public.  
* [0.x.166]*
   Return the square root of this field. Not for use in user code. Use   sqrt(x) instead.  
* [0.x.167]*
   Return the absolute value of this field. Not for use in user code. Use   abs(x) instead.  
* [0.x.168]*
   Return the component-wise maximum of this field and another one. Not for   use in user code. Use max(x,y) instead.  
* [0.x.169]*
   Return the component-wise minimum of this field and another one. Not for   use in user code. Use min(x,y) instead.  
* [0.x.170]*
 Specialization for double and SSE2.

* 
* [0.x.171]*
 Specialization for double and SSE2.

* 
* [0.x.172]*
 Specialization for double and SSE2.

* 
* [0.x.173]*
 Specialization for double and SSE2.

* 
* [0.x.174]*
 Specialization for float and SSE2.

* 
* [0.x.175]*
   This gives the type of the array elements.  
* [0.x.176]*
   This function can be used to set all data fields to a given scalar.  
* [0.x.177]*
   Default empty constructor, leaving the data in an uninitialized state   similar to float/double.  
* [0.x.178]*
   Construct an array with the given scalar broadcast to all lanes.  
* [0.x.179]*
   Access operator.  
* [0.x.180]*
   Constant access operator.  
* [0.x.181]*
   Addition.  
* [0.x.182]*
   Subtraction.  
* [0.x.183]*
   Multiplication.  
* [0.x.184]*
   Division.  
* [0.x.185]*
   Load  [2.x.71]  from memory into the calling class, starting at   the given address. The memory need not be aligned by 16 bytes, as opposed   to casting a float address to VectorizedArray<float>*.  
* [0.x.186]*
   Write the content of the calling class into memory in form of  [2.x.72]    size() to the given address. The memory need not be aligned by   16 bytes, as opposed to casting a float address to   VectorizedArray<float>*.  
* [0.x.187]*  [2.x.73]   [2.x.74]   
*  [2.x.75]  Memory must be aligned by 16 bytes.  
* [0.x.188]*
   Load  [2.x.76]  from memory into the calling class, starting at   the given address and with given offsets, each entry from the offset   providing one element of the vectorized array.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.18]
*   
* [0.x.189]*
   Write the content of the calling class into memory in form of  [2.x.77]    size() to the given address and the given offsets, filling the   elements of the vectorized array into each offset.     This operation corresponds to the following code (but uses a more   efficient implementation in case the hardware allows for that):  
* [1.x.19]
*   
* [0.x.190]*
   Actual data field. To be consistent with the standard layout type and to   enable interaction with external SIMD functionality, this member is   declared public.  
* [0.x.191]*
   Return the square root of this field. Not for use in user code. Use   sqrt(x) instead.  
* [0.x.192]*
   Return the absolute value of this field. Not for use in user code. Use   abs(x) instead.  
* [0.x.193]*
   Return the component-wise maximum of this field and another one. Not for   use in user code. Use max(x,y) instead.  
* [0.x.194]*
   Return the component-wise minimum of this field and another one. Not for   use in user code. Use min(x,y) instead.  
* [0.x.195]*
 Specialization for float and SSE2.

* 
* [0.x.196]*
 Specialization for float and SSE2.

* 
* [0.x.197]*
 Specialization for float and SSE2.

* 
* [0.x.198]*
 Specialization for float and SSE2.

* 
* [0.x.199]*
   This gives the type of the array elements.  
* [0.x.200]*
   Default empty constructor, leaving the data in an uninitialized state   similar to float/double.  
* [0.x.201]*
   Construct an array with the given scalar broadcast to all lanes.  
* [0.x.202]*
   This function assigns a scalar to this class.  
* [0.x.203]*
   Access operator. The component must be either 0 or 1.  
* [0.x.204]*
   Constant access operator.  
* [0.x.205]*
   Addition.  
* [0.x.206]*
   Subtraction.  
* [0.x.207]*
   Multiplication.  
* [0.x.208]*
   Division.  
* [0.x.209]*
   Load  [2.x.78]  from memory into the calling class, starting at   the given address.  
* [0.x.210]*
   Write the content of the calling class into memory in form of  [2.x.79]    size() to the given address.  
* [0.x.211]*
   Actual data field. To be consistent with the standard layout type and to   enable interaction with external SIMD functionality, this member is   declared public.  
* [0.x.212]*
   Return the square root of this field. Not for use in user code. Use   sqrt(x) instead.  
* [0.x.213]*
   Return the absolute value of this field. Not for use in user code. Use   abs(x) instead.  
* [0.x.214]*
   Return the component-wise maximum of this field and another one. Not for   use in user code. Use max(x,y) instead.  
* [0.x.215]*
   Return the component-wise minimum of this field and another one. Not for   use in user code. Use min(x,y) instead.  
* [0.x.216]*
   This gives the type of the array elements.  
* [0.x.217]*
   Default empty constructor, leaving the data in an uninitialized state   similar to float/double.  
* [0.x.218]*
   Construct an array with the given scalar broadcast to all lanes.  
* [0.x.219]*
   This function assigns a scalar to this class.  
* [0.x.220]*
   Access operator. The component must be between 0 and 3.  
* [0.x.221]*
   Constant access operator.  
* [0.x.222]*
   Addition.  
* [0.x.223]*
   Subtraction.  
* [0.x.224]*
   Multiplication.  
* [0.x.225]*
   Division.  
* [0.x.226]*
   Load  [2.x.80]  from memory into the calling class, starting at   the given address.  
* [0.x.227]*
   Write the content of the calling class into memory in form of  [2.x.81]    size() to the given address.  
* [0.x.228]*
   Actual data field. To be consistent with the standard layout type and to   enable interaction with external SIMD functionality, this member is   declared public.  
* [0.x.229]*
   Return the square root of this field. Not for use in user code. Use   sqrt(x) instead.  
* [0.x.230]*
   Return the absolute value of this field. Not for use in user code. Use   abs(x) instead.  
* [0.x.231]*
   Return the component-wise maximum of this field and another one. Not for   use in user code. Use max(x,y) instead.  
* [0.x.232]*
   Return the component-wise minimum of this field and another one. Not for   use in user code. Use min(x,y) instead.  
* [0.x.233]*
  [2.x.82]  Arithmetic operations with VectorizedArray

* 
* [0.x.234]*
 Relational operator == for VectorizedArray
*   [2.x.83]  VectorizedArray

* 
* [0.x.235]*
 Addition of two vectorized arrays with operator +.
*   [2.x.84]  VectorizedArray

* 
* [0.x.236]*
 Subtraction of two vectorized arrays with operator
* 
*  - 
*   [2.x.85]  VectorizedArray

* 
* [0.x.237]*
 Multiplication of two vectorized arrays with operator.
*   [2.x.86]  VectorizedArray

* 
* [0.x.238]*
 Division of two vectorized arrays with operator /.
*   [2.x.87]  VectorizedArray

* 
* [0.x.239]*
 Addition of a scalar (expanded to a vectorized array with  [2.x.88]  size() equal entries) and a vectorized array.
*   [2.x.89]  VectorizedArray

* 
* [0.x.240]*
 Addition of a scalar (expanded to a vectorized array with  [2.x.90]  size() equal entries) and a vectorized array in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers).
*   [2.x.91]  VectorizedArray

* 
* [0.x.241]*
 Addition of a vectorized array and a scalar (expanded to a vectorized array with  [2.x.92]  equal entries).
*   [2.x.93]  VectorizedArray

* 
* [0.x.242]*
 Addition of a vectorized array and a scalar (expanded to a vectorized array with  [2.x.94]  equal entries) in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers).
*   [2.x.95]  VectorizedArray

* 
* [0.x.243]*
 Subtraction of a vectorized array from a scalar (expanded to a vectorized array with  [2.x.96]  equal entries).
*   [2.x.97]  VectorizedArray

* 
* [0.x.244]*
 Subtraction of a vectorized array from a scalar (expanded to a vectorized array with  [2.x.98]  equal entries) in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers).
*   [2.x.99]  VectorizedArray

* 
* [0.x.245]*
 Subtraction of a scalar (expanded to a vectorized array with  [2.x.100]  size() equal entries) from a vectorized array.
*   [2.x.101]  VectorizedArray

* 
* [0.x.246]*
 Subtraction of a scalar (expanded to a vectorized array with  [2.x.102]  size() equal entries) from a vectorized array in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers).
*   [2.x.103]  VectorizedArray

* 
* [0.x.247]*
 Multiplication of a scalar (expanded to a vectorized array with  [2.x.104]  size() equal entries) and a vectorized array.
*   [2.x.105]  VectorizedArray

* 
* [0.x.248]*
 Multiplication of a scalar (expanded to a vectorized array with  [2.x.106]  size() equal entries) and a vectorized array in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers).
*   [2.x.107]  VectorizedArray

* 
* [0.x.249]*
 Multiplication of a vectorized array and a scalar (expanded to a vectorized array with  [2.x.108]  equal entries).
*   [2.x.109]  VectorizedArray

* 
* [0.x.250]*
 Multiplication of a vectorized array and a scalar (expanded to a vectorized array with  [2.x.110]  equal entries) in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers).
*   [2.x.111]  VectorizedArray

* 
* [0.x.251]*
 Quotient between a scalar (expanded to a vectorized array with  [2.x.112]  size() equal entries) and a vectorized array.
*   [2.x.113]  VectorizedArray

* 
* [0.x.252]*
 Quotient between a scalar (expanded to a vectorized array with  [2.x.114]  size() equal entries) and a vectorized array in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers).
*   [2.x.115]  VectorizedArray

* 
* [0.x.253]*
 Quotient between a vectorized array and a scalar (expanded to a vectorized array with  [2.x.116]  equal entries).
*   [2.x.117]  VectorizedArray

* 
* [0.x.254]*
 Quotient between a vectorized array and a scalar (expanded to a vectorized array with  [2.x.118]  equal entries) in case the scalar is a double (needed in order to be able to write simple code with constants that are usually double numbers).
*   [2.x.119]  VectorizedArray

* 
* [0.x.255]*
 Unary operator + on a vectorized array.
*   [2.x.120]  VectorizedArray

* 
* [0.x.256]*
 Unary operator
* 
*  - on a vectorized array.
*   [2.x.121]  VectorizedArray

* 
* [0.x.257]*
 Output operator for vectorized array.
*   [2.x.122]  VectorizedArray

* 
* [0.x.258]*
  [2.x.123]  Ternary operations on VectorizedArray

* 
* [0.x.259]*
 enum class encoding binary operations for a component-wise comparison of VectorizedArray data types.
* 

* 
*  [2.x.124]  In case of SIMD vecorization (sse, avx, av512) we select the corresponding ordered, non-signalling ( [2.x.125] ) variants.

* 
* [0.x.260]*
 Computes the vectorized equivalent of the following ternary operation:

* 
* [1.x.20]
*  where  [2.x.126] ,  [2.x.127] , and  [2.x.128] ).
*  Such a computational idiom is useful as an alternative to branching whenever the control flow itself would depend on (computed) data. For example, in case of a scalar data type the statement  [2.x.129]  could have been also implemented using an  [2.x.130] -statement:

* 
* [1.x.21]
*  This, however, is fundamentally impossible in case of vectorization because different decisions will be necessary on different vector entries (lanes) and the first variant (based on a ternary operator) has to be used instead:

* 
* [1.x.22]
*  Some more illustrative examples (that are less efficient than the dedicated  [2.x.131]  overloads):

* 
* [1.x.23]
* 
*  More precisely, this function first computes a (boolean) mask that is the result of a binary operator  [2.x.132]  applied to all elements of the VectorizedArray arguments  [2.x.133]  and  [2.x.134]  The mask is then used to either select the corresponding component of  [2.x.135]  (if the binary operation equates to true), or  [2.x.136]  The binary operator is encoded via the SIMDComparison template argument  [2.x.137] 
*  In order to ease with generic programming approaches, the function provides overloads for all VectorizedArray<Number> variants as well as generic POD types such as double and float.
* 

* 
*  [2.x.138]  For this function to work the binary operation has to be encoded via a SIMDComparison template argument  [2.x.139]  Depending on it appropriate low-level machine instructions are generated replacing the call to compare_and_apply_mask. This also explains why  [2.x.140]  is a compile-time constant template parameter and not a constant function argument. In order to be able to emit the correct low-level instruction, the compiler has to know the comparison at compile time.

* 
* [0.x.261]*
 Specialization of above function for the non-vectorized VectorizedArray<Number, 1> variant.

* 
* [0.x.262]*
 Implementation of functions from cmath on VectorizedArray. These functions do not reside in the dealii namespace in order to ensure a similar interface as for the respective functions in cmath. Instead, call them using  [2.x.141] 

* 
* [0.x.263]*
   Compute the sine of a vectorized data field. The result is returned as   vectorized array in the form <tt>{sin(x[0]), sin(x[1]), ...,    [2.x.142]       [2.x.143]  VectorizedArray  
* [0.x.264]*
   Compute the cosine of a vectorized data field. The result is returned as   vectorized array in the form <tt>{cos(x[0]), cos(x[1]), ...,   cos(x[size()-1])}</tt>.      [2.x.144]  VectorizedArray  
* [0.x.265]*
   Compute the tangent of a vectorized data field. The result is returned   as vectorized array in the form <tt>{tan(x[0]), tan(x[1]), ...,   tan(x[size()-1])}</tt>.      [2.x.145]  VectorizedArray  
* [0.x.266]*
   Compute the exponential of a vectorized data field. The result is   returned as vectorized array in the form <tt>{exp(x[0]), exp(x[1]), ...,   exp(x[size()-1])}</tt>.      [2.x.146]  VectorizedArray  
* [0.x.267]*
   Compute the natural logarithm of a vectorized data field. The result is   returned as vectorized array in the form <tt>{log(x[0]), log(x[1]), ...,   log(x[size()-1])}</tt>.      [2.x.147]  VectorizedArray  
* [0.x.268]*
   Compute the square root of a vectorized data field. The result is   returned as vectorized array in the form <tt>{sqrt(x[0]), sqrt(x[1]),   ..., sqrt(x[size()-1])}</tt>.      [2.x.148]  VectorizedArray  
* [0.x.269]*
   Raises the given number  [2.x.149]  to the power  [2.x.150]  for a vectorized data   field. The result is returned as vectorized array in the form   <tt>{pow(x[0],p), pow(x[1],p), ..., pow(x[size()-1],p)}</tt>.      [2.x.151]  VectorizedArray  
* [0.x.270]*
   Raises the given number  [2.x.152]  to the power  [2.x.153]  for a vectorized data   field. The result is returned as vectorized array in the form   <tt>{pow(x[0],p[0]), pow(x[1],p[1]), ...,   pow(x[size()-1],p[size()-1])}</tt>.      [2.x.154]  VectorizedArray  
* [0.x.271]*
   Compute the absolute value (modulus) of a vectorized data field. The   result is returned as vectorized array in the form <tt>{abs(x[0]),   abs(x[1]), ..., abs(x[size()-1])}</tt>.      [2.x.155]  VectorizedArray  
* [0.x.272]*
   Compute the componentwise maximum of two vectorized data fields. The   result is returned as vectorized array in the form <tt>{max(x[0],y[0]),   max(x[1],y[1]), ...}</tt>.      [2.x.156]  VectorizedArray  
* [0.x.273]*
   Compute the componentwise minimum of two vectorized data fields. The   result is returned as vectorized array in the form <tt>{min(x[0],y[0]),   min(x[1],y[1]), ...}</tt>.      [2.x.157]  VectorizedArray  
* [0.x.274]*
   Iterator traits for VectorizedArrayIterator.  
* [0.x.275]

include/deal.II-translator/base/vector_slice_0.txt
[0.x.0]

include/deal.II-translator/base/work_stream_0.txt
[0.x.0]*
 A namespace whose main template function supports running multiple threads each of which operates on a subset of the given range of objects. The class uses the Intel Threading Building Blocks (TBB) to load balance the individual subranges onto the available threads. For a lengthy discussion of the rationale of this class, see the  [2.x.0]  "Parallel computing with multiple processors" module. It is used in the tutorial first in  [2.x.1] , and again in  [2.x.2] ,  [2.x.3] ,  [2.x.4]  and others.
*  The class is built on the following premise: One frequently has some work that needs to be done on a sequence of objects; a prototypical example is assembling cell contributions to a system matrix or right hand side. In many such examples, part of the work can be done entirely independently and in parallel, possibly using several processor cores on a machine with shared memory. However, some other part of this work may need to be synchronized and be done in order. In the example of assembling a matrix, the computation of local contributions can be done entirely in parallel, but copying the local contributions into the global matrix requires some care: First, several threads can't write at the same time, but need to synchronize writing using a mutex; secondly, we want the order in which local contributions are added to the global matrix to be always the same because floating point addition is not commutative and adding local contributions to the global matrix in different orders leads to subtly different results that can affect the number of iterations for iterative solvers as well as the round-off error in the solution in random ways. Consequently, we want to ensure that only one thread at a time writes into the global matrix, and that results are copied in a stable and reproducible order.
*  This class implements a framework for this work model. It works with a stream of objects given by an iterator range, runs a worker function in parallel on all of these objects and then passes each object to a postprocessor function that runs sequentially and gets objects in exactly the order in which they appear in the input iterator range. None of the synchronization work is exposed to the user of this class.
*  Internally, the range given to the run() function of this class is split into a sequence of "items", which are then distributed according to some %internal algorithm onto the number of available threads. An item is an element of the range of iterators on which we are to operate; for example, for the purpose of assembling matrices or evaluating error indicators, an item could be a cell. The TBB library determines how many threads are created (typically as many as there are processor cores), but the number of items that may be active at any given time is specified by the argument to the constructor. It should be bigger or equal to the number of processor cores
* 
*  - the default is four times the number of cores on the current system.
*  Items are created upon request by the TBB whenever one of the worker threads is idle or is expected to become idle. It is then handed off to a worker function, typically a member function of a main class. These worker functions are run in parallel on a number of threads, and there is no guarantee that they are asked to work on items in any particular order, in particular not necessarily in the order in which items are generated from the iterator range.
*  Typically, worker functions need additional data, for example FEValues objects, input data vectors, etc, some of which can not be shared among threads. To this end, the run() function takes another template argument, ScratchData, which designates a type objects of which are stored with each item and which threads can use as private data without having to share them with other threads. The run() function takes an additional argument with an object of type ScratchData that is going to be copied for the arguments passed to each of the worker functions.
*  In addition, worker functions store their results in objects of template type CopyData. These are then handed off to a separate function, called copier, that may use the stored results to transfer them into permanent storage. For example, it may copy the results of local contributions to a matrix computed by a worker function into the global matrix. In contrast to the worker function, however, only one instance of the copier is run at any given time; it can therefore safely copy local contributions into the global matrix without the need to lock the global object using a mutex or similar means. Furthermore, it is guaranteed that the copier is run with CopyData objects in the same order in which their associated items were created; consequently, even if worker threads may compute results in unspecified order, the copier always receives the results in exactly the same order as the items were created.
*  Once an item is processed by the copier, it is deleted and the ScratchData and CopyData objects that were used in its computation are considered unused and may be re-used for the next invocation of the worker function, on this or another thread. However, the WorkStream functions make no attempt to reset these objects to any kind of pristine state
* 
*  -  a worker should assume that the CopyData object it gets handed has prior content and clear it first in whatever manner seems appropriate, before putting content into it that can later be processed again by the copier.
*  The member variables in ScratchData and CopyData can be accessed independently of other concurrent uses of copies of these data structures. Therefore, it is perfectly fine to resize auxiliary data structures associated with ScratchData and CopyData to different lengths on each cell. For example, a vector holding densities at each quadrature point which is used with  [2.x.5]  to assemble the local matrix could be resized to the corresponding number of quadrature points of the current cell in DoFHandlers with hp-capabilities. Similarly, local stiffness matrix in CopyData can be resized in accordance with the number of local DoFs on the current cell.
* 

* 
*  [2.x.6]  For integration over cells and faces, it is often useful to use methods more specific to the task than the current function (which doesn't care whether the iterators are over cells, vector elements, or any other kind of range). An implementation of an interface specifically suited to integration is the  [2.x.7]  function.
* 

* 
*  [2.x.8]  The functions in this namespace only really work in parallel when multithread mode was selected during deal.II configuration. Otherwise they simply work on each item sequentially.
* 

* 
*  [2.x.9] 

* 
* [0.x.1]*
   The nested namespaces contain various implementations of the workstream   algorithms.  
* [0.x.2]*
     A namespace for the implementation of details of the WorkStream pattern     and function. This namespace holds classes that deal with the second     implementation described in the paper by Turcksin, Kronbichler and     Bangerth (see      [2.x.10] ).     Here, no coloring is provided, so copying is done sequentially using a     TBB filter.         Even though this implementation is slower than the third implementation     discussed in that paper, we need to keep it around for two reasons: (i)     a user may not give us a graph coloring, (ii) we want to use this     implementation for colors that are just too small.    
* [0.x.3]*
       A class that creates a sequence of items from a range of iterators.      
* [0.x.4]*
         A data type that we use to identify items to be worked on. This is         the structure that is passed around between the different parts of         the WorkStream implementation to identify what needs to be done by         the various stages of the pipeline.        
* [0.x.5]*
           A structure that contains a pointer to a scratch data object           along with a flag that indicates whether this object is currently           in use.          
* [0.x.6]*
             Default constructor.            
* [0.x.7]*
           Typedef to a list of scratch data objects. The rationale for this           list is provided in the variables that use these lists.          
* [0.x.8]*
           A list of iterators that need to be worked on. Only the first           n_items are relevant.          
* [0.x.9]*
           The CopyData objects that the Worker part of the pipeline fills           for each work item. Again, only the first n_items elements are           what we care about.          
* [0.x.10]*
           Number of items identified by the work_items array that the           Worker and Copier pipeline stage need to work on. The maximum           value of this variable will be chunk_size.          
* [0.x.11]*
           Pointer to a thread local variable identifying the scratch data           objects this thread will use. The initial implementation of this           class using thread local variables provided only a single scratch           object per thread. This doesn't work, because the worker           functions may start tasks itself and then call            [2.x.11]  or a similar function, which the           TBB scheduler may use to run something else on the current thread
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  for example another instance of the worker function.           Consequently, there would be two instances of the worker function           that use the same scratch object if we only provided a single           scratch object per thread. The solution is to provide a list of           scratch objects for each thread, together with a flag indicating           whether this scratch object is currently used. If a thread needs           a scratch object, it walks this list until it finds an unused           object, or, if there is none, creates one itself. Note that we           need not use synchronization primitives for this process since           the lists are thread-local and we are guaranteed that only a           single thread accesses them as long as we have no yield point in           between the accesses to the list.                     The pointers to scratch objects stored in each of these lists           must be so that they are deleted on all threads when the thread           local object is destroyed. This is achieved by using unique_ptr.                     Note that when a worker needs to create a scratch object, it           allocates it using sample_scratch_data to copy from. This has the           advantage of a first-touch initialization, i.e., the memory for           the scratch data object is allocated and initialized by the same           thread that will later use it.          
* [0.x.12]*
           Pointer to a sample scratch data object, to be used to initialize           the scratch data objects created for each individual thread.          
* [0.x.13]*
           Flag is true if the buffer is used and false if the buffer can be           used.          
* [0.x.14]*
           Default constructor. Initialize everything that doesn't have a           default constructor itself.          
* [0.x.15]*
         Constructor. Take an iterator range, the size of a buffer that can         hold items, and the sample additional data object that will be         passed to each worker and copier function invocation.        
* [0.x.16]*
         Create an item and return a pointer to it.        
* [0.x.17]*
         The interval of iterators still to be worked on. This range will         shrink over time.        
* [0.x.18]*
         A buffer that will store items.        
* [0.x.19]*
         Pointer to a thread local variable identifying the scratch data         objects this thread will use. The initial implementation of this         class using thread local variables provided only a single scratch         object per thread. This doesn't work, because the worker functions         may start tasks itself and then call  [2.x.12]          or a similar function, which the TBB scheduler may use to run         something else on the current thread
* 
*  -  for example another         instance of the worker function. Consequently, there would be two         instances of the worker function that use the same scratch object         if we only provided a single scratch object per thread. The         solution is to provide a list of scratch objects for each thread,         together with a flag indicating whether this scratch object is         currently used. If a thread needs a scratch object, it walks this         list until it finds an unused object, or, if there is none, creates         one itself. Note that we need not use synchronization primitives         for this process since the lists are thread-local and we are         guaranteed that only a single thread accesses them as long as we         have no yield point in between the accesses to the list.                 The pointers to scratch objects stored in each of these lists must         be so that they are deleted on all threads when the thread local         object is destroyed. This is achieved by using unique_ptr.                 Note that when a worker needs to create a scratch object, it         allocates it using sample_scratch_data to copy from. This has the         advantage of a first-touch initialization, i.e., the memory for the         scratch data object is allocated and initialized by the same thread         that will later use it.        
* [0.x.20]*
         A reference to a sample scratch data that will be used to         initialize the thread-local pointers to a scratch data object each         of the worker tasks uses.        
* [0.x.21]*
         Number of elements of the iterator range that each thread should         work on sequentially; a large number makes sure that each thread         gets a significant amount of work before the next task switch         happens, whereas a small number is better for load balancing.        
* [0.x.22]*
       A class that manages calling the worker function on a number of       parallel threads. Note that it is, in the TBB notation, a filter that       can run in parallel.      
* [0.x.23]*
         Constructor. Takes a reference to the object on which we will         operate as well as a pointer to the function that will do the         assembly.        
* [0.x.24]*
         Work on an item.        
* [0.x.25]*
         Pointer to the function that does the assembling on the sequence of         cells.        
* [0.x.26]*
         This flag is true if the copier stage exist. If it does not, the         worker has to free the buffer. Otherwise the copier will do it.        
* [0.x.27]*
       A class that manages calling the copier function. Note that it is, in       the TBB notation, a filter that runs sequentially, ensuring that all       items are copied in the same order in which they are created.      
* [0.x.28]*
         Constructor. Takes a reference to the object on which we will         operate as well as a pointer to the function that will do the         copying from the additional data object to the global matrix or         similar.        
* [0.x.29]*
         Work on a single item.        
* [0.x.30]*
         Pointer to the function that does the copying of data.        
* [0.x.31]*
     A reference implementation without using multithreading to be used if we     don't have multithreading support or if the user requests to run things     sequentially. This is more efficient than using TBB or taskflow if we     only have a single thread.    
* [0.x.32]*
       Sequential version without colors.      
* [0.x.33]*
       Sequential version with colors      
* [0.x.34]*
     A namespace for the implementation of details of the WorkStream pattern     and function. This namespace holds classes that deal with the third     implementation described in the paper by Turcksin, Kronbichler and     Bangerth (see      [2.x.13] ).    
* [0.x.35]*
       A structure that contains a pointer to scratch and copy data objects       along with a flag that indicates whether this object is currently in       use.      
* [0.x.36]*
         Default constructor.        
* [0.x.37]*
       A class that manages calling the worker and copier functions. Unlike       the other implementations, parallel_for is used instead of a       pipeline.      
* [0.x.38]*
         Constructor.        
* [0.x.39]*
         The function that calls the worker and the copier functions on a         range of items denoted by the two arguments.        
* [0.x.40]*
         Typedef to a list of scratch data objects. The rationale for this         list is provided in the variables that use these lists.        
* [0.x.41]*
         Pointer to the function that does the assembling on the sequence of         cells.        
* [0.x.42]*
         Pointer to the function that does the copying from local         contribution to global object.        
* [0.x.43]*
         References to sample scratch and copy data for when we need them.        
* [0.x.44]*
       The colored run function using TBB.      
* [0.x.45]*
   This is one of two main functions of the WorkStream concept, doing work   as described in the introduction to this namespace. It corresponds to   implementation 3 of the paper by Turcksin, Kronbichler and Bangerth, see    [2.x.14] .   As such, it takes not a range of iterators described by a begin and end   iterator, but a "colored" graph of iterators where each color represents   cells for which writing the cell contributions into the global object   does not conflict (in other words, these cells are not neighbors). Each   "color" is represented by  [2.x.15]  of cells. The first argument to   this function, a set of sets of cells (which are represent as a vector of   vectors, for efficiency), is typically constructed by calling    [2.x.16]  See there for more information.     This function that can be used for worker and copier objects that are   either pointers to non-member functions or objects that allow to be   called with an operator(), for example objects created by lambda functions   or  [2.x.17]      The two data types <tt>ScratchData</tt> and <tt>CopyData</tt> need to   have a working copy constructor. <tt>ScratchData</tt> is only used in the   <tt>worker</tt> function, while <tt>CopyData</tt> is the object passed   from the <tt>worker</tt> to the <tt>copier</tt>.     The  [2.x.18]  argument indicates the number of items that can be   live at any given time. Each item consists of  [2.x.19]  elements of   the input stream that will be worked on by the worker and copier   functions one after the other on the same thread.    
*  [2.x.20]  If your data objects are large, or their constructors are   expensive, it is helpful to keep in mind that <tt>queue_length</tt>   copies of the <tt>ScratchData</tt> object and   <tt>queue_length*chunk_size</tt> copies of the <tt>CopyData</tt> object   are generated.    
*  [2.x.21]  In case the copier does not do anything, pass    [2.x.22]  CopyData &)>()` as  [2.x.23]  to make sure   a more efficient algorithm is used internally. It is important, however,   to recognize that the empty function object created above isnot*
   the same as a lambda function with an empty body,   `[](const CopyData &) {}`
* 
*  -  from the perspective of this function,   there is no way to recognize whether a lambda function provided as   a copier does something or does not do something in its body,   and so it needs to be copied. On the other hand, a default-constructed    [2.x.24]  objectcan* be recognized, and is then used to select   a more efficient algorithm.  
* [0.x.46]*
   This is one of two main functions of the WorkStream concept, doing work   as described in the introduction to this namespace. It corresponds to   implementation 2 of the paper by Turcksin, Kronbichler and Bangerth (see    [2.x.25] ).     This function that can be used for worker and copier objects that are   either pointers to non-member functions or objects that allow to be   called with an operator(), for example lambda functions   or objects created by  [2.x.26]  If the copier is an empty function, it is   ignored in the pipeline. (However, a lambda function with an empty body is  not* equivalent to an empty  [2.x.27]  object and will, consequently,   not be ignored.     The argument passed as  [2.x.28]  must be convertible to the same type as  [2.x.29]    begin, but doesn't have to be of the same type itself. This allows to   write code like <code>WorkStream().run(dof_handler.begin_active(),   dof_handler.end(), ...</code> where the first is of type    [2.x.30]  whereas the second is of type    [2.x.31]      The two data types <tt>ScratchData</tt> and <tt>CopyData</tt> need to   have a working copy constructor. <tt>ScratchData</tt> is only used in the   <tt>worker</tt> function, while <tt>CopyData</tt> is the object passed   from the <tt>worker</tt> to the <tt>copier</tt>.     The  [2.x.32]  argument indicates the number of items that can be   live at any given time. Each item consists of  [2.x.33]  elements of   the input stream that will be worked on by the worker and copier   functions one after the other on the same thread.    
*  [2.x.34]  If your data objects are large, or their constructors are   expensive, it is helpful to keep in mind that <tt>queue_length</tt>   copies of the <tt>ScratchData</tt> object and   <tt>queue_length*chunk_size</tt> copies of the <tt>CopyData</tt> object   are generated.    
*  [2.x.35]  In case the copier does not do anything, pass    [2.x.36]  CopyData &)>()` as  [2.x.37]  to make sure   a more efficient algorithm is used internally. It is important, however,   to recognize that the empty function object created above isnot*
   the same as a lambda function with an empty body,   `[](const CopyData &) {}`
* 
*  -  from the perspective of this function,   there is no way to recognize whether a lambda function provided as   a copier does something or does not do something in its body,   and so it needs to be copied. On the other hand, a default-constructed    [2.x.38]  objectcan* be recognized, and is then used to select   a more efficient algorithm.  
* [0.x.47]*
   Same as the function above, but for iterator ranges and C-style arrays.   A class that fulfills the requirements of an iterator range defines the   functions  [2.x.39]  and  [2.x.40]    both of which return iterators to elements that form the bounds of the   range.  
* [0.x.48]*
   Same as the function above, but for deal.II's IteratorRange.  
* [0.x.49]*
   This is a variant of one of the two main functions of the WorkStream   concept, doing work as described in the introduction to this namespace.   It corresponds to implementation 2 of the paper by Turcksin, Kronbichler   and Bangerth (see    [2.x.41] ).     This is the function that can be used for worker and copier functions   that are member functions of a class. If the copier is an empty function,   it is ignored in the pipeline.     The argument passed as  [2.x.42]  must be convertible to the same type as  [2.x.43]    begin, but doesn't have to be of the same type itself. This allows to   write code like <code>WorkStream().run(dof_handler.begin_active(),   dof_handler.end(), ...</code> where the first is of type    [2.x.44]  whereas the second is of type    [2.x.45]      The  [2.x.46]  argument indicates the number of items that can be   live at any given time. Each item consists of  [2.x.47]  elements of   the input stream that will be worked on by the worker and copier   functions one after the other on the same thread.    
*  [2.x.48]  If your data objects are large, or their constructors are   expensive, it is helpful to keep in mind that <tt>queue_length</tt>   copies of the <tt>ScratchData</tt> object and   <tt>queue_length*chunk_size</tt> copies of the <tt>CopyData</tt> object   are generated.    
*  [2.x.49]  In case the copier does not do anything, pass    [2.x.50]  CopyData &)>()` as  [2.x.51]  to make sure   a more efficient algorithm is used internally. It is important, however,   to recognize that the empty function object created above isnot*
   the same as a lambda function with an empty body,   `[](const CopyData &) {}`
* 
*  -  from the perspective of this function,   there is no way to recognize whether a lambda function provided as   a copier does something or does not do something in its body,   and so it needs to be copied. On the other hand, a default-constructed    [2.x.52]  objectcan* be recognized, and is then used to select   a more efficient algorithm.  
* [0.x.50]*
   Same as the function above, but for iterator ranges and C-style arrays.   A class that fulfills the requirements of an iterator range defines the   functions  [2.x.53]  and  [2.x.54]    both of which return iterators to elements that form the bounds of the   range.  
* [0.x.51]*
   Same as the function above, but for deal.II's IteratorRange.  
* [0.x.52]

