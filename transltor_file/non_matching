include/deal.II-translator/non_matching/coupling_0.txt
[0.x.0]*
 A namespace for functions offering tools to handle two meshes with no alignment requirements.
*  Typically these functions allow for computations on the real-space intersection between the two meshes e.g. surface integrals and construction of coupling matrices.

* 
* [0.x.1]*
   Create a coupling sparsity pattern for non-matching, overlapping grids.     Given two non-matching triangulations, representing the domains  [2.x.0]    and  [2.x.1] , with  [2.x.2] , and two finite element spaces    [2.x.3]  and  [2.x.4] , compute the sparsity pattern that would be   necessary to assemble the matrix   [1.x.0]   where  [2.x.5]  is the finite element space associated with the   `space_dh` passed to this function (or part of it, if specified in   `space_comps`), while  [2.x.6]  is the finite element space associated with   the `immersed_dh` passed to this function (or part of it, if specified in   `immersed_comps`).     The `sparsity` is filled by locating the position of quadrature points   (obtained by the reference quadrature `quad`) defined on elements of  [2.x.7]    with respect to the embedding triangulation  [2.x.8] . For each overlapping   cell, the entries corresponding to `space_comps` in `space_dh` and   `immersed_comps` in `immersed_dh` are added to the sparsity pattern.     The `space_comps` and `immersed_comps` masks are assumed to be ordered in   the same way: the first component of `space_comps` will couple with the   first component of `immersed_comps`, the second with the second, and so   on. If one of the two masks has more non-zero than the other, then the   excess components will be ignored.     If the domain  [2.x.9]  does not fall within  [2.x.10] , an exception will be   thrown by the algorithm that computes the quadrature point locations. In   particular, notice that this function only makes sens for `dim1` lower or   equal than `dim0`. A static assert guards that this is actually the case.     For both spaces, it is possible to specify a custom Mapping, which   defaults to StaticMappingQ1 for both.     This function will also work in parallel, provided that the immersed   triangulation is of type  [2.x.11]    An exception is thrown if you use an immersed    [2.x.12]      See the tutorial program  [2.x.13]  for an example on how to use this   function.  
* [0.x.2]*
   Same as above, but takes an additional  [2.x.14]  object, instead of   creating one internally. In this version of the function, the parameter  [2.x.15]    space_mapping cannot be specified, since it is taken from the  [2.x.16]    parameter.  
* [0.x.3]*
   Create a coupling mass matrix for non-matching, overlapping grids.     Given two non-matching triangulations, representing the domains  [2.x.17]    and  [2.x.18] , with  [2.x.19] , and two finite element spaces    [2.x.20]  and  [2.x.21] , compute the coupling matrix   [1.x.1]   where  [2.x.22]  is the finite element space associated with the   `space_dh` passed to this function (or part of it, if specified in   `space_comps`), while  [2.x.23]  is the finite element space associated with   the `immersed_dh` passed to this function (or part of it, if specified in   `immersed_comps`).     The corresponding sparsity patterns can be computed by calling the   make_coupling_sparsity_pattern function. The elements of the matrix are   computed by locating the position of quadrature points defined on elements   of  [2.x.24]  with respect to the embedding triangulation  [2.x.25] .     The `space_comps` and `immersed_comps` masks are assumed to be ordered in   the same way: the first component of `space_comps` will couple with the   first component of `immersed_comps`, the second with the second, and so   on. If one of the two masks has more non-zero entries non-zero than the   other, then the excess components will be ignored.     If the domain  [2.x.26]  does not fall within  [2.x.27] , an exception will be   thrown by the algorithm that computes the quadrature point locations. In   particular, notice that this function only makes sense for `dim1` lower or   equal than `dim0`. A static assert guards that this is actually the case.     For both spaces, it is possible to specify a custom Mapping, which   defaults to StaticMappingQ1 for both.     This function will also work in parallel, provided that the immersed   triangulation is of type  [2.x.28]    An exception is thrown if you use an immersed    [2.x.29]      See the tutorial program  [2.x.30]  for an example on how to use this   function.  
* [0.x.4]*
   Same as above, but takes an additional  [2.x.31]  object, instead of   creating one internally. In this version of the function, the parameter  [2.x.32]    space_mapping cannot specified, since it is taken from the  [2.x.33]    parameter.  
* [0.x.5]*
   Create a coupling sparsity pattern for non-matching independent grids,   using a convolution kernel with compact support of radius epsilon.     Given two non-matching triangulations, representing the domains  [2.x.34]    and  [2.x.35] , both embedded in  [2.x.36] , and two finite element   spaces  [2.x.37]  and  [2.x.38] , compute the sparsity pattern that   would be necessary to assemble the matrix     [1.x.2]     where  [2.x.39]  is the finite element space associated with the    [2.x.40]  passed to this function (or part of it, if specified in    [2.x.41]  while  [2.x.42]  is the finite element space associated   with the  [2.x.43]  passed to this function (or part of it, if specified   in  [2.x.44]  and  [2.x.45]  is a function derived from   CutOffFunctionBase with compact support included in a ball of radius    [2.x.46] .     The  [2.x.47]  and  [2.x.48]  masks are assumed to be ordered in   the same way: the first component of  [2.x.49]  will couple with the   first component of  [2.x.50]  the second with the second, and so   on. If one of the two masks has more active components than the other, then   the excess components will be ignored.     For both spaces, it is possible to specify a custom Mapping, which   defaults to StaticMappingQ1 for both.     This function will also work in parallel, provided that at least one of the   triangulations is of type  [2.x.51]    An exception is thrown if both triagnulations are of type    [2.x.52]      This function assumes that the convolution has support contained in a box   of radius  [2.x.53]  If epsilon is set to zero, then we assume that the   kernel is the Dirac delta distribution, and the call is forwarded to the   method in this namespace with the same name, that does not take an epsilon   as input (but a quadrature formula  [2.x.54]  is required). In this case, more   restrictive conditions are required on the two spaces. See the   documentation of the other create_coupling_sparsity_pattern() function.  
* [0.x.6]*
   Create a coupling mass matrix for non-matching independent grids,   using a convolution kernel with compact support.     Given two non-matching triangulations, representing the domains    [2.x.55]  and  [2.x.56] , both embedded in  [2.x.57] , and two finite   element spaces  [2.x.58]  and    [2.x.59] , compute the matrix     [1.x.3]     where  [2.x.60]  is the finite element space associated with the    [2.x.61]  passed to this function (or part of it, if specified in    [2.x.62]  while  [2.x.63]  is the finite element space associated   with the  [2.x.64]  passed to this function (or part of it, if specified   in  [2.x.65]  and  [2.x.66]  is a function derived from   CutOffFunctionBase with compact support included in a ball of radius    [2.x.67] .     The corresponding sparsity patterns can be computed by calling the   make_coupling_sparsity_pattern() function.     The  [2.x.68]  and  [2.x.69]  masks are assumed to be ordered in   the same way: the first component of  [2.x.70]  will couple with the   first component of  [2.x.71]  the second with the second, and so   on. If one of the two masks has more active components than the other, then   the excess components will be ignored.     For both spaces, it is possible to specify a custom Mapping, which   defaults to StaticMappingQ1 for both.     This function will also work in parallel, provided that one of the two   triangulations is of type  [2.x.72]    An exception is thrown if both triangulations are of type    [2.x.73]      The parameter  [2.x.74]  is used to set the size of the cut-off function   used to compute the convolution. If epsilon is set to zero, then we assume   that the kernel is the Dirac delta distribution, and the call is forwarded   to the method in this namespace with the same name, that does not take an   epsilon as input.  
* [0.x.7]

include/deal.II-translator/non_matching/immersed_surface_quadrature_0.txt
[0.x.0]*
   This class defines a quadrature formula for integration over an   oriented surface,  [2.x.0] , immersed in the unit cell. By   immersed it is meant that the surface may intersect the unit cell   in an arbitrary way. The quadrature formula is described by a set   of quadrature points,  [2.x.1] , weights,  [2.x.2] , and normalized   surface normals,  [2.x.3] .     We typically want to compute surface integrals in real space.   A surface  [2.x.4]  intersecting a cell  [2.x.5]  in real space, can be mapped onto a   surface  [2.x.6]  intersecting the unit cell  [2.x.7] .   Thus a surface integral over  [2.x.8]  in real space can be transformed to   a surface integral over  [2.x.9]  according to   [1.x.0]   where  [2.x.10]  is the mapping from reference to real space and  [2.x.11]  is its   Jacobian. This transformation is possible since the continuous surface   elements are vectors:  [2.x.12]  which are   parallel to the normals of  [2.x.13]  and  [2.x.14] . So in order to compute the   integral in real space one needs information about the normal to do the   transformation.     Thus, in addition to storing points and weights, this quadrature stores   also the normalized normal for each quadrature point. This can be viewed   as storing a discrete surface element,   [1.x.1]   for each quadrature point. The surface integral in real space would then be   approximated as   [1.x.2]      [2.x.15]   
* [0.x.1]*
     Default constructor to initialize the quadrature with no quadrature     points.    
* [0.x.2]*
     Construct a quadrature formula from vectors of points, weights and     surface normals. The points, weights and normals should be with respect     to reference space, and the normals should be normalized.    
* [0.x.3]*
     Extend the given formula by an additional quadrature point.     The point, weight and normal should be with respect to reference space,     and the normal should be normalized.         This function exists since immersed quadrature rules can be rather     complicated to construct. Often the construction is done by     partitioning the cell into regions and constructing points on each     region separately. This can make it cumbersome to create the quadrature     from the constructor since all quadrature points have to be known at     time of creation of the object.        
*  [2.x.16]  This function should only be used during construction of the     quadrature formula.    
* [0.x.4]*
     Return a reference to the <tt>i</tt>th surface normal.    
* [0.x.5]*
     Return a reference to the whole %vector of normals.    
* [0.x.6]*
     %Vector of surface normals at each quadrature point.    
* [0.x.7]

