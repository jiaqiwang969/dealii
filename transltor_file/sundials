include/deal.II-translator/sundials/arkode_0.txt
[0.x.0]*
 A namespace for dealing with ODE solvers through the SUNDIALS package.

* 
* [0.x.1]*
   Interface to SUNDIALS additive Runge-Kutta methods (ARKode).     The class ARKode is a wrapper to SUNDIALS variable-step, embedded,   additive Runge-Kutta solver which is a general purpose solver for systems   of ordinary differential equations characterized by the presence of both   fast and slow dynamics.     Fast dynamics are treated implicitly, and slow dynamics are treated   explicitly, using nested families of implicit and explicit Runge-Kutta   solvers.     Citing directly from ARKode documentation:     ARKode solves ODE initial value problems (IVPs) in  [2.x.0] . These problems   should be posed in explicit form as     [1.x.0]     Here,  [2.x.1]  is the independent variable (e.g. time), and the dependent   variables are given by  [2.x.2] , and we use notation  [2.x.3]  to denote    [2.x.4] .  [2.x.5]  is a user-supplied nonsingular operator from  [2.x.6] .   This operator may depend on  [2.x.7]  but not on  [2.x.8] .     For standard systems of ordinary differential equations and for problems   arising from the spatial semi-discretization of partial differential   equations using finite difference or finite volume methods,  [2.x.9]  is   typically the identity matrix,  [2.x.10] . For PDEs using a finite-element   spatial semi-discretization  [2.x.11]  is typically a well-conditioned mass   matrix.     The two right-hand side functions may be described as:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.12] : contains the "slow" time scale components of the system.                  This will be integrated using explicit methods.
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.13] : contains the "fast" time scale components of the system.                  This will be integrated using implicit methods.     ARKode may be used to solve stiff, nonstiff and multi-rate problems.   Roughly speaking, stiffness is characterized by the presence of at least   one rapidly damped mode, whose time constant is small compared to the time   scale of the solution itself. In the implicit/explicit (ImEx) splitting   above, these stiff components should be included in the right-hand side   function  [2.x.14] .     For multi-rate problems, a user should provide both of the functions  [2.x.15]    and  [2.x.16]  that define the IVP system.     For nonstiff problems, only  [2.x.17]  should be provided, and  [2.x.18]  is assumed   to be zero, i.e. the system reduces to the non-split IVP:     [1.x.1]     In this scenario, the ARK methods reduce to classical explicit Runge-Kutta   methods (ERK). For these classes of methods, ARKode allows orders of   accuracy  [2.x.19] , with embeddings of orders  [2.x.20] . These default to the Heun-Euler-2-1-2,   Bogacki-Shampine-4-2-3, Zonneveld-5-3-4, Cash-Karp-6-4-5, Verner-8-5-6 and   Fehlberg-13-7-8 methods, respectively.     Finally, for stiff (linear or nonlinear) problems the user may provide only    [2.x.21] , implying that  [2.x.22] , so that the system reduces to the non-split   IVP     [1.x.2]     Similarly to ERK methods, in this scenario the ARK methods reduce to   classical diagonally-implicit Runge-Kutta methods (DIRK). For these   classes of methods, ARKode allows orders of accuracy  [2.x.23] ,   with embeddings of orders  [2.x.24] . These default to the   SDIRK-2-1-2, ARK-4-2-3 (implicit), SDIRK-5-3-4 and ARK-8-4-5 (implicit)   methods, respectively.     For both DIRK and ARK methods, an implicit system of the form   [1.x.3]   must be solved for each stage  [2.x.25] , where   we have the data   [1.x.4]   for the ARK methods, or   [1.x.5]   for the DIRK methods. Here  [2.x.26]  and  [2.x.27]  are the Butcher's   tables for the chosen solver.     If  [2.x.28]  depends nonlinearly on  [2.x.29]  then the systems above correspond   to a nonlinear system of equations; if  [2.x.30]  depends linearly on    [2.x.31]  then this is a linear system of equations. By specifying the flag   `implicit_function_is_linear`, ARKode takes some shortcuts that allow a   faster solution process.     For systems of either type, ARKode allows a choice of solution strategy.   The default solver choice is a variant of Newton's method,   [1.x.6]   where  [2.x.32]  is the Newton index, and the Newton update  [2.x.33]    requires the solution of the linear Newton system   [1.x.7]   where   [1.x.8]     As an alternate to Newton's method, ARKode may solve for each stage  [2.x.34]  using an Anderson-accelerated fixed point iteration   [1.x.9]     Unlike with Newton's method, this option does not require the solution of   a linear system at each iteration, instead opting for solution of a   low-dimensional least-squares solution to construct the nonlinear update.     Finally, if the user specifies `implicit_function_is_linear`, i.e.,    [2.x.35]  depends linearly on  [2.x.36] , and if the Newton-based nonlinear   solver is chosen, then the system will be solved using only a single   Newton iteration. Notice that in order for the Newton solver to be used,   at least the jacobian_times_vector() function (or solve_jacobian_system()   for SUNDIALS version > 4.0.0) should be supplied. If this function is not   supplied, then only the fixed-point iteration will be supported, and the  `implicit_function_is_linear` setting is ignored.     The optimal solver (Newton vs fixed-point) is highly problem-dependent.   Since fixed-point solvers do not require the solution of any linear   systems, each iteration may be significantly less costly than their Newton   counterparts. However, this can come at the cost of slower convergence (or   even divergence) in comparison with Newton-like methods. These fixed-point   solvers do allow for user specification of the Anderson-accelerated   subspace size,  [2.x.37] . While the required amount of solver memory grows   proportionately to  [2.x.38] , larger values of  [2.x.39]  may result in faster   convergence.     This improvement may be significant even for "small" values, e.g.  [2.x.40] , and convergence may not improve (or even deteriorate) for   larger values of  [2.x.41] . While ARKode uses a Newton-based iteration as its   default solver due to its increased robustness on very stiff problems, it   is highly recommended that users also consider the fixed-point solver for   their cases when attempting a new problem.     For either the Newton or fixed-point solvers, it is well-known that both   the efficiency and robustness of the algorithm intimately depends on the   choice of a good initial guess. In ARKode, the initial guess for either   nonlinear solution method is a predicted value  [2.x.42]  that is computed   explicitly from the previously-computed data (e.g.  [2.x.43] , and    [2.x.44]  where  [2.x.45] ). Additional information on the specific predictor   algorithms implemented in ARKode is provided in ARKode documentation.     The user has to provide the implementation of at least one (or both) of the   following  [2.x.46] 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - implicit_function()
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - explicit_function()     If the mass matrix is different from the identity, the user should supply
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - mass_times_vector() (or solve_mass_system() for SUNDIALS version      < 4.0.0) and, optionally,
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - mass_times_setup() (or setup_mass() for SUNDIALS version < 4.0.0)     If the use of a Newton method is desired, then the user should also supply
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - jacobian_times_vector (or solve_jacobian_system() for SUNDIALS version      < 4.0.0)
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - optional: jacobian_times_setup() (or setup_jacobian() for SUNDIALS      version < 4.0.0)    
*  [2.x.47]  Although SUNDIALS can provide a difference quotient approximation     of the Jacobian, this is currently not supported through this wrapper.     Only for SUNDIALS version > 4.0.0: A SUNDIALS default solver (SPGMR) is   used to solve the linear systems. To use a custom linear solver for the   mass matrix and/or Jacobian, set:
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - solve_mass() and/or
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - solve_jacobian()     Only for SUNDIALS version > 4.0.0: To use a custom preconditioner with   either a default or custom linear solver, set:
* 

* 
* 

* 
* 

* 
* 
*  - jacobian_preconditioner_solve() and/or mass_preconditioner_solve()   and, optionally,
* 

* 
* 

* 
* 

* 
* 
*  - jacobian_preconditioner_setup() and/or mass_preconditioner_setup()     Also the following functions could be rewritten. By default   they do nothing, or are not required.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - solver_should_restart()
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - get_local_tolerances()     To produce output at fixed steps, set the function
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - output_step()     Any other custom settings of the ARKODE object can be specified in
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - custom_setup()     To provide a simple example, consider the harmonic oscillator problem:   [1.x.10]     We write it in terms of a first order ode:  [1.x.11]     That is  [2.x.48]    where   [1.x.12]   and  [2.x.49] .     The exact solution is  [2.x.50] ,  [2.x.51] ,  [2.x.52] .     A minimal implementation, using only explicit RK methods, is given by the   following code snippet:    
* [1.x.13]
*   
* [0.x.2]*
     Additional parameters that can be passed to the ARKode class.    
* [0.x.3]*
       Initialization parameters for ARKode.             Global parameters:              [2.x.53]  initial_time Initial time        [2.x.54]  final_time Final time        [2.x.55]  initial_step_size Initial step size        [2.x.56]  output_period Desired time interval between each output             Running parameters:              [2.x.57]  minimum_step_size Minimum step size        [2.x.58]  maximum_order Maximum ARK order        [2.x.59]  maximum_non_linear_iterations Maximum number of nonlinear         iterations        [2.x.60]  implicit_function_is_linear Specifies that the implicit portion         of the problem is linear        [2.x.61]  implicit_function_is_time_independent Specifies that the         implicit portion of the problem is linear and time independent        [2.x.62]  mass_is_time_independent Specifies that the mass pre-factor is         independent of time        [2.x.63]  anderson_acceleration_subspace The number of vectors to use for         Anderson acceleration within the packaged SUNDIALS solver.             Error parameters:              [2.x.64]  absolute_tolerance Absolute error tolerance        [2.x.65]  relative_tolerance Relative error tolerance      
* [0.x.4]*
       Add all AdditionalData() parameters to the given ParameterHandler       object. When the parameters are parsed from a file, the internal       parameters are automatically updated.             The options you pass at construction time are set as default values in       the ParameterHandler object `prm`. You can later modify them by parsing       a parameter file using `prm`. The values of the parameter will be       updated whenever the content of `prm` is updated.             Make sure that this class lives longer than `prm`. Undefined behavior       will occur if you destroy this class, and then parse a parameter file       using `prm`.      
* [0.x.5]*
       Initial time for the DAE.      
* [0.x.6]*
       Final time.      
* [0.x.7]*
       Initial step size.      
* [0.x.8]*
       Minimum step size.      
* [0.x.9]*
       Absolute error tolerance for adaptive time stepping.      
* [0.x.10]*
       Relative error tolerance for adaptive time stepping.      
* [0.x.11]*
       Maximum order of ARK.      
* [0.x.12]*
       Desired time period between each output. The actual output time period       may be adjusted by Arkode.      
* [0.x.13]*
       Maximum number of iterations for Newton or fixed point method during       time advancement.      
* [0.x.14]*
       Specify whether the implicit portion of the problem is linear.      
* [0.x.15]*
       Specify whether the implicit portion of the problem is linear and time       independent.      
* [0.x.16]*
       Specify whether the mass pre-factor is time independent. Has no effect       if no mass is specified.      
* [0.x.17]*
       Number of subspace vectors to use for Anderson acceleration. Only       meaningful if the packaged SUNDIALS fixed-point solver is used.      
* [0.x.18]*
     Constructor. It is possible to fine tune the SUNDIALS ARKode solver by     passing an AdditionalData() object that sets all of the solver     parameters.         The MPI communicator is simply ignored in the serial case.              [2.x.66]  data ARKode configuration data      [2.x.67]  mpi_comm MPI communicator    
* [0.x.19]*
     Destructor.    
* [0.x.20]*
     Integrate the initial value problem. This function returns the final     number of computed steps.          [2.x.68]  solution On input, this vector contains the initial condition. On       output, it contains the solution at the final time.    
* [0.x.21]*
     Integrate the initial value problem. Compared to the function above, this     function allows to specify an  [2.x.69]  for the next solution.     Repeated calls of this function must use monotonously increasing values     for  [2.x.70]  The last solution state is saved internally     along with the  [2.x.71]  and will be reused as initial     condition for the next call.         Users may find this function useful when integrating ARKode into an outer     time loop of their own, especially when output_step() is too restrictive.        
*  [2.x.72]   [2.x.73]  may be larger than  [2.x.74]        which is ignored by this function.          [2.x.75]  solution The final solution. If the solver restarts, either       because it is the first ever solve or the flag  [2.x.76]  is       set, the vector is also used as initial condition.      [2.x.77]  intermediate_time The time for the incremental solution step. Must       be greater than the last time that was used in a previous call to this       function.      [2.x.78]  reset_solver Optional flag to recreate all internal objects which       may be desirable for spatial adaptivity methods. If set to `true`,       reset() is called before solving the ODE, which sets  [2.x.79]  as       initial condition. This willnot* reset the stored time from previous       calls to this function.    
* [0.x.22]*
     Clear internal memory and start with clean objects. This function is     called when the simulation starts and when the user returns true to a     call to solver_should_restart().         By default solver_should_restart() returns false. If the user needs to     implement, for example, local adaptivity in space, he or she may assign     a different function to solver_should_restart() that performs all mesh     changes, transfers the solution to the new mesh, and returns true.          [2.x.80]  t  The new starting time      [2.x.81]  h  The new starting time step      [2.x.82]  y  The new initial solution    
* [0.x.23]*
     Provides user access to the internally used ARKODE memory.         This functionality is intended for users who wish to query additional     information directly from the ARKODE integrator, refer to the ARKODE     manual for the various `ARKStepGet...` functions. The `ARKStepSet...`     functions should not be called since this might lead to conflicts with     various settings that are performed by this ARKode object.        
*  [2.x.83]  If custom settings of ARKODE functionality (that are not achievable       via the interface of this class) are required, the function       custom_setup() should be used.          [2.x.84]  pointer to the ARKODE memory block that can be passed to SUNDIALS       functions    
* [0.x.24]*
     A function object that was used to `reinit` the given vector. Setting     this field does no longer have any effect and all auxiliary vectors are     reinit-ed automatically based on the user-supplied vector in solve_ode().          [2.x.85]  This function is no longer used and can be safely removed in       user code.    
* [0.x.25]*
     A function object that users may supply and that is intended to compute     the explicit part of the IVP right hand side. Sets  [2.x.86] .         At least one of explicit_function() or implicit_function() must be     provided. According to which one is provided, explicit, implicit, or     mixed RK methods are used.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.26]*
     A function object that users may supply and that is intended to compute     the implicit part of the IVP right hand side. Sets  [2.x.87] .         At least one of explicit_function() or implicit_function() must be     provided. According to which one is provided, explicit, implicit, or     mixed RK methods are used.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.27]*
     A function object that users may supply and that is intended to     prepare the linear solver for subsequent calls to     solve_jacobian_system().         Make sure that after a call to this function, we know how to compute     solutions of systems  [2.x.88] , where  [2.x.89]  is some approximation to the     Newton matrix,  [2.x.90] . This function is     optional. If the user does not provide it, then solve_jacobian_system()     is assumed to also perform the setup internally.         The setup_jacobian() function may call a user-supplied function to     compute needed data related to the Jacobian matrix. Alternatively, it may     choose to retrieve and use stored values of this data. In either case,     setup_jacobian() may also preprocess that data as needed for     solve_jacobian_system(), which may involve calling a generic function     (such as for LU factorization).         This data may be intended either for direct use (in a direct linear     solver) or for use in a preconditioner (in a preconditioned iterative     linear solver). The setup_jacobian() function is not called at every     stage solve (or even every time step), but only as frequently as the     solver determines that it is appropriate to perform the setup task. In     this way, Jacobian-related data generated by setup_jacobian() is     expected to be used over a number of time steps.         If the user uses a matrix based computation of the Jacobian, then this     is the right place where an assembly routine shoulde be called to     assemble both a matrix and a preconditioner for the Jacobian system.     Subsequent calls (possibly more than one) to solve_jacobian_system() can     assume that this function has been called at least once.         Notice that no assumption is made by this interface on what the user     should do in this function. ARKode only assumes that after a call to     setup_jacobian() it is possible to call solve_jacobian_system(), to     obtain a solution  [2.x.91]  to the system  [2.x.92] . If this function is not     provided, then it is never called.         Arguments to the function are          [2.x.93]  t  the current time      [2.x.94]  gamma  the current factor to use in the jacobian computation      [2.x.95]  ypred  is the predicted  [2.x.96]  vector for the current ARKode     internal step      [2.x.97]  fpred  is the value of the implicit right-hand side at ypred,             [2.x.98] .          [2.x.99]  convfail Input flag used to indicate any problem that     occurred during the solution of the nonlinear equation on the current     time step for which the linear solver is being used. This flag can be     used to help decide whether the Jacobian data kept by a linear solver     needs to be updated or not. Its possible values are:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - ARK_NO_FAILURES: this value is passed if either this is the first     call for this step, or the local error test failed on the previous     attempt at this step (but the Newton iteration converged).
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - ARK_FAIL_BAD_J: this value is passed if (a) the previous Newton         corrector iteration did not converge and the linear solver's setup         function indicated that its Jacobian-related data is not current, or     (b) during the previous Newton corrector iteration, the linear solver's         solve function failed in a recoverable manner and the linear solver's         setup function indicated that its Jacobian-related data is not     current.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - ARK_FAIL_OTHER: this value is passed if during the current internal         step try, the previous Newton iteration failed to converge even     though the linear solver was using current Jacobian-related data.          [2.x.100]  j_is_current: a boolean to be filled in by setup_jacobian().     The value should be set to `true` if the Jacobian data is current after     the call, and should be set to `false` if its Jacobian data is not     current. If setup_jacobian() calls for re-evaluation of Jacobian data     (based on convfail and ARKode state data), then it should set     `j_is_current` to `true` unconditionally, otherwise an infinite loop can     result.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (ARKodeReinit will be called if this happens, and           then last function will be attempted again
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an           assertion will be thrown.    
* [0.x.28]*
     A function object that users may supply and that is intended to solve     the Jacobian linear system. This function will be called by ARKode     (possibly several times) after setup_jacobian() has been called at least     once. ARKode tries to do its best to call setup_jacobian() the minimum     amount of times. If convergence can be achieved without updating the     Jacobian, then ARKode does not call setup_jacobian() again. If, on the     contrary, internal ARKode convergence tests fail, then ARKode calls     again setup_jacobian() with updated vectors and coefficients so that     successive calls to solve_jacobian_systems() lead to better convergence     in the Newton process.         If you do not specify a solve_jacobian_system() function, then a fixed     point iteration is used instead of a Newton method. Notice that this may     not converge, or may converge very slowly.         The jacobian  [2.x.101]  should be (an approximation of) the system Jacobian     [1.x.14]     evaluated at `t`, `ycur`. `fcur` is  [2.x.102] .         A call to this function should store in `dst` the result of  [2.x.103]      applied to `src`, i.e., `J*dst = src`. It is the users responsibility to     set up proper solvers and preconditioners inside this function.             Arguments to the function are          [2.x.104]  t  the current time      [2.x.105]  gamma  the current factor to use in the jacobian computation      [2.x.106]  ycur  is the current  [2.x.107]  vector for the current ARKode       internal step      [2.x.108]  fcur  is the current value of the implicit right-hand side at       ycur,  [2.x.109] .             This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (ARKodeReinit will be called if this happens, and           then last function will be attempted again
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an           assertion will be thrown.    
* [0.x.29]*
     A function object that users may supply and that is intended to set up     the mass matrix. This function is called by ARKode any time a mass     matrix update is required. The user should compute the mass matrix (or     update all the variables that allow the application of the mass matrix).     This function is called by ARKode once, before any call to     solve_mass_system().         ARKode supports the case where the mass matrix may depend on time, but     not the case where the mass matrix depends on the solution itself.         If the user does not provide a solve_mass_matrix() function, then the     identity is used. If the setup_mass() function is not provided, then     solve_mass_system() should do all the work by itself.         If the user uses a matrix based computation of the mass matrix, then     this is the right place where an assembly routine shoulde be called to     assemble both a matrix and a preconditioner. Subsequent calls (possibly     more than one) to solve_mass_system() can assume that this function     has been called at least once.         Notice that no assumption is made by this interface on what the user     should do in this function. ARKode only assumes that after a call to     setup_mass() it is possible to call solve_mass_system(), to     obtain a solution  [2.x.110]  to the system  [2.x.111] .         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (ARKodeReinit will be called if this happens, and           then last function will be attempted again
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an           assertion will be thrown.    
* [0.x.30]*
     A function object that users may supply and that is intended to solve     the mass matrix linear system. This function will be called by ARKode     (possibly several times) after setup_mass() has been called at least     once. ARKode tries to do its best to call setup_mass() the minimum     amount of times.         A call to this function should store in `dst` the result of  [2.x.112]      applied to `src`, i.e., `M*dst = src`. It is the users responsibility to     set up proper solvers and preconditioners inside this function.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (ARKodeReinit will be called if this happens, and           then last function will be attempted again
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an           assertion will be thrown.    
* [0.x.31]*
     A function object that users may supply and that is intended to compute     the product of the mass matrix with a given vector `v`. This function     will be called by ARKode (possibly several times) after     mass_times_setup() has been called at least once. ARKode tries to do its     best to call mass_times_setup() the minimum amount of times.         A call to this function should store in `Mv` the result of  [2.x.113]      applied to `v`.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.32]*
     A function object that users may supply and that is intended to set up     the mass matrix. This function is called by ARKode any time a mass     matrix update is required. The user should compute the mass matrix (or     update all the variables that allow the application of the mass matrix).     This function is guaranteed to be called by ARKode at least once, before     any call to mass_times_vector().         ARKode supports the case where the mass matrix may depend on time, but     not the case where the mass matrix depends on the solution itself.         If the user does not provide a mass_times_vector() function, then the     identity is used. If the mass_times_setup() function is not provided,     then mass_times_vector() should do all the work by itself.         If the user uses a matrix-based computation of the mass matrix, then     this is the right place where an assembly routine should be called to     assemble the matrix. Subsequent calls (possibly  more than one) to     mass_times_vector() can assume that this function has been called at     least once.        
*  [2.x.114]  No assumption is made by this interface on what the user       should do in this function. ARKode only assumes that after a call to       mass_times_setup() it is possible to call mass_times_vector().          [2.x.115]  t The current evaluation time         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.33]*
     A function object that users may supply and that is intended to compute     the product of the Jacobian matrix with a given vector `v`. The Jacobian     here refers to  [2.x.116] , i.e., the Jacobian of     the user-specified implicit_function.         A call to this function should store in `Jv` the result of  [2.x.117]      applied to `v`.         Arguments to the function are          [2.x.118]  v  The vector to be multiplied by the Jacobian      [2.x.119]  Jv The vector to be filled with the product J*v      [2.x.120]  t  The current time      [2.x.121]  y  The current  [2.x.122]  vector for the current ARKode internal       step      [2.x.123]  fy  The current value of the implicit right-hand side at y,        [2.x.124] .         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.34]*
     A function object that users may supply and that is intended to set up     all data necessary for the application of jacobian_times_vector(). This     function is called by ARKode any time a Jacobian update is required.     The user should compute the Jacobian (or update all the variables that     allow the application of Jacobian). This function is guaranteed to     be called by ARKode at least once, before any call to     jacobian_times_vector().         If the jacobian_times_setup() function is not provided, then     jacobian_times_vector() should do all the work by itself.         If the user uses a matrix based computation of the Jacobian, then this is     the right place where an assembly routine should be called to assemble     the matrix. Subsequent calls (possibly  more than one) to     jacobian_times_vector() can assume that this function has been called at     least once.        
*  [2.x.125]  No assumption is made by this interface on what the user       should do in this function. ARKode only assumes that after a call to       jacobian_times_setup() it is possible to call jacobian_times_vector().          [2.x.126]  t  The current time      [2.x.127]  y  The current ARKode internal solution vector  [2.x.128]       [2.x.129]  fy  The implicit right-hand side function evaluated at the       current time  [2.x.130]  and state  [2.x.131] , i.e.,  [2.x.132]          This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.35]*
     A LinearSolveFunction object that users may supply and that is intended     to solve the linearized system  [2.x.133] , where  [2.x.134]  is the     Jacobian of the nonlinear residual. The application of the mass matrix      [2.x.135]  and Jacobian  [2.x.136]  are known through the functions mass_times_vector()     and jacobian_times_vector() and  [2.x.137]  is a factor provided by     SUNDIALS. The matrix-vector product  [2.x.138]  is encoded in the supplied     SundialsOperator. If a preconditioner was set through     jacobian_preconditioner_solve(), it is encoded in the     SundialsPreconditioner. If no preconditioner was supplied this way, the     preconditioner is the identity matrix, i.e., no preconditioner. The user     is free to use a custom preconditioner in this function object that is     not supplied through SUNDIALS.         If you do not specify a solve_linearized_system() function, then a     SUNDIALS packaged SPGMR solver with default settings is used.         For more details on the function type refer to LinearSolveFunction.    
* [0.x.36]*
     A LinearSolveFunction object that users may supply and that is intended     to solve the mass system  [2.x.139] . The matrix-vector product  [2.x.140]  is     encoded in the supplied SundialsOperator. If a preconditioner was set     through mass_preconditioner_solve(), it is encoded in the     SundialsPreconditioner. If no preconditioner was supplied this way, the     preconditioner is the identity matrix, i.e., no preconditioner. The user     is free to use a custom preconditioner in this function object that is     not supplied through SUNDIALS.         The user must specify this function if a non-identity mass matrix is used     and applied in mass_times_vector().         For more details on the function type refer to LinearSolveFunction.    
* [0.x.37]*
     A function object that users may supply to either pass a preconditioner     to a SUNDIALS built-in solver or to apply a custom preconditioner within     the user's own linear solve specified in solve_linearized_system().         This function should compute the solution to the preconditioner equation      [2.x.141]  and store it in  [2.x.142]  In this equation  [2.x.143]  should approximate the     Jacobian  [2.x.144]  of the nonlinear system.          [2.x.145]  t  The current time      [2.x.146]  y  The current  [2.x.147]  vector for the current ARKode internal       step      [2.x.148]  fy  The current value of the implicit right-hand side at y,        [2.x.149] .      [2.x.150]  r  The right-hand side of the preconditioner equation      [2.x.151]  z The solution of applying the preconditioner, i.e., solving        [2.x.152]       [2.x.153]  gamma The value  [2.x.154]  in the preconditioner equation      [2.x.155]  tol The tolerance up to which the system should be solved      [2.x.156]  lr An input flag indicating whether the preconditioner solve       is to use the left preconditioner (lr = 1) or the right preconditioner       (lr = 2). Only relevant if used with a SUNDIALS packaged solver. If       used with a custom solve_mass() function this will be set to zero.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.38]*
     A function object that users may supply to set up a preconditioner     specified in jacobian_preconditioner_solve().         This function should prepare the solution of the preconditioner equation      [2.x.157] . In this equation  [2.x.158]  should approximate the Jacobian  [2.x.159]      of the nonlinear system.         If the jacobian_preconditioner_setup() function is not provided, then     jacobian_preconditioner_solve() should do all the work by itself.        
*  [2.x.160]  No assumption is made by this interface on what the user       should do in this function. ARKode only assumes that after a call to       jacobian_preconditioner_setup() it is possible to call       jacobian_preconditioner_solve().          [2.x.161]  t  The current time      [2.x.162]  y  The current  [2.x.163]  vector for the current ARKode internal       step      [2.x.164]  fy  The current value of the implicit right-hand side at y,        [2.x.165] .      [2.x.166]  jok  An input flag indicating whether the Jacobian-related       data needs to be updated. The jok argument provides for the reuse of       Jacobian data in the preconditioner solve function. When jok =       SUNFALSE, the Jacobian-related data should be recomputed from scratch.       When jok = SUNTRUE the Jacobian data, if saved from the previous call       to this function, can be reused (with the current value of gamma). A       call with jok = SUNTRUE can only occur after a call with jok =       SUNFALSE.      [2.x.167]  jcur On output this should be set to SUNTRUE if Jacobian data       was recomputed, or set to SUNFALSE if Jacobian data was not recomputed,       but saved data was still reused.      [2.x.168]  gamma The value  [2.x.169]  in  [2.x.170] . The preconditioner       should approximate the inverse of this matrix.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.39]*
     A function object that users may supply to either pass a preconditioner     to a SUNDIALS built-in solver or to apply a custom preconditioner within     the user's own linear solve specified in solve_mass().         This function should compute the solution to the preconditioner equation      [2.x.171]  and store it in  [2.x.172]  In this equation  [2.x.173]  should approximate the     mass matrix  [2.x.174] .          [2.x.175]  t  The current time      [2.x.176]  r  The right-hand side of the preconditioner equation      [2.x.177]  z The solution of applying the preconditioner, i.e., solving        [2.x.178]       [2.x.179]  gamma The value  [2.x.180]  in the preconditioner equation      [2.x.181]  tol The tolerance up to which the system should be solved      [2.x.182]  lr An input flag indicating whether the preconditioner solve       is to use the left preconditioner (lr = 1) or the right preconditioner       (lr = 2). Only relevant if used with a SUNDIALS packaged solver. If       used with a custom solve_mass() function this will be set to zero.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.40]*
     A function object that users may supply to set up a preconditioner     specified in mass_preconditioner_solve().         This function should prepare the solution of the preconditioner equation      [2.x.183] . In this equation  [2.x.184]  should approximate the mass matrix  [2.x.185] .         If the mass_preconditioner_setup() function is not provided, then     mass_preconditioner_solve() should do all the work by itself.        
*  [2.x.186]  No assumption is made by this interface on what the user       should do in this function. ARKode only assumes that after a call to       mass_preconditioner_setup() it is possible to call       mass_preconditioner_solve().          [2.x.187]  t  The current time         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this           function again.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an           assertion will be thrown.    
* [0.x.41]*
     A function object that users may supply and that is intended to     postprocess the solution. This function is called by ARKode at fixed     time increments (every `output_period` seconds), and it is passed a     polynomial interpolation of the solution, computed using the current ARK     order and the (internally stored) previously computed solution steps.        
*  [2.x.188]  It is well possible that internally ARKode computes a time       step which is much larger than the `output_period` step, and therefore       calls this function consecutively several times by simply performing       all intermediate interpolations. There is no relationship between how       many times this function is called and how many time steps have       actually been computed.    
* [0.x.42]*
     A function object that users may supply and that is intended to evaluate     whether the solver should be restarted (for example because the number of     degrees of freedom has changed).         This function is supposed to perform all operations that are necessary     in `sol` to make sure that the resulting vectors are consistent, and of     the correct final size.         For example, one may decide that a local refinement is necessary at time     t. This function should then return true, and change the dimension of     `sol` to reflect the new dimension. Since ARKode does not know about the     new dimension, an internal reset is necessary.         The default implementation simply returns `false`, i.e., no restart is     performed during the evolution.    
* [0.x.43]*
     A function object that users may supply and that is intended to return a     vector whose components are the weights used by ARKode to compute the     vector norm. The implementation of this function is optional, and it is     used only if implemented.    
* [0.x.44]*
     A function object that users may supply and which is intended to perform     custom settings on the supplied  [2.x.189]  object. Refer to the     SUNDIALS documentation for valid options.         For instance, the following code attaches two files for diagnostic and     error output of the internal ARKODE implementation:        
* [1.x.15]
*         
*  [2.x.190]  This function will be called at the end of all other set up right       before the actual time evloution is started or continued with       solve_ode(). This function is also called when the solver is restarted,       see solver_should_restart(). Consult the SUNDIALS manual to see which       options are still available at this point.          [2.x.191]  arkode_mem pointer to the ARKODE memory block which can be used       for custom calls to `ARKStepSet...` methods.    
* [0.x.45]*
     Throw an exception when a function with the given name is not     implemented.    
* [0.x.46]*
     Internal routine to call ARKode repeatedly.    
* [0.x.47]*
     Set up the (non)linear solver and preconditioners in the ARKODE memory     object based on the user-specified functions.      [2.x.192]  solution The solution vector which is used as a template to create       new vectors.    
* [0.x.48]*
     Set up the solver and preconditioner for a non-identity mass matrix in     the ARKODE memory object based on the user-specified functions.      [2.x.193]  solution The solution vector which is used as a template to create       new vectors.    
* [0.x.49]*
     This function is executed at construction time to set the      [2.x.194]  above to trigger an assert if they are not     implemented.    
* [0.x.50]*
     ARKode configuration data.    
* [0.x.51]*
     ARKode memory object.    
* [0.x.52]*
     MPI communicator. SUNDIALS solver runs happily in     parallel. Note that if the library is compiled without MPI     support, MPI_Comm is aliased as int.    
* [0.x.53]*
     The final time in the last call to solve_ode().    
* [0.x.54]*
   Handle ARKode exceptions.  
* [0.x.55]

include/deal.II-translator/sundials/ida_0.txt
[0.x.0]*
   Interface to SUNDIALS Implicit Differential-Algebraic (IDA) solver.     The class IDA is a wrapper to SUNDIALS Implicit Differential-Algebraic   solver which is a general purpose solver for systems of   Differential-Algebraic Equations (DAEs).     The user has to provide the implementation of the following  [2.x.0] 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - reinit_vector;
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - residual;
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - setup_jacobian;
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - solve_jacobian_system/solve_with_jacobian;     The function `solve_jacobian_system` should be implemented for SUNDIALS   < 4.0.0. For later versions, you should use   `solve_with_jacobian` to leverage better non-linear   algorithms.     Optionally, also the following functions could be provided. By default   they do nothing, or are not required. If you call the constructor in a way   that requires a not-implemented function, an Assertion will be   thrown.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - solver_should_restart;
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - differential_components;
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - get_local_tolerances;     To output steps, connect a function to the signal
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - output_step;     Citing from the SUNDIALS documentation:       Consider a system of Differential-Algebraic Equations written in the     general form     [1.x.0]     where  [2.x.1]  are vectors in  [2.x.2] ,  [2.x.3]  is often the time (but   can also be a parametric quantity), and    [2.x.4] .   Such problem is solved using Newton iteration augmented with a line search   global strategy. The integration method used in IDA is the variable-order,   variable-coefficient BDF (Backward Differentiation Formula), in   fixed-leading-coefficient. The method order ranges from 1 to 5, with   the BDF of order  [2.x.5]  given by the multistep formula     [1.x.1]     where  [2.x.6]  and  [2.x.7]  are the computed approximations of  [2.x.8]    and  [2.x.9] , respectively, and the step size is    [2.x.10] . The coefficients  [2.x.11]  are uniquely   determined by the order  [2.x.12] , and the history of the step sizes. The   application of the BDF method to the DAE system results in a nonlinear  algebraic system to be solved at each time step:     [1.x.2]   The Newton method leads to a linear system of the form   [1.x.3]    where  [2.x.13]  is the  [2.x.14] -th approximation to  [2.x.15] , and  [2.x.16]  is the  approximation of the system Jacobian     [1.x.4]     and  [2.x.17] . It is worth mentioning that the   scalar  [2.x.18]  changes whenever the step size or method order   changes.     To provide a simple example, consider the following harmonic oscillator  problem: [1.x.5]     We write it in terms of a first order ode:  [1.x.6]     That is  [2.x.19]    where   [1.x.7]   and  [2.x.20] ,  [2.x.21] .     The exact solution is  [2.x.22] ,  [2.x.23] ,  [2.x.24] .     The Jacobian to assemble is the following:   [2.x.25] .     This is achieved by the following snippet of code:  
* [1.x.8]
*   
* [0.x.1]*
     Additional parameters that can be passed to the IDA class.    
* [0.x.2]*
       IDA is a Differential Algebraic solver. As such, it requires initial       conditions also for the first order derivatives. If you do not provide       consistent initial conditions, (i.e., conditions for which F(y_dot(0),       y(0), 0) = 0), you can ask SUNDIALS to compute initial conditions for       you by specifying InitialConditionCorrection for the initial       conditions both at the `initial_time` (`ic_type`) and after a reset       has occurred (`reset_type`).      
* [0.x.3]*
         Do not try to make initial conditions consistent.        
* [0.x.4]*
         Compute the algebraic components of y and differential         components of y_dot, given the differential components of y.            This option requires that the user specifies differential and            algebraic components in the function get_differential_components.        
* [0.x.5]*
         Compute all components of y, given y_dot.        
* [0.x.6]*
       Initialization parameters for IDA.             Global parameters:              [2.x.26]  initial_time Initial time        [2.x.27]  final_time Final time        [2.x.28]  initial_step_size Initial step size        [2.x.29]  output_period Time interval between each output             Running parameters:              [2.x.30]  minimum_step_size Minimum step size        [2.x.31]  maximum_order Maximum BDF order        [2.x.32]  maximum_non_linear_iterations Maximum number of nonlinear       iterations        [2.x.33]  ls_norm_factor Converting factor from the integrator tolerance       to the linear solver tolerance       iterations             Error parameters:              [2.x.34]  absolute_tolerance Absolute error tolerance        [2.x.35]  relative_tolerance Relative error tolerance        [2.x.36]  ignore_algebraic_terms_for_errors Ignore algebraic terms for       error computations             Initial condition correction parameters:              [2.x.37]  ic_type Initial condition correction type        [2.x.38]  reset_type Initial condition correction type after restart        [2.x.39]  maximum_non_linear_iterations_ic Initial condition Newton max       iterations      
* [0.x.7]*
       Add all AdditionalData() parameters to the given ParameterHandler       object. When the parameters are parsed from a file, the internal       parameters are automatically updated.             The following parameters are declared:            
* [1.x.9]
*              These are one-to-one with the options you can pass at construction       time.             The options you pass at construction time are set as default values in       the ParameterHandler object `prm`. You can later modify them by parsing       a parameter file using `prm`. The values of the parameter will be       updated whenever the content of `prm` is updated.             Make sure that this class lives longer than `prm`. Undefined behavior       will occur if you destroy this class, and then parse a parameter file       using `prm`.      
* [0.x.8]*
       Initial time for the DAE.      
* [0.x.9]*
       Final time.      
* [0.x.10]*
       Initial step size.      
* [0.x.11]*
       Minimum step size.      
* [0.x.12]*
       Absolute error tolerance for adaptive time stepping.      
* [0.x.13]*
       Relative error tolerance for adaptive time stepping.      
* [0.x.14]*
       Maximum order of BDF.      
* [0.x.15]*
       Time period between each output.      
* [0.x.16]*
       Ignore algebraic terms for errors.      
* [0.x.17]*
       Type of correction for initial conditions.             If you do not provide consistent initial conditions, (i.e., conditions       for which  [2.x.40] ), you can ask SUNDIALS to compute       initial conditions for you by using the `ic_type` parameter at       construction time.             Notice that you could in principle use this capabilities to solve for       steady state problems by setting y_dot to zero, and asking to compute        [2.x.41]  that satisfies  [2.x.42] , however the nonlinear solver       used inside IDA may not be robust enough for complex problems with       several millions unknowns.      
* [0.x.18]*
       Type of correction for initial conditions to be used after a solver       restart.             If you do not have consistent initial conditions after a restart,       (i.e., conditions for which F(y_dot(t_restart), y(t_restart),       t_restart) = 0), you can ask SUNDIALS to compute the new initial       conditions for you by using the `reset_type` parameter at construction       time.      
* [0.x.19]*
       Maximum number of iterations for Newton method in IC calculation.      
* [0.x.20]*
       Maximum number of iterations for Newton method during time advancement.      
* [0.x.21]*
       Factor to use when converting from the integrator tolerance to the       linear solver tolerance      
* [0.x.22]*
     Constructor. It is possible to fine tune the SUNDIALS IDA solver by     passing an AdditionalData() object that sets all of the solver     parameters.         IDA is a Differential Algebraic solver. As such, it requires initial     conditions also for the first order derivatives. If you do not provide     consistent initial conditions, (i.e., conditions for which F(y_dot(0),     y(0), 0) = 0), you can ask SUNDIALS to compute initial conditions for you     by using the `ic_type` parameter at construction time.         You have three options
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  none: do not try to make initial conditions consistent.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  use_y_diff: compute the algebraic components of y and differential        components of y_dot, given the differential components of y.        This option requires that the user specifies differential and        algebraic components in the function get_differential_components.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  use_y_dot: compute all components of y, given y_dot.         By default, this class assumes that all components are differential, and     that you want to solve a standard ode. In this case, the initial     component type is set to `use_y_diff`, so that the `y_dot` at time     t=`initial_time` is computed by solving the nonlinear problem  [2.x.43]  in the variable `y_dot`.         Notice that a Newton solver is used for this computation. The Newton     solver parameters can be tweaked by acting on `ic_alpha` and     `ic_max_iter`.         If you reset the solver at some point, you may want to select a different     computation for the initial conditions after reset. Say, for example,     that you have refined a grid, and after transferring the solution to the     new grid, the initial conditions are no longer consistent. Then you can     choose how these are made consistent, using the same three options that     you used for the initial conditions in `reset_type`.         The MPI communicator is simply ignored in the serial case.          [2.x.44]  data IDA configuration data      [2.x.45]  mpi_comm MPI communicator    
* [0.x.23]*
     Destructor.    
* [0.x.24]*
     Integrate differential-algebraic equations. This function returns the     final number of computed steps.    
* [0.x.25]*
     Clear internal memory and start with clean objects. This function is     called when the simulation start and when the user returns true to a     call to solver_should_restart().         By default solver_should_restart() returns false. If the user needs to     implement, for example, local adaptivity in space, he or she may assign     a different function to solver_should_restart() that performs all mesh     changes, transfers the solution and the solution dot to the new mesh,     and returns true.         During reset(), both y and yp are checked for consistency, and according     to what was specified as ic_type (if t==initial_time) or reset_type (if     t>initial_time), yp, y, or both are modified to obtain a consistent set     of initial data.          [2.x.46]  t  The new starting time      [2.x.47]  h  The new (tentative) starting time step      [2.x.48]  y   The new (tentative) initial solution      [2.x.49]  yp  The new (tentative) initial solution_dot    
* [0.x.26]*
     Reinit vector to have the right size, MPI communicator, etc.    
* [0.x.27]*
     Compute residual. Return  [2.x.50] .         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (IDAReinit will be called if this happens, and           then last function will be attempted again
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an     assertion will be thrown.    
* [0.x.28]*
     Compute Jacobian. This function is called by IDA any time a Jacobian     update is required. The user should compute the Jacobian (or update all     the variables that allow the application of the Jacobian). This function     is called by IDA once, before any call to solve_jacobian_system() (for     SUNDIALS < 4.0.0) or solve_with_jacobian() (for     SUNDIALS >= 4.0.0).         The Jacobian  [2.x.51]  should be a (possibly inexact) computation of     [1.x.10]         If the user uses a matrix based computation of the Jacobian, than this     is the right place where an assembly routine should be called to     assemble both a matrix and a preconditioner for the Jacobian system.     Subsequent calls (possibly more than one) to solve_jacobian_system() or     solve_with_jacobian() can assume that this function has     been called at least once.         Notice that no assumption is made by this interface on what the user     should do in this function. IDA only assumes that after a call to     setup_jacobian() it is possible to call solve_jacobian_system() or     solve_with_jacobian() to obtain a solution  [2.x.52]  to the     system  [2.x.53] .         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (IDAReinit will be called if this happens, and           then last function will be attempted again
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an     assertion will be thrown.    
* [0.x.29]*
     Solve the Jacobian linear system. This function will be called by IDA     (possibly several times) after setup_jacobian() has been called at least     once. IDA tries to do its best to call setup_jacobian() the minimum     amount of times. If convergence can be achieved without updating the     Jacobian, then IDA does not call setup_jacobian() again. If, on the     contrary, internal IDA convergence tests fail, then IDA calls again     setup_jacobian() with updated vectors and coefficients so that successive     calls to solve_jacobian_systems() lead to better convergence in the     Newton process.         The jacobian  [2.x.54]  should be (an approximation of) the system Jacobian     [1.x.11]         A call to this function should store in `dst` the result of  [2.x.55]      applied to `src`, i.e., `J*dst = src`. It is the users responsibility     to set up proper solvers and preconditioners inside this function.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (IDAReinit will be called if this happens, and           then last function will be attempted again
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an     assertion will be thrown.          [2.x.56]  Starting with SUNDIALS 4.1, SUNDIALS provides the possibility of     specifying the tolerance for the resolution. A part from the tolerance     only `rhs` is provided and `dst` needs to be returned.    
* [0.x.30]*
     Solve the Jacobian linear system up to a specified tolerance. This     function will be called by IDA (possibly several times) after     setup_jacobian() has been called at least once. IDA tries to do its best     to call setup_jacobian() the minimum number of times. If convergence can     be achieved without updating the Jacobian, then IDA does not call     setup_jacobian() again. If, on the contrary, internal IDA convergence     tests fail, then IDA calls again setup_jacobian() with updated vectors     and coefficients so that successive calls to     solve_with_jacobian() lead to better convergence in the     Newton process.         The Jacobian  [2.x.57]  should be (an approximation of) the system Jacobian     [1.x.12]         Arguments to the function are:          [2.x.58]  rhs The system right hand side to solve for.      [2.x.59]  dst The solution of  [2.x.60] .      [2.x.61]  tolerance The tolerance with which to solve the linear system       of equations.         A call to this function should store in `dst` the result of  [2.x.62]      applied to `src`, i.e., the solution of the linear system `J*dst = src`.     It is the user's responsibility to set up proper solvers and     preconditioners either inside this function, or already within the     `setup_jacobian()` function. (The latter is, for example, what the      [2.x.63]  program does: All expensive operations happen in     `setup_jacobian()`, given that that function is called far less often     than the current one.)         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (IDAReinit will be called if this happens, and           then the last function will be attempted again).
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an     assertion will be thrown.    
* [0.x.31]*
     Process solution. This function is called by IDA at fixed time steps,     every `output_period` seconds, and it is passed a polynomial     interpolation of the solution and of its time derivative, computed using     the current BDF order and the (internally stored) previously computed     solution steps.         Notice that it is well possible that internally IDA computes a time step     which is much larger than the `output_period` step, and therefore calls     this function consecutively several times by simply performing all     intermediate interpolations. There is no relationship between how many     times this function is called and how many time steps have actually been     computed.    
* [0.x.32]*
     Evaluate whether the solver should be restarted (for example because the     number of degrees of freedom has changed).         This function is supposed to perform all operations that are necessary in     `sol` and `sol_dot` to make sure that the resulting vectors are     consistent, and of the correct final size.         For example, one may decide that a local refinement is necessary at time     t. This function should then return true, and change the dimension of     both sol and sol_dot to reflect the new dimension. Since IDA does not     know about the new dimension, an internal reset is necessary.         The default implementation simply returns `false`, i.e., no restart is     performed during the evolution.    
* [0.x.33]*
     Return an index set containing the differential components.     Implementation of this function is optional. The default is to return a     complete index set. If your equation is also algebraic (i.e., it     contains algebraic constraints, or Lagrange multipliers), you should     overwrite this function in order to return only the differential     components of your system.         When running in parallel, every process will call this function     independently, and synchronization will happen at the end of the     initialization setup to communicate what components are local. Make sure     you only return the locally owned (or locally relevant) components, in     order to minimize communication between processes.    
* [0.x.34]*
     Return a vector whose components are the weights used by IDA to compute     the vector norm. The implementation of this function is optional. If the     user does not provide an implementation, the weights are assumed to be     all ones.    
* [0.x.35]*
     Handle IDA exceptions.    
* [0.x.36]*
     Throw an exception when a function with the given name is not     implemented.    
* [0.x.37]*
     This function is executed at construction time to set the      [2.x.64]  above to trigger an assert if they are not     implemented.    
* [0.x.38]*
     IDA configuration data.    
* [0.x.39]*
     IDA memory object.    
* [0.x.40]*
     MPI communicator. SUNDIALS solver runs happily in     parallel. Note that if the library is compiled without MPI     support, MPI_Comm is aliased as int.    
* [0.x.41]*
     Memory pool of vectors.    
* [0.x.42]

include/deal.II-translator/sundials/kinsol_0.txt
[0.x.0]*
   Interface to SUNDIALS' nonlinear solver (KINSOL).     KINSOL is a solver for nonlinear algebraic systems in residual form  [2.x.0]  or fixed point form  [2.x.1] , where  [2.x.2]  is a vector which we will   assume to be in  [2.x.3]  or  [2.x.4] , but that may also have   a block structure and may be distributed in parallel computations; the   functions  [2.x.5]  and  [2.x.6]  satisfy  [2.x.7]  or    [2.x.8] . It includes a Newton-Krylov solver   as well as Picard and fixed point solvers, both of which can be   accelerated with Anderson acceleration. KINSOL is based on the previous   Fortran package NKSOL of Brown and Saad. An example of using KINSOL   can be found in the  [2.x.9]  tutorial program.     KINSOL's Newton solver employs the inexact Newton method. As this solver   is intended mainly for large systems, the user is required to provide   their own solver function.     At the highest level, KINSOL implements the following iteration   scheme:
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - set  [2.x.10]  = an initial guess
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - For  [2.x.11]  until convergence do:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Solve  [2.x.12] 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Set  [2.x.13] 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Test for convergence     Here,  [2.x.14]  is the  [2.x.15] -th iterate to  [2.x.16] , and  [2.x.17]  is   the system Jacobian. At each stage in the iteration process, a scalar   multiple of the step  [2.x.18] , is added to  [2.x.19]  to produce a new   iterate,  [2.x.20] . A test for convergence is made before the iteration   continues.     Unless specified otherwise by the user, KINSOL strives to update Jacobian   information as infrequently as possible to balance the high costs of   matrix operations against other costs. Specifically, these updates occur   when:
* 

* 
* 

* 
* 

* 
* 
*  - the problem is initialized,
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.21]  (inexact Newton only,     see below for a definition of  [2.x.22] )
* 

* 
* 

* 
* 

* 
* 
*  - a specified number of  nonlinear iterations have passed since the last     update,
* 

* 
* 

* 
* 

* 
* 
*  - the linear solver failed recoverably with outdated Jacobian information,
* 

* 
* 

* 
* 

* 
* 
*  - the global strategy failed with outdated Jacobian information, or
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.23] tolerance* with outdated     Jacobian information.     KINSOL allows changes to the above strategy through optional solver   inputs. The user can disable the initial Jacobian information evaluation   or change the default value of the number of nonlinear iterations after   which a Jacobian information update is enforced.     To address the case of ill-conditioned nonlinear systems, KINSOL allows   prescribing scaling factors both for the solution vector and for the   residual vector. For scaling to be used, the user may supply the function   get_solution_scaling(), that returns values  [2.x.24] , which are diagonal   elements of the scaling matrix such that  [2.x.25]  has all components   roughly the same magnitude when  [2.x.26]  is close to a solution, and   get_function_scaling(), that supply values  [2.x.27] , which are diagonal   scaling matrix elements such that  [2.x.28]  has all components roughly the   same magnitude when  [2.x.29]  isnot* too close to a solution.     When scaling values are provided for the solution vector, these values are   automatically incorporated into the calculation of the perturbations used   for the default difference quotient approximations for Jacobian   information if the user does not supply a Jacobian solver through the   solve_jacobian_system() function.     Two methods of applying a computed step  [2.x.30]  to the previously   computed solution vector are implemented. The first and simplest is the   standard Newton strategy which applies the update with a constant    [2.x.31]  always set to 1. The other method is a global strategy, which   attempts to use the direction implied by  [2.x.32]  in the most efficient   way for furthering convergence of the nonlinear problem. This technique is   implemented in the second strategy, called Linesearch. This option employs   both the  [2.x.33]  and  [2.x.34]  conditions of the Goldstein-Armijo   linesearch algorithm given inJ. E. Dennis and R. B. Schnabel. "Numerical   Methods for Unconstrained Optimization and Nonlinear Equations." SIAM,   Philadelphia, 1996.*, where  [2.x.35]  is chosen to guarantee a sufficient   decrease in  [2.x.36]  relative to the step length as well as a minimum step   length relative to the initial rate of decrease of  [2.x.37] . One property of the   algorithm is that the full Newton step tends to be taken close to the   solution.     The basic fixed-point iteration scheme implemented in KINSOL is given by:
* 

* 
* 

* 
* 

* 
* 
*  - Set  [2.x.38]  an initial guess
* 

* 
* 

* 
* 

* 
* 
*  - For  [2.x.39]  until convergence do:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Set  [2.x.40] 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Test for convergence     At each stage in the iteration process, function  [2.x.41]  is applied to the   current iterate to produce a new iterate,  [2.x.42] . A test for   convergence is made before the iteration continues.     For Picard iteration, as implemented in KINSOL, we consider a special form   of the nonlinear function  [2.x.43] , such that  [2.x.44] , where  [2.x.45]  is   a constant nonsingular matrix and  [2.x.46]  is (in general) nonlinear.     Then the fixed-point function  [2.x.47]  is defined as  [2.x.48] .   Within each iteration, the Picard step is computed then added to  [2.x.49]  to   produce the new iterate. Next, the nonlinear residual function is   evaluated at the new iterate, and convergence is checked. The Picard and   fixed point methods can be significantly accelerated using Anderson's   method.     The user has to provide the implementation of the following  [2.x.50] 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - reinit_vector;   and only one of
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - residual;   or
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - iteration_function;     Specifying residual() allows the user to use Newton and Picard strategies   (i.e.,  [2.x.51]  will be solved), while specifying iteration_function(), a   fixed point iteration will be used (i.e.,  [2.x.52]  will be solved).     If the use of a Newton or Picard method is desired, then the user should   also supply
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - solve_jacobian_system or solve_with_jacobian;   and optionally
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - setup_jacobian;     Fixed point iteration does not require the solution of any linear system.     Also the following functions could be rewritten, to provide additional   scaling factors for both the solution and the residual evaluation during   convergence checks:
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - get_solution_scaling;
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - get_function_scaling;  
* [0.x.1]*
     Additional parameters that can be passed to the KINSOL class.    
* [0.x.2]*
       KINSOL solution strategy. KINSOL includes a Newton-Krylov solver (both       local and global) as well as Picard and fixed point solvers.      
* [0.x.3]*
         Standard Newton iteration.        
* [0.x.4]*
         Newton iteration with linesearch.        
* [0.x.5]*
         Fixed point iteration.        
* [0.x.6]*
         Picard iteration.        
* [0.x.7]*
       Initialization parameters for KINSOL.             Global parameters:              [2.x.53]  strategy Solution strategy        [2.x.54]  maximum_non_linear_iterations Maximum number of nonlinear       iterations        [2.x.55]  function_tolerance %Function norm stopping tolerance        [2.x.56]  step_tolerance Scaled step stopping tolerance             Newton parameters:              [2.x.57]  no_init_setup No initial matrix setup        [2.x.58]  maximum_setup_calls Maximum iterations without matrix setup        [2.x.59]  maximum_newton_step Maximum allowable scaled length of the       Newton step        [2.x.60]  dq_relative_error Relative error for different quotient       computation             Line search parameters:              [2.x.61]  maximum_beta_failures Maximum number of beta-condition failures             Fixed point and Picard parameters:              [2.x.62]  anderson_subspace_size Anderson acceleration subspace size      
* [0.x.8]*
       Add all AdditionalData() parameters to the given ParameterHandler       object. When the parameters are parsed from a file, the internal       parameters are automatically updated.             The following parameters are declared:            
* [1.x.0]
*              These are one-to-one with the options you can pass at construction       time.             The options you pass at construction time are set as default values in       the ParameterHandler object `prm`. You can later modify them by parsing       a parameter file using `prm`. The values of the parameter will be       updated whenever the content of `prm` is updated.             Make sure that this class lives longer than `prm`. Undefined behavior       will occur if you destroy this class, and then parse a parameter file       using `prm`.      
* [0.x.9]*
       The solution strategy to use. If you choose  [2.x.63]        or  [2.x.64]  you have to provide also the function       residual(). If you choose  [2.x.65]  or        [2.x.66]  you have to provide also the function       iteration_function().      
* [0.x.10]*
       Maximum number of nonlinear iterations allowed.      
* [0.x.11]*
       A scalar used as a stopping tolerance on the scaled       maximum norm of the system function  [2.x.67]  or  [2.x.68] .             If set to zero, default values provided by KINSOL will be used.      
* [0.x.12]*
       A scalar used as a stopping tolerance on the minimum       scaled step length.             If set to zero, default values provided by KINSOL will be used.      
* [0.x.13]*
       Whether an initial call to the preconditioner or Jacobian       setup function should be made or not.             A call to this function is useful when solving a sequence of problems,       in which the final preconditioner or Jacobian value from one problem       is to be used initially for the next problem.      
* [0.x.14]*
       The maximum number of nonlinear iterations that can be       performed between calls to the setup_jacobian() function.             If set to zero, default values provided by KINSOL will be used,       and in practice this often means that KINSOL will re-use a       Jacobian matrix computed in one iteration for later iterations.      
* [0.x.15]*
       The maximum allowable scaled length of the Newton step.             If set to zero, default values provided by KINSOL will be used.      
* [0.x.16]*
       The relative error in computing  [2.x.69] , which is used in the       difference quotient approximation to the Jacobian matrix when the user       does not supply a solve_jacobian_system_matrix() function.             If set to zero, default values provided by KINSOL will be used.      
* [0.x.17]*
       The maximum number of beta-condition failures in the       linesearch algorithm. Only used if        [2.x.70]       
* [0.x.18]*
       The size of the subspace used with Anderson acceleration       in conjunction with Picard or fixed-point iteration.             If you set this to 0, no acceleration is used.      
* [0.x.19]*
     Constructor. It is possible to fine tune the SUNDIALS KINSOL solver by     passing an AdditionalData() object that sets all of the solver     parameters.          [2.x.71]  data KINSOL configuration data      [2.x.72]  mpi_comm MPI communicator    
* [0.x.20]*
     Destructor.    
* [0.x.21]*
     Solve the non linear system. Return the number of nonlinear steps taken     to converge. KINSOL uses the content of `initial_guess_and_solution` as     initial guess, and stores the final solution in the same vector.    
* [0.x.22]*
     A function object that users need to supply and that is intended to     reinitize the given vector to its correct size, block structure (if     block vectors are used), and MPI communicator (if the vector is     distributed across multiple processors using MPI), along with any     other properties necessary.    
* [0.x.23]*
     A function object that users should supply and that is intended to     compute the residual `dst = F(src)`. This function is only used if the      [2.x.73]  or  [2.x.74]  strategies     were selected.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (KINSOL will try to change its internal     parameters and attempt a new solution step)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an     assertion will be thrown.    
* [0.x.24]*
     A function object that users should supply and that is intended to     compute the iteration function  [2.x.75]  for the fixed point and Picard     iteration. This function is only used if the      [2.x.76]  or  [2.x.77]  strategies     were selected.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (KINSOL will try to change its internal     parameters and attempt a new solution step)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error; the computation will be aborted and an     assertion will be thrown.    
* [0.x.25]*
     A function object that users may supply and that is intended to     prepare the linear solver for subsequent calls to     solve_jacobian_system().         The job of setup_jacobian() is to prepare the linear solver for     subsequent calls to solve_jacobian_system(), in the solution of linear     systems  [2.x.78] . The exact nature of this system depends on the     SolutionStrategy that has been selected.         In the cases strategy =  [2.x.79]  or      [2.x.80]   [2.x.81]  is the Jacobian  [2.x.82] . If strategy =  [2.x.83]   [2.x.84]  is the     approximate Jacobian matrix  [2.x.85] . If strategy =      [2.x.86]  then linear systems do not arise, and this     function is never called.         The setup_jacobian() function may call a user-supplied function, or a     function within the linear solver module, to compute Jacobian-related     data that is required by the linear solver. It may also preprocess that     data as needed for solve_jacobian_system(), which may involve calling a     generic function (such as for LU factorization) or, more generally,     build preconditioners from the assembled Jacobian. In any case, the     data so generated may then be used whenever a linear system is solved.         The point of this function is that     setup_jacobian() function is not called at every Newton iteration,     but only as frequently as the solver determines that it is appropriate     to perform the setup task. In this way, Jacobian-related data generated     by setup_jacobian() is expected to be used over a number of Newton     iterations. KINSOL determines itself when it is beneficial to regenerate     the Jacobian and associated information (such as preconditioners     computed for the Jacobian), thereby saving the effort to regenerate     the Jacobian matrix and a preconditioner for it whenever possible.          [2.x.87]  current_u Current value of  [2.x.88]       [2.x.89]  current_f Current value of  [2.x.90]  or  [2.x.91]          This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (KINSOL will try to change its internal     parameters and attempt a new solution step)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an     assertion will be thrown.    
* [0.x.26]*
      [2.x.92]  Versions of SUNDIALS after 4.0 no longer provide all       of the information necessary for this callback (see below). Use the       `solve_with_jacobian` callback described below.         A function object that users may supply and that is intended to solve     a linear system with the Jacobian matrix. This function will be called by     KINSOL (possibly several times) after setup_jacobian() has been called at     least once. KINSOL tries to do its best to call setup_jacobian() the     minimum number of times. If convergence can be achieved without updating     the Jacobian, then KINSOL does not call setup_jacobian() again. If, on     the contrary, internal KINSOL convergence tests fail, then KINSOL calls     setup_jacobian() again with updated vectors and coefficients so that     successive calls to solve_jacobian_systems() lead to better convergence     in the Newton process.         If you do not specify a `solve_jacobian_system` or `solve_with_jacobian`     function, then only a fixed point iteration strategy can be used. Notice     that this may not converge, or may converge very slowly.         A call to this function should store in `dst` the result of  [2.x.93]      applied to `rhs`, i.e., `J*dst = rhs`. It is the user's responsibility     to set up proper solvers and preconditioners inside this function     (or in the `setup_jacobian` callback above).             Arguments to the function are:          [2.x.94]  ycur The current  [2.x.95]  vector for the current KINSOL     internal step. In the documentation above, this  [2.x.96]  vector is generally     denoted by  [2.x.97] .      [2.x.98]  fcur The current value of the implicit right-hand side at     `ycur`,  [2.x.99] .      [2.x.100]  rhs The system right hand side to solve for      [2.x.101]  dst The solution of  [2.x.102]          This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (KINSOL will try to change its internal     parameters and attempt a new solution step)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an     assertion will be thrown.          [2.x.103]  Starting with SUNDIALS 4.1, SUNDIALS no longer provides the       `ycur` and `fcur` variables
* 
*  -  only `rhs` is provided and `dst`       needs to be returned. The first two arguments will therefore be       empty vectors in that case. In practice, that means that one       can no longer compute a Jacobian matrix for the current iterate       within this function. Rather, this has to happen inside the       `setup_jacobian` function above that receives this information.       If it is important that the Jacobian corresponds to thecurrent*
       iterate (rather than a re-used Jacobian matrix that had been       computed in a previous iteration and that therefore corresponds       to aprevious* iterate), then you will also have to set the        [2.x.104]  variable to one, indicating       that the Jacobian should be re-computed in every iteration.    
* [0.x.27]*
     A function object that users may supply and that is intended to solve     a linear system with the Jacobian matrix. This function will be called by     KINSOL (possibly several times) after setup_jacobian() has been called at     least once. KINSOL tries to do its best to call setup_jacobian() the     minimum number of times. If convergence can be achieved without updating     the Jacobian, then KINSOL does not call setup_jacobian() again. If, on     the contrary, internal KINSOL convergence tests fail, then KINSOL calls     setup_jacobian() again with updated vectors and coefficients so that     successive calls to solve_jacobian_systems() lead to better convergence     in the Newton process.         If you do not specify a `solve_with_jacobian` function, then only a     fixed point iteration strategy can be used. Notice that this may not     converge, or may converge very slowly.         A call to this function should store in `dst` the result of  [2.x.105]      applied to `rhs`, i.e., `J*dst = rhs`. It is the user's responsibility     to set up proper solvers and preconditioners inside this function     (or in the `setup_jacobian` callback above). The function attached     to this callback is also provided with a tolerance to the linear solver,     indicating that it is not necessary to solve the linear system with     the Jacobian matrix exactly, but only to a tolerance that KINSOL will     adapt over time.         Arguments to the function are:          [2.x.106]  rhs The system right hand side to solve for.      [2.x.107]  dst The solution of  [2.x.108] .      [2.x.109]  tolerance The tolerance with which to solve the linear system       of equations.         This function should return:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error (KINSOL will try to change its internal     parameters and attempt a new solution step)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error the computation will be aborted and an     assertion will be thrown.    
* [0.x.28]*
     A function object that users may supply and that is intended to return a     vector whose components are the weights used by KINSOL to compute the     vector norm of the solution. The implementation of this function is     optional, and it is used only if implemented.         The intent for this scaling factor is for problems in which the different     components of a solution have vastly different numerical magnitudes
* 
*  -      typically because they have different physical units and represent     different things. For example, if one were to solve a nonlinear Stokes     problem, the solution vector has components that correspond to velocities     and other components that correspond to pressures. These have different     physical units and depending on which units one chooses, they may have     roughly comparable numerical sizes or maybe they don't. To give just one     example, in simulations of flow in the Earth's interior, one has     velocities on the order of maybe ten centimeters per year, and pressures     up to around 100 GPa. If one expresses this in SI units, this corresponds     to velocities of around  [2.x.110]  m/s, and     pressures around  [2.x.111] , i.e., vastly     different. In such cases, computing the  [2.x.112]  norm of a solution-type     vector (e.g., the difference between the previous and the current     solution) makes no sense because the norm will either be dominated by the     velocity components or the pressure components. The scaling vector this     function returns is intended to provide each component of the solution     with a scaling factor that is generally chosen as as the inverse of a     "typical velocity" or "typical pressure" so that upon multiplication of a     vector component by the corresponding scaling vector component, one     obtains a number that is of order of magnitude of one (i.e., a reasonably     small multiple of one times the typical velocity/pressure). The KINSOL     manual states this as follows: "The user should supply values  [2.x.113] ,     which are diagonal elements of the scaling matrix such that  [2.x.114]  has     all components roughly the same magnitude when  [2.x.115]  is close to a     solution".         If no function is provided to a KINSOL object, then this is interpreted     as implicitly saying that all of these scaling factors should be     considered as one.    
* [0.x.29]*
     A function object that users may supply and that is intended to return a     vector whose components are the weights used by KINSOL to compute the     vector norm of the function evaluation away from the solution. The     implementation of this function is optional, and it is used only if     implemented.         The point of this function and the scaling vector it returns is similar     to the one discussed above for `get_solution_scaling`, except that it is     for a vector that scales the components of the function  [2.x.116] , rather     than the components of  [2.x.117] , when computing norms. As above, if no     function is provided, then this is equivalent to using a scaling vector     whose components are all equal to one.    
* [0.x.30]*
     Handle KINSOL exceptions.    
* [0.x.31]*
     Throw an exception when a function with the given name is not     implemented.    
* [0.x.32]*
     This function is executed at construction time to set the      [2.x.118]  above to trigger an assert if they are not     implemented.    
* [0.x.33]*
     KINSOL configuration data.    
* [0.x.34]*
     KINSOL memory object.    
* [0.x.35]*
     Memory pool of vectors.    
* [0.x.36]

include/deal.II-translator/sundials/n_vector_0.txt
[0.x.0]*
     Create a NVectorView of the given  [2.x.0]          This call is intended to be used as        
* [1.x.0]
*          The resulting object `view` must be kept around as long as any other     object will use the internally viewed N_Vector.          [2.x.1]  VectorType Type of the viewed vector. This parameter can be       deduced automatically and will respect a potential const-qualifier.      [2.x.2]  vector The vector to view.      [2.x.3]  A NVectorView of the  [2.x.4]           [2.x.5]  NVectorView    
* [0.x.1]*
     Retrieve the underlying vector attached to N_Vector  [2.x.6]  This call will     only succeed if the underlying vector is not const. Use     unwrap_nvector_const() for this case.        
*  [2.x.7]  Users must ensure that they ask for the correct VectorType when       calling this function and there are no type-safety checks in place.          [2.x.8]  VectorType Type of the vector that is stored in  [2.x.9]       [2.x.10]  v Vector to unwrap      [2.x.11]  The vector that is stored inside  [2.x.12]     
* [0.x.2]*
     Retrieve the underlying vector attached to N_Vector  [2.x.13]  as a constant     pointer.        
*  [2.x.14]  Users must ensure that they ask for the correct VectorType when       calling this function and there are no type-safety checks in place.          [2.x.15]  VectorType Type of the vector that is stored in  [2.x.16]       [2.x.17]  v Vector to unwrap      [2.x.18]  The vector that is stored inside  [2.x.19]     
* [0.x.3]*
     A view to a vector which can be used whenever a N_Vector is required.         Objects of this class should preferably be created by     make_nvector_view() as        
* [1.x.1]
*          The resulting N_Vector is a view of the actual vector and not owning     memory. Also, N_VDestroy() cannot be called on the resulting N_Vector     since this would lead to a double delete in the destructor.        
*  [2.x.20]  SUNDIALS will never call N_VDestroy() on a vector it didn't create       itself and thus the above constraint is not limiting the user.          [2.x.21]  VectorType Type of the vector that is stored in  [2.x.22]     
* [0.x.4]*
       Default constructor.             The object is not actually viewing anything and needs to be assigned to       with operator=(NVectorView &&).      
* [0.x.5]*
       Constructor. Create view of  [2.x.23]       
* [0.x.6]*
       Move assignment.      
* [0.x.7]*
       Move constructor.      
* [0.x.8]*
       Explicitly delete copy ctor. This class is move-only.      
* [0.x.9]*
       Explicitly delete copy assignment. This class is move-only.      
* [0.x.10]*
       Destructor.            
*  [2.x.24]  This will not destroy the viewed vector.      
* [0.x.11]*
       Implicit conversion to N_Vector. This operator makes the NVectorView       look like an actual N_Vector and it can be used directly as an       argument in many SUNDIALS functions.      
* [0.x.12]*
       Access the N_Vector that is viewed by this object.      
* [0.x.13]*
       Actual pointer to a vector viewed by this class.      
* [0.x.14]

include/deal.II-translator/sundials/n_vector.templates_0.txt
[0.x.0]*
     An internal class that stores a pointer to a vector and manages the     memory if necessary. Objects of this class are used as the `content`     field in the SUNDIALS N_Vector module. In addition, this class has a     flag to store whether the stored vector should be treated as const. When     get() is called on a non-const object of this class the flag is checked     and an exception is thrown if the vector is actually const. Thus, we     retain a kind of "runtime const correctness" although the static const     correctness is lost because SUNDIALS N_Vector does not support constness.    
* [0.x.1]*
       Create a non-owning content with an existing  [2.x.0]         [2.x.1]  vector The underlying vector to wrap in this object.      
* [0.x.2]*
       Create a non-owning content with an existing const  [2.x.2]  If this       constructor is used, access is only allowed via the get() const method.        [2.x.3]  vector The underlying vector to wrap in this object.      
* [0.x.3]*
       Allocate a new (non-const) vector wrapped in a new content object. The       vector will be deallocated automatically when this object is destroyed.            
*  [2.x.4]  This constructor is intended for the N_VClone() call of SUNDIALS.      
* [0.x.4]*
       Non-const access to the stored vector. Only allowed if a constructor       different than NVectorContent(const VectorTypevector) was used.        [2.x.5]       
* [0.x.5]*
       Const access to the stored vector. Always allowed.      
* [0.x.6]*
       Vector memory which might be used to allocate storage if       NVectorContent() is called.      
* [0.x.7]*
       Actually stored vector content.      
* [0.x.8]*
       Flag storing whether the stored pointer is to be treated as const. If       the pointer passed in the constructor was indeed const, it is cast away       but this flag will be set to true. Access to the pointer must then       check that this flag is set correctly.      
* [0.x.9]*
     Helper to create a vector with all operations and the given  [2.x.6]           [2.x.7]  content The vector content to attach to the N_Vector.      [2.x.8]  A new N_Vector    
* [0.x.10]*
     Helper to create an empty vector with all operations but no content.      [2.x.9]  A new N_Vector    
* [0.x.11]*
     Collection of all operations specified by SUNDIALS N_Vector     documentation. These functions are attached to the generic N_Vector     structure.    
* [0.x.12]*
       Sundials likes a void* but we want to use the above functions       internally with a safe type.      
* [0.x.13]

include/deal.II-translator/sundials/sundials_backport_0.txt
[0.x.0] The functions in this file are based on an implementation distributed within the SUNDIALS package, see the license here: https://computing.llnl.gov/projects/sundials/license.
* 

* 
* 
*  - --------------------------------------------------------------- Programmer(s): Daniel Reynolds @ SMU                David J. Gardner, Carol S. Woodward, and                Slaven Peles @ LLNL
* 

* 
* 
*  - ---------------------------------------------------------------[0.x.1]

include/deal.II-translator/sundials/sunlinsol_newempty_0.txt
[0.x.0] The functions in this file are based on an implementation distributed within the SUNDIALS package, see the license here: https://computing.llnl.gov/projects/sundials/license.
* 

* 
* 
*  - --------------------------------------------------------------- Programmer(s): Daniel Reynolds @ SMU                David J. Gardner, Carol S. Woodward, and                Slaven Peles @ LLNL
* 

* 
* 
*  - ---------------------------------------------------------------[0.x.1]*
     Create a new SUNLinearSolver structure without any content and     operations set to `nullptr`.    
* [0.x.2]*
     Free the memory associated with  [2.x.0]  which was previously allocated     with a call to SUNLinSolNewEmpty().        
*  [2.x.1]  A call to this function does not deallocate the `content` field.          [2.x.2]  solver The solver memory to free    
* [0.x.3]

include/deal.II-translator/sundials/sunlinsol_wrapper_0.txt
[0.x.0]*
   A linear operator that wraps SUNDIALS functionality.  
* [0.x.1]*
     Apply this LinearOperator to  [2.x.0]  and store the result in  [2.x.1]     
* [0.x.2]*
     Constructor.          [2.x.2]  A_data Data required by  [2.x.3]       [2.x.4]  a_times_fn A function pointer to the function that computes A*v    
* [0.x.3]*
     Data necessary to evaluate a_times_fn.    
* [0.x.4]*
     %Function pointer declared by SUNDIALS to evaluate the matrix vector     product.    
* [0.x.5]*
   A linear operator that wraps preconditioner functionality as specified by   SUNDIALS. The vmult() function solves the preconditioner equation  [2.x.5] ,   i.e., it computes  [2.x.6] .  
* [0.x.6]*
     Apply the wrapped preconditioner, i.e., solve  [2.x.7]  where  [2.x.8]  is the      [2.x.9]  vector and  [2.x.10]  the  [2.x.11]  vector.          [2.x.12]  dst Result vector of the preconditioner application      [2.x.13]  src Target vector of the preconditioner application    
* [0.x.7]*
     Constructor.          [2.x.14]  P_data Data required by  [2.x.15]       [2.x.16]  p_solve_fn A function pointer to the function that computes A*v      [2.x.17]  tol Tolerance, that an iterative solver should use to judge       convergence    
* [0.x.8]*
     Data necessary to calls p_solve_fn    
* [0.x.9]*
     %Function pointer to a function that computes the preconditioner     application.    
* [0.x.10]*
     Potential tolerance to use in the internal solve of the preconditioner     equation.    
* [0.x.11]*
   Type of function objects to interface with SUNDIALS linear solvers     This function type encapsulates the action of solving  [2.x.18] .   The LinearOperator  [2.x.19]  encapsulates the matrix vector product  [2.x.20]  and   the LinearOperator  [2.x.21]  encapsulates the application of the   preconditioner  [2.x.22] .   The user can specify function objects of this type to attach custom linear   solver routines to SUNDIALS. The two LinearOperators  [2.x.23]  and  [2.x.24]  are   built internally by SUNDIALS based on user settings. The parameters are   interpreted as follows:      [2.x.25]  op A LinearOperator that applies the matrix vector product    [2.x.26]  prec A LinearOperator that applies the preconditioner    [2.x.27]  x The output solution vector    [2.x.28]  b The right-hand side    [2.x.29]  tol Tolerance for the iterative solver     This function should return:
* 

* 
* 

* 
* 

* 
* 
*  - 0: Success
* 

* 
* 

* 
* 

* 
* 
*  - >0: Recoverable error, ARKode will reattempt the solution and call this         function again.
* 

* 
* 

* 
* 

* 
* 
*  - <0: Unrecoverable error, the computation will be aborted and an         assertion will be thrown.  
* [0.x.12]!     Attach wrapper functions to SUNDIALS' linear solver interface. We pretend     that the user-supplied linear solver is matrix-free, even though it can     be matrix-based. This way SUNDIALS does not need to understand our matrix     types.    
* [0.x.13]*
       Implicit conversion to SUNLinearSolver.      
* [0.x.14]

