include/deal.II-translator/grid/cell_id_0.txt
[0.x.0]*
 A class to represent a unique ID for a cell in a Triangulation. It is returned by `cell->id()` (i.e.,  [2.x.0]  where `cell` is assumed to be a cell iterator.
*  This class stores the index of the coarse cell from which a cell is descendant (or, more specifically, the entry on  [2.x.1]  "coarse cell IDs"), together with information on how to reach the cell from that coarse cell (i.e., which child index to take on each level of the triangulation when moving from one cell to its children). The important point about this class is that an object of the current class uniquely identifies a cell in triangulation, and it even does so in the context of objects of type  [2.x.2]  where the local portion of a mesh may not store all cells. For example, the CellId computed for a ghost cell on one processor will be exactly the same as the CellId computed for the very same cell on the processor that actually owns the cell, although the level and index of the iterators pointing to that cell [1.x.0] may (and in general will) be different. In other words, CellId provides the tool with which it is possible to globally and uniquely identify cells in a parallel triangulation, and consequently makes it possible to exchange, between processors, data tied to individual cells.
* 

* 
*  [2.x.3]  How this data is internally represented is not of importance (and not exposed on purpose).

* 
* [0.x.1]*
   A type that is used to encode the CellId data in a compact and fast way   (e.g. for MPI transfer to other processes). Note that it limits the   number of children that can be transferred to 20 in 3D and 30 in 2D   (using 2 times 32 bit for storage), a limitation that is identical to   the one used by p4est.  
* [0.x.2]*
   Construct a CellId object with a given  [2.x.4]  and vector of   child indices.  [2.x.5]  is   interpreted identical to the member variable with the same name, namely   each entry denotes which child to pick from one refinement level to the   next, starting with the coarse cell, until we get to the cell represented   by the current object. Therefore, each entry should be a number between 0   and the number of children of a cell in the current space dimension (i.e.,    [2.x.6]   
* [0.x.3]*
   Construct a CellId object with a given  [2.x.7]  and array of   child indices provided in  [2.x.8]   [2.x.9]  is   interpreted identical to the member variable with the same name, namely   each entry denotes which child to pick from one refinement level to the   next, starting with the coarse cell, until we get to the cell represented   by the current object. Therefore, each entry should be a number between 0   and the number of children of a cell in the current space dimension (i.e.,    [2.x.10]  The array    [2.x.11]  must have at least  [2.x.12]  valid entries.  
* [0.x.4]*
   Construct a CellId object with a given binary representation that was   previously constructed by  [2.x.13]   
* [0.x.5]*
   Create a CellId from a string with the same format that is produced by   to_string().  
* [0.x.6]*
   Construct an invalid CellId.  
* [0.x.7]*
   Return a human-readable string representation of this CellId.     The string returned by this function consists of only ASCII characters   and will look, for example, like this: `"0_3:006"`. Itcan* be   interpreted by humans as saying "This cell originates from the zeroth   coarse mesh cell, lives on refinement level 3, and the path from the   coarse mesh cell to its children and grand children is given by 006".   But it is notmeant* to be interpreted in any meaningful way: It's just   a way of representing the internal state of the current object using   only ASCII characters in the printable range.  
* [0.x.8]*
   Return a compact and fast binary representation of this CellId.  
* [0.x.9]*
   Return a cell_iterator to the cell represented by this CellId.      [2.x.14]  Use  [2.x.15]  instead.  
* [0.x.10]*
   Compare two CellId objects for equality.  
* [0.x.11]*
   Compare two CellIds for inequality.  
* [0.x.12]*
   Compare two CellIds with regard to an ordering. The details of this   ordering are unspecified except that the operation provides a   total ordering among all cells.  
* [0.x.13]*
   Determine if this cell id is the direct parent of the input cell id.  
* [0.x.14]*
   Determine if this cell id is the ancestor of the input cell id.  
* [0.x.15]*
   Read or write the data of this object to or from a stream for the   purpose of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.16]*
   Return the id of the coarse cell.  
* [0.x.17]*
   Return a read-only container of integers that denotes which child to pick   from one refinement level to the next, starting with the coarse cell, until   we get to the cell represented by the current object.     The number of elements in this container corresponds to (level-1) of the   current cell.  
* [0.x.18]*
   The number of the coarse cell within whose tree the cell   represented by the current object is located.  
* [0.x.19]*
   The number of child indices stored in the child_indices array. This is   equivalent to (level-1) of the current cell.  
* [0.x.20]*
   An array of integers that denotes which child to pick from one   refinement level to the next, starting with the coarse cell,   until we get to the cell represented by the current object.   Only the first n_child_indices entries are used, but we use a statically   allocated array instead of a vector of size n_child_indices to speed up   creation of this object. If the given dimensions ever become a limitation   the array can be extended.  
* [0.x.21]*
 Write a CellId object into a stream.

* 
* [0.x.22]*
 Serialization function

* 
* [0.x.23]*
 Read a CellId object from a stream.

* 
* [0.x.24]

include/deal.II-translator/grid/composition_manifold_0.txt
[0.x.0]*
 CompositionManifold.  Take two ChartManifold objects, and make their composition. The CompositionManifold object is a ChartManifold going from the chart of the first ChartManifold to the embedding space of the second ChartManifold. If the first ChartManifold is periodic, so is the resulting ChartManifold, with the same periodicity. Periodicity on the second ChartManifold is not allowed, and the constructor will throw an exception if the second Manifold is periodic.
*  This class only works for dim <= chartdim <= intermediate_spacedim <= spacedim. If you try to instantiate anything different, an Exception will be thrown in one of the ChartManifold classes that violates this condition.
*  Given the ChartManifold F and the ChartManifold G, this class represents the composition of G after F.
*  The template parameters have the following meaning:
*   [2.x.0]  dim The dimension of the resulting ChartManifold  [2.x.1]  spacedim The space dimension of the resulting ChartManifold  [2.x.2]  chartdim The chart dimension of the resulting ChartManifold  [2.x.3]  intermediate_dim The space dimension of the first ChartManifold  [2.x.4]  dim1 The dimension of the first ChartManifold, which coincides also with the chart dimension of the second ChartManifold  [2.x.5]  dim2 The dimension of the second ChartManifold
* 

* 
*  [2.x.6] 

* 
* [0.x.1]*
   Construct the composition of the two given manifolds.  
* [0.x.2]*
   Make a clone of this Manifold.  
* [0.x.3]*
   Pull back the given point in spacedim to the Euclidean chartdim   dimensional space. This function calls the pull_back() function   of G, and then the pull_back() function of F.  
* [0.x.4]*
   Push forward the chartdim dimensional point to a spacedim   Euclidean point. The function calls first the push_forward() of   F, and then the push_forward() of G.  
* [0.x.5]*
   Return the derivative of the composition of G after F.  
* [0.x.6]*
   The first ChartManifold.  
* [0.x.7]*
   The second ChartManifold.  
* [0.x.8]

include/deal.II-translator/grid/connectivity_0.txt
[0.x.0]*
     Interface of geometric cell entities with the focus on creating a     reduced connectivity table.    
* [0.x.1]*
       Default destructor.      
* [0.x.2]*
       Number of sub-entities of dimension  [2.x.0]       
* [0.x.3]*
       Number of vertices of the  [2.x.1]  sub-entity of dimension  [2.x.2]       
* [0.x.4]*
       Geometric entity type of the  [2.x.3]  sub-entity of dimension  [2.x.4]       
* [0.x.5]*
       Number of lines of  [2.x.5]  surface.      
* [0.x.6]*
       Index of the  [2.x.6]  lines of  [2.x.7]  surface.      
* [0.x.7]*
       Vertex indices of the  [2.x.8]  lines of  [2.x.9]  surface.      
* [0.x.8]*
     Implementation for lines.    
* [0.x.9]*
     Implementation for triangles.    
* [0.x.10]*
     Implementation for quadrilaterals.    
* [0.x.11]*
     Implementation for tetrahedrons.    
* [0.x.12]*
     Implementation for pyramids.    
* [0.x.13]*
     Implementation for wedges.    
* [0.x.14]*
     Implementation for hexahedra.    
* [0.x.15]*
     Compressed row storage sparse matrix. This class is similar to     SparsityPattern but reduced to the bare minimum as needed here
* 
*  - in the     context of setting up the connectivity
* 
*  - and allowing direct simplified     access to the entries.    
* [0.x.16]*
       Default constructor.      
* [0.x.17]*
       Constructor which allows to set the internal fields directly.      
* [0.x.18]*
     Class for storing the reduced connectivity table.         A full connectivity table contains all possible connectivities of     entities of dimension d and entities of dimension d' with 0<=d,d'<=dim.     However, in the library we only need the following types of     connectivities:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - dim-dimensional neighbors of dim-dimensional entities (connected via        faces)
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - d-dimensional entity to it's (d-1)-dimension bounding entities
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - quad (2
* 
*  - 3D), line (1
* 
*  - 2D/3D) to vertices (0) to be able to process        the user provided SubCellData during         [2.x.10]      We call a table, which computes the corresponding entries of a full     connectivity table a reduced table.         The entries of the reduced table are as follows for 1D-3D:         1D :    | 0 1    2D:    | 0 1 2    3D:    | 0 1 2 3
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - -+-----
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - -+-------
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - -+--------           0 |             0 |               0 |           1 | x n         1 | x             1 | x                           2 | s x n         2 | s x                                             3 |     x n         with markers highlighting the reason for the entry x:=bounding entities;     n:= neighboring entities; s:=sub-cell data    
* [0.x.19]*
     Determine the neighbors of all cells.          [2.x.11]  connectivity cell-face      [2.x.12]  connectivity cell-cell (for each cell-face it contains the       index of the neighboring cell or
* 
*  -  for boundary face)    
* [0.x.20]*
     Build entities of dimension d (with 0<d<dim). Entities are described by     a set of vertices.         Furthermore, the function determines for each cell of which d-dimensional     entity it consists of and its orientation relative to the cell.    
* [0.x.21]*
     Call the right templated function to be able to use  [2.x.13]  instead     of  [2.x.14]     
* [0.x.22]*
     Build surface lines described by:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - connectivity quad
* 
-> line
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - orientation of line relative to the quad         Furthermore, the type of the quad is determined.    
* [0.x.23]*
     Build the reduced connectivity table for the given dimension  [2.x.15]          This function is inspired by the publication Anders Logg "Efficient     Representation of Computational Meshes" and the FEniCS's DOLFIN mesh     implementation. It has been strongly adjusted to efficiently solely meet     our connectivity needs while sacrificing some of the flexibility there.    
* [0.x.24]*
     Preprocessing step to remove the template argument dim.    
* [0.x.25]

include/deal.II-translator/grid/filtered_iterator_0.txt
[0.x.0]*
 In this namespace a number of classes is declared that may be used as filters in the FilteredIterator class. The filters either check for binary information (for example, the  [2.x.0]  filter class checks whether the object pointed to is active), or for valued information by comparison with prescribed values (for example, the LevelEqualTo filter class checks whether the level of the object pointed to by the iterator under consideration is equal to a value that was given to the filter upon construction.
*  For examples of use of these classes as well as requirements on filters see the general description of the FilteredIterator class.
* 

* 
*  [2.x.1] 

* 
* [0.x.1]*
   Filter that evaluates to true if either the iterator points to an active   object or an iterator past the end.    
*  [2.x.2]   
* [0.x.2]*
     Evaluate the iterator and return true if the object is active or past     the end.    
* [0.x.3]*
   Filter that evaluates to true if either the iterator points to an object   for which the user flag is set or an iterator past the end. See    [2.x.3]    for information about user flags.    
*  [2.x.4]   
* [0.x.4]*
     Evaluate the iterator and return true if the object has a set user flag     or past the end.    
* [0.x.5]*
   Filter that evaluates to true if either the iterator points to an object   for which the user flag is not set or an iterator past the end. Inverse   filter to the previous class.    
*  [2.x.5]   
* [0.x.6]*
     Evaluate the iterator and return true if the object has an unset user     flag or past the end.    
* [0.x.7]*
   Filter for iterators that evaluates to true if either the iterator is   past the end or the level of the object pointed to is equal to a value   given to the constructor.    
*  [2.x.6]   
* [0.x.8]*
     Constructor. Store the level which iterators shall have to be evaluated     to true.    
* [0.x.9]*
     Evaluation operator. Returns true if either the level of the object     pointed to is equal to the stored value or the iterator is past the     end.    
* [0.x.10]*
     Stored value to compare the level with.    
* [0.x.11]*
   Filter for iterators that evaluates to true if either the iterator is   past the end or the subdomain id of the object pointed to is equal to a   value given to the constructor, assuming that the iterator allows   querying for a subdomain id.    
*  [2.x.7]   
* [0.x.12]*
     Constructor. Store the subdomain which iterators shall have to be     evaluated to true.    
* [0.x.13]*
     Evaluation operator. Returns true if either the subdomain of the object     pointed to is equal to the stored value or the iterator is past the     end.    
* [0.x.14]*
     Stored value to compare the subdomain with.    
* [0.x.15]*
   Filter for iterators that evaluates to true if a cell is owned by the   current processor, i.e., if it is a    [2.x.8]  "locally owned cell".     This class is used in  [2.x.9] , in connection with the methods of the    [2.x.10]    module.    
*  [2.x.11]   
* [0.x.16]*
     Evaluation operator. Returns true if the cell is locally owned.    
* [0.x.17]*
   Filter for iterators that evaluates to true if the level subdomain id of   a cell is equal to the current processor id.    
*  [2.x.12]   
* [0.x.18]*
     Evaluation operator. Returns true if the level subdomain id of the cell     is equal to the current processor id.    
* [0.x.19]*
   Filter for iterators that evaluates to true if the iterator of the object   pointed to is equal to a value or set of values given to the constructor,   assuming that the iterator allows querying for a material id.      
*  [2.x.13]   
* [0.x.20]*
     Constructor. Store the material id which iterators shall have to be     evaluated to true and state if the iterator must be locally owned.    
* [0.x.21]*
     Constructor. Store a collection of material ids which iterators shall     have to be evaluated to true and state if the iterator must be locally     owned.    
* [0.x.22]*
     Evaluation operator. Returns true if the material id of the object     pointed to is equal within the stored set of value allowable values     and, if required, if the cell is locally owned.    
* [0.x.23]*
     Stored value to compare the material id with.    
* [0.x.24]*
     Flag stating whether only locally owned cells must return true.    
* [0.x.25]*
   Filter for iterators that evaluates to true if the iterator of the object   pointed to is equal to a value or set of values given to the constructor,   assuming that the iterator allows querying for an active FE index.      
*  [2.x.14]   
* [0.x.26]*
     Constructor. Store the active FE index which iterators shall have to be     evaluated to true and state if the iterator must be locally owned.    
* [0.x.27]*
     Constructor. Store a collection of active FE indices which iterators     shall have to be evaluated to true and state if the iterator must be     locally owned.    
* [0.x.28]*
     Evaluation operator. Returns true if the active FE index of the object     pointed to is equal within the stored set of value allowable values     and, if required, if the cell is locally owned.    
* [0.x.29]*
     Stored value to compare the material id with.    
* [0.x.30]*
     Flag stating whether only locally owned cells must return true.    
* [0.x.31]*
   Filter for iterators that evaluates to true if the iterator of the object   pointed to is on the boundary.      
*  [2.x.15]   
* [0.x.32]*
     Evaluate the iterator and return true if the object at the boundary.    
* [0.x.33]*
 This class provides a certain view on a range of triangulation or DoFHandler iterators by only iterating over elements that satisfy a given filter (called a  [2.x.16] predicate [2.x.17] , following the notation of the C++ standard library). Once initialized with a predicate and a value for the iterator, a filtered iterator hops to the next or previous element that satisfies the predicate if operators ++ or \-- are invoked. Intermediate iterator values that lie in between but do not satisfy the predicate are skipped. It is thus very simple to write loops over a certain class of objects without the need to explicitly write down the condition they have to satisfy in each loop iteration. This in particular is helpful if functions are called with a pair of iterators denoting a range on which they shall act, by choosing a filtered iterator instead of usual ones.
*  This class is used in  [2.x.18] .
* 

*  [1.x.0]
*  The object that represent the condition an iterator has to satisfy only have to provide an interface that allows to call the evaluation operator, i.e.  [2.x.19] . This includes function pointers as well as classes that implement an <code>bool operator ()(const BaseIterator&)</code>. Then, the FilteredIterator will skip all objects where the return value of this function is  [2.x.20] .
* 

*  An example of a simple valid predicate is the following: given the function

* 
* [1.x.1]
*  then

* 
* [1.x.2]
*  is a valid predicate.
*  Likewise, given the following binary function

* 
* [1.x.3]
*  then

* 
* [1.x.4]
*  is another valid predicate (here: a function that returns true if either the iterator is past the end or the level is equal to the second argument; this second argument is taken considered fixed when creating the lambda function).
*  Finally, classes can be predicates. The following class is one:

* 
* [1.x.5]
*  and objects of this type can be used as predicates. Likewise, this more complicated one can also be used:

* 
* [1.x.6]
*  Objects like  [2.x.21]  can then be used as predicates.
*  Since whenever a predicate is evaluated it is checked that the iterator checked is actually valid (i.e. not past the end), no checks for this case have to be performed inside predicates.
*  A number of filter classes are already implemented in the IteratorFilters namespace, but writing different ones is simple following the examples above.
* 

*  [1.x.7]
*  Filtered iterators are given a predicate at construction time which cannot be changed any more. This behavior would be expected if the predicate would have been given as a template parameter to the class, but since that would make the declaration of filtered iterators a nightmare, we rather give the predicate as an unchangeable entity to the constructor. Note that one can assign a filtered iterator with one predicate to another filtered iterator with another type; yet, this does  [2.x.22] not [2.x.23]  change the predicate of the assigned-to iterator, only the pointer indicating the iterator is changed.
*  If a filtered iterator is not assigned a value of the underlying (unfiltered) iterator type, the default value is taken. If, however, a value is given to the constructor, that value has either to be past the end, or has to satisfy the predicate. For example, if the predicate only evaluates to true if the level of an object is equal to three, then  [2.x.24]  would be a valid choice while  [2.x.25]  would not since the latter also returns iterators to non-active cells which always start at level 0.
*  Since one often only has some iterator and wants to set a filtered iterator to the first one that satisfies a predicate (for example, the first one for which the user flag is set, or the first one with a given subdomain id), there are assignment functions #set_to_next_positive and #set_to_previous_positive that assign the next or last previous iterator that satisfies the predicate, i.e. they follow the list of iterators in either direction until they find a matching one (or the past-the-end iterator). Like the  [2.x.26]  they return the resulting value of the filtered iterator.
* 

*  [1.x.8]
*  The following call counts the number of active cells that have a set user flag:

* 
* [1.x.9]
*  Note that by the  [2.x.27]  call the first cell with a set user flag was assigned to the  [2.x.28]  iterator. For the end iterator, no such call was necessary, since the past-the-end iterator always satisfies all predicates.
*  The same can be achieved by the following snippet, though harder to read:

* 
* [1.x.10]
*  It relies on the fact that if we create an unnamed filtered iterator with a given predicate but no iterator value and assign it the next positive value with respect to this predicate, it returns itself which is then used as the first parameter to the  [2.x.29]  function. This procedure is not necessary for the end element to this function here, since the past-the-end iterator always satisfies the predicate so that we can assign this value to the filtered iterator directly in the constructor.
*  Finally, the following loop only assembles the matrix on cells with subdomain id equal to three:

* 
* [1.x.11]
* 
*  Since comparison between filtered and unfiltered iterators is defined, we could as well have let the  [2.x.30]  variable in the last example be of type  [2.x.31]  since it is unchanged and its value does not depend on the filter.
* 

* 
*  [2.x.32] 

* 
*  [2.x.33] 

* 
* [0.x.34]*
   Typedef to the accessor type of the underlying iterator.  
* [0.x.35]*
   Constructor. Set the iterator to the default state and use the given   predicate for filtering subsequent assignment and iteration.  
* [0.x.36]*
   Constructor. Use the given predicate for filtering and initialize the   iterator with the given value.     If the initial value  [2.x.34]  does not satisfy the predicate  [2.x.35]  then it is   advanced until we either hit the past-the-end iterator, or the   predicate is satisfied. This allows, for example, to write code like  
* [1.x.12]
*      If the cell  [2.x.36]  does not have a   subdomain_id equal to 13, then the iterator will automatically be   advanced to the first cell that has.  
* [0.x.37]*
   Copy constructor. Copy the predicate and iterator value of the given   argument.  
* [0.x.38]*
   Assignment operator. Copy the iterator value of the argument, but as   discussed in the class documentation, the predicate of the argument is   not copied. The iterator value underlying the argument has to satisfy the   predicate of the object assigned to, as given at its construction time.  
* [0.x.39]*
   Assignment operator. Copy the iterator value of the argument, and keep   the predicate of this object. The given iterator value has to satisfy the   predicate of the object assigned to, as given at its construction time.  
* [0.x.40]*
   Search for the next iterator from  [2.x.37]  onwards that satisfies the   predicate of this object and assign it to this object.     Since filtered iterators are automatically converted to the underlying   base iterator type, you can also give a filtered iterator as argument to   this function.  
* [0.x.41]*
   As above, but search for the previous iterator from  [2.x.38]  backwards that   satisfies the predicate of this object and assign it to this object.     Since filtered iterators are automatically converted to the underlying   base iterator type, you can also give a filtered iterator as argument to   this function.  
* [0.x.42]*
   Compare for equality of the underlying iterator values of this and the   given object.     We do not compare for equality of the predicates.  
* [0.x.43]*
   Compare for equality of the underlying iterator value of this object with   the given object.     The predicate of this object is irrelevant for this operation.  
* [0.x.44]*
   Compare for inequality of the underlying iterator values of this and the   given object.     We do not compare for equality of the predicates.  
* [0.x.45]*
   Compare for inequality of the underlying iterator value of this object   with the given object.     The predicate of this object is irrelevant for this operation.  
* [0.x.46]*
   Compare for ordering of the underlying iterator values of this and the   given object.     We do not compare the predicates.  
* [0.x.47]*
   Compare for ordering of the underlying iterator value of this object with   the given object.     The predicate of this object is irrelevant for this operation.  
* [0.x.48]*
   Prefix advancement operator: move to the next iterator value satisfying   the predicate and return the new iterator value.  
* [0.x.49]*
   Postfix advancement operator: move to the next iterator value satisfying   the predicate and return the old iterator value.  
* [0.x.50]*
   Prefix decrement operator: move to the previous iterator value satisfying   the predicate and return the new iterator value.  
* [0.x.51]*
   Postfix advancement operator: move to the previous iterator value   satisfying the predicate and return the old iterator value.  
* [0.x.52]*
   Exception.  
* [0.x.53]*
   Base class to encapsulate a predicate object. Since predicates can be of   different types and we do not want to code these types into the template   parameter list of the filtered iterator class, we use a base class with   an abstract function and templatized derived classes that implement the   use of actual predicate types through the virtual function.    
*  [2.x.39]   
* [0.x.54]*
     Mark the destructor virtual to allow destruction through pointers to     the base class.    
* [0.x.55]*
     Abstract function which in derived classes denotes the evaluation of     the predicate on the given iterator.    
* [0.x.56]*
     Generate a copy of this object, i.e. of the actual type of this     pointer.    
* [0.x.57]*
   Actual implementation of the above abstract base class. Use a template   parameter to denote the actual type of the predicate and store a copy of   it. When the virtual function is called evaluate the given iterator with   the stored copy of the predicate.    
*  [2.x.40]   
* [0.x.58]*
     Constructor. Take a predicate and store a copy of it.    
* [0.x.59]*
     Evaluate the iterator with the stored copy of the predicate.    
* [0.x.60]*
     Generate a copy of this object, i.e. of the actual type of this     pointer.    
* [0.x.61]*
     Copy of the predicate.    
* [0.x.62]*
   Pointer to an object that encapsulated the actual data type of the   predicate given to the constructor.  
* [0.x.63]*
 Create an object of type FilteredIterator given the base iterator and predicate.  This function makes the creation of temporary objects (for example as function arguments) a lot simpler because one does not have to explicitly specify the type of the base iterator by hand
* 
*  -  it is deduced automatically here.
*   [2.x.41]  FilteredIterator

* 
* [0.x.64]*
 Filter the  given range of iterators using a Predicate. This allows to replace:

* 
* [1.x.13]
*  by:

* 
* [1.x.14]
* 
*   [2.x.42]  FilteredIterator

* 
*  [2.x.43] 

* 
* [0.x.65]*
 Filter the given range of iterators through an arbitrary number of Predicates. This allows to replace:

* 
* [1.x.15]
*  by:

* 
* [1.x.16]
* 
*   [2.x.44]  FilteredIterator

* 
*  [2.x.45] 

* 
* [0.x.66]

include/deal.II-translator/grid/grid_generator_0.txt
[0.x.0]*
 This namespace provides a collection of functions for generating triangulations for some basic geometries.
*  Some of these functions receive a flag  [2.x.0]  (see  [2.x.1]  "the glossary entry on colorization"). If this is set, parts of the boundary receive different  [2.x.2]  "boundary indicators" allowing them to be distinguished for the purpose of evaluating different boundary conditions.
*  If the domain is curved, each of the domain parts that should be refined by following an appropriate Manifold description will receive a different  [2.x.3]  "manifold indicator", and the correct Manifold descriptor will be attached to the Triangulation. Notice that if you later transform the triangulation, you have to make sure you attach the correct new Manifold to the triangulation.
* 

* 
*  [2.x.4] 

* 
* [0.x.1]*
    [2.x.5]  Creating meshes for basic geometries  
* [0.x.2]*
   Initialize the given triangulation with a hypercube (line in 1D, square   in 2D, etc) consisting of exactly one cell. The hypercube volume is the   tensor product interval  [2.x.6]  in the present number   of dimensions, where the limits are given as arguments. They default to   zero and unity, then producing the unit hypercube.     If the argument  [2.x.7]  is false, then all boundary indicators are   set to zero (the default boundary indicator) for 2d and 3d. If it is   true, the boundary is    [2.x.8]  "colorized"   as in hyper_rectangle(). In 1d the   indicators are always colorized, see hyper_rectangle().      [2.x.9]      If  [2.x.10]  <  [2.x.11]  this will create a  [2.x.12]  dimensional object in   the first  [2.x.13]  coordinate directions embedded into the  [2.x.14]    dimensional space with the remaining entries set to zero. For example, a   <tt>Triangulation [2.x.15]  will be a square in the xy plane with z=0.     See also subdivided_hyper_cube() for a coarse mesh consisting of several   cells. See hyper_rectangle(), if different lengths in different ordinate   directions are required.      [2.x.16]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.3]*
   Create a  [2.x.17] -[1.x.0]   (i.e., a triangle in 2d, or a tetrahedron in 3d) with    [2.x.18]  corners. Since deal.II does not support triangular and   tetrahedral cells, the simplex described by the input arguments   is subdivided into quadrilaterals and hexahedra by adding edge,   face, and simplex midpoints, resulting in a mesh that consists of    [2.x.19]  quadrilateral or hexahedral cells.     The  [2.x.20]  argument contains a vector with all d+1 vertices defining   the corners of the simplex. They must be given in an order such that the   vectors from the first vertex to each of the others form a right-handed   system.     The meshes generated in two and three dimensions are:      [2.x.21]     [2.x.22]       [2.x.23]  tria The triangulation to be created. It needs to be empty upon   calling this function.      [2.x.24]  vertices The dim+1 corners of the simplex.    
*  [2.x.25]  Implemented for <tt>Triangulation [2.x.26]    <tt>Triangulation [2.x.27]   
* [0.x.4]   Create a (coarse) grid with a single cell of the shape of the provided   reference cell. This is a generalization of the hyper_cube() and simplex()   functions above.  
* [0.x.5]*
   Same as hyper_cube(), but with the difference that not only one cell is   created but each coordinate direction is subdivided into  [2.x.28]    cells. Thus, the number of cells filling the given volume is   <tt>repetitions<sup>dim</sup></tt>.     If  [2.x.29]  <  [2.x.30]  this will create a  [2.x.31]  dimensional object in   the first  [2.x.32]  coordinate directions embedded into the  [2.x.33]    dimensional space with the remaining entries set to zero. For example, a   <tt>Triangulation [2.x.34]  will be a square in the xy plane with z=0.      [2.x.35]  The triangulation passed as argument needs to be empty when calling   this function.      [2.x.36]  tria The triangulation to create. It needs to be empty upon   calling this function.      [2.x.37]  repetitions An unsigned integer denoting the number of cells to   generate in each direction.      [2.x.38]  left Lower bound for the interval used to create the hyper cube.      [2.x.39]  right Upper bound for the interval used to create the hyper cube.      [2.x.40]  colorize Assign different boundary ids if set to true.  
* [0.x.6]*
   Create a coordinate-parallel brick from the two diagonally opposite   corner points  [2.x.41]  and  [2.x.42]      If the  [2.x.43]  flag is  [2.x.44] , then the  [2.x.45]  of   the boundary faces are assigned, such that the lower one in  [2.x.46]    x-direction is 0, the upper one is 1. The indicators for the surfaces in    [2.x.47]  are 2 and 3, the ones for  [2.x.48]  are 4 and 5. This   corresponds to the numbers of faces of the unit square of cube as laid   out in the documentation of the GeometryInfo class; see also    [2.x.49]  "the glossary entry on colorization".   Importantly,   however, in 3d    [2.x.50]  "colorization"   does not set  [2.x.51]    boundary_ids of [1.x.1], but only of [1.x.2], because each   boundary edge is shared between two faces and it is not clear how the   boundary id of an edge should be set in that case.     Additionally, if  [2.x.52]  is  [2.x.53]  material ids are assigned to the   cells according to the octant their center is in: being in the right half   space for any coordinate direction [1.x.3] adds   2<sup>i</sup>. For instance, a cell with center point (1,-1,1) yields a   material id 5, assuming that the center of the hyper rectangle lies at   the origin. No manifold id is set for the cells.     If  [2.x.54]  <  [2.x.55]  this will create a  [2.x.56]  dimensional object in   the first  [2.x.57]  coordinate directions embedded into the  [2.x.58]    dimensional space with the remaining entries set to zero. For example, a   <tt>Triangulation [2.x.59]  will be a rectangle in the xy plane with   z=0, defined by the two opposing corners  [2.x.60]  and  [2.x.61]       [2.x.62]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.7]*
   Create a coordinate-parallel brick from the two diagonally opposite   corner points  [2.x.63]  and  [2.x.64]  The number of cells in coordinate   direction  [2.x.65]  is given by the integer <tt>repetitions[i]</tt>.     To get cells with an aspect ratio different from that of the domain, use   different numbers of subdivisions, given by  [2.x.66]  in different   coordinate directions. The minimum number of subdivisions in each   direction is 1.     If the  [2.x.67]  flag is  [2.x.68] , then the  [2.x.69]  of   the surfaces are assigned, such that the lower one in  [2.x.70]  is   0, the upper one is 1 (the left and the right vertical face). The   indicators for the surfaces in  [2.x.71]  are 2 and 3, the ones for    [2.x.72]  are 4 and 5.  Additionally, material ids are assigned to the cells   according to the octant their center is in: being in the right half plane   for any coordinate direction [1.x.4] adds 2<sup>i</sup> (see    [2.x.73]  "the glossary entry on colorization").   For   instance, the center point (1,-1,1) yields a material id 5 (this means   that in 2d only material ids 0,1,2,3 are assigned independent from the   number of repetitions).     Note that the  [2.x.74]  flag is ignored in 1d and is assumed to always   be true. That means the boundary indicator is 0 on the left and 1 on the   right.  See  [2.x.75]  for details.     If  [2.x.76]  <  [2.x.77]  this will create a  [2.x.78]  dimensional object in   the first  [2.x.79]  coordinate directions embedded into the  [2.x.80]    dimensional space with the remaining entries set to zero. For example, a   <tt>Triangulation [2.x.81]  will be a rectangle in the xy plane with   z=0, defined by the two opposing corners  [2.x.82]  and  [2.x.83]     
*  [2.x.84]  For an example of the use of this function see the  [2.x.85]  tutorial   program.      [2.x.86]  tria The triangulation to be created. It needs to be empty upon   calling this function.      [2.x.87]  repetitions A vector of  [2.x.88]  positive values denoting the number   of cells to generate in that direction.      [2.x.89]  p1 First corner point.      [2.x.90]  p2 Second corner opposite to  [2.x.91]       [2.x.92]  colorize Assign different boundary ids if set to true. The same   comments apply as for the hyper_rectangle() function.  
* [0.x.8]*
   Like the previous function. However, here the second argument does not   denote the number of subdivisions in each coordinate direction, but a   sequence of step sizes for each coordinate direction. The domain will   therefore be subdivided into  [2.x.93]  cells in   coordinate direction  [2.x.94] , with width    [2.x.95] th cell.     This function is therefore the right one to generate graded meshes where   cells are concentrated in certain areas, rather than a uniformly   subdivided mesh as the previous function generates.     The step sizes have to add up to the dimensions of the hyper rectangle   specified by the points  [2.x.96]  and  [2.x.97]   
* [0.x.9]*
   Like the previous function, but with the following twist: the  [2.x.98]    material_id argument is a dim-dimensional array that, for each cell,   indicates which material_id should be set. In addition, and this is the   major new functionality, if the material_id of a cell is <tt>(unsigned   char)(-1)</tt>, then that cell is deleted from the triangulation, i.e.   the domain will have a void there.    
*  [2.x.99]  If you need a lot of holes, you may consider cheese().  
* [0.x.10]*
   \brief Rectangular domain with rectangular pattern of holes     The domain itself is rectangular, very much as if it had been generated   by subdivided_hyper_rectangle(). The argument  [2.x.100]    specifies how many square holes the domain should have in each coordinate   direction. The total number of mesh cells in that direction is then twice   this number plus one.     The number of holes in one direction must be at least one.     An example with two by three holes is      [2.x.101]      If  [2.x.102]  <  [2.x.103]  this will create a  [2.x.104]  dimensional object in   the first  [2.x.105]  coordinate directions embedded into the  [2.x.106]    dimensional space with the remaining entries set to zero.      [2.x.107]  tria The triangulation to be created. It needs to be empty upon   calling this function.      [2.x.108]  holes Positive number of holes in each of the dim directions.  
* [0.x.11]*
   \brief Rectangular plate with an (offset) cylindrical hole.     Generate a rectangular plate with an (offset) cylindrical hole. The   geometry consists of 2 regions:   The first is a square region with length  [2.x.109]  and a hole of radius  [2.x.110]  .   Cells in this region will have TransfiniteInterpolationManifold with   manifold id  [2.x.111]  attached to them. Additionally, the boundary   faces of the hole will be associated with a PolarManifold (in 2D) or   CylindricalManifold (in 3D). The center of this   region can be prescribed via  [2.x.112]  , namely the axis of the hole will   be located at  [2.x.113]  .   The second region describes the remainder of the bulk material. It is   specified via padding   parameters  [2.x.114]   [2.x.115]   [2.x.116]  and  [2.x.117]    All cells in this region will have a FlatManifold attached to them.   The final width of the plate will be <code>padding_left + 2*outer_radius +   padding_right</code>, while its length is <code>padding_top +   2*outer_radius + padding_bottom</code>.     Here is the non-symmetric grid (after one global refinement, colored   according to manifold id) in 2D and 3D, respectively:     \htmlonly <style>div.image   img[src="plate_with_a_hole.png"]{width:25%;}</style> \endhtmlonly    [2.x.118]    \htmlonly <style>div.image   img[src="plate_with_a_hole_3D.png"]{width:25%;}</style> \endhtmlonly    [2.x.119]      In 3D, triangulation will be extruded in the z-direction by the total   height of  [2.x.120]  using  [2.x.121]  slices (minimum is 2).
*    If the  [2.x.122]  flag is  [2.x.123] , the boundary_ids of the   boundary faces are assigned such that the lower one in the x-direction is   0, and the upper one is 1 (see    [2.x.124]  "the glossary entry on colorization").   The indicators for the surfaces in the y-direction are 2 and 3, and the   ones for the z-direction are 5 and 6. The hole boundary has indicator 4.      [2.x.125]  is the triangulation to be created. It needs to be empty upon   calling this function.
* [0.x.12]*
   Generate a grid consisting of a channel with a cylinder. This is a common   benchmark for Navier-Stokes solvers. The geometry consists of a channel   of size  [2.x.126]  (where the  [2.x.127]    dimension is omitted in 2D) with a cylinder, parallel to the  [2.x.128]  axis   with diameter  [2.x.129] , centered at  [2.x.130] . The channel has three   distinct regions:    [2.x.131]       [2.x.132] If  [2.x.133]  is greater than zero, then there are that many shells     centered around the cylinder, [2.x.134]       [2.x.135] a blending region between the shells and the rest of the     triangulation, and [2.x.136]       [2.x.137] a bulk region consisting of Cartesian cells. [2.x.138]     [2.x.139]    Since the cylinder is slightly offset from the center of the channel,   this geometry results in vortex shedding at moderate Reynolds   numbers. Here is the grid (without additional global refinement) in 2D:      [2.x.140]      and in 3D:      [2.x.141]      The resulting Triangulation uses three manifolds: a PolarManifold (in 2D)   or CylindricalManifold (in 3D) with manifold id  [2.x.142] , a   TransfiniteInterpolationManifold with manifold id  [2.x.143] , and a FlatManifold   everywhere else. For more information on this topic see    [2.x.144]  "the glossary entry on manifold indicators".   The   cell faces on the cylinder and surrounding shells have manifold ids of    [2.x.145] , while the cell volumes adjacent to the shells (or, if they do not   exist, the cylinder) have a manifold id of  [2.x.146] . Put another way: this   grid uses TransfiniteInterpolationManifold to smoothly transition from   the shells (generated with  [2.x.147]  to the   bulk region. All other cell volumes and faces have manifold id    [2.x.148]  and use FlatManifold. All cells with id    [2.x.149]  are rectangular prisms aligned with the   coordinate axes.     The picture below shows part of the 2D grid (using all default arguments   to this function) after two global refinements. The cells with manifold   id  [2.x.150]  are orange (the polar manifold id), cells with manifold id  [2.x.151]  are   yellow (the transfinite interpolation manifold id), and the ones with   manifold id  [2.x.152]  are cyan:      [2.x.153]       [2.x.154]  tria Triangulation to be created. Must be empty upon calling this   function.      [2.x.155]  shell_region_width Width of the layer of shells around the cylinder.   This value should be between  [2.x.156]  and  [2.x.157] ; the default value is  [2.x.158] .      [2.x.159]  n_shells Number of shells to use in the shell layer.      [2.x.160]  skewness Parameter controlling how close the shells are   to the cylinder: see the mathematical definition given in    [2.x.161]       [2.x.162]  colorize Assign different boundary ids if set to true. For more   information on boundary indicators see    [2.x.163]  "this glossary entry".   The left boundary (at  [2.x.164] ) is assigned an id of  [2.x.165] , the right   boundary (at  [2.x.166] ) is assigned an id of  [2.x.167] , the cylinder boundary   is assigned an id of  [2.x.168] , and the channel walls are assigned an id of    [2.x.169] .     See the original paper for more information:  
* [1.x.5]
*   
* [0.x.13]*
   A general  [2.x.170] 
* 
*  - imensional cell (a segment if dim is 1, a quadrilateral   if  [2.x.171]  is 2, or a hexahedron if  [2.x.172]  is 3) immersed in a    [2.x.173] 
* 
*  - imensional space. It is the responsibility of the user to   provide the vertices in the right order (see the documentation of the   GeometryInfo class) because the vertices are stored in the same order as   they are given. It is also important to make sure that the volume of the   cell is positive.     If the argument  [2.x.174]  is false, then all boundary indicators are   set to zero for 2d and 3d. If it is true, the boundary is colorized as in   hyper_rectangle() (see    [2.x.175]  "the glossary entry on colorization").   In 1d the   indicators are always colorized, see hyper_rectangle().      [2.x.176]  tria The triangulation that will be created    [2.x.177]  vertices The 2^dim vertices of the cell    [2.x.178]  colorize If true, set different boundary ids.  
* [0.x.14]*
   A parallelogram. The first corner point is the origin. The next  [2.x.179]    vertices are the ones given in the second argument and the last vertex   will be the sum of the two vectors connecting the origin to those   points. Colorizing is done in the same way as in hyper_rectangle().    
*  [2.x.180]  This function is implemented in 2d only.      [2.x.181]  tria The triangulation to be created. It needs to be empty upon   calling this function.      [2.x.182]  corners Second and third vertices of the parallelogram.      [2.x.183]  colorize Assign different boundary ids if true. (see    [2.x.184]  "the glossary entry on colorization").  
* [0.x.15]*
   A parallelepiped. The first corner point is the origin. The  [2.x.185]    adjacent points are vectors describing the edges of the parallelepiped   with respect to the origin. Additional points are sums of these dim   vectors. Colorizing is done according to hyper_rectangle().    
*  [2.x.186]  This function silently reorders the vertices on the cells to   lexicographic ordering (see  [2.x.187] ).   In other words, if reordering of the vertices does occur, the ordering of   vertices in the array of  [2.x.188]  will no longer refer to the   same triangulation.      [2.x.189]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.16]*
   A subdivided parallelepiped. The first corner point is the origin. The  [2.x.190]    dim adjacent points are vectors describing the edges of the   parallelepiped with respect to the origin. Additional points are sums of   these dim vectors. The variable  [2.x.191]  designates the number   of subdivisions in each of the  [2.x.192]  directions. Colorizing is done   according to hyper_rectangle().      [2.x.193]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.17]*
   A subdivided parallelepiped, i.e., the same as above, but where the   number of subdivisions in each of the  [2.x.194]  directions may vary.   Colorizing is done according to hyper_rectangle().      [2.x.195]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.18]*
   A subdivided parallelepiped.      [2.x.196]  tria The triangulation to be created. It needs to be empty upon   calling this function.      [2.x.197]  origin First corner of the parallelepiped.      [2.x.198]  edges An array of  [2.x.199]  tensors describing the length and   direction of the edges from  [2.x.200]       [2.x.201]  subdivisions Number of subdivisions in each of the dim directions.   Each entry must be positive. An empty vector is equivalent to one   subdivision in each direction.      [2.x.202]  colorize Assign different boundary ids if set to true (see    [2.x.203]  "the glossary entry on colorization").    
*  [2.x.204]  Implemented for all combinations of  [2.x.205]  and  [2.x.206]     
*  [2.x.207]  You likely need to help the compiler by explicitly specifying the   two template parameters when calling this function.  
* [0.x.19]*
   Hypercube with a layer of hypercubes around it. Parameters  [2.x.208]  and    [2.x.209]  give the lower and upper bound of the inner hypercube in all   coordinate directions.   [2.x.210]  marks the size of the layer cells.     If the flag  [2.x.211]  is set, the outer cells get material ids   according to the following scheme: extending over the inner cube in (+/-)   x-direction 1/2, y-direction 4/8, z-direction 16/32. A bitwise OR operation   is used to get these values at the corners and edges (3d), (see also    [2.x.212]  "the glossary entry on colorization").     Presently only available in 2d and 3d.      [2.x.213]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.20]*
   Initialize the given triangulation with several    [2.x.214]  "coarse mesh cells"   that cover a hyperball, i.e. a circle in 2d or a   ball in 3d, around  [2.x.215]  with given  [2.x.216]  The function is   used in  [2.x.217] .     In order to avoid degenerate cells at the boundaries, the circle is   triangulated by five cells, whereas in 3d the ball is subdivided by   seven cells. Specifically, these   cells are one cell in the center plus one "cap" cell on each of the faces   of this center cell. This ensures that under repeated refinement, none   of the cells at the outer boundary will degenerate to have an interior   angle approaching 180 degrees, as opposed to the case where one might   start with just one square (or cube) to approximate the domain.   The diameter of the   center cell is chosen so that the aspect ratio of the boundary cells   after one refinement is optimized.     This function is declared to exist for triangulations of all space   dimensions, but throws an error if called in 1d.     By default, the manifold_id is set to 0 on the boundary faces, 1 on the   boundary cells, and  [2.x.218]  on the central cell and on   internal faces.     A SphericalManifold is attached by default to the boundary faces for   correct placement of boundary vertices upon refinement and to be able to   use higher order mappings. However, it turns out that this strategy may   not be the optimal one to create a good a mesh for a hyperball. The   "Possibilities for extensions" section of  [2.x.219]  has an extensive   discussion of how one would construct better meshes and what one needs to   do for it. Setting the argument   `attach_spherical_manifold_on_boundary_cells` to true attaches a   SphericalManifold manifold also to the cells adjacent to the boundary, and   not only to the boundary faces.    
*  [2.x.220]  Since this is likely one of the earliest functions users typically     consider to create meshes with curved boundaries, let us also comment     on one aspect that is often confusing: Namely, that what one sees is not     always what is actually happening. Specifically, if you output the coarse     mesh with a function such as  [2.x.221]  using default options,     then one doesn't generally get to see curved faces at the boundary.     That's because most file formats by default only store vertex locations,     with the implicit understanding that cells are composed from these     vertices and bounded by straight edges. At the same time, the fact     that this function attaches a SphericalManifold object to the boundary     faces means that at leastinternally*, edges really are curved. If     you want to see them that way, you need to make sure that the function     you use to output the mesh actually plots boundary faces as curved     lines rather than straight lines characterized by only the locations     of the two end points. For example,  [2.x.222]  can do     that if you set the corresponding flag in the  [2.x.223]      structure. It is, however, an entirely separate consideration whether     you are actuallycomputing* on curved cells. In typical finite     element computations, one has to compute integrals and these are     computed by transforming back actual cells using a mapping to the     reference cell. What mapping is used determines what shape the     cells have for these internal computations: For example, with the     widely used  [2.x.224]  mapping (implicitly used in  [2.x.225] ), integration     always happens on cells that are assumed to have straight boundaries     described by only the vertex locations. In other words, if such a     mapping is used, then the cells of the domain really do have     straight edges, regardless of the manifold description attached     to these edges and regardless of the flags given when generating     output. As a consequence of all of this, it is important to     distinguish three things: (i) the manifold description attached to an     object in the mesh; (ii) the mapping used in integration; and (iii) the     style used in outputting graphical information about the mesh. All of     these can be chosen more or less independently of each other, and     what you see visualized is not necessarily exactly what is     happening.      [2.x.226]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.21]*
   This is an alternative to hyper_ball with 12 cells in 2d and 32 cells in   3d, which provides a better balance between the size of the cells around   the outer curved boundaries and the cell in the interior. The mesh is   based on the cells used by  [2.x.227]  with   appropriate copies and rotations to fill the whole ball.     The following pictures show the resulting mesh in 2D (left) and 3D:    [2.x.228]      By default, the manifold_id is set to 0 on the boundary faces, 1 on the   boundary cells, and  [2.x.229]  on the central cell and on   internal faces.      [2.x.230]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.22]*
   Generate a 2D mesh consisting of the unit square joined with a copy shifted   by  [2.x.231] . Depending on the flags passed either the right or the left   square is rotated by  [2.x.232] . This way one can generate a mesh in which one   square possibly contains an edge that has the opposite tangential (and   hence also opposite normal) orientation of the neighboring edge of the   other square.     This mesh is not overly useful from a practical point of view. For   debugging purposes it can be used to check for orientation issues for   vector- or tensor-valued finite elements.    
*  [2.x.233]  If  [2.x.234]  the mesh is consistently oriented.      [2.x.235]  tria The input triangulation.    [2.x.236]  rotate_left_square  [2.x.237]  if the left square is   rotated by  [2.x.238] .    [2.x.239]  rotate_right_square  [2.x.240]  if the right square is   rotated by  [2.x.241] .  
* [0.x.23]*
   Generate a 3D mesh consisting of the unit cube joined with a copy shifted   by  [2.x.242] . Depending on the flags passed either the right or the   left cube (when looking at the positively oriented (x,z)-plane) contains a   face that is either not in standard orientation and/or is rotated by either    [2.x.243] ,  [2.x.244]  or  [2.x.245] .     This mesh is not overly useful from a practical point of view. For   debugging purposes it can be used to check for orientation issues for   vector- or tensor-valued finite elements.      [2.x.246]  tria The input triangulation.    [2.x.247]  face_orientation  [2.x.248]  if the face is the not in   standard orientation.    [2.x.249]  face_flip  [2.x.250]  if the face is rotated by +180   degrees    [2.x.251]  face_rotation  [2.x.252]  if the face is rotated   (additionally) by +90 degrees    [2.x.253]  manipulate_left_cube  [2.x.254]  if the left cube is   to be re-ordered. If `false`, it is the right cube.  
* [0.x.24]*
   Creates a hyper sphere, i.e., a surface of a ball in  [2.x.255]    dimensions. This function only exists for dim+1=spacedim in 2 and 3 space   dimensions. (To create a mesh of a ball, use  [2.x.256]      By default, all manifold ids of the triangulation are set to zero, and a   SphericalManifold is attached to the grid.     The following pictures are generated with:  
* [1.x.6]
*      See the    [2.x.257]  "documentation module on manifolds"   for more details.      [2.x.258]     [2.x.259]       [2.x.260]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.25]*
   This function produces a hyper-ball intersected with the positive orthant   relative to  [2.x.261]  which contains three elements in 2d and four in   3d. The interior points of the mesh are chosen to balance the minimal   singular value of the Jacobian of the mapping from reference to real   coordinates among the cells around the interior point, which corresponds   to a high mesh quality.     The boundary indicators for the final triangulation are 0 for the curved   boundary and 1 for the cut plane. The manifold id for the curved boundary   is set to zero, and a SphericalManifold is attached to it.     The resulting grid in 2D and 3D looks as follows:    [2.x.262]       [2.x.263]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.26]*
   This function produces a half hyper-ball around  [2.x.264]  which contains   four elements in 2d and 6 in 3d. The cut plane is perpendicular to the   [1.x.7]-axis.     The boundary indicators for the final triangulation are 0 for the curved   boundary and 1 for the cut plane. The manifold id for the curved boundary   is set to zero, and a SphericalManifold is attached to it.      [2.x.265]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.27]*
   Create a  [2.x.266]  dimensional cylinder where the  [2.x.267] -axis serves as   the axis of the cylinder. For the purposes of this function, a   cylinder is defined as a ( [2.x.268] 
* 
*  - 1) dimensional disk of given    [2.x.269]  extruded along the axis of the cylinder (which is the   first coordinate direction). Consequently, in three dimensions,   the cylinder extends from `x=-half_length` to `x=+half_length`   and its projection into the  [2.x.270]  is a circle of radius  [2.x.271]    radius. In two dimensions, the cylinder is a rectangle from   `x=-half_length` to `x=+half_length` and from `y=-radius` to   `y=radius`.     The boundaries are colored according to the following scheme: 0 for the   hull of the cylinder, 1 for the left hand face and 2 for the right hand   face (see    [2.x.272]  "the glossary entry on colorization").     The manifold id for the hull of the cylinder is set to zero, and a   CylindricalManifold is attached to it.      [2.x.273]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.28]*
   Create a  [2.x.274]  dimensional cylinder where the  [2.x.275] -axis serves as   the axis of the cylinder. For the purposes of this function, a   cylinder is defined as a ( [2.x.276] 
* 
*  - 1) dimensional disk of given    [2.x.277]  extruded along the axis of the cylinder (which is the   first coordinate direction). Consequently, in three dimensions,   the cylinder extends from `x=-half_length` to `x=+half_length`   and its projection into the  [2.x.278]  is a circle of radius  [2.x.279]    radius. In two dimensions, the cylinder is a rectangle from   `x=-half_length` to `x=+half_length` and from `y=-radius` to   `y=radius`. This function is only implemented for dim==3.     The boundaries are colored according to the following scheme: 0 for the   hull of the cylinder, 1 for the left hand face and 2 for the right hand   face (see    [2.x.280]  "the glossary entry on colorization").     The manifold id for the hull of the cylinder is set to zero, and a   CylindricalManifold is attached to it.      [2.x.281]       [2.x.282]  tria The triangulation to be created. It needs to be empty upon   calling this function.      [2.x.283]  x_subdivisions A positive integer denoting the number   of cells to generate in the x direction. The default cylinder has   x_repetitions=2.      [2.x.284]  radius The radius of the circle in the yz-plane used to extrude the cylinder.      [2.x.285]  half_length The half-length of the cylinder in the x direction.  
* [0.x.29]*
   Create a cut cone around the x-axis.  The cone extends from   <tt>x=-half_length</tt> to <tt>x=half_length</tt> and its projection into   the  [2.x.286]  is a circle of radius  [2.x.287]  at   <tt>x=-half_length</tt> and a circle of radius  [2.x.288]  at   <tt>x=+half_length</tt>. In between the radius is linearly decreasing.     In two dimensions, the cone is a trapezoid from <tt>x=-half_length</tt>   to <tt>x=+half_length</tt> and from <tt>y=-radius_0</tt> to   <tt>y=radius_0</tt> at <tt>x=-half_length</tt> and from   <tt>y=-radius_1</tt> to <tt>y=radius_1</tt> at <tt>x=+half_length</tt>.   In between the range of <tt>y</tt> is linearly decreasing.     The boundaries are colored according to the following scheme: 0 for the   hull of the cone, 1 for the left hand face, and 2 for the right hand face   (see    [2.x.289]  "the glossary entry on colorization").   Both the boundary indicators and the manifold indicators are set.     In three dimensions, the manifold id of the hull is set to zero, and a   CylindricalManifold is attached to it.     Here are the grids in 2D and 3D after two mesh refinements:      [2.x.290]     [2.x.291]       [2.x.292]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.30]*
   \brief A center cell with stacks of cell protruding from each surface.     Each of the square mesh cells is Cartesian and has size one in each   coordinate direction. The center of cell number zero is the origin.      [2.x.293]  tria A Triangulation object which has to be empty.      [2.x.294]  sizes A vector of integers of dimension    [2.x.295]  with the following meaning: the legs of   the cross are stacked on the faces of the center cell, in the usual order   of deal.II cells, namely first  [2.x.296] , then  [2.x.297] , then  [2.x.298]  and so on. The   corresponding entries in  [2.x.299]  name the number of cells   stacked on this face. All numbers may be zero, thus L- and T-shaped   domains are specializations of this domain.      [2.x.300]  colorize_cells If colorization is enabled, then the material id of   a cells corresponds to the leg it is in. The id of the center cell is   zero, and then the legs are numbered starting at one (see    [2.x.301]  "the glossary entry on colorization").     Examples in two and three dimensions are:      [2.x.302]     [2.x.303]   
* [0.x.31]*
   Initialize the given triangulation with a hyper-L (in 2d or 3d)   consisting of exactly <tt>2^dim-1</tt> cells. It produces the   hypercube with the interval [[1.x.8]] without the   hypercube made out of the interval [[1.x.9]]   for each coordinate. Because the domain is about the simplest one   with a reentrant (i.e., non-convex) corner, solutions of many   partial differential equations have singularities at this   corner. That is, at the corner, the gradient or a higher   derivative (depending on the boundary conditions chosen) does not   remain bounded. As a consequence, this domain is often used to   test convergence of schemes when the solution lacks regularity.     If the  [2.x.304]  flag is  [2.x.305] , the  [2.x.306]  of the   surfaces are assigned such that the left boundary is 0 and the others are   assigned counterclockwise in ascending order (see    [2.x.307]  "the glossary entry on colorization"). The  [2.x.308]    colorize option only works in two dimensions.     This function will create the classical L-shape in 2d   and it will look like the following in 3d:      [2.x.309]     
*  [2.x.310]  The 3d domain is also often referred to as the "Fichera corner",   named after Gaetano Fichera (1922-1996) who first computed an   approximation of the corner singularity exponent of the lowest   eigenfunction of the domain.     This function exists for triangulations of all space   dimensions, but throws an error if called in 1d.      [2.x.311]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.32]*
   Initialize the given triangulation in 2D or 3D with a generalized   subdivided hyper-L.     This function produces a subdivided hyper rectangle with dimensions given   by  [2.x.312]  and  [2.x.313]  with the given number of   subdivisions in each direction given in the vector  [2.x.314]    and with a number of cells removed, given in the vector  [2.x.315]    Note that  [2.x.316]  contains integers, meaning that its entries   can be both positive and negative. A positive number denotes   cutting away cells in the 'positive' orientation, for example   left to right in the x-direction, bottom to top in   the y-direction, and front to back in the z-direction. A negative number   denotes cutting away cells in the reverse direction, so right to left,   top to bottom, and back to front.     A demonstration of this grid can be found in  [2.x.317] .     This function may be used to generate a mesh for a backward   facing step, a useful domain for benchmark problems in fluid dynamics.   The first image is a backward facing step in 3D, generated by   removing all cells in the z-direction, and 2 cells in the   positive x- and y-directions:    [2.x.318]    And in 2D, we can cut away 1 cell in the negative x-direction, and 2 cells   in the negative y-direction:    [2.x.319]     
*  [2.x.320]  This function is declared to exist for triangulations of all space   dimensions, but throws an error if called in 1D.  
* [0.x.33]*
   Initialize the given Triangulation with a hypercube with a slit. In each   coordinate direction, the hypercube extends from  [2.x.321]  to  [2.x.322]      In 2d, the split goes in vertical direction from <tt>x=(left+right)/2,   y=left</tt> to the center of the square at <tt>x=y=(left+right)/2</tt>.     In 3d, the 2d domain is just extended in the [1.x.10]-direction, such   that a plane cuts the lower half of a rectangle in two.  This function is   declared to exist for triangulations of all space dimensions, but throws   an error if called in 1d.     If  [2.x.323]  is set to  [2.x.324]  the faces forming the slit are marked   with boundary id 1 and 2, respectively (see    [2.x.325]  "the glossary entry on colorization").      [2.x.326]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.34]*
   Produce a hyper-shell, the region between two spheres around   <tt>center</tt>, with given <tt>inner_radius</tt> and   <tt>outer_radius</tt>. The number <tt>n_cells</tt> indicates the number   of cells of the resulting triangulation, i.e., how many cells form the   ring (in 2d) or the shell (in 3d).     If the flag  [2.x.327]  is  [2.x.328] , then the outer boundary   will have the indicator 1 while the inner boundary has id zero. In 3d,   this applies to both the faces and the edges of these boundaries. If the   flag is  [2.x.329]  both have indicator zero (see    [2.x.330]  "the glossary entry on colorization").     All manifold ids are set to zero, and a SphericalManifold is attached to   every cell and face of the triangulation.     In 2d, the number <tt>n_cells</tt> of elements for this initial   triangulation can be chosen arbitrarily. If the number of initial cells   is zero (as is the default), then it is computed adaptively such that the   resulting elements have the least aspect ratio.     In 3d, only certain numbers are allowed:    [2.x.331]     [2.x.332]  6 (or the default 0) for a surface based on a hexahedron (i.e. 6        panels on the inner sphere extruded in radial direction to form 6        cells),    [2.x.333]  12 for the rhombic dodecahedron,    [2.x.334]  24 for the hexahedron-based surface refined once in the azimuthal        directions but not in the radial direction,    [2.x.335]  48 for the rhombic dodecahedron refined once in the azimuthal        directions but not in the radial direction,    [2.x.336]  96 for the rhombic dodecahedron refined once. This choice dates from        an older version of deal.II before the Manifold classes were        implemented: today this choce is equivalent to the rhombic        dodecahedron after performing one global refinement.    [2.x.337]  Numbers of the kind  [2.x.338]  with  [2.x.339]  integer. This        choice is similar to the 24 and 48 cell cases, but provides        additional refinements in azimuthal direction combined with a single        layer in radial direction. The base mesh is either the 6 or 12 cell        version, depending on whether  [2.x.340]  in the power is odd or even,        respectively.    [2.x.341]    The versions with 24, 48, and  [2.x.342]  cells are useful if the shell is   thin and the radial lengths should be made more similar to the   circumferential lengths.     The 3d grids with 12 and 96 cells are plotted below:      [2.x.343]     [2.x.344]     
*  [2.x.345]  This function is declared to exist for triangulations of all space   dimensions, but throws an error if called in 1d.      [2.x.346]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.35]*
   Produce an eccentric hyper-shell, the region between two spheres centered   on two distinct center points. One has to specify the <tt>inner_center</tt>   and <tt>outer_center</tt>, with given <tt>inner_radius</tt> and   <tt>outer_radius</tt>. The number <tt>n_cells</tt> indicates the number of   cells of the resulting triangulation, i.e., how many cells form the ring   (in 2d) or the shell (in 3d).     By default, the outer boundary has the indicator 1 while the inner boundary   has id 0. In 3d, this applies to both the faces and the edges of these   boundaries.     A SphericalManifold is attached to the outer boundary with an id of 1 while   another SphericalManifold is attached to the inner boundary with an id of   0. A TransfiniteInterpolationManifold is attached to all other cells and   faces of the triangulation with an id of 2.     Here, the number <tt>n_cells</tt> of elements has the same meaning as in    [2.x.347]      The grids with a 30% offset of the inner shell in the x direction, 12   initial cells and 3 levels of global refinement are plotted below:      [2.x.348]     [2.x.349]     
*  [2.x.350]  Because it uses the definition of the hyper shell, this function is   declared to exist for triangulations of all space dimensions, but throws an   error if called in 1d.      [2.x.351]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.36]*
   Produce a half hyper-shell, i.e. the space between two circles in two   space dimensions and the region between two spheres in 3d, with given   inner and outer radius and a given number of elements for this initial   triangulation.  However, opposed to the previous function, it does not   produce a whole shell, but only one half of it, namely that part for   which the first component is restricted to non-negative values. The   purpose of this function is to enable computations for solutions which have   rotational symmetry, in which case the half shell in 2d represents a   shell in 3d.     If the number of initial cells  [2.x.352]  is zero in 2d (as is the   default), then it is computed adaptively such that the resulting elements   have the least aspect ratio. The argument is ignored in 3d, where the   coarse mesh always has 5 cells.     If colorize is set to  [2.x.353] , the inner, outer, and the part   of the boundary where  [2.x.354] , get indicator 0, 1, and 2,   respectively. Additionally, in 2d, the boundary indicator 3 is given to   the vertical edge below the x-axis. Otherwise, if colorize is set to    [2.x.355]  all indicators are set to 0 (see    [2.x.356]  "the glossary entry on colorization").     All manifold ids are set to zero, and a SphericalManifold is attached   to the triangulation.      [2.x.357]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.37]*
   Produce a domain that is the intersection between a hyper-shell with   given inner and outer radius, i.e. the space between two circles in two   space dimensions and the region between two spheres in 3d, and the   positive quadrant (in 2d) or octant (in 3d). In 2d, this is indeed a   quarter of the full annulus, while the function is a misnomer in 3d   because there the domain is not a quarter but one eighth of the full   shell.     If the number of initial cells is zero (as is the default), then it is   computed adaptively such that the resulting elements have the least   aspect ratio in 2d.     If  [2.x.358]  is set to  [2.x.359] , the inner, outer, left, and   right boundary get indicator 0, 1, 2, and 3 in 2d,   respectively. Otherwise all indicators are set to 0. In 3d indicator 2 is   at the face  [2.x.360] , 3 at  [2.x.361] , 4 at  [2.x.362]  (see    [2.x.363]  "the glossary entry on colorization").     All manifold ids are set to zero, and a SphericalManifold is attached   to the triangulation.      [2.x.364]  The triangulation passed as argument needs to be empty when calling   this function.  
* [0.x.38]*
   Produce a domain that is the space between two cylinders in 3d, with   given length, inner and outer radius and a given number of elements. The   cylinder shell is built around the  [2.x.365] -axis with the two faces located   at  [2.x.366]  and  [2.x.367]   [2.x.368]      If  [2.x.369]  is zero (as is the   default), then it is computed adaptively such that the resulting elements   have the least aspect ratio. The same holds for  [2.x.370]     
*  [2.x.371]  Although this function is declared as a template, it does not make   sense in 1D and 2D. Also keep in mind that this object is rotated   and positioned differently than the one created by cylinder().     All manifold ids are set to zero, and a CylindricalManifold is attached   to the triangulation.      [2.x.372]  The triangulation passed as argument needs to be empty when calling   this function.      [2.x.373]      In this picture, a cylinder shell of length 2, inner radius 0.5, outer   radius 1 is shown. The default argument for n_radial_cells and   n_axial_cells are used and a single global refinement is carried out.  
* [0.x.39]*
   Produce the volume or surface mesh of a torus. The axis of the torus is   the  [2.x.374] -axis while the plane of the torus is the  [2.x.375] - [2.x.376]  plane.     If  [2.x.377]  is 3, the mesh will be the volume of the torus, using a mesh   equivalent to the circle in the poloidal coordinates with 5 cells on the   cross section. This function attaches a TorusManifold to all boundary   faces which are marked with a manifold id of 1, a CylindricalManifold to   the interior cells and all their faces which are marked with a manifold   id of 2 (representing a flat state within the poloidal coordinates), and   a TransfiniteInterpolationManifold to the cells between the TorusManifold   on the surface and the ToroidalManifold in the center, with cells marked   with manifold id 0.     An example for the case if  [2.x.378]  is 3 with a cut through the domain at    [2.x.379] , 6 toroidal cells,  [2.x.380]  and  [2.x.381]  without any global refinement   is given here:      [2.x.382]      In this picture, the light gray shade represents the manifold id 0 of the   transfinite interpolation, which is applied to smoothly add new points   between the toroidal shape on the domain boundary and the inner rim where   a cylindrical description around the y-axis is prescribed. The inner rim   with the manifold id 2 is shown in red shade.     If  [2.x.383]  is 2, the mesh will describe the surface of the torus and this   function attaches a TorusManifold to all cells and faces (which are   marked with a manifold id of 0).      [2.x.384]  tria The triangulation to be filled.      [2.x.385]  R The radius of the circle, which forms the middle line of the   torus containing the loop of cells. Must be greater than  [2.x.386]       [2.x.387]  r The inner radius of the torus.      [2.x.388]  n_cells_toroidal Optional argument to set the number of cell   layers in toroidal direction. The default is 6 cell layers.      [2.x.389]  phi Optional argument to generate an open torus with angle    [2.x.390] . The default value is  [2.x.391] ,   in which case a closed torus is generated. If the torus is open,   the torus is cut at two planes perpendicular to the torus centerline.   The center of these two planes are located at  [2.x.392]    and  [2.x.393] .    
*  [2.x.394]  Implemented for Triangulation<2,3> and Triangulation<3,3>.  
* [0.x.40]*
   This function produces a square in the [1.x.11]-plane with a cylindrical   hole in the middle. The square and the circle are centered at the   origin. In 3d, this geometry is extruded in  [2.x.395]  direction to the interval    [2.x.396] .     The inner boundary has a manifold id of  [2.x.397]  and a boundary id of    [2.x.398] . This function attaches a PolarManifold or CylindricalManifold to the   interior boundary in 2d and 3d respectively. The other faces have   boundary ids of  [2.x.399] , or  [2.x.400]  given in the standard order of   faces in 2d or 3d.      [2.x.401]      It is implemented in 2d and 3d, and takes the following arguments:      [2.x.402]  triangulation The triangulation to be filled.    [2.x.403]  inner_radius  Radius of the internal hole.    [2.x.404]  outer_radius Half of the edge length of the square.    [2.x.405]  L  Extension in  [2.x.406]  (only used in 3d).    [2.x.407]  repetitions Number of subdivisions along the  [2.x.408]     [2.x.409]  colorize Whether to assign different boundary indicators to   different faces (see    [2.x.410]  "the glossary entry on colorization").   The colors are given in lexicographic ordering for the   flat faces (0 to 3 in 2d, 0 to 5 in 3d) plus the curved hole (4 in 2d,   and 6 in 3d). If  [2.x.411]  is set to false, then flat faces get the   number 0 and the hole gets number 1.  
* [0.x.41]*
   Produce a grid consisting of concentric shells. The primary difference   between this function and  [2.x.412]  is that this   function permits unevenly spaced (in the radial direction)    [2.x.413]  "coarse level cells".     The parameters  [2.x.414]   [2.x.415]  and  [2.x.416]  behave in   the same way as the first three arguments to    [2.x.417]   [2.x.418]  gives the total number of shells   to use (i.e., the number of cells in the radial direction). The outer   radius of the  [2.x.419] th shell is given by     [1.x.12]     where  [2.x.420]  is a parameter controlling the shell spacing in the   radial direction: values of  [2.x.421]  close to zero correspond to even   spacing, while larger values of  [2.x.422]  (such as  [2.x.423]  or  [2.x.424] )   correspond to shells biased to the inner radius.      [2.x.425]  is the same as in  [2.x.426]  in 2d   the default choice of zero will result in 8 cells per shell (and 12 in   3d). The only valid values in 3d are 6 (the default), 12, and 96 cells:   see the documentation of  [2.x.427]  for more information.     If  [2.x.428]  is  [2.x.429]  then the outer boundary of the merged   shells has a boundary id of  [2.x.430]  and the inner boundary has a boundary id   of  [2.x.431] .     Example: The following code (see, e.g.,  [2.x.432]  for instructions on how   to visualize GNUPLOT output)    
* [1.x.13]
*      generates the following output:      [2.x.433]   
* [0.x.42]*
   Produce a ring of cells in 3d that is cut open, twisted and glued   together again. This results in a kind of moebius-loop.      [2.x.434]  tria        The triangulation to be worked on.    [2.x.435]  n_cells     The number of cells in the loop. Must be greater than   4.    [2.x.436]  n_rotations The number of rotations ( [2.x.437]  each) to be performed   before gluing the loop together.    [2.x.438]  R           The radius of the circle, which forms the middle line   of the torus containing the loop of cells. Must be greater than  [2.x.439]     [2.x.440]  r           The radius of the cylinder bent together as a loop.  
* [0.x.43]*
   Call one of the other GridGenerator functions, parsing the name of the   function to call from the string  [2.x.441]  and   the arguments to the function from the string    [2.x.442]      The string that supplies the arguments is passed to the function    [2.x.443]  where `TupleType` here is   a tuple containing*all** the arguments of the GridGenerator function,   including all optional arguments.     An example usage of this function is given by:  
* [1.x.14]
*    Here, the colon separates the function arguments, and the comma separates   the coordinates of a Point<2> argument.     According to the arity of the `TupleType`, the arguments of the function   may be separated by different separators (see the documentation of    [2.x.444]  for the details of how the conversion is   performed). If a wrong format is used, an exception is thrown, and the   expected format is output as an error message.     All GridGenerator functions are supported. If you find some that are   missing, please open an issue on GitHub.      [2.x.445]  tria                              The triangulation to be worked on    [2.x.446]  grid_generator_function_name      The name of the function to call    [2.x.447]  grid_generator_function_arguments The arguments of the function, in   the format of a tuple-convertible string  
* [0.x.44]*
    [2.x.448]  Creating meshes from other meshes  
* [0.x.45]*
   Given the two triangulations specified as the first two arguments, create   the triangulation that contains the cells of both triangulation and store   it in the third parameter. Previous content of  [2.x.449]  will be deleted.   One of the two input triangulations can also be the  [2.x.450]  triangulation.     This function is most often used to compose meshes for more complicated   geometries if the geometry can be composed of simpler parts for which   functions exist to generate    [2.x.451]  "coarse meshes". For example, the channel mesh   used in  [2.x.452]  could in principle be created using a mesh created by the    [2.x.453]  function and several   rectangles, and merging them using the current function. The rectangles   will have to be translated to the right for this, a task that can be done   using the  [2.x.454]  function (other tools to transform individual   mesh building blocks are  [2.x.455]   [2.x.456]  and    [2.x.457]      Vertices that are less than  [2.x.458]  apart will be merged   together. It is usually necessary to set this value to something that   depends on the input triangulations in some way. One reasonable choice is   to use the minimum distance between all adjacent vertices of the input   mesh divided by some constant:    
* [1.x.15]
*      This will merge any vertices that are closer than any pair of vertices on   the input meshes.    
*  [2.x.459]  The two input triangulations must be    [2.x.460]  "coarse meshes", i.e., they can not have any   refined cells.    
*  [2.x.461]  The function copies the material ids of the cells of the two input   triangulations into the output triangulation. If  [2.x.462]  is   set to  [2.x.463]  manifold ids will be copied. Boundary indicators are never   copied. In other words, if the two coarse meshes have anything but the   default boundary indicators, then you will have to set boundary indicators   again by hand in the output triangulation.    
*  [2.x.464]  This function does not attach any manifolds to  [2.x.465]  nor does   it set any manifold ids. In particular, manifolds attached to the two   input triangulations will be lost in the  [2.x.466]  triangulation.    
*  [2.x.467]  For a related operation on refined meshes when both meshes are   derived from the same coarse mesh, see    [2.x.468]   
* [0.x.46]*
   Same as above but allows to merge more than two triangulations at once.   The following gives an example of how to use this function:  
* [1.x.16]
*   
* [0.x.47]*
   \brief Replicate a given triangulation in multiple coordinate axes      [2.x.469]  input The triangulation which will be replicated along the   coordinate axes.      [2.x.470]  extents A vector with <tt>dim</tt> entries specifying how many   copies of a triangulation should be present along each coordinate axis.      [2.x.471]  result The triangulation to be created. It needs to be empty upon   calling this function.     This function creates a new Triangulation equal to a   <tt>dim</tt>-dimensional array of copies of  [2.x.472]  Copies of  [2.x.473]    are created by translating  [2.x.474]  along the coordinate axes. Boundary   ids of faces (but not lines in 3D) and all manifold ids are copied but   Manifold objects are not since most Manifold objects do not work   correctly when a Triangulation has been translated.     To see how this works, consider the following code:  
* [1.x.17]
*    results in      [2.x.475]      And, similarly, in 3D:  
* [1.x.18]
*    results in      [2.x.476]     
*  [2.x.477]  This function determines the spacing of the copies of  [2.x.478]    based on the BoundingBox of  [2.x.479]  If the boundary faces of  [2.x.480]    are not aligned with the coordinate axes then the copies might not share   common faces; i.e., this function is intended for simple geometries with   boundary faces aligned along the coordinate axes.  
* [0.x.48]*
   Given the two triangulations specified as the first two arguments, create   the triangulation that contains the finest cells of both triangulation   and store it in the third parameter. Previous content of  [2.x.481]  will   be deleted.    
*  [2.x.482]  This function is intended to create an adaptively refined   triangulation that contains the [1.x.19] from two input   triangulations that were derived from the [1.x.20]    [2.x.483]  "coarse mesh" by   adaptive refinement. This is an operation sometimes needed when one   solves for two variables of a coupled problem on separately refined   meshes on the same domain (for example because these variables have   boundary layers in different places) but then needs to compute something   that involves both variables or wants to output the result into a single   file. In both cases, in order not to lose information, the two solutions   can not be interpolated onto the respectively other mesh because that may   be coarser than the ones on which the variable was computed. Rather, one   needs to have a mesh for the domain that is at least as fine as each of   the two initial meshes. This function computes such a mesh.    
*  [2.x.484]  If you want to create a mesh that is the merger of two other    [2.x.485]  "coarse meshes",   for example in order to compose   a mesh for a complicated geometry   from meshes for simpler geometries, then this is not the function for   you. Instead, consider  [2.x.486]     
*  [2.x.487]  This function assumes that both  [2.x.488]  and  [2.x.489]    triangulation_2 have the same manifold descriptions. The output   Triangulation  [2.x.490]  the same manifold ids as these two triangulations.    
*  [2.x.491]  Both of the source conditions need to be available entirely locally.   In other words, they can not be objects of type    [2.x.492]   
* [0.x.49]*
   This function creates a triangulation that consists of the same cells as   are present in the first argument, except those cells that are listed in   the second argument. The purpose of the function is to generate   geometries [1.x.21] from the geometry described by an   existing triangulation. A prototypical case is a 2d domain with   rectangular holes. This can be achieved by first meshing the entire   domain and then using this function to get rid of the cells that are   located at the holes. A demonstration of this particular use case is part   of  [2.x.493] . Likewise, you could create the mesh that    [2.x.494]  produces by starting with a    [2.x.495]  refining it once, and then calling the   current function with a single cell in the second argument.      [2.x.496]  input_triangulation The original triangulation that serves as   the template from which the new one is to be created.    [2.x.497]  cells_to_remove A list of cells of the triangulation provided   as first argument that should be removed (i.e., that should not show up   in the result.    [2.x.498]  result The resulting triangulation that consists of the same   cells as are in  [2.x.499]  with the exception of the cells   listed in  [2.x.500]     
*  [2.x.501]  Unlike most GridGenerator functions, this function does not attach   any manifolds to  [2.x.502]  nor does it set any manifold ids.      [2.x.503]  Because we cannot create triangulations de novo that contain   adaptively refined cells, the input triangulation needs to have all of   its cells on the same level. Oftentimes, this will in fact be the   coarsest level, but it is allowed to pass in a triangulation that has   been refined [1.x.22] a number of times. The output triangulation   will in that case simply be a mesh with only one level that consists of   the active cells of the input minus the ones listed in the second   argument. However, the input triangulation must not have been   [1.x.23] refined.  
* [0.x.50]*
   Extrude the Triangulation  [2.x.504]  in the  [2.x.505]  direction from  [2.x.506]  to  [2.x.507]  and store it in  [2.x.508]      The number of  [2.x.509] slices [2.x.510] , or layers of cells   perpendicular to the  [2.x.511]  plane, will be  [2.x.512]  slices (minimum is   2). The boundary indicators of the faces of  [2.x.513]  will be assigned to   the corresponding side walls in  [2.x.514]  direction. The bottom and top get the   next two free boundary indicators: i.e., if  [2.x.515]  has boundary ids of    [2.x.516] ,  [2.x.517] , and  [2.x.518] , then the  [2.x.519]  boundary id of  [2.x.520]  will be  [2.x.521]    and the  [2.x.522]  boundary id will be  [2.x.523] .     This function does not, by default, copy manifold ids. The reason for   this is that there is no way to set the manifold ids on the lines of the   resulting Triangulation without more information: for example, if two   faces of  [2.x.524]  with different manifold ids meet at a shared vertex then   there is no  [2.x.525] a priori [2.x.526]  reason to pick one manifold id or another   for the lines created in  [2.x.527]  that are parallel to the  [2.x.528] -axis and   pass through that point. If  [2.x.529]  is  [2.x.530]    then this function sets line manifold ids by picking the one that appears    [2.x.531] first [2.x.532]  in  [2.x.533]  For example: if  [2.x.534]    manifold_priorities is  [2.x.535]    and the line under consideration is adjacent to faces with manifold ids of    [2.x.536] , then that line will have a manifold id   of  [2.x.537] . The correct ordering is almost always    [2.x.538]       [2.x.539] manifold ids set on the boundary, [2.x.540]       [2.x.541] manifold ids that describe most of the cells in the Triangulation     (e.g.,  [2.x.542]  and [2.x.543]       [2.x.544] any manifold ids corresponding to TransfiniteInterpolationManifold     manifolds. [2.x.545]     [2.x.546]      In particular, since TransfiniteInterpolationManifold interpolates   between surrounding manifolds, its manifold id should usually not be set   on lines or faces that are adjacent to cells with different manifold   ids. The default value for  [2.x.547]  follows this ranking   (where each category is sorted in ascending order):    [2.x.548]       [2.x.549] manifold ids associated with manifolds that are not     TransfiniteInterpolationManifold, and [2.x.550]       [2.x.551] manifold ids associated with any TransfiniteInterpolationManifold     objects. [2.x.552]     [2.x.553]    Note that  [2.x.554]  (should it be a manifold id of  [2.x.555]    input) will always be the last entry in the first category.      [2.x.556]  The 2d input triangulation  [2.x.557]  must be a    [2.x.558]  "coarse mesh",   i.e., it cannot have any   refined cells.    
*  [2.x.559]  Since  [2.x.560]  and  [2.x.561]  have different spatial dimensions, no   manifold objects are copied by this function regardless of the value of    [2.x.562]   
* [0.x.51]*
   Overload of extrude_triangulation() to allow dimension independent   code to compile. This function throws an error when called, as   extrude_triangulation() is only implemented to extrude a dim=2 to a dim=3   Triangulation.  
* [0.x.52]*
   Overload of the previous function. Take a 2d Triangulation that is being   extruded. Differing from the previous function taking height and number of   slices for uniform extrusion, this function takes z-axis values    [2.x.563]  where the slicing will happen. The boundary indicators   of the faces of  [2.x.564]  are going to be assigned to the corresponding side   walls in z direction. The bottom and top get the next two free boundary   indicators.      [2.x.565]  The 2d input triangulation  [2.x.566]  must be a    [2.x.567]  "coarse mesh",   i.e., it cannot have any   refined cells.    
*  [2.x.568]  Since  [2.x.569]  and  [2.x.570]  have different spatial dimensions no   manifold objects are copied (nor are any manifold ids set) by this   function.  
* [0.x.53]*
   Overload of extrude_triangulation() to allow dimension independent   code to compile. This function throws an error when called, as   extrude_triangulation() is only implemented to extrude a dim=2 to a dim=3   Triangulation.  
* [0.x.54]*
   Given an input triangulation  [2.x.571]  this function makes a new flat   triangulation  [2.x.572]  which contains a single level with all active   cells of the input triangulation. If  [2.x.573]  and  [2.x.574]  are   different, only the smallest spacedim components of the vertices are   copied over. This is useful to create a Triangulation<2,3> out of a   Triangulation<2,2>, or to project a Triangulation<2,3> into a   Triangulation<2,2>, by neglecting the z components of the vertices.     No internal checks are performed on the vertices, which are assumed to   make sense topologically in the target  [2.x.575]  dimensional space. If   this is not the case, you will encounter problems when using the   triangulation later on.     All information about cell manifold_ids and material ids are copied from   one triangulation to the other, and only the boundary manifold_ids and   boundary_ids are copied over from the faces of  [2.x.576]  to the faces of    [2.x.577]  If you need to specify manifold ids on interior faces, they   have to be specified manually after the triangulation is created.     This function will fail if the input Triangulation is of type    [2.x.578]  as well as when the input   Triangulation contains hanging nodes.      [2.x.579]  in_tria The base input for a new flat triangulation.    [2.x.580]  out_tria The desired flattened triangulation constructed from   the in_tria.    
*  [2.x.581]  Since  [2.x.582]  and  [2.x.583]  have different spatial dimensions no   manifold objects are copied by this function: you must attach new   manifold objects to  [2.x.584]   
* [0.x.55]*
   Convert a triangulation consisting only of hypercube cells   (quadrilaterals, hexahedra) to a triangulation only consisting of   simplices (triangles, tetrahedra).     As an example, the following image shows how a set of three hexahedra   meshing one eighths of a sphere are subdivided into tetrahedra, and how   the curved surface is taken into account. Colors indicate how boundary   indicators are inherited:    [2.x.585]      In general, each quadrilateral in 2d is subdivided into eight triangles,   and each hexahedron in 3d into 24 tetrahedra as shown here:    [2.x.586]      Material ID and boundary IDs are inherited upon conversion.      [2.x.587]  in_tria The triangulation containing hex elements.    [2.x.588]  out_tria The converted triangulation containing tet elements.    
*  [2.x.589]  No manifold objects are copied by this function: you must     copy existing manifold objects from  [2.x.590]  to  [2.x.591]  e.g.,     with the following code:  
* [1.x.24]
*   
* [0.x.56]*
   Specialization of the above function for 1D: simply copy triangulation.  
* [0.x.57]*
   Namespace Airfoil contains classes and functions in order to create a   C-type mesh for the (flow) field around Joukowski or NACA airfoils.    
*  [2.x.592]   
* [0.x.58]*
     AdditionalData collects all settings that are required to generate a     airfoil triangulation with the functions  [2.x.593]     
* [0.x.59]*
       Type of the airfoil: either "NACA" or "Joukowksi" to choose airfoil       geometry among NACA and Joukowski airfoil.      
* [0.x.60]*
       NACA serial number defining the airfoil shape.            
*  [2.x.594]  Currently serial numbers with length 4 are supported.       A good overview of NACA serial numbers is presented in Wikipedia       (https://en.wikipedia.org/wiki/NACA_airfoil)      
* [0.x.61]*
       Center of Joukowski circle.            
*  [2.x.595]  A center on the x-axis leads to a symmetrical airfoil.      
* [0.x.62]*
       Chord length of the airfoil, i.e. distance from leading to trailing       edge.      
* [0.x.63]*
       Vertical distance from airfoil chord to upper boundary of the mesh       i.e. half of the total mesh height.      
* [0.x.64]*
       Length of mesh from the airfoil trailing edge to outflow boundary.      
* [0.x.65]*
       Factor defining the inclination HG of the coarse grid       The figure shows the upper coarse grid with two different inclinations
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - incline_factor = 0
* 

* 
* 

* 
* 
*  - > face HG
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - incline_factor = 0.5
* 
*  - > face HG'       Coordinate of point G' is defined by incline_factor after interpolation       G'(0) = G(0) + incline_factor (K(0)
* 
*  - G(0))       with incline_factor in [0,1).                          o-----G---G'--K                 /  |     |  /    |               /    o     | /     |             /    /    \  |/      |           o----o         H-------o      
* [0.x.66]*
       Factor to receive a finer mesh around the airfoil by increasing       bias_factor b.       Bias function: f(x) = tanh(bx) / tanh(x) with x in [0,1], leads to a       compression of values close to x = 1.      
* [0.x.67]*
       Number of global refinements.      
* [0.x.68]*
       Number of subdivisions along the airfoil in left block.      
* [0.x.69]*
       Number of subdivisions along the airfoil in middle block.      
* [0.x.70]*
       Number of subdivisions in block right of the airfoil.      
* [0.x.71]*
       Number of subdivisions normal to the airfoil contour.      
* [0.x.72]*
       Factor to enhance the approximation of the airfoil geometry that       happens when interpolating provided nonequidistant airfoil points to       equidistant airfoil points. When generating the required vector       consisting the equidistant airfoil points, it is interpolated between       nonequidistand airfoil points.       Increasing the provided nonequidistant airfoil points leads to       a better approximation of the airfoil geometry. Parameter       "airfoil_sampling_factor" thereby defines the relation of       provided_nonequidistant_points to required_equidistant_points.      
* [0.x.73]*
       Constructor.      
* [0.x.74]*
       This function adds the ParameterHandler entries.              [2.x.596]  prm Parameter handler.      
* [0.x.75]*
     Initialize the given triangulation with a flow field around an airfoil,     i.e., a mesh of C-Type approximating Joukowski or NACA (4 digit)     airfoils.         The user can specify the airfoil geometry and the mesh setup by providing     input parameters for the struct AdditionalData.     Thereby, the user can choose among different types of Joukowski or NACA     airfoils with variable chord length, far field size and mesh density.        
*  [2.x.597]  This function creates a refined mesh (number of global refinements           can be specified by the user). No manifold is attached. The           vertices in the final mesh are moved by this function to the           right position.        
*  [2.x.598]  This function is currently only implemented for 2D but the mesh           can of course be extruded into the third dimension using            [2.x.599]           [2.x.600]  tria The triangulation to be created. It needs to be empty                 upon calling this function.      [2.x.601]  additional_data Configuration of the mesh.         \htmlonly <style>div.image         img[src="https://www.dealii.org/images/grids/airfoils_naca_joukowski.png"]{width:50%;}</style>     \endhtmlonly      [2.x.602]     
* [0.x.76]*
     The same as above but periodic boundary conditions on the     upper and lower faces of the far field are applied.        
*  [2.x.603]  This function is currently only implemented for 2D.          [2.x.604]  tria The triangulation to be created. It needs to be empty     upon calling this function.      [2.x.605]  periodic_faces Periodic faces at upper and lower horizontal                           boundaries.      [2.x.606]  additional_data Configuration of the mesh.    
* [0.x.77]*
   Create a coordinate-parallel brick from the two diagonally opposite   corner points  [2.x.607]  and  [2.x.608]  The number of vertices in coordinate   direction  [2.x.609]  is given by <tt>repetitions[i]+1</tt>.    
*  [2.x.610]  This function connects internally 4/8 vertices to     quadrilateral/hexahedral cells and subdivides these into 2/5   triangular/tetrahedral cells.    
*  [2.x.611]  Currently, this function only works for `dim==spacedim`.    
*  [2.x.612]   
* [0.x.78]*
   Initialize the given triangulation with a hypercube (square in 2D and   cube in 3D) consisting of  [2.x.613]  cells in each direction.   The hypercube volume is the tensor product interval    [2.x.614]  in the present number of dimensions, where   the limits are given as arguments. They default to zero and unity, then   producing the unit hypercube.    
*  [2.x.615]  This function connects internally 4/8 vertices to   quadrilateral/hexahedral cells and subdivides these into 2/5   triangular/tetrahedral cells.    
*  [2.x.616]   
* [0.x.79]*
    [2.x.617]  Creating lower-dimensional meshes     Created from parts of higher-dimensional meshes.  
* [0.x.80]*
   This function implements a boundary subgrid extraction.  Given a   <dim,spacedim>-Triangulation (the "volume mesh") the function extracts a   subset of its boundary (the "surface mesh").  The boundary to be   extracted is specified by a list of boundary_ids.  If none is specified   the whole boundary will be extracted. The function is used in  [2.x.618] .     The function also builds a mapping linking the cells on the surface mesh   to the corresponding faces on the volume one. This mapping is the return   value of the function.    
*  [2.x.619]  The function builds the surface mesh by creating a    [2.x.620]  "coarse mesh"   from   the selected faces of the coarse cells of the volume mesh. It copies the   boundary indicators of these faces to the cells of the coarse surface   mesh. The surface mesh is then refined in the same way as the faces of   the volume mesh are. In order to ensure that the surface mesh has the   same vertices as the volume mesh, it is therefore important that you   assign appropriate boundary descriptions through    [2.x.621]  to the surface mesh object before calling   this function. If you don't, the refinement will happen under the   assumption that all faces are straight (i.e using the FlatManifold class)   rather than utilizing the Manifold object you may want to use to determine   the location of new vertices.      [2.x.622]  MeshType A type that satisfies the requirements of the    [2.x.623]  "MeshType concept".   The map that is returned will be between cell iterators pointing into the   container describing the surface mesh and face iterators of the volume   mesh container. If MeshType is DoFHandler, then the function will re-build   the triangulation underlying the second argument and return a map between   appropriate iterators into the MeshType arguments. However, the function   will not actually distribute degrees of freedom on this newly created   surface mesh.      [2.x.624]  dim The dimension of the cells of the volume mesh. For example,   if dim==2, then the cells are quadrilaterals that either live in the   plane, or form a surface in a higher-dimensional space. The dimension of   the cells of the surface mesh is consequently dim-1.    [2.x.625]  spacedim The dimension of the space in which both the volume and   the surface mesh live.      [2.x.626]  volume_mesh A container of cells that define the volume mesh.    [2.x.627]  surface_mesh A container whose associated triangulation will   be built to consist of the cells that correspond to the (selected portion   of) the boundary of the volume mesh.    [2.x.628]  boundary_ids A list of boundary indicators denoting that   subset of faces of volume cells for which this function should extract   the surface mesh. If left at its default, i.e., if the set is empty, then   the function operates on [1.x.25] boundary faces.      [2.x.629]  A map that for each cell of the surface mesh (key) returns an   iterator to the corresponding face of a cell of the volume mesh (value).   The keys include both active and non-active cells of the surface mesh.   The order of vertices of surface cells and the corresponding   volume faces may not match in order to ensure that each surface cell is   associated with an outward facing normal.   As a consequence, if you want to match quantities on the faces of the   domain cells and on the cells of the surface mesh, you may have to   translate between vertex locations or quadrature points.    
*  [2.x.630]  The algorithm outlined above assumes that all faces on higher   refinement levels always have exactly the same boundary indicator as   their parent face. Consequently, we can start with coarse level faces and   build the surface mesh based on that. It would not be very difficult to   extend the function to also copy boundary indicators from finer level   faces to their corresponding surface mesh cells, for example to   accommodate different geometry descriptions in the case of curved   boundaries (but this is not currently implemented).    
*  [2.x.631]  Since  [2.x.632]  and  [2.x.633]  have different spatial   dimensions no manifold objects are copied by this function: you must   attach new manifold objects to  [2.x.634]   
* [0.x.81]*
    [2.x.635]  Exceptions  
* [0.x.82]*
   Exception  
* [0.x.83]*
   Exception  
* [0.x.84]*
   Exception  
* [0.x.85]*
   Exception for input that is not properly oriented.  
* [0.x.86]

include/deal.II-translator/grid/grid_in_0.txt
[0.x.0]*
 This class implements an input mechanism for grid data. It allows to read a grid structure into a triangulation object. At present, UCD (unstructured cell data), DB Mesh, XDA, %Gmsh, Tecplot, UNV, VTK, ASSIMP, and Cubit are supported as input format for grid data. Any numerical data other than geometric (vertex locations) and topological (how vertices form cells, faces, and edges) information is ignored, but the readers for the various formats generally do read information that associates material ids or boundary ids to cells or faces (see  [2.x.0]  "this" and  [2.x.1]  "this" glossary entry for more information).
* 

* 
*  [2.x.2]  Since deal.II only supports line, quadrilateral and hexahedral meshes, the functions in this class can only read meshes that consist exclusively of such cells. If you absolutely need to work with a mesh that uses triangles or tetrahedra, then your only option is to convert the mesh to quadrilaterals and hexahedra. A tool that can do this is tethex, available [1.x.0].
*  The mesh you read will form the coarsest level of a  [2.x.3]  object. As such, it must not contain hanging nodes or other forms of adaptive refinement, or strange things will happen if the mesh represented by the input file does in fact have them. This is due to the fact that most mesh description formats do not store neighborship information between cells, so the grid reading functions have to regenerate it. They do so by checking whether two cells have a common face. If there are hanging nodes in a triangulation, adjacent cells have no common (complete) face, so the grid reader concludes that the adjacent cells have no neighbors along these faces and must therefore be at the boundary. In effect, an internal crack of the domain is introduced this way. Since such cases are very hard to detect (how is GridIn supposed to decide whether a place where the faces of two small cells coincide with the face or a larger cell is in fact a hanging node associated with local refinement, or is indeed meant to be a crack in the domain?), the library does not make any attempt to catch such situations, and you will get a triangulation that probably does not do what you want. If your goal is to save and later read again a triangulation that has been adaptively refined, then this class is not your solution; rather take a look at the PersistentTriangulation class.
*  To read grid data, the triangulation to be filled has to be empty. Upon calling the functions of this class, the input file may contain only lines in one dimension; lines and quads in two dimensions; and lines, quads, and hexes in three dimensions. All other cell types (e.g. triangles in two dimensions, triangles or tetrahedra in 3d) are rejected.  (Here, the "dimension" refers to the dimensionality of the mesh; it may be embedded in a higher dimensional space, such as a mesh on the two-dimensional surface of the sphere embedded in 3d, or a 1d mesh that discretizes a line in 3d.) The result will be a triangulation that consists of the cells described in the input file, and to the degree possible with material indicators and boundary indicators correctly set as described in the input file.
* 

* 
*  [2.x.4]  You can not expect vertex and cell numbers in the triangulation to match those in the input file. (This is already clear based on the fact that we number cells and vertices separately, whereas this is not the case for some input file formats; some formats also do not require consecutive numbering, or start numbering at indices other than zero.)
* 

*  [1.x.1]
*  At present, the following input formats are supported:  [2.x.5]   [2.x.6]   [2.x.7]  (unstructured cell data) format: this format is used for grid input as well as data output. If there are data vectors in the input file, they are ignored, as we are only interested in the grid in this class. The UCD format requires the vertices to be in following ordering: in 2d

* 
* [1.x.2]
*  and in 3d

* 
* [1.x.3]
*  Note, that this ordering is different from the deal.II numbering scheme, see the Triangulation class.  The exact description of the UCD format can be found in the AVS Explorer manual (see http://www.avs.com).  The  [2.x.8]  format can be read by the read_ucd() function.
*   [2.x.9]  <tt>DB mesh</tt> format: this format is used by the  [2.x.10]  mesh generator (see http://www-rocq.inria.fr/gamma/cdrom/www/bamg/eng.htm. The documentation of the format in the  [2.x.11]  manual is very incomplete, so we don't actually parse many of the fields of the output since we don't know their meaning, but the data that is read is enough to build up the mesh as intended by the mesh generator. This format can be read by the read_dbmesh() function.
*   [2.x.12]   [2.x.13]  format: this is a rather simple format used by the MGF code. We don't have an exact specification of the format, but the reader can read in several example files. If the reader does not grok your files, it should be fairly simple to extend it.
*   [2.x.14]  <tt>%Gmsh 1.0 mesh</tt> format: this format is used by the  [2.x.15]  mesh generator (see http://gmsh.info/). The documentation in the  [2.x.16]  manual explains how to generate meshes compatible with the deal.II library (i.e. quads rather than triangles). In order to use this format, %Gmsh has to output the file in the old format 1.0. This is done adding the line "Mesh.MshFileVersion = 1" to the input file.
*   [2.x.17]  <tt>%Gmsh 2.0 mesh</tt> format: this is a variant of the above format. The read_msh() function automatically determines whether an input file is version 1 or version 2.
*   [2.x.18]  <tt>Tecplot</tt> format: this format is used by  [2.x.19]  and often serves as a basis for data exchange between different applications. Note, that currently only the ASCII format is supported, binary data cannot be read.
*   [2.x.20]  <tt>UNV</tt> format: this format is generated by the Salome mesh generator, see http://www.salome-platform.org/ . The sections of the format that the  [2.x.21]  function supports are documented here:  [2.x.22]   [2.x.23]  section 2411: http://www.sdrl.uc.edu/sdrl/referenceinfo/universalfileformats/file-format-storehouse/universal-dataset-number-2411  [2.x.24]  section 2412: http://www.sdrl.uc.edu/sdrl/referenceinfo/universalfileformats/file-format-storehouse/universal-dataset-number-2412  [2.x.25]  section 2467: http://www.sdrl.uc.edu/sdrl/referenceinfo/universalfileformats/file-format-storehouse/universal-dataset-number-2467  [2.x.26]  all sections of this format, even if they may not be supported in our reader, can be found here: http://www.sdrl.uc.edu/sdrl/referenceinfo/universalfileformats/file-format-storehouse  [2.x.27]  Note that Salome, let's say in 2D, can only make a quad mesh on an object that has exactly 4 edges (or 4 pieces of the boundary). That means, that if you have a more complicated object and would like to mesh it with quads, you will need to decompose the object into >= 2 separate objects. Then 1) each of these separate objects is meshed, 2) the appropriate groups of cells and/or faces associated with each of these separate objects are created, 3) a compound mesh is built up, and 4) all numbers that might be associated with some of the internal faces of this compound mesh are removed.
*   [2.x.28]  <tt>VTK</tt> format: VTK Unstructured Grid Legacy file reader generator. The reader can handle only Unstructured Grid format of data at present for 2D & 3D geometries. The documentation for the general legacy vtk file, including Unstructured Grid format can be found here: http://www.cacr.caltech.edu/~slombey/asci/vtk/vtk_formats.simple.html
*  The VTK format requires the vertices to be in following ordering: in 2d

* 
* [1.x.4]
*  and in 3d

* 
* [1.x.5]
* 
* 

*   [2.x.29]  <tt>Cubit</tt> format: deal.II doesn't directly support importing from Cubit at this time. However, Cubit can export in UCD format using a simple plug-in, and the resulting UCD file can then be read by this class. The plug-in script can be found on the deal.II wiki page under [1.x.6].
*  Alternatively, Cubit can generate ABAQUS files that can be read in via the read_abaqus() function. This may be a better option for geometries with complex boundary condition surfaces and multiple materials
* 
*  - information which is currently not easily obtained through Cubit's python interface.
*   [2.x.30] 
*  [1.x.7]
*  It is your duty to use a correct numbering of vertices in the cell list, i.e. for lines in 1d, you have to first give the vertex with the lower coordinate value, then that with the higher coordinate value. For quadrilaterals in two dimensions, the vertex indices in the  [2.x.31]  list have to be such that the vertices are numbered in counter-clockwise sense.
*  In two dimensions, another difficulty occurs, which has to do with the sense of a quadrilateral. A quad consists of four lines which have a direction, which is by definition as follows:

* 
* [1.x.8]
*  Now, two adjacent cells must have a vertex numbering such that the direction of the common side is the same. For example, the following two quads

* 
* [1.x.9]
*  may be characterised by the vertex numbers <tt>(0 1 4 3)</tt> and <tt>(1 2 5 4)</tt>, since the middle line would get the direction <tt>1->4</tt> when viewed from both cells.  The numbering <tt>(0 1 4 3)</tt> and <tt>(5 4 1 2)</tt> would not be allowed, since the left quad would give the common line the direction <tt>1->4</tt>, while the right one would want to use <tt>4->1</tt>, leading to an ambiguity. The Triangulation object is capable of detecting this special case, which can be eliminated by rotating the indices of the right quad by two. However, it would not know what to do if you gave the vertex indices <tt>(4 1 2 5)</tt>, since then it would have to rotate by one element or three, the decision which to take is not yet implemented.
*  There are more ambiguous cases, where the triangulation may not know what to do at all without the use of sophisticated algorithms. Furthermore, similar problems exist in three space dimensions, where faces and lines have orientations that need to be taken care of.
*  For this reason, the <tt>read_*</tt> functions of this class that read in grids in various input formats call the GridReordering class to bring the order of vertices that define the cells into an ordering that satisfies the requirements of the Triangulation class. Be sure to read the documentation of that class if you experience unexpected problems when reading grids through this class.
* 

*  [1.x.10]
*  For each of the mesh reading functions, the last call is always to  [2.x.32]  That function checks whether all the cells it creates as part of the coarse mesh are distorted or not (where distortion here means that the Jacobian of the mapping from the reference cell to the real cell has a non-positive determinant, i.e. the cell is pinched or twisted; see the entry on  [2.x.33]  "distorted cells" in the glossary). If it finds any such cells, it throws an exception. This exception is not caught in the grid reader functions of the current class, and so will propagate through to the function that called it. There, you can catch and ignore the exception if you are certain that there is no harm in dealing with such cells. If you were not aware that your mesh had such cells, your results will likely be of dubious quality at best if you ignore the exception.
* 

* 

* 
*  [2.x.34] 

* 
*  [2.x.35]  Pelteret 2015, Timo Heister 2015,  Krzysztof Bzowski, 2015

* 
* [0.x.1]*
   List of possible mesh input formats. These values are used when calling   the function read() in order to determine the actual reader to be called.  
* [0.x.2]*
   Constructor.  
* [0.x.3]*
   Constructor. Attach this triangulation to be fed with the grid data.  
* [0.x.4]*
   Attach this triangulation to be fed with the grid data.  
* [0.x.5]*
   Read from the given stream. If no format is given,    [2.x.36]  is used.  
* [0.x.6]*
   Open the file given by the string and call the previous function read().   This function uses the PathSearch mechanism to find files. The file class   used is  [2.x.37] .  
* [0.x.7]*
   Read grid data from a unstructured vtk file. The vtk file may contain   the following VTK cell types: VTK_HEXAHEDRON (12), VTK_TETRA (10),   VTK_QUAD (9), VTK_TRIANGLE (5), and VTK_LINE (3).     Depending on the template dimension, only some of the above are accepted.     In particular, in three dimensions, this function expects the file to   contain
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - VTK_HEXAHEDRON/VTK_TETRA cell types
* 

* 
* 

* 
* 

* 
* 
*  - VTK_QUAD/VTK_TRIANGLE cell types, to specify optional boundary or     interior quad faces
* 

* 
* 

* 
* 

* 
* 
*  - VTK_LINE cell types, to specify optional boundary or interior edges     In two dimensions:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - VTK_QUAD/VTK_TRIANGLE cell types
* 

* 
* 

* 
* 

* 
* 
*  - VTK_LINE cell types, to specify optional boundary or interior edges     In one dimension
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - VTK_LINE cell types     The input file may specify boundary ids, material ids, and manifold ids   using the CELL_DATA section of the   [VTK file format](http://www.vtk.org/VTK/img/file-formats.pdf).     This function interprets two types of CELL_DATA contained in the input   file: `SCALARS MaterialID`, used to specify the material_id of the cells,   or the boundary_id of the faces and edges, and `SCALARS ManifoldID`, that   can be used to specify the manifold id of any Triangulation object (cell,   face, or edge).     The companion  [2.x.38]  function can be used to write VTK files   compatible with this method.    
*  [2.x.39]   
* [0.x.8]*
   Read grid data from a unstructured vtu file, saved by deal.II using    [2.x.40]  with the flag    [2.x.41]  set to true.     Notice that this function does not support reading in arbitrary vtu files,   but only files that were written by deal.II itself, using the function    [2.x.42]  and setting  [2.x.43]    to true.     When this flag is set to true, the generated vtu file contains the   triangulation in a xml section which is ignored by general vtu readers.   If this section is absent, an exception is thrown.  
* [0.x.9]*
   Read grid data from an unv file as generated by the Salome mesh   generator. Numerical data is ignored.     Note the comments on generating this file format in the general   documentation of this class.  
* [0.x.10]*
   Read grid data from an ucd file. Numerical data is ignored.   It is not possible to use a ucd file to set both boundary_id and   manifold_id for the same cell. Yet it is possible to use   the flag apply_all_indicators_to_manifolds to decide if   the indicators in the file refer to manifolds (flag set to true)   or boundaries (flag set to false). If the flag is set, the   indicators are used for cells as manifold id, too.  
* [0.x.11]*
   Read grid data from an Abaqus file. Numerical and constitutive data is   ignored. As in the case of the ucd file format, it is possible to use   the flag apply_all_indicators_to_manifolds to decide if   the indicators in the file refer to manifolds (flag set to true)   or boundaries (flag set to false).    
*  [2.x.44]  The current implementation of this mesh reader is suboptimal, and   may therefore be slow for large meshes.    
*  [2.x.45]  Usage tips for Cubit:
* 

* 
* 

* 
* 

* 
* 
*  - Multiple material-id's can be defined in the mesh.   This is done by specifying blocksets in the pre-processor.
* 

* 
* 

* 
* 

* 
* 
*  - Arbitrary surface boundaries can be defined in the mesh.   This is done by specifying sidesets in the pre-processor. In particular,   boundaries are not confined to just surfaces (in 3d) individual element   faces can be added to the sideset as well. This is useful when a boundary   condition is to be applied on a complex shape boundary that is difficult   to define using "surfaces" alone. Similar can be done in 2d.    
*  [2.x.46]  Compatibility information for this file format is listed below.
* 

* 
* 

* 
* 

* 
* 
*  - Files generated in Abaqus CAE 6.12 have been verified to be   correctly imported, but older (or newer) versions of Abaqus may also   generate valid input decks.
* 

* 
* 

* 
* 

* 
* 
*  - Files generated using Cubit 11.x, 12.x, 13.x, 14.x and 15.x are valid,   but only when using a specific set of export steps. These are as follows:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Go to "Analysis setup mode" by clicking on the disc icon in the   toolbar on the right.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Select "Export Mesh" under "Operation" by clicking on the   necessary icon in the toolbar on the right.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Select an output file. In Cubit version 11.0 and 12.0 it might be   necessary to click on the browse button and type it in the dialogue that   pops up.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Select the dimension to output in.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Tick the overwrite box.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - If using Cubit v12.0 onwards, uncheck the box "Export using Cubit   ID's". An invalid file will encounter errors if this box is left checked.
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Click apply.  
* [0.x.12]*
   Read grid data from a file containing data in the DB mesh format.  
* [0.x.13]*
   Read grid data from a file containing data in the XDA format.  
* [0.x.14]*
   Read grid data from an msh file, either version 1 or version 2 of that   file format. The %Gmsh formats are documented at   http://www.gmsh.info/.    
*  [2.x.47]  The input function of deal.II does not distinguish between newline   and other whitespace. Therefore, deal.II will be able to read files in a   slightly more general format than %Gmsh.    
*  [2.x.48]   
* [0.x.15]*
   Read grid data using Gmsh API. Any file supported by Gmsh can be passed as   argument. The format is deduced from the filename extension.     This function interprets non-named physical ids (gmsh format < 4.0) as   material or boundary ids (similarly to what happens with the other   read_msh() function). If you want to specify non default manifold or   boundary ids, you must group all entities that require a non default   boundary or manifold id into named physical groups, where the name is   interpreted using the function  [2.x.49]  applied to a    [2.x.50]  int>`. The keys can be either `MaterialID` (if the   physical group refers to object of dimension `dim`), `BoundaryID` (if the   group refers to objects of dimension < `dim`), or `ManifoldID`.     From the Gmsh documentation, the formats of the physical tags follows the   following conventions:  
* [1.x.11]
*      For example, the following snippet of mesh file  
* [1.x.12]
*      refers to a two dimensional grid where:
* 

* 
* 

* 
* 

* 
* 
*  - a portion of the boundary of dimension 1 has physical tag 1, and manifold     id 0
* 

* 
* 

* 
* 

* 
* 
*  - some internal faces (lines of dimension 1) have manifold id 1
* 

* 
* 

* 
* 

* 
* 
*  - some elements have manifold id 1 (and material id equal to the default     value, i.e., zero)
* 

* 
* 

* 
* 

* 
* 
*  - some elements have manifold id 1 and material id equal to 2     If the physical groups are not named, then the behaviour is the same as   the other read_msh() function, i.e., the physical tag itself is interpreted   as a boundary or material id.    
*  [2.x.51]   
* [0.x.16]*
   Read grid data from a file containing tecplot ASCII data. This also works   in the absence of any tecplot installation.  
* [0.x.17]*
   Read in a file supported by Assimp, and generate a Triangulation   out of it.  If you specify a  [2.x.52]  only the mesh with   the given index will be extracted, otherwise all meshes which are   present in the file will be used to generate the Triangulation.     This function can only be used to read two-dimensional meshes (possibly   embedded in three dimensions). This is the standard for graphical software   such as blender, or 3D studio max, and that is what the original Assimp   library was built for. We "bend" it to deal.II to support complex   co-dimension one meshes and complex two-dimensional meshes.     If  [2.x.53]  is set to true (the default), then   duplicated vertices will be removed if their distance is lower   than  [2.x.54]      Only the elements compatible with the given dimension and space dimension   will be extracted from the mesh, and only those elements that are   compatible with deal.II are supported. If you set   `ignore_unsupported_element_types`, all the other element types are simply   ignored by this algorithm. If your mesh contains a mixture of triangles   and quadrilaterals, for example, only the quadrilaterals will be   extracted. The resulting mesh (as represented in the Triangulation object)   may not make any sense if you are mixing compatible and incompatible   element types. If `ignore_unsupported_element_types` is set to `false`,   then an exception is thrown when an unsupported type is encountered.      [2.x.55]  filename The file to read from    [2.x.56]  mesh_index Index of the mesh within the file    [2.x.57]  remove_duplicates Remove duplicated vertices    [2.x.58]  tol Tolerance to use when removing vertices    [2.x.59]  ignore_unsupported_element_types Don't throw exceptions if we          encounter unsupported types during parsing  
* [0.x.18]*
   A structure containing some of the information provided by ExodusII that   doesn't have a direct representation in the Triangulation object.    
*  [2.x.60]  This struct exists to enable forward compatibility with future   versions of read_exodusii that may provide additional output data, but for   now it has a single field.  
* [0.x.19]*
     A vector containing a mapping from deal.II boundary ids (or manifold ids)     to the provided ExodusII sideset ids.    
* [0.x.20]*
   Read in a mesh stored in the ExodusII file format.     ExodusII is a feature-rich file format that supports many more features   (like node sets, finite element fields, quality assurance data, and more)   than most other grid formats supported by this class. Many of these   features do not have equivalent representations in deal.II and are   therefore not supported (for example, deal.II does not assign degrees of   freedom directly to nodes, so data stored in a nodal format is not loaded   by this function). At the current time only the following information is   extracted from the input file:      [2.x.61]       [2.x.62] Block ids: the block id of an element is loaded as its material       id. [2.x.63]       [2.x.64] Elements and vertices: the core geometric information stored in the       ExodusII file populates the attached Triangulation object. Higher-order       elements are automatically truncated to lower-order elements since       deal.II does not support this feature (e.g., there is no equivalent to       the  [2.x.65]  element in deal.II since all quadrilaterals have       four vertices and additional geometric information is either stored in       a Manifold or something like MappingQEulerian). [2.x.66]       [2.x.67] Sideset ids: these are interpreted as boundary ids or manifold ids       (see the note on the output value below). An error will occur if you       attempt to read an ExodusII file that assigns a sideset id to an       internal face boundary id. [2.x.68]     [2.x.69]      Sideset ids are not translated for Triangulations with nonzero codimension   since those Triangulations do not support the setting of boundary ids.      [2.x.70]  filename The name of the file to read from.      [2.x.71]  apply_all_indicators_to_manifolds Boolean determining if the sideset   ids should be interpreted as manifold ids or boundary ids. The default   value is <tt>false</tt>, i.e., treat all sideset ids as boundary ids. If   your mesh sets sideset ids on internal faces then it will be necessary to   set this argument to  [2.x.72]  and then do some postprocessing to   set the boundary ids correctly.      [2.x.73]  This function returns a struct containing some extra data stored by   the ExodusII file that cannot be loaded into a Triangulation
* 
*  - see   ExodusIIData for more information.     A cell face in ExodusII can be in an arbitrary number of sidesets (i.e., it   can have an arbitrary number of sideset ids)
* 
*  - however, a boundary cell   face in deal.II has exactly one boundary id. All boundary faces that are   not in a sideset are given the (default) boundary id of  [2.x.74] . This function   then groups sidesets together into unique sets and gives each one a   boundary id. For example: Consider a single-quadrilateral mesh whose left   side has no sideset id, right side has sideset ids  [2.x.75]  and  [2.x.76] , and whose   bottom and top sides have sideset ids of  [2.x.77] . The left face will have a   boundary id of  [2.x.78] , the top and bottom faces boundary ids of  [2.x.79] , and the   right face a boundary id of  [2.x.80] . Hence the vector returned by this function   in that case will be  [2.x.81] .  
* [0.x.21]*
   Return the standard suffix for a file in this format.  
* [0.x.22]*
   Return the enum Format for the format name.  
* [0.x.23]*
   Return a list of implemented input formats. The different names are   separated by vertical bar signs (<tt>`|'</tt>) as used by the   ParameterHandler classes.  
* [0.x.24]*
   Exception  
* [0.x.25]*
   Exception  
* [0.x.26]*
   Exception  
* [0.x.27]*
   Exception  
* [0.x.28]*
   Exception  
* [0.x.29]*
   Exception  
* [0.x.30]*
   Exception  
* [0.x.31]*
   Exception  
* [0.x.32]*
   Exception  
* [0.x.33]*
   Store address of the triangulation to be fed with the data read in.  
* [0.x.34]*
   This function can write the raw cell data objects created by the   <tt>read_*</tt> functions in Gnuplot format to a stream. This is   sometimes handy if one would like to see what actually was created, if it   is known that the data is not correct in some way, but the Triangulation   class refuses to generate a triangulation because of these errors. In   particular, the output of this class writes out the cell numbers along   with the direction of the faces of each cell. In particular the latter   information is needed to verify whether the cell data objects follow the   requirements of the ordering of cells and their faces, i.e. that all   faces need to have unique directions and specified orientations with   respect to neighboring cells (see the documentations to this class and   the GridReordering class).     The output of this function consists of vectors for each line bounding   the cells indicating the direction it has with respect to the orientation   of this cell, and the cell number. The whole output is in a form such   that it can be read in by Gnuplot and generate the full plot without   further ado by the user.  
* [0.x.35]*
   Skip empty lines in the input stream, i.e. lines that contain either   nothing or only whitespace.  
* [0.x.36]*
   Skip lines of comment that start with the indicated character (e.g.   <tt>#</tt>) following the point where the given input stream presently   is. After the call to this function, the stream is at the start of the   first line after the comment lines, or at the same position as before if   there were no lines of comments.  
* [0.x.37]*
   This function does the nasty work (due to very lax conventions and   different versions of the tecplot format) of extracting the important   parameters from a tecplot header, contained in the string  [2.x.82]  The   other variables are output variables, their value has no influence on the   function execution..  
* [0.x.38]*
   Input format used by read() if no format is given.  
* [0.x.39]

include/deal.II-translator/grid/grid_out_0.txt
[0.x.0]*
 Within this namespace, we define several structures that are used to describe flags that can be given to grid output routines to modify the default outfit of the grids written into a file. See the different subclasses and the documentation of the GridOut class for more details.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Flags for grid output in OpenDX format.    
*  [2.x.1]   
* [0.x.2]*
     Write cells.    
* [0.x.3]*
     Write faces.    
* [0.x.4]*
     Write field with diameters.    
* [0.x.5]*
     Write field with area/volume.    
* [0.x.6]*
     Write all faces, including interior faces. If <tt>false</tt>, only     boundary faces are written.    
* [0.x.7]*
     Constructor.    
* [0.x.8]*
     Declare parameters in ParameterHandler.    
* [0.x.9]*
     Parse parameters of ParameterHandler.    
* [0.x.10]*
   Flags describing the details of output in MSH format.    
*  [2.x.2]   
* [0.x.11]*
     When writing a mesh, write boundary faces explicitly if their boundary     indicator is not the default boundary indicator, which is zero.  This     is necessary if you later want to re-read the grid and want to get the     same boundary indicators for the different parts of the boundary of the     triangulation.         It is not necessary if you only want to write the triangulation to view     or print it.         Default:  [2.x.3]     
* [0.x.12]*
     When writing a mesh, write boundary lines explicitly if their boundary     indicator is not the default boundary indicator, which is zero.  This     is necessary if you later want to re-read the grid and want to get the     same boundary indicators for the different parts of the boundary of the     triangulation.         It is not necessary if you only want to write the triangulation to view     or print it.         This is used only if <tt>dim==3</tt>, and ignored in all other cases.         Default:  [2.x.4]     
* [0.x.13]*
     Constructor.    
* [0.x.14]*
     Declare parameters in ParameterHandler.    
* [0.x.15]*
     Parse parameters of ParameterHandler.    
* [0.x.16]*
   Flags describing the details of output in UCD format.    
*  [2.x.5]   
* [0.x.17]*
     Write a comment at the beginning of the file stating the date of     creation and some other data.  While this is supported by the UCD     format (and the AVS program), some other programs get confused by this,     so the default is to not write a preamble. However, a preamble can be     written using this flag.         Default:  [2.x.6] .    
* [0.x.18]*
     When writing a mesh, write boundary faces explicitly if their boundary     indicator is not the default boundary indicator, which is zero.  This     is necessary if you later want to re-read the grid and want to get the     same boundary indicators for the different parts of the boundary of the     triangulation.         It is not necessary if you only want to write the triangulation to view     or print it.         Default:  [2.x.7]     
* [0.x.19]*
     When writing a mesh, write boundary lines explicitly if their boundary     indicator is not the default boundary indicator, which is zero.  This     is necessary if you later want to re-read the grid and want to get the     same boundary indicators for the different parts of the boundary of the     triangulation.         It is not necessary if you only want to write the triangulation to view     or print it.         This directive is ignored if <tt>dim!=3</tt>.         Default:  [2.x.8]     
* [0.x.20]*
     Constructor.    
* [0.x.21]*
     Declare parameters in ParameterHandler.    
* [0.x.22]*
     Parse parameters of ParameterHandler.    
* [0.x.23]*
   Flags describing the details of output in GNUPLOT format.    
*  [2.x.9]   
* [0.x.24]*
     Write the number of each cell into the output file before starting with     the lines it is composed of, as a comment. This might be useful if you     want to find out details about the grid, for example the position of     cells of which you know the number. It enlarges the size of the output     significantly, however.         Default:  [2.x.10]     
* [0.x.25]*
     Number of points,  [2.x.11] excluding [2.x.12]  the vertices, to plot on curved     lines. Since GNUPLOT can only plot straight lines, setting this number     to a value greater than zero (4 or 5 is usually enough for refined     grids) makes the plot look curved even though it is not.    
* [0.x.26]*
     Boolean indicating whether or not interior lines should be plotted with     <tt>n_extra_curved_line_points</tt> line segments.    
* [0.x.27]*
     Flag. If true then, when writing <tt>spacedim = 3</tt> output, write     <tt>2*n_extra_curved_line_points</tt> extra lines on boundary faces.         Setting this option has no effect when <tt>spacedim = 2</tt> since, in     that case, boundary faces are lines and outputting additional lines     does not make sense.        
*  [2.x.13]  This is not yet implemented for the <tt>dim = 2</tt> case. For     backwards compatibility, however, this will not raise a runtime error.    
* [0.x.28]*
     Constructor.    
* [0.x.29]*
     Declare parameters in ParameterHandler.    
* [0.x.30]*
     Parse parameters of ParameterHandler.    
* [0.x.31]*
   Flags describing the details of output for encapsulated postscript.  In   this structure, the flags common to all dimensions are listed. Flags   which are specific to one space dimension only are listed in derived   classes.     By default, the size of the picture is scaled such that the width equals   300 units.    
*  [2.x.14]   
* [0.x.32]*
     Enum denoting the possibilities whether the scaling should be done such     that the given  [2.x.15]  equals the width or the height of the resulting     picture.    
* [0.x.33]*
       Scale with the width.      
* [0.x.34]*
       Scale with the height.      
* [0.x.35]*
     See above. Default is  [2.x.16]     
* [0.x.36]*
     Width or height of the output as given in postscript units This usually     is given by the strange unit 1/72 inch. Whether this is height or width     is specified by the flag  [2.x.17]          Default is 300.    
* [0.x.37]*
     Width of a line in postscript units. Default is 0.5.    
* [0.x.38]*
     Should lines with a set  [2.x.18]  be drawn in a different color     (red)?  See      [2.x.19]      for information about user flags.    
* [0.x.39]*
     The number of points on a boundary face that are plotted in addition to     the vertices of the face.         This number is only used if the mapping used is not simply the standard      [2.x.20]  mapping (i.e., an object of kind MappingQGeneric(1)) that may     describe edges of cells as curved and that will then be approximated     using line segments with a number of intermediate points as described     by the current variable.    
* [0.x.40]*
     Should lines be colored according to their refinement level? This     overrides color_lines_on_user_flag for all levels except level 0.     Colors are: level 0: black, other levels: rainbow scale from blue to     red.    
* [0.x.41]*
     Constructor.    
* [0.x.42]*
     Declare parameters in ParameterHandler.    
* [0.x.43]*
     Parse parameters of ParameterHandler.    
* [0.x.44]*
   Flags describing the details of output for encapsulated postscript for   all dimensions not explicitly specialized below. Some flags that are   common to all dimensions are listed in the base class.     This class does not actually exist, we only here declare the general   template and declare explicit specializations below.    
*  [2.x.21]   
* [0.x.45]*
   Flags specific to the output of grids in one space dimensions.    
*  [2.x.22]   
* [0.x.46]*
     Constructor.    
* [0.x.47]*
     Declare parameters in ParameterHandler.    
* [0.x.48]*
     Parse parameters of ParameterHandler.    
* [0.x.49]*
   Flags specific to the output of grids in two space dimensions.    
*  [2.x.23]   
* [0.x.50]*
     If this flag is set, then we place the number of the cell into the     middle of each cell. The default value is to not do this.         The format of the cell number written is <tt>level.index</tt>, or     simply  [2.x.24]  depending on the value of the following flag.    
* [0.x.51]*
     If the cell numbers shall be written, using the above flag, then the     value of this flag determines whether the format shall be     <tt>level.index</tt>, or simply  [2.x.25]  If  [2.x.26]  the first format     is taken. Default is  [2.x.27]          The flag has obviously no effect if  [2.x.28]  is  [2.x.29]     
* [0.x.52]*
     Vertex numbers can be written onto the vertices. This is controlled by     the following flag. Default is  [2.x.30]     
* [0.x.53]*
     Constructor.    
* [0.x.54]*
     Declare parameters in ParameterHandler.    
* [0.x.55]*
     Parse parameters of ParameterHandler.    
* [0.x.56]*
   Flags specific to the output of grids in three space dimensions.    
*  [2.x.31]   
* [0.x.57]*
     Angle of the line origin-viewer against the z-axis in degrees.         Default is the Gnuplot-default of 60.    
* [0.x.58]*
     Angle by which the viewers position projected onto the x-y-plane is     rotated around the z-axis, in positive sense when viewed from above.     The unit are degrees, and zero equals a position above or below the     negative y-axis.         Default is the Gnuplot-default of 30.    
* [0.x.59]*
     Constructor.    
* [0.x.60]*
     Declare parameters in ParameterHandler.    
* [0.x.61]*
     Parse parameters of ParameterHandler.    
* [0.x.62]*
   Flags for XFig output.    
*  [2.x.32]   
* [0.x.63]*
     Draw boundary lines. Default is true.    
* [0.x.64]*
     An enum used for deciding which field is used for coloring the cells.    
* [0.x.65]*
     Code level to depth. Default is true. If false, color depends on     material or boundary id.         Depth of the object is 900-level, if this value is true.    
* [0.x.66]*
     Additional points for curved boundaries. Default is none.    
* [0.x.67]*
     Scaling of graph. The default is a unit length of one inch.    
* [0.x.68]*
     Offset of the graph. Before scaling, the coordinates are shifted by     this value. Default is zero in each direction.    
* [0.x.69]*
     Style for filling cells. Default is solid fill (20). This value is     forwarded unchanged into the corresponding field <tt>fill_style</tt> of     the polyline object of XFig.    
* [0.x.70]*
     Style for drawing border lines of polygons. Defaults to solid (0) and     is forwarded to XFig.    
* [0.x.71]*
     Thickness of border lines of polygons. Default is 1.         Set this to zero to avoid border lines for very fine meshes.    
* [0.x.72]*
     Style for drawing lines at the boundary. Defaults to solid (0).    
* [0.x.73]*
     Thickness of boundary lines. Default is 3.    
* [0.x.74]*
     Constructor.    
* [0.x.75]*
     Declare parameters in ParameterHandler.    
* [0.x.76]*
     Parse parameters of ParameterHandler.    
* [0.x.77]*
   Flags controlling SVG output.     The figure below is a zoomed-in illustration of what the SVG flags are   capable of producing. These exact settings are the same as those used   in the test  [2.x.33]  with the addition   of the flag  [2.x.34]  .      [2.x.35]     
*  [2.x.36]   
* [0.x.78]*
      Height of the plot in SVG units, computed from width if zero. Defaults      to 1000.    
* [0.x.79]*
      The width of the plot. Computed automatically from height if zero      (default).    
* [0.x.80]*
      Thickness of the lines between cells.    
* [0.x.81]*
     Thickness of lines at the boundary.    
* [0.x.82]*
      Margin around the plotted area.    
* [0.x.83]*
     An `enum` describing all possible background styles.    
* [0.x.84]*
       Use transparent value of SVG.      
* [0.x.85]*
       Use white background.      
* [0.x.86]*
       Use a gradient from white (top) to steelblue (bottom), and add date       and time plus a deal.II logo. Automatically draws a margin.      
* [0.x.87]*
     The style used for the background of the mesh.    
* [0.x.88]*
     The azimuth angle measured from ??? in degrees. Default is 0.    
* [0.x.89]*
     The angle from vertically above the xy-plane. Default is 0.    
* [0.x.90]*
     Cell coloring.    
* [0.x.91]*
     The factor determining the vertical distance between levels (default =     0.3.    
* [0.x.92]*
     Scaling of the font for cell annotations. Defaults to 1.    
* [0.x.93]*
     Write level number into each cell. Defaults to false.    
* [0.x.94]*
     Write cell index into each cell. Defaults to false.    
* [0.x.95]*
     Write material id of each cell. Defaults to false.    
* [0.x.96]*
     Write subdomain id of each cell. Defaults to false.    
* [0.x.97]*
     Write level subdomain id of each cell. Defaults to false.    
* [0.x.98]*
     Write boundary id of each boundary face in a circle on the     corresponding boundary edge. Defaults to false.         Note: Depending on the choice of image viewer, the boundary id     labels may not appear to be centered in the circle.    
* [0.x.99]*
     Draw a colorbar next to the plotted grid with respect to the chosen     coloring of the cells.    
* [0.x.100]*
     Draw a legend next to the plotted grid, explaining the label of the     cells.    
* [0.x.101]*
     Constructor.    
* [0.x.102]*
   Flags for grid output in MathGL format.    
*  [2.x.37]   
* [0.x.103]*
     Constructor.    
* [0.x.104]*
     Draw a bounding box around the graph.    
* [0.x.105]*
     Declare parameters in ParameterHandler.    
* [0.x.106]*
     Parse parameters of ParameterHandler.    
* [0.x.107]*
   Flags for grid output in Vtk format. These flags are the same as those   declared in  [2.x.38]     
*  [2.x.39]   
* [0.x.108]*
     Default constructor.    
* [0.x.109]*
     Output cells.    
* [0.x.110]*
     Output faces.    
* [0.x.111]*
     Output co-faces/edges.    
* [0.x.112]*
     Output only faces/co-faces that differ from the default settings     (e.g boundary_id).    
* [0.x.113]*
   Flags for grid output in Vtu format. These flags are the same as those   declared in  [2.x.40]  with the addition of a flag that   determines if you want to add a entry in the vtu file (which is really   a xml file) containing the entire serialization of the triangulation.    
*  [2.x.41]   
* [0.x.114]*
     Add to the vtu file also the serialized triangulation.    
* [0.x.115]*
 This class provides a means to output a triangulation to a file in different formats. See the enum  [2.x.42]  for a list of formats and the corresponding output function names.
*  Usage is simple: either you use the direct form

* 
* [1.x.0]
*  if you know which format you want to have, or if you want the format to be a runtime parameter, you can write

* 
* [1.x.1]
*  The function <tt>get_output_format_names()</tt> provides a list of possible names of output formats in a string that is understandable by the ParameterHandler class.
*  Note that here, we have created an unnamed object of type GridOut and called one of its <tt>write_*</tt> functions. This looks like as if the respective function could really be made  [2.x.43]  This was not done in order to allow for parameters to be passed to the different output functions in a way compatible with the scheme of allowing the right output format to be selected at run-time through the generic  [2.x.44]  function.
*  In order to explain this, consider each function had one or more additional parameters giving the details of output, for example position of the spectator for 3d meshed, line thicknesses, etc. While this would allow each output function any flexibility it needs, it would not allow us to use the generic function  [2.x.45]  which is given a parameter determining the output format, since it is impractical to give it a list of parameters for each and every output format supported which it may then pass on to the respective output function.
*  Rather, we have chosen to let each object of this class GridOut have a set of parameters for each supported output format. These are collected in structures  [2.x.46]   [2.x.47]  etc declared in the GridOutFlags namespace, and you can set your preferred flags like this:

* 
* [1.x.2]
*  The respective output function then use the so-set flags. By default, they are set to reasonable values as described above and in the documentation of the different flags structures. Resetting the flags can be done by calling <tt>grid_out.set_flags  [2.x.48]  since the default constructor of each of the flags structures sets the parameters to their initial values.
*  The advantage of this approach is that it is possible to change the flags of one or more output formats according to your needs and later use the generic  [2.x.49]  function; the actual output function then called will use the flags as set before.
*  Note that some of the structures describing the flags of the different output formats are empty since the respective format does not support any flags. The structure and the  [2.x.50]  function are provided anyway. Note also that some of the structures may differ between the dimensions supported by this class; they then have a template parameter, as usual.
* 

* 
*  [2.x.51] 

* 
*  [2.x.52] 

* 
* [0.x.116]*
   Declaration of a name for each of the different output formats. These are   used by the generic output function write() to determine the actual   output format.  
* [0.x.117]*
   Constructor.  
* [0.x.118]*
   Write triangulation in OpenDX format.     Cells or faces are written together with their level and their material   id or boundary indicator, resp.     Not implemented for the codimension one case.  
* [0.x.119]*
   Write the triangulation in the gnuplot format.     In GNUPLOT format, each cell is written as a sequence of its confining   lines. Apart from the coordinates of the lines' end points, the level and   the material of the cell are appended to each line of output. Therefore,   if you let GNUPLOT draw a 2d grid as a 3d plot, you will see more refined   cells being raised against cells with less refinement.  Also, if you draw   a cut through a 3d grid, you can extrude the refinement level in the   direction orthogonal to the cut plane. The same can be done with the   material id, which is plotted after the level.     A more useful application of this feature is the following: if you use   the GNUPLOT command (for a 2d grid here)  
* [1.x.3]
*    then the whole x- and y-range will be plotted, i.e. the whole grid, but   only those lines with a z-value between 2.5 and 3.5. Since the z-values   were chosen to be the level to which a cell belongs, this results in a   plot of those cells only that belong to level 3 in this example. This   way, it is easy to produce plots of the different levels of grid.      [2.x.53]  is a pointer to a mapping used for the transformation of cells   at the boundary. If zero, then use standard Q1 mapping.     Names and values of additional flags controlling the output can be found   in the documentation of the  [2.x.54]  class, which also   describes some caveats for the codimension one case.  
* [0.x.120]*
   Write the triangulation in the msh format.     Msh is the format used by %Gmsh and it is described in the %Gmsh user's   guide. Besides the usual output of the grid only, you can decide through   additional flags (see below, and the documentation of the    [2.x.55]  class) whether boundary faces with non-zero boundary   indicator shall be written to the file explicitly. This is useful, if you   want to re-read the grid later on, since <tt>deal.II</tt> sets the   boundary indicator to zero by default; therefore, to obtain the same   triangulation as before, you have to specify faces with differing   boundary indicators explicitly, which is done by this flag.     Names and values of further flags controlling the output can be found in   the documentation of the  [2.x.56]  class.     Works also in the codimension one case.  
* [0.x.121]*
   Write the triangulation in any format supported by gmsh API.     Gmsh API allows writing its output in several formats through their C++   API. This function translates a Triangulation object into a gmsh collection   of entities and calls the  [2.x.57]  method with the filename passed as   argument. This method generates a different entity for each unique pair of   non default manifold id and boundary id, and writes a gmsh physical group   for each unique combination, allowing you to read back the triangulation   using the  [2.x.58]  method that takes a string as argument.     In particular, all cell objects with non default boundary id or non   default manifold id are grouped in a unique physical tag, whose name   contains the boundary and manifold indicators. The names are constructed   using  [2.x.59]  applied to a  [2.x.60]  int>`   where the keys are either `MaterialID`, `BoundaryID`, or `ManifoldID`,   i.e., a cell with material id 1, and manifold id 3 would be grouped in a   physical tag (whose numbering is not specified), named   `MaterialID:1, ManifoldID:3`.     For example, calling the method with a hyper ball grid refined once,   would results in the following physical tags defined in the output file:  
* [1.x.4]
*      The special boundary id `-1` is used to indicate internal boundaries. The   internal boundaries must be specified whenever it is necessary to specify   a non-flat manifold id.  
* [0.x.122]*
   Write the triangulation in the ucd format.     UCD (unstructured cell data) is the format used by AVS and some other   programs. It is described in the AVS developer's guide. Besides the usual   output of the grid only, you can decide through additional flags (see   below, and the documentation of the  [2.x.61]  class) whether   boundary faces with non-zero boundary indicator shall be written to the   file explicitly. This is useful, if you want to re-read the grid later   on, since <tt>deal.II</tt> sets the boundary indicator to zero by   default; therefore, to obtain the same triangulation as before, you have   to specify faces with differing boundary indicators explicitly, which is   done by this flag.     Names and values of further flags controlling the output can be found in   the documentation of the  [2.x.62]  class.     Works also for the codimension one case.  
* [0.x.123]*
   Write the triangulation in the encapsulated postscript format.     In this format, each line of the triangulation is written separately. We   scale the picture such that either x-values or y-values range between   zero and a fixed size. The other axis is scaled by the same factor. Which   axis is taken to compute the scale and the size of the box it shall fit   into is determined by the output flags (see below, and the documentation   of the  [2.x.63]  class).     The bounding box is close to the triangulation on all four sides, without   an extra frame. The line width is chosen to be 0.5 by default, but can be   changed. The line width is to be compared with the extension of the   picture, of which the default is 300.     The flag  [2.x.64]  allows to draw lines with the  [2.x.65]    user_flag set to be drawn in red. The colors black and red are defined as    [2.x.66]  and  [2.x.67]  in the preamble of the output file and can be changed there   according to need.      [2.x.68]  is a pointer to a mapping used for the transformation of cells   at the boundary. If zero, then use standard Q1 mapping.     Names and values of additional flags controlling the output can be found   in the documentation of the  [2.x.69]  class. Especially the   viewpoint for three dimensional grids is of importance here.     Not implemented for the codimension one case.  
* [0.x.124]*
   Write two-dimensional XFig-file.     This function writes all grid cells as polygons and optionally boundary   lines. Several parameters can be adjusted by the XFigFlags control   object.     If levels are coded to depth, the complete grid hierarchy is plotted with   fine cells before their parents. This way, levels can be switched on and   off in xfig by selecting levels.     Polygons are either at depth 900-level or at 900+ [2.x.70]    depending on the flag  [2.x.71]  Accordingly, boundary edges are at   depth 800-level or at 800+ [2.x.72]  Therefore, boundary edges are   always in front of cells.     Not implemented for the codimension one case.  
* [0.x.125]*
   Write the triangulation in the SVG format.     SVG (Scalable Vector Graphics) is an XML-based vector image format   developed and maintained by the World Wide Web Consortium (W3C). This   function conforms to the latest specification SVG 1.1, released on August   16, 2011.     The cells of the triangulation are written as polygons with additional   lines at the boundary of the triangulation. A coloring of the cells is   further possible in order to visualize a certain property of the cells   such as their level or material id. A colorbar can be drawn to encode the   chosen coloring.  Moreover, a cell label can be added, showing level   index, etc. Indeed, by using the set_flags() with an appropriately   generated object of type  [2.x.73]  many aspects of how and   what is being visualized by this function can be customized.    
*  [2.x.74]  This function is currently only implemented for two-dimensional   grids in two space dimensions.  
* [0.x.126]*
   Declaration of the same function as above for all other dimensions and   space dimensions. This function is not currently implemented and is only   declared to exist to support dimension independent programming.  
* [0.x.127]*
   Write triangulation in MathGL script format. To interpret this file a   version of MathGL>=2.0.0 is required.     To get a handle on the resultant MathGL script within a graphical   environment an interpreter is needed. A suggestion to start with is    [2.x.75]    can interpret and display small-to-medium MathGL scripts in a graphical   window and enables conversion to other formats such as EPS, PNG, JPG,   SVG, as well as view/display animations. Some minor editing, such as   modifying the lighting or alpha channels, can also be done.    
*  [2.x.76]  Not implemented for the codimension one case.  
* [0.x.128]*
   Write triangulation in VTK format. This function writes a   UNSTRUCTURED_GRID file, that contains the following VTK cell types:   VTK_HEXAHEDRON, VTK_QUAD, and VTK_LINE, depending on the template   dimension.     In three dimensions, this function writes a file that contains
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - VTK_HEXAHEDRON cell types, containing the cell information of the     Triangulation
* 

* 
* 

* 
* 

* 
* 
*  - VTK_QUAD cell types, containing all boundary faces with non-zero     boundary ids, and all faces with non-flat manifold ids
* 

* 
* 

* 
* 

* 
* 
*  - VTK_LINE cell types, containing all boundary edges with non-zero     boundary ids, and all edges with non-flat manifold ids     In two dimensions:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - VTK_QUAD cell types, containing the cell information of the     Triangulation
* 

* 
* 

* 
* 

* 
* 
*  - VTK_LINE cell types, containing all boundary faces with non-zero     boundary ids, and all faces with non-flat manifold ids     In one dimension
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - VTK_LINE cell types, containing the cell information of the     Triangulation     The output file will contain two CELL_DATA sections, `MaterialID` and   `ManifoldID`, recording for each VTK cell type the material or boundary id,   and the manifold. See the   [VTK file format](http://www.vtk.org/VTK/img/file-formats.pdf)   documentation for an explanation of the generated output.     The companion  [2.x.77]  function can be used to read VTK files   generated with this method.  
* [0.x.129]*
   Write triangulation in VTU format.     Due to the way this function writes data to the output stream,   the resulting output files correspond to a faithful representation   of the mesh in that all cells are visible for visualization. In general,   the data is not in a format that allows reading this file in again   through the GridIn class. This is because every vertex of the mesh is   duplicated as many times as there are adjacent cells. In other words,   every cell has its own, separate set of vertices that are at the   same location as the vertices of other cells, but are separately   numbered.     In order to create a file that can be read with the GridIn class,   the flag  [2.x.78]  must be set to true. In   this case, the generated vtu file will contain the triangulation in a xml   section which is ignored by general vtu readers.  
* [0.x.130]*
   Write triangulation in VTU format for each processor, and add a .pvtu file   for visualization in VisIt or Paraview that describes the collection of VTU   files as all part of the same simulation. The output is in the form   <tt>filename_without_extension.proc000*.vtu</tt> where is   0,1,...,n_proc-1 and <tt>filename_without_extension.pvtu</tt>. The input   <tt>view_levels</tt> can be set as true to view each level of a multilevel   method. The input <tt>include_artificial</tt> can be set as true to view   the artificial cells for each processor. Each .vtu and .pvtu file will have   the attributes subdomain, level_subdomain, level, and proc_writing. The   level value can be used to separate the image into the view of the grid on   each level of a multilevel method and the proc_writing value can be used to   separate the image into each processor's owned and ghost cells. This is   accomplished by applying the "warp by scalar" filter in paraview to each of   the values. After opening the .pvtu file of a mesh where the input   <tt>view_levels</tt> is set to true, select the "warp by scalar"   filter. For the "Scalars" input select <tt>proc_writing</tt> and for the   "Normal" input enter in 1 0 0, then click Apply. Next select the "warp by   scalar" filter again. For the "Scalars" input select <tt>level</tt> and for   the "Normal" input enter in 0 1 0, then click Apply. This will give you the   following image.    [2.x.79]    If the <tt>view_levels</tt> remains at false, thereby only giving the mesh   for the active level, it is enough to separate the image into the views   written by different processors. This is shown in the following image where   the <tt>include_artificial</tt> input is set as true.    [2.x.80]    Note: Depending on the size of the mesh you may need to increase the "Scale   Factor" input so that each piece does not overlap.  
* [0.x.131]*
   Write grid to  [2.x.81]  according to the given data format. This function   simply calls the appropriate <tt>write_*</tt> function.  
* [0.x.132]*
   Write mesh in default format set by ParameterHandler.  
* [0.x.133]*
   Set flags for DX output  
* [0.x.134]*
   Set flags for %Gmsh output  
* [0.x.135]*
   Set flags for UCD output  
* [0.x.136]*
   Set flags for GNUPLOT output  
* [0.x.137]*
   Set flags for EPS output of a one-dimensional triangulation  
* [0.x.138]*
   Set flags for EPS output of a two-dimensional triangulation  
* [0.x.139]*
   Set flags for EPS output of a three-dimensional triangulation  
* [0.x.140]*
   Set flags for EPS output of a three-dimensional triangulation  
* [0.x.141]*
   Set flags for SVG output  
* [0.x.142]*
   Set flags for MathGL output  
* [0.x.143]*
   Set flags for VTK output  
* [0.x.144]*
   Set flags for VTU output  
* [0.x.145]*
   Provide a function that can tell us which suffix a given output format   usually has. For example, it defines the following mappings:    [2.x.82]     [2.x.83]   [2.x.84]  <tt>.dx</tt>    [2.x.85]   [2.x.86]  <tt>.gnuplot</tt>    [2.x.87]   [2.x.88]  <tt>.inp</tt>    [2.x.89]   [2.x.90]  <tt>.eps</tt>.    [2.x.91]    Similar mappings are provided for all implemented formats.     Since this function does not need data from this object, it is static and   can thus be called without creating an object of this class.  
* [0.x.146]*
   Default suffix for the default output format selected through   ParameterHandler.  
* [0.x.147]*
   Return the  [2.x.92]  value corresponding to the given string. If   the string does not match any known format, an exception is thrown.     Since this function does not need data from this object, it is static and   can thus be called without creating an object of this class. Its main   purpose is to allow a program to use any implemented output format   without the need to extend the program's parser each time a new format is   implemented.     To get a list of presently available format names, e.g. to give it to the   ParameterHandler class, use the function get_output_format_names().  
* [0.x.148]*
   Return a list of implemented output formats. The different names are   separated by vertical bar signs (<tt>`|'</tt>) as used by the   ParameterHandler classes.  
* [0.x.149]*
   Declare parameters in ParameterHandler.  
* [0.x.150]*
   Parse parameters of ParameterHandler.  
* [0.x.151]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.152]*
   Exception  
* [0.x.153]*
   The default output format, set by a ParameterHandler.  
* [0.x.154]*
   Flags for OpenDX output.  
* [0.x.155]*
   Flags for %Gmsh output. Can be changed by using the set_flags(const    [2.x.93]  function.  
* [0.x.156]*
   Flags for UCD output. Can be changed by using the set_flags(const    [2.x.94]  function.  
* [0.x.157]*
   Flags to be used upon output of GNUPLOT data. Can be changed by using the   set_flags(const  [2.x.95]  function.  
* [0.x.158]*
   Flags to be used upon output of EPS data in one space dimension. Can be   changed by using the set_flags(const  [2.x.96]  function.  
* [0.x.159]*
   Flags to be used upon output of EPS data in two space dimensions. Can be   changed by using the  [2.x.97]  function.  
* [0.x.160]*
   Flags to be used upon output of EPS data in three space dimensions. Can   be changed by using the  [2.x.98]  function.  
* [0.x.161]*
   Flags used for XFig output.  
* [0.x.162]*
   Flags used for Svg output.  
* [0.x.163]*
   Flags for MathGL output.  
* [0.x.164]*
   Flags for VTK output.  
* [0.x.165]*
   Flags for VTU output.  
* [0.x.166]*
   Write the grid information about faces to  [2.x.99]  Only those faces are   printed which are on the boundary and which have a boundary indicator not   equal to zero, since the latter is the default for boundary faces.     Since, in %Gmsh, geometric elements are continuously numbered, this   function requires a parameter  [2.x.100]  providing the next   geometric element number. This index should have a numerical value equal   to one more than the index previously used to write a geometric element   to  [2.x.101]       [2.x.102]  The next unused geometric element index.      [2.x.103]   [2.x.104]  should be (at least) one larger than the   current number of triangulation elements (lines, cells, faces) that have   been written to  [2.x.105]  %Gmsh will not load the saved file correctly if   there are repeated indices.     This function unfortunately can not be included in the regular  [2.x.106]    write_msh function, since it needs special treatment for the case   <tt>dim==1</tt>, in which case the face iterators are <tt>void*</tt>'s   and lack the member functions which are called. We would not actually   call these functions, but the compiler would complain anyway when   compiling the function for <tt>dim==1</tt>. Bad luck.  
* [0.x.167]*
   Declaration of the specialization of above function for 1d. Does nothing.  
* [0.x.168]*
   Declaration of the specialization of above function for 1d, 2sd. Does   nothing.  
* [0.x.169]*
   Write the grid information about lines to  [2.x.107]  Only those lines are   printed which are on the boundary and which have a boundary indicator not   equal to zero, since the latter is the default for boundary faces.     Since, in %Gmsh, geometric elements are continuously numbered, this   function requires a parameter  [2.x.108]  providing the next   geometric element number. This index should have a numerical value equal   to one more than the index previously used to write a geometric element   to  [2.x.109]       [2.x.110]  The next unused geometric element index.      [2.x.111]   [2.x.112]  should be (at least) one larger than the   current number of triangulation elements (lines, cells, faces) that have   been written to  [2.x.113]  %Gmsh will not load the saved file correctly if   there are repeated indices.     This function unfortunately can not be included in the regular  [2.x.114]    write_msh function, since it needs special treatment for the case   <tt>dim==1</tt> and <tt>dim==2</tt>, in which case the edge iterators are   <tt>void*</tt>'s and lack the member functions which are called. We would   not actually call these functions, but the compiler would complain anyway   when compiling the function for <tt>dim==1/2</tt>. Bad luck.  
* [0.x.170]*
   Declaration of the specialization of above function for 1d. Does nothing.  
* [0.x.171]*
   Declaration of the specialization of above function for 1d, 2sd. Does   nothing.  
* [0.x.172]*
   Declaration of the specialization of above function for 1d, 3sd. Does   nothing.  
* [0.x.173]*
   Declaration of the specialization of above function for 2d. Does nothing.  
* [0.x.174]*
   Declaration of the specialization of above function for 2d, 3sd. Does   nothing.  
* [0.x.175]*
   Write the grid information about faces to  [2.x.115]  Only those faces are   printed which are on the boundary and which have a boundary indicator not   equal to zero, since the latter is the default for boundary faces.     Since (in the UCD format) geometric elements are continuously numbered,   this function requires a parameter  [2.x.116]  providing the   next geometric element number. This index should have a numerical value   equal to one more than the index previously used to write a geometric   element to  [2.x.117]       [2.x.118]  The next unused geometric element index.      [2.x.119]   [2.x.120]  should be (at least) one larger than the   current number of triangulation elements (lines, cells, faces) that have   been written to  [2.x.121]  Visualization programs may not load the saved   file correctly if there are repeated indices.     This function unfortunately can not be included in the regular  [2.x.122]    write_ucd function, since it needs special treatment for the case   <tt>dim==1</tt>, in which case the face iterators are <tt>void*</tt>'s   and lack the member functions which are called. We would not actually   call these functions, but the compiler would complain anyway when   compiling the function for <tt>dim==1</tt>. Bad luck.  
* [0.x.176]*
   Declaration of the specialization of above function for 1d. Does nothing.  
* [0.x.177]*
   Declaration of the specialization of above function for 1d, 2sd. Does   nothing.  
* [0.x.178]*
   Write the grid information about lines to  [2.x.123]  Only those lines are   printed which are on the boundary and which have a boundary indicator not   equal to zero, since the latter is the default for boundary lines.     Since (in the UCD format) geometric elements are continuously numbered,   this function requires a parameter  [2.x.124]  providing the   next geometric element number. This index should have a numerical value   equal to one more than the index previously used to write a geometric   element to  [2.x.125]       [2.x.126]  The next unused geometric element index.      [2.x.127]   [2.x.128]  should be (at least) one larger than the   current number of triangulation elements (lines, cells, faces) that have   been written to  [2.x.129]  Visualization programs may not load the saved   file correctly if there are repeated indices.     This function unfortunately can not be included in the regular  [2.x.130]    write_ucd function, since it needs special treatment for the case   <tt>dim==1/2</tt>, in which case the edge iterators are <tt>void*</tt>'s   and lack the member functions which are called. We would not actually   call these functions, but the compiler would complain anyway when   compiling the function for <tt>dim==1/2</tt>. Bad luck.  
* [0.x.179]*
   Declaration of the specialization of above function for 1d. Does nothing.  
* [0.x.180]*
   Declaration of the specialization of above function for 1d, 2sd. Does   nothing.  
* [0.x.181]*
   Declaration of the specialization of above function for 1d, 3sd. Does   nothing.  
* [0.x.182]*
   Declaration of the specialization of above function for 2d. Does nothing.  
* [0.x.183]*
   Declaration of the specialization of above function for 2d, 3sd. Does   nothing.  
* [0.x.184]*
   Return the number of faces in the triangulation which have a boundary   indicator not equal to zero. Only these faces are explicitly printed in   the <tt>write_*</tt> functions; all faces with indicator    [2.x.131]  are interior ones and an indicator   with value zero for faces at the boundary  are considered default.     This function always returns an empty list in one dimension.     The reason for this function is the same as for write_ucd_faces(). See   there for more information.  
* [0.x.185]*
   Declaration of the specialization of above function for 1d. Simply   returns zero.  
* [0.x.186]*
   Declaration of the specialization of above function for 1d, 2sd. Simply   returns zero.  
* [0.x.187]*
   Declaration of the specialization of above function for 1d, 3sd. Simply   returns zero.  
* [0.x.188]*
   Return the number of lines in the triangulation which have a boundary   indicator not equal to zero. Only these lines are explicitly printed in   the <tt>write_*</tt> functions; all lines with indicator    [2.x.132]  are interior ones and an indicator   with value zero for faces at the boundary are considered default.     This function always returns an empty list in one and two dimensions.     The reason for this function is the same as for write_ucd_faces(). See   there for more information.  
* [0.x.189]*
   Declaration of the specialization of above function for 1d. Simply   returns zero.  
* [0.x.190]*
   Declaration of the specialization of above function for 1d, 2sd. Simply   returns zero.  
* [0.x.191]*
   Declaration of the specialization of above function for 1d, 3sd. Simply   returns zero.  
* [0.x.192]*
   Declaration of the specialization of above function for 2d. Simply   returns zero.  
* [0.x.193]*
   Declaration of the specialization of above function for 2d, 3sd. Simply   returns zero.  
* [0.x.194]

include/deal.II-translator/grid/grid_refinement_0.txt
[0.x.0]*
 This namespace provides a collection of functions that aid in refinement and coarsening of triangulations. Despite the name of the namespace, the functions do not actually [1.x.0] the triangulation, but only [1.x.1]. In other words, they perform the "mark" part of the typical "solve-estimate-mark-refine" cycle of the adaptive finite element loop.
*  The functions in this namespace form two categories. There are the auxiliary functions refine() and coarsen(). More important for users are the other functions, which implement refinement strategies, as being found in the literature on adaptive finite element methods. For mathematical discussion of these methods, consider works by D&ouml;rfler, Morin, Nochetto, Rannacher, Stevenson, and others.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Return a pair of double values of which the first is adjusted refinement   fraction of cells and the second is adjusted coarsening fraction of   cells.        [2.x.1]  current_n_cells The current cell number.      [2.x.2]  max_n_cells The maximal number of cells. If current cell   number  [2.x.3]  is already exceeded maximal cell number  [2.x.4]    max_n_cells, refinement fraction of cells will be set to zero and   coarsening fraction of cells will be adjusted to reduce cell number to @   max_n_cells. If cell number is going to be exceeded only upon refinement,   then refinement and coarsening fractions are going to be adjusted with a   same ratio in an attempt to reach the maximum number of cells. Be aware   though that through proliferation of refinement due to    [2.x.5]  this number is only an indicator. The   default value of this argument is to impose no limit on the number of   cells.      [2.x.6]  top_fraction_of_cells The requested fraction of active   cells to be refined.      [2.x.7]  bottom_fraction_of_cells The requested fraction of   active cells to be coarsened.    
*  [2.x.8]  Usually you do not need to call this function explicitly. Pass  [2.x.9]    max_n_cells to function refine_and_coarsen_fixed_number() or function   refine_and_coarsen_fixed_fraction() and they will call this function if   necessary.  
* [0.x.2]*
   This function provides a strategy to mark cells for refinement and   coarsening with the goal of providing predictable growth in   the size of the mesh by refining a given fraction of all cells.     The function takes a vector of refinement  [2.x.10]  and two values   between zero and one denoting the fractions of cells to be refined and   coarsened. It flags cells for further processing by    [2.x.11]  according to the   following greedy algorithm:      [2.x.12]       [2.x.13]  Sort the cells according to descending values of  [2.x.14]       [2.x.15]  Mark the  [2.x.16]  times    [2.x.17]  active cells with the largest   refinement criteria for refinement.      [2.x.18]  Mark the  [2.x.19]  times    [2.x.20]  active cells with the smallest   refinement criteria for coarsening.      [2.x.21]      As an example, with no coarsening, setting  [2.x.22]  to   1/3 will result in approximately doubling the number of cells in two   dimensions. That is because each of these 1/3 of cells will be replaced by   its four children, resulting in  [2.x.23]  cells, whereas the   remaining 2/3 of cells remains untouched
* 
*  -  thus yielding a total of    [2.x.24]  cells.   The same effect in three dimensions is achieved by refining   1/7th of the cells. These values are therefore frequently used because   they ensure that the cost of computations on subsequent meshes become   expensive sufficiently quickly that the fraction of time spent on   the coarse meshes is not too large. On the other hand, the fractions   are small enough that mesh adaptation does not refine too many cells   in each step.    
*  [2.x.25]  This function only sets the coarsening and refinement flags. The   mesh is not changed until you call    [2.x.26]       [2.x.27]  triangulation The triangulation whose cells this function   is supposed to mark for coarsening and refinement.      [2.x.28]  criteria The refinement criterion for each mesh cell. Entries   may not be negative.      [2.x.29]  top_fraction_of_cells The fraction of cells to be refined. If   this number is zero, no cells will be refined. If it equals one, the   result will be flagging for global refinement.      [2.x.30]  bottom_fraction_of_cells The fraction of cells to be   coarsened. If this number is zero, no cells will be coarsened.      [2.x.31]  max_n_cells This argument can be used to specify a maximal   number of cells. If this number is going to be exceeded upon refinement,   then refinement and coarsening fractions are going to be adjusted in an   attempt to reach the maximum number of cells. Be aware though that   through proliferation of refinement due to  [2.x.32]    this number is only an indicator. The default value of this argument is   to impose no limit on the number of cells.  
* [0.x.3]*
   This function provides a strategy to mark cells for refinement and   coarsening with the goal of controlling the reduction of   the error estimate.     Also known as the [1.x.2] or D&ouml;rfler marking,   this function computes the thresholds for refinement and coarsening   such that the  [2.x.33]  of cells getting flagged for refinement make   up for a certain fraction of the total error. We explain its operation   for refinement, coarsening works analogously.     Let [1.x.3] be the criterion of cell [1.x.4]. Then the   total error estimate is computed by the formula   [1.x.5]     If [1.x.6] is  [2.x.34]  then we refine the   smallest subset  [2.x.35]  of the Triangulation  [2.x.36]  such that   [1.x.7]     The algorithm is performed by the greedy algorithm described in   refine_and_coarsen_fixed_number().    
*  [2.x.37]  The often used formula with squares on the left and right is   recovered by actually storing the square of [1.x.8] in the   vector  [2.x.38]      From the point of view of implementation, this time we really need to   sort the array of criteria.  Just like the other strategy described   above, this function only computes the threshold values and then passes   over to refine() and coarsen().      [2.x.39]  tria The triangulation whose cells this function is   supposed to mark for coarsening and refinement.      [2.x.40]  criteria The refinement criterion computed on each mesh cell.   Entries may not be negative.      [2.x.41]  top_fraction The fraction of the total estimate which should   be refined. If this number is zero, no cells will be refined. If it   equals one, the result will be flagging for global refinement.      [2.x.42]  bottom_fraction The fraction of the estimate coarsened. If   this number is zero, no cells will be coarsened.      [2.x.43]  max_n_cells This argument can be used to specify a maximal   number of cells. If this number is going to be exceeded upon refinement,   then refinement and coarsening fractions are going to be adjusted in an   attempt to reach the maximum number of cells. Be aware though that   through proliferation of refinement due to  [2.x.44]    this number is only an indicator. The default value of this argument is   to impose no limit on the number of cells.      [2.x.45]  norm_type To determine thresholds, combined errors on   subsets of cells are calculated as norms of the criteria on these   cells. Different types of norms can be used for this purpose, from   which  [2.x.46]  and    [2.x.47]  are currently supported.  
* [0.x.4]*
   This function flags cells of a triangulation for refinement with the   aim to reach a grid that   is optimal with respect to an objective function that tries to balance   reducing the error and increasing the numerical cost when the mesh is   refined. Specifically, this function makes the assumption that if you   refine a cell  [2.x.48]  with error indicator  [2.x.49]  provided by the second   argument to this function, then the error on the children (for all   children together) will only be  [2.x.50]  where    [2.x.51]  is the third argument of this function. This makes the   assumption that the error is only a local property on a mesh and can be   reduced by local refinement
* 
*  -  an assumption that is true for the   interpolation operator, but not for the usual Galerkin projection,   although it is approximately true for elliptic problems where the Greens   function decays quickly and the error here is not too much affected by a   too coarse mesh somewhere else.     With this, we can define the objective function this function tries to   optimize. Let us assume that the mesh currently has  [2.x.52]  cells. Then, if   we refine the  [2.x.53]  cells with the largest errors, we expect to get (in  [2.x.54]    space dimensions)   [1.x.9]   cells ( [2.x.55]  are not refined, and each of the  [2.x.56]  cells we refine yield    [2.x.57]  child cells. On the other hand, with refining  [2.x.58]  cells, and using   the assumptions above, we expect that the error will be   [1.x.10]   where the first sum extends over  [2.x.59]  cells and the second over the    [2.x.60]  cells that will be refined. Note that  [2.x.61]  is an increasing   function of  [2.x.62]  whereas  [2.x.63]  is a decreasing function.     This function then tries to find that number  [2.x.64]  of cells to mark for   refinement for which the objective function   [1.x.11]   is minimal.     The rationale for this function is two-fold. First, compared to the   refine_and_coarsen_fixed_fraction() and refine_and_coarsen_fixed_number()   functions, this function has the property that if all refinement   indicators are the same (i.e., we have achieved a mesh where the error   per cell is equilibrated), then the entire mesh is refined. This is based   on the observation that a mesh with equilibrated error indicators is the   optimal mesh (i.e., has the least overall error) among all meshes with   the same number of cells. (For proofs of this, see R. Becker, M. Braack,   R. Rannacher: "Numerical simulation of laminar flames at low Mach number   with adaptive finite elements", Combustion Theory and Modelling, Vol. 3,   Nr. 3, p. 503-534 1999; and W. Bangerth, R. Rannacher: "Adaptive Finite   Element Methods for Differential Equations", Birkhauser, 2003.)     Second, the function uses the observation that ideally, the error behaves   like  [2.x.65]  with some constant  [2.x.66]  that depends   on the dimension and the finite element degree. It should
* 
*  - given optimal   mesh refinement
* 
*  - not depend so much on the regularity of the solution,   as it is based on the idea, that all singularities can be resolved by   refinement. Mesh refinement is then based on the idea that we want to   make  [2.x.67]  small. This corresponds to the functional  [2.x.68]    above.    
*  [2.x.69]  This function was originally implemented by Thomas Richter. It   follows a strategy described in T. Richter, "Parallel Multigrid Method   for Adaptive Finite Elements with Application to 3D Flow Problems", PhD   thesis, University of Heidelberg, 2005. See in particular Section 4.3,   pp. 42-43.  
* [0.x.5]*
   Mark all mesh cells for which the value in  [2.x.70]  exceeds  [2.x.71]    threshold for refinement, but only flag up to  [2.x.72]  cells.     The vector  [2.x.73]  contains a nonnegative value for each active cell,   ordered in the canonical order of  [2.x.74]      The cells are only flagged for refinement, they are not actually refined.   To do so, you have to call    [2.x.75]      This function does not implement a refinement strategy, it is more a   helper function for the actual strategies.  
* [0.x.6]*
   Mark all mesh cells for which the value in  [2.x.76]  is less than  [2.x.77]    threshold for coarsening.     The vector  [2.x.78]  contains a nonnegative value for each active cell,   ordered in the canonical order of  [2.x.79]      The cells are only flagged for coarsening, they are not actually   coarsened. To do so, you have to call    [2.x.80]      This function does not implement a refinement strategy, it is more a   helper function for the actual strategies.  
* [0.x.7]*
   An exception thrown if the vector with cell criteria contains negative   values  
* [0.x.8]*
   One of the threshold parameters causes trouble. Or the refinement and   coarsening thresholds overlap.  
* [0.x.9]

include/deal.II-translator/grid/grid_reordering_0.txt
[0.x.0]*
 A class implementing various grid reordering algorithms. For more information see the  [2.x.0]  "reordering module".
*   [2.x.1]  Use  [2.x.2]  or  [2.x.3]  instead of the functions provided by this class. Usage of the old-style numbering is deprecated.

* 
* [0.x.1]*
   This is the main function, doing what is announced in the general   documentation of this class for dim=2 and 3 and doing nothing for dim=1.     If a consistent reordering is not possible in dim=3, the original   connectivity data is restored.      [2.x.4]  original_cells An object that contains the data that describes the   mesh.    [2.x.5]  use_new_style_ordering If true, then use the standard ordering of   vertices within a cell. If false (the default), then use the "old-style"   ordering of vertices within cells used by deal.II before version 5.2 and   as explained in the documentation of this class.      [2.x.6]  Use  [2.x.7]  instead.  
* [0.x.2]*
   Grids generated by grid generators may have an orientation of cells which   is the inverse of the orientation required by deal.II.     In 2d and 3d this function checks whether all cells have negative or   positive measure/volume. In the former case, all cells are inverted. It   does nothing in 1d.     The inversion of cells might also work when only a subset of all cells   have negative volume. However, grids consisting of a mixture of negative   and positively oriented cells are very likely to be broken. Therefore, an   exception is thrown, in case cells are not uniformly oriented.     Note, that this function should be called before reorder_cells().      [2.x.8]  all_vertices The vertices of the mesh.    [2.x.9]  original_cells An object that contains the data that describes the   mesh.    [2.x.10]  use_new_style_ordering If true, then use the standard ordering of   vertices within a cell. If false (the default), then use the "old-style"   ordering of vertices within cells used by deal.II before version 5.2 and   as explained in the documentation of this class.      [2.x.11]  Use  [2.x.12]  instead.  
* [0.x.3]

include/deal.II-translator/grid/grid_tools_0.txt
[0.x.0]*
 This namespace is a collection of algorithms working on triangulations, such as shifting or rotating triangulations, but also finding a cell that contains a given point. See the descriptions of the individual functions for more information.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
    [2.x.1]  Information about meshes and cells  
* [0.x.2]*
   Return the diameter of a triangulation. The diameter is computed using   only the vertices, i.e. if the diameter should be larger than the maximal   distance between boundary vertices due to a higher order mapping, then   this function will not catch this.  
* [0.x.3]*
   Compute the volume (i.e. the dim-dimensional measure) of the   triangulation. We compute the measure using the integral  [2.x.2]  where  [2.x.3]  are the cells of the given triangulation. The integral   is approximated via quadrature for which we need the mapping argument.     If the triangulation is a dim-dimensional one embedded in a higher   dimensional space of dimension spacedim, then the value returned is the   dim-dimensional measure. For example, for a two-dimensional triangulation   in three-dimensional space, the value returned is the area of the surface   so described. (This obviously makes sense since the spacedim-dimensional   measure of a dim-dimensional triangulation would always be zero if dim  [2.x.4]    spacedim.     This function also works for objects of type    [2.x.5]  in which case the function is a   collective operation.      [2.x.6]  tria The triangulation.    [2.x.7]  mapping An optional argument used to denote the mapping that   should be used when describing whether cells are bounded by straight or   curved faces. The default is to use a  [2.x.8]  mapping, which corresponds to   straight lines bounding the cells.    [2.x.9]  The dim-dimensional measure of the domain described by the   triangulation, as discussed above.  
* [0.x.4]*
   Return an approximation of the diameter of the smallest active cell of a   triangulation. See  [2.x.10]  for an example of use of this function.     Notice that, even if you pass a non-trivial mapping, the returned value is   computed only using information on the vertices of the triangulation,   possibly transformed by the mapping. While this is accurate most of the   times, it may fail to give the correct result when the triangulation   contains very distorted cells.  
* [0.x.5]*
   Return an approximation of the diameter of the largest active cell of a   triangulation.     Notice that, even if you pass a non-trivial mapping to this function, the   returned value is computed only using information on the vertices of the   triangulation, possibly transformed by the mapping. While this is accurate   most of the times, it may fail to give the correct result when the   triangulation contains very distorted cells.  
* [0.x.6]*
   Given a list of vertices (typically obtained using    [2.x.11]  as the first, and a list of vertex indices   that characterize a single cell as the second argument, return the   measure (area, volume) of this cell. If this is a real cell, then you can   get the same result using  [2.x.12] , but this   function also works for cells that do not exist except that you make it   up by naming its vertices from the list.      [2.x.13]  Use the more general function which takes an ArrayView instead.  
* [0.x.7]*
   Given a list of vertices (typically obtained using    [2.x.14]  as the first, and a list of vertex indices   that characterize a single cell as the second argument, return the   measure (area, volume) of this cell. If this is a real cell, then you can   get the same result using  [2.x.15] , but this   function also works for cells that do not exist except that you make it   up by naming its vertices from the list.     The parameter  [2.x.16]  is expected to have    [2.x.17]  entries. A  [2.x.18]  is implicitly   convertible to an ArrayView, so it can be passed directly. See the   ArrayView class for more information.    
*  [2.x.19]  This function is only implemented for codimension zero objects.  
* [0.x.8]*
   This function computes an affine approximation of the map from the unit   coordinates to the real coordinates of the form  [2.x.20]  by a least squares fit of this affine function to the    [2.x.21]  vertices representing a quadrilateral or hexahedral cell   in `spacedim` dimensions. The result is returned as a pair with the   matrix [1.x.0] as the first argument and the vector [1.x.1] describing   distance of the plane to the origin.     For any valid mesh cell whose geometry is not degenerate, this operation   results in a unique affine mapping, even in cases where the actual   transformation by a bi-/trilinear or higher order mapping might be   singular. The result is exact in case the transformation from the unit to   the real cell is indeed affine, such as in one dimension or for Cartesian   and affine (parallelogram) meshes in 2D/3D.     This approximation is underlying the function    [2.x.22]  function.     For exact transformations to the unit cell, use    [2.x.23]   
* [0.x.9]*
   Computes an aspect ratio measure for all locally-owned active cells and   fills a vector with one entry per cell, given a  [2.x.24]  and    [2.x.25]  The size of the vector that is returned equals the number of   active cells. The vector contains zero for non locally-owned cells. The   aspect ratio of a cell is defined as the ratio of the maximum to minimum   singular value of the Jacobian, taking the maximum over all quadrature   points of a quadrature rule specified via  [2.x.26]  For example, for   the special case of rectangular elements in 2d with dimensions  [2.x.27]  and  [2.x.28]    ( [2.x.29] ), this function returns the usual aspect ratio definition    [2.x.30] . The above definition using singular values is a generalization to   arbitrarily deformed elements. This function is intended to be used for    [2.x.31]  space dimensions, but it can also be used for  [2.x.32]  returning a   value of 1.    
*  [2.x.33]  Inverted elements do not throw an exception. Instead, a value of inf   is written into the vector in case of inverted elements.    
*  [2.x.34]  Make sure to use enough quadrature points for a precise calculation   of the aspect ratio in case of deformed elements.    
*  [2.x.35]  In parallel computations the return value will have the length   n_active_cells but the aspect ratio is only computed for the cells that   are locally owned and placed at index  [2.x.36]    respectively. All other values are set to 0.  
* [0.x.10]*
   Computes the maximum aspect ratio by taking the maximum over all cells.    
*  [2.x.37]  When running in parallel with a Triangulation that supports MPI,   this is a collective call and the return value is the maximum over all   processors.  
* [0.x.11]*
   Compute the smallest box containing the entire triangulation.     If the input triangulation is a  [2.x.38]    then each processor will compute a bounding box enclosing all locally   owned, ghost, and artificial cells. In the case of a domain without curved   boundaries, these bounding boxes will all agree between processors because   the union of the areas occupied by artificial and ghost cells equals the   union of the areas occupied by the cells that other processors own.   However, if the domain has curved boundaries, this is no longer the case.   The bounding box returned may be appropriate for the current processor,   but different from the bounding boxes computed on other processors.  
* [0.x.12]*
   Return the point on the geometrical object  [2.x.39]  closest to the given   point  [2.x.40]  For example, if  [2.x.41]  is a one-dimensional line   or edge, then the returned point will be a point on the geodesic that   connects the vertices as the manifold associated with the object sees it   (i.e., the geometric line may be curved if it lives in a higher   dimensional space). If the iterator points to a quadrilateral in a higher   dimensional space, then the returned point lies within the convex hull of   the vertices of the quad as seen by the associated manifold.    
*  [2.x.42]  This projection is usually not well-posed since there may be   multiple points on the object that minimize the distance. The algorithm   used in this function is robust (and the output is guaranteed to be on   the given  [2.x.43]  but may only provide a few correct digits if the   object has high curvature. If your manifold supports it then the   specialized function  [2.x.44]  may perform better.  
* [0.x.13]*
   Return the arrays that define the coarse mesh of a Triangulation. This   function is the inverse of  [2.x.45]      The return value is a tuple with the vector of vertices, the vector of   cells, and a SubCellData structure. The latter contains additional   information about faces and lines.     This function is useful in cases where one needs to deconstruct a   Triangulation or manipulate the numbering of the vertices in some way: an   example is  [2.x.46]   
* [0.x.14]*
    [2.x.47]  Functions supporting the creation of meshes  
* [0.x.15]*
   Remove vertices that are not referenced by any of the cells. This   function is called by all  [2.x.48]  functions to eliminate   vertices that are listed in the input files but are not used by the cells   in the input file. While these vertices should not be in the input from   the beginning, they sometimes are, most often when some cells have been   removed by hand without wanting to update the vertex lists, as they might   be lengthy.     This function is called by all  [2.x.49]  functions as the   triangulation class requires them to be called with used vertices only.   This is so, since the vertices are copied verbatim by that class, so we   have to eliminate unused vertices beforehand.     Not implemented for the codimension one case.  
* [0.x.16]*
   Remove vertices that are duplicated, due to the input of a structured   grid, for example. If these vertices are not removed, the faces bounded   by these vertices become part of the boundary, even if they are in the   interior of the mesh.     This function is called by some  [2.x.50]  functions. Only   the vertices with indices in  [2.x.51]  are tested for   equality. This speeds up the algorithm, which is, for worst-case hyper   cube geometries  [2.x.52]  in 2D and  [2.x.53]  in 3D: quite slow.   However, if you wish to consider all vertices, simply pass an empty   vector. In that case, the function fills  [2.x.54]  with all   vertices.     Two vertices are considered equal if their difference in each coordinate   direction is less than  [2.x.55]   
* [0.x.17]*
   Grids generated by grid generators may have an orientation of cells which   is the inverse of the orientation required by deal.II.     In 2d and 3d this function checks whether all cells have negative or   positive measure/volume. In the former case, all cells are inverted. It   does nothing in 1d.     The inversion of cells might also work when only a subset of all cells   have negative volume. However, grids consisting of a mixture of negative   and positively oriented cells are very likely to be broken. Therefore, an   exception is thrown, in case cells are not uniformly oriented.    
*  [2.x.56]  This function should be called before  [2.x.57]       [2.x.58]  all_vertices The vertices of the mesh.    [2.x.59]  cells The array of CellData objects that describe the mesh's topology.  
* [0.x.18]*
   Given a vector of CellData objects describing a mesh, reorder their   vertices so that all lines are consistently oriented.     The expectations on orientation and a discussion of this function are   available in the  [2.x.60]  "reordering module".      [2.x.61]  cells The array of CellData objects that describe the mesh's topology.  
* [0.x.19]*
    [2.x.62]  Rotating, stretching and otherwise transforming meshes  
* [0.x.20]*
   Transform the vertices of the given triangulation by applying the   function object provided as first argument to all its vertices.     The transformation given as argument is used to transform each vertex.   Its respective type has to offer a function-like syntax, i.e. the   predicate is either an object of a type that has an <tt>operator()</tt>,   or it is a pointer to the function. In either case, argument and return   value have to be of type <tt>Point [2.x.63]     
*  [2.x.64]  The transformations that make sense to use with this function     should have a Jacobian with a positive determinant. For example,     rotation, shearing, stretching, or scaling all satisfy this (though     there is no requirement that the transformation used actually is     linear, as all of these examples are). On the other hand, reflections     or inversions have a negative determinant of the Jacobian. The     current function has no way of asserting a positive determinant     of the Jacobian, but if you happen to use such a transformation,     the result will be a triangulation in which cells have a negative     volume.    
*  [2.x.65]  If you are using a  [2.x.66]  you will   have hanging nodes in your local Triangulation even if your "global" mesh   has no hanging nodes. This will cause issues with wrong positioning of   hanging nodes in ghost cells if you call the current functions: The   vertices of all locally owned cells will be correct, but the vertices of   some ghost cells may not. This means that computations like   KellyErrorEstimator may give wrong answers.    
*  [2.x.67]  This function is in general not compatible with manifolds attached   to the triangulation. For example, in order to refine the grid (using   manifolds) after the grid transformation, you have to make sure that   the original manifold is still valid for the transformed geometry. This   does not hold in general, and it is necessary to clear the manifold and   attach a new one for the transformed geometry in these cases.   If you want to perform refinements according to the original   manifold description attached to the triangulation, you should first do   the refinements, subsequently deactivate all manifolds, and finally call   the transform() function. The result is a triangulation with correctly   transformed vertices, but otherwise straight-sided elements. The   following procedure is recommended  
* [1.x.2]
*      This function is used in the "Possibilities for extensions" section of    [2.x.68] . It is also used in  [2.x.69]  and  [2.x.70] .  
* [0.x.21]*
   Shift each vertex of the triangulation by the given shift vector. This   function uses the transform() function above, so the requirements on the   triangulation stated there hold for this function as well.  
* [0.x.22]*
   Rotate all vertices of the given two-dimensional triangulation in   counter-clockwise sense around the origin of the coordinate system by the   given angle (given in radians, rather than degrees). This function uses   the transform() function above, so the requirements on the triangulation   stated there hold for this function as well.    
*  [2.x.71]  This function is only supported for dim=2.  
* [0.x.23]*
   Rotate all vertices of the given  [2.x.72]  in counter-clockwise   direction around the axis with the given index. Otherwise like the   function above.      [2.x.73]  angle Angle in radians to rotate the Triangulation by.    [2.x.74]  axis Index of the coordinate axis to rotate around, keeping   that coordinate fixed (0=x axis, 1=y axis, 2=z axis).    [2.x.75]  triangulation The Triangulation object to rotate.    
*  [2.x.76]  Implemented for dim=1, 2, and 3.  
* [0.x.24]*
   Transform the given triangulation smoothly to a different domain where,   typically, each of the vertices at the boundary of the triangulation is   mapped to the corresponding points in the  [2.x.77]  map.     The unknown displacement field  [2.x.78]  in direction  [2.x.79]  is   obtained from the minimization problem [1.x.3]   subject to prescribed constraints. The minimizer is obtained by solving the   Laplace equation of the dim components of a displacement field that maps   the current   domain into one described by  [2.x.80]  . Linear finite elements with   four Gaussian quadrature points in each direction are used. The difference   between the vertex positions specified in  [2.x.81]  and their current   value in  [2.x.82]  therefore represents the prescribed values of this   displacement field at the boundary of the domain, or more precisely at all   of those locations for which  [2.x.83]  provides values (which may be   at part of the boundary, or even in the interior of the domain). The   function then evaluates this displacement field at each unconstrained   vertex and uses it to place the mapped vertex where the displacement   field locates it. Because the solution of the Laplace equation is smooth,   this guarantees a smooth mapping from the old domain to the new one.      [2.x.84]  new_points The locations where a subset of the existing   vertices are to be placed. Typically, this would be a map from the vertex   indices of all nodes on the boundary to their new locations, thus   completely specifying the geometry of the mapped domain. However, it may   also include interior points if necessary and it does not need to include   all boundary vertices (although you then lose control over the exact   shape of the mapped domain).      [2.x.85]  tria The Triangulation object. This object is changed in-   place, i.e., the previous locations of vertices are overwritten.      [2.x.86]  coefficient An optional coefficient for the Laplace problem.   Larger values make cells less prone to deformation (effectively   increasing their stiffness). The coefficient is evaluated in the   coordinate system of the old, undeformed configuration of the   triangulation as input, i.e., before the transformation is applied.   Should this function be provided, sensible results can only be expected   if all coefficients are positive.      [2.x.87]  solve_for_absolute_positions If set to  [2.x.88] , the   minimization problem is formulated with respect to the final vertex   positions as opposed to their displacement. The two formulations are   equivalent for   the homogeneous problem (default value of  [2.x.89]  but they   result in very different mesh motion otherwise. Since in most cases one   will be using a non-constant coefficient in displacement formulation, the   default value of this parameter is  [2.x.90] .    
*  [2.x.91]  This function is not currently implemented for the 1d case.  
* [0.x.25]*
   Return a  [2.x.92]  with all vertices of faces located in the boundary      [2.x.93]  tria The Triangulation object.  
* [0.x.26]*
   Scale the entire triangulation by the given factor. To preserve the   orientation of the triangulation, the factor must be positive.     This function uses the transform() function above, so the requirements on   the triangulation stated there hold for this function as well.  
* [0.x.27]*
   Distort the given triangulation by randomly moving around all the   vertices of the grid.  The direction of movement of each vertex is   random, while the length of the shift vector has a value of  [2.x.94]    times the minimal length of the active edges adjacent to this vertex.   Note that  [2.x.95]  should obviously be well below <tt>0.5</tt>.     If  [2.x.96]  is set to  [2.x.97]  (which is the default), then   boundary vertices are not moved.      [2.x.98]  is used for the initialization of the random engine. Its   default value initializes the engine with the same state as in   previous versions of deal.II.  
* [0.x.28]*
   Remove hanging nodes from a grid. If the  [2.x.99]  parameter is set   to  [2.x.100]  (default) this function detects cells with hanging nodes and   refines the neighbours in the direction that removes hanging nodes.   If the  [2.x.101]  parameter is set   to  [2.x.102]  the neighbours refinement is made in each directions.   In order to remove all hanging nodes this procedure has to be repeated:   this could require a large number of iterations.   To avoid this a max number ( [2.x.103]  of iteration is provided.     Consider the following grid:    [2.x.104]       [2.x.105]  ==  [2.x.106]  would return:    [2.x.107]       [2.x.108]  ==  [2.x.109]  would return:    [2.x.110]       [2.x.111]  tria Triangulation to refine.      [2.x.112]  isotropic If true refine cells in each directions, otherwise   (default value) refine the cell in the direction that removes hanging node.      [2.x.113]  max_iterations At each step only closest cells to hanging nodes   are refined. The code may require a lot of iterations to remove all   hanging nodes.  [2.x.114]  is the maximum number of iteration   allowed. If  [2.x.115]  ==  [2.x.116]  this   function continues refining until there are no hanging nodes.    
*  [2.x.117]  In the case of parallel codes, this function should be combined   with  [2.x.118]   
* [0.x.29]*
   Refine a mesh anisotropically such that the resulting mesh is composed by   cells with maximum ratio between dimensions less than  [2.x.119]    This procedure requires an algorithm that may not terminate. Consequently,   it is possible to set a maximum number of iterations through the    [2.x.120]  parameter.     Starting from a cell like this:    [2.x.121]      This function would return:    [2.x.122]       [2.x.123]  tria Triangulation to refine.      [2.x.124]  max_ratio Maximum value allowed among the ratio between   the dimensions of each cell.      [2.x.125]  max_iterations Maximum number of iterations allowed.    
*  [2.x.126]  In the case of parallel codes, this function should be combined   with  [2.x.127]  and    [2.x.128]   
* [0.x.30]*
   Analyze the boundary cells of a mesh, and if one cell is found at   a corner position (with dim adjacent faces on the boundary), and its   dim-dimensional angle fraction exceeds  [2.x.129]    refine globally once, and replace the children of such cell   with children where the corner is no longer offending the given angle   fraction.     If no boundary cells exist with two adjacent faces on the boundary, then   the triangulation is left untouched. If instead we do have cells with dim   adjacent faces on the boundary, then the fraction between the   dim-dimensional   solid angle and dim*pi/2 is checked against the parameter  [2.x.130]    If it is higher, the grid is refined once, and the children of the   offending cell are replaced with some cells that instead respect the limit.   After this process the triangulation is flattened, and all Manifold objects   are restored as they were in the original triangulation.     An example is given by the following mesh, obtained by attaching a   SphericalManifold to a mesh generated using  [2.x.131]     
* [1.x.4]
*       [2.x.132]      The four cells that were originally the corners of a square will give you   some troubles during computations, as the jacobian of the transformation   from the reference cell to those cells will go to zero, affecting the error   constants of the finite element estimates.     Those cells have a corner with an angle that is very close to 180 degrees,   i.e., an angle fraction very close to one.     The same code, adding a call to regularize_corner_cells:  
* [1.x.5]
*    generates a mesh that has a much better behavior w.r.t. the jacobian of   the Mapping:      [2.x.133]      This mesh is very similar to the one obtained by  [2.x.134]    However, using  [2.x.135]  one has the freedom to   choose when to apply the regularization, i.e., one could in principle first   refine a few times, and then call the regularize_corner_cells function:    
* [1.x.6]
*      This generates the following mesh:      [2.x.136]      The function is currently implemented only for dim = 2 and   will throw an exception if called with dim = 3.      [2.x.137]  tria Triangulation to regularize.      [2.x.138]  limit_angle_fraction Maximum ratio of angle or solid   angle that is allowed for a corner element in the mesh.  
* [0.x.31]*
    [2.x.139]  Finding cells and vertices of a triangulation  
* [0.x.32]*
   Given a Triangulation's  [2.x.140]  and a list of  [2.x.141]  call   find_active_cell_around_point() on each element of  [2.x.142]  and return    [2.x.143]  reference positions  [2.x.144]  and a mapping  [2.x.145]  from local   to global indices into  [2.x.146]  .      [2.x.147]  cache The triangulation's  [2.x.148]  .    [2.x.149]  points The point's vector.    [2.x.150]  cell_hint (optional) A cell iterator for a cell which likely   contains the first point of  [2.x.151]       [2.x.152]  A tuple containing the following information:
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.153]  : A vector of all the cells containing at least one of     the  [2.x.154]  .
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.155]  : A vector of vectors of points.  [2.x.156]  contains     the reference positions of all points that fall within the cell  [2.x.157]  .
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.158]  : A vector of vectors of integers, containing the mapping between     local numbering in  [2.x.159]  , and global index in  [2.x.160]  .     If  [2.x.161]  and  [2.x.162]  are the only two points that fall in  [2.x.163]    then  [2.x.164]  and  [2.x.165]  are the reference positions of    [2.x.166]  and  [2.x.167]  in  [2.x.168]  and  [2.x.169]  = a,    [2.x.170]  = b. The function    [2.x.171]    returns  [2.x.172]      The algorithm builds an rtree of  [2.x.173]  to sort them spatially, before   attempting to call find_active_cell_around_point().    
*  [2.x.174]  This function is not implemented for the codimension one case (<tt>spacedim != dim</tt>).    
*  [2.x.175]  If a point is not found inside the mesh, or is lying inside an   artificial cell of a  [2.x.176]  the point is silently   ignored. If you want to infer for which points the search failed, use the   function compute_point_locations_try_all() that also returns a vector of   indices indicating the points for which the search failed.    
*  [2.x.177]  The actual return type of this function, i.e., the type referenced   above as  [2.x.178]  is  
* [1.x.7]
*    The type is abbreviated in the online documentation to improve readability   of this page.    
*  [2.x.179]  This function optimizes the search by making use of    [2.x.180]  which either returns   a cached rtree or builds and stores one. Building an rtree might hinder   the performance if the function is called only once on few points.  
* [0.x.33]*
   This function is similar to  [2.x.181]    but while compute_point_locations() silently ignores all points for which   find_active_cell_around_point() fails, this function also returns a   vector containing the indices of the points for which   find_active_cell_around_point() failed.      [2.x.182]  A tuple containing four elements; the first three   are documented in  [2.x.183]    The last element of the  [2.x.184]  contains the   indices of points which are neither found inside the mesh   nor lie in artificial cells. The  [2.x.185]  equals the   following tuple type:  
* [1.x.8]
*     
*  [2.x.186]  This function is not implemented for the codimension one case (<tt>spacedim != dim</tt>).    
*  [2.x.187]  This function optimizes the search by making use of    [2.x.188]  which either returns   a cached rtree or builds and stores one. Building an rtree might hinder   the performance if the function is called only once on few points.     For a more detailed documentation see    [2.x.189]   
* [0.x.34]*
   Given a  [2.x.190]  and a list of    [2.x.191]  for each process, find the points lying on the locally   owned part of the mesh and compute the quadrature rules for them.   Distributed compute point locations is a function similar to    [2.x.192]  but working for    [2.x.193]  objects and, unlike its serial version, also   for a distributed triangulation (see  [2.x.194]       [2.x.195]  cache a  [2.x.196]  object    [2.x.197]  local_points the array of points owned by the current process.   Every process can have a different array of points which can be empty and   not contained within the locally owned part of the triangulation    [2.x.198]  global_bboxes a vector of vectors of bounding boxes; it   describes the locally owned part of the mesh for each process. The bounding   boxes describing which part of the mesh is locally owned by process with   rank rk are contained in global_bboxes[rk]. The local description can be   obtained from  [2.x.199]  then the   global one can be obtained using either    [2.x.200]  or  [2.x.201]     [2.x.202]  tolerance Tolerance in terms of unit cell coordinates. Depending     on the problem, it might be necessary to adjust the tolerance in order     to be able to identify a cell. Floating     point arithmetic implies that a point will, in general, not lie exactly     on a vertex, edge, or face. In either case, it is not predictable which     of the cells adjacent to a vertex or an edge/face this function returns.     Consequently, algorithms that call this function need to take into     account that the returned cell will only contain the point approximately.    [2.x.203]  A tuple containing the quadrature information     The elements of the output tuple are:
* 

* 
* 

* 
* 

* 
* 
*  - cells : a vector of all cells containing at least one point.
* 

* 
* 

* 
* 

* 
* 
*  - qpoints : a vector of vector of points; containing in  [2.x.204]      the reference positions of all points that fall within the cell  [2.x.205]  .
* 

* 
* 

* 
* 

* 
* 
*  - maps : a vector of vector of integers, containing the mapping between    the numbering in qpoints (previous element of the tuple), and the vector    of local points of the process owning the points.
* 

* 
* 

* 
* 

* 
* 
*  - points : a vector of vector of points.  [2.x.206]  is the point in the    real space corresponding.    to  [2.x.207]  . Notice  [2.x.208]  are the points lying on the locally    owned part of the mesh; thus these can be either copies of  [2.x.209]     or points received from other processes i.e. local_points for other   processes
* 

* 
* 

* 
* 

* 
* 
*  - owners : a vector of vectors;  [2.x.210]  contains the rank of    the process owning the point[i][j] (previous element of the tuple).     The function uses the triangulation's mpi communicator: for this reason it   throws an assert error if the Triangulation is not derived from    [2.x.211]  .     In a serial execution the first three elements of the tuple are the same   as in  [2.x.212]  .     Note: this function is a collective operation.    
*  [2.x.213]  The actual return type of this function, i.e., the type referenced   above as  [2.x.214]  is  
* [1.x.9]
*    The type is abbreviated in the online documentation to improve readability   of this page.  
* [0.x.35]*
     Data structure returned by      [2.x.215]  It provides     information to perform  [2.x.216]      and to set up the communication pattern within      [2.x.217]         
*  [2.x.218]  The name of the fields are chosen with        [2.x.219]  in mind. Here, quantities are       computed at specified arbitrary positioned points (and even on remote       processes in the MPI universe) cell by cell and these values are sent       to requesting processes, which receive the result and resort the       result according to the points.    
* [0.x.36]*
       Information of each point on sending/evaluation side. The elements of       the tuple are as follows: 0) cell level and index, 1) rank of the       owning process, 2) local index of the owning process, 3) reference       position, 4) real position, 5) permutation index within a send buffer.      
* [0.x.37]*
       Ranks to send to.      
* [0.x.38]*
       Pointers of ranges within a send buffer to be sent to the ranks       specified by send_ranks. The size of the send buffer is given       by send_ptrs.back().      
* [0.x.39]*
       Information of each received data value. The elements of the tuple are       as follows: 0) rank of sender, 1) local index, 2) enumeration index.            
*  [2.x.220]  The vector is sorted according to 1), 0), 2).            
*  [2.x.221]  To each point multiple data values might be associated to. This         might be the case if a point coincides with a geometric entity (e.g.,         vertex) that is shared by multiple cells.      
* [0.x.40]*
       Ranks from where data is received.      
* [0.x.41]*
       Pointers of ranges within a receive buffer that are filled by ranks       specified by recv_ranks. The size of the receive buffer is given by       recv_ptrs.back().      
* [0.x.42]*
     A function that fills DistributedComputePointLocationsInternal.     If the input argument  [2.x.222]  is set to false only     the fields needed by      [2.x.223]  are filled.     If the input argument is set to true additional data structures are     set up to be able to setup the communication pattern within      [2.x.224]     
* [0.x.43]*
   Return a map `vertex index
* 
-> Point<spacedim>` containing the used   vertices of the given `container`. The key of the returned map (i.e.,   the first element of the pair above) is the global index in the   triangulation, whereas the value of each pair is the physical   location of the corresponding vertex. The used vertices are obtained by   looping over all cells,   and querying for each cell where its vertices are through the (optional)   `mapping` argument.     In serial Triangulation objects and  [2.x.225]    objects, the size of the returned map   equals  [2.x.226]  (not  [2.x.227]    Note that in  [2.x.228]  objects, only vertices in   locally owned cells and ghost cells are returned, as for all other vertices   their real location might not be known (e.g. for distributed computations   using MappingQEulerian).     If you use the default `mapping`, the returned map satisfies the following   equality:    
* [1.x.10]
*      Notice that the above is not satisfied for mappings that change the   location of vertices, like MappingQEulerian.      [2.x.229]  "MeshType concept".    [2.x.230]  container The container to extract vertices from.    [2.x.231]  mapping The mapping to use to compute the points locations.  
* [0.x.44]*
   Find and return the index of the closest vertex to a given point in the   map of vertices passed as the first argument.      [2.x.232]  vertices A map of index->vertex, as returned by           [2.x.233]     [2.x.234]  p The target point.    [2.x.235]  The index of the vertex that is closest to the target point `p`.  
* [0.x.45]*
   Find and return the index of the used vertex (or marked vertex) in a   given mesh that is located closest to a given point.     This function uses the locations of vertices as stored in the   triangulation. This is usually sufficient, unless you are using a Mapping   that moves the vertices around (for example, MappingQEulerian). In this   case, you should call the function with the same name and with an   additional Mapping argument.      [2.x.236]  mesh A variable of a type that satisfies the requirements of the    [2.x.237]  "MeshType concept".    [2.x.238]  p The point for which we want to find the closest vertex.    [2.x.239]  marked_vertices An array of bools indicating which   vertices of  [2.x.240]  will be considered within the search   as the potentially closest vertex. On receiving a non-empty    [2.x.241]  the function will   only search among  [2.x.242]  for the closest vertex.   The size of this array should be equal to the value returned by    [2.x.243]  for the triangulation underlying the given mesh   (as opposed to the value returned by  [2.x.244]     [2.x.245]  The index of the closest vertex found.  
* [0.x.46]*
   Find and return the index of the used vertex (or marked vertex) in a   given mesh that is located closest to a given point. Use the given   mapping to compute the actual location of the vertices.     If the Mapping does not modify the position of the mesh vertices (like,   for example, MappingQEulerian does), then this function is equivalent to   the one with the same name, and without the `mapping` argument.      [2.x.246]  mapping A mapping used to compute the vertex locations    [2.x.247]  mesh A variable of a type that satisfies the requirements of the    [2.x.248]  "MeshType concept".    [2.x.249]  p The point for which we want to find the closest vertex.    [2.x.250]  marked_vertices An array of bools indicating which   vertices of  [2.x.251]  will be considered within the search   as the potentially closest vertex. On receiving a non-empty    [2.x.252]  the function will   only search among  [2.x.253]  for the closest vertex.   The size of this array should be equal to the value returned by    [2.x.254]  for the triangulation underlying the given mesh   (as opposed to the value returned by  [2.x.255]     [2.x.256]  The index of the closest vertex found.  
* [0.x.47]*
   Find and return a vector of iterators to active cells that surround a   given vertex with index  [2.x.257]      For locally refined grids, the vertex itself might not be a vertex of all   adjacent cells that are returned. However, it will always be either a   vertex of a cell or be a hanging node located on a face or an edge of it.      [2.x.258]  container A variable of a type that satisfies the requirements of   the    [2.x.259]  "MeshType concept".    [2.x.260]  vertex_index The index of the vertex for which we try to find   adjacent cells.    [2.x.261]  A vector of cells that lie adjacent to the given vertex.    
*  [2.x.262]  It isn't entirely clear at this time whether the function does the   right thing with anisotropically refined meshes. It needs to be checked   for this case.  
* [0.x.48]*
   Find an active non-artificial cell that surrounds a given point  [2.x.263]  The return type   is a pair of an iterator to the active cell along with the unit cell   coordinates of the point.     The algorithm used in this function proceeds by first looking for the   vertex located closest to the given point, see    [2.x.264]  Secondly, all adjacent cells to this   vertex are found in the mesh, see    [2.x.265]  Lastly, for each of these   cells, the function tests whether the point is inside. This check is   performed using the given  [2.x.266]  argument to determine whether cells   have straight or curved boundaries.     If a point lies on the boundary of two or more cells, then the algorithm   tries to identify the cell that is of highest refinement level.     If the point requested does not lie in a locally-owned or ghost cell,   then this function will return the (invalid) MeshType<dim,  [2.x.267]    iterator. This case can be handled similarly to the various  [2.x.268]    and  [2.x.269]  functions.      [2.x.270]  mapping The mapping used to determine whether the given point is     inside a given cell.    [2.x.271]  mesh A variable of a type that satisfies the requirements of the      [2.x.272]  "MeshType concept".    [2.x.273]  p The point for which we want to find the surrounding cell.    [2.x.274]  marked_vertices An array of `bool`s indicating whether an     entry in the vertex array should be considered     (and the others must be ignored) as the potentially     closest vertex to the specified point. On specifying a non-default      [2.x.275]  find_closest_vertex() would     only search among  [2.x.276]  for the closest vertex.     The size of this array should be equal to n_vertices() of the     triangulation (as opposed to n_used_vertices() ). The motivation of using      [2.x.277]  is to cut down the search space of vertices if one has     a priori knowledge of a collection of vertices that the point of interest     may be close to.    [2.x.278]  tolerance Tolerance in terms of unit cell coordinates. Depending     on the problem, it might be necessary to adjust the tolerance in order     to be able to identify a cell. Floating     point arithmetic implies that a point will, in general, not lie exactly     on a vertex, edge, or face. In either case, it is not predictable which     of the cells adjacent to a vertex or an edge/face this function returns.     Consequently, algorithms that call this function need to take into     account that the returned cell will only contain the point approximately.      [2.x.279]  A pair of an iterators into the mesh that points to the   surrounding cell, and of the unit cell coordinates of that point. This   local position might be located slightly outside an actual unit cell,   due to numerical roundoff. Therefore, the point returned by this function   should be projected onto the unit cell, using    [2.x.280]   This is not automatically performed   by the algorithm. The returned cell can be a locally-owned cell or a   ghost cell (but not an artificial cell). The returned cell might be a   ghost cell even if the given point is a vertex of a locally owned cell.   The reason behind is that this is the only way to guarantee that all   processors that participate in a parallel triangulation will agree which   cell contains a point. For example, if two processors come together   at one vertex and the function is called with this vertex, then one   processor will return a locally owned cell and the other one a ghost cell.  
* [0.x.49]*
   A version of the above function that assumes straight boundaries and   as a consequence simply calls the above function using MappingQ1 for   the mapping argument.      [2.x.281]  An iterator into the mesh that points to the surrounding cell.  
* [0.x.50]*
   Another version where we use that mapping on a given   cell that corresponds to the active finite element index of that cell.   This is obviously only useful for hp-problems, since the active finite   element index for all other DoF handlers is always zero.  
* [0.x.51]*
   Finding an active non-artificial cell around a point can be very expensive   in terms of computational costs. This function aims at providing a fast   version of the above functions by using a space-tree to speed up the   geometry search.      [2.x.282]  cache Object with information about the space-tree of a triangulation,   see  [2.x.283]     [2.x.284]  p The point for which we want to find the surrounding cell.    [2.x.285]  cell_hint Gives a hint for the geometry search, which is beneficial   if a-priori knowledge is available regarding the cell on which the point   may likely be located. A typical use case would be that this search has   to be done for an array of points that are close to each other and where   the adjacent cell of the previous point is a good hint for the next point   in the array.    [2.x.286]  marked_vertices See above.    [2.x.287]  tolerance See above.       The following code example shows how to use this function:    
* [1.x.11]
*   
* [0.x.52]*
   A version of the previous function that exploits an already existing   map between vertices and cells (constructed using the function    [2.x.288]  a map of vertex_to_cell_centers (obtained   through  [2.x.289]  and   optionally an RTree constructed from the used vertices of the   Triangulation.    
*  [2.x.290]  All of these structures can be queried from a    [2.x.291]  object. Note, however, that in this case MeshType   has to be Triangulation, so that it might be more appropriate to directly   call the function above with argument `cache` in this case.  
* [0.x.53]*
   As compared to the functions above, this function identifies all active   non-artificial cells around a point for a given tolerance level `tolerance`   in terms of unit coordinates. Given a first cell with reference coordinates   as parameter    [2.x.292]  e.g. obtained by one of the functions above, all   corresponding neighboring cells with points in unit coordinates are also   identified.     This function is useful e.g. for discontinuous function spaces where, for   the case the given point `p` lies on a vertex, edge or face, several   cells might hold independent values of the solution that get combined in   some way in a user code.     This function is used as follows  
* [1.x.12]
*   
* [0.x.54]*
   A variant of the previous function that internally calls one of the   functions find_active_cell_around_point() to obtain a first cell, and   subsequently adds all other active non-artificial cells by calling the   function find_all_active_cells_around_point() above.  
* [0.x.55]*
   Return a list of all descendants of the given cell that are active. For   example, if the current cell is once refined but none of its children are   any further refined, then the returned list will contain all its   children.     If the current cell is already active, then the returned list is empty   (because the cell has no children that may be active).      [2.x.293]  MeshType A type that satisfies the requirements of the    [2.x.294]  "MeshType concept".    [2.x.295]  cell An iterator pointing to a cell of the mesh.    [2.x.296]  A list of active descendants of the given cell    
*  [2.x.297]  Since in C++ the MeshType template argument can not be deduced from   a function call, you will have to specify it after the function name, as   for example in  
* [1.x.13]
*   
* [0.x.56]*
   Extract the active cells around a given cell  [2.x.298]  and return them in   the vector  [2.x.299]  These neighbors are specifically the   [1.x.14] neighbors of a cell or, if that neighbor is further   refined, its active children that border on that face. On the other   hand, the neighbors returned do not include cells that lie, for   example, diagonally opposite to a vertex but are not face neighbors   themselves. (In 3d, it also does not include cells that are   adjacent to one of the edges of the current cell, but are not   face neighbors.)      [2.x.300]  MeshType A type that satisfies the requirements of the    [2.x.301]  "MeshType concept".    [2.x.302]  cell An iterator pointing to a cell of the mesh.    [2.x.303]  active_neighbors A list of active descendants of the given   cell    
*  [2.x.304]  Since in C++ the MeshType template argument can not be deduced from   a function call, you will have to specify it after the function name, as   for example in  
* [1.x.15]
*   
* [0.x.57]*
   Extract and return the active cell layer around a subdomain (set of   active cells) in the  [2.x.305]  (i.e. those that share a common set of   vertices with the subdomain but are not a part of it). Here, the   "subdomain" consists of exactly all of those cells for which the  [2.x.306]    predicate returns  [2.x.307]      An example of a custom predicate is one that checks for a given material   id  
* [1.x.16]
*    and we can then extract the layer of cells around this material with the   following call:  
* [1.x.17]
*      Predicates that are frequently useful can be found in namespace   IteratorFilters. For example, it is possible to extract a layer   of cells around all of those cells with a given material id,  
* [1.x.18]
*    or around all cells with one of a set of active FE indices for a DoFHandler   with hp-capabilities  
* [1.x.19]
*    Note that in the last two examples we ensure that the predicate returns   true only for locally owned cells. This means that the halo layer will   not contain any artificial cells.      [2.x.308]  MeshType A type that satisfies the requirements of the    [2.x.309]  "MeshType concept".    [2.x.310]  mesh A mesh (i.e. objects of type Triangulation or DoFHandler).    [2.x.311]  predicate A function  (or object of a type with an operator())   defining the subdomain around which the halo layer is to be extracted. It   is a function that takes in an active cell and returns a boolean.    [2.x.312]  A list of active cells sharing at least one common vertex with   the predicated subdomain.  
* [0.x.58]*
   Extract and return the cell layer around a subdomain (set of   cells) on a specified level of the  [2.x.313]  (i.e. those cells on   that level that share a common set of vertices with the subdomain   but are not a part of it). Here, the "subdomain" consists of exactly   all of those cells for which the  [2.x.314]  returns  [2.x.315]   
* [0.x.59]*
   Extract and return ghost cells which are the active cell layer around all   locally owned cells. This is most relevant for    [2.x.316]  where it will return a subset of all   ghost cells on a processor, but for  [2.x.317]    this will return all the ghost cells.      [2.x.318]  MeshType A type that satisfies the requirements of the    [2.x.319]  "MeshType concept".    [2.x.320]  mesh A mesh (i.e. objects of type Triangulation or DoFHandler).    [2.x.321]  A list of ghost cells  
* [0.x.60]*
   Extract and return the set of active cells within a geometric distance of    [2.x.322]  around a subdomain (set of active cells) in the  [2.x.323]    Here, the "subdomain" consists of exactly all of   those cells for which the  [2.x.324]  returns  [2.x.325]      The function first computes the cells that form the 'surface' of the   subdomain that consists of all of the active cells for which the predicate   is true. Using compute_bounding_box(), a bounding box is   computed for this subdomain and extended by  [2.x.326]  These   cells are called interior subdomain boundary cells.   The active cells with all of their vertices outside the extended   bounding box are ignored.   The cells that are inside the extended bounding box are then checked for   their proximity to the interior subdomain boundary cells. This implies   checking the distance between a pair of arbitrarily oriented cells,   which is not trivial in general. To simplify this, the algorithm checks   the distance between the two enclosing spheres of the cells.   This will definitely result in slightly more cells being marked but   also greatly simplifies the arithmetic complexity of the algorithm.      [2.x.327]    The image shows a mesh generated by subdivided_hyper_rectangle(). The cells   are marked using three different colors. If the grey colored cells in the   image are the cells for which the predicate is true, then the function   compute_active_cell_layer_within_distance() will return a set of cell   iterators corresponding to the cells colored in red.   The red colored cells are the active cells that are within a given   distance to the grey colored cells.      [2.x.328]  MeshType A type that satisfies the requirements of the    [2.x.329]  "MeshType concept".    [2.x.330]  mesh A mesh (i.e. objects of type Triangulation or DoFHandler).    [2.x.331]  predicate A function  (or object of a type with an operator())   defining the subdomain around which the halo layer is to be extracted. It   is a function that takes in an active cell and returns a boolean.    [2.x.332]  layer_thickness specifies the geometric distance within   which the function searches for active cells from the predicate domain.   If the minimal distance between the enclosing sphere of the an   active cell and the enclosing sphere of any of the cells for which   the  [2.x.333]  returns  [2.x.334]  is less than  [2.x.335]    then the active cell is an \a active_cell_within_distance.    [2.x.336]  A list of active cells within a given geometric distance    [2.x.337]  from the set of active cells for which the  [2.x.338]    returns  [2.x.339]      See compute_active_cell_halo_layer().  
* [0.x.61]*
   Extract and return a set of ghost cells which are within a    [2.x.340]  around all locally owned cells.   This is most relevant for  [2.x.341]    where it will return a subset of all ghost cells on a process, but for    [2.x.342]  this will return all the ghost cells.   All the cells for the  [2.x.343]  class that   are not owned by the current processor can be considered as ghost cells;   in particular, they do not only form a single layer of cells around the   locally owned ones.      [2.x.344]  MeshType A type that satisfies the requirements of the    [2.x.345]  "MeshType concept".    [2.x.346]  mesh A mesh (i.e. objects of type Triangulation or DoFHandler).    [2.x.347]  layer_thickness specifies the geometric distance within   which the function searches for active cells from the locally owned cells.    [2.x.348]  A subset of ghost cells within a given geometric distance of  [2.x.349]    layer_thickness from the locally owned cells of a current process.     Also see compute_ghost_cell_halo_layer() and   compute_active_cell_layer_within_distance().  
* [0.x.62]*
   Compute and return a bounding box, defined through a pair of points   bottom left and top right, that surrounds a subdomain of the  [2.x.350]    Here, the "subdomain" consists of exactly all of those   active cells for which the  [2.x.351]  returns  [2.x.352]      For a description of how  [2.x.353]  works,   see compute_active_cell_halo_layer().    
*  [2.x.354]  This function was written before the BoundingBox class was invented.     Consequently, it returns a pair of points, rather than a BoundingBox   object as one may expect. However, BoundingBox has a conversion constructor   from pairs of points, so the result of this function can still be assigned   to a BoundingBox object.  
* [0.x.63]*
   Compute a collection of bounding boxes so that all active cells for which   the given predicate is true, are completely enclosed in at least one of the   bounding boxes. Notice the cover is only guaranteed to contain all these   active cells but it's not necessarily exact i.e. it can include a bigger   area than their union.     For each cell at a given refinement level containing active cells for which  [2.x.355]  is true,   the function creates a bounding box of its children for which  [2.x.356]  is true.     This results in a cover of all active cells for which  [2.x.357]  is true; the parameters    [2.x.358]  and  [2.x.359]  are used to reduce the number of cells at a computational cost and   covering a bigger n-dimensional volume.     The parameters to control the algorithm are:
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.360]  : the property of the cells to enclose e.g.  [2.x.361]  .    The predicate is tested only on active cells.
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.362]  : it defines the level at which the initial bounding box are created. The refinement    should be set to a coarse refinement level. A bounding box is created for   each active cell at coarser    level than  [2.x.363]  if  [2.x.364]  is higher than the number of levels of the    triangulation an exception is thrown.
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.365]  : This flag allows for box merging and, by default, is false. The algorithm has a cost of    O(N^2) where N is the number of the bounding boxes created from the   refinement level; for this reason, if    the flag is set to true, make sure to choose wisely a coarse enough  [2.x.366] 
* 

* 
* 

* 
* 

* 
* 
*  -  [2.x.367]  : the maximum number of bounding boxes to compute. If more are created the smaller ones are    merged with neighbors. By default after merging the boxes which can be   expressed as a single one no more boxes are merged. See the    [2.x.368]  () function for details.    Notice only neighboring cells are merged (see the  [2.x.369]   function in bounding box class): if    the target number of bounding boxes max_boxes can't be reached by merging   neighbors an exception is thrown     The following image describes an example of the algorithm with  [2.x.370]  = 2,  [2.x.371]  = true   and  [2.x.372]  = 1. The cells with the property predicate are in red, the area of a bounding box is   slightly orange.    [2.x.373] 
* 

* 
* 

* 
* 

* 
* 
*  - 1. In black we can see the cells of the current level.
* 

* 
* 

* 
* 

* 
* 
*  - 2. For each cell containing the red area a bounding box is created: by   default these are returned.
* 

* 
* 

* 
* 

* 
* 
*  - 3. Because  [2.x.374]  = true the number of bounding boxes is reduced while not changing the cover.    If  [2.x.375]  was left as default or bigger than 1 these two boxes would be returned.
* 

* 
* 

* 
* 

* 
* 
*  - 4. Because  [2.x.376]  = 1 the smallest bounding box is merged to the bigger one.   Notice it is important to choose the parameters wisely. For instance,  [2.x.377]  = false and    [2.x.378]  = 1 returns the very same bounding box but with a   fraction of the computational cost.     This function does not take into account the curvature of cells and thus it   is not suited for handling curved geometry: the mapping is assumed to be   linear.  
* [0.x.64]*
   Given an array of points, use the global bounding box description obtained   using  [2.x.379]  to guess, for each of   them, which process might own it.      [2.x.380]  global_bboxes Vector of bounding boxes describing the portion of    mesh with a property for each process.    [2.x.381]  points Array of points to test.      [2.x.382]  A tuple containing the following information:
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A vector indicized with ranks of processes. For each rank it contains     a vector of the indices of points it might own.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A map from the index  [2.x.383]  of the point in  [2.x.384]      to the rank of the owner.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A map from the index  [2.x.385]  of the point in  [2.x.386]      to the ranks of the guessed owners.    
*  [2.x.387]  The actual return type of this function, i.e., the type referenced   above as  [2.x.388]  is  
* [1.x.20]
*    The type is abbreviated in the online documentation to improve readability   of this page.  
* [0.x.65]*
   Given a covering rtree (see  [2.x.389]  and an   array of points, find a superset of processes which, individually,   may own the cell containing the points.     For further details see  [2.x.390]  here only   different input/output types are reported:      [2.x.391]  covering_rtree RTRee which enables us to identify which   process(es) in a parallel computation may own the cell that   surrounds a given point.      [2.x.392]  points A vector of points to consider.      [2.x.393]  A tuple containing the following information:
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A map indexed by processor ranks. For each rank it contains     a vector of the indices of points it might own.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A map from the index  [2.x.394]  of the point in  [2.x.395]      to the rank of the owner; these are points for which a single possible     owner was found.
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - A map from the index  [2.x.396]  of the point in  [2.x.397]      to the ranks of the guessed owners; these are points for which multiple     possible owners were found.    
*  [2.x.398]  The actual return type of this function, i.e., the type referenced   above as  [2.x.399]  is  
* [1.x.21]
*    The type is abbreviated in the online documentation to improve readability   of this page.  
* [0.x.66]*
   Return the adjacent cells of all the vertices. If a vertex is also a   hanging node, the associated coarse cell is also returned. The vertices   are ordered by the vertex index. This is the number returned by the   function  [2.x.400] . Notice that only the indices   marked in the array returned by    [2.x.401]  are used.  
* [0.x.67]*
   Return a vector of normalized tensors for each vertex-cell combination of   the output of  [2.x.402]  (which is expected as input   parameter for this function). Each tensor represents a geometric vector   from the vertex to the respective cell center.     An assertion will be thrown if the size of the input vector is not equal to   the number of vertices of the triangulation.     result[v][c] is a unit Tensor for vertex index v, indicating the direction   of the center of the c-th cell with respect to the vertex v.  
* [0.x.68]*
   Return the local vertex index of cell  [2.x.403]  that is closest to   the given location  [2.x.404]  The location of the vertices is extracted   from the (optional)  [2.x.405]  argument, to guarantee that the correct   answer is returned when the underlying mapping modifies the position of the   vertices.  
* [0.x.69]*
   Compute a globally unique index for each vertex and hanging node   associated with a locally owned active cell. The vertices of a ghost cell   that are hanging nodes of a locally owned cells have a global index.   However, the other vertices of the cells that do not [1.x.22] an   active cell do not have a global index on this processor.     The key of the map is the local index of the vertex and the value is the   global index. The indices need to be recomputed after refinement or   coarsening and may be different.  
* [0.x.70]*
   Return the highest value among ratios between extents in each of the   coordinate directions of a  [2.x.406]  Moreover, return the dimension   relative to the highest elongation.      [2.x.407]  cell an iterator pointing to the cell.      [2.x.408]   A  [2.x.409]  int, double> such that the  [2.x.410]  value   is the dimension of the highest elongation and the  [2.x.411]  value is the   ratio among the dimensions of the  [2.x.412]   
* [0.x.71]*
    [2.x.413]  Partitions and subdomains of triangulations  
* [0.x.72]*
   Produce a sparsity pattern in which nonzero entries indicate that two   cells are connected via a common face. The diagonal entries of the   sparsity pattern are also set.     The rows and columns refer to the cells as they are traversed in their   natural order using cell iterators.  
* [0.x.73]*
   Produce a sparsity pattern in which nonzero entries indicate that two   cells are connected via a common vertex. The diagonal entries of the   sparsity pattern are also set.     The rows and columns refer to the cells as they are traversed in their   natural order using cell iterators.  
* [0.x.74]*
   Produce a sparsity pattern for a given level mesh in which nonzero entries   indicate that two cells are connected via a common vertex. The diagonal   entries of the sparsity pattern are also set.     The rows and columns refer to the cells as they are traversed in their   natural order using cell iterators.  
* [0.x.75]*
   Use graph partitioner to partition the active cells making up the entire   domain. After calling this function, the subdomain ids of all active cells   will have values   between zero and  [2.x.414]  You can access the subdomain id of a cell by using   <tt>cell- [2.x.415]      Use the third argument to select between partitioning algorithms provided   by METIS or ZOLTAN. METIS is the default partitioner.     If deal.II was not installed with ZOLTAN or METIS, this function will   generate an error   when corresponding partition method is chosen, unless  [2.x.416]  is one.   I.e., you can write a program so that it runs in the single-processor   single-partition case without packages installed, and only requires them   installed when multiple partitions are required.    
*  [2.x.417]  If the  [2.x.418]  signal has been attached to the  [2.x.419]    then this will be used and passed to the partitioner.  
* [0.x.76]*
   This function performs the same operation as the one above, except that   it takes into consideration a specific set of  [2.x.420]  which allow the   partitioner to balance the graph while taking into consideration the   computational effort expended on each cell.    
*  [2.x.421]  If the  [2.x.422]  vector is empty, then no weighting is taken   into consideration. If not then the size of this vector must equal to the   number of active cells in the triangulation.  
* [0.x.77]*
   This function does the same as the previous one, i.e. it partitions a   triangulation using a partitioning algorithm into a number of subdomains   identified by the  [2.x.423]  flag.     The difference to the previous function is the second argument, a   sparsity pattern that represents the connectivity pattern between cells.     While the function above builds it directly from the triangulation by   considering which cells neighbor each other, this function can take a   more refined connectivity graph. The sparsity pattern needs to be of size    [2.x.424] , where  [2.x.425]  is the number of active cells in the   triangulation. If the sparsity pattern contains an entry at position    [2.x.426] , then this means that cells  [2.x.427]  and  [2.x.428]  (in the order in which   they are traversed by active cell iterators) are to be considered   connected; partitioning algorithm will then try to partition the domain in   such a way that (i) the subdomains are of roughly equal size, and (ii) a   minimal number of connections are broken.     This function is mainly useful in cases where connections between cells   exist that are not present in the triangulation alone (otherwise the   previous function would be the simpler one to use). Such connections may   include that certain parts of the boundary of a domain are coupled   through symmetric boundary conditions or integrals (e.g. friction contact   between the two sides of a crack in the domain), or if a numerical scheme   is used that not only connects immediate neighbors but a larger   neighborhood of cells (e.g. when solving integral equations).     In addition, this function may be useful in cases where the default   sparsity pattern is not entirely sufficient. This can happen because the   default is to just consider face neighbors, not neighboring cells that   are connected by edges or vertices. While the latter couple when using   continuous finite elements, they are typically still closely connected in   the neighborship graph, and partitioning algorithm   will not usually cut important connections in this case. However, if there   are vertices in the mesh where many cells (many more than the common 4 or 6   in 2d and 3d, respectively) come together, then there will be a significant   number of cells that are connected across a vertex, but several degrees   removed in the connectivity graph built only using face neighbors. In a   case like this, partitioning algorithm may sometimes make bad decisions and   you may want to build your own connectivity graph.    
*  [2.x.429]  If the  [2.x.430]  signal has been attached to the  [2.x.431]    then this will be used and passed to the partitioner.  
* [0.x.78]*
   This function performs the same operation as the one above, except that   it takes into consideration a specific set of  [2.x.432]  which allow the   partitioner to balance the graph while taking into consideration the   computational effort expended on each cell.    
*  [2.x.433]  If the  [2.x.434]  vector is empty, then no weighting is taken   into consideration. If not then the size of this vector must equal to the   number of active cells in the triangulation.  
* [0.x.79]*
   Generates a partitioning of the active cells making up the entire domain   using the same partitioning scheme as in the p4est library if the flag    [2.x.435]  is set to true (default behavior of this function).   After calling this function, the subdomain ids of all active cells will   have values between zero and  [2.x.436]  You can access the   subdomain id of a cell by using <tt>cell- [2.x.437]     
*  [2.x.438]  If the flag  [2.x.439]  is set to false, children of a         cell might be placed on different processors even though they are all         active, which is an assumption made by p4est. By relaxing this, we         can create partitions owning a single cell (also for refined         meshes).  
* [0.x.80]*
   Partitions the cells of a multigrid hierarchy by assigning level subdomain   ids using the "youngest child" rule, that is, each cell in the hierarchy is   owned by the processor who owns its left most child in the forest, and   active cells have the same subdomain id and level subdomain id. You can   access the level subdomain id of a cell by using   <tt>cell- [2.x.440]      Note: This function assumes that the active cells have already been   partitioned.  
* [0.x.81]*
   This function allows to ask for the owning subdomain of cells identified by   CellId objects that do not have to exist on the current process.    
*  [2.x.441]  This function has not been implemented yet for      [2.x.442]   
* [0.x.82]*
   For each active cell, return in the output array to which subdomain (as   given by the <tt>cell->subdomain_id()</tt> function) it belongs. The   output array is supposed to have the right size already when calling this   function.     This function returns the association of each cell with one subdomain. If   you are looking for the association of each  [2.x.443]  DoF with a subdomain, use   the  [2.x.444]  function.  
* [0.x.83]*
   Count how many cells are uniquely associated with the given  [2.x.445]    index.     This function may return zero if there are no cells with the given  [2.x.446]    subdomain index. This can happen, for example, if you try to partition a   coarse mesh into more partitions (one for each processor) than there are   cells in the mesh.     This function returns the number of cells associated with one subdomain.   If you are looking for the association of  [2.x.447]  DoFs with this subdomain,   use the  [2.x.448]    function.  
* [0.x.84]*
   For a triangulation, return a mask that represents which of its vertices   are "owned" by the current process in the same way as we talk about   locally owned cells or degrees of freedom (see    [2.x.449]    and    [2.x.450] ).   For the purpose of this function, we define a locally owned vertex as   follows: a vertex is owned by that processor with the smallest subdomain   id (which equals the MPI rank of that processor) among all owners of   cells adjacent to this vertex. In other words, vertices that are in the   interior of a partition of the triangulation are owned by the owner of   this partition; for vertices that lie on the boundary between two or more   partitions, the owner is the processor with the least subdomain_id among   all adjacent subdomains.     For sequential triangulations (as opposed to, for example,    [2.x.451]  every user vertex is of course   owned by the current processor, i.e., the function returns    [2.x.452]  For parallel triangulations, the   returned mask is a subset of what  [2.x.453]    returns.      [2.x.454]  triangulation The triangulation of which the function evaluates   which vertices are locally owned.    [2.x.455]  The subset of vertices, as described above. The length of the   returned array equals Triangulation.n_vertices() and may, consequently,   be larger than  [2.x.456]   
* [0.x.85]*
    [2.x.457]  Comparing different meshes  
* [0.x.86]*
   Given two meshes (i.e. objects of type Triangulation or DoFHandler) that   are based on the same coarse mesh, this function figures out a set of cells   that are matched between the two meshes and where at most one of the meshes   is more refined on this cell. In other words, it finds the smallest cells   that are common to both meshes, and that together completely cover the   domain.     This function is useful, for example, in time-dependent or nonlinear   application, where one has to integrate a solution defined on one mesh   (e.g., the one from the previous time step or nonlinear iteration)   against the shape functions of another mesh (the next time step, the next   nonlinear iteration). If, for example, the new mesh is finer, then one   has to obtain the solution on the coarse mesh (mesh_1) and interpolate it   to the children of the corresponding cell of mesh_2. Conversely, if the   new mesh is coarser, one has to express the coarse cell shape function by   a linear combination of fine cell shape functions. In either case, one   needs to loop over the finest cells that are common to both   triangulations. This function returns a list of pairs of matching   iterators to cells in the two meshes that can be used to this end.     Note that the list of these iterators is not necessarily ordered, and   does also not necessarily coincide with the order in which cells are   traversed in one, or both, of the meshes given as arguments.      [2.x.458]  MeshType A type that satisfies the requirements of the    [2.x.459]  "MeshType concept".    
*  [2.x.460]  This function can only be used with    [2.x.461]  when both meshes use the same   Triangulation since, with a distributed Triangulation, not all cells are   stored locally, so the resulting list may not cover the entire domain.  
* [0.x.87]*
   Return true if the two triangulations are based on the same coarse mesh.   This is determined by checking whether they have the same number of cells   on the coarsest level, and then checking that they have the same   vertices.     The two meshes may have different refinement histories beyond the coarse   mesh.  
* [0.x.88]*
   The same function as above, but working on arguments of type DoFHandler.   This function is provided to allow calling have_same_coarse_mesh for all   types of containers representing triangulations or the classes built on   triangulations.      [2.x.462]  MeshType A type that satisfies the requirements of the    [2.x.463]  "MeshType concept".  
* [0.x.89]*
    [2.x.464]  Dealing with distorted cells  
* [0.x.90]*
   Given a triangulation and a list of cells whose children have become   distorted as a result of mesh refinement, try to fix these cells up by   moving the center node around.     The function returns a list of cells with distorted children that   couldn't be fixed up for whatever reason. The returned list is therefore   a subset of the input argument.     For a definition of the concept of distorted cells, see the    [2.x.465]  "glossary entry".   The first argument passed to the current function is typically the   exception thrown by the  [2.x.466]    function.  
* [0.x.91]*
    [2.x.467]  Extracting and creating patches of cells     These functions extract and create patches of cells surrounding a single   cell, and creating triangulation out of them.  
* [0.x.92]*
   This function returns a list of all the active neighbor cells of the   given, active cell.  Here, a neighbor is defined as one having at least   part of a face in common with the given cell, but not edge (in 3d) or   vertex neighbors (in 2d and 3d).     The first element of the returned list is the cell provided as argument.   The remaining ones are neighbors: The function loops over all faces of   that given cell and checks if that face is not on the boundary of the   domain. Then, if the neighbor cell does not have any children (i.e., it   is either at the same refinement level as the current cell, or coarser)   then this neighbor cell is added to the list of cells. Otherwise, if the   neighbor cell is refined and therefore has children, then this function   loops over all subfaces of current face adds the neighbors behind these   sub-faces to the list to be returned.      [2.x.468]  MeshType A type that satisfies the requirements of the    [2.x.469]  "MeshType concept".   In C++, the compiler can not determine  [2.x.470]  from the   function call. You need to specify it as an explicit template argument   following the function name.    [2.x.471]  cell An iterator pointing to a cell of the mesh.    [2.x.472]  A list of active cells that form the patch around the given cell    
*  [2.x.473]  Patches are often used in defining error estimators that require   the solution of a local problem on the patch surrounding each of the   cells of the mesh. This also requires manipulating the degrees of freedom   associated with the cells of a patch. To this end, there are further   functions working on patches in namespace DoFTools.    
*  [2.x.474]  In the context of a parallel distributed computation, it only makes   sense to call this function on locally owned cells. This is because the   neighbors of locally owned cells are either locally owned themselves, or   ghost cells. For both, we know that these are in fact the real cells of   the complete, parallel triangulation. We can also query the degrees of   freedom on these.  
* [0.x.93]*
   This function takes a vector of active cells (hereafter named  [2.x.475]    patch_cells) as input argument, and returns a vector of their parent   cells with the coarsest common level of refinement. In other words, find   that set of cells living at the same refinement level so that all cells   in the input vector are children of the cells in the set, or are in the   set itself.      [2.x.476]  Container In C++, the compiler can not determine the type of    [2.x.477]  from the function call. You need to specify it as   an explicit template argument following the function name. This type has   to satisfy the requirements of a mesh container (see    [2.x.478] ).      [2.x.479]  patch_cells A vector of active cells for which this function   finds the parents at the coarsest common level. This vector of cells   typically results from calling the function    [2.x.480]     [2.x.481]  A list of cells with the coarsest common level of refinement of   the input cells.  
* [0.x.94]*
   This function constructs a Triangulation (named  [2.x.482]    from a given vector of active cells. This vector (which we think of the   cells corresponding to a "patch") contains active cells that are part of   an existing global Triangulation. The goal of this function is to build a   local Triangulation that contains only the active cells given in  [2.x.483]    (and potentially a minimum number of additional cells required to form a   valid Triangulation). The function also returns a map that allows to   identify the cells in the output Triangulation and corresponding cells in   the input list.     The function copies the location of vertices of cells from the cells of the   source triangulation to the triangulation that is built from the list of   patch cells.  This adds support for triangulations which have been   perturbed or smoothed in some manner which makes the triangulation   deviate from the standard deal.II refinement strategy of placing new   vertices at midpoints of faces or edges.     The operation implemented by this function is frequently used in the   definition of error estimators that need to solve "local" problems on   each cell and its neighbors. A similar construction is necessary in the   definition of the Clement interpolation operator in which one needs to   solve a local problem on all cells within the support of a shape   function. This function then builds a complete Triangulation from a list   of cells that make up such a patch; one can then later attach a   DoFHandler to such a Triangulation.     If the list of input cells contains only cells at the same refinement   level, then the output Triangulation simply consists of a Triangulation   containing only exactly these patch cells. On the other hand, if the   input cells live on different refinement levels, i.e., the Triangulation   of which they are part is adaptively refined, then the construction of   the output Triangulation is not so simple because the coarsest level of a   Triangulation can not contain hanging nodes. Rather, we first have to   find the common refinement level of all input cells, along with their   common parents (see  [2.x.484]    build a Triangulation from those, and then adaptively refine it so that   the input cells all also exist in the output Triangulation.     A consequence of this procedure is that the output Triangulation may   contain more active cells than the ones that exist in the input vector.   On the other hand, one typically wants to solve the local problem not on   the entire output Triangulation, but only on those cells of it that   correspond to cells in the input list.  In this case, a user typically   wants to assign degrees of freedom only on cells that are part of the   "patch", and somehow ignore those excessive cells. The current function   supports this common requirement by setting the user flag for the cells   in the output Triangulation that match with cells in the input list.   Cells which are not part of the original patch will not have their  [2.x.485]    user_flag set; we can then avoid assigning degrees of freedom using the   FE_Nothing<dim> element.      [2.x.486]  Container In C++, the compiler can not determine the type of    [2.x.487]  from the function call. You need to specify it as   an explicit template argument following the function name. This type that   satisfies the requirements of a mesh container (see    [2.x.488] ).      [2.x.489]  patch A vector of active cells from a common triangulation.   These cells may or may not all be at the same refinement level.    [2.x.490]  local_triangulation A triangulation whose active cells   correspond to the given vector of active cells in  [2.x.491]     [2.x.492]  patch_to_global_tria_map A map between the local   triangulation which is built as explained above, and the cell iterators   in the input list.  
* [0.x.95]*
   This function runs through the degrees of freedom defined by the   DoFHandler and for each dof constructs a vector of   active_cell_iterators representing the cells of support of the associated   basis element at that degree of freedom. This function was originally   designed for the implementation of local projections, for instance the   Clement interpolant, in conjunction with other local patch functions like    [2.x.493]      DoFHandler's built on top of Triangulation or    [2.x.494]  are supported and handled   appropriately.     The result is the patch of cells representing the support of the basis   element associated to the degree of freedom.  For instance using an FE_Q   finite element, we obtain the standard patch of cells touching the degree   of freedom and then add other cells that take care of possible hanging node   constraints.  Using a FE_DGQ finite element, the degrees of freedom are   logically considered to be "interior" to the cells so the patch would   consist exclusively of the single cell on which the degree of freedom is   located.      [2.x.495]  dof_handler The DoFHandler which could be built on a   Triangulation or a  [2.x.496]  with a finite   element that has degrees of freedom that are logically associated to a   vertex, line, quad, or hex.    [2.x.497]  A map from the global_dof_index of   degrees of freedom on locally relevant cells to vectors containing    [2.x.498]  of cells in the support of the basis   function at that degree of freedom.  
* [0.x.96]*
    [2.x.499]  Dealing with periodic domains  
* [0.x.97]*
   Data type that provides all information necessary to create periodicity   constraints and a periodic p4est forest with respect to two 'periodic'   cell faces.  
* [0.x.98]*
     The cells associated with the two 'periodic' faces.    
* [0.x.99]*
     The local face indices (with respect to the specified cells) of the two     'periodic' faces.    
* [0.x.100]*
     The relative orientation of the first face with respect to the second     face as described in orthogonal_equality() and      [2.x.500]  (and stored as a bitset).    
* [0.x.101]*
     A  [2.x.501]   [2.x.502]   [2.x.503]  rotation matrix that describes how vector     valued DoFs of the first face should be modified prior to constraining     to the DoFs of the second face.         The rotation matrix is used in  [2.x.504]      by applying the rotation to all vector valued blocks listed in the     parameter  [2.x.505]  of the finite element space. For     more details see  [2.x.506]  and the     glossary      [2.x.507]  "glossary entry on periodic conditions".    
* [0.x.102]*
   An orthogonal equality test for faces.      [2.x.508]  and  [2.x.509]  are considered equal, if a one to one matching   between its vertices can be achieved via an orthogonal equality relation.     Here, two vertices <tt>v_1</tt> and <tt>v_2</tt> are considered equal, if    [2.x.510]  is parallel to the unit vector in unit   direction  [2.x.511]  If the parameter  [2.x.512]  is a reference to a   spacedim x spacedim matrix,  [2.x.513]  is set to  [2.x.514]  otherwise  [2.x.515]  is the   identity matrix.     If the matching was successful, the _relative_ orientation of  [2.x.516]    with respect to  [2.x.517]  is returned in the bitset  [2.x.518]  where  
* [1.x.23]
*      In 2D <tt>face_orientation</tt> is always <tt>true</tt>,   <tt>face_rotation</tt> is always <tt>false</tt>, and face_flip has the   meaning of <tt>line_flip</tt>. More precisely in 3d:     <tt>face_orientation</tt>: <tt>true</tt> if  [2.x.519]  and  [2.x.520]  have   the same orientation. Otherwise, the vertex indices of  [2.x.521]  match the   vertex indices of  [2.x.522]  in the following manner:    
* [1.x.24]
*      <tt>face_flip</tt>: <tt>true</tt> if the matched vertices are rotated by   180 degrees:    
* [1.x.25]
*      <tt>face_rotation</tt>: <tt>true</tt> if the matched vertices are rotated   by 90 degrees counterclockwise:    
* [1.x.26]
*      and any combination of that... More information on the topic can be found   in the    [2.x.523]  "glossary"   article.  
* [0.x.103]*
   Same function as above, but doesn't return the actual orientation  
* [0.x.104]*
   This function will collect periodic face pairs on the coarsest mesh level   of the given  [2.x.524]  (a Triangulation or DoFHandler) and add them to the   vector  [2.x.525]  leaving the original contents intact.     Define a 'first' boundary as all boundary faces having boundary_id  [2.x.526]    b_id1 and a 'second' boundary consisting of all faces belonging to  [2.x.527]    b_id2.     This function tries to match all faces belonging to the first boundary   with faces belonging to the second boundary with the help of   orthogonal_equality().     The bitset that is returned inside of PeriodicFacePair encodes the   _relative_ orientation of the first face with respect to the second face,   see the documentation of orthogonal_equality() for further details.     The  [2.x.528]  refers to the space direction in which periodicity is   enforced. When matching periodic faces this vector component is ignored.     The  [2.x.529]  is a vector tangential to the faces that is added to the   location of vertices of the 'first' boundary when attempting to match   them to the corresponding vertices of the 'second' boundary. This can be   used to implement conditions such as  [2.x.530] .     Optionally, a  [2.x.531]  rotation  [2.x.532]  can be specified that   describes how vector valued DoFs of the first face should be modified   prior to constraining to the DoFs of the second face. The  [2.x.533]  is   used in two places. First,  [2.x.534]  will be supplied to   orthogonal_equality() and used for matching faces: Two vertices  [2.x.535]  and    [2.x.536]  match if  [2.x.537]  is parallel   to the unit vector in unit direction  [2.x.538]  (For more details see    [2.x.539]  the glossary    [2.x.540]  "glossary entry on periodic conditions"   and  [2.x.541] ). Second,  [2.x.542]  will be stored in the PeriodicFacePair   collection  [2.x.543]  for further use.      [2.x.544]  MeshType A type that satisfies the requirements of the    [2.x.545]  "MeshType concept".    
*  [2.x.546]  The created  [2.x.547]  can be used in    [2.x.548]  and in    [2.x.549]  to enforce   periodicity algebraically.    
*  [2.x.550]  Because elements will be added to  [2.x.551]  (and existing   entries will be preserved), it is possible to call this function several   times with different boundary ids to generate a vector with all periodic   pairs.    
*  [2.x.552]  Since the periodic face pairs are found on the coarsest mesh level,   it is necessary to ensure that the coarsest level faces have the correct   boundary indicators set. In general, this means that one must first set   all boundary indicators on the coarse grid before performing any global   or local grid refinement.  
* [0.x.105]*
   This compatibility version of collect_periodic_faces() only works on   grids with cells in    [2.x.553]  "standard orientation".     Instead of defining a 'first' and 'second' boundary with the help of two   boundary_ids this function defines a 'left' boundary as all faces with   local face index  [2.x.554]  and boundary indicator  [2.x.555]    and, similarly, a 'right' boundary consisting of all face with local face   index  [2.x.556]  and boundary indicator  [2.x.557]  Faces   with coordinates only differing in the  [2.x.558]  component are   identified.     This function will collect periodic face pairs on the coarsest mesh level   and add them to  [2.x.559]  leaving the original contents intact.     See above function for further details.    
*  [2.x.560]  This version of collect_periodic_faces() will not work on   meshes with cells not in    [2.x.561]  "standard orientation".  
* [0.x.106]*
    [2.x.562]  Dealing with boundary and manifold ids  
* [0.x.107]*
   Copy boundary ids to manifold ids on faces and edges at the boundary. The   default manifold_id for new Triangulation objects is    [2.x.563]  This function copies the boundary_ids of   the boundary faces and edges to the manifold_ids of the same faces and   edges, allowing the user to change the boundary_ids and use them for   boundary conditions regardless of the geometry, which will use   manifold_ids to create new points. Only active cells will be iterated   over. This is a function you'd typically call when there is only one   active level on your Triangulation. Mesh refinement will then inherit   these indicators to child cells, faces, and edges.     The optional parameter  [2.x.564]  indicates whether this   function should reset the boundary_ids of boundary faces and edges to its   default value 0 after copying its value to the manifold_id. By default,   boundary_ids are left untouched.    
*  [2.x.565]     [2.x.566]  boundary  
* [0.x.108]*
   Map the given boundary ids to the given manifold ids on faces and   edges at the boundary.     This function copies the boundary ids of the boundary faces and   edges that are present in the parameter  [2.x.567]  to   the corresponding manifold id in  [2.x.568]  of the same   faces and edges.     If the optional parameter  [2.x.569]  is non empty,   each boundary id in  [2.x.570]  is replaced with the   corresponding boundary id in  [2.x.571]      An exception is thrown if the size of the input vectors do not   match. If a boundary id indicated in  [2.x.572]  is not   present in the triangulation, it is simply ignored during the   process.    
*  [2.x.573]     [2.x.574]  boundary  
* [0.x.109]*
   Copy material ids to manifold ids. The default manifold_id for new   Triangulation objects is  [2.x.575]  When refinements   occurs, the Triangulation asks where to locate new points to the   underlying manifold.     When reading a Triangulation from a supported input format, typical   information that can be stored in a file are boundary conditions for   boundary faces (which we store in the boundary_id of the faces), material   types for cells (which we store in the material_id of the cells) and in   some cases subdomain ids for cells (which we store in the subdomain_id of   the cell).     If you read one of these grids into a Triangulation, you might still want   to use the material_id specified in the input file as a manifold_id   description. In this case you can associate a Manifold object to internal   cells, and this object will be used by the Triangulation to query   Manifold objects for new points. This function iterates over active cells   and copies the material_ids to the manifold_ids.     The optional parameter  [2.x.576]  indicates whether this   function should also set the manifold_ids of the faces (both for internal   faces and for faces on the boundary). If set to true, then each face will   get a manifold_id equal to the minimum of the surrounding manifold_ids,   ensuring that a unique manifold id is selected for each face of the   Triangulation. By default, face manifold_ids are not computed.    
*  [2.x.577]   
* [0.x.110]*
   Propagate manifold indicators associated with the cells of the   Triangulation  [2.x.578]  to their co-dimension one and two objects.     This function sets the  [2.x.579]  of faces and edges (both on the   interior and on the boundary) to the value returned by the    [2.x.580]  method, called with the set of   manifold indicators of the cells that share the same face or edge.     By default, the  [2.x.581]  returns    [2.x.582]  when the set has size greater than one (i.e.,   when it is not possible to decide what manifold indicator a face or edge   should have according to the manifold indicators of the adjacent cells)   and it returns the manifold indicator contained in the set when it has   dimension one (i.e., when all adjacent cells and faces have the same   manifold indicator).     The parameter  [2.x.583]  allows you to specify   what to do when a face or an edge already has a manifold indicator   different from  [2.x.584]  If the flag is  [2.x.585]  the edge   or face will maintain its original manifold indicator.   If it is  [2.x.586]  then also the manifold indicator of these faces and edges   is set according to the return value of the  [2.x.587]   
* [0.x.111]*
   Exchange arbitrary data of type  [2.x.588]  provided by the function   objects from locally owned cells to ghost cells on other processors.     After this call, you typically will have received data from  [2.x.589]  on   every ghost cell as it was given by  [2.x.590]  on the owning processor.   Whether you do or do not receive information to  [2.x.591]  on a given   ghost cell depends on whether the  [2.x.592]  function decided that   something needs to be sent. It does so using the  [2.x.593]    mechanism: if the  [2.x.594]  return object of the  [2.x.595]    function is empty, then this implies that no data has to be sent for   the locally owned cell it was called on. In that case,  [2.x.596]  will   also not be called on the ghost cell that corresponds to it on the   receiving side. On the other hand, if the  [2.x.597]  object is   not empty, then the data stored within it will be sent to the received   and the  [2.x.598]  function called with it.      [2.x.599]  DataType The type of the data to be communicated. It is assumed     to be serializable by  [2.x.600]  In many cases, this     data type can not be deduced by the compiler, e.g., if you provide     lambda functions for the second and third argument     to this function. In this case, you have to explicitly specify     the  [2.x.601]  as a template argument to the function call.    [2.x.602]  MeshType The type of  [2.x.603]       [2.x.604]  mesh A variable of a type that satisfies the requirements of the    [2.x.605]  "MeshType concept".    [2.x.606]  pack The function that will be called on each locally owned cell     that is a ghost cell somewhere else. As mentioned above, the function     may return a regular data object of type  [2.x.607]  to indicate     that data should be sent, or an empty      [2.x.608]  to indicate that nothing has     to be sent for this cell.    [2.x.609]  unpack The function that will be called for each ghost cell     for which data was sent, i.e., for which the  [2.x.610]  function     on the sending side returned a non-empty  [2.x.611]  object.     The  [2.x.612]  function is then called with the data sent by the     processor that owns that cell.    [2.x.613]  cell_filter Only cells are communicated where this filter function returns     the value `true`. In the default case, the function returns true on all   cells and thus, all relevant cells are communicated.     [1.x.27]     Here is an example that shows how this function is to be used   in a concrete context. It is taken from the code that makes   sure that the  [2.x.614]  (a single unsigned integer) is   transported from locally owned cells where one can set it in   DoFHandler objects with hp-capabilities, to the corresponding ghost cells   on other processors to ensure that one can query the right value also on   those processors:  
* [1.x.28]
*      You will notice that the  [2.x.615]  lambda function returns an `unsigned int`,   not a  [2.x.616]  int>`. The former converts   automatically to the latter, implying that data will always be transported   to the other processor.     (In reality, the  [2.x.617]  function needs to be a bit more   complicated because it is not allowed to call    [2.x.618]  on ghost cells. Rather, the    [2.x.619]  function directly accesses internal data structures. But   you get the idea
* 
*  -  the code could, just as well, have exchanged   material ids, user indices, boundary indicators, or any kind of other   data with similar calls as the ones above.)  
* [0.x.112]*
   Exchange arbitrary data of type  [2.x.620]  provided by the function   objects from locally owned level cells to ghost level cells on other   processes.     In addition to the parameters of exchange_cell_data_to_ghosts(), this   function allows to provide a  [2.x.621]  function, which can be used to only   communicate marked cells. In the default case, all relevant cells are   communicated.  
* [0.x.113] Exchange with all processors of the MPI communicator  [2.x.622]  the vector of bounding   boxes  [2.x.623]      This function is meant to exchange bounding boxes describing the locally   owned cells in a distributed triangulation obtained with the function    [2.x.624]  .     The output vector's size is the number of processes of the MPI   communicator:   its i-th entry contains the vector  [2.x.625]  of the i-th process.  
* [0.x.114]*
   In this collective operation each process provides a vector   of bounding boxes and a communicator.   All these vectors are gathered on each of the processes,   organized in a search tree which, and then returned.     The idea is that the vector of bounding boxes describes a   relevant property of the computations on each process   individually, which could also be of use to other processes. An   example would be if the input vector of bounding boxes   corresponded to a covering of the locally owned partition of a   mesh (see    [2.x.626] )   of a    [2.x.627]  object. While these may   overlap the bounding boxes of other processes, finding which   process owns the cell that encloses a given point is vastly   easier if the process trying to figure this out has a list of   bounding boxes for each of the other processes at hand.     The returned search tree object is an r-tree with packing   algorithm, which is provided by boost library. See   https://www.boost.org/doc/libs/1_67_0/libs/geometry/doc/html/geometry/spatial_indexes/introduction.html   for more information.     In the returned tree, each node contains a pair of elements:   the first being a bounding box,   the second being the rank of the process whose local description   contains the bounding box.    
*  [2.x.628]  This function is a collective operation.  
* [0.x.115]*
   Collect for a given triangulation all locally relevant vertices that   coincide due to periodicity.     Coinciding vertices are put into a group, e.g.: [1, 25, 51], which is   labeled by an arbitrary element from it, e.g.: "1". All coinciding vertices   store the label to its group, so that they can quickly access all the   coinciding vertices in that group: e.g.: 51
* 
->  "1"
* 
-> [1, 25, 51]      [2.x.629]  tria Triangulation.    [2.x.630]  coinciding_vertex_groups A map of equivalence classes (of               coinciding vertices) labeled by an arbitrary element from them.               Vertices not coinciding are ignored.    [2.x.631]  vertex_to_coinciding_vertex_group Map of a vertex to the label               of a group of coinciding vertices. Vertices not contained in               this vector are not coinciding with any other vertex.  
* [0.x.116]*
   Return a map that, for each vertex, lists all the processes whose   subdomains are adjacent to that vertex.      [2.x.632]  tria Triangulation.  
* [0.x.117]*
   A structure that allows the transfer of cell data of type  [2.x.633]  from one processor   to another. It corresponds to a packed buffer that stores a vector of   CellId and a vector of type  [2.x.634]      This class facilitates the transfer by providing the save/load functions   that are able to pack up the vector of CellId's and the associated   data of type  [2.x.635]  into a stream.     Type  [2.x.636]  is assumed to be serializable by  [2.x.637]  (for   example  [2.x.638] ).  
* [0.x.118]*
     A vector to store IDs of cells to be transferred.    
* [0.x.119]*
     A vector of cell data to be transferred.    
* [0.x.120]*
     Write the data of this object to a stream for the purpose of     serialization using the [BOOST serialization     library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html)          [2.x.639]  The user is responsible to keep the size of  [2.x.640]      equal to the size as  [2.x.641]  .    
* [0.x.121]*
     Read the data of this object from a stream for the purpose of     serialization using the [BOOST serialization     library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).     Throw away the previous content.    
* [0.x.122]*
     Read or write the data of this object to or from a stream for the     purpose of serialization using the [BOOST serialization     library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).    
* [0.x.123]*
   An implementation of the marching-square (2D) and marching-cube algorithm   for creating data structures (vectors of Point and CellData) to   create a linear/bilinear surface mesh on the iso line/contour of a   scalar field.     To improve the approximation of the iso line/contour and the resulting   linear surface mesh, one increases the number of subdivision so that the   algorithm is not run on a cell but on subcells with vertex values having   been interpolated from the cell values.    
*  [2.x.642]  The resulting mesh will contain lines in 2D and triangles in 3D.    
*  [2.x.643]  The resulting mesh will not be of high quality, since it might     contain cells with very small diameters if the mesh is cut close to a     vertex.  
* [0.x.124]*
     Value type of vector.    
* [0.x.125]*
     Constructor.    
* [0.x.126]*
     Process all locally-owned cells and fill  [2.x.644]  and  [2.x.645]  for all     cells that are cut.    
* [0.x.127]*
     Process the provided cell and fill  [2.x.646]  and  [2.x.647]  for all cells     that are cut.        
*  [2.x.648]  The resulting vectors are empty if the cell is not cut.    
* [0.x.128]*
     Internal function to create a quadrature rule with n_subdivisions+1     equally-positioned quadrature points.    
* [0.x.129]*
     Process a cell.    
* [0.x.130]*
     Process a sub-cell (2D).        
*  [2.x.649]  Subcells with saddle points are ignored. Please increase the number       of subdivisions in this case.    
* [0.x.131]*
     Process a sub-cell (3D).    
* [0.x.132]*
     Number of subdivisions each cell is subdivided into in each direction to     improve the approximation.    
* [0.x.133]*
     Absolute tolerance specifying the minimum distance between a vertex and     the cut point so that a line is considered cut.    
* [0.x.134]*
     FEValues used internally and set up with a quadrature rule with the     correct number of subdivisions.    
* [0.x.135]*
    [2.x.650]  Exceptions  
* [0.x.136]*
   Exception  
* [0.x.137]*
   Exception  
* [0.x.138]*
   Exception  
* [0.x.139]*
   Exception  
* [0.x.140]*
   Exception  
* [0.x.141]*
 An exception that is thrown whenever the edges of a mesh are not orientable.
* 

* 
*  [2.x.651]  for backwards compatibility with the old GridReordering class this exception is not in the GridTools namespace.
* 

* 
*  [2.x.652] 

* 
* [0.x.142]*
       The method  [2.x.653]  requires taking derivatives       along the surface of a simplex. In general these cannot be       approximated with finite differences but special differences of the       form                 df/dx_i
* 
*  - df/dx_j              [2.x.654] can [2.x.655]  be approximated. This  [2.x.656]  just stores       the two derivatives approximated by the stencil (in the case of the       example above  [2.x.657] ).      
* [0.x.143]*
       Standard second-order approximation to the first derivative with a       two-point centered scheme. This is used below in a 1D Newton method.      
* [0.x.144]*
       Standard second-order approximation to the second derivative with a       three-point centered scheme. This is used below in a 1D Newton method.      
* [0.x.145]*
       Fourth order approximation of the derivative                 df/dx_i
* 
*  - df/dx_j             where  [2.x.658]  are specified by  [2.x.659]        cross_derivative. The derivative approximation is at  [2.x.660]  with a       step size of  [2.x.661]  and function  [2.x.662]       
* [0.x.146]*
       The optimization algorithm used in  [2.x.663]  is       essentially a gradient descent method. This function computes entries       in the gradient of the objective function; see the description in the       comments inside  [2.x.664]  for more information.      
* [0.x.147]*
       Project onto a d-linear object. This is more accurate than the       general algorithm in project_to_object but only works for geometries       described by linear, bilinear, or trilinear mappings.      
* [0.x.148]

include/deal.II-translator/grid/grid_tools_cache_0.txt
[0.x.0]*
   A class that caches computationally intensive information about a   Triangulation.     This class attaches a signal to the Triangulation passed at construction   time to keep track about refinement changes, and allows the user to query   some of the data structures constructed using functions in the GridTools   namespace which are computed only once, and then cached inside this class   for faster access whenever the triangulation has not changed.     Notice that this class only notices if the underlying Triangulation has   changed due to a  [2.x.0]  signal being   triggered.     If the triangulation changes for other reasons, for example because you   use it in conjunction with a MappingQEulerian object that sees the   vertices through its own transformation, or because you manually change   some vertex locations, then some of the structures in this class become   obsolete, and you will have to mark them as outdated, by calling the   method mark_for_update() manually.  
* [0.x.1]*
     Constructor.         If you provide the optional `mapping` argument, then this is used     whenever a mapping is required.          [2.x.1]  tria The triangulation for which to store information      [2.x.2]  mapping The mapping to use when computing cached objects    
* [0.x.2]*
     Destructor.    
* [0.x.3]*
     Make sure that the objects marked for update are recomputed during     subsequent calls to the `get_*` functions defined in this class.         Notice that no work is performed when you call this function. The actual     data structures are computed the next time you call the corresponding     `get_*` method.          [2.x.3]  flags What to mark for update    
* [0.x.4]*
     Return the cached vertex_to_cell_map as computed by      [2.x.4]     
* [0.x.5]*
     Return the cached vertex_to_cell_centers_directions as computed by      [2.x.5]     
* [0.x.6]*
     Return the cached map of used vertices, as computed by      [2.x.6]     
* [0.x.7]*
     Return the cached RTree object for the vertices, constructed using the     used vertices of the triangulation.    
* [0.x.8]*
     Return the cached RTree object of the cell bounding boxes, constructed     using the active cell iterators of the stored triangulation. For      [2.x.7]  objects, this function will return     also the bounding boxes of ghost and artificial cells.    
* [0.x.9]*
     Return the cached RTree object of bounding boxes containing locally owned     active cells, constructed using the active cell iterators of the stored     triangulation.         In contrast to the previous function, this function builds the RTree     using only the locally owned cells, i.e., not including ghost or     artificial cells. The two functions return the same result in serial     computations.    
* [0.x.10]*
     Returns the vector of set of integer containing the subdomain id     to which each vertex is connected to. This feature is used extensively     in the particle_handler to detect on which processors ghost particles     must be built.    
* [0.x.11]*
     Return a reference to the stored triangulation.    
* [0.x.12]*
     Return a reference to the stored mapping.    
* [0.x.13]*
     This function returns an object that allows identifying     which process(es) in a parallel computation may own the     cell that surrounds a given point. The elements of this     object
* 
*  -  an Rtree
* 
*  -  are pairs of bounding boxes denoting     areas that cover all or parts of the local portion of a     parallel triangulation, and an unsigned int representing     the process or subdomain that owns the cells falling within the given     bounding box.         Given a point on a  [2.x.8]  this tree     allows to identify one, or few candidate processes, for     which the point lies on a locally owned cell.         Constructing or updating the rtree requires a call to      [2.x.9]  which exchanges     bounding boxes between all processes using      [2.x.10]  a collective operation.     Therefore this function must be called by all processes     at the same time.         The local bounding boxes are constructed by extracting the     specified  [2.x.11]  from the rtree object returned by the     get_locally_owned_cell_bounding_boxes_rtree(). Notice that  [2.x.12]      in this context does not refer to the level of the triangulation, but     refer to the level of the RTree object (see, e.g.,     https://en.wikipedia.org/wiki/R-tree).    
* [0.x.14]*
     Keep track of what needs to be updated next.    
* [0.x.15]*
     A pointer to the Triangulation.    
* [0.x.16]*
     Mapping to use when computing on the Triangulation.    
* [0.x.17]*
     Store vertex to cell map information, as generated by      [2.x.13]     
* [0.x.18]*
     Store vertex to cell center directions, as generated by      [2.x.14]     
* [0.x.19]*
     A collection of rtree objects covering the whole mesh.         Each entry of the map is constructed from the function     extract_rtree_level() applied to the rtree returned by the function     get_locally_owned_cell_bounding_boxes_rtree(), with the specified level     in input.    
* [0.x.20]*
     Store the used vertices of the Triangulation, as generated by      [2.x.15]     
* [0.x.21]*
     Store an RTree object, containing the used vertices of the triangulation.    
* [0.x.22]*
     Store an RTree object, containing the bounding boxes of the cells of the     triangulation.    
* [0.x.23]*
     Store an RTree object, containing the bounding boxes of the locally owned     cells of the triangulation.    
* [0.x.24]*
     Store an  [2.x.16]  of  [2.x.17]  of integer containing the id of all     subdomain to which a vertex is connected to.    
* [0.x.25]*
     Storage for the status of the triangulation signal.    
* [0.x.26]

include/deal.II-translator/grid/grid_tools_cache_update_flags_0.txt
[0.x.0]*
   The enum type given to the Cache class to select what   information to update.     You can select more than one flag by concatenation using the bitwise or    [2.x.0] .  
* [0.x.1]*
     Update Nothing.    
* [0.x.2]*
     Update vertex_to_cell_map, as returned by      [2.x.1]     
* [0.x.3]*
     Update vertex_to_cell_centers_directions, as returned by      [2.x.2]     
* [0.x.4]*
     Update a mapping of used vertices.    
* [0.x.5]*
     Update an RTree of the used vertices.    
* [0.x.6]*
     Update an RTree of the cell bounding boxes.    
* [0.x.7]*
     Update the covering rtree object, initialized with pairs     of a bounding box and an unsigned int. The bounding     boxes are used to describe approximately which portion     of the mesh contains locally owned cells by the     process of rank the second element of the pair.    
* [0.x.8]*
     Update an RTree of locally owned cell bounding boxes.    
* [0.x.9]*
     Update vertex to neighbor subdomain    
* [0.x.10]*
     Update all objects.    
* [0.x.11]*
   Output operator which outputs assemble flags as a set of or'd text values.      [2.x.3]   
* [0.x.12]*
   Global operator which returns an object in which all bits are set which are   either set in the first or the second argument. This operator exists since   if it did not then the result of the bit-or <tt>operator |</tt> would be an   integer which would in turn trigger a compiler warning when we tried to   assign it to an object of type CacheUpdateFlags.      [2.x.4]   
* [0.x.13]*
   Global operator which returns an object in which all bits are set which are   not set in the argument. This operator exists since   if it did not then the result of the bit-negation <tt>operator ~</tt> would   be an integer which would in turn trigger a compiler warning when we tried   to assign it to an object of type CacheUpdateFlags.      [2.x.5]   
* [0.x.14]*
   Global operator which sets the bits from the second argument also in the   first one.      [2.x.6]   
* [0.x.15]*
   Global operator which returns an object in which all bits are set which are   set in the first as well as the second argument. This operator exists since   if it did not then the result of the bit-and <tt>operator &</tt> would be   an integer which would in turn trigger a compiler warning when we tried to   assign it to an object of type CacheUpdateFlags.      [2.x.7]   
* [0.x.16]*
   Global operator which clears all the bits in the first argument if they are   not also set in the second argument.      [2.x.8]   
* [0.x.17]

include/deal.II-translator/grid/intergrid_map_0.txt
[0.x.0]*
 This class provides a map between two grids which are derived from the same coarse grid. For each cell iterator of the source map, it provides the respective cell iterator on the destination map, through its <tt>operator []</tt>.
*  Usually, the two grids will be refined differently. Then, the value returned for an iterator on the source grid will be either:  [2.x.0]   [2.x.1]  The same cell on the destination grid, if it exists there;  [2.x.2]  The most refined cell of the destination grid from which the pendant of the source cell could be obtained by refinement. This cell is always active and has a refinement level less than that of the source cell.  [2.x.3]  Keys for this map are all cells on the source grid, whether active or not.
*  For example, consider these two one-dimensional grids:

* 
* [1.x.0]
*  (Cell numbers are only given as an example and will not correspond to real cell iterator's indices.) The mapping from grid 1 to grid 2 will then be as follows:

* 
* [1.x.1]
*  Besides the mappings shown here, the non-active cells on grid 1 are also valid keys. For example, the mapping for the mother cell of cells 1 and 2 on the first grid will point to cell 1 on the second grid.
*   [2.x.4]  MeshType This class may be used with any class that satisfies the  [2.x.5]  "MeshType concept". The extension to other classes offering iterator functions and some minor additional requirements is simple.
*  Note that this class could in principle be based on the C++  [2.x.6]  data type. Instead, it uses another data format which is more effective both in terms of computing time for access as well as with regard to memory consumption.
* 

*  [1.x.2]
*  In practice, use of this class is as follows:

* 
* [1.x.3]
* 
*  Note that the template parameters to this class have to be given as <tt>InterGridMap<DoFHandler<2> ></tt>, which here is DoFHandler (and could equally well be Triangulation or PersistentTriangulation).
* 

* 
*  [2.x.7] 

* 
* [0.x.1]*
   Typedef to the iterator type of the grid class under consideration.  
* [0.x.2]*
   Constructor setting the class name arguments in the SmartPointer members.  
* [0.x.3]*
   Create the mapping between the two grids.  
* [0.x.4]*
   Access operator: give a cell on the source grid and receive the   respective cell on the other grid, or if that does not exist, the most   refined cell of which the source cell would be created if it were further   refined.  
* [0.x.5]*
   Delete all data of this class.  
* [0.x.6]*
   Return a reference to the source grid.  
* [0.x.7]*
   Return a reference to the destination grid.  
* [0.x.8]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.9]*
   Exception  
* [0.x.10]*
   Exception  
* [0.x.11]*
   The actual data. Hold one iterator for each cell on each level.  
* [0.x.12]*
   Store a pointer to the source grid.  
* [0.x.13]*
   Likewise for the destination grid.  
* [0.x.14]*
   Set the mapping for the pair of cells given. These shall match in level   of refinement and all other properties.  
* [0.x.15]*
   Set the value of the key  [2.x.8]  to  [2.x.9]  Do so as well for   all the children and their children of  [2.x.10]  This function is used   for cells which are more refined on  [2.x.11]  than on  [2.x.12]  then   all values of the hierarchy of cells and their children point to one cell   on the  [2.x.13]   
* [0.x.16]

include/deal.II-translator/grid/magic_numbers_0.txt
[0.x.0]

include/deal.II-translator/grid/manifold_0.txt
[0.x.0]*
 We collect here some helper functions used in the Manifold<dim,spacedim> classes.

* 
* [0.x.1]*
   A  [2.x.0]  helper function that returns the number of   default points for the structure type pointed to by the given    [2.x.1] . See the documentation of    [2.x.2]  for more information.  
* [0.x.2]*
   Given a general mesh iterator, construct arrays of quadrature points and   weights that contain the following points:
* 

* 
* 

* 
* 

* 
* 
*  - If the iterator points to a line, then the quadrature points     are the two vertices of the line. This results in a point vector     with two points.
* 

* 
* 

* 
* 

* 
* 
*  - If the iterator points to a quad, then the quadrature points     are the vertices and line mid-points. This results in a point vector     with eight (4+4) points.
* 

* 
* 

* 
* 

* 
* 
*  - If the iterator points to a hex, then the quadrature points     are the vertices, the line mid-points, and the face mid-points.     This results in a points vector with 26 (8+12+6) points.     The quadrature weights for these points are either chosen identically and   equal to one over the number of quadrature points (if  [2.x.3]    with_interpolation is  [2.x.4]  or in a way that gives points closer to   the cell center (measured on the reference cell) a higher weight. These   weights correspond to the weights applied to lines and vertices in   transfinite interpolation (see TransfiniteInterpolationManifold for a   more thorough description) if  [2.x.5]  is  [2.x.6]      The function is primarily used to construct the input argument   for the  [2.x.7]  function, which computes a new   point on a manifold based on a weighted average of "surrounding"   points represented by the quadrature points and weights stored in the   returned pair of vectors. This function creates such an object based on   the points that "surround" a cell, face, or edge, and weights   are chosen in a way appropriate for computing the new "mid-point"   of the object pointed to. An example of where this is necessary   is for mesh refinement, where (using the 2d situation as an example)   we need to first create new edge mid-points, and then a new cell-point.      [2.x.8]  iterator A mesh iterator that points to either a line, quad,     or hex.    [2.x.9]  with_interpolation Whether or not to compute the quadrature   weights from transfinite interpolation, as discussed above.    [2.x.10]  MeshIteratorType An iterator type that corresponds to either      [2.x.11]  (or variants such as      [2.x.12]  or  [2.x.13]  or     that is the result of statements such as      [2.x.14] .  
* [0.x.3]*
 Manifolds are used to describe the geometry of boundaries of domains as well as the geometry of the interior. Manifold objects are therefore associated with cells, faces, and/or edges, either by direct user action or, if a user program does not do this explicitly, a default manifold object is used.
*  Manifolds are best understood by using the language of differential geometry, but their common uses can be easily described simply through examples. An exhaustive discussion of how, where, and why this class is used is provided in the  [2.x.15]  "geometry paper".
* 

*  [1.x.0]
*  In the most essential use of manifolds, manifold descriptions are used to create a "point between other points". For example, when a triangulation creates a new vertex on a cell, face, or edge, it determines the new vertex' coordinates through the following function call:  
* [1.x.1]
*  Here,  [2.x.16]  is a collection of points in  [2.x.17]  dimension, and  [2.x.18]  collection of corresponding weights. The points in this context will then be the vertices of the cell, face, or edge, and the weights are typically one over the number of points when a new midpoint of the cell, face, or edge is needed. Derived classes then will implement the  [2.x.19]  function in a way that computes the location of this new point. In the simplest case, for example in the FlatManifold class, the function simply computes the arithmetic average (with given weights) of the given points. However, other classes do something differently; for example, the SphericalManifold class, which is used to describe domains that form (part of) the sphere, will ensure that, given the two vertices of an edge at the boundary, the new returned point will lie on the grand circle that connects the two points, rather than choosing a point that is half-way between the two points in  [2.x.20] .
* 

* 

* 
*  [2.x.21]  Unlike almost all other cases in the library, we here interpret the points to be in real space, not on the reference cell.
*   [2.x.22]  has a default implementation that can simplify this process somewhat: Internally, the function calls the  [2.x.23]  to compute pair-wise intermediate points. Internally the  [2.x.24]  calls the  [2.x.25]  function after computing the convex combination of the given points.  This allows derived classes to only overload  [2.x.26]  for simple situations. This is often useful when describing manifolds that are embedded in higher dimensional space, e.g., the surface of a sphere.  In those cases, the desired new point may be computed simply by the (weighted) average of the provided points, projected back out onto the sphere.
* 

*  [1.x.2]
*  The second use of this class is in computing directions on domains and boundaries. For example, we may need to compute the normal vector to a face in order to impose the no-flow boundary condition  [2.x.27]  (see the  [2.x.28]  as an example). Similarly, we may need normal vectors in the computation of the normal component of the gradient of the numerical solution in order to compute the jump in the gradient of the solution in error estimators (see, for example, the KellyErrorEstimator class).
*  To make this possible, the Manifold class provides a member function (to be implemented by derived classes) that computes a "vector tangent to the manifold at one point, in direction of another point" via the  [2.x.29]  function. For example, in 2d, one would use this function with the two vertices of an edge at the boundary to compute a "tangential" vector along the edge, and then get the normal vector by rotation by 90 degrees. In 3d, one would compute the two vectors "tangential" to the two edges of a boundary face adjacent to a boundary vertex, and then take the cross product of these two to obtain a vector normal to the boundary.
*  For reasons that are more difficult to understand, these direction vectors are normalized in a very specific way, rather than to have unit norm. See the documentation of  [2.x.30]  as well as below, for more information.
*  In the simplest case (namely, the FlatManifold class), these tangent vectors are just the difference vector between the two given points. However, in more complicated (and more interesting) cases, the direction may be different. For example, for the SphericalManifold case, if the two given points lie on a common grand circle around the origin, then the tangent vector will be tangential to the grand circle, rather than pointing straight from one point to the other.
* 

*  [1.x.3]
*  The "real" way to understand what this class does is to see it in the framework of differential geometry. More specifically, differential geometry is fundamentally based on the assumption that two sufficiently close points are connected via a line of "shortest distance". This line is called a "geodesic", and it is selected from all other lines that connect the two points by the property that it is shortest if distances are measured in terms of the "metric" that describes a manifold. To give examples, recall that the geodesics of a flat manifold (implemented in the FlatManifold class) are simply the straight lines connecting two points, whereas for spherical manifolds (see the SphericalManifold class) geodesics between two points of same distance are the grand circles, and are in general curved lines when connecting two lines of different distance from the origin.
*  In the following discussion, and for the purposes of implementing the current class, the concept of "metrics" that is so fundamental to differential geometry is no longer of great importance to us. Rather, everything can simply be described by postulating the existence of geodesics connecting points on a manifold.
*  Given geodesics, the operations discussed in the previous two sections can be described in a more formal way. In essence, they rely on the fact that we can assume that a geodesic is parameterized by a "time" like variable  [2.x.31]  so that  [2.x.32]  describes the curve and so that  [2.x.33]  is the location of the first and  [2.x.34]  the location of the second point. Furthermore,  [2.x.35]  traces out the geodesic at constant speed, covering equal distance in equal time (as measured by the metric). Note that this parameterization uses time, not arc length to denote progress along the geodesic.
*  In this picture, computing a mid-point between points  [2.x.36]  and  [2.x.37] , with weights  [2.x.38]  and  [2.x.39] , simply requires computing the point  [2.x.40] . Computing a new point as a weighted average of more than two points can be done by considering pairwise geodesics, finding suitable points on the geodetic between the first two points, then on the geodetic between this new point and the third given point, etc.
*  Likewise, the "tangential" vector described above is simply the velocity vector,  [2.x.41] , evaluated at one of the end points of a geodesic (i.e., at  [2.x.42]  or  [2.x.43] ). In the case of a flat manifold, the geodesic is simply the straight line connecting two points, and the velocity vector is just the connecting vector in that case. On the other hand, for two points on a spherical manifold, the geodesic is a grand circle, and the velocity vector is tangent to the spherical surface.
*  Note that if we wanted to, we could use this to compute the length of the geodesic that connects two points  [2.x.44]  and  [2.x.45]  by computing  [2.x.46]  along the geodesic that connects them, but this operation will not be of use to us in practice. One could also conceive computing the direction vector using the "new point" operation above, using the formula  [2.x.47]  where all we need to do is compute the new point  [2.x.48]  with weights  [2.x.49]  and  [2.x.50]  along the geodesic connecting  [2.x.51]  and  [2.x.52] . The default implementation of the function does this, by evaluating the quotient for a small but finite weight  [2.x.53] . In practice, however, it is almost always possible to explicitly compute the direction vector, i.e., without the need to numerically approximate the limit process, and derived classes should do so.
* 

* 

* 
*  [2.x.54] 

* 
* [0.x.4]*
   Type keeping information about the normals at the vertices of a face of a   cell. Thus, there are  [2.x.55]    normal vectors, that define the tangent spaces of the boundary at the   vertices. Note that the vectors stored in this object are not required to   be normalized, nor to actually point outward, as one often will only want   to check for orthogonality to define the tangent plane; if a function   requires the normals to be normalized, then it must do so itself.     For obvious reasons, this type is not useful in 1d.  
* [0.x.5]*
   Destructor. Does nothing here, but needs to be declared virtual to make   class hierarchies derived from this class possible.  
* [0.x.6]*
   Return a copy of this manifold.     Every derived class should implement this operation in a sensible manner.  
* [0.x.7]*
    [2.x.56]  Computing the location of points.  
* [0.x.8]*
   Return an intermediate point between two given   points. Overloading this function allows the default pair-wise   reduction implementation of the method get_new_point() that takes   a Quadrature object as input to work properly.     An implementation of this function should returns a parametric   curve on the manifold, joining the points `p1` and `p2`, with   parameter `w` in the interval [0,1]. In particular   `get_intermediate_point(p1, p2, 0.0)` should return `p1` and   `get_intermediate_point(p1, p2, 1.0)` should return `p2`.     In its default implementation, this function calls the   project_to_manifold() method with the convex combination of `p1`   and `p2`. User classes can get away by simply implementing the   project_to_manifold() method.  
* [0.x.9]*
   Return the point which shall become the new vertex surrounded by the   given points  [2.x.57]   [2.x.58]  contains appropriate   weights for the surrounding points according to which the manifold   determines the new point's position.     In its default implementation it uses a pair-wise reduction of   the points by calling the function get_intermediate_point() on the first   two points, then on the resulting point and the next, until all points in   the vector have been taken into account. User classes can get away by   simply implementing the get_intermediate_point() function. Notice that   by default the get_intermediate_point() function calls the   project_to_manifold() function with the convex combination of its   arguments. For simple situations you may get away by implementing   only the project_to_manifold() function.  
* [0.x.10]*
   Compute a new set of points that interpolate between the given points  [2.x.59]    surrounding_points.  [2.x.60]  is a table with as many columns as  [2.x.61]    surrounding_points.size(). The number of rows in  [2.x.62]  must match   the length of  [2.x.63]      In its default implementation, this function simply calls get_new_point()   on each row of  [2.x.64]  and writes those points into the output array    [2.x.65]  However, this function is more efficient if multiple new   points need to be generated like in MappingQGeneric and the manifold does   expensive transformations between a chart space and the physical space,   such as ChartManifold. For this function, the surrounding points need to   be transformed back to the chart sparse only once, rather than for every   call to get_new_point(). If efficiency is not important, you may get away   by implementing only the get_new_point() function.     The implementation does not allow for  [2.x.66]  and    [2.x.67]  to point to the same array, so make sure to pass different   objects into the function.  
* [0.x.11]*
   Given a point which lies close to the given manifold, it modifies it and   projects it to manifold itself.     This class is used by the default implementation of the function   get_new_point() and should be implemented by derived classes. The default   implementation simply throws an exception if called.     If your manifold is simple, you could implement this function only, and   the default behavior should work out of the box.  
* [0.x.12]*
   Backward compatibility interface.  Return the point which shall become   the new middle vertex of the two children of a regular line. In 2D, this   line is a line at the boundary, while in 3d, it is bounding a face at the   boundary (the lines therefore is also on the boundary).     The default implementation of this function passes its argument to the    [2.x.68]  function, and then calls the    [2.x.69]  function. User derived classes   can overload  [2.x.70]  or    [2.x.71]  which is called by the   default implementation of  [2.x.72]   
* [0.x.13]*
   Backward compatibility interface. Return the point which shall become the   common point of the four children of a quad at the boundary in three or   more spatial dimensions. This function therefore is only useful in at   least three dimensions and should not be called for lower dimensions.     This function is called after the four lines bounding the given  [2.x.73]    are refined, so you may want to use the information provided by   <tt>quad->line(i)->child(j)</tt>, <tt>i=0...3</tt>, <tt>j=0,1</tt>.     The default implementation of this function passes its argument to the    [2.x.74]  function, and then calls the    [2.x.75]  function. User derived classes   can overload  [2.x.76]  or    [2.x.77]  which is called by the   default implementation of  [2.x.78]   
* [0.x.14]*
   Backward compatibility interface.  Return the point which shall become   the common point of the eight children of a hex in three or spatial   dimensions. This function therefore is only useful in at least three   dimensions and should not be called for lower dimensions.     This function is called after the all the bounding objects of the given    [2.x.79]  are refined, so you may want to use the information provided by   <tt>hex->quad(i)->line(j)->child(k)</tt>, <tt>i=0...5</tt>,   <tt>j=0...3</tt>, <tt>k=0,1</tt>.     The default implementation of this function passes its argument to the    [2.x.80]  function, and then calls the    [2.x.81]  function. User derived classes   can overload  [2.x.82]  or    [2.x.83]  which is called by the   default implementation of  [2.x.84]   
* [0.x.15]*
   Backward compatibility interface. Depending on <tt>dim=2</tt> or   <tt>dim=3</tt> this function calls the get_new_point_on_line or the   get_new_point_on_quad function. It throws an exception for   <tt>dim=1</tt>. This wrapper allows dimension independent programming.  
* [0.x.16]*
   Backward compatibility interface.  Depending on <tt>dim=1</tt>,   <tt>dim=2</tt> or <tt>dim=3</tt> this function calls the   get_new_point_on_line, get_new_point_on_quad or the get_new_point_on_hex   function. This wrapper allows dimension independent programming.  
* [0.x.17]*
    [2.x.85]  Computing tangent vectors  
* [0.x.18]*
   Return a vector that, at  [2.x.86] , is tangential to   the geodesic that connects two points  [2.x.87] . The   geodesic is the shortest line between these two points, where "shortest" is   defined via a metric specific to a particular implementation of this class   in a derived class. For example, in the case of a FlatManifold, the   shortest line between two points is just the straight line, and in this   case the tangent vector is just the difference  [2.x.88] . On the other hand, for a manifold that describes a   surface embedded in a higher dimensional space (e.g., the surface of a   sphere), then the tangent vector is tangential to the surface, and   consequently may point in a different direction than the straight line that   connects the two points.     While tangent vectors are often normalized to unit length, the vectors   returned by this function are normalized as described in the introduction   of this class. Specifically, if  [2.x.89]  traces out the geodesic   between the two points where  [2.x.90]  and    [2.x.91] , then the returned vector must equal    [2.x.92] . In other words, the norm of the returned vector also   encodes, in some sense, the [1.x.4] of the geodesic because a curve    [2.x.93]  must move "faster" if the two points it connects between   arguments  [2.x.94]  and  [2.x.95]  are farther apart.     The default implementation of this function approximates    [2.x.96]    for a small value of  [2.x.97] , and the evaluation of  [2.x.98]  is done by calling get_new_point(). If possible, derived   classes should override this function by an implementation of the exact   derivative.      [2.x.99]  x1 The first point that describes the geodesic, and the one     at which the "direction" is to be evaluated.    [2.x.100]  x2 The second point that describes the geodesic.    [2.x.101]  A "direction" vector tangential to the geodesic.  
* [0.x.19]*
    [2.x.102]  Computing normal vectors  
* [0.x.20]*
   Return the normal vector to a face embedded in this manifold, at   the point p. If p is not in fact on the surface, but only   close-by, try to return something reasonable, for example the   normal vector at the surface point closest to p.  (The point p   will in fact not normally lie on the actual surface, but rather   be a quadrature point mapped by some polynomial mapping; the   mapped surface, however, will not usually coincide with the   actual surface.)     This function only makes sense if dim==spacedim because   otherwise there is no unique normal vector but in fact a   (spacedim-dim+1)-dimensional tangent space of vectors that   are all both normal to the face and normal to the dim-dimensional   surface that lives in spacedim-dimensional space. For example,   think of a two-dimensional mesh that covers a two-dimensional   surface in three-dimensional space. In that case, each   face (edge) is one-dimensional, and there are two linearly independent   vectors that are both normal to the edge: one is normal to the   edge and tangent to the surface (intuitively, that would be the   one that points from the current cell to the neighboring one,   if the surface was locally flat), and the other one is rooted   in the edge but points perpendicular to the surface (which is   also perpendicular to the edge that lives within the surface).   Thus, because there are no obviously correct semantics for this function   if spacedim is greater than dim, the function will simply throw   an error in that situation.     The face iterator gives an indication which face this function is   supposed to compute the normal vector for.  This is useful if the   boundary of the domain is composed of different nondifferential   pieces (for example when using the FlatManifold class to   approximate a geometry that is completely described by the coarse   mesh, with piecewise (bi-)linear components between the vertices,   but where the boundary may have a kink at the vertices itself).    
*  [2.x.103]  In 2d, the default implementation of this function computes the   normal vector by taking the tangent direction from p to   the further one of the two vertices that make up an edge, and then   rotates it outward (with respect to the coordinate system of the edge)   by 90 degrees. In 3d, the default implementation is more   complicated, aiming at avoiding problems with numerical round-off   for points close to one of the vertices, and avoiding tangent directions   that are linearly dependent.  
* [0.x.21]*
   Compute the normal vectors to the boundary at each vertex of the   given face embedded in the Manifold. It is not required that the   normal vectors be normed somehow.  Neither is it required that   the normals actually point outward.     This function is needed to compute data for C1 mappings. The   default implementation calls normal_vector() on each vertex.     Note that when computing normal vectors at a vertex where the   boundary is not differentiable, you have to make sure that you   compute the one-sided limits, i.e. limit with respect to points   inside the given face.  
* [0.x.22]*
 Specialization of Manifold<dim,spacedim>, which represent a possibly periodic Euclidean space of dimension  [2.x.104]  embedded in the Euclidean space of  [2.x.105]  dimensions. The main characteristic of this Manifold is the fact that the function  [2.x.106]  is the identity function.
* 

* 
*  [2.x.107] 

* 
* [0.x.23]*
   Default constructor. The optional argument can be used to specify the   periodicity of the spacedim-dimensional manifold (one period per   direction). A periodicity value of zero means that along that direction   there is no periodicity. By default no periodicity is assumed.     Periodicity affects the way a middle point is computed. It is assumed   that if two points are more than half period distant, then the distance   should be computed by crossing the periodicity boundary, i.e., the   average is computed by adding a full period to the sum of the two. For   example, if along direction 0 we have 2*pi periodicity, then the average   of (2*pi-eps) and (eps) is not pi, but 2*pi (or zero), since, on a   periodic manifold, these two points are at distance 2*eps and not (2*pi-   eps). Special cases are taken into account, to ensure that the behavior   is always as expected. The third argument is used as a relative tolerance   when computing distances.     Periodicity will be intended in the following way: the domain is   considered to be the box contained in [Point<spacedim>(), periodicity)   where the right extreme is excluded. If any of the components of this box   has zero length, then no periodicity is assumed in that direction.   Whenever a function that tries to compute averages is called, an   exception will be thrown if one of the points which you are using for the   average lies outside the periodicity box. The return points are   guaranteed to lie in the periodicity box plus or minus   tolerance*periodicity.norm().  
* [0.x.24]*
   Return a copy of this manifold.  
* [0.x.25]*
   Let the new point be the average sum of surrounding vertices.     This particular implementation constructs the weighted average of the   surrounding points, and then calls internally the function   project_to_manifold(). The reason why we do it this way, is to allow lazy   programmers to implement only the project_to_manifold() function for their   own Manifold classes which are small (or trivial) perturbations of a flat   manifold. This is the case whenever the coarse mesh is a decent   approximation of the manifold geometry. In this case, the middle point of   a cell is close to true middle point of the manifold, and a projection   may suffice.     For most simple geometries, it is possible to get reasonable results by   deriving your own Manifold class from FlatManifold, and write a new   interface only for the project_to_manifold function. You will have good   approximations also with large deformations, as long as in the coarsest   mesh size you are trying to refine, the middle point is not too far from   the manifold mid point, i.e., as long as the coarse mesh size is small   enough.  
* [0.x.26]*
   Compute a new set of points that interpolate between the given points  [2.x.108]    surrounding_points.  [2.x.109]  is a table with as many columns as  [2.x.110]    surrounding_points.size(). The number of rows in  [2.x.111]  must match   the length of  [2.x.112]      For this particular implementation, the interpolation of the    [2.x.113]  according to the  [2.x.114]  is simply performed in   Cartesian space.  
* [0.x.27]*
   Project to FlatManifold. This is the identity function for flat,   Euclidean spaces. Note however that this function can be overloaded by   derived classes, which will then benefit from the logic behind the   get_new_point() function which are often very similar (if not identical) to   the one implemented in this class.  
* [0.x.28]*
   Return a vector that, at  [2.x.115] , is tangential to   the geodesic that connects two points  [2.x.116] .   For the current class, we assume that the manifold is flat, so   the geodesic is the straight line between the two points, and we   return  [2.x.117] . The normalization of the vector   is chosen so that it fits the convention described in    [2.x.118]     
*  [2.x.119]  If you use this class as a stepping stone to build a manifold     that only "slightly" deviates from a flat manifold, by overloading     the project_to_manifold() function.      [2.x.120]  x1 The first point that describes the geodesic, and the one     at which the "direction" is to be evaluated.    [2.x.121]  x2 The second point that describes the geodesic.    [2.x.122]  A "direction" vector tangential to the geodesic. Here, this is      [2.x.123] , possibly modified by the periodicity of     the domain as set in the constructor, to use the "shortest" connection     between the points through the periodic boundary as necessary.  
* [0.x.29]*
   Return the normal vector to the given face at point p taking into account   that quadrilateral faces of hexahedral cells in 3d may not be planar.   In those cases, the face is assumed to have a geometry described by a   bilinear function, and the normal vector is computed by embedding this   bilinear form into a Cartesian space with a flat metric.  
* [0.x.30]*
   Compute the normal vectors to the boundary at each vertex of the   given face taking into account that quadrilateral faces of hexahedral   cells in 3d may not be planar. In those cases, the face is assumed to   have a geometry described by a bilinear function, and the normal vector   is computed by embedding this bilinear form into a Cartesian space with   a flat metric.  
* [0.x.31]*
   Return the periodicity of this Manifold.  
* [0.x.32]*
   The periodicity of this Manifold. Periodicity affects the way a middle   point is computed. It is assumed that if two points are more than half   period distant, then the distance should be computed by crossing the   periodicity boundary, i.e., the average is computed by adding a full   period to the sum of the two. For example, if along direction 0 we have   2*pi periodicity, then the average of (2*pi-eps) and (eps) is not pi, but   2*pi (or zero), since, on a periodic manifold, these two points are at   distance 2*eps and not (2*pi-eps).     A periodicity 0 along one direction means no periodicity. This is the   default value for all directions.  
* [0.x.33]*
   Relative tolerance. This tolerance is used to compute distances in double   precision.  
* [0.x.34]*
 This class describes mappings that can be expressed in terms of charts. Specifically, this class with its template arguments describes a chart of dimension chartdim, which is part of a Manifold<dim,spacedim> and is used in an object of type Triangulation<dim,spacedim>:  It specializes a Manifold of dimension chartdim embedded in a manifold of dimension spacedim, for which you have explicit pull_back() and push_forward() transformations. Its use is explained in great detail in  [2.x.124] .
*  This is a helper class which is useful when you have an explicit map from an Euclidean space of dimension chartdim to an Euclidean space of dimension spacedim which represents your manifold, i.e., when your manifold  [2.x.125]  can be represented by a map [1.x.5] (the push_forward() function) and that admits the inverse transformation [1.x.6] (the pull_back() function).
*  The get_new_point() function of the ChartManifold class is implemented by calling the pull_back() method for all <tt>surrounding_points</tt>, computing their weighted average in the chartdim Euclidean space, and calling the push_forward() method with the resulting point, i.e., [1.x.7]
*  Derived classes are required to implement the push_forward() and the pull_back() methods. All other functions (with the exception of the push_forward_gradient() function, see below) that are required by mappings will then be provided by this class.
* 

*  [1.x.8]
*  In order to compute vectors that are tangent to the manifold (for example, tangent to a surface embedded in higher dimensional space, or simply the three unit vectors of  [2.x.126] ), one needs to also have access to the [1.x.9] of the push-forward function  [2.x.127] . The gradient is the matrix  [2.x.128] , where we take the derivative with regard to the chartdim reference coordinates on the flat Euclidean space in which  [2.x.129]  is located. In other words, at a point  [2.x.130] ,  [2.x.131]  is a matrix of size  [2.x.132]  times  [2.x.133] 
*  Only the  [2.x.134]  function uses the gradient of the push-forward, but only a subset of all finite element codes actually require the computation of tangent vectors. Consequently, while derived classes need to implement the abstract virtual push_forward() and pull_back() functions of this class, they do not need to implement the virtual push_forward_gradient() function. Rather, that function has a default implementation (and consequently is not abstract, therefore not forcing derived classes to overload it), but the default implementation clearly can not compute anything useful and therefore simply triggers and exception.
* 

*  [1.x.10]
*  The dimension arguments  [2.x.135]   [2.x.136]  and  [2.x.137]  must satisfy the following relationships:  
* [1.x.11]
*  However, there is no a priori relationship between  [2.x.138]  and  [2.x.139]  For example, if you want to describe a mapping for an edge (a 1d object) in a 2d triangulation embedded in 3d space, you could do so by parameterizing it via a line   [1.x.12] in which case  [2.x.140]  is 1. On the other hand, there is no reason why one can't describe this as a mapping   [1.x.13] in such a way that the line  [2.x.141]  happens to be mapped onto the edge in question. Here,  [2.x.142]  is 3. This may seem cumbersome but satisfies the requirements of an invertible function  [2.x.143]  just fine as long as it is possible to get from the edge to the pull-back space and then back again. Finally, given that we are dealing with a 2d triangulation in 3d, one will often have a mapping from, say, the 2d unit square or unit disk to the domain in 3d space, and the edge in question may simply be the mapped edge of the unit domain in 2d space. In this case,  [2.x.144]  chartdim is 2.
* 

* 
*  [2.x.145] 

* 
* [0.x.35]*
   Constructor. The optional argument can be used to specify the periodicity   of the chartdim-dimensional manifold (one period per direction). A   periodicity value of zero means that along that direction there is no   periodicity. By default no periodicity is assumed.     Periodicity affects the way a middle point is computed. It is assumed   that if two points are more than half period distant, then the distance   should be computed by crossing the periodicity boundary, i.e., then the   average is computed by adding a full period to the sum of the two. For   example, if along direction 0 we have 2*pi periodicity, then the average   of (2*pi-eps) and (eps) is not pi, but 2*pi (or zero), since, on the   manifold, these two points are at distance 2*eps and not (2*pi-eps)  
* [0.x.36]*
   Destructor. Does nothing here, but needs to be declared to make it   virtual.  
* [0.x.37]*
   Refer to the general documentation of this class and the documentation of   the base class for more information.  
* [0.x.38]*
   Refer to the general documentation of this class and the documentation of   the base class for more information.  
* [0.x.39]*
   Compute a new set of points that interpolate between the given points  [2.x.146]    surrounding_points.  [2.x.147]  is a table with as many columns as  [2.x.148]    surrounding_points.size(). The number of rows in  [2.x.149]  must match   the length of  [2.x.150]      The implementation of this function first transforms the    [2.x.151]  to the chart space by calling pull_back(). Then, new   points are computed on the chart by usual interpolation according to the   given  [2.x.152]  which are finally transformed to the image space by   push_forward().     This implementation can be much more efficient for computing multiple new   points from the same surrounding points than separate calls to   get_new_point() in case the pull_back() operation is expensive. This is   because pull_back() is only called once for the surrounding points and   the interpolation is done for all given weights using this set of   points. Often, pull_back() is also more expensive than push_forward()   because the former might involve some kind of Newton iteration in   non-trivial manifolds.  
* [0.x.40]*
   Pull back the given point in spacedim to the Euclidean chartdim   dimensional space.     Refer to the general documentation of this class for more information.  
* [0.x.41]*
   Given a point in the chartdim dimensional Euclidean space, this method   returns a point on the manifold embedded in the spacedim Euclidean space.     Refer to the general documentation of this class for more information.  
* [0.x.42]*
   Given a point in the chartdim dimensional Euclidean space, this method   returns the derivatives of the function  [2.x.153]  that maps from the   chartdim-dimensional to the spacedim-dimensional space. In other   words, it is a matrix of size  [2.x.154] .     This function is used in the computations required by the   get_tangent_vector() function. Since not all users of the Manifold   class interface will require calling that function, the current   function is implemented but will trigger an exception whenever   called. This allows derived classes to avoid implementing the   push_forward_gradient function if this functionality is not   needed in the user program.     Refer to the general documentation of this class for more information.  
* [0.x.43]*
   Return a vector that, at  [2.x.155] , is tangential to   the geodesic that connects two points  [2.x.156] .   See the documentation of the Manifold class and of    [2.x.157]  for a more detailed description.     For the current class, we assume that this geodesic is the image   under the push_forward() operation of a straight line of the   pre-images of  [2.x.158]  and  [2.x.159]  (where pre-images are computed by pulling   back the locations  [2.x.160]  and  [2.x.161]  In other words, if these   preimages are  [2.x.162] ,   then the geodesic in preimage (the chartdim-dimensional Euclidean) space   is  
* [1.x.14]
*    In image space, i.e., in the space in which we operate, this   leads to the curve  
* [1.x.15]
*    What the current function is supposed to return is  [2.x.163] . By   the chain rule, this is equal to  
* [1.x.16]
*    This formula may then have to be slightly modified by   considering any periodicity that was assumed in the call to   the constructor.     Thus, the computation of tangent vectors also requires the   implementation of [1.x.17]  [2.x.164]  of   the push-forward mapping. Here,  [2.x.165]    is a chartdim-dimensional vector, and  [2.x.166]  is a   spacedim-times-chartdim-dimensional matrix. Consequently, and as desired,   the operation results in a spacedim-dimensional vector.      [2.x.167]  x1 The first point that describes the geodesic, and the one     at which the "direction" is to be evaluated.    [2.x.168]  x2 The second point that describes the geodesic.    [2.x.169]  A "direction" vector tangential to the geodesic.  
* [0.x.44]*
   Return the periodicity associated with the submanifold.  
* [0.x.45]*
   The sub_manifold object is used to compute the average of the points in   the chart coordinates system.     In an ideal world, it would have type   FlatManifold<dim,chartdim>. However, this would instantiate cases   where dim>spacedim, which leads to invalid situations. We instead   use <chartdim,chartdim>, which is (i) always valid, and (ii) does   not matter at all since the first (dim) argument of manifolds is,   in fact, ignored as far as manifold functionality is concerned.  
* [0.x.46]

include/deal.II-translator/grid/manifold_lib_0.txt
[0.x.0]*
 Manifold description for a polar coordinate system.
*  You can use this Manifold object to describe any sphere, circle, hypersphere or hyperdisc in two or three dimensions, both as a co-dimension one manifold descriptor or as co-dimension zero manifold descriptor, provided that the north and south poles (in three dimensions) and the center (in both two and three dimensions) are excluded from the Manifold (as they are singular points of the polar change of coordinates).
*  The two template arguments match the meaning of the two template arguments in Triangulation<dim, spacedim>, however this Manifold can be used to describe both thin and thick objects, and the behavior is identical when dim <= spacedim, i.e., the functionality of PolarManifold<2,3> is identical to PolarManifold<3,3>.
*  This class works by transforming points to polar coordinates (in both two and three dimensions), taking the average in that coordinate system, and then transforming the point back to Cartesian coordinates. In order for this manifold to work correctly, it cannot be attached to cells containing the center of the coordinate system or the north and south poles in three dimensions. These points are singular points of the coordinate transformation, and taking averages around these points does not make any sense.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   The Constructor takes the center of the spherical coordinates system.   This class uses the pull_back and push_forward mechanism to transform   from Cartesian to spherical coordinate systems, taking into account the   periodicity of base Manifold in two dimensions, while in three dimensions   it takes the middle point, and project it along the radius using the   average radius of the surrounding points.  
* [0.x.2]*
   Make a clone of this Manifold object.  
* [0.x.3]*
   Pull back the given point from the Euclidean space. Will return the polar   coordinates associated with the point  [2.x.1]  Only used when   spacedim = 2.  
* [0.x.4]*
   Given a point in the spherical coordinate system, this method returns the   Euclidean coordinates associated to the polar coordinates  [2.x.2]    Only used when spacedim = 3.  
* [0.x.5]*
   Given a point in the spacedim dimensional Euclidean space, this   method returns the derivatives of the function  [2.x.3]  that maps from   the polar coordinate system to the Euclidean coordinate   system. In other words, it is a matrix of size    [2.x.4] .     This function is used in the computations required by the   get_tangent_vector() function.     Refer to the general documentation of this class for more information.  
* [0.x.6]*
    [2.x.5]   [2.x.6]   
* [0.x.7]*
   The center of the spherical coordinate system.  
* [0.x.8]*
   Helper function which returns the periodicity associated with this   coordinate system, according to dim, chartdim, and spacedim.  
* [0.x.9]*
 Manifold description for a spherical space coordinate system.
*  You can use this Manifold object to describe any sphere, circle, hypersphere or hyperdisc in two or three dimensions. This manifold can be used as a co-dimension one manifold descriptor of a spherical surface embedded in a higher dimensional space, or as a co-dimension zero manifold descriptor for a body with positive volume, provided that the center of the spherical space is excluded from the domain. An example for the use of this function would be in the description of a hyper-shell or hyper-ball geometry, for example after creating a coarse mesh using  [2.x.7]  (However, it is worth mentioning that generating a good mesh for a disk or ball is complicated and requires addition steps. See the "Possibilities for extensions" section of  [2.x.8]  for an extensive discussion of how one would construct such meshes and what one needs to do for it.)
*  The two template arguments match the meaning of the two template arguments in Triangulation<dim, spacedim>, however this Manifold can be used to describe both thin and thick objects, and the behavior is identical when dim <= spacedim, i.e., the functionality of SphericalManifold<2,3> is identical to SphericalManifold<3,3>.
*  While PolarManifold reflects the usual notion of polar coordinates, it may not be suitable for domains that contain either the north or south poles.  Consider for instance the pair of points  [2.x.9]  and  [2.x.10]  in polar coordinates (lying on the surface of a sphere with radius one, on a parallel at height  [2.x.11] ). In this case connecting the points with a straight line in polar coordinates would take the long road around the globe, without passing through the north pole.
*  These two points would be connected (using a PolarManifold) by the curve

* 
* [1.x.0]
*  This curve is not a geodesic on the sphere, and it is not how we would connect those two points. A better curve, would be the one passing through the North pole: [1.x.1] where  [2.x.12]  and  [2.x.13]  for  [2.x.14] . Indeed, this is a geodesic, and it is the natural choice when connecting points on the surface of the sphere. In the examples above, the PolarManifold class implements the first way of connecting two points on the surface of a sphere, while SphericalManifold implements the second way, i.e., this Manifold connects points using geodesics. If more than two points are involved through a  [2.x.15]  call, a so-called spherical average is used where the final point minimizes the weighted distance to all other points via geodesics.
*  In particular, this class implements a Manifold that joins any two points in space by first projecting them onto the surface of a sphere with unit radius, then connecting them with a geodesic, and finally rescaling the final radius so that the resulting one is the weighted average of the starting radii. This Manifold is identical to PolarManifold in dimension two, while for dimension three it returns points that are more uniformly distributed on the sphere, and it is invariant with respect to rotations of the coordinate system, therefore avoiding the problems that PolarManifold has at the poles. Notice, in particular, that computing tangent vectors at the poles with a PolarManifold is not well defined, while it is perfectly fine with this class.
*  For mathematical reasons, it is impossible to construct a unique map of a sphere using only geodesic curves, and therefore, using this class with MappingManifold is discouraged. If you use this Manifold to describe the geometry of a sphere, you should use MappingQ as the underlying mapping, and not MappingManifold.
*  This Manifold can be usedonly* on geometries where a ball with finite radius is removed from the center. Indeed, the center is a singular point for this manifold, and if you try to connect two points across the center, they would travel on spherical coordinates, avoiding the center.
*  The ideal geometry for this Manifold is an HyperShell. If you plan to use this Manifold on a HyperBall, you have to make sure you do not attach this Manifold to the cell containing the center. It is advisable to combine this class with TransfiniteInterpolationManifold to ensure a smooth transition from a curved shape to the straight coordinate system in the center of the ball. (See also the extensive discussion in  [2.x.16] .)
* 

* 
*  [2.x.17] 

* 
* [0.x.10]*
   The Constructor takes the center of the spherical coordinates.  
* [0.x.11]*
   Make a clone of this Manifold object.  
* [0.x.12]*
   Given any two points in space, first project them on the surface   of a sphere with unit radius, then connect them with a geodesic   and find the intermediate point, and finally rescale the final   radius so that the resulting one is the convex combination of the   starting radii.  
* [0.x.13]*
   Compute the derivative of the get_intermediate_point() function   with parameter w equal to zero.  
* [0.x.14]*
    [2.x.18]   [2.x.19]   
* [0.x.15]*
   Compute the normal vectors to the boundary at each vertex.  
* [0.x.16]*
   Compute a new set of points that interpolate between the given points  [2.x.20]    surrounding_points.  [2.x.21]  is a table with as many columns as  [2.x.22]    surrounding_points.size(). The number of rows in  [2.x.23]  must match   the length of  [2.x.24]      This function is optimized to perform on a collection   of new points, by collecting operations that are not dependent on the   weights outside of the loop over all new points.     The implementation does not allow for  [2.x.25]  and    [2.x.26]  to point to the same array, so make sure to pass different   objects into the function.  
* [0.x.17]*
   Return a point on the spherical manifold which is intermediate   with respect to the surrounding points.  
* [0.x.18]*
   The center of the spherical coordinate system.  
* [0.x.19]*
   Return a point on the spherical manifold which is intermediate   with respect to the surrounding points. This function uses a linear   average of the directions to find an estimated point. It returns a pair   of radius and direction from the center point to the candidate point.  
* [0.x.20]*
   Return a point on the spherical manifold which is intermediate   with respect to the surrounding points. This function uses a candidate   point as guess, and performs a Newton-style iteration to compute the   correct point.     The main part of the implementation uses the ideas in the publication     Buss, Samuel R., and Jay P. Fillmore.   "Spherical averages and applications to spherical splines and   interpolation." ACM Transactions on Graphics (TOG) 20.2 (2001): 95-126.     and in particular the implementation provided at   http://math.ucsd.edu/~sbuss/ResearchWeb/spheremean/  
* [0.x.21]*
   Compute a new set of points that interpolate between the given points  [2.x.27]    surrounding_points.  [2.x.28]  is an array view with as many entries as  [2.x.29]    surrounding_points.size() times  [2.x.30]      This function is optimized to perform on a collection   of new points, by collecting operations that are not dependent on the   weights outside of the loop over all new points.     The implementation does not allow for  [2.x.31]  and    [2.x.32]  to point to the same array, so make sure to pass different   objects into the function.  
* [0.x.22]*
   A manifold description to be used for get_new_point in 2D.  
* [0.x.23]*
 Cylindrical Manifold description.  In three dimensions, points are transformed using a cylindrical coordinate system along the <tt>x-</tt>, <tt>y-</tt> or <tt>z</tt>-axis (when using the first constructor of this class), or an arbitrarily oriented cylinder described by the direction of its axis and a point located on the axis.
*  This class was developed to be used in conjunction with the  [2.x.33]  or  [2.x.34]  functions of GridGenerator. This function will throw a run time exception whenever spacedim is not equal to three.
* 

* 
*  [2.x.35] 

* 
* [0.x.24]*
   Constructor. Using default values for the constructor arguments yields a   cylinder along the x-axis (<tt>axis=0</tt>). Choose <tt>axis=1</tt> or   <tt>axis=2</tt> for a tube along the y- or z-axis, respectively. The   tolerance value is used to determine if a point is on the axis.  
* [0.x.25]*
   Constructor. If constructed with this constructor, the manifold described   is a cylinder with an axis that points in direction #direction and goes   through the given #point_on_axis. The direction may be arbitrarily   scaled, and the given point may be any point on the axis. The tolerance   value is used to determine if a point is on the axis.  
* [0.x.26]*
   Make a clone of this Manifold object.  
* [0.x.27]*
   Compute the cylindrical coordinates  [2.x.36]  for the given   space point where  [2.x.37]  denotes the distance from the axis,    [2.x.38]  the angle between the given point and the computed normal   direction, and  [2.x.39]  the axial position.  
* [0.x.28]*
   Compute the Cartesian coordinates for a chart point given in cylindrical   coordinates  [2.x.40] , where  [2.x.41]  denotes the distance from the   axis,  [2.x.42]  the angle between the given point and the computed normal   direction, and  [2.x.43]  the axial position.  
* [0.x.29]*
   Compute the derivatives of the mapping from cylindrical coordinates    [2.x.44]  to cartesian coordinates where  [2.x.45]  denotes the   distance from the axis,  [2.x.46]  the angle between the given point and the   computed normal direction, and  [2.x.47]  the axial position.  
* [0.x.30]*
   Compute new points on the CylindricalManifold. See the documentation of   the base class for a detailed description of what this function does.  
* [0.x.31]*
   A vector orthogonal to the normal direction.  
* [0.x.32]*
   The direction vector of the axis.  
* [0.x.33]*
   An arbitrary point on the axis.  
* [0.x.34]*
   Relative tolerance to measure zero distances.  
* [0.x.35]*
 Elliptical manifold description derived from ChartManifold. More information on the elliptical coordinate system can be found at [1.x.2].
*  This is based on the definition of elliptic coordinates  [2.x.48]  [1.x.3] in which  [2.x.49]  are coordinates of the center of the cartesian system.
*  The current implementation uses coordinates  [2.x.50] , instead of  [2.x.51] , and fixes  [2.x.52]  according to a given eccentricity. Therefore, this choice of coordinates generates an elliptical manifold characterized by a constant eccentricity:  [2.x.53] , with  [2.x.54] .
*  The constructor of this class will throw an exception if both dim and spacedim are different from two.
*  This manifold can be used to produce hyper_shells with elliptical curvature. As an example, the test <B>elliptical_manifold_01</B> produces the following triangulation:  [2.x.55] 
* 

* 
*  [2.x.56] 

* 
* [0.x.36]*
   Constructor that takes the center of the manifold system, the direction of   the major axis, and the manifold eccentricity.   The default major axis is the <tt>x</tt>-axis. The manifold is rotated in   order to align the major axis to the direction specified in input.    [2.x.57]  center Center of the manifold.    [2.x.58]  major_axis_direction Direction of the major axis of the   manifold.    [2.x.59]  eccentricity Eccentricity of the   manifold  [2.x.60] .  
* [0.x.37]*
    [2.x.61]   [2.x.62]   
* [0.x.38]*
    [2.x.63]   [2.x.64]   
* [0.x.39]*
    [2.x.65]   [2.x.66]   
* [0.x.40]*
   The direction vector of the major axis.  
* [0.x.41]*
   The center of the manifold.  
* [0.x.42]*
   Parameters deriving from the eccentricity of the manifold.  
* [0.x.43]*
    [2.x.67]   [2.x.68]      For  [2.x.69]  and  [2.x.70] , the first coordinate is   non-periodic, while the second coordinate has a periodicity of  [2.x.71] .  
* [0.x.44]*
 Manifold description derived from ChartManifold, based on explicit Function<spacedim> and Function<chartdim> objects describing the push_forward() and pull_back() functions.
*  You can use this Manifold object to describe any arbitrary shape domain, as long as you can express it in terms of an invertible map, for which you provide both the forward expression, and the inverse expression.
*  In debug mode, a check is performed to verify that the transformations are actually one the inverse of the other.
* 

* 
*  [2.x.72] 

* 
* [0.x.45]*
   Explicit functions constructor. Takes a push_forward function of spacedim   components, and a pull_back function of  [2.x.73]  components. See the   documentation of the base class ChartManifold for the meaning of the   optional  [2.x.74]  argument.     The tolerance argument is used in debug mode to actually check that the   two functions are one the inverse of the other.     Note: the object constructed in this way stores pointers to the   push_forward and  pull_back functions. Therefore, one must guarantee that   the function objects are destroyed only after the constructed manifold.  
* [0.x.46]*
   Same as previous, except this constructor takes ownership of the Function   objects passed as first and second argument, and is ultimately in charge   of deleting the pointers when the FunctionManifold object is destroyed.     This constructor is useful because it allows creating function objects at   the place of calling the constructor without having to name and later   delete these objects. This allows the following idiom:   FunctionManifold<dim>  [2.x.75]                                    [2.x.76]   
* [0.x.47]*
   Expressions constructor. Takes the expressions of the push_forward   function of spacedim components, and of the pull_back function of  [2.x.77]    chartdim components. See the documentation of the base class   ChartManifold for the meaning of the optional  [2.x.78]  argument.     The strings should be the readable by the default constructor of the   FunctionParser classes. You can specify custom variable expressions with   the last two optional arguments. If you don't, the default names are   used, i.e., "x,y,z".     The tolerance argument is used in debug mode to actually check that the   two functions are one the inverse of the other.  
* [0.x.48]*
   If needed, we delete the pointers we own.  
* [0.x.49]*
   Make a clone of this Manifold object.  
* [0.x.50]*
   Given a point in the  [2.x.79]  coordinate system, uses the   push_forward_function to compute the push_forward of points in  [2.x.80]    chartdim space dimensions to  [2.x.81]  space dimensions.  
* [0.x.51]*
   Given a point in the chartdim dimensional Euclidean space, this   method returns the derivatives of the function  [2.x.82]  that maps from   the sub_manifold coordinate system to the Euclidean coordinate   system. In other words, it is a matrix of size    [2.x.83] .     This function is used in the computations required by the   get_tangent_vector() function. The default implementation calls   the get_gradient() method of the    [2.x.84]  member class. If you   construct this object using the constructor that takes two string   expression, then the default implementation of this method uses a   finite difference scheme to compute the gradients(see the   AutoDerivativeFunction() class for details), and you can specify   the size of the spatial step size at construction time with the    [2.x.85]  parameter.     Refer to the general documentation of this class for more information.  
* [0.x.52]*
   Given a point in the spacedim coordinate system, uses the   pull_back_function to compute the pull_back of points in  [2.x.86]    space dimensions to  [2.x.87]  space dimensions.  
* [0.x.53]*
   Constants for the FunctionParser classes.  
* [0.x.54]*
   Pointer to the push_forward function.  
* [0.x.55]*
   Pointer to the pull_back function.  
* [0.x.56]*
   Relative tolerance. In debug mode, we check that the two functions   provided at construction time are actually one the inverse of the other.   This value is used as relative tolerance in this check.  
* [0.x.57]*
   Check ownership of the smart pointers. Indicates whether this class is   the owner of the objects pointed to by the previous two member variables.   This value is set in the constructor of the class. If  [2.x.88]  then the   destructor will delete the function objects pointed to be the two   pointers.  
* [0.x.58]*
   The expression used to construct the push_forward function.  
* [0.x.59]*
   The expression used to construct the pull_back function.  
* [0.x.60]*
   Variable names in the chart domain.  
* [0.x.61]*
   Variable names in the space domain.  
* [0.x.62]*
   The finite difference step to use internally.  
* [0.x.63]*
 Manifold description for the surface of a Torus in three dimensions. The Torus is assumed to be in the x-z plane. The reference coordinate system is given by the angle  [2.x.89]  around the y axis, the angle  [2.x.90]  around the centerline of the torus, and the distance to the centerline  [2.x.91]  (between 0 and 1).
*  This class was developed to be used in conjunction with  [2.x.92] 
* 

* 
*  [2.x.93] 

* 
* [0.x.64]*
   Constructor. Specify the radius of the centerline  [2.x.94]  and the radius   of the torus itself ( [2.x.95]  The variables have the same meaning as   the parameters in  [2.x.96]   
* [0.x.65]*
   Make a clone of this Manifold object.  
* [0.x.66]*
   Pull back operation.  
* [0.x.67]*
   Push forward operation.  
* [0.x.68]*
   Gradient.  
* [0.x.69]*
 A mapping class that extends curved boundary descriptions into the interior of the computational domain. The outer curved boundary description is assumed to be given by another manifold (e.g. a polar manifold on a circle). The mechanism to extend the boundary information is a so-called transfinite interpolation. The use of this class is discussed extensively in  [2.x.97] .
*  The formula for extending such a description in 2D is, for example, described on [1.x.4].  Given a point  [2.x.98]  on the chart, the image of this point in real space is given by

* 
* [1.x.5]
*  where  [2.x.99]  denote the four bounding vertices bounding the image space and  [2.x.100]  are the four curves describing the lines of the cell. If a curved manifold is attached to any of these lines, the evaluation is done according to  [2.x.101]  with the two end points of the line and appropriate weight. In 3D, the generalization of this formula is implemented, creating a weighted sum of the vertices (positive contribution), the lines (negative), and the faces (positive contribution).
*  This manifold is usually attached to a coarse mesh and then places new points as a combination of the descriptions on the boundaries, weighted appropriately according to the position of the point in the original chart coordinates  [2.x.102] . This manifold should be preferred over setting only a curved manifold on the boundary of a mesh in most situations as it yields more uniform mesh distributions as the mesh is refined because it switches from a curved description to a straight description over all children of the initial coarse cell this manifold was attached to. This way, the curved nature of the manifold that is originally contained in one [1.x.6] mesh layer will be applied to more than one [1.x.7] mesh layer once the mesh gets refined. Note that the mechanisms of TransfiniteInterpolationManifold are also built into the MappingQGeneric class when only a surface of a cell is subject to a curved description, ensuring that even the default case without this manifold gets optimal convergence rates when applying curved boundary descriptions.
*  If no curved boundaries surround a coarse cell, this class reduces to a flat manifold description.
*  To give an example of using this class, the following code attaches a transfinite manifold to a circle:
* 

* 
* [1.x.8]
* 
*  In this code, we first set all manifold ids to the id of the transfinite interpolation, and then re-set the manifold ids on the boundary to identify the curved boundary described by the polar manifold. With this code, one gets a really nice mesh:
*   [2.x.103] 
*  which is obviously much nicer than the polar manifold applied to just the boundary:
*   [2.x.104] 
*  This manifold is used in a few GridGenerator functions, including  [2.x.105] 
*  [1.x.9]
*  In the implementation of this class, the manifolds surrounding a coarse cell are queried repeatedly to compute points on their interior. For optimal mesh quality, those manifolds should be compatible with a chart notion. For example, computing a point that is 0.25 along the line between two vertices using the weights 0.25 and 0.75 for the two vertices should give the same result as first computing the mid point at 0.5 and then again compute the midpoint between the first vertex and coarse mid point. This is the case for most of the manifold classes provided by deal.II, such as SphericalManifold or PolarManifold, but it might be violated by naive implementations. In case the quality of the manifold is not good enough, upon mesh refinement it may happen that the transformation to a chart inside the get_new_point() or get_new_points() methods produces points that are outside the unit cell. Then this class throws an exception of type  [2.x.106]  In that case, the mesh should be refined before attaching this class, as done in the following example:
* 

* 
* [1.x.10]
* 
* 

* 
*  [2.x.107]  For performance and accuracy reasons, it is recommended to apply the transfinite manifold to as coarse a mesh as possible. Regarding accuracy, the curved description can only be applied to new points created from a given neighborhood, and the grid quality is typically higher when extending the curved description over as large a domain as possible. Regarding performance, the identification of the correct coarse cell in the get_new_point() method needs to pass all coarse cells, so expect a linear complexity in the number of coarse cells for each single mapping operation, i.e., at least quadratic in the number of coarse mesh cells for any global operation on the whole mesh. Thus, the current implementation is only economical when there are not more than a few hundreds of coarse cells. To make performance better for larger numbers of cells, one could extend the current implementation by a pre-identification of relevant cells with axis-aligned bounding boxes.
* 

* 
*  [2.x.108] 

* 
* [0.x.70]*
   Constructor.  
* [0.x.71]*
   Destructor.  
* [0.x.72]*
   Make a clone of this Manifold object.  
* [0.x.73]*
   Initializes the manifold with a coarse mesh. The prerequisite for using   this class is that the input triangulation is uniformly refined and the   manifold is later attached to the same triangulation.     Whenever the assignment of manifold ids changes on the level of the   triangulation which this class was initialized with, initialize() must be   called again to update the manifold ids connected to the coarse cells.    
*  [2.x.109]  The triangulation used to construct the manifold must not be   destroyed during the usage of this object.  
* [0.x.74]*
   Return the point which shall become the new vertex surrounded by the   given points  [2.x.110]   [2.x.111]  contains appropriate   weights for the surrounding points according to which the manifold   determines the new point's position.     The implementation in this class overrides the method in the base class   and computes the new point by a transfinite interpolation. The first step   in the implementation is to identify the coarse cell on which the   surrounding points are located. Then, the coordinates are transformed to   the unit coordinates on the coarse cell by a Newton iteration, where the   new point is then computed according to the weights. Finally, it is   pushed forward to the real space according to the transfinite   interpolation.  
* [0.x.75]*
   Compute a new set of points that interpolate between the given points  [2.x.112]    surrounding_points.  [2.x.113]  is a table with as many columns as  [2.x.114]    surrounding_points.size(). The number of columns in  [2.x.115]  must match   the length of  [2.x.116]      The implementation in this class overrides the method in the base class   and computes the new point by a transfinite interpolation. The first step   in the implementation is to identify the coarse cell on which the   surrounding points are located. Then, the coordinates are transformed to   the unit coordinates on the coarse cell by a Newton iteration, where the   new points are then computed according to the weights. Finally, the is   pushed forward to the real space according to the transfinite   interpolation.     The implementation does not allow for  [2.x.117]  and    [2.x.118]  to point to the same vector, so make sure to pass different   objects into the function.  
* [0.x.76]*
   Internal function to identify the most suitable cells (=charts) where the   given surrounding points are located. We use a cheap algorithm to   identify the cells and rank the cells by probability before we actually   do the search inside the relevant cells. The cells are sorted by the   distance of a Q1 approximation of the inverse mapping to the unit cell of   the surrounding points. We expect at most 20 cells (it should be up to 8   candidates on a 3D structured mesh and a bit more on unstructured ones,   typically we only get two or three), so get an array with 20 entries of a   the indices <tt>cell->index()</tt>.  
* [0.x.77]*
   Finalizes the identification of the correct chart and populates  [2.x.119]    chart_points with the pullbacks of the surrounding points. This method   internally calls  [2.x.120]      Return an iterator to the cell on which the chart is defined.  
* [0.x.78]*
   Pull back operation into the unit coordinates on the given coarse cell.     This method is currently based on a Newton-like iteration to find the   point in the origin. One may speed up the iteration by providing a good   initial guess as the third argument. If no better point is known, use   cell->real_to_unit_cell_affine_approximation(p)    
*  [2.x.121]  This internal function is currently not compatible with the    [2.x.122]  function because the given class represents an   atlas of charts, not a single chart. Thus, the pull_back() operation is   only valid with the additional information of the chart, given by a cell   on the coarse grid. An alternative implementation could shift the index   depending on the coarse cell for a 1-to-1 relation between the chart space   and the image space.  
* [0.x.79]*
   Push forward operation.    
*  [2.x.123]  This internal function is currently not compatible with the    [2.x.124]  function because the given class represents   an atlas of charts, not a single chart. Thus, the push_forward()   operation is only valid with the additional information of the chart,   given by a cell on the coarse grid. An alternative implementation could   shift the index depending on the coarse cell for a 1-to-1 relation   between the chart space and the image space.  
* [0.x.80]*
   Gradient of the push_forward method.    
*  [2.x.125]  This internal function is not compatible with the    [2.x.126]  function because the given class   represents an atlas of charts, not a single chart. Furthermore, this   private function also requires the user to provide the result of the   push_forward() call on the chart point for the single use case of this   function, namely inside a Newton iteration where the gradient is computed   by finite differences.  
* [0.x.81]*
   The underlying triangulation.  
* [0.x.82]*
   The level of the mesh cells where the transfinite approximation is   applied, usually level 0.  
* [0.x.83]*
   In case there all surrounding manifolds are the transfinite manifold or   have default (invalid) manifold id, the manifold degenerates to a flat   manifold and we can choose cheaper algorithms for the push_forward method.  
* [0.x.84]*
   A flat manifold used to compute new points in the chart space where we   use a FlatManifold description.  
* [0.x.85]*
   A vector of quadratic approximations to the inverse map from real points   to chart points for each of the coarse mesh cells.  
* [0.x.86]*
   The connection to  [2.x.127]  that must be reset once   this class goes out of scope.  
* [0.x.87]

include/deal.II-translator/grid/persistent_tria_0.txt
[0.x.0]*
 This class handles the history of a triangulation and can rebuild it after it was deleted some time before. Its main purpose is support for time- dependent problems where one frequently deletes a triangulation due to memory pressure and later wants to rebuild it; this class has all the information to rebuild it exactly as it was before including the mapping of cell numbers to the geometrical cells.
*  Basically, this is a drop-in replacement for the triangulation. Since it is derived from the Triangulation class, it shares all the functionality, but it overrides some virtual functions and adds some functions, too. The main change to the base class is that it overrides the  [2.x.0]  execute_coarsening_and_refinement function, where the new version first stores all refinement and coarsening flags and only then calls the respective function of the base class. The stored flags may later be used to restore the grid just as it was before. Some other functions have been extended slightly as well, see their documentation for more information.
*  We note that since the triangulation is created in exactly the same state as it was before, other objects working on it should result in the same state as well. This holds in particular for the DoFHandler object, which will assign the same degrees of freedom to the original cells and the ones after reconstruction of the triangulation. You can therefore safely use data vectors computed on the original grid on the reconstructed grid as well.
* 

*  [1.x.0] You can use objects of this class almost in the same way as objects of the Triangulation class. One of the few differences is that you can only construct such an object by giving a coarse grid to the constructor. The coarse grid will be used to base the triangulation on, and therefore the lifetime of the coarse grid has to be longer than the lifetime of the object of this class.
*  Basically, usage looks like this:

* 
* [1.x.1]
* 
*  Note that initially, the PersistentTriangulation object does not constitute a triangulation; it only becomes one after  [2.x.1]  is first called. Note also that the  [2.x.2]  stores all necessary flags for later reconstruction using the  [2.x.3]  function.  [2.x.4]  resets the underlying triangulation to a virgin state, but does not affect the stored refinement flags needed for later reconstruction and does also not touch the coarse grid which is used within restore().
* 

* 
*  [2.x.5] 

* 
* [0.x.1]*
   Make the dimension available in function templates.  
* [0.x.2]*
   Build up the triangulation from the coarse grid in future. Copy smoothing   flags, etc from that grid as well. Note that the initial state of the   triangulation is empty, until  [2.x.6]  is called for the first   time.     The coarse grid must persist until the end of this object, since it will   be used upon reconstruction of the grid.  
* [0.x.3]*
   Copy constructor. This operation is only allowed, if the triangulation   underlying the object to be copied is presently empty. Refinement flags   as well as the pointer to the coarse grid are copied, however.  
* [0.x.4]*
   Destructor.  
* [0.x.5]*
   Overloaded version of the same function in the base class which stores   the refinement and coarsening flags for later reconstruction of the   triangulation and after that calls the respective function of the base   class.  
* [0.x.6]*
   Restore the grid according to the saved data. For this, the coarse grid   is copied and the grid is stepwise rebuilt using the saved flags.     Note that this function will result in an error if the underlying   triangulation is not empty, i.e. it will only succeed if this object is   newly created or the <tt>clear()</tt> function of the base class was   called on it before.     Repeatedly calls the <tt>restore(unsigned int)</tt> function in a loop   over all refinement steps.  
* [0.x.7]*
   Differential restore. Performs the  [2.x.7]  local refinement and   coarsening step. Step 0 stands for the copying of the coarse grid.     This function will only succeed if the triangulation is in just the state   it were if restore would have been called from   <tt>step=0...step_no-1</tt> before.  
* [0.x.8]*
   Return the number of refinement and coarsening steps. This is given by   the size of the  [2.x.8]  vector.  
* [0.x.9]*
   Overload this function to use  [2.x.9]  as a new coarse grid. The present   triangulation and all refinement and coarsening flags storing its history   are deleted, and the state of the underlying triangulation is reset to be   empty, until  [2.x.10]  is called the next time.     The coarse grid must persist until the end of this object, since it will   be used upon reconstruction of the grid.  
* [0.x.10]*
   Throw an error, since this function is not useful in the context of this   class.  
* [0.x.11]*
    [2.x.11]   [2.x.12]     
*  [2.x.13]  Not implemented yet.  
* [0.x.12]*
   An overload of the respective function of the base class.     Throw an error, since this function is not useful in the context of this   class.  
* [0.x.13]*
   Write all refine and coarsen flags to the ostream  [2.x.14]   
* [0.x.14]*
   Reads all refine and coarsen flags that previously were written by   <tt>write_flags(...)</tt>. This is especially useful for rebuilding the   triangulation after the end or breakdown of a program and its restart.  
* [0.x.15]*
   Clear all flags. Retains the same coarse grid.  
* [0.x.16]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.17]*
   Exception.  
* [0.x.18]*
   Exception.  
* [0.x.19]*
   This grid shall be used as coarse grid.  
* [0.x.20]*
   Vectors holding the refinement and coarsening flags of the different   sweeps on this time level. The vectors therefore hold the history of the   grid.  
* [0.x.21]*
    [2.x.15]   
* [0.x.22]

include/deal.II-translator/grid/reference_cell_0.txt
[0.x.0]*
     A helper function to create a ReferenceCell object from an     integer. ReferenceCell objects are "singletons" (actually,     "multitons"
* 
*  -  there are multiple, but they are only a handful and     these are all that can be used). What is then necessary is to     have a way to create these with their internal id to distinguish     the few possible ones in existence. We could do this via a public     constructor of ReferenceCell, but that would allow users     to create ones outside the range we envision, and we don't want to do     that. Rather, the constructor that takes an integer is made `private`     but we have this one function in an internal namespace that is a friend     of the class and can be used to create the objects.    
* [0.x.1]*
 A type that describes the kinds of reference cells that can be used. This includes quadrilaterals and hexahedra (i.e., "hypercubes"), triangles and tetrahedra (simplices), and the pyramids and wedges necessary when using mixed 3d meshes.
*  Objects of this type should not be created in user code, and as a consequence the class does not have a user-accessible constructor other than the default constructor (which creates an invalid object). Rather, there is a finite number of specific reference cell objects defined in the ReferenceCells namespace that completely enumerate all of the possible values. User codes should therefore rely exclusively on assigning ReferenceCell objects from these special objects, and comparing against those special objects.
*  The purposes and intents of this class are described in the  [2.x.0]  "reference cell" glossary entry.
* 

* 
*  [2.x.1] 

* 
* [0.x.2]*
   Return the correct ReferenceCell for a given structural   dimension and number of vertices. For example, if `dim==2` and   `n_vertices==4`, this function will return  [2.x.2]    But if `dim==3` and `n_vertices==4`, it will return    [2.x.3]   
* [0.x.3]*
   Default constructor. Initialize this object as an invalid object. The   end result is that the current object equals  [2.x.4]      Generally, ReferenceCell objects are created by assignment from   the special objects in namespace ReferenceCells, which is the only   way to obtain a valid object.  
* [0.x.4]*
    [2.x.5]  Querying information about the kind of reference cells    [2.x.6]   
* [0.x.5]*
   Return `true` if the object is a  [2.x.7]     [2.x.8]   [2.x.9]  or    [2.x.10]   
* [0.x.6]*
   Return true if the object is a Vertex, Line, Triangle, or Tetrahedron.  
* [0.x.7]*
   Return the dimension of the reference cell represented by the current   object.  
* [0.x.8]*
    [2.x.11]   
* [0.x.9]*
    [2.x.12]  Shape functions, mappings, quadratures defined on a reference cell    [2.x.13]   
* [0.x.10]*
   Compute the value of the  [2.x.14] -th linear shape function at location  [2.x.15]    for the current reference-cell type.  
* [0.x.11]*
   Compute the gradient of the  [2.x.16] -th linear shape function at location    [2.x.17]  for the current reference-cell type.  
* [0.x.12]*
   Return a default mapping of degree  [2.x.18]  matching the current   reference cell. If this reference cell is a hypercube, then the returned   mapping is a MappingQGeneric; otherwise, it is an object of type   MappingFE initialized with FE_SimplexP (if the reference cell is a   triangle or tetrahedron), with FE_PyramidP (if the reference   cell is a pyramid), or with FE_WedgeP (if the reference cell is   a wedge).  
* [0.x.13]*
   Return a default linear mapping matching the current reference cell.   If this reference cell is a hypercube, then the returned mapping   is a MappingQ1; otherwise, it is an object of type MappingFE   initialized with FE_SimplexP (if the reference cell is a triangle or   tetrahedron), with FE_PyramidP (if the reference cell is a   pyramid), or with FE_WedgeP (if the reference cell is a wedge).   In other words, the term "linear" in the name of the function has to be   understood as  [2.x.19] -linear (i.e., bilinear or trilinear) for some of the   coordinate directions.  
* [0.x.14]*
   Return a Gauss-type quadrature matching the given reference cell (QGauss,   QGaussSimplex, QGaussPyramid, QGaussWedge).      [2.x.20]  n_points_1D The number of quadrature points in each direction   (QGauss) or an indication of what polynomial degree needs to be   integrated exactly for the other types.  
* [0.x.15]*
   Return a quadrature rule with the support points of the given reference   cell.    
*  [2.x.21]  The weights of the quadrature object are left unfilled.  
* [0.x.16]*
    [2.x.22]   
* [0.x.17]*
    [2.x.23]  Querying the number of building blocks of a reference cell    [2.x.24]   
* [0.x.18]*
   Return the number of vertices that make up the reference   cell in question. A vertex is a "corner" (a zero-dimensional   object) of the reference cell.  
* [0.x.19]*
   Return an object that can be thought of as an array containing all   indices from zero to n_vertices().  
* [0.x.20]*
   Return the number of lines that make up the reference   cell in question. A line is an "edge" (a one-dimensional   object) of the reference cell.  
* [0.x.21]*
   Return an object that can be thought of as an array containing all   indices from zero to n_lines().  
* [0.x.22]*
   Return the number of faces that make up the reference   cell in question. A face is a `(dim-1)`-dimensional   object bounding the reference cell.  
* [0.x.23]*
   Return an object that can be thought of as an array containing all   indices from zero to n_faces().  
* [0.x.24]*
   Return the reference-cell type of face  [2.x.25]  of the current   object. For example, if the current object is    [2.x.26]  then `face_no` must be between   in the interval  [2.x.27]  and the function will always return    [2.x.28]  If the current object is    [2.x.29]  then `face_no` must be between   in the interval  [2.x.30]  and the function will always return    [2.x.31]  For wedges and pyramids, the   returned object may be either  [2.x.32]  or    [2.x.33]  depending on the given index.  
* [0.x.25]*
    [2.x.34]   
* [0.x.26]*
    [2.x.35]  Relationships between objects in the cell and on faces    [2.x.36]   
* [0.x.27]*
   Return which child cells are adjacent to a certain face of the   mother cell.     For example, in 2D the layout of a quadrilateral cell is as follows:  
* [1.x.0]
*    Vertices and faces are indicated with their numbers, faces also with   their directions.     Now, when refined, the layout is like this:  
* [1.x.1]
*      Thus, the child cells on face 0 are (ordered in the direction of the   face) 0 and 2, on face 3 they are 2 and 3, etc.     For three spatial dimensions, the exact order of the children is laid   down in the general documentation of this class.     The <tt>face_orientation</tt> argument is meant exclusively for   quadrilaterals and hexahedra at the moment. It determines how this function   handles faces oriented in the standard and non-standard orientation. It   represents a bit-code for the overall <tt>face_orientation</tt>,   <tt>face_flip</tt> and <tt>face_rotation</tt> and defaults to the standard   orientation. The concept of face orientations is explained in this    [2.x.37]  "glossary"   entry.  
* [0.x.28]*
   For a given vertex in a cell, return a pair of a face index and a   vertex index within this face.    
*  [2.x.38]  In practice, a vertex is of course generally part of more than one     face, and one could return different faces and the corresponding     index within. Which face this function chooses is often not of     importance (and not exposed by this function on purpose).  
* [0.x.29]*
   For a given line in a cell, return a pair of a face index and a   line index within this face.    
*  [2.x.39]  In practice, a line is of course generally part of more than one     face, and one could return different faces and the corresponding     index within. Which face this function chooses is often not of     importance (and not exposed by this function on purpose).  
* [0.x.30]*
   Map face line number to cell line number.  
* [0.x.31]*
   Map face vertex number to cell vertex number.  
* [0.x.32]*
   Correct vertex index depending on face orientation.  
* [0.x.33]*
   Correct line index depending on face orientation.  
* [0.x.34]*
   Return whether the line with index  [2.x.40]  is oriented in   standard direction within a cell, given the  [2.x.41]  of   the face within the current cell, and  [2.x.42]  flag   for the line within that face.  [2.x.43]  indicates that the line is   oriented from vertex 0 to vertex 1, whereas it is the other way   around otherwise. In 1d and 2d, this is always  [2.x.44]  but in 3d   it may be different, see the respective discussion in the   documentation of the GeometryInfo class.  
* [0.x.35]*
    [2.x.45]   
* [0.x.36]*
    [2.x.46]  Geometric properties of reference cells    [2.x.47]  Querying the number of building blocks of a reference cell    [2.x.48]   
* [0.x.37]   Return  [2.x.49] -th unit tangential vector of a face of the reference cell.   The vectors are arranged such that the   cross product between the two vectors returns the unit normal vector.      [2.x.50]   [2.x.51]  must be between zero and `dim-1`.  
* [0.x.38]*
   Return the unit normal vector of a face of the reference cell.  
* [0.x.39]*
   Determine the orientation of the current entity described by its   vertices  [2.x.52]  relative to an entity described by  [2.x.53]   
* [0.x.40]*
   Inverse function of compute_orientation().  
* [0.x.41]*
   Return a vector of faces a given  [2.x.54]  belongs to.  
* [0.x.42]*
    [2.x.55]   
* [0.x.43]*
    [2.x.56]  Translating between deal.II indexing and formats used by other programs    [2.x.57]   
* [0.x.44]*
   Map an ExodusII vertex number to a deal.II vertex number.  
* [0.x.45]*
   Map an ExodusII face number to a deal.II face number.  
* [0.x.46]*
   Map a UNV vertex number to a deal.II vertex number.  
* [0.x.47]*
   Return a VTK linear shape constant that corresponds to the reference cell.  
* [0.x.48]*
   Return a VTK quadratic shape constant that corresponds to the reference   cell.  
* [0.x.49]*
   Return a VTK Lagrange shape constant that corresponds to the reference   cell.  
* [0.x.50]*
    [2.x.58]   
* [0.x.51]*
    [2.x.59]  Other functions    [2.x.60]   
* [0.x.52]*
   Return a text representation of the reference cell represented by the   current object.  
* [0.x.53]*
   Conversion operator to an integer.  
* [0.x.54]*
   Operator for equality comparison.  
* [0.x.55]*
   Operator for inequality comparison.  
* [0.x.56]*
   Write and read the data of this object from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.57]*
    [2.x.61]   
* [0.x.58]*
   The variable that stores what this object actually corresponds to.  
* [0.x.59]*
   Constructor. This is the constructor used to create the different   `static` member variables of this class. It is `private` but can   be called by a function in an internal namespace that is a `friend`   of this class.  
* [0.x.60]*
   A kind of constructor
* 
*  -  not quite private because it can be   called by anyone, but at least hidden in an internal namespace.  
* [0.x.61]*
 A namespace in which we define objects that correspond to specific reference cells. The objects defined here are a complete enumeration of all possible reference cells that can be used in deal.II.
*   [2.x.62]  ReferenceCell

* 
* [0.x.62]*
   Return the correct simplex reference cell type for the given dimension   `dim`. Depending on the template argument `dim`, this function returns a   reference to either Vertex, Triangle, or Tetrahedron.  
* [0.x.63]*
   Return the correct hypercube reference cell type for the given dimension   `dim`. Depending on the template argument `dim`, this function returns a   reference to either Vertex, Quadrilateral, or Hexahedron.  
* [0.x.64]*
     Constructor.    
* [0.x.65]*
     Destructor.    
* [0.x.66]*
     Print error message to  [2.x.63]     
* [0.x.67]*
     Entity type.    
* [0.x.68]*
     First set of values.    
* [0.x.69]*
     Second set of values.    
* [0.x.70]

include/deal.II-translator/grid/tensor_product_manifold_0.txt
[0.x.0]*


* 
*  [2.x.0] 
*  This manifold will combine the ChartManifolds  [2.x.1]  and  [2.x.2]  given in the constructor to form a new ChartManifold by building the tensor product  [2.x.3] . The first  [2.x.4]  dimensions in the real space and the first  [2.x.5]  dimensions of the chart will be given by manifold  [2.x.6]  while the remaining coordinates are given by  [2.x.7]  The manifold is to be used by a <tt>Triangulation [2.x.8]  space_dim_A+space_dim_B [2.x.9] 
*  An example usage would be the combination of a SphericalManifold with space dimension 2 and a FlatManifold with space dimension 1 to form a cylindrical manifold.
*  pull_back(), push_forward(), and push_forward_gradient() are implemented by splitting the input argument into inputs for  [2.x.10]  and  [2.x.11]  according to the given dimensions and applying the corresponding operations before concatenating the result.
* 

* 
*  [2.x.12]  The dimension arguments  [2.x.13]  and  [2.x.14]  are not used.
*   [2.x.15]  dim Dimension of cells (needs to match first template argument of the Triangulation to be attached to.  [2.x.16]  dim_A Dimension of ChartManifold A.  [2.x.17]  spacedim_A Spacial dimension of ChartManifold A.  [2.x.18]  chartdim_A Chart dimension of ChartManifold A.  [2.x.19]  dim_B Dimension of ChartManifold B.  [2.x.20]  spacedim_B Spacial dimension of ChartManifold B.  [2.x.21]  chartdim_B Chart dimension of ChartManifold B.

* 
* [0.x.1]*
   The chart dimension is the sum of the chart dimensions of the manifolds    [2.x.22]  and  [2.x.23]   
* [0.x.2]*
   The space dimension is the sum of the space dimensions of the manifolds    [2.x.24]  and  [2.x.25]   
* [0.x.3]*
   Constructor.  
* [0.x.4]*
   Clone this manifold.  
* [0.x.5]*
   Pull back operation.  
* [0.x.6]*
   Push forward operation.  
* [0.x.7]*
   Gradient.  
* [0.x.8]

include/deal.II-translator/grid/tria_0.txt
[0.x.0]*
     Forward declaration of a class into which we put much of the     implementation of the Triangulation class. See the .cc file for more     information.    
* [0.x.1]*
   A namespace for classes internal to the triangulation classes and   helpers.  
* [0.x.2]*
     Cache class used to store the number of used and active elements (lines     or quads etc) within the levels of a triangulation. This is only the     declaration of the template, concrete instantiations are below.         In the old days, whenever one wanted to access one of these numbers,     one had to perform a loop over all lines, e.g., and count the elements     until we hit the end iterator. This is time consuming and since access     to the number of lines etc is a rather frequent operation, this was not     an optimal solution.    
* [0.x.3]*
     Cache class used to store the number of used and active elements (lines     or quads etc) within the levels of a triangulation. This specialization     stores the numbers of lines.         In the old days, whenever one wanted to access one of these numbers,     one had to perform a loop over all lines, e.g., and count the elements     until we hit the end iterator. This is time consuming and since access     to the number of lines etc is a rather frequent operation, this was not     an optimal solution.    
* [0.x.4]*
       The number of levels on which we have used objects.      
* [0.x.5]*
       Number of used lines in the whole triangulation.      
* [0.x.6]*
       Array holding the number of used lines on each level.      
* [0.x.7]*
       Number of active lines in the whole triangulation.      
* [0.x.8]*
       Array holding the number of active lines on each level.      
* [0.x.9]*
       Constructor. Set values to zero by default.      
* [0.x.10]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.11]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.12]*
     Cache class used to store the number of used and active elements (lines     or quads etc) within the levels of a triangulation. This specialization     stores the numbers of quads. Due to the inheritance from the base class     NumberCache<1>, the numbers of lines are also within this class.         In the old days, whenever one wanted to access one of these numbers,     one had to perform a loop over all lines, e.g., and count the elements     until we hit the end iterator. This is time consuming and since access     to the number of lines etc is a rather frequent operation, this was not     an optimal solution.    
* [0.x.13]*
       Number of used quads in the whole triangulation.      
* [0.x.14]*
       Array holding the number of used quads on each level.      
* [0.x.15]*
       Number of active quads in the whole triangulation.      
* [0.x.16]*
       Array holding the number of active quads on each level.      
* [0.x.17]*
       Constructor. Set values to zero by default.      
* [0.x.18]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.19]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.20]*
     Cache class used to store the number of used and active elements (lines     or quads etc) within the levels of a triangulation. This specialization     stores the numbers of hexes. Due to the inheritance from the base class     NumberCache<2>, the numbers of lines and quads are also within this     class.         In the old days, whenever one wanted to access one of these numbers,     one had to perform a loop over all lines, e.g., and count the elements     until we hit the end . This is time consuming and since access to the     number of lines etc is a rather frequent operation, this was not an     optimal solution.    
* [0.x.21]*
       Number of used hexes in the whole triangulation.      
* [0.x.22]*
       Array holding the number of used hexes on each level.      
* [0.x.23]*
       Number of active hexes in the whole triangulation.      
* [0.x.24]*
       Array holding the number of active hexes on each level.      
* [0.x.25]*
       Constructor. Set values to zero by default.      
* [0.x.26]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.27]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.28]*
 A triangulation is a collection of cells that, jointly, cover the domain on which one typically wants to solve a partial differential equation. This domain, and the mesh that covers it, represents a  [2.x.0] 
* 
*  - imensional manifold and lives in  [2.x.1]  spatial dimensions, where  [2.x.2]  and  [2.x.3]  are the template arguments of this class. (If  [2.x.4]  is not specified, it takes the default value `spacedim=dim`.)
*  Thus, for example, an object of type  [2.x.5]  (or simply  [2.x.6]  Triangulation<1> since  [2.x.7]  by default) is used to represent and handle the usual one-dimensional triangulation used in the finite element method (so, segments on a straight line). On the other hand, objects such as  [2.x.8]  or  [2.x.9]  (that are associated with curves in 2D or surfaces in 3D) are the ones one wants to use in the boundary element method.
*  The name of the class is mostly hierarchical and is not meant to imply that a Triangulation can only consist of triangles. Instead, triangulations consist of line segments in 1d (i.e., if `dim==1`), and of three-dimensional cells (if `dim==3`). Moreover, historically, deal.II only supported quadrilaterals (cells with four vertices: deformed rectangles) in 2d and hexahedra (cells with six sides and eight vertices that are deformed boxes), neither of which are triangles. In other words, the term "triangulation" in the deal.II language is synonymous with "mesh" and is to be understood separate from its linguistic origin.
*  This class is written to be as independent of the dimension as possible (thus the complex construction of the  [2.x.10]  classes) to allow code-sharing, to allow reducing the need to mirror changes in the code for one dimension to the code for other dimensions. Nonetheless, some of the functions are dependent of the dimension and there only exist specialized versions for distinct dimensions.
*  This class satisfies the  [2.x.11]  "MeshType concept" requirements.
*  [1.x.0]
*  The actual data structure of a Triangulation object is rather complex and quite inconvenient if one attempted to operate on it directly, since data is spread over quite a lot of arrays and other places. However, there are ways powerful enough to work on these data structures without knowing their exact relations. deal.II uses class local alias (see below) to make things as easy and dimension independent as possible.
*  The Triangulation class provides iterators which enable looping over all cells without knowing the exact representation used to describe them. For more information see the documentation of <tt>TriaIterator</tt>. Their names are alias imported from the Iterators class (thus making them local types to this class) and are as follows:
*   [2.x.12]   [2.x.13]  <tt>cell_iterator</tt>: loop over all cells used in the Triangulation  [2.x.14]  <tt>active_cell_iterator</tt>: loop over all active cells  [2.x.15] 
*  For <tt>dim==1</tt>, these iterators are mapped as follows: 
* [1.x.1]
*  while for  [2.x.16]  we have the additional face iterator: 
* [1.x.2]
* 
*  By using the cell iterators, you can write code independent of the spatial dimension. The same applies for substructure iterators, where a substructure is defined as a face of a cell. The face of a cell is a vertex in 1D and a line in 2D; however, vertices are handled in a different way and therefore lines have no faces.
*  The Triangulation class offers functions like begin_active() which gives you an iterator to the first active cell. There are quite a lot of functions returning iterators. Take a look at the class doc to get an overview.
*  Usage of these iterators is similar to usage of standard container iterators. Some examples taken from the Triangulation source code follow (notice that in the last two examples the template parameter  [2.x.17]  has been omitted, so it takes the default value  [2.x.18] ).
*   [2.x.19]   [2.x.20]   [2.x.21] Counting the number of cells on a specific level [2.x.22]    
* [1.x.3]
*  Another way, which uses  [2.x.23]  would be to write   
* [1.x.4]
* 
*   [2.x.24]   [2.x.25] Refining all cells of a triangulation [2.x.26]    
* [1.x.5]
*   [2.x.27] 
* 

*  [1.x.6]
*  Usage of a Triangulation is mainly done through the use of iterators. An example probably shows best how to use it:

* 
* [1.x.7]
* 
* 

*  [1.x.8]
*  There are several possibilities to create a triangulation:  [2.x.28]   [2.x.29]  The most common domains, such as hypercubes (i.e. lines, squares, cubes, etc), hyper-balls (circles, balls, ...) and some other, more weird domains such as the L-shape region and higher dimensional generalizations and others, are provided by the GridGenerator class which takes a triangulation and fills it by a division of the required domain.
*   [2.x.30]  Reading in a triangulation: By using an object of the GridIn class, you can read in fairly general triangulations. See there for more information. The mentioned class uses the interface described directly below to transfer the data into the triangulation.
*   [2.x.31]  Explicitly creating a triangulation: you can create a triangulation by providing a list of vertices and a list of cells. Each such cell consists of a vector storing the indices of the vertices of this cell in the vertex list. To see how this works, you can take a look at the  [2.x.32]  functions. The appropriate function to be called is create_triangulation().
*  Creating the hierarchical information needed for this library from cells storing only vertex information can be quite a complex task.  For example in 2D, we have to create lines between vertices (but only once, though there are two cells which link these two vertices) and we have to create neighborhood information. Grids being read in should therefore not be too large, reading refined grids would be inefficient (although there is technically no problem in reading grids with several 10.000 or 100.000 cells; the library can handle this without much problems). Apart from the performance aspect, refined grids do not lend too well to multigrid algorithms, since solving on the coarsest level is expensive. It is wiser in any case to read in a grid as coarse as possible and then do the needed refinement steps.
*  It is your duty to guarantee that cells have the correct orientation. To guarantee this, in the input vector keeping the cell list, the vertex indices for each cell have to be in a defined order, see the documentation of GeometryInfo<dim>. In one dimension, the first vertex index must refer to that vertex with the lower coordinate value. In 2D and 3D, the corresponding conditions are not easy to verify and no full attempt to do so is made. If you violate this condition, you may end up with matrix entries having the wrong sign (clockwise vertex numbering, which results in a negative area element) of with wrong matrix elements (twisted quadrilaterals, i.e. two vertices interchanged; this results in a wrong area element).
*  There are more subtle conditions which must be imposed upon the vertex numbering within cells. They do not only hold for the data read from an UCD or any other input file, but also for the data passed to create_triangulation(). See the documentation for the GridIn class for more details on this, and above all to the GridReordering class that explains many of the problems and an algorithm to reorder cells such that they satisfy the conditions outlined above.
*   [2.x.33]  Copying a triangulation: when computing on time dependent meshes or when using adaptive refinement, you will often want to create a new triangulation to be the same as another one. This is facilitated by the  [2.x.34]  copy_triangulation function.
*  It is guaranteed that vertex, line or cell numbers in the two triangulations are the same and that two iterators walking on the two triangulations visit matching cells if they are incremented in parallel. It may be conceivable to implement a clean-up in the copy operation, which eliminates holes of unused memory, re-joins scattered data and so on. In principle this would be a useful operation but guaranteeing some parallelism in the two triangulations seems more important since usually data will have to be transferred between the grids.  [2.x.35] 
*  Finally, there is a special function for folks who like bad grids: distort_random(). It moves all the vertices in the grid a bit around by a random value, leaving behind a distorted mesh. Note that you should apply this function to the final mesh, since refinement smoothes the mesh a bit.
*  The function will make sure that vertices on restricted faces (hanging nodes) will end up in the correct place, i.e. in the middle of the two other vertices of the mother line, and the analogue in higher space dimensions (vertices on the boundary are not corrected, so don't distort boundary vertices in more than two space dimension, i.e. in dimensions where boundary vertices can be hanging nodes). Applying the algorithm has another drawback related to the placement of cells, however: the children of a cell will not occupy the same region of the domain as the mother cell does. While this is the usual behavior with cells at the boundary, here you may get into trouble when using multigrid algorithms or when transferring solutions from coarse to fine grids and back. In general, the use of this function is only safe if you only use the most refined level of the triangulation for computations.
* 

* 
*  [1.x.9]
*  Refinement of a triangulation may be done through several ways. The most low-level way is directly through iterators: let  [2.x.36]  be an iterator to an active cell (i.e. the cell pointed to has no children), then the function call <tt>i->set_refine_flag()</tt> marks the respective cell for refinement. Marking non-active cells results in an error.
*  After all the cells you wanted to mark for refinement, call execute_coarsening_and_refinement() to actually perform the refinement. This function itself first calls the  [2.x.37]  function to regularize the resulting triangulation: since a face between two adjacent cells may only be subdivided once (i.e. the levels of two adjacent cells may differ by one at most; it is not possible to have a cell refined twice while the neighboring one is not refined), some additional cells are flagged for refinement to smooth the grid. This enlarges the number of resulting cells but makes the grid more regular, thus leading to better approximation properties and, above all, making the handling of data structures and algorithms much easier. To be honest, this is mostly an algorithmic step than one needed by the finite element method.
*  To coarsen a grid, the same way as above is possible by using <tt>i->set_coarsen_flag</tt> and calling execute_coarsening_and_refinement().
*  The reason for first coarsening, then refining is that the refinement usually adds some additional cells to keep the triangulation regular and thus satisfies all refinement requests, while the coarsening does not delete cells not requested for; therefore the refinement will often revert some effects of coarsening while the opposite is not true. The stated order of coarsening before refinement will thus normally lead to a result closer to the intended one.
*  Marking cells for refinement 'by hand' through iterators is one way to produce a new grid, especially if you know what kind of grid you are looking for, e.g. if you want to have a grid successively refined towards the boundary or always at the center (see the example programs, they do exactly these things). There are more advanced functions, however, which are more suitable for automatic generation of hierarchical grids in the context of a posteriori error estimation and adaptive finite elements. These functions can be found in the GridRefinement class.
* 

*  [1.x.10]
*  Some degradation of approximation properties has been observed for grids which are too unstructured. Therefore, prepare_coarsening_and_refinement() which is automatically called by execute_coarsening_and_refinement() can do some smoothing of the triangulation. Note that mesh smoothing is only done for two or more space dimensions, no smoothing is available at present for one spatial dimension. In the following, let <tt>execute_*</tt> stand for execute_coarsening_and_refinement().
*  For the purpose of smoothing, the Triangulation constructor takes an argument specifying whether a smoothing step shall be performed on the grid each time <tt>execute_*</tt> is called. The default is that such a step not be done, since this results in additional cells being produced, which may not be necessary in all cases. If switched on, calling <tt>execute_*</tt> results in flagging additional cells for refinement to avoid vertices as the ones mentioned. The algorithms for both regularization and smoothing of triangulations are described below in the section on technical issues. The reason why this parameter must be given to the constructor rather than to <tt>execute_*</tt> is that it would result in algorithmic problems if you called <tt>execute_*</tt> once without and once with smoothing, since then in some refinement steps would need to be refined twice.
*  The parameter taken by the constructor is an integer which may be composed bitwise by the constants defined in the enum #MeshSmoothing (see there for the possibilities).
* 

* 
*  [2.x.38]  While it is possible to pass all of the flags in #MeshSmoothing to objects of type  [2.x.39]  it is not always possible to honor all of these smoothing options if they would require knowledge of refinement/coarsening flags on cells not locally owned by this processor. As a consequence, for some of these flags, the ultimate number of cells of the parallel triangulation may depend on the number of processors into which it is partitioned.
* 

*  [1.x.11]
*  Each cell, face or edge stores information denoting the material or the part of the boundary that an object belongs to. The material id of a cell is typically used to identify which cells belong to a particular part of the domain, e.g., when you have different materials (steel, concrete, wood) that are all part of the same domain. One would then usually query the material id associated with a cell during assembly of the bilinear form, and use it to determine (e.g., by table lookup, or a sequence of if-else statements) what the correct material coefficients would be for that cell. See also  [2.x.40]  "this glossary entry".
*  This material_id may be set upon construction of a triangulation (through the CellData data structure), or later through use of cell iterators. For a typical use of this functionality, see the  [2.x.41]  tutorial program. The functions of the GridGenerator namespace typically set the material ID of all cells to zero. When reading a triangulation through the GridIn class, different input file formats have different conventions, but typically either explicitly specify the material id, or if they don't, then GridIn simply sets them to zero. Because the material of a cell is intended to pertain to a particular region of the domain, material ids are inherited by child cells from their parent upon mesh refinement.
*  Boundary indicators on lower dimensional objects (these have no material id) indicate the number of a boundary component. The weak formulation of the partial differential equation may have different boundary conditions on different parts of the boundary. The boundary indicator can be used in creating the matrix or the right hand side vector to indicate these different parts of the model (this use is like the material id of cells). Boundary indicators may be in the range from zero to  [2.x.42]  The value  [2.x.43]  is reserved to denote interior lines (in 2D) and interior lines and quads (in 3D), which do not have a boundary indicator. This way, a program can easily determine, whether such an object is at the boundary or not. Material indicators may be in the range from zero to  [2.x.44] 
*  Lines in two dimensions and quads in three dimensions inherit their boundary indicator to their children upon refinement. You should therefore make sure that if you have different boundary parts, the different parts are separated by a vertex (in 2D) or a line (in 3D) such that each boundary line or quad has a unique boundary indicator.
*  By default (unless otherwise specified during creation of a triangulation), all parts of the boundary have boundary indicator zero. As a historical wart, this isn't true for 1d meshes, however: For these, leftmost vertices have boundary indicator zero while rightmost vertices have boundary indicator one. In either case, the boundary indicator of a face can be changed using a call of the kind  [2.x.45] .
*   [2.x.46]   [2.x.47]  "Glossary entry on boundary indicators"
* 

*  [1.x.12]
*  It is possible to reconstruct a grid from its refinement history, which can be stored and loaded through the  [2.x.48]  and  [2.x.49]  load_refine_flags functions. Normally, the code will look like this:  
* [1.x.13]
* 
*  If you want to re-create the grid from the stored information, you write:  
* [1.x.14]
* 
*  The same scheme is employed for coarsening and the coarsening flags.
*  You may write other information to the output file between different sets of refinement information, as long as you read it upon re-creation of the grid. You should make sure that the other information in the new triangulation which is to be created from the saved flags, matches that of the old triangulation, for example the smoothing level; if not, the cells actually created from the flags may be other ones, since smoothing adds additional cells, but their number may be depending on the smoothing level.
*  There actually are two sets of <tt>save_*_flags</tt> and <tt>load_*_flags</tt> functions. One takes a stream as argument and reads/writes the information from/to the stream, thus enabling storing flags to files. The other set takes an argument of type <tt>vector<bool></tt>. This enables the user to temporarily store some flags, e.g. if another function needs them, and restore them afterwards.
* 

*  [1.x.15]
*  A triangulation offers one bit per line, quad, etc for user flags. This field can be accessed as all other data using iterators. Normally, this user flag is used if an algorithm walks over all cells and needs information whether another cell, e.g. a neighbor, has already been processed. See  [2.x.50]  "the glossary for more information".
*  There is another set of user data, which can be either an <tt>unsigned int</tt> or a <tt>void</tt>, for each line, quad, etc. You can access these through the functions listed under <tt>User data</tt> in the accessor classes. Again, see  [2.x.51]  "the glossary for more information".
*  The value of these user indices or pointers is  [2.x.52]  by default. Note that the pointers are not inherited to children upon refinement. Still, after a remeshing they are available on all cells, where they were set on the previous mesh.
*  The usual warning about the missing type safety of  [2.x.53]  pointers are obviously in place here; responsibility for correctness of types etc lies entirely with the user of the pointer.
* 

* 
*  [2.x.54]  User pointers and user indices are stored in the same place. In order to avoid unwanted conversions, Triangulation checks which one of them is in use and does not allow access to the other one, until clear_user_data() has been called.
* 

*  [1.x.16]
*  deal.II implements all geometries (curved and otherwise) with classes inheriting from Manifold; see the documentation of Manifold,  [2.x.55] , or the  [2.x.56]  module for examples and a complete description of the algorithms. By default, all cells in a Triangulation have a flat geometry, meaning that all lines in the Triangulation are assumed to be straight. If a cell has a manifold_id that is not equal to  [2.x.57]  then the Triangulation uses the associated Manifold object for computations on that cell (e.g., cell refinement). Here is a quick example, taken from the implementation of  [2.x.58]  that sets up a polar grid:
* 

* 
* [1.x.17]
* 
*  This will set up a grid where the boundary lines will be refined by performing calculations in polar coordinates. When the mesh is refined the cells adjacent to the boundary will use this new line midpoint (as well as the other three midpoints and original cell vertices) to calculate the cell midpoint with a transfinite interpolation: this propagates the curved boundary into the interior in a smooth way. It is possible to generate a better grid (which interpolates across all cells between two different Manifold descriptions, instead of just going one cell at a time) by using TransfiniteInterpolationManifold; see the documentation of that class for more information.
*  You should take note of one caveat: if you have concave boundaries, you must make sure that a new boundary vertex does not lie too much inside the cell which is to be refined. The reason is that the center vertex is placed at the point which is a weighted average of the vertices of the original cell, new face midpoints, and (in 3D) new line midpoints. Therefore if your new boundary vertex is too near the center of the old quadrilateral or hexahedron, the distance to the midpoint vertex will become too small, thus generating distorted cells. This issue is discussed extensively in  [2.x.59]  "distorted cells".
*  [1.x.18]
*  There are cases where one object would like to know whenever a triangulation is being refined, copied, or modified in a number of other ways. This could of course be achieved if, in your user code, you tell every such object whenever you are about to refine the triangulation, but this will get tedious and is error prone. The Triangulation class implements a more elegant way to achieve this: signals.
*  In essence, a signal is an object (a member of the Triangulation class) that another object can connect to. A connection is in essence that the connecting object passes a function object taking a certain number and kind of arguments. Whenever the owner of the signal wants to indicate a certain kind of event, it 'triggers' the signal, which in turn means that all connections of the signal are triggered: in other word, the function objects are executed and can take the action that is necessary.
*  As a simple example, the following code will print something to the output every time the triangulation has just been refined:  
* [1.x.19]
*  This code will produce output twice, once for each refinement cycle.
*  A more interesting application would be the following, akin to what the FEValues class does. This class stores a pointer to a triangulation and also an iterator to the cell last handled (so that it can compare the current cell with the previous one and, for example, decide that there is no need to re-compute the Jacobian matrix if the new cell is a simple translation of the previous one). However, whenever the triangulation is modified, the iterator to the previously handled cell needs to be invalidated since it now no longer points to any useful cell (or, at the very least, points to something that may not necessarily resemble the cells previously handled). The code would look something like this (the real code has some more error checking and has to handle the case that subsequent cells might actually belong to different triangulation, but that is of no concern to us here):

* 
* [1.x.20]
*  Here, whenever the triangulation is refined, it triggers the post- refinement signal which calls the function object attached to it. This function object is the member function  [2.x.60]  where we have bound the single argument (the  [2.x.61]  pointer of a member function that otherwise takes no arguments) to the  [2.x.62]  pointer of the FEValues object. Note how here there is no need for the code that owns the triangulation and the FEValues object to inform the latter if the former is refined. (In practice, the function would want to connect to some of the other signals that the triangulation offers as well, in particular to creation and deletion signals.)
*  The Triangulation class has a variety of signals that indicate different actions by which the triangulation can modify itself and potentially require follow-up action elsewhere. Please refer to  [2.x.63]  for details.
*  [1.x.21]
*  Like many other classes in deal.II, the Triangulation class can stream its contents to an archive using BOOST's serialization facilities. The data so stored can later be retrieved again from the archive to restore the contents of this object. This facility is frequently used to save the state of a program to disk for possible later resurrection, often in the context of checkpoint/restart strategies for long running computations or on computers that aren't very reliable (e.g. on very large clusters where individual nodes occasionally fail and then bring down an entire MPI job).
*  For technical reasons, writing and restoring a Triangulation object is not trivial. The primary reason is that unlike many other objects, triangulations rely on many other objects to which they store pointers or with which they interface; for example, triangulations store pointers to objects describing boundaries and manifolds, and they have signals that store pointers to other objects so they can be notified of changes in the triangulation (see the section on signals in this introduction). Since these objects are owned by the user space (for example the user can create a custom manifold object), they may not be serializable. So in cases like this,  [2.x.64]  can store a reference to an object instead of the pointer, but the reference will never be satisfied at write time because the object pointed to is not serialized. Clearly, at load time,  [2.x.65]  will not know where to let the pointer point to because it never gets to re-create the object originally pointed to.
*  For these reasons, saving a triangulation to an archive does not store all information, but only certain parts. More specifically, the information that is stored is everything that defines the mesh such as vertex locations, vertex indices, how vertices are connected to cells, boundary indicators, subdomain ids, material ids, etc. On the other hand, the following information is not stored:
* 

* 
* 

* 
* 

* 
* 
*  - signals
* 

* 
* 

* 
* 

* 
* 
*  - pointers to Manifold objects previously set using      [2.x.66] 
*  On the other hand, since these are objects that are usually set in user code, they can typically easily be set again in that part of your code in which you re-load triangulations.
*  In a sense, this approach to serialization means that re-loading a triangulation is more akin to calling the  [2.x.67]  function and filling it with some additional content, as that function also does not touch the signals and Manifold objects that belong to this triangulation. In keeping with this analogy, the  [2.x.68]  function also triggers the same kinds of signal as  [2.x.69] 
* 

*  [1.x.22]
*  [1.x.23]
*  We chose an inductive point of view: since upon creation of the triangulation all cells are on the same level, all regularity assumptions regarding the maximum difference in level of cells sharing a common face, edge or vertex hold. Since we use the regularization and smoothing in each step of the mesh history, when coming to the point of refining it further the assumptions also hold.
*  The regularization and smoothing is done in the  [2.x.70]  prepare_coarsening_and_refinement function, which is called by  [2.x.71]  execute_coarsening_and_refinement at the very beginning.  It decides which additional cells to flag for refinement by looking at the old grid and the refinement flags for each cell.
*   [2.x.72]   [2.x.73]   [2.x.74] Regularization: [2.x.75]  The algorithm walks over all cells checking whether the present cell is flagged for refinement and a neighbor of the present cell is refined once less than the present one. If so, flag the neighbor for refinement. Because of the induction above, there may be no neighbor with level two less than the present one.
*  The neighbor thus flagged for refinement may induce more cells which need to be refined. However, such cells which need additional refinement always are on one level lower than the present one, so we can get away with only one sweep over all cells if we do the loop in the reverse way, starting with those on the highest level. This way, we may flag additional cells on lower levels, but if these induce more refinement needed, this is performed later on when we visit them in out backward running loop.
*   [2.x.76]   [2.x.77] Smoothing: [2.x.78]   [2.x.79]   [2.x.80]   [2.x.81]  First a list is set up which stores for each vertex the highest level one of the adjacent cells belongs to. Now, since we did smoothing in the previous refinement steps also, each cell may only have vertices with levels at most one greater than the level of the present cell.
*  However, if we store the level plus one for cells marked for refinement, we may end up with cells which have vertices of level two greater than the cells level. We need to refine this cell also, and need thus also update the levels of its vertices. This itself may lead to cells needing refinement, but these are on lower levels, as above, which is why we may do all kinds of additional flagging in one loop only.
*   [2.x.82]   [2.x.83]  For each cell we count the number of neighbors which are refined or flagged for refinement. If this exceeds the number of neighbors which are not refined and not flagged for refinement, then the current cell is flagged for refinement. Since this may lead to cells on the same level which also will need refinement, we will need additional loops of regularization and smoothing over all cells until nothing changes any more.
*   [2.x.84]  <tt>eliminate_refined_*_islands</tt>: This one does much the same as the above one, but for coarsening. If a cell is flagged for refinement or if all of its children are active and if the number of neighbors which are either active and not flagged for refinement, or not active but all children flagged for coarsening equals the total number of neighbors, then this cell's children are flagged for coarsening or (if this cell was flagged for refinement) the refine flag is cleared.
*  For a description of the distinction between the two versions of the flag see above in the section about mesh smoothing in the general part of this classes description.
*  The same applies as above: several loops may be necessary.  [2.x.85]   [2.x.86] 
*  Regularization and smoothing are a bit complementary in that we check whether we need to set additional refinement flags when being on a cell flagged for refinement (regularization) or on a cell not flagged for refinement. This makes readable programming easier.
*  All the described algorithms apply only for more than one space dimension, since for one dimension no restrictions apply. It may be necessary to apply some smoothing for multigrid algorithms, but this has to be decided upon later.
* 

*  [1.x.24]
*  It seems impossible to preserve  [2.x.87]  of a triangulation through iterator usage. Thus, if you declare pointers to a  [2.x.88]  triangulation object, you should be well aware that you might involuntarily alter the data stored in the triangulation.
* 

* 
*  [2.x.89] 

* 
* [0.x.29]*
   An internal alias to make the definition of the iterator classes   simpler.  
* [0.x.30]*
   Declare some symbolic names for mesh smoothing algorithms. The meaning of   these flags is documented in the Triangulation class.  
* [0.x.31]*
     No mesh smoothing at all, except that meshes have to remain one-     irregular.    
* [0.x.32]*
     It can be shown, that degradation of approximation occurs if the     triangulation contains vertices which are member of cells with levels     differing by more than one. One such example is the following:          [2.x.90]          It would seem that in two space dimensions, the maximum jump in levels     between cells sharing a common vertex is two (as in the example above).     However, this is not true if more than four cells meet at a vertex. It     is not uncommon that a      [2.x.91]  "coarse (initial) mesh" contains vertices at which     six or even eight cells meet, when small features of the domain have to     be resolved even on the coarsest mesh. In that case, the maximum     difference in levels is three or four, respectively. The problem gets     even worse in three space dimensions.         Looking at an interpolation of the second derivative of the finite     element solution (assuming bilinear finite elements), one sees that the     numerical solution is almost totally wrong, compared with the true     second derivative. Indeed, on regular meshes, there exist sharp     estimations that the H<sup>2</sup>-error is only of order one, so we     should not be surprised; however, the numerical solution may show a     value for the second derivative which may be a factor of ten away from     the true value. These problems are located on the small cell adjacent     to the center vertex, where cells of non-subsequent levels meet, as     well as on the upper and right neighbor of this cell (but with a less     degree of deviation from the true value).         If the smoothing indicator given to the constructor contains the bit     for #limit_level_difference_at_vertices, situations as the above one     are eliminated by also marking the upper right cell for refinement.         In case of anisotropic refinement, the level of a cell is not linked to     the refinement of a cell as directly as in case of isotropic     refinement. Furthermore, a cell can be strongly refined in one     direction and not or at least much less refined in another. Therefore,     it is very difficult to decide, which cases should be excluded from the     refinement process. As a consequence, when using anisotropic     refinement, the #limit_level_difference_at_vertices flag must not be     set. On the other hand, the implementation of multigrid methods in     deal.II requires that this bit be set.    
* [0.x.33]*
     Single cells which are not refined and are surrounded by cells which     are refined usually also lead to a sharp decline in approximation     properties locally. The reason is that the nodes on the faces between     unrefined and refined cells are not real degrees of freedom but carry     constraints. The patch without additional degrees of freedom is thus     significantly larger then the unrefined cell itself. If in the     parameter passed to the constructor the bit for     #eliminate_unrefined_islands is set, all cells which are not flagged     for refinement but which are surrounded by more refined cells than     unrefined cells are flagged for refinement. Cells which are not yet     refined but flagged for that are accounted for the number of refined     neighbors. Cells on the boundary are not accounted for at all. An     unrefined island is, by this definition also a cell which (in 2D) is     surrounded by three refined cells and one unrefined one, or one     surrounded by two refined cells, one unrefined one and is at the     boundary on one side. It is thus not a true island, as the name of the     flag may indicate. However, no better name came to mind to the author     by now.    
* [0.x.34]*
     A triangulation of patch level 1 consists of patches, i.e. of cells     that are refined once. This flag ensures that a mesh of patch level 1     is still of patch level 1 after coarsening and refinement. It is,     however, the user's responsibility to ensure that the mesh is of patch     level 1 before calling      [2.x.92]  the first time. The     easiest way to achieve this is by calling global_refine(1) straight     after creation of the triangulation.  It follows that if at least one     of the children of a cell is or will be refined than all children need     to be refined. If the #patch_level_1 flag is set, than the flags     #eliminate_unrefined_islands, #eliminate_refined_inner_islands and     #eliminate_refined_boundary_islands will be ignored as they will be     fulfilled automatically.    
* [0.x.35]*
     Each      [2.x.93]  "coarse grid"     cell is refined at least once,     i.e., the triangulation     might have active cells on level 1 but not on level 0. This flag     ensures that a mesh which has coarsest_level_1 has still     coarsest_level_1 after coarsening and refinement. It is, however, the     user's responsibility to ensure that the mesh has coarsest_level_1     before calling execute_coarsening_and_refinement the first time. The     easiest way to achieve this is by calling global_refine(1) straight     after creation of the triangulation. It follows that active cells on     level 1 may not be coarsened.         The main use of this flag is to ensure that each cell has at least one     neighbor in each coordinate direction (i.e. each cell has at least a     left or right, and at least an upper or lower neighbor in 2d). This is     a necessary precondition for some algorithms that compute finite     differences between cells. The DerivativeApproximation class is one of     these algorithms that require that a triangulation is coarsest_level_1     unless all cells already have at least one neighbor in each coordinate     direction on the coarsest level.    
* [0.x.36]*
     This flag is not included in  [2.x.94]  The flag is     concerned with the following case: consider the case that an unrefined     and a refined cell share a common face and that one of the children of     the refined cell along the common face is flagged for further     refinement. In that case, the resulting mesh would have more than one     hanging node along one or more of the edges of the triangulation, a     situation that is not allowed. Consequently, in order to perform the     refinement, the coarser of the two original cells is also going to be     refined.         However, in many cases it is sufficient to refine the coarser of the     two original cells in an anisotropic way to avoid the case of multiple     hanging vertices on a single edge. Doing only the minimal anisotropic     refinement can save cells and degrees of freedom. By specifying this     flag, the library can produce these anisotropic refinements.         The flag is not included by default since it may lead to     anisotropically refined meshes even though no cell has ever been     refined anisotropically explicitly by a user command. This surprising     fact may lead to programs that do the wrong thing since they are not     written for the additional cases that can happen with anisotropic     meshes, see the discussion in the introduction to  [2.x.95] .    
* [0.x.37]*
     This algorithm seeks for isolated cells which are refined or flagged     for refinement. This definition is unlike that for     #eliminate_unrefined_islands, which would mean that an island is     defined as a cell which is refined but more of its neighbors are not     refined than are refined. For example, in 2D, a cell's refinement would     be reverted if at most one of its neighbors is also refined (or refined     but flagged for coarsening).         The reason for the change in definition of an island is, that this     option would be a bit dangerous, since if you consider a chain of     refined cells (e.g. along a kink in the solution), the cells at the two     ends would be coarsened, after which the next outermost cells would     need to be coarsened. Therefore, only one loop of flagging cells like     this could be done to avoid eating up the whole chain of refined cells     (`chain reaction'...).         This algorithm also takes into account cells which are not actually     refined but are flagged for refinement. If necessary, it takes away the     refinement flag.         Actually there are two versions of this flag,     #eliminate_refined_inner_islands and     #eliminate_refined_boundary_islands. The first eliminates islands     defined by the definition above which are in the interior of the     domain, while the second eliminates only those islands if the cell is     at the boundary. The reason for this split of flags is that one often     wants to eliminate such islands in the interior while those at the     boundary may well be wanted, for example if one refines the mesh     according to a criterion associated with a boundary integral or if one     has rough boundary data.    
* [0.x.38]*
     The result of this flag is very similar to     #eliminate_refined_inner_islands. See the documentation there.    
* [0.x.39]*
     This flag prevents the occurrence of unrefined islands. In more detail:     It prohibits the coarsening of a cell if 'most of the neighbors' will     be refined after the step.    
* [0.x.40]*
     This flag sums up all smoothing algorithms which may be performed upon     refinement by flagging some more cells for refinement.    
* [0.x.41]*
     This flag sums up all smoothing algorithms which may be performed upon     coarsening by flagging some more cells for coarsening.    
* [0.x.42]*
     This flag includes all the above ones (therefore combines all     smoothing algorithms implemented), with the exception of anisotropic     smoothing.    
* [0.x.43]*
   An alias that is used to identify cell iterators. The concept of   iterators is discussed at length in the    [2.x.96]  "iterators documentation module".     The current alias identifies cells in a triangulation. The TriaIterator   class works like a pointer that when you dereference it yields an object   of type CellAccessor. CellAccessor is a class that identifies properties   that are specific to cells in a triangulation, but it is derived (and   consequently inherits) from TriaAccessor that describes what you can ask   of more general objects (lines, faces, as well as cells) in a   triangulation.    
*  [2.x.97]   
* [0.x.44]*
   The same as above to allow the usage of the "MeshType concept" also   on the refinement levels.  
* [0.x.45]*
   An alias that is used to identify    [2.x.98]  "active cell iterators".   The concept of iterators is discussed at length in the    [2.x.99]  "iterators documentation module".     The current alias identifies active cells in a triangulation. The   TriaActiveIterator class works like a pointer to active objects that when   you dereference it yields an object of type CellAccessor. CellAccessor is   a class that identifies properties that are specific to cells in a   triangulation, but it is derived (and consequently inherits) from   TriaAccessor that describes what you can ask of more general objects   (lines, faces, as well as cells) in a triangulation.    
*  [2.x.100]   
* [0.x.46]*
   An alias that is used to identify iterators that point to faces.   The concept of iterators is discussed at length in the    [2.x.101]  "iterators documentation module".     The current alias identifies faces in a triangulation. The   TriaIterator class works like a pointer to objects that when   you dereference it yields an object of type TriaAccessor, i.e.,   class that can be used to query geometric properties of faces   such as their vertices, their area, etc.    
*  [2.x.102]   
* [0.x.47]*
   An alias that is used to identify iterators that point to active faces,   i.e., to faces that have no children. Active faces must be faces of at   least one active cell.     Other than the "active" qualification, this alias is identical to the    [2.x.103]  alias. In particular, dereferencing either yields   the same kind of object.    
*  [2.x.104]   
* [0.x.48]*
   An alias that defines an iterator type to iterate over   vertices of a mesh.  The concept of iterators is discussed at   length in the    [2.x.105]  "iterators documentation module".    
*  [2.x.106]   
* [0.x.49]*
   An alias that defines an iterator type to iterate over   vertices of a mesh.  The concept of iterators is discussed at   length in the    [2.x.107]  "iterators documentation module".     This alias is in fact identical to the  [2.x.108]  alias   above since all vertices in a mesh are active (i.e., are a vertex of   an active cell).    
*  [2.x.109]   
* [0.x.50]*
   An alias that defines an iterator over the (one-dimensional) lines   of a mesh. In one-dimensional meshes, these are the cells of the mesh,   whereas in two-dimensional meshes the lines are the faces of cells.    
*  [2.x.110]   
* [0.x.51]*
   An alias that allows iterating over the [1.x.25] lines, i.e.,   that subset of lines that have no children. In one-dimensional meshes,   these are the cells of the mesh, whereas in two-dimensional   meshes the lines are the faces of cells.     In two- or three-dimensional meshes, lines without children (i.e.,   the active lines) are part of at least one active cell. Each such line may   additionally be a child of a line of a coarser cell adjacent to a cell   that is active. (This coarser neighbor would then also be active.)    
*  [2.x.111]   
* [0.x.52]*
   An alias that defines an iterator over the (two-dimensional) quads   of a mesh. In two-dimensional meshes, these are the cells of the mesh,   whereas in three-dimensional meshes the quads are the faces of cells.    
*  [2.x.112]   
* [0.x.53]*
   An alias that allows iterating over the [1.x.26] quads, i.e.,   that subset of quads that have no children. In two-dimensional meshes,   these are the cells of the mesh, whereas in three-dimensional   meshes the quads are the faces of cells.     In three-dimensional meshes, quads without children (i.e.,   the active quads) are faces of at least one active cell. Each such quad may   additionally be a child of a quad face of a coarser cell adjacent to a cell   that is active. (This coarser neighbor would then also be active.)    
*  [2.x.113]   
* [0.x.54]*
   An alias that defines an iterator over the (three-dimensional) hexes   of a mesh. This iterator only makes sense in three-dimensional meshes,   where hexes are the cells of the mesh.    
*  [2.x.114]   
* [0.x.55]*
   An alias that allows iterating over the [1.x.27] hexes of a mesh.   This iterator only makes sense in three-dimensional meshes,   where hexes are the cells of the mesh. Consequently, in these   three-dimensional meshes, this iterator is equivalent to the    [2.x.115]  alias.    
*  [2.x.116]   
* [0.x.56]*
   A structure that is used as an exception object by the   create_triangulation() function to indicate which cells among the coarse   mesh cells are inverted or severely distorted (see the entry on    [2.x.117]  "distorted cells"   in the glossary).     Objects of this kind are thrown by the create_triangulation() and   execute_coarsening_and_refinement() functions, and they can be caught in   user code if this condition is to be ignored. Note, however, that such   exceptions are only produced if the necessity for this check was   indicated when calling the constructor of the Triangulation class.     A cell is called [1.x.28] if the determinant of the Jacobian of   the mapping from reference cell to real cell is negative at least at one   vertex. This computation is done using the    [2.x.118]  function.  
* [0.x.57]*
     Destructor. Empty, but needed for the sake of exception specification,     since the base class has this exception specification and the     automatically generated destructor would have a different one due to     member objects.    
* [0.x.58]*
     A list of those cells among the coarse mesh cells that are deformed or     whose children are deformed.    
* [0.x.59]*
   Make the dimension available in function templates.  
* [0.x.60]*
   Make the space-dimension available in function templates.  
* [0.x.61]*
   Create an empty triangulation. Do not create any cells.      [2.x.119]  smooth_grid Determines the level of smoothness of the mesh size   function that should be enforced upon mesh refinement.      [2.x.120]  check_for_distorted_cells Determines whether the triangulation   should check whether any of the cells that are created by   create_triangulation() or execute_coarsening_and_refinement() are   distorted (see    [2.x.121]  "distorted cells").   If set, these two functions may throw an exception if they encounter   distorted cells.  
* [0.x.62]*
   Copy constructor.     You should really use the  [2.x.122]  function, so this   constructor is deleted. The reason for this is   that we may want to use triangulation objects in collections. However,   C++ containers require that the objects stored in them are copyable, so   we need to provide a copy constructor. On the other hand, copying   triangulations is so expensive that we do not want such objects copied by   accident, for example in compiler-generated temporary objects. By   defining a copy constructor but throwing an error, we satisfy the formal   requirements of containers, but at the same time disallow actual copies.   Finally, through the exception, one easily finds the places where code   has to be changed to avoid copies.  
* [0.x.63]*
   Move constructor.     Create a new triangulation by stealing the internal data of another   triangulation.  
* [0.x.64]*
   Move assignment operator.  
* [0.x.65]*
   Delete the object and all levels of the hierarchy.  
* [0.x.66]*
   Reset this triangulation into a virgin state by deleting all data.     Note that this operation is only allowed if no subscriptions to this   object exist any more, such as DoFHandler objects using it.  
* [0.x.67]*
   Return MPI communicator used by this triangulation. In the case of   a serial Triangulation object, MPI_COMM_SELF is returned.  
* [0.x.68]*
   Set the mesh smoothing to  [2.x.123]  This overrides the   MeshSmoothing given to the constructor. It is allowed to call this   function only if the triangulation is empty.  
* [0.x.69]*
   Return the mesh smoothing requirements that are obeyed.  
* [0.x.70]*
   Assign a manifold object to a certain part of the triangulation. If   an object with manifold number  [2.x.124]  is refined, this object is used   to find the location of new vertices (see the results section of  [2.x.125]    for a more in-depth discussion of this, with examples).  It is also used   for non-linear (i.e.: non-Q1) transformations of cells to the unit cell   in shape function calculations.     A copy of  [2.x.126]  is created using   Manifold<dim,  [2.x.127]  and stored internally.     It is possible to remove or replace a Manifold object during the   lifetime of a non-empty triangulation. Usually, this is done before the   first refinement and is dangerous afterwards. Removal of a manifold   object is done by reset_manifold(). This operation then replaces the   manifold object given before by a straight manifold approximation.    
*  [2.x.128]       [2.x.129]     [2.x.130]  "Glossary entry on manifold indicators"  
* [0.x.71]*
   Reset those parts of the triangulation with the given    [2.x.131]  to use a FlatManifold object. This is the   default state of a non-curved triangulation, and undoes   assignment of a different Manifold object by the function    [2.x.132]     
*  [2.x.133]       [2.x.134]     [2.x.135]  "Glossary entry on manifold indicators"  
* [0.x.72]*
   Reset all parts of the triangulation, regardless of their   manifold_id, to use a FlatManifold object. This undoes assignment   of all Manifold objects by the function    [2.x.136]     
*  [2.x.137]       [2.x.138]     [2.x.139]  "Glossary entry on manifold indicators"  
* [0.x.73]*
   Set the manifold_id of all cells and faces to the given argument.    
*  [2.x.140]       [2.x.141]     [2.x.142]  "Glossary entry on manifold indicators"  
* [0.x.74]*
   Set the manifold_id of all boundary faces to the given argument.    
*  [2.x.143]       [2.x.144]     [2.x.145]  "Glossary entry on manifold indicators"  
* [0.x.75]*
   Set the manifold_id of all boundary faces and edges with given   boundary_id  [2.x.146]  to the given manifold_id  [2.x.147]     
*  [2.x.148]       [2.x.149]     [2.x.150]  "Glossary entry on manifold indicators"  
* [0.x.76]*
   Return a constant reference to a Manifold object used for this   triangulation.  [2.x.151]  is the same as in set_manifold().    
*  [2.x.152]  If no manifold could be found, the default flat manifold is returned.    
*  [2.x.153]       [2.x.154]     [2.x.155]  "Glossary entry on manifold indicators"  
* [0.x.77]*
   Return a vector containing all boundary indicators assigned to boundary   faces of active cells of this Triangulation object. Note, that each   boundary indicator is reported only once. The size of the return vector   will represent the number of different indicators (which is greater or   equal one).    
*  [2.x.156]       [2.x.157]     [2.x.158]  "Glossary entry on boundary indicators"  
* [0.x.78]*
   Return a vector containing all manifold indicators assigned to the   objects of the active cells of this Triangulation. Note, that each   manifold indicator is reported only once. The size of the return vector   will represent the number of different indicators (which is greater or   equal one).    
*  [2.x.159]       [2.x.160]     [2.x.161]  "Glossary entry on manifold indicators"  
* [0.x.79]*
   Copy  [2.x.162]  to this triangulation. This operation is not cheap, so   you should be careful with using this. We do not implement this function   as a copy constructor, since it makes it easier to maintain collections   of triangulations if you can assign them values later on.     Keep in mind that this function also copies the pointer to the boundary   descriptor previously set by the  [2.x.163]  function. You must   therefore also guarantee that the Manifold objects describing the boundary   have a lifetime at least as long as the copied triangulation.     This triangulation must be empty beforehand.     The function is made  [2.x.164]  since some derived classes might want to   disable or extend the functionality of this function.    
*  [2.x.165]  Calling this function triggers the 'copy' signal on other_tria, i.e.   the triangulation being copied [1.x.29].  It also triggers the   'create' signal of the current triangulation. See the section on signals   in the general documentation for more information.    
*  [2.x.166]  The list of connections to signals is not copied from the old to   the new triangulation since these connections were established to monitor   how the old triangulation changes, not how any triangulation it may be   copied to changes.  
* [0.x.80]*
   Create a triangulation from a list of vertices and a list of cells, each   of the latter being a list of <tt>1<<dim</tt> vertex indices. The   triangulation must be empty upon calling this function and the cell list   should be useful (connected domain, etc.). The result of calling this   function is a    [2.x.167]  "coarse mesh".     Material data for the cells is given within the  [2.x.168]  array, while   boundary information is given in the  [2.x.169]  field.     The numbering of vertices within the  [2.x.170]  array is subject to some   constraints; see the general class documentation for this.     For conditions when this function can generate a valid triangulation, see   the documentation of this class, and the GridIn and GridReordering class.     If the  [2.x.171]  flag was specified upon   creation of this object, at the very end of its operation, the current   function walks over all cells and verifies that none of the cells is   deformed (see the entry on    [2.x.172]  "distorted cells"   in the glossary), where we call a cell deformed if the determinant of the   Jacobian of the mapping from reference cell to real cell is negative at   least at one of the vertices (this computation is done using the    [2.x.173]  function). If there are   deformed cells, this function throws an exception of kind   DistortedCellList. Since this happens after all data structures have been   set up, you can catch and ignore this exception if you know what you do
* 

* 
* 

* 
* 

* 
* 
*  -  for example, it may be that the determinant is zero (indicating that   you have collapsed edges in a cell) but that this is ok because you   didn't intend to integrate on this cell anyway. On the other hand,   deformed cells are often a sign of a mesh that is too coarse to resolve   the geometry of the domain, and in this case ignoring the exception is   probably unwise.    
*  [2.x.174]  This function is used in  [2.x.175]  and  [2.x.176] .    
*  [2.x.177]  This function triggers the "create" signal after doing its work. See   the section on signals in the general documentation of this class. For   example as a consequence of this, all DoFHandler objects connected to   this triangulation will be reinitialized via  [2.x.178]     
*  [2.x.179]  The check for distorted cells is only done if dim==spacedim, as   otherwise cells can legitimately be twisted if the manifold they describe   is twisted.  
* [0.x.81]*
   Create a triangulation from the provided    [2.x.180]     
*  [2.x.181]  Don't forget to attach the manifolds with set_manifold() before     calling this function if manifolds are needed.    
*  [2.x.182]  The namespace  [2.x.183]  contains functions     to create  [2.x.184]       [2.x.185]  construction_data The data needed for this process.  
* [0.x.82]*
   For backward compatibility, only. This function takes the cell data in   the ordering as requested by deal.II versions up to 5.2, converts it to   the new (lexicographic) ordering and calls create_triangulation().    
*  [2.x.186]  This function internally calls create_triangulation and therefore   can throw the same exception as the other function.  
* [0.x.83]*
   Revert or flip the direction_flags of a dim<spacedim triangulation, see    [2.x.187] .     This function throws an exception if dim equals spacedim.  
* [0.x.84]*
    [2.x.188]  Mesh refinement    [2.x.189]   
* [0.x.85]*
   Flag all active cells for refinement.  This will refine all cells of all   levels which are not already refined (i.e. only cells are refined which   do not yet have children). The cells are only flagged, not refined, thus   you have the chance to save the refinement flags.  
* [0.x.86]*
   Refine all cells  [2.x.190]  times. In other words, in each one of   the  [2.x.191]  iterations, loop over all cells and refine each cell   uniformly into  [2.x.192]  children. In practice, this   function repeats the following operations  [2.x.193]  times: call   set_all_refine_flags() followed by   execute_coarsening_and_refinement(). The end result is that the   number of cells increases by a factor of    [2.x.194] .     The execute_coarsening_and_refinement() function called in this   loop may throw an exception if it creates cells that are   distorted (see its documentation for an explanation). This   exception will be propagated through this function if that   happens, and you may not get the actual number of refinement   steps in that case.    
*  [2.x.195]  This function triggers the pre- and post-refinement signals before   and after doing each individual refinement cycle (i.e. more than once if   `times > 1`) . See the section on signals in the general documentation of   this class.  
* [0.x.87]*
   Coarsen all cells the given number of times.     In each of one of the  [2.x.196]  iterations, all cells will be marked for   coarsening. If an active cell is already on the coarsest level, it will   be ignored.    
*  [2.x.197]  This function triggers the pre- and post-refinement signals before   and after doing each individual coarsening cycle (i.e. more than once if   `times > 1`) . See the section on signals in the general documentation of   this class.  
* [0.x.88]*
   Execute both refinement and coarsening of the triangulation.     The function resets all refinement and coarsening flags to false. It uses   the user flags for internal purposes. They will therefore be overwritten   by undefined content.     To allow user programs to fix up these cells if that is desired, this   function after completing all other work may throw an exception of type   DistortedCellList that contains a list of those cells that have been   refined and have at least one child that is distorted. The function does   not create such an exception if no cells have created distorted children.   Note that for the check for distorted cells to happen, the    [2.x.198]  flag has to be specified upon   creation of a triangulation object.     See the general docs for more information.    
*  [2.x.199]  This function triggers the pre- and post-refinement signals before   and after doing its work. See the section on signals in the general   documentation of this class.    
*  [2.x.200]  If the boundary description is sufficiently irregular, it can   happen that some of the children produced by mesh refinement are   distorted (see the extensive discussion on    [2.x.201]  "distorted cells").    
*  [2.x.202]  This function is <tt>virtual</tt> to allow derived classes to   insert hooks, such as saving refinement flags and the like (see e.g. the   PersistentTriangulation class).  
* [0.x.89]*
   Do both preparation for refinement and coarsening as well as mesh   smoothing.     Regarding the refinement process it fixes the closure of the refinement   in <tt>dim>=2</tt> (make sure that no two cells are adjacent with a   refinement level differing with more than one), etc.  It performs some   mesh smoothing if the according flag was given to the constructor of this   class.  The function returns whether additional cells have been flagged   for refinement.     See the general doc of this class for more information on smoothing upon   refinement.     Regarding the coarsening part, flagging and deflagging cells in   preparation of the actual coarsening step are done. This includes   deleting coarsen flags from cells which may not be deleted (e.g. because   one neighbor is more refined than the cell), doing some smoothing, etc.     The effect is that only those cells are flagged for coarsening which will   actually be coarsened. This includes the fact that all flagged cells   belong to parent cells of which all children are flagged.     The function returns whether some cells' flagging has been changed in the   process.     This function uses the user flags, so store them if you still need them   afterwards.  
* [0.x.90]    [2.x.203]   
* [0.x.91]*
    [2.x.204]  Keeping up with what happens to a triangulation    [2.x.205]   
* [0.x.92]*
   Used to inform functions in derived classes how the cell with the given   cell_iterator is going to change. Note that this may me different than   the refine_flag() and coarsen_flag() in the cell_iterator in parallel   calculations because of refinement constraints that this machine does not   see.  
* [0.x.93]*
     The cell will not be refined or coarsened and might or might not move     to a different processor.    
* [0.x.94]*
     The cell will be or was refined.    
* [0.x.95]*
     The children of this cell will be or were coarsened into this cell.    
* [0.x.96]*
     Invalid status. Will not occur for the user.    
* [0.x.97]*
   A structure used to accumulate the results of the cell_weights slot   functions below. It takes an iterator range and returns the sum of   values.  
* [0.x.98]*
   A structure that has  [2.x.206]  objects for a number of actions that a   triangulation can do to itself. Please refer to the "Getting notice when   a triangulation changes" section in the general documentation of the   Triangulation class for more information and examples.     For documentation on signals, see   http://www.boost.org/doc/libs/release/libs/signals2 .  
* [0.x.99]*
     This signal is triggered whenever the      [2.x.207]  or      [2.x.208]  is called. This signal is also     triggered when loading a triangulation from an archive via      [2.x.209]     
* [0.x.100]*
     This signal is triggered at the beginning of execution of the      [2.x.210]  function (which is     itself called by other functions such as  [2.x.211]      ). At the time this signal is triggered, the triangulation is still     unchanged.    
* [0.x.101]*
     This signal is triggered at the end of execution of the      [2.x.212]  function when the     triangulation has reached its final state.    
* [0.x.102]*
     This signal is triggered at the beginning of execution of the      [2.x.213]  and      [2.x.214]  functions. At the time this     signal is triggered, the triangulation is still unchanged.    
* [0.x.103]*
     This signal is triggered when a function in deal.II moves the grid     points of a mesh, e.g.  [2.x.215]  Unfortunately,     modification of a vertex in user code through      [2.x.216]  cannot be detected by this     method.    
* [0.x.104]*
     This signal is triggered for each cell that is going to be coarsened.        
*  [2.x.217]  This signal is triggered with the immediate parent cell of a set     of active cells as argument. The children of this parent cell will     subsequently be coarsened away.    
* [0.x.105]*
     This signal is triggered for each cell that just has been refined.        
*  [2.x.218]  The signal parameter  [2.x.219]  corresponds to the immediate parent     cell of a set of newly created active cells.    
* [0.x.106]*
     This signal is triggered whenever the triangulation owning the signal     is copied by another triangulation using      [2.x.220]  (i.e. it is triggered on the     [1.x.30] triangulation, but the new one is passed as an argument).    
* [0.x.107]*
     This signal is triggered whenever the  [2.x.221]  function     is called and in the destructor of the triangulation. This signal is     also triggered when loading a triangulation from an archive via      [2.x.222]  as the previous content of the triangulation is     first destroyed.         The signal is triggered before the data structures of the     triangulation are destroyed. In other words, the functions     attached to this signal get a last look at the triangulation,     for example to save information stored as part of the     triangulation.    
* [0.x.108]*
     This is a catch-all signal that is triggered whenever the create,     post_refinement, or clear signals are triggered. In effect, it can be     used to indicate to an object connected to the signal that the     triangulation has been changed, whatever the exact cause of the change.        
*  [2.x.223]  The cell-level signals  [2.x.224]  and  [2.x.225]      post_refinement_on_cell are not connected to this signal.    
* [0.x.109]*
     This signal is triggered for each cell during every automatic or manual     repartitioning. This signal is somewhat special in that it is only     triggered for distributed parallel calculations and only if functions     are connected to it. It is intended to allow a weighted repartitioning     of the domain to balance the computational load across processes in a     different way than balancing the number of cells. Any connected     function is expected to take an iterator to a cell, and a CellStatus     argument that indicates whether this cell is going to be refined,     coarsened or left untouched (see the documentation of the CellStatus     enum for more information). The function is expected to return an     unsigned integer, which is interpreted as the additional computational     load of this cell. If this cell is going to be coarsened, the signal is     called for the parent cell and you need to provide the weight of the     future parent cell. If this cell is going to be refined the function     should return a weight, which will be equally assigned to every future     child cell of the current cell. As a reference a value of 1000 is added     for every cell to the total weight. This means a signal return value of     1000 (resulting in a weight of 2000) means that it is twice as     expensive for a process to handle this particular cell. If several     functions are connected to this signal, their return values will be     summed to calculate the final weight.         This function is used in  [2.x.226] .    
* [0.x.110]*
     This signal is triggered at the beginning of execution of the      [2.x.227]      function (which is     itself called by other functions such as  [2.x.228]      ). At the time this signal is triggered, the triangulation is still     unchanged. This signal     is different from the pre_refinement signal, because in the parallel     distributed case the pre_refinement signal is triggered multiple times     without a way to distinguish the last signal call.    
* [0.x.111]*
     This signal is triggered during execution of the      [2.x.229]      function. At the time this signal is triggered, the p4est oracle has been     refined and the cell relations have been updated. The triangulation is     unchanged otherwise, and the p4est oracle has not yet been repartitioned.    
* [0.x.112]*
     This signal is triggered at the end of execution of the      [2.x.230]      function when the triangulation has reached its final state. This signal     is different from the post_refinement signal, because in the parallel     distributed case the post_refinement signal is triggered multiple times     without a way to distinguish the last signal call.    
* [0.x.113]*
     This signal is triggered at the beginning of execution of the      [2.x.231]  function. At the time     this signal is triggered, the triangulation is still unchanged.        
*  [2.x.232]  The  [2.x.233]  function is     also called by  [2.x.234]  Thus, the     pre_distributed_repartition signal will be triggered after the     pre_distributed_load one.    
* [0.x.114]*
     This signal is triggered at the end of execution of the      [2.x.235]      function when the triangulation has reached its final state.    
* [0.x.115]*
     This signal is triggered at the beginning of execution of the      [2.x.236]      function. At the time this signal is triggered, the triangulation     is still unchanged.    
* [0.x.116]*
     This signal is triggered at the end of execution of the      [2.x.237]      function when the triangulation has reached its final state.    
* [0.x.117]*
     This signal is triggered at the beginning of execution of the      [2.x.238]      function. At the time this signal is triggered, the triangulation     is still unchanged.    
* [0.x.118]*
     This signal is triggered at the end of execution of the      [2.x.239]      function when the triangulation has reached its final state.    
* [0.x.119]*
   Signals for the various actions that a triangulation can do to itself.  
* [0.x.120]    [2.x.240]   
* [0.x.121]*
    [2.x.241]  History of a triangulation    [2.x.242]   
* [0.x.122]*
   Save the addresses of the cells which are flagged for refinement to  [2.x.243]    out.  For usage, read the general documentation for this class.  
* [0.x.123]*
   Same as above, but store the flags to a bitvector rather than to a file.  
* [0.x.124]*
   Read the information stored by  [2.x.244]   
* [0.x.125]*
   Read the information stored by  [2.x.245]   
* [0.x.126]*
   Analogue to  [2.x.246]   
* [0.x.127]*
   Same as above, but store the flags to a bitvector rather than to a file.  
* [0.x.128]*
   Analogue to  [2.x.247]   
* [0.x.129]*
   Analogue to  [2.x.248]   
* [0.x.130]*
   Return whether this triangulation has ever undergone anisotropic (as   opposed to only isotropic) refinement.  
* [0.x.131]    [2.x.249]   
* [0.x.132]*
    [2.x.250]  User data    [2.x.251]   
* [0.x.133]*
   Clear all user flags.  See also    [2.x.252] .  
* [0.x.134]*
   Save all user flags. See the general documentation for this class and the   documentation for the  [2.x.253]  for more details.  See also    [2.x.254] .  
* [0.x.135]*
   Same as above, but store the flags to a bitvector rather than to a file.   The output vector is resized if necessary.  See also    [2.x.255] .  
* [0.x.136]*
   Read the information stored by  [2.x.256]   See also    [2.x.257] .  
* [0.x.137]*
   Read the information stored by  [2.x.258]   See also    [2.x.259] .  
* [0.x.138]*
   Clear all user flags on lines.  See also    [2.x.260] .  
* [0.x.139]*
   Save the user flags on lines.  See also    [2.x.261] .  
* [0.x.140]*
   Same as above, but store the flags to a bitvector rather than to a file.   The output vector is resized if necessary.  See also    [2.x.262] .  
* [0.x.141]*
   Load the user flags located on lines.  See also    [2.x.263] .  
* [0.x.142]*
   Load the user flags located on lines.  See also    [2.x.264] .  
* [0.x.143]*
   Clear all user flags on quads.  See also    [2.x.265] .  
* [0.x.144]*
   Save the user flags on quads.  See also    [2.x.266] .  
* [0.x.145]*
   Same as above, but store the flags to a bitvector rather than to a file.   The output vector is resized if necessary.  See also    [2.x.267] .  
* [0.x.146]*
   Load the user flags located on quads.  See also    [2.x.268] .  
* [0.x.147]*
   Load the user flags located on quads.  See also    [2.x.269] .  
* [0.x.148]*
   Clear all user flags on quads.  See also    [2.x.270] .  
* [0.x.149]*
   Save the user flags on hexs.  See also    [2.x.271] .  
* [0.x.150]*
   Same as above, but store the flags to a bitvector rather than to a file.   The output vector is resized if necessary.  See also    [2.x.272] .  
* [0.x.151]*
   Load the user flags located on hexs.  See also    [2.x.273] .  
* [0.x.152]*
   Load the user flags located on hexs.  See also    [2.x.274] .  
* [0.x.153]*
   Clear all user pointers and indices and allow the use of both for next   access.  See also    [2.x.275] .  
* [0.x.154]*
   Save all user indices. The output vector is resized if necessary. See   also    [2.x.276] .  
* [0.x.155]*
   Read the information stored by save_user_indices().  See also    [2.x.277] .  
* [0.x.156]*
   Save all user pointers. The output vector is resized if necessary.  See   also    [2.x.278] .  
* [0.x.157]*
   Read the information stored by save_user_pointers().  See also    [2.x.279] .  
* [0.x.158]*
   Save the user indices on lines. The output vector is resized if   necessary.  See also    [2.x.280] .  
* [0.x.159]*
   Load the user indices located on lines.  See also    [2.x.281] .  
* [0.x.160]*
   Save the user indices on quads. The output vector is resized if   necessary.  See also    [2.x.282] .  
* [0.x.161]*
   Load the user indices located on quads.  See also    [2.x.283] .  
* [0.x.162]*
   Save the user indices on hexes. The output vector is resized if   necessary.  See also    [2.x.284] .  
* [0.x.163]*
   Load the user indices located on hexs.  See also    [2.x.285] .  
* [0.x.164]*
   Save the user indices on lines. The output vector is resized if   necessary.  See also    [2.x.286] .  
* [0.x.165]*
   Load the user pointers located on lines.  See also    [2.x.287] .  
* [0.x.166]*
   Save the user pointers on quads. The output vector is resized if   necessary.  See also    [2.x.288] .  
* [0.x.167]*
   Load the user pointers located on quads.  See also    [2.x.289] .  
* [0.x.168]*
   Save the user pointers on hexes. The output vector is resized if   necessary.  See also    [2.x.290] .  
* [0.x.169]*
   Load the user pointers located on hexs.  See also    [2.x.291] .  
* [0.x.170]    [2.x.292]   
* [0.x.171]*
    [2.x.293]  Cell iterator functions    [2.x.294]   
* [0.x.172]*
   Iterator to the first used cell on level  [2.x.295]     
*  [2.x.296]  The given  [2.x.297]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.298]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.31] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.299]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.300]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.173]*
   Iterator to the first active cell on level  [2.x.301]  If the given level   does not contain any active cells (i.e., all cells on this level are   further refined, then this function returns    [2.x.302]  so that loops of the kind  
* [1.x.32]
*    have zero iterations, as may be expected if there are no active cells on   this level.    
*  [2.x.303]  The given  [2.x.304]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.305]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.33] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.306]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.307]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.174]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states.  
* [0.x.175]*
   Return an iterator which is the first iterator not on level. If  [2.x.308]    is the last level, then this returns <tt>end()</tt>.    
*  [2.x.309]  The given  [2.x.310]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.311]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.34] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.312]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.313]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.176]*
   Return an active iterator which is the first active iterator not on the   given level. If  [2.x.314]  is the last level, then this returns   <tt>end()</tt>.    
*  [2.x.315]  The given  [2.x.316]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.317]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.35] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.318]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.319]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.177]*
   Return an iterator pointing to the last used cell.  
* [0.x.178]*
   Return an iterator pointing to the last active cell.  
* [0.x.179]*
   Return an iterator to a cell of this Triangulation object constructed from   an independent CellId object.     If the given argument corresponds to a valid cell in this triangulation,   this operation will always succeed for sequential triangulations where the   current processor stores all cells that are part of the triangulation. On   the other hand, if this is a parallel triangulation, then the current   processor may not actually know about this cell. In this case, this   operation will succeed for locally relevant cells, but may not for   artificial cells that are less refined on the current processor.  
* [0.x.180]*
    [2.x.320]  Cell iterator functions returning ranges of iterators  
* [0.x.181]*
   Return an iterator range that contains all cells (active or not) that   make up this triangulation. Such a range is useful to initialize range-   based for loops as supported by C++11. See the example in the   documentation of active_cell_iterators().      [2.x.321]  The half open range  [2.x.322]     
*  [2.x.323]   
* [0.x.182]*
   Return an iterator range that contains all active cells that make up this   triangulation. Such a range is useful to initialize range-based for loops   as supported by C++11, see also    [2.x.324]  "C++11 standard".     Range-based for loops are useful in that they require much less code than   traditional loops (see [1.x.36] for a discussion of how they work). An   example is that without range-based for loops, one often writes code such   as the following (assuming for a moment that our goal is setting the user   flag on every active cell):  
* [1.x.37]
*    Using C++11's range-based for loops, this is now entirely equivalent to   the following:  
* [1.x.38]
*       [2.x.325]  The half open range <code>[this->begin_active(),   this->end())</code>    
*  [2.x.326]   
* [0.x.183]*
   Return an iterator range that contains all cells (active or not) that   make up the given level of this triangulation. Such a range is useful to   initialize range-based for loops as supported by C++11. See the example   in the documentation of active_cell_iterators().      [2.x.327]  level A given level in the refinement hierarchy of this   triangulation.    [2.x.328]  The half open range <code>[this->begin(level),   this->end(level))</code>      [2.x.329]  level must be less than this->n_levels().    
*  [2.x.330]   
* [0.x.184]*
   Return an iterator range that contains all active cells that make up the   given level of this triangulation. Such a range is useful to initialize   range-based for loops as supported by C++11. See the example in the   documentation of active_cell_iterators().      [2.x.331]  level A given level in the refinement hierarchy of this   triangulation.    [2.x.332]  The half open range <code>[this->begin_active(level),   this->end(level))</code>      [2.x.333]  level must be less than this->n_levels().    
*  [2.x.334]   
* [0.x.185]    [2.x.335]   
* [0.x.186]*
    [2.x.336]  Face iterator functions    [2.x.337]   
* [0.x.187]*
   Iterator to the first used face.  
* [0.x.188]*
   Iterator to the first active face.  
* [0.x.189]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states.  
* [0.x.190]*
   Return an iterator range that contains all active faces that make up this   triangulation. This function is the face version of    [2.x.338]  and allows one to write code   like, e.g.,    
* [1.x.39]
*       [2.x.339]  The half open range <code>[this->begin_active_face(),   this->end_face())</code>    
*  [2.x.340]   
* [0.x.191]    [2.x.341]   
* [0.x.192]*
    [2.x.342]  Vertex iterator functions    [2.x.343]   
* [0.x.193]*
   Iterator to the first used vertex. This function can only be used if dim   is not one.  
* [0.x.194]*
   Iterator to the first active vertex. Because all vertices are active,   begin_vertex() and begin_active_vertex() return the same vertex. This   function can only be used if dim is not one.  
* [0.x.195]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states. This function can only   be used if dim is not one.  
* [0.x.196]    [2.x.344]   
* [0.x.197]*
    [2.x.345]  Information about the triangulation    [2.x.346]   
* [0.x.198]*
   In the following, most functions are provided in two versions, with and   without an argument describing the level. The versions with this argument   are only applicable for objects describing the cells of the present   triangulation. For example: in 2D <tt>n_lines(level)</tt> cannot be   called, only <tt>n_lines()</tt>, as lines are faces in 2D and therefore   have no level.  
* [0.x.199]*
   Return the total number of used lines, active or not.  
* [0.x.200]*
   Return the total number of used lines, active or not on level  [2.x.347]   
* [0.x.201]*
   Return the total number of active lines.  
* [0.x.202]*
   Return the total number of active lines, on level  [2.x.348]   
* [0.x.203]*
   Return the total number of used quads, active or not.  
* [0.x.204]*
   Return the total number of used quads, active or not on level  [2.x.349]   
* [0.x.205]*
   Return the total number of active quads, active or not.  
* [0.x.206]*
   Return the total number of active quads, active or not on level  [2.x.350]   
* [0.x.207]*
   Return the total number of used hexahedra, active or not.  
* [0.x.208]*
   Return the total number of used hexahedra, active or not on level  [2.x.351]    level.  
* [0.x.209]*
   Return the total number of active hexahedra, active or not.  
* [0.x.210]*
   Return the total number of active hexahedra, active or not on level  [2.x.352]    level.  
* [0.x.211]*
   Return the total number of used cells, active or not.  Maps to   <tt>n_lines()</tt> in one space dimension and so on.  
* [0.x.212]*
   Return the total number of used cells, active or not, on level  [2.x.353]    Maps to <tt>n_lines(level)</tt> in one space dimension and so on.  
* [0.x.213]*
   Return the total number of active cells. Maps to   <tt>n_active_lines()</tt> in one space dimension and so on.  
* [0.x.214]*
   Return the total number of active cells. For the current class, this is   the same as n_active_cells(). However, the function may be overloaded in   derived classes (e.g., in  [2.x.354]  where it   may return a value greater than the number of active cells reported by   the triangulation object on the current processor.  
* [0.x.215]*
   Return the total number of active cells on level  [2.x.355]   Maps to   <tt>n_active_lines(level)</tt> in one space dimension and so on.  
* [0.x.216]*
   Return the total number of used faces, active or not.  In 2D, the result   equals n_lines(), in 3D it equals n_quads(), while in 1D it equals   the number of used vertices.  
* [0.x.217]*
   Return the total number of active faces.  In 2D, the result equals   n_active_lines(), in 3D it equals n_active_quads(), while in 1D it equals   the number of used vertices.  
* [0.x.218]*
   Return the number of levels in this triangulation.    
*  [2.x.356]  Internally, triangulations store data in levels, and there may be   more levels in this data structure than one may think
* 
*  -  for example,   imagine a triangulation that we just got by coarsening the highest level   so that it was completely depopulated. That level is not removed, since   it will most likely be repopulated soon by the next refinement process.   As a consequence, if you happened to run through raw cell iterators   (which you can't do as a user of this class, but can internally), then   the number of objects in the levels hierarchy is larger than the level of   the most refined cell plus one. On the other hand, since this is rarely   what a user of this class cares about, the function really just returns   the level of the most refined active cell plus one. (The plus one is   because in a coarse, unrefined mesh, all cells have level zero
* 
*  -  making   the number of levels equal to one.)  
* [0.x.219]*
   Return the number of levels in use. This function is equivalent to   n_levels() for a serial Triangulation, but gives the maximum of   n_levels() over all processors for a  [2.x.357]    and therefore can be larger than n_levels().  
* [0.x.220]*
   Return true if the triangulation has hanging nodes.     The function is made virtual since the result can be interpreted in   different ways, depending on whether the triangulation lives only on a   single processor, or may be distributed as done in the    [2.x.358]  class (see there for a description   of what the function is supposed to do in the parallel context).  
* [0.x.221]*
   Return the total number of vertices.  Some of them may not be used, which   usually happens upon coarsening of a triangulation when some vertices are   discarded, but we do not want to renumber the remaining ones, leading to   holes in the numbers of used vertices.  You can get the number of used   vertices using  [2.x.359]  function.  
* [0.x.222]*
   Return a constant reference to all the vertices present in this   triangulation. Note that not necessarily all vertices in this array are   actually used; for example, if you coarsen a mesh, then some vertices are   deleted, but their positions in this array are unchanged as the indices   of vertices are only allocated once. You can find out about which   vertices are actually used by the function get_used_vertices().  
* [0.x.223]*
   Return the number of vertices that are presently in use, i.e. belong to   at least one used element.  
* [0.x.224]*
   Return  [2.x.360]  if the vertex with this  [2.x.361]  is used.  
* [0.x.225]*
   Return a constant reference to the array of  [2.x.362]  indicating whether   an entry in the vertex array is used or not.  
* [0.x.226]*
   Return the maximum number of cells meeting at a common vertex. Since this   number is an invariant under refinement, only the cells on the coarsest   level are considered. The operation is thus reasonably fast. The   invariance is only true for sufficiently many cells in the coarsest   triangulation (e.g. for a single cell one would be returned), so a   minimum of four is returned in two dimensions, 8 in three dimensions,   etc, which is how many cells meet if the triangulation is refined.     In one space dimension, two is returned.  
* [0.x.227]*
   This function always returns  [2.x.363]  but is there for   compatibility with the derived  [2.x.364]    class. For distributed parallel triangulations this function returns the   subdomain id of those cells that are owned by the current processor.  
* [0.x.228]*
   Return a reference to the current object.     This doesn't seem to be very useful but allows to write code that can   access the underlying triangulation for anything that satisfies the    [2.x.365]  "MeshType concept"   (which may not only be a triangulation, but also a DoFHandler, for   example).  
* [0.x.229]*
   Return a reference to the current object. This is the const-version of   the previous function.  
* [0.x.230]    [2.x.366]   
* [0.x.231]*
    [2.x.367]  Internal information about the number of objects    [2.x.368]   
* [0.x.232]*
   Total number of lines, used or unused.    
*  [2.x.369]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.233]*
   Number of lines, used or unused, on the given level.    
*  [2.x.370]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.234]*
   Total number of quads, used or unused.    
*  [2.x.371]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.235]*
   Number of quads, used or unused, on the given level.    
*  [2.x.372]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.236]*
   Number of hexs, used or unused, on the given level.    
*  [2.x.373]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.237]*
   Number of cells, used or unused, on the given level.    
*  [2.x.374]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.238]*
   Return the total number of faces, used or not. In 2d, the result equals   n_raw_lines(), in 3d it equals n_raw_quads(), while in 1D it equals   the number of vertices.    
*  [2.x.375]  This function really exports internal information about the   triangulation. It shouldn't be used in applications. The function is only   part of the public interface of this class because it is used in some of   the other classes that build very closely on it (in particular, the   DoFHandler class).  
* [0.x.239]    [2.x.376]   
* [0.x.240]*
   Determine an estimate for the memory consumption (in bytes) of this   object.     This function is made virtual, since a triangulation object might be   accessed through a pointer to this base class, even if the actual object   is a derived class.  
* [0.x.241]*
   Write the data of this object to a stream for the purpose of   serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).    
*  [2.x.377]  This function does not save [1.x.40] member variables of the   current triangulation. Rather, only certain kinds of information are   stored. For more information see the general documentation of this class.  
* [0.x.242]*
   Read the data of this object from a stream for the purpose of   serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).   Throw away the previous content.    
*  [2.x.378]  This function does not reset [1.x.41] member variables of the   current triangulation to the ones of the triangulation that was   previously stored to an archive. Rather, only certain kinds of   information are loaded. For more information see the general   documentation of this class.    
*  [2.x.379]  This function calls the  [2.x.380]  function and   consequently triggers the "clear" signal. After loading all data from the   archive, it then triggers the "create" signal. For more information on   signals, see the general documentation of this class.  
* [0.x.243]*
   Declare the (coarse) face pairs given in the argument of this function as   periodic. This way it is possible to obtain neighbors across periodic   boundaries.     The vector can be filled by the function    [2.x.381]      For more information on periodic boundary conditions see    [2.x.382]   [2.x.383]    and  [2.x.384] .    
*  [2.x.385]  Before this function can be used the Triangulation has to be   initialized and must not be refined.  
* [0.x.244]*
   Return the periodic_face_map.  
* [0.x.245]*
   Return vector filled with the used reference-cell types of this   triangulation.  
* [0.x.246]*
   Indicate if the triangulation only consists of hypercube-like cells, i.e.,   lines, quadrilaterals, or hexahedra.  
* [0.x.247]*
   Write and read the data of this object from a stream for the purpose   of serialization. using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.248]*
    [2.x.386]  Exceptions    [2.x.387]   
* [0.x.249]*
   Exception    
*  [2.x.388]   
* [0.x.250]*
   The function raising this exception can only operate on an empty   Triangulation, i.e., a Triangulation without grid cells.    
*  [2.x.389]   
* [0.x.251]*
   Trying to re-read a grid, an error occurred.    
*  [2.x.390]   
* [0.x.252]*
   Exception  
*  [2.x.391]   
* [0.x.253]*
   The triangulation level you accessed is empty.    
*  [2.x.392]   
* [0.x.254]*
   Exception    
*  [2.x.393]   
* [0.x.255]*
   Exception     Requested boundary_id not found    
*  [2.x.394]   
* [0.x.256]*
   Exception    
*  [2.x.395]   
* [0.x.257]    [2.x.396]   
* [0.x.258]*
   Do some smoothing in the process of refining the triangulation. See the   general doc of this class for more information about this.  
* [0.x.259]*
   Vector caching all reference-cell types of the given triangulation   (also in the distributed case).  
* [0.x.260]*
   Write a bool vector to the given stream, writing a pre- and a postfix   magic number. The vector is written in an almost binary format, i.e. the   bool flags are packed but the data is written as ASCII text.     The flags are stored in a binary format: for each  [2.x.397]  a  [2.x.398]  bit is   stored, a  [2.x.399]  bit otherwise.  The bits are stored as <tt>unsigned   char</tt>, thus avoiding endianness. They are written to  [2.x.400]  in plain   text, thus amounting to 3.6 bits in the output per bits in the input on   the average. Other information (magic numbers and number of elements of   the input vector) is stored as plain text as well. The format should   therefore be interplatform compatible.  
* [0.x.261]*
   Re-read a vector of bools previously written by  [2.x.401]  and   compare with the magic numbers.  
* [0.x.262]*
   Recreate information about periodic neighbors from   periodic_face_pairs_level_0.  
* [0.x.263]*
   Update the internal reference_cells vector.  
* [0.x.264]*
   Policy with the Triangulation-specific tasks related to creation,   refinement, and coarsening.  
* [0.x.265]*
   If add_periodicity() is called, this variable stores the given periodic   face pairs on level 0 for later access during the identification of ghost   cells for the multigrid hierarchy and for setting up the   periodic_face_map.  
* [0.x.266]*
   If add_periodicity() is called, this variable stores the active periodic   face pairs.  
* [0.x.267]*
    [2.x.402]  Cell iterator functions for internal use    [2.x.403]   
* [0.x.268]*
   Declare a number of iterator types for raw iterators, i.e., iterators   that also iterate over holes in the list of cells left by cells that have   been coarsened away in previous mesh refinement cycles.     Since users should never have to access these internal properties of how   we store data, these iterator types are made private.  
* [0.x.269]*
   Iterator to the first cell, used or not, on level  [2.x.404]  If a level   has no cells, a past-the-end iterator is returned.  
* [0.x.270]*
   Return a raw iterator which is the first iterator not on level. If  [2.x.405]    level is the last level, then this returns <tt>end()</tt>.  
* [0.x.271]    [2.x.406]   
* [0.x.272]*
    [2.x.407]  Line iterator functions for internal use    [2.x.408]   
* [0.x.273]*
   Iterator to the first line, used or not, on level  [2.x.409]  If a level   has no lines, a past-the-end iterator is returned.  If lines are no   cells, i.e. for  [2.x.410]  no  [2.x.411]  argument must be given.  The same   applies for all the other functions above, of course.  
* [0.x.274]*
   Iterator to the first used line on level  [2.x.412]     
*  [2.x.413]  The given  [2.x.414]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.415]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.42] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.416]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.417]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.275]*
   Iterator to the first active line on level  [2.x.418]     
*  [2.x.419]  The given  [2.x.420]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.421]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.43] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.422]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.423]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.276]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states.  
* [0.x.277]    [2.x.424]   
* [0.x.278]*
    [2.x.425]  Quad iterator functions for internal use    [2.x.426]   
* [0.x.279]*
   Iterator to the first quad, used or not, on the given level. If a level   has no quads, a past-the-end iterator is returned.  If quads are no   cells, i.e. for  [2.x.427]  no level argument must be given.    
*  [2.x.428]  The given  [2.x.429]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.430]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.44] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.431]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.432]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.280]*
   Iterator to the first used quad on level  [2.x.433]     
*  [2.x.434]  The given  [2.x.435]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.436]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.45] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.437]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.438]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.281]*
   Iterator to the first active quad on level  [2.x.439]     
*  [2.x.440]  The given  [2.x.441]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.442]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.46] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.443]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.444]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.282]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states.  
* [0.x.283]    [2.x.445]   
* [0.x.284]*
    [2.x.446]  Hex iterator functions for internal use    [2.x.447]   
* [0.x.285]*
   Iterator to the first hex, used or not, on level  [2.x.448]  If a level has   no hexes, a past-the-end iterator is returned.    
*  [2.x.449]  The given  [2.x.450]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.451]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.47] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.452]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.453]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.286]*
   Iterator to the first used hex on level  [2.x.454]     
*  [2.x.455]  The given  [2.x.456]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.457]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.48] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.458]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.459]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.287]*
   Iterator to the first active hex on level  [2.x.460]     
*  [2.x.461]  The given  [2.x.462]  argument needs to correspond to a level of the     triangulation, i.e., should be less than the value returned by     n_levels(). On the other hand, for parallel computations using     a  [2.x.463]  object, it is often convenient     to write loops over the cells of all levels of the global mesh, even     if the [1.x.49] portion of the triangulation does not actually     have cells at one of the higher levels. In those cases, the      [2.x.464]  argument is accepted if it is less than what the     n_global_levels() function returns. If the given  [2.x.465]  is     between the values returned by n_levels() and n_global_levels(),     then no cells exist in the local portion of the triangulation     at this level, and the function simply returns what end() would     return.  
* [0.x.288]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states.  
* [0.x.289]    [2.x.466]   
* [0.x.290]*
   The (public) function clear() will only work when the triangulation is   not subscribed to by other users. The clear_despite_subscriptions()   function now allows the triangulation being cleared even when there are   subscriptions.     Make sure, you know what you do, when calling this function, as its use   is reasonable in very rare cases, only. For example, when the   subscriptions were for the initially empty Triangulation and the   Triangulation object wants to release its memory before throwing an   assertion due to input errors (e.g. in the create_triangulation()   function).  
* [0.x.291]*
   Reset triangulation policy.  
* [0.x.292]*
   For all cells, set the active cell indices so that active cells know the   how many-th active cell they are, and all other cells have an invalid   value. This function is called after mesh creation, refinement, and   serialization.  
* [0.x.293]*
   Reset global cell ids and globale level cell ids.  
* [0.x.294]*
   Reset cache for the cells' vertex indices.  
* [0.x.295]*
   Refine all cells on all levels which were previously flagged for   refinement.     Note, that this function uses the <tt>line->user_flags</tt> for   <tt>dim=2,3</tt> and the <tt>quad->user_flags</tt> for <tt>dim=3</tt>.     The function returns a list of cells that have produced children that   satisfy the criteria of    [2.x.467]  "distorted cells"   if the  [2.x.468]  flag was specified upon   creation of this object, at  
* [0.x.296]*
   Coarsen all cells which were flagged for coarsening, or rather: delete   all children of those cells of which all child cells are flagged for   coarsening and several other constraints hold (see the general doc of   this class).  
* [0.x.297]*
   Make sure that either all or none of the children of a cell are tagged   for coarsening.  
* [0.x.298]*
   Translate the unique id of a coarse cell to its index. See the glossary   entry on    [2.x.469]  "coarse cell IDs"   for more information.    
*  [2.x.470]  For serial and shared triangulation both id and index are the same.         For distributed triangulations setting both might differ, since the         id might correspond to a global id and the index to a local id.      [2.x.471]  coarse_cell_id Unique id of the coarse cell.    [2.x.472]  Index of the coarse cell within the current triangulation.  
* [0.x.299]*
   Translate the index of coarse cell to its unique id. See the glossary   entry on    [2.x.473]  "coarse cell IDs"   for more information.    
*  [2.x.474]  See the note of the method   coarse_cell_id_to_coarse_cell_index().      [2.x.475]  coarse_cell_index Index of the coarse cell.    [2.x.476]  Id of the coarse cell.  
* [0.x.300]*
   Array of pointers pointing to the objects storing the cell data on the   different levels.  
* [0.x.301]*
   Pointer to the faces of the triangulation. In 1d this contains nothing,   in 2D it contains data concerning lines and in 3D quads and lines.  All   of these have no level and are therefore treated separately.  
* [0.x.302]*
   Array of the vertices of this triangulation.  
* [0.x.303]*
   Array storing a bit-pattern which vertices are used.  
* [0.x.304]*
   Collection of manifold objects. We store only objects, which are not of   type FlatManifold.  
* [0.x.305]*
   Flag indicating whether anisotropic refinement took place.  
* [0.x.306]*
   A flag that determines whether we are to check for distorted cells upon   creation and refinement of a mesh.  
* [0.x.307]*
   Cache to hold the numbers of lines, quads, hexes, etc. These numbers are   set at the end of the refinement and coarsening functions and enable   faster access later on. In the old days, whenever one wanted to access   one of these numbers, one had to perform a loop over all lines, e.g., and   count the elements until we hit the end iterator. This is time consuming   and since access to the number of lines etc is a rather frequent   operation, this was not an optimal solution.  
* [0.x.308]*
   A map that relates the number of a boundary vertex to the boundary   indicator. This field is only used in 1d. We have this field because we   store boundary indicator information with faces in 2d and higher where we   have space in the structures that store data for faces, but in 1d there   is no such space for faces.     The field is declared as a pointer for a rather mundane reason: all other   fields of this class that can be modified by the TriaAccessor hierarchy   are pointers, and so these accessor classes store a const pointer to the   triangulation. We could no longer do so for TriaAccessor<0,1,spacedim> if   this field (that can be modified by  [2.x.477]  were   not a pointer.  
* [0.x.309]*
   A map that relates the number of a boundary vertex to the manifold   indicator. This field is only used in 1d. We have this field because we   store manifold indicator information with faces in 2d and higher where we   have space in the structures that store data for faces, but in 1d there   is no such space for faces.    
*  [2.x.478]  Manifold objects are pretty useless for points since they are   neither refined nor are their interiors mapped. We nevertheless allow   storing manifold ids for points to be consistent in dimension-independent   programs.     The field is declared as a pointer for a rather mundane reason: all other   fields of this class that can be modified by the TriaAccessor hierarchy   are pointers, and so these accessor classes store a const pointer to the   triangulation. We could no longer do so for TriaAccessor<0,1,spacedim> if   this field (that can be modified by  [2.x.479]  were   not a pointer.  
* [0.x.310]

include/deal.II-translator/grid/tria_accessor.templates_0.txt
[0.x.0]*
     Compute the diameter for a given set of vertices. The vertices are     interpreted, depending on their count, as the vertices of a particular     reference cell.    
* [0.x.1]*
     A class with the same purpose as the similarly named class of the     Triangulation class. See there for more information.    
* [0.x.2]*
       Implementation of the function of some name in the mother class.      
* [0.x.3]*
       Implementation of the function of some name in the mother class.      
* [0.x.4]*
       Implementation of the function of some name in the mother class      
* [0.x.5]         Default implementation used in 1d                 In 1d, face_orientation is always true        
* [0.x.6]*
       Implementation of the function of some name in the mother class.      
* [0.x.7]         Default implementation used in 1d and 2d                 In 1d, face_flip is always false as there is no such concept as         "flipped" faces in 1d.                 In 2d, we currently only support meshes where all faces are in         standard orientation, so the result is also false. This also         matches the fact that one canalways* orient faces in 2d in such a         way that the don't need to be flipped        
* [0.x.8]*
       Implementation of the function of some name in the mother class.      
* [0.x.9]         Default implementation used in 1d and 2d                 In 1d and 2d, face_rotation is always false as there is no such         concept as "rotated" faces in 1d and 2d.        
* [0.x.10]*
       Implementation of the function of some name in the mother class.      
* [0.x.11]*
       Implementation of the function of some name in the mother class.      
* [0.x.12]*
       Implementation of the function of some name in the mother class.      
* [0.x.13]*
       Implementation of the function of some name in the mother class.      
* [0.x.14]*
       Implementation of the function of some name in the mother class.      
* [0.x.15]*
       Implementation of the function of same name in the enclosing class.      
* [0.x.16]

include/deal.II-translator/grid/tria_accessor_0.txt
[0.x.0]*
     Implementation of a type with which to store the level of an accessor     object. We only need it for the case that <tt>structdim == dim</tt>.     Otherwise, an empty object is sufficient.    
* [0.x.1]*
         Default constructor.        
* [0.x.2]*
         Dummy constructor. Only level zero is allowed.        
* [0.x.3]*
         Dummy conversion operator. Returns level zero.        
* [0.x.4]*
     Implementation of a type with which to store the level of an accessor     object. We only need it for the case that <tt>structdim == dim</tt>.     Otherwise, an empty object is sufficient.    
* [0.x.5]*
 A namespace that contains exception classes used by the accessor classes.

* 
* [0.x.6]*
  
*  [2.x.0]   
* [0.x.7]*
   The cell is not an    [2.x.1]  "active"   cell, but it already has children. Some operations, like setting   refinement flags or accessing degrees of freedom are only possible on   active cells.    
*  [2.x.2]   
* [0.x.8]*
   Trying to access the children of a cell which is in fact active.    
*  [2.x.3]   
* [0.x.9]*
   Trying to access the parent of a cell which is in the coarsest level of   the triangulation.    
*  [2.x.4]   
* [0.x.10]*
  
*  [2.x.5]   
* [0.x.11]*
  
*  [2.x.6]   
* [0.x.12]*
  
*  [2.x.7]   
* [0.x.13]*
  
*  [2.x.8]   
* [0.x.14]*
  
*  [2.x.9]   
* [0.x.15]*
   You are trying to access the level of a face, but faces have no inherent   level. The level of a face can only be determined by the level of an   adjacent face, which in turn implies that a face can have several levels.    
*  [2.x.10]   
* [0.x.16]*
   You are trying to get the periodic neighbor for a face, which does not   have a periodic neighbor. For more information on this, refer to    [2.x.11]  "entry for periodic boundaries".  
*  [2.x.12]   
* [0.x.17]*
  
*  [2.x.13]   
* [0.x.18]*
 A base class for the accessor classes used by TriaRawIterator and derived classes.
*  This class offers only the basic functionality required by the iterators (stores the necessary data members, offers comparison operators and the like), but has no functionality to actually dereference data. This is done in the derived classes.
*  In the implementation, the behavior of this class differs between the cases where <tt>structdim==dim</tt> (cells of a mesh) and <tt>structdim&lt;dim</tt> (faces and edges). For the latter, #present_level is always equal to zero and the constructors may not receive a positive value there. For cells, any level is possible, but only those within the range of the levels of the Triangulation are reasonable. Furthermore, the function objects() returns either the container with all cells on the same level or the container with all objects of this dimension (<tt>structdim&lt;dim</tt>).
*  Some internals of this class are discussed in  [2.x.14] .
* 

* 
*  [2.x.15] 

* 
*  [2.x.16] 

* 
* [0.x.19]*
   Dimension of the space the object represented by this accessor lives in.   For example, if this accessor represents a quad that is part of a two-   dimensional surface in four-dimensional space, then this value is four.  
* [0.x.20]*
   Dimensionality of the object that the thing represented by this accessor   is part of. For example, if this accessor represents a line that is part   of a hexahedron, then this value will be three.  
* [0.x.21]*
   Dimensionality of the current object represented by this accessor. For   example, if it is line (irrespective of whether it is part of a quad or   hex, and what dimension we are in), then this value equals 1.  
* [0.x.22]*
   Copy operator. These operators are usually used in a context like   <tt>iterator a,b;a=*b;</tt>. Presumably, the intent here is to copy the   object pointed to   by  [2.x.17]  to the object pointed to by  [2.x.18]  However, the result of   dereferencing an iterator is not an object but an accessor; consequently,   this operation is not useful for iterators on triangulations.   Consequently, this operator is declared as deleted and can not be used.  
* [0.x.23]*
   Declare the data type that this accessor class expects to get passed from   the iterator classes. Since the pure triangulation iterators need no   additional data, this data type is  [2.x.19]   
* [0.x.24]*
   Constructor. Protected, thus only callable from friend classes.  
* [0.x.25]*
   Copy constructor. Creates an object with exactly the same data.  
* [0.x.26]*
   Copy operator. Since this is only called from iterators, do not return   anything, since the iterator will return itself.     This method is protected, since it is only to be called from the iterator   class.  
* [0.x.27]*
   Copy operator. Creates an object with exactly the same data.  
* [0.x.28]*
   Comparison operator for accessors. This operator is used when comparing   iterators into objects of a triangulation, for example when putting   them into a  [2.x.20]      If #structure_dimension is less than #dimension, we simply compare the   index of such an object because faces and edges do not have levels. If   #structure_dimension equals #dimension, we compare the level first, and   the index only if levels are equal.  
* [0.x.29]*
   Compare for equality.  
* [0.x.30]*
   Compare for inequality.  
* [0.x.31]*
    [2.x.21]  Advancement of iterators  
* [0.x.32]*
    [2.x.22]   
* [0.x.33]*
   This operator advances the iterator to the next element.     For  [2.x.23]  only: The next element is next on this level if there are   more. If the present element is the last on this level, the first on the   next level is accessed.  
* [0.x.34]*
   This operator moves the iterator to the previous element.     For  [2.x.24]  only: The previous element is previous on this level if   <tt>index>0</tt>. If the present element is the first on this level, the   last on the previous level is accessed.  
* [0.x.35]*
    [2.x.25]   
* [0.x.36]*
   Access to the other objects of a Triangulation with same dimension.  
* [0.x.37]*
   Data type to be used for passing parameters from iterators to the   accessor classes in a unified way, no matter what the type of number of   these parameters is.  
* [0.x.38]*
    [2.x.26]  Iterator address and state  
* [0.x.39]*
    [2.x.27]   
* [0.x.40]*
   For cells, this function returns the level within the mesh hierarchy at   which this cell is located. For all other objects, the function returns   zero.    
*  [2.x.28]  Within a Triangulation object, cells are uniquely identified by a   pair  [2.x.29]  where the former is the cell's   refinement level and the latter is the index of the cell within this   refinement level (the former being what this function returns).   Consequently, there may be multiple cells on different refinement levels   but with the same index within their level. Contrary to this, if the   current object corresponds to a face or edge, then the object is uniquely   identified solely by its index as faces and edges do not have a   refinement level. For these objects, the current function always returns   zero as the level.  
* [0.x.41]*
   Return the index of the element presently pointed to on the present   level.     Within a Triangulation object, cells are uniquely identified by a pair    [2.x.30]  where the former is the cell's refinement   level and the latter is the index of the cell within this refinement   level (the latter being what this function returns). Consequently, there   may be multiple cells on different refinement levels but with the same   index within their level. Contrary to this, if the current object   corresponds to a face or edge, then the object is uniquely identified   solely by its index as faces and edges do not have a refinement level.    
*  [2.x.31]  The indices objects returned by this function are not a contiguous   set of numbers on each level: going from cell to cell, some of the   indices in a level may be unused.    
*  [2.x.32]  If the triangulation is actually of type    [2.x.33]  then the indices are relatively only   to that part of the distributed triangulation that is stored on the   current processor. In other words, cells living in the partitions of the   triangulation stored on different processors may have the same index even   if they refer to the same cell, and the may have different indices even   if they do refer to the same cell (e.g., if a cell is owned by one   processor but is a ghost cell on another).  
* [0.x.42]*
   Return the state of the iterator.  For the different states an accessor   can be in, refer to the TriaRawIterator documentation.  
* [0.x.43]*
   Return a reference to the triangulation which the object pointed to by this   class belongs to.  
* [0.x.44]*
    [2.x.34]   
* [0.x.45]*
   The level if this is a cell (<tt>structdim==dim</tt>). Else, contains   zero.  
* [0.x.46]*
   Used to store the index of the element presently pointed to on the level   presently used.  
* [0.x.47]*
   Pointer to the triangulation which we act on.  
* [0.x.48]*
 A class that represents accessor objects to iterators that don't make sense such as quad iterators in on 1d meshes.  This class can not be used to create objects (it will in fact throw an exception if this should ever be attempted but it sometimes allows code to be written in a simpler way in a dimension independent way. For example, it allows to write code that works on quad iterators that is dimension independent
* 
*  -  i.e., also compiles in 1d
* 
*  -  because quad iterators (via the current class) exist and are syntactically correct. You can not expect, however, to ever create an actual object of one of these iterators in 1d, meaning you need to expect to wrap the code block in which you use quad iterators into something like  [2.x.35] 
* 
*  -  which makes eminent sense anyway.
*  This class provides the minimal interface necessary for Accessor classes to interact with Iterator classes. However, this is only for syntactic correctness, none of the functions do anything but generate errors.
* 

* 
*  [2.x.36] 

* 
* [0.x.49]*
   Propagate alias from base class to this class.  
* [0.x.50]*
   Constructor.  This class is used for iterators that do not make   sense in a given dimension, for example quads for 1d meshes. Consequently,   while the creation of such objects is syntactically valid, they make no   semantic sense, and we generate an exception when such an object is   actually generated.  
* [0.x.51]*
   Copy constructor.  This class is used for iterators that do not make   sense in a given dimension, for example quads for 1d meshes. Consequently,   while the creation of such objects is syntactically valid, they make no   semantic sense, and we generate an exception when such an object is   actually generated.  
* [0.x.52]*
   Conversion from other accessors to the current invalid one. This of   course also leads to a run-time error.  
* [0.x.53]*
   Dummy copy operation.  
* [0.x.54]*
   Dummy comparison operators.  
* [0.x.55]*
   Dummy operators to make things compile. Does nothing.  
* [0.x.56]*
   Dummy function representing whether the accessor points to a used or an   unused object.  
* [0.x.57]*
   Dummy function representing whether the accessor points to an object that   has children.  
* [0.x.58]*
   Dummy function that always returns  [2.x.37]   
* [0.x.59]*
   Dummy function that always returns  [2.x.38]   
* [0.x.60]*
   Dummy function that always throws.  
* [0.x.61]*
   Dummy function that always throws.  
* [0.x.62]*
   Dummy function to extract vertices. Returns the origin.  
* [0.x.63]*
   Dummy function to extract lines. Returns a default-constructed line   iterator.  
* [0.x.64]*
   Dummy function to extract quads. Returns a default-constructed quad   iterator.  
* [0.x.65]*
 A class that provides access to objects in a triangulation such as its vertices, sub-objects, children, geometric information, etc. This class represents objects of dimension  [2.x.39]  (i.e. 1 for lines, 2 for quads, 3 for hexes) in a triangulation of dimensionality  [2.x.40]  (i.e. 1 for a triangulation of lines, 2 for a triangulation of quads, and 3 for a triangulation of hexes) that is embedded in a space of dimensionality  [2.x.41]  (for  [2.x.42]  the triangulation represents a domain in  [2.x.43] , for  [2.x.44]  the triangulation is of a manifold embedded in a higher dimensional space).
*  There is a specialization of this class for the case where  [2.x.45]  equals zero, i.e., for vertices of a triangulation.
* 

* 
*  [2.x.46] 

* 
* [0.x.66]*
   Propagate alias from base class to this class.  
* [0.x.67]*
   Constructor.  
* [0.x.68]*
   The copy constructor is not deleted but copied constructed elements should   not be modified, also the comments to the copy assignment operator.  
* [0.x.69]*
   Move constructor.  
* [0.x.70]*
   Conversion constructor. This constructor exists to make certain   constructs simpler to write in dimension independent code. For example,   it allows assigning a face iterator to a line iterator, an operation that   is useful in 2d but doesn't make any sense in 3d. The constructor here   exists for the purpose of making the code conform to C++ but it will   unconditionally abort; in other words, assigning a face iterator to a   line iterator is better put into an if-statement that checks that the   dimension is two, and assign to a quad iterator in 3d (an operator that,   without this constructor would be illegal if we happen to compile for   2d).  
* [0.x.71]*
   Another conversion operator between objects that don't make sense, just   like the previous one.  
* [0.x.72]*
   Copy operator. These operators are usually used in a context like   <tt>iterator a,b;a=*b;</tt>. Presumably, the intent here is to copy the   object pointed to   by  [2.x.47]  to the object pointed to by  [2.x.48]  However, the result of   dereferencing an iterator is not an object but an accessor; consequently,   this operation is not useful for iterators on triangulations.   Consequently, this operator is declared as deleted and can not be used.  
* [0.x.73]*
   Move assignment operator. Moving is allowed.  
* [0.x.74]*
   Defaulted destructor.  
* [0.x.75]*
   Test for the element being used or not.  The return value is  [2.x.49]  for   all iterators that are either normal iterators or active iterators, only   raw iterators can return  [2.x.50]  Since raw iterators are only used in   the interiors of the library, you will not usually need this function.  
* [0.x.76]*
    [2.x.51]  Accessing sub-objects  
* [0.x.77]*
    [2.x.52]   
* [0.x.78]*
   Pointer to the  [2.x.53]  vertex bounding this object. Throw an exception if    [2.x.54] .  
* [0.x.79]*
   Return the global index of i-th vertex of the current object. The   convention regarding the numbering of vertices is laid down in the   documentation of the GeometryInfo class.     Note that the returned value is only the index of the geometrical vertex.   It has nothing to do with possible degrees of freedom associated with it.   For this, see the  [2.x.55]  functions.    
*  [2.x.56]  Despite the name, the index returned here is only global in the   sense that it is specific to a particular Triangulation object or, in the   case the triangulation is actually of type    [2.x.57]  specific to that part of the   distributed triangulation stored on the current processor.  
* [0.x.80]*
   Return a reference to the  [2.x.58]  vertex. The reference is not const,   i.e., it is possible to call this function on the left hand side of an   assignment, thereby moving the vertex of a cell within the triangulation.   Of course, doing so requires that you ensure that the new location of the   vertex remains useful
* 
*  -  for example, avoiding inverted or otherwise   distorted (see also    [2.x.59]  "this glossary entry").    
*  [2.x.60]  When a cell is refined, its children inherit the position of the   vertex positions of those vertices they share with the mother cell (plus   the locations of the new vertices on edges, faces, and cell interiors   that are created for the new child cells). If the vertex of a cell is   moved, this implies that its children will also use these new locations.   On the other hand, imagine a 2d situation where you have one cell that is   refined (with four children) and then you move the central vertex   connecting all four children. If you coarsen these four children again to   the mother cell, then the location of the moved vertex is lost and if, in   a later step, you refine the mother cell again, the then again new vertex   will be placed again at the same position as the first time around
* 
*  -    i.e., not at the location you had previously moved it to.    
*  [2.x.61]  The behavior described above is relevant if you have a    [2.x.62]  object. There, refining a mesh   always involves a re-partitioning. In other words, vertices of locally   owned cells (see    [2.x.63]  "this glossary entry")   that you may have moved to a different location on one processor may be   moved to a different processor upon mesh refinement (even if these   particular cells were not refined) which will re-create their position   based on the position of the coarse cells they previously had, not based   on the position these vertices had on the processor that previously owned   them. In other words, in parallel computations, you will probably have to   move nodes explicitly after every mesh refinement because vertex   positions may or may not be preserved across the re-partitioning that   accompanies mesh refinement.  
* [0.x.81]*
   Pointer to the  [2.x.64]  line bounding this object.  
* [0.x.82]*
   Line index of the  [2.x.65]  line bounding this object.     Implemented only for <tt>structdim>1</tt>, otherwise an exception   generated.  
* [0.x.83]*
   Pointer to the  [2.x.66]  quad bounding this object.  
* [0.x.84]*
   Quad index of the  [2.x.67]  quad bounding this object.     Implemented only for <tt>structdim>2</tt>, otherwise an exception   generated.  
* [0.x.85]*
    [2.x.68]   
* [0.x.86]*
    [2.x.69]  Orientation of sub-objects  
* [0.x.87]*
    [2.x.70]   
* [0.x.88]*
   Return whether the face with index  [2.x.71]  has its normal pointing in the   standard direction ( [2.x.72]  or whether it is the opposite ( [2.x.73]    Which is the standard direction is documented with the GeometryInfo   class. In 1d and 2d, this is always  [2.x.74]  but in 3d it may be   different, see the respective discussion in the documentation of the   GeometryInfo class.     This function is really only for internal use in the library unless you   absolutely know what this is all about.  
* [0.x.89]*
   Return whether the face with index  [2.x.75]  is rotated by 180 degrees ( [2.x.76]    true) or not ( [2.x.77]  In 1d and 2d, this is always  [2.x.78]  but in   3d it may be different, see the respective discussion in the   documentation of the GeometryInfo class.     This function is really only for internal use in the library unless you   absolutely know what this is all about.  
* [0.x.90]*
   Return whether the face with index  [2.x.79]  is rotated by 90 degrees ( [2.x.80]    true) or not ( [2.x.81]  In 1d and 2d, this is always  [2.x.82]  but in   3d it may be different, see the respective discussion in the   documentation of the GeometryInfo class.     This function is really only for internal use in the library unless you   absolutely know what this is all about.  
* [0.x.91]*
   Return whether the line with index  [2.x.83]  is oriented in standard   direction.  [2.x.84]  indicates, that the line is oriented from vertex 0 to   vertex 1, whereas it is the other way around otherwise. In 1d and 2d,   this is always  [2.x.85]  but in 3d it may be different, see the respective   discussion in the documentation of the GeometryInfo class.     This function is really only for internal use in the library unless you   absolutely know what this is all about.     This function queries  [2.x.86]   
* [0.x.92]*
    [2.x.87]   
* [0.x.93]*
    [2.x.88]  Accessing children  
* [0.x.94]*
    [2.x.89]   
* [0.x.95]*
   Test whether the object has children.  
* [0.x.96]*
   Return the number of immediate children of this object. The number of   children of an unrefined cell is zero.  
* [0.x.97]*
    [2.x.90]  Use n_active_descendants() instead.  
* [0.x.98]*
   Compute and return the number of active descendants of this objects. For   example, if all of the eight children of a hex are further refined   isotropically exactly once, the returned number will be 64, not 80.     If the present cell is not refined, one is returned.     If one considers a triangulation as a forest where the root of each tree   are the coarse mesh cells and nodes have descendants (the children of a   cell), then this function returns the number of terminal nodes in the   sub-tree originating from the current object; consequently, if the   current object is not further refined, the answer is one.  
* [0.x.99]*
   Return the number of times that this object is refined. Note that not all   its children are refined that often (which is why we prepend  [2.x.91]    the returned number is rather the maximum number of refinement in any   branch of children of this object.     For example, if this object is refined, and one of its children is   refined exactly one more time, then <tt>max_refinement_depth</tt> should   return 2.     If this object is not refined (i.e. it is active), then the return value   is zero.  
* [0.x.100]*
   Return an iterator to the  [2.x.92]  child.  
* [0.x.101]*
   Return the child number of  [2.x.93]  on the current cell. This is the   inverse function of  [2.x.94]   
* [0.x.102]*
   Return an iterator to that object that is identical to the ith child for   isotropic refinement. If the current object is refined isotropically,   then the returned object is the ith child. If the current object is   refined anisotropically, the returned child may in fact be a grandchild   of the object, or may not exist at all (in which case an exception is   generated).  
* [0.x.103]*
   Return the RefinementCase of this cell.  
* [0.x.104]*
   Index of the  [2.x.95]  child. The level of the child is one higher than that   of the present cell, if the children of a cell are accessed. The children   of faces have no level. If the child does not exist,
* 
*  -  is returned.  
* [0.x.105]*
   Index of the  [2.x.96]  isotropic child. See the isotropic_child() function   for a definition of this concept.  If the child does not exist,
* 
*  -  is   returned.  
* [0.x.106]*
    [2.x.97]   
* [0.x.107]*
    [2.x.98]  Dealing with boundary indicators  
* [0.x.108]*
    [2.x.99]   
* [0.x.109]*
   Return the boundary indicator of this object.     If the return value is the special value    [2.x.100]  then this object is in the interior   of the domain.      [2.x.101]     [2.x.102]  "Glossary entry on boundary indicators"  
* [0.x.110]*
   Set the boundary indicator of the current object. The same applies as for   the boundary_id() function.     This function only sets the boundary object of the current object itself,   not the indicators of the ones that bound it. For example, in 3d, if this   function is called on a face, then the boundary indicator of the 4 edges   that bound the face remain unchanged. If you want to set the boundary   indicators of face and edges at the same time, use the   set_all_boundary_ids() function. You can see the result of not using the   correct function in the results section of  [2.x.103] .      [2.x.104]  You should never set the boundary indicator of an interior face   (a face not at the boundary of the domain), or set the boundary   indicator of an exterior face to  [2.x.105]  (this   value is reserved for another purpose). Algorithms may not work or   produce very confusing results if boundary cells have a boundary   indicator of  [2.x.106]  or if interior cells have   boundary indicators other than  [2.x.107]    Unfortunately, the current object has no means of finding out whether it   really is at the boundary of the domain and so cannot determine whether   the value you are trying to set makes sense under the current   circumstances.    
*  [2.x.108]       [2.x.109]     [2.x.110]  "Glossary entry on boundary indicators"  
* [0.x.111]*
   Do as set_boundary_id() but also set the boundary indicators of the   objects that bound the current object. For example, in 3d, if   set_boundary_id() is called on a face, then the boundary indicator of the   4 edges that bound the face remain unchanged. In contrast, if you call   the current function, the boundary indicators of face and edges are all   set to the given value.     This function is useful if you set boundary indicators of faces in 3d (in   2d, the function does the same as set_boundary_id()) and you do so   because you want a curved boundary object to represent the part of the   boundary that corresponds to the current face. In that case, the   Triangulation class needs to figure out where to put new vertices upon   mesh refinement, and higher order Mapping objects also need to figure out   where new interpolation points for a curved boundary approximation should   be. In either case, the two classes first determine where interpolation   points on the edges of a boundary face should be, asking the boundary   object, before asking the boundary object for the interpolation points   corresponding to the interior of the boundary face. For this to work   properly, it is not sufficient to have set the boundary indicator for the   face alone, but you also need to set the boundary indicators of the edges   that bound the face. This function does all of this at once. You can see   the result of not using the correct function in the results section of    [2.x.111] .    
*  [2.x.112]       [2.x.113]     [2.x.114]  "Glossary entry on boundary indicators"  
* [0.x.112]*
   Return whether this object is at the boundary. Obviously, the use of this   function is only possible for <tt>dim [2.x.115]  however, for   <tt>dim==structdim</tt>, an object is a cell and the CellAccessor class   offers another possibility to determine whether a cell is at the boundary   or not.  
* [0.x.113]*
   Return a constant reference to the manifold object used for this object.     As explained in the    [2.x.116]    module, the process involved in finding the appropriate manifold   description involves querying both the manifold or boundary   indicators. See there for more information.  
* [0.x.114]*
    [2.x.117]   
* [0.x.115]*
    [2.x.118]  Dealing with manifold indicators  
* [0.x.116]*
    [2.x.119]   
* [0.x.117]*
   Return the manifold indicator of this object.     If the return value is the special value  [2.x.120]  then   this object is associated with a standard Cartesian Manifold Description.      [2.x.121]     [2.x.122]  "Glossary entry on manifold indicators"  
* [0.x.118]*
   Set the manifold indicator.  The same applies as for the   <tt>manifold_id()</tt> function.     Note that it only sets the manifold object of the current object itself,   not the indicators of the ones that bound it, nor of its children. For   example, in 3d, if this function is called on a face, then the manifold   indicator of the 4 edges that bound the face remain unchanged. If you   want to set the manifold indicators of face, edges and all children at   the same time, use the set_all_manifold_ids() function.      
*  [2.x.123]       [2.x.124]     [2.x.125]  "Glossary entry on manifold indicators"  
* [0.x.119]*
   Do as set_manifold_id() but also set the manifold indicators of the   objects that bound the current object. For example, in 3d, if   set_manifold_id() is called on a face, then the manifold indicator of the   4 edges that bound the face remain unchanged. On the other hand, the   manifold indicators of face and edges are all set at the same time using   the current function.    
*  [2.x.126]       [2.x.127]     [2.x.128]  "Glossary entry on manifold indicators"  
* [0.x.120]*
    [2.x.129]   
* [0.x.121]*
    [2.x.130]  User data  
* [0.x.122]*
    [2.x.131]   
* [0.x.123]*
   Read the user flag. See    [2.x.132]    for more information.  
* [0.x.124]*
   Set the user flag. See    [2.x.133]    for more information.  
* [0.x.125]*
   Clear the user flag. See    [2.x.134]    for more information.  
* [0.x.126]*
   Set the user flag for this and all descendants. See    [2.x.135]    for more information.  
* [0.x.127]*
   Clear the user flag for this and all descendants. See    [2.x.136]    for more information.  
* [0.x.128]*
   Reset the user data to zero, independent if pointer or index. See    [2.x.137]    for more information.  
* [0.x.129]*
   Set the user pointer to  [2.x.138]     
*  [2.x.139]  User pointers and user indices are mutually exclusive. Therefore,   you can only use one of them, unless you call    [2.x.140]  in between.     See    [2.x.141]    for more information.  
* [0.x.130]*
   Reset the user pointer to a  [2.x.142]  pointer. See    [2.x.143]    for more information.  
* [0.x.131]*
   Access the value of the user pointer. It is in the responsibility of the   user to make sure that the pointer points to something useful. You should   use the new style cast operator to maintain a minimum of type safety,   e.g.    
*  [2.x.144]  User pointers and user indices are mutually exclusive. Therefore,   you can only use one of them, unless you call    [2.x.145]  in between. <tt>A  a=static_cast<A*>(cell->user_pointer());</tt>.     See    [2.x.146]    for more information.  
* [0.x.132]*
   Set the user pointer of this object and all its children to the given   value. This is useful for example if all cells of a certain subdomain, or   all faces of a certain part of the boundary should have user pointers   pointing to objects describing this part of the domain or boundary.     Note that the user pointer is not inherited under mesh refinement, so   after mesh refinement there might be cells or faces that don't have user   pointers pointing to the describing object. In this case, simply loop   over all the elements of the coarsest level that has this information,   and use this function to recursively set the user pointer of all finer   levels of the triangulation.    
*  [2.x.147]  User pointers and user indices are mutually exclusive. Therefore,   you can only use one of them, unless you call    [2.x.148]  in between.     See    [2.x.149]    for more information.  
* [0.x.133]*
   Clear the user pointer of this object and all of its descendants. The   same holds as said for the recursively_set_user_pointer() function. See    [2.x.150]    for more information.  
* [0.x.134]*
   Set the user index to  [2.x.151]     
*  [2.x.152]  User pointers and user indices are mutually exclusive. Therefore,   you can only use one of them, unless you call    [2.x.153]  in between. See    [2.x.154]    for more information.  
* [0.x.135]*
   Reset the user index to 0. See    [2.x.155]    for more information.  
* [0.x.136]*
   Access the value of the user index.    
*  [2.x.156]  User pointers and user indices are mutually exclusive. Therefore,   you can only use one of them, unless you call    [2.x.157]  in between.     See    [2.x.158]    for more information.  
* [0.x.137]*
   Set the user index of this object and all its children.     Note that the user index is not inherited under mesh refinement, so after   mesh refinement there might be cells or faces that don't have the   expected user indices. In this case, simply loop over all the elements of   the coarsest level that has this information, and use this function to   recursively set the user index of all finer levels of the triangulation.    
*  [2.x.159]  User pointers and user indices are mutually exclusive. Therefore,   you can only use one of them, unless you call    [2.x.160]  in between.     See    [2.x.161]    for more information.  
* [0.x.138]*
   Clear the user index of this object and all of its descendants. The same   holds as said for the recursively_set_user_index() function.     See    [2.x.162]    for more information.  
* [0.x.139]*
    [2.x.163]   
* [0.x.140]*
    [2.x.164]  Geometric information about an object  
* [0.x.141]*
    [2.x.165]   
* [0.x.142]*
   Diameter of the object.     The diameter of an object is computed to be the largest diagonal of the   current object. If this object is a quadrilateral, then there are two   such diagonal, and if it is a hexahedron, then there are four diagonals   that connect "opposite" points. For triangles and tetrahedra, the function   simply returns the length of the longest edge.     The situation is more difficult for wedges and pyramids: For wedges, we   return the length of the longest diagonal of the three quadrilateral faces   or the longest edge length of the two triangular faces. For pyramids,   the same principle is applied.     In all of these cases, this definition of "diameter" is   not necessarily the true diameter in the sense of the largest distance   between points inside the object. Indeed, one can often construct objects   for which it is not, though these are generally quite deformed compared to   the reference shape. Furthermore, for objects that may use higher order   mappings, one may have bulging faces that also create trouble for   computing an exact representation of the diameter of the object. That said,   the definition used above is completely sufficient for most computations.  
* [0.x.143]*
   Return a pair of Point and double corresponding to the center and   the radius of a reasonably small enclosing ball of the object.     The function implements Ritter's O(n) algorithm to get a reasonably   small enclosing ball around the vertices of the object.   The initial guess for the enclosing ball is taken to be the ball   which contains the largest diagonal of the object as its diameter.   Starting from such an initial guess, the algorithm tests whether all   the vertices of the object (except the vertices of the largest diagonal)   are geometrically within the ball.   If any vertex (v) is found to be geometrically outside the ball,   a new iterate of the ball is constructed by shifting its center and   increasing the radius so as to geometrically enclose both the previous   ball and the vertex (v). The algorithm terminates when all the vertices   are geometrically inside the ball.     If a vertex (v) is geometrically inside a particular iterate of the ball,   then it will continue to be so in the subsequent iterates of   the ball (this is true \a by \a construction).    
*  [2.x.166]  This function assumes d-linear mapping from the reference cell.     [1.x.0] and   [Ritter 1990]  
* [0.x.144]*
   Return the smallest bounding box that encloses the object.     Notice that this method is not aware of any mapping you may be using to   do your computations. If you are using a mapping object that modifies the   position of the vertices, like MappingQEulerian, or MappingFEField, then   you should call the function  [2.x.167]  instead.  
* [0.x.145]*
   Length of an object in the direction of the given axis, specified in the   local coordinate system. See the documentation of GeometryInfo for the   meaning and enumeration of the local axes.     Note that the "length" of an object can be interpreted in a variety of   ways. Here, we choose it as the maximal length of any of the edges of the   object that are parallel to the chosen axis on the reference cell.  
* [0.x.146]*
   Return the minimal distance between any two vertices.  
* [0.x.147]*
   Return a point belonging to the Manifold<dim,spacedim> where this object   lives, given its parametric coordinates on the reference  [2.x.168]    cell. This function queries the underlying manifold object, and can be   used to obtain the exact geometrical location of arbitrary points on this   object.     Notice that the argument  [2.x.169]  are the coordinates on the    [2.x.170] reference cell [2.x.171] , given in reference coordinates. In other words,   the argument provides a weighting between the different vertices. For   example, for lines, calling this function with argument Point<1>(.5), is   equivalent to asking the line for its center.  
* [0.x.148]*
   This function computes a fast approximate transformation from the real to   the unit cell by inversion of an affine approximation of the  [2.x.172] -linear   function from the reference  [2.x.173] -dimensional cell.     The affine approximation of the unit to real cell mapping is found by a   least squares fit of an affine function to the  [2.x.174]  vertices of the   present object. For any valid mesh cell whose geometry is not degenerate,   this operation results in a unique affine mapping. Thus, this function   will return a finite result for all given input points, even in cases   where the actual transformation by an actual bi-/trilinear or higher   order mapping might be singular. Besides only approximating the mapping   from the vertex points, this function also ignores the attached manifold   descriptions. The result is only exact in case the transformation from   the unit to the real cell is indeed affine, such as in one dimension or   for Cartesian and affine (parallelogram) meshes in 2D/3D.     For exact transformations to the unit cell, use    [2.x.175]     
*  [2.x.176]  If dim<spacedim we first project p onto the plane.  
* [0.x.149]*
   Center of the object. The center of an object is defined to be the   average of the locations of the vertices, which is also where a  [2.x.177]    mapping would map the center of the reference cell. However, you can also   ask this function to instead return the average of the vertices as   computed by the underlying Manifold object associated with the current   object, by setting to true the optional parameter  [2.x.178]    Manifolds would then typically pull back the coordinates of the vertices   to a reference domain (not necessarily the reference cell), compute the   average there, and then push forward the coordinates of the averaged   point to the physical space again; the resulting point is guaranteed to   lie within the manifold, even if the manifold is curved.     When the object uses a different manifold description as its surrounding,   like when part of the bounding objects of this TriaAccessor use a   non-flat manifold description but the object itself is flat, the result   given by the  [2.x.179]  function may not be accurate enough,   even when parameter  [2.x.180]  is set to true. If you find this   to be case, than you can further refine the computation of the center by   setting to true the second additional parameter  [2.x.181]    interpolate_from_surrounding. This computes the location of the center by   a so-called transfinite interpolation from the center of all the bounding   objects. For a 2D object, it puts a weight of  [2.x.182]  on each of   the four surrounding lines and a weight  [2.x.183]  on the four   vertices. This corresponds to a linear interpolation between the   descriptions of the four faces, subtracting the contribution of the   vertices that is added twice when coming through both lines adjacent to   the vertex. In 3D, the weights for faces are  [2.x.184] , the   weights for lines are  [2.x.185] , and the weights for vertices are    [2.x.186] . For further information, also confer to the   TransfiniteInterpolationManifold class that is able to not only apply   this beneficial description to a single cell but all children of a coarse   cell.  
* [0.x.150]*
   Return the barycenter (also called centroid)   of the object. The barycenter for an object  [2.x.187]    of dimension  [2.x.188]  in  [2.x.189]  space dimensions is given by the  [2.x.190] -dimensional   vector  [2.x.191]  defined by   [1.x.1]   where the measure of the object is given by   [1.x.2]   This function assumes that  [2.x.192]  is mapped by a  [2.x.193] -linear function from   the reference  [2.x.194] -dimensional cell. Then the integrals above can be   pulled back to the reference cell and evaluated exactly (if through   lengthy and, compared to the center() function, expensive computations).  
* [0.x.151]*
   Compute the dim-dimensional measure of the object. For a dim-dimensional   cell in dim-dimensional space, this equals its volume. On the other hand,   for a 2d cell in 3d space, or if the current object pointed to is a 2d   face of a 3d cell in 3d space, then the function computes the area the   object occupies. For a one-dimensional object, return its length.     The function only computes the measure of cells, faces or edges assumed   to be represented by (bi-/tri-)linear mappings. In other words, it only   takes into account the locations of the vertices that bound the current   object but not how the interior of the object may actually be mapped. In   most simple cases, this is exactly what you want. However, for objects   that are not "straight", e.g. 2d cells embedded in 3d space as part of a   triangulation of a curved domain, two-dimensional faces of 3d cells that   are not just parallelograms, or for faces that are at the boundary of a   domain that is not just bounded by straight line segments or planes, this   function only computes the dim-dimensional measure of a (bi-/tri-)linear   interpolation of the "real" object as defined by the manifold or boundary   object describing the real geometry of the object in question. If you   want to consider the "real" geometry, you will need to compute the   measure by integrating a function equal to one over the object, which   after applying quadrature equals the summing the JxW values returned by   the FEValues or FEFaceValues object you will want to use for the   integral.  
* [0.x.152]*
   Return true if the current object is a translation of the given argument.    
*  [2.x.195]  For the purpose of a triangulation, cells, faces, etc are only   characterized by their vertices. The current function therefore only   compares the locations of vertices. For many practical applications,   however, it is not only the vertices that determine whether one cell is a   translation of another, but also how the cell is mapped from the   reference cell to its location in real space. For example, if we are   using higher order mappings, then not only do the vertices have to be   translations of each other, but also the points along edges. In these   questions, therefore, it would be appropriate to ask the mapping, not the   current function, whether two objects are translations of each other.  
* [0.x.153]*
   Reference cell type of the current object.  
* [0.x.154]*
   Number of vertices.  
* [0.x.155]*
   Number of lines.  
* [0.x.156]*
   Number of faces.    
*  [2.x.196]  Only implemented for cells (dim==spacedim).  
* [0.x.157]*
   Return an object that can be thought of as an array containing all indices   from zero to n_vertices().  
* [0.x.158]*
   Return an object that can be thought of as an array containing all indices   from zero to n_lines().  
* [0.x.159]*
   Return an object that can be thought of as an array containing all indices   from zero to n_faces().    
*  [2.x.197]  Only implemented for cells (dim==spacedim).  
* [0.x.160]*
    [2.x.198]   
* [0.x.161]*
   Like set_boundary_id but without checking for internal faces or invalid   ids.  
* [0.x.162]*
   Set the indices of those objects that bound the current   object. For example, if the current object represents a cell,   then the argument denotes the indices of the faces that bound the   cell. If the current object represents a line, the argument   denotes the indices of the vertices that bound it. And so on.  
* [0.x.163]*
   The same as above but for `unsigned int`.  
* [0.x.164]*
   Set the flag indicating, what  [2.x.199]  will   return.     It is only possible to set the line_orientation of faces in 3d (i.e.    [2.x.200] ).  
* [0.x.165]*
   Set whether the quad with index  [2.x.201]  has its normal pointing in the   standard direction ( [2.x.202]  or whether it is the opposite ( [2.x.203]    Which is the standard direction is documented with the GeometryInfo   class.     This function is only for internal use in the library. Setting this flag   to any other value than the one that the triangulation has already set is   bound to bring you disaster.  
* [0.x.166]*
   Set the flag indicating, what  [2.x.204]  will return.     It is only possible to set the face_orientation of cells in 3d (i.e.    [2.x.205] ).  
* [0.x.167]*
   Set the flag indicating, what  [2.x.206]  will return.     It is only possible to set the face_orientation of cells in 3d (i.e.    [2.x.207] ).  
* [0.x.168]*
   Set the  [2.x.208]  flag. Only for internal use in the library.  
* [0.x.169]*
   Clear the  [2.x.209]  flag. Only for internal use in the library.  
* [0.x.170]*
   Set the  [2.x.210]  this TriaObject is refined with. Not   defined for <tt>structdim=1</tt> as lines are always refined resulting in   2 children lines (isotropic refinement).     You should know quite exactly what you are doing if you touch this   function. It is exclusively for internal use in the library.  
* [0.x.171]*
   Clear the RefinementCase<dim> of this TriaObject, i.e. reset it to    [2.x.211]      You should know quite exactly what you are doing if you touch this   function. It is exclusively for internal use in the library.  
* [0.x.172]*
   Set the index of the ith child. Since the children come at least in   pairs, we need to store the index of only every second child, i.e. of the   even numbered children. Make sure, that the index of child i=0 is set   first. Calling this function for odd numbered children is not allowed.  
* [0.x.173]*
   Clear the child field, i.e. set it to a value which indicates that this   cell has no children.  
* [0.x.174]*
 This class is a specialization of <code>TriaAccessor<structdim, dim, spacedim></code> for the case that  [2.x.212]  is zero. This class represents vertices in a triangulation of dimensionality  [2.x.213]  (i.e. 1 for a triangulation of lines, 2 for a triangulation of quads, and 3 for a triangulation of hexes) that is embedded in a space of dimensionality  [2.x.214]  (for  [2.x.215]  the triangulation represents a domain in  [2.x.216] , for  [2.x.217]  the triangulation is of a manifold embedded in a higher dimensional space).
*  There is a further specialization of this class for the case that  [2.x.218]  equals one, i.e., for vertices of a one-dimensional triangulation, since in that case vertices are also faces.
* 

* 
*  [2.x.219] 

* 
* [0.x.175]*
   Dimension of the space the object represented by this accessor lives in.   For example, if this accessor represents a quad that is part of a two-   dimensional surface in four-dimensional space, then this value is four.  
* [0.x.176]*
   Dimensionality of the object that the thing represented by this accessor   is part of. For example, if this accessor represents a line that is part   of a hexahedron, then this value will be three.  
* [0.x.177]*
   Dimensionality of the current object represented by this accessor. For   example, if it is line (irrespective of whether it is part of a quad or   hex, and what dimension we are in), then this value equals 1.  
* [0.x.178]*
   Pointer to internal data.  
* [0.x.179]*
   Constructor. The second argument is the global index of the vertex we   point to.  
* [0.x.180]*
   Constructor. This constructor exists in order to maintain interface   compatibility with the other accessor classes.  [2.x.220]  can be used to   set the global index of the vertex we point to.  
* [0.x.181]*
   Constructor. Should never be called and thus produces an error.  
* [0.x.182]*
   Constructor. Should never be called and thus produces an error.  
* [0.x.183]*
   Return the state of the iterator.  
* [0.x.184]*
   Level of this object. Vertices have no level, so this function always   returns zero.  
* [0.x.185]*
   Index of this object. Returns the global index of the vertex this object   points to.  
* [0.x.186]*
   Return a reference to the triangulation which the object pointed to by this   class belongs to.  
* [0.x.187]*
    [2.x.221]  Advancement of iterators  
* [0.x.188]*
    [2.x.222]   
* [0.x.189]*
   This operator advances the iterator to the next element.  
* [0.x.190]*
   This operator moves the iterator to the previous element.  
* [0.x.191]*
   Compare for equality.  
* [0.x.192]*
   Compare for inequality.  
* [0.x.193]*
    [2.x.223]   
* [0.x.194]*
    [2.x.224]  Accessing sub-objects  
* [0.x.195]*
    [2.x.225]   
* [0.x.196]*
   Return the global index of i-th vertex of the current object. If  [2.x.226]  is   zero, this returns the index of the current point to which this object   refers. Otherwise, it throws an exception.     Note that the returned value is only the index of the geometrical vertex.   It has nothing to do with possible degrees of freedom associated with it.   For this, see the  [2.x.227]  functions.    
*  [2.x.228]  Despite the name, the index returned here is only global in the   sense that it is specific to a particular Triangulation object or, in the   case the triangulation is actually of type    [2.x.229]  specific to that part of the   distributed triangulation stored on the current processor.  
* [0.x.197]*
   Return a reference to the  [2.x.230]  vertex. If i is zero, this returns a   reference to the current point to which this object refers. Otherwise, it   throws an exception.  
* [0.x.198]*
   Pointer to the  [2.x.231]  line bounding this object. Will point to an invalid   object.  
* [0.x.199]*
   Line index of the  [2.x.232]  line bounding this object. Throws an exception.  
* [0.x.200]*
   Pointer to the  [2.x.233]  quad bounding this object.  
* [0.x.201]*
   Quad index of the  [2.x.234]  quad bounding this object. Throws an exception.  
* [0.x.202]*
    [2.x.235]   
* [0.x.203]*
    [2.x.236]  Geometric information about an object  
* [0.x.204]*
    [2.x.237]   
* [0.x.205]*
   Diameter of the object. This function always returns zero.  
* [0.x.206]*
   Length of an object in the direction of the given axis, specified in the   local coordinate system. See the documentation of GeometryInfo for the   meaning and enumeration of the local axes.     This function always returns zero.  
* [0.x.207]*
   Return the center of this object, which of course coincides with the   location of the vertex this object refers to. The parameters  [2.x.238]    respect_manifold and  [2.x.239]  are not used. They   are there to provide the same interface as    [2.x.240] .  
* [0.x.208]*
   Compute the dim-dimensional measure of the object. For a dim-dimensional   cell in dim-dimensional space, this equals its volume. On the other hand,   for a 2d cell in 3d space, or if the current object pointed to is a 2d   face of a 3d cell in 3d space, then the function computes the area the   object occupies. For a one-dimensional object, return its length. For a   zero-dimensional object, return zero.  
* [0.x.209]*
    [2.x.241]   
* [0.x.210]*
    [2.x.242]  Orientation of sub-objects  
* [0.x.211]*
    [2.x.243]   
* [0.x.212]*
  
*  [2.x.244]   
* [0.x.213]*
  
*  [2.x.245]   
* [0.x.214]*
  
*  [2.x.246]   
* [0.x.215]*
  
*  [2.x.247]   
* [0.x.216]*
    [2.x.248]   
* [0.x.217]*
    [2.x.249]  Accessing children  
* [0.x.218]*
    [2.x.250]   
* [0.x.219]*
   Test whether the object has children. Always false.  
* [0.x.220]*
   Return the number of immediate children of this object. This is always   zero.  
* [0.x.221]*
   Compute and return the number of active descendants of this objects.   Always zero.  
* [0.x.222]*
    [2.x.251]  Use n_active_descendants() instead.  
* [0.x.223]*
   Return the number of times that this object is refined. Always 0.  
* [0.x.224]*
  
*  [2.x.252]   
* [0.x.225]*
  
*  [2.x.253]   
* [0.x.226]*
  
*  [2.x.254]   
* [0.x.227]*
   Always return no refinement.  
* [0.x.228]*
  
*  [2.x.255] 
* 
*  -   
* [0.x.229]*
  
*  [2.x.256] 
* 
*  -   
* [0.x.230]*
    [2.x.257]   
* [0.x.231]*
   Return whether the vertex pointed to here is used.  
* [0.x.232]*
   Copy operator. Since this is only called from iterators, do not return   anything, since the iterator will return itself.     This method is protected, since it is only to be called from the iterator   class.  
* [0.x.233]*
   Comparison operator for accessors. This operator is used when comparing   iterators into objects of a triangulation, for example when putting   them into a  [2.x.258]      This operator simply compares the global index of the vertex the   current object points to.  
* [0.x.234]*
   Pointer to the triangulation we operate on.  
* [0.x.235]*
   The global vertex index of the vertex this object corresponds to.  
* [0.x.236]*
 This class is a specialization of <code>TriaAccessor<structdim, dim, spacedim></code> for the case that  [2.x.259]  is zero and  [2.x.260]  is one. This class represents vertices in a one-dimensional triangulation that is embedded in a space of dimensionality  [2.x.261]  (for  [2.x.262]  the triangulation represents a domain in  [2.x.263] , for  [2.x.264]  the triangulation is of a manifold embedded in a higher dimensional space).
*  The current specialization of the TriaAccessor<0,dim,spacedim> class for vertices of a one-dimensional triangulation exists since in the  [2.x.265]  == 1 case vertices are also faces.
* 

* 
*  [2.x.266] 

* 
* [0.x.237]*
   Dimension of the space the object represented by this accessor lives in.   For example, if this accessor represents a quad that is part of a two-   dimensional surface in four-dimensional space, then this value is four.  
* [0.x.238]*
   Dimensionality of the object that the thing represented by this accessor   is part of. For example, if this accessor represents a line that is part   of a hexahedron, then this value will be three.  
* [0.x.239]*
   Dimensionality of the current object represented by this accessor. For   example, if it is line (irrespective of whether it is part of a quad or   hex, and what dimension we are in), then this value equals 1.  
* [0.x.240]*
   Pointer to internal data.  
* [0.x.241]*
   Whether the vertex represented here is at the left end of the domain, the   right end, or in the interior.  
* [0.x.242]*
     Left vertex.    
* [0.x.243]*
     Interior vertex.    
* [0.x.244]*
     Right vertex.    
* [0.x.245]*
   Constructor.     Since there is no mapping from vertices to cells, an accessor object for   a point has no way to figure out whether it is at the boundary of the   domain or not. Consequently, the second argument must be passed by the   object that generates this accessor
* 
*  -  e.g. a 1d cell that can figure out   whether its left or right vertex are at the boundary.     The third argument is the global index of the vertex we point to.  
* [0.x.246]*
   Constructor. This constructor exists in order to maintain interface   compatibility with the other accessor classes. However, it doesn't do   anything useful here and so may not actually be called.  
* [0.x.247]*
   Constructor. Should never be called and thus produces an error.  
* [0.x.248]*
   Constructor. Should never be called and thus produces an error.  
* [0.x.249]*
   Copy operator. Since this is only called from iterators, do not return   anything, since the iterator will return itself.  
* [0.x.250]*
   Return the state of the iterator. Since an iterator to points can not be   incremented or decremented, its state remains constant, and in particular   equal to  [2.x.267]   
* [0.x.251]*
   Level of this object. Vertices have no level, so this function always   returns zero.  
* [0.x.252]*
   Index of this object. Returns the global index of the vertex this object   points to.  
* [0.x.253]*
   Return a reference to the triangulation which the object pointed to by this   class belongs to.  
* [0.x.254]*
    [2.x.268]  Advancement of iterators  
* [0.x.255]*
    [2.x.269]   
* [0.x.256]*
   This operator advances the iterator to the next element. For points, this   operation is not defined, so you can't iterate over point iterators.  
* [0.x.257]*
   This operator moves the iterator to the previous element. For points,   this operation is not defined, so you can't iterate over point iterators.  
* [0.x.258]*
   Compare for equality.  
* [0.x.259]*
   Compare for inequality.  
* [0.x.260]*
   Comparison operator for accessors. This operator is used when comparing   iterators into objects of a triangulation, for example when putting   them into a  [2.x.270]      This operator simply compares the global index of the vertex the   current object points to.  
* [0.x.261]*
    [2.x.271]   
* [0.x.262]*
    [2.x.272]  Accessing sub-objects  
* [0.x.263]*
    [2.x.273]   
* [0.x.264]*
   Return the global index of i-th vertex of the current object. If i is   zero, this returns the index of the current point to which this object   refers. Otherwise, it throws an exception.     Note that the returned value is only the index of the geometrical vertex.   It has nothing to do with possible degrees of freedom associated with it.   For this, see the  [2.x.274]  functions.    
*  [2.x.275]  Despite the name, the index returned here is only global in the   sense that it is specific to a particular Triangulation object or, in the   case the triangulation is actually of type    [2.x.276]  specific to that part of the   distributed triangulation stored on the current processor.  
* [0.x.265]*
   Return a reference to the  [2.x.277]  vertex. If i is zero, this returns a   reference to the current point to which this object refers. Otherwise, it   throws an exception.  
* [0.x.266]*
   Return the center of this object, which of course coincides with the   location of the vertex this object refers to.  
* [0.x.267]*
   Pointer to the  [2.x.278]  line bounding this object. Will point to an invalid   object.  
* [0.x.268]*
   Line index of the  [2.x.279]  line bounding this object.     Implemented only for <tt>structdim>1</tt>, otherwise an exception   generated.  
* [0.x.269]*
   Pointer to the  [2.x.280]  quad bounding this object.  
* [0.x.270]*
   Quad index of the  [2.x.281]  quad bounding this object.     Implemented only for <tt>structdim>2</tt>, otherwise an exception   generated.  
* [0.x.271]*
    [2.x.282]   
* [0.x.272]*
   Return whether this point is at the boundary of the one-dimensional   triangulation we deal with here.  
* [0.x.273]*
   Return the boundary indicator of this object. The convention for one   dimensional triangulations is that left end vertices (of each line   segment from which the triangulation may be constructed) have boundary   indicator zero, and right end vertices have boundary indicator one,   unless explicitly set differently.     If the return value is the special value    [2.x.283]  then this object is in the interior   of the domain.      [2.x.284]     [2.x.285]  "Glossary entry on boundary indicators"  
* [0.x.274]*
   Return a constant reference to the manifold object used for this object.  
* [0.x.275]*
   Return the manifold indicator of this object.      [2.x.286]     [2.x.287]  "Glossary entry on manifold indicators"  
* [0.x.276]*
    [2.x.288]  Orientation of sub-objects  
* [0.x.277]*
    [2.x.289]   
* [0.x.278]*
  
*  [2.x.290]   
* [0.x.279]*
  
*  [2.x.291]   
* [0.x.280]*
  
*  [2.x.292]   
* [0.x.281]*
  
*  [2.x.293]   
* [0.x.282]*
    [2.x.294]   
* [0.x.283]*
    [2.x.295]  Accessing children  
* [0.x.284]*
    [2.x.296]   
* [0.x.285]*
   Test whether the object has children. Always false.  
* [0.x.286]*
   Return the number of immediate children of this object.This is always   zero in dimension 0.  
* [0.x.287]*
   Compute and return the number of active descendants of this objects.   Always zero.  
* [0.x.288]*
    [2.x.297]  Use n_active_descendants() instead.  
* [0.x.289]*
   Return the number of times that this object is refined. Always 0.  
* [0.x.290]*
  
*  [2.x.298]   
* [0.x.291]*
  
*  [2.x.299]   
* [0.x.292]*
  
*  [2.x.300]   
* [0.x.293]*
   Always return no refinement.  
* [0.x.294]*
  
*  [2.x.301] 
* 
*  -   
* [0.x.295]*
  
*  [2.x.302] 
* 
*  -   
* [0.x.296]*
    [2.x.303]   
* [0.x.297]*
    [2.x.304]  Dealing with boundary indicators  
* [0.x.298]*
    [2.x.305]   
* [0.x.299]*
   Set the boundary indicator. The same applies as for the   <tt>boundary_id()</tt> function.      [2.x.306]  You should never set the boundary indicator of an interior face   (a face not at the boundary of the domain), or set the boundary   indicator of an exterior face to  [2.x.307]  (this   value is reserved for another purpose). Algorithms may not work or   produce very confusing results if boundary cells have a boundary   indicator of  [2.x.308]  or if interior cells have   boundary indicators other than  [2.x.309]    Unfortunately, the current object has no means of finding out whether it   really is at the boundary of the domain and so cannot determine whether   the value you are trying to set makes sense under the current   circumstances.    
*  [2.x.310]       [2.x.311]     [2.x.312]  "Glossary entry on boundary indicators"  
* [0.x.300]*
   Set the manifold indicator of this vertex. This does nothing so far since   manifolds are only used to refine and map objects, but vertices are not   refined and the mapping is trivial. This function is here only to allow   dimension independent programming.  
* [0.x.301]*
   Set the boundary indicator of this object and all of its lower-   dimensional sub-objects.  Since this object only represents a single   vertex, there are no lower-dimensional object and this function is   equivalent to calling set_boundary_id() with the same argument.    
*  [2.x.313]       [2.x.314]     [2.x.315]  "Glossary entry on boundary indicators"  
* [0.x.302]*
   Set the manifold indicator of this object and all of its lower-   dimensional sub-objects.  Since this object only represents a single   vertex, there are no lower-dimensional object and this function is   equivalent to calling set_manifold_id() with the same argument.    
*  [2.x.316]       [2.x.317]     [2.x.318]  "Glossary entry on manifold indicators"  
* [0.x.303]*
    [2.x.319]   
* [0.x.304]*
   Return whether the vertex pointed to here is used.  
* [0.x.305]*
   Reference cell type of the current object.  
* [0.x.306]*
   Number of vertices.  
* [0.x.307]*
   Number of lines.  
* [0.x.308]*
   Return an object that can be thought of as an array containing all indices   from zero to n_vertices().  
* [0.x.309]*
   Return an object that can be thought of as an array containing all indices   from zero to n_lines().  
* [0.x.310]*
   Pointer to the triangulation we operate on.  
* [0.x.311]*
   Whether this is a left end, right end, or interior vertex. This   information is provided by the cell at the time of creation.  
* [0.x.312]*
   The global vertex index of the vertex this object corresponds to.  
* [0.x.313]*
 This class allows access to a cell: a line in one dimension, a quad in two dimension, etc.
*  The following refers to any dimension:
*  This class allows access to a <tt>cell</tt>, which is a line in 1D and a quad in 2D. Cells have more functionality than lines or quads by themselves, for example they can be flagged for refinement, they have neighbors, they have the possibility to check whether they are at the boundary etc. This class offers access to all this data.
* 

* 
*  [2.x.320] 

* 
*  [2.x.321] 

* 
* [0.x.314]*
   Propagate the AccessorData type into the present class.  
* [0.x.315]*
   Define the type of the container this is part of.  
* [0.x.316]*
    [2.x.322]  Constructors  
* [0.x.317]*
    [2.x.323]   
* [0.x.318]*
   Constructor.  
* [0.x.319]*
   Copy constructor.  
* [0.x.320]*
   Conversion constructor. This constructor exists to make certain   constructs simpler to write in dimension independent code. For example,   it allows assigning a face iterator to a line iterator, an operation that   is useful in 2d but doesn't make any sense in 3d. The constructor here   exists for the purpose of making the code conform to C++ but it will   unconditionally abort; in other words, assigning a face iterator to a   line iterator is better put into an if-statement that checks that the   dimension is two, and assign to a quad iterator in 3d (an operator that,   without this constructor would be illegal if we happen to compile for   2d).  
* [0.x.321]*
   Another conversion operator between objects that don't make sense, just   like the previous one.  
* [0.x.322]*
   Copy constructor.  
* [0.x.323]*
   Move constructor.  
* [0.x.324]*
   Destructor.  
* [0.x.325]*
   Copy operator. These operators are usually used in a context like   <tt>iterator a,b;a=*b;</tt>. Presumably, the intent here is to copy the   object pointed to   by  [2.x.324]  to the object pointed to by  [2.x.325]  However, the result of   dereferencing an iterator is not an object but an accessor; consequently,   this operation is not useful for iterators on triangulations.   Consequently, this operator is declared as deleted and can not be used.  
* [0.x.326]*
   Move assignment operator.  
* [0.x.327]*
    [2.x.326]   
* [0.x.328]*
    [2.x.327]  Accessing sub-objects and neighbors  
* [0.x.329]*
    [2.x.328]   
* [0.x.330]*
   Return a pointer to the  [2.x.329]  child. Overloaded version which returns a   more reasonable iterator class.  
* [0.x.331]*
   Return an array of iterators to all children of this cell.  
* [0.x.332]*
   Return an iterator to the  [2.x.330]  face of this cell.  
* [0.x.333]*
   Return the face number of  [2.x.331]  on the current cell. This is the   inverse function of  [2.x.332]   
* [0.x.334]*
   Return an array of iterators to all faces of this cell.  
* [0.x.335]*
   Return the (global) index of the  [2.x.333]  face of this cell.    
*  [2.x.334]  Despite the name, the index returned here is only global in the   sense that it is specific to a particular Triangulation object or, in the   case the triangulation is actually of type    [2.x.335]  specific to that part of the   distributed triangulation stored on the current processor.  
* [0.x.336]*
   Return an iterator to that cell that neighbors the present cell on the   given face and subface number.     To succeed, the present cell must not be further refined, and the   neighbor on the given face must be further refined exactly once; the   returned cell is then a child of that neighbor.     The function may not be called in 1d, since there we have no subfaces.   The implementation of this function is rather straightforward in 2d, by   first determining which face of the neighbor cell the present cell is   bordering on (this is what the  [2.x.336]  function does),   and then asking  [2.x.337]  for the index of   the child.     However, the situation is more complicated in 3d, since there faces may   have more than one orientation, and we have to use  [2.x.338]     [2.x.339]  and  [2.x.340]  for both this and the neighbor cell to   figure out which cell we want to have.     This can lead to surprising results: if we are sitting on a cell and are   asking for a cell behind subface <tt>sf</tt>, then this means that we are   considering the subface for the face in the natural direction for the   present cell. However, if the face as seen from this cell has   <tt>face_orientation()==false</tt>, then the child of the face that   separates the present cell from the neighboring cell's child is not   necessarily the  [2.x.341]  child of the face of this cell. This is so   because the  [2.x.342]  on a cell corresponds to the subface with   respect to the intrinsic ordering of the present cell, whereas children   of face iterators are computed with respect to the intrinsic ordering of   faces; these two orderings are only identical if the face orientation is    [2.x.343]  and reversed otherwise.     Similarly, effects of <tt>face_flip()==true</tt> and   <tt>face_rotation()==true()</tt>, both of which indicate a non-standard   face have to be considered.     Fortunately, this is only very rarely of concern, since usually one   simply wishes to loop over all finer neighbors at a given face of an   active cell. Only in the process of refinement of a Triangulation we want   to set neighbor information for both our child cells and the neighbor's   children. Since we can respect orientation of faces from our current cell   in that case, we do NOT respect face_orientation, face_flip and   face_rotation of the present cell within this function, i.e. the returned   neighbor's child is behind subface  [2.x.344]  concerning the intrinsic   ordering of the given face.  
* [0.x.337]*
   Return an iterator to the neighboring cell on the other side of the face   with number  [2.x.345]  If the neighbor does not exist,   i.e., if the face with number  [2.x.346]  of the current object is at the boundary, then   an invalid iterator is returned.     Consequently, the index  [2.x.347]  must be less than n_faces().     The neighbor of a cell has at most the same level as this cell. For   example, consider the following situation:    [2.x.348]    Here, if you are on the top right cell and you ask for its left neighbor   (which is, according to the conventions spelled out in the GeometryInfo   class, its [1.x.3] neighbor), then you will get the mother cell of   the four small cells at the top left. In other words, the cell you get as   neighbor has the same refinement level as the one you're on right now   (the top right one) and it may have children.     On the other hand, if you were at the top right cell of the four small   cells at the top left, and you asked for the right neighbor (which is   associated with index  [2.x.349] ), then you would get the large   cell at the top right which in this case has a lower refinement level and   no children of its own.  
* [0.x.338]*
   Return the cell index of the neighboring cell on the other side of the face   with index  [2.x.350]  If the neighbor does not exist, this function returns
* 
*  - .     This function is equivalent to <tt>cell->neighbor(face_no)->index()</tt>.   See neighbor() for more details.  
* [0.x.339]*
   Return the level of the neighboring cell on the other side of the face with   number  [2.x.351]  If the neighbor does not exist, this function returns
* 
*  - .     This function is equivalent to `cell->neighbor(face_no)->level()`.   See neighbor() for more details.  
* [0.x.340]*
   Return the how-many'th neighbor this cell is of   <tt>cell->neighbor(face_no)</tt>, i.e. return  [2.x.352]  such that   <tt>cell->neighbor(face_no)->neighbor(other_face_no)==cell</tt>. This   function is the right one if you want to know how to get back from a   neighbor to the present cell.     Note that this operation is only useful if the neighbor is not coarser   than the present cell. If the neighbor is coarser this function throws an   exception. Use the  [2.x.353]  function in that case.  
* [0.x.341]*
   Return, whether the neighbor is coarser then the present cell. This is   important in case of anisotropic refinement where this information does   not depend on the levels of the cells.     Note, that in an anisotropic setting, a cell can only be coarser than   another one at a given face, not on a general basis. The face of the   finer cell is contained in the corresponding face of the coarser cell,   the finer face is either a child or a grandchild of the coarser face.  
* [0.x.342]*
   This function is a generalization of the  [2.x.354]  function   for the case of a coarser neighbor. It returns a pair of numbers, face_no   and subface_no, with the following property, if the neighbor is not   refined: <tt>cell->neighbor(neighbor)->neighbor_child_on_subface(face_no,   subface_no)==cell</tt>. In 3D, a coarser neighbor can still be refined.   In that case subface_no denotes the child index of the neighbors face   that relates to our face:   <tt>cell->neighbor(neighbor)->face(face_no)->child(subface_no)==cell->face(neighbor)</tt>.   This case in 3d and how it can happen is discussed in the introduction of   the  [2.x.355]  tutorial program.     This function is impossible for <tt>dim==1</tt>.  
* [0.x.343]*
   This function is a generalization of the  [2.x.356]  and the    [2.x.357]  functions. It checks whether the neighbor   is coarser or not and calls the respective function. In both cases, only   the face_no is returned.  
* [0.x.344]*
   Compatibility interface with DoFCellAccessor. Always returns  [2.x.358]   
* [0.x.345]*
    [2.x.359]   
* [0.x.346]*
    [2.x.360]  Dealing with periodic neighbors  
* [0.x.347]*
    [2.x.361]   
* [0.x.348]*
   If the cell has a periodic neighbor at its  [2.x.362]  ith face, this function   returns true, otherwise, the returned value is false.  
* [0.x.349]*
   For a cell with its  [2.x.363]  ith face at a periodic boundary,   see    [2.x.364]  "the entry for periodic boundaries",   this function returns an iterator to the cell on the other side   of the periodic boundary. If there is no periodic boundary at the  [2.x.365]  ith   face, an exception will be thrown.   In order to avoid running into an exception, check the result of   has_periodic_neighbor() for the  [2.x.366]  ith face prior to using this function.   The behavior of periodic_neighbor() is similar to neighbor(), in   the sense that the returned cell has at most the same level of refinement   as the current cell. On distributed meshes, by calling    [2.x.367]    we can make sure that the element on the other side of the periodic   boundary exists in this rank as a ghost cell or a locally owned cell.  
* [0.x.350]*
   For a cell whose  [2.x.368]  ith face is not at a boundary, this function returns   the same result as neighbor(). If the  [2.x.369]  ith face is at a periodic boundary   this function returns the same result as periodic_neighbor(). If neither of   the aforementioned conditions are met, i.e. the  [2.x.370]  ith face is on a   nonperiodic boundary, an exception will be thrown.  
* [0.x.351]*
   Return an iterator to the periodic neighbor of the cell at a given   face and subface number. The general guidelines for using this function   is similar to the function neighbor_child_on_subface(). The   implementation of this function is consistent with   periodic_neighbor_of_coarser_periodic_neighbor(). For instance,   assume that we are sitting on a cell named  [2.x.371]  cell1, whose neighbor behind   the  [2.x.372]  ith face is one level coarser. Let us name this coarser neighbor    [2.x.373]  cell2. Then, by calling   periodic_neighbor_of_coarser_periodic_neighbor(), from  [2.x.374]  cell1, we get   a  [2.x.375]  face_num and a  [2.x.376]  subface_num. Now, if we call   periodic_neighbor_child_on_subface() from cell2, with the above face_num   and subface_num, we get an iterator to  [2.x.377]  cell1.  
* [0.x.352]*
   This function is a generalization of   periodic_neighbor_of_periodic_neighbor()   for those cells which have a coarser periodic neighbor. The returned   pair of numbers can be used in periodic_neighbor_child_on_subface()   to get back to the current cell. In other words, the following   assertion should be true, for a cell with coarser periodic neighbor:   cell->periodic_neighbor(i)->periodic_neighbor_child_on_subface(face_no,   subface_no)==cell  
* [0.x.353]*
   This function returns the index of the periodic neighbor at the    [2.x.378]  ith face of the current cell. If there is no periodic neighbor   at the given face, the returned value is
* 
*  - .  
* [0.x.354]*
   This function returns the level of the periodic neighbor at the    [2.x.379]  ith face of the current cell. If there is no periodic neighbor   at the given face, the returned value is
* 
*  - .  
* [0.x.355]*
   For a cell with a periodic neighbor at its  [2.x.380]  ith face, this function   returns the face number of that periodic neighbor such that the   current cell is the periodic neighbor of that neighbor. In other words   the following assertion holds for those cells which have a periodic   neighbor with the same or a higher level of refinement as the current   cell:    [2.x.381]  {cell->periodic_neighbor(i)->       periodic_neighbor(cell->periodic_neighbor_of_periodic_neighbor(i))==cell}   For the cells with a coarser periodic neighbor, one should use   periodic_neighbor_of_coarser_periodic_neighbor() and   periodic_neighbor_child_on_subface()   to get back to the current cell.  
* [0.x.356]*
   If a cell has a periodic neighbor at its  [2.x.382]  ith face, this function   returns the face number of the periodic neighbor, which is connected   to the  [2.x.383]  ith face of this cell.  
* [0.x.357]*
   This function returns true if the element on the other side of the   periodic boundary is coarser and returns false otherwise. The   implementation allows this function to work in the case of   anisotropic refinement.  
* [0.x.358]*
    [2.x.384]   
* [0.x.359]*
    [2.x.385]  Dealing with boundary indicators  
* [0.x.360]*
    [2.x.386]   
* [0.x.361]*
   Return whether the  [2.x.387]  vertex or face (depending on the dimension) is   part of the boundary. This is true, if the  [2.x.388]  neighbor does not   exist.  
* [0.x.362]*
   Return whether the cell is at the boundary. Being at the boundary is   defined by one face being on the boundary. Note that this does not catch   cases where only one vertex of a quad or of a hex is at the boundary, or   where only one line of a hex is at the boundary while the interiors of   all faces are in the interior of the domain. For the latter case, the  [2.x.389]    has_boundary_lines function is the right one to ask.  
* [0.x.363]*
   This is a slight variation to the  [2.x.390]  function: for 1 and 2   dimensions, it is equivalent, for three dimensions it returns whether at   least one of the 12 lines of the hexahedron is at a boundary. This, of   course, includes the case where a whole face is at the boundary, but also   some other cases.  
* [0.x.364]*
    [2.x.391]   
* [0.x.365]*
    [2.x.392]  Dealing with refinement indicators  
* [0.x.366]*
    [2.x.393]   
* [0.x.367]*
   Return the  [2.x.394]  this cell was flagged to be refined   with.  The return value of this function can be compared to a bool to   check if this cell is flagged for any kind of refinement. For example, if   you have previously called cell->set_refine_flag() for a cell, then you   will enter the 'if' block in the following snippet:    
* [1.x.4]
*   
* [0.x.368]*
   Flag the cell pointed to for refinement. This function is only allowed   for active cells. Keeping the default value for  [2.x.395]  will mark   this cell for isotropic refinement.     If you choose anisotropic refinement, for example by passing as argument   one of the flags  [2.x.396]   [2.x.397]     [2.x.398]  or a combination of these, then keep in mind   that refining in x-, y-, or z-direction happens with regard to the    [2.x.399] local [2.x.400]  coordinate system of the cell. In other words, these   flags determine which edges and faces of the cell will be cut into new   edges and faces. On the other hand, this process is independent of   how the cell is oriented within the  [2.x.401] global [2.x.402]  coordinate system,   and you should not assume any particular orientation of the cell's   local coordinate system within the global coordinate system of the   space it lives in.  
* [0.x.369]*
   Clear the refinement flag.  
* [0.x.370]*
   Modify the refinement flag of the cell to ensure (at least) the given   refinement case  [2.x.403]  at face <tt>face_no</tt>, taking   into account orientation, flip and rotation of the face. Return, whether   the refinement flag had to be modified. This function is only allowed for   active cells.  
* [0.x.371]*
   Modify the refinement flag of the cell to ensure that line   <tt>face_no</tt> will be refined. Return, whether the refinement flag had   to be modified. This function is only allowed for active cells.  
* [0.x.372]*
   Return the SubfaceCase of face <tt>face_no</tt>. Note that this is not   identical to asking <tt>cell->face(face_no)->refinement_case()</tt> since   the latter returns a RefinementCase<dim-1> and thus only considers one   (anisotropic) refinement, whereas this function considers the complete   refinement situation including possible refinement of the face's   children. This function may only be called for active cells in 2d and 3d.  
* [0.x.373]*
   Return whether the coarsen flag is set or not.  
* [0.x.374]*
   Flag the cell pointed to for coarsening. This function is only allowed   for active cells.  
* [0.x.375]*
   Clear the coarsen flag.  
* [0.x.376]*
    [2.x.404]   
* [0.x.377]*
    [2.x.405]  Dealing with material indicators  
* [0.x.378]*
    [2.x.406]   
* [0.x.379]*
   Return the material id of this cell.     For a typical use of this function, see the    [2.x.407]  " [2.x.408] "   tutorial program.     See the    [2.x.409]  "glossary"   for more information.  
* [0.x.380]*
   Set the material id of this cell.     For a typical use of this function, see the    [2.x.410]  " [2.x.411] "   tutorial program.     See the    [2.x.412]  "glossary"   for more information.  
* [0.x.381]*
   Set the material id of this cell and all its children (and grand-   children, and so on) to the given value.     See the    [2.x.413]  "glossary"   for more information.  
* [0.x.382]*
    [2.x.414]   
* [0.x.383]*
    [2.x.415]  Dealing with subdomain indicators  
* [0.x.384]*
    [2.x.416]   
* [0.x.385]*
   Return the subdomain id of this cell.     See the    [2.x.417]  "glossary"   for more information.    
*  [2.x.418]  The subdomain of a cell is a property only defined for active   cells, i.e., cells that are not further refined. Consequently, you can   only call this function if the cell it refers to has no children. For   multigrid methods in parallel, it is also important to know which   processor owns non-active cells, and for this you can call   level_subdomain_id().  
* [0.x.386]*
   Set the subdomain id of this cell.     See the    [2.x.419]  "glossary"   for more information. This function should not be called if you use a    [2.x.420]  object.    
*  [2.x.421]  The subdomain of a cell is a property only defined for active   cells, i.e., cells that are not further refined. Consequently, you can   only call this function if the cell it refers to has no children. For   multigrid methods in parallel, it is also important to know which   processor owns non-active cells, and for this you can call   level_subdomain_id().  
* [0.x.387]*
   Get the level subdomain id of this cell. This is used for parallel   multigrid where not only the global mesh (consisting of the active cells)   is partitioned among processors, but also the individual levels of the   hierarchy of recursively refined cells that make up the mesh. In   other words, the level subdomain id is a property that is also defined   for non-active cells if a multigrid hierarchy is used.  
* [0.x.388]*
   Set the level subdomain id of this cell. This is used for parallel   multigrid.  
* [0.x.389]*
   Set the subdomain id of this cell (if it is active) or all its terminal   children (and grand-children, and so on, as long as they have no children   of their own) to the given value. Since the subdomain id is a concept   that is only defined for cells that are active (i.e., have no children of   their own), this function only sets the subdomain ids for all children   and grand children of this cell that are actually active, skipping   intermediate child cells.     See the    [2.x.422]  "glossary"   for more information. This function should not be called if you use a    [2.x.423]  object since there the subdomain id   is implicitly defined by which processor you're on.  
* [0.x.390]*
    [2.x.424]   
* [0.x.391]*
   Return a globally unique cell index for the current cell,   assuming it is not artificial. The value is identical to   active_cell_index() if the cell is part of a serial   triangulation.     In the context of parallel triangulations, locally-owned cells   are enumerated contiguously within each subdomain of the   mesh. This ensures that the index returned by this function can   be used as the index into vectors with a total of    [2.x.425]  entries, and for which   every process stores a contiguous part.  If such a cell-data   vector has been set up with    [2.x.426]    the index returned by this function can then be used to access   the correct vector entry.  
* [0.x.392]*
   Return a globally unique index for a non-artificial level cell.    
*  [2.x.427]  Similar to global_active_cell_index().  
* [0.x.393]*
    [2.x.428]  Dealing with codim 1 cell orientation  
* [0.x.394]*
    [2.x.429]   
* [0.x.395]*
   Return the orientation of this cell.     For the meaning of this flag, see    [2.x.430] .  
* [0.x.396]*
   Return the how many-th active cell the current cell is (assuming the   current cell is indeed active). This is useful, for example, if you are   accessing the elements of a vector with as many entries as there are   active cells. Such vectors are used for estimating the error on each cell   of a triangulation, for specifying refinement criteria passed to the   functions in GridRefinement, and for generating cell-wise output.     The function throws an exception if the current cell is not active.    
*  [2.x.431]  If the triangulation this function is called on is of type    [2.x.432]  then active cells may be locally   owned, ghost cells, or artificial (see    [2.x.433] ,    [2.x.434] ,   and    [2.x.435] ).   This function counts over all of them, including ghost and artificial   active cells. This implies that the index returned by this function   uniquely identifies a cell within the triangulation on a single   processor, but does not uniquely identify the cell among the (parts of   the) triangulation that is shared among processors. If you would like to   identify active cells across processors, you need to consider the CellId   of a cell returned by  [2.x.436]   
* [0.x.397]*
   Return the index of the parent of this cell within the level of the   triangulation to which the parent cell belongs. The level of the parent   is of course one lower than that of the present cell. If the parent does   not exist (i.e., if the object is at the coarsest level of the mesh   hierarchy), an exception is generated.  
* [0.x.398]*
   Return an iterator to the parent. If the parent does not exist (i.e., if   the object is at the coarsest level of the mesh hierarchy), an exception   is generated.  
* [0.x.399]*
    [2.x.437]   
* [0.x.400]*
    [2.x.438]  Other functions  
* [0.x.401]*
    [2.x.439]   
* [0.x.402]*
   Test that the cell has no children (this is the criterion for whether a   cell is called "active").     See the    [2.x.440]  "glossary"   for more information.  
* [0.x.403]*
   Return whether this cell is owned by the current processor or is owned by   another processor. The function always returns true if applied to an   object of type  [2.x.441]  but may yield false if the   triangulation is of type  [2.x.442]      See the    [2.x.443]  "glossary"   and the    [2.x.444]    module for more information.      [2.x.445]  The returned value is equal to <code>!is_ghost() &&   !is_artificial()</code>.    
*  [2.x.446]  Whether a cell is a ghost cell, artificial, or is locally owned or   is a property that only pertains to cells that are active. Consequently,   you can only call this function if the cell it refers to has no children.  
* [0.x.404]*
   Return true if either the Triangulation is not distributed or if   level_subdomain_id() is equal to the id of the current processor.  
* [0.x.405]*
   Return whether this cell exists in the global mesh but (i) is owned by   another processor, i.e. has a subdomain_id different from the one the   current processor owns and (ii) is adjacent to a cell owned by the   current processor.     This function only makes sense if the triangulation used is of kind    [2.x.447]  In all other cases, the returned   value is always false.     See the    [2.x.448]  "glossary"   and the    [2.x.449]    module for more information.      [2.x.450]  The returned value is equal to <code>!is_locally_owned() &&   !is_artificial()</code>.    
*  [2.x.451]  Whether a cell is a ghost cell, artificial, or is locally owned or   is a property that only pertains to cells that are active. Consequently,   you can only call this function if the cell it refers to has no children.  
* [0.x.406]*
   Return whether this cell is artificial, i.e. it isn't one of the cells   owned by the current processor, and it also doesn't border on one. As a   consequence, it exists in the mesh to ensure that each processor has all   coarse mesh cells and that the 2:1 ratio of neighboring cells is   maintained, but it is not one of the cells we should work on on the   current processor. In particular, there is no guarantee that this cell   isn't, in fact, further refined on one of the other processors.     This function only makes sense if the triangulation used is of kind    [2.x.452]  In all other cases, the returned   value is always false.     See the    [2.x.453]  "glossary"   and the    [2.x.454]    module for more information.      [2.x.455]  The returned value is equal to <code>!is_ghost() &&   !is_locally_owned()</code>.    
*  [2.x.456]  Whether a cell is a ghost cell, artificial, or is locally owned is   a property that only pertains to cells that are active. Consequently, you   can only call this function if the cell it refers to has no children.  
* [0.x.407]*
   Test whether the point  [2.x.457]  is inside this cell. Points on the boundary   are counted as being inside the cell.     Note that this function assumes that the mapping between unit cell and   real cell is (bi-, tri-)linear, i.e. that faces in 2d and edges in 3d are   straight lines. If you have higher order transformations, results may be   different as to whether a point is in- or outside the cell in real space.     In case of codim>0, the point is first projected to the manifold where   the cell is embedded and then check if this projection is inside the   cell.  
* [0.x.408]*
   Set the neighbor  [2.x.458]  of this cell to the cell pointed to by  [2.x.459]      This function shouldn't really be public (but needs to for various   reasons in order not to make a long list of functions friends): it   modifies internal data structures and may leave things. Do not use it   from application codes.  
* [0.x.409]*
   Return a unique ID for the current cell. This ID is constructed from the   path in the hierarchy from the coarse father cell and works correctly in   parallel computations using objects of type    [2.x.460]  This function is therefore useful   in providing a unique identifier for cells (active or not) that also   works for parallel triangulations. See the documentation of the CellId   class for more information.    
*  [2.x.461]  This operation takes O(level) time to compute. In most practical   cases, the number of levels of a triangulation will depend   logarithmically on the number of cells in the triangulation.  
* [0.x.410]*
   The same as  [2.x.462]  but also taking a Mapping class.  
* [0.x.411]*
    [2.x.463]   
* [0.x.412]*
  
*  [2.x.464]   
* [0.x.413]*
  
*  [2.x.465]   
* [0.x.414]*
  
*  [2.x.466]   
* [0.x.415]*
   This function assumes that the neighbor is not coarser than the current   cell. In this case it returns the neighbor_of_neighbor() value. If,   however, the neighbor is coarser this function returns an    [2.x.467] .     This function is not for public use. Use the function   neighbor_of_neighbor() instead which throws an exception if called for a   coarser neighbor. If neighbor is indeed coarser (you get to know this by   e.g. the neighbor_is_coarser() function) then the   neighbor_of_coarser_neighbor() function should be call. If you'd like to   know only the  [2.x.468]  which is required to get back from the   neighbor to the present cell then simply use the neighbor_face_no()   function which can be used for coarser as well as non-coarser neighbors.  
* [0.x.416]*
   As for any codim>0 we can use a similar code and c++ does not allow   partial templates. we use this auxiliary function that is then called   from point_inside.  
* [0.x.417]*
   Set the active cell index of a cell. This is done at the end of   refinement.  
* [0.x.418]*
   Set global active cell index for a cell.  
* [0.x.419]*
   Set global level cell index for a level cell.  
* [0.x.420]*
   Set the parent of a cell.  
* [0.x.421]*
   Set the orientation of this cell.     For the meaning of this flag, see    [2.x.469] .  
* [0.x.422]

include/deal.II-translator/grid/tria_description_0.txt
[0.x.0]*
 The CellData class (and the related SubCellData class) is used to provide a comprehensive, but minimal, description of the cells when creating a triangulation via  [2.x.0]  Specifically, each CellData object
* 
*  -  describing one cell in a triangulation
* 
*  -  has member variables for indices of the  [2.x.1]  vertices (the actual coordinates of the vertices are described in a separate vector passed to  [2.x.2]  so the CellData object only needs to store indices into that vector), the material id of the cell that can be used in applications to describe which part of the domain a cell belongs to (see  [2.x.3]  "the glossary entry on material ids"), and a manifold id that is used to describe the geometry object that is responsible for this cell (see  [2.x.4]  "the glossary entry on manifold ids") to describe the manifold this object belongs to.
*  This structure is also used to represent data for faces and edges when used as a member of the SubCellData class. In this case, the template argument  [2.x.5]  of an object will be less than the dimension  [2.x.6]  of the triangulation. If this is so, then #vertices array represents the indices of the vertices of one face or edge of one of the cells passed to  [2.x.7]  Furthermore, for faces the material id has no meaning, and the  [2.x.8]  field is reused to store a  [2.x.9]  instead to designate which part of the boundary the face or edge belongs to (see  [2.x.10]  "the glossary entry on boundary ids").
*  An example showing how this class can be used is in the  [2.x.11]  function of  [2.x.12] . There are also many more use cases in the implementation of the functions of the GridGenerator namespace.
* 

* 
*  [2.x.13] 

* 
* [0.x.1]*
   Indices of the vertices of this cell. These indices correspond   to entries in the vector of vertex locations passed to    [2.x.14]   
* [0.x.2]*
   Material or boundary indicator of this cell.   This field is a union that stores [1.x.0] a boundary or   a material id, depending on whether the current object is used   to describe a cell (in a vector of CellData objects) or a   face or edge (as part of a SubCellData object).  
* [0.x.3]*
     The material id of the cell being described. See the documentation     of the CellData class for examples of how to use this field.         This variable can only be used if the current object is used to     describe a cell, i.e., if  [2.x.15]  equals the dimension      [2.x.16]  of a triangulation.    
* [0.x.4]*
     The boundary id of a face or edge being described. See the documentation     of the CellData class for examples of how to use this field.         This variable can only be used if the current object is used to     describe a face or edge, i.e., if  [2.x.17]  is less than the dimension      [2.x.18]  of a triangulation. In this case, the CellData object this     variable belongs to will be part of a SubCellData object.    
* [0.x.5]*
   Manifold identifier of this object. This identifier should be used to   identify the manifold to which this object belongs, and from which this   object will collect information on how to add points upon refinement.     See the documentation of the CellData class for examples of how to use   this field.  
* [0.x.6]*
   Default constructor. Sets the member variables to the following values:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - vertex indices to invalid values
* 

* 
* 

* 
* 

* 
* 
*  - boundary or material id zero (the default for boundary or material ids)
* 

* 
* 

* 
* 

* 
* 
*  - manifold id to  [2.x.19]   
* [0.x.7]*
   Comparison operator.  
* [0.x.8]*
   Read or write the data of this object to or from a stream for the   purpose of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.9]*
 The SubCellData class is used to describe information about faces and edges at the boundary of a mesh when creating a triangulation via  [2.x.20]  It contains member variables that describe boundary edges and boundary quads.
*  The class has no template argument and is used both in the description of boundary edges in 2d (in which case the contents of the  [2.x.21]  member variable are ignored), as well as in the description of boundary edges and faces in 3d (in which case both the  [2.x.22]  and  [2.x.23]  members may be used). It is also used as the argument to  [2.x.24]  in 1d, where the contents of objects of the current type are simply ignored.
*  By default,  [2.x.25]  simply assigns default boundary indicators and manifold indicators to edges and quads at the boundary of the mesh. (See the glossary entries on  [2.x.26]  "boundary ids" and  [2.x.27]  "manifold ids" for more information on what they represent.) As a consequence, it is not [1.x.1] to explicitly describe the properties of boundary objects. In all cases, these properties can also be set at a later time, once the triangulation has already been created. On the other hand, it is sometimes convenient to describe boundary indicators or manifold ids at the time of creation. In these cases, the current class can be used by filling the  [2.x.28]  and  [2.x.29]  vectors with CellData<1> and CellData<2> objects that correspond to boundary edges and quads for which properties other than the default values should be used.
*  Each entry in the  [2.x.30]  and  [2.x.31]  vectors then needs to correspond to an edge or quad of the cells that are described by the vector of CellData objects passed to  [2.x.32]  I.e., the vertex indices stored in each entry need to correspond to an edge or face of the triangulation that has the same set of vertex indices, and in the same order. For these boundary edges or quads, one can then set either or both the  [2.x.33]  and  [2.x.34] 
*  There are also use cases where one may want to set the manifold id of an [1.x.2] edge or face. Such faces, identified by their vertex indices, may also appear in the  [2.x.35]  and  [2.x.36]  vectors (despite the names of these member variables). However, it is then obviously not allowed to set a boundary id (because the object is not actually part of the boundary). As a consequence, to be valid, the  [2.x.37]  of interior edges or faces needs to equal  [2.x.38] 
* 

* 
*  [2.x.39] 

* 
* [0.x.10]*
   A vector of CellData<1> objects that describe boundary and manifold   information for edges of 2d or 3d triangulations.     This vector may not be used in the creation of 1d triangulations.  
* [0.x.11]*
   A vector of CellData<2> objects that describe boundary and manifold   information for quads of 3d triangulations.     This vector may not be used in the creation of 1d or 2d triangulations.  
* [0.x.12]*
   Determine whether the member variables above which may not be used in a   given dimension are really empty. In other words, this function returns   whether   both  [2.x.40]  and  [2.x.41]  are empty vectors   when  [2.x.42]  equals one, and whether the  [2.x.43]    vector is empty when  [2.x.44]  equals two.  
* [0.x.13]*
 A namespace dedicated to the struct Description, which can be used in  [2.x.45] 

* 
* [0.x.14]*
   Configuration flags for Triangulations.   Settings can be combined using bitwise OR.  
* [0.x.15]*
     Default settings, other options are disabled.    
* [0.x.16]*
     This flag needs to be set to use the geometric multigrid     functionality. This option requires additional computation and     communication.    
* [0.x.17]*
   Information needed for each locally relevant cell, stored in   Description and used during construction of a   Triangulation. This struct stores   the cell id, the subdomain_id and the level_subdomain_id as well as   information related to manifold_id and boundary_id.    
*  [2.x.46]  Similarly to  [2.x.47]  this structure stores information   about a cell. However, in contrast to  [2.x.48]  it also stores   a unique id, partitioning information, and information related to cell   faces and edges.  
* [0.x.18]*
     Read or write the data of this object to or from a stream for the     purpose of serialization using the [BOOST serialization     library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).    
* [0.x.19]*
     Comparison operator.    
* [0.x.20]*
     Unique CellID of the cell.    
* [0.x.21]*
     subdomain_id of the cell.    
* [0.x.22]*
     level_subdomain_id of the cell.    
* [0.x.23]*
     Manifold id of the cell.    
* [0.x.24]*
     Manifold id of all lines of the cell.        
*  [2.x.49]  Only used for 2D and 3D.    
* [0.x.25]*
     Manifold id of all face quads of the cell.        
*  [2.x.50]  Only used for 3D.    
* [0.x.26]*
     List of face number and boundary id of all non-internal faces of the     cell.    
* [0.x.27]*
   Data used in  [2.x.51]   
* [0.x.28]*
     Read or write the data of this object to or from a stream for the     purpose of serialization using the [BOOST serialization     library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).    
* [0.x.29]*
     Comparison operator.    
* [0.x.30]*
     Cells of the locally-relevant coarse-grid triangulation.    
* [0.x.31]*
     Vertices of the locally-relevant coarse-grid triangulation.    
* [0.x.32]*
     List that for each locally-relevant coarse cell provides the     corresponding global      [2.x.52] .    
* [0.x.33]*
     CellData for each locally relevant cell on each level. cell_infos[i]     contains the CellData for each locally relevant cell on the ith     level.    
* [0.x.34]*
     The MPI communicator used to create this struct. It will be compared     to the communicator inside of the Triangulation     and an assert is thrown if they do not match.        
*  [2.x.53]  Please note this is necessary since the communicator inside of      [2.x.54]  is const and cannot be changed after the     constructor has been called.    
* [0.x.35]*
     Properties to be use in the construction of the triangulation.    
* [0.x.36]*
     Mesh smoothing type.    
* [0.x.37]*
   A namespace for  [2.x.55]  utility functions.    
*  [2.x.56]   
* [0.x.38]*
     Construct  [2.x.57]  from a given     partitioned triangulation `tria` and a specified process.     The input triangulation can be either     a serial triangulation of type  [2.x.58]  which has been     colored (subdomain_id and/or level_subdomain_id has been set) or a     distributed triangulation of type      [2.x.59]  where the partitioning is     adopted unaltered.          [2.x.60]  tria Partitioned input triangulation.      [2.x.61]  comm MPI_Communicator to be used. In the case       of  [2.x.62]  the communicators have     to match.      [2.x.63]  settings See the description of the Settings enumerator.      [2.x.64]  my_rank_in Construct Description for the specified rank (only       working for serial triangulations that have been partitioned by       functions like  [2.x.65]       [2.x.66]  Description to be used to set up a Triangulation.        
*  [2.x.67]  If construct_multigrid_hierarchy is set in the settings, the source       triangulation has to be setup with limit_level_difference_at_vertices.    
* [0.x.39]*
     Similar to the above function but the owner of active cells are provided     by a cell vector (see also      [2.x.68]  and      [2.x.69]  This function allows to     repartition distributed Triangulation objects.        
*  [2.x.70]  The communicator is extracted from the vector  [2.x.71]         
*  [2.x.72]  The triangulation  [2.x.73]  can be set up on a subcommunicator of the       communicator of  [2.x.74]  All processes that are not part of that       subcommunicator need to set up the local triangulation with the       special-purpose communicator MPI_COMM_NULL.        
*  [2.x.75]  The multgrid levels are currently not constructed, since        [2.x.76]  only describes the partitioning of the active level.    
* [0.x.40]*
     Construct a  [2.x.77]  In contrast     to the function above, this function is also responsible for creating     a serial triangulation and for its partitioning (by calling the     provided  [2.x.78]  objects). Internally only selected processes (     every n-th/each root of a group of size group_size) create a serial     triangulation and the  [2.x.79]  for all     processes in its group, which is communicated.        
*  [2.x.80]  A reasonable group size is the size of a NUMA domain or the     size of a compute node.          [2.x.81]  serial_grid_generator A function which creates a serial triangulation.      [2.x.82]  serial_grid_partitioner A function which can partition a serial       triangulation, i.e., sets the sudomain_ids of the active cells.       The function takes as the first argument a serial triangulation,       as the second argument the MPI communicator, and as the third       argument the group size.      [2.x.83]  comm MPI communicator.      [2.x.84]  group_size The size of each group.      [2.x.85]  smoothing Mesh smoothing type.      [2.x.86]  setting See the description of the Settings enumerator.      [2.x.87]  Description to be used to set up a Triangulation.        
*  [2.x.88]  If construct_multigrid_hierarchy is set in the settings, the        [2.x.89]  parameter is extended with the       limit_level_difference_at_vertices flag.    
* [0.x.41]

include/deal.II-translator/grid/tria_faces_0.txt
[0.x.0]*
     This class contains information belonging to the faces of a     triangulation. These classes are similar to the TriaLevel classes. As     cells are organised in a hierarchical structure of levels, each     triangulation consists of several such TriaLevels. However the faces of     a triangulation, lower dimensional objects like lines in 2D or lines     and quads in 3D, do not have to be based on such a hierarchical     structure. In fact we have to organise them in only one object if we     want to enable anisotropic refinement. Therefore the TriaFaces classes     store the information belonging to the faces of a triangulation     separately from the TriaLevel classes.    
* [0.x.1]*
       Constructor.      
* [0.x.2]*
       Default constructor for  [2.x.0]       
* [0.x.3]*
       Dimension of the underlying triangulation.      
* [0.x.4]*
       The TriaObject containing the data of quads.            
*  [2.x.1]  Used only for dim=3.      
* [0.x.5]*
       Orientation of each line of each quad.            
*  [2.x.2]  Used only for dim=3.      
* [0.x.6]*
       Reference cell type of each quad.            
*  [2.x.3]  Used only for dim=3.      
* [0.x.7]*
       The TriaObject containing the data of lines.            
*  [2.x.4]  Used only for dim>1.      
* [0.x.8]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.9]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.10]

include/deal.II-translator/grid/tria_iterator.templates_0.txt
[0.x.0] Note: This file only contains template definitions and will thus   not produce an object file. It is rather thought to be included   into the_accessor.cc files.
* [0.x.1]

include/deal.II-translator/grid/tria_iterator_0.txt
[0.x.0]*
 This class implements an iterator, analogous to those used in the standard library. It fulfills the requirements of a bidirectional iterator. See the C++ documentation for further details of iterator specification and usage.
* 

*  In addition to the standard interface, an iterator of this class provides a <tt>- [2.x.0]  operator, i.e. you can write statements like

* 
* [1.x.0]
* 
*  Iterators are used whenever a loop over all lines, quads, cells etc. is to be performed. These loops can then be coded like this:

* 
* [1.x.1]
* 
*  Note the usage of <tt>++cell</tt> instead of <tt>cell++</tt> since this does not involve temporaries and copying. It is recommended to use a fixed value <tt>end</tt> inside the loop instead of <tt>tria.end()</tt>, since the creation and copying of these iterators is rather expensive compared to normal pointers.
*  The objects pointed to are accessors, derived from TriaAccessorBase. Which kind of accessor is determined by the template argument  [2.x.1] Accessor [2.x.2] . These accessors are not so much data structures as they are a collection of functions providing access to the data stored in Triangulation or DoFHandler objects. Using these accessors, the structure of these classes is hidden from the application program.
*  [1.x.2]
*   [2.x.3]  Application programs will rarely use TriaRawIterator, but rather one of the derived classes TriaIterator or TriaActiveIterator.
*   [2.x.4]   [2.x.5]  TriaRawIterator objects point to lines, cells, etc in the lists whether they are used or not (in the vectors, also [1.x.3] objects are stored, since deletion in vectors is expensive and we also do not want to destroy the ordering induced by the numbering in the vectors). Therefore not all raw iterators point to valid objects.
*   [2.x.6]  The derived class TriaIterator selects the valid cells, that is, cells used somewhere in the triangulation hierarchy.
*   [2.x.7]  TriaActiveIterator objects which only loop over active cells.  [2.x.8] 
*  [1.x.4]
*  Iterators are not much slower than operating directly on the data structures, since they perform the loops that you had to handcode yourself anyway. Most iterator and accessor functions are inlined.
*  The main functionality of iterators, resides in the <tt>++</tt> and <tt>\--</tt> operators. These move the iterator forward or backward just as if it were a pointer into an array. Here, this operation is not so easy, since it may include skipping some elements and the transition between the triangulation levels. This is completely hidden from the user, though you can still create an iterator pointing to an arbitrary element.  Actually, the operation of moving iterators back and forth is not done in the iterator classes, but rather in the accessor classes. Since these are passed as template arguments, you can write your own versions here to add more functionality.
*  Furthermore, the iterators described here satisfy the requirement of input and bidirectional iterators as stated by the C++ standard. It is therefore possible to use the functions from the algorithm section of the C++ standard, e.g.,  [2.x.9] count_if [2.x.10]  (see the documentation for Triangulation for an example) and several others.
*  [1.x.5]
*  The iterator class itself does not have much functionality. It only becomes useful when assigned an Accessor (the second template parameter), which really does the access to data. An Accessor has to fulfill some requirements:
*   [2.x.11]   [2.x.12]  It must have two members named <tt>present_level</tt> and <tt>present_index</tt> storing the address of the element in the triangulation presently pointed to. These data have to be accessible by all triangulation iterators listed above.
*   [2.x.13]  It must have a constructor which takes a Triangulation* and two unsigned integers, denoting the initial level and index, as well as a data object depending on its type.
*   [2.x.14]  For the TriaIterator and the TriaActiveIterator class, it must have a member function <tt>bool used()</tt>, for the latter a member function <tt>bool active()</tt>.
*   [2.x.15]  It must have void operators <tt>++</tt> and <tt>\--</tt>.
*   [2.x.16]  It must declare a local alias <tt>AccessorData</tt> which states the data type the accessor expects to get passed as fourth constructor argument. By declaring a local data type, the respective iterator class may type-safely enforce that data type to be one of its own constructor argument types. If an accessor class does not need additional data, this type shall be <tt>void</tt>.  [2.x.17] 
*  Then the iterator is able to do what it is supposed to. All of the necessary functions are implemented in the <tt>Accessor</tt> base class, but you may write your own version (non-virtual, since we use templates) to add functionality.
*  The accessors provided by the library consist of two groups, determined by whether they access the data of Triangulation objects or DoFHandler objects. They are derived from TriaAccessor and DoFAccessor, respectively. Each group also has specialized accessors for cells (as opposed to faces and lines) that offer more functionality such as accessing neighbors.
*   [2.x.18]  It seems impossible to preserve constness of a triangulation through iterator usage. Thus, if you declare pointers to a <tt>const</tt> triangulation object, you should be well aware that you might involuntarily alter the data stored in the triangulation.
* 

* 
*  [2.x.19]  More information on valid and invalid iterators can be found in the documentation of TriaAccessorBase, where the iterator states are checked and implemented.
* 

*  [1.x.6]
*  There is a representation of past-the-end-pointers, denoted by special values of the member variables  [2.x.20]  and  [2.x.21]  If <tt>present_level>=0</tt> and <tt>present_index>=0</tt>, then the object is valid (there is no check whether the triangulation really has that many levels or that many cells on the present level when we investigate the state of an iterator; however, in many places where an iterator is dereferenced we make this check); if <tt>present_level==-1</tt> and <tt>present_index==-1</tt>, then the iterator points past the end; in all other cases, the iterator is considered invalid. You can check this by calling the <tt>state()</tt> function.
*  An iterator is also invalid, if the pointer pointing to the Triangulation object is invalid or zero.
*  Finally, an iterator is invalid, if the element pointed to by  [2.x.22]  present_level and  [2.x.23]  is not used, i.e. if the  [2.x.24]  flag is set to false.
*  The last two checks are not made in <tt>state()</tt> since both cases should only occur upon uninitialized construction through  [2.x.25]  and the like (the parent triangulation can only be set upon construction). If an iterator is constructed empty through the empty constructor, <tt>present_level==-2</tt> and <tt>present_index==-2</tt>. Thus, the iterator is invalid anyway, regardless of the state of the triangulation pointer and the state of the element pointed to.
*  Past-the-end iterators may also be used to compare an iterator with the [1.x.7] value, when running backwards. There is no distinction between the iterators pointing past the two ends of a vector.
*  By defining only one value to be past-the-end and making all other values invalid provides a second track of security: if we should have forgotten a check in the library when an iterator is incremented or decremented, we automatically convert the iterator from the allowed state "past-the-end" to the disallowed state "invalid" which increases the chance that some time earlier than for past-the-end iterators an exception is raised.
*   [2.x.26] 

* 
*  [2.x.27] 

* 
*  [2.x.28] 

* 
* [0.x.1]*
   Declare the type of the Accessor for use in the outside world. This way   other functions can use the Accessor's type without knowledge of how the   exact implementation actually is.  
* [0.x.2]*
   Default constructor. This constructor creates an iterator pointing   to an invalid object. The iterator is consequently not usable.  
* [0.x.3]*
   Copy constructor.  
* [0.x.4]*
   Construct an iterator from the given accessor; the given accessor needs   not be of the same type as the accessor of this class is, but it needs to   be convertible.     Through this constructor, it is also possible to construct objects for   derived iterators:  
* [1.x.8]
*   
* [0.x.5]*
   Constructor. Assumes that the other accessor type is convertible to the   current one.  
* [0.x.6]*
   Proper constructor, initialized with the triangulation, the level and   index of the object pointed to. The last parameter is of a type declared   by the accessor class.  
* [0.x.7]*
   This is a conversion operator (constructor) which takes another iterator   type and copies the data; this conversion works, if there is a conversion   path from the  [2.x.29]  class to the  [2.x.30]  class of this   object. One such path would be derived class to base class, which for   example may be used to get a  [2.x.31]  from a    [2.x.32]  since the DoFAccessor class is derived   from the TriaAccessorBase class.  
* [0.x.8]*
   Another conversion operator, where we use the pointers to the   Triangulation from a TriaAccessorBase object, while the additional data   is used according to the actual type of Accessor.  
* [0.x.9]*
   Conversion constructor. Same as above with the difference that it   converts from TriaIterator classes (not TriaRawIterator).  
* [0.x.10]*
   Conversion constructor. Same as above with the difference that it   converts from TriaActiveIterator classes (not TriaRawIterator).  
* [0.x.11]*
    [2.x.33]  Dereferencing  
* [0.x.12]*
   Dereferencing operator, returns a reference to an accessor. Usage is thus   like <tt>(*i).index ();</tt>     This function has to be specialized explicitly for the different  [2.x.34]    Pointees, to allow an    [2.x.35]  to point to   <tt>tria->lines.cells[index]</tt> while for one dimension higher it has   to point to <tt>tria->quads.cells[index]</tt>.     You must not dereference invalid or past the end iterators.  
* [0.x.13]*
   Dereferencing operator, non- [2.x.36]  version.  
* [0.x.14]*
   Dereferencing operator, returns a reference of the cell pointed to. Usage   is thus like <tt>i->index ();</tt>     There is a  [2.x.37]  and a non- [2.x.38]  version.  
* [0.x.15]*
   Dereferencing operator, non- [2.x.39]  version.  
* [0.x.16]*
   In order be able to assign end-iterators for different accessors to each   other, we need an access function which returns the accessor regardless   of its state.      [2.x.40]  This function should not be used in application programs. It is   only intended for limited purposes inside the library and it makes   debugging much harder.  
* [0.x.17]*
   Assignment operator.  
* [0.x.18]*
   Compare for equality.  
* [0.x.19]*
   Compare for inequality.  
* [0.x.20]*
   Ordering relation for iterators.     This relation attempts a total ordering of cells.     The relation is defined as follows:     For objects of  [2.x.41]  <    [2.x.42]  we simply compare the index of such an object.   The ordering is lexicographic according to the following hierarchy (in   the sense, that the next test is only applied if the previous was   inconclusive):      [2.x.43]     [2.x.44]  The past-the-end iterator is always ordered last. Two past-the-end   iterators rank the same, thus false is returned in that case. [2.x.45]       [2.x.46]  The level of the cell. [2.x.47]     [2.x.48]  The index of a cell inside the level. [2.x.49]     [2.x.50]     
*  [2.x.51]  The ordering is not consistent between different processor in a    [2.x.52]  because we rely on index(), which is   likely not the same.  
* [0.x.21]*
   Another comparison operator, implementing with the same ordering as   #operator<.  
* [0.x.22]*
    [2.x.53]  Advancement of iterators  
* [0.x.23]*
   Prefix <tt>++</tt> operator: <tt>++iterator</tt>. This operator advances   the iterator to the next element and returns a reference to   <tt>*this</tt>.  
* [0.x.24]*
   Postfix <tt>++</tt> operator: <tt>iterator++</tt>. This operator advances   the iterator to the next element, but returns an iterator to the element   previously pointed to.     Since this operation involves a temporary and a copy operation and since   an  [2.x.54]  is quite a large object for a pointer, use the prefix   operator <tt>++iterator</tt> whenever possible, especially in the header   of for loops (<tt>for (; iterator!=end; ++iterator)</tt>) since there you   normally never need the returned value.  
* [0.x.25]*
   Prefix  [2.x.55]  operator:  [2.x.56]  This operator moves the iterator to   the previous element and returns a reference to <tt>*this</tt>.  
* [0.x.26]*
   Postfix  [2.x.57]  operator:  [2.x.58]  This operator moves the iterator   to the previous element, but returns an iterator to the element   previously pointed to.     The same applies as for the postfix operator++: If possible, avoid it by   using the prefix operator form to avoid the use of a temporary variable.  
* [0.x.27]*
   Return the state of the iterator.  
* [0.x.28]*
   Print the iterator to a stream  [2.x.59] . The format is   <tt>level.index</tt>.  
* [0.x.29]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.30]*
   Mark the class as bidirectional iterator and declare some alias which   are standard for iterators and are used by algorithms to enquire about the   specifics of the iterators they work on.  
* [0.x.31]*
    [2.x.60]  Exceptions  
* [0.x.32]*
   Exception for TriaObjects with level, i.e. cells.  
* [0.x.33]*
   Exception.  
* [0.x.34]*
   Exception  
* [0.x.35]*
   Exception  
* [0.x.36]*
   Object holding the real data.  
* [0.x.37]*
 This specialization of TriaRawIterator provides access only to the  [2.x.61] used [2.x.62]  lines, quads, cells, etc.
* 

* 
*  [2.x.63] 

* 
*  [2.x.64] 

* 
* [0.x.38]*
   Default constructor. This constructor creates an iterator pointing   to an invalid object. The iterator is consequently not usable.  
* [0.x.39]*
   Copy constructor.  
* [0.x.40]*
   Conversion constructor from iterators potentially pointing to non-active   objects (i.e., for objects for which we can't tell that the object is   used just by looking at its type).      [2.x.65]  The argument passed to this constructor must either be     (i) a past-the-end iterator; or (ii) it must point to     a used object. All other cases will result in an exception.  
* [0.x.41]*
   Constructor, initialized with the triangulation, the level and   index of the object pointed to. The last parameter is of a type declared   by the accessor class.      [2.x.66]  The argument passed to this constructor must either be     (i) a past-the-end iterator; or (ii) it must point to     a used object. All other cases will result in an exception.  
* [0.x.42]*
   Construct from an accessor of type OtherAccessor that is convertible to   the type Accessor.  
* [0.x.43]*
   This is a conversion operator (constructor) which takes another iterator   type and copies the data; this conversion works, if there is a conversion   path from the  [2.x.67]  class to the  [2.x.68]  class of this   object. One such path would be derived class to base class, which for   example may be used to get a  [2.x.69]  from a    [2.x.70]  since the DoFAccessor class is derived from   the TriaAccessorBase class.  
* [0.x.44]*
   Another conversion operator, where we use the pointers to the   Triangulation from a TriaAccessorBase object, while the additional data   is used according to the actual type of Accessor.  
* [0.x.45]*
   Similar conversion operator to the above one, but does a check whether   the iterator points to a used element, which is necessary for raw   iterators.  
* [0.x.46]*
   Similar conversion operator to the above one, but for conversion from   active iterators.  
* [0.x.47]*
   Assignment operator.  
* [0.x.48]*
   Cross assignment operator. This assignment is only valid if the given   iterator points to a used element.  
* [0.x.49]*
   Assignment operator. Requires, that Accessor can be copied from   OtherAccessor.  
* [0.x.50]*
   Cross assignment operator. This assignment is only valid if the given   iterator points to a used element. Requires, that Accessor can be copied   from OtherAccessor.  
* [0.x.51]*
    [2.x.71]  Advancement of iterators  
* [0.x.52]*
   Prefix <tt>++</tt> operator: <tt>++i</tt>. This operator advances the   iterator to the next used element and returns a reference to   <tt>*this</tt>.  
* [0.x.53]*
   Postfix <tt>++</tt> operator: <tt>i++</tt>. This operator advances the   iterator to the next used element, but returns an iterator to the element   previously pointed to. Since this involves a temporary and a copy   operation and since an  [2.x.72]  is quite a large object for a   pointer, use the prefix operator <tt>++i</tt> whenever possible,   especially in the head of for loops (<tt>for (; i!=end; ++i)</tt>) since   there you normally never need the returned value.  
* [0.x.54]*
   Prefix  [2.x.73]  operator:  [2.x.74]  This operator advances the iterator to the   previous used element and returns a reference to <tt>*this</tt>.  
* [0.x.55]*
   Postfix  [2.x.75]  operator:  [2.x.76]   
* [0.x.56]*
   Declare some aliases which are standard for iterators and are used   by algorithms to enquire about the specifics of the iterators they   work on.  
* [0.x.57]*
   Exception  
* [0.x.58]*
 This specialization of TriaIterator provides access only to the  [2.x.77] active [2.x.78]  lines, quads, cells, etc. An active cell is a cell which is not refined and thus a cell on which calculations on the finest level are done.
* 

* 
*  [2.x.79] 

* 
*  [2.x.80] 

* 
* [0.x.59]*
   Default constructor. This constructor creates an iterator pointing   to an invalid object. The iterator is consequently not usable.  
* [0.x.60]*
   Copy constructor.  
* [0.x.61]*
   Conversion constructor creating an active iterator from an iterators   pointing to a potentially non-active object (or at least from which   it is not apparent from the type alone that it is active).      [2.x.81]  The argument passed to this constructor must either be     (i) a past-the-end iterator; or (ii) it must point to     an active object. All other cases will result in an exception.  
* [0.x.62]*
   Conversion constructor creating an active iterator from an iterators   pointing to a potentially non-active object (or at least from which   it is not apparent from the type alone that it is active).      [2.x.82]  The argument passed to this constructor must either be     (i) a past-the-end iterator; or (ii) it must point to     an active object. All other cases will result in an exception.  
* [0.x.63]*
   Constructor, initialized with the triangulation, the level and   index of the object pointed to. The last parameter is of a type declared   by the accessor class used by the current iterator.      [2.x.83]  The argument passed to this constructor must either be     (i) a past-the-end iterator; or (ii) it must point to     an active object. All other cases will result in an exception.  
* [0.x.64]*
   This is a conversion operator (constructor) which takes another iterator   type and copies the data; this conversion works, if there is a conversion   path from the  [2.x.84]  class to the  [2.x.85]  class of this   object. One such path would be derived class to base class, which for   example may be used to get a  [2.x.86]  from a    [2.x.87]  since the DoFAccessor class is derived   from the TriaAccessorBase class.  
* [0.x.65]*
   Another conversion operator, where we use the pointers to the   Triangulation from a TriaAccessorBase object, while the additional data   is used according to the actual type of Accessor.  
* [0.x.66]*
   Similar conversion operator to the above one, but does a check whether   the iterator points to a used element, and is active, which is necessary   for raw iterators. Since usual iterators are also raw iterators, this   constructor works also for parameters of type   <tt>TriaIterator<OtherAccessor></tt>.      [2.x.88]  The argument passed to this constructor must either be     (i) a past-the-end iterator; or (ii) it must point to     an active object. All other cases will result in an exception.  
* [0.x.67]*
   Assignment operator.  
* [0.x.68]*
   Cross assignment operator. This assignment is only valid if the given   iterator points to an active element.  
* [0.x.69]*
   Cross assignment operator. This assignment is only valid if the given   iterator points to an active element or past the end.  
* [0.x.70]*
   Assignment operator. Requires, that Accessor can be copied from   OtherAccessor.  
* [0.x.71]*
   Cross assignment operator. This assignment is only valid if the given   iterator points to an active element or past the end. Requires, that   Accessor can be copied from OtherAccessor.  
* [0.x.72]*
   Cross assignment operator. This assignment is only valid if the given   iterator points to an active element. Requires, that Accessor can be   copied from OtherAccessor.  
* [0.x.73]*
   Prefix <tt>++</tt> operator: <tt>++i</tt>. This operator advances the   iterator to the next active element and returns a reference to   <tt>*this</tt>.  
* [0.x.74]*
    [2.x.89]  Advancement of iterators  
* [0.x.75]*
   Postfix <tt>++</tt> operator: <tt>i++</tt>. This operator advances the   iterator to the next active element, but returns an iterator to the   element previously pointed to. Since this involves a temporary and a copy   operation and since an  [2.x.90]  is quite a large object for a   pointer, use the prefix operator <tt>++i</tt> whenever possible,   especially in the head of for loops (<tt>for (; i!=end; ++i)</tt>) since   there you normally never need the returned value.  
* [0.x.76]*
   Prefix  [2.x.91]  operator:  [2.x.92]  This operator advances the iterator to the   previous active element and returns a reference to <tt>*this</tt>.  
* [0.x.77]*
   Postfix  [2.x.93]  operator:  [2.x.94]   
* [0.x.78]*
   Declare some alias which are standard for iterators and are used   by algorithms to enquire about the specifics of the iterators they   work on.  
* [0.x.79]*
   Exception  
* [0.x.80]*
 Print the address to which this iterator points to  [2.x.95]  The address is given by the pair <tt>(level,index)</tt>, where  [2.x.96]  is an index relative to the level in which the object is that is pointed to.

* 
* [0.x.81]*
 Print the address to which this iterator points to  [2.x.97]  The address is given by the pair <tt>(level,index)</tt>, where  [2.x.98]  is an index relative to the level in which the object is that is pointed to.

* 
* [0.x.82]*
 Print the address to which this iterator points to  [2.x.99]  The address is given by the pair <tt>(level,index)</tt>, where  [2.x.100]  is an index relative to the level in which the object is that is pointed to.

* 
* [0.x.83]

include/deal.II-translator/grid/tria_iterator_base_0.txt
[0.x.0]*
 Namespace in which an enumeration is declared that denotes the states in which an iterator can be in.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   The three states an iterator can be in: valid, past-the-end and invalid.  
* [0.x.2]

include/deal.II-translator/grid/tria_iterator_selector_0.txt
[0.x.0]*
     This class implements some types which differ between the dimensions.     These are the declarations for the 1D case only. See the      [2.x.0]      module for more information.         A  [2.x.1]  is aliased to an iterator operating on the  [2.x.2]      lines member variable of a <tt>Triangulation<1></tt> object. An  [2.x.3]      active_line_iterator only operates on the active lines.  [2.x.4]      raw_line_iterator objects operate on all lines, used or not.         Since we are in one dimension, the following identities are declared:     
* [1.x.0]
*          To enable the declaration of  [2.x.5]  and the like in     <tt>Triangulation<1></tt>, the  [2.x.6]  are declared as     iterators over InvalidAccessor. Thus these types exist, but are useless     and will certainly make any involuntary use visible. The same holds for     hexahedron iterators.         The same applies for the  [2.x.7]  types, since lines have no     substructures apart from vertices, which are handled in a different     way, however.    
* [0.x.1]*
     This class implements some types which differ between the dimensions.     These are the declarations for the 2D case only. See the      [2.x.8]      module for more information.         A  [2.x.9]  is aliased to an iterator operating on the  [2.x.10]      lines member variable of a <tt>Triangulation<2></tt> object. An  [2.x.11]      active_line_iterator only operates on the active lines.  [2.x.12]      raw_line_iterator objects operate on all lines, used or not. Using  [2.x.13]      active_line_iterators may not be particularly in 2D useful since it     only operates on unrefined lines. However, also refined lines may bound     unrefined cells if the neighboring cell is refined once more than the     present one.         Similarly to line iterators,  [2.x.14]   [2.x.15]  and      [2.x.16]  are declared.         To enable the declaration of  [2.x.17]  and the like in     <tt>Triangulation<[12]></tt>, the  [2.x.18]  are declared as     iterators over InvalidAccessor. Thus these types exist, but are useless     and will certainly make any involuntary use visible.         Since we are in two dimension, the following identities are declared:     
* [1.x.1]
*     
* [0.x.2]*
     This class implements some types which differ between the dimensions.     These are the declarations for the 3D case only. See the      [2.x.19]      module for more information.         For the declarations of the data types, more or less the same holds as     for lower dimensions (see <tt>Iterators<[12]></tt>). The dimension     specific data types are here, since we are in three dimensions:     
* [1.x.2]
*     
* [0.x.3]

include/deal.II-translator/grid/tria_levels_0.txt
[0.x.0]*
     Store all information which belongs to one level of the multilevel     hierarchy.         In TriaLevel, all cell data is stored which is not dependent on the     dimension, e.g. a field to store the refinement flag for the cells     (what a cell actually is is declared elsewhere), etc. See also     TriaObjects for non level-oriented data.         There is another field, which may fit in here, namely the material data     (for cells) or the boundary indicators (for faces), but since we need     for a line or quad either boundary information or material data, we     store them with the lines and quads rather than with the common data.     Likewise, in 3d, we need boundary indicators for lines and quads (we     need to know how to refine a line if the two adjacent faces have     different boundary indicators), and material data for cells.    
* [0.x.1]*
       Constructor.              [2.x.0]  dim Dimension of the Triangulation.      
* [0.x.2]*
       Default constructor (needed by Boost).      
* [0.x.3]*
       Dimension of the Triangulation.      
* [0.x.4]*
        [2.x.1]  flags for the cells to be refined with       or not  [2.x.2]  The meaning what a cell       is, is dimension specific, therefore also the length of this vector       depends on the dimension: in one dimension, the length of this vector       equals the length of the  [2.x.3]  vector, in two dimensions that of       the  [2.x.4]  vector, etc.      
* [0.x.5]*
       Same meaning as the one above, but specifies whether a cell must be       coarsened.      
* [0.x.6]*
       An integer that, for every active cell, stores the how many-th active       cell this is. For non-active cells, this value is unused and set to       an invalid value.      
* [0.x.7]*
       Global cell index of each active cell.      
* [0.x.8]*
       Global cell index of each cell on the given level.      
* [0.x.9]*
       Levels and indices of the neighbors of the cells. Convention is, that       the neighbors of the cell with index  [2.x.5]  are stored in the fields       following  [2.x.6] , e.g. in one spatial       dimension, the neighbors of cell 0 are stored in       <tt>neighbors[0]</tt> and <tt>neighbors[1]</tt>, the neighbors of       cell 1 are stored in <tt>neighbors[2]</tt> and <tt>neighbors[3]</tt>,       and so on.             In neighbors, <tt>neighbors[i].first</tt> is the level, while       <tt>neighbors[i].second</tt> is the index of the neighbor.             If a neighbor does not exist (cell is at the boundary),       <tt>level=index=-1</tt> is set.              [2.x.7] Conventions: [2.x.8]  The  [2.x.9]  neighbor of a cell is the one which       shares the  [2.x.10]  face ( [2.x.11]  in 2D,  [2.x.12]  in 3D) of this cell.             The neighbor of a cell has at most the same level as this cell, i.e.       it may or may not be refined.             In one dimension, a neighbor may have any level less or equal the       level of this cell. If it has the same level, it may be refined an       arbitrary number of times, but the neighbor pointer still points to       the cell on the same level, while the neighbors of the children of       the neighbor may point to this cell or its children.             In two and more dimensions, the neighbor is either on the same level       and refined (in which case its children have neighbor pointers to       this cell or its direct children), unrefined on the same level or one       level down (in which case its neighbor pointer points to the mother       cell of this cell).      
* [0.x.10]*
       One integer per cell to store which subdomain it belongs to. This       field is most often used in parallel computations, where it denotes       which processor shall work on/owns the cells with a given subdomain       number.             This number is only used on active cells.      
* [0.x.11]*
       The subdomain id used on each level for parallel multigrid.             In contrast to the subdomain_id, this number is also used on inactive       cells once the mesh has been partitioned also on the lower levels of       the multigrid hierarchy.      
* [0.x.12]*
       One integer for every consecutive pair of cells to store which index       their parent has.             (We store this information once for each pair of cells since every       refinement, isotropic or anisotropic, and in any space dimension,       always creates children in multiples of two, so there is no need to       store the parent index for every cell.)      
* [0.x.13]*
       One bool per cell to indicate the direction of the normal true:  use       orientation from vertex false: revert the orientation. See        [2.x.13] .             This is only used for codim==1 meshes.      
* [0.x.14]*
       The object containing the data on lines and related functions      
* [0.x.15]*
       For edges, we enforce a standard convention that opposite       edges should be parallel. Now, that's enforceable in most       cases, and we have code that makes sure that if a mesh allows       this to happen, that we have this convention. We also know       that it is always possible to have opposite faces have       parallel normal vectors. (For both things, see the paper by       Agelek, Anderson, Bangerth, Barth in the ACM Transactions on       Mathematical Software mentioned in the documentation of the       GridReordering class.)             The problem is that we originally had another condition, namely that       faces 0, 2 and 4 have normals that point into the cell, while the       other faces have normals that point outward. It turns out that this       is not always possible. In effect, we have to store whether the       normal vector of each face of each cell follows this convention or       not. If this is so, then this variable stores a  [2.x.14]  value,       otherwise a  [2.x.15]  value.             In effect, this field has  [2.x.16]  elements, being the       number of cells times the six faces each has.            
*  [2.x.17]  Only needed for dim=3.      
* [0.x.16]*
       Reference cell type of each cell.            
*  [2.x.18]  Used only for dim=2 and dim=3.      
* [0.x.17]*
       A cache for the vertex indices of the cells (`structdim == dim`), in       order to more quickly retrieve these frequently accessed quantities.       For simplified addressing, the information is indexed by the maximum       number of vertices possible for a cell (quadrilateral/hexahedron).      
* [0.x.18]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.19]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.20]

include/deal.II-translator/grid/tria_objects_0.txt
[0.x.0]*
     General template for information belonging to the geometrical objects     of a triangulation, i.e. lines, quads, hexahedra...  Apart from the     vector of objects additional information is included, namely vectors     indicating the children, the used-status, user-flags, material-ids..         Objects of these classes are included in the TriaLevel and TriaFaces     classes.    
* [0.x.1]*
       Constructor resetting some data.      
* [0.x.2]*
       Constructor for a specific dimension.      
* [0.x.3]*
       Vector of the objects belonging to this level. The index of the       object equals the index in this container.      
* [0.x.4]*
       Return number of geometric objects stored by this class.      
* [0.x.5]*
       Return a view on the indices of the objects that bound the  [2.x.0]        index-th object stored by the current object. For example, if       the current object stores cells, then this function returns       the equivalent of an array containing the indices of the       faces that bound the  [2.x.1]  cell.      
* [0.x.6]*
       Index of the even children of an object. Since when objects are       refined, all children are created at the same time, they are appended       to the list at least in pairs after each other. We therefore only       store the index of the even children, the uneven follow immediately       afterwards.             If an object has no children,
* 
*  -  is stored in this list. An object is       called active if it has no children. The function        [2.x.2]  tests for this.      
* [0.x.7]*
       Store the refinement case each of the cells is refined with. This       vector might be replaced by vector<vector<bool> > (dim, vector<bool>       (n_cells)) which is more memory efficient.      
* [0.x.8]*
       Vector storing whether an object is used in the  [2.x.3]  vector.             Since it is difficult to delete elements in a  [2.x.4]  when an       element is not needed any more (e.g. after derefinement), it is not       deleted from the list, but rather the according  [2.x.5]  flag is set       to  [2.x.6]       
* [0.x.9]*
       Make available a field for user data, one bit per object. This field       is usually used when an operation runs over all cells and needs       information whether another cell (e.g. a neighbor) has already been       processed.             You can clear all used flags using        [2.x.7]       
* [0.x.10]*
       We use this union to store boundary and material data. Because only       one out of these two is actually needed here, we use an union.      
* [0.x.11]*
         Default constructor.        
* [0.x.12]*
         Return the size of objects of this kind.        
* [0.x.13]*
         Read or write the data of this object to or from a stream for the         purpose of serialization using the [BOOST serialization         library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).        
* [0.x.14]*
       Store boundary and material data. For example, in one dimension, this       field stores the material id of a line, which is a number between 0       and  [2.x.8]  In more than one dimension, lines       have no material id, but they may be at the boundary; then, we store       the boundary indicator in this field, which denotes to which part of       the boundary this line belongs and which boundary conditions hold on       this part. The boundary indicator also is a number between zero and        [2.x.9]  the id        [2.x.10]  is reserved for lines in the       interior and may be used to check whether a line is at the boundary       or not, which otherwise is not possible if you don't know which cell       it belongs to.      
* [0.x.15]*
       Store manifold ids. This field stores the manifold id of each object,       which is a number between 0 and  [2.x.11]       
* [0.x.16]*
       Return an iterator to the next free slot for a single object. This       function is only used by  [2.x.12]        in 3D.              [2.x.13]  Interestingly, this function is not used for 1D or 2D       triangulations, where it seems the authors of the refinement function       insist on reimplementing its contents.              [2.x.14]  This function is not instantiated for the codim-one case      
* [0.x.17]*
       Return an iterator to the next free slot for a pair of objects. This       function is only used by  [2.x.15]        in 3D.              [2.x.16]  Interestingly, this function is not used for 1D or 2D       triangulations, where it seems the authors of the refinement function       insist on reimplementing its contents.              [2.x.17]  This function is not instantiated for the codim-one case      
* [0.x.18]*
       Return an iterator to the next free slot for a pair of hexes. Only       implemented for  [2.x.18] .      
* [0.x.19]*
       Access to user pointers.      
* [0.x.20]*
       Read-only access to user pointers.      
* [0.x.21]*
       Access to user indices.      
* [0.x.22]*
       Read-only access to user pointers.      
* [0.x.23]*
       Reset user data to zero.      
* [0.x.24]*
       Clear all user pointers or indices and reset their type, such that       the next access may be either or.      
* [0.x.25]*
       Clear all user flags.      
* [0.x.26]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.27]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.28]*
       Triangulation objects can either access a user pointer or a       user index. What you tried to do is trying to access one of those       after using the other.            
*  [2.x.19]       
* [0.x.29]*
       Counter for next_free_single_* functions      
* [0.x.30]*
       Counter for next_free_pair_* functions      
* [0.x.31]*
       Bool flag for next_free_single_* functions      
* [0.x.32]*
       The data type storing user pointers or user indices.      
* [0.x.33]*
         Default constructor.        
* [0.x.34]*
         Write the data of this object to a stream for the purpose of         serialization using the [BOOST serialization         library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).        
* [0.x.35]*
       Enum describing the possible types of userdata.      
* [0.x.36]*
       Pointer which is not used by the library but may be accessed and set       by the user to handle data local to a line/quad/etc.      
* [0.x.37]*
       In order to avoid confusion between user pointers and indices, this       enum is set by the first function accessing either and subsequent       access will not be allowed to change the type of data accessed.      
* [0.x.38]

