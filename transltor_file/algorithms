include/deal.II-translator/algorithms/any_data_0.txt
[0.x.0]*
 Store any amount of any type of data accessible by an identifier string.
*   [2.x.0]  GK: Deprecate access to AnyData by index and change to a map.

* 
* [0.x.1]*
  
*  [2.x.1]   
* [0.x.2]*
  
*  [2.x.2]      Find the object with given name, try to convert it to <tt>type</tt> and   return it. This function throws an exception if either the name does not   exist or if the conversion fails. If such an exception is not desired,   use try_read() instead.  
* [0.x.3]*
  
*  [2.x.3]      Find the object with given name, try to convert it to <tt>type</tt> and   return it. This function throws an exception if either the name does not   exist or if the conversion fails. If such an exception is not desired,   use try_read() instead.  
* [0.x.4]*
  
*  [2.x.4]      For a constant object, this function equals entry(). For a non-const   object, it forces read only access to the data. In particular, it throws   an exception if the object is not found or cannot be converted to type.   If such an exception is not desired, use try_read() instead.      [2.x.5]  Do not use this function for stored objects which are pointers.   Use read_ptr() instead!  
* [0.x.5]*
  
*  [2.x.6]      If the stored data object is a pointer to a constant object, the logic of   access becomes fairly complicated. Namely, the standard read function may   fail, depending on whether it was a const pointer or a regular pointer.   This function fixes the logic and ascertains that the object does not   become mutable by accident.  
* [0.x.6]*
   Perform the same action as read_ptr(), but do not throw an exception if   the pointer does not exist. Return a null pointer instead.  
* [0.x.7]*
  
*  [2.x.7]      This function tries to find the name in the list and return a pointer to   the associated object. If either the name is not found or the object   cannot be converted to the return type, a null pointer is returned.  
* [0.x.8]*
   Access to stored data object by index.  
* [0.x.9]*
  
*  [2.x.8]      Try to find the object and return its index in the list. Throw an   exception if the object has not been found.  
* [0.x.10]*
  
*  [2.x.9]      Try to find the object and return its index in the list. returns    [2.x.10]  if the name was not found.  
* [0.x.11]*
   Exception indicating that a function expected a vector to have a certain   name, but we store a different name in that position.  
* [0.x.12]

include/deal.II-translator/algorithms/general_data_storage_0.txt
[0.x.0]*
 This class facilitates the storage of any general data. It offers a mechanism to store any amount of data, of any type, which is then made accessible by an identifier string.
*  When using this class, please cite
* 

* 
* [1.x.0]
* 

* 
* [0.x.1]*
   Default constructor.  
* [0.x.2]*
   Copy constructor.  
* [0.x.3]*
   Move constructor.  
* [0.x.4]*
   Number of objects stored by this class instance.  
* [0.x.5]*
   Merge the contents of  [2.x.0]  with this object.  
* [0.x.6]*
   Print the contents of the internal cache to the  [2.x.1]      Each key and value pair in the  [2.x.2]  map are printed on an   individual line, with the  [2.x.3]  key listed first   followed by the demangled <tt>type_id</tt> of the associated mapped   type.  
* [0.x.7]*
   Clear all data stored in this class instance.     When you call this function, it destroys all objects you asked to be stored   as copies, and it forgets about the references to data you asked to store   by reference. As a consequence, you are now free to destroy the objects to   which references were stored at whatever time you want
* 
*  -  before or after   the current `GeneralDataStorage` object is destroyed.     To clarify this point, consider the following small example:    
* [1.x.1]
*      In the code above, the  [2.x.4]   object has a longer scope than   <tt>some_number</tt>. By the time we fetch the <tt>"value"</tt> from    [2.x.5]  , the reference to  [2.x.6]  is no longer valid.     Similarly, for data copied into a GeneralDataStorage object one should   consider the scope under which it remains valid:    
* [1.x.2]
*      Similar to the first example, we must be conscious of the fact that the   copies of any  [2.x.7]  stored by  [2.x.8]  only remains valid while the   GeneralDataStorage instance in which it is stored is alive.     Furthermore, as elucidated in the last example, the copy of the   class instance (owned by GeneralDataStorage) that is being pointed to   is no longer alive when the reset() function is called, or when it is   removed via a call to remove_object_with_name().    
* [1.x.3]
*   
* [0.x.8]*
    [2.x.9]  Data storage and access  
* [0.x.9]*
   Store internally a copy of the given object. The copied object is   owned by this class, and is accessible via reference through the   get_object_with_name() method.     This function ensures that no  [2.x.10]  with the given  [2.x.11]  is   already stored by this class instance.  
* [0.x.10]*
   Store internally a copy of the given object. The copied object is   owned by this class, and is accessible via reference through the   get_object_with_name() method.     This function does not perform any checks to ensure that the  [2.x.12]    with the given  [2.x.13]  is already stored by this class instance. If the    [2.x.14]  does in fact point to existing data, then this is overwritten.  
* [0.x.11]*
   Add a reference to an already existing object. The object is not   owned by this class, and the user has to guarantee that the   referenced object lives longer than this class instance. The stored   reference is accessible through the get_object_with_name() method.     This function ensures that no  [2.x.15]  with the given  [2.x.16]  is   already stored by this class instance.  
* [0.x.12]*
   Add a reference to an already existing object. The object is not   owned by this class, and the user has to guarantee that the   referenced object lives longer than this class instance. The stored   reference is accessible through the get_object_with_name() method.     This function does not perform any checks to ensure that the  [2.x.17]    with the given  [2.x.18]  is already stored by this class instance. If the    [2.x.19]  does in fact point to existing data, then this is overwritten.  
* [0.x.13]*
   Return a reference to the object with given name. If the object does   not exist, then the input  [2.x.20]  will be used to construct an object   of the given  [2.x.21]  and a reference to this new object then be returned.     A copy of an object of type  [2.x.22]  , which is owned by this class   instance, is generated by calling its constructor with the given set of   arguments. For this function, the  [2.x.23]  are passed as   <tt>lvalue</tt> references.  
* [0.x.14]*
   Return a reference to the object with given name. If the object does   not exist, then the input  [2.x.24]  will be used to construct an object   of the given  [2.x.25]  and a reference to this new object then be returned.     Same as above for a single argument.  
* [0.x.15]*
   Return a reference to the object with given name. If the object does   not exist, then the input  [2.x.26]  will be used to construct an object   of the given  [2.x.27]  and a reference to this new object then be returned.     A copy of an object of type  [2.x.28]  , which is owned by this class   instance, is generated by calling its constructor with the given set of   arguments. In contrast to the previous function of the same name, for   this function the  [2.x.29]  are passed as <tt>rvalue</tt> references.  
* [0.x.16]*
   Return a reference to the object with given name. If the object does   not exist, then the input  [2.x.30]  will be used to construct an object   of the given  [2.x.31]  and a reference to this new object then be returned.     Same as above for a single argument.  
* [0.x.17]*
   Same as above for default constructors.  
* [0.x.18]*
   Return a reference to the object with given name.     This function throws an exception if either an object with the given name   is not stored in this class, or if the object with the given name is   neither of the exact specified  [2.x.32]  nor a pointer to the  [2.x.33]   
* [0.x.19]*
   Return a constant reference to the object with the given name.     This function throws an exception if either an object with the given name   is not stored in this class, or if the object with the given name is   neither of the exact specified  [2.x.34]  nor a pointer to the  [2.x.35]   
* [0.x.20]*
   Find out if we store an object with given name.  
* [0.x.21]*
   Remove the object with given name.  
* [0.x.22]*
   An entry with this name does not exist in the internal  [2.x.36]  map.  
* [0.x.23]*
   An entry with this name does not exist in the internal  [2.x.37]  map.  
* [0.x.24]*
   The requested type and the stored type are different.  
* [0.x.25]*
   Arbitrary user data, identified by a string.  
* [0.x.26]

include/deal.II-translator/algorithms/named_selection_0.txt
[0.x.0]*
 Select data from AnyData corresponding to the attached name.
*  Given a list of names to search for (provided by add()), objects of this class provide an index list of the selected data.

* 
* [0.x.1]*
   Add a new name to be searched for in  [2.x.0]  supplied in initialize().    
*  [2.x.1]  Names will be added to the end of the current list.  
* [0.x.2]*
   Create the index vector pointing into the AnyData object.  
* [0.x.3]*
   The number of names in this object. This function may be used whether   initialize() was called before or not.  
* [0.x.4]*
   Return the corresponding index in the AnyData object supplied to the last   initialize(). It is an error if initialize() has not been called before.     Indices are in the same order as the calls to add().  
* [0.x.5]*
   The selected names.  
* [0.x.6]*
   The index map generated by initialize() and accessed by operator().  
* [0.x.7]

include/deal.II-translator/algorithms/newton_0.txt
[0.x.0]*
   Operator class performing Newton's iteration with standard step size   control and adaptive matrix generation.     This class performs a Newton iteration up to convergence determined by   #control. If after an update the norm of the residual has become larger,   then step size control is activated and the update is subsequently   divided by two until the residual actually becomes smaller (or the   minimal scaling factor determined by #n_stepsize_iterations is reached).     Since assembling matrices, depending on the implementation, tends to be   costly, this method applies an adaptive reassembling strategy. Only if   the reduction factor for the residual is more than #threshold, the event    [2.x.0]  is submitted to #inverse_derivative. It is up   to this object to implement reassembling accordingly.     [1.x.0]     The only value used by the Newton method is the first vector in the   parameter <tt>out</tt> of operator()(). It serves as the start vector of   Newton's method and in the end contains the solution. All other vectors   of <tt>out</tt> are ignored by Newton's method and its inner Operator   objects. All vectors of <tt>in</tt> are forwarded to the inner Operator   objects, with additional information added as follows.     When calling (*#residual)(), the AnyData <tt>in</tt> given to the Newton   iteration is prepended by a vector <tt>"Newton iterate"</tt>, the current   value of the Newton iterate, which can be used to evaluate the residual   at this point.     For the call to (*#inverse_derivative), the vector <tt>"Newton   residual"</tt> is inserted before <tt>"Newton iterate"</tt>.  
* [0.x.1]*
     Constructor, receiving the applications computing the residual and     solving the linear problem, respectively.    
* [0.x.2]*
     Declare the parameters applicable to Newton's method.    
* [0.x.3]*
     Read the parameters in the ParameterHandler.    
* [0.x.4]*
     Initialize the pointer data_out for debugging.    
* [0.x.5]*
     The actual Newton iteration. The initial value is in <tt>out(0)</tt>,     which also contains the result after convergence. Values in <tt>in</tt>     are not used by Newton, but will be handed down to the objects     #residual and #inverse_derivative.    
* [0.x.6]*
     Set the maximal residual reduction allowed without triggering     assembling in the next step. Return the previous value.    
* [0.x.7]*
     Control object for the Newton iteration.    
* [0.x.8]*
     The operator computing the residual.    
* [0.x.9]*
     The operator applying the inverse derivative to the residual.    
* [0.x.10]*
     The operator handling the output in case the debug_vectors is true.     Call the initialize function first.    
* [0.x.11]*
     This flag is set by the function assemble(), indicating that the matrix     must be assembled anew upon start.    
* [0.x.12]*
     A flag used to decide how many stepsize iteration should be made.     Default is the original value of 21.         Enter zero here to turn off stepsize control.        
*  [2.x.1]  Controlled by <tt>Stepsize iterations</tt> in parameter file    
* [0.x.13]*
     Threshold for re-assembling matrix.         If the quotient of two consecutive residuals is smaller than this     threshold, the system matrix is not assembled in this step.        
*  [2.x.2]  This parameter should be adjusted to the residual gain of the     inner solver.         The default values is zero, resulting in reassembling in every Newton     step.    
* [0.x.14]*
     Print residual, update and updated solution after each step into file     <tt>Newton_NNN</tt>?    
* [0.x.15]*
     Write debug output to  [2.x.3]  the higher the number, the more     output.    
* [0.x.16]

include/deal.II-translator/algorithms/newton.templates_0.txt
[0.x.0]

include/deal.II-translator/algorithms/operator_0.txt
[0.x.0]*
 Namespace containing numerical algorithms in a unified form.
*  All algorithmic classes in this namespace are derived from either Operator or OutputOperator, depending on whether they return a value or not. See the documentation of those classes for more detailed information on how to use them.

* 
* [0.x.1]*
    [2.x.0]  Update this documentation and the one of Operator     The abstract base class of all algorithms in this library. An operator is   an object with an operator(), which transforms a set of named vectors   into another set of named vectors.     Furthermore, an operator can be notified of parameter changes by the   calling routine. The outer iteration can notify() the Operator of an   Event, which could be for instance a change of mesh, a different time   step size or too slow convergence of Newton's method, which would then   trigger reassembling of a matrix or similar things.     [1.x.0]     This is probably the most prominent use for Operator, where an outer   iterative method calls an inner solver and so on. Typically, the   innermost method in such a nested system will have to compute a residual   using values from all outer iterations. Since the depth and order of such   a nesting is hardly predictable when designing a general tool, we use   AnyData to access these vectors. Typically, the first vector in   <tt>out</tt> contains the start vector when operator()() is called, and   the solution when the function returns. The object <tt>in</tt> is   providing additional information and forwarded to the inner Operator   objects of the nested iteration.  
* [0.x.2]*
     The virtual destructor.    
* [0.x.3]*
     The actual operation, which is implemented in a derived class.    
* [0.x.4]*
     Register an event triggered by an outer iteration.    
* [0.x.5]*
     Clear all #notifications.    
* [0.x.6]*
     Accumulate events here. If any of those is set, the function solve() of     a terminal application must take care of reassembling the matrix.    
* [0.x.7]*
   An unary operator base class, intended to output the vectors in AnyData   in each step of an iteration.  
* [0.x.8]*
     Constructor initializing member variables with invalid data.    
* [0.x.9]*
     The copy constructor is deleted since objects of this class     should not be copied.    
* [0.x.10]*
     Empty virtual destructor.    
* [0.x.11]*
     Set the stream  [2.x.1]  to which data is written. If no stream is selected     with this function, data goes to  [2.x.2]     
* [0.x.12]*
     Set the current step.    
* [0.x.13]*
     Output all the vectors in AnyData.    
* [0.x.14]*
   Set the step number in OutputOperator by shifting an integer value.      [2.x.3]  OutputOperator  
* [0.x.15]

include/deal.II-translator/algorithms/operator.templates_0.txt
[0.x.0]

include/deal.II-translator/algorithms/theta_timestepping_0.txt
[0.x.0]*
   A little structure, gathering the size of a timestep and the current   time. Time stepping schemes can use this to provide time step information   to the classes actually performing a single step.     The definition of what is considered "current time" depends on the   scheme. For an explicit scheme, this is the time at the beginning of the   step. For an implicit scheme, it is usually the time at the end.  
* [0.x.1]*
   Application class performing the theta timestepping scheme.     The theta scheme is an abstraction of implicit and explicit Euler   schemes, the Crank-Nicholson scheme and linear combinations of those. The   choice of the actual scheme is controlled by the parameter #theta as   follows.    [2.x.0]     [2.x.1]  #theta=0: explicit Euler scheme    [2.x.2]  #theta=1: implicit Euler scheme    [2.x.3]  #theta=½: Crank-Nicholson scheme    [2.x.4]      For fixed #theta, the Crank-Nicholson scheme is the only second order   scheme. Nevertheless, further stability may be achieved by choosing   #theta larger than ½, thereby introducing a first order error term. In   order to avoid a loss of convergence order, the adaptive theta scheme can   be used, where [1.x.0].     Assume that we want to solve the equation [1.x.1] with a   step size [1.x.2].  A step of the theta scheme can be written as     [1.x.3]     Here, [1.x.4] is the mass matrix. We see, that the right hand side   amounts to an explicit Euler step with modified step size in weak form   (up to inversion of M). The left hand side corresponds to an implicit   Euler step with modified step size (right hand side given). Thus, the   implementation of the theta scheme will use two Operator objects, one for   the explicit, one for the implicit part. Each of these will use its own   TimestepData to account for the modified step sizes (and different times   if the problem is not autonomous). Note that once the explicit part has   been computed, the left hand side actually constitutes a linear or   nonlinear system which has to be solved.     [1.x.5]     ThetaTimestepping uses AnyData for communicating vectors and time step   information. With outer or inner Operator objects. It does not use itself   the input vectors provided, but forwards them to the explicit and   implicit operators.     [1.x.6]     The explicit Operator #op_explicit receives in its input in first place   the vector "Previous iterate", which is the solution value after the   previous timestep. It is followed by all vectors provided to    [2.x.5]  as input argument. #op_explicit is supposed   to write its result into the first position of its output argument,   labeled "Result".     The implicit Operator #op_implicit receives the result of #op_explicit in   its first input vector labeled "Previous time". It is followed by all   vectors provided to  [2.x.6]  as input argument. The   output of #op_implicit is directly written into the output argument given   to ThetaTimestepping.     [1.x.7]     Since the introduction of AnyData, ThetaTimestepping is able to   communicate the current time step information through AnyData as well.   Therefore, the AnyData objects handed as input to #op_explicit and   #op_implicit contain two entries of type `const double*` named "Time" and   "Timestep". Note that "Time" refers to the time at the beginning of the   current step for #op_explicit and at the end for #op_implicit,   respectively.     [1.x.8]     The use ThetaTimestepping is more complicated than for instance Newton,   since the inner operators will usually need to access the TimeStepData.   Thus, we have a circular dependency of information, and we include the   following example for its use.     First, we define the two operators used by ThetaTimestepping and call   them  [2.x.7] . They both share the   public interface of Operator, and additionally provide storage for the   matrices to be used and a pointer to TimestepData. Note that we do not   use a SmartPointer here, since the TimestepData will be destroyed before   the operator.    
* [1.x.9]
*      These operators will be implemented after the main program. But let us   look first at how they get used. First, let us define a matrix to be used   for our system and also an OutputOperator in order to write the data of   each timestep to a file.    
* [1.x.10]
*      Now we create objects for the implicit and explicit parts of the steps as   well as the ThetaTimestepping itself. We initialize the timestepping with   the output operator in order to be able to see the output in every step.    
* [1.x.11]
*      The next step is providing the vectors to be used. <tt>value</tt> is   filled with the initial value and is also the vector where the solution   at each timestep will be. Because the interface of Operator has to be   able to handle several vectors, we need to store it in an AnyData object.   Since our problem has no additional parameters, the input AnyData object   remains empty.    
* [1.x.12]
*      Finally, we are ready to tell the solver, that we are starting at the   initial timestep and run it.    
* [1.x.13]
*      Besides the main function, we need to define the members functions   of the implicit and explicit operators.   First the constructor, which simply copies the system matrix into the   member pointer for later use.    
* [1.x.14]
*      Now we need to study the application of the implicit and explicit   operator. We assume that the pointer  [2.x.8]  points to the   matrix created in the main program (the constructor did this for us).   Here, we first get the time step size from the AnyData object that was   provided as input. Then, if we are in the first step or if the timestep   has changed, we fill the local matrix  [2.x.9] , such that with the given   matrix  [2.x.10] , it becomes [1.x.15] After we have worked   off the notifications, we clear them, such that the matrix is only   generated when necessary.    
* [1.x.16]
*      Now we multiply the input vector with the new matrix and store on output.    
* [1.x.17]
*      The code for the implicit operator is almost the same, except   that we change the sign in front of the timestep and use the inverse of   the matrix.    
* [1.x.18]
*   
* [0.x.2]*
     Constructor, receiving the two operators stored in #op_explicit and     #op_implicit. For their meaning, see the description of those     variables.    
* [0.x.3]*
     The timestepping scheme.          [2.x.11]  in is ignored by ThetaTimestepping, but is merged into the     AnyData objects used as input for the operators #op_explicit and     #op_implicit.          [2.x.12]  out in its first argument must contain a pointer to a VectorType     instance, which contains the initial value when the operator is called.     It contains the final value when the operator returns.    
* [0.x.4]*
     Register an event triggered by an outer iteration.    
* [0.x.5]*
     Define an operator which will output the result in each step. Note that     no output will be generated without this.    
* [0.x.6]*
     Declare parameters in a parameter handler.    
* [0.x.7]*
     Read the parameters in the ParameterHandler.    
* [0.x.8]*
     The current time in the timestepping scheme.    
* [0.x.9]*
     The weight between implicit and explicit part.    
* [0.x.10]*
     Set a new weight and return the old    
* [0.x.11]*
     The data handed to the #op_explicit time stepping operator.         The time in here is the time at the beginning of the current step, the     time step is (1-#theta) times the actual time step.    
* [0.x.12]*
     The data handed to the #op_implicit time stepping operator.         The time in here is the time at the beginning of the current step, the     time step is #theta times the actual time step.    
* [0.x.13]*
     Allow access to the control object.    
* [0.x.14]*
     The object controlling the time step size and computing the new time in     each step.    
* [0.x.15]*
     The control parameter theta in the range <tt>[0,1]</tt>. It defaults to     0.5.    
* [0.x.16]*
     Use adaptive #theta if <tt>true</tt>. Not yet implemented.    
* [0.x.17]*
     The data for the explicit part of the scheme.    
* [0.x.18]*
     The data for the implicit part of the scheme.    
* [0.x.19]*
     The operator computing the explicit part of the scheme. This will     receive in its input data the value at the current time with name     "Current time solution". It should obtain the current time and time     step size from explicit_data().         Its return value is  [2.x.13] , where  [2.x.14]  is the current state     vector,  [2.x.15]  the mass matrix,  [2.x.16]  the operator in space and  [2.x.17]  is the     adjusted time step size  [2.x.18] .    
* [0.x.20]*
     The operator solving the implicit part of the scheme. It will receive     in its input data the vector "Previous time". Information on the     timestep should be obtained from implicit_data().         Its return value is the solution [1.x.19] of [1.x.20], where     [1.x.21] is the dual space vector found in the "Previous time" entry of     the input data, [1.x.22] the mass matrix, [1.x.23] the operator in     space and [1.x.24] is the adjusted time step size  [2.x.19]     
* [0.x.21]*
     The operator writing the output in each time step    
* [0.x.22]

include/deal.II-translator/algorithms/theta_timestepping.templates_0.txt
[0.x.0]

include/deal.II-translator/algorithms/timestep_control_0.txt
[0.x.0]*
   Control class for timestepping schemes. Its main task is determining the   size of the next time step and the according point in the time interval.   Additionally, it controls writing the solution to a file.     The size of the next time step is determined as follows:    [2.x.0]     [2.x.1]  According to the strategy, the step size is tentatively added to the   current time.    [2.x.2]  If the resulting time exceeds the final time of the interval, the   step size is reduced in order to meet this time.    [2.x.3]  If the resulting time is below the final time by just a fraction of   the step size, the step size is increased in order to meet this time.    [2.x.4]  The resulting step size is used from the current time.    [2.x.5]      The variable  [2.x.6]  can be used to control the amount of output   generated by the timestepping scheme.    
*  [2.x.7]  Many of the features of this class are available in DiscreteTime   with a more modern interface and better programming guarantees. Consider   using DiscreteTime instead of TimestepControl.  
* [0.x.1]*
     Constructor setting default values    
* [0.x.2]*
     Declare the control parameters for parameter handler.    
* [0.x.3]*
     Read the control parameters from a parameter handler.         This function also calls restart() to reset all other internal     parameters of this class to their appropriate values based on     the parameters just read.    
* [0.x.4]*
     Return the left end of the time interval.    
* [0.x.5]*
     Return the right end of the time interval. The control mechanism     ensures that the final time step ends at this point.    
* [0.x.6]*
     Return the tolerance value controlling the time steps.    
* [0.x.7]*
     Return the size of the current time step.    
* [0.x.8]*
     Return the current time.    
* [0.x.9]*
     Compute the size of the next step and return true if it differs from     the current step size. Advance the current time by the new step size.    
* [0.x.10]*
     Set start value.    
* [0.x.11]*
     Set final time value.    
* [0.x.12]*
     Set tolerance    
* [0.x.13]*
     Set size of the first step. This may be overwritten by the time     stepping strategy.          [2.x.8]  step The size of the first step, which may be overwritten by     the time stepping strategy.    
* [0.x.14]*
     Set size of the maximum step size.    
* [0.x.15]*
     Set now() equal to start(). Initialize step() and print() to their     initial values.    
* [0.x.16]*
     Return true if this timestep should be written to disk.    
* [0.x.17]*
     The beginning of the time interval.    
* [0.x.18]*
    The end of the time interval.    
* [0.x.19]*
     The tolerance value controlling the time steps.    
* [0.x.20]*
     The size of the first step.    
* [0.x.21]*
     The maximum step size.    
* [0.x.22]*
     The minimum step size.    
* [0.x.23]*
     The size of the current time step. This may differ from  [2.x.9]  if     we aim at  [2.x.10]     
* [0.x.24]*
     The size of the current time step determined by the strategy. This may     differ from  [2.x.11]  if we aim at  [2.x.12]     
* [0.x.25]*
     The current time.    
* [0.x.26]*
     Determines the approximate time interval between generated outputs.     If negative, output will be generated at all time steps.    
* [0.x.27]*
     If current time exceeds this value, it is time to generate the output.    
* [0.x.28]

