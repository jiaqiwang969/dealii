include/deal.II-translator/dofs/block_info_0.txt
[0.x.0]*


* 
*  [2.x.0]  global, multilevel and local computations.
*  Once a DoFHandler has been initialized with an FESystem, a data object of type BlockInfo (accessed by  [2.x.1]  ) is filled, which reflects the block structure of the degrees of freedom.
*  BlockInfo consists of several BlockIndices objects. The member global() reflects the block structure of the system on the active cell level, usually referred to as the global system. As soon as  [2.x.2]  has been called, the function  [2.x.3]  in global() will return the correct sizes of each block. After  [2.x.4]   [2.x.5]  will return the start index for each of the blocks.
*  When a DoFHandler with levels is used, the same structure is automatically generated for each level. The level blocks can be accessed through level().
*  Finally, there are local() BlockIndices, which describe the block structure on a single cell. This is used for instance by  [2.x.6]  The local indices are not filled automatically, since they change the behavior of the  [2.x.7]  classes relying on BlockInfo. They must be initialized by hand through initialize_local().
*  [1.x.0]
*  The most common usage for this object is initializing vectors as in the following code:
* 

* 
* [1.x.1]
* 
*  In this example, <tt>solution</tt> obtains the block structure needed to represent a finite element function on the DoFHandler. Similarly, all levels of <tt>mg_vector</tt> will have the block structure needed on that level.
*   [2.x.8]  Extend the functions local() and renumber() to allow for hp-capablilites.
* 

* 
*  [2.x.9] 

* 
* [0.x.1]*
  
*  [2.x.10]    DoFHandler.     By default, this function will attempt to initialize whatever is   possible. If active dofs have been assigned int the DoFHandler argument,   they BlockIndices for those will be generated. The same for level dofs.     This default behavior can be overridden by the two parameters, which can   switch off active dofs or level dofs.     This function will also clear the local() indices.  
* [0.x.2]*
  
*  [2.x.11]    between cell dofs and block cell dofs.  
* [0.x.3]*
   Access the BlockIndices structure of the global system.  
* [0.x.4]*
   Access BlockIndices for the local system on a cell.  
* [0.x.5]*
   Access the BlockIndices structure of a level in the multilevel hierarchy.  
* [0.x.6]*
   Return the index after local renumbering.     The input of this function is an index between zero and the number of   dofs per cell, numbered in local block ordering, that is first all   indices of the first system block, then all of the second block and so   forth. The function then outputs the index in the standard local   numbering of DoFAccessor.  
* [0.x.7]*
   The number of base elements.  
* [0.x.8]*
   Return the base element of this index.  
* [0.x.9]*
   Write a summary of the block structure to the stream.  
* [0.x.10]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.11]*
   Read or write the data of this object to or from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.12]*
  
*  [2.x.12]   
* [0.x.13]*
  
*  [2.x.13]   
* [0.x.14]*
  
*  [2.x.14]   
* [0.x.15]*
   The base element associated with each block.  
* [0.x.16]*
   A vector containing the renumbering from the standard order of degrees of   freedom on a cell to a component wise ordering. Filled by initialize().  
* [0.x.17]

include/deal.II-translator/dofs/dof_accessor.templates_0.txt
[0.x.0]*
     A class like the one with same name in tria.cc. See there for more     information.    
* [0.x.1]*
       Process the  [2.x.0]  degree of freedom corresponding to the       finite element specified by  [2.x.1]  on the vertex with global       number  [2.x.2]  to  [2.x.3]       
* [0.x.2]*
       Determine range of dofs of object in global data structure.      
* [0.x.3]*
       Process all dofs of an object.      
* [0.x.4]*
       Set the  [2.x.4]  degree of freedom corresponding to the       finite element specified by  [2.x.5]  on the vertex with global       number  [2.x.6]  to  [2.x.7]       
* [0.x.5]*
       Get the  [2.x.8]  degree of freedom corresponding to the       finite element specified by  [2.x.9]  on the vertex with global       number  [2.x.10]  to  [2.x.11]       
* [0.x.6]*
       Return the number of different finite elements that are active on a       given vertex.      
* [0.x.7]*
       Return the FE index of the n-th finite element active on a given       vertex.      
* [0.x.8]*
       Returns all active FE indices on a given vertex.             The size of the returned set equals the number of finite elements that       are active on this vertex.      
* [0.x.9]*
       Loop over all degrees of freedom of the object described by the       provided  [2.x.12]  and  [2.x.13]  and count them.      
* [0.x.10]*
       Loop over all degrees of freedom of the object described by the       provided  [2.x.14]  and  [2.x.15]  and perform the static functions       provided by DoFOperation (set/get) on these.      
* [0.x.11]*
       An internal struct encapsulating the task of getting (vertex)       DoF indices.      
* [0.x.12]*
         Return vertex DoF indices.        
* [0.x.13]*
         Return DoF indices for lines, quads, and inner degrees of freedom.        
* [0.x.14]*
         Fallback for DoFInvalidAccessor.        
* [0.x.15]*
         Process non-active DoF.        
* [0.x.16]*
       An internal struct encapsulating the task of setting (vertex)       DoF indices.      
* [0.x.17]*
         Set vertex DoF indices.        
* [0.x.18]*
         Set DoF indices for lines, quads, and inner degrees of freedom.        
* [0.x.19]*
         Fallback for DoFInvalidAccessor.        
* [0.x.20]*
         Process non-active DoF.        
* [0.x.21]*
       An internal struct encapsulating the task of getting level (vertex)       DoF indices.      
* [0.x.22]*
         Constructor.        
* [0.x.23]*
         Return vertex DoF indices.        
* [0.x.24]*
         Return DoF indices for lines, quads, and inner degrees of freedom.        
* [0.x.25]*
         Fallback for DoFInvalidAccessor.        
* [0.x.26]*
         Process non-active DoF.        
* [0.x.27]*
       An internal struct encapsulating the task of setting level (vertex)       DoF indices.      
* [0.x.28]*
         Constructor.        
* [0.x.29]*
         Set vertex DoF indices.        
* [0.x.30]*
         Set DoF indices for lines, quads, and inner degrees of freedom.        
* [0.x.31]*
         Fallback for DoFInvalidAccessor.        
* [0.x.32]*
         Process non-active DoF.        
* [0.x.33]*
     A class with the same purpose as the similarly named class of the     Triangulation class. See there for more information.    
* [0.x.34]*
       Implement the updating of the cache.      
* [0.x.35]*
       Do what the active_fe_index function in the parent class is supposed to       do.      
* [0.x.36]*
       Do what the set_active_fe_index function in the parent class is       supposed to do.      
* [0.x.37]*
       Do what the future_fe_index function in the parent class is supposed to       do.      
* [0.x.38]*
       Do what the set_future_fe_index function in the parent class is       supposed to do.      
* [0.x.39]*
       Do what the future_fe_index_set function in the parent class is       supposed to do.      
* [0.x.40]*
       Do what the clear_fe_index function in the parent class is supposed to       do.      
* [0.x.41]

include/deal.II-translator/dofs/dof_accessor_0.txt
[0.x.0]*
     This is a switch class which only declares an  [2.x.0]  It is meant to     determine which class a DoFAccessor class is to be derived from. By     default, <tt>DoFAccessor [2.x.1]  derives from     the alias in the general     <tt>Inheritance [2.x.2]  class, which is     <tt>TriaAccessor [2.x.3]  but if     <tt>structdim==dim</tt>, then the specialization     <tt>Inheritance [2.x.4]  is used which declares its     local type to be <tt>CellAccessor [2.x.5]  Therefore, the     inheritance is automatically chosen to be from CellAccessor if the     object under consideration has full dimension, i.e. constitutes a cell.        
*  [2.x.6]     
*  [2.x.7]     
* [0.x.1]*
       Declaration of the  [2.x.8]  See the full documentation for more       information.      
* [0.x.2]*
     This is the specialization of the general template used for the case     where an object has full dimension, i.e. is a cell. See the general     template for more details.    
* [0.x.3]*
       Declaration of the  [2.x.9]  See the full documentation for more       information.      
* [0.x.4]*
 A class that gives access to the degrees of freedom stored in a DoFHandler object. Accessors are used to access the data that pertains to edges, faces, and cells of a triangulation. The concept is explained in more detail in connection to  [2.x.10] .
*  This class follows mainly the route laid out by the accessor library declared in the triangulation library (TriaAccessor). It enables the user to access the degrees of freedom on lines, quads, or hexes. The first template argument of this class determines the dimensionality of the object under consideration: 1 for lines, 2 for quads, and 3 for hexes. The second argument denotes the type of DoFHandler we should work on. From the second template argument we also deduce the dimension of the Triangulation this object refers to as well as the dimension of the space into which it is embedded. Finally, the template argument  [2.x.11]  governs the behavior of the function get_active_or_mg_dof_indices(). See the section on Generic loops below.
*  [1.x.0]
*  Usage is best to happen through the alias to the various kinds of iterators provided by the DoFHandler class, since they are more secure to changes in the class naming and template interface as well as providing easier typing (much less complicated names!).
*  [1.x.1]
*  Many loops look very similar, whether they operate on the active dofs of the active cells of the Triangulation or on the level dofs of a single level or the whole grid hierarchy. In order to use polymorphism in such loops, they access degrees of freedom through the function get_active_or_mg_dof_indices(), which changes behavior according to the third template argument.  If the argument is false, then the active dofs of active cells are accessed. If it is true, the level dofs are used. DoFHandler has functions, for instance begin() and begin_mg(), which return either type or the other. Additionally, they can be cast into each other, in case this is needed, since they access the same data.
*  It is recommended to use the function get_active_or_mg_dof_indices() in generic loops in lieu of get_dof_indices() or get_mg_dof_indices().
*  [1.x.2]
*  If the structural dimension given by the first template argument equals the dimension of the DoFHandler (given as the second template argument), then we are obviously dealing with cells, rather than lower-dimensional objects. In that case, inheritance is from CellAccessor, to provide access to all the cell specific information afforded by that class. Otherwise, i.e. for lower-dimensional objects, inheritance is from TriaAccessor.
*  There is a DoFCellAccessor class that provides the equivalent to the CellAccessor class.
*   [2.x.12]  structdim The dimensionality of the objects the accessor   represents. For example, points have  [2.x.13]  equal to zero,   edges have  [2.x.14]  equal to one, etc.  [2.x.15]  dim Dimension of the underlying DoFHandler.  [2.x.16]  spacedim Space dimension of the underlying DoFHandler.  [2.x.17]  level_dof_access If  [2.x.18]  then the accessor simply represents   a cell, face, or edge in a DoFHandler for which degrees of freedom only   exist on the finest level. Some operations are not allowed in this case,   such as asking for DoF indices on non-active cells. On the other hand,   if this template argument is  [2.x.19]  then the accessor represents an   object in a multilevel hierarchy of degrees of freedom. In this case,   accessing DoF indices of [1.x.3] cell is possible, and will return   the [1.x.4] indices (which, for active cells, may be different   from the [1.x.5] indices).
* 

* 
*  [2.x.20] 

* 
*  [2.x.21] 

* 
* [0.x.5]*
   A static variable that allows users of this class to discover the value   of the second template argument.  
* [0.x.6]*
   A static variable that allows users of this class to discover the value   of the third template argument.  
* [0.x.7]*
   Declare an alias to the base class to make accessing some of the   exception classes simpler.  
* [0.x.8]*
   Data type passed by the iterator class.  
* [0.x.9]*
    [2.x.22]  Constructors  
* [0.x.10]*
    [2.x.23]   
* [0.x.11]*
   Default constructor. Provides an accessor that can't be used.  
* [0.x.12]*
   Constructor that generates an access that points to a particular cell or   face or edge in a DoFHandler.      [2.x.24]  tria The triangulation into which this accessor points.    [2.x.25]  level The level within the mesh hierarchy of the object pointed     to. For example, coarse mesh cells will have level zero, their children     level one, and so on. This argument is ignored for faces and edges     which do not have a level.    [2.x.26]  index The index of the object pointed to within the specified     refinement level.    [2.x.27]  dof_handler A pointer to the DoFHandler object to which the     accessor shall refer. This DoFHandler object must of course be built on     the same triangulation as the one specified in the first argument.  
* [0.x.13]*
   Copy constructor.  
* [0.x.14]*
   Move constructor.  
* [0.x.15]*
   Destructor.  
* [0.x.16]*
   Conversion constructor. This constructor exists to make certain   constructs simpler to write in dimension independent code. For example,   it allows assigning a face iterator to a line iterator, an operation that   is useful in 2d but doesn't make any sense in 3d. The constructor here   exists for the purpose of making the code conform to C++ but it will   unconditionally abort; in other words, assigning a face iterator to a   line iterator is better put into an if-statement that checks that the   dimension is two, and assign to a quad iterator in 3d (an operator that,   without this constructor would be illegal if we happen to compile for   2d).  
* [0.x.17]*
   Another conversion operator between objects that don't make sense, just   like the previous one.  
* [0.x.18]*
   Copy constructor allowing to switch level access and active access.  
* [0.x.19]*
   Copy operator. These operators are usually used in a context like   <tt>iterator a,b;a=*b;</tt>. Presumably, the intent here is to copy the   object pointed to   by  [2.x.28]  to the object pointed to by  [2.x.29]  However, the result of   dereferencing an iterator is not an object but an accessor; consequently,   this operation is not useful for iterators on DoF handler objects.   Consequently, this operator is declared as deleted and can not be used.  
* [0.x.20]*
   Move assignment operator.  
* [0.x.21]*
    [2.x.30]   
* [0.x.22]*
   Return a handle on the DoFHandler object which we are using.  
* [0.x.23]*
   Implement the copy operator needed for the iterator classes.  
* [0.x.24]*
   Copy operator used by the iterator class. Keeps the previously set dof   handler, but sets the object coordinates of the TriaAccessor.  
* [0.x.25]*
   Tell the caller whether get_active_or_mg_dof_indices() accesses active or   level dofs.  
* [0.x.26]*
    [2.x.31]  Accessing sub-objects  
* [0.x.27]*
    [2.x.32]   
* [0.x.28]*
   Return an iterator pointing to the  [2.x.33]  child.  
* [0.x.29]*
   Pointer to the  [2.x.34]  line bounding this object. If the current object is   a line itself, then the only valid index is  [2.x.35]  equals to zero, and the   function returns an iterator to itself.  
* [0.x.30]*
   Pointer to the  [2.x.36]  quad bounding this object. If the current object is   a quad itself, then the only valid index is  [2.x.37]  equals to zero, and the   function returns an iterator to itself.  
* [0.x.31]*
    [2.x.38]   
* [0.x.32]*
    [2.x.39]  Accessing the DoF indices of this object  
* [0.x.33]*
    [2.x.40]   
* [0.x.34]*
   Return the [1.x.6] indices of the degrees of freedom located on   this object in the standard ordering defined by the finite element (i.e.,   dofs on vertex 0, dofs on vertex 1, etc, dofs on line 0, dofs on line 1,   etc, dofs on quad 0, etc.) This function is only available on   [1.x.7] objects (see    [2.x.41]  "this glossary entry").     The cells needs to be an active cell (and not artificial in a parallel   distributed computation).     The vector has to have the right size before being passed to this   function.     The last argument denotes the finite element index. For the standard   ::DoFHandler class, this value must be equal to its default value since   that class only supports the same finite element on all cells anyway.     However, when the relevant DoFHandler object has hp-capabilities enabled,   different finite element objects may be used on different cells. On faces   between two cells, as well as vertices, there may therefore be two sets   of degrees of freedom, one for each of the finite elements used on the   adjacent cells. In order to specify which set of degrees of freedom to   work on, the last argument is used to disambiguate. Finally, if this   function is called for a cell object, there can only be a single set of   degrees of freedom, and fe_index has to match the result of   active_fe_index().     For cells, there is only a single possible finite element index (namely   the one for that cell, returned by  [2.x.42] .   Consequently, the derived DoFCellAccessor class has an overloaded version   of this function that calls the present function with    [2.x.43]  as last argument.  
* [0.x.35]*
   Return the global multilevel indices of the degrees of freedom that live   on the current object with respect to the given level within the   multigrid hierarchy. The indices refer to the local numbering for the   level this line lives on.  
* [0.x.36]*
   Set the level DoF indices that are returned by get_mg_dof_indices.  
* [0.x.37]*
   Global DoF index of the [1.x.8] degree associated with the  [2.x.44]    vertex of the present cell.     The last argument denotes the finite element index. For the standard   ::DoFHandler class, this value must be equal to its default value since   that class only supports the same finite element on all cells anyway.     However, when hp-capabilities are enabled, different finite element   objects may be used on different cells. On faces between two cells, as   well as vertices, there may therefore be two sets of degrees of freedom,   one for each of the finite elements used on the adjacent cells.  In order   to specify which set of degrees of freedom to work on, the last argument   is used to disambiguate. Finally, if this function is called for a cell   object, there can only be a single set of degrees of freedom, and   fe_index has to match the result of active_fe_index().  
* [0.x.38]*
   Return the global DoF index of the  [2.x.45] th degree of freedom   associated with the  [2.x.46] th vertex on level  [2.x.47]  Also   see vertex_dof_index().  
* [0.x.39]*
   Index of the [1.x.9]th degree of freedom of this object.     The last argument denotes the finite element index. For the standard   ::DoFHandler class, this value must be equal to its default value since   that class only supports the same finite element on all cells anyway.     However, when hp-capabilities are enabled, different finite element   objects may be used on different cells. On faces between two cells, as   well as vertices, there may therefore be two sets of degrees of freedom,   one for each of the finite elements used on the adjacent cells.  In order   to specify which set of degrees of freedom to work on, the last argument   is used to disambiguate. Finally, if this function is called for a cell   object, there can only be a single set of degrees of freedom, and   fe_index has to match the result of active_fe_index().    
*  [2.x.48]  While the get_dof_indices() function returns an array that contains   the indices of all degrees of freedom that somehow live on this object   (i.e. on the vertices, edges or interior of this object), the current   dof_index() function only considers the DoFs that really belong to this   particular object's interior. In other words, as an example, if the   current object refers to a quad (a cell in 2d, a face in 3d) and the   finite element associated with it is a bilinear one, then the   get_dof_indices() will return an array of size 4 while dof_index() will   produce an exception because no degrees are defined in the interior of   the face.  
* [0.x.40]*
   Return the dof_index on the given level. Also see dof_index.  
* [0.x.41]*
    [2.x.49]   
* [0.x.42]*
    [2.x.50]  Accessing the finite element associated with this object  
* [0.x.43]*
    [2.x.51]   
* [0.x.44]*
   Return the number of finite elements that are active on a given object.     When hp-capabilities are disabled the answer is, of course, always one.   However, when hp-capabilities are enabled, this isn't the case: If this   is a cell, the answer is of course one. If it is a face, the answer may   be one or two, depending on whether the two adjacent cells use the same   finite element or not. If it is an edge in 3d, the possible return value   may be one or any other value larger than that.  
* [0.x.45]*
   Return the  [2.x.52]  active FE index on this object. For cells and all non-   hp-objects, there is only a single active FE index, so the argument must   be equal to zero. For lower-dimensional hp-objects, there are   n_active_fe_indices() active finite elements, and this function can be   queried for their indices.  
* [0.x.46]*
   Returns all active FE indices on this object.     The size of the returned set equals the number of finite elements that   are active on this object.  
* [0.x.47]*
   Return true if the finite element with given index is active on the   present object. When the current DoFHandler does not have hp-   capabilities, this is of course the case only if  [2.x.53]  equals   zero. For cells, it is the case if  [2.x.54]  equals active_fe_index()   of this cell. For faces and other lower- dimensional objects, there may   be more than one  [2.x.55]  that are active on any given object (see   n_active_fe_indices()).  
* [0.x.48]*
   Return a reference to the finite element used on this object with the   given  [2.x.56]   [2.x.57]  must be used on this object, i.e.    [2.x.58]  must return true.  
* [0.x.49]*
    [2.x.59]   
* [0.x.50]*
   Exceptions for child classes    
*  [2.x.60]   
* [0.x.51]*
   Exception    
*  [2.x.61]   
* [0.x.52]*
   Exception    
*  [2.x.62]   
* [0.x.53]*
   Exception    
*  [2.x.63]   
* [0.x.54]*
   A function has been called for a cell which should be    [2.x.64]  "active",   but is refined.    
*  [2.x.65]   
* [0.x.55]*
   Exception    
*  [2.x.66]   
* [0.x.56]*
   Store the address of the DoFHandler object to be accessed.  
* [0.x.57]*
   Compare for equality. Return <tt>true</tt> if the two accessors refer to   the same object.     The template parameters of this function allow for a comparison of very   different objects. Therefore, some of them are disabled. Namely, if the   dimension, or the dof handler of the two objects differ, an exception is   generated. It can be expected that this is an unwanted comparison.     The template parameter <tt>level_dof_access2</tt> is ignored, such that   an iterator with level access can be equal to one with access to the   active degrees of freedom.  
* [0.x.58]*
   Compare for inequality. The boolean not of operator==().  
* [0.x.59]*
   Reset the DoF handler pointer.  
* [0.x.60]*
   Set the index of the [1.x.10]th degree of freedom of this object to  [2.x.67]    index.     The last argument denotes the finite element index. For the standard   ::DoFHandler class, this value must be equal to its default value since   that class only supports the same finite element on all cells anyway.     However, when the relevant DoFHandler has hp-capabilities, different   finite element objects may be used on different cells. On faces between   two cells, as well as vertices, there may therefore be two sets of   degrees of freedom, one for each of the finite elements used on the   adjacent cells.  In order to specify which set of degrees of freedom to   work on, the last argument is used to disambiguate. Finally, if this   function is called for a cell object, there can only be a single set of   degrees of freedom, and fe_index has to match the result of   active_fe_index().  
* [0.x.61]*
   Set the global index of the [1.x.11] degree on the  [2.x.68]  vertex of   the present cell to  [2.x.69]      The last argument denotes the finite element index. For the standard   ::DoFHandler class, this value must be equal to its default value since   that class only supports the same finite element on all cells anyway.     However, when the relevant DoFHandler has hp-capabilities, different   finite element objects may be used on different cells. On faces between   two cells, as well as vertices, there may therefore be two sets of   degrees of freedom, one for each of the finite elements used on the   adjacent cells.  In order to specify which set of degrees of freedom to   work on, the last argument is used to disambiguate. Finally, if this   function is called for a cell object, there can only be a single set of   degrees of freedom, and fe_index has to match the result of   active_fe_index().  
* [0.x.62]*
 Specialization of the general DoFAccessor class template for the case of zero-dimensional objects (a vertex) that are the face of a one-dimensional cell in spacedim space dimensions. Since vertices function differently than general faces, this class does a few things differently than the general template, but the interface should look the same.

* 
* [0.x.63]*
   A static variable that allows users of this class to discover the value   of the second template argument.  
* [0.x.64]*
   A static variable that allows users of this class to discover the value   of the third template argument.  
* [0.x.65]*
   Declare an alias to the base class to make accessing some of the   exception classes simpler.  
* [0.x.66]*
   Data type passed by the iterator class.  
* [0.x.67]*
    [2.x.70]  Constructors  
* [0.x.68]*
    [2.x.71]   
* [0.x.69]*
   Default constructor. Provides an accessor that can't be used.  
* [0.x.70]*
   Constructor to be used if the object here refers to a vertex of a one-   dimensional triangulation, i.e. a face of the triangulation.     Since there is no mapping from vertices to cells, an accessor object for   a point has no way to figure out whether it is at the boundary of the   domain or not. Consequently, the second argument must be passed by the   object that generates this accessor
* 
*  -  e.g. a 1d cell that can figure out   whether its left or right vertex are at the boundary.     The third argument is the global index of the vertex we point to.     The fourth argument is a pointer to the DoFHandler object.     This iterator can only be called for one-dimensional triangulations.  
* [0.x.71]*
   Constructor. This constructor exists in order to maintain interface   compatibility with the other accessor classes. However, it doesn't do   anything useful here and so may not actually be called.  
* [0.x.72]*
   Conversion constructor. This constructor exists to make certain   constructs simpler to write in dimension independent code. For example,   it allows assigning a face iterator to a line iterator, an operation that   is useful in 2d but doesn't make any sense in 3d. The constructor here   exists for the purpose of making the code conform to C++ but it will   unconditionally abort; in other words, assigning a face iterator to a   line iterator is better put into an if-statement that checks that the   dimension is two, and assign to a quad iterator in 3d (an operator that,   without this constructor would be illegal if we happen to compile for   2d).  
* [0.x.73]*
   Another conversion operator between objects that don't make sense, just   like the previous one.  
* [0.x.74]*
   Copy constructor.  
* [0.x.75]*
   Move constructor.  
* [0.x.76]*
   Destructor.  
* [0.x.77]*
   Copy operator. These operators are usually used in a context like   <tt>iterator a,b;a=*b;</tt>. Presumably, the intent here is to copy the   object pointed to   by  [2.x.72]  to the object pointed to by  [2.x.73]  However, the result of   dereferencing an iterator is not an object but an accessor; consequently,   this operation is not useful for iterators on DoF handler objects.   Consequently, this operator is declared as deleted and can not be used.  
* [0.x.78]*
   Move assignment operator.  
* [0.x.79]*
    [2.x.74]   
* [0.x.80]*
   Return a handle on the DoFHandler object which we are using.  
* [0.x.81]*
   Implement the copy operator needed for the iterator classes.  
* [0.x.82]*
   Copy operator used by the iterator class. Keeps the previously set dof   handler, but sets the object coordinates of the TriaAccessor.  
* [0.x.83]*
    [2.x.75]  Accessing sub-objects  
* [0.x.84]*
    [2.x.76]   
* [0.x.85]*
   Return an invalid iterator of a type that represents pointing to a child   of the current object. The object is invalid because points (as   represented by the current class) do not have children.  
* [0.x.86]*
   Pointer to the  [2.x.77]  line bounding this object.     Since meshes with dimension 1 do not have quads this method just throws   an exception.  
* [0.x.87]*
   Pointer to the  [2.x.78]  quad bounding this object.     Since meshes with dimension 1 do not have quads this method just throws   an exception.  
* [0.x.88]*
    [2.x.79]   
* [0.x.89]*
    [2.x.80]  Accessing the DoF indices of this object  
* [0.x.90]*
    [2.x.81]   
* [0.x.91]*
   Return the [1.x.12] indices of the degrees of freedom located on   this object in the standard ordering defined by the finite element. This   function is only available on [1.x.13] objects (see    [2.x.82]  "this glossary entry").     The present vertex must belong to an active cell (and not artificial in a   parallel distributed computation).     The vector has to have the right size before being passed to this   function.     The last argument denotes the finite element index. For the standard   ::DoFHandler class, this value must be equal to its default value since   that class only supports the same finite element on all cells anyway.     However, when the relevant DoFHandler has hp-capabilities, different   finite element objects may be used on different cells. On faces between   two cells, as well as vertices, there may therefore be two sets of   degrees of freedom, one for each of the finite elements used on the   adjacent cells.  In order to specify which set of degrees of freedom to   work on, the last argument is used to disambiguate. Finally, if this   function is called for a cell object, there can only be a single set of   degrees of freedom, and fe_index has to match the result of   active_fe_index().     For cells, there is only a single possible finite element index (namely   the one for that cell, returned by  [2.x.83] .   Consequently, the derived DoFCellAccessor class has an overloaded version   of this function that calls the present function with    [2.x.84]  as last argument.  
* [0.x.92]*
   Return the global multilevel indices of the degrees of freedom that live   on the current object with respect to the given level within the   multigrid hierarchy. The indices refer to the local numbering for the   level this line lives on.  
* [0.x.93]*
   Global DoF index of the [1.x.14] degree associated with the  [2.x.85]    vertex of the present cell.     The last argument denotes the finite element index. For the standard   ::DoFHandler class, this value must be equal to its default value since   that class only supports the same finite element on all cells anyway.     However, when the relevant DoFHandler has hp-capabilities, different   finite element objects may be used on different cells. On faces between   two cells, as well as vertices, there may therefore be two sets of   degrees of freedom, one for each of the finite elements used on the   adjacent cells.  In order to specify which set of degrees of freedom to   work on, the last argument is used to disambiguate. Finally, if this   function is called for a cell object, there can only be a single set of   degrees of freedom, and fe_index has to match the result of   active_fe_index().  
* [0.x.94]*
   Index of the [1.x.15]th degree of freedom of this object.     The last argument denotes the finite element index. For the standard   ::DoFHandler class, this value must be equal to its default value since   that class only supports the same finite element on all cells anyway.     However, when the relevant DoFHandler has hp-capabilities, different   finite element objects may be used on different cells. On faces between   two cells, as well as vertices, there may therefore be two sets of   degrees of freedom, one for each of the finite elements used on the   adjacent cells.  In order to specify which set of degrees of freedom to   work on, the last argument is used to disambiguate. Finally, if this   function is called for a cell object, there can only be a single set of   degrees of freedom, and fe_index has to match the result of   active_fe_index().  
* [0.x.95]*
    [2.x.86]   
* [0.x.96]*
    [2.x.87]  Accessing the finite element associated with this object  
* [0.x.97]*
    [2.x.88]   
* [0.x.98]*
   Return the number of finite elements that are active on a given object.     Since vertices do not store the information necessary for this to be   calculated, this method just raises an exception and only exists to   enable dimension-independent programming.  
* [0.x.99]*
   Return the  [2.x.89]  active FE index on this object.     Since vertices do not store the information necessary for this to be   calculated, this method just raises an exception and only exists to   enable dimension-independent programming.  
* [0.x.100]*
   Return true if the finite element with given index is active on the   present object.     Since vertices do not store the information necessary for this to be   calculated, this method just raises an exception and only exists to   enable dimension-independent programming.  
* [0.x.101]*
   Return a reference to the finite element used on this object with the   given  [2.x.90]   [2.x.91]  must be used on this object, i.e.    [2.x.92]  must return true.  
* [0.x.102]*
    [2.x.93]   
* [0.x.103]*
   Exceptions for child classes    
*  [2.x.94]   
* [0.x.104]*
   Exception    
*  [2.x.95]   
* [0.x.105]*
   Exception    
*  [2.x.96]   
* [0.x.106]*
   Exception    
*  [2.x.97]   
* [0.x.107]*
   A function has been called for a cell which should be    [2.x.98]  "active",   but is refined.    
*  [2.x.99]   
* [0.x.108]*
   Exception    
*  [2.x.100]   
* [0.x.109]*
   Store the address of the DoFHandler object to be accessed.  
* [0.x.110]*
   Compare for equality.  
* [0.x.111]*
   Compare for inequality.  
* [0.x.112]*
   Reset the DoF handler pointer.  
* [0.x.113]*
   Set the index of the [1.x.16]th degree of freedom of this object to  [2.x.101]    index.     The last argument denotes the finite element index. For the standard   ::DoFHandler class, this value must be equal to its default value since   that class only supports the same finite element on all cells anyway.     However, when the relevant DoFHandler has hp-capabilities, different   finite element objects may be used on different cells. On faces between   two cells, as well as vertices, there may therefore be two sets of   degrees of freedom, one for each of the finite elements used on the   adjacent cells.  In order to specify which set of degrees of freedom to   work on, the last argument is used to disambiguate. Finally, if this   function is called for a cell object, there can only be a single set of   degrees of freedom, and fe_index has to match the result of   active_fe_index().  
* [0.x.114]*
   Set the global index of the [1.x.17] degree on the  [2.x.102]  vertex of   the present cell to  [2.x.103]      The last argument denotes the finite element index. For the standard   ::DoFHandler class, this value must be equal to its default value since   that class only supports the same finite element on all cells anyway.     However, when the relevant DoFHandler has hp-capabilities, different   finite element objects may be used on different cells. On faces between   two cells, as well as vertices, there may therefore be two sets of   degrees of freedom, one for each of the finite elements used on the   adjacent cells.  In order to specify which set of degrees of freedom to   work on, the last argument is used to disambiguate. Finally, if this   function is called for a cell object, there can only be a single set of   degrees of freedom, and fe_index has to match the result of   active_fe_index().  
* [0.x.115]*
 A class that represents DoF accessor objects to iterators that don't make sense such as quad iterators in on 1d meshes.  This class can not be used to create objects (it will in fact throw an exception if this should ever be attempted but it sometimes allows code to be written in a simpler way in a dimension independent way. For example, it allows to write code that works on quad iterators that is dimension independent
* 
*  -  i.e., also compiles in 1d
* 
*  -  because quad iterators (via the current class) exist and are syntactically correct. You can not expect, however, to ever create an actual object of one of these iterators in 1d, meaning you need to expect to wrap the code block in which you use quad iterators into something like  [2.x.104] 
* 
*  -  which makes eminent sense anyway.
*  This class provides the minimal interface necessary for Accessor classes to interact with Iterator classes. However, this is only for syntactic correctness, none of the functions do anything but generate errors.
* 

* 
*  [2.x.105] 

* 
* [0.x.116]*
   Propagate alias from base class to this class.  
* [0.x.117]*
   Constructor.  This class is used for iterators that do not make   sense in a given dimension, for example quads for 1d meshes. Consequently,   while the creation of such objects is syntactically valid, they make no   semantic sense, and we generate an exception when such an object is   actually generated.  
* [0.x.118]*
   Copy constructor.  This class is used for iterators that do not make   sense in a given dimension, for example quads for 1d meshes. Consequently,   while the creation of such objects is syntactically valid, they make no   semantic sense, and we generate an exception when such an object is   actually generated.  
* [0.x.119]*
   Conversion from other accessors to the current invalid one. This of   course also leads to a run-time error.  
* [0.x.120]*
   Return the index of the [1.x.18]th degree of freedom of this object to    [2.x.106]  Since the current object doesn't point to anything useful, like   all other functions in this class this function only throws an exception.  
* [0.x.121]*
   Set the index of the [1.x.19]th degree of freedom of this object to  [2.x.107]    index. Since the current object doesn't point to anything useful, like   all other functions in this class this function only throws an exception.  
* [0.x.122]*
 Grant access to the degrees of freedom on a cell.
*  Note that since for the class we derive from, i.e. <tt>DoFAccessor<dim></tt>, the two template parameters are equal, the base class is actually derived from CellAccessor, which makes the functions of this class available to the DoFCellAccessor class as well.
* 

* 
*  [2.x.108] 

* 
*  [2.x.109] 

* 
* [0.x.123]*
   Extract dimension from DoFHandler.  
* [0.x.124]*
   Extract space dimension from DoFHandler.  
* [0.x.125]*
   Data type passed by the iterator class.  
* [0.x.126]*
   Declare an alias to the base class to make accessing some of the   exception classes simpler.  
* [0.x.127]*
   Define the type of the container this is part of.  
* [0.x.128]*
   A type for an iterator over the faces of a cell. This is what the face()   function returns.  
* [0.x.129]*
    [2.x.110]  Constructors and initialization  
* [0.x.130]*
    [2.x.111]   
* [0.x.131]*
   Constructor  
* [0.x.132]*
   Conversion constructor. This constructor exists to make certain   constructs simpler to write in dimension independent code. For example,   it allows assigning a face iterator to a line iterator, an operation that   is useful in 2d but doesn't make any sense in 3d. The constructor here   exists for the purpose of making the code conform to C++ but it will   unconditionally abort; in other words, assigning a face iterator to a   line iterator is better put into an if-statement that checks that the   dimension is two, and assign to a quad iterator in 3d (an operator that,   without this constructor would be illegal if we happen to compile for   2d).  
* [0.x.133]*
   Another conversion operator between objects that don't make sense, just   like the previous one.  
* [0.x.134]*
   Copy constructor.  
* [0.x.135]*
   Move constructor.  
* [0.x.136]*
   Destructor  
* [0.x.137]*
   Copy operator. These operators are usually used in a context like   <tt>iterator a,b;a=*b;</tt>. Presumably, the intent here is to copy the   object pointed to   by  [2.x.112]  to the object pointed to by  [2.x.113]  However, the result of   dereferencing an iterator is not an object but an accessor; consequently,   this operation is not useful for iterators on DoF handler objects.   Consequently, this operator is declared as deleted and can not be used.  
* [0.x.138]*
   Move assignment operator.  
* [0.x.139]*
    [2.x.114]   
* [0.x.140]*
   Return the parent of this cell as a DoF cell iterator. If the parent does   not exist (i.e., if the object is at the coarsest level of the mesh   hierarchy), an exception is generated.     This function is needed since the parent function of the base class   CellAccessor returns a triangulation cell accessor without access to the   DoF data.  
* [0.x.141]*
    [2.x.115]  Accessing sub-objects and neighbors  
* [0.x.142]*
    [2.x.116]   
* [0.x.143]*
   Return the  [2.x.117]  neighbor as a DoF cell iterator. This function is   needed since the neighbor function of the base class returns a cell   accessor without access to the DoF data.  
* [0.x.144]*
   Return the  [2.x.118]  periodic neighbor as a DoF cell iterator. This function   is needed since the neighbor function of the base class returns a cell   accessor without access to the DoF data.  
* [0.x.145]*
   Return the  [2.x.119]  neighbor or periodic neighbor as a DoF cell iterator.   This function is needed since the neighbor function of the base class   returns a cell accessor without access to the DoF data.  
* [0.x.146]*
   Return the  [2.x.120]  child as a DoF cell iterator. This function is needed   since the child function of the base class returns a cell accessor   without access to the DoF data.  
* [0.x.147]*
   Return an array of iterators to all children of this cell.  
* [0.x.148]*
   Return an iterator to the  [2.x.121]  face of this cell.     This function returns a DoFAccessor with  [2.x.122]  in   1D, a  [2.x.123]  in 2D, and a  [2.x.124]  in 3d.  
* [0.x.149]*
   Return an array of iterators to all faces of this cell.  
* [0.x.150]*
   Return the result of the  [2.x.125]  function of the   base class, but convert it so that one can also access the DoF data (the   function in the base class only returns an iterator with access to the   triangulation data).  
* [0.x.151]*
   Return the result of the  [2.x.126]  function   of the base class, but convert it so that one can also access the DoF   data (the function in the base class only returns an iterator with access   to the triangulation data).  
* [0.x.152]*
    [2.x.127]   
* [0.x.153]*
    [2.x.128]  Extracting values from global vectors  
* [0.x.154]*
    [2.x.129]   
* [0.x.155]*
   Collect the values of the given vector restricted to the dofs of this cell   in the standard ordering: dofs on vertex 0, dofs on vertex 1, etc, dofs   on line 0, dofs on line 1, etc, dofs on quad 0, etc. In other   words, this function implements a   [gather   operation](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)).     The vector has to have the right size before being passed to this   function. This function is only callable for active cells.     The input vector may be either a <tt>Vector<float></tt>, Vector<double>,   or a BlockVector<double>, or a PETSc or Trilinos vector if deal.II is   compiled to support these libraries. It is in the responsibility of the   caller to assure that the types of the numbers stored in input and output   vectors are compatible and with similar accuracy.  
* [0.x.156]*
   Collect the values of the given vector restricted to the dofs of this cell   in the standard ordering: dofs on vertex 0, dofs on vertex 1, etc, dofs   on line 0, dofs on line 1, etc, dofs on quad 0, etc. In other   words, this function implements a   [gather   operation](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)).     The vector has to have the right size before being passed to this   function. This function is only callable for active cells.     The input vector may be either a <tt>Vector<float></tt>, Vector<double>,   or a BlockVector<double>, or a PETSc or Trilinos vector if deal.II is   compiled to support these libraries. It is in the responsibility of the   caller to assure that the types of the numbers stored in input and output   vectors are compatible and with similar accuracy.  
* [0.x.157]*
   Collect the values of the given vector restricted to the dofs of this cell   in the standard ordering: dofs on vertex 0, dofs on vertex 1, etc, dofs   on line 0, dofs on line 1, etc, dofs on quad 0, etc. In other   words, this function implements a   [gather   operation](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)).     The vector has to have the right size before being passed to this   function. This function is only callable for active cells.     The input vector may be either a <tt>Vector<float></tt>, Vector<double>,   or a BlockVector<double>, or a PETSc or Trilinos vector if deal.II is   compiled to support these libraries. It is in the responsibility of the   caller to assure that the types of the numbers stored in input and output   vectors are compatible and with similar accuracy. The   AffineConstraints object passed as an argument to this function makes   sure that constraints are correctly distributed when the dof values   are calculated.  
* [0.x.158]*
   This function is the counterpart to get_dof_values(): it takes a vector   of values for the degrees of freedom of the cell pointed to by this   iterator and writes these values into the global data vector  [2.x.130]    In other words, this function implements a   [scatter   operation](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)).   This function is only callable for active cells.     Note that for continuous finite elements, calling this function affects   the dof values on neighboring cells as well. It may also violate   continuity requirements for hanging nodes, if neighboring cells are less   refined than the present one. These requirements are not taken care of   and must be enforced by the user afterwards.     The vector has to have the right size before being passed to this   function.     The output vector may be either a Vector<float>, Vector<double>, or a   BlockVector<double>, or a PETSc vector if deal.II is compiled to support   these libraries. It is in the responsibility of the caller to assure that   the types of the numbers stored in input and output vectors are   compatible and with similar accuracy.  
* [0.x.159]*
   Return the interpolation of the given finite element function to the   present cell. In the simplest case, the cell is a terminal one, i.e., it   has no children; then, the returned value is the vector of nodal values   on that cell. You could as well get the desired values through the  [2.x.131]    get_dof_values function. In the other case, when the cell has children,   we use the restriction matrices provided by the finite element class to   compute the interpolation from the children to the present cell.     If the cell is part of a DoFHandler with hp-capabilities, cells only have   an associated finite element space if they are active. However, this   function is supposed to also provide information on inactive cells with   children. Consequently, it carries a third argument that can be used in   the hp-context that denotes the finite element space we are supposed to   interpolate onto. If the cell is active, this function then obtains the   finite element function from the  [2.x.132]  vector on this cell   and interpolates it onto the space described by the    [2.x.133] th element of the  [2.x.134]  associated with   the DoFHandler of which this cell is a part of. If the cell is not   active, then we first perform this interpolation on all of its terminal   children and then interpolate this function down to the cell requested   keeping the function space the same.     It is assumed that both input vectors already have the right size   beforehand.    
*  [2.x.135]  Unlike the get_dof_values() function, this function is only   available on cells, rather than on lines, quads, and hexes, since   interpolation is presently only provided for cells by the finite element   classes.  
* [0.x.160]*
   This function is the counterpart to get_interpolated_dof_values(): you   specify the dof values on a cell and these are interpolated to the   children of the present cell and set on the terminal cells.     In principle, it works as follows: if the cell pointed to by this object   is terminal (i.e., has no children), then the dof values are set in the   global data vector by calling the set_dof_values() function; otherwise,   the values are prolonged to each of the children and this function is   called for each of them.     Using the get_interpolated_dof_values() and this function, you can   compute the interpolation of a finite element function to a coarser grid   by first getting the interpolated solution on a cell of the coarse grid   and afterwards redistributing it using this function.     Note that for continuous finite elements, calling this function affects   the dof values on neighboring cells as well. It may also violate   continuity requirements for hanging nodes, if neighboring cells are less   refined than the present one, or if their children are less refined than   the children of this cell. These requirements are not taken care of and   must be enforced by the user afterward.     If the cell is part of a DoFHandler with hp-capabilities, cells only have   an associated finite element space if they are active. However, this   function is supposed to also work on inactive cells with children.   Consequently, it carries a third argument that can be used in the hp-   context that denotes the finite element space we are supposed to   interpret the input vector of this function in. If the cell is active,   this function then interpolates the input vector interpreted as an   element of the space described by the  [2.x.136] th element of   the  [2.x.137]  associated with the DoFHandler of which this   cell is a part of, and interpolates it into the space that is associated   with this cell. On the other hand, if the cell is not active, then we   first perform this interpolation from this cell to its children using the   given  [2.x.138]  until we end up on an active cell, at which   point we follow the procedure outlined at the beginning of the paragraph.     It is assumed that both vectors already have the right size beforehand.   This function relies on the existence of a natural interpolation property   of finite element spaces of a cell to its children, denoted by the   prolongation matrices of finite element classes. For some elements, the   spaces on coarse and fine grids are not nested, in which case the   interpolation to a child is not the identity; refer to the documentation   of the respective finite element class for a description of what the   prolongation matrices represent in this case.    
*  [2.x.139]  Unlike the get_dof_values() function, this function is only   available on cells, rather than on lines, quads, and hexes, since   interpolation is presently only provided for cells by the finite element   classes.  
* [0.x.161]*
   Distribute a local (cell based) vector to a global one by mapping the   local numbering of the degrees of freedom to the global one and entering   the local values into the global vector. In other words, this function   implements a   [scatter   operation](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)).     The elements are  [2.x.140] added [2.x.141]  to the existing elements in the global   vector, rather than just set, since this is usually what one wants. You may   also want to take a look at the    [2.x.142]  function if you need to   deal with constraints.  
* [0.x.162]*
   Distribute a local (cell based) vector in iterator format to a global one   by mapping the local numbering of the degrees of freedom to the global   one and entering the local values into the global vector.   In other words, this function implements a   [scatter   operation](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)).     The elements are  [2.x.143] added [2.x.144]  to the existing elements in the global   vector, rather than just set, since this is usually what one wants. You may   also want to take a look at the    [2.x.145]  function if you need to   deal with constraints.  
* [0.x.163]*
   Distribute a local (cell based) vector in iterator format to a global one   by mapping the local numbering of the degrees of freedom to the global   one and entering the local values into the global vector.   In other words, this function implements a   [scatter   operation](https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)).     The elements are  [2.x.146] added [2.x.147]  up to the elements in the global vector,   rather than just set, since this is usually what one wants. Moreover, the   AffineConstraints object passed to this function makes sure that also   constraints are eliminated in this process.  
* [0.x.164]*
   This function does much the same as the   <tt>distribute_local_to_global(Vector,Vector)</tt> function, but operates   on matrices instead of vectors. If the matrix type is a sparse matrix   then it is supposed to have non-zero entry slots where required.  
* [0.x.165]*
   This function does what the two <tt>distribute_local_to_global</tt>   functions with vector and matrix argument do, but all at once.  
* [0.x.166]*
    [2.x.148]   
* [0.x.167]*
    [2.x.149]  Accessing the DoF indices of this object  
* [0.x.168]*
    [2.x.150]   
* [0.x.169]*
   Obtain the global indices of the local degrees of freedom on this cell.     If this object accesses a level cell (indicated by the third template   argument or #is_level_cell), then return the result of   get_mg_dof_indices(), else return get_dof_indices().     You will get a level_cell_iterator when calling begin_mg() and a normal   one otherwise.     Examples for this use are in the implementation of DoFRenumbering.  
* [0.x.170]*
   Return the [1.x.20] indices of the degrees of freedom located on   this object in the standard ordering defined by the finite element (i.e.,   dofs on vertex 0, dofs on vertex 1, etc, dofs on line 0, dofs on line 1,   etc, dofs on quad 0, etc.) This function is only available on   [1.x.21] objects (see    [2.x.151]  "this glossary entry").      [2.x.152]  dof_indices The vector into which the indices will be   written. It has to have the right size (namely,    [2.x.153] , or    [2.x.154] , depending on which kind of object this   function is called) before being passed to this function.     This function reimplements the same function in the base class. In   contrast to the function in the base class, we do not need the    [2.x.155]  here because there is always a unique finite   element index on cells.     This is a function which requires that the cell is active.     Also see get_active_or_mg_dof_indices().    
*  [2.x.156]  In many places in the tutorial and elsewhere in the library, the   argument to this function is called  [2.x.157]  by   convention. The name is not meant to indicate the [1.x.22] numbers of   degrees of freedom (which are always between zero and    [2.x.158] ) but instead that the returned values are   the [1.x.23] indices of those degrees of freedom that are located   locally on the current cell.  
* [0.x.171]*
   Retrieve the global indices of the degrees of freedom on this cell in the   level vector associated to the level of the cell.  
* [0.x.172]*
    [2.x.159]   
* [0.x.173]*
    [2.x.160]  Accessing the finite element associated with this object  
* [0.x.174]*
    [2.x.161]   
* [0.x.175]*
   Return the finite element that is used on the cell pointed to by this   iterator. For DoFHandler objects without hp-capabilities, this is of   course always the same element, independent of the cell we are presently   on, but for hp-DoFHandler objects this may change from cell to cell.    
*  [2.x.162]  Since degrees of freedom only exist on active cells for DoFHandler   objects with hp-capabilities (i.e., there is currently no implementation   of multilevel such objects), it does not make sense to query the finite   element on non-active cells since they do not have finite element spaces   associated with them without having any degrees of freedom. Consequently,   this function will produce an exception when called on non-active cells.  
* [0.x.176]*
   Return the index inside the  [2.x.163]  of the FiniteElement used   for this cell. This function is only useful if the DoFHandler object   associated with the current cell has hp-capabilities enabled.    
*  [2.x.164]  Since degrees of freedom only exist on active cells for DoFHandler   objects with hp-capabilities (i.e., there is currently no implementation   of multilevel such objects), it does not make sense to query the finite   element on non-active cells since they do not have finite element spaces   associated with them without having any degrees of freedom. Consequently,   this function will produce an exception when called on non-active cells.    
*  [2.x.165]  When using parallel meshes, either through the    [2.x.166]  or  [2.x.167]    classes, it is only allowed to call this function on locally   owned or ghost cells. No information is available on artificial cells.   Furthermore,  [2.x.168]  information is only exchanged from locally   owned cells on one processor to other processors where they may be   ghost cells, during the call to  [2.x.169]  and    [2.x.170]  Be aware that if you call   set_active_fe_index() on a cell after calling one of these functions, then   this information will not be propagated to other processors who may have   this cell as a ghost cell. See the documentation of DoFHandler for more   information.  
* [0.x.177]*
   Set the index of the FiniteElement used for this cell. This determines   which element in an  [2.x.171]  to use. This function is only useful   if the DoF handler object associated with the current cell has hp-   capabilities enabled.    
*  [2.x.172]  Since degrees of freedom only exist on active cells for DoFHandler   objects with hp-capabilities (i.e., there is currently no implementation   of multilevel such objects), it does not make sense to query the finite   element on non-active cells since they do not have finite element spaces   associated with them without having any degrees of freedom. Consequently,   this function will produce an exception when called on non-active cells.    
*  [2.x.173]  When using parallel meshes, either through the    [2.x.174]  or  [2.x.175]    classes, it is only allowed to call this function on locally   owned or ghost cells. No information is available on artificial cells.   Furthermore,  [2.x.176]  information is only exchanged from locally   owned cells on one processor to other processors where they may be   ghost cells, during the call to  [2.x.177]  and    [2.x.178]  Be aware that if you call   set_active_fe_index() on a cell after calling one of these functions, then   this information will not be propagated to other processors who may have   this cell as a ghost cell. See the documentation of DoFHandler for more   information.  
* [0.x.178]*
    [2.x.179]   
* [0.x.179]*
   Set the DoF indices of this cell to the given values. This function   bypasses the DoF cache, if one exists for the given DoF handler class.  
* [0.x.180]*
   Set the Level DoF indices of this cell to the given values.  
* [0.x.181]*
   Update the cache in which we store the dof indices of this cell.  
* [0.x.182]*
    [2.x.180]  Dealing with refinement indicators  
* [0.x.183]*
    [2.x.181]   
* [0.x.184]*
   Return the finite element that will be assigned to this cell next time the   triangulation gets refined and coarsened. If no future finite element has   been specified for this cell via the set_future_fe_index() function, the   active one will remain unchanged, in which case the active finite element   will be returned.     For DoFHandlers without hp-capabilities enabled, this is of course always   the same element, independent of the cell we are presently on, but for hp-   DoFHandler objects this may change from cell to cell.    
*  [2.x.182]  Since degrees of freedom only exist on active cells for DoFHandler   objects with hp-capabilities (i.e., there is currently no implementation   of multilevel such objects), it does not make sense to query the finite   element on non-active cells since they do not have finite element spaces   associated with them without having any degrees of freedom. Consequently,   this function will produce an exception when called on non-active cells.  
* [0.x.185]*
   Return the fe_index of the finite element that will be assigned to this   cell next time the triangulation gets refined and coarsened. If no future   finite element has been specified for this cell via the   set_future_fe_index() function, the active one will remain unchanged, in   which case the fe_index of the active finite element will be returned.    
*  [2.x.183]  Since degrees of freedom only exist on active cells for DoFHandler   objects with hp-capabilities (i.e., there is currently no implementation   of multilevel such objects), it does not make sense to query the finite   element on non-active cells since they do not have finite element spaces   associated with them without having any degrees of freedom. Consequently,   this function will produce an exception when called on non-active cells.    
*  [2.x.184]  When using parallel meshes, either through the    [2.x.185]  or  [2.x.186]    classes, it is only allowed to call this function on locally owned cells.  
* [0.x.186]*
   Set the fe_index of the finite element that will be assigned to this   cell next time the triangulation gets refined and coarsened. A previously   assigned future finite element will be overwritten.     See notes of future_fe_index() for information about restrictions on this   functionality.  
* [0.x.187]*
   Return whether a future finite element has been set.     See notes of future_fe_index() for information about restrictions on this   functionality.  
* [0.x.188]*
   Revoke the future finite element assigned. Thus, the active finite element   will remain unchanged next time the triangulation gets refined and   coarsened.     See notes on future_fe_index() for information about restrictions on this   functionality.  
* [0.x.189]*
    [2.x.187]   
* [0.x.190]

include/deal.II-translator/dofs/dof_faces_0.txt
[0.x.0]*
   A namespace for internal data structures of the DoFHandler group of   classes.    
*  [2.x.0]   
* [0.x.1]*
         [1.x.0]         These classes are similar to the DoFLevel classes. We here store     information that is associated with faces, rather than cells, as this     information is independent of the hierarchical structure of cells,     which are organized in levels. In 2D we store information on degrees of     freedom located on lines whereas in 3D we store information on degrees     of freedom located on quads and lines. In 1D we do nothing, as the     faces of lines are vertices which are treated separately.         Apart from the DoFObjects object containing the data to store (degree     of freedom indices) we do not store any data or provide any     functionality. However, we do implement a function to determine an     estimate of the memory consumption of the contained DoFObjects     object(s).         The data contained isn't usually directly accessed. Rather, except for     some access from the DoFHandler class, access is usually through the      [2.x.1]  and  [2.x.2]  functions or     similar functions of derived classes that in turn access the member     variables using the  [2.x.3]  and corresponding     setter functions. Knowledge of the actual data format is therefore     encapsulated to the present hierarchy of classes as well as the      [2.x.4]  class.    
* [0.x.2]*
       Constructor. This constructor is deleted to prevent the use of this       template, as only the specializations should be used      
* [0.x.3]*
     Store the indices of degrees of freedom on faces in 1D. As these would     be vertices, which are treated separately, don't do anything.    
* [0.x.4]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.5]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).            
* [0.x.6]*
     Store the indices of degrees of freedom on faces in 2D, which are     lines.    
* [0.x.7]*
       The object containing the data of DoFs on lines.      
* [0.x.8]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.9]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.10]*
     Store the indices of degrees of freedom on faces in 3D, which are     quads, additionally also on lines.    
* [0.x.11]*
       The object containing the data of DoFs on lines.      
* [0.x.12]*
       The object containing the data of DoFs on quads.      
* [0.x.13]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.14]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.15]

include/deal.II-translator/dofs/dof_handler_0.txt
[0.x.0]*
 Given a triangulation and a description of a finite element, this class enumerates degrees of freedom on all vertices, edges, faces, and cells of the triangulation. As a result, it also provides a [1.x.0] for a discrete space  [2.x.0]  whose elements are finite element functions defined on each cell by a FiniteElement object. This class satisfies the  [2.x.1]  "MeshType concept" requirements.
*  It is first used in the  [2.x.2]  tutorial program.
*  For each vertex, line, quad, etc, this class stores a list of the indices of degrees of freedom living on this object. These indices refer to the unconstrained degrees of freedom, i.e. constrained degrees of freedom are numbered in the same way as unconstrained ones, and are only later eliminated.  This leads to the fact that indices in global vectors and matrices also refer to all degrees of freedom and some kind of condensation is needed to restrict the systems of equations to the unconstrained degrees of freedom only. The actual layout of storage of the indices is described in the  [2.x.3]  class documentation.
*  The class offers iterators to traverse all cells, in much the same way as the Triangulation class does. Using the begin() and end() functions (and companions, like begin_active()), one can obtain iterators to walk over cells, and query the degree of freedom structures as well as the triangulation data. These iterators are built on top of those of the Triangulation class, but offer the additional information on degrees of freedom functionality compared to pure triangulation iterators. The order in which dof iterators are presented by the <tt>++</tt> and <tt>\--</tt> operators is the same as that for the corresponding iterators traversing the triangulation on which this DoFHandler is constructed.
*  The <tt>spacedim</tt> parameter has to be used if one wants to solve problems on surfaces. If not specified, this parameter takes the default value <tt>=dim</tt> implying that we want to solve problems in a domain whose dimension equals the dimension of the space in which it is embedded.
* 

*  [1.x.1]
*  The degrees of freedom (`dofs') are distributed on the given triangulation by the function distribute_dofs(). It gets passed a finite element object describing how many degrees of freedom are located on vertices, lines, etc. It traverses the triangulation cell by cell and numbers the dofs of that cell if not yet numbered. For non-multigrid algorithms, only active cells are considered. Active cells are defined to be those cells which have no children, i.e. they are the most refined ones.
*  Since the triangulation is traversed starting with the cells of the coarsest active level and going to more refined levels, the lowest numbers for dofs are given to the largest cells as well as their bounding lines and vertices, with the dofs of more refined cells getting higher numbers.
*  This numbering implies very large bandwidths of the resulting matrices and is thus vastly suboptimal for some solution algorithms. For this reason, the DoFRenumbering class offers several algorithms to reorder the dof numbering according. See there for a discussion of the implemented algorithms.
* 

*  [1.x.2]
*  Upon construction, this class takes a reference to a triangulation object. In most cases, this will be a reference to an object of type Triangulation, i.e. the class that represents triangulations that entirely reside on a single processor. However, it can also be of type  [2.x.4]  (see, for example,  [2.x.5] ,  [2.x.6]  and in particular the  [2.x.7]  module) in which case the DoFHandler object will proceed to only manage degrees of freedom on locally owned and ghost cells. This process is entirely transparent to the used.
* 

*  [1.x.3]
*  The DoFRenumbering class offers a number of renumbering schemes like the Cuthill-McKee scheme. Basically, the function sets up an array in which for each degree of freedom we store the new index this DoF should have after renumbering. Using this array, the renumber_dofs() function of the present class is called, which actually performs the change from old DoF indices to the ones given in the array. In some cases, however, a user may want to compute their own renumbering order; in this case, one can allocate an array with one element per degree of freedom and fill it with the number that the respective degree of freedom shall be assigned. This number may, for example, be obtained by sorting the support points of the degrees of freedom in downwind direction.  Then call the  [2.x.8]  function with the array, which converts old into new degree of freedom indices.
* 

*  [1.x.4]
*  Like many other classes in deal.II, the DoFHandler class can stream its contents to an archive using BOOST's serialization facilities. The data so stored can later be retrieved again from the archive to restore the contents of this object. This facility is frequently used to save the state of a program to disk for possible later resurrection, often in the context of checkpoint/restart strategies for long running computations or on computers that aren't very reliable (e.g. on very large clusters where individual nodes occasionally fail and then bring down an entire MPI job).
*  The model for doing so is similar for the DoFHandler class as it is for the Triangulation class (see the section in the general documentation of that class). In particular, the load() function does not exactly restore the same state as was stored previously using the save() function. Rather, the function assumes that you load data into a DoFHandler object that is already associated with a triangulation that has a content that matches the one that was used when the data was saved. Likewise, the load() function assumes that the current object is already associated with a finite element object that matches the one that was associated with it when data was saved; the latter can be achieved by calling  [2.x.9]  using the same kind of finite element before re-loading data from the serialization archive.
* 

*  [1.x.5]
*  Instead of only using one particular FiniteElement on all cells, this class also allows for an enumeration of degrees of freedom on different finite elements on every cells. To this end, one assigns an  [2.x.10]  to every cell that indicates which element within a collection of finite elements (represented by an object of type  [2.x.11]  is the one that lives on this cell. The class then enumerates the degree of freedom associated with these finite elements on each cell of a triangulation and, if possible, identifies degrees of freedom at the interfaces of cells if they match. If neighboring cells have degrees of freedom along the common interface that do not immediate match (for example, if you have  [2.x.12]  and  [2.x.13]  elements meeting at a common face), then one needs to compute constraints to ensure that the resulting finite element space on the mesh remains conforming.
*  The whole process of working with objects of this type is explained in  [2.x.14] . Many of the algorithms this class implements are described in the  [2.x.15]  "hp-paper".
* 

*  [1.x.6]
*  The typical workflow for using this class is to create a mesh, assign an active FE index to every active cell, call  [2.x.16]  and then assemble a linear system and solve a problem on this finite element space.
*  Active FE indices will be automatically transferred during mesh adaptation from the old to the new mesh. Future FE indices are meant to determine the active FE index after mesh adaptation, and are used to prepare data on the old mesh for the new one. If no future FE index is specified, the finite element prevails.
*  In particular, the following rules apply during adaptation:
* 

* 
* 
*  - Upon mesh refinement, child cells inherit the future FE index of   the parent.
* 

* 
* 
*  - When coarsening cells, the (now active) parent cell will be assigned   a future FE index that is determined from its (no longer active)   children, following the FiniteElementDomination logic: Out of the set of   elements previously assigned to the former children, we choose the one   dominated by all children for the parent cell. If none was found, we pick   the most dominant element in the whole collection that is dominated by   all former children. See  [2.x.17]    for further information on this topic.
*  Strategies for automatic hp-adaptation which will set future FE indices based on criteria are available in the  [2.x.18]  namespace.
* 

*  [1.x.7]
*  When this class is used with either a  [2.x.19]  or a  [2.x.20]  you can only set active FE indices on cells that are locally owned, using a call such as  [2.x.21] . On the other hand, setting the active FE index on ghost or artificial cells is not allowed.
*  Ghost cells do acquire the information what element is active on them, however: whenever you call  [2.x.22]  all processors that participate in the parallel mesh exchange information in such a way that the active FE index on ghost cells equals the active FE index that was set on that processor that owned that particular ghost cell. Consequently, one can [1.x.8] the  [2.x.23]  on ghost cells, just not set it by hand.
*  On artificial cells, no information is available about the  [2.x.24]  used there. That's because we don't even know whether these cells exist at all, and even if they did, the current processor does not know anything specific about them. See  [2.x.25]  "the glossary entry on artificial cells" for more information.
*  During refinement and coarsening, information about the  [2.x.26]  of each cell will be automatically transferred.
*  However, using a  [2.x.27]  with a DoFHandler in hp-mode requires additional attention during serialization, since no information on active FE indices will be automatically transferred. This has to be done manually using the prepare_for_serialization_of_active_fe_indices() and deserialize_active_fe_indices() functions. The former has to be called before  [2.x.28]  is invoked, and the latter needs to be run after  [2.x.29]  If further data will be attached to the triangulation via the  [2.x.30]   [2.x.31]  or  [2.x.32]  classes, all corresponding preparation and deserialization function calls need to happen in the same order. Consult the documentation of  [2.x.33]  for more information.
* 

* 
*  [2.x.34] 

* 
* [0.x.1]*
   An alias that is used to identify cell iterators in DoFHandler objects.   The concept of iterators is discussed at length in the    [2.x.35]  "iterators documentation module".     The current alias works, in essence, like the corresponding    [2.x.36]  alias. However, it also makes available   the member functions of DoFCellAccessor, in addition to the ones   already available through the CellAccessor class.    
*  [2.x.37]   
* [0.x.2]*
   An alias that is used to identify iterators that point to faces.   The concept of iterators is discussed at length in the    [2.x.38]  "iterators documentation module".     The current alias works, in essence, like the corresponding    [2.x.39]  alias. However, it also makes available   the member functions of DoFAccessor, in addition to the ones   already available through the TriaAccessor class.    
*  [2.x.40]   
* [0.x.3]*
   An alias that defines an iterator over the (one-dimensional) lines   of a mesh. In one-dimensional meshes, these are the cells of the mesh,   whereas in two-dimensional meshes the lines are the faces of cells.    
*  [2.x.41]   
* [0.x.4]*
   An alias that allows iterating over the [1.x.9] lines, i.e.,   that subset of lines that have no children. In one-dimensional meshes,   these are the cells of the mesh, whereas in two-dimensional   meshes the lines are the faces of cells.     In two- or three-dimensional meshes, lines without children (i.e.,   the active lines) are part of at least one active cell. Each such line may   additionally be a child of a line of a coarser cell adjacent to a cell   that is active. (This coarser neighbor would then also be active.)    
*  [2.x.42]   
* [0.x.5]*
   An alias that defines an iterator over the (two-dimensional) quads   of a mesh. In two-dimensional meshes, these are the cells of the mesh,   whereas in three-dimensional meshes the quads are the faces of cells.    
*  [2.x.43]   
* [0.x.6]*
   An alias that allows iterating over the [1.x.10] quads, i.e.,   that subset of quads that have no children. In two-dimensional meshes,   these are the cells of the mesh, whereas in three-dimensional   meshes the quads are the faces of cells.     In three-dimensional meshes, quads without children (i.e.,   the active quads) are faces of at least one active cell. Each such quad may   additionally be a child of a quad face of a coarser cell adjacent to a cell   that is active. (This coarser neighbor would then also be active.)    
*  [2.x.44]   
* [0.x.7]*
   An alias that defines an iterator over the (three-dimensional) hexes   of a mesh. This iterator only makes sense in three-dimensional meshes,   where hexes are the cells of the mesh.    
*  [2.x.45]   
* [0.x.8]*
   An alias that allows iterating over the [1.x.11] hexes of a mesh.   This iterator only makes sense in three-dimensional meshes,   where hexes are the cells of the mesh. Consequently, in these   three-dimensional meshes, this iterator is equivalent to the    [2.x.46]  alias.    
*  [2.x.47]   
* [0.x.9]*
   An alias that is used to identify    [2.x.48]  "active cell iterators".   The concept of iterators is discussed at length in the    [2.x.49]  "iterators documentation module".     The current alias identifies active cells in a DoFHandler object. While   the actual data type of the alias is hidden behind a few layers of   (unfortunately necessary) indirections, it is in essence   TriaActiveIterator<DoFCellAccessor>. The TriaActiveIterator class works   like a pointer to active objects that when you dereference it yields an   object of type DoFCellAccessor. DoFCellAccessor is a class that   identifies properties that are specific to cells in a DoFHandler, but it   is derived (and consequently inherits) from both DoFAccessor,   TriaCellAccessor and TriaAccessor that describe what you can ask of more   general objects (lines, faces, as well as cells) in a triangulation and   DoFHandler objects.    
*  [2.x.50]   
* [0.x.10]*
   An alias that is used to identify cell iterators. The concept of   iterators is discussed at length in the    [2.x.51]  "iterators documentation module".     The current alias identifies cells in a DoFHandler object. Some of   these cells may in fact be active (see    [2.x.52]  "active cell iterators")   in which case they can in fact be asked for the degrees of freedom that   live on them. On the other hand, if the cell is not active, any such   query will result in an error. Note that this is what distinguishes this   alias from the level_cell_iterator alias.     While the actual data type of the alias is hidden behind a few layers   of (unfortunately necessary) indirections, it is in essence   TriaIterator<DoFCellAccessor>. The TriaIterator class works like a   pointer to objects that when you dereference it yields an object of type   DoFCellAccessor. DoFCellAccessor is a class that identifies properties   that are specific to cells in a DoFHandler, but it is derived (and   consequently inherits) from both DoFAccessor, TriaCellAccessor and   TriaAccessor that describe what you can ask of more general objects   (lines, faces, as well as cells) in a triangulation and DoFHandler   objects.    
*  [2.x.53]   
* [0.x.11]*
   An alias that is used to identify iterators that point to faces.   The concept of iterators is discussed at length in the    [2.x.54]  "iterators documentation module".     While the actual data type of the alias is hidden behind a few layers   of (unfortunately necessary) indirections, it is in essence   TriaIterator<DoFAccessor>. The   TriaIterator class works like a pointer to objects that when   you dereference it yields an object of type DoFAccessor. DoFAccessor,   in turn, is a class that can be used to query DoF indices on faces,   but it is also derived from TriaAccessor and consequently can be used   to query geometric properties such as vertices of faces, their area, etc.    
*  [2.x.55]   
* [0.x.12]*
   An alias that is used to identify iterators that point to active faces,   i.e., to faces that have no children. Active faces must be faces of at   least one active cell.     Other than the "active" qualification, this alias is identical to the    [2.x.56]  alias. In particular, dereferencing either yields   the same kind of object.    
*  [2.x.57]   
* [0.x.13]*
   Make the dimension available in function templates.  
* [0.x.14]*
   Make the space dimension available in function templates.  
* [0.x.15]*
   The default index of the finite element to be used on a given cell.  
* [0.x.16]*
   Invalid index of the finite element to be used on a given cell.  
* [0.x.17]*
   The type in which we store the active FE index.  
* [0.x.18]*
   The type in which we store the offsets in the CRS data structures.  
* [0.x.19]*
   Invalid active FE index which will be used as a default value to determine   whether a future FE index has been set or not.  
* [0.x.20]*
   Standard constructor, not initializing any data. After constructing an   object with this constructor, use reinit() to get a valid DoFHandler.  
* [0.x.21]*
   Constructor. Take  [2.x.58]  as the triangulation to work on.  
* [0.x.22]*
   Copy constructor. DoFHandler objects are large and expensive.   They should not be copied, in particular not by accident, but   rather deliberately constructed. As a consequence, this constructor   is explicitly removed from the interface of this class.  
* [0.x.23]*
   Destructor.  
* [0.x.24]*
   Copy operator. DoFHandler objects are large and expensive.   They should not be copied, in particular not by accident, but   rather deliberately constructed. As a consequence, this operator   is explicitly removed from the interface of this class.  
* [0.x.25]*
   Assign a Triangulation and a FiniteElement to the DoFHandler and compute   the distribution of degrees of freedom over the mesh.      [2.x.59]  Use reinit() and distribute_dofs() instead.  
* [0.x.26]*
   Same as above but taking an  [2.x.60]  object.      [2.x.61]  Use reinit() and distribute_dofs() instead.  
* [0.x.27]*
   Assign a FiniteElement  [2.x.62]  to this object.    
*  [2.x.63]  This function makes a copy of the finite element given as   argument, and stores it as a member variable. Consequently, it is   possible to write code such as  
* [1.x.12]
*    You can then access the finite element later on by calling    [2.x.64]  However, it is often more convenient to   keep a named finite element object as a member variable in your   main class and refer to it directly whenever you need to access   properties of the finite element (such as    [2.x.65]  This is what all tutorial programs do.      [2.x.66]  This function only sets a FiniteElement. Degrees of freedom have   either not been distributed yet, or are distributed using a previously set   element. In both cases, accessing degrees of freedom will lead to invalid   results. To restore consistency, call distribute_dofs().      [2.x.67]  Use distribute_dofs() instead.  
* [0.x.28]*
   Same as above but taking an  [2.x.68]  object.      [2.x.69]  Use distribute_dofs() instead.  
* [0.x.29]*
   Go through the triangulation and set the active FE indices of all   active cells to the values given in  [2.x.70]   
* [0.x.30]*
   Go through the triangulation and store the active FE indices of all   active cells to the vector  [2.x.71]  This vector is   resized, if necessary.  
* [0.x.31]*
   Assign a Triangulation to the DoFHandler.     Remove all associations with the previous Triangulation object and   establish connections with the new one. All information about previous   degrees of freedom will be removed. Activates hp-mode.  
* [0.x.32]*
   Go through the triangulation and "distribute" the degrees of   freedom needed for the given finite element. "Distributing"   degrees of freedom involves allocating memory to store the   indices on all entities on which degrees of freedom can be   located (e.g., vertices, edges, faces, etc.) and to then enumerate   all degrees of freedom. In other words, while the mesh and the   finite element object by themselves simply define a finite   element space  [2.x.72] , the process of distributing degrees of   freedom makes sure that there is a basis for this space and that   the shape functions of this basis are enumerated in an indexable,   predictable way.     The exact order in which degrees of freedom on a mesh are   ordered, i.e., the order in which basis functions of the finite   element space are enumerated, is something that deal.II treats as   an implementation detail. By and large, degrees of freedom are   enumerated in the same order in which we traverse cells, but you   should not rely on any specific numbering. In contrast, if you   want a particular ordering, use the functions in namespace   DoFRenumbering.     This function is first discussed in the introduction to the    [2.x.73]  tutorial program.    
*  [2.x.74]  This function makes a copy of the finite element given as   argument, and stores it as a member variable, similarly to the above   function set_fe().  
* [0.x.33]*
   Same as above but taking an  [2.x.75]  object.  
* [0.x.34]*
   Distribute level degrees of freedom on each level for geometric   multigrid. The active DoFs need to be distributed using distribute_dofs()   before calling this function.  
* [0.x.35]*
   Returns whether this DoFHandler has hp-capabilities.  
* [0.x.36]*
   This function returns whether this DoFHandler has DoFs distributed on   each multigrid level or in other words if distribute_mg_dofs() has been   called.  
* [0.x.37]*
   This function returns whether this DoFHandler has active DoFs. This is   equivalent to asking whether (i) distribute_dofs() has been called and   (ii) the finite element for which degrees of freedom have been   distributed actually has degrees of freedom (which is not the case for   FE_Nothing, for example).     If this object is based on a  [2.x.76]  then   the current function returns true if [1.x.13] partition of the parallel   DoFHandler object has any degrees of freedom. In other words, the   function returns true even if the Triangulation does not own any active   cells on the current MPI process, but at least one process owns cells and   at least this one process has any degrees of freedom associated with it.  
* [0.x.38]*
   After distribute_dofs() with an FESystem element, the block structure of   global and level vectors is stored in a BlockInfo object accessible with   block_info(). This function initializes the local block structure on each   cell in the same object.  
* [0.x.39]*
   Clear all data of this object.  
* [0.x.40]*
   Renumber degrees of freedom based on a list of new DoF indices for each   of the degrees of freedom.     This function is called by the functions in DoFRenumbering function after   computing a new ordering of the degree of freedom indices. However, it   can of course also be called from user code.      [2.x.77]  new_number This array must have a size equal to the number of   degrees of freedom owned by the current processor, i.e. the size must be   equal to what n_locally_owned_dofs() returns. If only one processor   participates in storing the current mesh, then this equals the total   number of degrees of freedom, i.e. the result of n_dofs(). The contents   of this array are the new global indices for each freedom listed in the   IndexSet returned by locally_owned_dofs(). In the case of a sequential   mesh this means that the array is a list of new indices for each of the   degrees of freedom on the current mesh. In the case that we have a    [2.x.78]  or    [2.x.79]  underlying this DoFHandler object,   the array is a list of new indices for all the locally owned degrees of   freedom, enumerated in the same order as the currently locally owned   DoFs. In other words, assume that degree of freedom  [2.x.80]  is   currently locally owned, then    [2.x.81]    returns the new global DoF index of  [2.x.82] . Since the IndexSet of   locally_owned_dofs() is complete in the sequential case, the latter   convention for the content of the array reduces to the former in the case   that only one processor participates in the mesh.    
*  [2.x.83]  While it follows from the above, it may be surprising to know that     the [1.x.14] of locally owned degrees of freedom in a parallel     computation is an invariant     under renumbering, even if the [1.x.15] associated with these     locally owned degrees of freedom are not. At a fundamental level,     this invariant exists because the [1.x.16] whether a degree of     freedom is locally owned or not has nothing to do with that     degree of freedom's (old or new) index. Indeed, degrees of freedom     are locally owned if they are on a locally owned cell and not on     an interface between cells where the neighboring cell has a lower      [2.x.84]  "subdomain id". Since both of these conditions     are independent of the index associated with the DoF, a locally     owned degree of freedom will also be locally owned after renumbering.     On the other hand, properties such as whether the set of indices     of locally owned DoFs forms a contiguous range or not     (i.e., whether the locally_owned_dofs() returns an IndexSet object     for which  [2.x.85]  returns  [2.x.86]  are of     course affected by the exact renumbering performed here. For example,     while the initial numbering of DoF indices done in distribute_dofs()     yields a contiguous numbering, the renumbering performed by      [2.x.87]  will, in general, not yield     contiguous locally owned DoF indices.  
* [0.x.41]*
   The same function as above, but renumber the degrees of freedom of a   single level of a multigrid hierarchy.  
* [0.x.42]*
   Return the maximum number of degrees of freedom a degree of freedom in   the given triangulation with the given finite element may couple with.   This is the maximum number of entries per line in the system matrix; this   information can therefore be used upon construction of the   SparsityPattern object.     The returned number is not really the maximum number but an estimate   based on the finite element and the maximum number of cells meeting at a   vertex. The number holds for the constrained matrix as well.     The determination of the number of couplings can be done by simple   picture drawing. An example can be found in the implementation of this   function.    
*  [2.x.88]  This function is most often used to determine the maximal row   length for sparsity patterns. Unfortunately, while the estimates returned   by this function are rather accurate in 1d and 2d, they are often   significantly too high in 3d, leading the SparsityPattern class to   allocate much too much memory in some cases. Unless someone comes around   to improving the present function for 3d, there is not very much one can   do about these cases. The typical way to work around this problem is to   use an intermediate compressed sparsity pattern that only allocates   memory on demand. Refer to the  [2.x.89]  and  [2.x.90]  example programs on how   to do this. The problem is also discussed in the documentation of the   module on    [2.x.91] .  
* [0.x.43]*
   Return the number of degrees of freedom located on the boundary another   dof on the boundary can couple with.     The number is the same as for max_couplings_between_dofs() in one   dimension less.    
*  [2.x.92]  The same applies to this function as to max_couplings_per_dofs() as   regards the performance of this function. Think about one of the dynamic   sparsity pattern classes instead (see    [2.x.93] ).  
* [0.x.44]*
    [2.x.94]  Cell iterator functions  
* [0.x.45]    [2.x.95]   
* [0.x.46]*
   Iterator to the first used cell on level  [2.x.96]   
* [0.x.47]*
   Iterator to the first active cell on level  [2.x.97]  If the given level   does not contain any active cells (i.e., all cells on this level are   further refined), then this function returns    [2.x.98]  so that loops of the kind  
* [1.x.17]
*    have zero iterations, as may be expected if there are no active cells on   this level.  
* [0.x.48]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states.  
* [0.x.49]*
   Return an iterator which is the first iterator not on the given level. If    [2.x.99]  is the last level, then this returns <tt>end()</tt>.  
* [0.x.50]*
   Return an active iterator which is the first active iterator not on the   given level. If  [2.x.100]  is the last level, then this returns   <tt>end()</tt>.  
* [0.x.51]*
   Iterator to the first used cell on level  [2.x.101]  This returns a   level_cell_iterator that returns level dofs when dof_indices() is called.  
* [0.x.52]*
   Iterator past the last cell on level  [2.x.102]  This returns a   level_cell_iterator that returns level dofs when dof_indices() is called.  
* [0.x.53]*
   Iterator past the end; this iterator serves for comparisons of iterators   with past-the-end or before-the-beginning states.  
* [0.x.54]*
    [2.x.103]  Cell iterator functions returning ranges of iterators  
* [0.x.55]*
   Return an iterator range that contains all cells (active or not) that   make up this DoFHandler. Such a range is useful to initialize range-based   for loops as supported by C++11. See the example in the documentation of   active_cell_iterators().      [2.x.104]  The half open range  [2.x.105]     
*  [2.x.106]   
* [0.x.56]*
   Return an iterator range that contains all active cells that make up this   DoFHandler. Such a range is useful to initialize range-based for loops as   supported by C++11, see also    [2.x.107]  "C++11 standard".     Range-based for loops are useful in that they require much less code than   traditional loops (see [1.x.18] for a discussion of how they work). An   example is that without range-based for loops, one often writes code such   as the following:  
* [1.x.19]
*    Using C++11's range-based for loops, this is now entirely equivalent to   the following:  
* [1.x.20]
*       [2.x.108]  The half open range <code>[this->begin_active(),   this->end())</code>    
*  [2.x.109]   
* [0.x.57]*
   Return an iterator range that contains all cells (active or not) that   make up this DoFHandler in their level-cell form. Such a range is useful   to initialize range-based for loops as supported by C++11. See the   example in the documentation of active_cell_iterators().      [2.x.110]  The half open range <code>[this->begin_mg(),   this->end_mg())</code>    
*  [2.x.111]   
* [0.x.58]*
   Return an iterator range that contains all cells (active or not) that   make up the given level of this DoFHandler. Such a range is useful to   initialize range-based for loops as supported by C++11. See the example   in the documentation of active_cell_iterators().      [2.x.112]  level A given level in the refinement hierarchy of this   triangulation.    [2.x.113]  The half open range <code>[this->begin(level),   this->end(level))</code>      [2.x.114]  level must be less than this->n_levels().    
*  [2.x.115]   
* [0.x.59]*
   Return an iterator range that contains all active cells that make up the   given level of this DoFHandler. Such a range is useful to initialize   range-based for loops as supported by C++11. See the example in the   documentation of active_cell_iterators().      [2.x.116]  level A given level in the refinement hierarchy of this   triangulation.    [2.x.117]  The half open range <code>[this->begin_active(level),   this->end(level))</code>      [2.x.118]  level must be less than this->n_levels().    
*  [2.x.119]   
* [0.x.60]*
   Return an iterator range that contains all cells (active or not) that   make up the given level of this DoFHandler in their level-cell form. Such   a range is useful to initialize range-based for loops as supported by   C++11. See the example in the documentation of active_cell_iterators().      [2.x.120]  level A given level in the refinement hierarchy of this   triangulation.    [2.x.121]  The half open range <code>[this->begin_mg(level),   this->end_mg(level))</code>      [2.x.122]  level must be less than this->n_levels().    
*  [2.x.123]   
* [0.x.61]    [2.x.124]   
* [0.x.62]*
   Return the global number of degrees of freedom. If the current object   handles all degrees of freedom itself (even if you may intend to solve   your linear system in parallel, such as in  [2.x.125]  or  [2.x.126] ), then this   number equals the number of locally owned degrees of freedom since this   object doesn't know anything about what you want to do with it and   believes that it owns every degree of freedom it knows about.     On the other hand, if this object operates on a    [2.x.127]  object, then this function returns   the global number of degrees of freedom, accumulated over all processors.     In either case, included in the returned number are those DoFs which are   constrained by hanging nodes, see    [2.x.128] .     Mathematically speaking, the number returned by this function equals the   dimension of the finite element space (without taking into account   constraints) that corresponds to (i) the mesh on which it is defined,   and (ii) the finite element that is used by the current object. It   also, of course, equals the number of shape functions that span this   space.  
* [0.x.63]*
   The (global) number of multilevel degrees of freedom on a given level.     If no level degrees of freedom have been assigned to this level, returns    [2.x.129]  Else returns the number of degrees of freedom   on this level.  
* [0.x.64]*
   Return the number of locally owned degrees of freedom located on the   boundary.  
* [0.x.65]*
   Return the number of locally owned degrees of freedom located on those   parts of the boundary which have a boundary indicator listed in the given   set.   The reason that a  [2.x.130]  rather than a  [2.x.131]  is used is the same as   described in the documentation of that variant of    [2.x.132]  that takes a map.     There is, however, another overload of this function that takes   a  [2.x.133]  argument (see below).  
* [0.x.66]*
   Return the number of degrees of freedom located on those parts of the   boundary which have a boundary indicator listed in the given set. The  
* [0.x.67]*
   Access to an object informing of the block structure of the dof handler.     If an FESystem is used in distribute_dofs(), degrees of freedom naturally   split into several    [2.x.134]  "blocks".   For each base element as many blocks appear as its multiplicity.     At the end of distribute_dofs(), the number of degrees of freedom in each   block is counted, and stored in a BlockInfo object, which can be accessed   here. If you have previously called distribute_mg_dofs(), the same is   done on each level of the multigrid hierarchy. Additionally, the block   structure on each cell can be generated in this object by calling   initialize_local_block_info().  
* [0.x.68]*
   Return the number of degrees of freedom that belong to this process.     If this is a sequential DoFHandler, then the result equals that produced by   n_dofs(). (Here, "sequential" means that either   the whole program does not use MPI, or that it uses MPI   but only uses a single MPI process, or that there are multiple MPI   processes but the Triangulation on which this DoFHandler builds   works only on one MPI process.)   On the other hand, if we are operating on a    [2.x.135]  or  [2.x.136]    then it includes only the degrees   of freedom that the current processor owns. Note that in this case this   does not include all degrees of freedom that have been distributed on the   current processor's image of the mesh: in particular, some of the degrees   of freedom on the interface between the cells owned by this processor and   cells owned by other processors may be theirs, and degrees of freedom on   ghost cells are also not necessarily included.  
* [0.x.69]*
   Return an IndexSet describing the set of locally owned DoFs as a subset   of 0..n_dofs(). The number of elements of this set equals   n_locally_owned_dofs().  
* [0.x.70]*
   Return an IndexSet describing the set of locally owned DoFs used for the   given multigrid level as a subset of 0..n_dofs(level).  
* [0.x.71]*
   Return a constant reference to the indexth finite element object that is   used by this object.  
* [0.x.72]*
   Return a constant reference to the set of finite element objects that   are used by this object.  
* [0.x.73]*
   Return a constant reference to the triangulation underlying this object.  
* [0.x.74]*
   Return MPI communicator used by the underlying triangulation.  
* [0.x.75]*
   Whenever serialization with a  [2.x.137]  as the   underlying triangulation is considered, we also need to consider storing   the active FE indices on all active cells as well.     This function registers that these indices are to be stored whenever the    [2.x.138]  function is called on the   underlying triangulation.    
*  [2.x.139]  Currently only implemented for triangulations of type      [2.x.140]  An assertion will be triggered if     a different type is registered.      [2.x.141]  The documentation of  [2.x.142]  has further     information on serialization.  
* [0.x.76]*
   Whenever serialization with a  [2.x.143]  as the   underlying triangulation is considered, we also need to consider storing   the active FE indices on all active cells as well.     This function deserializes and distributes the previously stored   active FE indices on all active cells.    
*  [2.x.144]  Currently only implemented for triangulations of type      [2.x.145]  An assertion will be triggered if     a different type is registered.      [2.x.146]  The documentation of  [2.x.147]  has further     information on serialization.  
* [0.x.77]*
   Determine an estimate for the memory consumption (in bytes) of this   object.     This function is made virtual, since a dof handler object might be   accessed through a pointers to this base class, although the actual   object might be a derived class.  
* [0.x.78]*
   Write the data of this object to a stream for the purpose of   serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.79]*
   Read the data of this object from a stream for the purpose of   serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.80]*
   Write and read the data of this object from a stream for the purpose   of serialization using the [BOOST serialization   library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).  
* [0.x.81]*
   Exception  
* [0.x.82]*
   Exception  
*  [2.x.148]   
* [0.x.83]*
   Exception  
*  [2.x.149]   
* [0.x.84]*
   Exception  
*  [2.x.150]   
* [0.x.85]*
   Exception  
* [0.x.86]*
   Exception used when a certain feature doesn't make sense when   DoFHandler does not hp-capabilities.  
* [0.x.87]*
   Exception used when a certain feature is not implemented when the   DoFHandler has hp-capabilities.  
* [0.x.88]*
   A data structure that is used to store the DoF indices associated with a   particular vertex. Unlike cells, vertices live on several levels of a   multigrid hierarchy; consequently, we need to store DoF indices for each   vertex for each of the levels it lives on. This class does this.  
* [0.x.89]*
     Constructor.    
* [0.x.90]*
     A function that is called to allocate the necessary amount of memory to     store the indices of the DoFs that live on this vertex for the given     (inclusive) range of levels.    
* [0.x.91]*
     Return the coarsest level for which this structure stores data.    
* [0.x.92]*
     Return the finest level for which this structure stores data.    
* [0.x.93]*
     Return the index of the  [2.x.151] th degree of freedom for     the given level stored for the current vertex.    
* [0.x.94]*
     Set the index of the  [2.x.152] th degree of freedom for     the given level stored for the current vertex to  [2.x.153] .    
* [0.x.95]*
     Coarsest level for which this object stores DoF indices.    
* [0.x.96]*
     Finest level for which this object stores DoF indices.    
* [0.x.97]*
     A pointer to an array where we store the indices of the DoFs that live     on the various levels this vertex exists on.         The starting offset of the DoFs that belong to a  [2.x.154]  are given by      [2.x.155] .  [2.x.156]      must therefore be passed as an argument to the functions that set or     read an index.    
* [0.x.98]*
   Whenever the underlying triangulation changes by either   h/p-refinement/coarsening and serialization, the active FE index of cells   needs to be transferred. This structure stores all temporary information   required during that process.  
* [0.x.99]*
     Container to temporarily store the iterator and future active FE index     of cells that persist.    
* [0.x.100]*
     Container to temporarily store the iterator and future active FE index     of cells that will be refined.    
* [0.x.101]*
     Container to temporarily store the iterator and future active FE index     of parent cells that will remain after coarsening.    
* [0.x.102]*
     Container to temporarily store the active FE index of every locally     owned cell for transfer across  [2.x.157]      objects.    
* [0.x.103]*
     Helper object to transfer all active FE indices on      [2.x.158]  objects during     refinement/coarsening and serialization.    
* [0.x.104]*
   An object containing information on the block structure.  
* [0.x.105]*
   Boolean indicating whether or not the current DoFHandler has hp-   capabilities.  
* [0.x.106]*
   Address of the triangulation to work on.  
* [0.x.107]*
   Store a  [2.x.159]  object. If only a single FiniteElement is   used during initialization of this object, it contains the (one)   FiniteElement.  
* [0.x.108]*
   An object that describes how degrees of freedom should be distributed and   renumbered.  
* [0.x.109]*
   A structure that contains all sorts of numbers that characterize the   degrees of freedom this object works on.     For most members of this structure, there is an accessor function in this   class that returns its value.  
* [0.x.110]*
   Data structure like number_cache, but for each multigrid level.  
* [0.x.111]*
   Cached indices of the degrees of freedom of all active cell. Identification   of the appropriate position of a cell in the vectors is done via   cell_dof_cache_ptr (CRS scheme).  
* [0.x.112]*
   Pointer to the first cached degree of freedom of an active cell   (identified by level and level index) within cell_dof_cache_indices.  
* [0.x.113]*
   Indices of degree of freedom of each d+1 geometric object (3D: vertex,   line, quad, hex) for all relevant active finite elements. Identification   of the appropriate position is done via object_dof_ptr (CRS scheme).  
* [0.x.114]*
   Pointer to the first cached degree of freedom of a geometric object for all   relevant active finite elements.    
*  [2.x.160]  In normal mode it is possible to access this data structure directly.     In hp-mode, an indirection via hp_object_fe_indices/hp_object_fe_ptr is   necessary.  
* [0.x.115]*
   Active FE indices of each geometric object. Identification   of the appropriate position of a cell in the vectors is done via   hp_object_fe_ptr (CRS scheme).  
* [0.x.116]*
   Pointer to the first FE index of a geometric object.  
* [0.x.117]*
   Active FE index of an active cell (identified by level and level index).   This vector is only used in hp-mode.  
* [0.x.118]*
   Future FE index of an active cell (identified by level and level index).   This vector is only used in hp-mode.  
* [0.x.119]*
   An array to store the indices for level degrees of freedom located at   vertices.  
* [0.x.120]*
   Space to store the DoF numbers for the different multigrid levels.  
* [0.x.121]*
   Space to store DoF numbers of faces in the multigrid context.  
* [0.x.122]*
   We embed our data structure into a pointer to control that   all transfer related data only exists during the actual transfer process.  
* [0.x.123]*
   A list of connections with which this object connects to the   triangulation to get information about when the triangulation changes.  
* [0.x.124]*
   A list of connections with which this object connects to the   triangulation. They get triggered specifically when data needs to be   transferred due to refinement or repartitioning. Only active in hp-mode.  
* [0.x.125]*
   Free all memory used for non-multigrid data structures.  
* [0.x.126]*
   Free all memory used for multigrid data structures.  
* [0.x.127]*
   Return dof index of specified object.  
* [0.x.128]*
   Return dof index of specified object.  
* [0.x.129]*
   Set up DoFHandler policy.  
* [0.x.130]*
   Set up connections to signals of the underlying triangulation.  
* [0.x.131]*
   Create default tables for the active and future fe_indices.     Active indices are initialized with a zero indicator, meaning that fe[0] is   going to be used by default. Future indices are initialized with an invalid   indicator, meaning that no p-adaptation is scheduled by default.     This method is called upon construction and whenever the underlying   triangulation gets created. This ensures that each cell has a valid active   and future fe_index.  
* [0.x.132]*
   Update tables for active and future fe_indices.     Whenever the underlying triangulation changes (either by adaptation or   deserialization), active and future FE index tables will be adjusted to the   current structure of the triangulation. Missing values of active and future   indices will be initialized with their defaults (see   create_active_fe_table()).     This method is called post refinement and post deserialization. This   ensures that each cell has a valid active and future fe_index.  
* [0.x.133]*
   A function that will be triggered through a triangulation   signal just before the associated Triangulation or    [2.x.161]  is modified.     The function that stores the active FE indices of all cells that will   be refined or coarsened before the refinement happens, so that   they can be set again after refinement.  
* [0.x.134]*
   A function that will be triggered through a triangulation   signal just after the associated Triangulation or    [2.x.162]  is modified.     The function that restores the active FE indices of all cells that   were refined or coarsened.  
* [0.x.135]*
   A function that will be triggered through a triangulation   signal just before the associated  [2.x.163]  is   modified.     The function that stores all active FE indices on locally owned cells for   distribution over all participating processors.  
* [0.x.136]*
   A function that will be triggered through a triangulation   signal just after the associated  [2.x.164]  is   modified.     The function that restores all active FE indices on locally owned cells   that have been communicated.  
* [0.x.137]*
       Given a DoFHandler object in hp-mode, make sure that the       future FE indices that a user has set for locally owned cells are       communicated to all other relevant cells as well.             For  [2.x.165]  objects,       this information is distributed on both ghost and artificial cells.             In case a  [2.x.166]  is used,       indices are communicated only to ghost cells.      
* [0.x.138]*
       Return the index of the finite element from the entire  [2.x.167]        that is dominated by those assigned as future finite elements to the       children of  [2.x.168]              We find the corresponding finite element among the future finite       elements on the children of this cell. If none of them qualify, we       extend our search on the whole  [2.x.169]  which is the element       that describes the smallest finite element space that includes all       future finite elements assigned to the children. If the function is not       able to find a finite element at all, an assertion will be triggered.             In this way, we determine the finite element of the parent cell in case       of h-coarsening in the hp-context.            
*  [2.x.170]  This function can only be called on direct parent cells, i.e.,       non-active cells whose children are all active.            
*  [2.x.171]  On  [2.x.172]  objects where sibling cells       can be ghost cells, make sure that future FE indices have been properly       communicated with communicate_future_fe_indices() first. Otherwise,       results might differ on different processors. There is no check for       consistency of future FE indices.      
* [0.x.139]*
       Exception      
* [0.x.140]*
   Return a string representing the dynamic type of the given argument.   This is basically the same what typeid(...).name() does, but it turns out   this is broken on Intel 13+.     Defined in dof_handler.cc.  
* [0.x.141]

include/deal.II-translator/dofs/dof_handler_policy_0.txt
[0.x.0]*
     A namespace in which we define classes that describe how to distribute     and renumber degrees of freedom.    
* [0.x.1]*
       A class that implements policies for how the        [2.x.0]  and  [2.x.1]  functions       should work.      
* [0.x.2]*
         Destructor.        
* [0.x.3]*
         Distribute degrees of freedom on the DoFHandler object associated         with this policy object. The argument is a reference to the         NumberCache of the DoFHandler object. The function may modify it to         make DoFHandler related functions work properly when called within         the policies classes. The updated NumberCache is written to that         argument.        
* [0.x.4]*
         Distribute the multigrid dofs on each level of the DoFHandler         associated with this policy object. Return a vector of number         caches for all of the levels.        
* [0.x.5]*
         Renumber degrees of freedom as specified by the first argument.                 Return an updated NumberCache for the DoFHandler after renumbering.        
* [0.x.6]*
         Renumber multilevel degrees of freedom on one level of a multigrid         hierarchy. The second argument specifies the set of new DoF         indices.                 Return an updated NumberCache for the specified level of the         DoFHandler after renumbering.        
* [0.x.7]*
       This class implements the default policy for sequential operations,       i.e. for the case where all cells get degrees of freedom.      
* [0.x.8]*
         Constructor.          [2.x.2]  dof_handler The DoFHandler object upon which this           policy class is supposed to work.        
* [0.x.9]*
         The DoFHandler object on which this policy object works.        
* [0.x.10]*
       This class implements the policy for operations when we use a        [2.x.3]  object.      
* [0.x.11]*
         Constructor.          [2.x.4]  dof_handler The DoFHandler object upon which this           policy class is supposed to work.        
* [0.x.12]*
         Distribute degrees of freedom on the object given as first         argument.                 On distribution, DoFs are renumbered subdomain-wise and         number_cache.n_locally_owned_dofs_per_processor[i] and         number_cache.locally_owned_dofs are updated consistently.        
* [0.x.13]*
         This function is not yet implemented.        
* [0.x.14]*
         Renumber degrees of freedom as specified by the first argument.                 The input argument  [2.x.5]  may either have as many entries         as there are global degrees of freedom (i.e. dof_handler.n_dofs() )         or dof_handler.locally_owned_dofs().n_elements(). Therefore it can         be utilized with renumbering functions implemented for the          [2.x.6]  case.        
* [0.x.15]*
         The DoFHandler object on which this policy object works.        
* [0.x.16]*
       This class implements the policy for operations when we use a        [2.x.7]  object.      
* [0.x.17]*
         Constructor.          [2.x.8]  dof_handler The DoFHandler object upon which this           policy class is supposed to work.        
* [0.x.18]*
         The DoFHandler object on which this policy object works.        
* [0.x.19]

include/deal.II-translator/dofs/dof_iterator_selector_0.txt
[0.x.0]*
     Define some types for DoF handling in one dimension.         The types have the same meaning as those declared in      [2.x.0]  only the     treatment of templates is a little more complicated. See the      [2.x.1]      module for more information.    
* [0.x.1]*
     Define some types for DoF handling in two dimensions.         The types have the same meaning as those declared in      [2.x.2]  only the     treatment of templates is a little more complicated. See the      [2.x.3]      module for more information.    
* [0.x.2]*
     Define some types for DoF handling in three dimensions.         The types have the same meaning as those declared in      [2.x.4]  only the     treatment of templates is a little more complicated. See the      [2.x.5]      module for more information.    
* [0.x.3]

include/deal.II-translator/dofs/dof_levels_0.txt
[0.x.0]*
     Structure for storing degree of freedom information for cells,     organized by levels.         We store are cached values for the DoF indices on each cell     in#cell_dof_indices_cache, since this is a frequently requested     operation. The values are set by      [2.x.0]  and are used by      [2.x.1]          Note that vertices are separate from, and in fact have nothing to do     with cells. The indices of degrees of freedom located on vertices     therefore are not stored here, but rather in member variables of the      [2.x.2]  class.         The indices of degrees of freedom located on lower dimensional objects,     i.e. on lines for 2D and on quads and lines for 3D are treated     similarly than that on cells. However, these geometrical objects, which     are called faces as a generalization, are not organised in a     hierarchical structure of levels. Therefore, the degrees of freedom     located on these objects are stored in separate classes, namely the     <tt>DoFFaces</tt> classes.         Access to this object is usually through the      [2.x.3]  and  [2.x.4]  functions or     similar functions of derived classes that in turn access the member     variables using the  [2.x.5]  and corresponding     setter functions. Knowledge of the actual data format is therefore     encapsulated to the present hierarchy of classes as well as the      [2.x.6]  class.    
* [0.x.1]*
       Cache for the DoF indices on cells. The size of this array equals the       number of cells on a given level times selected_fe.n_dofs_per_cell().      
* [0.x.2]*
       The object containing dof-indices and related access-functions      
* [0.x.3]*
       Return a pointer to the beginning of the DoF indices cache for a       given cell.              [2.x.7]  obj_index The number of the cell we are looking at.        [2.x.8]  dofs_per_cell The number of DoFs per cell for this cell.        [2.x.9]  A pointer to the first DoF index for the current cell. The       next dofs_per_cell indices are for the current cell.      
* [0.x.4]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.5]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.6]

include/deal.II-translator/dofs/dof_objects_0.txt
[0.x.0]*
     Store the indices of the degrees of freedom which are located on     objects of dimension  [2.x.0]          [1.x.0]         The DoFObjects classes store the global indices of the degrees of     freedom for each cell on a certain level. The global index or number of     a degree of freedom is the zero-based index of the according value in     the solution vector and the row and column index in the global matrix     or the multigrid matrix for this level. These indices refer to the     unconstrained vectors and matrices, where we have not taken account of     the constraints introduced by hanging nodes.         Since vertices are not associated with a particular level, the indices     associated with vertices are not stored in the DoFObjects classes but     rather in the  [2.x.1]  array.         The DoFObjects classes are not used directly, but objects of these     classes are included in the DoFLevel and DoFFaces classes.        
*  [2.x.2]     
* [0.x.1]*
       Store the global indices of the degrees of freedom.      
* [0.x.2]*
       Set the global index of the  [2.x.3]  degree of freedom       located on the object with number  [2.x.4]  to the value given by       the last argument. The  [2.x.5]  argument is used to access the       finite element that is to be used to compute the location where this       data is stored.             The third argument,  [2.x.6]  must equal zero. It is otherwise       unused, but we retain the argument so that we can use the same       interface for non-hp- and hp-finite element methods, in effect making       it possible to share the DoFAccessor class hierarchy between hp- and       non-hp-classes.      
* [0.x.3]*
       Return the global index of the  [2.x.7]  degree of freedom       located on the object with number  [2.x.8]  The  [2.x.9]        argument is used to access the finite element that is to be used to       compute the location where this data is stored.             The third argument,  [2.x.10]  must equal zero. It is otherwise       unused, but we retain the argument so that we can use the same       interface for non-hp- and hp-finite element methods, in effect making       it possible to share the DoFAccessor class hierarchy between hp- and       non-hp-classes.      
* [0.x.4]*
       Return the value 1. The meaning of this function becomes clear by       looking at what the corresponding functions in the classes        [2.x.11]       
* [0.x.5]*
       Similar to the function above. Assert that the given index is zero,       and then return true.      
* [0.x.6]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.7]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.8]

include/deal.II-translator/dofs/dof_renumbering_0.txt
[0.x.0]*
 Implementation of a number of renumbering algorithms for the degrees of freedom on a triangulation. The functions in this namespace compute new indices for each degree of freedom of a DoFHandler object, and then call  [2.x.0] 
* 

*  [1.x.0]
*  Within this class, the Cuthill-McKee algorithm is implemented. It starts at a degree of freedom, searches the other DoFs for those which are coupled with the one we started with and numbers these in a certain way. It then finds the second level of DoFs, namely those that couple with those of the previous level (which were those that coupled with the initial DoF) and numbers these. And so on. For the details of the algorithm, especially the numbering within each level, please see H. R. Schwarz: "Methode der finiten Elemente". The reverse Cuthill-McKee algorithm does the same job, but numbers all elements in the reverse order.
*  These algorithms have one major drawback: they require a good starting point, i.e. the degree of freedom index that will get a new index of zero. The renumbering functions therefore allow the caller to specify such an initial DoF, e.g. by exploiting knowledge of the actual topology of the domain. It is also possible to give several starting indices, which may be used to simulate a simple upstream numbering (by giving the inflow dofs as starting values) or to make preconditioning faster (by letting the Dirichlet boundary indices be starting points).
*  If no starting index is given, one is chosen automatically, namely one with the smallest coordination number (the coordination number is the number of other dofs this dof couples with). This dof is usually located on the boundary of the domain. There is, however, large ambiguity in this when using the hierarchical meshes used in this library, since in most cases the computational domain is not approximated by tilting and deforming elements and by plugging together variable numbers of elements at vertices, but rather by hierarchical refinement. There is therefore a large number of dofs with equal coordination numbers. The renumbering algorithms will therefore not give optimal results.
*  In the book of Schwarz (H.R.Schwarz: Methode der finiten Elemente), it is advised to test many starting points, if possible all with the smallest coordination number and also those with slightly higher numbers. However, this seems only possible for meshes with at most several dozen or a few hundred elements found in small engineering problems of the early 1980s (the second edition was published in 1984), but certainly not with those used in this library, featuring several 10,000 to a few 100,000 elements.
* 

*  [1.x.1]
*  The renumbering algorithms need quite a lot of memory, since they have to store for each dof with which other dofs it couples. This is done using a SparsityPattern object used to store the sparsity pattern of matrices. It is not useful for the user to do anything between distributing the dofs and renumbering, i.e. the calls to  [2.x.1]  and  [2.x.2]  should follow each other immediately. If you try to create a sparsity pattern or anything else in between, these will be invalid afterwards.
*  The renumbering may take care of dof-to-dof couplings only induced by eliminating constraints. In addition to the memory consumption mentioned above, this also takes quite some computational time, but it may be switched off upon calling the  [2.x.3]  function. This will then give inferior results, since knots in the graph (representing dofs) are not found to be neighbors even if they would be after condensation.
*  The renumbering algorithms work on a purely algebraic basis, due to the isomorphism between the graph theoretical groundwork underlying the algorithms and binary matrices (matrices of which the entries are binary values) represented by the sparsity patterns. In special, the algorithms do not try to exploit topological knowledge (e.g. corner detection) to find appropriate starting points. This way, however, they work in arbitrary space dimension.
*  If you want to give starting points, you may give a list of dof indices which will form the first step of the renumbering. The dofs of the list will be consecutively numbered starting with zero, i.e. this list is not renumbered according to the coordination number of the nodes. Indices not in the allowed range are deleted. If no index is allowed, the algorithm will search for its own starting point.
* 

*  [1.x.2]
*  The renumbering schemes mentioned above do not lead to optimal results. However, after all there is no algorithm that accomplishes this within reasonable time. There are situations where the lack of optimality even leads to worse results than with the original, crude, levelwise numbering scheme; one of these examples is a mesh of four cells of which always those cells are refined which are neighbors to the center (you may call this mesh a `zoom in' mesh). In one such example the bandwidth was increased by about 50 per cent.
*  In most other cases, the bandwidth is reduced significantly. The reduction is the better the less structured the grid is. With one grid where the cells were refined according to a random driven algorithm, the bandwidth was reduced by a factor of six.
*  Using the constraint information usually leads to reductions in bandwidth of 10 or 20 per cent, but may for some very unstructured grids also lead to an increase. You have to weigh the decrease in your case with the time spent to use the constraint information, which usually is several times longer than the `pure' renumbering algorithm.
*  In almost all cases, the renumbering scheme finds a corner to start with. Since there is more than one corner in most grids and since even an interior degree of freedom may be a better starting point, giving the starting point by the user may be a viable way if you have a simple scheme to derive a suitable point (e.g. by successively taking the third child of the cell top left of the coarsest level, taking its third vertex and the dof index thereof, if you want the top left corner vertex). If you do not know beforehand what your grid will look like (e.g. when using adaptive algorithms), searching a best starting point may be difficult, however, and in many cases will not justify the effort.
* 

*  [1.x.3]
*  For finite elements composed of several base elements using the FESystem class, or for elements which provide several components themselves, it may be of interest to sort the DoF indices by component. This will then bring out the block matrix structure, since otherwise the degrees of freedom are numbered cell-wise without taking into account that they may belong to different components. For example, one may want to sort degree of freedom for a Stokes discretization so that we first get all velocities and then all the pressures so that the resulting matrix naturally decomposes into a  [2.x.4]  system.
*  This kind of numbering may be obtained by calling the component_wise() function of this class. Since it does not touch the order of indices within each component, it may be worthwhile to first renumber using the Cuthill- McKee or a similar algorithm and afterwards renumbering component-wise. This will bring out the matrix structure and additionally have a good numbering within each block.
*  The component_wise() function allows not only to honor enumeration based on vector components, but also allows to group together vector components into "blocks" using a defaulted argument to the various  [2.x.5]  functions (see  [2.x.6]  vs  [2.x.7]  for a description of the difference). The blocks designated through this argument may, but do not have to be, equal to the blocks that the finite element reports. For example, a typical Stokes element would be

* 
* [1.x.4]
*  This element has  [2.x.8]  vector components and equally many blocks. However, one may want to consider the velocities as one logical block so that all velocity degrees of freedom are enumerated the same way, independent of whether they are  [2.x.9] - or  [2.x.10] -velocities. This is done, for example, in  [2.x.11]  and  [2.x.12]  as well as several other tutorial programs.
*  On the other hand, if you really want to use block structure reported by the finite element itself (a case that is often the case if you have finite elements that have multiple vector components, e.g. the FE_RaviartThomas or FE_Nedelec elements) then you can use the  [2.x.13]  instead of the  [2.x.14]  functions.
* 

*  [1.x.5]
*  Given an ordered vector of cells, the function cell_wise() sorts the degrees of freedom such that degrees on earlier cells of this vector will occur before degrees on later cells.
*  This rule produces a well-defined ordering for discontinuous Galerkin methods (FE_DGP, FE_DGQ). For continuous methods, we use the additional rule that each degree of freedom is ordered according to the first cell in the ordered vector it belongs to.
*  Applications of this scheme are downstream() and clock_wise_dg(). The first orders the cells according to a downstream direction and then applies cell_wise().
* 

* 
*  [2.x.15]  For DG elements, the internal numbering in each cell remains unaffected. This cannot be guaranteed for continuous elements anymore, since degrees of freedom shared with an earlier cell will be accounted for by the other cell.
* 

*  [1.x.6]
*  The random() function renumbers degrees of freedom randomly. This function is probably seldom of use, except to check the dependence of solvers (iterative or direct ones) on the numbering of the degrees of freedom.
* 

*  [1.x.7]
*  As a benchmark of comparison, let us consider what the different sparsity patterns produced by the various algorithms when using the  [2.x.16]  element combination typically employed in the discretization of Stokes equations, when used on the mesh obtained in  [2.x.17]  after one adaptive mesh refinement in 3d. The space dimension together with the coupled finite element leads to a rather dense system matrix with, on average around 180 nonzero entries per row. After applying each of the reordering strategies shown below, the degrees of freedom are also sorted using  [2.x.18]  into velocity and pressure groups; this produces the  [2.x.19]  block structure seen below with the large velocity-velocity block at top left, small pressure-pressure block at bottom right, and coupling blocks at top right and bottom left.
*  The goal of reordering strategies is to improve the preconditioner. In  [2.x.20]  we use a SparseILU to preconditioner for the velocity-velocity block at the top left. The quality of the preconditioner can then be measured by the number of CG iterations required to solve a linear system with this block. For some of the reordering strategies below we record this number for adaptive refinement cycle 3, with 93176 degrees of freedom; because we solve several linear systems with the same matrix in the Schur complement, the average number of iterations is reported. The lower the number the better the preconditioner and consequently the better the renumbering of degrees of freedom is suited for this task. We also state the run-time of the program, in part determined by the number of iterations needed, for the first 4 cycles on one of our machines. Note that the reported times correspond to the run time of the entire program, not just the affected solver; if a program runs twice as fast with one particular ordering than with another one, then this means that the actual solver is actually several times faster.
*   [2.x.21] 
* 

*  [1.x.8]
*  Most of the algorithms listed above also work on multigrid degree of freedom numberings. Refer to the actual function declarations to get more information on this.
* 

* 
*  [2.x.22] 

* 
* [0.x.1]*
   Direction based comparator for cell iterators: it returns  [2.x.23]  if the   center of the second cell is downstream of the center of the first one   with respect to the direction given to the constructor.  
* [0.x.2]*
     Constructor.    
* [0.x.3]*
     Return true if c1 less c2.    
* [0.x.4]*
     Flow direction.    
* [0.x.5]*
   Point based comparator for downstream directions: it returns  [2.x.24]  if   the second point is downstream of the first one with respect to the   direction given to the constructor. If the points are the same with   respect to the downstream direction, the point with the lower DoF number   is considered smaller.  
* [0.x.6]*
     Constructor.    
* [0.x.7]*
     Return true if c1 less c2.    
* [0.x.8]*
     Flow direction.    
* [0.x.9]*
   A namespace for the implementation of some renumbering algorithms based   on algorithms implemented in the Boost Graph Library (BGL) by Jeremy Siek   and others.     While often slightly slower to compute, the algorithms using BOOST often   lead to matrices with smaller bandwidths and sparse ILUs based on this   numbering are therefore more efficient.     For a comparison of these algorithms with the ones defined in   DoFRenumbering, see the comparison section in the documentation of the   DoFRenumbering namespace.  
* [0.x.10]*
     Renumber the degrees of freedom according to the Cuthill-McKee method,     eventually using the reverse numbering scheme.         See the general documentation of the parent class for details on the     different methods.         As an example of the results of this algorithm, take a look at the     comparison of various algorithms in the documentation of the     DoFRenumbering namespace.    
* [0.x.11]*
     Compute the renumbering vector needed by the Cuthill_McKee() function.     Does not perform the renumbering on the DoFHandler dofs but returns the     renumbering vector.    
* [0.x.12]*
     Renumber the degrees of freedom based on the BOOST implementation of     the King algorithm. This often results in slightly larger (by a few     percent) bandwidths than the Cuthill-McKee algorithm, but sparse ILUs     are often slightly (also by a few percent) better preconditioners.         As an example of the results of this algorithm, take a look at the     comparison of various algorithms in the documentation of the     DoFRenumbering namespace.         This algorithm is used in  [2.x.25] .    
* [0.x.13]*
     Compute the renumbering for the King algorithm but do not actually     renumber the degrees of freedom in the DoF handler argument.    
* [0.x.14]*
     Renumber the degrees of freedom based on the BOOST implementation of     the minimum degree algorithm. Unlike the Cuthill-McKee algorithm, this     algorithm does not attempt to minimize the bandwidth of a matrix but to     minimize the amount of fill-in when doing an LU decomposition. It may     sometimes yield better ILUs because of this property.         As an example of the results of this algorithm, take a look at the     comparison of various algorithms in the documentation of the     DoFRenumbering namespace.    
* [0.x.15]*
     Compute the renumbering for the minimum degree algorithm but do not     actually renumber the degrees of freedom in the DoF handler argument.    
* [0.x.16]*
   Renumber the degrees of freedom according to the Cuthill-McKee method,   possibly using the reverse numbering scheme.     See the general documentation of this class for details on the different   methods.     As an example of the results of this algorithm, take a look at the   comparison of various algorithms in the documentation of the   DoFRenumbering namespace.      [2.x.26]  dof_handler The DoFHandler object to work on.    [2.x.27]  reversed_numbering Whether to use the original Cuthill-McKee     algorithm, or to reverse the ordering.    [2.x.28]  use_constraints Whether or not to use hanging node constraints in     determining the reordering of degrees of freedom.    [2.x.29]  starting_indices A set of degrees of freedom that form the first     level of renumbered degrees of freedom. If the set is empty, then a     single starting entry is chosen automatically among those that have the     smallest number of others that couple with it.     [1.x.9]     If the given DoFHandler uses a distributed triangulation (i.e., if   dof_handler.locally_owned() is not the complete index set), the   renumbering is performed on each processor's degrees of freedom   individually, without any communication between processors. In other   words, the resulting renumbering is an attempt at minimizing the bandwidth   of [1.x.10]   separately, without making an attempt at minimizing the bandwidth of   the global matrix. Furthermore, the renumbering reuses exactly the   same set of DoF indices that each processor used before. In other words,   if the previous numbering of DoFs on one processor used a contiguous   range of DoF indices, then so will the DoFs on that processor after   the renumbering, and they will occupy the same range. The same is true   if the previous numbering of DoFs on a processor consisted of a number   of index ranges or single indices: after renumbering, the locally owned   DoFs on that processor will use the exact same indices, just in a   different order.     In addition, if the DoFHandler is built on a parallel triangulation, then   on every processor, the starting indices for renumbering need to be a   (possibly empty) subset of the    [2.x.30]  "locally active degrees of freedom". In   general, these starting indices will be different on each processor   (unless of course you pass an empty list as is the default),   and each processor will use them as starting indices for the local   renumbering on that processor.     The starting indices must be locally active degrees of freedom, but   the function will only renumber the locally owned subset of the   locally owned DoFs. The function accepts starting indices from the   largest set of locally active degrees of freedom because a typical   renumbering operation with this function starts with indices that   are located on the boundary
* 
*  -  in the case of the current function,   that would be the boundary between processor subdomains. Since the   degrees of freedom that are located on subdomain interfaces may   be owned by either one of the two processors that own the adjacent   subdomains, it is not always easy to identify starting indices that   are locally owned. On the other hand, all degrees of freedom on subdomain   interfaces are locally active, and so the function accepts them as   starting indices even though it can only renumber them on a given   processor if they are also locally owned.  
* [0.x.17]*
   Compute the renumbering vector needed by the Cuthill_McKee() function.   This function does not perform the renumbering on the DoFHandler DoFs but   only returns the renumbering vector.     If a valid level is passed as parameter, the renumbering vector for this   grid level is returned.   See the Cuthill_McKee() function for an explanation of the other arguments.  
* [0.x.18]*
   Renumber the degrees of freedom according to the Cuthill-McKee method,   eventually using the reverse numbering scheme, in this case for a   multigrid numbering of degrees of freedom.     You can give a triangulation level to which this function is to be   applied.  Since with a level-wise numbering there are no hanging nodes,   no constraints can be used, so the respective parameter of the previous   function is omitted.     See the general documentation of this class for details on the different   methods.  
* [0.x.19]*
    [2.x.31]  Component-wise numberings    [2.x.32]   
* [0.x.20]*
   Sort the degrees of freedom by vector component. The numbering within   each component is not touched, so a degree of freedom with index  [2.x.33] ,   belonging to some component, and another degree of freedom with index  [2.x.34]    belonging to the same component will be assigned new indices  [2.x.35]  and    [2.x.36]  with  [2.x.37]  if  [2.x.38]  and  [2.x.39]  if  [2.x.40] .     You can specify that the components are ordered in a different way than   suggested by the FESystem object you use. To this end, set up the vector    [2.x.41]  such that the entry at index  [2.x.42]  denotes the number   of the target component for dofs with component  [2.x.43]  in the FESystem.   Naming the same target component more than once is possible and results   in a blocking of several components into one. This is discussed in    [2.x.44] . If you omit this argument, the same order as given by the finite   element is used.     If one of the base finite elements from which the global finite element   under consideration here, is a non-primitive one, i.e. its shape   functions have more than one non-zero component, then it is not possible   to associate these degrees of freedom with a single vector component. In   this case, they are associated with the first vector component to which   they belong.     For finite elements with only one component, or a single non-primitive   base element, this function is the identity operation.  
* [0.x.21]*
   Sort the degrees of freedom by component. It does the same thing as the   above function, only that it does this for one single level of a   multilevel discretization. The non-multigrid part of the DoFHandler   is not touched.  
* [0.x.22]*
   Compute the renumbering vector needed by the component_wise() functions.   Does not perform the renumbering on the DoFHandler dofs but returns the   renumbering vector.  
* [0.x.23]*
    [2.x.45]   
* [0.x.24]*
    [2.x.46]  Block-wise numberings    [2.x.47]   
* [0.x.25]*
   Sort the degrees of freedom by vector block. The numbering within each   block is not touched, so a degree of freedom with index  [2.x.48] , belonging to   some block, and another degree of freedom with index  [2.x.49]  belonging to the   same block will be assigned new indices  [2.x.50]  and  [2.x.51]  with    [2.x.52]  if  [2.x.53]  and  [2.x.54]  if  [2.x.55] .    
*  [2.x.56]  This function only succeeds if each of the elements in the    [2.x.57]  attached to the DoFHandler argument has exactly the   same number of blocks (see    [2.x.58]  "the glossary"   for more information). Note that this is not always given: while the    [2.x.59]  class ensures that all of its elements have the same   number of vector components, they need not have the same number of   blocks. At the same time, this function here needs to match individual   blocks across elements and therefore requires that elements have the same   number of blocks and that subsequent blocks in one element have the same   meaning as in another element.  
* [0.x.26]*
   Sort the degrees of freedom by vector block. It does the same thing as   the above function, only that it does this for one single level of a   multilevel discretization. The non-multigrid part of the DoFHandler   is not touched.  
* [0.x.27]*
   Compute the renumbering vector needed by the block_wise() functions.   Does not perform the renumbering on the DoFHandler dofs but returns the   renumbering vector.  
* [0.x.28]*
    [2.x.60]   
* [0.x.29]*
    [2.x.61]  Various cell-wise numberings    [2.x.62]   
* [0.x.30]*
   Renumber the degrees cell by cell by traversing the cells in    [2.x.63]  "Z order".     There are two reasons to use this function:
* 

* 
* 

* 
* 

* 
* 
*  - It produces a predictable ordering of degrees of freedom     that is independent of how exactly you arrived at a mesh.     In particular, in general the order of cells of a mesh     depends on the order in which cells were marked for     refinement and coarsening during the refinement cycles     the mesh has undergone. On the other hand, the z-order     of cells is independent of the mesh's history, and so yields a     predictable DoF numbering.
* 

* 
* 

* 
* 

* 
* 
*  - For meshes based on  [2.x.64]      the      [2.x.65]  "locally owned cells"     of     each MPI process are contiguous in Z order. That means that     numbering degrees of freedom by visiting cells in Z order yields      [2.x.66]  "locally owned DoF indices"     that consist     of contiguous ranges for each process. This is also true for the     default ordering of DoFs on such triangulations, but the default     ordering creates an enumeration that also depends on how many     processors participate in the mesh, whereas the one generated     by this function enumerates the degrees of freedom on a particular     cell with indices that will be the same regardless of how many     processes the mesh is split up between.     For meshes based on  [2.x.67]  the situation is   more complex. Here, the set of locally owned cells is determined by   a partitioning algorithm (selected by passing an object of type    [2.x.68]  to the constructor of the   triangulation), and in general these partitioning algorithms may   assign cells to    [2.x.69]  "subdomains"   based on   decisions that may have nothing to do with the Z order. (Though it   is possible to select these flags in a way so that partitioning   uses the Z order.) As a consequence, the cells of one subdomain   are not contiguous in Z order, and if one renumbered degrees of freedom   based on the Z order of cells, one would generally end up with DoF   indices that on each processor do not form a contiguous range.   This is often inconvenient (for example, because PETSc cannot store   vectors and matrices for which the locally owned set of indices   is not contiguous), and consequently this function uses the following   algorithm for  [2.x.70]  objects:
* 

* 
* 

* 
* 

* 
* 
*  - It determines how many degrees of freedom each processor owns.     This is an invariant under renumbering, and consequently we can     use how many DoFs each processor owns at the beginning of the current     function. Let us call this number  [2.x.71]  for processor  [2.x.72] .
* 

* 
* 

* 
* 

* 
* 
*  - It determines for each processor a contiguous range of new     DoF indices  [2.x.73]  so that  [2.x.74] ,  [2.x.75] , and      [2.x.76] .
* 

* 
* 

* 
* 

* 
* 
*  - It traverses the [1.x.11] in Z order and     renumbers the locally owned degrees of freedom on these cells     so that the new numbers fit within the interval  [2.x.77] .   In other words, the [1.x.12] on each   processor are sorted according to the Z order of the locally   owned cells they are on, but this property may not hold globally,   across cells. This is because the partitioning algorithm may have   decided that, for example, processor 0 owns a cell that comes   [1.x.13] in Z order than one of the cells assigned to processor 1.   On the other hand, the algorithm described above assigns the   degrees of freedom on this cell [1.x.14] indices than   all of the indices owned by processor 1.    
*  [2.x.78]  This function generates an ordering that is independent of the previous   numbering of degrees of freedom. In other words, any information that may   have been produced by a previous call to a renumbering function is   ignored.  
* [0.x.31]*
   Renumber degrees of freedom by cell. The function takes a vector of cell   iterators (which needs to list [1.x.15] locally owned active cells of the   DoF handler objects) and will give degrees of freedom new indices based on   where in the given list of cells the cell is on which the degree of freedom   is located. Degrees of freedom that exist at the interface between two or   more cells will be numbered when they are encountered first.     Degrees of freedom that are encountered first on the same cell retain   their original ordering before the renumbering step.      [2.x.79]  dof_handler The DoFHandler whose degrees of freedom are to   be renumbered.    [2.x.80]  cell_order A vector that contains the order of the cells that   defines the order in which degrees of freedom should be renumbered.      [2.x.81]  for serial triangulation  [2.x.82]  must have size    [2.x.83] , whereas   in case of parallel triangulation its size should be    [2.x.84]  Every active   cell   iterator of that triangulation needs to be present in  [2.x.85]  exactly   once.  
* [0.x.32]*
   Compute a renumbering of degrees of freedom by cell. The function takes a   vector of cell iterators (which needs to list [1.x.16] locally owned   active cells of the DoF handler objects) and will give degrees of freedom   new indices based on where in the given list of cells the cell is on which   the degree of freedom is located. Degrees of freedom that exist at the   interface between two or more cells will be numbered when they are   encountered first.     Degrees of freedom that are encountered first on the same cell retain   their original ordering before the renumbering step.      [2.x.86]  renumbering A vector of length    [2.x.87]  that contains for each   degree of freedom (in their current numbering) their future DoF index. This   vector therefore presents a (very particular) [1.x.17] of the   current DoF indices.    [2.x.88]  inverse_renumbering The reverse of the permutation returned   in the previous argument. In case of  [2.x.89]  the   inverse is within locally owned DoFs.    [2.x.90]  dof_handler The DoFHandler whose degrees of freedom are to be   renumbered.    [2.x.91]  cell_order A vector that contains the order of the cells that   defines the order in which degrees of freedom should be renumbered.      [2.x.92]  for serial triangulation  [2.x.93]  must have size    [2.x.94] , whereas   in case of parallel triangulation its size should be    [2.x.95]  Every active   cell iterator of that triangulation needs to be present in  [2.x.96]    cell_order exactly once.  [2.x.97]  For each  [2.x.98]  between zero and    [2.x.99] , the condition   <code>renumbering[inverse_renumbering[i]] ==   dof_handler.locally_owned_dofs().nth_index_in_set(i)</code> will hold.  
* [0.x.33]*
   Like the other cell_wise() function, but for one level of a multilevel   enumeration of degrees of freedom.  
* [0.x.34]*
   Like the other compute_cell_wise() function, but for one level of a   multilevel enumeration of degrees of freedom.  
* [0.x.35]*
    [2.x.100]   
* [0.x.36]*
    [2.x.101]  Directional numberings    [2.x.102]   
* [0.x.37]*
   Downstream numbering with respect to a constant flow direction. If the   additional argument  [2.x.103]  is set to  [2.x.104]  the   numbering is performed cell-wise, otherwise it is performed based on the   location of the support points.     The cells are sorted such that the centers of cells numbered higher are   further   downstream with respect to the constant vector  [2.x.105]  than the   centers of cells numbered lower. Even if this yields a downstream numbering   with respect to the flux on the edges for fairly general grids, this might   not be guaranteed for all meshes.     If the  [2.x.106]  argument is set to  [2.x.107]  this function   produces a downstream ordering of the mesh cells and calls cell_wise().   Therefore, the output only makes sense for Discontinuous Galerkin Finite   Elements (all degrees of freedom have to be associated with the interior   of the cell in that case) in that case.     If  [2.x.108]  is set to  [2.x.109]  the degrees of freedom are   renumbered based on the support point location of the individual degrees   of freedom (obviously, the finite element needs to define support points   for this to work). The numbering of points with the same position in   downstream location (e.g. those parallel to the flow direction, or   several dofs within a FESystem) will be unaffected.  
* [0.x.38]*
   Cell-wise downstream numbering with respect to a constant flow direction   on one level of a multigrid hierarchy. See the other function with the same   name.  
* [0.x.39]*
   Compute the set of renumbering indices needed by the downstream() function.   Does not perform the renumbering on the DoFHandler dofs but returns the   renumbering vector.  
* [0.x.40]*
   Compute the set of renumbering indices needed by the downstream() function.   Does not perform the renumbering on the DoFHandler dofs but returns the   renumbering vector.  
* [0.x.41]*
   Cell-wise clockwise numbering.     This function produces a (counter)clockwise ordering of the mesh cells   with respect to the hub  [2.x.110]  and calls cell_wise().  Therefore, it   only works with Discontinuous Galerkin Finite Elements, i.e. all degrees   of freedom have to be associated with the interior of the cell.  
* [0.x.42]*
   Cell-wise clockwise numbering on one level of a multigrid   hierarchy. See the other function with the same name.  
* [0.x.43]*
   Compute the renumbering vector needed by the clockwise_dg() functions.   Does not perform the renumbering on the DoFHandler dofs but returns the   renumbering vector.  
* [0.x.44]*
    [2.x.111]   
* [0.x.45]*
    [2.x.112]  Selective and random numberings    [2.x.113]   
* [0.x.46]*
   Sort those degrees of freedom which are tagged with  [2.x.114]  in the  [2.x.115]    selected_dofs array to the back of the DoF numbers. The sorting is   stable, i.e. the relative order within the tagged degrees of freedom is   preserved, as is the relative order within the untagged ones.      [2.x.116]  The  [2.x.117]  array must have as many elements as the  [2.x.118]    dof_handler has degrees of freedom.  
* [0.x.47]*
   Sort those degrees of freedom which are tagged with  [2.x.119]  in the  [2.x.120]    selected_dofs array on the level  [2.x.121]  to the back of the DoF numbers.   The sorting is stable, i.e. the relative order within the tagged degrees   of freedom is preserved, as is the relative order within the untagged   ones.      [2.x.122]  The  [2.x.123]  array must have as many elements as the  [2.x.124]    dof_handler has degrees of freedom on the given level.  
* [0.x.48]*
   Compute the renumbering vector needed by the sort_selected_dofs_back()   function. Does not perform the renumbering on the DoFHandler dofs but   returns the renumbering vector.      [2.x.125]  The  [2.x.126]  array must have as many elements as the  [2.x.127]    dof_handler has degrees of freedom.  
* [0.x.49]*
   This function computes the renumbering vector on each level needed by the   sort_selected_dofs_back() function. Does not perform the renumbering on   the DoFHandler dofs but only computes the renumbering and returns the   renumbering vector.      [2.x.128]  The  [2.x.129]  array must have as many elements as the  [2.x.130]    dof_handler has degrees of freedom on the given level.  
* [0.x.50]*
   Renumber the degrees of freedom in a random way. The result of this   function is repeatable in that two runs of the same program will yield   the same result. This is achieved by creating a new random number   generator with a fixed seed every time this function is entered. In   particular, the function therefore does not rely on an external random   number generator for which it would matter how often it has been called   before this function (or, for that matter, whether other threads running   concurrently to this function also draw random numbers).  
* [0.x.51]*
   Renumber the degrees of freedom in a random way. It does the same thing as   the above function, only that it does this for one single level of a   multilevel discretization. The non-multigrid part of the DoFHandler   is not touched.  
* [0.x.52]*
   Compute the renumbering vector needed by the random() function. See   there for more information on the computed random renumbering.     This function does not perform the renumbering on the DoFHandler dofs but   returns the renumbering vector.  
* [0.x.53]*
   Compute the renumbering vector needed by the random() function. Same   as the above function but for a single level of a multilevel   discretization.  
* [0.x.54]*
    [2.x.131]   
* [0.x.55]*
    [2.x.132]  Numberings based on cell attributes    [2.x.133]   
* [0.x.56]*
   Renumber the degrees of freedom such that they are associated with the   subdomain id of the cells they are living on, i.e. first all degrees of   freedom that belong to cells with subdomain zero, then all with subdomain   one, etc. This is useful when doing parallel computations with a standard   Triangulation after assigning subdomain ids using a partitioner (see the    [2.x.134]  function for this). Calling this   function is unnecessary when using a  [2.x.135]  or    [2.x.136]  as the degrees of freedom are   already enumerated according to the MPI process id. Therefore, if the   underlying triangulation is of this type then an error will be thrown.     Note that degrees of freedom associated with faces, edges, and vertices   may be associated with multiple subdomains if they are sitting on   partition boundaries. It would therefore be undefined with which   subdomain they have to be associated. For this, we use what we get from   the  [2.x.137]  function.     The algorithm is stable, i.e. if two dofs i,j have <tt>i<j</tt> and   belong to the same subdomain, then they will be in this order also after   reordering.  
* [0.x.57]*
   Compute the renumbering vector needed by the subdomain_wise() function.   Does not perform the renumbering on the  [2.x.138]  dofs but returns   the renumbering vector.  
* [0.x.58]*
    [2.x.139]   
* [0.x.59]*
   Exception    
*  [2.x.140]   
* [0.x.60]*
   Exception    
*  [2.x.141]   
* [0.x.61]*
   The function is only implemented for Discontinuous Galerkin Finite   elements.    
*  [2.x.142]   
* [0.x.62]

include/deal.II-translator/dofs/dof_tools_0.txt
[0.x.0]     Default value of the face_has_flux_coupling parameter of     make_flux_sparsity_pattern. Defined here (instead of using a default     lambda in the parameter list) to avoid a bug in gcc where the same lambda     gets defined multiple times.    
* [0.x.1]*
 This is a collection of functions operating on, and manipulating the numbers of degrees of freedom. The documentation of the member functions will provide more information, but for functions that exist in multiple versions, there are sections in this global documentation stating some commonalities.
*  [1.x.0]
*  When assembling system matrices, the entries are usually of the form  [2.x.0] , where  [2.x.1]  is a bilinear functional, often an integral. When using sparse matrices, we therefore only need to reserve space for those  [2.x.2]  only, which are nonzero, which is the same as to say that the basis functions  [2.x.3]  and  [2.x.4]  have a nonempty intersection of their support. Since the support of basis functions is bound only on cells on which they are located or to which they are adjacent, to determine the sparsity pattern it is sufficient to loop over all cells and connect all basis functions on each cell with all other basis functions on that cell.  There may be finite elements for which not all basis functions on a cell connect with each other, but no use of this case is made since no examples where this occurs are known to the author.
* 

*  [1.x.1]
*  When projecting the traces of functions to the boundary or parts thereof, one needs to build matrices and vectors that act only on those degrees of freedom that are located on the boundary, rather than on all degrees of freedom. One could do that by simply building matrices in which the entries for all interior DoFs are zero, but such matrices are always very rank deficient and not very practical to work with.
*  What is needed instead in this case is a numbering of the boundary degrees of freedom, i.e. we should enumerate all the degrees of freedom that are sitting on the boundary, and exclude all other (interior) degrees of freedom. The map_dof_to_boundary_indices() function does exactly this: it provides a vector with as many entries as there are degrees of freedom on the whole domain, with each entry being the number in the numbering of the boundary or  [2.x.5]  if the dof is not on the boundary.
*  With this vector, one can get, for any given degree of freedom, a unique number among those DoFs that sit on the boundary; or, if your DoF was interior to the domain, the result would be  [2.x.6]  We need this mapping, for example, to build the mass matrix on the boundary (for this, see make_boundary_sparsity_pattern() function, the corresponding section below, as well as the MatrixCreator namespace documentation).
*  Actually, there are two map_dof_to_boundary_indices() functions, one producing a numbering for all boundary degrees of freedom and one producing a numbering for only parts of the boundary, namely those parts for which the boundary indicator is listed in a set of indicators given to the function. The latter case is needed if, for example, we would only want to project the boundary values for the Dirichlet part of the boundary. You then give the function a list of boundary indicators referring to Dirichlet parts on which the projection is to be performed. The parts of the boundary on which you want to project need not be contiguous; however, it is not guaranteed that the indices of each of the boundary parts are continuous, i.e. the indices of degrees of freedom on different parts may be intermixed.
*  Degrees of freedom on the boundary but not on one of the specified boundary parts are given the index  [2.x.7]  as if they were in the interior. If no boundary indicator was given or if no face of a cell has a boundary indicator contained in the given list, the vector of new indices consists solely of  [2.x.8] 
*  (As a side note, for corner cases: The question what a degree of freedom on the boundary is, is not so easy.  It should really be a degree of freedom of which the respective basis function has nonzero values on the boundary. At least for Lagrange elements this definition is equal to the statement that the off-point, or what deal.II calls support_point, of the shape function, i.e. the point where the function assumes its nominal value (for Lagrange elements this is the point where it has the function value 1), is located on the boundary. We do not check this directly, the criterion is rather defined through the information the finite element class gives: the FiniteElement class defines the numbers of basis functions per vertex, per line, and so on and the basis functions are numbered after this information; a basis function is to be considered to be on the face of a cell (and thus on the boundary if the cell is at the boundary) according to it belonging to a vertex, line, etc but not to the interior of the cell. The finite element uses the same cell-wise numbering so that we can say that if a degree of freedom was numbered as one of the dofs on lines, we assume that it is located on the line. Where the off-point actually is, is a secret of the finite element (well, you can ask it, but we don't do it here) and not relevant in this context.)
* 

*  [1.x.2]
*  In some cases, one wants to only work with DoFs that sit on the boundary. One application is, for example, if rather than interpolating non- homogeneous boundary values, one would like to project them. For this, we need two things: a way to identify nodes that are located on (parts of) the boundary, and a way to build matrices out of only degrees of freedom that are on the boundary (i.e. much smaller matrices, in which we do not even build the large zero block that stems from the fact that most degrees of freedom have no support on the boundary of the domain). The first of these tasks is done by the map_dof_to_boundary_indices() function (described above).
*  The second part requires us first to build a sparsity pattern for the couplings between boundary nodes, and then to actually build the components of this matrix. While actually computing the entries of these small boundary matrices is discussed in the MatrixCreator namespace, the creation of the sparsity pattern is done by the create_boundary_sparsity_pattern() function. For its work, it needs to have a numbering of all those degrees of freedom that are on those parts of the boundary that we are interested in. You can get this from the map_dof_to_boundary_indices() function. It then builds the sparsity pattern corresponding to integrals like  [2.x.9] , where  [2.x.10]  and  [2.x.11]  are indices into the matrix, and  [2.x.12]  is the global DoF number of a degree of freedom sitting on a boundary (i.e.,  [2.x.13]  is the inverse of the mapping returned by map_dof_to_boundary_indices() function).
* 

* 

* 
*  [2.x.14] 

* 
* [0.x.2]*
   The flags used in tables by certain <tt>make_*_pattern</tt> functions to   describe whether two components of the solution couple in the bilinear   forms corresponding to cell or face terms. An example of using these   flags is shown in the introduction of  [2.x.15] .     In the descriptions of the individual elements below, remember that these   flags are used as elements of tables of size  [2.x.16]    times  [2.x.17]  where each element indicates whether   two components do or do not couple.  
* [0.x.3]*
     Two components do not couple.    
* [0.x.4]*
     Two components do couple.    
* [0.x.5]*
     Two components couple only if their shape functions are both nonzero on     a given face. This flag is only used when computing integrals over     faces of cells, e.g., in  [2.x.18]      Use  [2.x.19]  in general cases where gradients etc. occur on face     integrals.    
* [0.x.6]*
    [2.x.20]  DoF couplings    [2.x.21]   
* [0.x.7]*
   Map a coupling table from the user friendly organization by components to   the organization by blocks.     The return vector will be initialized to the correct length inside this   function.  
* [0.x.8]*
   Given a finite element and a table how the vector components of it couple   with each other, compute and return a table that describes how the   individual shape functions couple with each other.  
* [0.x.9]*
   Same function as above for a collection of finite elements, returning a   collection of tables.     The function currently treats  [2.x.22]  the same as    [2.x.23]  .  
* [0.x.10]*
    [2.x.24]   
* [0.x.11]*
    [2.x.25]  Sparsity pattern generation    [2.x.26]   
* [0.x.12]*
   Compute which entries of a matrix built on the given  [2.x.27]  may   possibly be nonzero, and create a sparsity pattern object that represents   these nonzero locations.     This function computes the possible positions of non-zero entries in the   global system matrix by [1.x.3] which entries one would write   to during the actual assembly of a matrix. For this, the function assumes   that each finite element basis function is non-zero on a cell only if its   degree of freedom is associated with the interior, a face, an edge or a   vertex of this cell.  As a result, a matrix entry  [2.x.28]  that is   computed from two basis functions  [2.x.29]  and  [2.x.30]  with   (global) indices  [2.x.31]  and  [2.x.32]  (for example, using a bilinear form    [2.x.33] ) can be non-zero only if these shape   functions correspond to degrees of freedom that are defined on at least   one common cell. Therefore, this function just loops over all cells,   figures out the global indices of all degrees of freedom, and presumes   that all matrix entries that couple any of these indices will result in a   nonzero matrix entry. These will then be added to the sparsity pattern.   As this process of generating the sparsity pattern does not take into   account the equation to be solved later on, the resulting sparsity   pattern is symmetric.     This algorithm makes no distinction between shape functions on each cell,   i.e., it simply couples all degrees of freedom on a cell with all other   degrees of freedom on a cell. This is often the case, and always a safe   assumption. However, if you know something about the structure of your   operator and that it does not couple certain shape functions with certain   test functions, then you can get a sparser sparsity pattern by calling a   variant of the current function described below that allows to specify   which vector components couple with which other vector components.     The method described above lives on the assumption that coupling between   degrees of freedom only happens if shape functions overlap on at least   one cell. This is the case with most usual finite element formulations   involving conforming elements. However, for formulations such as the   Discontinuous Galerkin finite element method, the bilinear form contains   terms on interfaces between cells that couple shape functions that live   on one cell with shape functions that live on a neighboring cell. The   current function would not see these couplings, and would consequently   not allocate entries in the sparsity pattern. You would then get into   trouble during matrix assembly because you try to write into matrix   entries for which no space has been allocated in the sparsity pattern.   This can be avoided by calling the  [2.x.34]    function instead, which takes into account coupling between degrees of   freedom on neighboring cells.     There are other situations where bilinear forms contain non-local terms,   for example in treating integral equations. These require different   methods for building the sparsity patterns that depend on the exact   formulation of the problem. You will have to do this yourself then.      [2.x.35]  dof_handler The DoFHandler object that describes which degrees   of freedom live on which cells.      [2.x.36]  sparsity_pattern The sparsity pattern to be filled with   entries.      [2.x.37]  constraints The process for generating entries described above   is purely local to each cell. Consequently, the sparsity pattern does   not provide for matrix entries that will only be written into during   the elimination of hanging nodes or other constraints. They have to be   taken care of by a subsequent call to  [2.x.38]    Alternatively, the constraints on degrees of freedom can already be   taken into account at the time of creating the sparsity pattern. For   this, pass the AffineConstraints object as the third argument to the   current function. No call to  [2.x.39]  is then   necessary. This process is explained in  [2.x.40] ,  [2.x.41] , and other   tutorial programs.      [2.x.42]  keep_constrained_dofs In case the constraints are already   taken care of in this function by passing in a AffineConstraints object,   it is possible to abandon some off-diagonal entries in the sparsity   pattern if these entries will also not be written into during the actual   assembly of the matrix this sparsity pattern later serves. Specifically,   when using an assembly method that uses    [2.x.43]  no entries will ever be   written into those matrix rows or columns that correspond to constrained   degrees of freedom. In such cases, you can set the argument  [2.x.44]    keep_constrained_dofs to  [2.x.45]  to avoid allocating these entries in   the sparsity pattern.      [2.x.46]  subdomain_id If specified, the sparsity pattern is built only   on cells that have a subdomain_id equal to the given argument. This is   useful in parallel contexts where the matrix and sparsity pattern (for   example a  [2.x.47]  may be distributed and not   every MPI process needs to build the entire sparsity pattern; in that   case, it is sufficient if every process only builds that part of the   sparsity pattern that corresponds to the subdomain_id for which it is   responsible. This feature is used in  [2.x.48] . (This argument is not   usually needed for objects of type  [2.x.49]    because the current function only loops over locally owned cells anyway;   thus, this argument typically only makes sense if you want to use the   subdomain_id for anything other than indicating which processor owns a   cell, for example which geometric component of the domain a cell belongs   to.)    
*  [2.x.50]  The actual type of the sparsity pattern may be SparsityPattern,   DynamicSparsityPattern, BlockSparsityPattern,   BlockDynamicSparsityPattern, or any other class that satisfies similar   requirements. It is assumed that the size of the sparsity pattern matches   the number of degrees of freedom and that enough unused nonzero entries   are left to fill the sparsity pattern if the sparsity pattern is of   "static" kind (see    [2.x.51]    for more information on what this means). The nonzero entries generated   by this function are added to possible previous content of the object,   i.e., previously added entries are not removed.    
*  [2.x.52]  If the sparsity pattern is represented by an object of type   SparsityPattern (as opposed to, for example, DynamicSparsityPattern), you   need to remember using  [2.x.53]  after generating the   pattern.    
*  [2.x.54]   
* [0.x.13]*
   Compute which entries of a matrix built on the given  [2.x.55]  may   possibly be nonzero, and create a sparsity pattern object that represents   these nonzero locations.     This function is a simple variation on the previous   make_sparsity_pattern() function (see there for a description of all of   the common arguments), but it provides functionality for vector finite   elements that allows to be more specific about which variables couple in   which equation.     For example, if you wanted to solve the Stokes equations,    
* [1.x.4]
*      in two space dimensions, using stable Q2/Q1 mixed elements (using the   FESystem class), then you don't want all degrees of freedom to couple in   each equation. More specifically, in the first equation, only  [2.x.56]  and    [2.x.57]  appear; in the second equation, only  [2.x.58]  and  [2.x.59]  appear; and in the   third equation, only  [2.x.60]  and  [2.x.61]  appear. (Note that this discussion   only talks about vector components of the solution variable and the   different equation, and has nothing to do with degrees of freedom, or in   fact with any kind of discretization.) We can describe this by the   following pattern of "couplings":     [1.x.5]     where "1" indicates that two variables (i.e., vector components of the   FESystem) couple in the respective equation, and a "0" means no coupling.   These zeros imply that upon discretization via a standard finite element   formulation, we will not write entries into the matrix that, for example,   couple pressure test functions with pressure shape functions (and similar   for the other zeros above). It is then a waste to allocate memory for   these entries in the matrix and the sparsity pattern, and you can avoid   this by creating a mask such as the one above that describes this to the   (current) function that computes the sparsity pattern. As stated above,   the mask shown above refers to components of the composed FESystem,   rather than to degrees of freedom or shape functions.     This function is designed to accept a coupling pattern, like the one   shown above, through the  [2.x.62]  parameter, which contains values of   type #Coupling. It builds the matrix structure just like the previous   function, but does not create matrix elements if not specified by the   coupling pattern. If the couplings are symmetric, then so will be the   resulting sparsity pattern.     There is a complication if some or all of the shape functions of the   finite element in use are non-zero in more than one component (in deal.II   speak: they are    [2.x.63]  "non-primitive finite elements").   In this case, the coupling element corresponding to the first non-zero   component is taken and additional ones for this component are ignored.    
*  [2.x.64]   
* [0.x.14]*
   Construct a sparsity pattern that allows coupling degrees of freedom on   two different but related meshes.     The idea is that if the two given DoFHandler objects correspond to two   different meshes (and potentially to different finite elements used on   these cells), but that if the two triangulations they are based on are   derived from the same coarse mesh through hierarchical refinement, then   one may set up a problem where one would like to test shape functions   from one mesh against the shape functions from another mesh. In   particular, this means that shape functions from a cell on the first mesh   are tested against those on the second cell that are located on the   corresponding cell; this correspondence is something that the   IntergridMap class can determine.     This function then constructs a sparsity pattern for which the degrees of   freedom that represent the rows come from the first given DoFHandler,   whereas the ones that correspond to columns come from the second   DoFHandler.  
* [0.x.15]*
   Compute which entries of a matrix built on the given  [2.x.65]  may   possibly be nonzero, and create a sparsity pattern object that represents   these nonzero locations. This function is a variation of the   make_sparsity_pattern() functions above in that it assumes that the   bilinear form you want to use to generate the matrix also contains terms   that integrate over the [1.x.6] between cells (i.e., it contains   "fluxes" between cells, explaining the name of the function).     This function is useful for Discontinuous Galerkin methods where the   standard make_sparsity_pattern() function would only create nonzero   entries for all degrees of freedom on one cell coupling to all other   degrees of freedom on the same cell; however, in DG methods, all or some   degrees of freedom on each cell also couple to the degrees of freedom on   other cells connected to the current one by a common face. The current   function also creates the nonzero entries in the matrix resulting from   these additional couplings. In other words, this function computes a   strict super-set of nonzero entries compared to the work done by   make_sparsity_pattern().      [2.x.66]  dof_handler The DoFHandler object that describes which degrees   of freedom live on which cells.      [2.x.67]  sparsity_pattern The sparsity pattern to be filled with   entries.    
*  [2.x.68]  The actual type of the sparsity pattern may be SparsityPattern,   DynamicSparsityPattern, BlockSparsityPattern,   BlockDynamicSparsityPattern, or any other class that satisfies similar   requirements. It is assumed that the size of the sparsity pattern matches   the number of degrees of freedom and that enough unused nonzero entries   are left to fill the sparsity pattern if the sparsity pattern is of   "static" kind (see    [2.x.69]    for more information on what this means). The nonzero entries generated   by this function are added to possible previous content of the object,   i.e., previously added entries are not removed.    
*  [2.x.70]  If the sparsity pattern is represented by an object of type   SparsityPattern (as opposed to, for example, DynamicSparsityPattern), you   need to remember using  [2.x.71]  after generating the   pattern.    
*  [2.x.72]   
* [0.x.16]*
   This function does essentially the same as the other   make_flux_sparsity_pattern() function but allows the specification of a   number of additional arguments. These carry the same meaning as discussed   in the first make_sparsity_pattern() function above.    
*  [2.x.73]   
* [0.x.17]*
   This function does essentially the same as the other   make_flux_sparsity_pattern() function but allows the specification of   coupling matrices that state which components of the solution variable   couple in each of the equations you are discretizing. This works in   complete analogy as discussed in the second make_sparsity_pattern()   function above.     In fact, this function takes two such masks, one describing which   variables couple with each other in the cell integrals that make up your   bilinear form, and which variables couple with each other in the face   integrals. If you passed masks consisting of only 1s to both of these,   then you would get the same sparsity pattern as if you had called the   first of the make_sparsity_pattern() functions above. By setting some of   the entries of these masks to zeros, you can get a sparser sparsity   pattern.    
*  [2.x.74]   
* [0.x.18]*
   This function does essentially the same as the previous   make_flux_sparsity_pattern() function but allows the application of an   AffineConstraints object. This is useful in the case where some   components of a finite element are continuous and some discontinuous,   allowing constraints to be imposed on the continuous part while also   building the flux terms needed for the discontinuous part.     The optional  [2.x.75]  can be used to specify on which   faces flux couplings occur. This allows for creating a sparser pattern when   using a bilinear form where flux terms only appear on a subset of the faces   in the triangulation. By default flux couplings are added over all internal   faces.  [2.x.76]  should be a function that takes an   active_cell_iterator and a face index and should return true if there is a   flux coupling over the face. When using the  [2.x.77]  we could,   for example, use    
* [1.x.7]
*   
* [0.x.19]*
   Create the sparsity pattern for boundary matrices. See the general   documentation of this class for more information.     The function does essentially what the other make_sparsity_pattern()   functions do, but assumes that the bilinear form that is used to build   the matrix does not consist of domain integrals, but only of integrals   over the boundary of the domain.  
* [0.x.20]*
   This function is a variation of the previous   make_boundary_sparsity_pattern() function in which we assume that the   boundary integrals that will give rise to the matrix extends only over   those parts of the boundary whose boundary indicators are listed in the    [2.x.78]  argument to this function.     This function could have been written by passing a  [2.x.79]  of boundary_id   numbers. However, most of the functions throughout deal.II dealing with   boundary indicators take a mapping of boundary indicators and the   corresponding boundary function, i.e., a  [2.x.80]  const   Function<spacedim,number>*> argument. Correspondingly, this function does   the same, though the actual boundary function is ignored here.   (Consequently, if you don't have any such boundary functions, just create a   map with the boundary indicators you want and set the function pointers to   null pointers).  
* [0.x.21]*
    [2.x.81]   
* [0.x.22]*
    [2.x.82]  Hanging nodes and other constraints    [2.x.83]   
* [0.x.23]*
   Compute the constraints resulting from the presence of hanging nodes.   Hanging nodes are best explained using a small picture:      [2.x.84]      In order to make a finite element function globally continuous, we have   to make sure that the dark red nodes have values that are compatible with   the adjacent yellow nodes, so that the function has no jump when coming   from the small cells to the large one at the top right. We therefore have   to add conditions that constrain those "hanging nodes".     The object into which these are inserted is later used to condense the   global system matrix and right hand side, and to extend the solution   vectors from the true degrees of freedom also to the constraint nodes.   This function is explained in detail in the    [2.x.85]  " [2.x.86] "   tutorial program and is used in almost all following programs as well.     This function does not clear the AffineConstraints object before use, in   order to allow adding constraints from different sources to the same   object. You therefore need to make sure it contains only constraints you   still want; otherwise call the  [2.x.87]  function.   Since this function does not check if it would add cycles in    [2.x.88]  it is recommended to call this function prior to other   functions that constrain DoFs with respect to others such as   make_periodicity_constraints().   This function does not close the object since you may want to   enter other constraints later on yourself.     Using a DoFHandler with hp-capabilities, we consider constraints due to   different finite elements used on two sides of a face between cells as   hanging nodes as well. In other words, in hp-mode, this function computes   all constraints due to differing mesh sizes (h) or polynomial degrees (p)   between adjacent cells.    
*  [2.x.89]   
* [0.x.24]*
   This function is used when different variables in a problem are   discretized on different grids, where one grid is strictly coarser than   the other. An example are optimization problems where the control   variable is often discretized on a coarser mesh than the state variable.     The function's result can be stated as follows mathematically: Let  [2.x.90]  and  [2.x.91]  be two meshes where  [2.x.92]  results from    [2.x.93]  strictly by refining or leaving alone the cells of  [2.x.94] . Using the same finite element on both, there are function spaces    [2.x.95]  and  [2.x.96]  associated with these meshes. Then every   function  [2.x.97]  can of course also be represented exactly   in  [2.x.98]  since by construction  [2.x.99] .   However, not every function in  [2.x.100]  can be expressed as a linear   combination of the shape functions of  [2.x.101] . The functions that   can be represented lie in a homogeneous subspace of  [2.x.102]  (namely,    [2.x.103] , of course) and this subspace can be represented by a linear   constraint of the form  [2.x.104]  where  [2.x.105]  is the vector of nodal values of   functions  [2.x.106] . In other words, every function  [2.x.107]  that also satisfies  [2.x.108]  automatically satisfies  [2.x.109] . This function computes the matrix    [2.x.110]  in the form of a AffineConstraints object.     The construction of these constraints is done as follows: for each of the   degrees of freedom (i.e. shape functions) on the coarse grid, we compute   its representation on the fine grid, i.e. how the linear combination of   shape functions on the fine grid looks like that resembles the shape   function on the coarse grid. From this information, we can then compute   the constraints which have to hold if a solution of a linear equation on   the fine grid shall be representable on the coarse grid. The exact   algorithm how these constraints can be computed is rather complicated and   is best understood by reading the source code, which contains many   comments.     The use of this function is as follows: it accepts as parameters two DoF   Handlers, the first of which refers to the coarse grid and the second of   which is the fine grid. On both, a finite element is represented by the   DoF handler objects, which will usually have several vector components,   which may belong to different base elements. The second and fourth   parameter of this function therefore state which vector component on the   coarse grid shall be used to restrict the stated component on the fine   grid. The finite element used for the respective components on the two   grids needs to be the same. An example may clarify this: consider an   optimization problem with controls  [2.x.111]  discretized on a coarse mesh and a   state variable  [2.x.112]  (and corresponding Lagrange multiplier  [2.x.113] )   discretized on the fine mesh. These are discretized using piecewise   constant discontinuous, continuous linear, and continuous linear   elements, respectively. Only the parameter  [2.x.114]  is represented on the   coarse grid, thus the DoFHandler object on the coarse grid represents   only one variable, discretized using piecewise constant discontinuous   elements. Then, the parameter denoting the vector component on the coarse   grid would be zero (the only possible choice, since the variable on the   coarse grid is scalar). If the ordering of variables in the fine mesh   FESystem is  [2.x.115] , then the fourth argument of the function   corresponding to the vector component would be one (corresponding to the   variable  [2.x.116] ; zero would be  [2.x.117] , two would be  [2.x.118] ).     The function also requires an object of type IntergridMap representing   how to get from the coarse mesh cells to the corresponding cells on the   fine mesh. This could in principle be generated by the function itself   from the two DoFHandler objects, but since it is probably available   anyway in programs that use different meshes, the function simply takes   it as an argument.     The computed constraints are entered into a variable of type   AffineConstraints; previous contents are not deleted.  
* [0.x.25]*
   This function generates a matrix such that when a vector of data with as   many elements as there are degrees of freedom of this component on the   coarse grid is multiplied to this matrix, we obtain a vector with as many   elements as there are global degrees of freedom on the fine grid. All the   elements of the other vector components of the finite element fields on   the fine grid are not touched.     Triangulation of the fine grid can be distributed. When called in   parallel, each process has to have a copy of the coarse grid. In this   case, function returns transfer representation for a set of locally owned   cells.     The output of this function is a compressed format that can be used to   construct corresponding sparse transfer matrix.  
* [0.x.26]*
    [2.x.119]   
* [0.x.27]*
    [2.x.120]  Periodic boundary conditions    [2.x.121]   
* [0.x.28]*
   Insert the (algebraic) constraints due to periodic boundary conditions   into an AffineConstraints object  [2.x.122]      Given a pair of not necessarily active boundary faces  [2.x.123]  and  [2.x.124]    face_2, this functions constrains all DoFs associated with the boundary   described by  [2.x.125]  to the respective DoFs of the boundary described   by  [2.x.126]  More precisely:     If  [2.x.127]  and  [2.x.128]  are both active faces it adds the DoFs of  [2.x.129]    face_1 to the list of constrained DoFs in  [2.x.130]  and adds   entries to constrain them to the corresponding values of the DoFs on  [2.x.131]    face_2. This happens on a purely algebraic level, meaning, the global DoF   with (local face) index <tt>i</tt> on  [2.x.132]  gets constraint to the   DoF with (local face) index <tt>i</tt> on  [2.x.133]  (possibly corrected   for orientation, see below).     Otherwise, if  [2.x.134]  and  [2.x.135]  are not active faces, this function   loops recursively over the children of  [2.x.136]  and  [2.x.137]  If only   one of the two faces is active, then we recursively iterate over the   children of the non-active ones and make sure that the solution function   on the refined side equals that on the non-refined face in much the same   way as we enforce hanging node constraints at places where differently   refined cells come together. (However, unlike hanging nodes, we do not   enforce the requirement that there be only a difference of one refinement   level between the two sides of the domain you would like to be periodic).     This routine only constrains DoFs that are not already constrained. If   this routine encounters a DoF that already is constrained (for instance   by Dirichlet boundary conditions), the old setting of the constraint   (dofs the entry is constrained to, inhomogeneities) is kept and nothing   happens.     The flags in the  [2.x.138]  (see    [2.x.139] )   denote which components of the finite element space shall be constrained   with periodic boundary conditions. If it is left as specified by the   default value all components are constrained. If it is different from the   default value, it is assumed that the number of entries equals the number   of components of the finite element. This can be used to enforce   periodicity in only one variable in a system of equations.      [2.x.140]   [2.x.141]  and  [2.x.142]  describe an   orientation that should be applied to  [2.x.143]  prior to matching and   constraining DoFs. This has nothing to do with the actual orientation of   the given faces in their respective cells (which for boundary faces is   always the default) but instead how you want to see periodicity to be   enforced. For example, by using these flags, you can enforce a condition   of the kind  [2.x.144]  (i.e., a Moebius band) or in 3d a twisted   torus. More precisely, these flags match local face DoF indices in the   following manner:     In 2d: <tt>face_orientation</tt> must always be <tt>true</tt>,   <tt>face_rotation</tt> is always <tt>false</tt>, and face_flip has the   meaning of <tt>line_flip</tt>; this implies e.g. for <tt>Q1</tt>:    
* [1.x.8]
*      And similarly for the case of Q1 in 3d:    
* [1.x.9]
*      Optionally a matrix  [2.x.145]  along with a  [2.x.146]   [2.x.147]    first_vector_components can be specified that describes how DoFs on  [2.x.148]    face_1 should be modified prior to constraining to the DoFs of  [2.x.149]    Here, two declarations are possible: If the  [2.x.150]   [2.x.151]    first_vector_components is non empty the matrix is interpreted as a  [2.x.152]    dim  [2.x.153]   [2.x.154]  rotation matrix that is applied to all vector valued   blocks listed in  [2.x.155]  of the FESystem. If  [2.x.156]    first_vector_components is empty the matrix is interpreted as an   interpolation matrix with size no_face_dofs  [2.x.157]  no_face_dofs.     This function makes sure that identity constraints don't create cycles   in  [2.x.158]       [2.x.159]  can be used to implement Bloch periodic conditions   (a.k.a. phase shift periodic conditions) of the form    [2.x.160]    where  [2.x.161]  is periodic with the same periodicity as the crystal lattice and    [2.x.162]  is the wavevector, see   [https://en.wikipedia.org/wiki/Bloch_wave](https://en.wikipedia.org/wiki/Bloch_wave).   The solution at  [2.x.163]  is equal to the solution at  [2.x.164]  times    [2.x.165]  For example, if the solution at  [2.x.166]  is    [2.x.167]  and  [2.x.168]  is the corresponding point on  [2.x.169]  then   the solution at  [2.x.170]  should be    [2.x.171] . This condition can be   implemented using    [2.x.172] .     Detailed information can be found in the see    [2.x.173]  "Glossary entry on periodic boundary conditions".  
* [0.x.29]*
   Insert the (algebraic) constraints due to periodic boundary conditions   into an AffineConstraints object  [2.x.174]      This is the main high level interface for above low level variant of   make_periodicity_constraints(). It takes a  [2.x.175]   [2.x.176]    as argument and applies above make_periodicity_constraints() on each   entry.  [2.x.177]  can be created by    [2.x.178]     
*  [2.x.179]  For DoFHandler objects that are built on a    [2.x.180]  object    [2.x.181]  has to be called   before calling this function..      [2.x.182]     [2.x.183]  "Glossary entry on periodic boundary conditions"   and  [2.x.184]  for further information.  
* [0.x.30]*
   The same as above.      [2.x.185]  Use the function that takes dim and spacedim as template     argument.  
* [0.x.31]*
   Insert the (algebraic) constraints due to periodic boundary conditions   into a AffineConstraints  [2.x.186]      This function serves as a high level interface for the   make_periodicity_constraints() function.     Define a 'first' boundary as all boundary faces having boundary_id  [2.x.187]    b_id1 and a 'second' boundary consisting of all faces belonging to  [2.x.188]    b_id2.     This function tries to match all faces belonging to the first boundary   with faces belonging to the second boundary with the help of   orthogonal_equality(). More precisely, faces with coordinates only   differing in the  [2.x.189]  component are identified.     If this matching is successful it constrains all DoFs associated with the   'first' boundary to the respective DoFs of the 'second' boundary   respecting the relative orientation of the two faces.    
*  [2.x.190]  This function is a convenience wrapper. It internally calls    [2.x.191]  with the supplied parameters and   feeds the output to above make_periodicity_constraints() variant. If you   need more functionality use  [2.x.192]  directly.      [2.x.193]     [2.x.194]  "Glossary entry on periodic boundary conditions"   for further information.  
* [0.x.32]*
   This compatibility version of make_periodicity_constraints only works on   grids with cells in    [2.x.195]  "standard orientation".     Instead of defining a 'first' and 'second' boundary with the help of two   boundary_ids this function defines a 'left' boundary as all faces with   local face index  [2.x.196]  and boundary indicator  [2.x.197]    and, similarly, a 'right' boundary consisting of all face with local face   index  [2.x.198]  and boundary indicator  [2.x.199]  Faces with   coordinates only differing in the  [2.x.200]  component are identified.    
*  [2.x.201]  This version of make_periodicity_constraints  will not work on   meshes with cells not in    [2.x.202]  "standard orientation".    
*  [2.x.203]  This function is a convenience wrapper. It internally calls    [2.x.204]  with the supplied parameters and   feeds the output to above make_periodicity_constraints() variant. If you   need more functionality use  [2.x.205]  directly.      [2.x.206]     [2.x.207]  "Glossary entry on periodic boundary conditions"   for further information.  
* [0.x.33]*
    [2.x.208]   
* [0.x.34]*
    [2.x.209]  Identifying subsets of degrees of freedom with particular properties    [2.x.210]   
* [0.x.35]*
   Return an IndexSet describing all dofs that will be constrained by   interface constraints, i.e. all hanging nodes.     In case of a  [2.x.211]  or a    [2.x.212]  only locally relevant dofs are   considered.  
* [0.x.36]*
   Extract the (locally owned) indices of the degrees of freedom belonging to   certain vector components of a vector-valued finite element. The    [2.x.213]  defines which components or blocks of an FESystem or   vector-valued element are to be extracted   from the DoFHandler  [2.x.214]  The entries in the output object then   correspond to degrees of freedom belonging to these   components.     If the finite element under consideration is not primitive, i.e., some or   all of its shape functions are non-zero in more than one vector component   (which holds, for example, for FE_Nedelec or FE_RaviartThomas elements),   then shape functions cannot be associated with a single vector component.   In this case, if  [2.x.215] one [2.x.216]  shape vector component of this element is   flagged in  [2.x.217]  (see    [2.x.218] ),   then this is equivalent to selecting  [2.x.219] all [2.x.220]  vector components   corresponding to this non-primitive base element.      [2.x.221]  dof_handler The DoFHandler whose enumerated degrees of freedom     are to be filtered by this function.    [2.x.222]  component_mask A mask that states which components you want     to select. The size of this mask must be compatible with the number of     components in the FiniteElement used by the  [2.x.223]  See      [2.x.224]  "the glossary entry on component masks"     for more information.    [2.x.225]  An IndexSet object that will contain exactly those entries that     (i) correspond to degrees of freedom selected by the mask above, and     (ii) are locally owned. The size of the index set is equal to the global     number of degrees of freedom. Note that the resulting object is always     a subset of what  [2.x.226]  returns.  
* [0.x.37]*
   This function is the equivalent to the  [2.x.227]  functions   above except that the selection of which degrees of freedom to extract is   not done based on components (see    [2.x.228] )   but instead based on whether they are part of a particular block (see    [2.x.229] ).   Consequently, the second argument is not a ComponentMask but a BlockMask   object.      [2.x.230]  dof_handler The DoFHandler whose enumerated degrees of freedom     are to be filtered by this function.    [2.x.231]  block_mask A mask that states which blocks you want     to select. The size of this mask must be compatible with the number of     blocks in the FiniteElement used by the  [2.x.232]  See      [2.x.233]  "the glossary entry on block masks"     for more information.    [2.x.234]  An IndexSet object that will contain exactly those entries that     (i) correspond to degrees of freedom selected by the mask above, and     (ii) are locally owned. The size of the index set is equal to the global     number of degrees of freedom. Note that the resulting object is always     a subset of what  [2.x.235]  returns.  
* [0.x.38]*
   Do the same thing as the corresponding extract_dofs() function for one   level of a multi-grid DoF numbering.  
* [0.x.39]*
   Do the same thing as the corresponding extract_dofs() function for one   level of a multi-grid DoF numbering.  
* [0.x.40]*
   Extract all degrees of freedom which are at the boundary and belong to   specified components of the solution. The function returns its results in   the last non-default-valued parameter which contains  [2.x.236]  if a degree   of freedom is at the boundary and belongs to one of the selected   components, and  [2.x.237]  otherwise.     By specifying the  [2.x.238]  variable, you can select which boundary   indicators the faces have to have on which the degrees of freedom are   located that shall be extracted. If it is an empty list, then all   boundary indicators are accepted.     The size of  [2.x.239]  (see    [2.x.240] )   shall equal the number of components in the finite element used by  [2.x.241]    dof. The size of  [2.x.242]  shall equal   <tt>dof_handler.n_dofs()</tt>. Previous contents of this array are   overwritten.     Using the usual convention, if a shape function is non-zero in more than   one component (i.e. it is non-primitive), then the element in the   component mask is used that corresponds to the first non-zero components.   Elements in the mask corresponding to later components are ignored.      [2.x.243]  This function will not work for DoFHandler objects that are built   on a  [2.x.244]  object. The reasons is that the   output argument  [2.x.245]  has to have a length equal to [1.x.10]   global degrees of freedom. Consequently, this does not scale to very   large problems, and this is also why the function is deprecated. If you   need the functionality of this function for   parallel triangulations, then you need to use the other    [2.x.246]  function that returns its information   via an IndexSet object.      [2.x.247]  dof_handler The object that describes which degrees of freedom   live on which cell.    [2.x.248]  component_mask A mask denoting the vector components of the   finite element that should be considered (see also    [2.x.249] ).    [2.x.250]  selected_dofs A vector of booleans that is returned and for   which   an element will be  [2.x.251]  if the corresponding index is a   degree of freedom that is located on the   boundary (and correspond to the selected vector components and boundary   indicators, depending on the values of the  [2.x.252]  and  [2.x.253]    boundary_ids arguments).    [2.x.254]  boundary_ids If empty, this function extracts the indices of the   degrees of freedom for all parts of the boundary. If it is a non- empty   list, then the function only considers boundary faces with the boundary   indicators listed in this argument.      [2.x.255]     [2.x.256]  "Glossary entry on boundary indicators"  
* [0.x.41]*
   Extract all degrees of freedom which are at the boundary and belong to   specified components of the solution. The function returns its results in   the form of an IndexSet that contains those entries that correspond to   these selected degrees of freedom, i.e., which are at the boundary and   belong to one of the selected components.     By specifying the  [2.x.257]  variable, you can select which boundary   indicators the faces have to have on which the degrees of freedom are   located that shall be extracted. If it is an empty list (the default), then   all boundary indicators are accepted.     This function is used in  [2.x.258]  and  [2.x.259] , for example.    
*  [2.x.260]  If the DoFHandler object is defined on a   parallel Triangulation object, then the computed index set   will contain only those degrees of freedom on the boundary that belong to   the locally relevant set (see    [2.x.261]  "locally relevant DoFs"), i.e., the function   only considers faces of locally owned and ghost cells, but not of   artificial cells.      [2.x.262]  dof_handler The object that describes which degrees of freedom   live on which cell.    [2.x.263]  component_mask A mask denoting the vector components of the   finite element that should be considered (see also    [2.x.264] ). If left at the default, the component mask   indicates that all vector components of the finite element should be   considered.    [2.x.265]  boundary_ids If empty, this function extracts the indices of the   degrees of freedom for all parts of the boundary. If it is a non-empty   list, then the function only considers boundary faces with the boundary   indicators listed in this argument.    [2.x.266]  The IndexSet object that   will contain the indices of degrees of freedom that are located on the   boundary (and correspond to the selected vector components and boundary   indicators, depending on the values of the  [2.x.267]  and  [2.x.268]    boundary_ids arguments).      [2.x.269]     [2.x.270]  "Glossary entry on boundary indicators"  
* [0.x.42]*
   The same as the previous function, except that it returns its information   via the third argument.      [2.x.271]  Use the previous function instead.  
* [0.x.43]*
   This function is similar to the extract_boundary_dofs() function but it   extracts those degrees of freedom whose shape functions are nonzero on at   least part of the selected boundary. For continuous elements, this is   exactly the set of shape functions whose degrees of freedom are defined   on boundary faces. On the other hand, if the finite element in used is a   discontinuous element, all degrees of freedom are defined in the inside   of cells and consequently none would be boundary degrees of freedom.   Several of those would have shape functions that are nonzero on the   boundary, however. This function therefore extracts all those for which   the  [2.x.272]  function says that it is nonzero   on any face on one of the selected boundary parts.      [2.x.273]     [2.x.274]  "Glossary entry on boundary indicators"  
* [0.x.44]*
   Extract all indices of shape functions such that their support is entirely   contained within the cells for which the  [2.x.275]  is  [2.x.276] .   The result is returned as an IndexSet.     Consider the following FE space where predicate returns  [2.x.277]    for all cells on the left half of the domain:      [2.x.278]      This functions will return the union of all DoF indices on those cells   minus DoF 11, 13, 2 and 0; the result will be <code>[9,10], 12,   [14,38]</code>. In the image above the returned DoFs are separated from the   rest by the red line     Essentially, the question this functions answers is the following:   Given a subdomain with associated DoFs, what is the largest subset of   these DoFs that are allowed to be non-zero such that after calling    [2.x.279]  the resulting solution vector will have   support only within the given domain. Here,  [2.x.280]  is the   AffineConstraints container containing hanging nodes constraints.     In case of  [2.x.281]   [2.x.282]  will be called   only for locally owned and ghost cells. The resulting index set may contain   DoFs that are associated with the locally owned or ghost cells, but are not   owned by the current MPI core.  
* [0.x.45]*
   Extract a vector that represents the constant modes of the DoFHandler for   the components chosen by <tt>component_mask</tt> (see    [2.x.283] ).   The constant modes on a discretization are the null space of a Laplace   operator on the selected components with Neumann boundary conditions   applied. The null space is a necessary ingredient for obtaining a good   AMG preconditioner when using the class    [2.x.284]   Since the ML AMG package only works   on algebraic properties of the respective matrix, it has no chance to   detect whether the matrix comes from a scalar or a vector valued problem.   However, a near null space supplies exactly the needed information about   the components placement of vector components within the matrix. The null   space (or rather, the constant modes) is provided by the finite element   underlying the given DoFHandler and for most elements, the null space   will consist of as many vectors as there are true arguments in   <tt>component_mask</tt> (see    [2.x.285] ),   each of which will be one in one vector component and zero in all others.   However, the representation of the constant function for e.g. FE_DGP is   different (the first component on each element one, all other components   zero), and some scalar elements may even have two constant modes   (FE_Q_DG0). Therefore, we store this object in a vector of vectors, where   the outer vector contains the collection of the actual constant modes on   the DoFHandler. Each inner vector has as many components as there are   (locally owned) degrees of freedom in the selected components. Note that   any matrix associated with this null space must have been constructed   using the same <tt>component_mask</tt> argument, since the numbering of   DoFs is done relative to the selected dofs, not to all dofs.     The main reason for this program is the use of the null space with the   AMG preconditioner.  
* [0.x.46]*
    [2.x.286]  Parallelization and domain decomposition    [2.x.287]   
* [0.x.47]*
   Flag all those degrees of freedom which are on cells with the given   subdomain id. Note that DoFs on faces can belong to cells with differing   subdomain ids, so the sets of flagged degrees of freedom are not mutually   exclusive for different subdomain ids.     If you want to get a unique association of degree of freedom with   subdomains, use the  [2.x.288]  function.  
* [0.x.48]*
   Extract the set of global DoF indices that are active on the current   DoFHandler. For regular DoFHandlers, these are all DoF indices, but for   DoFHandler objects built on  [2.x.289]  this set   is a superset of  [2.x.290]  and contains all DoF   indices that live on all locally owned cells (including on the interface   to ghost cells). However, it does not contain the DoF indices that are   exclusively defined on ghost or artificial cells (see    [2.x.291]  "the glossary").     The degrees of freedom identified by this function equal those obtained   from the dof_indices_with_subdomain_association() function when called   with the locally owned subdomain id.  
* [0.x.49]*
   Same function as above but for a certain (multigrid-)level.   This function returns all DoF indices that live on   all locally owned cells (including on the interface to ghost cells) on the   given level.  
* [0.x.50]*
   Extract the set of global DoF indices that are active on the current   DoFHandler. For regular DoFHandlers, these are all DoF indices, but for   DoFHandler objects built on  [2.x.292]  this set   is the union of  [2.x.293]  and the DoF indices on   all ghost cells. In essence, it is the DoF indices on all cells that are   not artificial (see    [2.x.294]  "the glossary").  
* [0.x.51]*
   Extract the set of locally owned DoF indices for each component within the   mask that are owned by the current  processor. For components disabled by   the mask, an empty IndexSet is returned. For a scalar DoFHandler built on a   sequential triangulation, the return vector contains a single complete   IndexSet with all DoF indices. If the mask contains all components (which   also corresponds to the default value), then the union of the returned   index sets equlas what  [2.x.295]  returns.  
* [0.x.52]*
   For each processor, determine the set of locally owned degrees of freedom   as an IndexSet. This function then returns a vector of index sets, where   the vector has size equal to the number of MPI processes that participate   in the DoF handler object.     The function can be used for objects of type  [2.x.296]  or    [2.x.297]  It will not work for objects of type    [2.x.298]  since for such triangulations we do   not have information about all cells of the triangulation available   locally, and consequently can not say anything definitive about the   degrees of freedom active on other processors' locally owned cells.  
* [0.x.53]*
     For each processor, determine the set of locally relevant degrees of   freedom as an IndexSet. This function then returns a vector of index   sets, where the vector has size equal to the number of MPI processes that   participate in the DoF handler object.     The function can be used for objects of type  [2.x.299]  or    [2.x.300]  It will not work for objects of type    [2.x.301]  since for such triangulations we do   not have information about all cells of the triangulation available   locally, and consequently can not say anything definitive about the   degrees of freedom active on other processors' locally owned cells.  
* [0.x.54]*
   Same as extract_locally_relevant_dofs() but for multigrid DoFs for the   given  [2.x.302]   
* [0.x.55]*
   For each degree of freedom, return in the output array to which subdomain   (as given by the <tt>cell->subdomain_id()</tt> function) it belongs. The   output array is supposed to have the right size already when calling this   function.     Note that degrees of freedom associated with faces, edges, and vertices   may be associated with multiple subdomains if they are sitting on   partition boundaries. In these cases, we assign them to the process with   the smaller subdomain id. This may lead to different numbers of degrees   of freedom in partitions, even if the number of cells is perfectly   equidistributed. While this is regrettable, it is not a problem in   practice since the number of degrees of freedom on partition boundaries   is asymptotically vanishing as we refine the mesh as long as the number   of partitions is kept constant.     This function returns the association of each DoF with one subdomain. If   you are looking for the association of each  [2.x.303]  cell with a subdomain,   either query the <tt>cell->subdomain_id()</tt> function, or use the    [2.x.304]  function.     Note that this function is of questionable use for DoFHandler objects   built on  [2.x.305]  since in that case   ownership of individual degrees of freedom by MPI processes is controlled   by the DoF handler object, not based on some geometric algorithm in   conjunction with subdomain id. In particular, the degrees of freedom   identified by the functions in this namespace as associated with a   subdomain are not the same the DoFHandler class identifies as those it   owns.  
* [0.x.56]*
   Count how many degrees of freedom are uniquely associated with the given    [2.x.306]  index.     Note that there may be rare cases where cells with the given  [2.x.307]    index exist, but none of its degrees of freedom are actually associated   with it. In that case, the returned value will be zero.     This function will generate an exception if there are no cells with the   given  [2.x.308]  index.     This function returns the number of DoFs associated with one subdomain.   If you are looking for the association of  [2.x.309]  cells with this subdomain,   use the  [2.x.310]    function.     Note that this function is of questionable use for DoFHandler objects   built on  [2.x.311]  since in that case   ownership of individual degrees of freedom by MPI processes is controlled   by the DoF handler object, not based on some geometric algorithm in   conjunction with subdomain id. In particular, the degrees of freedom   identified by the functions in this namespace as associated with a   subdomain are not the same the DoFHandler class identifies as those it   owns.  
* [0.x.57]*
   Count how many degrees of freedom are uniquely associated with the given    [2.x.312]  index.     This function does what the previous one does except that it splits the   result among the vector components of the finite element in use by the   DoFHandler object. The last argument (which must have a length equal to   the number of vector components) will therefore store how many degrees of   freedom of each vector component are associated with the given subdomain.     Note that this function is of questionable use for DoFHandler objects   built on  [2.x.313]  since in that case   ownership of individual degrees of freedom by MPI processes is controlled   by the DoF handler object, not based on some geometric algorithm in   conjunction with subdomain id. In particular, the degrees of freedom   identified by the functions in this namespace as associated with a   subdomain are not the same the DoFHandler class identifies as those it   owns.  
* [0.x.58]*
   Return a set of indices that denotes the degrees of freedom that live on   the given subdomain, i.e. that are on cells owned by the current   processor. Note that this includes the ones that this subdomain "owns"   (i.e. the ones for which get_subdomain_association() returns a value   equal to the subdomain given here and that are selected by the    [2.x.314]  function) but also all of those that sit   on the boundary between the given subdomain and other subdomain. In   essence, degrees of freedom that sit on boundaries between subdomain will   be in the index sets returned by this function for more than one   subdomain.     Note that this function is of questionable use for DoFHandler objects   built on  [2.x.315]  since in that case   ownership of individual degrees of freedom by MPI processes is controlled   by the DoF handler object, not based on some geometric algorithm in   conjunction with subdomain id. In particular, the degrees of freedom   identified by the functions in this namespace as associated with a   subdomain are not the same the DoFHandler class identifies as those it   owns.  
* [0.x.59]*
    [2.x.316]  DoF indices on patches of cells     Create structures containing a large set of degrees of freedom for small   patches of cells. The resulting objects can be used in RelaxationBlockSOR   and related classes to implement Schwarz preconditioners and smoothers,   where the subdomains consist of small numbers of cells only.  
* [0.x.60]*
   Return the set of degrees of freedom that live on a set of cells (i.e., a   patch) described by the argument.     Patches are often used in defining error estimators that require the   solution of a local problem on the patch surrounding each of the cells of   the mesh. You can get a list of cells that form the patch around a given   cell using  [2.x.317]  While    [2.x.318]  can be used to determine the size of   these local problems, so that one can assemble the local system and then   solve it, it is still necessary to provide a mapping between the global   indices of the degrees of freedom that live on the patch and a local   enumeration. This function provides such a local enumeration by returning   the set of degrees of freedom that live on the patch.     Since this set is returned in the form of a  [2.x.319]  one can also   think of it as a mapping  
* [1.x.11]
*    where  [2.x.320]  is an index into the returned vector (i.e., a the   [1.x.12] index of a degree of freedom on the patch) and    [2.x.321]  is the global index of a degree of freedom   located on the patch. The array returned has size equal to    [2.x.322]     
*  [2.x.323]  The array returned is sorted by global DoF index. Consequently, if   one considers the index into this array a local DoF index, then the local   system that results retains the block structure of the global system.      [2.x.324]  patch A collection of cells within an object of type   DoFHandler<dim,  [2.x.325]       [2.x.326]  A list of those global degrees of freedom located on the patch,   as defined above.    
*  [2.x.327]  In the context of a parallel distributed computation, it only makes   sense to call this function on patches around locally owned cells. This   is because the neighbors of locally owned cells are either locally owned   themselves, or ghost cells. For both, we know that these are in fact the   real cells of the complete, parallel triangulation. We can also query the   degrees of freedom on these. In other words, this function can only work   if all cells in the patch are either locally owned or ghost cells.  
* [0.x.61]*
   The same as above.      [2.x.328]  Use the function that takes dim and spacedim as template     argument.  
* [0.x.62]*
   Creates a sparsity pattern, which lists   the degrees of freedom associated to each cell on the given   level. This pattern can be used in RelaxationBlock classes as   block list for additive and multiplicative Schwarz methods.     The row index in this pattern is the cell index resulting from   standard iteration through a level of the Triangulation. For a    [2.x.329]  only locally owned cells   are entered.     The sparsity pattern is resized in this function to contain as   many rows as there are locally owned cells on a given level, as   many columns as there are degrees of freedom on this level.     <tt>selected_dofs</tt> is a vector indexed by the local degrees   of freedom on a cell. If it is used, only such dofs are entered   into the block list which are selected. This allows for instance   the exclusion of components or of dofs on the boundary.  
* [0.x.63]*
   Create an incidence matrix that for every vertex on a given level of a   multilevel DoFHandler flags which degrees of freedom are associated with   the adjacent cells. This data structure is a matrix with as many rows as   there are vertices on a given level, as many columns as there are degrees   of freedom on this level, and entries that are either true or false. This   data structure is conveniently represented by a SparsityPattern object.   The sparsity pattern may be empty when entering this function and will be   reinitialized to the correct size.     The function has some boolean arguments (listed below) controlling   details of the generated patches. The default settings are those for   Arnold-Falk-Winther type smoothers for divergence and curl conforming   finite elements with essential boundary conditions. Other applications   are possible, in particular changing <tt>boundary_patches</tt> for non-   essential boundary conditions.     This function returns the <tt>vertex_mapping</tt>,   that contains the mapping from the vertex indices to the block indices   of the <tt>block_list</tt>. For vertices that do not lead to a vertex   patch, the entry in <tt>vertex_mapping</tt> contains the value   <tt>invalid_unsigned_int</tt>. If <tt>invert_vertex_mapping</tt> is set to   <tt>true</tt>, then the <tt>vertex_mapping</tt> is inverted such that it   contains the mapping from the block indices to the corresponding vertex   indices.      [2.x.330]  <tt>block_list</tt>: the SparsityPattern into which the patches will   be stored.      [2.x.331]  <tt>dof_handler</tt>: the multilevel dof handler providing the   topology operated on.      [2.x.332]  <tt>interior_dofs_only</tt>: for each patch of cells around a   vertex, collect only the interior degrees of freedom of the patch and   disregard those on the boundary of the patch. This is for instance the   setting for smoothers of Arnold-Falk-Winther type.      [2.x.333]  <tt>boundary_patches</tt>: include patches around vertices at the   boundary of the domain. If not, only patches around interior vertices   will be generated.      [2.x.334]  <tt>level_boundary_patches</tt>: same for refinement edges towards   coarser cells.      [2.x.335]  <tt>single_cell_patches</tt>: if not true, patches containing a   single cell are eliminated.      [2.x.336]  <tt>invert_vertex_mapping</tt>: if true, then the return value   contains one vertex index for each block; if false, then the return value   contains one block index or <tt>invalid_unsigned_int</tt> for each vertex.  
* [0.x.64]*
   Same as above but allows boundary dofs on blocks to be excluded   individually.     This is helpful if you want to use, for example, Taylor Hood elements as   it allows you to not include the boundary DoFs for the velocity block on   the patches while also letting you include the boundary DoFs for the   pressure block.     For each patch of cells around a vertex, collect all of the interior   degrees of freedom of the patch and disregard those on the boundary of   the patch if the boolean value for the corresponding block in the   BlockMask of  [2.x.337]  is false.  
* [0.x.65]*
   Create an incidence matrix that for every cell on a given level of a   multilevel DoFHandler flags which degrees of freedom are associated with   children of this cell. This data structure is conveniently represented by   a SparsityPattern object.     The function thus creates a sparsity pattern which in each row (with rows   corresponding to the cells on this level) lists the degrees of freedom   associated to the cells that are the children of this cell. The DoF   indices used here are level dof indices of a multilevel hierarchy, i.e.,   they may be associated with children that are not themselves active. The   sparsity pattern may be empty when entering this function and will be   reinitialized to the correct size.     The function has some boolean arguments (listed below) controlling   details of the generated patches. The default settings are those for   Arnold-Falk-Winther type smoothers for divergence and curl conforming   finite elements with essential boundary conditions. Other applications   are possible, in particular changing <tt>boundary_dofs</tt> for non-   essential boundary conditions.      [2.x.338]  <tt>block_list</tt>: the SparsityPattern into which the patches will   be stored.      [2.x.339]  <tt>dof_handler</tt>: The multilevel dof handler providing the   topology operated on.      [2.x.340]  <tt>interior_dofs_only</tt>: for each patch of cells around a   vertex, collect only the interior degrees of freedom of the patch and   disregard those on the boundary of the patch. This is for instance the   setting for smoothers of Arnold-Falk-Winther type.      [2.x.341]  <tt>boundary_dofs</tt>: include degrees of freedom, which would have   excluded by <tt>interior_dofs_only</tt>, but are lying on the boundary of   the domain, and thus need smoothing. This parameter has no effect if   <tt>interior_dofs_only</tt> is false.  
* [0.x.66]*
   Create a block list with only a single patch, which in turn contains all   degrees of freedom on the given level.     This function is mostly a closure on level 0 for functions like   make_child_patches() and make_vertex_patches(), which may produce an   empty patch list.      [2.x.342]  <tt>block_list</tt>: the SparsityPattern into which the patches will   be stored.      [2.x.343]  <tt>dof_handler</tt>: The multilevel dof handler providing the   topology operated on.      [2.x.344]  <tt>level</tt> The grid level used for building the list.      [2.x.345]  <tt>interior_dofs_only</tt>: if true, exclude degrees of freedom on   the boundary of the domain.  
* [0.x.67]*
    [2.x.346]   
* [0.x.68]*
    [2.x.347]  Counting degrees of freedom and related functions    [2.x.348]   
* [0.x.69]*
   Count how many degrees of freedom out of the total number belong to each   component. If the number of components the finite element has is one   (i.e. you only have one scalar variable), then the number in this   component obviously equals the total number of degrees of freedom.   Otherwise, the sum of the DoFs in all the components needs to equal the   total number.     However, the last statement does not hold true if the finite element is   not primitive, i.e. some or all of its shape functions are non-zero in   more than one vector component. This applies, for example, to the Nedelec   or Raviart-Thomas elements. In this case, a degree of freedom is counted   in each component in which it is non-zero, so that the sum mentioned   above is greater than the total number of degrees of freedom.     This behavior can be switched off by the optional parameter   <tt>vector_valued_once</tt>. If this is <tt>true</tt>, the number of   components of a nonprimitive vector valued element is collected only in   the first component. All other components will have a count of zero.     The additional optional argument  [2.x.349]  allows for a re-   sorting and grouping of components. To this end, it contains for each   component the component number it shall be counted as. Having the same   number entered several times sums up several components as the same. One   of the applications of this argument is when you want to form block   matrices and vectors, but want to pack several components into the same   block (for example, when you have  [2.x.350]  velocities and one pressure, to   put all velocities into one block, and the pressure into another).     The result is returned in  [2.x.351]  Note that the size of  [2.x.352]    dofs_per_component needs to be enough to hold all the indices specified   in  [2.x.353]  If this is not the case, an assertion is thrown.   The indices not targeted by target_components are left untouched.  
* [0.x.70]*
   Count the degrees of freedom in each block. This function is similar to   count_dofs_per_component(), with the difference that the counting is done   by blocks. See    [2.x.354]  "blocks"   in the glossary for details. Again the vectors are assumed to have the   correct size before calling this function. If this is not the case, an   assertion is thrown.     This function is used in the  [2.x.355] ,  [2.x.356] , and  [2.x.357]  tutorial   programs, among others.      [2.x.358]  The dofs_per_block variable has as many components as the finite   element used by the dof_handler argument has blocks, or alternatively as   many blocks as are enumerated in the target_blocks argument if given.  
* [0.x.71]*
   For each active cell of a DoFHandler, extract the active finite element   index and fill the vector given as second argument. This vector is assumed   to have as many entries as there are active cells.     For DoFHandler objects without hp-capabilities given as first argument, the   returned vector will consist of only zeros, indicating that all cells use   the same finite element. In hp-mode, the values may be different, though.  
* [0.x.72]*
   Count how many degrees of freedom live on a set of cells (i.e., a patch)   described by the argument.     Patches are often used in defining error estimators that require the   solution of a local problem on the patch surrounding each of the cells of   the mesh. You can get a list of cells that form the patch around a given   cell using  [2.x.359]  This function is then   useful in setting up the size of the linear system used to solve the   local problem on the patch around a cell. The function    [2.x.360]  will then help to make the connection   between global degrees of freedom and the local ones.      [2.x.361]  patch A collection of cells within an object of type   DoFHandler<dim, spacedim>      [2.x.362]  The number of degrees of freedom associated with the cells of   this patch.    
*  [2.x.363]  In the context of a parallel distributed computation, it only makes   sense to call this function on patches around locally owned cells. This   is because the neighbors of locally owned cells are either locally owned   themselves, or ghost cells. For both, we know that these are in fact the   real cells of the complete, parallel triangulation. We can also query the   degrees of freedom on these. In other words, this function can only work   if all cells in the patch are either locally owned or ghost cells.  
* [0.x.73]*
   The same as above.      [2.x.364]  Use the function that takes dim and spacedim as template     argument.  
* [0.x.74]*
    [2.x.365]   
* [0.x.75]*
    [2.x.366]  Functions that return different DoF mappings    [2.x.367]   
* [0.x.76]*
   Create a mapping from degree of freedom indices to the index of that   degree of freedom on the boundary. After this operation,   <tt>mapping[dof]</tt> gives the index of the degree of freedom with   global number  [2.x.368]  in the list of degrees of freedom on the boundary.   If the degree of freedom requested is not on the boundary, the value of   <tt>mapping[dof]</tt> is  [2.x.369]  This function is   mainly used when setting up matrices and vectors on the boundary from the   trial functions, which have global numbers, while the matrices and vectors   use numbers of the trial functions local to the boundary.     Prior content of  [2.x.370]  is deleted.  
* [0.x.77]*
   Same as the previous function, except that only those parts of the   boundary are considered for which the boundary indicator is listed in the   second argument.     See the general doc of this class for more information.      [2.x.371]     [2.x.372]  "Glossary entry on boundary indicators"  
* [0.x.78]*
   Return a list of support points (see this    [2.x.373]  "glossary entry")   for all the degrees of freedom handled by this DoF handler object. This   function, of course, only works if the finite element object used by the   DoF handler object actually provides support points, i.e. no edge   elements or the like. Otherwise, an exception is thrown.      [2.x.374]  The given array must have a length of as many elements as there are   degrees of freedom.    
*  [2.x.375]  The precondition to this function that the output argument needs to   have size equal to the total number of degrees of freedom makes this   function unsuitable for the case that the given DoFHandler object derives   from a  [2.x.376]  object (or any of the classes derived   from  [2.x.377]  Consequently, this function will produce   an error if called with such a DoFHandler.      [2.x.378]  mapping The mapping from the reference cell to the real cell on   which DoFs are defined.    [2.x.379]  dof_handler The object that describes which DoF indices live on   which cell of the triangulation.    [2.x.380]  support_points A vector that stores the corresponding   location of the dofs in real space coordinates. Previous content of this   object is deleted in this function.    [2.x.381]  mask An optional component mask that restricts the   components from which the support points are extracted.  
* [0.x.79]*
   Same as the previous function but for the hp-case.  
* [0.x.80]*
   This function is a version of the above map_dofs_to_support_points   function that doesn't simply return a vector of support points (see this    [2.x.382]  "glossary entry")   with one entry for each global degree of freedom, but instead a map that   maps from the DoFs index to its location. The point of this function is   that it is also usable in cases where the DoFHandler is based on a    [2.x.383]  object (or any of the classes derived from    [2.x.384]  In such cases, each   processor will not be able to determine the support point location of all   DoFs, and worse no processor may be able to hold a vector that would   contain the locations of all DoFs even if they were known. As a   consequence, this function constructs a map from those DoFs for which we   can know the locations (namely, those DoFs that are locally relevant (see    [2.x.385]  "locally relevant DoFs")   to their locations.     For non-distributed triangulations, the map returned as  [2.x.386]    is of course dense, i.e., every DoF is to be found in it.      [2.x.387]  mapping The mapping from the reference cell to the real cell on   which DoFs are defined.    [2.x.388]  dof_handler The object that describes which DoF indices live on   which cell of the triangulation.    [2.x.389]  support_points A map that for every locally relevant DoF   index contains the corresponding location in real space coordinates.   Previous content of this object is deleted in this function.    [2.x.390]  mask An optional component mask that restricts the   components from which the support points are extracted.  
* [0.x.81]*
   Same as the previous function but for the hp-case.  
* [0.x.82]*
   This is the opposite function to the one above. It generates a map where   the keys are the support points of the degrees of freedom, while the   values are the DoF indices. For a definition of support points, see this    [2.x.391]  "glossary entry".     Since there is no natural order in the space of points (except for the 1d   case), you have to provide a map with an explicitly specified comparator   object. This function is therefore templatized on the comparator object.   Previous content of the map object is deleted in this function.     Just as with the function above, it is assumed that the finite element in   use here actually supports the notion of support points of all its   components.      [2.x.392]  This function should generate a multimap, rather than just a map,   since several dofs may be located at the same support point. Currently,   only the last value in the map returned by map_dofs_to_support_points() for   each point will be returned.  
* [0.x.83]*
    [2.x.393]   
* [0.x.84]*
    [2.x.394]  Miscellaneous    [2.x.395]   
* [0.x.85]*
   Take a vector of values which live on cells (e.g. an error per cell) and   distribute it to the dofs in such a way that a finite element field   results, which can then be further processed, e.g. for output. You should   note that the resulting field will not be continuous at hanging nodes.   This can, however, easily be arranged by calling the appropriate  [2.x.396]    distribute function of an AffineConstraints object created for this   DoFHandler object, after the vector has been fully assembled.     It is assumed that the number of elements in  [2.x.397]  equals the   number of active cells and that the number of elements in  [2.x.398]    equals <tt>dof_handler.n_dofs()</tt>.     Note that the input vector may be a vector of any data type as long as it   is convertible to  [2.x.399]   The output vector, being a data vector on a   DoF handler, always consists of elements of type  [2.x.400]      In case the finite element used by this DoFHandler consists of more than   one component, you need to specify which component in the output vector   should be used to store the finite element field in; the default is zero   (no other value is allowed if the finite element consists only of one   component). All other components of the vector remain untouched, i.e.   their contents are not changed.     This function cannot be used if the finite element in use has shape   functions that are non-zero in more than one vector component (in deal.II   speak: they are non-primitive).  
* [0.x.86]*
   Generate text output readable by gnuplot with point data based on the   given map  [2.x.401]   For each support point location, a string   label containing a list of all DoFs from the map is generated.  The map   can be generated with a call to map_dofs_to_support_points() and is useful   to visualize location and global numbering of unknowns.     An example for the format of each line in the output is:  
* [1.x.13]
*    where x, y, and z (present only in corresponding dimension) are the   coordinates of the support point, followed by a list of DoF numbers.     The points with labels can be plotted as follows in gnuplot:  
* [1.x.14]
*      Examples (this also includes the grid written separately using GridOut):    [2.x.402]      To generate the mesh and the support point information in a   single gnuplot file, use code similar to  
* [1.x.15]
*    and from within gnuplot execute the following command:  
* [1.x.16]
*      Alternatively, the following gnuplot script will generate a png file when   executed as <tt>gnuplot gnuplot.gpl</tt> on the command line:  
* [1.x.17]
*   
* [0.x.87]*
   Add constraints to  [2.x.403]  corresponding to   enforcing a zero boundary condition on the given boundary indicator.     This function constrains all degrees of freedom on the given part of the   boundary.     A variant of this function with different arguments is used in  [2.x.404] .      [2.x.405]  dof The DoFHandler to work on.    [2.x.406]  boundary_id The indicator of that part of the boundary for which   constraints should be computed. If this number equals    [2.x.407]  then all boundaries of the domain will be   treated.    [2.x.408]  zero_boundary_constraints The constraint object into which the   constraints will be written. The new constraints due to zero boundary   values will simply be added, preserving any other constraints previously   present. However, this will only work if the previous content of that   object consists of constraints on degrees of freedom that are not located   on the boundary treated here. If there are previously existing   constraints for degrees of freedom located on the boundary, then this   would constitute a conflict. See the    [2.x.409]    module for handling the case where there are conflicting constraints on   individual degrees of freedom.    [2.x.410]  component_mask An optional component mask that restricts the   functionality of this function to a subset of an FESystem. For non-    [2.x.411]  "primitive"   shape functions, any degree of freedom is affected that belongs to a   shape function where at least one of its nonzero components is affected   by the component mask (see    [2.x.412] ).   If this argument is omitted, all components of the finite element with   degrees of freedom at the boundary will be considered.    
*  [2.x.413]       [2.x.414]     [2.x.415]  "Glossary entry on boundary indicators"  
* [0.x.88]*
   Do the same as the previous function, except do it for all parts of the   boundary, not just those with a particular boundary indicator. This   function is then equivalent to calling the previous one with    [2.x.416]  as second argument.     This function is used in  [2.x.417] , for example.    
*  [2.x.418]   
* [0.x.89]*
    [2.x.419]   
* [0.x.90]*
    [2.x.420]  Exceptions    [2.x.421]   
* [0.x.91]*
    [2.x.422]  Write description    
*  [2.x.423]   
* [0.x.92]*
    [2.x.424]  Write description    
*  [2.x.425]   
* [0.x.93]*
    [2.x.426]  Write description     Exception  
*  [2.x.427]   
* [0.x.94]*
   The DoFHandler was not initialized with a finite element. Please call    [2.x.428]  first.    
*  [2.x.429]   
* [0.x.95]*
    [2.x.430]  Write description    
*  [2.x.431]   
* [0.x.96]*
    [2.x.432]   
* [0.x.97]*
   Operator computing the maximum coupling out of two.      [2.x.433]  DoFTools  
* [0.x.98]*
   Operator computing the maximum coupling out of two.      [2.x.434]  DoFTools  
* [0.x.99]

include/deal.II-translator/dofs/number_cache_0.txt
[0.x.0]*
     A structure used by the DoFHandler classes to store information about     the degrees of freedom they deal with.    
* [0.x.1]*
       Default constructor.      
* [0.x.2]*
       Copy constructor. Simply copy all members of the referenced       object to the current object.      
* [0.x.3]*
       Move constructor. Simply move all members of the referenced       object to the current object.      
* [0.x.4]*
       Create a NumberCache object that corresponds to a sequential       DoFHandler object in which a single processor stores all       degrees of freedom. (Here, "sequential" means that either       the whole program does not use MPI, or that it uses MPI       but only uses a single MPI process, or that there are multiple MPI       processes but the Triangulation on which this DoFHandler builds       works only on one MPI process.)      
* [0.x.5]*
       Create a NumberCache object that corresponds to a parallel       DoFHandler object with as many processors as the size of the       given argument, in which each processor stores the degrees       of freedom indicated in the corresponding element of the       vector passed as first argument. The second argument indicates       the rank among all participating processors the current       processor has, so that we can set the  [2.x.0]        and  [2.x.1]  fields.             All other fields stored by the current object can be and are computed       from the argument.      
* [0.x.6]*
       Copy operator. Simply copy all members of the referenced       object to the current object.      
* [0.x.7]*
       Move assignment operator. Simply move all members of the referenced       object to the current object.      
* [0.x.8]*
       Determine an estimate for the memory consumption (in bytes) of this       object.      
* [0.x.9]*
       This function resets all the stored information.      
* [0.x.10]*
       Return a representation of  [2.x.2]  both       in case it was set up (directly returning the array) or in case we       need to accumulate some information over all processors. The latter       case involves global communication and is typically expensive to set       up because it invokes MPI_Allgather.      
* [0.x.11]*
       Return a representation of  [2.x.3]  both       in case it was set up (directly returning the array of IndexSet       fields) or in case we need to accumulate some information over all       processors. The latter case involves global communication and is       typically expensive to set up because it invokes MPI_Allgather.      
* [0.x.12]*
       Total number of dofs, accumulated over all processors that may       participate on this mesh.      
* [0.x.13]*
       Number of dofs owned by this MPI process. If this is a sequential       computation, then this equals n_global_dofs. (Here, "sequential" means       that either the whole program does not use MPI, or that it uses MPI but       only uses a single MPI process, or that there are multiple MPI       processes but the Triangulation on which this DoFHandler builds       works only on one MPI process.)      
* [0.x.14]*
       An index set denoting the set of locally owned dofs. If this is a       sequential computation, then it contains the entire range       [0,n_global_dofs). (Here, "sequential" means that either       the whole program does not use MPI, or that it uses MPI       but only uses a single MPI process, or that there are multiple MPI       processes but the Triangulation on which this DoFHandler builds       works only on one MPI process.)      
* [0.x.15]*
       The number of dofs owned by each of the various MPI processes. If       this is a sequential computation, then the vector contains a single       element equal to n_global_dofs. (Here, "sequential" means that either       the whole program does not use MPI, or that it uses MPI       but only uses a single MPI process, or that there are multiple MPI       processes but the Triangulation on which this DoFHandler builds       works only on one MPI process.)      
* [0.x.16]*
       The dofs owned by each of the various MPI processes. If this is a       sequential DoFHandler, then the vector has a single element equal to       locally_owned_dofs. (Here, "sequential" means that either       the whole program does not use MPI, or that it uses MPI       but only uses a single MPI process, or that there are multiple MPI       processes but the Triangulation on which this DoFHandler builds       works only on one MPI process.)      
* [0.x.17]*
       Read or write the data of this object to or from a stream for the       purpose of serialization using the [BOOST serialization       library](https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html).      
* [0.x.18]

