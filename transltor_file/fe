include/deal.II-translator/fe/block_mask_0.txt
[0.x.0]*
 This class represents a mask that can be used to select individual vector blocks of a finite element (see also  [2.x.0]  "this glossary entry"). It will typically have as many elements as the finite element has blocks, and one can use  [2.x.1]  to query whether a particular block has been selected.
*  The semantics of this class are the same as the related ComponentMask class, i.e., a default constructed mask represents all possible blocks. See there for more information about these semantics.
*  Objects of this kind are used in many places where one wants to restrict operations to a certain subset of blocks, e.g. in  [2.x.2]  These objects can either be created by hand, or, simpler, by asking the finite element to generate a block mask from certain selected blocks using code such as this where we create a mask that only denotes the velocity block of a Stokes element (see  [2.x.3] ):

* 
* [1.x.0]
*  Note that by wrapping the velocity elements into a single FESystem object we make sure that the overall element has only 2 blocks. The result is a block mask that, in both 2d and 3d, would have values <code>[false, true]</code>. (Compare this to the corresponding component mask discussed in the ComponentMask documentation.) Similarly, using

* 
* [1.x.1]
*  would result in a mask  [2.x.4]  in both 2d and 3d.
* 

* 
*  [2.x.5] 

* 
*  [2.x.6] 

* 
* [0.x.1]*
   Initialize a block mask. The default is that a block mask represents a   set of blocks that are [1.x.2] selected, i.e., calling this   constructor results in a block mask that always returns  [2.x.7]    whenever asked whether a block is selected.  
* [0.x.2]*
   Initialize an object of this type with a set of selected blocks specified   by the argument.      [2.x.8]  block_mask A vector of  [2.x.9]  entries that   determine which blocks of a finite element are selected. If the length of   the given vector is zero, then this interpreted as the case where   [1.x.3] block is selected.  
* [0.x.3]*
   Initialize the block mask with a number of elements that are either all   true or false.      [2.x.10]  n_blocks The number of elements of this mask    [2.x.11]  initializer The value each of these elements is supposed to have:   either true or false.  
* [0.x.4]*
   If this block mask has been initialized with a mask of size greater than   zero, then return the size of the mask represented by this object. On the   other hand, if this mask has been initialized as an empty object that   represents a mask that is true for every element (i.e., if this object   would return true when calling represents_the_all_selected_mask()) then   return zero since no definite size is known.  
* [0.x.5]*
   Return whether a particular block is selected by this mask. If this mask   represents the case of an object that selects [1.x.4] (e.g. if   it is created using the default constructor or is converted from an empty   vector of type bool) then this function returns true regardless of the   given argument.      [2.x.12]  block_index The index for which the function should return whether   the block is selected. If this object represents a mask in which all   blocks are always selected then any index is allowed here. Otherwise, the   given index needs to be between zero and the number of blocks that this   mask represents.  
* [0.x.6]*
   Return whether this block mask represents a mask with exactly    [2.x.13]  blocks. This is true if either it was initialized with a   vector with exactly  [2.x.14]  (in   this case,  [2.x.15]  must equal the result of size()) or if it was initialized   with an empty vector (or using the default constructor) in which case it   can represent a mask with an arbitrary number of blocks and will always   say that a block is selected.  
* [0.x.7]*
   Return the number of blocks that are selected by this mask.     Since empty block masks represent a block mask that would return    [2.x.16]  for every block, this function may not know the true   size of the block mask and it therefore requires an argument that denotes   the overall number of blocks.     If the object has been initialized with a non-empty mask (i.e., if the   size() function returns something greater than zero, or equivalently if   represents_the_all_selected_mask() returns false) then the argument can   be omitted and the result of size() is taken.  
* [0.x.8]*
   Return the index of the first selected block. The argument is there for   the same reason it exists with the n_selected_blocks() function.     The function throws an exception if no block is selected at all.  
* [0.x.9]*
   Return true if this mask represents a default constructed mask that   corresponds to one in which all blocks are selected. If true, then the   size() function will return zero.  
* [0.x.10]*
   Return a block mask that contains the union of the blocks selected by the   current object and the one passed as an argument.  
* [0.x.11]*
   Return a block mask that has only those elements set that are set both in   the current object as well as the one passed as an argument.  
* [0.x.12]*
   Return whether this object and the argument are identical.  
* [0.x.13]*
   Return whether this object and the argument are not identical.  
* [0.x.14]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.15]*
   The actual block mask.  
* [0.x.16]*
 Write a block mask to an output stream. If the block mask represents one where all blocks are selected without specifying a particular size of the mask, then it writes the string  [2.x.17]  to the stream. Otherwise, it prints the block mask in a form like  [2.x.18] .
*   [2.x.19]  out The stream to write to.  [2.x.20]  mask The mask to write.  [2.x.21]  A reference to the first argument.

* 
* [0.x.17]

include/deal.II-translator/fe/component_mask_0.txt
[0.x.0]*
 This class represents a mask that can be used to select individual vector components of a finite element (see also  [2.x.0]  "this glossary entry"). It will typically have as many elements as the finite element has vector components, and one can use  [2.x.1]  to query whether a particular component has been selected.
* 

* 
*  [2.x.2]  A "mask" represents a data structure with  [2.x.3]  and  [2.x.4]    entries that is generally used to enable or disable an operation   for a particular vector component. By this definition, disabled   vector components still exist
* 
*  -  they are simply not touched. As   a consequence, when you apply a component mask for interpolating   boundary values (to choose just one example) of a problem with    [2.x.5]  vector components, the input argument that describes the   boundary values will still have to provide  [2.x.6]  components even   if the mask says that we only want to interpolate a subset of   these components onto the finite element space. In other words,   a component mask does not represent a [1.x.0] operation;   it represents a [1.x.1].
*  Objects of this kind are used in many places where one wants to restrict operations to a certain subset of components, e.g. in  [2.x.7]  or  [2.x.8]  These objects can either be created by hand, or, simpler, by asking the finite element to generate a component mask from certain selected components using code such as this where we create a mask that only denotes the velocity components of a Stokes element (see  [2.x.9] ):

* 
* [1.x.2]
*  The result is a component mask that, in 2d, would have values <code>[false, false, true]</code>. Similarly, using

* 
* [1.x.3]
*  would result in a mask  [2.x.10]  in 2d. Of course, in 3d, the result would be  [2.x.11] .
* 

* 
*  [2.x.12] 

* 
*  [2.x.13] 

* 
* [0.x.1]*
   Initialize a component mask. The default is that a component mask   represents a set of components that are [1.x.4] selected, i.e.,   calling this constructor results in a component mask that always returns    [2.x.14]  whenever asked whether a component is selected.  
* [0.x.2]*
   Initialize an object of this type with a set of selected components   specified by the argument.      [2.x.15]  component_mask A vector of  [2.x.16]  entries that   determine which components of a finite element are selected. If the   length of the given vector is zero, then this interpreted as the case   where [1.x.5] component is selected.  
* [0.x.3]*
   Initialize the component mask with a number of elements that are either   all true or false.      [2.x.17]  n_components The number of elements of this mask    [2.x.18]  initializer The value each of these elements is supposed to have:   either true or false.  
* [0.x.4]*
   Set a particular entry in the mask to a value.  
* [0.x.5]*
   If this component mask has been initialized with a mask of size greater   than zero, then return the size of the mask represented by this object.   On the other hand, if this mask has been initialized as an empty object   that represents a mask that is true for every element (i.e., if this   object would return true when calling represents_the_all_selected_mask())   then return zero since no definite size is known.  
* [0.x.6]*
   Return whether a particular component is selected by this mask. If this   mask represents the case of an object that selects [1.x.6]   (e.g. if it is created using the default constructor or is converted from   an empty vector of type bool) then this function returns true regardless   of the given argument.      [2.x.19]  component_index The index for which the function should return   whether the component is selected. If this object represents a mask in   which all components are always selected then any index is allowed here.   Otherwise, the given index needs to be between zero and the number of   components that this mask represents.  
* [0.x.7]*
   Return whether this component mask represents a mask with exactly    [2.x.20]  components. This is true if either it was initialized with   a vector with exactly  [2.x.21]    (in this case,  [2.x.22]  must equal the result of size()) or if it was   initialized with an empty vector (or using the default constructor) in   which case it can represent a mask with an arbitrary number of components   and will always say that a component is selected.  
* [0.x.8]*
   Return the number of components that are selected by this mask.     Since empty component masks represent a component mask that would return    [2.x.23]  for every component, this function may not know the   true size of the component mask and it therefore requires an argument   that denotes the overall number of components.     If the object has been initialized with a non-empty mask (i.e., if the   size() function returns something greater than zero, or equivalently if   represents_the_all_selected_mask() returns false) then the argument can   be omitted and the result of size() is taken.  
* [0.x.9]*
   Return the index of the first selected component. The argument is there   for the same reason it exists with the n_selected_components() function.     The function throws an exception if no component is selected at all.  
* [0.x.10]*
   Return true if this mask represents a default constructed mask that   corresponds to one in which all components are selected. If true, then   the size() function will return zero.  
* [0.x.11]*
   Return a component mask that contains the union of the components   selected by the current object and the one passed as an argument.  
* [0.x.12]*
   Return a component mask that has only those elements set that are set   both in the current object as well as the one passed as an argument.  
* [0.x.13]*
   Return whether this object and the argument are identical.  
* [0.x.14]*
   Return whether this object and the argument are not identical.  
* [0.x.15]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.16]*
   Exception  
* [0.x.17]*
   The actual component mask.  
* [0.x.18]*
 Write a component mask to an output stream. If the component mask represents one where all components are selected without specifying a particular size of the mask, then it writes the string <code>[all components selected]</code> to the stream. Otherwise, it prints the component mask in a form like  [2.x.24] .
*   [2.x.25]  out The stream to write to.  [2.x.26]  mask The mask to write.  [2.x.27]  A reference to the first argument.

* 
* [0.x.19]

include/deal.II-translator/fe/fe_0.txt
[0.x.0]*
 This is the base class for finite elements in arbitrary dimensions. It declares the interface both in terms of member variables and public member functions through which properties of a concrete implementation of a finite element can be accessed. This interface generally consists of a number of groups of variables and functions that can roughly be delineated as follows:
* 

* 
* 
*  - Basic information about the finite element, such as the number of degrees of freedom per vertex, edge, or cell. This kind of data is stored in the FiniteElementData base class. (Though the  [2.x.0]  member function also falls into this category.)
* 

* 
* 
*  - A description of the shape functions and their derivatives on the reference cell  [2.x.1] , if an element is indeed defined by mapping shape functions from the reference cell to an actual cell.
* 

* 
* 
*  - Matrices (and functions that access them) that describe how an element's shape functions related to those on parent or child cells (restriction or prolongation) or neighboring cells (for hanging node constraints), as well as to other finite element spaces defined on the same cell (e.g., when doing  [2.x.2]  refinement).
* 

* 
* 
*  - %Functions that describe the properties of individual shape functions, for example which  [2.x.3]  "vector components" of a  [2.x.4]  "vector-valued finite element's" shape function is nonzero, or whether an element is  [2.x.5]  "primitive".
* 

* 
* 
*  - For elements that are interpolatory, such as the common  [2.x.6]  Lagrange elements, data that describes where their  [2.x.7]  "support points" are located.
* 

* 
* 
*  - %Functions that define the interface to the FEValues class that is almost always used to access finite element shape functions from user code.
*  The following sections discuss many of these concepts in more detail, and outline strategies by which concrete implementations of a finite element can provide the details necessary for a complete description of a finite element space.
*  As a general rule, there are three ways by which derived classes provide this information:
* 

* 
* 
*  - A number of fields that are generally easy to compute and that are initialized by the constructor of this class (or the constructor of the FiniteElementData base class) and derived classes therefore have to compute in the process of calling this class's constructor. This is, specifically, the case for the basic information and parts of the descriptive information about shape functions mentioned above.
* 

* 
* 
*  - Some common matrices that are widely used in the library and for which this class provides protected member variables that the constructors of derived classes need to fill. The purpose of providing these matrices in this class is that (i) they are frequently used, and (ii) they are expensive to compute. Consequently, it makes sense to only compute them once, rather than every time they are used. In most cases, the constructor of the current class already sets them to their correct size, and derived classes therefore only have to fill them. Examples of this include the matrices that relate the shape functions on one cell to the shape functions on neighbors, children, and parents.
* 

* 
* 
*  - Uncommon information, or information that depends on specific input arguments, and that needs to be implemented by derived classes. For these, this base class only declares abstract virtual member functions and derived classes then have to implement them. Examples of this category would include the functions that compute values and derivatives of shape functions on the reference cell for which it is not possible to tabulate values because there are infinitely many points at which one may want to evaluate them. In some cases, derived classes may choose to simply not implement [1.x.0] possible interfaces (or may not [1.x.1] have a complete implementation); for uncommon functions, there is then often a member function derived classes can overload that describes whether a particular feature is implemented. An example is whether an element implements the information necessary to use it in the  [2.x.8]  finite element context (see  [2.x.9]  "hp-finite element support").
* 

*  [1.x.2]
*  Finite element classes have to define a large number of different properties describing  a finite element space. The following subsections describe some nomenclature that will be used in the documentation below.
*  [1.x.3]
*   [2.x.10]  "Vector-valued finite element" are elements used for systems of partial differential equations. Oftentimes, they are composed via the FESystem class (which is itself derived from the current class), but there are also non-composed elements that have multiple components (for example the FE_Nedelec and FE_RaviartThomas classes, among others). For any of these vector valued elements, individual shape functions may be nonzero in one or several  [2.x.11]  "components" of the vector valued function. If the element is  [2.x.12]  "primitive", there is indeed a single component with a nonzero entry for each shape function. This component can be determined using the  [2.x.13]  function.
*  On the other hand, if there is at least one shape function that is nonzero in more than one vector component, then we call the entire element "non- primitive". The  [2.x.14]  can then be used to determine which vector components of a shape function are nonzero. The number of nonzero components of a shape function is returned by  [2.x.15]  Whether a shape function is non-primitive can be queried by  [2.x.16] 
*  Oftentimes, one may want to split linear system into blocks so that they reflect the structure of the underlying operator. This is typically not done based on vector components, but based on the use of  [2.x.17]  "blocks", and the result is then used to substructure objects of type BlockVector, BlockSparseMatrix, BlockMatrixArray, and so on. If you use non-primitive elements, you cannot determine the block number by  [2.x.18]  Instead, you can use  [2.x.19]  The number of blocks of a finite element can be determined by  [2.x.20] 
*  To better illustrate these concepts, let's consider the following example of the multi-component system

* 
* [1.x.4]
*  with  [2.x.21] . The resulting finite element has 3 components: two that come from the quadratic element and one from the linear element. If, for example, this system were used to discretize a problem in fluid dynamics then one could think of the first two components representing a vector-valued velocity field whereas the last one corresponds to the scalar pressure field. Without degree-of-freedom (DoF) renumbering this finite element will produce the following distribution of local DoFs:
*   [2.x.22] 
*  Using the two functions  [2.x.23]  and  [2.x.24]  one can get the following information for each degree-of-freedom "i":

* 
* [1.x.5]
*  which will result in:
*  | DoF    | Component  | Base element | Shape function within base | Multiplicity | | :----: | :--------: | :----------: | :------------------------: | :----------: | |      0 |          0 |            0 |                          0 |            0 | |      1 |          1 |            0 |                          0 |            1 | |      2 |          2 |            1 |                          0 |            0 | |      3 |          0 |            0 |                          1 |            0 | |      4 |          1 |            0 |                          1 |            1 | |      5 |          2 |            1 |                          1 |            0 | |      6 |          0 |            0 |                          2 |            0 | |      7 |          1 |            0 |                          2 |            1 | |      8 |          2 |            1 |                          2 |            0 | |      9 |          0 |            0 |                          3 |            0 | |     10 |          1 |            0 |                          3 |            1 | |     11 |          2 |            1 |                          3 |            0 | |     12 |          0 |            0 |                          4 |            0 | |     13 |          1 |            0 |                          4 |            1 | |     14 |          0 |            0 |                          5 |            0 | |     15 |          1 |            0 |                          5 |            1 | |     16 |          0 |            0 |                          6 |            0 | |     17 |          1 |            0 |                          6 |            1 | |     18 |          0 |            0 |                          7 |            0 | |     19 |          1 |            0 |                          7 |            1 | |     20 |          0 |            0 |                          8 |            0 | |     21 |          1 |            0 |                          8 |            1 |
*  What we see is the following: there are a total of 22 degrees-of-freedom on this element with components ranging from 0 to 2. Each DoF corresponds to one of the two base elements used to build FESystem :  [2.x.25]  or  [2.x.26] . Since FE_Q are primitive elements, we have a total of 9 distinct scalar-valued shape functions for the quadratic element and 4 for the linear element. Finally, for DoFs corresponding to the first base element multiplicity is either zero or one, meaning that we use the same scalar valued  [2.x.27]  for both  [2.x.28]  and  [2.x.29]  components of the velocity field  [2.x.30] . For DoFs corresponding to the second base element multiplicity is zero.
*  [1.x.6]
*  Finite elements are frequently defined by defining a polynomial space and a set of dual functionals. If these functionals involve point evaluations, then the element is "interpolatory" and it is possible to interpolate an arbitrary (but sufficiently smooth) function onto the finite element space by evaluating it at these points. We call these points "support points".
*  Most finite elements are defined by mapping from the reference cell to a concrete cell. Consequently, the support points are then defined on the reference ("unit") cell, see  [2.x.31]  "this glossary entry". The support points on a concrete cell can then be computed by mapping the unit support points, using the Mapping class interface and derived classes, typically via the FEValues class.
*  A typical code snippet to do so would look as follows:

* 
* [1.x.7]
* 
*  Alternatively, the points can be transformed one-by-one:

* 
* [1.x.8]
* 
* 

* 
*  [2.x.32]  Finite elements' implementation of the get_unit_support_points() function returns these points in the same order as shape functions. As a consequence, the quadrature points accessed above are also ordered in this way. The order of shape functions is typically documented in the class documentation of the various finite element classes.
* 

*  [1.x.9]
*  The following sections provide some more guidance for implementing concrete finite element spaces in derived classes. This includes information that depends on the dimension for which you want to provide something, followed by a list of tools helping to generate information in concrete cases.
*  It is important to note that there is a number of intermediate classes that can do a lot of what is necessary for a complete description of finite element spaces. For example, the FE_Poly, FE_PolyTensor, and FE_PolyFace classes in essence build a complete finite element space if you only provide them with an abstract description of the polynomial space upon which you want to build an element. Using these intermediate classes typically makes implementing finite element descriptions vastly simpler.
*  As a general rule, if you want to implement an element, you will likely want to look at the implementation of other, similar elements first. Since many of the more complicated pieces of a finite element interface have to do with how they interact with mappings, quadrature, and the FEValues class, you will also want to read through the  [2.x.33]  documentation module.
* 

*  [1.x.10]
*  In one space dimension (i.e., for  [2.x.34]  and any value of  [2.x.35] ), finite element classes implementing the interface of the current base class need only set the #restriction and #prolongation matrices that describe the interpolation of the finite element space on one cell to that of its parent cell, and to that on its children, respectively. The constructor of the current class in one dimension presets the #interface_constraints matrix (used to describe hanging node constraints at the interface between cells of different refinement levels) to have size zero because there are no hanging nodes in 1d.
*  [1.x.11]
*  In addition to the fields discussed above for 1D, a constraint matrix is needed to describe hanging node constraints if the finite element has degrees of freedom located on edges or vertices. These constraints are represented by an  [2.x.36] -matrix #interface_constraints, where [1.x.12] is the number of degrees of freedom on the refined side without the corner vertices (those dofs on the middle vertex plus those on the two lines), and [1.x.13] is that of the unrefined side (those dofs on the two vertices plus those on the line). The matrix is thus a rectangular one. The  [2.x.37]  size of the #interface_constraints matrix can also be accessed through the interface_constraints_size() function.
*  The mapping of the dofs onto the indices of the matrix on the unrefined side is as follows: let  [2.x.38]  be the number of dofs on a vertex,  [2.x.39]  that on a line, then  [2.x.40]  refers to the dofs on vertex zero of the unrefined line,  [2.x.41]  to those on vertex one,  [2.x.42]  to those on the line.
*  Similarly,  [2.x.43]  refers to the dofs on the middle vertex of the refined side (vertex one of child line zero, vertex zero of child line one),  [2.x.44]  refers to the dofs on child line zero,  [2.x.45]  refers to the dofs on child line one.  Please note that we do not need to reserve space for the dofs on the end vertices of the refined lines, since these must be mapped one-to-one to the appropriate dofs of the vertices of the unrefined line.
*  Through this construction, the degrees of freedom on the child faces are constrained to the degrees of freedom on the parent face. The information so provided is typically consumed by the  [2.x.46]  function.
* 

* 
*  [2.x.47]  The hanging node constraints described by these matrices are only relevant to the case where the same finite element space is used on neighboring (but differently refined) cells. The case that the finite element spaces on different sides of a face are different, i.e., the  [2.x.48]  case (see  [2.x.49]  "hp-finite element support") is handled by separate functions. See the  [2.x.50]  and  [2.x.51]  functions.
* 

*  [1.x.14]
*  For the interface constraints, the 3d case is similar to the 2d case. The numbering for the indices  [2.x.52]  on the mother face is obvious and keeps to the usual numbering of degrees of freedom on quadrilaterals.
*  The numbering of the degrees of freedom on the interior of the refined faces for the index  [2.x.53]  is as follows: let  [2.x.54]  and  [2.x.55]  be as above, and  [2.x.56]  be the number of degrees of freedom per quadrilateral (and therefore per face), then  [2.x.57]  denote the dofs on the vertex at the center,  [2.x.58]  for the dofs on the vertices at the center of the bounding lines of the quadrilateral,  [2.x.59]  are for the degrees of freedom on the four lines connecting the center vertex to the outer boundary of the mother face,  [2.x.60]  for the degrees of freedom on the small lines surrounding the quad, and  [2.x.61]  for the dofs on the four child faces. Note the direction of the lines at the boundary of the quads, as shown below.
*  The order of the twelve lines and the four child faces can be extracted from the following sketch, where the overall order of the different dof groups is depicted:

* 
* [1.x.15]
*  The numbering of vertices and lines, as well as the numbering of children within a line is consistent with the one described in Triangulation. Therefore, this numbering is seen from the outside and inside, respectively, depending on the face.
*  The three-dimensional case has a few pitfalls available for derived classes that want to implement constraint matrices. Consider the following case:

* 
* [1.x.16]
*  Now assume that we want to refine cell 2. We will end up with two faces with hanging nodes, namely the faces between cells 1 and 2, as well as between cells 2 and 3. Constraints have to be applied to the degrees of freedom on both these faces. The problem is that there is now an edge (the top right one of cell 2) which is part of both faces. The hanging node(s) on this edge are therefore constrained twice, once from both faces. To be meaningful, these constraints of course have to be consistent: both faces have to constrain the hanging nodes on the edge to the same nodes on the coarse edge (and only on the edge, as there can then be no constraints to nodes on the rest of the face), and they have to do so with the same weights. This is sometimes tricky since the nodes on the edge may have different local numbers.
*  For the constraint matrix this means the following: if a degree of freedom on one edge of a face is constrained by some other nodes on the same edge with some weights, then the weights have to be exactly the same as those for constrained nodes on the three other edges with respect to the corresponding nodes on these edges. If this isn't the case, you will get into trouble with the AffineConstraints class that is the primary consumer of the constraint information: while that class is able to handle constraints that are entered more than once (as is necessary for the case above), it insists that the weights are exactly the same.
*  Using this scheme, child face degrees of freedom are constrained against parent face degrees of freedom that contain those on the edges of the parent face; it is possible that some of them are in turn constrained themselves, leading to longer chains of constraints that the AffineConstraints class will eventually have to sort out. (The constraints described above are used by the  [2.x.62]  function that constructs an AffineConstraints object.) However, this is of no concern for the FiniteElement and derived classes since they only act locally on one cell and its immediate neighbor, and do not see the bigger picture. The  [2.x.63]  details how such chains are handled in practice.
* 

*  [1.x.17]
*  Construction of a finite element and computation of the matrices described above is often a tedious task, in particular if it has to be performed for several dimensions. Most of this work can be avoided by using the intermediate classes already mentioned above (e.g., FE_Poly, FE_PolyTensor, etc). Other tasks can be automated by some of the functions in namespace FETools.
*  [1.x.18]
*  First, it may already be difficult to compute the basis of shape functions for arbitrary order and dimension. On the other hand, if the  [2.x.64]  "node values" are given, then the duality relation between node functionals and basis functions defines the basis. As a result, the shape function space may be defined from a set of linearly independent functions, such that the actual finite element basis is computed from linear combinations of them. The coefficients of these combinations are determined by the duality of node values and form a matrix.
*  Using this matrix allows the construction of the basis of shape functions in two steps.  [2.x.65] 
*   [2.x.66] Define the space of shape functions using an arbitrary basis [1.x.19] and compute the matrix [1.x.20] of node functionals [1.x.21] applied to these basis functions, such that its entries are [1.x.22].
*   [2.x.67] Compute the basis [1.x.23] of the finite element shape function space by applying [1.x.24] to the basis [1.x.25].  [2.x.68] 
*  The matrix [1.x.26] may be computed with  [2.x.69]  This function relies on the existence of #generalized_support_points and  [2.x.70]  (see the  [2.x.71]  "glossary entry on generalized support points" for more information). With this, one can then use the following piece of code in the constructor of a class derived from FiniteElement to compute the  [2.x.72]  matrix:

* 
* [1.x.27]
*  Don't forget to make sure that #unit_support_points or #generalized_support_points are initialized before this!
*  [1.x.28]
*  Once you have shape functions, you can define matrices that transfer data from one cell to its children or the other way around. This is a common operation in multigrid, of course, but is also used when interpolating the solution from one mesh to another after mesh refinement, as well as in the definition of some error estimators.
*  To define the prolongation matrices, i.e., those matrices that describe the transfer of a finite element field from one cell to its children, implementations of finite elements can either fill the #prolongation array by hand, or can call  [2.x.73] 
*  In the latter case, all that is required is the following piece of code:

* 
* [1.x.29]
*  As in this example, prolongation is almost always implemented via embedding, i.e., the nodal values of the function on the children may be different from the nodal values of the function on the parent cell, but as a function of  [2.x.74] , the finite element field on the child is the same as on the parent.
* 

*  [1.x.30]
*  The opposite operation, restricting a finite element function defined on the children to the parent cell is typically implemented by interpolating the finite element function on the children to the nodal values of the parent cell. In deal.II, the restriction operation is implemented as a loop over the children of a cell that each apply a matrix to the vector of unknowns on that child cell (these matrices are stored in #restriction and are accessed by get_restriction_matrix()). The operation that then needs to be implemented turns out to be surprisingly difficult to describe, but is instructive to describe because it also defines the meaning of the #restriction_is_additive_flags array (accessed via the restriction_is_additive() function).
*  To give a concrete example, assume we use a  [2.x.75]  element in 1d, and that on each of the parent and child cells degrees of freedom are (locally and globally) numbered as follows:

* 
* [1.x.31]
*  Then we want the restriction operation to take the value of the zeroth DoF on child 0 as the value of the zeroth DoF on the parent, and take the value of the first DoF on child 1 as the value of the first DoF on the parent. Ideally, we would like to write this follows [1.x.32] where  [2.x.76]  and  [2.x.77] . Writing the requested operation like this would here be possible by choosing [1.x.33] However, this approach already fails if we go to a  [2.x.78]  element with the following degrees of freedom:

* 
* [1.x.34]
*  Writing things as the sum over matrix operations as above would not easily work because we have to add nonzero values to  [2.x.79]  twice, once for each child.
*  Consequently, restriction is typically implemented as a [1.x.35] operation. I.e., we first compute the individual restrictions from each child, [1.x.36] and then compute the values of  [2.x.80]  with the following code:

* 
* [1.x.37]
*  In other words, each nonzero element of  [2.x.81]  [1.x.38], rather than adds to the corresponding element of  [2.x.82] . This typically also implies that the restriction matrices from two different cells should agree on a value for coarse degrees of freedom that they both want to touch (otherwise the result would depend on the order in which we loop over children, which would be unreasonable because the order of children is an otherwise arbitrary convention). For example, in the example above, the restriction matrices will be [1.x.39] and the compatibility condition is the  [2.x.83]  because they both indicate that  [2.x.84]  should be set to one times  [2.x.85]  and  [2.x.86] .
*  Unfortunately, not all finite elements allow to write the restriction operation in this way. For example, for the piecewise constant FE_DGQ(0) element, the value of the finite element field on the parent cell can not be determined by interpolation from the children. Rather, the only reasonable choice is to take it as the [1.x.40] value between the children
* 
*  -  so we are back to the sum operation, rather than the concatenation. Further thought shows that whether restriction should be additive or not is a property of the individual shape function, not of the finite element as a whole. Consequently, the  [2.x.87]  function returns whether a particular shape function should act via concatenation (a return value of  [2.x.88]  or via addition (return value of  [2.x.89]  and the correct code for the overall operation is then as follows (and as, in fact, implemented in  [2.x.90] 

* 
* [1.x.41]
* 
* 

*  [1.x.42]
*  Constraint matrices can be computed semi-automatically using  [2.x.91]  This function computes the representation of the coarse mesh functions by fine mesh functions for each child of a face separately. These matrices must be convoluted into a single rectangular constraint matrix, eliminating degrees of freedom on common vertices and edges as well as on the coarse grid vertices. See the discussion above for details of this numbering.
* 

* 
*  [2.x.92] 

* 
* [0.x.1]*
   The dimension of the image space, corresponding to Triangulation.  
* [0.x.2]*
   A base class for internal data that derived finite element classes may   wish to store.     The class is used as follows: Whenever an FEValues (or FEFaceValues or   FESubfaceValues) object is initialized, it requests that the finite   element it is associated with creates an object of a class derived from   the current one here. This is done via each derived class's    [2.x.93]  function. This object is then passed to the    [2.x.94]   [2.x.95]    and  [2.x.96]  functions as a constant   object. The intent of these objects is so that finite element classes can   pre-compute information once at the beginning (in the call to    [2.x.97]  call) that can then be used on each cell that   is subsequently visited. An example for this is the values of shape   functions at the quadrature point of the reference cell, which remain the   same no matter the cell visited, and that can therefore be computed once   at the beginning and reused later on.     Because only derived classes can know what they can pre-compute, each   derived class that wants to store information computed once at the   beginning, needs to derive its own InternalData class from this class,   and return an object of the derived type through its get_data() function.  
* [0.x.3]*
     Constructor. Sets update_flags to  [2.x.98]  and  [2.x.99]      to  [2.x.100]     
* [0.x.4]*
     Destructor. Made virtual to allow polymorphism.    
* [0.x.5]*
     Copy construction is forbidden.    
* [0.x.6]*
     A set of update flags specifying the kind of information that an     implementation of the FiniteElement interface needs to compute on each     cell or face, i.e., in  [2.x.101]  and friends.         This set of flags is stored here by implementations of      [2.x.102]   [2.x.103]  or      [2.x.104]  and is that subset of the update     flags passed to those functions that require re-computation on every     cell. (The subset of the flags corresponding to information that can be     computed once and for all already at the time of the call to      [2.x.105] 
* 
*  -  or an implementation of that interface
* 
*  -      need not be stored here because it has already been taken care of.)    
* [0.x.7]*
     Return an estimate (in bytes) for the memory consumption of this object.    
* [0.x.8]*
   Constructor: initialize the fields of this base class of all finite   elements.      [2.x.106]  fe_data An object that stores identifying (typically integral)   information about the element to be constructed. In particular, this   object will contain data such as the number of degrees of freedom per   cell (and per vertex, line, etc), the number of vector components, etc.   This argument is used to initialize the base class of the current object   under construction.    [2.x.107]  restriction_is_additive_flags A vector of size    [2.x.108]  (or of size one, see below) that for each   shape function states whether the shape function is additive or not. The   meaning of these flags is described in the section on restriction   matrices in the general documentation of this class.    [2.x.109]  nonzero_components A vector of size  [2.x.110]    (or of size one, see below) that for each shape function provides a   ComponentMask (of size  [2.x.111] ) that   indicates in which vector components this shape function is nonzero   (after mapping the shape function to the real cell). For "primitive"   shape functions, this component mask will have a single entry (see    [2.x.112]    for more information about primitive elements). On the other hand, for   elements such as the Raviart-Thomas or Nedelec elements, shape functions   are nonzero in more than one vector component (after mapping to the real   cell) and the given component mask will contain more than one entry. (For   these two elements, all entries will in fact be set, but this would not   be the case if you couple a FE_RaviartThomas and a FE_Nedelec together   into a FESystem.)      [2.x.113]   [2.x.114] ,   or  [2.x.115] . In the latter   case, the array is simply interpreted as having size    [2.x.116]  where each element has the same value as the   single element given.      [2.x.117]   [2.x.118] , or    [2.x.119] . In the latter case, the   array is simply interpreted as having size  [2.x.120]    where each element equals the component mask provided in the single   element given.  
* [0.x.9]*
   Move constructor.  
* [0.x.10]*
   Copy constructor.  
* [0.x.11]*
   Virtual destructor. Makes sure that pointers to this class are deleted   properly.  
* [0.x.12]*
   Creates information for creating a FESystem with this class as   base element and with multiplicity  [2.x.121]  In particular,   the return type of this function can be used in the constructor   for a FESystem object.   This function calls clone() and hence creates a copy of the   current object.  
* [0.x.13]*
   A sort of virtual copy constructor, this function returns a copy of   the finite element object. Derived classes need to override the function   here in this base class and return an object of the same type as the   derived class.     Some places in the library, for   example the constructors of FESystem as well as the  [2.x.122]    class, need to make copies of finite elements without knowing their exact   type. They do so through this function.  
* [0.x.14]*
   Return a string that uniquely identifies a finite element. The general   convention is that this is the class name, followed by the dimension in   angle brackets, and the polynomial degree and whatever else is necessary   in parentheses. For example, <tt>FE_Q<2>(3)</tt> is the value returned   for a cubic element in 2d.     Systems of elements have their own naming convention, see the FESystem   class.  
* [0.x.15]*
   This operator returns a reference to the present object if the argument   given equals to zero. While this does not seem particularly useful, it is   helpful in writing code that works with both ::DoFHandler and the hp-   version  [2.x.123]  since one can then write code like this:  
* [1.x.43]
*      This code doesn't work in both situations without the present operator   because  [2.x.124]  returns a finite element, whereas    [2.x.125]  returns a collection of finite elements that   doesn't offer a  [2.x.126]  member variable: one first has   to select which finite element to work on, which is done using the   operator[]. Fortunately,  [2.x.127]  also works   for non-hp-classes and simply returns zero in that case. The present   operator[] accepts this zero argument, by returning the finite element   with index zero within its collection (that, of course, consists only of   the present finite element anyway).      [2.x.128]  With  [2.x.129]  and the deprecation of the    [2.x.130]  class, there is no more use of this operator.  
* [0.x.16]*
    [2.x.131]  Shape function access    [2.x.132]   
* [0.x.17]*
   Return the value of the  [2.x.133]  shape function at the point  [2.x.134]   [2.x.135]  is   a point on the reference element. If the finite element is vector-valued,   then return the value of the only non-zero component of the vector value   of this shape function. If the shape function has more than one non-zero   component (which we refer to with the term non-primitive), then derived   classes implementing this function should throw an exception of type   ExcShapeFunctionNotPrimitive. In that case, use the   shape_value_component() function.     Implementations of this function should throw an exception of type   ExcUnitShapeValuesDoNotExist if the shape functions of the FiniteElement   under consideration depend on the shape of the cell in real space, i.e.,   if the shape functions are not defined by mapping from the reference   cell. Some non-conforming elements are defined this way, as is the   FE_DGPNonparametric class, to name just one example.     The default implementation of this virtual function does exactly this,   i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist.  
* [0.x.18]*
   Just like for shape_value(), but this function will be called when the   shape function has more than one non-zero vector component. In that case,   this function should return the value of the  [2.x.136]  vector   component of the  [2.x.137]  shape function at point  [2.x.138]   
* [0.x.19]*
   Return the gradient of the  [2.x.139]  shape function at the point  [2.x.140]   [2.x.141]    is a point on the reference element, and likewise the gradient is the   gradient on the unit cell with respect to unit cell coordinates. If the   finite element is vector-valued, then return the value of the only non-   zero component of the vector value of this shape function. If the shape   function has more than one non-zero component (which we refer to with the   term non-primitive), then derived classes implementing this function   should throw an exception of type ExcShapeFunctionNotPrimitive. In that   case, use the shape_grad_component() function.     Implementations of this function should throw an exception of type   ExcUnitShapeValuesDoNotExist if the shape functions of the FiniteElement   under consideration depend on the shape of the cell in real space, i.e.,   if the shape functions are not defined by mapping from the reference   cell. Some non-conforming elements are defined this way, as is the   FE_DGPNonparametric class, to name just one example.     The default implementation of this virtual function does exactly this,   i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist.  
* [0.x.20]*
   Just like for shape_grad(), but this function will be called when the   shape function has more than one non-zero vector component. In that case,   this function should return the gradient of the  [2.x.142]  vector   component of the  [2.x.143]  shape function at point  [2.x.144]   
* [0.x.21]*
   Return the tensor of second derivatives of the  [2.x.145]  shape function at   point  [2.x.146]  on the unit cell. The derivatives are derivatives on the unit   cell with respect to unit cell coordinates. If the finite element is   vector-valued, then return the value of the only non-zero component of   the vector value of this shape function. If the shape function has more   than one non-zero component (which we refer to with the term non-   primitive), then derived classes implementing this function should throw   an exception of type ExcShapeFunctionNotPrimitive. In that case, use the   shape_grad_grad_component() function.     Implementations of this function should throw an exception of type   ExcUnitShapeValuesDoNotExist if the shape functions of the FiniteElement   under consideration depend on the shape of the cell in real space, i.e.,   if the shape functions are not defined by mapping from the reference   cell. Some non-conforming elements are defined this way, as is the   FE_DGPNonparametric class, to name just one example.     The default implementation of this virtual function does exactly this,   i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist.  
* [0.x.22]*
   Just like for shape_grad_grad(), but this function will be called when   the shape function has more than one non-zero vector component. In that   case, this function should return the gradient of the  [2.x.147]    vector component of the  [2.x.148]  shape function at point  [2.x.149]   
* [0.x.23]*
   Return the tensor of third derivatives of the  [2.x.150]  shape function at   point  [2.x.151]  on the unit cell. The derivatives are derivatives on the unit   cell with respect to unit cell coordinates. If the finite element is   vector-valued, then return the value of the only non-zero component of   the vector value of this shape function. If the shape function has more   than one non-zero component (which we refer to with the term non-   primitive), then derived classes implementing this function should throw   an exception of type ExcShapeFunctionNotPrimitive. In that case, use the   shape_3rd_derivative_component() function.     Implementations of this function should throw an exception of type   ExcUnitShapeValuesDoNotExist if the shape functions of the FiniteElement   under consideration depend on the shape of the cell in real space, i.e.,   if the shape functions are not defined by mapping from the reference   cell. Some non-conforming elements are defined this way, as is the   FE_DGPNonparametric class, to name just one example.     The default implementation of this virtual function does exactly this,   i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist.  
* [0.x.24]*
   Just like for shape_3rd_derivative(), but this function will be called   when the shape function has more than one non-zero vector component. In   that case, this function should return the gradient of the  [2.x.152]    th vector component of the  [2.x.153]  shape function at point  [2.x.154]   
* [0.x.25]*
   Return the tensor of fourth derivatives of the  [2.x.155]  shape function at   point  [2.x.156]  on the unit cell. The derivatives are derivatives on the unit   cell with respect to unit cell coordinates. If the finite element is   vector-valued, then return the value of the only non-zero component of   the vector value of this shape function. If the shape function has more   than one non-zero component (which we refer to with the term non-   primitive), then derived classes implementing this function should throw   an exception of type ExcShapeFunctionNotPrimitive. In that case, use the   shape_4th_derivative_component() function.     Implementations of this function should throw an exception of type   ExcUnitShapeValuesDoNotExist if the shape functions of the FiniteElement   under consideration depend on the shape of the cell in real space, i.e.,   if the shape functions are not defined by mapping from the reference   cell. Some non-conforming elements are defined this way, as is the   FE_DGPNonparametric class, to name just one example.     The default implementation of this virtual function does exactly this,   i.e., it simply throws an exception of type ExcUnitShapeValuesDoNotExist.  
* [0.x.26]*
   Just like for shape_4th_derivative(), but this function will be called   when the shape function has more than one non-zero vector component. In   that case, this function should return the gradient of the  [2.x.157]    th vector component of the  [2.x.158]  shape function at point  [2.x.159]   
* [0.x.27]*
   This function returns  [2.x.160]  if the shape function  [2.x.161]  has   non-zero function values somewhere on the face  [2.x.162]  The   function is typically used to determine whether some matrix elements   resulting from face integrals can be assumed to be zero and may therefore   be omitted from integration.     A default implementation is provided in this base class which always   returns  [2.x.163]  This is the safe way to go.  
* [0.x.28]*
    [2.x.164]  Transfer and constraint matrices    [2.x.165]   
* [0.x.29]*
   Return the matrix that describes restricting a finite element field from   the given  [2.x.166]  (as obtained by the given  [2.x.167]  to the   parent cell. The interpretation of the returned matrix depends on what   restriction_is_additive() returns for each shape function.     Row and column indices are related to coarse grid and fine grid spaces,   respectively, consistent with the definition of the associated operator.     If projection matrices are not implemented in the derived finite element   class, this function aborts with an exception of type    [2.x.168]  You can check whether this would happen   by first calling the restriction_is_implemented() or the   isotropic_restriction_is_implemented() function.  
* [0.x.30]*
   Prolongation/embedding matrix between grids.     The identity operator from a coarse grid space into a fine grid space   (where both spaces are identified as functions defined on the parent and   child cells) is associated with a matrix  [2.x.169]  that maps the corresponding   representations of these functions in terms of their nodal values. The   restriction of this matrix  [2.x.170]  to a single child cell is returned   here.     The matrix  [2.x.171]  is the concatenation, not the sum of the cell matrices  [2.x.172]    P_i. That is, if the same non-zero entry <tt>j,k</tt> exists in two   different child matrices  [2.x.173]  the value should be the same in both   matrices and it is copied into the matrix  [2.x.174]  only once.     Row and column indices are related to fine grid and coarse grid spaces,   respectively, consistent with the definition of the associated operator.     These matrices are used by routines assembling the prolongation matrix   for multi-level methods.  Upon assembling the transfer matrix between   cells using this matrix array, zero elements in the prolongation matrix   are discarded and will not fill up the transfer matrix.     If prolongation matrices are not implemented in the derived finite   element class, this function aborts with an exception of type    [2.x.175]  You can check whether this would happen   by first calling the prolongation_is_implemented() or the   isotropic_prolongation_is_implemented() function.  
* [0.x.31]*
   Return whether this element implements its prolongation matrices. The   return value also indicates whether a call to the   get_prolongation_matrix() function will generate an error or not.     Note, that this function returns  [2.x.176]  only if the   prolongation matrices of the isotropic and all anisotropic refinement   cases are implemented. If you are interested in the prolongation matrices   for isotropic refinement only, use the   isotropic_prolongation_is_implemented function instead.     This function is mostly here in order to allow us to write more efficient   test programs which we run on all kinds of weird elements, and for which   we simply need to exclude certain tests in case something is not   implemented. It will in general probably not be a great help in   applications, since there is not much one can do if one needs these   features and they are not implemented. This function could be used to   check whether a call to <tt>get_prolongation_matrix()</tt> will succeed;   however, one then still needs to cope with the lack of information this   just expresses.  
* [0.x.32]*
   Return whether this element implements its prolongation matrices for   isotropic children. The return value also indicates whether a call to the    [2.x.177]  function will generate an error or not.     This function is mostly here in order to allow us to write more efficient   test programs which we run on all kinds of weird elements, and for which   we simply need to exclude certain tests in case something is not   implemented. It will in general probably not be a great help in   applications, since there is not much one can do if one needs these   features and they are not implemented. This function could be used to   check whether a call to <tt>get_prolongation_matrix()</tt> will succeed;   however, one then still needs to cope with the lack of information this   just expresses.  
* [0.x.33]*
   Return whether this element implements its restriction matrices. The   return value also indicates whether a call to the   get_restriction_matrix() function will generate an error or not.     Note, that this function returns  [2.x.178]  only if the   restriction matrices of the isotropic and all anisotropic refinement   cases are implemented. If you are interested in the restriction matrices   for isotropic refinement only, use the   isotropic_restriction_is_implemented() function instead.     This function is mostly here in order to allow us to write more efficient   test programs which we run on all kinds of weird elements, and for which   we simply need to exclude certain tests in case something is not   implemented. It will in general probably not be a great help in   applications, since there is not much one can do if one needs these   features and they are not implemented. This function could be used to   check whether a call to <tt>get_restriction_matrix()</tt> will succeed;   however, one then still needs to cope with the lack of information this   just expresses.  
* [0.x.34]*
   Return whether this element implements its restriction matrices for   isotropic children. The return value also indicates whether a call to the   get_restriction_matrix() function will generate an error or not.     This function is mostly here in order to allow us to write more efficient   test programs which we run on all kinds of weird elements, and for which   we simply need to exclude certain tests in case something is not   implemented. It will in general probably not be a great help in   applications, since there is not much one can do if one needs these   features and they are not implemented. This function could be used to   check whether a call to <tt>get_restriction_matrix()</tt> will succeed;   however, one then still needs to cope with the lack of information this   just expresses.  
* [0.x.35]*
   Access the #restriction_is_additive_flags field. See the discussion about   restriction matrices in the general class documentation for more   information.     The index must be between zero and the number of shape functions of this   element.  
* [0.x.36]*
   Return a read only reference to the matrix that describes the constraints   at the interface between a refined and an unrefined cell.     Some finite elements do not (yet) implement hanging node constraints. If   this is the case, then this function will generate an exception, since no   useful return value can be generated. If you should have a way to live   with this, then you might want to use the constraints_are_implemented()   function to check up front whether this function will succeed or generate   the exception.  
* [0.x.37]*
   Return whether this element implements its hanging node constraints. The   return value also indicates whether a call to the constraints() function   will generate an error or not.     This function is mostly here in order to allow us to write more efficient   test programs which we run on all kinds of weird elements, and for which   we simply need to exclude certain tests in case hanging node constraints   are not implemented. It will in general probably not be a great help in   applications, since there is not much one can do if one needs hanging   node constraints and they are not implemented. This function could be   used to check whether a call to <tt>constraints()</tt> will succeed;   however, one then still needs to cope with the lack of information this   just expresses.  
* [0.x.38]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".  That   means, the element properly implements the get_face_interpolation_matrix   and get_subface_interpolation_matrix methods. Therefore the return value   also indicates whether a call to the get_face_interpolation_matrix()   method and the get_subface_interpolation_matrix() method will generate an   error or not.     Currently the main purpose of this function is to allow the   make_hanging_node_constraints method to decide whether the new   procedures, which are supposed to work in the hp-framework can be used,   or if the old well verified but not hp-capable functions should be used.   Once the transition to the new scheme for computing the interface   constraints is complete, this function will be superfluous and will   probably go away.     Derived classes should implement this function accordingly. The default   assumption is that a finite element does not provide hp-capable face   interpolation, and the default implementation therefore returns  [2.x.179]   
* [0.x.39]*
   Return the matrix interpolating from the given finite element to the   present one. The size of the matrix is then #dofs_per_cell times   <tt>source.#dofs_per_cell</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type   ExcInterpolationNotImplemented.  
* [0.x.40]*
    [2.x.180]  Functions to support hp    [2.x.181]   
* [0.x.41]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.#dofs_per_face</tt> times <tt>this->#dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type   ExcInterpolationNotImplemented.  
* [0.x.42]*
   Return the matrix interpolating from a face of one element to the   subface of the neighboring element.  The size of the matrix is then   <tt>source.#dofs_per_face</tt> times <tt>this->#dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type   ExcInterpolationNotImplemented.  
* [0.x.43]*
    [2.x.182]  Functions to support hp-    [2.x.183]   
* [0.x.44]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.184]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.  
* [0.x.45]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.  
* [0.x.46]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on quads.  
* [0.x.47]*
   Return whether this element dominates another one given as argument    [2.x.185]  whether it is the other way around, whether neither dominates,   or if either could dominate. The  [2.x.186]  parameter describes the codimension   of the investigated subspace and specifies that it is subject to this   comparison. For example, if `codim==0` then this function compares which   element dominates at the cell level. If `codim==1`, then the elements are   compared at faces, i.e., the comparison happens between the function spaces   of the two finite elements as restricted to a face. Larger values of   `codim` work correspondingly.     For a definition of domination, see  [2.x.187]    and in particular the    [2.x.188]  "hp-paper".  
* [0.x.48]*
   Comparison operator.     The implementation in the current class checks for equality of the   following pieces of information between the current object and the one   given as argument, in this order:
* 

* 
* 

* 
* 

* 
* 
*  - the dynamic type (i.e., the type of the most derived class) of the     current object and of the given object,
* 

* 
* 

* 
* 

* 
* 
*  - the name returned by get_name(),
* 

* 
* 

* 
* 

* 
* 
*  - as all of the fields in FiniteElementData,
* 

* 
* 

* 
* 

* 
* 
*  - constraint matrices.     This covers most cases where elements can differ, but there are   cases of derived elements that are different and for which the   current function still returns  [2.x.189]  For these cases, derived   classes should overload this function.    
*  [2.x.190]  This operator specifically does not check the following     member variables of the current class:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - restriction matrices,
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - prolongation matrices of this object and the argument.    This is because these member variables may be initialized only    on demand by derived classes, rather than being available immediately.    Consequently, comparing these members would not only be costly because    these are generally big arrays, but also because their computation may    be expensive. On the other hand, derived classes for which these    arrays may differ for two objects even though the above list compares    as equal, will probably want to implement their own operator==()    anyway.  
* [0.x.49]*
   Non-equality comparison operator. Defined in terms of the equality   comparison operator.  
* [0.x.50]*
    [2.x.191]  Index computations    [2.x.192]   
* [0.x.51]*
   Compute vector component and index of this shape function within the   shape functions corresponding to this component from the index of a shape   function within this finite element.     If the element is scalar, then the component is always zero, and the   index within this component is equal to the overall index.     If the shape function referenced has more than one non-zero component,   then it cannot be associated with one vector component, and an exception   of type ExcShapeFunctionNotPrimitive will be raised.     Note that if the element is composed of other (base) elements, and a base   element has more than one component but all its shape functions are   primitive (i.e. are non-zero in only one component), then this mapping   contains valid information. However, the index of a shape function of   this element within one component (i.e. the second number of the   respective entry of this array) does not indicate the index of the   respective shape function within the base element (since that has more   than one vector-component). For this information, refer to the   #system_to_base_table field and the system_to_base_index() function.     See the class description above for an example of how this function is   typically used.     The use of this function is explained extensively in the  [2.x.193]  and    [2.x.194]  " [2.x.195] "   tutorial programs as well as in the    [2.x.196]    module.  
* [0.x.52]*
   Compute the shape function for the given vector component and index.     If the element is scalar, then the component must be zero, and the index   within this component is equal to the overall index.     This is the opposite operation from the system_to_component_index()   function.  
* [0.x.53]*
   Same as system_to_component_index(), but do it for shape functions and   their indices on a face. The range of allowed indices is therefore   0..#dofs_per_face.     You will rarely need this function in application programs, since almost   all application codes only need to deal with cell indices, not face   indices. The function is mainly there for use inside the library.  
* [0.x.54]*
   For faces with non-standard face_orientation in 3D, the dofs on faces   (quads) have to be permuted in order to be combined with the correct   shape functions. Given a local dof  [2.x.197]  on a quad, return the local   index, if the face has non-standard face_orientation, face_flip or   face_rotation. In 2D and 1D there is no need for permutation and   consequently an exception is thrown.  
* [0.x.55]*
   Given an index in the natural ordering of indices on a face, return the   index of the same degree of freedom on the cell.     To explain the concept, consider the case where we would like to know   whether a degree of freedom on a face, for example as part of an FESystem   element, is primitive. Unfortunately, the is_primitive() function in the   FiniteElement class takes a cell index, so we would need to find the cell   index of the shape function that corresponds to the present face index.   This function does that.     Code implementing this would then look like this:  
* [1.x.44]
*    The function takes additional arguments that account for the fact that   actual faces can be in their standard ordering with respect to the cell   under consideration, or can be flipped, oriented, etc.      [2.x.198]  face_dof_index The index of the degree of freedom on a face. This   index must be between zero and dofs_per_face.    [2.x.199]  face The number of the face this degree of freedom lives on. This   number must be between zero and  [2.x.200]     [2.x.201]  face_orientation One part of the description of the orientation of   the face. See    [2.x.202] .    [2.x.203]  face_flip One part of the description of the orientation of the   face. See    [2.x.204] .    [2.x.205]  face_rotation One part of the description of the orientation of   the face. See    [2.x.206] .    [2.x.207]  The index of this degree of freedom within the set of degrees of   freedom on the entire cell. The returned value will be between zero and   dofs_per_cell.    
*  [2.x.208]  This function exists in this class because that is where it was   first implemented. However, it can't really work in the most general case   without knowing what element we have. The reason is that when a face is   flipped or rotated, we also need to know whether we need to swap the   degrees of freedom on this face, or whether they are immune from this.   For this, consider the situation of a  [2.x.209]  element in 2d. If face_flip   is true, then we need to consider the two degrees of freedom on the edge   in reverse order. On the other hand, if the element were a  [2.x.210] , then   because the two degrees of freedom on this edge belong to different   vector components, they should not be considered in reverse order. What   all of this shows is that the function can't work if there are more than   one degree of freedom per line or quad, and that in these cases the   function will throw an exception pointing out that this functionality   will need to be provided by a derived class that knows what degrees of   freedom actually represent.  
* [0.x.56]*
   For lines with non-standard line_orientation in 3D, the dofs on lines   have to be permuted in order to be combined with the correct shape   functions. Given a local dof  [2.x.211]  on a line, return the local index,   if the line has non-standard line_orientation. In 2D and 1D there is no   need for permutation, so the given index is simply returned.  
* [0.x.57]*
   Return in which of the vector components of this finite element the  [2.x.212]    ith shape function is non-zero. The length of the returned array is equal   to the number of vector components of this element.     For most finite element spaces, the result of this function will be a   vector with exactly one element being  [2.x.213]  since for most spaces the   individual vector components are independent. In that case, the component   with the single zero is also the first element of what   system_to_component_index() returns.     Only for those spaces that couple the components, for example to make a   shape function divergence free, will there be more than one  [2.x.214]    entry.  Elements for which this is true are called non-primitive (see    [2.x.215] ).  
* [0.x.58]*
   Return in how many vector components the  [2.x.216]  shape function is non-   zero. This value equals the number of entries equal to  [2.x.217]  in the   result of the get_nonzero_components() function.     For most finite element spaces, the result will be equal to one. It is   not equal to one only for those ansatz spaces for which vector-valued   shape functions couple the individual components, for example in order to   make them divergence-free.  
* [0.x.59]*
   Return whether the entire finite element is primitive, in the sense that   all its shape functions are primitive. If the finite element is scalar,   then this is always the case.     Since this is an extremely common operation, the result is cached and   returned by this function.  
* [0.x.60]*
   Return whether the  [2.x.218]  shape function is primitive in the sense that   the shape function is non-zero in only one vector component. Non-   primitive shape functions would then, for example, be those of divergence   free ansatz spaces, in which the individual vector components are   coupled.     The result of the function is  [2.x.219]  if and only if the result of   <tt>n_nonzero_components(i)</tt> is equal to one.  
* [0.x.61]*
   Number of base elements in a mixed discretization.     Note that even for vector valued finite elements, the number of   components needs not coincide with the number of base elements, since   they may be reused. For example, if you create a FESystem with three   identical finite element classes by using the constructor that takes one   finite element and a multiplicity, then the number of base elements is   still one, although the number of components of the finite element is   equal to the multiplicity.  
* [0.x.62]*
   Access to base element objects. If the element is atomic, then    [2.x.220]  is  [2.x.221]   
* [0.x.63]*
   This index denotes how often the base element  [2.x.222]  is used in a   composed element. If the element is atomic, then the result is always   equal to one. See the documentation for the n_base_elements() function   for more details.  
* [0.x.64]*
   Return a reference to a contained finite element that matches the   components   selected by the given ComponentMask  [2.x.223]      For an arbitrarily nested FESystem, this function returns the inner-most   FiniteElement that matches the given mask. The method fails if the  [2.x.224]    does not exactly match one of the contained finite elements. It is most   useful if the current object is an FESystem, as the return value can   only be  [2.x.225]  in all other cases.     Note that the returned object can be an FESystem if the   mask matches it but not any of the contained objects.     Let us illustrate the function with the an FESystem  [2.x.226]  with 7 components:  
* [1.x.45]
*      The following table lists all possible component masks you can use:    [2.x.227]   
* [0.x.65]*
   Return a reference to a contained finite element that matches the   components    [2.x.228]  components starting at component with index    [2.x.229]      See the other get_sub_fe() function above for more details.  
* [0.x.66]*
   Return for shape function  [2.x.230]  the base element it belongs to, the   number of the copy of this base element (which is between zero and the   multiplicity of this element), and the index of this shape function   within this base element.     If the element is not composed of others, then base and instance are   always zero, and the index is equal to the number of the shape function.   If the element is composed of single instances of other elements (i.e.   all with multiplicity one) all of which are scalar, then base values and   dof indices within this element are equal to the   #system_to_component_table. It differs only in case the element is   composed of other elements and at least one of them is vector-valued   itself.     See the class documentation above for an example of how this function is   typically used.     This function returns valid values also in the case of vector-valued   (i.e. non-primitive) shape functions, in contrast to the   system_to_component_index() function.  
* [0.x.67]*
   Same as system_to_base_index(), but for degrees of freedom located on a   face. The range of allowed indices is therefore 0..#dofs_per_face.     You will rarely need this function in application programs, since almost   all application codes only need to deal with cell indices, not face   indices. The function is mainly there for use inside the library.  
* [0.x.68]*
   Given a base element number, return the first block of a BlockVector it   would generate.  
* [0.x.69]*
   For each vector component, return which base element implements this   component and which vector component in this base element this is. This   information is only of interest for vector-valued finite elements which   are composed of several sub-elements. In that case, one may want to   obtain information about the element implementing a certain vector   component, which can be done using this function and the    [2.x.231]  function.     If this is a scalar finite element, then the return value is always equal   to a pair of zeros.  
* [0.x.70]*
   Return the base element for this block and the number of the copy of the   base element.  
* [0.x.71]*
   The vector block and the index inside the block for this shape function.  
* [0.x.72]*
   The vector block for this component.  
* [0.x.73]*
    [2.x.232]  Component and block matrices    [2.x.233]   
* [0.x.74]*
   Return a component mask with as many elements as this object has vector   components and of which exactly the one component is true that   corresponds to the given argument. See    [2.x.234]  "the glossary"   for more information.      [2.x.235]  scalar An object that represents a single scalar vector component   of this finite element.    [2.x.236]  A component mask that is false in all components except for the   one that corresponds to the argument.  
* [0.x.75]*
   Return a component mask with as many elements as this object has vector   components and of which exactly the  [2.x.237]  components are true   that correspond to the given argument. See    [2.x.238]  "the glossary"   for more information.      [2.x.239]  vector An object that represents dim vector components of this   finite element.    [2.x.240]  A component mask that is false in all components except for the   ones that corresponds to the argument.  
* [0.x.76]*
   Return a component mask with as many elements as this object has vector   components and of which exactly the  [2.x.241]  components   are true that correspond to the given argument. See    [2.x.242]  "the glossary"   for more information.      [2.x.243]  sym_tensor An object that represents dim*(dim+1)/2 components of   this finite element that are jointly to be interpreted as forming a   symmetric tensor.    [2.x.244]  A component mask that is false in all components except for the   ones that corresponds to the argument.  
* [0.x.77]*
   Given a block mask (see    [2.x.245]  "this glossary entry"),   produce a component mask (see    [2.x.246]  "this glossary entry")   that represents the components that correspond to the blocks selected in   the input argument. This is essentially a conversion operator from   BlockMask to ComponentMask.      [2.x.247]  block_mask The mask that selects individual blocks of the finite   element    [2.x.248]  A mask that selects those components corresponding to the   selected blocks of the input argument.  
* [0.x.78]*
   Return a block mask with as many elements as this object has blocks and   of which exactly the one component is true that corresponds to the given   argument. See    [2.x.249]  "the glossary"   for more information.    
*  [2.x.250]  This function will only succeed if the scalar referenced by the   argument encompasses a complete block. In other words, if, for example,   you pass an extractor for the single  [2.x.251]  velocity and this object   represents an FE_RaviartThomas object, then the single scalar object you   selected is part of a larger block and consequently there is no block   mask that would represent it. The function will then produce an   exception.      [2.x.252]  scalar An object that represents a single scalar vector component   of this finite element.    [2.x.253]  A component mask that is false in all components except for the   one that corresponds to the argument.  
* [0.x.79]*
   Return a component mask with as many elements as this object has vector   components and of which exactly the  [2.x.254]  components are true   that correspond to the given argument. See    [2.x.255]  "the glossary"   for more information.    
*  [2.x.256]  The same caveat applies as to the version of the function above:   The extractor object passed as argument must be so that it corresponds to   full blocks and does not split blocks of this element.      [2.x.257]  vector An object that represents dim vector components of this   finite element.    [2.x.258]  A component mask that is false in all components except for the   ones that corresponds to the argument.  
* [0.x.80]*
   Return a component mask with as many elements as this object has vector   components and of which exactly the  [2.x.259]  components   are true that correspond to the given argument. See    [2.x.260]  "the glossary"   for more information.    
*  [2.x.261]  The same caveat applies as to the version of the function above:   The extractor object passed as argument must be so that it corresponds to   full blocks and does not split blocks of this element.      [2.x.262]  sym_tensor An object that represents dim*(dim+1)/2 components of   this finite element that are jointly to be interpreted as forming a   symmetric tensor.    [2.x.263]  A component mask that is false in all components except for the   ones that corresponds to the argument.  
* [0.x.81]*
   Given a component mask (see    [2.x.264]  "this glossary entry"),   produce a block mask (see    [2.x.265]  "this glossary entry")   that represents the blocks that correspond to the components selected in   the input argument. This is essentially a conversion operator from   ComponentMask to BlockMask.    
*  [2.x.266]  This function will only succeed if the components referenced by the   argument encompasses complete blocks. In other words, if, for example,   you pass an component mask for the single  [2.x.267]  velocity and this object   represents an FE_RaviartThomas object, then the single component you   selected is part of a larger block and consequently there is no block   mask that would represent it. The function will then produce an   exception.      [2.x.268]  component_mask The mask that selects individual components of the   finite element    [2.x.269]  A mask that selects those blocks corresponding to the selected   blocks of the input argument.  
* [0.x.82]*
   Return a list of constant modes of the element. The number of rows in   the resulting table depends on the elements in use. For standard   elements, the table has as many rows as there are components in the   element and dofs_per_cell columns. To each component of the finite   element, the row in the returned table contains a basis representation of   the constant function 1 on the element. However, there are some scalar   elements where there is more than one constant mode, e.g. the element   FE_Q_DG0.     In order to match the constant modes to the actual components in the   element, the returned data structure also returns a vector with as many   components as there are constant modes on the element that contains the   component number.  
* [0.x.83]*
    [2.x.270]  Support points and interpolation    [2.x.271]   
* [0.x.84]*
   Return the support points of the trial functions on the unit cell, if the   derived finite element defines them.  Finite elements that allow some   kind of interpolation operation usually have support points. On the other   hand, elements that define their degrees of freedom by, for example,   moments on faces, or as derivatives, don't have support points. In that   case, the returned field is empty.     If the finite element defines support points, then their number equals   the number of degrees of freedom of the element.  The order of points in   the array matches that returned by the <tt>cell->get_dof_indices</tt>   function.     See the class documentation for details on support points.    
*  [2.x.272]  Finite elements' implementation of this function returns these   points in the same order as shape functions. The order of shape functions   is typically documented in the class documentation of the various finite   element classes. In particular, shape functions (and consequently the   mapped quadrature points discussed in the class documentation of this   class) will then traverse first those shape functions located on   vertices, then on lines, then on quads, etc.    
*  [2.x.273]  If this element implements support points, then it will return one   such point per shape function. Since multiple shape functions may be   defined at the same location, the support points returned here may be   duplicated. An example would be an element of the kind    [2.x.274]  for which each support point would   appear three times in the returned array.  
* [0.x.85]*
   Return whether a finite element has defined support points. If the result   is true, then a call to the get_unit_support_points() yields a non-empty   array.     The result may be false if an element is not defined by interpolating   shape functions, for example by P-elements on quadrilaterals. It will   usually only be true if the element constructs its shape functions by the   requirement that they be one at a certain point and zero at all the   points associated with the other shape functions.     In composed elements (i.e. for the FESystem class), the result will be   true if all the base elements have defined support points. FE_Nothing   is a special case in FESystems, because it has 0 support points and   has_support_points() is false, but an FESystem containing an FE_Nothing   among other elements will return true.  
* [0.x.86]*
   Return the position of the support point of the  [2.x.275]  shape   function. If it does not exist, raise an exception.     The default implementation simply returns the respective element from the   array you get from get_unit_support_points(), but derived elements may   overload this function. In particular, note that the FESystem class   overloads it so that it can return the support points of individual base   elements, if not all the base elements define support points. In this   way, you can still ask for certain support points, even if   get_unit_support_points() only returns an empty array.  
* [0.x.87]*
   Return the support points of the trial functions on the unit face, if the   derived finite element defines some.  Finite elements that allow some   kind of interpolation operation usually have support points. On the other   hand, elements that define their degrees of freedom by, for example,   moments on faces, or as derivatives, don't have support points. In that   case, the returned field is empty     Note that elements that have support points need not necessarily have   some on the faces, even if the interpolation points are located   physically on a face. For example, the discontinuous elements have   interpolation points on the vertices, and for higher degree elements also   on the faces, but they are not defined to be on faces since in that case   degrees of freedom from both sides of a face (or from all adjacent   elements to a vertex) would be identified with each other, which is not   what we would like to have). Logically, these degrees of freedom are   therefore defined to belong to the cell, rather than the face or vertex.   In that case, the returned element would therefore have length zero.     If the finite element defines support points, then their number equals   the number of degrees of freedom on the face (#dofs_per_face). The order   of points in the array matches that returned by the   <tt>cell->face(face)->get_dof_indices</tt> function.     See the class documentation for details on support points.  
* [0.x.88]*
   Return whether a finite element has defined support points on faces. If   the result is true, then a call to the get_unit_face_support_points()   yields a non-empty vector.     For more information, see the documentation for the has_support_points()   function.  
* [0.x.89]*
   The function corresponding to the unit_support_point() function, but for   faces. See there for more information.  
* [0.x.90]*
   Return a vector of generalized support points.    
*  [2.x.276]  The vector returned by this function is always a minimal set of  unique* support points. This is in contrast to the behavior of   get_unit_support_points() that returns a repeated list of unit support   points for an FESystem of numerous (Lagrangian) base elements.     See the    [2.x.277]  "glossary entry on generalized support points"   for more information.  
* [0.x.91]*
   Return whether a finite element has defined generalized support   points. If the result is true, then a call to the   get_generalized_support_points() yields a non-empty vector.     See the    [2.x.278]  "glossary entry on generalized support points"   for more information.  
* [0.x.92]*
   For a given degree of freedom, return whether it is logically associated   with a vertex, line, quad or hex.     For instance, for continuous finite elements this coincides with the   lowest dimensional object the support point of the degree of freedom lies   on. To give an example, for  [2.x.279]  elements in 3d, every degree of freedom   is defined by a shape function that we get by interpolating using support   points that lie on the vertices of the cell. The support of these points   of course extends to all edges connected to this vertex, as well as the   adjacent faces and the cell interior, but we say that logically the   degree of freedom is associated with the vertex as this is the lowest-   dimensional object it is associated with. Likewise, for  [2.x.280]  elements in   3d, the degrees of freedom with support points at edge midpoints would   yield a value of  [2.x.281]  from this function, whereas   those on the centers of faces in 3d would return  [2.x.282]      To make this more formal, the kind of object returned by this function   represents the object so that the support of the shape function   corresponding to the degree of freedom, (i.e., that part of the domain   where the function "lives") is the union of all of the cells sharing this   object. To return to the example above, for  [2.x.283]  in 3d, the shape   function with support point at an edge midpoint has support on all cells   that share the edge and not only the cells that share the adjacent faces,   and consequently the function will return  [2.x.284]      On the other hand, for discontinuous elements of type  [2.x.285] , a degree   of freedom associated with an interpolation polynomial that has its   support point physically located at a line bounding a cell, but is   nonzero only on one cell. Consequently, it is logically associated with   the interior of that cell (i.e., with a  [2.x.286]  in 2d and   a  [2.x.287]  in 3d).      [2.x.288]  cell_dof_index The index of a shape function or degree of   freedom. This index must be in the range  [2.x.289] .    
*  [2.x.290]  The integer value of the object returned by this function equals   the dimensionality of the object it describes, and can consequently be   used in generic programming paradigms. For example, if a degree of   freedom is associated with a vertex, then this function returns    [2.x.291]  which has a numeric value of zero (the   dimensionality of a vertex).  
* [0.x.93]*
   Given the values of a function  [2.x.292]  at the (generalized)   support points of the reference cell, this function then computes what   the nodal values of the element are, i.e.,  [2.x.293] , where  [2.x.294]    are the node functionals of the element   (see also    [2.x.295]  "Node values or node functionals").   The values  [2.x.296]  are then the expansion coefficients   for the shape functions of the finite element function that   [1.x.46] the given function  [2.x.297] , i.e.,    [2.x.298]  is the finite element interpolant of  [2.x.299]  with the current element.   The operation described here is used, for example, in the    [2.x.300]  function.     In more detail, let us assume that the generalized support points   (see    [2.x.301]  "this glossary entry"   ) of the current   element are  [2.x.302]  and that the node functionals associated   with the current element are  [2.x.303] . Then, the fact that the   element is based on generalized support points, implies that if we   apply  [2.x.304]  to a (possibly vector-valued) finite element function    [2.x.305] , the result must have the form    [2.x.306] 
* 
*  -  in other words,   the value of the node functional  [2.x.307]  applied to  [2.x.308]  [1.x.47]   depends on the [1.x.48] and not   on values anywhere else, or integrals of  [2.x.309] , or any other kind   of information.     The exact form of  [2.x.310]  depends on the element. For example, for scalar    [2.x.311]  "Lagrange elements",   we have that in fact    [2.x.312] . If you combine multiple   scalar Lagrange elements via an FESystem object, then    [2.x.313]  where  [2.x.314]    is the result of the  [2.x.315]    function's return value's first component. In these two cases,    [2.x.316]  is therefore simply the identity (in the scalar case) or a   function that selects a particular vector component of its argument.   On the other hand, for Raviart-Thomas elements, one would have that    [2.x.317]  where  [2.x.318]    is the normal vector of the face at which the shape function is   defined.     Given all of this, what this function does is the following: If you   input a list of values of a function  [2.x.319]  at all generalized   support points (where each value is in fact a vector of values with   as many components as the element has), then this function returns   a vector of values obtained by applying the node functionals to   these values. In other words, if you pass in    [2.x.320]  then you   will get out a vector    [2.x.321]  where  [2.x.322]  equals  [2.x.323]       [2.x.324]  support_point_values An array of size  [2.x.325]      (which equals the number of points the get_generalized_support_points()     function will return) where each element is a vector with as many entries     as the element has vector components. This array should contain     the values of a function at the generalized support points of the     current element.    [2.x.326]  nodal_values An array of size  [2.x.327]  that contains     the node functionals of the element applied to the given function.    
*  [2.x.328]  It is safe to call this function for (transformed) values on the   real cell only for elements with trivial MappingKind. For all other   elements (for example for H(curl), or H(div) conforming elements)   vector values have to be transformed to the reference cell first.    
*  [2.x.329]  Given what the function is supposed to do, the function clearly   can only work for elements that actually implement (generalized) support   points. Elements that do not have generalized support points
* 
*  -  e.g.,   elements whose nodal functionals evaluate integrals or moments of   functions (such as FE_Q_Hierarchical)
* 
*  -  can in general not make   sense of the operation that is required for this function. They   consequently may not implement it.  
* [0.x.94]*
   Determine an estimate for the memory consumption (in bytes) of this   object.     This function is made virtual, since finite element objects are usually   accessed through pointers to their base class, rather than the class   itself.  
* [0.x.95]*
   Exception    
*  [2.x.330]   
* [0.x.96]*
   Exception    
*  [2.x.331]   
* [0.x.97]*
   Exception    
*  [2.x.332]   
* [0.x.98]*
   Attempt to access support points of a finite element that is not   Lagrangian.    
*  [2.x.333]   
* [0.x.99]*
   Attempt to access embedding matrices of a finite element that did not   implement these matrices.    
*  [2.x.334]   
* [0.x.100]*
   Attempt to access restriction matrices of a finite element that did not   implement these matrices.     Exception  
*  [2.x.335]   
* [0.x.101]*
   Exception  
*  [2.x.336]   
* [0.x.102]*
   Exception  
*  [2.x.337]   
* [0.x.103]*
   Reinit the vectors of restriction and prolongation matrices to the right   sizes: For every refinement case, except for    [2.x.338]  and for every child of that refinement   case the space of one restriction and prolongation matrix is allocated,   see the documentation of the restriction and prolongation vectors for   more detail on the actual vector sizes.      [2.x.339]  isotropic_restriction_only only the restriction matrices required   for isotropic refinement are reinited to the right size.    [2.x.340]  isotropic_prolongation_only only the prolongation matrices   required for isotropic refinement are reinited to the right size.  
* [0.x.104]*
   Vector of projection matrices. See get_restriction_matrix() above. The   constructor initializes these matrices to zero dimensions, which can be   changed by derived classes implementing them.     Note, that  [2.x.341]  includes   the restriction matrix of child  [2.x.342]  for the RefinementCase    [2.x.343]    instead of  [2.x.344]  as for    [2.x.345]  there are no restriction matrices   available.  
* [0.x.105]*
   Vector of embedding matrices. See <tt>get_prolongation_matrix()</tt>   above. The constructor initializes these matrices to zero dimensions,   which can be changed by derived classes implementing them.     Note, that  [2.x.346]  includes   the prolongation matrix of child  [2.x.347]  for the   RefinementCase  [2.x.348] . Here, we use    [2.x.349]  as   for  [2.x.350]  there are no prolongation matrices   available.  
* [0.x.106]*
   Specify the constraints which the dofs on the two sides of a cell   interface underlie if the line connects two cells of which one is refined   once.     For further details see the general description of the derived class.     This field is obviously useless in one dimension and has there a zero   size.  
* [0.x.107]*
   List of support points on the unit cell, in case the finite element has   any. The constructor leaves this field empty, derived classes may write   in some contents.     Finite elements that allow some kind of interpolation operation usually   have support points. On the other hand, elements that define their   degrees of freedom by, for example, moments on faces, or as derivatives,   don't have support points. In that case, this field remains empty.  
* [0.x.108]*
   Same for the faces. See the description of the   get_unit_face_support_points() function for a discussion of what   contributes a face support point.  
* [0.x.109]*
   Support points used for interpolation functions of non-Lagrangian   elements.  
* [0.x.110]*
   Face support points used for interpolation functions of non-Lagrangian   elements.  
* [0.x.111]*
   For faces with non-standard face_orientation in 3D, the dofs on faces   (quads) have to be permuted in order to be combined with the correct   shape functions. Given a local dof  [2.x.351]  on a quad, return the shift   in the local index, if the face has non-standard face_orientation, i.e.    [2.x.352] . In 2D and 1D there is no need   for permutation so the vector is empty. In 3D it has the size of  [2.x.353] , where 8 is the number of orientations, a face   can be in (all combinations of the three bool flags face_orientation,   face_flip and face_rotation).     The constructor of this class fills this table with zeros, i.e.,   no permutation at all. Derived finite element classes have to   fill this Table with the correct values.  
* [0.x.112]*
   For lines with non-standard line_orientation in 3D, the dofs on lines   have to be permuted in order to be combined with the correct shape   functions. Given a local dof  [2.x.354]  on a line, return the shift in the   local index, if the line has non-standard line_orientation, i.e.    [2.x.355] . In 2D and 1D there is no need   for permutation so the vector is empty. In 3D it has the size of   #dofs_per_line.     The constructor of this class fills this table with zeros, i.e.,   no permutation at all. Derived finite element classes have to   fill this vector with the correct values.  
* [0.x.113]*
   Store what system_to_component_index() will return.  
* [0.x.114]*
   Map between linear dofs and component dofs on face. This is filled with   default values in the constructor, but derived classes will have to   overwrite the information if necessary.     By component, we mean the vector component, not the base element. The   information thus makes only sense if a shape function is non-zero in only   one component.  
* [0.x.115]*
   For each shape function, store to which base element and which instance   of this base element (in case its multiplicity is greater than one) it   belongs, and its index within this base element. If the element is not   composed of others, then base and instance are always zero, and the index   is equal to the number of the shape function. If the element is composed   of single instances of other elements (i.e. all with multiplicity one)   all of which are scalar, then base values and dof indices within this   element are equal to the #system_to_component_table. It differs only in   case the element is composed of other elements and at least one of them   is vector-valued itself.     This array has valid values also in the case of vector-valued (i.e. non-   primitive) shape functions, in contrast to the   #system_to_component_table.  
* [0.x.116]*
   Likewise for the indices on faces.  
* [0.x.117]*
   For each base element, store the number of blocks generated by the base   and the first block in a block vector it will generate.  
* [0.x.118]*
   The base element establishing a component.     For each component number <tt>c</tt>, the entries have the following   meaning:  [2.x.356]  <dt><tt>table[c].first.first</tt></dt>  [2.x.357] Number of the   base element for <tt>c</tt>. This is the index you can pass to   base_element(). [2.x.358]  <dt><tt>table[c].first.second</tt></dt>    [2.x.359] Component within the base element for <tt>c</tt>. This value is   between 0 and the n_components() of this base element. [2.x.360]    <dt><tt>table[c].second</tt></dt>  [2.x.361] Index of the multiple of the base   element that contains <tt>c</tt>. This value is between 0 and the   element_multiplicity() of this base element. [2.x.362]   [2.x.363]      This variable is set to the correct size by the constructor of this   class, but needs to be initialized by derived classes, unless its size is   one and the only entry is a zero, which is the case for scalar elements.   In that case, the initialization by the base class is sufficient.    
*  [2.x.364]  This table is filled by  [2.x.365]   
* [0.x.119]*
   A flag determining whether restriction matrices are to be concatenated or   summed up. See the discussion about restriction matrices in the general   class documentation for more information.  
* [0.x.120]*
   For each shape function, give a vector of bools (with size equal to the   number of vector components which this finite element has) indicating in   which component each of these shape functions is non-zero.     For primitive elements, there is only one non-zero component.  
* [0.x.121]*
   This array holds how many values in the respective entry of the   #nonzero_components element are non-zero. The array is thus a short-cut   to allow faster access to this information than if we had to count the   non-zero entries upon each request for this information. The field is   initialized in the constructor of this class.  
* [0.x.122]*
   Store whether all shape functions are primitive. Since finding this out   is a very common operation, we cache the result, i.e. compute the value   in the constructor for simpler access.  
* [0.x.123]*
   Return the size of interface constraint matrices. Since this is needed in   every derived finite element class when initializing their size, it is   placed into this function, to avoid having to recompute the dimension-   dependent size of these matrices each time.     Note that some elements do not implement the interface constraints for   certain polynomial degrees. In this case, this function still returns the   size these matrices should have when implemented, but the actual matrices   are empty.  
* [0.x.124]*
   Given the pattern of nonzero components for each shape function, compute   for each entry how many components are non-zero for each shape function.   This function is used in the constructor of this class.  
* [0.x.125]*
   Given a set of update flags, compute which other quantities [1.x.49]   need to be computed in order to satisfy the request by the given flags.   Then return the combination of the original set of flags and those just   computed.     As an example, if  [2.x.366]  contains update_gradients a finite   element class will typically require the computation of the inverse of   the Jacobian matrix in order to rotate the gradient of shape functions on   the reference cell to the real cell. It would then return not just   update_gradients, but also update_covariant_transformation, the flag that   makes the mapping class produce the inverse of the Jacobian matrix.     An extensive discussion of the interaction between this function and   FEValues can be found in the    [2.x.367]    documentation module.      [2.x.368]  UpdateFlags  
* [0.x.126]*
   Create an internal data object and return a pointer to it of which the   caller of this function then assumes ownership. This object will then be   passed to the  [2.x.369]  every time the finite   element shape functions and their derivatives are evaluated on a concrete   cell. The object created here is therefore used by derived classes as a   place for scratch objects that are used in evaluating shape functions, as   well as to store information that can be pre-computed once and re-used on   every cell (e.g., for evaluating the values and gradients of shape   functions on the reference cell, for later re-use when transforming these   values to a concrete cell).     This function is the first one called in the process of initializing a   FEValues object for a given mapping and finite element object. The   returned object will later be passed to  [2.x.370]    for a concrete cell, which will itself place its output into an object of   type  [2.x.371]  Since   there may be data that can already be computed in its [1.x.50] form on   the reference cell, this function also receives a reference to the    [2.x.372]  object as its   last argument. This output argument is guaranteed to always be the same one   when used with the InternalDataBase object returned by this function. In   other words, the subdivision of scratch data and final data in the returned   object and the  [2.x.373]  object is as follows: If data can be pre-   computed on the reference cell in the exact form in which it will later   be needed on a concrete cell, then this function should already emplace   it in the  [2.x.374]  object. An example are the values of shape   functions at quadrature points for the usual Lagrange elements which on a   concrete cell are identical to the ones on the reference cell. On the   other hand, if some data can be pre-computed to make computations on a   concrete cell [1.x.51], then it should be put into the returned   object for later re-use in a derive class's implementation of    [2.x.375]  An example are the gradients of shape   functions on the reference cell for Lagrange elements: to compute the   gradients of the shape functions on a concrete cell, one has to multiply   the gradients on the reference cell by the inverse of the Jacobian of the   mapping; consequently, we cannot already compute the gradients on a   concrete cell at the time the current function is called, but we can at   least pre-compute the gradients on the reference cell, and store it in   the object returned.     An extensive discussion of the interaction between this function and   FEValues can be found in the    [2.x.376]    documentation module. See also the documentation of the InternalDataBase   class.      [2.x.377]  update_flags A set of UpdateFlags values that describe what   kind of information the FEValues object requests the finite element to   compute. This set of flags may also include information that the finite   element can not compute, e.g., flags that pertain to data produced by the   mapping. An implementation of this function needs to set up all data   fields in the returned object that are necessary to produce the finite-   element related data specified by these flags, and may already pre-   compute part of this information as discussed above. Elements may want to   store these update flags (or a subset of these flags) in    [2.x.378]  so they know at the time when    [2.x.379]  is called what they are supposed to   compute    [2.x.380]  mapping A reference to the mapping used for computing values   and derivatives of shape functions.    [2.x.381]  quadrature A reference to the object that describes where the   shape functions should be evaluated.    [2.x.382]  output_data A reference to the object that FEValues will use   in conjunction with the object returned here and where an implementation   of  [2.x.383]  will place the requested information.   This allows the current function to already pre-compute pieces of   information that can be computed on the reference cell, as discussed   above. FEValues guarantees that this output object and the object   returned by the current function will always be used together.    [2.x.384]  A pointer to an object of a type derived from InternalDataBase   and that derived classes can use to store scratch data that can be pre-   computed, or for scratch arrays that then only need to be allocated once.   The calling site assumes ownership of this object and will delete it when   it is no longer necessary.  
* [0.x.127]*
   Like get_data(), but return an object that will later be used for   evaluating shape function information at quadrature points on faces of   cells. The object will then be used in calls to implementations of    [2.x.385]  See the documentation of get_data()   for more information.     The default implementation of this function converts the face quadrature   into a cell quadrature with appropriate quadrature point locations, and   with that calls the get_data() function above that has to be implemented   in derived classes.      [2.x.386]  update_flags A set of UpdateFlags values that describe what   kind of information the FEValues object requests the finite element to   compute. This set of flags may also include information that the finite   element can not compute, e.g., flags that pertain to data produced by the   mapping. An implementation of this function needs to set up all data   fields in the returned object that are necessary to produce the finite-   element related data specified by these flags, and may already pre-   compute part of this information as discussed above. Elements may want to   store these update flags (or a subset of these flags) in    [2.x.387]  so they know at the time when    [2.x.388]  is called what they are supposed to   compute    [2.x.389]  mapping A reference to the mapping used for computing values   and derivatives of shape functions.    [2.x.390]  quadrature A reference to the object that describes where the   shape functions should be evaluated.    [2.x.391]  output_data A reference to the object that FEValues will use   in conjunction with the object returned here and where an implementation   of  [2.x.392]  will place the requested   information. This allows the current function to already pre-compute   pieces of information that can be computed on the reference cell, as   discussed above. FEValues guarantees that this output object and the   object returned by the current function will always be used together.    [2.x.393]  A pointer to an object of a type derived from InternalDataBase   and that derived classes can use to store scratch data that can be pre-   computed, or for scratch arrays that then only need to be allocated once.   The calling site assumes ownership of this object and will delete it when   it is no longer necessary.  
* [0.x.128]*
    [2.x.394]  Use the version taking a  [2.x.395]  argument.  
* [0.x.129]*
   Like get_data(), but return an object that will later be used for   evaluating shape function information at quadrature points on children of   faces of cells. The object will then be used in calls to implementations   of  [2.x.396]  See the documentation of   get_data() for more information.     The default implementation of this function converts the face quadrature   into a cell quadrature with appropriate quadrature point locations, and   with that calls the get_data() function above that has to be implemented   in derived classes.      [2.x.397]  update_flags A set of UpdateFlags values that describe what   kind of information the FEValues object requests the finite element to   compute. This set of flags may also include information that the finite   element can not compute, e.g., flags that pertain to data produced by the   mapping. An implementation of this function needs to set up all data   fields in the returned object that are necessary to produce the finite-   element related data specified by these flags, and may already pre-   compute part of this information as discussed above. Elements may want to   store these update flags (or a subset of these flags) in    [2.x.398]  so they know at the time when    [2.x.399]  is called what they are supposed   to compute    [2.x.400]  mapping A reference to the mapping used for computing values   and derivatives of shape functions.    [2.x.401]  quadrature A reference to the object that describes where the   shape functions should be evaluated.    [2.x.402]  output_data A reference to the object that FEValues will use   in conjunction with the object returned here and where an implementation   of  [2.x.403]  will place the requested   information. This allows the current function to already pre-compute   pieces of information that can be computed on the reference cell, as   discussed above. FEValues guarantees that this output object and the   object returned by the current function will always be used together.    [2.x.404]  A pointer to an object of a type derived from InternalDataBase   and that derived classes can use to store scratch data that can be pre-   computed, or for scratch arrays that then only need to be allocated once.   The calling site assumes ownership of this object and will delete it when   it is no longer necessary.  
* [0.x.130]*
   Compute information about the shape functions on the cell denoted by the   first argument. Derived classes will have to implement this function   based on the kind of element they represent. It is called by    [2.x.405]      Conceptually, this function evaluates shape functions and their   derivatives at the quadrature points represented by the mapped locations   of those described by the quadrature argument to this function. In many   cases, computing derivatives of shape functions (and in some cases also   computing values of shape functions) requires making use of the mapping   from the reference to the real cell; this information can either be taken   from the  [2.x.406]  object that has been filled for the current cell   before this function is called, or by calling the member functions of a   Mapping object with the  [2.x.407]  object that also corresponds   to the current cell.     The information computed by this function is used to fill the various   member variables of the output argument of this function. Which of the   member variables of that structure should be filled is determined by the   update flags stored in the  [2.x.408]    field of the object passed to this function. These flags are typically   set by  [2.x.409]   [2.x.410]  and    [2.x.411]  (or, more specifically, implementations   of these functions in derived classes).     An extensive discussion of the interaction between this function and   FEValues can be found in the    [2.x.412]    documentation module.      [2.x.413]  cell The cell of the triangulation for which this function is   to compute a mapping from the reference cell to.    [2.x.414]  cell_similarity Whether or not the cell given as first   argument is simply a translation, rotation, etc of the cell for which   this function was called the most recent time. This information is   computed simply by matching the vertices (as stored by the Triangulation)   between the previous and the current cell. The value passed here may be   modified by implementations of this function and should then be returned   (see the discussion of the return value of this function).    [2.x.415]  quadrature A reference to the quadrature formula in use for   the current evaluation. This quadrature object is the same as the one   used when creating the  [2.x.416]  object. The current object is   then responsible for evaluating shape functions at the mapped locations   of the quadrature points represented by this object.    [2.x.417]  mapping A reference to the mapping object used to map from the   reference cell to the current cell. This object was used to compute the   information in the  [2.x.418]  object before the current function was   called. It is also the mapping object that created the  [2.x.419]    mapping_internal object via  [2.x.420]  You will need the   reference to this mapping object most often to call  [2.x.421]    to transform gradients and higher derivatives from the reference to the   current cell.    [2.x.422]  mapping_internal An object specific to the mapping object.   What the mapping chooses to store in there is of no relevance to the   current function, but you may have to pass a reference to this object to   certain functions of the Mapping class (e.g.,  [2.x.423]  if   you need to call them from the current function.    [2.x.424]  mapping_data The output object into which the    [2.x.425]  function wrote the mapping information   corresponding to the current cell. This includes, for example, Jacobians   of the mapping that may be of relevance to the current function, as well   as other information that  [2.x.426]  requested from the mapping.    [2.x.427]  fe_internal A reference to an object previously created by   get_data() and that may be used to store information the mapping can   compute once on the reference cell. See the documentation of the    [2.x.428]  class for an extensive description of the   purpose of these objects.    [2.x.429]  output_data A reference to an object whose member variables   should be computed. Not all of the members of this argument need to be   filled; which ones need to be filled is determined by the update flags   stored inside the  [2.x.430]  object.    
*  [2.x.431]  FEValues ensures that this function is always called with the same   pair of  [2.x.432]  and  [2.x.433]  objects. In other words, if an   implementation of this function knows that it has written a piece of data   into the output argument in a previous call, then there is no need to   copy it there again in a later call if the implementation knows that this   is the same value.  
* [0.x.131]*
   This function is the equivalent to  [2.x.434]  but   for faces of cells. See there for an extensive discussion of its purpose.   It is called by  [2.x.435]       [2.x.436]  cell The cell of the triangulation for which this function is   to compute a mapping from the reference cell to.    [2.x.437]  face_no The number of the face we are currently considering,   indexed among the faces of the cell specified by the previous argument.    [2.x.438]  quadrature A reference to the quadrature formula in use for   the current evaluation. This quadrature object is the same as the one   used when creating the  [2.x.439]  object. The current object is   then responsible for evaluating shape functions at the mapped locations   of the quadrature points represented by this object.    [2.x.440]  mapping A reference to the mapping object used to map from the   reference cell to the current cell. This object was used to compute the   information in the  [2.x.441]  object before the current function was   called. It is also the mapping object that created the  [2.x.442]    mapping_internal object via  [2.x.443]  You will need the   reference to this mapping object most often to call  [2.x.444]    to transform gradients and higher derivatives from the reference to the   current cell.    [2.x.445]  mapping_internal An object specific to the mapping object.   What the mapping chooses to store in there is of no relevance to the   current function, but you may have to pass a reference to this object to   certain functions of the Mapping class (e.g.,  [2.x.446]  if   you need to call them from the current function.    [2.x.447]  mapping_data The output object into which the    [2.x.448]  function wrote the mapping information   corresponding to the current cell. This includes, for example, Jacobians   of the mapping that may be of relevance to the current function, as well   as other information that  [2.x.449]  requested from the mapping.    [2.x.450]  fe_internal A reference to an object previously created by   get_data() and that may be used to store information the mapping can   compute once on the reference cell. See the documentation of the    [2.x.451]  class for an extensive description of the   purpose of these objects.    [2.x.452]  output_data A reference to an object whose member variables   should be computed. Not all of the members of this argument need to be   filled; which ones need to be filled is determined by the update flags   stored inside the  [2.x.453]  object.  
* [0.x.132]*
    [2.x.454]  Use the version taking a  [2.x.455]  argument.  
* [0.x.133]*
   This function is the equivalent to  [2.x.456]  but   for the children of faces of cells. See there for an extensive discussion   of its purpose. It is called by  [2.x.457]       [2.x.458]  cell The cell of the triangulation for which this function is   to compute a mapping from the reference cell to.    [2.x.459]  face_no The number of the face we are currently considering,   indexed among the faces of the cell specified by the previous argument.    [2.x.460]  sub_no The number of the subface, i.e., the number of the   child of a face, that we are currently considering, indexed among the   children of the face specified by the previous argument.    [2.x.461]  quadrature A reference to the quadrature formula in use for   the current evaluation. This quadrature object is the same as the one   used when creating the  [2.x.462]  object. The current object is   then responsible for evaluating shape functions at the mapped locations   of the quadrature points represented by this object.    [2.x.463]  mapping A reference to the mapping object used to map from the   reference cell to the current cell. This object was used to compute the   information in the  [2.x.464]  object before the current function was   called. It is also the mapping object that created the  [2.x.465]    mapping_internal object via  [2.x.466]  You will need the   reference to this mapping object most often to call  [2.x.467]    to transform gradients and higher derivatives from the reference to the   current cell.    [2.x.468]  mapping_internal An object specific to the mapping object.   What the mapping chooses to store in there is of no relevance to the   current function, but you may have to pass a reference to this object to   certain functions of the Mapping class (e.g.,  [2.x.469]  if   you need to call them from the current function.    [2.x.470]  mapping_data The output object into which the    [2.x.471]  function wrote the mapping information   corresponding to the current cell. This includes, for example, Jacobians   of the mapping that may be of relevance to the current function, as well   as other information that  [2.x.472]  requested from the mapping.    [2.x.473]  fe_internal A reference to an object previously created by   get_data() and that may be used to store information the mapping can   compute once on the reference cell. See the documentation of the    [2.x.474]  class for an extensive description of the   purpose of these objects.    [2.x.475]  output_data A reference to an object whose member variables   should be computed. Not all of the members of this argument need to be   filled; which ones need to be filled is determined by the update flags   stored inside the  [2.x.476]  object.  
* [0.x.134]

include/deal.II-translator/fe/fe_abf_0.txt
[0.x.0]*
 Implementation of Arnold-Boffi-Falk (ABF) elements, conforming with the space H<sup>div</sup>. These elements generate vector fields with normal components continuous between mesh cells.
*  These elements are based on an article from Arnold, Boffi and Falk: Quadrilateral H(div) finite elements, SIAM J. Numer. Anal. Vol.42, No.6, pp.2429-2451
*  In this article, the authors demonstrate that the usual RT elements and also BDM and other proposed finite dimensional subspaces of H(div) do not work properly on arbitrary FE grids. I.e. the convergence rates deteriorate on these meshes. As a solution the authors propose the ABF elements, which are implemented in this module.
*  This class is not implemented for the codimension one case (<tt>spacedim != dim</tt>).
*   [2.x.0]  Even if this element is implemented for two and three space dimensions, the definition of the node values relies on consistently oriented faces in 3D. Therefore, care should be taken on complicated meshes.
*  [1.x.0]
*  The  [2.x.1]  "interpolation" operators associated with the RT element are constructed such that interpolation and computing the divergence are commuting operations. We require this from interpolating arbitrary functions as well as the #restriction matrices.  It can be achieved by two interpolation schemes, the simplified one in FE_RaviartThomasNodal and the original one here:
*  [1.x.1]
*  On edges or faces, the  [2.x.2]  "node values" are the moments of the normal component of the interpolated function with respect to the traces of the RT polynomials. Since the normal trace of the RT space of degree [1.x.2] on an edge/face is the space [1.x.3], the moments are taken with respect to this space.
*  [1.x.4]
*  Higher order RT spaces have interior nodes. These are moments taken with respect to the gradient of functions in [1.x.5] on the cell (this space is the matching space for RT<sub>k</sub> in a mixed formulation).
*  [1.x.6]
*  The node values above rely on integrals, which will be computed by quadrature rules themselves. The generalized support points are a set of points such that this quadrature can be performed with sufficient accuracy. The points needed are those of QGauss<sub>k+1</sub> on each face as well as QGauss<sub>k</sub> in the interior of the cell (or none for RT<sub>0</sub>). See the  [2.x.3]  "glossary entry on generalized support points" for more information.

* 
* [0.x.1]*
   Constructor for the ABF element of degree  [2.x.4]   
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_ABF<dim>(degree)</tt>, with  [2.x.5]  and  [2.x.6]  replaced   by appropriate values.  
* [0.x.3]*
   This function returns  [2.x.7]  if the shape function  [2.x.8]  has   non-zero function values somewhere on the face  [2.x.9]      Right now, this is only implemented for RT0 in 1D. Otherwise, returns   always  [2.x.10]   
* [0.x.4]*
   The order of the ABF element. The lowest order elements are usually   referred to as RT0, even though their shape functions are piecewise   quadratics.  
* [0.x.5]*
   Only for internal use. Its full name is  [2.x.11]    function and it creates the  [2.x.12]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.13]    FiniteElementData.  
* [0.x.6]*
   Initialize the  [2.x.14]  field of the FiniteElement   class and fill the tables with interpolation weights (#boundary_weights   and #interior_weights). Called from the constructor.     See the    [2.x.15]  "glossary entry on generalized support points"   for more information.  
* [0.x.7]*
   Initialize the interpolation from functions on refined mesh cells onto   the father cell. According to the philosophy of the Raviart-Thomas   element, this restriction operator preserves the divergence of a function   weakly.  
* [0.x.8]*
   Fields of cell-independent data.     For information about the general purpose of this class, see the   documentation of the base class.  
* [0.x.9]*
     Array with shape function values in quadrature points. There is one row     for each shape function, containing values for each quadrature point.     Since the shape functions are vector-valued (with as many components as     there are space dimensions), the value is a tensor.         In this array, we store the values of the shape function in the     quadrature points on the unit cell. The transformation to the real     space cell is then simply done by multiplication with the Jacobian of     the mapping.    
* [0.x.10]*
     Array with shape function gradients in quadrature points. There is one     row for each shape function, containing values for each quadrature     point.         We store the gradients in the quadrature points on the unit cell. We     then only have to apply the transformation (which is a matrix-vector     multiplication) when visiting an actual cell.    
* [0.x.11]*
   These are the factors multiplied to a function in the   #generalized_face_support_points when computing the integration. They are   organized such that there is one row for each generalized face support   point and one column for each degree of freedom on the face.  
* [0.x.12]*
   Precomputed factors for interpolation of interior degrees of freedom. The   rationale for this Table is the same as for #boundary_weights. Only, this   table has a third coordinate for the space direction of the component   evaluated.  
* [0.x.13]*
   These are the factors multiplied to a function in the   #generalized_face_support_points when computing the integration. They are   organized such that there is one row for each generalized face support   point and one column for each degree of freedom on the face.  
* [0.x.14]*
   Precomputed factors for interpolation of interior degrees of freedom. The   rationale for this Table is the same as for #boundary_weights. Only, this   table has a third coordinate for the space direction of the component   evaluated.  
* [0.x.15]*
   Initialize the permutation pattern and the pattern of sign change.    
*  [2.x.16]  This function is not fully filled with the correct implementation   yet. It needs to be consistently implemented in a future release to work   on meshes that contain cells with flipped faces.  
* [0.x.16]

include/deal.II-translator/fe/fe_base_0.txt
[0.x.0]*
 A namespace solely for the purpose of defining the Domination enum as well as associated operators.

* 
* [0.x.1]*
   An enum that describes the outcome of comparing two elements for mutual   domination. If one element dominates another, then the restriction of the   space described by the dominated element to a face of the cell is   strictly larger than that of the dominating element. For example, in 2-d   Q(2) elements dominate Q(4) elements, because the traces of Q(4) elements   are quartic polynomials which is a space strictly larger than the   quadratic polynomials (the restriction of the Q(2) element). Similar   reasonings apply for vertices and cells as well. In general, Q(k) dominates   Q(k') if  [2.x.0] .     This enum is used in the  [2.x.1]  function   that is used in the context of hp-finite element methods when determining   what to do at faces where two different finite elements meet (see the    [2.x.2]  "hp-paper"   for a more detailed description of the following). In that case, the   degrees of freedom of one side need to be constrained to those on the   other side. The determination which side is which is based on the outcome   of a comparison for mutual domination: the dominated side is constrained   to the dominating one.     Note that there are situations where neither side dominates. The    [2.x.3]  "hp-paper"   lists two case, with the simpler one being that a  [2.x.4]  vector-   valued element (i.e. a  [2.x.5] ) meets   a  [2.x.6]  element: here, for each of the two vector-components,   we can define a domination relationship, but it is different for the two   components.     It is clear that the concept of domination doesn't matter for   discontinuous elements. However, discontinuous elements may be part of   vector-valued elements and may therefore be compared against each other   for domination. They should return    [2.x.7]  in that case. Likewise, when   comparing two identical finite elements, they should return this code;   the reason is that we can not decide which element will dominate at the   time we look at the first component of, for example, two  [2.x.8]    and  [2.x.9]  elements, and have to keep our options open until we   get to the second base element.     Finally, the code no_requirements exists for cases where elements impose   no continuity requirements. The case is primarily meant for FE_Nothing   which is an element that has no degrees of freedom in a subdomain. It   could also be used by discontinuous elements, for example.     More details on domination can be found in the    [2.x.10]  "hp-paper".  
* [0.x.2]*
     The current element dominates.    
* [0.x.3]*
     The other element dominates.    
* [0.x.4]*
     Neither element dominates.    
* [0.x.5]*
     Either element may dominate.    
* [0.x.6]*
     There are no requirements.    
* [0.x.7]*
   A generalization of the binary  [2.x.11]  operator to a comparison   relationship. The way this works is pretty much as when you would want to   define a comparison relationship for vectors: either all elements of the   first vector are smaller, equal, or larger than those of the second   vector, or some are and some are not.     This operator is pretty much the same: if both arguments are    [2.x.12]  or    [2.x.13] , then the returned value is that   value. On the other hand, if one of the values is    [2.x.14] , then the returned value is that   of the other argument. If either argument is    [2.x.15] , or if the two arguments are    [2.x.16]  and    [2.x.17] , then the returned value is    [2.x.18] .  
* [0.x.8]*
   Internal data structure for setting up FiniteElementData. It stores for   each object the (inclusive/exclusive) number of degrees of freedoms, as   well as, the index of its first degree of freedom within a cell and the   index of the first d-dimensional object within each face.     The information is saved as a vector of vectors. One can query the   inclusive number of dofs of the i-th d-dimensional object via:   dofs_per_object_inclusive[d][i].     As an example, the data is shown for a quadratic wedge. Which consists of   6 vertices, 9 lines, and 5 faces (two triangles and three quadrilaterals).  
* [1.x.0]
*      Since the above table looks as follows for:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - a triangle:  
* [1.x.1]
* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - quadrilateral:  
* [1.x.2]
*      The index of the first d-dimensional object within each face results as:  
* [1.x.3]
*     
* [0.x.9]*
     Exclusive number of degrees of freedom per object.    
* [0.x.10]*
     Inclusive number of degrees of freedom per object.    
* [0.x.11]*
     First index of an object.    
* [0.x.12]*
     First index of an object within a face.    
* [0.x.13]*
 A class that declares a number of scalar constant variables that describe basic properties of a finite element implementation. This includes, for example, the number of degrees of freedom per vertex, line, or cell; the number of vector components; etc.
*  The kind of information stored here is computed during initialization of a finite element object and is passed down to this class via its constructor. The data stored by this class is part of the public interface of the FiniteElement class (which derives from the current class). See there for more information.
* 

* 
*  [2.x.19] 

* 
* [0.x.14]*
   Enumerator for the different types of continuity a finite element may   have. Continuity is measured by the Sobolev space containing the   constructed finite element space and is also called this way.     Note that certain continuities may imply others. For instance, a function   in [1.x.4] is in [1.x.5] and   [1.x.6] as well.     If you are interested in continuity in the classical sense, then the   following relations hold:      [2.x.20]       [2.x.21]  [1.x.7] implies that the function is continuous over   cell boundaries.      [2.x.22]  [1.x.8] implies that the function is continuously   differentiable over cell boundaries.      [2.x.23]  [1.x.9] indicates that the element is discontinuous.   Since discontinuous elements have no topological couplings between grid   cells and code may actually depend on this property, [1.x.10]   conformity is handled in a special way in the sense that it is [1.x.11]   implied by any higher conformity.    [2.x.24]      In order to test if a finite element conforms to a certain space, use    [2.x.25]   
* [0.x.15]*
     Indicates incompatible continuities of a system.    
* [0.x.16]*
     Discontinuous elements. See above!    
* [0.x.17]*
     Conformity with the space [1.x.12] (continuous     tangential component of a vector field)    
* [0.x.18]*
     Conformity with the space [1.x.13] (continuous normal     component of a vector field)    
* [0.x.19]*
     Conformity with the space [1.x.14] (continuous)    
* [0.x.20]*
     Conformity with the space [1.x.15] (continuously     differentiable)    
* [0.x.21]*
   The dimension of the finite element, which is the template parameter   <tt>dim</tt>  
* [0.x.22]*
   Reference cell type.  
* [0.x.23]*
   Number of unique quads. If all quads have the same type, the value is   one; else it equals the number of quads.  
* [0.x.24]*
   Number of unique faces. If all faces have the same type, the value is   one; else it equals the number of faces.  
* [0.x.25]*
   Number of degrees of freedom on a vertex.  
* [0.x.26]*
   Number of degrees of freedom in a line; not including the degrees of   freedom on the vertices of the line.  
* [0.x.27]*
   Number of degrees of freedom on quads. If all quads have the same   number of degrees freedoms the values equal dofs_per_quad.  
* [0.x.28]*
   Number of degrees of freedom in a quadrilateral; not including the   degrees of freedom on the lines and vertices of the quadrilateral.  
* [0.x.29]*
   Maximum number of degrees of freedom on any quad.  
* [0.x.30]*
   Number of degrees of freedom in a hexahedron; not including the degrees   of freedom on the quadrilaterals, lines and vertices of the hexahedron.  
* [0.x.31]*
   First index of dof on a line.  
* [0.x.32]*
   First index of a quad. If all quads have the same number of degrees of   freedom, only the first index of the first quad is stored since the   indices of the others can be simply recomputed.  
* [0.x.33]*
   First index of dof on a quad.  
* [0.x.34]*
   First index of dof on a hexahedron.  
* [0.x.35]*
   Index of the first line of all faces.  
* [0.x.36]*
   First index of dof on a line for face data.  
* [0.x.37]*
   Index of the first quad of all faces.  
* [0.x.38]*
   First index of dof on a quad for face data.  
* [0.x.39]*
   Number of degrees of freedom on faces. If all faces have the same   number of degrees freedoms the values equal dofs_per_quad.  
* [0.x.40]*
   Number of degrees of freedom on a face. This is the accumulated number of   degrees of freedom on all the objects of dimension up to <tt>dim-1</tt>   constituting a face.  
* [0.x.41]*
   Maximum number of degrees of freedom on any face.  
* [0.x.42]*
   Total number of degrees of freedom on a cell. This is the accumulated   number of degrees of freedom on all the objects of dimension up to   <tt>dim</tt> constituting a cell.  
* [0.x.43]*
   Number of vector components of this finite element, and dimension of the   image space. For vector-valued finite elements (i.e. when this number is   greater than one), the number of vector components is in many cases equal   to the number of base elements glued together with the help of the   FESystem class. However, for elements like the Nedelec element, the   number is greater than one even though we only have one base element.  
* [0.x.44]*
   Maximal polynomial degree of a shape function in a single coordinate   direction.  
* [0.x.45]*
   Indicate the space this element conforms to.  
* [0.x.46]*
   Storage for an object describing the sizes of each block of a compound   element. For an element which is not an FESystem, this contains only a   single block with length #dofs_per_cell.  
* [0.x.47]*
   Constructor, computing all necessary values from the distribution of dofs   to geometrical objects.      [2.x.26]  dofs_per_object A vector that describes the number of degrees   of freedom on geometrical objects for each dimension. This vector must   have size dim+1, and entry 0 describes the number of degrees of freedom   per vertex, entry 1 the number of degrees of freedom per line, etc. As an   example, for the common  [2.x.27]  Lagrange element in 2d, this vector would   have elements  [2.x.28] . On the other hand, for a  [2.x.29]    element in 3d, it would have entries  [2.x.30] .      [2.x.31]  n_components Number of vector components of the element.      [2.x.32]  degree The maximal polynomial degree of any of the shape   functions of this element in any variable on the reference element. For   example, for the  [2.x.33]  element (in any space dimension), this would be   one; this is so despite the fact that the element has a shape function of   the form  [2.x.34]  (in 2d) and  [2.x.35]  (in 3d), which,   although quadratic and cubic polynomials, are still only linear in each   reference variable separately. The information provided by this variable   is typically used in determining what an appropriate quadrature formula   is.      [2.x.36]  conformity A variable describing which Sobolev space this   element conforms to. For example, the  [2.x.37]  Lagrange elements   (implemented by the FE_Q class) are  [2.x.38]  conforming, whereas the   Raviart-Thomas element (implemented by the FE_RaviartThomas class) is    [2.x.39]  conforming; finally, completely discontinuous elements   (implemented by the FE_DGQ class) are only  [2.x.40]  conforming.      [2.x.41]  block_indices An argument that describes how the base elements   of a finite element are grouped. The default value constructs a single   block that consists of all  [2.x.42]  degrees of freedom. This is   appropriate for all "atomic" elements (including non-primitive ones) and   these can therefore omit this argument. On the other hand, composed   elements such as FESystem will want to pass a different value here.  
* [0.x.48]*
   The same as above but with the difference that also the type of the   underlying geometric entity can be specified.  
* [0.x.49]*
   The same as above but instead of passing a vector containing the degrees   of freedoms per object a struct of type GenericDoFsPerObject. This allows   that 2D objects might have different number of degrees of freedoms, which   is particular useful for cells with triangles and quadrilaterals as faces.  
* [0.x.50]*
   Return the kind of reference cell this element is defined on: For   example, whether the element's reference cell is a square or   triangle, or similar choices in higher dimensions.  
* [0.x.51]*
   Number of unique quads. If all quads have the same type, the value is   one; else it equals the number of quads.  
* [0.x.52]*
   Number of unique faces. If all faces have the same type, the value is   one; else it equals the number of faces.  
* [0.x.53]*
   Number of dofs per vertex.  
* [0.x.54]*
   Number of dofs per line. Not including dofs on lower dimensional objects.  
* [0.x.55]*
   Number of dofs per quad. Not including dofs on lower dimensional objects.  
* [0.x.56]*
   Maximum number of dofs per quad. Not including dofs on lower dimensional   objects.  
* [0.x.57]*
   Number of dofs per hex. Not including dofs on lower dimensional objects.  
* [0.x.58]*
   Number of dofs per face, accumulating degrees of freedom of all lower   dimensional objects.  
* [0.x.59]*
   Maximum number of dofs per face, accumulating degrees of freedom of all   lower dimensional objects.  
* [0.x.60]*
   Number of dofs per cell, accumulating degrees of freedom of all lower   dimensional objects.  
* [0.x.61]*
   Return the number of degrees per structdim-dimensional object. For   structdim==0, the function therefore returns dofs_per_vertex, for   structdim==1 dofs_per_line, etc. This function is mostly used to allow   some template trickery for functions that should work on all sorts of   objects without wanting to use the different names (vertex, line, ...)   associated with these objects.  
* [0.x.62]*
   Number of components. See    [2.x.43]  "the glossary"   for more information.  
* [0.x.63]*
   Number of blocks. See    [2.x.44]  "the glossary"   for more information.  
* [0.x.64]*
   Detailed information on block sizes.  
* [0.x.65]*
   Maximal polynomial degree of a shape function in a single coordinate   direction.     This function can be used to determine the optimal quadrature rule.  
* [0.x.66]*
   Test whether a finite element space conforms to a certain Sobolev space.    
*  [2.x.45]  This function will return a true value even if the finite element   space has higher regularity than asked for.  
* [0.x.67]*
   Comparison operator.  
* [0.x.68]*
   Return first index of dof on a line.  
* [0.x.69]*
   Return first index of dof on a quad.  
* [0.x.70]*
   Return first index of dof on a hexahedron.  
* [0.x.71]*
   Return first index of dof on a line for face data.  
* [0.x.72]*
   Return first index of dof on a quad for face data.  
* [0.x.73]*
   Utility function to convert "dofs per object" information   of a  [2.x.46]  dimensional reference cell  [2.x.47]   
* [0.x.74]

include/deal.II-translator/fe/fe_bdm_0.txt
[0.x.0]*
 The Brezzi-Douglas-Marini element.
*  [1.x.0]
*   [2.x.0]  The 3D version exhibits some numerical instabilities, in particular for higher order
*   [2.x.1]  Restriction matrices are missing.
*  The matching pressure space for FE_BDM of order [1.x.1] is the element FE_DGP of order [1.x.2].
*  The BDM element of order  [2.x.2]  has [1.x.3] degrees of freedom on each face. These are implemented as the function values in the [1.x.4] Gauss points on each face.
*  Additionally, for order greater or equal 2, we have additional [1.x.5], the number of vector valued polynomials in [1.x.6], interior degrees of freedom. These are the vector function values in the first [1.x.7] of the [1.x.8] Gauss points in the cell.
* 

* 
*  [2.x.3] 

* 
* [0.x.1]*
   Constructor for the BDM element of degree  [2.x.4]   
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_BDM<dim>(degree)</tt>, with  [2.x.5]  and  [2.x.6]  replaced   by appropriate values.  
* [0.x.3]*
   Only for internal use. Its full name is  [2.x.7]    function and it creates the  [2.x.8]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.9]    FiniteElementData.  
* [0.x.4]*
   Compute the vector used for the  [2.x.10]  field passed   to the base class's constructor.  
* [0.x.5]*
   Initialize the  [2.x.11]  and    [2.x.12]  fields. Called from   the constructor. See the    [2.x.13]  "glossary entry on generalized support points"   for more information.  
* [0.x.6]*
   The values in the face support points of the polynomials needed as test   functions. The outer vector is indexed by quadrature points, the inner by   the test function. The test function space is PolynomialsP<dim-1>.  
* [0.x.7]*
   The values in the interior support points of the polynomials needed as   test functions. The outer vector is indexed by quadrature points, the   inner by the test function. The test function space is PolynomialsP<dim>.  
* [0.x.8]*
   Initialize the permutation pattern and the pattern of sign change.    
*  [2.x.14]  This function is not fully filled with the correct implementation   yet. It needs to be consistently implemented in a future release to work   on meshes that contain cells with flipped faces.  
* [0.x.9]

include/deal.II-translator/fe/fe_bernardi_raugel_0.txt
[0.x.0]*
 The Bernardi-Raugel element.
*  This class implements the non-standard Bernardi-Raugel (BR) element that can be used as one part of a stable velocity/pressure pair for the Stokes equation. The BR element can be seen as either an enriched version of the  [2.x.0]  element with added bubble functions on each edge (in 2d) or face (in 3d), or as a reduced version of the  [2.x.1]  element. It addresses the fact that the  [2.x.2]  combination is not inf-sup stable (requiring a larger velocity space), and that the  [2.x.3]  combination is stable but sub-optimal since the velocity space is too large relative to the pressure space to provide additional accuracy commensurate with the cost of the large number of velocity unknowns.
*  The element was introduced in the following paper:

* 
* [1.x.0]
* 
* 

*  [1.x.1]
*  The BR1 element has [1.x.2] degrees of freedom on each vertex and 1 on each face. The shape functions are ordered by the  [2.x.4]  shape functions supported on each vertex, increasing according to vertex ordering on the element in GeometryInfo, then the bubble functions follow in the ordering given in PolynomialsBernardiRaugel.
*  This element only has 1 degree (degree  [2.x.5] ) because it yields an LBB stable pair BR1-P0 for Stokes problems which is lower degree than the Taylor-Hood element. The pair is sometimes referred to as an enriched P1-P0 element or a reduced P2-P0 element.
*  This element does not support hanging nodes or multigrid in the current implementation.
*  Some numerical experiments have shown that this element may converge with first-order accuracy when using the BR1-Q0 pair for the mixed Laplace equation in  [2.x.6] .

* 
* [0.x.1]*
   Constructor for the Bernardi-Raugel element of degree  [2.x.7]  The only   supported degree is 1.      [2.x.8]  p: The degree of the element  [2.x.9]  for  [2.x.10] .  
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_BR<dim>(degree)</tt>, with  [2.x.11]  and  [2.x.12]  replaced   by appropriate values.  
* [0.x.3]*
   Only for internal use. Its full name is  [2.x.13]    function and it creates the  [2.x.14]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.15]    FiniteElementData.  
* [0.x.4]*
   Initialize the  [2.x.16]  and    [2.x.17]  fields. Called from   the constructor. See the    [2.x.18]  "glossary entry on generalized support points"   for more information.  
* [0.x.5]*
   Initialize the permutation pattern and the pattern of sign change.    
*  [2.x.19]  This function is not fully filled with the correct implementation   yet. It needs to be consistently implemented in a future release to work   on meshes that contain cells with flipped faces.  
* [0.x.6]

include/deal.II-translator/fe/fe_bernstein_0.txt
[0.x.0]*
 Implementation of a scalar Bernstein finite element  [2.x.0]  we call FE_Bernstein in analogy with FE_Q that yields the finite element space of continuous, piecewise Bernstein polynomials of degree  [2.x.1]  in each coordinate direction. This class is realized using tensor product polynomials of Bernstein basis polynomials.
* 

*  The standard constructor of this class takes the degree  [2.x.2]  of this finite element.
*  For more information about the <tt>spacedim</tt> template parameter check the documentation of FiniteElement or the one of Triangulation.
*  [1.x.0]
*  The constructor creates a TensorProductPolynomials object that includes the tensor product of  [2.x.3]  polynomials of degree  [2.x.4]  This  [2.x.5]  TensorProductPolynomials object provides all values and derivatives of the shape functions.
*  [1.x.1]
*  The original ordering of the shape functions represented by the TensorProductPolynomials is a tensor product numbering. However, the shape functions on a cell are renumbered beginning with the shape functions whose support points are at the vertices, then on the line, on the quads, and finally (for 3d) on the hexes. See the documentation of FE_Q for more details.

* 
* [0.x.1]*
   Constructor for tensor product polynomials of degree  [2.x.6]   
* [0.x.2]*
   FE_Bernstein is not interpolatory in the element interior, which prevents   this element from defining an interpolation matrix. An exception will be   thrown.     This function overrides the implementation from FE_Q_Base.  
* [0.x.3]*
   FE_Bernstein is not interpolatory in the element interior, which prevents   this element from defining a restriction matrix. An exception will be   thrown.     This function overrides the implementation from FE_Q_Base.  
* [0.x.4]*
   FE_Bernstein is not interpolatory in the element interior, which prevents   this element from defining a prolongation matrix. An exception will be   thrown.     This function overrides the implementation from FE_Q_Base.  
* [0.x.5]*
   Return the matrix interpolating from a face of one element to the face of   the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>. The   FE_Bernstein element family only provides interpolation matrices for   elements of the same type, for elements that have support points, and   FE_Nothing. For all other elements, an exception of type    [2.x.7]  is thrown.  
* [0.x.6]*
   Return the matrix interpolating from a face of one element to the face of   the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>. The   FE_Bernstein element family only provides interpolation matrices for   elements of the same type, for elements that have support points, and   FE_Nothing. For all other elements, an exception of type    [2.x.8]  is thrown.  
* [0.x.7]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".  
* [0.x.8]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.9]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.  
* [0.x.9]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.  
* [0.x.10]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on quads.  
* [0.x.11]*
    [2.x.10]   [2.x.11]   
* [0.x.12]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_Bernstein<dim>(degree)</tt>, with  [2.x.12]  and  [2.x.13]    replaced by appropriate values.  
* [0.x.13]*
   Only for internal use. Its full name is  [2.x.14]    function and it creates the  [2.x.15]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.16]    FiniteElementData.  
* [0.x.14]*
   This function renumbers Bernstein basis functions from hierarchic to   lexicographic numbering.  
* [0.x.15]

include/deal.II-translator/fe/fe_dgp_0.txt
[0.x.0]*
 Discontinuous finite elements based on Legendre polynomials.
*  This finite element implements complete polynomial spaces, that is, dim- dimensional polynomials of degree p. For example, in 2d the element FE_DGP(1) would represent the span of the functions  [2.x.0] , which is in contrast to the element FE_DGQ(1) that is formed by the span of  [2.x.1] . Since the DGP space has only three unknowns for each quadrilateral, it is immediately clear that this element can not be continuous.
*  The basis functions used in this element for the space described above are chosen to form a Legendre basis on the unit square, i.e., in particular they are  [2.x.2] -orthogonal and normalized on the reference cell (but not necessarily on the real cell). As a consequence, the first basis function of this element is always the function that is constant and equal to one, regardless of the polynomial degree of the element. In addition, as a result of the orthogonality of the basis functions, the mass matrix is diagonal if the grid cells are parallelograms. Note that this is in contrast to the FE_DGPMonomial class that actually uses the monomial basis listed above as basis functions, without transformation from reference to real cell.
*  The shape functions are defined in the class PolynomialSpace. The polynomials used inside PolynomialSpace are  [2.x.3]  up to degree <tt>p</tt> given in FE_DGP. For the ordering of the basis functions, refer to PolynomialSpace, remembering that the Legendre polynomials are ordered by ascending degree.
* 

* 
*  [2.x.4]  This element is not defined by finding shape functions within the given function space that interpolate a particular set of points. Consequently, there are no support points to which a given function could be interpolated; finding a finite element function that approximates a given function is therefore only possible through projection, rather than interpolation. Secondly, the shape functions of this element do not jointly add up to one. As a consequence of this, adding or subtracting a constant value
* 
*  -  such as one would do to make a function have mean value zero
* 
*  -  can not be done by simply subtracting the constant value from each degree of freedom. Rather, one needs to use the fact that the first basis function is constant equal to one and simply subtract the constant from the value of the degree of freedom corresponding to this first shape function on each cell.
* 

* 

* 
*  [2.x.5]  This class is only partially implemented for the codimension one case (<tt>spacedim != dim </tt>), since no passage of information between meshes of different refinement level is possible because the embedding and projection matrices are not computed in the class constructor.
*  [1.x.0]
*  It is worth noting that under a (bi-, tri-)linear mapping, the space described by this element does not contain  [2.x.6] , even if we use a basis of polynomials of degree  [2.x.7] . Consequently, for example, on meshes with non-affine cells, a linear function can not be exactly represented by elements of type FE_DGP(1) or FE_DGPMonomial(1).
*  This can be understood by the following 2-d example: consider the cell with vertices at  [2.x.8] :  [2.x.9] 
*  For this cell, a bilinear transformation  [2.x.10]  produces the relations  [2.x.11]  and  [2.x.12]  that correlate reference coordinates  [2.x.13]  and coordinates in real space  [2.x.14] . Under this mapping, the constant function is clearly mapped onto itself, but the two other shape functions of the  [2.x.15]  space, namely  [2.x.16]  and  [2.x.17]  are mapped onto  [2.x.18]  where  [2.x.19] .
*  For the simple case that  [2.x.20] , i.e. if the real cell is the unit square, the expressions can be simplified to  [2.x.21]  and  [2.x.22] . However, for all other cases, the functions  [2.x.23]  are not linear any more, and neither is any linear combination of them. Consequently, the linear functions are not within the range of the mapped  [2.x.24]  polynomials.
*  [1.x.1] In 2d, the shape functions of this element look as follows.
*  [1.x.2]
*   [2.x.25] 
*  [1.x.3]
*   [2.x.26] 
* 

*  [1.x.4]
*   [2.x.27] 
* 

*  [1.x.5]
*   [2.x.28] 
* 

*  [1.x.6]  [2.x.29] 

* 
* [0.x.1]*
   Constructor for tensor product polynomials of degree  [2.x.30]   
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_DGP<dim>(degree)</tt>, with  [2.x.31]  and  [2.x.32]  replaced   by appropriate values.  
* [0.x.3]*
    [2.x.33]  Functions to support hp    [2.x.34]   
* [0.x.4]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.35]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.     This being a discontinuous element, the set of such constraints is of   course empty.  
* [0.x.5]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.     This being a discontinuous element, the set of such constraints is of   course empty.  
* [0.x.6]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on quads.     This being a discontinuous element, the set of such constraints is of   course empty.  
* [0.x.7]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".     For the FE_DGP class the result is always true (independent of the degree   of the element), as it has no hanging nodes (being a discontinuous   element).  
* [0.x.8]*
    [2.x.36]   [2.x.37]   
* [0.x.9]*
    [2.x.38]   
* [0.x.10]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element. The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type    [2.x.39]   
* [0.x.11]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element. The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type    [2.x.40]   
* [0.x.12]*
   This function returns  [2.x.41]  if the shape function  [2.x.42]  has   non-zero function values somewhere on the face  [2.x.43]   
* [0.x.13]*
   Determine an estimate for the memory consumption (in bytes) of this   object.     This function is made virtual, since finite element objects are usually   accessed through pointers to their base class, rather than the class   itself.  
* [0.x.14]*
   Return a list of constant modes of the element. For this element, the   first entry is true, all other are false.  
* [0.x.15]*
   Only for internal use. Its full name is  [2.x.44]    function and it creates the  [2.x.45]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.46]    FiniteElementData.  
* [0.x.16]

include/deal.II-translator/fe/fe_dgp_monomial_0.txt
[0.x.0]*
 Discontinuous finite elements based on monomials.
*  This finite element implements complete polynomial spaces, that is, dim- dimensional polynomials of degree p. For example, in 2d the element FE_DGP(1) would represent the span of the functions  [2.x.0] , which is in contrast to the element FE_DGQ(1) that is formed by the span of  [2.x.1] . Since the DGP space has only three unknowns for each quadrilateral, it is immediately clear that this element can not be continuous.
*  The basis functions for this element are chosen to be the monomials listed above. Note that this is the main difference to the FE_DGP class that uses a set of polynomials of complete degree  [2.x.2]  that form a Legendre basis on the unit square. Thus, there, the mass matrix is diagonal, if the grid cells are parallelograms. The basis here does not have this property; however, it is simpler to compute. On the other hand, this element has the additional disadvantage that the local cell matrices usually have a worse condition number than the ones originating from the FE_DGP element.
*  This class is not implemented for the codimension one case (<tt>spacedim != dim</tt>).
*  [1.x.0]
*  It is worth noting that under a (bi-, tri-)linear mapping, the space described by this element does not contain  [2.x.3] , even if we use a basis of polynomials of degree  [2.x.4] . Consequently, for example, on meshes with non-affine cells, a linear function can not be exactly represented by elements of type FE_DGP(1) or FE_DGPMonomial(1).
*  This can be understood by the following 2-d example: consider the cell with vertices at  [2.x.5] :  [2.x.6] 
*  For this cell, a bilinear transformation  [2.x.7]  produces the relations  [2.x.8]  and  [2.x.9]  that correlate reference coordinates  [2.x.10]  and coordinates in real space  [2.x.11] . Under this mapping, the constant function is clearly mapped onto itself, but the two other shape functions of the  [2.x.12]  space, namely  [2.x.13]  and  [2.x.14]  are mapped onto  [2.x.15]  where  [2.x.16] .
*  For the simple case that  [2.x.17] , i.e. if the real cell is the unit square, the expressions can be simplified to  [2.x.18]  and  [2.x.19] . However, for all other cases, the functions  [2.x.20]  are not linear any more, and neither is any linear combination of them. Consequently, the linear functions are not within the range of the mapped  [2.x.21]  polynomials.
* 

*  [1.x.1] In 2d, the shape functions of this element look as follows.
*  [1.x.2]
*   [2.x.22] 
*  [1.x.3]
*   [2.x.23] 
* 

*  [1.x.4]
*   [2.x.24] 
* 

*  [1.x.5]
*   [2.x.25] 
* 

*  [1.x.6]  [2.x.26] 

* 
* [0.x.1]*
   Constructor for the polynomial space of degree <tt>p</tt>.  
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_DGPMonomial<dim>(degree)</tt>, with <tt>dim</tt> and   <tt>p</tt> replaced by appropriate values.  
* [0.x.3]*
    [2.x.27]  Functions to support hp    [2.x.28]   
* [0.x.4]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.29]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.     This being a discontinuous element, the set of such constraints is of   course empty.  
* [0.x.5]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.     This being a discontinuous element, the set of such constraints is of   course empty.  
* [0.x.6]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on quads.     This being a discontinuous element, the set of such constraints is of   course empty.  
* [0.x.7]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".     For the FE_DGPMonomial class the result is always true (independent of   the degree of the element), as it has no hanging nodes (being a   discontinuous element).  
* [0.x.8]*
    [2.x.30]   [2.x.31]   
* [0.x.9]*
    [2.x.32]   
* [0.x.10]*
   Return the matrix interpolating from the given finite element to the   present one. The size of the matrix is then  [2.x.33]  times   <tt>source.n_dofs_per_cell()</tt>.     These matrices are only available if the source element is also a  [2.x.34]    element. Otherwise, an exception of type    [2.x.35]  is thrown.  
* [0.x.11]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element. The size of the matrix is then  [2.x.36]    dofs_per_face times <tt>source.dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type    [2.x.37]   
* [0.x.12]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element. The size of the matrix is then  [2.x.38]    dofs_per_face times <tt>source.dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type    [2.x.39]   
* [0.x.13]*
   This function returns  [2.x.40]  if the shape function  [2.x.41]  has   non-zero function values somewhere on the face  [2.x.42]   
* [0.x.14]*
   Determine an estimate for the memory consumption (in bytes) of this   object.     This function is made virtual, since finite element objects are usually   accessed through pointers to their base class, rather than the class   itself.  
* [0.x.15]*
   Only for internal use. Its full name is  [2.x.43]    function and it creates the  [2.x.44]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.45]    FiniteElementData.  
* [0.x.16]*
   Initialize the restriction matrices. Called from the constructor.  
* [0.x.17]

include/deal.II-translator/fe/fe_dgp_nonparametric_0.txt
[0.x.0]*
 Discontinuous finite elements evaluated at the mapped quadrature points.
*  Warning: this class does not work properly, yet. Don't use it!
*  This finite element implements complete polynomial spaces, that is,  [2.x.0] -dimensional polynomials of order  [2.x.1] .
*  The polynomials are not mapped. Therefore, they are constant, linear, quadratic, etc. on any grid cell.
*  Since the polynomials are evaluated at the quadrature points of the actual grid cell, no grid transfer and interpolation matrices are available.
*  The purpose of this class is experimental, therefore the implementation will remain incomplete.
*  Besides, this class is not implemented for the codimension one case (<tt>spacedim != dim</tt>).
* 

*  [1.x.0] In 2d, the shape functions of this element look as follows.
*  [1.x.1]
*   [2.x.2] 
*  [1.x.2]
*   [2.x.3] 
* 

*  [1.x.3]
*   [2.x.4] 
* 

*  [1.x.4]
*   [2.x.5] 
* 

*  [1.x.5]  [2.x.6] 
* 

*  [1.x.6]
*  This element does not have an InternalData class, unlike all other elements, because the InternalData classes are used to store things that can be computed once and reused multiple times (such as the values of shape functions at quadrature points on the reference cell). However, because the element is not mapped, this element has nothing that could be computed on the reference cell
* 
*  -  everything needs to be computed on the real cell
* 
*  -  and consequently there is nothing we'd like to store in such an object. We can thus simply use the members already provided by  [2.x.7]  without adding anything in a derived class in this class.

* 
* [0.x.1]*
   Constructor for tensor product polynomials of degree  [2.x.8]   
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_DGPNonparametric<dim>(degree)</tt>, with  [2.x.9]  and  [2.x.10]    degree replaced by appropriate values.  
* [0.x.3]*
   This function is intended to return the value of a shape function at a   point on the reference cell. However, since the current element does not   implement shape functions by mapping from a reference cell, no shape   functions exist on the reference cell.     Consequently, as discussed in the corresponding function in the base   class,  [2.x.11]  this function throws an exception of   type  [2.x.12]   
* [0.x.4]*
   This function is intended to return the value of a shape function at a   point on the reference cell. However, since the current element does not   implement shape functions by mapping from a reference cell, no shape   functions exist on the reference cell.     Consequently, as discussed in the corresponding function in the base   class,  [2.x.13]  this function throws an   exception of type  [2.x.14]   
* [0.x.5]*
   This function is intended to return the gradient of a shape function at a   point on the reference cell. However, since the current element does not   implement shape functions by mapping from a reference cell, no shape   functions exist on the reference cell.     Consequently, as discussed in the corresponding function in the base   class,  [2.x.15]  this function throws an exception of   type  [2.x.16]   
* [0.x.6]*
   This function is intended to return the gradient of a shape function at a   point on the reference cell. However, since the current element does not   implement shape functions by mapping from a reference cell, no shape   functions exist on the reference cell.     Consequently, as discussed in the corresponding function in the base   class,  [2.x.17]  this function throws an   exception of type  [2.x.18]   
* [0.x.7]*
   This function is intended to return the Hessian of a shape function at a   point on the reference cell. However, since the current element does not   implement shape functions by mapping from a reference cell, no shape   functions exist on the reference cell.     Consequently, as discussed in the corresponding function in the base   class,  [2.x.19]  this function throws an   exception of type  [2.x.20]   
* [0.x.8]*
   This function is intended to return the Hessian of a shape function at a   point on the reference cell. However, since the current element does not   implement shape functions by mapping from a reference cell, no shape   functions exist on the reference cell.     Consequently, as discussed in the corresponding function in the base   class,  [2.x.21]  this function throws   an exception of type  [2.x.22]   
* [0.x.9]*
   Return the polynomial degree of this finite element, i.e. the value   passed to the constructor.  
* [0.x.10]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element. The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type    [2.x.23]   
* [0.x.11]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element. The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type    [2.x.24]   
* [0.x.12]*
    [2.x.25]  Functions to support hp    [2.x.26]   
* [0.x.13]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.27]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.     This being a discontinuous element, the set of such constraints is of   course empty.  
* [0.x.14]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.     This being a discontinuous element, the set of such constraints is of   course empty.  
* [0.x.15]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on quads.     This being a discontinuous element, the set of such constraints is of   course empty.  
* [0.x.16]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".     For the FE_DGPNonparametric class the result is always true (independent   of the degree of the element), as it has no hanging nodes (being a   discontinuous element).  
* [0.x.17]*
    [2.x.28]   [2.x.29]   
* [0.x.18]*
    [2.x.30]   
* [0.x.19]*
   This function returns  [2.x.31]  if the shape function  [2.x.32]  has   non-zero function values somewhere on the face  [2.x.33]   
* [0.x.20]*
   Determine an estimate for the memory consumption (in bytes) of this   object.     This function is made virtual, since finite element objects are usually   accessed through pointers to their base class, rather than the class   itself.  
* [0.x.21]*
   Prepare internal data structures and fill in values independent of the   cell.  
* [0.x.22]*
   Only for internal use. Its full name is  [2.x.34]    function and it creates the  [2.x.35]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.36]    FiniteElementData.  
* [0.x.23]*
   Pointer to an object representing the polynomial space used here.  
* [0.x.24]

include/deal.II-translator/fe/fe_dgq_0.txt
[0.x.0]*
 Implementation of scalar, discontinuous tensor product elements based on equidistant support points.
*  This is a discontinuous finite element based on tensor products of Lagrangian polynomials. The shape functions are Lagrangian interpolants of an equidistant grid of points on the unit cell. The points are numbered in lexicographical order, with [1.x.0] running fastest, then [1.x.1], then [1.x.2] (if these coordinates are present for a given space dimension at all). For example, these are the node orderings for <tt>FE_DGQ(1)</tt> in 3d: 
* [1.x.3]
*  and <tt>FE_DGQ(2)</tt>: 
* [1.x.4]
*  with node 13 being placed in the interior of the hex.
*  Note, however, that these are just the Lagrange interpolation points of the shape functions. Even though they may physically be on the boundary of the cell, they are logically in the interior since there are no continuity requirements for these shape functions across cell boundaries. While discontinuous, when restricted to a single cell the shape functions of this element are exactly the same as those of the FE_Q element where they are shown visually.
*  [1.x.5]
*  When constructing an FE_DGQ element at polynomial degrees one or two, equidistant support points at 0 and 1 (linear case) or 0, 0.5, and 1 (quadratic case) are used. The unit support or nodal points [1.x.6] are those points where the [1.x.7]th Lagrange polynomial satisfies the  [2.x.0]  property, i.e., where one polynomial is one and all the others are zero.  For higher polynomial degrees, the support points are non-equidistant by default, and chosen to be the support points of the <tt>(degree+1)</tt>-order Gauss-Lobatto quadrature rule. This point distribution yields well-conditioned Lagrange interpolation at arbitrary polynomial degrees. By contrast, polynomials based on equidistant points get increasingly ill-conditioned as the polynomial degree increases. In interpolation, this effect is known as the Runge phenomenon. For Galerkin methods, the Runge phenomenon is typically not visible in the solution quality but rather in the condition number of the associated system matrices. For example, the elemental mass matrix of equidistant points at degree 10 has condition number 2.6e6, whereas the condition number for Gauss-Lobatto points is around 400.
*  The Gauss-Lobatto points in 1D include the end points 0 and +1 of the unit interval. The interior points are shifted towards the end points, which gives a denser point distribution close to the element boundary.

* 
* [0.x.1]*
   Constructor for tensor product polynomials of degree <tt>p</tt>. The   shape functions created using this constructor correspond to Lagrange   interpolation polynomials for Gauss-Lobatto support (node) points in each   coordinate direction.  
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_DGQ<dim>(degree)</tt>, with <tt>dim</tt> and   <tt>degree</tt> replaced by appropriate values.  
* [0.x.3]*
   Return the matrix interpolating from the given finite element to the   present one. The size of the matrix is then  [2.x.1]  times   <tt>source.n_dofs_per_cell()</tt>.     These matrices are only available if the source element is also a  [2.x.2]    FE_DGQ element. Otherwise, an exception of type    [2.x.3]  is thrown.  
* [0.x.4]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element. The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type    [2.x.4]   
* [0.x.5]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element. The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type    [2.x.5]   
* [0.x.6]*
   Projection from a fine grid space onto a coarse grid space. Overrides the   respective method in FiniteElement, implementing lazy evaluation   (initialize when requested).     If this projection operator is associated with a matrix  [2.x.6]  then the   restriction of this matrix  [2.x.7]  to a single child cell is returned   here.     The matrix  [2.x.8]  is the concatenation or the sum of the cell matrices  [2.x.9]    P_i, depending on the #restriction_is_additive_flags. This distinguishes   interpolation (concatenation) and projection with respect to scalar   products (summation).     Row and column indices are related to coarse grid and fine grid spaces,   respectively, consistent with the definition of the associated operator.  
* [0.x.7]*
   Embedding matrix between grids. Overrides the respective method in   FiniteElement, implementing lazy evaluation (initialize when queried).     The identity operator from a coarse grid space into a fine grid space is   associated with a matrix  [2.x.10]  The restriction of this matrix  [2.x.11]  to a   single child cell is returned here.     The matrix  [2.x.12]  is the concatenation, not the sum of the cell matrices  [2.x.13]    P_i. That is, if the same non-zero entry <tt>j,k</tt> exists in two   different child matrices  [2.x.14]  the value should be the same in both   matrices and it is copied into the matrix  [2.x.15]  only once.     Row and column indices are related to fine grid and coarse grid spaces,   respectively, consistent with the definition of the associated operator.     These matrices are used by routines assembling the prolongation matrix   for multi-level methods.  Upon assembling the transfer matrix between   cells using this matrix array, zero elements in the prolongation matrix   are discarded and will not fill up the transfer matrix.  
* [0.x.8]*
    [2.x.16]  Functions to support hp    [2.x.17]   
* [0.x.9]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.18]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.     This being a discontinuous element, the set of such constraints is of   course empty.  
* [0.x.10]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.     This being a discontinuous element, the set of such constraints is of   course empty.  
* [0.x.11]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on quads.     This being a discontinuous element, the set of such constraints is of   course empty.  
* [0.x.12]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".     For the FE_DGQ class the result is always true (independent of the degree   of the element), as it has no hanging nodes (being a discontinuous   element).  
* [0.x.13]*
    [2.x.19]   [2.x.20]   
* [0.x.14]*
    [2.x.21]   
* [0.x.15]*
   This function returns  [2.x.22]  if the shape function  [2.x.23]  has   non-zero function values somewhere on the face  [2.x.24]   
* [0.x.16]*
   Return a list of constant modes of the element. For this element, it   simply returns one row with all entries set to true.  
* [0.x.17]*
   Implementation of the corresponding function in the FiniteElement   class.  Since the current element is interpolatory, the nodal   values are exactly the support point values. Furthermore, since   the current element is scalar, the support point values need to   be vectors of length 1.  
* [0.x.18]*
   Constructor for tensor product polynomials based on an arbitrary vector   of polynomials. This constructor is used in derived classes to construct   e.g. elements with arbitrary nodes or elements based on Legendre   polynomials.     The degree of these polynomials is <tt>polynomials.size()-1</tt>.  
* [0.x.19]*
   Only for internal use. Its full name is  [2.x.25]    function and it creates the  [2.x.26]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.27]    FiniteElementData.  
* [0.x.20]*
   Compute renumbering for rotation of degrees of freedom.     This function rotates a tensor product numbering of degrees of   freedom by 90 degrees.  It is used to compute the transfer   matrices of the children by using only the matrix for the first   child.     The direction parameter determines the type of rotation. It is one   character of  [2.x.28]  The character determines the axis of rotation,   case determines the direction. Lower case is counter-clockwise seen in   direction of the axis.     Since rotation around the y-axis is not used, it is not implemented   either.  
* [0.x.21]   Mutex for protecting initialization of restriction and embedding matrix.  
* [0.x.22]*
 Implementation of scalar, discontinuous tensor product elements based on Lagrange polynomials with arbitrary nodes. The primary purpose of this class is to provide an element for which the mass matrix can be made diagonal by choosing basis functions that are not either zero or one at the vertices of the cell, but instead are zero or one at a given set of quadrature points. If this set of quadrature points is then also used in integrating the mass matrix, then it will be diagonal. The number of quadrature points automatically determines the polynomial degree chosen for this element. The typical applications are the Gauss quadrature or the Gauss-Lobatto quadrature (provided through the base class).
*  See the base class documentation in FE_DGQ for details.

* 
* [0.x.23]*
   Constructor for tensor product polynomials based on  [2.x.29]    interpolation of the support points in the quadrature rule   <tt>points</tt>. The degree of these polynomials is   <tt>points.size()-1</tt>.  
* [0.x.24]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_DGQArbitraryNodes<dim>(degree)</tt>, with <tt>dim</tt> and   <tt>degree</tt> replaced by appropriate values.  
* [0.x.25]*
   Implementation of the corresponding function in the FiniteElement   class.  Since the current element is interpolatory, the nodal   values are exactly the support point values. Furthermore, since   the current element is scalar, the support point values need to   be vectors of length 1.  
* [0.x.26]*
 Implementation of scalar, discontinuous tensor product elements based on Legendre polynomials, described by the tensor product of the polynomial space  [2.x.30]  The tensor product is achieved using TensorProductPolynomials and the ordering of shape functions, like in TensorProductPolynomials, is lexicographic. For instance, the ordering in 2d is  [2.x.31]  when <tt>degree=n</tt> where  [2.x.32]  are the one-dimensional Legendre polynomials defined on  [2.x.33] . As opposed to the basic FE_DGQ element, these elements are not interpolatory and no support points are defined.
*  See the base class documentation in FE_DGQ for details.

* 
* [0.x.27]*
   Constructor for tensor product polynomials based on  [2.x.34]    interpolation.  
* [0.x.28]*
   Return a list of constant modes of the element. For the Legendre basis,   it returns one row where the first element (corresponding to the constant   mode) is set to true and all other elements are set to false.  
* [0.x.29]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_DGQLegendre<dim>(degree)</tt> with <tt>dim</tt> and   <tt>degree</tt> replaced by the values given by the template parameter   and the argument passed to the constructor, respectively.  
* [0.x.30]*
 Implementation of scalar, discontinuous tensor product elements based on Hermite-like polynomials, described by the polynomial space  [2.x.35]  As opposed to the basic FE_DGQ element, these elements are not interpolatory and no support points are defined.
*  Note that Hermite polynomials are only available for degrees larger or equal to three, and thus the beneficial properties of  [2.x.36]  with only two basis functions having a non-trivial value or derivative on a face per dimension is only present for higher degrees. To facilitate usage also for degrees zero to two, a usual Lagrange basis is constructed by this class.
*  See the base class documentation in FE_DGQ for details.

* 
* [0.x.31]*
   Constructor for tensor product polynomials based on    [2.x.37]   
* [0.x.32]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_DGQHermite<dim>(degree)</tt>, with <tt>dim</tt> and   <tt>degree</tt> replaced by the values given by the template parameter   and the argument passed to the constructor, respectively.  
* [0.x.33]

include/deal.II-translator/fe/fe_dg_vector_0.txt
[0.x.0]*
 DG elements based on vector valued polynomials.
*  These elements use vector valued polynomial spaces as they have been introduced for H<sup>div</sup> and H<sup>curl</sup> conforming finite elements, but do not use the usual continuity of these elements. Thus, they are suitable for DG and hybrid formulations involving these function spaces.
*  The template argument <tt>PolynomialType</tt> refers to a vector valued polynomial space like PolynomialsRaviartThomas or PolynomialsNedelec. Note that the dimension of the polynomial space and the argument <tt>dim</tt> must coincide.
* 

* 
*  [2.x.0] 

* 
* [0.x.1]*
   Constructor for the vector element of degree  [2.x.1]   
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns `FE_DGVector_` plus a piece of the name that is taken from what   the polynomial object returns, plus `<dim>(degree)`, with  [2.x.2]  and  [2.x.3]    replaced by appropriate values.  
* [0.x.3]*
   This function returns  [2.x.4]  if the shape function  [2.x.5]  has   non-zero function values somewhere on the face  [2.x.6]      For this element, we always return  [2.x.7]   
* [0.x.4]*
   Only for internal use. Its full name is  [2.x.8]    function and it creates the  [2.x.9]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.10]    FiniteElementData.  
* [0.x.5]*
   Fields of cell-independent data.     For information about the general purpose of this class, see the   documentation of the base class.  
* [0.x.6]*
     Array with shape function values in quadrature points. There is one row     for each shape function, containing values for each quadrature point.     Since the shape functions are vector-valued (with as many components as     there are space dimensions), the value is a tensor.         In this array, we store the values of the shape function in the     quadrature points on the unit cell. The transformation to the real     space cell is then simply done by multiplication with the Jacobian of     the mapping.    
* [0.x.7]*
     Array with shape function gradients in quadrature points. There is one     row for each shape function, containing values for each quadrature     point.         We store the gradients in the quadrature points on the unit cell. We     then only have to apply the transformation (which is a matrix-vector     multiplication) when visiting an actual cell.    
* [0.x.8]*
 A vector-valued DG element based on the polynomials space of FE_Nedelec. This class implements a "broken" finite element space that is discontinuous between cells and on each cell has shape functions that equal those of the Nedelec element.
*  The related class FE_DGRT is used in  [2.x.11] .

* 
*  [2.x.12] 

* 
* [0.x.9]*
   Constructor for the discontinuous N&eacute;d&eacute;lec element of degree    [2.x.13]   
* [0.x.10]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_DGNedelec<dim>(degree)</tt>, with  [2.x.14]  and  [2.x.15]    replaced by appropriate values.  
* [0.x.11]*
 A vector-valued DG element based on the polynomials space of FE_RaviartThomas. This class implements a "broken" finite element space that is discontinuous between cells and on each cell has shape functions that equal those of the Raviart-Thomas element.
*  The class is used in  [2.x.16] .
* 

* 
*  [2.x.17] 

* 
* [0.x.12]*
   Constructor for the Raviart-Thomas element of degree  [2.x.18]   
* [0.x.13]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_DGRaviartThomas<dim>(degree)</tt>, with  [2.x.19]  and  [2.x.20]    degree replaced by appropriate values.  
* [0.x.14]*
 A vector-valued DG element based on the polynomials space of FE_BDM. This class implements a "broken" finite element space that is discontinuous between cells and on each cell has shape functions that equal those of the BDM element.
*  The related class FE_DGRT is used in  [2.x.21] .
* 

* 
*  [2.x.22] 

* 
* [0.x.15]*
   Constructor for the discontinuous BDM element of degree  [2.x.23]   
* [0.x.16]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_DGBDM<dim>(degree)</tt>, with  [2.x.24]  and  [2.x.25]    replaced by appropriate values.  
* [0.x.17]

include/deal.II-translator/fe/fe_dg_vector.templates_0.txt
[0.x.0]

include/deal.II-translator/fe/fe_enriched_0.txt
[0.x.0]*
 Implementation of a partition of unity finite element method (PUM) by Babuska and Melenk which enriches a standard finite element with an enrichment function multiplied with another (usually linear) finite element: [1.x.0] where  [2.x.0]  and  [2.x.1]  are the underlying finite elements (including the mapping from the isoparametric element to the real element);  [2.x.2]  are the scalar enrichment functions in real space (e.g.  [2.x.3] ,  [2.x.4] , etc);  [2.x.5]  and  [2.x.6]  are the standard and enriched DoFs. This allows to include in the finite element space a priori knowledge about the partial differential equation being solved which in turn improves the local approximation properties of the spaces. This can be useful for highly oscillatory solutions, problems with domain corners or on unbounded domains or sudden changes of boundary conditions. PUM method uses finite element spaces which satisfy the partition of unity property (e.g. FE_Q). Among other properties this makes the resulting space to reproduce enrichment functions exactly.
*  The simplest constructor of this class takes two finite element objects and an enrichment function to be used. For example
* 

* 
* [1.x.1]
* 
*  In this case, standard DoFs are distributed by  [2.x.7] , whereas enriched DoFs are coming from a single finite element  [2.x.8]  used with a single enrichment function  [2.x.9] . In this case, the total number of DoFs on the enriched element is the sum of DoFs from  [2.x.10]  and  [2.x.11] .
*  As an example of an enrichment function, consider  [2.x.12] , which leads to the following shape functions on the unit element:  [2.x.13] 
*  Note that evaluation of gradients (hessians) of the enriched shape functions or the finite element field requires evaluation of gradients (gradients and hessians) of the enrichment functions:

* 
* [1.x.2]
* 
*  [1.x.3]
*  In most applications it is beneficial to introduce enrichments only in some part of the domain (e.g. around a crack tip) and use standard FE (e.g. FE_Q) elsewhere. This can be achieved by using the hp-finite element framework in deal.II that allows for the use of different elements on different cells. To make the resulting space  [2.x.14]  continuous, it is then necessary for the DoFHandler class and  [2.x.15]  function to be able to figure out what to do at the interface between enriched and non-enriched cells. Specifically, we want the degrees of freedom corresponding to enriched shape functions to be zero at these interfaces. These classes and functions can not to do this automatically, but the effect can be achieved by using not just a regular FE_Q on cells without enrichment, but to wrap the FE_Q into an FE_Enriched object [1.x.4]. This can be done as follows:

* 
* [1.x.5]
*  This constructor is equivalent to calling

* 
* [1.x.6]
*  and will result in the correct constraints for enriched DoFs attributed to support points on the interface between the two regions.
*  [1.x.7]
*  When using this class, please cite  [2.x.16]  . The PUM was introduced in  [2.x.17]  and  [2.x.18]  .
*  [1.x.8]
*  The implementation of the class is based on FESystem which is aggregated as a private member. The simplest constructor <code> FE_Enriched<dim> fe(FE_Q<dim>(2), FE_Q<dim>(1),function)</code> will internally initialize FESystem as
* 

* 
* [1.x.9]
* 
*  Note that it would not be wise to have this class derived from FESystem as the latter concatenates the given elements into different components of a vector element, whereas the current class combines the given elements into the same components. For instance, if two scalar elements are given, the resulting element will be scalar rather than have two components when doing the same with an FESystem.
*  The ordering of the shape function,  [2.x.19]  the  [2.x.20]  (embedding) and the  [2.x.21]  matrices are taken from the FESystem class.
* 

* 
*  [2.x.22] 

* 
* [0.x.1]*
   Constructor which takes base FiniteElement  [2.x.23]  and the enrichment   FiniteElement  [2.x.24]  which will be multiplied by the  [2.x.25]      In case  [2.x.26]  is other than FE_Nothing, the lifetime of the    [2.x.27]  must be at least as long as the FE_Enriched object.  
* [0.x.2]*
   Constructor which only wraps the base FE  [2.x.28]    As for the enriched finite element space, FE_Nothing is used.   Continuity constraints will be automatically generated when   this non-enriched element is used in conjunction with enriched finite   element within a DoFHandler with hp-capabilities.     See the discussion in the class documentation on how to use this element   in the context of hp-finite element methods.  
* [0.x.3]*
   Constructor which takes pointer to the base FiniteElement  [2.x.29]  and   a vector of enriched FiniteElement's  [2.x.30]  .  [2.x.31]    finite element will be enriched with functions in  [2.x.32]      This is the most general public constructor which also allows to have   different enrichment functions in different disjoint parts of the domain.   To that end the last argument provides an association of cell iterator   to a Function. This is done to simplify the usage of this class when the   number of disjoint domains with different functions is more than a few.   Otherwise one would have to use different instance of this class for each   disjoint enriched domain.     If you don't plan to use this feature, you can utilize C++11 lambdas to   define dummy functions. Below is an example which uses two functions with   the first element to be enriched and a single function with the second one.  
* [1.x.10]
*     
*  [2.x.33]  When using the same finite element for enrichment with N   different functions, it is advised to have the second argument of size 1   and the last argument of size 1 x N. The same can be achieved by providing   N equivalent enrichment elements while keeping the last argument of size   N x 1. However this will be much more computationally expensive.    
*  [2.x.34]  When using different enrichment functions on disjoint domains, no   checks are done by this class that the domains are actually disjoint.  
* [0.x.4]*
   The most general private constructor. The first two input parameters are   consistent with those in FESystem. It is used internally only with    [2.x.35] , which is a logical requirement for this   finite element.  
* [0.x.5]*
   Return a string that identifies a finite element.  
* [0.x.6]*
   Access to a composing element. The index needs to be smaller than the   number of base elements. In the context of this class, the number of   base elements is always more than one: a non-enriched element plus an   element to be enriched, which could be FE_Nothing.  
* [0.x.7]*
   Return the value of the  [2.x.36]  shape function at the point  [2.x.37]   [2.x.38]  is a   point on the reference element.     This function returns meaningful values only for non-enriched element as   real-space enrichment requires evaluation of the function at the point in   real-space.  
* [0.x.8]*
    [2.x.39]  Transfer matrices    [2.x.40]   
* [0.x.9]*
   Projection from a fine grid space onto a coarse grid space.     This function only makes sense when all child elements are also enriched   using the same function(s) as the parent element.  
* [0.x.10]*
   Embedding matrix between grids.     This function only makes sense when all child elements are also enriched   using the same function(s) as the parent element.  
* [0.x.11]*
    [2.x.41]  Functions to support hp    [2.x.42]   
* [0.x.12]*
   Return whether this element implements hp-constraints.     This function returns  [2.x.43]  if and only if all its base elements return  [2.x.44]    for this function.  
* [0.x.13]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Base elements of this element will have to implement this function. They   may only provide interpolation matrices for certain source finite   elements, for example those from the same family. If they don't implement   interpolation from a given element, then they must throw an exception of   type  [2.x.45]  which   will get propagated out from this element.  
* [0.x.14]*
   Return the matrix interpolating from a face of one element to the   subface of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Base elements of this element will have to implement this function. They   may only provide interpolation matrices for certain source finite   elements, for example those from the same family. If they don't implement   interpolation from a given element, then they must throw an exception of   type  [2.x.46]  which   will get propagated out from this element.  
* [0.x.15]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.47]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.  
* [0.x.16]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.  
* [0.x.17]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on quads.  
* [0.x.18]*
    [2.x.48]   [2.x.49]   
* [0.x.19]*
   Return enrichment functions  
* [0.x.20]*
   Return the underlying FESystem object.  
* [0.x.21]*
   A class to hold internal data needed for evaluation of this FE at   quadrature points.  
* [0.x.22]*
     For each Finite Element (base number) and each enrichment function     (base_index) this struct will contain values, gradients and hessians of     the enrichment functions.    
* [0.x.23]*
     Constructor. Is used inside setup_data to wrap FESystem's internal     data object. The former is called from get_data, get_subface_data and     get_face_data which FE_Enriched has to implement.         Since  [2.x.50]   [2.x.51]  and      [2.x.52]  just create an object and return a pointer     to it (i.e. they don't retain ownership), we store the cast result in a      [2.x.53]  to indicate that InternalData owns the object.    
* [0.x.24]*
     Give read-access to the pointer to a  [2.x.54]  of the  [2.x.55]       [2.x.56] th base element of FESystem's data.    
* [0.x.25]*
     Give read-access to the pointer to an object into which the      [2.x.57] th base element will write its output when calling      [2.x.58]  and similar functions.    
* [0.x.26]*
     Aggregate FESystem's internal data. It is used every time     we call FESystem's fill_fe_values() and alike.    
* [0.x.27]*
     For each FE used in enrichment (base number  [2.x.59] ) and each     enrichment function (base multiplicity  [2.x.60] ),      [2.x.61]  will be used to store possibly     requested values, gradients and hessians of enrichment function      [2.x.62] .         The variable is made mutable as InternalData's provided to fill_fe_values     and alike are const.        
*  [2.x.63]  We do not want to store this information in the finite element object itself,     because this would mean that (i) only one FEValues object could use a     finite element object at a time, and (ii) that these objects could not be     used in a multithreaded context.    
* [0.x.28]*
   For each finite element  [2.x.64]  used in enrichment and each enrichment function    [2.x.65]  associated with it (essentially its multiplicity),    [2.x.66]  contains the associated local   DoFs on the FE_Enriched finite element.  
* [0.x.29]*
   Enrichment functions.   The size of the first vector is the same as the number of FiniteElement   spaces used with enrichment. Whereas the size of the inner vector   corresponds to the number of enrichment functions associated with a single   FiniteElement.  
* [0.x.30]*
   Auxiliary variable used to distinguish between the case when we do   enrichment and when the class simply wraps another FiniteElement.     This variable is initialized in the constructor by looping over a vector of   enrichment elements and checking if all of them are FE_Nothing. If this is   the case, then the value is set to  [2.x.67] , otherwise it is    [2.x.68] .  
* [0.x.31]*
   Auxiliary function called from get_data, get_face_data and   get_subface_data. It take internal data of FESystem object in  [2.x.69]    and the quadrature rule  [2.x.70]      This function essentially take the internal data from an instance of   FESystem class and wraps it into our own InternalData class which   additionally has objects to hold values/gradients/hessians of   enrichment functions at each quadrature point depending on  [2.x.71]   
* [0.x.32]*
   Prepare internal data structures and fill in values independent of the   cell. Returns a pointer to an object of which the caller of this function   (FEValues) then has to assume ownership (which includes destruction when it   is no more needed).  
* [0.x.33]*
   This function sets up the index table for the system as well as  [2.x.72]    restriction and  [2.x.73]  matrices.  
* [0.x.34]*
   The underlying FESystem object.  
* [0.x.35]*
   After calling fill_fe_(face/subface_)values this function   implements the chain rule to multiply stored shape values/gradient/hessians   by those of enrichment function evaluated at quadrature points.  
* [0.x.36]*
 This namespace consists of a class needed to create a collection of FE_Enriched finite elements  [2.x.74]  to be used with DoFHandler in hp-mode on a domain with multiple, possibly overlapping, sub-domains with individual enrichment functions.
*  To create  [2.x.75]  a graph coloring algorithm is used to assign colors to enrichment functions before creating  [2.x.76]  Hence the name.

* 
* [0.x.37]*
   An alias template for predicate function which returns a   boolean for a  [2.x.77]  object.     This is used by helper functions and in the implementation of    [2.x.78]  class.  
* [0.x.38]*
     Returns true if there is a connection between subdomains in the mesh     associated with  [2.x.79]  i.e., if the subdomains share at least     a vertex. The two subdomains are defined by predicates provided by      [2.x.80]  and  [2.x.81]  A predicate is a function (or     object of a type with an operator()) which takes in a cell iterator and     gives a boolean. It is said to be active in a cell if it returns true.         An example of a custom predicate is one that checks the distance from a     fixed point. Note that the operator() takes in a cell iterator. Using the     constructor, the fixed point and the distance can be chosen.    
* [1.x.11]
*      and then the function can be used as follows to find if the subdomains     are connected.    
* [1.x.12]
*           [2.x.82]  dof_handler DoFHandler object      [2.x.83]  predicate_1 A function (or object of a type with an     operator()) defining the subdomain 1. The function takes in a cell and     returns a boolean.      [2.x.84]  predicate_2 Same as  [2.x.85]  but defines subdomain 2.      [2.x.86]  A boolean "true" if the subdomains share at least a vertex.    
* [0.x.39]*
     Assign colors to subdomains using Graph coloring algorithm where each     subdomain is considered as a graph node. Subdomains which are     connected i.e share at least a vertex have different color. Each     subdomain     is defined using a predicate function of  [2.x.87]           [2.x.88]  dof_handler a DoFHandler object      [2.x.89]  predicates predicates defining the subdomains      [2.x.90]  predicate_colors Colors (unsigned int) associated with each     subdomain.    
* [0.x.40]*
     Used to construct data members  [2.x.91]  and      [2.x.92]  of Helper class. Inputs are DoFHandler object,     vector of predicates and colors associated with them. Before calling     this function, colors can be assigned to predicates (i.e subdomains)     using the function color_predicates.         Each active FE index has a set of colors associated with it.     A cell with an active FE index i has a set of colors given by      [2.x.93] . An active FE index with color {a,b}     means that the cell has two active predicates (i.e they return true     for the cell) of color a and b.         Eg: fe_sets = { {}, {1}, {2}, {1,2} } means     Cells with active FE index 0 have no predicates associated.     Cells with index 1 have a active predicate with color 1.     Cells with index 2 have a active predicate with color 2.     Cells with index 3 have active predicates with color 1 and color 2.         A map of maps cellwise_color_predicate_map is used to associate     predicate colors in cells with predicate ids. For this purpose, each     cell is given a unique id which is stored in material id for now.     When the grid is refined, material id is inherited to the children, so     map which associates material id with color map will still be relevant.         Now the color map can be explained with an example. If the cell with     material id 100 has active predicates 4 (color = 1) and 5 (color = 2),     the map will insert pairs (1, 4) and (2, 5) at key 100 (i.e unique id     of cell is mapped with a map which associates color with predicate id).          [2.x.94]  dof_handler DoFHandler object      [2.x.95]  predicates vector of predicates defining the subdomains.      [2.x.96]  returns true for a cell if it     belongs to subdomain with index i.      [2.x.97]  predicate_colors vector of colors (unsigned int) associated     with each subdomain.      [2.x.98]  cellwise_color_predicate_map A map of maps used to associate     predicate colors in cells with predicate ids.      [2.x.99]  fe_sets a vector of color lists    
* [0.x.41]*
     A function that returns a vector of enrichment functions corresponding     to a color. The size of the vector is equal to total number of different     colors associated with predicates (i.e subdomains).         Assume that a cell has a active predicates with ids 4 (color = 1) and     5 (color = 2). cellwise_color_predicate_map has this information     provided we know the material id.         The constructed color_enrichments is such that     color_enrichments[color=1](cell) will return a pointer to     the enrichment function with id=4, i.e. enrichments[4].     In other words, using the previously collected information in     this function we translate a vector of user provided enrichment     functions into a vector of functions suitable for FE_Enriched class.          [2.x.100]  n_colors number of colors for predicates      [2.x.101]  enrichments vector of enrichment functions      [2.x.102]  cellwise_color_predicate_map A map of maps used to associate     predicate colors in cells with predicate ids.      [2.x.103]  color_enrichments A vector of functions that take in cell     and return a function pointer.    
* [0.x.42]*
     Creates a  [2.x.104]  object constructed using FE_Enriched     elements which itself is constructed using color enrichment functions     and is of size equal to number of colors.          [2.x.105]  fe_sets a vector of color lists      [2.x.106]  color_enrichments A vector of functions that take in cell     and return a function pointer.      [2.x.107]  fe_base base FiniteElement      [2.x.108]  fe_enriched enriched FiniteElements      [2.x.109]  fe_nothing a finite element with zero degrees of freedom      [2.x.110]  fe_collection a collection of     finite elements    
* [0.x.43]*
    [2.x.111]  class creates a collection of FE_Enriched finite   elements  [2.x.112]  to be used with DoFHandler in a domain   with multiple, possibly overlapping, sub-domains with individual   enrichment functions. Note that the overlapping regions may have   multiple enrichment functions associated with them. This is implemented   using a general constructor of FE_Enriched object which allows different   enrichment functions.     Consider a domain with multiple enriched sub-domains   which are disjoint i.e. not connected with each other.   To ensure  [2.x.113]  continuity at the interface between   the enriched sub-domain (characterized by a single enrichment   function) and the non-enriched domain, we can use an FE_Enriched   object in the enriched sub-domain and in the non-enriched domain   a standard finite element (eg: FE_Q) wrapped into an FE_Enriched   object (which internally uses a dominating FE_Nothing object).   Refer to the documentation on FE_Enriched for more   information on this. It is to be noted that an FE_Enriched   object is constructed using a base FE   (FiniteElement objects) and one or more   enriched FEs. FE_Nothing is a dummy enriched FE.     The situation becomes more   complicated when two enriched sub-domains   share an interface. When the number of enrichment functions are   same for the sub-domains, FE_Enriched object of one sub-domain   is constructed such that each enriched FE is paired (figuratively) with a   FE_Nothing in the FE_Enriched object of the other sub-domain.   For example, let the FEs fe_enr1 and fe_enr2, which will be   used with enrichment functions, correspond   to the two sub-domains. Then the FE_Enriched objects of the two   sub-domains are built using   [fe_base, fe_enr1, fe_nothing] and   [fe_base, fe_nothing, fe_enr2] respectively.   Note that the size of the vector of enriched FEs   (used in FE_Enriched constructor) is equal to 2, the   same as the number of enrichment functions. When the number of enrichment   functions is not the same, additional enriched FEs are paired   with FE_Nothing. This ensures that the enriched DOF's at the interface   are set to zero by the  [2.x.114]  function.   Using these two strategies, we construct the appropriate FE_Enriched   using the general constructor. Note that this is   done on a mesh without hanging nodes.     Now consider a domain with multiple sub-domains which may share   an interface with each other. As discussed previously,   the number of enriched FEs in the FE_Enriched object of each   sub-domain needs to be equal to the number of sub-domains. This is because   we are not using the information of how the domains are connected   and any sub-domain may share interface with any other sub-domain (not   considering overlaps for now!). However, in general, a given sub-domain   shares an interface only with a few sub-domains. This warrants   the use of a graph coloring algorithm to reduce   the size of the vector of enriched FEs   (used in the FE_Enriched constructor). By giving the sub-domains   that share no interface the same color, a single  [2.x.115]    that returns different enrichment functions for each   sub-domain can be constructed. Then the size of the vector of enriched   FEs is equal to the number of different colors   used for predicates (or sub-domains).    
*  [2.x.116]  The graph coloring function,  [2.x.117]    used for assigning colors to the sub-domains   needs MPI (use  [2.x.118]  to initialize MPI   and the necessary Zoltan setup).   The coloring function, based on Zoltan, is a parallel coloring   algorithm but is used in serial by  [2.x.119]      Construction of the Helper class needs a base FiniteElement  [2.x.120]    an enriched FiniteElement  [2.x.121]  (used for all the   enrichment functions), a vector of predicate   functions (used to define sub-domains) as well as the corresponding   enrichment functions. The FECollection object, a collection of FE_Enriched   objects to be used with a DoFHandler object, can be retrieved   using the member function build_fe_collection which also modifies the   active FE indices of the DoFHandler object (provided as an argument   to the build_fe_collection function).     [1.x.13]   Consider a domain with three sub-domains defined by predicate functions.   Different cells are associated with FE indices as shown in the following   image. The three equal-sized square-shaped sub-domains 'a', 'b'   and 'c' can be seen. The predicates associated with these sub-domains   are also labeled 'a', 'b' and 'c'.   The subdomains 'a' and 'b' intersect with cell labeled with FE   index 3. The cells in 'c' are labeled with FE   index 1. As can be seen, connections exist between 'a' and 'b',   'b' and 'c' but 'a' and 'c' are not connected.     \htmlonly <style>div.image   img[src="3source_fe_indices.png"]{width:25%;}</style> \endhtmlonly    [2.x.122]      As discussed before, the colors of predicates are allotted using   the graph coloring algorithm. Each predicate is a node in the graph and if   two sub-domains share an interface, the corresponding predicates   should be given different colors.   (The predicate colors are different from what is shown   in the image. The colors in the image are as per FE indices).   Predicates 'a' and 'c' can be given the same color since they   are not connected but the color given to 'b' has to be different from   'a' and 'c'.     The name of finite element at an index (i) of  [2.x.123]     [2.x.124]  can be obtained by    [2.x.125]  and is   show in the table below. Note that all the FE_Enriched elements   are of the same size and FE_Nothing<2>(dominating) is used as   discussed before.      [2.x.126]      The internal data members used by this class need to be available when the   problem is solved. This can be ensured by declaring the object static,   which is deallocated only when the program terminates. An alternative   would be to use it as a data member of the containing class. Since vector   of predicates and enrichment functions may not be available while   constructing the Helper, a  [2.x.127]  to Helper object can be used   and constructed when the predicates and enrichment functions are   available.      [2.x.128]  The current implementation relies on assigning each cell a   material id, which shall not be modified after the setup   and h-adaptive refinement. For a given cell, the material id is used   to define color predicate map, which doesn't change with refinement.     [1.x.14]  
* [1.x.15]
*   
* [0.x.44]*
     Constructor for Helper class.          [2.x.129]  fe_base A base FiniteElement      [2.x.130]  fe_enriched An enriched FiniteElement      [2.x.131]  predicates  [2.x.132]  of predicates defining the sub-domains.      [2.x.133]  returns true for a cell if it     belongs to a sub-domain with index (i).      [2.x.134]  enrichments  [2.x.135]  of enrichment functions    
* [0.x.45]*
     Prepares a DoFHandler object. The active FE indices of     mesh cells are initialized to work with      [2.x.136]           [2.x.137]  dof_handler a DoFHandler object      [2.x.138]   [2.x.139]  a collection of     finite elements needed by  [2.x.140]     
* [0.x.46]*
     Contains a collection of FiniteElement objects needed by a DoFHandler     object.    
* [0.x.47]*
     A base FiniteElement used for constructing FE_Enriched     object required by  [2.x.141]     
* [0.x.48]*
     An enriched FiniteElement used for constructing FE_Enriched     object required by  [2.x.142]     
* [0.x.49]*
     A finite element with zero degrees of freedom used for     constructing FE_Enriched object required by      [2.x.143]     
* [0.x.50]*
      [2.x.144]  of predicates defining the sub-domains.      [2.x.145]  returns true for a cell if it     belongs to a sub-domain with index (i).    
* [0.x.51]*
      [2.x.146]  of enrichment functions corresponding     to the predicates. These are needed while constructing      [2.x.147]     
* [0.x.52]*
     An alias template for any callable target such as functions, lambda     expressions, function objects that take a      [2.x.148]      and return a pointer to Function<dim>. This is used to define      [2.x.149]      which returns an enrichment function     for a cell in Triangulation<dim,spacedim>.    
* [0.x.53]*
      [2.x.150]  of functions that take in a cell     and return a function pointer. These are needed while constructing     fe_collection.         color_enrichments[i](cell_iterator) returns a pointer to     the correct enrichment function (i.e. whose corresponding     predicate has the color i) for the cell.    
* [0.x.54]*
      [2.x.151]  of colors (unsigned int) associated     with each sub-domain. No two connected sub-domains (i.e. sub-domains that     share a vertex) have the same color.    
* [0.x.55]*
     Total number of different colors in predicate_colors    
* [0.x.56]*
     A map of maps used to associate     a cell with a map that in turn associates colors of active predicates in     the cell with corresponding predicate ids.    
* [0.x.57]*
     A vector of different possible color sets for a given set of     predicates and DoFHandler object    
* [0.x.58]

include/deal.II-translator/fe/fe_face_0.txt
[0.x.0]*
 A finite element that is a tensor product polynomial on each face and undefined in the interior of the cells. The basis functions on the faces are Lagrange polynomials based on the support points of the (dim-1)-dimensional Gauss--Lobatto quadrature rule. For element degree one and two, the polynomials hence correspond to the usual Lagrange polynomials on equidistant points.
*  Although the name does not give it away, the element is discontinuous at locations where faces of cells meet. In particular, this finite element is the trace space of FE_RaviartThomas on the faces and serves in hybridized methods, e.g. in combination with the FE_DGQ element. Its use is demonstrated in the  [2.x.0]  tutorial program.
* 

* 
*  [2.x.1]  Since this element is defined only on faces, only FEFaceValues and FESubfaceValues will provide useful information. On the other hand, if you use this element with FEValues for cell integration, then the values and derivatives of shape functions will have invalid values and will not likely produce anything useful. In order to make the use of this element as part of an FESystem simpler, using a (cell) FEValues object will not fail outright, but those components of shape functions of the combined element that correspond to FE_FaceQ will have the invalid values mentioned above.
* 

* 
*  [2.x.2] 

* 
* [0.x.1]*
   Constructor for tensor product polynomials of degree <tt>p</tt>. The   shape functions created using this constructor correspond to Lagrange   polynomials in each coordinate direction.  
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_FaceQ<dim>(degree)</tt>, with <tt>dim</tt> and   <tt>degree</tt> replaced by appropriate values.  
* [0.x.3]*
   Implementation of the corresponding function in the FiniteElement   class.  Since the current element is interpolatory, the nodal   values are exactly the support point values. Furthermore, since   the current element is scalar, the support point values need to   be vectors of length 1.  
* [0.x.4]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>. This   element only provides interpolation matrices for elements of the same   type and FE_Nothing. For all other elements, an exception of type    [2.x.3]  is thrown.  
* [0.x.5]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>. This   element only provides interpolation matrices for elements of the same   type and FE_Nothing. For all other elements, an exception of type    [2.x.4]  is thrown.  
* [0.x.6]*
   This function returns  [2.x.5]  if the shape function  [2.x.6]  has   non-zero function values somewhere on the face  [2.x.7]   
* [0.x.7]*
    [2.x.8]  Functions to support hp    [2.x.9]   
* [0.x.8]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.10]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.     The set of such constraints is non-empty only for dim==1.  
* [0.x.9]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.     The set of such constraints is non-empty only for dim==2.  
* [0.x.10]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on quads.     The set of such constraints is non-empty only for dim==3.  
* [0.x.11]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".  
* [0.x.12]*
    [2.x.11]   [2.x.12]   
* [0.x.13]*
    [2.x.13]   
* [0.x.14]*
   Return a list of constant modes of the element. For this element, it   simply returns one row with all entries set to true.  
* [0.x.15]*
   Return vector with dofs per vertex, line, quad, hex.  
* [0.x.16]*
 Specialization of FE_FaceQ for 1D. In that case, the finite element only consists of one degree of freedom in each of the two faces (= vertices) of a cell, irrespective of the degree. However, this element still accepts a degree in its constructor and also returns that degree. This way, dimension-independent programming with trace elements is also possible in 1D (even though there is no computational benefit at all from it in 1D).
* 

* 
*  [2.x.14] 

* 
* [0.x.17]*
   Constructor.  
* [0.x.18]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_FaceQ<dim>(degree)</tt>, with <tt>dim</tt> and   <tt>degree</tt> replaced by appropriate values.  
* [0.x.19]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>. This   element only provides interpolation matrices for elements of the same   type and FE_Nothing. For all other elements, an exception of type    [2.x.15]  is thrown.  
* [0.x.20]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>. This   element only provides interpolation matrices for elements of the same   type and FE_Nothing. For all other elements, an exception of type    [2.x.16]  is thrown.  
* [0.x.21]*
   This function returns  [2.x.17]  if the shape function  [2.x.18]  has   non-zero function values somewhere on the face  [2.x.19]   
* [0.x.22]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".  
* [0.x.23]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.20]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.     The set of such constraints is non-empty only for dim==1.  
* [0.x.24]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.     The set of such constraints is non-empty only for dim==2.  
* [0.x.25]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on quads.     The set of such constraints is non-empty only for dim==3.  
* [0.x.26]*
   Return a list of constant modes of the element. For this element, it   simply returns one row with all entries set to true.  
* [0.x.27]   NOTE: The following functions have their definitions inlined into the class   declaration because we otherwise run into a compiler error with MS Visual   Studio.  
* [0.x.28]*
   Return vector with dofs per vertex, line, quad, hex.  
* [0.x.29]*
 A finite element that is a Legendre element of complete polynomials on each face (i.e., it is the face equivalent of what FE_DGP is on cells) and undefined in the interior of the cells. The basis functions on the faces are from  [2.x.21] 
*  Although the name does not give it away, the element is discontinuous at locations where faces of cells meet. The element serves in hybridized methods, e.g. in combination with the FE_DGP element. An example of hybridizes methods can be found in the  [2.x.22]  tutorial program.
* 

* 
*  [2.x.23]  Since this element is defined only on faces, only FEFaceValues and FESubfaceValues will provide useful information. On the other hand, if you use this element with FEValues for cell integration, then the values and derivatives of shape functions will have invalid values and will not likely produce anything useful. In order to make the use of this element as part of an FESystem simpler, using a (cell) FEValues object will not fail outright, but those components of shape functions of the combined element that correspond to FE_FaceP will have the invalid values mentioned above.
* 

* 
*  [2.x.24] 

* 
* [0.x.30]*
   Constructor for complete basis of polynomials of degree <tt>p</tt>. The   shape functions created using this constructor correspond to Legendre   polynomials in each coordinate direction.  
* [0.x.31]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_FaceP<dim>(degree)</tt> , with <tt>dim</tt> and   <tt>degree</tt> replaced by appropriate values.  
* [0.x.32]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>. This   element only provides interpolation matrices for elements of the same   type and FE_Nothing. For all other elements, an exception of type    [2.x.25]  is thrown.  
* [0.x.33]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>. This   element only provides interpolation matrices for elements of the same   type and FE_Nothing. For all other elements, an exception of type    [2.x.26]  is thrown.  
* [0.x.34]*
   This function returns  [2.x.27]  if the shape function  [2.x.28]  has   non-zero function values somewhere on the face  [2.x.29]   
* [0.x.35]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".  
* [0.x.36]*
    [2.x.30]   [2.x.31]   
* [0.x.37]*
   Return a list of constant modes of the element. For this element, the   first entry on each face is true, all other are false (as the constant   function is represented by the first base function of Legendre   polynomials).  
* [0.x.38]*
   Return vector with dofs per vertex, line, quad, hex.  
* [0.x.39]*
 FE_FaceP in 1D, i.e., with degrees of freedom on the element vertices. See the documentation of the general template for more information.

* 
* [0.x.40]*
   Constructor.  
* [0.x.41]*
   Return the name of the element  
* [0.x.42]

include/deal.II-translator/fe/fe_interface_values_0.txt
[0.x.0]*
 Namespace for views you get from accessing FEInterfaceValues using an extractor.

* 
* [0.x.1]*
   The base class for the views.  
* [0.x.2]*
     The constructor.   
* [0.x.3]*
     Store a pointer to the FEInterfaceValues instance.    
* [0.x.4]*
   The view of a scalar variable for FEInterfaceValues.  
* [0.x.5]*
     This is the type returned for values.    
* [0.x.6]*
     This is the type returned for gradients, for example from     average_gradient().    
* [0.x.7]*
     This is the type returned for hessians, for example from jump_hessian().    
* [0.x.8]*
     This is the type returned for third derivatives, for example from     jump_hessian().    
* [0.x.9]*
     Constructor for an object that represents a single scalar component    
* [0.x.10]*
     Return the value of the shape function     with interface dof index  [2.x.0]  in     quadrature point  [2.x.1]  of the component selected by this view.         The argument  [2.x.2]  selects between the upstream value and     the downstream value as defined by the direction of the normal vector     in this quadrature point. If  [2.x.3]  is true, the shape     functions from the first cell of the interface is used.         In other words, this function returns the limit of the value of the shape     function in the given quadrature point when approaching it from one of     the two cells of the interface.        
*  [2.x.4]  This function is typically used to pick the upstream or downstream     value based on a direction. This can be achieved by using      [2.x.5]  as the first argument of this     function.    
* [0.x.11]*
     Return the jump  [2.x.6]  on the interface for the shape     function      [2.x.7]  in the quadrature point  [2.x.8]      of the component selected by this view.    
* [0.x.12]*
     Return the average value  [2.x.9]  on the     interface for the shape     function  [2.x.10]  in the quadrature point  [2.x.11]      of the component selected by this view.    
* [0.x.13]*
     Return the average of the gradient  [2.x.12]  on the interface     for the shape     function  [2.x.13]  in the quadrature point  [2.x.14]      of the component selected by this view.    
* [0.x.14]*
     Return the jump of the gradient  [2.x.15]  on the interface for     the shape     function  [2.x.16]  in the quadrature point  [2.x.17]      of the component selected by this view.    
* [0.x.15]*
     Return the average of the Hessian  [2.x.18]  on the interface     for the shape function  [2.x.19]  at the quadrature point  [2.x.20]      q_point of the component selected by this view.    
* [0.x.16]*
     Return the jump in the gradient  [2.x.21]  on the interface for the shape function  [2.x.22]      interface_dof_index at the quadrature point  [2.x.23]  of     the component selected by this view.    
* [0.x.17]*
     Return the jump in the third derivative  [2.x.24]  on the interface for the     shape function  [2.x.25]  at the quadrature point  [2.x.26]  of     the component selected by this view.    
* [0.x.18]*
     The extractor for this view.    
* [0.x.19]*
   The view of a vector-valued variable for FEInterfaceValues.  
* [0.x.20]*
     This is the type returned for values.    
* [0.x.21]*
     This is the type returned for gradients, for example from     average_gradient().    
* [0.x.22]*
     An alias for the type of second derivatives of the view this class     represents. Here, for a set of  [2.x.27]  components of the     finite element, the Hessian is a  [2.x.28] .    
* [0.x.23]*
     An alias for the type of third derivatives of the view this class     represents. Here, for a set of  [2.x.29]  components of the     finite element, the third derivative is a  [2.x.30] .    
* [0.x.24]*
     Constructor for an object that represents a vector component    
* [0.x.25]*
     Return the value of the vector components selected by this view     with interface dof index  [2.x.31]  in     quadrature point  [2.x.32]          The argument  [2.x.33]  selects between the upstream value and     the downstream value as defined by the direction of the normal vector     in this quadrature point. If  [2.x.34]  is true, the shape     functions from the first cell of the interface is used.         In other words, this function returns the limit of the value of the shape     function in the given quadrature point when approaching it from one of     the two cells of the interface.        
*  [2.x.35]  This function is typically used to pick the upstream or downstream     value based on a direction. This can be achieved by using      [2.x.36]  as the first argument of this     function.    
* [0.x.26]*
     Return the jump vector  [2.x.37]  on the     interface for the shape function      [2.x.38]  in the quadrature point  [2.x.39]     
* [0.x.27]*
     Return the average vector  [2.x.40]  on the interface for the shape     function  [2.x.41]  in the quadrature point  [2.x.42]     
* [0.x.28]*
     Return the average of the gradient (a tensor of rank 2)  [2.x.43]  on the interface for the shape     function  [2.x.44]  in the quadrature point  [2.x.45]     
* [0.x.29]*
     Return the jump of the gradient (a tensor of rank 2)  [2.x.46]  on the interface for the shape     function  [2.x.47]  in the quadrature point  [2.x.48]     
* [0.x.30]*
     Return the average of the Hessian  [2.x.49]  on the interface     for the shape function  [2.x.50]  at the quadrature point  [2.x.51]      q_point of the component selected by this view.    
* [0.x.31]*
     Return the jump in the gradient  [2.x.52]  on the interface for the shape function  [2.x.53]      interface_dof_index at the quadrature point  [2.x.54]  of     the component selected by this view.    
* [0.x.32]*
     Return the jump in the third derivative  [2.x.55]  on the interface for the     shape function  [2.x.56]  at the quadrature point  [2.x.57]  of     the component selected by this view.    
* [0.x.33]*
     The extractor for this view.    
* [0.x.34]*
 FEInterfaceValues is a data structure to access and assemble finite element data on interfaces between two cells of a mesh.
*  It provides a way to access averages, jump terms, and similar operations used in Discontinuous Galerkin methods on a face between two neighboring cells. This allows the computation of typical mesh-dependent linear or bilinear forms in a similar way as FEValues does for cells and FEFaceValues does for faces. In the literature, the faces between neighboring cells are called "inner interfaces" or "facets".
*  Internally, this class provides an abstraction for two FEFaceValues objects (or FESubfaceValues when using adaptive refinement). The class introduces a new "interface dof index" that walks over the union of the dof indices of the two FEFaceValues objects. Helper functions allow translating between the new "interface dof index" and the corresponding "cell index" (0 for the first cell, 1 for the second cell) and "dof index" within that cell.
*  The class is made to be used inside  [2.x.58]  It is intended to be a low level replacement for MeshWorker and LocalIntegrators and a higher level abstraction compared to assembling face terms manually.

* 
* [0.x.35]*
   Number of quadrature points.  
* [0.x.36]*
   Construct the FEInterfaceValues with a single FiniteElement (same on both   sides of the facet). The FEFaceValues objects will be initialized with   the given  [2.x.59]   [2.x.60]  and  [2.x.61]   
* [0.x.37]*
   The same as above but taking a collection of quadrature rules   so that different quadrature rules can be assigned to different   faces.  
* [0.x.38]*
   Construct the FEInterfaceValues with a single FiniteElement and   a Q1 Mapping.     See the constructor above.  
* [0.x.39]*
   Re-initialize this object to be used on a new interface given by two faces   of two neighboring cells. The `cell` and `cell_neighbor` cells will be   referred to through `cell_index` zero and one after this call in all places   where one needs to identify the two cells adjacent to the interface.     Use  [2.x.62]  for  [2.x.63]  or  [2.x.64]    sub_face_no_neighbor to indicate that you want to work on the entire face,   not a sub-face.     The arguments (including their order) are identical to the  [2.x.65]    arguments in  [2.x.66]       [2.x.67]  cell An iterator to the first cell adjacent to the interface.    [2.x.68]  face_no An integer identifying which face of the first cell the     interface is on.    [2.x.69]  sub_face_no An integer identifying the subface (child) of the     face (identified by the previous two arguments) that the interface     corresponds to. If equal to  [2.x.70]  then the     interface is considered to be the entire face.    [2.x.71]  cell_neighbor An iterator to the second cell adjacent to     the interface. The type of this iterator does not have to equal that     of `cell`, but must be convertible to it. This allows using an     active cell iterator for `cell`, and `cell->neighbor(f)` for     `cell_neighbor`, since the return type of `cell->neighbor(f)` is     simply a cell iterator (not necessarily an active cell iterator).    [2.x.72]  face_no_neighbor Like `face_no`, just for the neighboring     cell.    [2.x.73]  sub_face_no_neighbor Like `sub_face_no`, just for the     neighboring cell.  
* [0.x.40]*
   Re-initialize this object to be used on an interface given by a single face    [2.x.74]  of the cell  [2.x.75]  This is useful to use FEInterfaceValues   on boundaries of the domain.     As a consequence, members like jump() will assume a value of zero for the   values on the "other" side. Note that no sub_face_number is needed as a   boundary face can not neighbor a finer cell.     After calling this function at_boundary() will return true.  
* [0.x.41]*
   Return a reference to the FEFaceValues or FESubfaceValues object   of the specified cell of the interface.     The  [2.x.76]  is either 0 or 1 and corresponds to the cell index   returned by interface_dof_to_cell_and_dof_index().  
* [0.x.42]*
   Constant reference to the selected mapping object.  
* [0.x.43]*
   Constant reference to the selected finite element object.  
* [0.x.44]*
   Return a reference to the quadrature object in use.  
* [0.x.45]*
   Return the update flags set.  
* [0.x.46]*
    [2.x.77]  Functions to query information on a given interface    [2.x.78]   
* [0.x.47]*
   Return if the current interface is a boundary face or an internal   face with two adjacent cells.     See the corresponding reinit() functions for details.  
* [0.x.48]*
   Mapped quadrature weight. This value equals the   mapped surface element times the weight of the quadrature   point.     You can think of the quantity returned by this function as the   surface element  [2.x.79]  in the integral that we implement here by   quadrature.      [2.x.80]   
* [0.x.49]*
   Return the vector of JxW values for each quadrature point.      [2.x.81]   
* [0.x.50]*
   Return the normal vector of the interface in each quadrature point.     The return value is identical to get_fe_face_values(0).get_normal_vectors()   and therefore, are outside normal vectors from the perspective of the   first cell of this interface.      [2.x.82]   
* [0.x.51]*
   Return a reference to the quadrature points in real space.      [2.x.83]   
* [0.x.52]*
   Return the number of DoFs (or shape functions) on the current interface.    
*  [2.x.84]  This number is only available after a call to reinit() and can change   from one call to reinit() to the next. For example, on a boundary interface   it is equal to the number of dofs of the single FEFaceValues object, while   it is twice that for an interior interface for a DG element. For a   continuous element, it is slightly smaller because the two cells on the   interface share some of the dofs.  
* [0.x.53]*
   Return the set of joint DoF indices. This includes indices from both cells.   If reinit was called with an active cell iterator, the indices are based   on the active indices (returned by  [2.x.85]  ),   in case of level cell (that is, if is_level_cell() return true )   the mg dof indices are returned.    
*  [2.x.86]  This function is only available after a call to reinit() and can   change from one call to reinit() to the next.  
* [0.x.54]*
   Convert an interface dof index into the corresponding local DoF indices of   the two cells. If an interface DoF is only active on one of the   cells, the other index will be  [2.x.87]      For discontinuous finite elements each interface dof will correspond to   exactly one DoF index.    
*  [2.x.88]  This function is only available after a call to reinit() and can   change from one call to reinit() to the next.  
* [0.x.55]*
   Return the normal in a given quadrature point.     The normal points in outwards direction as seen from the first cell of   this interface.      [2.x.89]   
* [0.x.56]*
    [2.x.90]   
* [0.x.57]*
    [2.x.91]  Functions to evaluate data of the shape functions    [2.x.92]   
* [0.x.58]*
   Return component  [2.x.93]  of the value of the shape function   with interface dof index  [2.x.94]  in   quadrature point  [2.x.95]      The argument  [2.x.96]  selects between the value on cell 0 (here,  [2.x.97]    and cell 1 (there,  [2.x.98]  You can also interpret it as "upstream" ( [2.x.99]    and "downstream" ( [2.x.100]  as defined by the direction of the normal   vector   in this quadrature point. If  [2.x.101]  is true, the shape   functions from the first cell of the interface is used.     In other words, this function returns the limit of the value of the shape   function in the given quadrature point when approaching it from one of the   two cells of the interface.    
*  [2.x.102]  This function is typically used to pick the upstream or downstream   value based on a direction. This can be achieved by using    [2.x.103]  as the first argument of this   function.  
* [0.x.59]*
   Return the jump  [2.x.104]  on the   interface   for the shape function  [2.x.105]  at the quadrature point    [2.x.106]  of component  [2.x.107]      Note that one can define the jump in   different ways (the value "there" minus the value "here", or the other way   around; both are used in the finite element literature). The definition   here uses "value here minus value there", as seen from the first cell.     If this is a boundary face (at_boundary() returns true), then    [2.x.108] .  
* [0.x.60]*
   Return the average  [2.x.109]  on the interface   for the shape function  [2.x.110]  at the quadrature point    [2.x.111]  of component  [2.x.112]      If this is a boundary face (at_boundary() returns true), then    [2.x.113] .  
* [0.x.61]*
   Return the average of the gradient  [2.x.114]  on the interface   for the shape function  [2.x.115]  at the quadrature point  [2.x.116]    q_point of component  [2.x.117]      If this is a boundary face (at_boundary() returns true), then    [2.x.118] .  
* [0.x.62]*
   Return the average of the Hessian  [2.x.119]  on the interface   for the shape function  [2.x.120]  at the quadrature point  [2.x.121]    q_point of component  [2.x.122]      If this is a boundary face (at_boundary() returns true), then    [2.x.123] .  
* [0.x.63]*
   Return the jump in the gradient  [2.x.124]  on the interface for the shape function  [2.x.125]    interface_dof_index at the quadrature point  [2.x.126]  of component  [2.x.127]    component.     If this is a boundary face (at_boundary() returns true), then    [2.x.128] .  
* [0.x.64]*
   Return the jump in the Hessian  [2.x.129]  on the interface for the   shape function    [2.x.130]  at the quadrature point  [2.x.131]  of component    [2.x.132]      If this is a boundary face (at_boundary() returns true), then    [2.x.133] .  
* [0.x.65]*
   Return the jump in the third derivative  [2.x.134]  on the interface for the   shape function  [2.x.135]  at the quadrature point  [2.x.136]  of   component  [2.x.137]      If this is a boundary face (at_boundary() returns true), then    [2.x.138] .  
* [0.x.66]*
   Create a view of the current FEInterfaceValues object that represents a   particular scalar component of the possibly vector-valued finite element.   The concept of views is explained in the documentation of the namespace   FEValuesViews.  
* [0.x.67]*
   Create a view of the current FEInterfaceValues object that represents a set   of  [2.x.139]  scalar components (i.e. a vector) of the vector-valued   finite element. The concept of views is explained in the documentation of   the namespace FEValuesViews.  
* [0.x.68]*
    [2.x.140]   
* [0.x.69]*
   The list of DoF indices for the current interface, filled in reinit().  
* [0.x.70]*
   The mapping from interface dof to the two local dof indices of the   FeFaceValues objects. If an interface DoF is only active on one of the   cells, the other one will have  [2.x.141]   
* [0.x.71]*
   The FEFaceValues object for the current cell.  
* [0.x.72]*
   The FEFaceValues object for the current cell if the cell is refined.  
* [0.x.73]*
   The FEFaceValues object for the neighboring cell.  
* [0.x.74]*
   The FEFaceValues object for the neighboring cell if the cell is refined.  
* [0.x.75]*
   Pointer to internal_fe_face_values or internal_fe_subface_values,   respectively as determined in reinit().  
* [0.x.76]*
   Pointer to internal_fe_face_values_neighbor,   internal_fe_subface_values_neighbor, or nullptr, respectively   as determined in reinit().  
* [0.x.77] Make the view classes friends of this class, since they access internal   data.  
* [0.x.78]

include/deal.II-translator/fe/fe_nedelec_0.txt
[0.x.0]*
  [2.x.0]  Several aspects of the implementation are experimental. For the moment, it is safe to use the element on globally refined meshes with consistent orientation of faces. See the todo entries below for more detailed caveats.
*  Implementation of N&eacute;d&eacute;lec elements. The N&eacute;d&eacute;lec space is designed to solve problems in which the solution only lives in the space  [2.x.1] , rather than in the more commonly used space  [2.x.2] . In other words, the solution must be a vector field whose curl is square integrable, but for which the gradient may not be square integrable. The typical application for this space (and these elements) is to the Maxwell equations and corresponding simplifications, such as the reduced version of the Maxwell equation that only involves the electric field  [2.x.3]  which has to satisfy the equation  [2.x.4]  in the time independent case when no currents are present, or the equation  [2.x.5]  that the magnetic vector potential  [2.x.6]  has to satisfy in the time independent case.
*  The defining characteristic of functions in  [2.x.7]  is that they are in general discontinuous
* 
*  -  but that if you draw a line in 2d (or a surface in 3d), then the [1.x.0] component(s) of the vector field must be continuous across the line (or surface) even though the normal component may not be. As a consequence, the N&eacute;d&eacute;lec element is constructed in such a way that (i) it is  [2.x.8]  "vector-valued", (ii) the shape functions are discontinuous, but (iii) the tangential component(s) of the vector field represented by each shape function are continuous across the faces of cells.
*  Other properties of the N&eacute;d&eacute;lec element are that (i) it is  [2.x.9]  "not a primitive element"; (ii) the shape functions are defined so that certain integrals over the faces are either zero or one, rather than the common case of certain point values being either zero or one.
*  We follow the commonly used
* 
*  -  though confusing
* 
*  -  definition of the "degree" of N&eacute;d&eacute;lec elements. Specifically, the "degree" of the element denotes the polynomial degree of the [1.x.1] contained in the finite element space, even if the space may contain shape functions of higher polynomial degree. The lowest order element is consequently FE_Nedelec(0), i.e., the Raviart-Thomas element "of degree zero", even though the functions of this space are in general polynomials of degree one in each variable. This choice of "degree" implies that the approximation order of the function itself is [1.x.2], as with usual polynomial spaces. The numbering so chosen implies the sequence [1.x.3] Note that this follows the convention of Brezzi and Raviart, though not the one used in the original paper by N&eacute;d&eacute;lec.
*  This class is not implemented for the codimension one case (<tt>spacedim != dim</tt>).
*   [2.x.10]  Even if this element is implemented for two and three space dimensions, the definition of the node values relies on consistently oriented faces in 3D. Therefore, care should be taken on complicated meshes.
* 

*  [1.x.4]
*  The  [2.x.11]  "interpolation" operators associated with the N&eacute;d&eacute;lec element are constructed such that interpolation and computing the curl are commuting operations on rectangular mesh cells. We require this from interpolating arbitrary functions as well as the #restriction matrices.
*  [1.x.5]
*  The  [2.x.12]  "node values" for an element of degree [1.x.6] on the reference cell are:  [2.x.13]   [2.x.14]  On edges: the moments of the tangential component with respect to polynomials of degree [1.x.7].  [2.x.15]  On faces: the moments of the tangential components with respect to <tt>dim</tt>-1 dimensional FE_Nedelec polynomials of degree [1.x.8]-1.  [2.x.16]  In cells: the moments with respect to gradients of polynomials in FE_Q of degree [1.x.9].  [2.x.17] 
*  [1.x.10]
*  The node values above rely on integrals, which will be computed by quadrature rules themselves. The generalized support points are a set of points such that this quadrature can be performed with sufficient accuracy. The points needed are those of QGauss<sub>k+1</sub> on each edge and QGauss<sub>k+2</sub> on each face and in the interior of the cell (or none for N<sub>1</sub>).

* 
* [0.x.1]*
   Constructor for the Nedelec element of given  [2.x.18]  The maximal   polynomial degree of the shape functions is `order+1` (in each variable;   the total polynomial degree may be higher). If `order = 0`, the element is   linear and has degrees of freedom only on the edges. If `order >=1` the   element has degrees of freedom on the edges, faces and volume. For example   the 3D version of FE_Nedelec has 12 degrees of freedom for `order = 0`   and 54 for `degree = 1`. It is important to have enough quadrature points   in order to perform the quadrature with sufficient accuracy.   For example [QGauss<dim>(order + 2)]( [2.x.19] ) can be used for the   quadrature formula, where `order` is the order of FE_Nedelec.  
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_Nedelec<dim>(degree)</tt>, with  [2.x.20]  and  [2.x.21]    replaced by appropriate values.  
* [0.x.3]*
   This function returns  [2.x.22]  if the shape function  [2.x.23]  has   non-zero function values somewhere on the face  [2.x.24]   
* [0.x.4]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".     For the <tt>FE_Nedelec</tt> class the result is always true (independent   of the degree of the element), as it implements the complete set of   functions necessary for hp-capability.  
* [0.x.5]*
    [2.x.25]   [2.x.26]   
* [0.x.6]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.27]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.  
* [0.x.7]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.  
* [0.x.8]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.  
* [0.x.9]*
   Return the matrix interpolating from a face of one element to the face of   the neighboring element. The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type    [2.x.28]   
* [0.x.10]*
   Return the matrix interpolating from a face of one element to the subface   of the neighboring element. The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type   <tt>ExcInterpolationNotImplemented</tt>.  
* [0.x.11]*
   Projection from a fine grid space onto a coarse grid space. If this   projection operator is associated with a matrix  [2.x.29]  then the   restriction of this matrix  [2.x.30]  to a single child cell is returned   here.     The matrix  [2.x.31]  is the concatenation or the sum of the cell matrices  [2.x.32]    P_i, depending on the #restriction_is_additive_flags. This distinguishes   interpolation (concatenation) and projection with respect to scalar   products (summation).     Row and column indices are related to coarse grid and fine grid spaces,   respectively, consistent with the definition of the associated operator.  
* [0.x.12]*
   Embedding matrix between grids.     The identity operator from a coarse grid space into a fine grid space is   associated with a matrix  [2.x.33]  The restriction of this matrix  [2.x.34]  to a   single child cell is returned here.     The matrix  [2.x.35]  is the concatenation, not the sum of the cell matrices  [2.x.36]    P_i. That is, if the same non-zero entry <tt>j,k</tt> exists in two   different child matrices  [2.x.37]  the value should be the same in both   matrices and it is copied into the matrix  [2.x.38]  only once.     Row and column indices are related to fine grid and coarse grid spaces,   respectively, consistent with the definition of the associated operator.     These matrices are used by routines assembling the prolongation matrix   for multi-level methods.  Upon assembling the transfer matrix between   cells using this matrix array, zero elements in the prolongation matrix   are discarded and will not fill up the transfer matrix.  
* [0.x.13]*
   Return a list of constant modes of the element.  
* [0.x.14]*
   Only for internal use. Its full name is  [2.x.39]    function and it creates the  [2.x.40]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.41]    FiniteElementData.     If the optional argument <tt>dg</tt> is true, the vector returned will   have all degrees of freedom assigned to the cell, none on the faces and   edges.  
* [0.x.15]*
   Initialize the  [2.x.42]  field of the FiniteElement   class and fill the tables with interpolation weights (#boundary_weights   and interior_weights). Called from the constructor.  
* [0.x.16]*
   Initialize the interpolation from functions on refined mesh cells onto   the father cell. According to the philosophy of the Ndlec element,   this restriction operator preserves the curl of a function weakly.  
* [0.x.17]*
   These are the factors multiplied to a function in the   #generalized_face_support_points when computing the integration.     See the    [2.x.43]  "glossary entry on generalized support points"   for more information.  
* [0.x.18]*
   Mutex for protecting initialization of restriction and embedding matrix.  
* [0.x.19]*
   Initialize the permutation pattern and the pattern of sign change.    
*  [2.x.44]  This function is not fully filled with the correct implementation   yet. It needs to be consistently implemented in a future release to work   on meshes that contain cells with flipped faces.  
* [0.x.20]

include/deal.II-translator/fe/fe_nedelec_sz_0.txt
[0.x.0]*
 This class represents an implementation of the H<sup>curl</sup>-conforming N&eacute;d&eacute;lec element described in the PhD thesis of S. Zaglmayr, [1.x.0], Johannes Kepler Universit&auml;t Linz, 2006. It its used in the same context as described at the top of the description for the FE_Nedelec class.
*  This element overcomes the sign conflict issues present in traditional N&eacute;d&eacute;lec elements that arise from the edge and face parameterizations used in the basis functions. Therefore, this element should provide consistent results for general quadrilateral and hexahedral elements for which the relative orientations of edges and faces as seen from all adjacent cells are often difficult to establish.
*  The way this element addresses the sign conflict problem is to assign local edges and faces a globally defined orientation. The local edge orientation is always chosen such that the first vertex defining the edge is the one that has the highest global vertex numbering, with the second edge vertex being that which has the lowest global vertex numbering.
*  Similarly, the face orientation is always chosen such that the first vertex is chosen to be that with the highest global vertex numbering of the four vertices making up the face. The third vertex is then chosen to be that which is geometrically opposite the first vertex, and the second and fourth vertices are decided such that the second has a higher global vertex numbering than the fourth.
*  Note that this element does not support non-conforming meshes at this time.
*  Further details on this element, including some benchmarking, can be in the paper R. Kynch, P. Ledger: [1.x.1], Computers & Structures 181, 41-54, 2017 (see https://doi.org/10.1016/j.compstruc.2016.05.021).

* 
* [0.x.1]*
   Constructor for the NedelecSZ element of given  [2.x.0]  The maximal   polynomial degree of the shape functions is `order+1` (in each variable;   the total polynomial degree may be higher). If `order = 0`, the element is   linear and has degrees of freedom only on the edges. If `order >= 1` the   element has degrees of freedom on the edges, faces and volume. For example   the 3D version of FE_NedelecSZ has 12 degrees of freedom for `order = 0`   and 54 for `degree = 1`. It is important to have enough quadrature points   in order to perform the quadrature with sufficient accuracy.   For example [QGauss<dim>(order + 2)]( [2.x.1] ) can be used for the   quadrature formula, where `order` is the order of FE_NedelecSZ.  
* [0.x.2]*
   This element is vector-valued so this function will   throw an exception.  
* [0.x.3]*
   Not implemented.  
* [0.x.4]*
   This element is vector-valued so this function will   throw an exception.  
* [0.x.5]*
   Not implemented.  
* [0.x.6]*
   This element is vector-valued so this function will   throw an exception.  
* [0.x.7]*
   Not implemented.  
* [0.x.8]*
   The mapping kind to be used to map shape functions from the reference   cell to the mesh cell.  
* [0.x.9]*
   Compute information about the shape functions on the cell denoted by the   first argument. Note that this function must recompute the cell-dependent   degrees of freedom, and so is not thread-safe at this time.  
* [0.x.10]*
   Compute information about the shape functions on the cell and face denoted   by the first two arguments. Note that this function must recompute the   cell-dependent degrees of freedom, and so is not thread-safe at this time.  
* [0.x.11]*
   Not implemented.  
* [0.x.12]*
   Derived Internal data which is used to store cell-independent data.   Note that due to the nature of this element, a number of useful   pre-computed quantities are stored for the computation of cell-dependent   shape functions.     The main quantities which are stored are associated with edge and face   parameterizations. These are:    [2.x.2]     [2.x.3]   [2.x.4] 
* 
*  - trilinear function, equal to one at the  [2.x.5] -th vertex   and zero at all other vertices. [2.x.6]     [2.x.7]   [2.x.8] 
* 
*  - linear functional associated with the  [2.x.9] -th vertex. [2.x.10]     [2.x.11]      The definitions of these functionals, as well as the edge and face   parameterizations and edge and face extension parameters, can be found on   page 82 of Zaglmayr's thesis. The details of the definition of the   globally-defined edge and face orientations can be found on page 67.  
* [0.x.13]*
     Storage for shape functions on the reference element. We only pre-compute     cell-based DoFs, as the edge- and face-based DoFs depend on the cell.         Due to the cell-dependent DoFs, this variable is declared mutable.    
* [0.x.14]*
     Storage for shape function gradients on the reference element. We only     pre-compute cell-based DoFs, as the edge- and face-based DoFs depend on     the cell.         Due to the cell-dependent DoFs, this variable is declared mutable.    
* [0.x.15]*
     Storage for all possible edge parameterization between vertices. These     are required in the computation of edge- and face-based DoFs, which are     cell-dependent.         The edge parameterization of an edge, E, starting at vertex i and ending     at vertex  [2.x.12]  is given by  [2.x.13] .         sigma_imj_values[q][i][j] stores the value of the edge parameterization     connected by vertices  [2.x.14]  and  [2.x.15]  at the q-th quadrature point.         Note that not all of the  [2.x.16]  and  [2.x.17]  combinations result in valid edges     on the hexahedral cell, but they are computed in this fashion for use     with non-standard edge and face orientations.    
* [0.x.16]*
     Storage for gradients of all possible edge parameterizations between     vertices. These are required in the computation of edge- and face-based     DoFs, which are cell-dependent. Note that the components of the gradient     are constant.         The edge parameterization of an edge,  [2.x.18] , starting at vertex  [2.x.19]  and     ending at vertex  [2.x.20]  is given by  [2.x.21] .         sigma_imj_grads[i][j][d] stores the gradient of the edge parameterization     connected by vertices  [2.x.22]  and  [2.x.23]  in component  [2.x.24] .         Note that the gradient of the edge parameterization is constant on an     edge, so we do not need to store it at every quadrature point.    
* [0.x.17]*
     Storage for values of edge parameterizations at quadrature points. These     are stored for the 12 edges such that the global vertex numbering would     follow the order defined by the "standard" deal.II cell.         edge_sigma_values[m][q] stores the edge parameterization value at the     q-th quadrature point on edge m.         These values change with the orientation of the edges of a physical cell     and so must take the "sign" into account when used for computation.    
* [0.x.18]*
     Storage for gradients of edge parameterization at quadrature points.     These are stored for the 12 edges such that the global vertex numbering     would follow the order defined by the "standard" deal.II cell.         edge_sigma_grads[m][d] stores the gradient of the edge parameterization     for component d on edge m.         These values change with the orientation of the edges of a physical cell     and so must take the "sign" into account when used for computation.    
* [0.x.19]*
     Storage for edge extension parameters at quadrature points. These are     stored for the 12 edges such that the global vertex numbering would     follow the order defined by the "standard" deal.II cell.         The edge extension parameter of an edge,  [2.x.25] , starting at vertex  [2.x.26]  and     ending at vertex  [2.x.27]  is given by  [2.x.28] .         Note that under this definition, the values of  [2.x.29]  do not     change with the orientation of the edge.         edge_lambda_values[m][q] stores the edge extension parameter value at     the  [2.x.30] -th quadrature point on edge  [2.x.31] .    
* [0.x.20]*
     Storage for gradients of edge extension parameters in 2D. In this case     they are constant. These are stored for the 12 edges such that the global     vertex numbering* would follow the order defined by the "standard"     deal.II cell.         edge_lambda_grads_2d[m][d] stores the gradient of the edge extension     parameter for component  [2.x.32]  on edge  [2.x.33] .    
* [0.x.21]*
     Storage for gradients of edge extension parameters in 3D. In this case     they are non-constant. These are stored for the 12 edges such that the     global vertex numbering* would follow the order defined by the     "standard" deal.II cell.         edge_lambda_grads_3d[m][q][d] stores the gradient of the edge extension     parameter for component  [2.x.34]  at the  [2.x.35] -th quadrature point on edge m.    
* [0.x.22]*
     Storage for 2nd derivatives of edge extension parameters in 3D, which are     constant across the cell. These are stored for the 12 edges such that the     global vertex numbering* would follow the order defined by the     "standard" deal.II cell.         edge_lambda_gradgrads_3d[m][d1][d2] stores the 2nd derivatives of the     edge extension parameters with respect to components d1 and d2 on edge      [2.x.36] .    
* [0.x.23]*
     Storage for the face extension parameters. These are stored for the 6     faces such that the global vertex numbering would follow the order     defined by the "standard" deal.II cell.         The face extension parameter of a face, F, defined by the vertices     v1, v2, v3, v4 is given by      [2.x.37] .         Note that under this definition, the values of  [2.x.38]  do not     change with the orientation of the face.         face_lambda_values[m][q] stores the face extension parameter value at     the  [2.x.39] -th quadrature point on face  [2.x.40] .    
* [0.x.24]*
     Storage for gradients of face extension parameters. These are stored for     the 6 faces such that the global vertex numbering would follow the order     defined by the "standard" deal.II cell.         face_lambda_grads[m][d] stores the gradient of the face extension     parameters for component  [2.x.41]  on face  [2.x.42] .    
* [0.x.25]*
   Internal function to return a vector of "dofs per object"   where the components of the returned vector refer to:   0 = vertex   1 = edge   2 = face (which is a cell in 2D)   3 = cell  
* [0.x.26]*
   Internal storage for all required integrated Legendre polynomials.  
* [0.x.27]*
   Internal function to populate the internal array of integrated Legendre   polynomials.  
* [0.x.28]*
   Returns the number of DoFs in the basis set.  
* [0.x.29]*
   Populates cell-dependent edge-based shape functions on the given   InternalData object.  
* [0.x.30]*
   Populates the cell-dependent face-based shape functions on the given   InternalData object.  
* [0.x.31]

include/deal.II-translator/fe/fe_nothing_0.txt
[0.x.0]*
 Definition of a finite element space with zero degrees of freedom and that, consequently, can only represent a single function: the zero function.
*  This class is useful (in the context of an hp-method) to represent empty cells in the triangulation on which no degrees of freedom should be allocated, or to describe a field that is extended by zero to a part of the domain where we don't need it. Thus a triangulation may be divided into two regions: an active region where normal elements are used, and an inactive region where FE_Nothing elements are used. The DoFHandler will therefore assign no degrees of freedom to the FE_Nothing cells, and this subregion is therefore implicitly deleted from the computation.  [2.x.0]  and  [2.x.1]  show use cases for this element. An interesting application for this element is also presented in the paper  [2.x.2] .
* 

*  [1.x.0]
*  Finite elements are often best interpreted as forming a [function space](https://en.wikipedia.org/wiki/Function_space), i.e., a set of functions that form a [vector space](https://en.wikipedia.org/wiki/Vector_space). One can indeed interpret FE_Nothing in this light: It corresponds to the function space  [2.x.3] , i.e., the set of functions that are zero everywhere. (The constructor can take an argument that, if greater than one, extends the space to one of vector-valued functions with more than one component, with all components equal to zero everywhere.) Indeed, this is a vector space since every linear combination of elements in the vector space is also an element in the vector space, as is every multiple of the single element zero. It is obvious that the function space has no degrees of freedom, thus the name of the class.
* 

*  [1.x.1]
*  In situations such as those of  [2.x.4] , one uses FE_Nothing on cells where one is not interested in a solution variable. For example, in fluid structure interaction problems, the fluid velocity is only defined on cells inside the fluid part of the domain. One then uses FE_Nothing on cells in the solid part of the domain to describe the finite element space for the velocity. In other words, the velocity lives everywhere conceptually, but it is identically zero in those parts of the domain where it is not of interest and doesn't use up any degrees of freedom there.
*  The question is what happens at the interface between areas where one is interested in the solution (and uses a "normal" finite element) and where one is not interested (and uses FE_Nothing): Should the solution at that interface be zero
* 
*  -  i.e., we consider a "continuous" finite element field that happens to be zero in that area where FE_Nothing is used
* 
*  -  or is there no requirement for continuity at the interface. In the deal.II language, this is encoded by what the function  [2.x.5]  returns: If the FE_Nothing "dominates", then the solution must be zero at the interface; if it does not, then there is no requirement and one can think of FE_Nothing as a function space that is in general discontinuous (i.e., there is no requirement for any kind of continuity at cell interfaces) but on every cell equal to zero.
*  A constructor argument denotes whether the element should be considered dominating or not. The default is for it not to dominate, i.e., FE_Nothing is treated as a discontinuous element.
* 

*  [1.x.2]
*  Note that some care must be taken that the resulting mesh topology continues to make sense when FE_Nothing elements are introduced. This is particularly true when dealing with hanging node constraints, because the library makes some basic assumptions about the nature of those constraints. The following geometries are acceptable:

* 
* [1.x.3]
* 

* 
* [1.x.4]
*  Here, 0 denotes an FE_Nothing cell, and 1 denotes some other element type. The library has no difficulty computing the necessary hanging node constraints in these cases (i.e. no constraint). However, the following geometry is NOT acceptable (at least in the current implementation):

* 
* [1.x.5]
*  The distinction lies in the mixed nature of the child faces, a case we have not implemented as of yet.

* 
* [0.x.1]*
   Constructor.      [2.x.6]  type Specifies the reference-cell type.      [2.x.7]  n_components Denotes the number of   vector components to give this finite element. The default is one.      [2.x.8]  dominate Decides whether FE_Nothing will dominate   any other FE in compare_for_domination() (with the default being `false`).   Therefore at interfaces where, for example, a  [2.x.9]  meets an FE_Nothing, we   will force the traces of the two functions to be the same. Because the   FE_Nothing encodes a space that is zero everywhere, this means that the    [2.x.10]  field will be forced to become zero at this interface. See also the   discussion in the general documentation of this class.  
* [0.x.2]*
   Same as above but for a hypercube reference-cell type.  
* [0.x.3]*
   Return a string that uniquely identifies a finite element. The name is   <tt>FE_Nothing [2.x.11]  n_components, dominating)</tt> where   <tt>dim</tt>, <tt>spacedim</tt>, <tt>type</tt>, and <tt>n_components</tt>   are all specified by the constructor or type signature with the following   exceptions:    [2.x.12]       [2.x.13] If <tt>spacedim == dim</tt> then that field is not printed. [2.x.14]       [2.x.15] If <tt>type</tt> is a hypercube then that field is not printed. [2.x.16]       [2.x.17] If <tt>n_components == 1</tt> then that field is not printed. [2.x.18]       [2.x.19] If <tt>dominate == false</tt> then that field is not printed. [2.x.20]     [2.x.21]   
* [0.x.4]*
   Return the value of the  [2.x.22]  shape function at the point  [2.x.23]   [2.x.24]  is   a point on the reference element. Because the current element has no   degrees of freedom, this function should obviously not be called in   practice.  All this function really does, therefore, is trigger an   exception.  
* [0.x.5]*
   Prepare internal data structures and fill in values independent of the   cell. Returns a pointer to an object of which the caller of this function   then has to assume ownership (which includes destruction when it is no   more needed).     In the current case, this function just returns a default pointer, since   no meaningful data exists for this element.  
* [0.x.6]*
    [2.x.25]   [2.x.26]      In the current case, this element is assumed to dominate if the second   argument in the constructor  [2.x.27]  is true. When this argument is   false and  [2.x.28]  is also of type FE_Nothing(), either element can   dominate. Otherwise there are no_requirements.     See also the discussion in the general documentation of this class.  
* [0.x.7]*
   Return the matrix interpolating from the given finite element to the   present one. Since the current finite element has no degrees of freedom,   the interpolation matrix is necessarily empty.  
* [0.x.8]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element. The size of the matrix is then   <tt>source.#dofs_per_face</tt> times <tt>this->#dofs_per_face</tt>.     Since the current finite element has no degrees of freedom, the   interpolation matrix is necessarily empty.  
* [0.x.9]*
   Return the matrix interpolating from a face of one element to the   subface of the neighboring element. The size of the matrix is then   <tt>source.#dofs_per_face</tt> times <tt>this->#dofs_per_face</tt>.     Since the current finite element has no degrees of freedom, the   interpolation matrix is necessarily empty.  
* [0.x.10]*
    [2.x.29]  true if the FE dominates any other.  
* [0.x.11]*
   If true, this element will dominate any other apart from itself in   compare_for_domination(). This is because a space that only contains the   zero function is definitely smaller (and consequently dominant) when   compared to any other finite element space.  
* [0.x.12]

include/deal.II-translator/fe/fe_p1nc_0.txt
[0.x.0]*
 Implementation of the scalar version of the P1 nonconforming finite element, a piecewise linear element on quadrilaterals in 2D. This implementation is only for 2D cells in a 2D space (i.e., codimension 0).
*  Unlike the usual continuous,  [2.x.0]  conforming finite elements, the P1 nonconforming element does not enforce continuity across edges. However, it requires the continuity in an integral sense: any function in the space should have the same integral values on two sides of the common edge shared by two adjacent elements.
*  Thus, each function in the nonconforming element space can be discontinuous, and consequently not included in  [2.x.1] , just like the basis functions in Discontinuous Galerkin (DG) finite element spaces. On the other hand, basis functions in DG spaces are completely discontinuous across edges without any relation between the values from both sides.  This is a reason why usual weak formulations for DG schemes contain additional penalty terms for jump across edges to control discontinuity.  However, nonconforming elements usually do not need additional terms in their weak formulations because their integrals along edges are the same from both sides, i.e., there is [1.x.0] of continuity.
*  [1.x.1] Since any function in the P1 nonconforming space is piecewise linear on each element, the function value at the midpoint of each edge is same as the mean value on the edge. Thus the continuity of the integral value across each edge is equivalent to the continuity of the midpoint value of each edge in this case.
*  Thus for the P1 nonconforming element, the function values at midpoints on edges of a cell are important. The first attempt to define (local) degrees of freedom (DoFs) on a quadrilateral is by using midpoint values of a function.
*  However, these 4 functionals are not linearly independent because a linear function on 2D is uniquely determined by only 3 independent values. A simple observation reads that any linear function on a quadrilateral should satisfy the 'dice rule': the sum of two function values at the midpoints of the edge pair on opposite sides of a cell is equal to the sum of those at the midpoints of the other edge pair. This is called the 'dice rule' because the number of points on opposite sides of a dice always adds up to the same number as well (in the case of dice, to seven).
*  In formulas, the dice rule is written as  [2.x.2]  for all  [2.x.3]  in the function space where  [2.x.4]  is the midpoint of the edge  [2.x.5] . Here, we assume the standard numbering convention for edges used in deal.II and described in class GeometryInfo.
*  Conversely if 4 values at midpoints satisfying the dice rule are given, then there always exists the unique linear function which coincides with 4 midpoints values.
*  Due to the dice rule, three values at any three midpoints can determine the last value at the last midpoint. It means that the number of independent local functionals on a cell is 3, and this is also the dimension of the linear polynomial space on a cell in 2D.
*  [1.x.2] Before introducing the degrees of freedom, we present 4 local shape functions on a cell. Due to the dice rule, we need a special construction for shape functions. Although the following 4 shape functions are not linearly independent within a cell, they are helpful to define the global basis functions which are linearly independent on the whole domain. Again, we assume the standard numbering for vertices used in deal.II.
*  
* [1.x.3]
* 
*  For each vertex  [2.x.6]  of given cell, there are two edges of which  [2.x.7]  is one of end points. Consider a linear function such that it has value 0.5 at the midpoints of two adjacent edges, and 0.0 at the two midpoints of the other edges. Note that the set of these values satisfies the dice rule which is described above. We denote such a function associated with vertex  [2.x.8]  by  [2.x.9] . Then the set of 4 shape functions is a partition of unity on a cell:  [2.x.10] . (This is easy to see: at each edge midpoint, the sum of the four function adds up to one because two functions have value 0.5 and the other value 0.0. Because the function is globally linear, the only function that can have value 1 at four points must also be globally equal to one.)
*  The following figures represent  [2.x.11]  for  [2.x.12]  with their midpoint values:
*   [2.x.13]   [2.x.14]  shape function  [2.x.15] : 
* [1.x.4]
* 
*   [2.x.16]  shape function  [2.x.17] : 
* [1.x.5]
* 
*   [2.x.18]  shape function  [2.x.19] : 
* [1.x.6]
* 
*   [2.x.20]  shape function  [2.x.21] : 
* [1.x.7]
* 
*   [2.x.22] 
*  The local DoFs are defined by the coefficients of the shape functions associated with vertices, respectively. Although these 4 local DoFs are not linearly independent within a single cell, this definition is a good start point for the definition of the global DoFs.
*  We want to emphasize that the shape functions are constructed on each cell, not on the reference cell only. Usual finite elements are defined based on a 'parametric' concept. It means that a function space for a finite element is defined on one reference cell, and it is transformed into each cell via a mapping from the reference cell. However the P1 nonconforming element does not follow such concept. It defines a function space with linear shape functions on each cell without any help of a function space on the reference cell. In other words, the element is defined in real space, not via a mapping from a reference cell. In this, it is similar to the FE_DGPNonparametric element.
*  Thus this implementation does not have to compute shape values on the reference cell. Rather, the shape values are computed by construction of the shape functions on each cell independently.
*  [1.x.8] We next have to consider the [1.x.9] basis functions for the element because the system of equations which we ultimately have to solve is for a global system, not local. The global basis functions associated with a node are defined by a cell-wise composition of local shape functions associated with the node on each element.
*  There is a theoretical result about the linear independence of the global basis functions depending on the type of the boundary condition we consider.
*  When homogeneous Dirichlet boundary conditions are given, the global basis functions associated with interior nodes are linearly independent. Then, the number of DoFs is equal to the number of interior nodes, and consequently the same as the number of DoFs for the standard bilinear  [2.x.23]  finite element.
*  When Neumann boundary conditions are given, the global basis functions associated with all nodes (including boundary nodes) are actually not linearly independent. There exists one redundancy. Thus in this case, the number of DoFs is equal to the number of all nodes minus 1. This is, again as for the regular  [2.x.24]  element.
*  [1.x.10] For a smooth function, we construct a piecewise linear function which belongs to the element space by using its nodal values as DoF values.
*  Note that for the P1 nonconforming element, two nodal values of a smooth function and its interpolant do not coincide in general, in contrast to ordinary Lagrange finite elements. Of course, it is meaningless to refer 'nodal value' because the element space has nonconformity. But it is also true even though the single global basis function associated with a node is considered the unique 'nodal value' at the node. For instance, consider the basis function associated with a node. Consider two lines representing the level sets for value 0.5 and 0, respectively, by connecting two midpoints. Then we cut the quad into two sub-triangles by the diagonal which is placed along those two lines. It gives another level set for value 0.25 which coincides with the cutting diagonal. Therefore these three level sets are all parallel in the quad and it gives the value 0.75 at the base node, not value 1. This is true whether the quadrilateral is a rectangle, parallelogram, or any other shape.
*  [1.x.11] The original paper for the P1 nonconforming element  by Park and Sheen is accessible at https://doi.org/10.1137/S0036142902404923 , see  [2.x.25]  .

* 
* [0.x.1]*
   Constructor for the P1 nonconforming element.   It is only for 2D and codimension = 0.  
* [0.x.2]*
   Destructor.  
* [0.x.3]*
   Return the vector consists of the numbers of degrees of freedom per   objects.  
* [0.x.4]*
   Return the coefficients of 4 local linear shape functions  [2.x.26]  on given cell. For each local shape function, the array   consists of three coefficients is in order of a,b and c.  
* [0.x.5]*
   Do the work which is needed before cellwise data computation.   Since the shape functions are constructed independently on each cell,   the data on the reference cell is not necessary.   It returns an empty variable type of @ InternalDataBase and updates @   update_flags, and computes trivially zero Hessian for each cell if it is   needed.  
* [0.x.6]*
   Compute the data on the current cell.  
* [0.x.7]*
   Compute the data on the face of the current cell.  
* [0.x.8]*
   Compute the data on the subface of the current cell.  
* [0.x.9]*
   Create the constraints matrix for hanging edges.  
* [0.x.10]

include/deal.II-translator/fe/fe_poly_0.txt
[0.x.0]*
 This class gives a unified framework for the implementation of FiniteElement classes based on scalar polynomial spaces like the TensorProductPolynomials or PolynomialSpace classes. This class has a corresponding class for tensor-valued finite elements in the FE_PolyTensor class.
*  Every class that has the following public member variables and functions can be used as template parameter  [2.x.0] 
* 

* 
* [1.x.0]
*  Example classes are TensorProductPolynomials, PolynomialSpace or PolynomialsP.
*  This class is not a fully implemented FiniteElement class. Instead there are several pure virtual functions declared in the FiniteElement and FiniteElement classes which cannot be implemented by this class but are left for implementation in derived classes.
*   [2.x.1]  Since nearly all functions for spacedim != dim are specialized, this class needs cleaning up.

* 
* [0.x.1]*
   Constructor.  
* [0.x.2]*
   Copy constructor.  
* [0.x.3]*
   Return the polynomial degree of this finite element, i.e. the value   passed to the constructor.  
* [0.x.4]*
   Return the underlying polynomial space.  
* [0.x.5]*
   Return the numbering of the underlying polynomial space compared to   lexicographic ordering of the basis functions. Returns    [2.x.2]     
*  [2.x.3]  Some implementations of this class do not support this function,     since no lexicographic ordering of the basis functions is possible     for them. Examples are: FE_SimplexP, FE_WedgeP, and FE_PyramidP.  
* [0.x.6]*
   Return the inverse numbering of the underlying polynomial space. Returns    [2.x.4]     
*  [2.x.5]  See note of get_poly_space_numbering().  
* [0.x.7]*
   Return the value of the <tt>i</tt>th shape function at the point   <tt>p</tt>. See the FiniteElement base class for more information about   the semantics of this function.  
* [0.x.8]*
   Return the value of the <tt>component</tt>th vector component of the   <tt>i</tt>th shape function at the point <tt>p</tt>. See the   FiniteElement base class for more information about the semantics of this   function.     Since this element is scalar, the returned value is the same as if the   function without the <tt>_component</tt> suffix were called, provided   that the specified component is zero.  
* [0.x.9]*
   Return the gradient of the <tt>i</tt>th shape function at the point   <tt>p</tt>. See the FiniteElement base class for more information about   the semantics of this function.  
* [0.x.10]*
   Return the gradient of the <tt>component</tt>th vector component of the   <tt>i</tt>th shape function at the point <tt>p</tt>. See the   FiniteElement base class for more information about the semantics of this   function.     Since this element is scalar, the returned value is the same as if the   function without the <tt>_component</tt> suffix were called, provided   that the specified component is zero.  
* [0.x.11]*
   Return the tensor of second derivatives of the <tt>i</tt>th shape   function at point <tt>p</tt> on the unit cell. See the FiniteElement base   class for more information about the semantics of this function.  
* [0.x.12]*
   Return the second derivative of the <tt>component</tt>th vector component   of the <tt>i</tt>th shape function at the point <tt>p</tt>. See the   FiniteElement base class for more information about the semantics of this   function.     Since this element is scalar, the returned value is the same as if the   function without the <tt>_component</tt> suffix were called, provided   that the specified component is zero.  
* [0.x.13]*
   Return the tensor of third derivatives of the <tt>i</tt>th shape function   at point <tt>p</tt> on the unit cell. See the FiniteElement base class   for more information about the semantics of this function.  
* [0.x.14]*
   Return the third derivative of the <tt>component</tt>th vector component   of the <tt>i</tt>th shape function at the point <tt>p</tt>. See the   FiniteElement base class for more information about the semantics of this   function.     Since this element is scalar, the returned value is the same as if the   function without the <tt>_component</tt> suffix were called, provided   that the specified component is zero.  
* [0.x.15]*
   Return the tensor of fourth derivatives of the <tt>i</tt>th shape   function at point <tt>p</tt> on the unit cell. See the FiniteElement base   class for more information about the semantics of this function.  
* [0.x.16]*
   Return the fourth derivative of the <tt>component</tt>th vector component   of the <tt>i</tt>th shape function at the point <tt>p</tt>. See the   FiniteElement base class for more information about the semantics of this   function.     Since this element is scalar, the returned value is the same as if the   function without the <tt>_component</tt> suffix were called, provided   that the specified component is zero.  
* [0.x.17]*
   Return an estimate (in bytes) for the memory consumption of this object.  
* [0.x.18]   NOTE: The following function has its definition inlined into the class   declaration because we otherwise run into a compiler error with MS Visual   Studio.  
* [0.x.19]*
   Fields of cell-independent data.     For information about the general purpose of this class, see the   documentation of the base class.  
* [0.x.20]*
     Array with shape function values in quadrature points. There is one row     for each shape function, containing values for each quadrature point.         In this array, we store the values of the shape function in the     quadrature points on the unit cell. Since these values do not change     under transformation to the real cell, we only need to copy them over     when visiting a concrete cell.    
* [0.x.21]*
     Array with shape function gradients in quadrature points. There is one     row for each shape function, containing values for each quadrature     point.         We store the gradients in the quadrature points on the unit cell. We     then only have to apply the transformation (which is a matrix-vector     multiplication) when visiting an actual cell.    
* [0.x.22]*
     Array with shape function hessians in quadrature points. There is one     row for each shape function, containing values for each quadrature     point.         We store the hessians in the quadrature points on the unit cell. We     then only have to apply the transformation when visiting an actual     cell.    
* [0.x.23]*
     Array with shape function third derivatives in quadrature points. There     is one row for each shape function, containing values for each     quadrature point.         We store the third derivatives in the quadrature points on the unit     cell. We then only have to apply the transformation when visiting an     actual cell.    
* [0.x.24]*
   Correct the shape Hessians by subtracting the terms corresponding to the   Jacobian pushed forward gradient.     Before the correction, the Hessians would be given by   [1.x.1]   where  [2.x.6] . After the correction, the   correct Hessians would be given by   [1.x.2]   where  [2.x.7]  is the Jacobian pushed-forward derivative.  
* [0.x.25]*
   Correct the shape third derivatives by subtracting the terms   corresponding to the Jacobian pushed forward gradient and second   derivative.     Before the correction, the third derivatives would be given by   [1.x.3]   where  [2.x.8] . After the correction, the   correct third derivative would be given by   [1.x.4]   where  [2.x.9]  is the Jacobian pushed-forward derivative and  [2.x.10]    is the Jacobian pushed-forward second derivative.  
* [0.x.26]*
   The polynomial space.  
* [0.x.27]

include/deal.II-translator/fe/fe_poly_face_0.txt
[0.x.0]*
  [2.x.0]  This class is not sufficiently tested yet!
*  This class gives a unified framework for the implementation of FiniteElement classes only located on faces of the mesh. They are based on polynomial spaces like the TensorProductPolynomials or a PolynomialSpace classes.
*  Every class that implements the following functions can be used as template parameter PolynomialType.
* 

* 
* [1.x.0]
*  Example classes are TensorProductPolynomials, PolynomialSpace or PolynomialsP.
*  This class is not a fully implemented FiniteElement class. Instead there are several pure virtual functions declared in the FiniteElement class which cannot be implemented by this class but are left for implementation in derived classes.

* 
* [0.x.1]*
   Constructor.  
* [0.x.2]*
   Return the polynomial degree of this finite element, i.e. the value   passed to the constructor.  
* [0.x.3]   NOTE: The following functions have their definitions inlined into the class   declaration because we otherwise run into a compiler error with MS Visual   Studio.  
* [0.x.4]*
   Fields of cell-independent data.     For information about the general purpose of this class, see the   documentation of the base class.  
* [0.x.5]*
     Array with shape function values in quadrature points on one face.     There is one row for each shape function, containing values for each     quadrature point.         In this array, we store the values of the shape function in the     quadrature points on one face of the unit cell. Since these values do     not change under transformation to the real cell, we only need to copy     them over when visiting a concrete cell.         In particular, we can simply copy the same set of values to each of the     faces.    
* [0.x.6]*
   The polynomial space. Its type is given by the template parameter   PolynomialType.  
* [0.x.7]

include/deal.II-translator/fe/fe_poly_face.templates_0.txt
[0.x.0]

include/deal.II-translator/fe/fe_poly.templates_0.txt
[0.x.0]*
 Returns whether we need to correct the Hessians and third derivatives with the derivatives of the Jacobian. This is determined by checking if the jacobian_pushed_forward are zero.
*  Especially for the third derivatives, the correction term is very expensive, which is why we check if the derivatives are zero before computing the correction.

* 
* [0.x.1]

include/deal.II-translator/fe/fe_poly_tensor_0.txt
[0.x.0]*
 This class provides a unified framework for the implementation of FiniteElement classes based on tensor-valued polynomial spaces like PolynomialsBDM and PolynomialsRaviartThomas. In this, it is the tensor-valued equivalent of the FE_Poly class.
*  In essence, what this class requires is that a derived class describes to it a (vector-valued) polynomial space in which every polynomial has exactly  [2.x.0]  vector components. The classes that provide such implementations are all derived from the TensorPolynomialsBase class, and an object of one of these derived types needs to be provided to the constructor of this class.
* 

*  [1.x.0]
*  This class is not a fully implemented FiniteElement class, but implements some common features of vector valued elements based on vector valued polynomial classes. What's missing here in particular is information on the topological location of the node values (i.e., whether a degree of freedom is logically at a vertex, edge, face, or the interior of a cell
* 
*  -  information that determines the continuity properties of the associated shape functions across cell interfaces), and derived classes need to provide this information.
*  Similarly, in many cases, node functionals depend on the shape of the mesh cell, since they evaluate normal or tangential components on the faces. In order to allow for a set of transformations, the variable #mapping_kind has been introduced. It needs be set in the constructor of a derived class.
*  Any derived class must decide on the polynomial space to use.  This polynomial space should be implemented simply as a set of vector valued polynomials like PolynomialsBDM and PolynomialsRaviartThomas.  In order to facilitate this implementation, which basis the polynomial space chooses is not of importance to the current class
* 
*  -  as described next, this class handles the transformation from the basis chosen by the polynomial space template argument to the basis we want to use for finite element computations internally.
* 

*  [1.x.1]
*  In most cases, the basis used by the class that describes the polynomial space,  [2.x.1] , does not match the one we want to use for the finite element description,  [2.x.2] . Rather, we need to express the finite element shape functions as a linear combination of the basis provided by the polynomial space:

* 
* [1.x.2]
*  These expansion coefficients  [2.x.3]  are typically computed in the constructors of derived classes. To facilitate this, this class at first (unless told otherwise, see below), assumes that the shape functions should be exactly the ones provided by the polynomial space. In the constructor of the derived class, one then typically has code of the form

* 
* [1.x.3]
*  The  [2.x.4]  function explains in more detail what exactly it computes, and how; in any case, the result is that  [2.x.5]  now contains the expansion coefficients  [2.x.6] , and the fact that this block of code now sets the matrix to a non-zero size indicates to the functions of the current class that it should from then on use the expanded basis,  [2.x.7] , and no longer the original, "raw" basis  [2.x.8]  when asked for values or derivatives of shape functions.
*  In order for this scheme to work, it is important to ensure that the size of the  [2.x.9]  be zero at the time when  [2.x.10]  is called; thus, the call to this function cannot be inlined into the last line
* 
*  -  the result of the call really does need to be stored in the temporary object  [2.x.11] 
* 

*  [1.x.4]
*  In most cases, vector valued basis functions must be transformed when mapped from the reference cell to the actual grid cell. These transformations can be selected from the set MappingKind and stored in #mapping_kind. Therefore, each constructor should contain a line like:

* 
* [1.x.5]
*  (in case no mapping is required) or using whatever value among the ones defined in MappingKind is appropriate for the element you are implementing. If each shape function may be mapped by different mappings, then  [2.x.12]  may be a vector with the same number of elements as there are shape functions.
*   [2.x.13]  TensorPolynomialsBase

* 
*  [2.x.14] 

* 
* [0.x.1]*
   Constructor. This constructor does a deep copy of the polynomials   object via the  [2.x.15]  function and stores   a pointer to the copy. As a consequence, the calling site can   simply pass a temporary object as the first argument.  
* [0.x.2]*
   Copy constructor.  
* [0.x.3]*
   Compute the (scalar) value of shape function  [2.x.16]  at the given quadrature   point  [2.x.17]  Since the elements represented by this class are vector   valued, there is no such scalar value and the function therefore throws   an exception.  
* [0.x.4]*
   Compute the gradient of (scalar) shape function  [2.x.18]  at the given   quadrature point  [2.x.19]  Since the elements represented by this class are   vector valued, there is no such scalar value and the function therefore   throws an exception.  
* [0.x.5]*
   Compute the Hessian of (scalar) shape function  [2.x.20]  at the given   quadrature point  [2.x.21]  Since the elements represented by this class are   vector valued, there is no such scalar value and the function therefore   throws an exception.  
* [0.x.6]*
   The mapping type to be used to map shape functions from the reference   cell to the mesh cell. If this vector is length one, the same mapping   will be applied to all shape functions. If the vector size is equal to   the finite element dofs per cell, then each shape function will be mapped   according to the corresponding entry in the vector.  
* [0.x.7]*
   Returns a boolean that is true when the finite element uses a single   mapping and false when the finite element uses multiple mappings.  
* [0.x.8]*
   For faces with non-standard face_orientation in 3D, the dofs on faces   (quads) have to be permuted in order to be combined with the correct   shape functions and additionally can change the sign. Given a local   dof  [2.x.22]  on a quad, return the   sign of the permuted shape function, if the face has non-standard   face_orientation, face_flip or face_rotation. In 2D and 1D there is no need   for permutation and consequently it does nothing in this case.     The permutation itself is returned by   adjust_quad_dof_index_for_face_orientation implemented in the interface   class FiniteElement<dim>.  
* [0.x.9]*
   For faces with non-standard face_orientation in 3D, the dofs on faces   (quads) need not only to be permuted in order to be combined with the   correct shape functions. Additionally they may change their sign.     The constructor of this class fills this table with 'false' values, i.e.,   no sign change at all. Derived finite element classes have to   fill this Table with the correct values, see the documentation in   GeometryInfo<dim> and   this  [2.x.23]  "glossary entry on face orientation".     The table must be filled in finite element classes derived   from FE_PolyTensor in a meaningful way since the permutation   pattern and the pattern of sign changes depends on how the finite element   distributes the local dofs on the faces. An example is the function   `initialize_quad_dof_index_permutation_and_sign_change()` in the   FE_RaviartThomas class that fills this table.  
* [0.x.10]*
   Returns MappingKind  [2.x.24]  for the finite element.  
* [0.x.11] NOTE: The following function has its definition inlined into the class     declaration because we otherwise run into a compiler error with MS Visual     Studio.
* [0.x.12]*
   Fields of cell-independent data for FE_PolyTensor. Stores the values of   the shape functions and their derivatives on the reference cell for later   use.     All tables are organized in a way, that the value for shape function   [1.x.6] at quadrature point [1.x.7] is accessed by indices   [1.x.8].  
* [0.x.13]*
     Array with shape function values in quadrature points. There is one row     for each shape function, containing values for each quadrature point.    
* [0.x.14]*
     Array with shape function gradients in quadrature points. There is one     row for each shape function, containing values for each quadrature     point.    
* [0.x.15]*
     Array with shape function hessians in quadrature points. There is one     row for each shape function, containing values for each quadrature     point.    
* [0.x.16]*
     Scratch arrays for intermediate computations    
* [0.x.17]*
   A copy of the object passed to the constructor that describes the   polynomial space.  
* [0.x.18]*
   The inverse of the matrix [1.x.9] of node values   [1.x.10] applied to polynomial [1.x.11]. This   matrix is used to convert polynomials in the "raw" basis provided in   #poly_space to the basis dual to the node functionals on the reference   cell.     This object is not filled by FE_PolyTensor, but is a chance for a derived   class to allow for reorganization of the basis functions. If it is left   empty, the basis in #poly_space is used.  
* [0.x.19]*
   A mutex to be used to guard access to the variables below.  
* [0.x.20]*
   If a shape function is computed at a single point, we must compute all of   them to apply #inverse_node_matrix. In order to avoid too much overhead,   we cache the point and the function values for the next evaluation.  
* [0.x.21]*
   Cached shape function values after call to shape_value_component().  
* [0.x.22]*
   Cached shape function gradients after call to shape_grad_component().  
* [0.x.23]*
   Cached second derivatives of shape functions after call to   shape_grad_grad_component().  
* [0.x.24]

include/deal.II-translator/fe/fe_pyramid_p_0.txt
[0.x.0]*
 Base class of FE_PyramidP and FE_PyramidDGP.
* 

* 
*  [2.x.0]  Only implemented for 3D.
* 

* 
*  [2.x.1] 

* 
* [0.x.1]*
   Constructor.  
* [0.x.2]*
 Implementation of a scalar Lagrange finite element on a pyramid that yields the finite element space of continuous, piecewise polynomials of degree  [2.x.2] .
* 

* 
*  [2.x.3] 

* 
* [0.x.3]*
   Constructor.  
* [0.x.4]*
    [2.x.4]   [2.x.5]   
* [0.x.5]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_PyramidP<dim>(degree)</tt>, with  [2.x.6]  and  [2.x.7]    replaced by appropriate values.  
* [0.x.6]*
    [2.x.8]   [2.x.9]   
* [0.x.7]*
    [2.x.10]   [2.x.11]   
* [0.x.8]*
    [2.x.12]   [2.x.13]   
* [0.x.9]*
    [2.x.14]   [2.x.15]   
* [0.x.10]*
 Implementation of a scalar Lagrange finite element on a pyramid that yields the finite element space of discontinuous, piecewise polynomials of degree  [2.x.16] .
* 

* 
*  [2.x.17] 

* 
* [0.x.11]*
   Constructor.  
* [0.x.12]*
    [2.x.18]   [2.x.19]   
* [0.x.13]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_PyramidDGP<dim>(degree)</tt>, with  [2.x.20]  and  [2.x.21]    replaced by appropriate values.  
* [0.x.14]

include/deal.II-translator/fe/fe_q_0.txt
[0.x.0]*
 Implementation of a scalar Lagrange finite element  [2.x.0]  that yields the finite element space of continuous, piecewise polynomials of degree  [2.x.1]  in each coordinate direction. This class is realized using tensor product polynomials based on 1D Lagrange polynomials with equidistant (degree up to 2), Gauss-Lobatto (starting from degree 3), or given support points.
*  The standard constructor of this class takes the degree  [2.x.2]  of this finite element. Alternatively, it can take a quadrature formula  [2.x.3]  defining the support points of the Lagrange interpolation in one coordinate direction.
*  For more information about the <tt>spacedim</tt> template parameter check the documentation of FiniteElement or the one of Triangulation.
*  [1.x.0]
*  The constructor creates a TensorProductPolynomials object that includes the tensor product of  [2.x.4]  polynomials of degree  [2.x.5]  This  [2.x.6]  object provides all values and derivatives of the shape functions.  In case a quadrature rule is given, the constructor creates a TensorProductPolynomials object that includes the tensor product of  [2.x.7]  polynomials with the support points from  [2.x.8] 
*  Furthermore the constructor fills the  [2.x.9]  the  [2.x.10]  prolongation (embedding) and the  [2.x.11]  matrices. These are implemented only up to a certain degree and may not be available for very high polynomial degree.
*  [1.x.1]
*  When constructing an FE_Q element at polynomial degrees one or two, equidistant support points at 0 and 1 (linear case) or 0, 0.5, and 1 (quadratic case) are used. The unit support or nodal points [1.x.2] are those points where the [1.x.3]th Lagrange polynomial satisfies the  [2.x.12]  property, i.e., where one polynomial is one and all the others are zero.  For higher polynomial degrees, the support points are non-equidistant by default, and chosen to be the support points of the <tt>(degree+1)</tt>-order Gauss-Lobatto quadrature rule. This point distribution yields well-conditioned Lagrange interpolation at arbitrary polynomial degrees. By contrast, polynomials based on equidistant points get increasingly ill-conditioned as the polynomial degree increases. In interpolation, this effect is known as the Runge phenomenon. For Galerkin methods, the Runge phenomenon is typically not visible in the solution quality but rather in the condition number of the associated system matrices. For example, the elemental mass matrix of equidistant points at degree 10 has condition number 2.6e6, whereas the condition number for Gauss-Lobatto points is around 400.
*  The Gauss-Lobatto points in 1D include the end points 0 and +1 of the unit interval. The interior points are shifted towards the end points, which gives a denser point distribution close to the element boundary.
*  If combined with Gauss-Lobatto quadrature, FE_Q based on the default support points gives diagonal mass matrices. This case is demonstrated in  [2.x.13] . However, this element can be combined with arbitrary quadrature rules through the usual FEValues approach, including full Gauss quadrature. In the general case, the mass matrix is non-diagonal.
*  [1.x.4]
*  The original ordering of the shape functions represented by the TensorProductPolynomials is a tensor product numbering. However, the shape functions on a cell are renumbered beginning with the shape functions whose support points are at the vertices, then on the line, on the quads, and finally (for 3d) on the hexes. To be explicit, these numberings are listed in the following:
*  [1.x.5]  [2.x.14]   [2.x.15]  1D case:  
* [1.x.6]
* 
*   [2.x.16]  2D case:  
* [1.x.7]
* 
*   [2.x.17]  3D case:  
* [1.x.8]
* 
*  The respective coordinate values of the support points of the shape functions are as follows:  [2.x.18]   [2.x.19]  Shape function 0: <tt>[0, 0, 0]</tt>;  [2.x.20]  Shape function 1: <tt>[1, 0, 0]</tt>;  [2.x.21]  Shape function 2: <tt>[0, 1, 0]</tt>;  [2.x.22]  Shape function 3: <tt>[1, 1, 0]</tt>;  [2.x.23]  Shape function 4: <tt>[0, 0, 1]</tt>;  [2.x.24]  Shape function 5: <tt>[1, 0, 1]</tt>;  [2.x.25]  Shape function 6: <tt>[0, 1, 1]</tt>;  [2.x.26]  Shape function 7: <tt>[1, 1, 1]</tt>;  [2.x.27]   [2.x.28] 
*  In 2d, these shape functions look as follows:  [2.x.29] 
* 

*  [1.x.9]  [2.x.30]   [2.x.31]  1D case:  
* [1.x.10]
* 
*   [2.x.32]  2D case:  
* [1.x.11]
* 
*   [2.x.33]  3D case:  
* [1.x.12]
*  The center vertex has number 26.
*  The respective coordinate values of the support points of the shape functions are as follows:  [2.x.34]   [2.x.35]  Shape function 0: <tt>[0, 0, 0]</tt>;  [2.x.36]  Shape function 1: <tt>[1, 0, 0]</tt>;  [2.x.37]  Shape function 2: <tt>[0, 1, 0]</tt>;  [2.x.38]  Shape function 3: <tt>[1, 1, 0]</tt>;  [2.x.39]  Shape function 4: <tt>[0, 0, 1]</tt>;  [2.x.40]  Shape function 5: <tt>[1, 0, 1]</tt>;  [2.x.41]  Shape function 6: <tt>[0, 1, 1]</tt>;  [2.x.42]  Shape function 7: <tt>[1, 1, 1]</tt>;  [2.x.43]  Shape function 8: <tt>[0, 1/2, 0]</tt>;  [2.x.44]  Shape function 9: <tt>[1, 1/2, 0]</tt>;  [2.x.45]  Shape function 10: <tt>[1/2, 0, 0]</tt>;  [2.x.46]  Shape function 11: <tt>[1/2, 1, 0]</tt>;  [2.x.47]  Shape function 12: <tt>[0, 1/2, 1]</tt>;  [2.x.48]  Shape function 13: <tt>[1, 1/2, 1]</tt>;  [2.x.49]  Shape function 14: <tt>[1/2, 0, 1]</tt>;  [2.x.50]  Shape function 15: <tt>[1/2, 1, 1]</tt>;  [2.x.51]  Shape function 16: <tt>[0, 0, 1/2]</tt>;  [2.x.52]  Shape function 17: <tt>[1, 0, 1/2]</tt>;  [2.x.53]  Shape function 18: <tt>[0, 1, 1/2]</tt>;  [2.x.54]  Shape function 19: <tt>[1, 1, 1/2]</tt>;  [2.x.55]  Shape function 20: <tt>[0, 1/2, 1/2]</tt>;  [2.x.56]  Shape function 21: <tt>[1, 1/2, 1/2]</tt>;  [2.x.57]  Shape function 22: <tt>[1/2, 0, 1/2]</tt>;  [2.x.58]  Shape function 23: <tt>[1/2, 1, 1/2]</tt>;  [2.x.59]  Shape function 24: <tt>[1/2, 1/2, 0]</tt>;  [2.x.60]  Shape function 25: <tt>[1/2, 1/2, 1]</tt>;  [2.x.61]  Shape function 26: <tt>[1/2, 1/2, 1/2]</tt>;  [2.x.62]   [2.x.63] 
* 

*  In 2d, these shape functions look as follows (the black plane corresponds to zero; negative shape function values may not be visible):  [2.x.64] 
* 

*  [1.x.13]  [2.x.65]   [2.x.66]  1D case:  
* [1.x.14]
* 
*   [2.x.67]  2D case:  
* [1.x.15]
*   [2.x.68] 
*  In 2d, these shape functions look as follows (the black plane corresponds to zero; negative shape function values may not be visible):  [2.x.69] 
* 

*  [1.x.16]  [2.x.70]   [2.x.71]  1D case:  
* [1.x.17]
* 
*   [2.x.72]  2D case:  
* [1.x.18]
*   [2.x.73] 
*  In 2d, these shape functions look as follows (the black plane corresponds to zero; negative shape function values may not be visible):  [2.x.74] 

* 
* [0.x.1]*
   Constructor for tensor product polynomials of degree  [2.x.75]  based on   Gauss-Lobatto support (node) points. For polynomial degrees of one and   two, these are the usual equidistant points.  
* [0.x.2]*
   Constructor for tensor product polynomials with support points  [2.x.76]    based on a one-dimensional quadrature formula. The degree of the finite   element is <tt>points.size()-1</tt>. Note that the first point has to be   0 and the last one 1. Constructing   <tt>FE_Q<dim>(QGaussLobatto<1>(fe_degree+1))</tt> is equivalent to the   constructor that specifies the polynomial degree only. For selecting   equidistant nodes at <tt>fe_degree > 2</tt>, construct   <tt>FE_Q<dim>(QIterated<1>(QTrapezoid<1>(),fe_degree))</tt>.     Thespace* created by this constructor is the   same as if you had called `FE_Q<dim>(points.size()-1)`, but whatis*
   different are the basis functions of this space. This is useful in   contexts where one wants to achieve certain properties of the matrices   that result from integrating bilinear forms of these shape functions.   For example, when computing the mass matrix on cell  [2.x.77] ,   [1.x.19]   one generally applies a quadrature formula and approximates the real   mass matrix by the following:   [1.x.20]   where the locations of the quadrature points  [2.x.78]  and the   weights  [2.x.79]  depend on the cell  [2.x.80] . If the quadrature formula used   to define these points  [2.x.81]  is the same as the one passed   to this constructor (or, in higher dimensions, is generated by a   tensor product of the one used to the constructor), then    [2.x.82] , and the matrix reduces to   [1.x.21]   i.e., a diagonal matrix with the weights  [2.x.83]  on the diagonal. Such   constructions are quite useful when using explicit time stepping   methods because, for example, one then only has to invert a diagonal   mass matrix in each time step when solving the linear system.  
* [0.x.3]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_Q<dim>(degree)</tt>, with  [2.x.84]  and  [2.x.85]  replaced by   appropriate values.  
* [0.x.4]*
   Implementation of the corresponding function in the FiniteElement   class.  Since the current element is interpolatory, the nodal   values are exactly the support point values. Furthermore, since   the current element is scalar, the support point values need to   be vectors of length 1.  
* [0.x.5]*
    [2.x.86]   [2.x.87]   
* [0.x.6]

include/deal.II-translator/fe/fe_q_base_0.txt
[0.x.0]*
 This class collects the basic methods used in FE_Q, FE_Q_DG0 and FE_Q_Bubbles. There is no public constructor for this class as it is not functional as a stand-alone. The completion of definitions is left to the derived classes.

* 
* [0.x.1]*
   Constructor.  
* [0.x.2]*
   Return the matrix interpolating from the given finite element to the   present one. The size of the matrix is then  [2.x.0]  times   <tt>source.n_dofs_per_cell()</tt>.     These matrices are only available if the source element is also a  [2.x.1]    element. Otherwise, an exception of type    [2.x.2]  is thrown.  
* [0.x.3]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>. The   FE_Q element family only provides interpolation matrices for elements of   the same type and FE_Nothing. For all other elements, an exception of   type  [2.x.3]  is   thrown.  
* [0.x.4]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>. The   FE_Q element family only provides interpolation matrices for elements of   the same type and FE_Nothing. For all other elements, an exception of   type  [2.x.4]  is   thrown.  
* [0.x.5]*
   This function returns  [2.x.5]  if the shape function  [2.x.6]  has   non-zero function values somewhere on the face  [2.x.7]   
* [0.x.6]*
   Projection from a fine grid space onto a coarse grid space. Overrides the   respective method in FiniteElement, implementing lazy evaluation   (initialize when requested).     If this projection operator is associated with a matrix  [2.x.8]  then the   restriction of this matrix  [2.x.9]  to a single child cell is returned   here.     The matrix  [2.x.10]  is the concatenation or the sum of the cell matrices  [2.x.11]    P_i, depending on the #restriction_is_additive_flags. This distinguishes   interpolation (concatenation) and projection with respect to scalar   products (summation).     Row and column indices are related to coarse grid and fine grid spaces,   respectively, consistent with the definition of the associated operator.     If projection matrices are not implemented in the derived finite element   class, this function aborts with ExcProjectionVoid. You can check whether   this is the case by calling the restriction_is_implemented() or the   isotropic_restriction_is_implemented() function.  
* [0.x.7]*
   Embedding matrix between grids. Overrides the respective method in   FiniteElement, implementing lazy evaluation (initialize when queried).     The identity operator from a coarse grid space into a fine grid space is   associated with a matrix  [2.x.12]  The restriction of this matrix  [2.x.13]  to a   single child cell is returned here.     The matrix  [2.x.14]  is the concatenation, not the sum of the cell matrices  [2.x.15]    P_i. That is, if the same non-zero entry <tt>j,k</tt> exists in two   different child matrices  [2.x.16]  the value should be the same in both   matrices and it is copied into the matrix  [2.x.17]  only once.     Row and column indices are related to fine grid and coarse grid spaces,   respectively, consistent with the definition of the associated operator.     These matrices are used by routines assembling the prolongation matrix   for multi-level methods.  Upon assembling the transfer matrix between   cells using this matrix array, zero elements in the prolongation matrix   are discarded and will not fill up the transfer matrix.     If projection matrices are not implemented in the derived finite element   class, this function aborts with ExcEmbeddingVoid. You can check whether   this is the case by calling the prolongation_is_implemented() or the   isotropic_prolongation_is_implemented() function.  
* [0.x.8]*
   Given an index in the natural ordering of indices on a face, return the   index of the same degree of freedom on the cell.     To explain the concept, consider the case where we would like to know   whether a degree of freedom on a face, for example as part of an FESystem   element, is primitive. Unfortunately, the is_primitive() function in the   FiniteElement class takes a cell index, so we would need to find the cell   index of the shape function that corresponds to the present face index.   This function does that.     Code implementing this would then look like this:  
* [1.x.0]
*    The function takes additional arguments that account for the fact that   actual faces can be in their standard ordering with respect to the cell   under consideration, or can be flipped, oriented, etc.      [2.x.18]  face_dof_index The index of the degree of freedom on a face. This   index must be between zero and dofs_per_face.    [2.x.19]  face The number of the face this degree of freedom lives on. This   number must be between zero and  [2.x.20]     [2.x.21]  face_orientation One part of the description of the orientation of   the face. See    [2.x.22] .    [2.x.23]  face_flip One part of the description of the orientation of the   face. See    [2.x.24] .    [2.x.25]  face_rotation One part of the description of the orientation of   the face. See    [2.x.26] .    [2.x.27]  The index of this degree of freedom within the set of degrees of   freedom on the entire cell. The returned value will be between zero and   dofs_per_cell.  
* [0.x.9]*
   Return a list of constant modes of the element. For this element, the   list consists of true arguments for all components.  
* [0.x.10]*
    [2.x.28]  Functions to support hp    [2.x.29]   
* [0.x.11]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".     For the FE_Q class the result is always true (independent of the degree   of the element), as it implements the complete set of functions necessary   for hp-capability.  
* [0.x.12]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.30]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.  
* [0.x.13]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.  
* [0.x.14]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on quads.  
* [0.x.15]*
   Attempt to construct an FE_Q object of degree 0    
*  [2.x.31]   
* [0.x.16]*
   Only for internal use. Its full name is  [2.x.32]    function and it creates the  [2.x.33]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.34]    FiniteElementData.  
* [0.x.17]*
   Perform the initialization of the element based on 1D support points,   i.e., sets renumbering, initializes unit support points, initializes   constraints as well as restriction and prolongation matrices.  
* [0.x.18]*
   Initialize the hanging node constraints matrices. Called from   initialize().  
* [0.x.19]*
   Initialize the  [2.x.35]  field of the FiniteElement class.   Called from initialize().  
* [0.x.20]*
   Initialize the  [2.x.36]  field of the FiniteElement   class. Called from initialize().  
* [0.x.21]*
   Initialize the  [2.x.37]  field   of the FiniteElement class. Called from initialize().  
* [0.x.22]*
   Forward declaration of a class into which we put significant parts of the   implementation.     See the .cc file for more information.  
* [0.x.23]*
   Mutex for protecting initialization of restriction and embedding matrix.  
* [0.x.24]*
   The highest polynomial degree of the underlying tensor product space   without any enrichment. For FE_Q*(p) this is p. Note that enrichments   may lead to a difference to degree.  
* [0.x.25]

include/deal.II-translator/fe/fe_q_bubbles_0.txt
[0.x.0]*
 Implementation of a scalar Lagrange finite element  [2.x.0]  that yields the finite element space of continuous, piecewise polynomials of degree  [2.x.1]  in each coordinate direction plus some (non-normalized) bubble enrichment space spanned by the additional shape function  [2.x.2] . for  [2.x.3] .  If  [2.x.4]  is one, then the first factor disappears and one receives the usual bubble function centered at the mid-point of the cell. Because these last shape functions have polynomial degree is  [2.x.5] , the overall polynomial degree of the shape functions in the space described by this class is  [2.x.6] .
*  This class is realized using tensor product polynomials based on equidistant or given support points, in the same way as one can provide support points to the FE_Q class's constructors.
*  For more information about the <tt>spacedim</tt> template parameter check the documentation of the FiniteElement class, or the one of Triangulation.
*  Due to the fact that the enrichments are small almost everywhere for large  [2.x.7] , the condition number for the mass and stiffness matrix quickly increaseses with increasing  [2.x.8] . Below you see a comparison with FE_Q(QGaussLobatto(p+1)) for dim=1.
*   [2.x.9] 
*  Therefore, this element should be used with care for  [2.x.10] .
* 

*  [1.x.0]
*  The constructor creates a TensorProductPolynomials object that includes the tensor product of  [2.x.11]  polynomials of degree  [2.x.12]  plus the bubble enrichments. This  [2.x.13]  object provides all values and derivatives of the shape functions. In case a quadrature rule is given, the constructor creates a TensorProductPolynomialsBubbles object that includes the tensor product of  [2.x.14]  polynomials with the support points from  [2.x.15]  and the bubble enrichments as defined above.
*  Furthermore the constructor fills the  [2.x.16]  the  [2.x.17]  prolongation (embedding) and the  [2.x.18]  matrices.
* 

*  [1.x.1]
*  The original ordering of the shape functions represented by the TensorProductPolynomialsBubbles is a tensor product numbering. However, the shape functions on a cell are renumbered beginning with the shape functions whose support points are at the vertices, then on the line, on the quads, and finally (for 3d) on the hexes. Finally, there are support points for the bubble enrichments in the middle of the cell.

* 
* [0.x.1]*
   Constructor for tensor product polynomials of degree  [2.x.19]  plus bubble   enrichments  
* [0.x.2]*
   Constructor for tensor product polynomials with support points    [2.x.20]  plus bubble enrichments based on a one-dimensional   quadrature formula.  The degree of the finite element is then   <tt>points.size()</tt>, the plus one compared to the   corresponding case for the FE_Q class coming from the additional   bubble function. See the documentation of the FE_Q constructors   for more information.     Note that the first point has to be 0   and the last one 1.  
* [0.x.3]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_Q_Bubbles<dim>(degree)</tt>, with  [2.x.21]  and  [2.x.22]    replaced by appropriate values.  
* [0.x.4]*
   Return the matrix interpolating from the given finite element to the   present one.  The size of the matrix is then  [2.x.23]  times   <tt>source.n_dofs_per_cell()</tt>.     These matrices are only available if the source element is also a  [2.x.24]    FE_Q_Bubbles element. Otherwise, an exception of type    [2.x.25]  is thrown.  
* [0.x.5]*
   Check for non-zero values on a face.     This function returns  [2.x.26]  if the shape function  [2.x.27]  has   non-zero values on the face  [2.x.28]      Implementation of the interface in FiniteElement  
* [0.x.6]*
    [2.x.29]   [2.x.30]   
* [0.x.7]*
   Return the restriction_is_additive flags. Only the last components for   the bubble enrichments are true.  
* [0.x.8]*
   Only for internal use. Its full name is  [2.x.31]    function and it creates the  [2.x.32]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.33]    FiniteElementData.  
* [0.x.9]*
   Number of additional bubble functions  
* [0.x.10]

include/deal.II-translator/fe/fe_q_dg0_0.txt
[0.x.0]*
 Implementation of a scalar Lagrange finite element  [2.x.0]  that yields the finite element space of continuous, piecewise polynomials of degree  [2.x.1]  p in each coordinate direction plus the space of locally constant functions. This class is realized using tensor product polynomials based on equidistant or given support points.
*  The standard constructor of this class takes the degree  [2.x.2]  of this finite element. Alternatively, it can take a quadrature formula  [2.x.3]  defining the support points of the Lagrange interpolation in one coordinate direction.
*  For more information about the <tt>spacedim</tt> template parameter check the documentation of FiniteElement or the one of Triangulation.
*  For more information regarding this element see: Boffi, D., et al. "Local Mass Conservation of Stokes Finite Elements." Journal of Scientific Computing (2012): 1-18.
*  [1.x.0]
*  The constructor creates a TensorProductPolynomials object that includes the tensor product of  [2.x.4]  polynomials of degree  [2.x.5]  plus the locally constant function. This  [2.x.6]  object provides all values and derivatives of the shape functions. In case a quadrature rule is given, the constructor creates a TensorProductPolynomialsConst object that includes the tensor product of  [2.x.7]  Lagrange polynomials with the support points from  [2.x.8]  and a locally constant function.
*  Furthermore the constructor fills the  [2.x.9]  the  [2.x.10]  prolongation (embedding) and the  [2.x.11]  matrices.
*  [1.x.1]
*  The original ordering of the shape functions represented by the TensorProductPolynomialsConst is a tensor product numbering. However, the shape functions on a cell are renumbered beginning with the shape functions whose support points are at the vertices, then on the line, on the quads, and finally (for 3d) on the hexes. Finally there is a support point for the discontinuous shape function in the middle of the cell. To be explicit, these numberings are listed in the following:
*  [1.x.2]  [2.x.12]   [2.x.13]  1D case:  
* [1.x.3]
* 
*   [2.x.14]  2D case:  
* [1.x.4]
* 
*   [2.x.15]  3D case:  
* [1.x.5]
* 
*  The respective coordinate values of the support points of the degrees of freedom are as follows:  [2.x.16]   [2.x.17]  Index 0: <tt>[ 0,  0, 0]</tt>;  [2.x.18]  Index 1: <tt>[ 1,  0, 0]</tt>;  [2.x.19]  Index 2: <tt>[ 0,  1, 0]</tt>;  [2.x.20]  Index 3: <tt>[ 1,  1, 0]</tt>;  [2.x.21]  Index 4: <tt>[ 0,  0, 1]</tt>;  [2.x.22]  Index 5: <tt>[ 1,  0, 1]</tt>;  [2.x.23]  Index 6: <tt>[ 0,  1, 1]</tt>;  [2.x.24]  Index 7: <tt>[ 1,  1, 1]</tt>;  [2.x.25]  Index 8: <tt>[1/2, 1/2, 1/2]</tt>;  [2.x.26]   [2.x.27]  [1.x.6]  [2.x.28]   [2.x.29]  1D case:  
* [1.x.7]
*  Index 3 has the same coordinates as index 2
*   [2.x.30]  2D case:  
* [1.x.8]
*  Index 9 has the same coordinates as index 2
*   [2.x.31]  3D case:  
* [1.x.9]
*  The center vertices have number 26 and 27.
*  The respective coordinate values of the support points of the degrees of freedom are as follows:  [2.x.32]   [2.x.33]  Index 0: <tt>[0, 0, 0]</tt>;  [2.x.34]  Index 1: <tt>[1, 0, 0]</tt>;  [2.x.35]  Index 2: <tt>[0, 1, 0]</tt>;  [2.x.36]  Index 3: <tt>[1, 1, 0]</tt>;  [2.x.37]  Index 4: <tt>[0, 0, 1]</tt>;  [2.x.38]  Index 5: <tt>[1, 0, 1]</tt>;  [2.x.39]  Index 6: <tt>[0, 1, 1]</tt>;  [2.x.40]  Index 7: <tt>[1, 1, 1]</tt>;  [2.x.41]  Index 8: <tt>[0, 1/2, 0]</tt>;  [2.x.42]  Index 9: <tt>[1, 1/2, 0]</tt>;  [2.x.43]  Index 10: <tt>[1/2, 0, 0]</tt>;  [2.x.44]  Index 11: <tt>[1/2, 1, 0]</tt>;  [2.x.45]  Index 12: <tt>[0, 1/2, 1]</tt>;  [2.x.46]  Index 13: <tt>[1, 1/2, 1]</tt>;  [2.x.47]  Index 14: <tt>[1/2, 0, 1]</tt>;  [2.x.48]  Index 15: <tt>[1/2, 1, 1]</tt>;  [2.x.49]  Index 16: <tt>[0, 0, 1/2]</tt>;  [2.x.50]  Index 17: <tt>[1, 0, 1/2]</tt>;  [2.x.51]  Index 18: <tt>[0, 1, 1/2]</tt>;  [2.x.52]  Index 19: <tt>[1, 1, 1/2]</tt>;  [2.x.53]  Index 20: <tt>[0, 1/2, 1/2]</tt>;  [2.x.54]  Index 21: <tt>[1, 1/2, 1/2]</tt>;  [2.x.55]  Index 22: <tt>[1/2, 0, 1/2]</tt>;  [2.x.56]  Index 23: <tt>[1/2, 1, 1/2]</tt>;  [2.x.57]  Index 24: <tt>[1/2, 1/2, 0]</tt>;  [2.x.58]  Index 25: <tt>[1/2, 1/2, 1]</tt>;  [2.x.59]  Index 26: <tt>[1/2, 1/2, 1/2]</tt>;  [2.x.60]  Index 27: <tt>[1/2, 1/2, 1/2]</tt>;  [2.x.61]   [2.x.62]  [1.x.10]  [2.x.63]   [2.x.64]  1D case:  
* [1.x.11]
* 
*   [2.x.65]  2D case:  
* [1.x.12]
*   [2.x.66]  [1.x.13]  [2.x.67]   [2.x.68]  1D case:  
* [1.x.14]
*  Index 5 has the same coordinates as index 3
*   [2.x.69]  2D case:  
* [1.x.15]
*  Index 21 has the same coordinates as index 20  [2.x.70] 

* 
* [0.x.1]*
   Constructor for tensor product polynomials of degree  [2.x.71]  plus locally   constant functions.  
* [0.x.2]*
   Constructor for tensor product polynomials with support points  [2.x.72]    plus locally constant functions based on a one-dimensional quadrature   formula. The degree of the finite element is <tt>points.size()-1</tt>.   Note that the first point has to be 0 and the last one 1.  
* [0.x.3]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_Q_DG0<dim>(degree)</tt>, with  [2.x.73]  and  [2.x.74]    replaced by appropriate values.  
* [0.x.4]*
   Return the matrix interpolating from the given finite element to the   present one.  The size of the matrix is then  [2.x.75]  times   <tt>source.n_dofs_per_cell()</tt>.     These matrices are only available if the source element is also a  [2.x.76]    FE_Q_DG0 element. Otherwise, an exception of type    [2.x.77]  is thrown.  
* [0.x.5]*
   This function returns  [2.x.78]  if the shape function  [2.x.79]  has   non-zero function values somewhere on the face  [2.x.80]   
* [0.x.6]*
   Return a list of constant modes of the element. For this element, there   are two constant modes despite the element is scalar: The first constant   mode is all ones for the usual FE_Q basis and the second one only using   the discontinuous part.  
* [0.x.7]*
    [2.x.81]   [2.x.82]   
* [0.x.8]*
   Return the restriction_is_additive flags. Only the last component is   true.  
* [0.x.9]*
   Only for internal use. Its full name is  [2.x.83]    function and it creates the  [2.x.84]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.85]    FiniteElementData.  
* [0.x.10]

include/deal.II-translator/fe/fe_q_hierarchical_0.txt
[0.x.0]*
 Implementation of hierarchical  [2.x.0]  shape functions that yield the finite element space of continuous, piecewise polynomials of degree  [2.x.1]  This class is realized using tensor product polynomials based on a hierarchical basis  [2.x.2]  on the interval <tt>[0,1]</tt> which is suitable for building an  [2.x.3]  tensor product finite element if we assume that each element has a single degree.
*  The constructor of this class takes the degree  [2.x.4]  of this finite element.
*  This class is not implemented for the codimension one case (<tt>spacedim != dim</tt>).
*  [1.x.0]
*  The constructor creates a TensorProductPolynomials object that includes the tensor product of  [2.x.5]  polynomials of degree  [2.x.6]  This  [2.x.7]  TensorProductPolynomials object provides all values and derivatives of the shape functions.
*  [1.x.1]
*  The original ordering of the shape functions represented by the TensorProductPolynomials is a tensor product numbering. However, the shape functions on a cell are renumbered beginning with the shape functions whose support points are at the vertices, then on the line, on the quads, and finally (for 3d) on the hexes. To be explicit, these numberings are listed in the following:
*  [1.x.2]
*  The  [2.x.8]  element is of polynomial degree one and, consequently, is exactly the same as the  [2.x.9]  element in class FE_Q. In particular, the shape function are defined in the exact same way:
*   [2.x.10]   [2.x.11]  1D case:  
* [1.x.3]
* 
*   [2.x.12]  2D case:  
* [1.x.4]
* 
*   [2.x.13]  3D case:  
* [1.x.5]
* 
*  The respective coordinate values of the support points of the degrees of freedom are as follows:  [2.x.14]   [2.x.15]  Shape function 0: <tt>[0, 0, 0]</tt>;  [2.x.16]  Shape function 1: <tt>[1, 0, 0]</tt>;  [2.x.17]  Shape function 2: <tt>[0, 1, 0]</tt>;  [2.x.18]  Shape function 3: <tt>[1, 1, 0]</tt>;  [2.x.19]  Shape function 4: <tt>[0, 0, 1]</tt>;  [2.x.20]  Shape function 5: <tt>[1, 0, 1]</tt>;  [2.x.21]  Shape function 6: <tt>[0, 1, 1]</tt>;  [2.x.22]  Shape function 7: <tt>[1, 1, 1]</tt>;  [2.x.23]   [2.x.24] 
*  In 2d, these shape functions look as follows:  [2.x.25] 
* 

*  [1.x.6]  [2.x.26]   [2.x.27]  1D case:  
* [1.x.7]
* 
*   [2.x.28]  2D case:  
* [1.x.8]
* 
*   [2.x.29]  3D case:  
* [1.x.9]
*  The center vertex has number 26.
*  The respective coordinate values of the support points of the degrees of freedom are as follows:  [2.x.30]   [2.x.31]  Shape function 0: <tt>[0, 0, 0]</tt>;  [2.x.32]  Shape function 1: <tt>[1, 0, 0]</tt>;  [2.x.33]  Shape function 2: <tt>[0, 1, 0]</tt>;  [2.x.34]  Shape function 3: <tt>[1, 1, 0]</tt>;  [2.x.35]  Shape function 4: <tt>[0, 0, 1]</tt>;  [2.x.36]  Shape function 5: <tt>[1, 0, 1]</tt>;  [2.x.37]  Shape function 6: <tt>[0, 1, 1]</tt>;  [2.x.38]  Shape function 7: <tt>[1, 1, 1]</tt>;  [2.x.39]  Shape function 8: <tt>[0, 1/2, 0]</tt>;  [2.x.40]  Shape function 9: <tt>[1, 1/2, 0]</tt>;  [2.x.41]  Shape function 10: <tt>[1/2, 0, 0]</tt>;  [2.x.42]  Shape function 11: <tt>[1/2, 1, 0]</tt>;  [2.x.43]  Shape function 12: <tt>[0, 1/2, 1]</tt>;  [2.x.44]  Shape function 13: <tt>[1, 1/2, 1]</tt>;  [2.x.45]  Shape function 14: <tt>[1/2, 0, 1]</tt>;  [2.x.46]  Shape function 15: <tt>[1/2, 1, 1]</tt>;  [2.x.47]  Shape function 16: <tt>[0, 0, 1/2]</tt>;  [2.x.48]  Shape function 17: <tt>[1, 0, 1/2]</tt>;  [2.x.49]  Shape function 18: <tt>[0, 1, 1/2]</tt>;  [2.x.50]  Shape function 19: <tt>[1, 1, 1/2]</tt>;  [2.x.51]  Shape function 20: <tt>[0, 1/2, 1/2]</tt>;  [2.x.52]  Shape function 21: <tt>[1, 1/2, 1/2]</tt>;  [2.x.53]  Shape function 22: <tt>[1/2, 0, 1/2]</tt>;  [2.x.54]  Shape function 23: <tt>[1/2, 1, 1/2]</tt>;  [2.x.55]  Shape function 24: <tt>[1/2, 1/2, 0]</tt>;  [2.x.56]  Shape function 25: <tt>[1/2, 1/2, 1]</tt>;  [2.x.57]  Shape function 26: <tt>[1/2, 1/2, 1/2]</tt>;  [2.x.58]   [2.x.59] 
* 

*  In 2d, these shape functions look as follows (the black plane corresponds to zero; negative shape function values may not be visible):  [2.x.60] 
* 

*  [1.x.10]  [2.x.61]   [2.x.62]  1D case:  
* [1.x.11]
* 
*   [2.x.63]  2D case:  
* [1.x.12]
*   [2.x.64] 
*  In 2d, these shape functions look as follows (the black plane corresponds to zero; negative shape function values may not be visible):  [2.x.65] 
* 

*  [1.x.13]  [2.x.66]   [2.x.67]  1D case:  
* [1.x.14]
* 
*   [2.x.68]  2D case:  
* [1.x.15]
*   [2.x.69] 
*  In 2d, these shape functions look as follows (the black plane corresponds to zero; negative shape function values may not be visible):  [2.x.70] 

* 
* [0.x.1]*
   Constructor for tensor product polynomials of degree  [2.x.71]   
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_Q_Hierarchical<dim>(degree)</tt>, with  [2.x.72]  and  [2.x.73]    degree replaced by appropriate values.  
* [0.x.3]*
   This function returns  [2.x.74]  if the shape function  [2.x.75]  has   non-zero function values somewhere on the face  [2.x.76]   
* [0.x.4]*
    [2.x.77]  Functions to support hp    [2.x.78]   
* [0.x.5]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".     For the FE_Q_Hierarchical class the result is always true (independent of   the degree of the element), as it implements the complete set of   functions necessary for hp-capability.  
* [0.x.6]*
   Return the matrix interpolating from the given finite element to the   present one. Interpolation only between FE_Q_Hierarchical is supported.  
* [0.x.7]*
   Embedding matrix between grids. Only isotropic refinement is supported.  
* [0.x.8]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.79]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.  
* [0.x.9]*
   Same as above but for lines.  
* [0.x.10]*
   Same as above but for faces.  
* [0.x.11]*
    [2.x.80]   [2.x.81]   
* [0.x.12]*
   Return the matrix interpolating from a face of one element to the face of   the neighboring element. The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type    [2.x.82]   
* [0.x.13]*
   Return the matrix interpolating from a face of one element to the subface   of the neighboring element. The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Derived elements will have to implement this function. They may only   provide interpolation matrices for certain source finite elements, for   example those from the same family. If they don't implement interpolation   from a given element, then they must throw an exception of type   <tt>ExcInterpolationNotImplemented</tt>.  
* [0.x.14]*
   Determine an estimate for the memory consumption (in bytes) of this   object.     This function is made virtual, since finite element objects are usually   accessed through pointers to their base class, rather than the class   itself.  
* [0.x.15]*
   For a finite element of degree  [2.x.83]  <  [2.x.84]  we return a   vector which maps the numbering on an FE of degree  [2.x.85]  into the   numbering on this element.  
* [0.x.16]*
   Return a list of constant modes of the element. For this element, the   list consists of true arguments for the first vertex shape functions and   false for the remaining ones.  
* [0.x.17]*
   Only for internal use. Its full name is  [2.x.86]    function and it creates the  [2.x.87]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.88]    FiniteElementData.  
* [0.x.18]*
   The numbering of the degrees of freedom in continuous finite elements is   hierarchic, i.e. in such a way that we first number the vertex dofs, in   the order of the vertices as defined by the triangulation, then the line   dofs in the order and respecting the direction of the lines, then the   dofs on quads, etc.     The dofs associated with 1d hierarchical polynomials are ordered with the   vertices first ( [2.x.89]  and  [2.x.90] ) and then the line dofs   (the higher degree polynomials).  The 2d and 3d hierarchical polynomials   originate from the 1d hierarchical polynomials by tensor product. In the   following, the resulting numbering of dofs will be denoted by   `fe_q_hierarchical numbering`.     This function constructs a table which fe_q_hierarchical index each   degree of freedom in the hierarchic numbering would have.     This function is analogous to the    [2.x.91]  function. However, in   contrast to the fe_q_hierarchical numbering defined above, the   lexicographic numbering originates from the tensor products of   consecutive numbered dofs (like for LagrangeEquidistant).     It is assumed that the size of the output argument already matches the   correct size, which is equal to the number of degrees of freedom in the   finite element.  
* [0.x.19]*
   This is an analogon to the previous function, but working on faces.  
* [0.x.20]*
   Initialize two auxiliary fields that will be used in setting up the   various matrices in the constructor.  
* [0.x.21]*
   Initialize the hanging node constraints matrices. Called from the   constructor.  
* [0.x.22]*
   Initialize the embedding matrices. Called from the constructor.  
* [0.x.23]*
   Initialize the  [2.x.92]  field of the FiniteElement class.   Called from the constructor.  
* [0.x.24]*
   Initialize the  [2.x.93]  field of the FiniteElement   class. Called from the constructor.  
* [0.x.25]*
   Mapping from lexicographic to shape function numbering on first face.  
* [0.x.26]

include/deal.II-translator/fe/fe_q_iso_q1_0.txt
[0.x.0]*
 Implementation of a scalar Lagrange finite element  [2.x.0]  that defines the finite element space of continuous, piecewise linear elements with  [2.x.1]  subdivisions in each coordinate direction. It yields an element with the same number of degrees of freedom as the  [2.x.2]  elements but using linear interpolation instead of higher order one. This type of element is also called macro element in the literature as it really consists of several smaller elements, namely [1.x.0]<tt><sup>dim</sup></tt> such sub-cells.
*  The numbering of degrees of freedom is done in exactly the same way as in FE_Q of degree  [2.x.3]  See there for a detailed description on how degrees of freedom are numbered within one element.
*  This element represents a Q-linear finite element space on a reduced mesh size [1.x.1]. Its effect is equivalent to using FE_Q of degree one on a finer mesh by a factor  [2.x.4]  if an equivalent quadrature is used. However, this element reduces the flexibility in the choice of (adaptive) mesh size by exactly this factor  [2.x.5]  which typically reduces efficiency. On the other hand, comparing this element with  [2.x.6]  subdivisions to the FE_Q element of degree  [2.x.7]  on the same mesh shows that the convergence is typically much worse for smooth problems. In particular,  [2.x.8]  elements achieve interpolation orders of [1.x.2] in the L2 norm, whereas these elements reach only [1.x.3]. For these two reasons, this element is usually not very useful as a standalone. In addition, any evaluation of face terms on the boundaries within the elements becomes impossible with this element because deal.II does not have the equivalent of FEFaceValues for lower-dimensional integrals in the interior of cells.
*  Nonetheless, there are a few use cases where this element actually is useful:  [2.x.9] 
*   [2.x.10]  Systems of PDEs where certain variables demand for higher resolutions than the others and the additional degrees of freedom should be spent on increasing the resolution of linears instead of higher order polynomials, and you do not want to use two different meshes for the different components. This can be the case when irregularities (shocks) appear in the solution and stabilization techniques are used that work for linears but not higher order elements.  [2.x.11] 
*   [2.x.12]  Stokes/Navier Stokes systems such as the one discussed in  [2.x.13]  could be solved with Q2-iso-Q1 elements for velocities instead of Q2 elements. Combined with Q1 pressures they give a stable mixed element pair. However, they perform worse than the standard (Taylor-Hood  [2.x.14] ) approach in most situations.   [2.x.15] 
*   [2.x.16]  Preconditioning systems of FE_Q systems of higher order  [2.x.17]  with a preconditioner based on  [2.x.18]  elements: Some preconditioners like algebraic multigrid perform much better with linear elements than with higher order elements because they often implicitly assume a sparse connectivity between entries. Then, creating a preconditioner matrix based on these elements yields the same number of degrees of freedom (and a spectrally equivalent linear system), which can be combined with a (high order) system matrix in an iterative solver like CG.   [2.x.19]   [2.x.20] 
*  [1.x.4]
*  Due to the nature of these elements as a concatenation of linears, care must be taken when selecting quadrature formulas for this element. The standard choice for an element of  [2.x.21]  subelements is a formula <tt>QIterated<dim>(QGauss<1>(2), p)</tt>, which corresponds to the formula that would be used for integrating functions on a finer mesh. This is in contrast with FE_Q(p) where QGauss<dim>(p+1) is the default choice. In particular, care must be taken to not use a quadrature formula that evaluates the basis functions (and their derivatives) on sub-element boundaries as the gradients of piecewiese functions on internal boundaries are set to zero. No checks are performed internally to ensure that this is not the case
* 
*  - it is the user's responsibility to avoid these situations.
*  Also note that the usual deal.II routines for setting up sparsity patterns and assembling matrices do not make use of the increased sparsity in this element compared to FE_Q. This is because  [2.x.22]  assumes coupling between all degrees of freedom within the element, whereas FE_Q_iso_Q1 with more than one subdivision does have less coupling.

* 
* [0.x.1]*
   Construct a FE_Q_iso_Q1 element with a given number of subdivisions. The   number of subdivision is similar to the degree in FE_Q in the sense that   both elements produce the same number of degrees of freedom.  
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_Q_iso_q1<dim>(equivalent_degree)</tt>, with  [2.x.23]  and  [2.x.24]    equivalent_degree replaced by appropriate values.  
* [0.x.3]*
   Implementation of the corresponding function in the FiniteElement   class.  Since the current element is interpolatory, the nodal   values are exactly the support point values. Furthermore, since   the current element is scalar, the support point values need to   be vectors of length 1.  
* [0.x.4]*
    [2.x.25]  Functions to support hp    [2.x.26]   
* [0.x.5]*
    [2.x.27]   [2.x.28]   
* [0.x.6]

include/deal.II-translator/fe/fe_rannacher_turek_0.txt
[0.x.0]*
 Implementation of the Rannacher-Turek element. This element is used to generate a stable pair of function spaces for the Stokes equation without having to increase the polynomial degree of the velocity space as much as one would do for the stable Taylor-Hood element which uses the  [2.x.0]  pair for velocity and pressure. That said, like many other non-conforming elements, it can also be used for the discretization of the Laplace equation. The element was first described in R. Rannacher and S. Turek: "Simple non-conforming quadrilateral Stokes element", Numerical Methods for Partial Differential Equations, vol. 8, pp. 97-112, 1992.
*  The shape functions generated by this element are in general discontinuous, and consequently the element is not  [2.x.1]  conforming (i.e., it is a "non-conforming" element). However, the shape functions are constructed in such a way that the jump along faces has mean value zero, and consequently there is [1.x.0] sort of conformity in the element: a conforming element would have a pointwise zero jump, a completely discontinuous element like the FE_DGQ elements can have entirely arbitrary values for the jump across a face, and the current element is somewhere in the middle because its jump is nonzero but at least has mean value zero.
*  The element is currently implemented only in dimension 2, for the lowest polynomial order, and without hanging nodes and restriction/prolongation.
* 

*  [1.x.1]
*  [1.x.2]
*  The  [2.x.2]  "node values" are moments on faces.
*  [1.x.3]
*  To calculate the node values, we are using a QGauss rule on each face. By default, we are using a two point rule to integrate Rannacher-Turek functions exactly. But in order to be able to interpolate other functions with sufficient accuracy, the number of quadrature points used on a face can be adjusted in the constructor.
* 

* 
*  [2.x.3] 

* 
* [0.x.1]*
   Constructor for Rannacher-Turek element of given  [2.x.4]  using  [2.x.5]    n_face_support_points quadrature points on each face for interpolation.   Notice that the element of order 0 contains polynomials of degree 2.     The element is currently only implemented for order 0 in 2D.  
* [0.x.2]*
   Order of this element.  
* [0.x.3]*
   The number of quadrature points used on each face to evaluate node   functionals during interpolation.  
* [0.x.4]*
   The weights used on the faces to evaluate node functionals.  
* [0.x.5]*
   Compute generalized support points and their weights.  
* [0.x.6]*
   Return information about degrees of freedom per object as needed during   construction.  
* [0.x.7]

include/deal.II-translator/fe/fe_raviart_thomas_0.txt
[0.x.0]*
 Implementation of Raviart-Thomas (RT) elements. The Raviart-Thomas space is designed to solve problems in which the solution only lives in the space  [2.x.0] , rather than in the more commonly used space  [2.x.1] . In other words, the solution must be a vector field whose divergence is square integrable, but for which the gradient may not be square integrable. The typical application for this space (and these elements) is to the mixed formulation of the Laplace equation and related situations, see for example  [2.x.2] . The defining characteristic of functions in  [2.x.3]  is that they are in general discontinuous
* 
*  -  but that if you draw a line in 2d (or a surface in 3d), then the [1.x.0] component of the vector field must be continuous across the line (or surface) even though the tangential component may not be. As a consequence, the Raviart-Thomas element is constructed in such a way that (i) it is  [2.x.4]  "vector-valued", (ii) the shape functions are discontinuous, but (iii) the normal component of the vector field represented by each shape function is continuous across the faces of cells.
*  Other properties of the Raviart-Thomas element are that (i) it is  [2.x.5]  "not a primitive element"; (ii) the shape functions are defined so that certain integrals over the faces are either zero or one, rather than the common case of certain point values being either zero or one. (There is, however, the FE_RaviartThomasNodal element that uses point values.)
*  We follow the commonly used
* 
*  -  though confusing
* 
*  -  definition of the "degree" of RT elements. Specifically, the "degree" of the element denotes the polynomial degree of the [1.x.1] contained in the finite element space, even if the space may contain shape functions of higher polynomial degree. The lowest order element is consequently FE_RaviartThomas(0), i.e., the Raviart-Thomas element "of degree zero", even though the functions of this space are in general polynomials of degree one in each variable. This choice of "degree" implies that the approximation order of the function itself is [1.x.2], as with usual polynomial spaces. The numbering so chosen implies the sequence [1.x.3]
*  This class is not implemented for the codimension one case (<tt>spacedim != dim</tt>).
* 

*  [1.x.4]
*  The  [2.x.6]  "interpolation" operators associated with the RT element are constructed such that interpolation and computing the divergence are commuting operations. We require this from interpolating arbitrary functions as well as the #restriction matrices.  It can be achieved by two interpolation schemes, the simplified one in FE_RaviartThomasNodal and the original one here:
*  [1.x.5]
*  On edges or faces, the  [2.x.7]  "node values" are the moments of the normal component of the interpolated function with respect to the traces of the RT polynomials. Since the normal trace of the RT space of degree [1.x.6] on an edge/face is the space [1.x.7], the moments are taken with respect to this space.
*  [1.x.8]
*  Higher order RT spaces have interior nodes. These are moments taken with respect to the gradient of functions in [1.x.9] on the cell (this space is the matching space for RT<sub>k</sub> in a mixed formulation).
*  [1.x.10]
*  The node values above rely on integrals, which will be computed by quadrature rules themselves. The generalized support points are a set of points such that this quadrature can be performed with sufficient accuracy. The points needed are those of QGauss<sub>k+1</sub> on each face as well as QGauss<sub>k+1</sub> in the interior of the cell (or none for RT<sub>0</sub>).

* 
* [0.x.1]*
   Constructor for the Raviart-Thomas element of degree  [2.x.8]   
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_RaviartThomas<dim>(degree)</tt>, with  [2.x.9]  and  [2.x.10]    replaced by appropriate values.  
* [0.x.3]*
   This function returns  [2.x.11]  if the shape function  [2.x.12]  has   non-zero function values somewhere on the face  [2.x.13]      Right now, this is only implemented for RT0 in 1D. Otherwise, returns   always  [2.x.14]   
* [0.x.4]*
   Return a list of constant modes of the element. This method is currently   not correctly implemented because it returns ones for all components.  
* [0.x.5]*
   Only for internal use. Its full name is  [2.x.15]    function and it creates the  [2.x.16]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.17]    FiniteElementData.  
* [0.x.6]*
   Initialize the  [2.x.18]  field of the FiniteElement   class and fill the tables with interpolation weights (#boundary_weights   and #interior_weights). Called from the constructor.  
* [0.x.7]*
   Initialize the interpolation from functions on refined mesh cells onto   the father cell. According to the philosophy of the Raviart-Thomas   element, this restriction operator preserves the divergence of a function   weakly.  
* [0.x.8]*
   These are the factors multiplied to a function in the   #generalized_face_support_points when computing the integration. They are   organized such that there is one row for each generalized face support   point and one column for each degree of freedom on the face.     See the    [2.x.19]  "glossary entry on generalized support points"   for more information.  
* [0.x.9]*
   Precomputed factors for interpolation of interior degrees of freedom. The   rationale for this Table is the same as for #boundary_weights. Only, this   table has a third coordinate for the space direction of the component   evaluated.  
* [0.x.10]*
   Fill the necessary tables defined in base classes such as    [2.x.20]  declared in   fe.cc. We need to fill it with the correct values in case of non-standard,   flipped (rotated by +180 degrees) or rotated (rotated by +90 degrees)  faces. These are given in the form three flags (face_orientation, face_flip,   face_rotation), see the documentation in GeometryInfo<dim> and   this  [2.x.21]  "glossary entry on face orientation".     [1.x.11]     The dofs on a face are connected to a  [2.x.22]    matrix where here  [2.x.23] . In our example we can imagine the   following dofs on a quad (face):    
* [1.x.12]
*      We have for a local  [2.x.24]  with index    [2.x.25]  in y-direction   running from 0 to  [2.x.26]  and    [2.x.27]  and <code>j =   dof_index / n</code> (integer division). The indices  [2.x.28]  and    [2.x.29]  can then be used to compute the offset.     For our example of Raviart-Thomas elements this means if the   switches are  [2.x.30]  that means we rotate the   face first by + 90 degree(counterclockwise) then by another +180   degrees but we do not flip it since the face has standard   orientation. The flip axis is the diagonal from the lower left to the upper   right corner of the face. With these flags the configuration above becomes:   
* [1.x.13]
*      Note that the necessity of a permutation depends on the combination of the   three flags.     There is also a pattern for the sign change of the permuted shape functions   that depends on the combination of the switches. In the above example it   would be    
* [1.x.14]
*      The relevant table for the sign changes is declared in FE_PolyTensor.  
* [0.x.11]*
 The Raviart-Thomas elements with node functionals defined as point values in Gauss points.
*  [1.x.15]
*  For this Raviart-Thomas element, the node values are not cell and face moments with respect to certain polynomials, but the values in quadrature points. Following the general scheme for numbering degrees of freedom, the node values on edges are first, edge by edge, according to the natural ordering of the edges of a cell. The interior degrees of freedom are last.
*  For an RT-element of degree [1.x.16], we choose [1.x.17] Gauss points on each face. These points are ordered lexicographically with respect to the orientation of the face. This way, the normal component which is in [1.x.18] is uniquely determined. Furthermore, since this Gauss-formula is exact on [1.x.19], these node values correspond to the exact integration of the moments of the RT-space.
*  In the interior of the cells, the moments are with respect to an anisotropic [1.x.20] space, where the test functions are one degree lower in the direction corresponding to the vector component under consideration. This is emulated by using an anisotropic Gauss formula for integration.
*   [2.x.31]  The current implementation is for Cartesian meshes only. You must use MappingCartesian.
*   [2.x.32]  Even if this element is implemented for two and three space dimensions, the definition of the node values relies on consistently oriented faces in 3D. Therefore, care should be taken on complicated meshes.
* 

* 
*  [2.x.33]  The degree stored in the member variable  [2.x.34]  is higher by one than the constructor argument!

* 
* [0.x.12]*
   Constructor for the Raviart-Thomas element of degree  [2.x.35]   
* [0.x.13]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_RaviartThomasNodal<dim>(degree)</tt>, with  [2.x.36]  and  [2.x.37]    degree replaced by appropriate values.  
* [0.x.14]*
    [2.x.38]   [2.x.39]   
* [0.x.15]*
   Only for internal use. Its full name is  [2.x.40]    function and it creates the  [2.x.41]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.42]    FiniteElementData.  
* [0.x.16]*
   Compute the vector used for the  [2.x.43]  field passed   to the base class's constructor.  
* [0.x.17]*
   This function returns  [2.x.44]  if the shape function  [2.x.45]  has   non-zero function values somewhere on the face  [2.x.46]      Right now, this is only implemented for RT0 in 1D. Otherwise, returns   always  [2.x.47]   
* [0.x.18]*
   Initialize the  [2.x.48]  and    [2.x.49]  fields. Called from   the constructor.     See the    [2.x.50]  "glossary entry on generalized support points"   for more information.  
* [0.x.19]*
   Initialize the permutation pattern and the pattern of sign change.  
* [0.x.20]

include/deal.II-translator/fe/fe_rt_bubbles_0.txt
[0.x.0]*
 This class implements a curl-enhanced Raviart-Thomas elements, conforming with [1.x.0] space. The node functionals are defined as point values in Gauss-Lobatto points. These elements generate vector fields with normal components continuous between mesh cells. The purpose of this finite element is in localizing the interactions between degrees of freedom around the nodes when an appropriate quadrature rule is used, leading to a block-diagonal mass matrix (even with full-tensor coefficient).
*  The elements are defined through enrichment of classical Raviart-Thomas elements with extra curls, so that the [1.x.1] conformity is preserved, and the total number of degrees of freedom of FE_RT_Bubbles of order k is equal to the number of DoFs in [1.x.2] copies of FE_Q of order [1.x.3].
* 

* 
*  [2.x.0]  Unlike Raviart-Thomas, the lowest possible order for this enhanced finite element is 1, i.e.  [2.x.1] .
*  The matching pressure space for FE_RT_Bubbles of order [1.x.4] is FE_DGQ of order [1.x.5]. With the exact integration, this pair yields  [2.x.2] -st order of convergence in  [2.x.3] -norm for a vector variable and  [2.x.4] -th order in  [2.x.5] -norm for a scalar one (same as  [2.x.6] ).
*  For this enhanced Raviart-Thomas element, the node values are not cell and face moments with respect to certain polynomials, but the values in Gauss-Lobatto quadrature points. The nodal values on edges (faces in [1.x.6]) are evaluated first, according to the natural ordering of the edges (faces) of a cell. The interior degrees of freedom are evaluated last.
*  For an RT-Bubbles element of degree [1.x.7], we choose [1.x.8] Gauss-Lobatto points on each face. These points are ordered lexicographically with respect to the orientation of the face. In the interior of the cells, the values are computed using an anisotropic Gauss-Lobatto formula for integration. The mass matrix assembled with the use of this same quadrature rule, is block diagonal with blocks corresponding to quadrature points. See [1.x.9][1.x.10] for more details.
*  The elements of degree  [2.x.7]  in [1.x.11] and  [2.x.8]  in [1.x.12] are shown in the figures below (filled arrows indicate DoFs for which continuity across the edges (faces in [1.x.13]) is required).
*   [2.x.9] 
*   [2.x.10]  Implement restriction matrices

* 
* [0.x.1]*
   Constructor for the RT_Bubbles element of degree  [2.x.11]   
* [0.x.2]*
   Returns a string that uniquely identifies a finite element. This class   returns <tt>FE_RT_Bubbles<dim>(degree)</tt>, with  [2.x.12]  and  [2.x.13]    degree replaced by appropriate values.  
* [0.x.3]*
   Only for internal use. Its full name is  [2.x.14]    function and it creates the  [2.x.15]  vector that is needed   within the constructor to be passed to the constructor of  [2.x.16]    FiniteElementData.  
* [0.x.4]*
   Compute the vector used for the  [2.x.17]  field passed   to the base class's constructor.  
* [0.x.5]*
   Initialize the  [2.x.18]  and    [2.x.19]  fields. Called from   the constructor.     See the    [2.x.20]  "glossary entry on generalized support points"   for more information.  
* [0.x.6]*
   Initialize the permutation pattern and the pattern of sign change.  
* [0.x.7]

include/deal.II-translator/fe/fe_series_0.txt
[0.x.0]*
 This namespace offers functions to calculate expansion series of the solution on the reference element. Coefficients of expansion are often used to estimate local smoothness of the underlying FiniteElement field to decide on h- or p-adaptive refinement strategy.

* 
* [0.x.1]*
   A class to calculate expansion of a scalar FE (or a single component   of vector-valued FE) field into Fourier series on a reference element.   The exponential form of the Fourier series is  based on completeness   and Hermitian orthogonality of the set of exponential   functions  [2.x.0] .   For example in 1D the L2-orthogonality condition reads   [1.x.0]   Note that  [2.x.1] .     The arbitrary scalar FE field on the reference element can be expanded in   the complete orthogonal exponential basis as   [1.x.1]   From the orthogonality property of the basis, it follows that   [1.x.2]   It is this complex-valued expansion coefficients, that are calculated by   this class. Note that  [2.x.2] ,   where  [2.x.3]  are real-valued FiniteElement shape functions.   Consequently  [2.x.4]  and   we only need to compute  [2.x.5]  for positive indices    [2.x.6]  .  
* [0.x.2]*
     Constructor that initializes all required data structures.         The  [2.x.7]  defines the number of coefficients in     each direction,  [2.x.8]  is the  [2.x.9]  for which     expansion will be used and  [2.x.10]  is the  [2.x.11]  used to     integrate the expansion for each FiniteElement in  [2.x.12]          As the Fourier expansion can only be performed on scalar fields, this     class does not operate on vector-valued finite elements and will     therefore throw an assertion. However, each component of a finite element     field can be treated as a scalar field, respectively, on which Fourier     expansions are again possible. For this purpose, the optional parameter      [2.x.13]  defines which component of each FiniteElement will be used.     The default value of  [2.x.14]  only applies to scalar FEs, in which     case it indicates that the sole component is to be decomposed. For     vector-valued FEs, a non-default value must be explicitly provided.    
* [0.x.3]*
     A non-default constructor. The  [2.x.15]  defines the     number of modes in each direction,  [2.x.16]  is the  [2.x.17]      for which expansion will be used and  [2.x.18]  is the  [2.x.19]      used to integrate the expansion for each FiniteElement     in  [2.x.20]           [2.x.21]  Use a different constructor instead.    
* [0.x.4]*
     Calculate  [2.x.22]  of the cell vector field given by      [2.x.23]  corresponding to FiniteElement with      [2.x.24]  .    
* [0.x.5]*
     Return the number of coefficients in each coordinate direction for the     finite element associated with  [2.x.25]  in the provided  [2.x.26]     
* [0.x.6]*
     Calculate all transformation matrices to transfer the finite element     solution to the series expansion representation.         These matrices will be generated on demand by calling calculate() and     stored for recurring purposes. Usually, this operation consumes a lot of     workload. With this function, all matrices will be calculated in advance.     This way, we can separate their costly generation from the actual     application.    
* [0.x.7]*
     Write all transformation matrices of this object to a stream for the     purpose of serialization.         Since any of its transformation matrices has to be generated only once     for a given scenario, it is common practice to determine them in advance     calling precalculate_all_transformation_matrices() and keep them via     serialization.    
* [0.x.8]*
     Read all transformation matrices from a stream and recover them for this     object.    
* [0.x.9]*
     Test for equality of two series expansion objects.    
* [0.x.10]*
     Number of coefficients in each direction for each finite element in the     registered  [2.x.27]     
* [0.x.11]*
      [2.x.28]  for which transformation matrices will be calculated.    
* [0.x.12]*
      [2.x.29]  used in calculation of transformation matrices.    
* [0.x.13]*
     Angular frequencies  [2.x.30]  .    
* [0.x.14]*
     Transformation matrices for each FiniteElement.    
* [0.x.15]*
     Auxiliary vector to store unrolled coefficients.    
* [0.x.16]*
     Which component of FiniteElement should be used to calculate the     expansion.    
* [0.x.17]*
   A class to calculate expansion of a scalar FE (or a single component   of vector-valued FE) field into series of Legendre functions on a   reference element.     Legendre functions are solutions to Legendre's differential equation   [1.x.3]   and can be expressed using Rodrigues' formula   [1.x.4]   These polynomials are orthogonal with respect to the  [2.x.31]  inner   product on the interval  [2.x.32]    [1.x.5]   and are complete.   A family of  [2.x.33] -orthogonal polynomials on  [2.x.34]  can be   constructed via   [1.x.6]       An arbitrary scalar FE field on the reference element  [2.x.35]  can be   expanded in the complete orthogonal basis as   [1.x.7]   From the orthogonality property of the basis, it follows that   [1.x.8]   This class calculates coefficients  [2.x.36]  using    [2.x.37] -dimensional Legendre polynomials constructed from    [2.x.38]  using tensor product rule.  
* [0.x.18]*
     Constructor that initializes all required data structures.         The  [2.x.39]  defines the number of coefficients in     each direction,  [2.x.40]  is the  [2.x.41]  for which     expansion will be used and  [2.x.42]  is the  [2.x.43]  used to     integrate the expansion for each FiniteElement in  [2.x.44]          As the Legendre expansion can only be performed on scalar fields, this     class does not operate on vector-valued finite elements and will     therefore throw an assertion. However, each component of a finite element     field can be treated as a scalar field, respectively, on which Legendre     expansions are again possible. For this purpose, the optional parameter      [2.x.45]  defines which component of each FiniteElement will be used.     The default value of  [2.x.46]  only applies to scalar FEs, in which     case it indicates that the sole component is to be decomposed. For     vector-valued FEs, a non-default value must be explicitly provided.    
* [0.x.19]*
     A non-default constructor. The  [2.x.47]  defines the number     of coefficients in each direction,  [2.x.48]  is the  [2.x.49]      for which expansion will be used and  [2.x.50]  is the  [2.x.51]      used to integrate the expansion for each FiniteElement in  [2.x.52]           [2.x.53]  Use a different constructor instead.    
* [0.x.20]*
     Calculate  [2.x.54]  of the cell vector field given by      [2.x.55]  corresponding to FiniteElement with      [2.x.56]  .    
* [0.x.21]*
     Return the number of coefficients in each coordinate direction for the     finite element associated with  [2.x.57]  in the provided  [2.x.58]     
* [0.x.22]*
     Calculate all transformation matrices to transfer the finite element     solution to the series expansion representation.         These matrices will be generated on demand by calling calculate() and     stored for recurring purposes. Usually, this operation consumes a lot of     workload. With this function, all matrices will be calculated in advance.     This way, we can separate their costly generation from the actual     application.    
* [0.x.23]*
     Write all transformation matrices of this object to a stream for the     purpose of serialization.         Since any of its transformation matrices has to be generated only once     for a given scenario, it is common practice to determine them in advance     calling precalculate_all_transformation_matrices() and keep them via     serialization.    
* [0.x.24]*
     Read all transformation matrices from a stream and recover them for this     object.    
* [0.x.25]*
     Test for equality of two series expansion objects.    
* [0.x.26]*
     Number of coefficients in each direction for each finite element in the     registered  [2.x.59]     
* [0.x.27]*
      [2.x.60]  for which transformation matrices will be calculated.    
* [0.x.28]*
      [2.x.61]  used in calculation of transformation matrices.    
* [0.x.29]*
     Transformation matrices for each FiniteElement.    
* [0.x.30]*
     Auxiliary vector to store unrolled coefficients.    
* [0.x.31]*
     Which component of FiniteElement should be used to calculate the     expansion.    
* [0.x.32]*
   Calculate the  [2.x.62]  of subsets of  [2.x.63]  defined by    [2.x.64]  being constant. Return the pair of vectors of predicate values   and the vector of calculated subset norms.      [2.x.65]  should return a pair of  [2.x.66]  and <code>unsigned   int</code>. The former is a flag whether a given TableIndices should be   used in calculation, whereas the latter is the unrolled value of indices   according to which the subsets of coefficients will be formed.     Only those coefficients will be considered which are larger than    [2.x.67]     
*  [2.x.68]  Only the following values of  [2.x.69]  are implemented and make   sense in this case: mean, L1_norm, L2_norm, Linfty_norm. The mean norm ca   only be applied to real valued coefficients.  
* [0.x.33]*
   Linear regression least-square fit of  [2.x.70] .   The size of the input vectors should be equal and more than 1.   The returned pair will contain  [2.x.71]  (first) and  [2.x.72]  (second).  
* [0.x.34]

include/deal.II-translator/fe/fe_simplex_p_0.txt
[0.x.0]*
 Base class of FE_SimplexP and FE_SimplexDGP.
* 

* 
*  [2.x.0]  Only implemented for 2D and 3D.
* 

* 
*  [2.x.1] 

* 
* [0.x.1]*
   Constructor.  
* [0.x.2]*
   Return a list of constant modes of the element. For this element, the   list consists of true arguments for all components.  
* [0.x.3]*
    [2.x.2]   [2.x.3]     
*  [2.x.4]  Only implemented for  [2.x.5]   
* [0.x.4]*
    [2.x.6]   [2.x.7]     
*  [2.x.8]  Only implemented for  [2.x.9]   
* [0.x.5]*
    [2.x.10]   [2.x.11]   
* [0.x.6]*
    [2.x.12]   [2.x.13]   
* [0.x.7]*
    [2.x.14]   [2.x.15]   
* [0.x.8]*
    [2.x.16]   [2.x.17]   
* [0.x.9]*
 Implementation of a scalar Lagrange finite element  [2.x.18]  that yields the finite element space of continuous, piecewise polynomials of degree  [2.x.19] .
* 

* 
*  [2.x.20] 

* 
* [0.x.10]*
   Constructor.  
* [0.x.11]*
    [2.x.21]   [2.x.22]   
* [0.x.12]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_SimplexP<dim>(degree)</tt>, with  [2.x.23]  and  [2.x.24]    replaced by appropriate values.  
* [0.x.13]*
    [2.x.25]   [2.x.26]   
* [0.x.14]*
    [2.x.27]   [2.x.28]   
* [0.x.15]*
    [2.x.29]   [2.x.30]   
* [0.x.16]*
 Implementation of a scalar discontinuous Lagrange finite element  [2.x.31] , sometimes denoted as  [2.x.32] , that yields the finite element space of discontinuous, piecewise polynomials of degree  [2.x.33] .
* 

* 
*  [2.x.34] 

* 
* [0.x.17]*
   Constructor.  
* [0.x.18]*
    [2.x.35]   [2.x.36]   
* [0.x.19]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_SimplexDGP<dim>(degree)</tt>, with  [2.x.37]  and  [2.x.38]    replaced by appropriate values.  
* [0.x.20]*
    [2.x.39]   [2.x.40]   
* [0.x.21]*
    [2.x.41]   [2.x.42]   
* [0.x.22]*
    [2.x.43]   [2.x.44]   
* [0.x.23]

include/deal.II-translator/fe/fe_simplex_p_bubbles_0.txt
[0.x.0]*


* 
*  [2.x.0] 
*  Many explicit time integration schemes require solving a mass matrix at each time step. There are various ways around this requirement
* 
*  - for example,  [2.x.1]  replaces the mass matrix with a diagonal approximation, which makes the solution step trivial. In  [2.x.2] , and also commonly for tensor-product elements, this is done by computing the mass matrix with a lower-order quadrature point based on the nodes of the finite element (i.e., the nodal quadrature rule one obtains by using the shape functions as an interpolatory basis).
*  A major drawback of standard simplex-based finite elements is that they cannot be used with nodal quadrature since some of the quadrature weights end up being either zero or negative, resulting in either an unsolvable or unstable approximation to the mass matrix. For example: the shape functions of FE_P<2>(2) with support points at vertices have mean values of zero so that element cannot be used with mass lumping.
*  This element avoids this issue by replacing the shape functions of FE_P with an augmented space amendable to the construction of nodal quadrature rules. For example, on the triangle a single basis function is added corresponding to interpolation at the centroid (and all other basis functions are updated to preserve the partition of unity property). This results in shape functions with positive means (i.e., a valid nodal quadrature formula). Similarly, in 3D, the polynomial space of FE_P<3>(2) is enriched with five additional degrees of freedom (where four have support points at face centroids and one has a support point at the centroid) to enable construction of valid nodal quadrature rule.
*  Since this FE space includes bubbles (i.e., extra functions which are nonzero only on element interiors), the polynomial degrees of the component basis functions are higher than the actual approximation degree of the element. For example, with a constructor argument  [2.x.3]  in 3D, the polynomials are in fact cubic (degree 3) but the order of the approximation is the same as if we were using quadratic (degree 2) finite elements.
*  The 2D quadratic element was first described in  [2.x.4] . The 3D quadratic element implemented here was first described in  [2.x.5] . Higher degree elements amendable to lumping exist but are not yet implemented in this class.

* 
* [0.x.1]*
   Constructor, taking the approximation degree as an argument. The   polynomial space is typically one degree higher than the approximation   space for this element: see the general documentation of this class for   more information.    
*  [2.x.6]  For  [2.x.7]  this element is equivalent to FE_P(1).  
* [0.x.2]*
    [2.x.8]   [2.x.9]   
* [0.x.3]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_SimplexP_Bubbles<dim,spacedim>(degree)</tt>, with    [2.x.10]   [2.x.11]  and  [2.x.12]  replaced by appropriate values. As   usual,  [2.x.13]  is omitted in the codimension zero case.  
* [0.x.4]*
    [2.x.14]   [2.x.15]   
* [0.x.5]*
   Degree of the approximation (i.e., the constructor argument).  
* [0.x.6]

include/deal.II-translator/fe/fe_system_0.txt
[0.x.0]*
 This class provides an interface to group several elements together into one, vector-valued element. As example, consider the Taylor-Hood element that is used for the solution of the Stokes and Navier-Stokes equations: There, the velocity (of which there are as many components as the dimension  [2.x.0]  of the domain) is discretized with  [2.x.1]  elements and the pressure with  [2.x.2]  elements. Mathematically, the finite element space for the coupled problem is then often written as  [2.x.3]  where the exponentiation is understood to be the tensor product of spaces
* 
*  -  i.e., in 2d, we have  [2.x.4] 
* 
*  -  and tensor products lead to vectors where each component of the vector-valued function space corresponds to a scalar function in one of the  [2.x.5]  or  [2.x.6]  spaces. Using the FESystem class, this space is created using

* 
* [1.x.0]
*  The creation of this element here corresponds to taking tensor-product powers of the  [2.x.7]  element in the first line of the list of arguments to the FESystem constructor, and then concatenation via another tensor product with the element in the second line. This kind of construction is used, for example, in the  [2.x.8]  tutorial program.
*  Similarly,  [2.x.9]  solves an elasticity equation where we need to solve for the displacement of a solid object. The displacement again has  [2.x.10]  components if the domain is  [2.x.11] -dimensional, and so the combined finite element is created using

* 
* [1.x.1]
*  where now each (vector) component of the combined element corresponds to a  [2.x.12]  space.
*  To the outside world, FESystem objects look just like a usual finite element object, they just happen to be composed of several other finite elements that are possibly of different type. These "base elements" can themselves have multiple components and, in particular, could also be vector-valued
* 
*  -  for example, if one of the base elements is an FESystem itself (see also below). An example is given in the documentation of namespace  [2.x.13]  when using the "tensor product" strategy.
*  %Vector valued elements are discussed in a number of tutorial programs, for example  [2.x.14] ,  [2.x.15] ,  [2.x.16] ,  [2.x.17] , and in particular in the  [2.x.18]  module.
*   [2.x.19] 
* 

*  [1.x.2]
*  An FESystem, except in the most trivial case, produces a vector-valued finite element with several components. The number of components n_components() corresponds to the dimension of the solution function in the PDE system, and correspondingly also to the number of equations your PDE system has. For example, the mixed Laplace system covered in  [2.x.20]  has  [2.x.21]  components in  [2.x.22]  space dimensions: the scalar pressure and the  [2.x.23]  components of the velocity vector. Similarly, the elasticity equation covered in  [2.x.24]  has  [2.x.25]  components in  [2.x.26]  space dimensions. In general, the number of components of a FESystem element is the accumulated number of components of all base elements times their multiplicities. A bit more on components is also given in the  [2.x.27]  "glossary entry on components".
*  While the concept of components is important from the viewpoint of a partial differential equation, the finite element side looks a bit different Since not only FESystem, but also vector-valued elements like FE_RaviartThomas, have several components. The concept needed here is a  [2.x.28]  "block". Each block encompasses the set of degrees of freedom associated with a single base element of an FESystem, where base elements with multiplicities count multiple times. These blocks are usually addressed using the information in  [2.x.29]  The number of blocks of a FESystem object is simply the sum of all multiplicities of base elements and is given by n_blocks().
*  For example, the FESystem for the Taylor-Hood element for the three-dimensional Stokes problem can be built using the code

* 
* [1.x.3]
*  or more concisely via

* 
* [1.x.4]
*  or even shorter (mimicking the mathematical notation that we are dealing with a  [2.x.30]  element):

* 
* [1.x.5]
* 
*  This example creates an FESystem  [2.x.31]  with four components, three for the velocity components and one for the pressure, and also four blocks with the degrees of freedom of each of the velocity components and the pressure in a separate block each. The number of blocks is four since the first base element is repeated three times.
*  On the other hand, a Taylor-Hood element can also be constructed using
* 

* 
* [1.x.6]
* 
*  The FESystem  [2.x.32]  created here has the same four components, but the degrees of freedom are distributed into only two blocks. The first block has all velocity degrees of freedom from  [2.x.33]  while the second block contains the pressure degrees of freedom. Note that while  [2.x.34]  itself has 3 blocks, the FESystem  [2.x.35]  does not attempt to split  [2.x.36]  into its base elements but considers it a block of its own. By blocking all velocities into one system first as in  [2.x.37]  we achieve the same block structure that would be generated if instead of using a  [2.x.38]  element for the velocities we had used vector-valued base elements, for instance like using a mixed discretization of Darcy's law using
* 

* 
* [1.x.7]
* 
*  This example also produces a system with four components, but only two blocks.
*  In most cases, the composed element behaves as if it were a usual element. It just has more degrees of freedom than most of the "common" elements. However the underlying structure is visible in the restriction, prolongation and interface constraint matrices, which do not couple the degrees of freedom of the base elements. E.g. the continuity requirement is imposed for the shape functions of the subobjects separately; no requirement exist between shape functions of different subobjects, i.e. in the above example: on a hanging node, the respective value of the  [2.x.39]  velocity is only coupled to  [2.x.40]  at the vertices and the line on the larger cell next to this vertex, but there is no interaction with  [2.x.41]  and  [2.x.42]  of this or the other cell.
* 

*  [1.x.8]
*  The overall numbering of degrees of freedom is as follows: for each subobject (vertex, line, quad, or hex), the degrees of freedom are numbered such that we run over all subelements first, before turning for the next dof on this subobject or for the next subobject. For example, for an element of three components in one space dimension, the first two components being cubic lagrange elements and the third being a quadratic lagrange element, the ordering for the system <tt>s=(u,v,p)</tt> is:
*   [2.x.43]   [2.x.44]  First vertex: <tt>u0, v0, p0 = s0, s1, s2</tt>  [2.x.45]  Second vertex: <tt>u1, v1, p1 = s3, s4, s5</tt>  [2.x.46]  First component on the line: <tt>u2, u3 = s4, s5</tt>  [2.x.47]  Second component on the line: <tt>v2, v3 = s6, s7</tt>.  [2.x.48]  Third component on the line: <tt>p2 = s8</tt>.  [2.x.49]  That said, you should not rely on this numbering in your application as these %internals might change in future. Rather use the functions system_to_component_index() and component_to_system_index().
*  For more information on the template parameter <tt>spacedim</tt> see the documentation of Triangulation.
* 

* 
*  [2.x.50] 
* 

* 
* [0.x.1]*
   Delete default constructor so that `FESystem(FEPairs &&... fe_pairs)` is   not accidentally picked if no FiniteElement is provided.  
* [0.x.2]*
   Constructor. Take a finite element and the number of elements you want to   group together using this class.     The object  [2.x.51]  is not actually used for anything other than creating a   copy that will then be owned by the current object. In other words, it is   completely fine to call this constructor with a temporary object for the   finite element, as in this code snippet:  
* [1.x.9]
*    Here,  [2.x.52]  constructs an unnamed, temporary object   that is passed to the FESystem constructor to create a finite element   that consists of two components, both of which are quadratic FE_Q   elements. The temporary is destroyed again at the end of the code that   corresponds to this line, but this does not matter because FESystem   creates its own copy of the FE_Q object.     This constructor (or its variants below) is used in essentially all   tutorial programs that deal with vector valued problems. See  [2.x.53] ,    [2.x.54] ,  [2.x.55]  and others for use cases. Also see the module on    [2.x.56]  "Handling vector valued problems".      [2.x.57]       [2.x.58]  fe The finite element that will be used to represent the   components of this composed element.    [2.x.59]  n_elements An integer denoting how many copies of  [2.x.60]  this   element should consist of.  
* [0.x.3]*
   Constructor for mixed discretizations with two base elements.     See the other constructor above for an explanation of the general idea of   composing elements.  
* [0.x.4]*
   Constructor for mixed discretizations with three base elements.     See the other constructor above for an explanation of the general idea of   composing elements.  
* [0.x.5]*
   Constructor for mixed discretizations with four base elements.     See the first of the other constructors above for an explanation of the   general idea of composing elements.  
* [0.x.6]*
   Constructor for mixed discretizations with five base elements.     See the first of the other constructors above for an explanation of the   general idea of composing elements.  
* [0.x.7]*
   Same as above but for any number of base elements. Pointers to the base   elements and their multiplicities are passed as vectors to this   constructor. The lengths of these vectors are assumed to be equal.     As above, the finite element objects pointed to by the first argument are   not actually used other than to create copies internally. Consequently,   you can delete these pointers immediately again after calling this   constructor.     [1.x.10]     Using this constructor is a bit awkward at times because you need to pass   two vectors in a place where it may not be straightforward to construct   such a vector
* 
*  -  for example, in the member initializer list of a class   with an FESystem member variable. For example, if your main class looks   like this:  
* [1.x.11]
*      Using the C++11 language standard (or later) you could do something like   this to create an element with four base elements and multiplicities 1,   2, 3 and 4:  
* [1.x.12]
*    This creates two vectors in place and initializes them using the   initializer list enclosed in braces  [2.x.61] .     This code has a problem: it creates four memory leaks because the first   vector above is created with pointers to elements that are allocated with    [2.x.62]  but never destroyed.     The solution to the second of these problems is to create two static   member functions that can create vectors. Here is an example:  
* [1.x.13]
*      The way this works is that we have two static member functions that   create the necessary vectors to pass to the constructor of the member   variable  [2.x.63] . They need to be static because they are called   during the constructor of  [2.x.64]  at a time when the    [2.x.65]  object isn't fully constructed and, consequently,   regular member functions cannot be called yet.     The code above does not solve the problem with the memory leak yet,   though: the  [2.x.66]  function creates a vector of   pointers, but nothing destroys these. This is the solution:  
* [1.x.14]
*      In other words, the vector we receive from the    [2.x.67]  is packed into a temporary object of type    [2.x.68] ; we then get the vector from this   temporary object immediately to pass it to the constructor of    [2.x.69]    destructor is called at the end of the entire expression (after the   constructor of  [2.x.70]  has finished) and destroys the elements of   the temporary vector. Voila: not short nor elegant, but it works!  
* [0.x.8]*
   Constructor taking an arbitrary number of parameters of type    [2.x.71]  spacedim>>, unsigned   int></code>. In combination with  [2.x.72]  this allows to   construct FESystem objects as follows:  
* [1.x.15]
*      The `fe_1` and `fe_2` objects are not actually used for anything other than   creating a copy that will then be owned by the current object. In other   words, it is completely fine to call this constructor with a temporary   object for the finite element, as in this code snippet:  
* [1.x.16]
*    Here,  [2.x.73]  constructs an unnamed, temporary object   that is passed to the FESystem constructor to create a finite element   that consists of two components, both of which are quadratic FE_Q   elements. The temporary is destroyed again at the end of the code that   corresponds to this line, but this does not matter because FESystem   creates its own copy of the FE_Q object.     As a shortcut, this constructor also allows calling  
* [1.x.17]
*    instead of the more explicit  
* [1.x.18]
*    In other words, if no multiplicity for an element is explicitly specified   via the exponentiation operation, then it is assumed to be one (as one   would have expected).      [2.x.74]  This feature is not available for Intel compilers   prior to version 19.0. Defining this   constructor leads to internal compiler errors for Intel compilers prior   to 18.0.  
* [0.x.9]*
   Same as above allowing the following syntax:  
* [1.x.19]
*       [2.x.75]  This feature is not available for Intel compilers   prior to version 19.0. The constructor is just not selected for overload   resolution.  
* [0.x.10]*
   Copy constructor. This constructor is deleted, i.e., copying   FESystem objects is not allowed.  
* [0.x.11]*
   Move constructor.  
* [0.x.12]*
   Destructor.  
* [0.x.13]*
   Return a string that uniquely identifies a finite element. This element   returns a string that is composed of the strings  [2.x.76]  nameN   returned by the basis elements. From these, we create a sequence   <tt>FESystem<dim>[name1^m1-name2^m2-...-nameN^mN]</tt>, where  [2.x.77]  are   the multiplicities of the basis elements. If a multiplicity is equal to   one, then the superscript is omitted.  
* [0.x.14]*
    [2.x.78]   [2.x.79]   
* [0.x.15]*
   Return the value of the  [2.x.80]  shape function at the point  [2.x.81]    [2.x.82]  is   a point on the reference element. Since this finite element is always   vector-valued, we return the value of the only non-zero component of the   vector value of this shape function. If the shape function has more than   one non-zero component (which we refer to with the term non-primitive),   then throw an exception of type  [2.x.83]      An  [2.x.84]  is thrown if the shape values of the    [2.x.85]  (corresponding to the  [2.x.86]  shape function) depend on   the shape of the cell in real space.  
* [0.x.16]*
   Return the value of the  [2.x.87]  vector component of the  [2.x.88]    shape function at the point  [2.x.89]  See the FiniteElement base class for   more information about the semantics of this function.     Since this element is vector valued in general, it relays the computation   of these values to the base elements.  
* [0.x.17]*
   Return the gradient of the  [2.x.90]  shape function at the point  [2.x.91]   [2.x.92]    is a point on the reference element, and likewise the gradient is the   gradient on the unit cell with respect to unit cell coordinates. Since   this finite element is always vector-valued, we return the value of the   only non-zero component of the vector value of this shape function. If   the shape function has more than one non-zero component (which we refer   to with the term non-primitive), then throw an exception of type  [2.x.93]    ExcShapeFunctionNotPrimitive.     An  [2.x.94]  is thrown if the shape values of the    [2.x.95]  (corresponding to the  [2.x.96]  shape function) depend on   the shape of the cell in real space.  
* [0.x.18]*
   Return the gradient of the  [2.x.97]  vector component of the  [2.x.98]    shape function at the point  [2.x.99]  See the FiniteElement base class for   more information about the semantics of this function.     Since this element is vector valued in general, it relays the computation   of these values to the base elements.  
* [0.x.19]*
   Return the tensor of second derivatives of the  [2.x.100]  shape function at   point  [2.x.101]  on the unit cell. The derivatives are derivatives on the unit   cell with respect to unit cell coordinates. Since this finite element is   always vector-valued, we return the value of the only non-zero component   of the vector value of this shape function. If the shape function has   more than one non-zero component (which we refer to with the term non-   primitive), then throw an exception of type  [2.x.102]    ExcShapeFunctionNotPrimitive.     An  [2.x.103]  is thrown if the shape values of the    [2.x.104]  (corresponding to the  [2.x.105]  shape function) depend on   the shape of the cell in real space.  
* [0.x.20]*
   Return the second derivatives of the  [2.x.106]  vector component of   the  [2.x.107]  shape function at the point  [2.x.108]  See the FiniteElement base   class for more information about the semantics of this function.     Since this element is vector valued in general, it relays the computation   of these values to the base elements.  
* [0.x.21]*
   Return the tensor of third derivatives of the  [2.x.109]  shape function at   point  [2.x.110]  on the unit cell. The derivatives are derivatives on the unit   cell with respect to unit cell coordinates. Since this finite element is   always vector-valued, we return the value of the only non-zero component   of the vector value of this shape function. If the shape function has   more than one non-zero component (which we refer to with the term non-   primitive), then throw an exception of type  [2.x.111]    ExcShapeFunctionNotPrimitive.     An  [2.x.112]  is thrown if the shape values of the    [2.x.113]  (corresponding to the  [2.x.114]  shape function) depend on   the shape of the cell in real space.  
* [0.x.22]*
   Return the third derivatives of the  [2.x.115]  vector component of   the  [2.x.116]  shape function at the point  [2.x.117]  See the FiniteElement base   class for more information about the semantics of this function.     Since this element is vector valued in general, it relays the computation   of these values to the base elements.  
* [0.x.23]*
   Return the tensor of fourth derivatives of the  [2.x.118]  shape function at   point  [2.x.119]  on the unit cell. The derivatives are derivatives on the unit   cell with respect to unit cell coordinates. Since this finite element is   always vector-valued, we return the value of the only non-zero component   of the vector value of this shape function. If the shape function has   more than one non-zero component (which we refer to with the term non-   primitive), then throw an exception of type  [2.x.120]    ExcShapeFunctionNotPrimitive.     An  [2.x.121]  is thrown if the shape values of the    [2.x.122]  (corresponding to the  [2.x.123]  shape function) depend on   the shape of the cell in real space.  
* [0.x.24]*
   Return the fourth derivatives of the  [2.x.124]  vector component of   the  [2.x.125]  shape function at the point  [2.x.126]  See the FiniteElement base   class for more information about the semantics of this function.     Since this element is vector valued in general, it relays the computation   of these values to the base elements.  
* [0.x.25]*
   Return the matrix interpolating from the given finite element to the   present one. The size of the matrix is then  [2.x.127]  times   <tt>source.n_dofs_per_cell()</tt>.     These matrices are available if source and destination element are both    [2.x.128]  elements, have the same number of base elements with same   element multiplicity, and if these base elements also implement their  [2.x.129]    get_interpolation_matrix functions. Otherwise, an exception of type    [2.x.130]  is thrown.  
* [0.x.26]*
   Access to a composing element. The index needs to be smaller than the   number of base elements. Note that the number of base elements may in   turn be smaller than the number of components of the system element, if   the multiplicities are greater than one.  
* [0.x.27]*
   This function returns  [2.x.131]  if the shape function  [2.x.132]  has   non-zero function values somewhere on the face  [2.x.133]   
* [0.x.28]*
   Projection from a fine grid space onto a coarse grid space. Overrides the   respective method in FiniteElement, implementing lazy evaluation   (initialize when requested).     If this projection operator is associated with a matrix  [2.x.134]  then the   restriction of this matrix  [2.x.135]  to a single child cell is returned   here.     The matrix  [2.x.136]  is the concatenation or the sum of the cell matrices  [2.x.137]    P_i, depending on the value of  [2.x.138]    This distinguishes interpolation (concatenation) and projection with   respect to scalar products (summation).     Row and column indices are related to coarse grid and fine grid spaces,   respectively, consistent with the definition of the associated operator.     If projection matrices are not implemented in the derived finite element   class, this function aborts with an exception of type    [2.x.139]  You can check whether this would happen   by first calling the restriction_is_implemented() or the   isotropic_restriction_is_implemented() function.  
* [0.x.29]*
   Embedding matrix between grids. Overrides the respective method in   FiniteElement, implementing lazy evaluation (initialize when queried).     The identity operator from a coarse grid space into a fine grid space is   associated with a matrix  [2.x.140]  The restriction of this matrix  [2.x.141]  to a   single child cell is returned here.     The matrix  [2.x.142]  is the concatenation, not the sum of the cell matrices  [2.x.143]    P_i. That is, if the same non-zero entry <tt>j,k</tt> exists in two   different child matrices  [2.x.144]  the value should be the same in both   matrices and it is copied into the matrix  [2.x.145]  only once.     Row and column indices are related to fine grid and coarse grid spaces,   respectively, consistent with the definition of the associated operator.     These matrices are used by routines assembling the prolongation matrix   for multi-level methods.  Upon assembling the transfer matrix between   cells using this matrix array, zero elements in the prolongation matrix   are discarded and will not fill up the transfer matrix.     If prolongation matrices are not implemented in one of the base finite   element classes, this function aborts with an exception of type    [2.x.146]  You can check whether this would happen   by first calling the prolongation_is_implemented() or the   isotropic_prolongation_is_implemented() function.  
* [0.x.30]*
   Given an index in the natural ordering of indices on a face, return the   index of the same degree of freedom on the cell.     To explain the concept, consider the case where we would like to know   whether a degree of freedom on a face, for example as part of an FESystem   element, is primitive. Unfortunately, the is_primitive() function in the   FiniteElement class takes a cell index, so we would need to find the cell   index of the shape function that corresponds to the present face index.   This function does that.     Code implementing this would then look like this:  
* [1.x.20]
*    The function takes additional arguments that account for the fact that   actual faces can be in their standard ordering with respect to the cell   under consideration, or can be flipped, oriented, etc.      [2.x.147]  face_dof_index The index of the degree of freedom on a face. This   index must be between zero and dofs_per_face.    [2.x.148]  face The number of the face this degree of freedom lives on. This   number must be between zero and  [2.x.149]     [2.x.150]  face_orientation One part of the description of the orientation of   the face. See    [2.x.151] .    [2.x.152]  face_flip One part of the description of the orientation of the   face. See    [2.x.153] .    [2.x.154]  face_rotation One part of the description of the orientation of   the face. See    [2.x.155] .    [2.x.156]  The index of this degree of freedom within the set of degrees of   freedom on the entire cell. The returned value will be between zero and   dofs_per_cell.  
* [0.x.31]*
   Implementation of the respective function in the base class.  
* [0.x.32]*
   Implementation of the respective function in the base class.  
* [0.x.33]*
   Return a list of constant modes of the element. The returns table has as   many rows as there are components in the element and dofs_per_cell   columns. To each component of the finite element, the row in the returned   table contains a basis representation of the constant function 1 on the   element. Concatenates the constant modes of each base element.  
* [0.x.34]*
    [2.x.157]  Functions to support hp    [2.x.158]   
* [0.x.35]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".     This function returns  [2.x.159]  if and only if all its base elements return    [2.x.160]  for this function.  
* [0.x.36]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Base elements of this element will have to implement this function. They   may only provide interpolation matrices for certain source finite   elements, for example those from the same family. If they don't implement   interpolation from a given element, then they must throw an exception of   type  [2.x.161]  which   will get propagated out from this element.  
* [0.x.37]*
   Return the matrix interpolating from a face of one element to the   subface of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>.     Base elements of this element will have to implement this function. They   may only provide interpolation matrices for certain source finite   elements, for example those from the same family. If they don't implement   interpolation from a given element, then they must throw an exception of   type  [2.x.162]  which   will get propagated out from this element.  
* [0.x.38]*
   If, on a vertex, several finite elements are active, the hp-code first   assigns the degrees of freedom of each of these FEs different global   indices. It then calls this function to find out which of them should get   identical values, and consequently can receive the same global DoF index.   This function therefore returns a list of identities between DoFs of the   present finite element object with the DoFs of  [2.x.163]  which is a   reference to a finite element object representing one of the other finite   elements active on this particular vertex. The function computes which of   the degrees of freedom of the two finite element objects are equivalent,   both numbered between zero and the corresponding value of   n_dofs_per_vertex() of the two finite elements. The first index of each   pair denotes one of the vertex dofs of the present element, whereas the   second is the corresponding index of the other finite element.  
* [0.x.39]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on lines.  
* [0.x.40]*
   Same as hp_vertex_dof_indices(), except that the function treats degrees   of freedom on quads.  
* [0.x.41]*
    [2.x.164]   [2.x.165]   
* [0.x.42]*
   Implementation of the    [2.x.166]    function.     This function simply calls    [2.x.167]    of the base elements and re-assembles everything into the output   argument. If a base element is non-interpolatory the corresponding dof   values are filled with "signaling" NaNs instead.     The function fails if none of the base elements of the FESystem are   interpolatory.  
* [0.x.43]*
   Determine an estimate for the memory consumption (in bytes) of this   object.     This function is made virtual, since finite element objects are usually   accessed through pointers to their base class, rather than the class   itself.  
* [0.x.44]*
   Do the work for the three <tt>fill_fe*_values</tt> functions.     Calls (among other things) <tt>fill_fe_([sub]face)_values</tt> of the   base elements. Calls  [2.x.168]  if   <tt>face_no==invalid_face_no</tt> and <tt>sub_no==invalid_face_no</tt>;   calls  [2.x.169]  if <tt>face_no==invalid_face_no</tt> and   <tt>sub_no!=invalid_face_no</tt>; and calls  [2.x.170]  if   <tt>face_no!=invalid_face_no</tt> and <tt>sub_no!=invalid_face_no</tt>.  
* [0.x.45]*
   Value to indicate that a given face or subface number is invalid.  
* [0.x.46]*
   Pointers to underlying finite element objects.     This object contains a pointer to each contributing element of a mixed   discretization and its multiplicity. It is created by the constructor and   constant afterwards.  
* [0.x.47]*
   An index table that maps generalized support points of a base element   to the vector of generalized support points of the FE System.   It holds true that  
* [1.x.21]
*    for each base element (indexed by i) and each g. s. point of the base   element (index by j).  
* [0.x.48]*
   This function is simply singled out of the constructors since there are   several of them. It sets up the index table for the system as well as  [2.x.171]    restriction and  [2.x.172]  matrices.  
* [0.x.49]*
   Used by  [2.x.173]   
* [0.x.50]*
   A function that computes the hp_vertex_dof_identities(),   hp_line_dof_identities(), or hp_quad_dof_identities(), depending on the   value of the template parameter.  
* [0.x.51]*
   Usually: Fields of cell-independent data.     However, here, this class does not itself store the data but only   pointers to  [2.x.174]  objects for each of the base elements.  
* [0.x.52]*
     Constructor. Is called by the  [2.x.175]  function. Sets the size of     the  [2.x.176]  vector to  [2.x.177]     
* [0.x.53]*
     Destructor. Deletes all  [2.x.178]  whose pointers are stored by     the  [2.x.179]  vector.    
* [0.x.54]*
     Give write-access to the pointer to a  [2.x.180]  of the  [2.x.181]      base_noth base element.    
* [0.x.55]*
     Give read-access to the pointer to a  [2.x.182]  of the  [2.x.183]      base_noth base element.    
* [0.x.56]*
     Give read-access to the pointer to an object to which into which the      [2.x.184] th base element will write its output when calling      [2.x.185]  and similar functions.    
* [0.x.57]*
     Pointers to  [2.x.186]  objects for each of the base elements. They     are accessed to by the  [2.x.187]  and  [2.x.188]  functions.         The size of this vector is set to  [2.x.189]  by the     InternalData constructor.  It is filled by the  [2.x.190]  function.     Note that since the data for each instance of a base class is     necessarily the same, we only need as many of these objects as there     are base elements, irrespective of their multiplicity.    
* [0.x.58]*
     A collection of objects to which the base elements will write their     output when we call  [2.x.191]  and related     functions on them.         The size of this vector is set to  [2.x.192]  by the     InternalData constructor.    
* [0.x.59]*
   Mutex for protecting initialization of restriction and embedding matrix.  
* [0.x.60]

include/deal.II-translator/fe/fe_tools_0.txt
[0.x.0]*
 This namespace offers interpolations and extrapolations of discrete functions of one  [2.x.0]   [2.x.1]  to another  [2.x.2]   [2.x.3]  fe2.
*  It also provides the local interpolation matrices that interpolate on each cell. Furthermore it provides the difference matrix  [2.x.4]  that is needed for evaluating  [2.x.5]  for e.g. the dual solution  [2.x.6] .
*  For more information about the <tt>spacedim</tt> template parameter check the documentation of FiniteElement or the one of Triangulation.

* 
* [0.x.1]*
   A base class for factory objects creating finite elements of a given   degree. Derived classes are called whenever one wants to have a   transparent way to create a finite element object.     This class is used in the  [2.x.7]  and    [2.x.8]  functions.  
* [0.x.2]*
     Create a FiniteElement and return a pointer to it.    
* [0.x.3]*
     Create a FiniteElement from a quadrature formula (currently only     implemented for FE_Q) and return a pointer to it.    
* [0.x.4]*
     Virtual destructor doing nothing but making the compiler happy.    
* [0.x.5]*
   A concrete class for factory objects creating finite elements of a given   degree.     The class's get() function generates a finite element object of the type   given as template argument, and with the degree (however the finite   element class wishes to interpret this number) given as argument to   get().  
* [0.x.6]*
     Create a FiniteElement and return a pointer to it.    
* [0.x.7]*
     Create a FiniteElement from a quadrature formula (currently only     implemented for FE_Q) and return a pointer to it.    
* [0.x.8]*
    [2.x.9]  In most cases, you will probably want to use   compute_base_renumbering().     Compute the vector required to renumber the dofs of a cell by component.   Furthermore, compute the vector storing the start indices of each   component in the local block vector.     The second vector is organized such that there is a vector for each base   element containing the start index for each component served by this base   element.     While the first vector is checked to have the correct size, the second   one is reinitialized for convenience.  
* [0.x.9]*
   Compute the vector required to renumber the dofs of a cell by block.   Furthermore, compute the vector storing either the start indices or the   size of each local block vector.     If the  [2.x.10]  parameter is true,  [2.x.11]  is filled with the start   indices of each local block. If it is false, then the block sizes are   returned.     The vector <tt>renumbering</tt> will be indexed by the standard numbering   of local degrees of freedom, namely the first vertex, then the second   vertex, after vertices lines, quads, and hexes. For each index, the entry   indicates the index which this degree of freedom receives in a numbering   scheme, where the first block is numbered completely before the second.  
* [0.x.10]*
    [2.x.12]  Generation of local matrices    [2.x.13]   
* [0.x.11]*
   Compute the interpolation matrix that interpolates a  [2.x.14]  to a    [2.x.15]  on each cell. The interpolation_matrix needs to be of   size <tt>(fe2.n_dofs_per_cell(), fe1.n_dofs_per_cell())</tt>.     Note, that if the finite element space  [2.x.16]  is a subset of the finite   element space  [2.x.17]  then the  [2.x.18]  is an embedding   matrix.  
* [0.x.12]*
   Compute the interpolation matrix that interpolates a  [2.x.19]  to a    [2.x.20]  and interpolates this to a second  [2.x.21]  on   each cell. The interpolation_matrix needs to be of size   <tt>(fe1.n_dofs_per_cell(), fe1.n_dofs_per_cell())</tt>.     Note, that this function only makes sense if the finite element space due   to  [2.x.22]  is not a subset of the finite element space due to  [2.x.23]  as   if it were a subset then the  [2.x.24]  would be only the   unit matrix.  
* [0.x.13]*
   Compute the identity matrix minus the back interpolation matrix.   The  [2.x.25]  will be of size <tt>(fe1.n_dofs_per_cell(),   fe1.n_dofs_per_cell())</tt> after this function. Previous content   of the argument will be overwritten.     This function computes the matrix that transforms a  [2.x.26]  function  [2.x.27]  to    [2.x.28]  where  [2.x.29]  denotes the interpolation operator from the  [2.x.30]    space to the  [2.x.31]  space. This matrix hence is useful to evaluate   error-representations where  [2.x.32]  denotes the dual solution.  
* [0.x.14]*
   Compute the local  [2.x.33] -projection matrix from fe1 to fe2.  
* [0.x.15]*
   This is a rather specialized function used during the construction of   finite element objects. It is used to build the basis of shape functions   for an element, given a set of polynomials and interpolation points. The   function is only implemented for finite elements with exactly  [2.x.34]    vector components. In particular, this applies to classes derived from   the FE_PolyTensor class.     Specifically, the purpose of this function is as follows: FE_PolyTensor   receives, from its derived classes, an argument that describes a polynomial   space. This space may be parameterized in terms of monomials, or in some   other way, but is in general not in the form that we use for finite   elements where we typically want to use a basis that is derived from   some kind of node functional (e.g., the interpolation at specific points).   Concretely, assume that the basis used by the polynomial space is    [2.x.35] , and that the node functionals   of the finite element are  [2.x.36] . We then want to compute a   basis  [2.x.37]  for the finite element space so   that  [2.x.38] . To do this, we can set    [2.x.39]    where we need to determine the expansion coefficients  [2.x.40] . We do this   by applying  [2.x.41]  to both sides of the equation, to obtain  
* [1.x.0]
*    and we know that the left hand side equals  [2.x.42] .   If you think of this as a system of  [2.x.43]  equations for the   elements of a matrix on the left and on the right, then this can be   written as  
* [1.x.1]
*    where  [2.x.44]  is the matrix of coefficients  [2.x.45]  and    [2.x.46] . Consequently, in order to compute   the expansion coefficients  [2.x.47] , we need to apply the node   functionals to all functions of the "raw" basis of the polynomial space.     Until the finite element receives this matrix  [2.x.48]  back, it describes its   shape functions (e.g., in  [2.x.49]  in the form    [2.x.50] . After it calls this function, it has the expansion   coefficients and can describe its shape functions as  [2.x.51] .     This function therefore computes this matrix  [2.x.52] , for the following   specific circumstances:
* 

* 
* 

* 
* 

* 
* 
*  - That the node functionals  [2.x.53]  are point evaluations at points      [2.x.54]  that the finite element in question describes via its     "generalized" support points (through      [2.x.55]  see also      [2.x.56]  "this glossary entry"). These point     evaluations need to necessarily evaluate the [1.x.2] of a shape     function at that point (the shape function may be vector-valued, and     so the functional may be a linear combination of the individual     components of the values); but, in particular, the nodal functions may     not be [1.x.3] over entire edges or faces,     or other non-local functionals. In other words, we assume that      [2.x.57]      where  [2.x.58]  is a function of the (possibly vector-valued) argument     that returns a scalar.
* 

* 
* 

* 
* 

* 
* 
*  - That the finite element has exactly  [2.x.59]  vector components.
* 

* 
* 

* 
* 

* 
* 
*  - That the function  [2.x.60]  is given by whatever the element implements     through the    [2.x.61]      function.      [2.x.62]  fe The finite element for which the operations above are to be          performed.    [2.x.63]  The matrix  [2.x.64]  as discussed above.  
* [0.x.16]*
   For all possible (isotropic and anisotropic) refinement cases compute the   embedding matrices from a coarse cell to the child cells. Each column of   the resulting matrices contains the representation of a coarse grid basis   function by the fine grid basis; the matrices are split such that there   is one matrix for every child.     This function computes the coarse grid function in a sufficiently large   number of quadrature points and fits the fine grid functions using least   squares approximation. Therefore, the use of this function is restricted   to the case that the finite element spaces are actually nested.     Note, that  [2.x.65]  includes the   embedding (or prolongation) matrix of child  [2.x.66]  for the   RefinementCase  [2.x.67] . Here, we use    [2.x.68]  as   for  [2.x.69]  there are no prolongation matrices   available.     Typically this function is called by the various implementations of   FiniteElement classes in order to fill the respective    [2.x.70]  matrices.      [2.x.71]  fe The finite element class for which we compute the embedding   matrices.      [2.x.72]  matrices A reference to  [2.x.73]    vectors of FullMatrix objects. Each vector corresponds to one   RefinementCase  [2.x.74]  and is of the vector size    [2.x.75]  This is the format used   in FiniteElement, where we want to use this function mostly.      [2.x.76]  isotropic_only Set to  [2.x.77]  if you only want to   compute matrices for isotropic refinement.      [2.x.78]  threshold is the gap allowed in the least squares algorithm   computing the embedding.  
* [0.x.17]*
   Compute the embedding matrices on faces needed for constraint matrices.      [2.x.79]  fe The finite element for which to compute these matrices.      [2.x.80]  matrices An array of [1.x.4] FullMatrix objects,holding the embedding matrix for   each subface.      [2.x.81]  face_coarse The number of the face on the coarse side of the face   for which this is computed.      [2.x.82]  face_fine The number of the face on the refined side of the face   for which this is computed.      [2.x.83]  threshold is the gap allowed in the least squares algorithm   computing the embedding.      [2.x.84]  This function will be used in computing constraint matrices. It   is not sufficiently tested yet.  
* [0.x.18]*
   For all possible (isotropic and anisotropic) refinement cases compute the   [1.x.5]-projection matrices from the children to a coarse   cell.     Note, that  [2.x.85]  includes the   projection (or restriction) matrix of child  [2.x.86]  for the   RefinementCase  [2.x.87] . Here, we use    [2.x.88]  as   for  [2.x.89]  there are no projection matrices   available.     Typically this function is called by the various implementations of   FiniteElement classes in order to fill the respective    [2.x.90]  matrices.      [2.x.91]  fe The finite element class for which we compute the projection     matrices.      [2.x.92]  matrices A reference to a set of      [2.x.93]  vectors of FullMatrix     objects. Each vector corresponds to one RefinementCase  [2.x.94]      and is of the vector size      [2.x.95]  This is the     format used in FiniteElement, where we want to use this function mostly.      [2.x.96]  isotropic_only If set to  [2.x.97] , then this     function only computes data for the isotropic refinement case. The     other elements of the output vector are left untouched (but still     exist).  
* [0.x.19]*
   Project scalar data defined in quadrature points to a finite element   space on a single cell.     What this function does is the following: assume that there is scalar   data <tt>u<sub>q</sub>, 0 <= q < Q:=quadrature.size()</tt> defined at the   quadrature points of a cell, with the points defined by the given   <tt>rhs_quadrature</tt> object. We may then want to ask for that finite   element function (on a single cell) <tt>v<sub>h</sub></tt> in the finite-   dimensional space defined by the given FE object that is the projection   of <tt>u</tt> in the following sense:     Usually, the projection <tt>v<sub>h</sub></tt> is that function that   satisfies <tt>(v<sub>h</sub>,w)=(u,w)</tt> for all discrete test   functions <tt>w</tt>. In the present case, we can't evaluate the right   hand side, since <tt>u</tt> is only defined in the quadrature points   given by <tt>rhs_quadrature</tt>, so we replace it by a quadrature   approximation. Likewise, the left hand side is approximated using the   <tt>lhs_quadrature</tt> object; if this quadrature object is chosen   appropriately, then the integration of the left hand side can be done   exactly, without any approximation. The use of different quadrature   objects is necessary if the quadrature object for the right hand side has   too few quadrature points
* 
*  -  for example, if data <tt>q</tt> is only   defined at the cell center, then the corresponding one-point quadrature   formula is obviously insufficient to approximate the scalar product on   the left hand side by a definite form.     After these quadrature approximations, we end up with a nodal   representation <tt>V<sub>h</sub></tt> of <tt>v<sub>h</sub></tt> that   satisfies the following system of linear equations: <tt>M V<sub>h</sub> =   Q U</tt>, where <tt>M<sub>ij</sub>=(phi_i,phi_j)</tt> is the mass matrix   approximated by <tt>lhs_quadrature</tt>, and <tt>Q</tt> is the matrix   <tt>Q<sub>iq</sub>=phi<sub>i</sub>(x<sub>q</sub>) w<sub>q</sub></tt>   where <tt>w<sub>q</sub></tt> are quadrature weights; <tt>U</tt> is the   vector of quadrature point data <tt>u<sub>q</sub></tt>.     In order to then get the nodal representation <tt>V<sub>h</sub></tt> of   the projection of <tt>U</tt>, one computes <tt>V<sub>h</sub> = X U,   X=M<sup>-1</sup> Q</tt>. The purpose of this function is to compute the   matrix <tt>X</tt> and return it through the last argument of this   function.     Note that this function presently only supports scalar data. An extension   of the mass matrix is of course trivial, but one has to define the order   of data in the vector <tt>U</tt> if it contains vector valued data in all   quadrature points.     A use for this function is described in the introduction to the  [2.x.98]    example program.     The opposite of this function, interpolation of a finite element function   onto quadrature points is essentially what the    [2.x.99]  functions do; to make things a   little simpler, the    [2.x.100]    provides the matrix form of this.     Note that this function works on a single cell, rather than an entire   triangulation. In effect, it therefore doesn't matter if you use a   continuous or discontinuous version of the finite element.     It is worth noting that there are a few confusing cases of this function.   The first one is that it really only makes sense to project onto a finite   element that has at most as many degrees of freedom per cell as there are   quadrature points; the projection of N quadrature point data into a space   with M>N unknowns is well-defined, but often yields funny and non-   intuitive results. Secondly, one would think that if the quadrature point   data is defined in the support points of the finite element, i.e. the   quadrature points of <tt>ths_quadrature</tt> equal   <tt>fe.get_unit_support_points()</tt>, then the projection should be the   identity, i.e. each degree of freedom of the finite element equals the   value of the given data in the support point of the corresponding shape   function. However, this is not generally the case: while the matrix   <tt>Q</tt> in that case is the identity matrix, the mass matrix   <tt>M</tt> is not equal to the identity matrix, except for the special   case that the quadrature formula <tt>lhs_quadrature</tt> also has its   quadrature points in the support points of the finite element.     Finally, this function only defines a cell wise projection, while one   frequently wants to apply it to all cells in a triangulation. However, if   it is applied to one cell after the other, the results from later cells   may overwrite nodal values computed already from previous cells if   degrees of freedom live on the interfaces between cells. The function is   therefore most useful for discontinuous elements.  
* [0.x.20]*
   Given a (scalar) local finite element function, compute the matrix that   maps the vector of nodal values onto the vector of values of this   function at quadrature points as given by the second argument. In a   sense, this function does the opposite of the    [2.x.101]  function.  
* [0.x.21]*
   Compute the projection of tensorial (first-order tensor) data stored at   the quadrature points  [2.x.102]  to data  [2.x.103]    vector_of_tensors_at_nodes at the support points of the cell.  The data   in  [2.x.104]  is ordered sequentially following the   quadrature point numbering.  The size of  [2.x.105]  must   correspond to the number of columns of  [2.x.106]   The size of    [2.x.107]  must correspond to the number of rows of  [2.x.108]    vector_of_tensors_at_nodes .  The projection matrix  [2.x.109]    describes the projection of scalar data from the quadrature points and   can be obtained from the    [2.x.110]  function.  
* [0.x.22]*
   same as last function but for a  [2.x.111]  .  
* [0.x.23]*
   This method implements the    [2.x.112]  method for   faces of a mesh.  The matrix that it returns, X, is face specific and its   size is fe.n_dofs_per_cell() by rhs_quadrature.size().  The dimension, dim   must be larger than 1 for this class, since Quadrature<dim-1> objects are   required. See the documentation on the Quadrature class for more   information.  
* [0.x.24]*
   Wrapper around    [2.x.113]    that works with arbitrary number types.      [2.x.114]  finite_element The FiniteElement to compute dof values for.    [2.x.115]  support_point_values An array of size  [2.x.116]      (which equals the number of points the get_generalized_support_points()     function will return) where each element is a vector with as many entries     as the element has vector components. This array should contain     the values of a function at the generalized support points of the     finite element.    [2.x.117]  dof_values An array of size  [2.x.118]  that contains     the node functionals of the element applied to the given function.  
* [0.x.25]*
    [2.x.119]  Functions which should be in DoFTools  
* [0.x.26]*
   Compute the interpolation of a the  [2.x.120]   [2.x.121]  to a  [2.x.122]    dof2-function  [2.x.123]   [2.x.124]  and  [2.x.125]  need to be DoFHandlers based on   the same triangulation.     If the elements  [2.x.126]  and  [2.x.127]  are either both continuous or both   discontinuous then this interpolation is the usual point interpolation.   The same is true if  [2.x.128]  is a continuous and  [2.x.129]  is a discontinuous   finite element. For the case that  [2.x.130]  is a discontinuous and  [2.x.131]  is   a continuous finite element there is no point interpolation defined at   the discontinuities.  Therefore the mean value is taken at the DoF values   on the discontinuities.     Note that for continuous elements on grids with hanging nodes (i.e.   locally refined grids) this function does not give the expected output.   Indeed, the resulting output vector does not necessarily respect   continuity requirements at hanging nodes: if, for example, you are   interpolating a Q2 field to a Q1 field, then at hanging nodes the output   field will have the function value of the input field, which however is   not usually the mean value of the two adjacent nodes. It is thus not part   of the Q1 function space on the whole triangulation, although it is of   course Q1 on each cell.     For this case (continuous elements on grids with hanging nodes), please   use the  [2.x.132]  function with an additional AffineConstraints   object as argument, see below, or make the field conforming yourself   by calling the  [2.x.133]  function of your hanging node constraints   object.  
* [0.x.27]*
   Compute the interpolation of a the  [2.x.134]   [2.x.135]  to a  [2.x.136]    dof2-function  [2.x.137]   [2.x.138]  and  [2.x.139]  need to be DoFHandlers based on   the same triangulation.  [2.x.140]  is a hanging node constraints object   corresponding to  [2.x.141]  This object is particular important when   interpolating onto continuous elements on grids with hanging nodes (locally   refined grids).     If the elements  [2.x.142]  and  [2.x.143]  are either both continuous or both   discontinuous then this interpolation is the usual point interpolation.   The same is true if  [2.x.144]  is a continuous and  [2.x.145]  is a discontinuous   finite element. For the case that  [2.x.146]  is a discontinuous and  [2.x.147]  is   a continuous finite element there is no point interpolation defined at   the discontinuities.  Therefore the mean value is taken at the DoF values   at the discontinuities.  
* [0.x.28]*
   Compute the interpolation of the  [2.x.148]   [2.x.149]  to a  [2.x.150]    fe2-function, and interpolates this to a second  [2.x.151]  named  [2.x.152]    u1_interpolated.     Note, that this function does not work on continuous elements at hanging   nodes. For that case use the  [2.x.153]  function, below, that   takes an additional  [2.x.154]  object.     Furthermore note, that for the specific case when the finite element   space corresponding to  [2.x.155]  is a subset of the finite element space   corresponding to  [2.x.156]  this function is simply an identity mapping.  
* [0.x.29]*
   Compute the interpolation of the  [2.x.157]   [2.x.158]  to a  [2.x.159]    dof2-function, and interpolates this to a second  [2.x.160]  named    [2.x.161]    [2.x.162]  and  [2.x.163]  are the hanging   node constraints corresponding to  [2.x.164]  and  [2.x.165]  respectively.   These objects are particular important when continuous elements on grids   with hanging nodes (locally refined grids) are involved.     Furthermore note, that for the specific case when the finite element   space corresponding to  [2.x.166]  is a subset of the finite element space   corresponding to  [2.x.167]  this function is simply an identity mapping.  
* [0.x.30]*
   Compute  [2.x.168]  for a given  [2.x.169]   [2.x.170] , where  [2.x.171]  is   the interpolation from  [2.x.172]  to  [2.x.173]  The result  [2.x.174]  is   written into  [2.x.175]      Note, that this function does not work for continuous elements at hanging   nodes. For that case use the  [2.x.176]  function, below,   that takes an additional  [2.x.177]  object.  
* [0.x.31]*
   Compute  [2.x.178]  for a given  [2.x.179]   [2.x.180] , where  [2.x.181]  is   the interpolation from  [2.x.182]  to  [2.x.183]  The result  [2.x.184]  is   written into  [2.x.185]    [2.x.186]  and  [2.x.187]  are   the hanging node constraints corresponding to  [2.x.188]  and  [2.x.189]    respectively. These objects are particular important when continuous   elements on grids with hanging nodes (locally refined grids) are   involved.     For parallel computations, supply  [2.x.190]  with ghost elements and  [2.x.191]    z1_difference without ghost elements.  
* [0.x.32]*
    [2.x.192]  projection for discontinuous elements. Operates the same direction   as interpolate.     The global projection can be computed by local matrices if the finite   element spaces are discontinuous. With continuous elements, this is   impossible, since a global mass matrix must be inverted.  
* [0.x.33]*
   Compute the patchwise extrapolation of a  [2.x.193]  function  [2.x.194]  to a  [2.x.195]    dof2 function  [2.x.196]    [2.x.197]  and  [2.x.198]  need to be DoFHandler objects   based on the same triangulation. This function is used, for example, for   extrapolating patchwise a piecewise linear solution to a piecewise   quadratic solution.     The function's name is historical and probably not particularly well   chosen. The function performs the following operations, one after the   other:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - It interpolates directly from every cell of  [2.x.199]  to the   corresponding cell of `dof2` using the interpolation matrix of the finite   element spaces used on these cells and provided by the finite element   objects involved. This step is done using the  [2.x.200]    function.
* 

* 
* 

* 
* 

* 
* 
*  - It then performs a loop over all non-active cells of `dof2`.   If such a non-active cell has at least one active child, then we call the   children of this cell a "patch". We then interpolate from the children of   this patch to the patch, using the finite element space associated with   `dof2` and immediately interpolate back to the children. In essence, this   information throws away all information in the solution vector that lives   on a scale smaller than the patch cell.
* 

* 
* 

* 
* 

* 
* 
*  - Since we traverse non-active cells from the coarsest to the finest   levels, we may find patches that correspond to child cells of previously   treated patches if the mesh had been refined adaptively (this cannot   happen if the  mesh has been refined globally because there the children   of a patch are all active). We also perform the operation described above   on these patches, but it is easy to see that on patches that are children   of previously treated patches, the operation is now the identity operation   (since it interpolates from the children of the current patch a function   that had previously been interpolated to these children from an even   coarser patch). Consequently, this does not alter the solution vector any   more.     The name of the function originates from the fact that it can be used to   construct a representation of a function of higher polynomial degree on a   once coarser mesh. For example, if you imagine that you start with a    [2.x.201]  function on a globally refined mesh, and that  [2.x.202]  is associated   with a  [2.x.203]  element, then this function computes the equivalent of the   operator  [2.x.204]  interpolating the original piecewise linear   function onto a quadratic function on a once coarser mesh with mesh size    [2.x.205]  (but representing this function on the original mesh with size  [2.x.206] ).   If the exact solution is sufficiently smooth, then    [2.x.207]  is typically a better approximation to the exact   solution  [2.x.208]  of the PDE than  [2.x.209]  is. In other words, this function   provides a postprocessing step that improves the solution in a similar   way one often obtains by extrapolating a sequence of solutions,   explaining the origin of the function's name.    
*  [2.x.210]  The resulting field does not satisfy continuity requirements of the   given finite elements if the algorithm outlined above is used. When you   use continuous elements on grids with hanging nodes, please use the  [2.x.211]    extrapolate function with an additional AffineConstraints argument, see   below.    
*  [2.x.212]  Since this function operates on patches of cells, it requires that   the underlying grid is refined at least once for every coarse grid cell.   If this is not the case, an exception will be raised.  
* [0.x.34]*
   Compute the patchwise extrapolation of a  [2.x.213]  function  [2.x.214]  to a  [2.x.215]    dof2 function  [2.x.216]    [2.x.217]  and  [2.x.218]  need to be DoFHandler objects   based on the same triangulation.   [2.x.219]  is a hanging node   constraints object corresponding to  [2.x.220]  This object is necessary   when interpolating onto continuous elements on grids with hanging nodes   (locally refined grids).     Otherwise, the function does the same as the other  [2.x.221]    function above (for which the documentation provides an extensive   description of its operation).  
* [0.x.35]*
   The numbering of the degrees of freedom in continuous finite elements is   hierarchic, i.e. in such a way that we first number the vertex dofs, in   the order of the vertices as defined by the triangulation, then the line   dofs in the order and respecting the direction of the lines, then the   dofs on quads, etc. However, we could have, as well, numbered them in a   lexicographic way, i.e. with indices first running in x-direction, then   in y-direction and finally in z-direction. Discontinuous elements of   class FE_DGQ() are numbered in this way, for example.     This function returns a vector containing information about the   lexicographic index each degree of freedom in the hierarchic numbering   would have to a given degree of a continuous finite element.  
* [0.x.36]*
   This is the reverse function to the above one, generating the map from   the lexicographic to the hierarchical numbering for a given polynomial   degree of a continuous finite element. All the remarks made about the   above function are also valid here.  
* [0.x.37]*
   A namespace that contains functions that help setting up internal   data structures when implementing FiniteElement which are build   from simpler ("base") elements, for example FESystem. The things   computed by these functions typically serve as constructor   arguments to the FiniteElement base class of the derived finite   element object being constructed.     There are generally two ways in which one can build more complex   elements, and this is reflected by several of the functions in   this namespace having arguments called    [2.x.222] :      [2.x.223]     [2.x.224]  Tensor product construction ( [2.x.225] ):   The tensor product construction, in the simplest case, builds a   vector-valued element from scalar elements (see    [2.x.226]  "this documentation module" and    [2.x.227]  "this glossary entry" for more information).   To give an example, consider creating a vector-valued element with   two vector components, where the first should have linear shape   functions and the second quadratic shape functions. In 1d, the   shape functions (on the reference cell) of the base elements are then  
* [1.x.6]
*    where shape functions are ordered in the usual way (first on the   first vertex, then on the second vertex, then in the interior of   the cell). The tensor product construction will create an element with   the following shape functions:  
* [1.x.7]
*    The list here is again in standard order.     Of course, the procedure also works if the base elements are   already vector valued themselves: in that case, the composed   element simply has as many vector components as the base elements   taken together.      [2.x.228]  Combining shape functions   ( [2.x.229] ): In contrast to the   previous strategy, combining shape functions simply takes   [1.x.8] of the shape functions together. In the case above,   this would yield the following element:  
* [1.x.9]
*    In other words, if the base elements are scalar, the resulting   element will also be. In general, the base elements all will   have to have the same number of vector components.     The element constructed above of course no longer has a linearly   independent set of shape functions. As a consequence, any matrix   one creates by treating all shape functions of the composed   element in the same way will be singular. In practice, this   strategy is therefore typically used in situations where one   explicitly makes sure that certain shape functions are treated   differently (e.g., by multiplying them with weight functions), or   in cases where the shape functions one combines are not linearly   dependent.      [2.x.230]   
* [0.x.38]*
     Take vectors of finite elements and multiplicities and multiply out     how many degrees of freedom the composed element has per vertex,     line, etc.         If  [2.x.231]  is true, the number of components     returned in the FiniteElementData object is the sum over the     product of the number of components in each of the finite     elements times the corresponding multiplicity.  Otherwise the     number of components is taken from the first finite element with     non-zero multiplicity, and all other elements with non-zero     multiplicities need to have the same number of vector components.         See the documentation of namespace  [2.x.232]  for more     information about the  [2.x.233]  argument.    
* [0.x.39]*
     Same as above for an arbitrary number of parameters of type      [2.x.234]  spacedim>>, unsigned     int></code> and  [2.x.235] .    
* [0.x.40]*
     Same as above but for a specific number of sub-elements.    
* [0.x.41]*
     Compute the "restriction is additive" flags (see the     documentation of the FiniteElement class) for a list of finite     elements with multiplicities given in the second argument.         The "restriction is additive" flags are properties of     individual shape functions that do not depend on whether the     composed element uses the tensor product or combination     strategy outlined in the documentation of the      [2.x.236]  namespace. Consequently, this function     does not have a  [2.x.237]  argument.    
* [0.x.42]*
     Same as above for an arbitrary number of parameters of type      [2.x.238]  spacedim>>, unsigned     int></code>.    
* [0.x.43]*
     Take a  [2.x.239]  object and return a boolean vector     describing the  [2.x.240]  (see the     documentation of the FiniteElement class) for each shape function     of the mixed element consisting of  [2.x.241]   [2.x.242]  ... copies of     the sub-elements  [2.x.243]   [2.x.244]  ...         The "restriction is additive" flags are properties of     individual shape functions that do not depend on whether the     composed element uses the tensor product or combination     strategy outlined in the documentation of the      [2.x.245]  namespace. Consequently, this function     does not have a  [2.x.246]  argument.    
* [0.x.44]*
     Compute the nonzero components for each shape function of a     composed finite element described by a list of finite elements     with multiplicities given in the second argument.         If  [2.x.247]  is true, the number of components (and     thus the size of the ComponentMask objects) is the sum over the     product of the number of components in each of the finite     elements times the corresponding multiplicity.  Otherwise the     number of components is taken from the first finite element with     non-zero multiplicity, and all other elements with non-zero     multiplicities need to have the same number of vector components.         See the documentation of namespace  [2.x.248]  for more     information about the  [2.x.249]  argument.    
* [0.x.45]*
     Same as above for an arbitrary number of parameters of type      [2.x.250]  spacedim>>, unsigned     int></code> and  [2.x.251] .    
* [0.x.46]*
     Compute the non-zero vector components of a composed finite     element. This function is similar to the previous one, except     that the pointers indicate the elements to be composed, and the     arguments  [2.x.252]   [2.x.253]  ... the multiplicities. Null pointers     indicate that an argument is to be skipped.         If  [2.x.254]  is true, the number of components (and     thus the size of the ComponentMask objects) is the sum over the     product of the number of components in each of the finite     elements times the corresponding multiplicity.  Otherwise the     number of components is taken from the first finite element with     non-zero multiplicity, and all other elements with non-zero     multiplicities need to have the same number of vector components.         See the documentation of namespace  [2.x.255]  for more     information about the  [2.x.256]  argument.    
* [0.x.47]*
     For a given (composite)  [2.x.257]  build  [2.x.258]      system_to_component_table,  [2.x.259]  and  [2.x.260]      component_to_base_table.         If  [2.x.261]  is true, the number of components     used for the composite element is the sum over the     product of the number of components in each of the finite     elements times the corresponding multiplicity.  Otherwise the     number of components is taken from the first finite element with     non-zero multiplicity, and all other elements with non-zero     multiplicities need to have the same number of vector components.         See the documentation of namespace  [2.x.262]  for more     information about the  [2.x.263]  argument.    
* [0.x.48]*
     For a given (composite)  [2.x.264]  build  [2.x.265]      and  [2.x.266]          If  [2.x.267]  is true, the number of components     used for the composite element is the sum over the     product of the number of components in each of the finite     elements times the corresponding multiplicity.  Otherwise the     number of components is taken from the first finite element with     non-zero multiplicity, and all other elements with non-zero     multiplicities need to have the same number of vector components.         See the documentation of namespace  [2.x.268]  for more     information about the  [2.x.269]  argument.    
* [0.x.49]*
   Parse the name of a finite element and generate a finite element object   accordingly. The parser ignores space characters between words (things   matching the regular expression [A-Za-z0-9_]).     The name must be in the form which is returned by the    [2.x.270]  function, where dimension template parameters   &lt;2&gt; etc. can be omitted. Alternatively, the explicit number can be   replaced by <tt>dim</tt> or <tt>d</tt>. If a number is given, it   [1.x.10] match the template parameter of this function.     The names of FESystem elements follow the pattern    [2.x.271]    etc. may either be numbers or can be replaced by <tt>dim</tt> or   <tt>d</tt>.       If no finite element can be reconstructed from this string, an exception   of type  [2.x.272]  is thrown.     The function returns a  [2.x.273]  to a newly created finite element   meaning the caller obtains ownership over the returned object.     Since the value of the template argument can't be deduced from the   (string) argument given to this function, you have to explicitly specify   it when you call this function.     This function knows about all the standard elements defined in the   library. However, it doesn't by default know about elements that you may   have defined in your program. To make your own elements known to this   function, use the add_fe_name() function.  This function does not work if   one wants to get a codimension 1 finite element.  
* [0.x.50]*
   Extend the list of finite elements that can be generated by   get_fe_by_name() by the one given as  [2.x.274]  If get_fe_by_name() is   later called with this name, it will use the object given as second   argument to create a finite element object.     The format of the  [2.x.275]  parameter should include the name of a finite   element. However, it is safe to use either the class name alone or to use   the result of  [2.x.276]  (which includes the space dimension   as well as the polynomial degree), since everything after the first non-   name character will be ignored.     The FEFactory object should be an object newly created with <tt>new</tt>.   FETools will take ownership of this object and delete it once it is not   used anymore.     In most cases, if you want objects of type  [2.x.277]  be created   whenever the name  [2.x.278]  is given to get_fe_by_name, you   will want the second argument to this function be of type   FEFactory [2.x.279]  but you can of course create your custom finite   element factory class.     This function takes over ownership of the object given as second   argument, i.e. you should never attempt to destroy it later on. The   object will be deleted at the end of the program's lifetime.     If the name of the element is already in use, an exception is thrown.   Thus, functionality of get_fe_by_name() can only be added, not changed.    
*  [2.x.280]  This function manipulates a global table (one table for each space   dimension). It is thread safe in the sense that every access to this   table is secured by a lock. Nevertheless, since each name can be added   only once, user code has to make sure that only one thread adds a new   element.     Note also that this table exists once for each space dimension. If you   have a program that works with finite elements in different space   dimensions (for example,    [2.x.281]  " [2.x.282] "   does something like this), then you should call this function for each   space dimension for which you want your finite element added to the map.  
* [0.x.51]*
   The string used for get_fe_by_name() cannot be translated to a finite   element.     Either the string is badly formatted or you are using a custom element   that must be added using add_fe_name() first.    
*  [2.x.283]   
* [0.x.52]*
   The string used for get_fe_by_name() cannot be translated to a finite   element.     Dimension arguments in finite element names should be avoided. If they   are there, the dimension should be <tt>dim</tt> or <tt>d</tt>. Here, you   gave a numeric dimension argument, which does not match the template   dimension of the finite element class.    
*  [2.x.284]   
* [0.x.53]*
   Exception    
*  [2.x.285]   
* [0.x.54]*
   The finite element must be    [2.x.286]  "primitive".    
*  [2.x.287]   
* [0.x.55]*
   Exception    
*  [2.x.288]   
* [0.x.56]*
   A continuous element is used on a mesh with hanging nodes, but the   constraint matrices are missing.    
*  [2.x.289]   
* [0.x.57]*
   You need at least two grid levels.    
*  [2.x.290]   
* [0.x.58]*
   The dimensions of the matrix used did not match the expected dimensions.    
*  [2.x.291]   
* [0.x.59]*
   Exception thrown if an embedding matrix was computed inaccurately.    
*  [2.x.292]   
* [0.x.60]*
   Exception thrown if one variable may not be greater than another.    
*  [2.x.293]   
* [0.x.61]

include/deal.II-translator/fe/fe_tools_extrapolate.templates_0.txt
[0.x.0]

include/deal.II-translator/fe/fe_tools_interpolate.templates_0.txt
[0.x.0]

include/deal.II-translator/fe/fe_tools.templates_0.txt
[0.x.0]*
     Take a  [2.x.0]  object     and return an boolean vector including the  [2.x.1]      restriction_is_additive_flags of the mixed element consisting of  [2.x.2]      elements of the sub-element  [2.x.3]     
* [0.x.1]*
     Compute the non-zero vector components of a composed finite element.    
* [0.x.2]

include/deal.II-translator/fe/fe_trace_0.txt
[0.x.0]*
 A finite element, which is the trace of FE_Q elements, that is a tensor product of polynomials on the faces, undefined in the interior of the cells and continuous. The basis functions on the faces are formed by a tensor product of 1D Lagrange polynomials with equidistant points up to degree 2 and Gauss-Lobatto points starting from degree 3.
*  This finite element is the trace space of FE_Q on the faces.
* 

* 
*  [2.x.0]  Since these are only finite elements on faces, only FEFaceValues and FESubfaceValues will be able to extract reasonable values from any face polynomial. In order to make the use of FESystem simpler, FEValues objects will not fail using this finite element space, but all shape function values extracted will equal to zero.

* 
* [0.x.1]*
   Constructor for tensor product polynomials of degree <tt>p</tt>. The   shape functions created using this constructor correspond to Legendre   polynomials in each coordinate direction.  
* [0.x.2]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_DGQ<dim>(degree)</tt>, with <tt>dim</tt> and   <tt>degree</tt> replaced by appropriate values.  
* [0.x.3]*
   Implementation of the corresponding function in the FiniteElement   class.  Since the current element is interpolatory, the nodal   values are exactly the support point values. Furthermore, since   the current element is scalar, the support point values need to   be vectors of length 1.  
* [0.x.4]*
   This function returns  [2.x.1]  if the shape function  [2.x.2]  has   non-zero function values somewhere on the face  [2.x.3]   
* [0.x.5]*
   Return a list of constant modes of the element. For this element, it   simply returns one row with all entries set to true.  
* [0.x.6]*
   Return whether this element implements its hanging node constraints in   the new way, which has to be used to make elements "hp-compatible".  
* [0.x.7]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>. This   element only provides interpolation matrices for elements of the same   type and FE_Nothing. For all other elements, an exception of type    [2.x.4]  is thrown.  
* [0.x.8]*
   Return the matrix interpolating from a face of one element to the face   of the neighboring element.  The size of the matrix is then   <tt>source.dofs_per_face</tt> times <tt>this->dofs_per_face</tt>. This   element only provides interpolation matrices for elements of the same   type and FE_Nothing. For all other elements, an exception of type    [2.x.5]  is thrown.  
* [0.x.9]*
    [2.x.6]   [2.x.7]   
* [0.x.10]*
   Store a copy of FE_Q for delegating the hp-constraints functionality.  
* [0.x.11]*
   Return vector with dofs per vertex, line, quad, hex.  
* [0.x.12]*
 FE_TraceQ in 1D, i.e., with degrees of freedom on the element vertices.

* 
* [0.x.13]*
   Constructor.  
* [0.x.14]*
   Return the name of the element  
* [0.x.15]

include/deal.II-translator/fe/fe_update_flags_0.txt
[0.x.0]*
 The enum type given to the constructors of FEValues, FEFaceValues and FESubfaceValues, telling those objects which data will be needed on each mesh cell.
*  Selecting these flags in a restrictive way is crucial for the efficiency of  [2.x.0]   [2.x.1]  and  [2.x.2]  Therefore, only the flags actually needed should be selected. It is the responsibility of the involved Mapping and FiniteElement to add additional flags according to their own requirements. For instance, most finite elements will add #update_covariant_transformation if #update_gradients is selected.  By default, all flags are off, i.e. no reinitialization will be done.
*  You can select more than one flag by concatenation using the bitwise or operator|(UpdateFlags,UpdateFlags).
*  [1.x.0]
*  More information on the use of this type both in user code as well as internally can be found in the documentation modules on  [2.x.3]  "The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues" and  [2.x.4]  "How Mapping, FiniteElement, and FEValues work together".

* 
* [0.x.1]*
   Compute the values of the shape functions at the quadrature points on the   real space cell. For the usual Lagrange elements, these values are equal   to the values of the shape functions at the quadrature points on the unit   cell, but they are different for more complicated elements, such as   FE_RaviartThomas elements.  
* [0.x.2]*
   Compute the gradients of the shape functions in coordinates of the real   cell.  
* [0.x.3]*
   Compute the second derivatives of the shape functions in coordinates of   the real cell.  
* [0.x.4]*
   Compute the third derivatives of the shape functions in coordinates of   the real cell  
* [0.x.5]*
   Vector product of tangential vectors, yielding a normal vector with a   length corresponding to the surface element; may be more efficient than   computing both.  
* [0.x.6]*
   Compute the quadrature points location in real cell coordinates.     FEValues objects take the quadrature point locations on the   reference cell as an argument of the constructor (via the   Quadrature object). For most finite elements, knowing the   location of quadrature points on the reference cell is all that   is necessary to evaluate shape functions, evaluate the mapping,   and other things. On the other hand, if you want to evaluate a   right hand side function  [2.x.5]  at quadrature point   locations  [2.x.6]  on the real cell, you need to pass this   flag to the FEValues constructor to make sure you can later   access them.     In the context of DataPostprocessor,    [2.x.7]  will be updated.  
* [0.x.7]*
   Compute the quadrature weights on the real cell, i.e. the weights of the   quadrature rule multiplied with the determinant of the Jacobian of the   transformation from reference to real cell.  
* [0.x.8]*
   Compute the normal vectors, either for a face or for a cell of   codimension one. Setting this flag for any other object will raise an   error.  
* [0.x.9]*
   Compute the Jacobian of the transformation from the reference cell to the   real cell.  
* [0.x.10]*
   Compute the derivatives of the Jacobian of the transformation.  
* [0.x.11]*
   Compute the inverse Jacobian of the transformation from the reference   cell to the real cell.  
* [0.x.12]*
   Compute all values the Mapping needs to perform a contravariant   transformation of vectors. For special mappings like MappingCartesian   this may be simpler than #update_inverse_jacobians.  
* [0.x.13]*
   Compute all values the Mapping needs to perform a contravariant   transformation of vectors. For special mappings like MappingCartesian   this may be simpler than #update_jacobians.  
* [0.x.14]*
   Compute the shape function values of the transformation defined by the   Mapping.  
* [0.x.15]*
   Compute the shape function gradients of the transformation defined by the   Mapping.  
* [0.x.16]*
   Compute the volume element in each quadrature point.  
* [0.x.17]*
   Compute the derivatives of the Jacobian of the transformation pushed   forward to the real cell coordinates.  
* [0.x.18]*
   Compute the second derivatives of the Jacobian of the transformation.  
* [0.x.19]*
   Compute the second derivatives of the Jacobian of the transformation   pushed forward to the real cell coordinates.  
* [0.x.20]*
   Compute the third derivatives of the Jacobian of the transformation.  
* [0.x.21]*
   Compute the third derivatives of the Jacobian of the transformation   pushed forward to the real cell coordinates.  
* [0.x.22]*
   Combination of the flags needed for Piola transform of Hdiv elements.  
* [0.x.23]*
   Combination of the flags that require a mapping calculation  
* [0.x.24]*
 Output operator which outputs update flags as a set of or'd text values.
*   [2.x.8] 

* 
* [0.x.25]*
 Global operator which returns an object in which all bits are set which are either set in the first or the second argument. This operator exists since if it did not then the result of the bit-or <tt>operator |</tt> would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type UpdateFlags.
*   [2.x.9] 

* 
* [0.x.26]*
 Global operator which sets the bits from the second argument also in the first one.
*   [2.x.10] 

* 
* [0.x.27]*
 Global operator which returns an object in which all bits are set which are set in the first as well as the second argument. This operator exists since if it did not then the result of the bit-and <tt>operator &</tt> would be an integer which would in turn trigger a compiler warning when we tried to assign it to an object of type UpdateFlags.
*   [2.x.11] 

* 
* [0.x.28]*
 Global operator which clears all the bits in the first argument if they are not also set in the second argument.
*   [2.x.12] 

* 
* [0.x.29]*
 This enum definition is used for storing similarities of the current cell to the previously visited cell. This information is used for reusing data when calling the method  [2.x.13]  (like derivatives, which do not change if one cell is just a translation of the previous). Currently, this variable does only recognize a translation and an inverted translation (if dim<spacedim). However, this concept makes it easy to add additional states to be detected in FEValues/FEFaceValues for making use of these similarities as well.

* 
* [0.x.30]*
     The cells differ by something besides a translation or inverted     translations.    
* [0.x.31]*
     The cells differ by a translation.    
* [0.x.32]*
     The cells differ by an inverted translation.    
* [0.x.33]*
     The next cell is not valid.    
* [0.x.34]*
     A class that stores all of the mapping related data used in      [2.x.14]   [2.x.15]  and  [2.x.16]      objects. Objects of this kind will be given as [1.x.1] argument     when  [2.x.17]  calls  [2.x.18]  for a     given cell, face, or subface.         The data herein will then be provided as [1.x.2] argument in the     following call to  [2.x.19]         
*  [2.x.20]     
* [0.x.35]*
       Initialize all vectors to correct size.      
* [0.x.36]*
       Compute and return an estimate for the memory consumption (in bytes)       of this object.      
* [0.x.37]*
       Store an array of weights times the Jacobi determinant at the       quadrature points. This function is reset each time reinit() is       called. The Jacobi determinant is actually the reciprocal value of       the Jacobi matrices stored in this class, see the general       documentation of this class for more information.             However, if this object refers to an FEFaceValues or FESubfaceValues       object, then the JxW_values correspond to the Jacobian of the       transformation of the face, not the cell, i.e. the dimensionality is       that of a surface measure, not of a volume measure. In this case, it       is computed from the boundary forms, rather than the Jacobian matrix.      
* [0.x.38]*
       Array of the Jacobian matrices at the quadrature points.      
* [0.x.39]*
       Array of the derivatives of the Jacobian matrices at the quadrature       points.      
* [0.x.40]*
       Array of the inverse Jacobian matrices at the quadrature points.      
* [0.x.41]*
       Array of the derivatives of the Jacobian matrices at the quadrature       points, pushed forward to the real cell coordinates.      
* [0.x.42]*
       Array of the second derivatives of the Jacobian matrices at the       quadrature points.      
* [0.x.43]*
       Array of the  second derivatives of the Jacobian matrices at the       quadrature points, pushed forward to the real cell coordinates.      
* [0.x.44]*
       Array of the  third derivatives of the Jacobian matrices at the       quadrature points.      
* [0.x.45]*
       Array of the  third derivatives of the Jacobian matrices at the       quadrature points, pushed forward to the real cell coordinates.      
* [0.x.46]*
       Array of quadrature points. This array is set up upon calling       reinit() and contains the quadrature points on the real element,       rather than on the reference element.      
* [0.x.47]*
       List of outward normal vectors at the quadrature points.      
* [0.x.48]*
       List of boundary forms at the quadrature points.      
* [0.x.49]*
     A class that stores all of the shape function related data used in      [2.x.21]   [2.x.22]  and  [2.x.23]      objects. Objects of this kind will be given as [1.x.3] argument     when  [2.x.24]  calls  [2.x.25]         
*  [2.x.26]     
* [0.x.50]*
       Initialize all vectors to correct size.      
* [0.x.51]*
       Compute and return an estimate for the memory consumption (in bytes)       of this object.      
* [0.x.52]*
       Storage type for shape values. Each row in the matrix denotes the       values of a single shape function at the different points, columns       are for a single point with the different shape functions.             If a shape function has more than one non-zero component (in deal.II       diction: it is non-primitive), then we allocate one row per non-zero       component, and shift subsequent rows backward.  Lookup of the correct       row for a shape function is thus simple in case the entire finite       element is primitive (i.e. all shape functions are primitive), since       then the shape function number equals the row number. Otherwise, use       the #shape_function_to_row_table array to get at the first row that       belongs to this particular shape function, and navigate among all the       rows for this shape function using the        [2.x.27]  function which tells us which       components are non-zero and thus have a row in the array presently       under discussion.      
* [0.x.53]*
       Storage type for gradients. The layout of data is the same as for the       #ShapeVector data type.      
* [0.x.54]*
       Likewise for second order derivatives.      
* [0.x.55]*
       And the same also applies to the third order derivatives.      
* [0.x.56]*
       Store the values of the shape functions at the quadrature points. See       the description of the data type for the layout of the data in this       field.      
* [0.x.57]*
       Store the gradients of the shape functions at the quadrature points.       See the description of the data type for the layout of the data in       this field.      
* [0.x.58]*
       Store the 2nd derivatives of the shape functions at the quadrature       points.  See the description of the data type for the layout of the       data in this field.      
* [0.x.59]*
       Store the 3rd derivatives of the shape functions at the quadrature       points.  See the description of the data type for the layout of the       data in this field.      
* [0.x.60]*
       When asked for the value (or gradient, or Hessian) of shape function       i's c-th vector component, we need to look it up in the       #shape_values, #shape_gradients and #shape_hessians arrays.  The       question is where in this array does the data for shape function i,       component c reside. This is what this table answers.             The format of the table is as follows:
* 
*  - It has dofs_per_cell times       n_components entries.
* 
*  - The entry that corresponds to shape function       i, component c is  [2.x.28] .
* 
*  - The value       stored at this position indicates the row in #shape_values and the       other tables where the corresponding datum is stored for all the       quadrature points.             In the general, vector-valued context, the number of components is       larger than one, but for a given shape function, not all vector       components may be nonzero (e.g., if a shape function is primitive,       then exactly one vector component is non-zero, while the others are       all zero). For such zero components, #shape_values and friends do not       have a row. Consequently, for vector components for which shape       function i is zero, the entry in the current table is        [2.x.29]              On the other hand, the table is guaranteed to have at least one valid       index for each shape function. In particular, for a primitive finite       element, each shape function has exactly one nonzero component and so       for each i, there is exactly one valid index within the range        [2.x.30] .      
* [0.x.61]

include/deal.II-translator/fe/fe_values_0.txt
[0.x.0]*
   A class whose specialization is used to define what type the curl of a   vector valued function corresponds to.  
* [0.x.1]*
   A class whose specialization is used to define what type the curl of a   vector valued function corresponds to.     In 1d, the curl is a scalar.  
* [0.x.2]*
   A class whose specialization is used to define what type the curl of a   vector valued function corresponds to.     In 2d, the curl is a scalar.  
* [0.x.3]*
   A class whose specialization is used to define what type the curl of a   vector valued function corresponds to.     In 3d, the curl is a vector.  
* [0.x.4]*
 A namespace for "views" on a FEValues, FEFaceValues, or FESubfaceValues object. A view represents only a certain part of the whole: whereas the FEValues object represents [1.x.0] values, gradients, or second derivatives of all components of a vector-valued element, views restrict the attention to only a single component or a subset of components. You typically get objects of classes defined in this namespace by applying FEValuesExtractors objects to a FEValues, FEFaceValues or FESubfaceValues objects using the square bracket operator.
*  There are classes that present views for single scalar components, vector components consisting of  [2.x.0]  elements, and symmetric second order tensor components consisting of  [2.x.1]  elements
*  See the description of the  [2.x.2]  module for examples how to use the features of this namespace.
* 

* 
*  [2.x.3] 

* 
* [0.x.5]*
   A class representing a view to a single scalar component of a possibly   vector-valued finite element. Views are discussed in the    [2.x.4]    module.     You get an object of this type if you apply a  [2.x.5]    to an FEValues, FEFaceValues or FESubfaceValues object.    
*  [2.x.6]   
* [0.x.6]*
     An alias for the data type of values of the view this class     represents. Since we deal with a single components, the value type is a     scalar double.    
* [0.x.7]*
     An alias for the type of gradients of the view this class represents.     Here, for a scalar component of the finite element, the gradient is a      [2.x.7] .    
* [0.x.8]*
     An alias for the type of second derivatives of the view this class     represents. Here, for a scalar component of the finite element, the     Hessian is a  [2.x.8] .    
* [0.x.9]*
     An alias for the type of third derivatives of the view this class     represents. Here, for a scalar component of the finite element, the     Third derivative is a  [2.x.9] .    
* [0.x.10]*
     An alias for the data type of the product of a  [2.x.10]  and the     values of the view this class provides. This is the data type of     scalar components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.11]     
* [0.x.11]*
     An alias for the data type of the product of a  [2.x.12]  and the     gradients of the view this class provides. This is the data type of     scalar components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.13]     
* [0.x.12]*
     An alias for the data type of the product of a  [2.x.14]  and the     laplacians of the view this class provides. This is the data type of     scalar components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.15]     
* [0.x.13]*
     An alias for the data type of the product of a  [2.x.16]  and the     hessians of the view this class provides. This is the data type of     scalar components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.17]     
* [0.x.14]*
     An alias for the data type of the product of a  [2.x.18]  and the     third derivatives of the view this class provides. This is the data type     of scalar components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.19]     
* [0.x.15]*
     A struct that provides the output type for the product of the value     and derivatives of basis functions of the Scalar view and any  [2.x.20]  type.          [2.x.21]  Use the types defined in the surrounding class instead.    
* [0.x.16]*
       An alias for the data type of the product of a  [2.x.22]  and the       values of the view the Scalar class.      
* [0.x.17]*
       An alias for the data type of the product of a  [2.x.23]  and the       gradients of the view the Scalar class.      
* [0.x.18]*
       An alias for the data type of the product of a  [2.x.24]  and the       laplacians of the view the Scalar class.      
* [0.x.19]*
       An alias for the data type of the product of a  [2.x.25]  and the       hessians of the view the Scalar class.      
* [0.x.20]*
       An alias for the data type of the product of a  [2.x.26]  and the       third derivatives of the view the Scalar class.      
* [0.x.21]*
     A structure where for each shape function we pre-compute a bunch of     data that will make later accesses much cheaper.    
* [0.x.22]*
       For each shape function, store whether the selected vector component       may be nonzero. For primitive shape functions we know for sure       whether a certain scalar component of a given shape function is       nonzero, whereas for non-primitive shape functions this may not be       entirely clear (e.g. for RT elements it depends on the shape of a       cell).      
* [0.x.23]*
       For each shape function, store the row index within the shape_values,       shape_gradients, and shape_hessians tables (the column index is the       quadrature point index). If the shape function is primitive, then we       can get this information from the shape_function_to_row_table of the       FEValues object; otherwise, we have to work a bit harder to compute       this information.      
* [0.x.24]*
     Default constructor. Creates an invalid object.    
* [0.x.25]*
     Constructor for an object that represents a single scalar component of     a FEValuesBase object (or of one of the classes derived from     FEValuesBase).    
* [0.x.26]*
     Copy constructor. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.27]*
     Move constructor.    
* [0.x.28]*
     Destructor.    
* [0.x.29]*
     Copy operator. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.30]*
     Move assignment operator.    
* [0.x.31]*
     Return the value of the vector component selected by this view, for the     shape function and quadrature point selected by the arguments.          [2.x.27]  shape_function Number of the shape function to be evaluated.     Note that this number runs from zero to dofs_per_cell, even in the case     of an FEFaceValues or FESubfaceValues object.          [2.x.28]  q_point Number of the quadrature point at which function is to     be evaluated.          [2.x.29]     
* [0.x.32]*
     Return the gradient (a tensor of rank 1) of the vector component     selected by this view, for the shape function and quadrature point     selected by the arguments.        
*  [2.x.30]  The meaning of the arguments is as documented for the value()     function.          [2.x.31]     
* [0.x.33]*
     Return the Hessian (the tensor of rank 2 of all second derivatives) of     the vector component selected by this view, for the shape function and     quadrature point selected by the arguments.        
*  [2.x.32]  The meaning of the arguments is as documented for the value()     function.          [2.x.33]     
* [0.x.34]*
     Return the tensor of rank 3 of all third derivatives of the vector     component selected by this view, for the shape function and quadrature     point selected by the arguments.        
*  [2.x.34]  The meaning of the arguments is as documented for the value()     function.          [2.x.35]     
* [0.x.35]*
     Return the values of the selected scalar component of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.36]  function but it only works on the     selected scalar component.         The data type stored by the output vector must be what you get when you     multiply the values of shape functions (i.e.,  [2.x.37]  times the     type used to store the values of the unknowns  [2.x.38]  of your finite     element vector  [2.x.39]  (represented by the  [2.x.40]  argument).          [2.x.41]     
* [0.x.36]*
     Same as above, but using a vector of local degree-of-freedom values. In     other words, instead of extracting the nodal values of the degrees of     freedom located on the current cell from a global vector associated with     a DoFHandler object (as the function above does), this function instead     takes these local nodal values through its first argument. A typical     way to obtain such a vector is by calling code such as    
* [1.x.1]
*      (See  [2.x.42]  for more information on this     function.) The point of the current function is then that one could     modify these local values first, for example by applying a limiter     or by ensuring that all nodal values are positive, before evaluating     the finite element field that corresponds to these local values on the     current cell. Another application is where one wants to postprocess     the solution on a cell into a different finite element space on every     cell, without actually creating a corresponding DoFHandler
* 
*  -  in that     case, all one would compute is a local representation of that     postprocessed function, characterized by its nodal values; this function     then allows the evaluation of that representation at quadrature points.          [2.x.43]  dof_values A vector of local nodal values. This vector must       have a length equal to number of DoFs on the current cell, and must       be ordered in the same order as degrees of freedom are numbered on       the reference cell.          [2.x.44]  values A vector of values of the given finite element field,       at the quadrature points on the current object.          [2.x.45]  InputVector The  [2.x.46]  type must allow creation       of an ArrayView object from it; this is satisfied by the        [2.x.47]  class, among others.    
* [0.x.37]*
     Return the gradients of the selected scalar component of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.48]  function but it only works on the     selected scalar component.         The data type stored by the output vector must be what you get when you     multiply the gradients of shape functions (i.e.,  [2.x.49]      times the type used to store the values of the unknowns  [2.x.50]  of your     finite element vector  [2.x.51]  (represented by the  [2.x.52]  argument).          [2.x.53]     
* [0.x.38]*
     This function relates to get_function_gradients() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.39]*
     Return the Hessians of the selected scalar component of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.54]  function but it only works on the     selected scalar component.         The data type stored by the output vector must be what you get when you     multiply the Hessians of shape functions (i.e.,  [2.x.55]  times     the type used to store the values of the unknowns  [2.x.56]  of your finite     element vector  [2.x.57]  (represented by the  [2.x.58]  argument).          [2.x.59]     
* [0.x.40]*
     This function relates to get_function_hessians() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.41]*
     Return the Laplacians of the selected scalar component of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called. The     Laplacians are the trace of the Hessians.         This function is the equivalent of the      [2.x.60]  function but it only works on the     selected scalar component.         The data type stored by the output vector must be what you get when you     multiply the Laplacians of shape functions (i.e.,  [2.x.61]  times     the type used to store the values of the unknowns  [2.x.62]  of your finite     element vector  [2.x.63]  (represented by the  [2.x.64]  argument).          [2.x.65]     
* [0.x.42]*
     This function relates to get_function_laplacians() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.43]*
     Return the third derivatives of the selected scalar component of the     finite element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.66]  function but it only works     on the selected scalar component.         The data type stored by the output vector must be what you get when you     multiply the third derivatives of shape functions (i.e.,  [2.x.67]      third_derivative_type) times the type used to store the values of the     unknowns  [2.x.68]  of your finite element vector  [2.x.69]  (represented by the  [2.x.70]      fe_function argument).          [2.x.71]     
* [0.x.44]*
     This function relates to get_function_third_derivatives() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.45]*
     A pointer to the FEValuesBase object we operate on.    
* [0.x.46]*
     The single scalar component this view represents of the FEValuesBase     object.    
* [0.x.47]*
     Store the data about shape functions.    
* [0.x.48]*
   A class representing a view to a set of  [2.x.72]  components   forming a vector part of a vector-valued finite element. Views are   discussed in the    [2.x.73]    module.     Note that in the current context, a vector is meant in the sense physics   uses it: it has  [2.x.74]  components that behave in specific   ways under coordinate system transformations. Examples include velocity   or displacement fields. This is opposed to how mathematics uses the word   "vector" (and how we use this word in other contexts in the library, for   example in the Vector class), where it really stands for a collection of   numbers. An example of this latter use of the word could be the set of   concentrations of chemical species in a flame; however, these are really   just a collection of scalar variables, since they do not change if the   coordinate system is rotated, unlike the components of a velocity vector,   and consequently, this class should not be used for this context.     This class allows to query the value, gradient and divergence of   (components of) shape functions and solutions representing vectors. The   gradient of a vector  [2.x.75]  is defined as  [2.x.76] .     You get an object of this type if you apply a  [2.x.77]    to an FEValues, FEFaceValues or FESubfaceValues object.    
*  [2.x.78]   
* [0.x.49]*
     An alias for the data type of values of the view this class     represents. Since we deal with a set of  [2.x.79]  components,     the value type is a Tensor<1,spacedim>.    
* [0.x.50]*
     An alias for the type of gradients of the view this class represents.     Here, for a set of  [2.x.80]  components of the finite element,     the gradient is a  [2.x.81] .         See the general documentation of this class for how exactly the     gradient of a vector is defined.    
* [0.x.51]*
     An alias for the type of symmetrized gradients of the view this class     represents. Here, for a set of  [2.x.82]  components of the     finite element, the symmetrized gradient is a      [2.x.83] .         The symmetric gradient of a vector field  [2.x.84]  is defined as      [2.x.85] .    
* [0.x.52]*
     An alias for the type of the divergence of the view this class     represents. Here, for a set of  [2.x.86]  components of the     finite element, the divergence of course is a scalar.    
* [0.x.53]*
     An alias for the type of the curl of the view this class represents.     Here, for a set of  [2.x.87]  components of the finite     element, the curl is a  [2.x.88] . For      [2.x.89] .    
* [0.x.54]*
     An alias for the type of second derivatives of the view this class     represents. Here, for a set of  [2.x.90]  components of the     finite element, the Hessian is a  [2.x.91] .    
* [0.x.55]*
     An alias for the type of third derivatives of the view this class     represents. Here, for a set of  [2.x.92]  components of the     finite element, the third derivative is a  [2.x.93] .    
* [0.x.56]*
     An alias for the data type of the product of a  [2.x.94]  and the     values of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.95]     
* [0.x.57]*
     An alias for the data type of the product of a  [2.x.96]  and the     gradients of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.97]     
* [0.x.58]*
     An alias for the data type of the product of a  [2.x.98]  and the     symmetric gradients of the view this class provides. This is the data     type of vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.99]     
* [0.x.59]*
     An alias for the data type of the product of a  [2.x.100]  and the     divergences of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.101]     
* [0.x.60]*
     An alias for the data type of the product of a  [2.x.102]  and the     laplacians of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.103]     
* [0.x.61]*
     An alias for the data type of the product of a  [2.x.104]  and the     curls of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.105]     
* [0.x.62]*
     An alias for the data type of the product of a  [2.x.106]  and the     hessians of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.107]     
* [0.x.63]*
     An alias for the data type of the product of a  [2.x.108]  and the     third derivatives of the view this class provides. This is the data type     of vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.109]     
* [0.x.64]*
     A struct that provides the output type for the product of the value     and derivatives of basis functions of the Vector view and any  [2.x.110]  type.          [2.x.111]  Use the types defined in the surrounding class instead.    
* [0.x.65]*
       An alias for the data type of the product of a  [2.x.112]  and the       values of the view the Vector class.      
* [0.x.66]*
       An alias for the data type of the product of a  [2.x.113]  and the       gradients of the view the Vector class.      
* [0.x.67]*
       An alias for the data type of the product of a  [2.x.114]  and the       symmetric gradients of the view the Vector class.      
* [0.x.68]*
       An alias for the data type of the product of a  [2.x.115]  and the       divergences of the view the Vector class.      
* [0.x.69]*
       An alias for the data type of the product of a  [2.x.116]  and the       laplacians of the view the Vector class.      
* [0.x.70]*
       An alias for the data type of the product of a  [2.x.117]  and the       curls of the view the Vector class.      
* [0.x.71]*
       An alias for the data type of the product of a  [2.x.118]  and the       hessians of the view the Vector class.      
* [0.x.72]*
       An alias for the data type of the product of a  [2.x.119]  and the       third derivatives of the view the Vector class.      
* [0.x.73]*
     A structure where for each shape function we pre-compute a bunch of     data that will make later accesses much cheaper.    
* [0.x.74]*
       For each pair (shape function,component within vector), store whether       the selected vector component may be nonzero. For primitive shape       functions we know for sure whether a certain scalar component of a       given shape function is nonzero, whereas for non-primitive shape       functions this may not be entirely clear (e.g. for RT elements it       depends on the shape of a cell).      
* [0.x.75]*
       For each pair (shape function, component within vector), store the       row index within the shape_values, shape_gradients, and       shape_hessians tables (the column index is the quadrature point       index). If the shape function is primitive, then we can get this       information from the shape_function_to_row_table of the FEValues       object; otherwise, we have to work a bit harder to compute this       information.      
* [0.x.76]*
       For each shape function say the following: if only a single entry in       is_nonzero_shape_function_component for this shape function is       nonzero, then store the corresponding value of row_index and       single_nonzero_component_index represents the index between 0 and dim       for which it is attained. If multiple components are nonzero, then       store
* 
*  - . If no components are nonzero then store
* 
*  - .      
* [0.x.77]*
     Default constructor. Creates an invalid object.    
* [0.x.78]*
     Constructor for an object that represents dim components of a     FEValuesBase object (or of one of the classes derived from     FEValuesBase), representing a vector-valued variable.         The second argument denotes the index of the first component of the     selected vector.    
* [0.x.79]*
     Copy constructor. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.80]*
     Move constuctor.    
* [0.x.81]*
     Destructor.    
* [0.x.82]*
     Copy operator. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.83]*
     Move assignment operator.    
* [0.x.84]*
     Return the value of the vector components selected by this view, for     the shape function and quadrature point selected by the arguments.     Here, since the view represents a vector-valued part of the FEValues     object with  [2.x.120]  components, the return type is a tensor of     rank 1 with  [2.x.121]  components.          [2.x.122]  shape_function Number of the shape function to be evaluated.     Note that this number runs from zero to dofs_per_cell, even in the case     of an FEFaceValues or FESubfaceValues object.          [2.x.123]  q_point Number of the quadrature point at which function is to     be evaluated.          [2.x.124]     
* [0.x.85]*
     Return the gradient (a tensor of rank 2) of the vector component     selected by this view, for the shape function and quadrature point     selected by the arguments.         See the general documentation of this class for how exactly the     gradient of a vector is defined.        
*  [2.x.125]  The meaning of the arguments is as documented for the value()     function.          [2.x.126]     
* [0.x.86]*
     Return the symmetric gradient (a symmetric tensor of rank 2) of the     vector component selected by this view, for the shape function and     quadrature point selected by the arguments.         The symmetric gradient is defined as  [2.x.127] , where  [2.x.128]  represents the      [2.x.129]  components selected from the FEValuesBase object, and      [2.x.130]  is the location of the  [2.x.131] -th quadrature point.        
*  [2.x.132]  The meaning of the arguments is as documented for the value()     function.          [2.x.133]     
* [0.x.87]*
     Return the scalar divergence of the vector components selected by this     view, for the shape function and quadrature point selected by the     arguments.        
*  [2.x.134]  The meaning of the arguments is as documented for the value()     function.          [2.x.135]     
* [0.x.88]*
     Return the vector curl of the vector components selected by this view,     for the shape function and quadrature point selected by the arguments.     For 1d this function does not make any sense. Thus it is not     implemented for  [2.x.136] .  In 2d the curl is defined as     [1.x.2]
*      whereas in 3d it is given by     [1.x.3]
*         
*  [2.x.137]  The meaning of the arguments is as documented for the value()     function.          [2.x.138]     
* [0.x.89]*
     Return the Hessian (the tensor of rank 2 of all second derivatives) of     the vector components selected by this view, for the shape function and     quadrature point selected by the arguments.        
*  [2.x.139]  The meaning of the arguments is as documented for the value()     function.          [2.x.140]     
* [0.x.90]*
     Return the tensor of rank 3 of all third derivatives of the vector     components selected by this view, for the shape function and quadrature     point selected by the arguments.        
*  [2.x.141]  The meaning of the arguments is as documented for the value()     function.          [2.x.142]     
* [0.x.91]*
     Return the values of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.143]  function but it only works on the     selected vector components.         The data type stored by the output vector must be what you get when you     multiply the values of shape functions (i.e.,  [2.x.144]  times the     type used to store the values of the unknowns  [2.x.145]  of your finite     element vector  [2.x.146]  (represented by the  [2.x.147]  argument).          [2.x.148]     
* [0.x.92]*
     Same as above, but using a vector of local degree-of-freedom values. In     other words, instead of extracting the nodal values of the degrees of     freedom located on the current cell from a global vector associated with     a DoFHandler object (as the function above does), this function instead     takes these local nodal values through its first argument. A typical     way to obtain such a vector is by calling code such as    
* [1.x.4]
*      (See  [2.x.149]  for more information on this     function.) The point of the current function is then that one could     modify these local values first, for example by applying a limiter     or by ensuring that all nodal values are positive, before evaluating     the finite element field that corresponds to these local values on the     current cell. Another application is where one wants to postprocess     the solution on a cell into a different finite element space on every     cell, without actually creating a corresponding DoFHandler
* 
*  -  in that     case, all one would compute is a local representation of that     postprocessed function, characterized by its nodal values; this function     then allows the evaluation of that representation at quadrature points.          [2.x.150]  dof_values A vector of local nodal values. This vector must       have a length equal to number of DoFs on the current cell, and must       be ordered in the same order as degrees of freedom are numbered on       the reference cell.          [2.x.151]  values A vector of values of the given finite element field,       at the quadrature points on the current object.          [2.x.152]  InputVector The  [2.x.153]  type must allow creation       of an ArrayView object from it; this is satisfied by the        [2.x.154]  class, among others.    
* [0.x.93]*
     Return the gradients of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.155]  function but it only works on the     selected vector components.         The data type stored by the output vector must be what you get when you     multiply the gradients of shape functions (i.e.,  [2.x.156]      times the type used to store the values of the unknowns  [2.x.157]  of your     finite element vector  [2.x.158]  (represented by the  [2.x.159]  argument).          [2.x.160]     
* [0.x.94]*
     This function relates to get_function_gradients() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.95]*
     Return the symmetrized gradients of the selected vector components of     the finite element function characterized by <tt>fe_function</tt> at     the quadrature points of the cell, face or subface selected the last     time the <tt>reinit</tt> function of the FEValues object was called.         The symmetric gradient of a vector field  [2.x.161]  is defined as      [2.x.162] .        
*  [2.x.163]  There is no equivalent function such as      [2.x.164]  in the FEValues classes     but the information can be obtained from      [2.x.165]  of course.         The data type stored by the output vector must be what you get when you     multiply the symmetric gradients of shape functions (i.e.,  [2.x.166]      symmetric_gradient_type) times the type used to store the values of the     unknowns  [2.x.167]  of your finite element vector  [2.x.168]  (represented by the  [2.x.169]      fe_function argument).          [2.x.170]     
* [0.x.96]*
     This function relates to get_function_symmetric_gradients() in the same     way as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.97]*
     Return the divergence of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         There is no equivalent function such as      [2.x.171]  in the FEValues classes but the     information can be obtained from  [2.x.172]      of course.         The data type stored by the output vector must be what you get when you     multiply the divergences of shape functions (i.e.,  [2.x.173]      times the type used to store the values of the unknowns  [2.x.174]  of your     finite element vector  [2.x.175]  (represented by the  [2.x.176]  argument).          [2.x.177]     
* [0.x.98]*
     This function relates to get_function_divergences() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.99]*
     Return the curl of the selected vector components of the finite element     function characterized by <tt>fe_function</tt> at the quadrature points     of the cell, face or subface selected the last time the <tt>reinit</tt>     function of the FEValues object was called.         There is no equivalent function such as      [2.x.178]  in the FEValues classes but the     information can be obtained from  [2.x.179]      of course.         The data type stored by the output vector must be what you get when you     multiply the curls of shape functions (i.e.,  [2.x.180]  times the     type used to store the values of the unknowns  [2.x.181]  of your finite     element vector  [2.x.182]  (represented by the  [2.x.183]  argument).          [2.x.184]     
* [0.x.100]*
     This function relates to get_function_curls() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.101]*
     Return the Hessians of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.185]  function but it only works on the     selected vector components.         The data type stored by the output vector must be what you get when you     multiply the Hessians of shape functions (i.e.,  [2.x.186]  times     the type used to store the values of the unknowns  [2.x.187]  of your finite     element vector  [2.x.188]  (represented by the  [2.x.189]  argument).          [2.x.190]     
* [0.x.102]*
     This function relates to get_function_hessians() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.103]*
     Return the Laplacians of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called. The     Laplacians are the trace of the Hessians.         This function is the equivalent of the      [2.x.191]  function but it only works on the     selected vector components.         The data type stored by the output vector must be what you get when you     multiply the Laplacians of shape functions (i.e.,  [2.x.192]      times the type used to store the values of the unknowns  [2.x.193]  of your     finite element vector  [2.x.194]  (represented by the  [2.x.195]  argument).          [2.x.196]     
* [0.x.104]*
     This function relates to get_function_laplacians() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.105]*
     Return the third derivatives of the selected scalar component of the     finite element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.197]  function but it only works     on the selected scalar component.         The data type stored by the output vector must be what you get when you     multiply the third derivatives of shape functions (i.e.,  [2.x.198]      third_derivative_type) times the type used to store the values of the     unknowns  [2.x.199]  of your finite element vector  [2.x.200]  (represented by the  [2.x.201]      fe_function argument).          [2.x.202]     
* [0.x.106]*
     This function relates to get_function_third_derivatives() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.107]*
     A pointer to the FEValuesBase object we operate on.    
* [0.x.108]*
     The first component of the vector this view represents of the     FEValuesBase object.    
* [0.x.109]*
     Store the data about shape functions.    
* [0.x.110]*
   A class representing a view to a set of  [2.x.203]    components forming a symmetric second-order tensor from a vector-valued   finite element. Views are discussed in the    [2.x.204]    module.     This class allows to query the value and divergence of (components of)   shape functions and solutions representing symmetric tensors. The   divergence of a symmetric tensor  [2.x.205]  is defined   as  [2.x.206] , which due to the symmetry of the tensor is also  [2.x.207] .  In other words, it due to   the symmetry of  [2.x.208]  it does not matter whether we apply the nabla   operator by row or by column to get the divergence.     You get an object of this type if you apply a    [2.x.209]  to an FEValues, FEFaceValues or   FESubfaceValues object.    
*  [2.x.210]   
* [0.x.111]*
     An alias for the data type of values of the view this class     represents. Since we deal with a set of  [2.x.211]      components (i.e. the unique components of a symmetric second-order     tensor), the value type is a SymmetricTensor<2,spacedim>.    
* [0.x.112]*
     An alias for the type of the divergence of the view this class     represents. Here, for a set of  [2.x.212]  unique     components of the finite element representing a symmetric second-order     tensor, the divergence of course is a  [2.x.213] .         See the general discussion of this class for a definition of the     divergence.    
* [0.x.113]*
     An alias for the data type of the product of a  [2.x.214]  and the     values of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.215]     
* [0.x.114]*
     An alias for the data type of the product of a  [2.x.216]  and the     divergences of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.217]     
* [0.x.115]*
     A struct that provides the output type for the product of the value     and derivatives of basis functions of the SymmetricTensor view and any  [2.x.218]  type.          [2.x.219]  Use the types defined in the surrounding class instead.    
* [0.x.116]*
       An alias for the data type of the product of a  [2.x.220]  and the       values of the view the SymmetricTensor class.      
* [0.x.117]*
       An alias for the data type of the product of a  [2.x.221]  and the       divergences of the view the SymmetricTensor class.      
* [0.x.118]*
     A structure where for each shape function we pre-compute a bunch of     data that will make later accesses much cheaper.    
* [0.x.119]*
       For each pair (shape function,component within vector), store whether       the selected vector component may be nonzero. For primitive shape       functions we know for sure whether a certain scalar component of a       given shape function is nonzero, whereas for non-primitive shape       functions this may not be entirely clear (e.g. for RT elements it       depends on the shape of a cell).      
* [0.x.120]*
       For each pair (shape function, component within vector), store the       row index within the shape_values, shape_gradients, and       shape_hessians tables (the column index is the quadrature point       index). If the shape function is primitive, then we can get this       information from the shape_function_to_row_table of the FEValues       object; otherwise, we have to work a bit harder to compute this       information.      
* [0.x.121]*
       For each shape function say the following: if only a single entry in       is_nonzero_shape_function_component for this shape function is       nonzero, then store the corresponding value of row_index and       single_nonzero_component_index represents the index between 0 and       (dim^2 + dim)/2 for which it is attained. If multiple components are       nonzero, then store
* 
*  - . If no components are nonzero then store
* 
*  - .      
* [0.x.122]*
       Index of the  [2.x.222]  .      
* [0.x.123]*
     Default constructor. Creates an invalid object.    
* [0.x.124]*
     Constructor for an object that represents <code>(dim*dim +     dim)/2</code> components of a FEValuesBase object (or of one of the     classes derived from FEValuesBase), representing the unique components     comprising a symmetric second- order tensor valued variable.         The second argument denotes the index of the first component of the     selected symmetric second order tensor.    
* [0.x.125]*
     Copy constructor. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.126]*
     Move constructor.    
* [0.x.127]*
     Copy operator. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.128]*
     Move assignment operator.    
* [0.x.129]*
     Return the value of the vector components selected by this view, for     the shape function and quadrature point selected by the arguments.     Here, since the view represents a vector-valued part of the FEValues     object with  [2.x.223]  components (the unique     components of a symmetric second-order tensor), the return type is a     symmetric tensor of rank 2.          [2.x.224]  shape_function Number of the shape function to be evaluated.     Note that this number runs from zero to dofs_per_cell, even in the case     of an FEFaceValues or FESubfaceValues object.          [2.x.225]  q_point Number of the quadrature point at which function is to     be evaluated.          [2.x.226]     
* [0.x.130]*
     Return the vector divergence of the vector components selected by this     view, for the shape function and quadrature point selected by the     arguments.         See the general discussion of this class for a definition of the     divergence.        
*  [2.x.227]  The meaning of the arguments is as documented for the value()     function.          [2.x.228]     
* [0.x.131]*
     Return the values of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.229]  function but it only works on the     selected vector components.         The data type stored by the output vector must be what you get when you     multiply the values of shape functions (i.e.,  [2.x.230]  times the     type used to store the values of the unknowns  [2.x.231]  of your finite     element vector  [2.x.232]  (represented by the  [2.x.233]  argument).          [2.x.234]     
* [0.x.132]*
     Same as above, but using a vector of local degree-of-freedom values. In     other words, instead of extracting the nodal values of the degrees of     freedom located on the current cell from a global vector associated with     a DoFHandler object (as the function above does), this function instead     takes these local nodal values through its first argument. A typical     way to obtain such a vector is by calling code such as    
* [1.x.5]
*      (See  [2.x.235]  for more information on this     function.) The point of the current function is then that one could     modify these local values first, for example by applying a limiter     or by ensuring that all nodal values are positive, before evaluating     the finite element field that corresponds to these local values on the     current cell. Another application is where one wants to postprocess     the solution on a cell into a different finite element space on every     cell, without actually creating a corresponding DoFHandler
* 
*  -  in that     case, all one would compute is a local representation of that     postprocessed function, characterized by its nodal values; this function     then allows the evaluation of that representation at quadrature points.          [2.x.236]  dof_values A vector of local nodal values. This vector must       have a length equal to number of DoFs on the current cell, and must       be ordered in the same order as degrees of freedom are numbered on       the reference cell.          [2.x.237]  values A vector of values of the given finite element field,       at the quadrature points on the current object.          [2.x.238]  InputVector The  [2.x.239]  type must allow creation       of an ArrayView object from it; this is satisfied by the        [2.x.240]  class, among others.    
* [0.x.133]*
     Return the divergence of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         There is no equivalent function such as      [2.x.241]  in the FEValues classes but the     information can be obtained from  [2.x.242]      of course.         See the general discussion of this class for a definition of the     divergence.         The data type stored by the output vector must be what you get when you     multiply the divergences of shape functions (i.e.,  [2.x.243]      times the type used to store the values of the unknowns  [2.x.244]  of your     finite element vector  [2.x.245]  (represented by the  [2.x.246]  argument).          [2.x.247]     
* [0.x.134]*
     This function relates to get_function_divergences() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.135]*
     A pointer to the FEValuesBase object we operate on.    
* [0.x.136]*
     The first component of the vector this view represents of the     FEValuesBase object.    
* [0.x.137]*
     Store the data about shape functions.    
* [0.x.138]*
   A class representing a view to a set of  [2.x.248]  components   forming a second-order tensor from a vector-valued finite element. Views   are discussed in the    [2.x.249]    module.     This class allows to query the value, gradient and divergence of   (components of) shape functions and solutions representing tensors. The   divergence of a tensor  [2.x.250]  is defined as  [2.x.251] , whereas   its gradient is  [2.x.252] .     You get an object of this type if you apply a  [2.x.253]    to an FEValues, FEFaceValues or FESubfaceValues object.    
*  [2.x.254]   
* [0.x.139]*
     Data type for what you get when you apply an extractor of this kind to     a vector-valued finite element.    
* [0.x.140]*
     Data type for taking the divergence of a tensor: a vector.    
* [0.x.141]*
     Data type for taking the gradient of a second order tensor: a third order     tensor.    
* [0.x.142]*
     An alias for the data type of the product of a  [2.x.255]  and the     values of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.256]     
* [0.x.143]*
     An alias for the data type of the product of a  [2.x.257]  and the     divergences of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.258]     
* [0.x.144]*
     An alias for the data type of the product of a  [2.x.259]  and the     gradient of the view this class provides. This is the data type of     vector components of a finite element field whose degrees of     freedom are described by a vector with elements of type  [2.x.260]     
* [0.x.145]*
     A struct that provides the output type for the product of the value     and derivatives of basis functions of the Tensor view and any  [2.x.261]  type.          [2.x.262]  Use the types defined in the surrounding class instead.    
* [0.x.146]*
       An alias for the data type of the product of a  [2.x.263]  and the       values of the view the Tensor class.      
* [0.x.147]*
       An alias for the data type of the product of a  [2.x.264]  and the       divergences of the view the Tensor class.      
* [0.x.148]*
       An alias for the data type of the product of a  [2.x.265]  and the       gradient of the view the Tensor class.      
* [0.x.149]*
     A structure where for each shape function we pre-compute a bunch of     data that will make later accesses much cheaper.    
* [0.x.150]*
       For each pair (shape function,component within vector), store whether       the selected vector component may be nonzero. For primitive shape       functions we know for sure whether a certain scalar component of a       given shape function is nonzero, whereas for non-primitive shape       functions this may not be entirely clear (e.g. for RT elements it       depends on the shape of a cell).      
* [0.x.151]*
       For each pair (shape function, component within vector), store the       row index within the shape_values, shape_gradients, and       shape_hessians tables (the column index is the quadrature point       index). If the shape function is primitive, then we can get this       information from the shape_function_to_row_table of the FEValues       object; otherwise, we have to work a bit harder to compute this       information.      
* [0.x.152]*
       For each shape function say the following: if only a single entry in       is_nonzero_shape_function_component for this shape function is       nonzero, then store the corresponding value of row_index and       single_nonzero_component_index represents the index between 0 and       (dim^2) for which it is attained. If multiple components are nonzero,       then store
* 
*  - . If no components are nonzero then store
* 
*  - .      
* [0.x.153]*
       Index of the  [2.x.266]  .      
* [0.x.154]*
     Default constructor. Creates an invalid object.    
* [0.x.155]*
     Copy constructor. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.156]*
     Move constructor.    
* [0.x.157]*
     Destructor.    
* [0.x.158]*
     Constructor for an object that represents  [2.x.267]      components of a FEValuesBase object (or of one of the classes derived     from FEValuesBase), representing the unique components comprising a     second-order tensor valued variable.         The second argument denotes the index of the first component of the     selected symmetric second order tensor.    
* [0.x.159]*
     Copy operator. This is not a lightweight object so we don't allow     copying and generate a compile-time error if this function is called.    
* [0.x.160]*
     Move assignment operator.    
* [0.x.161]*
     Return the value of the vector components selected by this view, for     the shape function and quadrature point selected by the arguments.     Here, since the view represents a vector-valued part of the FEValues     object with  [2.x.268]  components (the unique components of     a second-order tensor), the return type is a tensor of rank 2.          [2.x.269]  shape_function Number of the shape function to be evaluated.     Note that this number runs from zero to dofs_per_cell, even in the case     of an FEFaceValues or FESubfaceValues object.          [2.x.270]  q_point Number of the quadrature point at which function is to     be evaluated.          [2.x.271]     
* [0.x.162]*
     Return the vector divergence of the vector components selected by this     view, for the shape function and quadrature point selected by the     arguments.         See the general discussion of this class for a definition of the     divergence.        
*  [2.x.272]  The meaning of the arguments is as documented for the value()     function.          [2.x.273]     
* [0.x.163]*
     Return the gradient (3-rd order tensor) of the vector components selected     by this view, for the shape function and quadrature point selected by the     arguments.         See the general discussion of this class for a definition of the     gradient.        
*  [2.x.274]  The meaning of the arguments is as documented for the value()     function.          [2.x.275]     
* [0.x.164]*
     Return the values of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         This function is the equivalent of the      [2.x.276]  function but it only works on the     selected vector components.         The data type stored by the output vector must be what you get when you     multiply the values of shape functions (i.e.,  [2.x.277]  times the     type used to store the values of the unknowns  [2.x.278]  of your finite     element vector  [2.x.279]  (represented by the  [2.x.280]  argument).          [2.x.281]     
* [0.x.165]*
     Same as above, but using a vector of local degree-of-freedom values. In     other words, instead of extracting the nodal values of the degrees of     freedom located on the current cell from a global vector associated with     a DoFHandler object (as the function above does), this function instead     takes these local nodal values through its first argument. A typical     way to obtain such a vector is by calling code such as    
* [1.x.6]
*      (See  [2.x.282]  for more information on this     function.) The point of the current function is then that one could     modify these local values first, for example by applying a limiter     or by ensuring that all nodal values are positive, before evaluating     the finite element field that corresponds to these local values on the     current cell. Another application is where one wants to postprocess     the solution on a cell into a different finite element space on every     cell, without actually creating a corresponding DoFHandler
* 
*  -  in that     case, all one would compute is a local representation of that     postprocessed function, characterized by its nodal values; this function     then allows the evaluation of that representation at quadrature points.          [2.x.283]  dof_values A vector of local nodal values. This vector must       have a length equal to number of DoFs on the current cell, and must       be ordered in the same order as degrees of freedom are numbered on       the reference cell.          [2.x.284]  values A vector of values of the given finite element field,       at the quadrature points on the current object.          [2.x.285]  InputVector The  [2.x.286]  type must allow creation       of an ArrayView object from it; this is satisfied by the        [2.x.287]  class, among others.    
* [0.x.166]*
     Return the divergence of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         There is no equivalent function such as      [2.x.288]  in the FEValues classes but the     information can be obtained from  [2.x.289]      of course.         See the general discussion of this class for a definition of the     divergence.         The data type stored by the output vector must be what you get when you     multiply the divergences of shape functions (i.e.,  [2.x.290]      times the type used to store the values of the unknowns  [2.x.291]  of your     finite element vector  [2.x.292]  (represented by the  [2.x.293]  argument).          [2.x.294]     
* [0.x.167]*
     This function relates to get_function_divergences() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.168]*
     Return the gradient of the selected vector components of the finite     element function characterized by <tt>fe_function</tt> at the     quadrature points of the cell, face or subface selected the last time     the <tt>reinit</tt> function of the FEValues object was called.         See the general discussion of this class for a definition of the     gradient.         The data type stored by the output vector must be what you get when you     multiply the gradients of shape functions (i.e.,  [2.x.295]      times the type used to store the values of the unknowns  [2.x.296]  of your     finite element vector  [2.x.297]  (represented by the  [2.x.298]  argument).          [2.x.299]     
* [0.x.169]*
     This function relates to get_function_gradients() in the same way     as get_function_values_from_local_dof_values() relates to     get_function_values(). See the documentation of     get_function_values_from_local_dof_values() for more information.    
* [0.x.170]*
     A pointer to the FEValuesBase object we operate on.    
* [0.x.171]*
     The first component of the vector this view represents of the     FEValuesBase object.    
* [0.x.172]*
     Store the data about shape functions.    
* [0.x.173]*
     A class whose specialization is used to define what FEValuesViews     object corresponds to the given FEValuesExtractors object.    
* [0.x.174]*
     A class whose specialization is used to define what FEValuesViews     object corresponds to the given FEValuesExtractors object.         When using  [2.x.300]  the corresponding view is an      [2.x.301]  spacedim>.    
* [0.x.175]*
     A class whose specialization is used to define what FEValuesViews     object corresponds to the given FEValuesExtractors object.         When using  [2.x.302]  the corresponding view is an      [2.x.303]  spacedim>.    
* [0.x.176]*
     A class whose specialization is used to define what FEValuesViews     object corresponds to the given FEValuesExtractors object.         When using  [2.x.304]  the corresponding view is an      [2.x.305]  dim, spacedim>.    
* [0.x.177]*
     A class whose specialization is used to define what FEValuesViews     object corresponds to the given FEValuesExtractors object.         When using  [2.x.306]  the corresponding     view is an  [2.x.307]  dim, spacedim>.    
* [0.x.178]*
     A class objects of which store a collection of  [2.x.308]       [2.x.309]  etc object. The FEValuesBase class uses it to     generate all possible Views classes upon construction time; we do this     at construction time since the Views classes cache some information and     are therefore relatively expensive to create.    
* [0.x.179]*
       Caches for scalar and vector, and symmetric second-order tensor       valued views.      
* [0.x.180]*
       Constructor.      
* [0.x.181]*
   A templated alias that associates to a given Extractor class   the corresponding view in FEValuesViews.  
* [0.x.182]*
 FEValues, FEFaceValues and FESubfaceValues objects are interfaces to finite element and mapping classes on the one hand side, to cells and quadrature rules on the other side. They allow to evaluate values or derivatives of shape functions at the quadrature points of a quadrature formula when projected by a mapping from the unit cell onto a cell in real space. The reason for this abstraction is possible optimization: Depending on the type of finite element and mapping, some values can be computed once on the unit cell. Others must be computed on each cell, but maybe computation of several values at the same time offers ways for optimization. Since this interplay may be complex and depends on the actual finite element, it cannot be left to the applications programmer.
*  FEValues, FEFaceValues and FESubfaceValues provide only data handling: computations are left to objects of type Mapping and FiniteElement. These provide functions <tt>get_*_data</tt> and <tt>fill_*_values</tt> which are called by the constructor and <tt>reinit</tt> functions of <tt>FEValues*</tt>, respectively.
*  [1.x.7]
*  Usually, an object of <tt>FEValues*</tt> is used in integration loops over all cells of a triangulation (or faces of cells). To take full advantage of the optimization features, it should be constructed before the loop so that information that does not depend on the location and shape of cells can be computed once and for all (this includes, for example, the values of shape functions at quadrature points for the most common elements: we can evaluate them on the unit cell and they will be the same when mapped to the real cell). Then, in the loop over all cells, it must be re-initialized for each grid cell to compute that part of the information that changes depending on the actual cell (for example, the gradient of shape functions equals the gradient on the unit cell
* 
*  -  which can be computed once and for all
* 
*  -  times the Jacobian matrix of the mapping between unit and real cell, which needs to be recomputed for each cell).
*  A typical piece of code, adding up local contributions to the Laplace matrix looks like this:
* 

* 
* [1.x.8]
* 
*  The individual functions used here are described below. Note that by design, the order of quadrature points used inside the FEValues object is the same as defined by the quadrature formula passed to the constructor of the FEValues object above.
*  [1.x.9]
*  The functions of this class fall into different categories:  [2.x.310]   [2.x.311]  shape_value(), shape_grad(), etc: return one of the values of this object at a time. These functions are inlined, so this is the suggested access to all finite element values. There should be no loss in performance with an optimizing compiler. If the finite element is vector valued, then these functions return the only non-zero component of the requested shape function. However, some finite elements have shape functions that have more than one non-zero component (we call them non-"primitive"), and in this case this set of functions will throw an exception since they cannot generate a useful result. Rather, use the next set of functions.
*   [2.x.312]  shape_value_component(), shape_grad_component(), etc: This is the same set of functions as above, except that for vector valued finite elements they return only one vector component. This is useful for elements of which shape functions have more than one non-zero component, since then the above functions cannot be used, and you have to walk over all (or only the non- zero) components of the shape function using this set of functions.
*   [2.x.313]  get_function_values(), get_function_gradients(), etc.: Compute a finite element function or its derivative in quadrature points.
*   [2.x.314]  reinit: initialize the FEValues object for a certain cell. This function is not in the present class but only in the derived classes and has a variable call syntax. See the docs for the derived classes for more information.  [2.x.315] 
* 

*  [1.x.10]
*  The mechanisms by which this class work are discussed on the page on  [2.x.316]  "Update flags" and about the  [2.x.317]  "How Mapping, FiniteElement, and FEValues work together".
* 

* 

* 
*  [2.x.318] 

* 
* [0.x.183]*
   Dimension in which this object operates.  
* [0.x.184]*
   Dimension of the space in which this object operates.  
* [0.x.185]*
   Number of quadrature points of the current object. Its value is   initialized by the value of max_n_quadrature_points and is updated,   e.g., if  [2.x.319]  is called for a new cell/face.    
*  [2.x.320]  The default value equals to the value of max_n_quadrature_points.  
* [0.x.186]*
   Maximum number of quadrature points. This value might be different from   n_quadrature_points, e.g., if a QCollection with different face quadrature   rules has been passed to initialize FEFaceValues.     This is mostly useful to initialize arrays to allocate the maximum amount   of memory that may be used when re-sizing later on to a the current   number of quadrature points given by n_quadrature_points.  
* [0.x.187]*
   Number of shape functions per cell. If we use this base class to evaluate   a finite element on faces of cells, this is still the number of degrees   of freedom per cell, not per face.  
* [0.x.188]*
   Constructor. Set up the array sizes with <tt>n_q_points</tt> quadrature   points, <tt>dofs_per_cell</tt> trial functions per cell and with the   given pattern to update the fields when the <tt>reinit</tt> function of   the derived classes is called. The fields themselves are not set up, this   must happen in the constructor of the derived class.  
* [0.x.189]*
   The copy assignment is deleted since objects of this class are not   copyable.  
* [0.x.190]*
   The copy constructor is deleted since objects of this class are not   copyable.  
* [0.x.191]*
   Destructor.  
* [0.x.192]*
   Value of a shape function at a quadrature point on the cell, face or   subface selected the last time the <tt>reinit</tt> function of the   derived class was called.     If the shape function is vector-valued, then this returns the only non-   zero component. If the shape function has more than one non-zero   component (i.e. it is not primitive), then throw an exception of type   ExcShapeFunctionNotPrimitive. In that case, use the   shape_value_component() function.      [2.x.321]  function_no Number of the shape function to be evaluated. Note   that this number runs from zero to dofs_per_cell, even in the case of an   FEFaceValues or FESubfaceValues object.      [2.x.322]  point_no Number of the quadrature point at which function is to be   evaluated      [2.x.323]   
* [0.x.193]*
   Compute one vector component of the value of a shape function at a   quadrature point. If the finite element is scalar, then only component   zero is allowed and the return value equals that of the shape_value()   function. If the finite element is vector valued but all shape functions   are primitive (i.e. they are non-zero in only one component), then the   value returned by shape_value() equals that of this function for exactly   one component. This function is therefore only of greater interest if the   shape function is not primitive, but then it is necessary since the other   function cannot be used.      [2.x.324]  function_no Number of the shape function to be evaluated.      [2.x.325]  point_no Number of the quadrature point at which function is to be   evaluated.      [2.x.326]  component vector component to be evaluated.      [2.x.327]   
* [0.x.194]*
   Compute the gradient of the <tt>function_no</tt>th shape function at the   <tt>quadrature_point</tt>th quadrature point with respect to real cell   coordinates.  If you want to get the derivative in one of the coordinate   directions, use the appropriate function of the Tensor class to extract   one component of the Tensor returned by this function. Since only a   reference to the gradient's value is returned, there should be no major   performance drawback.     If the shape function is vector-valued, then this returns the only non-   zero component. If the shape function has more than one non-zero   component (i.e. it is not primitive), then it will throw an exception of   type ExcShapeFunctionNotPrimitive. In that case, use the   shape_grad_component() function.     The same holds for the arguments of this function as for the   shape_value() function.      [2.x.328]  function_no Number of the shape function to be evaluated.      [2.x.329]  quadrature_point Number of the quadrature point at which function   is to be evaluated.      [2.x.330]   
* [0.x.195]*
   Return one vector component of the gradient of a shape function at a   quadrature point. If the finite element is scalar, then only component   zero is allowed and the return value equals that of the shape_grad()   function. If the finite element is vector valued but all shape functions   are primitive (i.e. they are non-zero in only one component), then the   value returned by shape_grad() equals that of this function for exactly   one component. This function is therefore only of greater interest if the   shape function is not primitive, but then it is necessary since the other   function cannot be used.     The same holds for the arguments of this function as for the   shape_value_component() function.      [2.x.331]   
* [0.x.196]*
   Second derivatives of the <tt>function_no</tt>th shape function at the   <tt>point_no</tt>th quadrature point with respect to real cell   coordinates. If you want to get the derivatives in one of the coordinate   directions, use the appropriate function of the Tensor class to extract   one component. Since only a reference to the hessian values is returned,   there should be no major performance drawback.     If the shape function is vector-valued, then this returns the only non-   zero component. If the shape function has more than one non-zero   component (i.e. it is not primitive), then throw an exception of type   ExcShapeFunctionNotPrimitive. In that case, use the   shape_hessian_component() function.     The same holds for the arguments of this function as for the   shape_value() function.      [2.x.332]   
* [0.x.197]*
   Return one vector component of the hessian of a shape function at a   quadrature point. If the finite element is scalar, then only component   zero is allowed and the return value equals that of the shape_hessian()   function. If the finite element is vector valued but all shape functions   are primitive (i.e. they are non-zero in only one component), then the   value returned by shape_hessian() equals that of this function for   exactly one component. This function is therefore only of greater   interest if the shape function is not primitive, but then it is necessary   since the other function cannot be used.     The same holds for the arguments of this function as for the   shape_value_component() function.      [2.x.333]   
* [0.x.198]*
   Third derivatives of the <tt>function_no</tt>th shape function at the   <tt>point_no</tt>th quadrature point with respect to real cell   coordinates. If you want to get the 3rd derivatives in one of the   coordinate directions, use the appropriate function of the Tensor class   to extract one component. Since only a reference to the 3rd derivative   values is returned, there should be no major performance drawback.     If the shape function is vector-valued, then this returns the only non-   zero component. If the shape function has more than one non-zero   component (i.e. it is not primitive), then throw an exception of type   ExcShapeFunctionNotPrimitive. In that case, use the   shape_3rdderivative_component() function.     The same holds for the arguments of this function as for the   shape_value() function.      [2.x.334]   
* [0.x.199]*
   Return one vector component of the third derivative of a shape function   at a quadrature point. If the finite element is scalar, then only   component zero is allowed and the return value equals that of the   shape_3rdderivative() function. If the finite element is vector valued   but all shape functions are primitive (i.e. they are non-zero in only one   component), then the value returned by shape_3rdderivative() equals that   of this function for exactly one component. This function is therefore   only of greater interest if the shape function is not primitive, but then   it is necessary since the other function cannot be used.     The same holds for the arguments of this function as for the   shape_value_component() function.      [2.x.335]   
* [0.x.200]*
   Return the values of a finite element function restricted to the current   cell, face or subface selected the last time the <tt>reinit</tt> function   of the derived class was called, at the quadrature points.     If the present cell is not active then values are interpolated to the   current cell and point values are computed from that.     This function may only be used if the finite element in use is a scalar   one, i.e. has only one vector component.  To get values of multi-   component elements, there is another get_function_values() below,   returning a vector of vectors of results.      [2.x.336]  fe_function A vector of values that describes (globally) the   finite element function that this function should evaluate at the   quadrature points of the current cell.      [2.x.337]  values The values of the function specified by fe_function at   the quadrature points of the current cell.  The object is assume to   already have the correct size. The data type stored by this output vector   must be what you get when you multiply the values of shape function times   the type used to store the values of the unknowns  [2.x.338]  of your finite   element vector  [2.x.339]  (represented by the  [2.x.340]  argument). This   happens to be equal to the type of the elements of the solution vector.      [2.x.341]   [2.x.342]  will contain the value of the field   described by fe_function at the  [2.x.343] th quadrature point.    
*  [2.x.344]  The actual data type of the input vector may be either a   Vector&lt;T&gt;, BlockVector&lt;T&gt;, or one of the PETSc or Trilinos   vector wrapper classes. It represents a global vector of DoF values   associated with the DoFHandler object with which this FEValues object was   last initialized.      [2.x.345]   
* [0.x.201]*
   This function does the same as the other get_function_values(), but   applied to multi-component (vector-valued) elements. The meaning of the   arguments is as explained there.      [2.x.346]   [2.x.347]  is a vector of values of the field described   by fe_function at the  [2.x.348] th quadrature point. The size of the vector   accessed by  [2.x.349]  equals the number of components of the   finite element, i.e.  [2.x.350]  returns the value of the    [2.x.351] th vector component at the  [2.x.352] th quadrature point.      [2.x.353]   
* [0.x.202]*
   Generate function values from an arbitrary vector. This function   does in essence the same as the first function of this name above,   except that it does not make the assumption that the input vector   corresponds to a DoFHandler that describes the unknowns of a finite   element field (and for which we would then assume that   `fe_function.size() == dof_handler.n_dofs()`). Rather, the nodal   values corresponding to the current cell are elements of an otherwise   arbitrary vector, and these elements are indexed by the second   argument to this function. What the rest of the `fe_function` input   argument corresponds to is of no consequence to this function.     Given this, the function above corresponds to passing `fe_function`   as first argument to the current function, and using the   `local_dof_indices` array that results from the following call as   second argument to the current function:  
* [1.x.11]
*    (See  [2.x.354]  for more information.)     Likewise, the function above is equivalent to calling  
* [1.x.12]
*    and then calling the current function with `local_dof_values` as   first argument, and an array with indices `{0,...,fe.dofs_per_cell-1}`   as second argument.     The point of the current function is that one sometimes wants to   evaluate finite element functions at quadrature points with nodal   values that are not stored in a global vector
* 
*  -  for example, one could   modify these local values first, such as by applying a limiter   or by ensuring that all nodal values are positive, before evaluating   the finite element field that corresponds to these local values on the   current cell. Another application is where one wants to postprocess   the solution on a cell into a different finite element space on every   cell, without actually creating a corresponding DoFHandler
* 
*  -  in that   case, all one would compute is a local representation of that   postprocessed function, characterized by its nodal values; this function   then allows the evaluation of that representation at quadrature points.      [2.x.355]  fe_function A vector of nodal values. This vector can have     an arbitrary size, as long as all elements index by `indices` can     actually be accessed.      [2.x.356]  indices A vector of indices into `fe_function`. This vector     must have length equal to the number of degrees of freedom on the     current cell, and must identify elements in `fe_function` in the     order in which degrees of freedom are indexed on the reference cell.      [2.x.357]  values A vector of values of the given finite element field,     at the quadrature points on the current object.      [2.x.358]   
* [0.x.203]*
   Generate vector function values from an arbitrary vector.     This function corresponds to the previous one, just for the vector-valued   case.      [2.x.359]   
* [0.x.204]*
   Generate vector function values from an arbitrary vector. This   function is similar to the previous one, but the `indices`   vector may also be a multiple of the number of dofs per   cell. Then, the vectors in <tt>value</tt> should allow for the same   multiple of the components of the finite element.     Depending on the value of the last argument, the outer vector of   <tt>values</tt> has either the length of the quadrature rule   (<tt>quadrature_points_fastest == false</tt>) or the length of components   to be filled <tt>quadrature_points_fastest == true</tt>. If <tt>p</tt> is   the current quadrature point number and <tt>i</tt> is the vector   component of the solution desired, the access to <tt>values</tt> is   <tt>values[p][i]</tt> if <tt>quadrature_points_fastest == false</tt>, and   <tt>values[i][p]</tt> otherwise.     Since this function allows for fairly general combinations of argument   sizes, be aware that the checks on the arguments may not detect errors.      [2.x.360]   
* [0.x.205]*
   Compute the gradients of a finite element at the quadrature points of a   cell. This function is the equivalent of the corresponding   get_function_values() function (see there for more information) but   evaluates the finite element field's gradient instead of its value.     This function may only be used if the finite element in use is a scalar   one, i.e. has only one vector component. There is a corresponding   function of the same name for vector-valued finite elements.      [2.x.361]  fe_function A vector of values that describes (globally) the   finite element function that this function should evaluate at the   quadrature points of the current cell.      [2.x.362]  gradients The gradients of the function specified by   fe_function at the quadrature points of the current cell.  The gradients   are computed in real space (as opposed to on the unit cell).  The object   is assume to already have the correct size. The data type stored by this   output vector must be what you get when you multiply the gradients of   shape function times the type used to store the values of the unknowns    [2.x.363]  of your finite element vector  [2.x.364]  (represented by the  [2.x.365]    fe_function argument).      [2.x.366]   [2.x.367]  will contain the gradient of the field   described by fe_function at the  [2.x.368] th quadrature point.    [2.x.369]  represents the derivative in coordinate   direction  [2.x.370]  at quadrature point  [2.x.371] .    
*  [2.x.372]  The actual data type of the input vector may be either a   Vector&lt;T&gt;, BlockVector&lt;T&gt;, or one of the PETSc or Trilinos   vector wrapper classes. It represents a global vector of DoF values   associated with the DoFHandler object with which this FEValues object was   last initialized.      [2.x.373]   
* [0.x.206]*
   This function does the same as the other get_function_gradients(), but   applied to multi-component (vector-valued) elements. The meaning of the   arguments is as explained there.      [2.x.374]   [2.x.375]  is a vector of gradients of the field   described by fe_function at the  [2.x.376] th quadrature point. The size of the   vector accessed by  [2.x.377]  equals the number of   components of the finite element, i.e.  [2.x.378]    returns the gradient of the  [2.x.379] th vector component at the  [2.x.380] th   quadrature point. Consequently,  [2.x.381]  is the   derivative in coordinate direction  [2.x.382]  of the  [2.x.383] th vector component of   the vector field at quadrature point  [2.x.384]  of the current cell.      [2.x.385]   
* [0.x.207]*
   This function relates to the first of the get_function_gradients() function   above in the same way as the get_function_values() with similar arguments   relates to the first of the get_function_values() functions. See there for   more information.      [2.x.386]   
* [0.x.208]*
   This function relates to the first of the get_function_gradients() function   above in the same way as the get_function_values() with similar arguments   relates to the first of the get_function_values() functions. See there for   more information.      [2.x.387]   
* [0.x.209]*
   Compute the tensor of second derivatives of a finite element at the   quadrature points of a cell. This function is the equivalent of the   corresponding get_function_values() function (see there for more   information) but evaluates the finite element field's second derivatives   instead of its value.     This function may only be used if the finite element in use is a scalar   one, i.e. has only one vector component. There is a corresponding   function of the same name for vector-valued finite elements.      [2.x.388]  fe_function A vector of values that describes (globally) the   finite element function that this function should evaluate at the   quadrature points of the current cell.      [2.x.389]  hessians The Hessians of the function specified by   fe_function at the quadrature points of the current cell.  The Hessians   are computed in real space (as opposed to on the unit cell).  The object   is assume to already have the correct size. The data type stored by this   output vector must be what you get when you multiply the Hessians of   shape function times the type used to store the values of the unknowns    [2.x.390]  of your finite element vector  [2.x.391]  (represented by the  [2.x.392]    fe_function argument).      [2.x.393]   [2.x.394]  will contain the Hessian of the field   described by fe_function at the  [2.x.395] th quadrature point.    [2.x.396]  represents the  [2.x.397] th component of the   matrix of second derivatives at quadrature point  [2.x.398] .    
*  [2.x.399]  The actual data type of the input vector may be either a   Vector&lt;T&gt;, BlockVector&lt;T&gt;, or one of the PETSc or Trilinos   vector wrapper classes. It represents a global vector of DoF values   associated with the DoFHandler object with which this FEValues object was   last initialized.      [2.x.400]   
* [0.x.210]*
   This function does the same as the other get_function_hessians(), but   applied to multi-component (vector-valued) elements. The meaning of the   arguments is as explained there.      [2.x.401]   [2.x.402]  is a vector of Hessians of the field   described by fe_function at the  [2.x.403] th quadrature point. The size of the   vector accessed by  [2.x.404]  equals the number of   components of the finite element, i.e.  [2.x.405]    returns the Hessian of the  [2.x.406] th vector component at the  [2.x.407] th quadrature   point. Consequently,  [2.x.408]  is the  [2.x.409] th   component of the matrix of second derivatives of the  [2.x.410] th vector   component of the vector field at quadrature point  [2.x.411]  of the current   cell.      [2.x.412]   
* [0.x.211]*
   This function relates to the first of the get_function_hessians() function   above in the same way as the get_function_values() with similar arguments   relates to the first of the get_function_values() functions. See there for   more information.      [2.x.413]   
* [0.x.212]*
   This function relates to the first of the get_function_hessians() function   above in the same way as the get_function_values() with similar arguments   relates to the first of the get_function_values() functions. See there for   more information.      [2.x.414]   
* [0.x.213]*
   Compute the (scalar) Laplacian (i.e. the trace of the tensor of second   derivatives) of a finite element at the quadrature points of a cell. This   function is the equivalent of the corresponding get_function_values()   function (see there for more information) but evaluates the finite   element field's second derivatives instead of its value.     This function may only be used if the finite element in use is a scalar   one, i.e. has only one vector component. There is a corresponding   function of the same name for vector-valued finite elements.      [2.x.415]  fe_function A vector of values that describes (globally) the   finite element function that this function should evaluate at the   quadrature points of the current cell.      [2.x.416]  laplacians The Laplacians of the function specified by   fe_function at the quadrature points of the current cell.  The Laplacians   are computed in real space (as opposed to on the unit cell).  The object   is assume to already have the correct size. The data type stored by this   output vector must be what you get when you multiply the Laplacians of   shape function times the type used to store the values of the unknowns    [2.x.417]  of your finite element vector  [2.x.418]  (represented by the  [2.x.419]    fe_function argument). This happens to be equal to the type of the   elements of the input vector.      [2.x.420]   [2.x.421]  will contain the Laplacian of the field   described by fe_function at the  [2.x.422] th quadrature point.      [2.x.423]  For each component of the output vector, there holds    [2.x.424] , where <tt>hessians</tt>   would be the output of the get_function_hessians() function.    
*  [2.x.425]  The actual data type of the input vector may be either a   Vector&lt;T&gt;, BlockVector&lt;T&gt;, or one of the PETSc or Trilinos   vector wrapper classes. It represents a global vector of DoF values   associated with the DoFHandler object with which this FEValues object was   last initialized.      [2.x.426]   
* [0.x.214]*
   This function does the same as the other get_function_laplacians(), but   applied to multi-component (vector-valued) elements. The meaning of the   arguments is as explained there.      [2.x.427]   [2.x.428]  is a vector of Laplacians of the field   described by fe_function at the  [2.x.429] th quadrature point. The size of the   vector accessed by  [2.x.430]  equals the number of   components of the finite element, i.e.  [2.x.431]    returns the Laplacian of the  [2.x.432] th vector component at the  [2.x.433] th   quadrature point.      [2.x.434]  For each component of the output vector, there holds    [2.x.435] , where   <tt>hessians</tt> would be the output of the get_function_hessians()   function.      [2.x.436]   
* [0.x.215]*
   This function relates to the first of the get_function_laplacians()   function above in the same way as the get_function_values() with similar   arguments relates to the first of the get_function_values() functions. See   there for more information.      [2.x.437]   
* [0.x.216]*
   This function relates to the first of the get_function_laplacians()   function above in the same way as the get_function_values() with similar   arguments relates to the first of the get_function_values() functions. See   there for more information.      [2.x.438]   
* [0.x.217]*
   This function relates to the first of the get_function_laplacians()   function above in the same way as the get_function_values() with similar   arguments relates to the first of the get_function_values() functions. See   there for more information.      [2.x.439]   
* [0.x.218]*
   Compute the tensor of third derivatives of a finite element at the   quadrature points of a cell. This function is the equivalent of the   corresponding get_function_values() function (see there for more   information) but evaluates the finite element field's third derivatives   instead of its value.     This function may only be used if the finite element in use is a scalar   one, i.e. has only one vector component. There is a corresponding   function of the same name for vector-valued finite elements.      [2.x.440]  fe_function A vector of values that describes (globally) the   finite element function that this function should evaluate at the   quadrature points of the current cell.      [2.x.441]  third_derivatives The third derivatives of the function   specified by fe_function at the quadrature points of the current cell.   The third derivatives are computed in real space (as opposed to on the   unit cell).  The object is assumed to already have the correct size. The   data type stored by this output vector must be what you get when you   multiply the third derivatives of shape function times the type used to   store the values of the unknowns  [2.x.442]  of your finite element vector  [2.x.443]    (represented by the  [2.x.444]  argument).      [2.x.445]   [2.x.446]  will contain the third   derivatives of the field described by fe_function at the  [2.x.447] th quadrature   point.  [2.x.448]  represents the    [2.x.449] th component of the 3rd order tensor of third derivatives at   quadrature point  [2.x.450] .    
*  [2.x.451]  The actual data type of the input vector may be either a   Vector&lt;T&gt;, BlockVector&lt;T&gt;, or one of the PETSc or Trilinos   vector wrapper classes. It represents a global vector of DoF values   associated with the DoFHandler object with which this FEValues object was   last initialized.      [2.x.452]   
* [0.x.219]*
   This function does the same as the other   get_function_third_derivatives(), but applied to multi-component (vector-   valued) elements. The meaning of the arguments is as explained there.      [2.x.453]   [2.x.454]  is a vector of third derivatives   of the field described by fe_function at the  [2.x.455] th quadrature point. The   size of the vector accessed by  [2.x.456]  equals   the number of components of the finite element, i.e.    [2.x.457]  returns the third derivative of the    [2.x.458] th vector component at the  [2.x.459] th quadrature point. Consequently,    [2.x.460]  is the  [2.x.461] th   component of the tensor of third derivatives of the  [2.x.462] th vector   component of the vector field at quadrature point  [2.x.463]  of the current   cell.      [2.x.464]   
* [0.x.220]*
   This function relates to the first of the get_function_third_derivatives()   function above in the same way as the get_function_values() with similar   arguments relates to the first of the get_function_values() functions. See   there for more information.      [2.x.465]   
* [0.x.221]*
   This function relates to the first of the get_function_third_derivatives()   function above in the same way as the get_function_values() with similar   arguments relates to the first of the get_function_values() functions. See   there for more information.      [2.x.466]   
* [0.x.222]*
   Return an object that can be thought of as an array containing all   indices from zero (inclusive) to `dofs_per_cell` (exclusive). This allows   one to write code using range-based `for` loops of the following kind:  
* [1.x.13]
*    Here, we are looping over all degrees of freedom on all cells, with   `i` and `j` taking on all valid indices for cell degrees of freedom, as   defined by the finite element passed to `fe_values`.  
* [0.x.223]*
   Return an object that can be thought of as an array containing all   indices from  [2.x.467]  (inclusive) to `dofs_per_cell` (exclusive).   This allows one to write code using range-based `for` loops of the   following kind:  
* [1.x.14]
*    Here, we are looping over all local degrees of freedom on all cells, with   `i` taking on all valid indices for cell degrees of freedom, as   defined by the finite element passed to `fe_values`, and `j` taking   on a specified subset of `i`'s range, starting at `i` itself and ending at   the number of cell degrees of freedom. In this way, we can construct the   upper half and the diagonal of a stiffness matrix contribution (assuming it   is symmetric, and that only one half of it needs to be computed), for   example.    
*  [2.x.468]  If the  [2.x.469]  is equal to the number of DoFs in the cell,   then the returned index range is empty.  
* [0.x.224]*
   Return an object that can be thought of as an array containing all   indices from zero (inclusive) to  [2.x.470]  (inclusive). This allows   one to write code using range-based `for` loops of the following kind:  
* [1.x.15]
*    Here, we are looping over all local degrees of freedom on all cells, with   `i` taking on all valid indices for cell degrees of freedom, as   defined by the finite element passed to `fe_values`, and `j` taking   on a specified subset of `i`'s range, starting at zero and ending at   `i` itself. In this way, we can construct the lower half and the   diagonal of a stiffness matrix contribution (assuming it is symmetric, and   that only one half of it needs to be computed), for example.    
*  [2.x.471]  If the  [2.x.472]  is equal to zero, then the returned index   range is empty.  
* [0.x.225]*
   Return an object that can be thought of as an array containing all   indices from zero to `n_quadrature_points`. This allows to write code   using range-based `for` loops of the following kind:  
* [1.x.16]
*    Here, we are looping over all quadrature points on all cells, with   `q_point` taking on all valid indices for quadrature points, as defined   by the quadrature rule passed to `fe_values`.      [2.x.473]  CPP11  
* [0.x.226]*
   Position of the <tt>q</tt>th quadrature point in real space.      [2.x.474]   
* [0.x.227]*
   Return a reference to the vector of quadrature points in real space.      [2.x.475]   
* [0.x.228]*
   Mapped quadrature weight. If this object refers to a volume evaluation   (i.e. the derived class is of type FEValues), then this is the Jacobi   determinant times the weight of the<tt>i</tt>th unit quadrature point.     For surface evaluations (i.e. classes FEFaceValues or FESubfaceValues),   it is the mapped surface element times the weight of the quadrature   point.     You can think of the quantity returned by this function as the volume or   surface element  [2.x.476]  in the integral that we implement here by   quadrature.      [2.x.477]   
* [0.x.229]*
   Return a reference to the array holding the values returned by JxW().  
* [0.x.230]*
   Return the Jacobian of the transformation at the specified quadrature   point, i.e.   [2.x.478]       [2.x.479]   
* [0.x.231]*
   Return a reference to the array holding the values returned by   jacobian().      [2.x.480]   
* [0.x.232]*
   Return the second derivative of the transformation from unit to real   cell, i.e. the first derivative of the Jacobian, at the specified   quadrature point, i.e.  [2.x.481] .      [2.x.482]   
* [0.x.233]*
   Return a reference to the array holding the values returned by   jacobian_grads().      [2.x.483]   
* [0.x.234]*
   Return the second derivative of the transformation from unit to real   cell, i.e. the first derivative of the Jacobian, at the specified   quadrature point, pushed forward to the real cell coordinates, i.e.    [2.x.484] .      [2.x.485]   
* [0.x.235]*
   Return a reference to the array holding the values returned by   jacobian_pushed_forward_grads().      [2.x.486]   
* [0.x.236]*
   Return the third derivative of the transformation from unit to real cell,   i.e. the second derivative of the Jacobian, at the specified quadrature   point, i.e.  [2.x.487] .      [2.x.488]   
* [0.x.237]*
   Return a reference to the array holding the values returned by   jacobian_2nd_derivatives().      [2.x.489]   
* [0.x.238]*
   Return the third derivative of the transformation from unit to real cell,   i.e. the second derivative of the Jacobian, at the specified quadrature   point, pushed forward to the real cell coordinates, i.e.    [2.x.490] .      [2.x.491]   
* [0.x.239]*
   Return a reference to the array holding the values returned by   jacobian_pushed_forward_2nd_derivatives().      [2.x.492]   
* [0.x.240]*
   Return the fourth derivative of the transformation from unit to real   cell, i.e. the third derivative of the Jacobian, at the specified   quadrature point, i.e.  [2.x.493] .      [2.x.494]   
* [0.x.241]*
   Return a reference to the array holding the values returned by   jacobian_3rd_derivatives().      [2.x.495]   
* [0.x.242]*
   Return the fourth derivative of the transformation from unit to real   cell, i.e. the third derivative of the Jacobian, at the specified   quadrature point, pushed forward to the real cell coordinates, i.e.    [2.x.496] .      [2.x.497]   
* [0.x.243]*
   Return a reference to the array holding the values returned by   jacobian_pushed_forward_3rd_derivatives().      [2.x.498]   
* [0.x.244]*
   Return the inverse Jacobian of the transformation at the specified   quadrature point, i.e.   [2.x.499]       [2.x.500]   
* [0.x.245]*
   Return a reference to the array holding the values returned by   inverse_jacobian().      [2.x.501]   
* [0.x.246]*
   Return the normal vector at a quadrature point. If you call this   function for a face (i.e., when using a FEFaceValues or FESubfaceValues   object), then this function returns the outward normal vector to   the cell at the <tt>i</tt>th quadrature point of the face.     In contrast, if you call this function for a cell of codimension one   (i.e., when using a `FEValues<dim,spacedim>` object with   `spacedim>dim`), then this function returns the normal vector to the   cell
* 
*  -  in other words, an approximation to the normal vector to the   manifold in which the triangulation is embedded. There are of   course two normal directions to a manifold in that case, and this   function returns the "up" direction as induced by the numbering of the   vertices.     The length of the vector is normalized to one.      [2.x.502]   
* [0.x.247]*
   Return the normal vectors at all quadrature points represented by   this object. See the normal_vector() function for what the normal   vectors represent.      [2.x.503]   
* [0.x.248]*
   Create a view of the current FEValues object that represents a particular   scalar component of the possibly vector-valued finite element. The   concept of views is explained in the documentation of the namespace   FEValuesViews and in particular in the    [2.x.504]    module.  
* [0.x.249]*
   Create a view of the current FEValues object that represents a set of    [2.x.505]  scalar components (i.e. a vector) of the vector-valued   finite element. The concept of views is explained in the documentation of   the namespace FEValuesViews and in particular in the    [2.x.506]    module.  
* [0.x.250]*
   Create a view of the current FEValues object that represents a set of    [2.x.507]  scalar components (i.e. a symmetric 2nd   order tensor) of the vector-valued finite element. The concept of views   is explained in the documentation of the namespace FEValuesViews and in   particular in the    [2.x.508]    module.  
* [0.x.251]*
   Create a view of the current FEValues object that represents a set of    [2.x.509]  scalar components (i.e. a 2nd order tensor) of the   vector-valued finite element. The concept of views is explained in the   documentation of the namespace FEValuesViews and in particular in the    [2.x.510]    module.  
* [0.x.252]*
   Constant reference to the selected mapping object.  
* [0.x.253]*
   Constant reference to the selected finite element object.  
* [0.x.254]*
   Return the update flags set for this object.  
* [0.x.255]*
   Return a triangulation iterator to the current cell.  
* [0.x.256]*
   Return the relation of the current cell to the previous cell. This allows   re-use of some cell data (like local matrices for equations with constant   coefficients) if the result is  [2.x.511]   
* [0.x.257]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.258]*
   This exception is thrown if FEValuesBase is asked to return the value of   a field which was not required by the UpdateFlags for this FEValuesBase.    
*  [2.x.512]   
* [0.x.259]*
   Mismatch between the FEValues FiniteElement and   cell->get_dof_handler().get_fe()    
*  [2.x.513]   
* [0.x.260]*
   A given shape function is not primitive, but it needs to be.    
*  [2.x.514]   
* [0.x.261]*
   The given FiniteElement is not a primitive element, see    [2.x.515]     
*  [2.x.516]   
* [0.x.262]*
   Objects of the FEValues class need to store an iterator   to the present cell in order to be able to extract the values of the   degrees of freedom on this cell in the get_function_values() and assorted   functions. On the other hand, this class should also work for different   iterators, as long as they have the same interface to extract the DoF   values (i.e., for example, they need to have a  [2.x.517]    get_interpolated_dof_values function).     This calls for a common base class of iterator classes, and making the   functions we need here  [2.x.518]  On the other hand, this is the only   place in the library where we need this, and introducing a base class of   iterators and making a function virtual penalizes  [2.x.519] all [2.x.520]  users of   the iterators, which are basically intended as very fast accessor   functions. So we do not want to do this. Rather, what we do here is   making the functions we need virtual only for use with  [2.x.521] this   class [2.x.522] . The idea is the following: have a common base class which   declares some pure virtual functions, and for each possible iterator   type, we have a derived class which stores the iterator to the cell and   implements these functions. Since the iterator classes have the same   interface, we can make the derived classes a template, templatized on the   iterator type.     This way, the use of virtual functions is restricted to only this class,   and other users of iterators do not have to bear the negative effects.    
*  [2.x.523]  This class is an example of the   [1.x.17] design pattern.  
* [0.x.263]*
   Forward declaration of classes derived from CellIteratorBase. Their   definition and implementation is given in the .cc file.  
* [0.x.264]*
   Store the cell selected last time the reinit() function was called.  This   is necessary for the <tt>get_function_*</tt> functions as well as the   functions of same name in the extractor classes.  
* [0.x.265]*
   A signal connection we use to ensure we get informed whenever the   triangulation changes by refinement. We need to know about that because   it invalidates all cell iterators and, as part of that, the   'present_cell' iterator we keep around between subsequent calls to   reinit() in order to compute the cell similarity.  
* [0.x.266]*
   A signal connection we use to ensure we get informed whenever the   triangulation changes by mesh transformations. We need to know about that   because it invalidates all cell iterators and, as part of that, the   'present_cell' iterator we keep around between subsequent calls to   reinit() in order to compute the cell similarity.  
* [0.x.267]*
   A function that is connected to the triangulation in order to reset the   stored 'present_cell' iterator to an invalid one whenever the   triangulation is changed and the iterator consequently becomes invalid.  
* [0.x.268]*
   This function is called by the various reinit() functions in derived   classes. Given the cell indicated by the argument, test whether we have   to throw away the previously stored present_cell argument because it   would require us to compare cells from different triangulations. In   checking all this, also make sure that we have tria_listener connected to   the triangulation to which we will set present_cell right after calling   this function.  
* [0.x.269]*
   A pointer to the mapping object associated with this FEValues object.  
* [0.x.270]*
   A pointer to the internal data object of mapping, obtained from    [2.x.524]   [2.x.525]  or    [2.x.526]   
* [0.x.271]*
   An object into which the  [2.x.527]  and similar functions   place their output.  
* [0.x.272]*
   A pointer to the finite element object associated with this FEValues   object.  
* [0.x.273]*
   A pointer to the internal data object of finite element, obtained from    [2.x.528]   [2.x.529]  or    [2.x.530]   
* [0.x.274]*
   An object into which the  [2.x.531]  and similar   functions place their output.  
* [0.x.275]*
   Original update flags handed to the constructor of FEValues.  
* [0.x.276]*
   Initialize some update flags. Called from the  [2.x.532]  functions of   derived classes, which are in turn called from their constructors.     Basically, this function finds out using the finite element and mapping   object already stored which flags need to be set to compute everything   the user wants, as expressed through the flags passed as argument.  
* [0.x.277]*
   An enum variable that can store different states of the current cell in   comparison to the previously visited cell. If wanted, additional states   can be checked here and used in one of the methods used during reinit.  
* [0.x.278]*
   A function that checks whether the new cell is similar to the one   previously used. Then, a significant amount of the data can be reused,   e.g. the derivatives of the basis functions in real space, shape_grad.  
* [0.x.279]*
   A cache for all possible FEValuesViews objects.  
* [0.x.280]*
 Finite element evaluated in quadrature points of a cell.
*  This function implements the initialization routines for FEValuesBase, if values in quadrature points of a cell are needed. For further documentation see this class.
* 

* 
*  [2.x.533] 

* 
* [0.x.281]*
   Dimension of the object over which we integrate. For the present class,   this is equal to  [2.x.534] .  
* [0.x.282]*
   Constructor. Gets cell independent data from mapping and finite element   objects, matching the quadrature rule and update flags.  
* [0.x.283]*
   Like the function above, but taking a collection of quadrature rules.    
*  [2.x.535]  We require, in contrast to FEFaceValues, that the number of quadrature     rules in the collection is one.  
* [0.x.284]*
   Constructor. This constructor is equivalent to the other one except that   it makes the object use a  [2.x.536]  mapping (i.e., an object of type   MappingQGeneric(1)) implicitly.  
* [0.x.285]*
   Like the function above, but taking a collection of quadrature rules.    
*  [2.x.537]  We require, in contrast to FEFaceValues, that the number of quadrature     rules in the collection is one.  
* [0.x.286]*
   Reinitialize the gradients, Jacobi determinants, etc for the given cell   of type "iterator into a DoFHandler object", and the finite element   associated with this object. It is assumed that the finite element used   by the given cell is also the one used by this FEValues object.  
* [0.x.287]*
   Reinitialize the gradients, Jacobi determinants, etc for the given cell   of type "iterator into a Triangulation object", and the given finite   element. Since iterators into triangulation alone only convey information   about the geometry of a cell, but not about degrees of freedom possibly   associated with this cell, you will not be able to call some functions of   this class if they need information about degrees of freedom. These   functions are, above all, the   <tt>get_function_value/gradients/hessians/laplacians/third_derivatives</tt>   functions. If you want to call these functions, you have to call the  [2.x.538]    reinit variants that take iterators into DoFHandler or other DoF handler   type objects.  
* [0.x.288]*
   Return a reference to the copy of the quadrature formula stored by this   object.  
* [0.x.289]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.290]*
   Return a reference to this very object.     Though it seems that it is not very useful, this function is there to   provide capability to the  [2.x.539]  class, in which case it provides   the FEValues object for the present cell (remember that for hp-finite   elements, the actual FE object used may change from cell to cell, so we   also need different FEValues objects for different cells; once you   reinitialize the  [2.x.540]  object for a specific cell, it retrieves   the FEValues object for the FE on that cell and returns it through a   function of the same name as this one; this function here therefore only   provides the same interface so that one can templatize on FEValues and    [2.x.541]   
* [0.x.291]*
   Store a copy of the quadrature formula here.  
* [0.x.292]*
   Do work common to the two constructors.  
* [0.x.293]*
   The reinit() functions do only that part of the work that requires   knowledge of the type of iterator. After setting present_cell(), they   pass on to this function, which does the real work, and which is   independent of the actual type of the cell iterator.  
* [0.x.294]*
 Extend the interface of FEValuesBase to values that only make sense when evaluating something on the surface of a cell. All the data that is available in the interior of cells is also available here.
*  See FEValuesBase
* 

* 
*  [2.x.542] 

* 
* [0.x.295]*
   Dimension of the object over which we integrate. For the present class,   this is equal to  [2.x.543] .  
* [0.x.296]*
   Constructor. Call the constructor of the base class and set up the arrays   of this class with the right sizes.  Actually filling these arrays is a   duty of the derived class's constructors.      [2.x.544]  is the number of faces or subfaces that this   object is to store. The actual number depends on the derived class, for   FEFaceValues it is <tt>2*dim</tt>, while for the FESubfaceValues class it   is <tt>2*dim*(1<<(dim-1))</tt>, i.e. the number of faces times the number   of subfaces per face.  
* [0.x.297]*
   Like the function above, but taking a collection of quadrature rules. This   allows to assign each face a different quadrature rule. In the case that   the collection only contains a single face quadrature, this quadrature   rule is use on all faces.  
* [0.x.298]*
   Boundary form of the transformation of the cell at the <tt>i</tt>th   quadrature point.  See    [2.x.545] .      [2.x.546]   
* [0.x.299]*
   Return the list of outward normal vectors times the Jacobian of the   surface mapping.      [2.x.547]   
* [0.x.300]*
   Return the index of the face selected the last time the reinit() function   was called.  
* [0.x.301]*
   Return a reference to the copy of the quadrature formula stored by this   object.  
* [0.x.302]*
   Determine an estimate for the memory consumption (in bytes) of this   object.  
* [0.x.303]*
   Number of the face selected the last time the reinit() function was   called.  
* [0.x.304]*
   Index of the face selected the last time the reinit() function was   called.  
* [0.x.305]*
   Store a copy of the quadrature formula here.  
* [0.x.306]*
 Finite element evaluated in quadrature points on a face.
*  This class adds the functionality of FEFaceValuesBase to FEValues; see there for more documentation.
*  Since finite element functions and their derivatives may be discontinuous at cell boundaries, there is no restriction of this function to a mesh face. But, there are limits of these values approaching the face from either of the neighboring cells.
* 

* 
*  [2.x.548] 

* 
* [0.x.307]*
   Dimension in which this object operates.  
* [0.x.308]*
   Dimension of the object over which we integrate. For the present class,   this is equal to  [2.x.549] .  
* [0.x.309]*
   Constructor. Gets cell independent data from mapping and finite element   objects, matching the quadrature rule and update flags.  
* [0.x.310]*
   Like the function above, but taking a collection of quadrature rules. This   allows to assign each face a different quadrature rule. In the case that   the collection only contains a single face quadrature, this quadrature   rule is use on all faces.  
* [0.x.311]*
   Constructor. This constructor is equivalent to the other one except that   it makes the object use a  [2.x.550]  mapping (i.e., an object of type   MappingQGeneric(1)) implicitly.  
* [0.x.312]*
   Like the function above, but taking a collection of quadrature rules. This   allows to assign each face a different quadrature rule. In the case that   the collection only contains a single face quadrature, this quadrature   rule is use on all faces.  
* [0.x.313]*
   Reinitialize the gradients, Jacobi determinants, etc for the face with   number  [2.x.551]  of  [2.x.552]  and the given finite element.  
* [0.x.314]*
   Reinitialize the gradients, Jacobi determinants, etc for face  [2.x.553]    and cell  [2.x.554]     
*  [2.x.555]   [2.x.556]  must be one of  [2.x.557]  face iterators.  
* [0.x.315]*
   Reinitialize the gradients, Jacobi determinants, etc for the given face   on a given cell of type "iterator into a Triangulation object", and the   given finite element. Since iterators into a triangulation alone only   convey information about the geometry of a cell, but not about degrees of   freedom possibly associated with this cell, you will not be able to call   some functions of this class if they need information about degrees of   freedom. These functions are, above all, the   <tt>get_function_value/gradients/hessians/third_derivatives</tt>   functions. If you want to call these functions, you have to call the  [2.x.558]    reinit variants that take iterators into DoFHandler or other DoF handler   type objects.  
* [0.x.316]   Reinitialize the gradients, Jacobi determinants, etc for the given face   on a given cell of type "iterator into a Triangulation object", and the   given finite element. Since iterators into a triangulation alone only   convey information about the geometry of a cell, but not about degrees of   freedom possibly associated with this cell, you will not be able to call   some functions of this class if they need information about degrees of   freedom. These functions are, above all, the   <tt>get_function_value/gradients/hessians/third_derivatives</tt>   functions. If you want to call these functions, you have to call the  [2.x.559]    reinit variants that take iterators into DoFHandler or other DoF handler   type objects.    
*  [2.x.560]   [2.x.561]  must be one of  [2.x.562]  face iterators.  
* [0.x.317]*
   Return a reference to this very object.     Though it seems that it is not very useful, this function is there to   provide capability to the  [2.x.563]  class, in which case it provides   the FEValues object for the present cell (remember that for hp-finite   elements, the actual FE object used may change from cell to cell, so we   also need different FEValues objects for different cells; once you   reinitialize the  [2.x.564]  object for a specific cell, it retrieves   the FEValues object for the FE on that cell and returns it through a   function of the same name as this one; this function here therefore only   provides the same interface so that one can templatize on FEValues and    [2.x.565]   
* [0.x.318]*
   Do work common to the two constructors.  
* [0.x.319]*
   The reinit() functions do only that part of the work that requires   knowledge of the type of iterator. After setting present_cell(), they   pass on to this function, which does the real work, and which is   independent of the actual type of the cell iterator.  
* [0.x.320]*
 Finite element evaluated in quadrature points on a face.
*  This class adds the functionality of FEFaceValuesBase to FEValues; see there for more documentation.
*  This class is used for faces lying on a refinement edge. In this case, the neighboring cell is refined. To be able to compute differences between interior and exterior function values, the refinement of the neighboring cell must be simulated on this cell. This is achieved by applying a quadrature rule that simulates the refinement. The resulting data fields are split up to reflect the refinement structure of the neighbor: a subface number corresponds to the number of the child of the neighboring face.
* 

* 
*  [2.x.566] 

* 
* [0.x.321]*
   Dimension in which this object operates.  
* [0.x.322]*
   Dimension of the space in which this object operates.  
* [0.x.323]*
   Dimension of the object over which we integrate. For the present class,   this is equal to  [2.x.567] .  
* [0.x.324]*
   Constructor. Gets cell independent data from mapping and finite element   objects, matching the quadrature rule and update flags.  
* [0.x.325]*
   Like the function above, but taking a collection of quadrature rules.    
*  [2.x.568]  We require, in contrast to FEFaceValues, that the number of quadrature     rules in the collection is one.  
* [0.x.326]*
   Constructor. This constructor is equivalent to the other one except that   it makes the object use a  [2.x.569]  mapping (i.e., an object of type   MappingQGeneric(1)) implicitly.  
* [0.x.327]*
   Like the function above, but taking a collection of quadrature rules.    
*  [2.x.570]  We require, in contrast to FEFaceValues, that the number of quadrature     rules in the collection is one.  
* [0.x.328]*
   Reinitialize the gradients, Jacobi determinants, etc for the given cell   of type "iterator into a DoFHandler object", and the finite element   associated with this object. It is assumed that the finite element used   by the given cell is also the one used by this FESubfaceValues object.  
* [0.x.329]*
   Alternative reinitialization function that takes, as arguments, iterators   to the face and subface instead of their numbers.  
* [0.x.330]*
   Reinitialize the gradients, Jacobi determinants, etc for the given   subface on a given cell of type "iterator into a Triangulation object", and   the given finite element. Since iterators into a triangulation alone only   convey information about the geometry of a cell, but not about degrees of   freedom possibly associated with this cell, you will not be able to call   some functions of this class if they need information about degrees of   freedom. These functions are, above all, the   <tt>get_function_value/gradients/hessians/third_derivatives</tt>   functions. If you want to call these functions, you have to call the  [2.x.571]    reinit variants that take iterators into DoFHandler or other DoF handler   type objects.  
* [0.x.331]*
   Reinitialize the gradients, Jacobi determinants, etc for the given   subface on a given cell of type "iterator into a Triangulation object", and   the given finite element. Since iterators into a triangulation alone only   convey information about the geometry of a cell, but not about degrees of   freedom possibly associated with this cell, you will not be able to call   some functions of this class if they need information about degrees of   freedom. These functions are, above all, the   <tt>get_function_value/gradients/hessians/third_derivatives</tt>   functions. If you want to call these functions, you have to call the  [2.x.572]    reinit variants that take iterators into DoFHandler or other DoF handler   type objects.     This does the same thing as the previous function but takes iterators   instead of numbers as arguments.    
*  [2.x.573]   [2.x.574]  and  [2.x.575]  must correspond to a face (and a subface of   that face) of  [2.x.576]   
* [0.x.332]*
   Return a reference to this very object.     Though it seems that it is not very useful, this function is there to   provide capability to the  [2.x.577]  class, in which case it provides   the FEValues object for the present cell (remember that for hp-finite   elements, the actual FE object used may change from cell to cell, so we   also need different FEValues objects for different cells; once you   reinitialize the  [2.x.578]  object for a specific cell, it retrieves   the FEValues object for the FE on that cell and returns it through a   function of the same name as this one; this function here therefore only   provides the same interface so that one can templatize on FEValues and    [2.x.579]   
* [0.x.333]*
    [2.x.580]  Document this    
*  [2.x.581]   
* [0.x.334]*
    [2.x.582]  Document this    
*  [2.x.583]   
* [0.x.335]*
   Do work common to the two constructors.  
* [0.x.336]*
   The reinit() functions do only that part of the work that requires   knowledge of the type of iterator. After setting present_cell(), they   pass on to this function, which does the real work, and which is   independent of the actual type of the cell iterator.  
* [0.x.337]*
     Return the symmetrized version of a tensor whose n'th row equals the     second argument, with all other rows equal to zero.    
* [0.x.338]

include/deal.II-translator/fe/fe_values_extractors_0.txt
[0.x.0]*
 A namespace in which we declare "extractors", i.e. classes that when used as subscripts in operator[] expressions on FEValues, FEFaceValues, and FESubfaceValues objects extract certain components of a vector-valued element. The result of applying an extractor to these objects is an object with corresponding type from the namespace FEValuesViews. There are extractors for single scalar components, vector components consisting of  [2.x.0]  elements, and second order symmetric tensors consisting of  [2.x.1]  components, as well as second order nonsymmetric tensors.
*  One can think of extractors as the equivalent of an index, or an index range. In the case of scalar extractors (i.e., the  [2.x.2]  class), creating an object like (see  [2.x.3]  for this use)

* 
* [1.x.0]
*  can be thought of as creating a single index with value `dim`. By itself, an index does not know what it is an index to, so it takes the equivalent of an array to extract anything. Consequently, assume that there is a finite element with at least `dim+1` vector components (as indeed there is in  [2.x.4] ), and an FEValues object that operates on it, then writing

* 
* [1.x.1]
*  results in an object that represents the shape functions of only the `dim`th component of the overall element. In the example, these would be the values of the pressure shape functions, or more precisely: the (scalar) pressure values of all shape functions (even for shape functions that are not associated with the pressure, but for example the velocity). In the example above, the result of using `operator[]` on the `fe_values` object as shown is of type  [2.x.5] 
*  Likewise, when using

* 
* [1.x.2]
*  then the object so created can be thought of as an [1.x.3], starting at zero and extending exactly `dim` components on. In Matlab notation, one could write this as `0:dim-1`. Then, writing

* 
* [1.x.4]
*  will result in an object that represents the values of a subset of exactly `dim` vector components of the overall finite element, in much the same way as writing `array(3:7)` in Matlab would return an array of length 5 that has been extracted from the original array by looking at indices 3 through 7 (inclusive).
*  See the description of the  [2.x.6]  module for examples how to use the features of this namespace.
* 

* 
*  [2.x.7] 

* 
* [0.x.1]*
   Extractor for a single scalar component of a vector-valued element. The   result of applying an object of this type to an FEValues, FEFaceValues or   FESubfaceValues object is of type  [2.x.8]  The concept of   extractors is defined in the documentation of the namespace   FEValuesExtractors and in the    [2.x.9]    module.    
*  [2.x.10]   
* [0.x.2]*
     The selected scalar component of the vector.    
* [0.x.3]*
     Default constructor. Initialize the object with an invalid component.     This leads to an object that can not be used, but it allows objects of     this kind to be put into arrays that require a default constructor upon     resizing the array, and then later assigning a suitable object to each     element of the array.    
* [0.x.4]*
     Constructor. Take the selected vector component as argument.    
* [0.x.5]*
     Return a string that uniquely identifies this finite element extractor.    
* [0.x.6]*
   Extractor for a vector of  [2.x.11]  components of a vector-   valued element. The value of  [2.x.12]  is defined by the   FEValues object the extractor is applied to. The result of applying an   object of this type to an FEValues, FEFaceValues or FESubfaceValues   object is of type  [2.x.13]      The concept of extractors is defined in the documentation of the   namespace FEValuesExtractors and in the    [2.x.14]    module.     Note that in the current context, a vector is meant in the sense physics   uses it: it has  [2.x.15]  components that behave in specific   ways under coordinate system transformations. Examples include velocity   or displacement fields. This is opposed to how mathematics uses the word   "vector" (and how we use this word in other contexts in the library, for   example in the Vector class), where it really stands for a collection of   numbers. An example of this latter use of the word could be the set of   concentrations of chemical species in a flame; however, these are really   just a collection of scalar variables, since they do not change if the   coordinate system is rotated, unlike the components of a velocity vector,   and consequently, this class should not be used for this context.    
*  [2.x.16]   
* [0.x.7]*
     The first component of the vector view.    
* [0.x.8]*
     Default constructor. Initialize the object with an invalid component.     This leads to an object that can not be used, but it allows objects of     this kind to be put into arrays that require a default constructor upon     resizing the array, and then later assigning a suitable object to each     element of the array.    
* [0.x.9]*
     Constructor. Take the first component of the selected vector inside the     FEValues object as argument.    
* [0.x.10]*
     Return a string that uniquely identifies this finite element extractor.    
* [0.x.11]*
   Extractor for a symmetric tensor of a rank specified by the template   argument. For a second order symmetric tensor, this represents a   collection of  [2.x.17]  components of a vector-   valued element. The value of  [2.x.18]  is defined by the FEValues   object the extractor is applied to. The result of applying an object of   this type to an FEValues, FEFaceValues or FESubfaceValues object is of   type  [2.x.19]      The concept of extractors is defined in the documentation of the   namespace FEValuesExtractors and in the    [2.x.20]    module.    
*  [2.x.21]   
* [0.x.12]*
     The first component of the tensor view.    
* [0.x.13]*
     Default constructor. Initialize the object with an invalid component.     This leads to an object that can not be used, but it allows objects of     this kind to be put into arrays that require a default constructor upon     resizing the array, and then later assigning a suitable object to each     element of the array.    
* [0.x.14]*
     Constructor. Take the first component of the selected tensor inside the     FEValues object as argument.    
* [0.x.15]*
     Return a string that uniquely identifies this finite element extractor.    
* [0.x.16]*
   Extractor for a general tensor of a given rank specified by   the template argument. For a second order tensor, this represents a   collection of  [2.x.22]  components of a vector-valued   element. The value of  [2.x.23]  is defined by the FEValues object   the extractor is applied to. The result of applying an object of this   type to an FEValues, FEFaceValues or FESubfaceValues object is of type    [2.x.24]      The concept of extractors is defined in the documentation of the   namespace FEValuesExtractors and in the    [2.x.25]    module.    
*  [2.x.26]   
* [0.x.17]*
     The first component of the tensor view.    
* [0.x.18]*
     Default constructor. Initialize the object with an invalid component.     This leads to an object that can not be used, but it allows objects of     this kind to be put into arrays that require a default constructor upon     resizing the array, and then later assigning a suitable object to each     element of the array.    
* [0.x.19]*
     Constructor. Take the first component of the selected tensor inside the     FEValues object as argument.    
* [0.x.20]*
     Return a string that uniquely identifies this finite element extractor.    
* [0.x.21]

include/deal.II-translator/fe/fe_wedge_p_0.txt
[0.x.0]*
 Base class of FE_WedgeP and FE_WedgeDGP.
* 

* 
*  [2.x.0]  Only implemented for 3D.
* 

* 
*  [2.x.1] 

* 
* [0.x.1]*
   Constructor.  
* [0.x.2]*
 Implementation of a scalar Lagrange finite element on a wedge that yields the finite element space of continuous, piecewise polynomials of degree  [2.x.2] .
* 

* 
*  [2.x.3] 

* 
* [0.x.3]*
   Constructor.  
* [0.x.4]*
    [2.x.4]   [2.x.5]   
* [0.x.5]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_WedgeP<dim>(degree)</tt>, with  [2.x.6]  and  [2.x.7]    replaced by appropriate values.  
* [0.x.6]*
    [2.x.8]   [2.x.9]   
* [0.x.7]*
    [2.x.10]   [2.x.11]   
* [0.x.8]*
    [2.x.12]   [2.x.13]   
* [0.x.9]*
    [2.x.14]   [2.x.15]   
* [0.x.10]*
 Implementation of a scalar Lagrange finite element on a wedge that yields the finite element space of discontinuous, piecewise polynomials of degree  [2.x.16] .
* 

* 
*  [2.x.17] 

* 
* [0.x.11]*
   Constructor.  
* [0.x.12]*
    [2.x.18]   [2.x.19]   
* [0.x.13]*
   Return a string that uniquely identifies a finite element. This class   returns <tt>FE_WedgeDGP<dim>(degree)</tt>, with  [2.x.20]  and  [2.x.21]    replaced by appropriate values.  
* [0.x.14]

include/deal.II-translator/fe/mapping_0.txt
[0.x.0]*
 The transformation kind used for the  [2.x.0]  functions.
*  Special finite elements may need special Mapping from the reference cell to the actual mesh cell. In order to be most flexible, this enum provides an extensible interface for arbitrary transformations. Nevertheless, these must be implemented in the transform() functions of inheriting classes in order to work.
* 

* 
*  [2.x.1] 

* 
* [0.x.1]*
   No mapping, i.e., shape functions are not mapped from a reference cell   but instead are defined right on the real-space cell.  
* [0.x.2]*
   Covariant mapping (see  [2.x.2]  for details).  
* [0.x.3]*
   Contravariant mapping (see  [2.x.3]  for details).  
* [0.x.4]*
   Mapping of the gradient of a covariant vector field (see    [2.x.4]  for details).  
* [0.x.5]*
   Mapping of the gradient of a contravariant vector field (see    [2.x.5]  for details).  
* [0.x.6]*
   The Piola transform usually used for Hdiv elements. Piola transform is   the standard transformation of vector valued elements in H<sup>div</sup>.   It amounts to a contravariant transformation scaled by the inverse of the   volume element.  
* [0.x.7]*
   Transformation for the gradient of a vector field corresponding to a   mapping_piola transformation (see  [2.x.6]  for details).  
* [0.x.8]*
   The mapping used for Nedelec elements.     Curl-conforming elements are mapped as covariant vectors. Nevertheless,   we introduce a separate mapping kind, such that we can use the same flag   for the vector and its gradient (see  [2.x.7]  for details).  
* [0.x.9]*
   The mapping used for Raviart-Thomas elements.  
* [0.x.10]*
   The mapping used for BDM elements.  
* [0.x.11]*
   The mappings for 2-forms and third order tensors.     These are mappings typpically applied to hessians transformed to the   reference cell.     Mapping of the hessian of a covariant vector field (see    [2.x.8]  for details).  
* [0.x.12]*
   Mapping of the hessian of a contravariant vector field (see    [2.x.9]  for details).  
* [0.x.13]*
   Mapping of the hessian of a piola vector field (see  [2.x.10]    for details).  
* [0.x.14]*
  [2.x.11]  Abstract base class for mapping classes.
*  This class declares the interface for the functionality to describe mappings from the reference (unit) cell to a cell in real space, as well as for filling the information necessary to use the FEValues, FEFaceValues, and FESubfaceValues classes. Concrete implementations of these interfaces are provided in derived classes.
*  [1.x.0]
*  The mapping is a transformation  [2.x.12]  which maps points  [2.x.13]  in the reference cell  [2.x.14]  to points  [2.x.15]  in the actual grid cell  [2.x.16] . Many of the applications of such mappings require the Jacobian of this mapping,  [2.x.17] . For instance, if dim=spacedim=2, we have [1.x.1]
*  [1.x.2]
*  The shape functions of scalar finite elements are typically defined on a reference cell and are then simply mapped according to the rule [1.x.3]
* 

*  [1.x.4]
*  Using simply a change of variables, integrals of scalar functions over a cell  [2.x.18]  can be expressed as an integral over the reference cell  [2.x.19] . Specifically, The volume form  [2.x.20]  is transformed so that [1.x.5]
*  In expressions where such integrals are approximated by quadrature, this then leads to terms of the form [1.x.6] Here, the weights  [2.x.21]  of each quadrature point (where [1.x.7] mnemonically stands for [1.x.8]) take the role of the  [2.x.22]  in the original integral. Consequently, they appear in all code that computes integrals approximated by quadrature, and are accessed by  [2.x.23] 
*   [2.x.24]  Document what happens in the codimension-1 case.
* 

*  [1.x.9]
*  The transformation of vector fields or differential forms (gradients of scalar functions)  [2.x.25] , and gradients of vector fields  [2.x.26]  follows the general form
*  [1.x.10] The differential forms [1.x.11] and [1.x.12] are determined by the kind of object being transformed. These transformations are performed through the transform() functions, and the type of object being transformed is specified by their MappingKind argument. See the documentation there for possible choices.
*  [1.x.13]
*  Some applications require the derivatives of the mapping, of which the first order derivative is the mapping Jacobian,  [2.x.27] , described above. Higher order derivatives of the mapping are similarly defined, for example the Jacobian derivative,  [2.x.28] , and the Jacobian second derivative,  [2.x.29] . It is also useful to define the "pushed-forward" versions of the higher order derivatives: the Jacobian pushed-forward derivative,  [2.x.30] , and the Jacobian pushed-forward second derivative,  [2.x.31] . These pushed-forward versions can be used to compute the higher order derivatives of functions defined on the reference cell with respect to the real cell coordinates. For instance, the Jacobian derivative with respect to the real cell coordinates is given by:
*  [1.x.14] and the derivative of the Jacobian inverse with respect to the real cell coordinates is similarly given by: [1.x.15]
*  In a similar fashion, higher order derivatives, with respect to the real cell coordinates, of functions defined on the reference cell can be defined using the Jacobian pushed-forward higher-order derivatives. For example, the derivative, with respect to the real cell coordinates, of the Jacobian pushed-forward derivative is given by:
*  [1.x.16]
*  [1.x.17]
*  A general publication on differential geometry and finite elements is the survey  [2.x.32]   [2.x.33] Douglas N. Arnold, Richard S. Falk, and Ragnar Winther. [1.x.18] Bull. Amer. Math. Soc. (N.S.), 47:281-354, 2010. [1.x.19].  [2.x.34] 
*  The description of the Piola transform has been taken from the [1.x.20] by Ronald H. W. Hoppe, University of Houston, Chapter 7.
* 

* 
*  [2.x.35] 

* 
* [0.x.15]*
   Virtual destructor.  
* [0.x.16]*
   Return a pointer to a copy of the present object. The caller of this copy   then assumes ownership of it.     The function is declared abstract virtual in this base class, and derived   classes will have to implement it.     This function is mainly used by the  [2.x.36]  class.  
* [0.x.17]*
   Return the mapped vertices of a cell.     Most of the time, these values will simply be the coordinates of the   vertices of a cell as returned by  [2.x.37]  for   vertex  [2.x.38] , i.e., information stored by the triangulation.   However, there are also mappings that add displacements or choose   completely different locations, e.g., MappingQEulerian,   MappingQ1Eulerian, or MappingFEField.     The default implementation of this function simply returns the   information stored by the triangulation, i.e.,    [2.x.39] .  
* [0.x.18]*
   Return the mapped center of a cell.     If you are using a (bi-,tri-)linear mapping that preserves vertex   locations, this function simply returns the value also produced by   `cell->center()`. However, there are also mappings that add displacements   or choose completely different locations, e.g., MappingQEulerian,   MappingQ1Eulerian, or MappingFEField, and mappings based on high order   polynomials, for which the center may not coincide with the average of   the vertex locations.     By default, this function returns the push forward of the center of the   reference cell. If the parameter    [2.x.40]  is set to false, than the return value   will be the average of the vertex locations, as returned by the   get_vertices() method.      [2.x.41]  cell The cell for which you want to compute the center    [2.x.42]  map_center_of_reference_cell A flag that switches the algorithm   for the computation of the cell center from   transform_unit_to_real_cell() applied to the center of the reference cell   to computing the vertex averages.  
* [0.x.19]*
   Return the bounding box of a mapped cell.     If you are using a (bi-,tri-)linear mapping that preserves vertex   locations, this function simply returns the value also produced by   `cell->bounding_box()`. However, there are also mappings that add   displacements or choose completely different locations, e.g.,   MappingQEulerian, MappingQ1Eulerian, or MappingFEField.     For linear mappings, this function returns the bounding box containing all   the vertices of the cell, as returned by the get_vertices() method. For   higher order mappings defined through support points, the bounding box is   only guaranteed to contain all the support points, and it is, in general,   only an approximation of the true bounding box, which may be larger.      [2.x.43]  cell The cell for which you want to compute the bounding box  
* [0.x.20]*
   Return whether the mapping preserves vertex locations. In other words,   this function returns whether the mapped location of the reference cell   vertices (given by  [2.x.44]  equals the result of    [2.x.45]  (i.e., information stored by the   triangulation).     For example, implementations in derived classes return  [2.x.46]  for   MappingQ, MappingQGeneric, MappingCartesian, but  [2.x.47]  for   MappingQEulerian, MappingQ1Eulerian, and MappingFEField.  
* [0.x.21]*
   Returns if this instance of Mapping is compatible with the type of cell   in  [2.x.48]   
* [0.x.22]*
    [2.x.49]  Mapping points between reference and real cells    [2.x.50]   
* [0.x.23]*
   Map the point  [2.x.51]  on the unit cell to the corresponding point on the   real cell  [2.x.52]       [2.x.53]  cell Iterator to the cell that will be used to define the mapping.    [2.x.54]  p Location of a point on the reference cell.    [2.x.55]  The location of the reference point mapped to real space using   the mapping defined by the class derived from the current one that   implements the mapping, and the coordinates of the cell identified by the   first argument.  
* [0.x.24]*
   Map the point  [2.x.56]  on the real  [2.x.57]  to the corresponding point on the   unit cell, and return its coordinates. This function provides the inverse   of the mapping provided by transform_unit_to_real_cell().     In the codimension one case, this function returns the normal projection   of the real point  [2.x.58]  on the curve or surface identified by the  [2.x.59]     
*  [2.x.60]  Polynomial mappings from the reference (unit) cell coordinates to   the coordinate system of a real cell are not always invertible if the   point for which the inverse mapping is to be computed lies outside the   cell's boundaries. In such cases, the current function may fail to   compute a point on the reference cell whose image under the mapping   equals the given point  [2.x.61]   If this is the case then this function   throws an exception of type  [2.x.62]  . Whether   the given point  [2.x.63]  lies outside the cell can therefore be determined by   checking whether the returned reference coordinates lie inside or outside   the reference cell (e.g., using  [2.x.64]  or   whether the exception mentioned above has been thrown.      [2.x.65]  cell Iterator to the cell that will be used to define the mapping.    [2.x.66]  p Location of a point on the given cell.    [2.x.67]  The reference cell location of the point that when mapped to real   space equals the coordinates given by the second argument. This mapping   uses the mapping defined by the class derived from the current one that   implements the mapping, and the coordinates of the cell identified by the   first argument.  
* [0.x.25]*
   Map multiple points from the real point locations to points in reference   locations. The functionality is essentially the same as looping over all   points and calling the  [2.x.68]  function   for each point individually, but it can be much faster for certain   mappings that implement a more specialized version such as   MappingQGeneric. The only difference in behavior is that this function   will never throw an ExcTransformationFailed() exception. If the   transformation fails for `real_points[i]`, the returned `unit_points[i]`   contains  [2.x.69]  as the first entry.  
* [0.x.26]*
   Transform the point  [2.x.70]  on the real  [2.x.71]  to the corresponding point   on the reference cell, and then project this point to a (dim-1)-dimensional   point in the coordinate system of the face with   the given face number  [2.x.72]  Ideally the point  [2.x.73]  is near the face    [2.x.74]  but any point in the cell can technically be projected.     This function does not make physical sense when dim=1, so it throws an   exception in this case.  
* [0.x.27]*
    [2.x.75]   
* [0.x.28]*
    [2.x.76]  Exceptions    [2.x.77]   
* [0.x.29]*
   Exception  
* [0.x.30]*
   Computing the mapping between a real space point and a point in reference   space failed, typically because the given point lies outside the cell   where the inverse mapping is not unique.    
*  [2.x.78]   
* [0.x.31]*
   deal.II assumes the Jacobian determinant to be positive. When the cell   geometry is distorted under the image of the mapping, the mapping becomes   invalid and this exception is thrown.    
*  [2.x.79]   
* [0.x.32]*
    [2.x.80]   
* [0.x.33]*
    [2.x.81]  Interface with FEValues    [2.x.82]   
* [0.x.34]*
   Base class for internal data of mapping objects. The internal mechanism   is that upon construction of a FEValues object, it asks the mapping and   finite element classes that are to be used to allocate memory for their   own purpose in which they may store data that only needs to be computed   once. For example, most finite elements will store the values of the   shape functions at the quadrature points in this object, since they do   not change from cell to cell and only need to be computed once. The same   may be true for Mapping classes that want to only evaluate the shape   functions used for mapping once at the quadrature points.     Since different FEValues objects using different quadrature rules might   access the same mapping object at the same time, it is necessary to   create one such object per FEValues object. FEValues does this by calling    [2.x.83]  or in reality the implementation of the   corresponding function in derived classes. Ownership of the object   created by  [2.x.84]  is then transferred to the FEValues   object, but a reference to this object is passed to the mapping object   every time it is asked to compute information on a concrete cell. This   happens when  [2.x.85]  (or the corresponding classes in   FEFaceValues and FESubfaceValues) call  [2.x.86]  (and   similarly via  [2.x.87]  and    [2.x.88]      The purpose of this class is for mapping objects to store information   that can be computed once at the beginning, on the reference cell, and to   access it later when computing information on a concrete cell. As such,   the object handed to  [2.x.89]  is marked as    [2.x.90] , because the assumption is that at the time this   information is used, it will not need to modified again. However, classes   derived from Mapping can also use such objects for two other purposes:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - To provide scratch space for computations that are done in    [2.x.91]  and similar functions. Some of the derived   classes would like to use scratch arrays and it would be a waste of time   to allocate these arrays every time this function is called, just to de-   allocate it again at the end of the function. Rather, one could allocate   this memory once as a member variable of the current class, and simply   use it in  [2.x.92] 
* 

* 
* 

* 
* 

* 
* 
*  - After calling  [2.x.93]   [2.x.94]    calls  [2.x.95]  where the finite element computes   values, gradients, etc of the shape functions using both information   computed once at the beginning using a mechanism similar to the one   described here (see  [2.x.96]  as well as the data   already computed by  [2.x.97]  As part of its work, some   implementations of  [2.x.98]  need to transform   shape function data, and they do so by calling  [2.x.99]  The   call to the latter function also receives a reference to the    [2.x.100]  object. Since  [2.x.101]  may be   called many times on each cell, it is sometimes worth for derived classes   to compute some information only once in  [2.x.102]  and   reuse it in  [2.x.103]  This information can also be stored in   the classes that derived mapping classes derive from InternalDataBase.     In both of these cases, the InternalDataBase object being passed around   is "morally const", i.e., no external observer can tell whether a scratch   array or some intermediate data for  [2.x.104]  is being   modified by  [2.x.105]  or not. Consequently, the   InternalDataBase objects are always passed around as  [2.x.106]    objects. Derived classes that would like to make use of the two   additional uses outlined above therefore need to mark the member   variables they want to use for these purposes as  [2.x.107]  to   allow for their modification despite the fact that the surrounding object   is marked as  [2.x.108] .  
* [0.x.35]*
     Constructor. Sets update_flags to  [2.x.109]  and  [2.x.110]      to  [2.x.111]     
* [0.x.36]*
     Copy construction is forbidden.    
* [0.x.37]*
     Virtual destructor for derived classes    
* [0.x.38]*
     A set of update flags specifying the kind of information that an     implementation of the Mapping interface needs to compute on each cell     or face, i.e., in  [2.x.112]  and friends.         This set of flags is stored here by implementations of      [2.x.113]   [2.x.114]  or      [2.x.115]  and is that subset of the update flags     passed to those functions that require re-computation on every cell.     (The subset of the flags corresponding to information that can be     computed once and for all already at the time of the call to      [2.x.116] 
* 
*  -  or an implementation of that interface
* 
*  -  need     not be stored here because it has already been taken care of.)    
* [0.x.39]*
     Return an estimate (in bytes) for the memory consumption of this object.    
* [0.x.40]*
   Given a set of update flags, compute which other quantities [1.x.21]   need to be computed in order to satisfy the request by the given flags.   Then return the combination of the original set of flags and those just   computed.     As an example, if  [2.x.117]  contains update_JxW_values (i.e., the   product of the determinant of the Jacobian and the weights provided by   the quadrature formula), a mapping may require the computation of the   full Jacobian matrix in order to compute its determinant. They would then   return not just update_JxW_values, but also update_jacobians. (This is   not how it is actually done internally in the derived classes that   compute the JxW values
* 
*  -  they set update_contravariant_transformation   instead, from which the determinant can also be computed
* 
*  -  but this does   not take away from the instructiveness of the example.)     An extensive discussion of the interaction between this function and   FEValues can be found in the    [2.x.118]    documentation module.      [2.x.119]  UpdateFlags  
* [0.x.41]*
   Create and return a pointer to an object into which mappings can store   data that only needs to be computed once but that can then be used   whenever the mapping is applied to a concrete cell (e.g., in the various   transform() functions, as well as in the fill_fe_values(),   fill_fe_face_values() and fill_fe_subface_values() that form the   interface of mappings with the FEValues class).     Derived classes will return pointers to objects of a type derived from    [2.x.120]  (see there for more information) and may pre-   compute some information already (in accordance with what will be asked   of the mapping in the future, as specified by the update flags) and for   the given quadrature object. Subsequent calls to transform() or   fill_fe_values() and friends will then receive back the object created   here (with the same set of update flags and for the same quadrature   object). Derived classes can therefore pre-compute some information in   their get_data() function and store it in the internal data object.     The mapping classes do not keep track of the objects created by this   function. Ownership will therefore rest with the caller.     An extensive discussion of the interaction between this function and   FEValues can be found in the    [2.x.121]    documentation module.      [2.x.122]  update_flags A set of flags that define what is expected of the   mapping class in future calls to transform() or the fill_fe_values()   group of functions. This set of flags may contain flags that mappings do   not know how to deal with (e.g., for information that is in fact computed   by the finite element classes, such as  [2.x.123]    Derived classes will need to store these flags, or at least that subset   of flags that will require the mapping to perform any actions in   fill_fe_values(), in  [2.x.124]     [2.x.125]  quadrature The quadrature object for which mapping information   will have to be computed. This includes the locations and weights of   quadrature points.    [2.x.126]  A pointer to a newly created object of type InternalDataBase (or   a derived class). Ownership of this object passes to the calling   function.    
*  [2.x.127]  C++ allows that virtual functions in derived classes may return   pointers to objects not of type InternalDataBase but in fact pointers to   objects of classes [1.x.22] from InternalDataBase. (This feature is   called "covariant return types".) This is useful in some contexts where   the calling is within the derived class and will immediately make use of   the returned object, knowing its real (derived) type.  
* [0.x.42]*
   Like get_data(), but in preparation for later calls to transform() or   fill_fe_face_values() that will need information about mappings from the   reference face to a face of a concrete cell.      [2.x.128]  update_flags A set of flags that define what is expected of the   mapping class in future calls to transform() or the fill_fe_values()   group of functions. This set of flags may contain flags that mappings do   not know how to deal with (e.g., for information that is in fact computed   by the finite element classes, such as  [2.x.129]    Derived classes will need to store these flags, or at least that subset   of flags that will require the mapping to perform any actions in   fill_fe_values(), in  [2.x.130]     [2.x.131]  quadrature The quadrature object for which mapping information   will have to be computed. This includes the locations and weights of   quadrature points.    [2.x.132]  A pointer to a newly created object of type InternalDataBase (or   a derived class). Ownership of this object passes to the calling   function.    
*  [2.x.133]  C++ allows that virtual functions in derived classes may return   pointers to objects not of type InternalDataBase but in fact pointers to   objects of classes [1.x.23] from InternalDataBase. (This feature is   called "covariant return types".) This is useful in some contexts where   the calling is within the derived class and will immediately make use of   the returned object, knowing its real (derived) type.  
* [0.x.43]*
    [2.x.134]  Use the version taking a  [2.x.135]  argument.  
* [0.x.44]*
   Like get_data() and get_face_data(), but in preparation for later calls   to transform() or fill_fe_subface_values() that will need information   about mappings from the reference face to a child of a face (i.e.,   subface) of a concrete cell.      [2.x.136]  update_flags A set of flags that define what is expected of the   mapping class in future calls to transform() or the fill_fe_values()   group of functions. This set of flags may contain flags that mappings do   not know how to deal with (e.g., for information that is in fact computed   by the finite element classes, such as  [2.x.137]    Derived classes will need to store these flags, or at least that subset   of flags that will require the mapping to perform any actions in   fill_fe_values(), in  [2.x.138]     [2.x.139]  quadrature The quadrature object for which mapping information   will have to be computed. This includes the locations and weights of   quadrature points.    [2.x.140]  A pointer to a newly created object of type InternalDataBase (or   a derived class). Ownership of this object passes to the calling   function.    
*  [2.x.141]  C++ allows that virtual functions in derived classes may return   pointers to objects not of type InternalDataBase but in fact pointers to   objects of classes [1.x.24] from InternalDataBase. (This feature is   called "covariant return types".) This is useful in some contexts where   the calling is within the derived class and will immediately make use of   the returned object, knowing its real (derived) type.  
* [0.x.45]*
   Compute information about the mapping from the reference cell to the real   cell indicated by the first argument to this function. Derived classes   will have to implement this function based on the kind of mapping they   represent. It is called by  [2.x.142]      Conceptually, this function's represents the application of the mapping    [2.x.143]  from reference coordinates    [2.x.144]  to real space coordinates  [2.x.145]  for a given   cell  [2.x.146] . Its purpose is to compute the following kinds of data:
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 

* 
* 
*  - Data that results from the application of the mapping itself, e.g.,   computing the location  [2.x.147]  of   quadrature points on the real cell, and that is directly useful to users   of FEValues, for example during assembly.
* 

* 
* 

* 
* 

* 
* 
*  - Data that is necessary for finite element implementations to compute   their shape functions on the real cell. To this end, the    [2.x.148]  function calls  [2.x.149]  after   the current function, and the output of this function serves as input to    [2.x.150]  Examples of information that needs to be   computed here for use by the finite element classes is the Jacobian of   the mapping,  [2.x.151]  or its inverse,   for example to transform the gradients of shape functions on the   reference cell to the gradients of shape functions on the real cell.     The information computed by this function is used to fill the various   member variables of the output argument of this function. Which of the   member variables of that structure should be filled is determined by the   update flags stored in the  [2.x.152]  object passed to   this function.     An extensive discussion of the interaction between this function and   FEValues can be found in the    [2.x.153]    documentation module.      [2.x.154]  cell The cell of the triangulation for which this function is   to compute a mapping from the reference cell to.    [2.x.155]  cell_similarity Whether or not the cell given as first   argument is simply a translation, rotation, etc of the cell for which   this function was called the most recent time. This information is   computed simply by matching the vertices (as stored by the Triangulation)   between the previous and the current cell. The value passed here may be   modified by implementations of this function and should then be returned   (see the discussion of the return value of this function).    [2.x.156]  quadrature A reference to the quadrature formula in use for   the current evaluation. This quadrature object is the same as the one   used when creating the  [2.x.157]  object. The object is used both   to map the location of quadrature points, as well as to compute the JxW   values for each quadrature point (which involves the quadrature weights).    [2.x.158]  internal_data A reference to an object previously created by   get_data() and that may be used to store information the mapping can   compute once on the reference cell. See the documentation of the    [2.x.159]  class for an extensive description of the   purpose of these objects.    [2.x.160]  output_data A reference to an object whose member variables   should be computed. Not all of the members of this argument need to be   filled; which ones need to be filled is determined by the update flags   stored inside the  [2.x.161]  object.    [2.x.162]  An updated value of the  [2.x.163]  argument to this   function. The returned value will be used for the corresponding argument   when  [2.x.164]  calls  [2.x.165]  In most   cases, derived classes will simply want to return the value passed for  [2.x.166]    cell_similarity. However, implementations of this function may downgrade   the level of cell similarity. This is, for example, the case for classes   that take not only into account the locations of the vertices of a cell   (as reported by the Triangulation), but also other information specific   to the mapping. The purpose is that  [2.x.167]  can compute   whether a cell is similar to the previous one only based on the cell's   vertices, whereas the mapping may also consider displacement fields   (e.g., in the MappingQ1Eulerian and MappingFEField classes). In such   cases, the mapping may conclude that the previously computed cell   similarity is too optimistic, and invalidate it for subsequent use in    [2.x.168]  by returning a less optimistic cell   similarity value.    
*  [2.x.169]  FEValues ensures that this function is always called with the same   pair of  [2.x.170]  and  [2.x.171]  objects. In other words, if   an implementation of this function knows that it has written a piece of   data into the output argument in a previous call, then there is no need   to copy it there again in a later call if the implementation knows that   this is the same value.  
* [0.x.46]*
   This function is the equivalent to  [2.x.172]  but for   faces of cells. See there for an extensive discussion of its purpose. It   is called by  [2.x.173]       [2.x.174]  cell The cell of the triangulation for which this function is   to compute a mapping from the reference cell to.    [2.x.175]  face_no The number of the face of the given cell for which   information is requested.    [2.x.176]  quadrature A reference to the quadrature formula in use for   the current evaluation. This quadrature object is the same as the one   used when creating the  [2.x.177]  object. The object is used both   to map the location of quadrature points, as well as to compute the JxW   values for each quadrature point (which involves the quadrature weights).    [2.x.178]  internal_data A reference to an object previously created by   get_data() and that may be used to store information the mapping can   compute once on the reference cell. See the documentation of the    [2.x.179]  class for an extensive description of the   purpose of these objects.    [2.x.180]  output_data A reference to an object whose member variables   should be computed. Not all of the members of this argument need to be   filled; which ones need to be filled is determined by the update flags   stored inside the  [2.x.181]  object.  
* [0.x.47]*
    [2.x.182]  Use the version taking a  [2.x.183]  argument.  
* [0.x.48]*
   This function is the equivalent to  [2.x.184]  but for   subfaces (i.e., children of faces) of cells. See there for an extensive   discussion of its purpose. It is called by  [2.x.185]       [2.x.186]  cell The cell of the triangulation for which this function is   to compute a mapping from the reference cell to.    [2.x.187]  face_no The number of the face of the given cell for which   information is requested.    [2.x.188]  subface_no The number of the child of a face of the given cell   for which information is requested.    [2.x.189]  quadrature A reference to the quadrature formula in use for   the current evaluation. This quadrature object is the same as the one   used when creating the  [2.x.190]  object. The object is used both   to map the location of quadrature points, as well as to compute the JxW   values for each quadrature point (which involves the quadrature weights).    [2.x.191]  internal_data A reference to an object previously created by   get_data() and that may be used to store information the mapping can   compute once on the reference cell. See the documentation of the    [2.x.192]  class for an extensive description of the   purpose of these objects.    [2.x.193]  output_data A reference to an object whose member variables   should be computed. Not all of the members of this argument need to be   filled; which ones need to be filled is determined by the update flags   stored inside the  [2.x.194]  object.  
* [0.x.49]*
    [2.x.195]   
* [0.x.50]*
    [2.x.196]  Functions to transform tensors from reference to real coordinates    [2.x.197]   
* [0.x.51]*
   Transform a field of vectors or 1-differential forms according to the   selected MappingKind.    
*  [2.x.198]  Normally, this function is called by a finite element, filling   FEValues objects. For this finite element, there should be an alias   MappingKind like  [2.x.199]   [2.x.200]  etc. This alias   should be preferred to using the kinds below.     The mapping kinds currently implemented by derived classes are:    [2.x.201]     [2.x.202]   [2.x.203]  maps a vector field on the reference cell   to the physical cell through the Jacobian:   [1.x.25]   In physics, this is usually referred to as the contravariant   transformation. Mathematically, it is the push forward of a vector field.      [2.x.204]   [2.x.205]  maps a field of one-forms on the reference   cell to a field of one-forms on the physical cell. (Theoretically this   would refer to a DerivativeForm<1,dim,1> but we canonically identify this   type with a Tensor<1,dim>). Mathematically, it is the pull back of the   differential form   [1.x.26]   Gradients of scalar differentiable functions are transformed this way.     In the case when dim=spacedim the previous formula reduces to   [1.x.27]   because we assume that the mapping  [2.x.206]  is always invertible,   and consequently its Jacobian  [2.x.207]  is an invertible matrix.      [2.x.208]   [2.x.209]  A field of [1.x.28]-forms on the reference   cell is also represented by a vector field, but again transforms   differently, namely by the Piola transform   [1.x.29]    [2.x.210]       [2.x.211]  input An array (or part of an array) of input objects that   should be mapped.    [2.x.212]  kind The kind of mapping to be applied.    [2.x.213]  internal A pointer to an object of type    [2.x.214]  that contains information previously stored by   the mapping. The object pointed to was created by the get_data(),   get_face_data(), or get_subface_data() function, and will have been   updated as part of a call to fill_fe_values(), fill_fe_face_values(), or   fill_fe_subface_values() for the current cell, before calling the current   function. In other words, this object also represents with respect to   which cell the transformation should be applied to.    [2.x.215]  output An array (or part of an array) into which the   transformed objects should be placed. (Note that the array view is  [2.x.216]    const, but the tensors it points to are not.)  
* [0.x.52]*
   Transform a field of differential forms from the reference cell to the   physical cell.  It is useful to think of  [2.x.217]    and  [2.x.218] , with  [2.x.219]  a   vector field.  The mapping kinds currently implemented by derived classes   are:    [2.x.220]     [2.x.221]   [2.x.222]  maps a field of forms on the reference cell to   a field of forms on the physical cell. Mathematically, it is the pull   back of the differential form   [1.x.30]   Jacobians of spacedim-vector valued differentiable functions are   transformed this way.     In the case when dim=spacedim the previous formula reduces to   [1.x.31]    [2.x.223]     
*  [2.x.224]  It would have been more reasonable to make this transform a   template function with the rank in <code>DerivativeForm [2.x.225]  dim,   rank [2.x.226]  Unfortunately C++ does not allow templatized virtual   functions. This is why we identify <code>DerivativeForm [2.x.227]  dim,   1 [2.x.228]  with a  [2.x.229]  when using   mapping_covariant() in the function transform() above this one.      [2.x.230]  input An array (or part of an array) of input objects that   should be mapped.    [2.x.231]  kind The kind of mapping to be applied.    [2.x.232]  internal A pointer to an object of type    [2.x.233]  that contains information previously stored by   the mapping. The object pointed to was created by the get_data(),   get_face_data(), or get_subface_data() function, and will have been   updated as part of a call to fill_fe_values(), fill_fe_face_values(), or   fill_fe_subface_values() for the current cell, before calling the current   function. In other words, this object also represents with respect to   which cell the transformation should be applied to.    [2.x.234]  output An array (or part of an array) into which the   transformed objects should be placed. (Note that the array view is  [2.x.235]    const, but the tensors it points to are not.)  
* [0.x.53]*
   Transform a tensor field from the reference cell to the physical cell.   These tensors are usually the Jacobians in the reference cell of vector   fields that have been pulled back from the physical cell.  The mapping   kinds currently implemented by derived classes are:    [2.x.236]     [2.x.237]   [2.x.238]  it assumes  [2.x.239]  so that   [1.x.32]    [2.x.240]   [2.x.241]  it assumes  [2.x.242]  so that   [1.x.33]    [2.x.243]   [2.x.244]  it assumes  [2.x.245]  so that   [1.x.34]    [2.x.246]       [2.x.247]  The formulas for mapping_covariant_gradient,   mapping_contravariant_gradient and mapping_piola_gradient are only true   as stated for linear mappings. If, for example, the mapping is bilinear   (or has a higher order polynomial degree) then there is a missing term   associated with the derivative of  [2.x.248] .      [2.x.249]  input An array (or part of an array) of input objects that   should be mapped.    [2.x.250]  kind The kind of mapping to be applied.    [2.x.251]  internal A pointer to an object of type    [2.x.252]  that contains information previously stored by   the mapping. The object pointed to was created by the get_data(),   get_face_data(), or get_subface_data() function, and will have been   updated as part of a call to fill_fe_values(), fill_fe_face_values(), or   fill_fe_subface_values() for the current cell, before calling the current   function. In other words, this object also represents with respect to   which cell the transformation should be applied to.    [2.x.253]  output An array (or part of an array) into which the   transformed objects should be placed. (Note that the array view is  [2.x.254]    const, but the tensors it points to are not.)  
* [0.x.54]*
   Transform a tensor field from the reference cell to the physical cell.   This tensors are most of times the hessians in the reference cell of   vector fields that have been pulled back from the physical cell.     The mapping kinds currently implemented by derived classes are:    [2.x.255]     [2.x.256]   [2.x.257]  maps a field of forms on the   reference cell to a field of forms on the physical cell. Mathematically,   it is the pull back of the differential form   [1.x.35],     where [1.x.36]    [2.x.258]      Hessians of spacedim-vector valued differentiable functions are   transformed this way (After subtraction of the product of the derivative   with the Jacobian gradient).     In the case when dim=spacedim the previous formula reduces to   [1.x.37]      [2.x.259]  input An array (or part of an array) of input objects that   should be mapped.    [2.x.260]  kind The kind of mapping to be applied.    [2.x.261]  internal A pointer to an object of type    [2.x.262]  that contains information previously stored by   the mapping. The object pointed to was created by the get_data(),   get_face_data(), or get_subface_data() function, and will have been   updated as part of a call to fill_fe_values(), fill_fe_face_values(), or   fill_fe_subface_values() for the current cell, before calling the current   function. In other words, this object also represents with respect to   which cell the transformation should be applied to.    [2.x.263]  output An array (or part of an array) into which the   transformed objects should be placed. (Note that the array view is  [2.x.264]    const, but the tensors it points to are not.)  
* [0.x.55]*
   Transform a field of 3-differential forms from the reference cell to the   physical cell.  It is useful to think of  [2.x.265]  and  [2.x.266] , with  [2.x.267]  a vector field.     The mapping kinds currently implemented by derived classes are:    [2.x.268]     [2.x.269]   [2.x.270]  it assumes  [2.x.271]  so that   [1.x.38]    [2.x.272]   [2.x.273]  it assumes  [2.x.274]  so that   [1.x.39]    [2.x.275]   [2.x.276]  it assumes  [2.x.277]  so that   [1.x.40]    [2.x.278]       [2.x.279]  input An array (or part of an array) of input objects that   should be mapped.    [2.x.280]  kind The kind of mapping to be applied.    [2.x.281]  internal A pointer to an object of type    [2.x.282]  that contains information previously stored by   the mapping. The object pointed to was created by the get_data(),   get_face_data(), or get_subface_data() function, and will have been   updated as part of a call to fill_fe_values(), fill_fe_face_values(), or   fill_fe_subface_values() for the current cell, before calling the current   function. In other words, this object also represents with respect to   which cell the transformation should be applied to.    [2.x.283]  output An array (or part of an array) into which the   transformed objects should be placed.  
* [0.x.56]*
    [2.x.284]   
* [0.x.57]*
 Return a default linear mapping that works for the given triangulation. Internally, this function calls the function above for the reference cell used by the given triangulation, assuming that the triangulation uses only a single cell type. If the triangulation uses mixed cell types, then this function will trigger an exception.

* 
* [0.x.58]

include/deal.II-translator/fe/mapping_c1_0.txt
[0.x.0]*
 Mapping class that uses C1 (continuously differentiable) cubic mappings of the boundary. This class is built atop of MappingQ by simply determining the interpolation points for a cubic mapping of the boundary differently: MappingQ chooses them such that they interpolate the boundary, while this class chooses them such that the discretized boundary is globally continuously differentiable.

* 
* [0.x.1]*
   Constructor. Pass the fixed degree  [2.x.0]  down to the base class, as a   cubic mapping suffices to generate a continuous mapping of the boundary.  
* [0.x.2]*
   Return a pointer to a copy of the present object. The caller of this copy   then assumes ownership of it.  
* [0.x.3]*
   A class derived from MappingQGeneric that provides the generic mapping   with support points on boundary objects so that the corresponding Q3   mapping ends up being C1.  
* [0.x.4]*
     Constructor.    
* [0.x.5]*
     For <tt>dim=2,3</tt>. Append the support points of all shape functions     located on bounding lines to the vector  [2.x.1]  Points located on the     line but on vertices are not included.         This function chooses the respective points not such that they are     interpolating the boundary (as does the base class), but rather such     that the resulting cubic mapping is a continuous one.    
* [0.x.6]*
     For <tt>dim=3</tt>. Append the support points of all shape functions     located on bounding faces (quads in 3d) to the vector  [2.x.2]  Points     located on the line but on vertices are not included.         This function chooses the respective points not such that they are     interpolating the boundary (as does the base class), but rather such     that the resulting cubic mapping is a continuous one.    
* [0.x.7]

include/deal.II-translator/fe/mapping_cartesian_0.txt
[0.x.0]*
 A class providing a mapping from the reference cell to cells that are axiparallel, i.e., that have the shape of rectangles (in 2d) or boxes (in 3d) with edges parallel to the coordinate directions. The class therefore provides functionality that is equivalent to what, for example, MappingQ would provide for such cells. However, knowledge of the shape of cells allows this class to be substantially more efficient.
*  Specifically, the mapping is meant for cells for which the mapping from the reference to the real cell is a scaling along the coordinate directions: The transformation from reference coordinates  [2.x.0]  to real coordinates  [2.x.1]  on each cell is of the form

* 
* [1.x.0]
*  in 2d, and

* 
* [1.x.1]
*  in 3d, where  [2.x.2]  is the bottom left vertex and  [2.x.3]  are the extents of the cell along the axes.
*  The class is intended for efficiency, and it does not do a whole lot of error checking. If you apply this mapping to a cell that does not conform to the requirements above, you will get strange results.

* 
* [0.x.1]*
   Return  [2.x.4]  because MappingCartesian preserves vertex   locations.  
* [0.x.2]*
    [2.x.5]  Mapping points between reference and real cells    [2.x.6]   
* [0.x.3]*
    [2.x.7]   
* [0.x.4]*
    [2.x.8]  Functions to transform tensors from reference to real coordinates    [2.x.9]   
* [0.x.5]*
    [2.x.10]   
* [0.x.6]*
    [2.x.11]  Interface with FEValues    [2.x.12]   
* [0.x.7]*
   Storage for internal data of the mapping. See  [2.x.13]    for an extensive description.     This includes data that is computed once when the object is created (in   get_data()) as well as data the class wants to store from between the   call to fill_fe_values(), fill_fe_face_values(), or   fill_fe_subface_values() until possible later calls from the finite   element to functions such as transform(). The latter class of member   variables are marked as 'mutable'.  
* [0.x.8]*
     Constructor.    
* [0.x.9]*
     Return an estimate (in bytes) for the memory consumption of this object.    
* [0.x.10]*
     Extents of the last cell we have seen in the coordinate directions,     i.e., [1.x.2], [1.x.3], [1.x.4].    
* [0.x.11]*
     The volume element    
* [0.x.12]*
     Vector of all quadrature points. Especially, all points on all faces.    
* [0.x.13]*
    [2.x.14]   
* [0.x.14]*
   Update the cell_extents field of the incoming InternalData object with the   size of the incoming cell.  
* [0.x.15]*
   Compute the quadrature points if the UpdateFlags of the incoming   InternalData object say that they should be updated.     Called from fill_fe_values.  
* [0.x.16]*
   Compute the quadrature points if the UpdateFlags of the incoming   InternalData object say that they should be updated.     Called from fill_fe_face_values.  
* [0.x.17]*
   Compute the quadrature points if the UpdateFlags of the incoming   InternalData object say that they should be updated.     Called from fill_fe_subface_values.  
* [0.x.18]*
   Transform quadrature points in InternalData to real space by scaling unit   coordinates with cell_extends in each direction.     Called from the various maybe_update_*_quadrature_points functions.  
* [0.x.19]*
   Compute the normal vectors if the UpdateFlags of the incoming InternalData   object say that they should be updated.  
* [0.x.20]*
   Since the Jacobian is constant for this mapping all derivatives of the   Jacobian are identically zero. Fill these quantities with zeros if the   corresponding update flags say that they should be updated.  
* [0.x.21]

include/deal.II-translator/fe/mapping_fe_0.txt
[0.x.0]*
 This class consistently uses a user-provided finite element on all cells of a triangulation to implement a polynomial mapping.
*  If one initializes this class with the same FiniteElement as the discretization, one obtains an iso-parametric mapping.
*  If one initializes this class with an FE_Q(degree) object, then this class is equivalent to MappingQGeneric(degree). Please note that no optimizations exploiting tensor-product structures of finite elements have been added here.
* 

* 
*  [2.x.0]  Currently, only implemented for elements with tensor_degree==1 and   n_components==1.
* 

* 
*  [2.x.1] 

* 
* [0.x.1]*
   Constructor.  
* [0.x.2]*
   Copy constructor.  
* [0.x.3]*
   Return the degree of the mapping, i.e., the degree of the finite element   which was passed to the constructor.  
* [0.x.4]*
   Always returns  [2.x.2]  because the default implementation of functions in   this class preserves vertex locations.  
* [0.x.5]*
    [2.x.3]  Mapping points between reference and real cells    [2.x.4]   
* [0.x.6]*
    [2.x.5]   
* [0.x.7]*
    [2.x.6]  Functions to transform tensors from reference to real coordinates    [2.x.7]   
* [0.x.8]*
    [2.x.8]   
* [0.x.9]*
    [2.x.9]  Interface with FEValues    [2.x.10]   
* [0.x.10]*
   Storage for internal data of polynomial mappings. See    [2.x.11]  for an extensive description.     For the current class, the InternalData class stores data that is   computed once when the object is created (in get_data()) as well as data   the class wants to store from between the call to fill_fe_values(),   fill_fe_face_values(), or fill_fe_subface_values() until possible later   calls from the finite element to functions such as transform(). The   latter class of member variables are marked as 'mutable'.  
* [0.x.11]*
     Constructor.    
* [0.x.12]*
     Initialize the object's member variables related to cell data based on     the given arguments.         The function also calls compute_shape_function_values() to actually set     the member variables related to the values and derivatives of the     mapping shape functions.    
* [0.x.13]*
     Initialize the object's member variables related to cell and face data     based on the given arguments. In order to initialize cell data, this     function calls initialize().    
* [0.x.14]*
     Compute the values and/or derivatives of the shape functions used for     the mapping.    
* [0.x.15]*
     Shape function at quadrature point. Shape functions are in tensor     product order, so vertices must be reordered to obtain transformation.    
* [0.x.16]*
     Shape function at quadrature point. See above.    
* [0.x.17]*
     Gradient of shape function in quadrature point. See above.    
* [0.x.18]*
     Gradient of shape function in quadrature point. See above.    
* [0.x.19]*
     Second derivative of shape function in quadrature point. See above.    
* [0.x.20]*
     Second derivative of shape function in quadrature point. See above.    
* [0.x.21]*
     third derivative of shape function in quadrature point. See above.    
* [0.x.22]*
     third derivative of shape function in quadrature point. See above.    
* [0.x.23]*
     fourth derivative of shape function in quadrature point. See above.    
* [0.x.24]*
     fourth derivative of shape function in quadrature point. See above.    
* [0.x.25]*
     Return an estimate (in bytes) for the memory consumption of this object.    
* [0.x.26]*
     Values of shape functions. Access by function  [2.x.12]          Computed once.    
* [0.x.27]*
     Values of shape function derivatives. Access by function  [2.x.13]          Computed once.    
* [0.x.28]*
     Values of shape function second derivatives. Access by function  [2.x.14]      second_derivative.         Computed once.    
* [0.x.29]*
     Values of shape function third derivatives. Access by function  [2.x.15]      second_derivative.         Computed once.    
* [0.x.30]*
     Values of shape function fourth derivatives. Access by function  [2.x.16]      second_derivative.         Computed once.    
* [0.x.31]*
     Unit tangential vectors. Used for the computation of boundary forms and     normal vectors.         Filled once.    
* [0.x.32]*
     Underlying finite element.    
* [0.x.33]*
     The polynomial degree of the mapping.    
* [0.x.34]*
     Number of shape functions.    
* [0.x.35]*
     Tensors of covariant transformation at each of the quadrature points.     The matrix stored is the Jacobian G^{-1}, where G = Jacobian^{t}     Jacobian, is the first fundamental form of the map; if dim=spacedim     then it reduces to the transpose of the inverse of the Jacobian matrix,     which itself is stored in the  [2.x.17]  field of this structure.         Computed on each cell.    
* [0.x.36]*
     Tensors of contravariant transformation at each of the quadrature     points. The contravariant matrix is the Jacobian of the transformation,     i.e.  [2.x.18] .         Computed on each cell.    
* [0.x.37]*
     Auxiliary vectors for internal use.    
* [0.x.38]*
     Stores the support points of the mapping shape functions on the  [2.x.19]      cell_of_current_support_points.    
* [0.x.39]*
     Stores the cell of which the  [2.x.20]  are stored.    
* [0.x.40]*
     The determinant of the Jacobian in each quadrature point. Filled if     #update_volume_elements.    
* [0.x.41]*
     Projected quadrature weights.    
* [0.x.42]*
    [2.x.21]   
* [0.x.43]*
   The degree of the polynomials used as shape functions for the mapping of   cells.  
* [0.x.44]*
   Return the locations of support points for the mapping.  
* [0.x.45]

include/deal.II-translator/fe/mapping_fe_field_0.txt
[0.x.0]*
  [2.x.0]  Use MappingFEField<dim, spacedim, VectorType> instead.

* 
* [0.x.1]*
 The MappingFEField is a generalization of the MappingQEulerian class, for arbitrary vector finite elements. The two main differences are that this class uses a vector of absolute positions instead of a vector of displacements, and it allows for arbitrary FiniteElement types, instead of only FE_Q.
*  This class effectively decouples the topology from the geometry, by relegating all geometrical information to some components of a FiniteElement vector field. The components that are used for the geometry can be arbitrarily selected at construction time.
*  The idea is to consider the Triangulation as a parameter configuration space, on which we construct an arbitrary geometrical mapping, using the instruments of the deal.II library: a vector of degrees of freedom, a DoFHandler associated to the geometry of the problem and a ComponentMask that tells us which components of the FiniteElement to use for the mapping.
*  Typically, the DoFHandler operates on a finite element that is constructed as a system element (FESystem()) from continuous FE_Q() (for iso-parametric discretizations) or FE_Bernstein() (for iso-geometric discretizations) objects. An example is shown below:
* 

* 
* [1.x.0]
* 

* 
* [0.x.2]*
   Constructor. The first argument is a VectorType that specifies the   transformation of the domain from the reference to the current   configuration.     In general this class decouples geometry from topology, allowing users to   define geometries which are only topologically equivalent to the   underlying Triangulation, but which may otherwise be arbitrary.   Differently from what happens in MappingQEulerian, the FiniteElement   field which is passed to the constructor is interpreted as an absolute   geometrical configuration, therefore one has to make sure that the   euler_vector actually represents a valid geometry (i.e., one with no   inverted cells, or with no zero-volume cells).     If the underlying FiniteElement is a system of FE_Q(), and euler_vector   is initialized using  [2.x.1]  then this class   is in all respects identical to MappingQ().     The optional ComponentMask argument can be used to specify what   components of the FiniteElement to use for the geometrical   transformation. If no mask is specified at construction time, then a   default one is used, which makes this class works in the same way of   MappingQEulerian(), i.e., the first spacedim components of the   FiniteElement are assumed to represent the geometry of the problem.     Notice that if a mask is specified, it has to match in size the   underlying FiniteElement, and it has to have exactly spacedim non-zero   elements, indicating the components (in order) of the FiniteElement which   will be used for the geometry.     If an incompatible mask is passed, an exception is thrown.  
* [0.x.3]*
   Constructor taking vectors on the multigrid levels rather than the active   cells only. The vector of vectors is expected to have as many entries as   there are global levels in the triangulation and provide valid data on   each level, i.e., be of compatible length  [2.x.2]  A   prerequisite of this constructor is that  [2.x.3]    has been called. Apart from the level vectors, the same arguments as in   the other constructor need to be provided.  
* [0.x.4]*
   Constructor with MGLevelObject instead of  [2.x.4]  otherwise the same   as above. It is required that `euler_vector.max_level()+1` equals the   global number of levels in the triangulation. The minimum level may be   zero or more &mdash; it only needs to be consistent between what is set   here and later used for evaluation of the mapping.  
* [0.x.5]*
   Copy constructor.  
* [0.x.6]*
   Return a pointer to a copy of the present object. The caller of this copy   then assumes ownership of it.  
* [0.x.7]*
   See the documentation of  [2.x.5]    for the purpose of this function. The implementation in this   class always returns  [2.x.6]   
* [0.x.8]*
   Return the mapped vertices of a cell.     This mapping ignores the vertices of the Triangulation it is associated to,   and constructs the position of the vertices according to the  [2.x.7]    that was passed at construction time.  
* [0.x.9]*
    [2.x.8]  Mapping points between reference and real cells    [2.x.9]   
* [0.x.10]*
    [2.x.10]   
* [0.x.11]*
    [2.x.11]  Functions to transform tensors from reference to real coordinates    [2.x.12]   
* [0.x.12]*
    [2.x.13]   
* [0.x.13]*
   Return the degree of the mapping, i.e. the value which was passed to the   constructor.  
* [0.x.14]*
   Return the ComponentMask of the mapping, i.e. which components to use for   the mapping.  
* [0.x.15]*
   Exception  
* [0.x.16]*
    [2.x.14]  Interface with FEValues    [2.x.15]   
* [0.x.17]*
   Storage for internal data of this mapping. See  [2.x.16]    for an extensive description.     This includes data that is computed once when the object is created (in   get_data()) as well as data the class wants to store from between the   call to fill_fe_values(), fill_fe_face_values(), or   fill_fe_subface_values() until possible later calls from the finite   element to functions such as transform(). The latter class of member   variables are marked as 'mutable', along with scratch arrays.  
* [0.x.18]*
     Constructor.    
* [0.x.19]*
     Shape function at quadrature point. Shape functions are in tensor     product order, so vertices must be reordered to obtain transformation.    
* [0.x.20]*
     Shape function at quadrature point. See above.    
* [0.x.21]*
     Gradient of shape function in quadrature point. See above.    
* [0.x.22]*
     Gradient of shape function in quadrature point. See above.    
* [0.x.23]*
     Second derivative of shape function in quadrature point. See above.    
* [0.x.24]*
     Second derivative of shape function in quadrature point. See above.    
* [0.x.25]*
     Third derivative of shape function in quadrature point. See above.    
* [0.x.26]*
     Fourth derivative of shape function in quadrature point. See above.    
* [0.x.27]*
     Fourth derivative of shape function in quadrature point. See above.    
* [0.x.28]*
     Third derivative of shape function in quadrature point. See above.    
* [0.x.29]*
     Return an estimate (in bytes) for the memory consumption of this object.    
* [0.x.30]*
     Values of shape functions. Access by function  [2.x.17]          Computed once.    
* [0.x.31]*
     Values of shape function derivatives. Access by function  [2.x.18]          Computed once.    
* [0.x.32]*
     Values of shape function second derivatives. Access by function  [2.x.19]      second_derivative.         Computed once.    
* [0.x.33]*
     Values of shape function third derivatives. Access by function  [2.x.20]      third_derivative.         Computed once.    
* [0.x.34]*
     Values of shape function fourth derivatives. Access by function  [2.x.21]      fourth_derivative.         Computed once.    
* [0.x.35]*
     Unit tangential vectors. Used for the computation of boundary forms and     normal vectors.         This array has  [2.x.22]  entries. The     first  [2.x.23]  contain the vectors in the first     tangential direction for each face; the second set of      [2.x.24]  entries contain the vectors in the second     tangential direction (only in 3d, since there we have 2 tangential     directions per face), etc.         Filled once.    
* [0.x.36]*
     Number of shape functions. If this is a Q1 mapping, then it is simply     the number of vertices per cell. However, since also derived classes     use this class (e.g. the Mapping_Q() class), the number of shape     functions may also be different.    
* [0.x.37]*
     Stores the mask given at construction time. If no mask was specified at     construction time, then a default one is used, which makes this class     works in the same way of MappingQEulerian(), i.e., the first spacedim     components of the FiniteElement are used for the euler_vector and the     euler_dh.         If a mask is specified, then it has to match the underlying     FiniteElement, and it has to have exactly spacedim non-zero elements,     indicating the components (in order) of the FiniteElement which will be     used for the euler vector and the euler dof handler.    
* [0.x.38]*
     Tensors of covariant transformation at each of the quadrature points.     The matrix stored is the Jacobian G^{-1}, where G = Jacobian^{t}     Jacobian, is the first fundamental form of the map; if dim=spacedim     then it reduces to the transpose of the inverse of the Jacobian matrix,     which itself is stored in the  [2.x.25]  field of this structure.         Computed on each cell.    
* [0.x.39]*
     Tensors of contravariant transformation at each of the quadrature     points. The contravariant matrix is the Jacobian of the transformation,     i.e.  [2.x.26] .         Computed on each cell.    
* [0.x.40]*
     The determinant of the Jacobian in each quadrature point. Filled if     #update_volume_elements.    
* [0.x.41]*
     Auxiliary vectors for internal use.    
* [0.x.42]*
     Storage for the indices of the local degrees of freedom.    
* [0.x.43]*
     Storage for local degrees of freedom.    
* [0.x.44]*
    [2.x.27]   
* [0.x.45]*
   Specifies whether we access unknowns on the active dofs (with a single   Euler vector) or on the level dofs (via a vector of Euler vectors).  
* [0.x.46]*
   Reference to the vector of shifts.  
* [0.x.47]*
   Pointer to the DoFHandler to which the mapping vector is associated.  
* [0.x.48]*
   Transform a point  [2.x.28]  on the unit cell to the point  [2.x.29]  on the   real cell  [2.x.30]  and returns  [2.x.31]      This function is called by  [2.x.32]  and multiple   times (through the Newton iteration) by  [2.x.33]    transform_real_to_unit_cell_internal.     Takes a reference to an  [2.x.34]  that must already include the   shape values at point  [2.x.35]  and the mapping support points of the cell.     This  [2.x.36]  argument avoids multiple computations of the shape   values at point  [2.x.37]  and especially multiple computations of the mapping   support points.  
* [0.x.49]*
   Transform the point  [2.x.38]  on the real cell to the corresponding point on   the unit cell  [2.x.39]  by a Newton iteration.     Takes a reference to an  [2.x.40]  that is assumed to be previously   created by the  [2.x.41]  function with  [2.x.42]  including  [2.x.43]    update_transformation_values and  [2.x.44]  and a   one point Quadrature that includes the given initial guess for the   transformation  [2.x.45]   Hence this function assumes that  [2.x.46]    mdata already includes the transformation shape values and gradients   computed at  [2.x.47]       [2.x.48]  will be changed by this function.  
* [0.x.50]*
   Update internal degrees of freedom.  
* [0.x.51]*
   See the documentation of the base class for detailed information.  
* [0.x.52]   Which components to use for the mapping.  
* [0.x.53]*
   Mapping between indices in the FE space and the real space. This vector   contains one index for each component of the finite element space. If the   index is one for which the ComponentMask which is used to construct this   element is false, then  [2.x.49]  is returned,   otherwise the component in real space is returned. For example, if we   construct the mapping using ComponentMask(spacedim, true), then this   vector contains {0,1,2} in spacedim = 3.  
* [0.x.54]*
   FEValues object used to query the given finite element field at the   support points in the reference configuration.  
* [0.x.55]*
   A variable to guard access to the fe_values variable.  
* [0.x.56]

include/deal.II-translator/fe/mapping_manifold_0.txt
[0.x.0]*
 This class implements the functionality for Manifold conforming mappings. This Mapping computes the transformation between the reference and real cell by exploiting the geometrical information coming from the underlying Manifold object.
*  Quadrature points computed using this mapping lie on the exact geometrical objects, and tangent and normal vectors computed using this class are tangent and normal to the underlying geometry. This is in contrast with the MappingQ class, which approximates the geometry using a polynomial of some order, and then computes the normals and tangents using the approximated surface.
*   [2.x.0]  It is not possible, for mathematical reasons, for one to use this class with a geometry described by a SphericalManifold: see the note in that class for more information.

* 
* [0.x.1]*
   Constructor.  
* [0.x.2]*
   Copy constructor.  
* [0.x.3]*
   Always returns  [2.x.1]  because this class assumes that the   vertices always lies on the underlying Manifold.  
* [0.x.4]*
    [2.x.2]  Mapping points between reference and real cells    [2.x.3]   
* [0.x.5]*
    [2.x.4]   
* [0.x.6]*
    [2.x.5]  Functions to transform tensors from reference to real coordinates    [2.x.6]   
* [0.x.7]*
    [2.x.7]   
* [0.x.8]*
    [2.x.8]  Interface with FEValues    [2.x.9]   
* [0.x.9]*
   Storage for internal data of polynomial mappings. See    [2.x.10]  for an extensive description.     For the current class, the InternalData class stores data that is   computed once when the object is created (in get_data()) as well as data   the class wants to store from between the call to fill_fe_values(),   fill_fe_face_values(), or fill_fe_subface_values() until possible later   calls from the finite element to functions such as transform(). The   latter class of member variables are marked as 'mutable'.  
* [0.x.10]*
     Constructor.    
* [0.x.11]*
     Initialize the object's member variables related to cell data based on     the given arguments.         The function also calls compute_shape_function_values() to actually set     the member variables related to the values and derivatives of the     mapping shape functions.    
* [0.x.12]*
     Initialize the object's member variables related to cell and face data     based on the given arguments. In order to initialize cell data, this     function calls initialize().    
* [0.x.13]*
     Compute the weights associated to the Manifold object, that     need to be passed when computing the location of the quadrature     points.    
* [0.x.14]*
     Store vertices internally.    
* [0.x.15]*
     Return an estimate (in bytes) for the memory consumption of this object.    
* [0.x.16]*
     The current cell vertices.         Computed each.    
* [0.x.17]*
     The current cell.         Computed each.    
* [0.x.18]*
     The actual quadrature on the reference cell.         Computed once.    
* [0.x.19]*
     Values of quadrature weights for manifold quadrature     formulas.         The Manifold class has a function  [2.x.11]      that returns new points according to a weighted average of some     surrounding points on the Manifold. For each quadrature point,     we call this function with a Quadrature formula constructed     using the vertices of the current cell, and the values of the     basis functions of an FE_Q(1) finite element evaluated at the     quadrature point itself. While the vertices of the cell change     for every cell, the weights can be computed once for each     quadrature point. We store this information in the following     variable, where the first index runs through the quadrature     points, and the second index runs through the vertex indices.         Computed once.    
* [0.x.20]*
     A vector of weights for use in  [2.x.12]  For     each point (interior to a cell), we compute the weight each     vertex has for this point. If the point lies at a vertex, then     this vertex has weight one and all others have weight zero. If     the point lies interior to a cell, then the weight every vertex     has is just the  [2.x.13] -linear shape functions associated with each     vertex evaluated at that point.         This array has size  [2.x.14]  but it     can't be converted into a fixed size array because it is used     as input for  [2.x.15]  which wants to see a      [2.x.16]  for the weights.    
* [0.x.21]*
     Unit tangential vectors. Used for the computation of boundary forms and     normal vectors.         This array has `(dim-1)  [2.x.17]  entries. The     first  [2.x.18]  contain the vectors in the first     tangential direction for each face; the second set of      [2.x.19]  entries contain the vectors in the     second tangential direction (only in 3d, since there we have 2 tangential     directions per face), etc.         Filled once.    
* [0.x.22]*
     Tensors of covariant transformation at each of the quadrature points.     The matrix stored is the Jacobian G^{-1}, where G = Jacobian^{t}     Jacobian, is the first fundamental form of the map; if dim=spacedim     then it reduces to the transpose of the inverse of the Jacobian matrix,     which itself is stored in the  [2.x.20]  field of this structure.         Computed on each cell.    
* [0.x.23]*
     Tensors of contravariant transformation at each of the quadrature     points. The contravariant matrix is the Jacobian of the transformation,     i.e.  [2.x.21] .         Computed on each cell.    
* [0.x.24]*
     Auxiliary vectors for internal use.    
* [0.x.25]*
     The determinant of the Jacobian in each quadrature point. Filled if     #update_volume_elements.    
* [0.x.26]*
     A pointer to the Manifold in use.         Updated each.    
* [0.x.27]*
    [2.x.22]   
* [0.x.28]

include/deal.II-translator/fe/mapping_q_0.txt
[0.x.0]*
 A class that implements a polynomial mapping  [2.x.0]  of degree  [2.x.1]  on cells at the boundary of the domain (or, if requested in the constructor, for all cells) and linear mappings for interior cells.
*  The class is in fact poorly named since (unless explicitly specified during the construction of the object, see below), it does not actually use mappings of degree  [2.x.2]  [1.x.0], but only on cells at the boundary. This is in contrast to the MappingQGeneric class which indeed does use a polynomial mapping  [2.x.3]  of degree  [2.x.4]  everywhere. The point of the current class is that in many situations, curved domains are only provided with information about how exactly edges at the boundary are shaped, but we do not know anything about internal edges. Thus, in the absence of other information, we can only assume that internal edges are straight lines, and in that case internal cells may as well be treated is bilinear quadrilaterals or trilinear hexahedra. (An example of how such meshes look is shown in  [2.x.5]  already, but it is also discussed in the "Results" section of  [2.x.6] .) Because bi-/trilinear mappings are significantly cheaper to compute than higher order mappings, it is advantageous in such situations to use the higher order mapping only on cells at the boundary of the domain. This class implements exactly this behavior.
*  There are a number of special cases worth considering:
* 

* 
* 
*  - If you want to use a higher order mapping for all cells, you can achieve this by setting the second argument to the constructor to true. This only makes sense if you can actually provide information about how interior edges and faces of the mesh should be curved. This is typically done by associating a Manifold with interior cells and edges. A simple example of this is discussed in the "Results" section of  [2.x.7] ; a full discussion of manifolds is provided in  [2.x.8] .
* 

* 
* 
*  - If you pass true as the second argument to this class, then it is in fact completely equivalent to generating a MappingQGeneric object right away.
* 

* 
* 
*  - This class is also entirely equivalent to MappingQGeneric if the polynomial degree provided is one. This is because in that case, no distinction between the mapping used on cells in the interior and on the boundary of the domain can be made.
* 

* 
* 
*  - If you are working on meshes embedded in higher space dimensions, i.e., if dim!=spacedim, then every cell is considered to be at the boundary of the domain and consequently a higher order mapping is used for all cells; again this class is then equivalent to using MappingQGeneric right away.
*  [1.x.1]
*  For the behavior of the mapping and convergence rates in case of mixing different manifolds, please consult the respective section of MappingQGeneric.

* 
* [0.x.1]*
   Constructor.   [2.x.9]  denotes the polynomial degree of the   polynomials that are used to map cells boundary.     The second argument determines whether the higher order mapping should   also be used on interior cells. If its value is  [2.x.10]  (the   default), then a lower order mapping is used in the interior. This is   sufficient for most cases where higher order mappings are only used to   better approximate the boundary. In that case, cells bounded by straight   lines are acceptable in the interior. However, there are cases where one   would also like to use a higher order mapping in the interior. The   MappingQEulerian class is one such case.     The value of  [2.x.11]  is ignored if  [2.x.12]  is not   equal to  [2.x.13]  i.e., if we are considering meshes on surfaces   embedded into higher dimensional spaces.  
* [0.x.2]*
   Copy constructor.  
* [0.x.3]*
   Return the degree of the mapping, i.e. the value which was passed to the   constructor.  
* [0.x.4]*
   Always returns  [2.x.14]  because the default implementation of functions in   this class preserves vertex locations.  
* [0.x.5]*
   Transform the point  [2.x.15]  on the unit cell to the point  [2.x.16]  on the   real cell  [2.x.17]  and returns  [2.x.18]   
* [0.x.6]*
   Transform the point  [2.x.19]  on the real cell to the point  [2.x.20]  on the   unit cell  [2.x.21]  and returns  [2.x.22]      Uses Newton iteration and the  [2.x.23]  function.     In the codimension one case, this function returns the normal projection   of the real point  [2.x.24]  on the curve or surface identified by the  [2.x.25]     
*  [2.x.26]  Polynomial mappings from the reference (unit) cell coordinates to   the coordinate system of a real cell are not always invertible if the   point for which the inverse mapping is to be computed lies outside the   cell's boundaries.  In such cases, the current function may fail to   compute a point on the reference cell whose image under the mapping   equals the given point  [2.x.27]   If this is the case then this function   throws an exception of type  [2.x.28]  .  Whether   the given point  [2.x.29]  lies outside the cell can therefore be determined by   checking whether the return reference coordinates lie inside of outside   the reference cell (e.g., using  [2.x.30]  or   whether the exception mentioned above has been thrown.  
* [0.x.7]*
   Return a pointer to a copy of the present object. The caller of this copy   then assumes ownership of it.  
* [0.x.8]*
    [2.x.31]  Interface with FEValues    [2.x.32]   
* [0.x.9]*
   Storage for internal data of this mapping. See  [2.x.33]    for an extensive description.     This includes data that is computed once when the object is created (in   get_data()) as well as data the class wants to store from between the   call to fill_fe_values(), fill_fe_face_values(), or   fill_fe_subface_values() until possible later calls from the finite   element to functions such as transform(). The latter class of member   variables are marked as 'mutable'.     The current class uses essentially the same fields for storage as the   MappingQGeneric class. Consequently, it inherits from    [2.x.34]  rather than from    [2.x.35]  The principal difference to    [2.x.36]  is that MappingQ switches between  [2.x.37]  and    [2.x.38]  mappings depending on the cell we are on, so the internal data   object needs to also store a pointer to an InternalData object that   pertains to a  [2.x.39]  mapping.  
* [0.x.10]*
     Constructor.    
* [0.x.11]*
     Return an estimate (in bytes) for the memory consumption of this object.    
* [0.x.12]*
     Flag that is set by the <tt>fill_fe_[[sub]face]_values</tt> function.         If this flag is  [2.x.40]  we are on an interior cell and the  [2.x.41]      mapping_q1_data is used.    
* [0.x.13]*
     A pointer to a structure to store the information for the pure  [2.x.42]      mapping that is, by default, used on all interior cells.    
* [0.x.14]*
     A pointer to a structure to store the information for the full  [2.x.43]      mapping that is, by default, used on all boundary cells.    
* [0.x.15]*
    [2.x.44]   
* [0.x.16]*
   The polynomial degree of the cells to be used on all cells at the   boundary of the domain, or everywhere if so specified.  
* [0.x.17]*
   If this flag is set  [2.x.45]  then  [2.x.46]  is used on all cells, not   only on boundary cells.  
* [0.x.18]*
   Pointer to a Q1 mapping. This mapping is used on interior cells unless   use_mapping_q_on_all_cells was set in the call to the constructor. The   mapping is also used on any cell in the transform_real_to_unit_cell() to   compute a cheap initial guess for the position of the point before we   employ the more expensive Newton iteration using the full mapping.    
*  [2.x.47]  MappingQEulerian resets this pointer to an object of type   MappingQ1Eulerian to ensure that the Q1 mapping also knows about the   proper shifts and transformations of the Eulerian displacements. This   also means that we really need to store our own Q1 mapping here, rather   than simply resorting to  [2.x.48]     
*  [2.x.49]  If the polynomial degree used for the current object is one, then   the qp_mapping and q1_mapping variables point to the same underlying   object.  
* [0.x.19]*
   Pointer to a Q_p mapping. This mapping is used on boundary cells unless   use_mapping_q_on_all_cells was set in the call to the constructor (in   which case it is used for all cells).    
*  [2.x.50]  MappingQEulerian and MappingC1 reset this pointer to an object of   their own implementation to ensure that the Q_p mapping also knows about   the proper shifts and transformations of the Eulerian displacements   (Eulerian case) and proper choice of support points (C1 case).    
*  [2.x.51]  If the polynomial degree used for the current object is one, then   the qp_mapping and q1_mapping variables point to the same underlying   object.  
* [0.x.20]

include/deal.II-translator/fe/mapping_q1_0.txt
[0.x.0]*
 Implementation of a  [2.x.0] -linear mapping from the reference cell to a general quadrilateral/hexahedron.
*  The mapping implemented by this class maps the reference (unit) cell to a general grid cell with straight lines in  [2.x.1]  dimensions. (Note, however, that in 3D the [1.x.0] of a general, trilinearly mapped cell may be curved, even if the edges are not). This is the standard mapping used for polyhedral domains. It is also the mapping used throughout deal.II for many functions that come in two variants, one that allows to pass a mapping argument explicitly and one that simply falls back to the MappingQ1 class declared here. (Or, in fact, to an object of kind MappingQGeneric(1), which implements exactly the functionality of this class.)
*  The shape functions for this mapping are the same as for the finite element FE_Q of polynomial degree 1. Therefore, coupling these two yields an isoparametric element.
* 

* 
*  [2.x.2]  This class is, in all reality, nothing more than a different name for calling MappingQGeneric with a polynomial degree of one as argument.

* 
* [0.x.1]*
   Default constructor.  
* [0.x.2]*
 Many places in the library by default use (bi-,tri-)linear mappings unless users explicitly provide a different mapping to use. In these cases, the called function has to create a  [2.x.3]  mapping object, i.e., an object of kind MappingQGeneric(1). This is costly. It would also be costly to create such objects as static objects in the affected functions, because static objects are never destroyed throughout the lifetime of a program, even though they only have to be created once the first time code runs through a particular function.
*  In order to avoid creation of (static or dynamic)  [2.x.4]  mapping objects in these contexts throughout the library, this class defines a static  [2.x.5]  mapping object. This object can then be used in all of those places where such an object is needed.
* 

* 
*  [2.x.6]  The use of this object should be avoided since it is only applicable   in cases where a mesh consists exclusively of quadrilaterals or hexahedra.   Use  [2.x.7]    instead.

* 
* [0.x.3]*
   The static  [2.x.8]  mapping object discussed in the documentation of this   class.  
* [0.x.4]

include/deal.II-translator/fe/mapping_q1_eulerian_0.txt
[0.x.0]*
 This class provides a mapping that adds to the location of each cell a  [2.x.0] -linear displacement field. (The generalization to higher order polynomials is provided in the MappingQEulerian class.) Each cell is thus shifted in space by values given to the mapping through a finite element field.
*  [1.x.0]
*  The constructor of this class takes two arguments: a reference to the vector that defines the mapping from the reference configuration to the current configuration and a reference to the DoFHandler. The vector should then represent a (flattened out version of a) vector valued field defined at nodes defined by the DoFHandler, where the number of components of the vector field equals the number of space dimensions. Thus, the DoFHandler shall operate on a finite element that has as many components as space dimensions. As an additional requirement, we impose that it have as many degree of freedom per vertex as there are space dimensions; since this object only evaluates the finite element field at the vertices, the values of all other degrees of freedom (not associated to vertices) are ignored. These requirements are met if the finite element which the given DoFHandler operates on is constructed as a system element (FESystem) from  [2.x.1]  continuous FE_Q() objects.
*  In many cases, the shift vector will also be the solution vector of the problem under investigation. If this is not the case (i.e. the number of components of the solution variable is not equal to the space dimension, e.g. for scalar problems in <tt>dim>1</tt> where the Eulerian coordinates only give a background field) or for coupled problems where more variables are computed than just the flow field), then a different DoFHandler has to be set up on the given triangulation, and the shift vector has then to be associated to it.
*  An example is shown below:

* 
* [1.x.1]
* 
*  Note that since the vector of shift values and the dof handler are only associated to this object at construction time, you have to make sure that whenever you use this object, the given objects still represent valid data.
*  To enable the use of the MappingQ1Eulerian class also in the context of parallel codes using the PETSc or Trilinos wrapper classes, the type of the vector can be specified as template parameter <tt>VectorType</tt>.
*  For more information about the <tt>spacedim</tt> template parameter check the documentation of FiniteElement or the one of Triangulation.

* 
* [0.x.1]*
   Constructor.      [2.x.2]  euler_dof_handler A DoFHandler object that defines a finite   element space. This space needs to have exactly dim components   and these will be considered displacements   relative to the original positions of the cells of the triangulation.   This DoFHandler must be based on a  [2.x.3]    finite element.    [2.x.4]  euler_vector A finite element function in the space defined by   the first argument. The dim components of this function will be   interpreted as the displacement we use in defining the mapping, relative   to the location of cells of the underlying triangulation.  
* [0.x.2]*
   Return the mapped vertices of the cell. For the current class, this   function does not use the support points from the geometry of the current   cell but instead evaluates an externally given displacement field in   addition to the geometry of the cell.  
* [0.x.3]*
   Return a pointer to a copy of the present object. The caller of this copy   then assumes ownership of it.  
* [0.x.4]*
   Always returns  [2.x.5]  because MappingQ1Eulerian does not in general   preserve vertex locations (unless the translation vector happens to   provide for zero displacements at vertex locations).  
* [0.x.5]*
   Exception.  
* [0.x.6]*
   Compute mapping-related information for a cell. See the documentation of    [2.x.6]  for a discussion of purpose, arguments, and   return value of this function.     This function overrides the function in the base class since we cannot   use any cell similarity for this class.  
* [0.x.7]*
   Compute the support points of the mapping. For the current class, these   are the vertices, as obtained by calling  [2.x.7]  See the   documentation of  [2.x.8]  for   more information.  
* [0.x.8]*
   Reference to the vector of shifts.  
* [0.x.9]*
   Pointer to the DoFHandler to which the mapping vector is associated.  
* [0.x.10]

include/deal.II-translator/fe/mapping_q_cache_0.txt
[0.x.0]*
 This class implements a caching strategy for objects of the MappingQ family in terms of the  [2.x.0]  function, which is used in all operations of MappingQGeneric. The information of the mapping is pre-computed by the  [2.x.1]  function.
*  The use of this class is discussed extensively in  [2.x.2] .

* 
* [0.x.1]*
   Constructor.  [2.x.3]  denotes the polynomial degree of the   polynomials that are used to map cells from the reference to the real   cell.  
* [0.x.2]*
   Copy constructor.  
* [0.x.3]*
   Destructor.  
* [0.x.4]*
   clone() functionality. For documentation, see  [2.x.4]   
* [0.x.5]*
   Returns  [2.x.5]  because the preservation of vertex locations depends on   the mapping handed to the reinit() function.  
* [0.x.6]*
   Initialize the data cache by computing the mapping support points for all   cells (on all levels) of the given triangulation.    
*  [2.x.6]  The cache is invalidated upon the signal    [2.x.7]  of the underlying triangulation.  
* [0.x.7]*
   Initialize the data cache by computing the mapping support points for all   cells (on all levels) of the given triangulation.    
*  [2.x.8]  The cache is invalidated upon the signal    [2.x.9]  of the underlying triangulation.      [2.x.10]  Use initialize() version above instead.  
* [0.x.8]*
   Initialize the data cache by letting the function given as an argument   provide the mapping support points for all cells (on all levels) of the   given triangulation. The function must return a vector of   `Point<spacedim>` whose length is the same as the size of the polynomial   space,  [2.x.11] , where  [2.x.12]  is the polynomial degree of the   mapping, and it must be in the order the mapping or FE_Q sort their   points, i.e., all  [2.x.13]  vertex points first, then the points on   the lines, quads, and hexes according to the usual hierarchical   numbering. No attempt is made to validate these points internally, except   for the number of given points.    
*  [2.x.14]  If multiple threads are enabled, this function will run in   parallel, invoking the function passed in several times. Thus, in case    [2.x.15]  the user code must make sure that the   function, typically a lambda, does not write into data shared with other   threads.    
*  [2.x.16]  The cache is invalidated upon the signal    [2.x.17]  of the underlying triangulation.  
* [0.x.9]*
   Initialize the data cache by computing the mapping support points for all   cells (on all levels) of the given triangulation and a given  [2.x.18]    and transforming these points via the function  [2.x.19]      The bool  [2.x.20]  indicates that   the function  [2.x.21]  maps to absolute coordinates.   If the parameter is set to true, the return value of the function is   interpreted as relative deformation and the result is eventually added   to the original point for the support points eventually used by this class.     This function calls the previous function so the comments regarding   threading listed above apply also here.    
*  [2.x.22]  The cache is invalidated upon the signal    [2.x.23]  of the underlying triangulation.  
* [0.x.10]*
   The same as above but taking a  [2.x.24]  object.  
* [0.x.11]*
   Initialize the data cache of the active cells by a discrete field   (specified   by  [2.x.25]  and  [2.x.26]  that describes the absolute or   relative position of each support point.    
*  [2.x.27]  By using this function for reinitialization, this class behaves like     MappingFEField (vector_describes_relative_displacement == false) or     MappingQEulerian (vector_describes_relative_displacement == true), but     with much more efficient operations internally.  
* [0.x.12]*
   Initialize the data cache of all non-artificial cells by a solution   (specified by  [2.x.28]  and a set of  [2.x.29]  on all levels of the   triangulation) that describes the absolute or relative position of each   support point.    
*  [2.x.30]  By using this function for reinitialization, this class behaves like     MappingFEField (vector_describes_relative_displacement == false) or     MappingQEulerian (vector_describes_relative_displacement == true), but     with much more efficient operations internally.  
* [0.x.13]*
   Return the memory consumption (in bytes) of the cache.  
* [0.x.14]*
   This is the main function overridden from the base class MappingQGeneric.  
* [0.x.15]*
   The point cache filled upon calling initialize(). It is made a shared   pointer to allow several instances (created via clone()) to share this   cache.  
* [0.x.16]*
   The connection to  [2.x.31]  that must be reset once   this class goes out of scope.  
* [0.x.17]*
   Specifies if support_point_cache has been set up for the cells on the   levels.  
* [0.x.18]

include/deal.II-translator/fe/mapping_q_eulerian_0.txt
[0.x.0]*
 This class is an extension of the MappingQ1Eulerian class to higher order  [2.x.0]  mappings.  It is useful when one wants to calculate shape function information on a domain that is deforming as the computation proceeds.
*  [1.x.0]
*  The constructor of this class takes three arguments: the polynomial degree of the desired Qp mapping, a reference to the vector that defines the mapping from the initial configuration to the current configuration, and a reference to the DoFHandler. The most common case is to use the solution vector for the problem under consideration as the shift vector. The key requirement is that the number of components of the given vector field must be equal to (or possibly greater than) the number of space dimensions. If there are more components than space dimensions (for example, if one is working with a coupled problem where there are additional solution variables), the first <tt>dim</tt> components are assumed to represent the displacement field, and the remaining components are ignored.  If this assumption does not hold one may need to set up a separate DoFHandler on the triangulation and associate the desired shift vector to it.
*  Typically, the DoFHandler operates on a finite element that is constructed as a system element (FESystem) from continuous FE_Q objects. An example is shown below:

* 
* [1.x.1]
* 
*  In this example, our element consists of <tt>(dim+1)</tt> components. Only the first <tt>dim</tt> components will be used, however, to define the Q2 mapping.  The remaining components are ignored.
*  Note that it is essential to call the distribute_dofs(...) function before constructing a mapping object.
*  Also note that since the vector of shift values and the dof handler are only associated to this object at construction time, you have to make sure that whenever you use this object, the given objects still represent valid data.
*  To enable the use of the MappingQEulerian class also in the context of parallel codes using the PETSc or Trilinos wrapper classes, the type of the vector can be specified as template parameter <tt>VectorType</tt>.

* 
* [0.x.1]*
   Constructor.      [2.x.1]  degree The polynomial degree of the desired  [2.x.2]  mapping.    [2.x.3]  euler_dof_handler A DoFHandler object that defines a finite   element space. This space needs to have at least dim components and the   first dim components of the space will be considered displacements   relative to the original positions of the cells of the triangulation.    [2.x.4]  euler_vector A finite element function in the space defined by   the second argument. The first dim components of this function will be   interpreted as the displacement we use in defining the mapping, relative   to the location of cells of the underlying triangulation.    [2.x.5]  level The multi-grid level at which the mapping will   be used. It is mainly used to check if the size of the  [2.x.6]    is consistent with the  [2.x.7]  .  
* [0.x.2]*
   Return the mapped vertices of the cell. For the current class, this   function does not use the support points from the geometry of the current   cell but instead evaluates an externally given displacement field in   addition to the geometry of the cell.  
* [0.x.3]*
   Return a pointer to a copy of the present object. The caller of this copy   then assumes ownership of it.  
* [0.x.4]*
   Always return  [2.x.8]  because MappingQEulerian does not in general   preserve vertex locations (unless the translation vector happens to   provide zero displacements at vertex locations).  
* [0.x.5]*
   Exception which is thrown when the mapping is being evaluated at   non-active cell.  
* [0.x.6]*
   Compute mapping-related information for a cell. See the documentation of    [2.x.9]  for a discussion of purpose, arguments, and   return value of this function.     This function overrides the function in the base class since we cannot   use any cell similarity for this class.  
* [0.x.7]*
   Reference to the vector of shifts.  
* [0.x.8]*
   Pointer to the DoFHandler to which the mapping vector is associated.  
* [0.x.9]*
   Multigrid level at which the mapping is to be used.  
* [0.x.10]*
   A class derived from MappingQGeneric that provides the generic mapping   with support points on boundary objects so that the corresponding Q3   mapping ends up being C1.  
* [0.x.11]*
     Constructor.    
* [0.x.12]*
     Return the mapped vertices of the cell. For the current class, this     function does not use the support points from the geometry of the     current cell but instead evaluates an externally given displacement     field in addition to the geometry of the cell.    
* [0.x.13]*
     Compute the positions of the support points in the current     configuration. See the documentation of      [2.x.10]  for more information.    
* [0.x.14]*
     Always return  [2.x.11]  because MappingQEulerianGeneric does not in general     preserve vertex locations (unless the translation vector happens to     provide for zero displacements at vertex locations).    
* [0.x.15]*
     Reference to the surrounding object off of which we live.    
* [0.x.16]*
     Special quadrature rule used to define the support points in the     reference configuration.    
* [0.x.17]*
       Constructor, with an argument defining the desired polynomial degree.      
* [0.x.18]*
     A member variable holding the quadrature points in the right order.    
* [0.x.19]*
     FEValues object used to query the given finite element field at the     support points in the reference configuration.         The variable is marked as mutable since we have to call      [2.x.12]  from compute_mapping_support_points, a function that     is 'const'.    
* [0.x.20]*
     A variable to guard access to the fe_values variable.    
* [0.x.21]

include/deal.II-translator/fe/mapping_q_generic_0.txt
[0.x.0]*
 This class implements the functionality for polynomial mappings  [2.x.0]  of polynomial degree  [2.x.1]  that will be used on all cells of the mesh. The MappingQ1 and MappingQ classes specialize this behavior slightly.
*  The class is poorly named. It should really have been called MappingQ because it consistently uses  [2.x.2]  mappings on all cells of a triangulation. However, the name MappingQ was already taken when we rewrote the entire class hierarchy for mappings. One might argue that one should always use MappingQGeneric over the existing class MappingQ (which, unless explicitly specified during the construction of the object, only uses mappings of degree  [2.x.3]  [1.x.0]). On the other hand, there are good reasons to use MappingQ in many situations: in many situations, curved domains are only provided with information about how exactly edges at the boundary are shaped, but we do not know anything about internal edges. Thus, in the absence of other information, we can only assume that internal edges are straight lines, and in that case internal cells may as well be treated is bilinear quadrilaterals or trilinear hexahedra. (An example of how such meshes look is shown in  [2.x.4]  already, but it is also discussed in the "Results" section of  [2.x.5] .) Because bi-/trilinear mappings are significantly cheaper to compute than higher order mappings, it is advantageous in such situations to use the higher order mapping only on cells at the boundary of the domain
* 
*  -  i.e., the behavior of MappingQ. Of course, MappingQGeneric also uses bilinear mappings for interior cells as long as it has no knowledge about curvature of interior edges, but it implements this the expensive way: as a general  [2.x.6]  mapping where the mapping support points just [1.x.1] to be arranged along linear or bilinear edges or faces.
*  There are a number of special cases worth considering:
* 

* 
* 
*  - If you really want to use a higher order mapping for all cells, you can do this using the current class, but this only makes sense if you can actually provide information about how interior edges and faces of the mesh should be curved. This is typically done by associating a Manifold with interior cells and edges. A simple example of this is discussed in the "Results" section of  [2.x.7] ; a full discussion of manifolds is provided in  [2.x.8] .
* 

* 
* 
*  - If you are working on meshes that describe a (curved) manifold embedded in higher space dimensions, i.e., if dim!=spacedim, then every cell is at the boundary of the domain you will likely already have attached a manifold object to all cells that can then also be used by the mapping classes for higher order mappings.
*  [1.x.2]
*  As described above, one often only knows a manifold description of a surface but not the interior of the computational domain. In such a case, a FlatManifold object will be assigned to the interior entities that describes a usual planar coordinate system where the additional points for the higher order mapping are placed exactly according to a bi-/trilinear mapping. When combined with a non-flat manifold on the boundary, for example a circle bulging into the interior of a square cell, the two manifold descriptions are in general incompatible. For example, a FlatManifold defined solely through the cell's vertices would put an interior point located at some small distance epsilon away from the boundary along a straight line and thus in general outside the concave part of a circle. If the polynomial degree of MappingQ is sufficiently high, the transformation from the reference cell to such a cell would in general contain inverted regions close to the boundary.
*  In order to avoid this situation, this class applies an algorithm for making this transition smooth using a so-called transfinite interpolation that is essentially a linear blend between the descriptions along the surrounding entities. In the algorithm that computes additional points, the compute_mapping_support_points() method, all the entities of the cells are passed through hierarchically, starting from the lines to the quads and finally hexes. Points on objects higher up in the hierarchy are obtained from the manifold associated with that object, taking into account all the points previously computed by the manifolds associated with the lower-dimensional objects, not just the vertices. If only a line is assigned a curved boundary but the adjacent quad is on a flat manifold, the flat manifold on the quad will take the points on the deformed line into account when interpolating the position of the additional points inside the quad and thus always result in a well-defined transformation.
*  The interpolation scheme used in this class makes sure that curved descriptions can go over to flat descriptions within a single layer of elements, maintaining the overall optimal convergence rates of the finite element interpolation. However, one does often get better solution qualities if the transition between curved boundaries and flat interior domains is spread over a larger range as the mesh is refined. This is provided by the special manifold TransfiniteInterpolationManifold.

* 
* [0.x.1]*
   Constructor.   [2.x.9]  denotes the polynomial degree of the   polynomials that are used to map cells from the reference to the real   cell.  
* [0.x.2]*
   Copy constructor.  
* [0.x.3]*
   Return the degree of the mapping, i.e. the value which was passed to the   constructor.  
* [0.x.4]*
   Always returns  [2.x.10]  because the default implementation of functions in   this class preserves vertex locations.  
* [0.x.5]*
    [2.x.11]  Mapping points between reference and real cells    [2.x.12]   
* [0.x.6]*
    [2.x.13]   
* [0.x.7]*
    [2.x.14]  Functions to transform tensors from reference to real coordinates    [2.x.15]   
* [0.x.8]*
    [2.x.16]   
* [0.x.9]*
    [2.x.17]  Interface with FEValues and friends    [2.x.18]   
* [0.x.10]*
   Storage for internal data of polynomial mappings. See    [2.x.19]  for an extensive description.     For the current class, the InternalData class stores data that is   computed once when the object is created (in get_data()) as well as data   the class wants to store from between the call to fill_fe_values(),   fill_fe_face_values(), or fill_fe_subface_values() until possible later   calls from the finite element to functions such as transform(). The   latter class of member variables are marked as 'mutable'.  
* [0.x.11]*
     Constructor. The argument denotes the polynomial degree of the mapping     to which this object will correspond.    
* [0.x.12]*
     Initialize the object's member variables related to cell data based on     the given arguments.         The function also calls compute_shape_function_values() to actually set     the member variables related to the values and derivatives of the     mapping shape functions.    
* [0.x.13]*
     Initialize the object's member variables related to cell and face data     based on the given arguments. In order to initialize cell data, this     function calls initialize().    
* [0.x.14]*
     Compute the values and/or derivatives of the shape functions used for     the mapping.         Which values, derivatives, or higher order derivatives are computed is     determined by which of the member arrays have nonzero sizes. They are     typically set to their appropriate sizes by the initialize() and     initialize_face() functions, which indeed call this function     internally. However, it is possible (and at times useful) to do the     resizing by hand and then call this function directly. An example is in     a Newton iteration where we update the location of a quadrature point     (e.g., in  [2.x.20]  and need to re-     compute the mapping and its derivatives at this location, but have     already sized all internal arrays correctly.    
* [0.x.15]*
     Shape function at quadrature point. Shape functions are in tensor     product order, so vertices must be reordered to obtain transformation.    
* [0.x.16]*
     Shape function at quadrature point. See above.    
* [0.x.17]*
     Gradient of shape function in quadrature point. See above.    
* [0.x.18]*
     Gradient of shape function in quadrature point. See above.    
* [0.x.19]*
     Second derivative of shape function in quadrature point. See above.    
* [0.x.20]*
     Second derivative of shape function in quadrature point. See above.    
* [0.x.21]*
     third derivative of shape function in quadrature point. See above.    
* [0.x.22]*
     third derivative of shape function in quadrature point. See above.    
* [0.x.23]*
     fourth derivative of shape function in quadrature point. See above.    
* [0.x.24]*
     fourth derivative of shape function in quadrature point. See above.    
* [0.x.25]*
     Return an estimate (in bytes) for the memory consumption of this object.    
* [0.x.26]*
     Values of shape functions. Access by function  [2.x.21]          Computed once.    
* [0.x.27]*
     Values of shape function derivatives. Access by function  [2.x.22]          Computed once.    
* [0.x.28]*
     Values of shape function second derivatives. Access by function  [2.x.23]      second_derivative.         Computed once.    
* [0.x.29]*
     Values of shape function third derivatives. Access by function  [2.x.24]      second_derivative.         Computed once.    
* [0.x.30]*
     Values of shape function fourth derivatives. Access by function  [2.x.25]      second_derivative.         Computed once.    
* [0.x.31]*
     Unit tangential vectors. Used for the computation of boundary forms and     normal vectors.         This array has `(dim-1)  [2.x.26]  entries. The     first  [2.x.27]  contain the vectors in the first     tangential direction for each face; the second set of      [2.x.28]  entries contain the vectors in the second     tangential direction (only in 3d, since there we have 2 tangential     directions per face), etc.         Filled once.    
* [0.x.32]*
     The polynomial degree of the mapping. Since the objects here are also     used (with minor adjustments) by MappingQ, we need to store this.    
* [0.x.33]*
     Number of shape functions. If this is a Q1 mapping, then it is simply     the number of vertices per cell. However, since also derived classes     use this class (e.g. the Mapping_Q() class), the number of shape     functions may also be different.         In general, it is  [2.x.29] , where  [2.x.30]  is the polynomial     degree of the mapping.    
* [0.x.34]     The default line support points. Is used in when the shape function     values are computed.         The number of quadrature points depends on the degree of this     class, and it matches the number of degrees of freedom of an     FE_Q<1>(this->degree).    
* [0.x.35]*
     In case the quadrature rule given represents a tensor product     we need to store the evaluations of the 1d polynomials at     the 1d quadrature points. That is what this variable is for.    
* [0.x.36]*
     In case the quadrature rule given represents a tensor product     we need to store temporary data in this object.    
* [0.x.37]*
     In case the quadrature rule given represents a tensor product     the values at the mapped support points are stored in this object.    
* [0.x.38]*
     In case the quadrature rule given represents a tensor product     the values at the quadrature points are stored in this object.    
* [0.x.39]*
     In case the quadrature rule given represents a tensor product     the gradients at the quadrature points are stored in this object.    
* [0.x.40]*
     In case the quadrature rule given represents a tensor product     the hessians at the quadrature points are stored in this object.    
* [0.x.41]*
     Indicates whether the given Quadrature object is a tensor product.    
* [0.x.42]*
     Tensors of covariant transformation at each of the quadrature points.     The matrix stored is the Jacobian G^{-1}, where G = Jacobian^{t}     Jacobian, is the first fundamental form of the map; if dim=spacedim     then it reduces to the transpose of the inverse of the Jacobian matrix,     which itself is stored in the  [2.x.31]  field of this structure.         Computed on each cell.    
* [0.x.43]*
     Tensors of contravariant transformation at each of the quadrature     points. The contravariant matrix is the Jacobian of the transformation,     i.e.  [2.x.32] .         Computed on each cell.    
* [0.x.44]*
     Auxiliary vectors for internal use.    
* [0.x.45]*
     Stores the support points of the mapping shape functions on the  [2.x.33]      cell_of_current_support_points.    
* [0.x.46]*
     Stores the cell of which the  [2.x.34]  are stored.    
* [0.x.47]*
     The determinant of the Jacobian in each quadrature point. Filled if     #update_volume_elements.    
* [0.x.48]*
   As opposed to the other fill_fe_values() and fill_fe_face_values()   functions that rely on pre-computed information of InternalDataBase, this   function chooses the flexible evaluation path on the cell and points   passed in to the current function.      [2.x.35]  cell The cell where to evaluate the mapping      [2.x.36]  unit_points The points in reference coordinates where the   transformation (Jacobians, positions) should be computed.      [2.x.37]  update_flags The kind of information that should be computed.      [2.x.38]  output_data A struct containing the evaluated quantities such   as the Jacobian resulting from application of the mapping on the given   cell with its underlying manifolds.  
* [0.x.49]*
    [2.x.39]   
* [0.x.50]*
   The degree of the polynomials used as shape functions for the mapping of   cells.  
* [0.x.51]   The default line support points. These are used when computing the   location in real space of the support points on lines and quads, which   are needed by the Manifold<dim,spacedim> class.     The number of points depends on the degree of this class, and it matches   the number of degrees of freedom of an FE_Q<1>(this->degree).  
* [0.x.52]   The one-dimensional polynomials defined as Lagrange polynomials from the   line support points. These are used for point evaluations and match the   polynomial space of an FE_Q<1>(this->degree).  
* [0.x.53]   The numbering from the lexicographic to the hierarchical ordering used   when expanding the tensor product with the mapping support points (which   come in hierarchical numbers).  
* [0.x.54]   The support points in reference coordinates. These are used for   constructing approximations of the output of   compute_mapping_support_points() when evaluating the mapping on the fly,   rather than going through the FEValues interface provided by   InternalData.     The number of points depends on the degree of this class, and it matches   the number of degrees of freedom of an FE_Q<dim>(this->degree).  
* [0.x.55]*
   A vector of tables of weights by which we multiply the locations of the   support points on the perimeter of an object (line, quad, hex) to get the   location of interior support points.     Access into this table is by  [2.x.40]  i.e., use 0 to access the   support point weights on a line (i.e., the interior points of the   GaussLobatto quadrature), use 1 to access the support point weights from   to perimeter to the interior of a quad, and use 2 to access the support   point weights from the perimeter to the interior of a hex.     The table itself contains as many columns as there are surrounding points   to a particular object (2 for a line,  [2.x.41]  for   a quad,  [2.x.42]  for a   hex) and as many rows as there are strictly interior points.     For the definition of this table see equation (8) of the `mapping'   report.  
* [0.x.56]*
   A table of weights by which we multiply the locations of the vertex   points of the cell to get the location of all additional support points,   both on lines, quads, and hexes (as appropriate). This data structure is   used when we fill all support points at once, which is the case if the   same manifold is attached to all sub-entities of a cell. This way, we can   avoid some of the overhead in transforming data for mappings.     The table has as many rows as there are vertices to the cell (2 in 1D, 4   in 2D, 8 in 3D), and as many rows as there are additional support points   in the mapping, i.e., <code>(degree+1)^dim
* 
*  - 2^dim</code>.  
* [0.x.57]*
   Return the locations of support points for the mapping. For example, for    [2.x.43]  mappings these are the vertices, and for higher order polynomial   mappings they are the vertices plus interior points on edges, faces, and   the cell interior that are placed in consultation with the Manifold   description of the domain and its boundary. However, other classes may   override this function differently. In particular, the MappingQ1Eulerian   class does exactly this by not computing the support points from the   geometry of the current cell but instead evaluating an externally given   displacement field in addition to the geometry of the cell.     The default implementation of this function is appropriate for most   cases. It takes the locations of support points on the boundary of the   cell from the underlying manifold. Interior support points (ie. support   points in quads for 2d, in hexes for 3d) are then computed using an   interpolation from the lower-dimensional entities (lines, quads) in order   to make the transformation as smooth as possible without introducing   additional boundary layers within the cells due to the placement of   support points.     The function works its way from the vertices (which it takes from the   given cell) via the support points on the line (for which it calls the   add_line_support_points() function) and the support points on the quad   faces (in 3d, for which it calls the add_quad_support_points() function).   It then adds interior support points that are either computed by   interpolation from the surrounding points using weights for transfinite   interpolation, or if dim<spacedim, it asks the underlying manifold for   the locations of interior points.  
* [0.x.58]*
   Transform the point  [2.x.44]  on the real cell to the corresponding point on   the unit cell  [2.x.45]  by a Newton iteration.  
* [0.x.59]*
   Append the support points of all shape functions located on bounding   lines of the given cell to the vector  [2.x.46]  Points located on the   vertices of a line are not included.     This function uses the underlying manifold object of the line (or, if   none is set, of the cell) for the location of the requested points. This   function is usually called by compute_mapping_support_points() function.     This function is made virtual in order to allow derived classes to choose   shape function support points differently than the present class, which   chooses the points as interpolation points on the boundary.  
* [0.x.60]*
   Append the support points of all shape functions located on bounding   faces (quads in 3d) of the given cell to the vector  [2.x.47]  This function   is only defined for <tt>dim=3</tt>. Points located on the vertices or   lines of a quad are not included.     This function uses the underlying manifold object of the quad (or, if   none is set, of the cell) for the location of the requested points. This   function is usually called by compute_mapping_support_points().     This function is made virtual in order to allow derived classes to choose   shape function support points differently than the present class, which   chooses the points as interpolation points on the boundary.  
* [0.x.61]

include/deal.II-translator/fe/mapping_q_internal_0.txt
[0.x.0]*
   Internal namespace to implement methods specific to MappingQ1, in   particular an explicit formula for the transformation from the real to   the unit cell in 2D.  
* [0.x.1]       There are two ways to compute xi from eta, but either one may have a       zero denominator.      
* [0.x.2]*
   Internal namespace to implement methods of MappingQGeneric, such as the   evaluation of the mapping and the transformation between real and unit   cell.  
* [0.x.3]*
     This function generates the reference cell support points from the 1d     support points by expanding the tensor product.    
* [0.x.4]*
     This function is needed by the constructor of     <tt>MappingQ<dim,spacedim></tt> for <tt>dim=</tt> 2 and 3.         For the definition of the  [2.x.0]  please     refer to the description of TransfiniteInterpolationManifold.    
* [0.x.5]*
     This function is needed by the constructor of <tt>MappingQ<3></tt>.         For the definition of the  [2.x.1]  please     refer to the description of TransfiniteInterpolationManifold.    
* [0.x.6]*
     This function collects the output of     compute_support_point_weights_on_{quad,hex} in a single data structure.    
* [0.x.7]*
     Collects all interior points for the various dimensions.    
* [0.x.8]*
     Using the relative weights of the shape functions evaluated at     one point on the reference cell (and stored in data.shape_values     and accessed via data.shape(0,i)) and the locations of mapping     support points (stored in data.mapping_support_points), compute     the mapped location of that point in real space.    
* [0.x.9]*
     Implementation of transform_real_to_unit_cell for either type double     or VectorizedArray<double>    
* [0.x.10]*
     Implementation of transform_real_to_unit_cell for dim==spacedim-1    
* [0.x.11]*
     A class to compute a quadratic approximation to the inverse map from     real to unit points by a least-squares fit along the mapping support     points. The least squares fit is special in the sense that the     approximation is constructed for the inverse function of a     MappingQGeneric, which is generally a rational function. This allows     for a very cheap evaluation of the inverse map by a simple polynomial     interpolation, which can be used as a better initial guess for     transforming points from real to unit coordinates than an affine     approximation.         Far away outside the unit cell, this approximation can become     inaccurate for non-affine cell shapes. This must be expected from a     fit of a polynomial to a rational function, and due to the fact that     the region of the least squares fit, the unit cell, is left. Hence,     use this function with care in those situations.    
* [0.x.12]*
       Number of basis functions in the quadratic approximation.      
* [0.x.13]*
       Constructor.              [2.x.2]  real_support_points The position of the mapping support points       in real space, queried by        [2.x.3]               [2.x.4]  unit_support_points The location of the support points in       reference coordinates  [2.x.5]  that map to the mapping support       points in real space by a polynomial map.      
* [0.x.14]*
       Copy constructor.      
* [0.x.15]*
       Evaluate the quadratic approximation.      
* [0.x.16]*
       In order to guarantee a good conditioning, we need to apply a       transformation to the points in real space that is computed by a       shift vector normalization_shift (first point of the mapping support       points in real space) and an inverse length scale called       `length_normalization` as the distance between the first two points.      
* [0.x.17]*
       See the documentation of `normalization_shift` above.      
* [0.x.18]*
       The vector of coefficients in the quadratic approximation.      
* [0.x.19]*
       In case the quadratic approximation is not possible due to an       insufficient number of support points, we switch to an affine       approximation that always works but is less accurate.      
* [0.x.20]*
     In case the quadrature formula is a tensor product, this is a     replacement for maybe_compute_q_points(), maybe_update_Jacobians() and     maybe_update_jacobian_grads()    
* [0.x.21]*
     Compute the locations of quadrature points on the object described by     the first argument (and the cell for which the mapping support points     have already been set), but only if the update_flags of the  [2.x.6]      argument indicate so.    
* [0.x.22]*
     Update the co- and contravariant matrices as well as their determinant,     for the cell     described stored in the data object, but only if the update_flags of the  [2.x.7]      argument indicate so.         Skip the computation if possible as indicated by the first argument.    
* [0.x.23]*
     Update the Hessian of the transformation from unit to real cell, the     Jacobian gradients.         Skip the computation if possible as indicated by the first argument.    
* [0.x.24]*
     Update the Hessian of the transformation from unit to real cell, the     Jacobian gradients, pushed forward to the real cell coordinates.         Skip the computation if possible as indicated by the first argument.    
* [0.x.25]*
     Update the third derivatives of the transformation from unit to real     cell, the Jacobian hessians.         Skip the computation if possible as indicated by the first argument.    
* [0.x.26]*
     Update the Hessian of the Hessian of the transformation from unit     to real cell, the Jacobian Hessian gradients, pushed forward to the     real cell coordinates.         Skip the computation if possible as indicated by the first argument.    
* [0.x.27]*
     Update the fourth derivatives of the transformation from unit to real     cell, the Jacobian hessian gradients.         Skip the computation if possible as indicated by the first argument.    
* [0.x.28]*
     Update the Hessian gradient of the transformation from unit to real     cell, the Jacobian Hessians, pushed forward to the real cell     coordinates.         Skip the computation if possible as indicated by the first argument.    
* [0.x.29]*
     Depending on what information is called for in the update flags of the      [2.x.8]  object, compute the various pieces of information that is     required by the fill_fe_face_values() and fill_fe_subface_values()     functions. This function simply unifies the work that would be done by     those two functions.         The resulting data is put into the  [2.x.9]  argument.    
* [0.x.30]*
     Do the work of  [2.x.10]  and      [2.x.11]  in a generic way,     using the 'data_set' to differentiate whether we will     work on a face (and if so, which one) or subface.    
* [0.x.31]*
     Implementation of  [2.x.12]  for generic tensors.    
* [0.x.32]*
     Implementation of  [2.x.13]  for gradients.    
* [0.x.33]*
     Implementation of  [2.x.14]  for hessians.    
* [0.x.34]*
     Implementation of  [2.x.15]  for DerivativeForm     arguments.    
* [0.x.35]

